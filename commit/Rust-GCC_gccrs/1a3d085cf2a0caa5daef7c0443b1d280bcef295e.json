{"sha": "1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEzZDA4NWNmMmEwY2FhNWRhZWY3YzA0NDNiMWQyODBiY2VmMjk1ZQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-04-17T12:37:16Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-04-17T12:37:16Z"}, "message": "pass current function to opt_pass::gate ()\n\ngcc/\n\t* passes.c (opt_pass::gate): Take function * argument.\n\t(gate_all_early_local_passes): Merge into\n\t(early_local_passes::gate): this.\n\t(gate_all_early_optimizations): Merge into\n\t(all_early_optimizations::gate): this.\n\t(gate_all_optimizations): Mege into\n\t(all_optimizations::gate): this.\n\t(gate_all_optimizations_g): Merge into\n\t(all_optimizations_g::gate): this.\n\t(gate_rest_of_compilation): Mege into\n\t(rest_of_compilation::gate): this.\n\t(gate_postreload): Merge into\n\t(postreload::gate): this.\n\t(dump_one_pass): Pass cfun to the pass's gate method.\n\t(execute_ipa_summary_passes): Likewise.\n\t(execute_one_pass): Likewise.\n\t(ipa_write_summaries_2): Likewise.\n\t(ipa_write_optimization_summaries_1): Likewise.\n\t(ipa_read_summaries_1): Likewise.\n\t(ipa_read_optimization_summaries_1): Likewise.\n\t(execute_ipa_stmt_fixups): Likewise.\n\t* tree-pass.h (opt_pass::gate): Add function * argument.\n\t* asan.c, auto-inc-dec.c, bb-reorder.c, bt-load.c,\n\tcombine-stack-adj.c, combine.c, compare-elim.c,\n\tconfig/epiphany/resolve-sw-modes.c, config/i386/i386.c,\n\tconfig/rl78/rl78.c, config/sh/sh_optimize_sett_clrt.cc,\n\tconfig/sh/sh_treg_combine.cc, config/sparc/sparc.c, cprop.c, cse.c,\n\tdce.c, df-core.c, dse.c, dwarf2cfi.c, except.c,  fwprop.c, gcse.c,\n\tgimple-ssa-isolate-paths.c, gimple-ssa-strength-reduction.c,\n\tgraphite.c, ifcvt.c, init-regs.c, ipa-cp.c, ipa-devirt.c,\n\tipa-profile.c, ipa-pure-const.c, ipa-reference.c, ipa-split.c, ipa.c,\n\tloop-init.c, lower-subreg.c, mode-switching.c, modulo-sched.c,\n\tomp-low.c, postreload-gcse.c, postreload.c, predict.c, recog.c, ree.c,\n\treg-stack.c, regcprop.c, regrename.c, reorg.c, sched-rgn.c,\n\tstore-motion.c, tracer.c, trans-mem.c, tree-call-cdce.c, tree-cfg.c,\n\ttree-cfgcleanup.c, tree-complex.c, tree-eh.c, tree-emutls.c,\n\ttree-if-conv.c, tree-into-ssa.c, tree-loop-distribution.c,\n\ttree-nrv.c, tree-parloops.c, tree-predcom.c, tree-profile.c,\n\ttree-sra.c, tree-ssa-ccp.c, tree-ssa-copy.c, tree-ssa-copyrename.c,\n\ttree-ssa-dce.c, tree-ssa-dom.c, tree-ssa-dse.c, tree-ssa-forwprop.c,\n\ttree-ssa-ifcombine.c, tree-ssa-loop-ch.c, tree-ssa-loop-im.c,\n\ttree-ssa-loop-ivcanon.c, tree-ssa-loop-prefetch.c,\n\ttree-ssa-loop-unswitch.c, tree-ssa-loop.c, tree-ssa-math-opts.c,\n\ttree-ssa-phiopt.c, tree-ssa-phiprop.c, tree-ssa-pre.c,\n\ttree-ssa-reassoc.c, tree-ssa-sink.c, tree-ssa-strlen.c,\n\ttree-ssa-structalias.c, tree-ssa-uncprop.c, tree-ssa-uninit.c,\n\ttree-ssa.c, tree-stdarg.c, tree-switch-conversion.c, tree-tailcall.c,\n\ttree-vect-generic.c, tree-vectorizer.c, tree-vrp.c, tsan.c, ubsan.c,\n\tvar-tracking.c, vtable-verify.c, web.c: Adjust.\n\ngcc/testsuite/\n\t* g++.dg/plugin/dumb_plugin.c, g++.dg/plugin/selfasign.c,\n\tgcc.dg/plugin/one_time_plugin.c, gcc.dg/plugin/selfasign.c: Adjust.\n\nFrom-SVN: r209481", "tree": {"sha": "bd964988c4666a3f7e6173f1abe75d29fc4a771e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd964988c4666a3f7e6173f1abe75d29fc4a771e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/comments", "author": null, "committer": null, "parents": [{"sha": "45887209f8039295836635d191e0ec6d9b05e77d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45887209f8039295836635d191e0ec6d9b05e77d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45887209f8039295836635d191e0ec6d9b05e77d"}], "stats": {"total": 2122, "additions": 774, "deletions": 1348}, "files": [{"sha": "e2ca3289f6f3d4da05946f1657a18cfea8e1b8b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1,3 +1,55 @@\n+2014-04-17  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* passes.c (opt_pass::gate): Take function * argument.\n+\t(gate_all_early_local_passes): Merge into\n+\t(early_local_passes::gate): this.\n+\t(gate_all_early_optimizations): Merge into\n+\t(all_early_optimizations::gate): this.\n+\t(gate_all_optimizations): Mege into\n+\t(all_optimizations::gate): this.\n+\t(gate_all_optimizations_g): Merge into\n+\t(all_optimizations_g::gate): this.\n+\t(gate_rest_of_compilation): Mege into\n+\t(rest_of_compilation::gate): this.\n+\t(gate_postreload): Merge into\n+\t(postreload::gate): this.\n+\t(dump_one_pass): Pass cfun to the pass's gate method.\n+\t(execute_ipa_summary_passes): Likewise.\n+\t(execute_one_pass): Likewise.\n+\t(ipa_write_summaries_2): Likewise.\n+\t(ipa_write_optimization_summaries_1): Likewise.\n+\t(ipa_read_summaries_1): Likewise.\n+\t(ipa_read_optimization_summaries_1): Likewise.\n+\t(execute_ipa_stmt_fixups): Likewise.\n+\t* tree-pass.h (opt_pass::gate): Add function * argument.\n+\t* asan.c, auto-inc-dec.c, bb-reorder.c, bt-load.c,\n+\tcombine-stack-adj.c, combine.c, compare-elim.c,\n+\tconfig/epiphany/resolve-sw-modes.c, config/i386/i386.c,\n+\tconfig/rl78/rl78.c, config/sh/sh_optimize_sett_clrt.cc,\n+\tconfig/sh/sh_treg_combine.cc, config/sparc/sparc.c, cprop.c, cse.c,\n+\tdce.c, df-core.c, dse.c, dwarf2cfi.c, except.c,  fwprop.c, gcse.c,\n+\tgimple-ssa-isolate-paths.c, gimple-ssa-strength-reduction.c,\n+\tgraphite.c, ifcvt.c, init-regs.c, ipa-cp.c, ipa-devirt.c,\n+\tipa-profile.c, ipa-pure-const.c, ipa-reference.c, ipa-split.c, ipa.c,\n+\tloop-init.c, lower-subreg.c, mode-switching.c, modulo-sched.c,\n+\tomp-low.c, postreload-gcse.c, postreload.c, predict.c, recog.c, ree.c,\n+\treg-stack.c, regcprop.c, regrename.c, reorg.c, sched-rgn.c,\n+\tstore-motion.c, tracer.c, trans-mem.c, tree-call-cdce.c, tree-cfg.c,\n+\ttree-cfgcleanup.c, tree-complex.c, tree-eh.c, tree-emutls.c,\n+\ttree-if-conv.c, tree-into-ssa.c, tree-loop-distribution.c,\n+\ttree-nrv.c, tree-parloops.c, tree-predcom.c, tree-profile.c,\n+\ttree-sra.c, tree-ssa-ccp.c, tree-ssa-copy.c, tree-ssa-copyrename.c,\n+\ttree-ssa-dce.c, tree-ssa-dom.c, tree-ssa-dse.c, tree-ssa-forwprop.c,\n+\ttree-ssa-ifcombine.c, tree-ssa-loop-ch.c, tree-ssa-loop-im.c,\n+\ttree-ssa-loop-ivcanon.c, tree-ssa-loop-prefetch.c,\n+\ttree-ssa-loop-unswitch.c, tree-ssa-loop.c, tree-ssa-math-opts.c,\n+\ttree-ssa-phiopt.c, tree-ssa-phiprop.c, tree-ssa-pre.c,\n+\ttree-ssa-reassoc.c, tree-ssa-sink.c, tree-ssa-strlen.c,\n+\ttree-ssa-structalias.c, tree-ssa-uncprop.c, tree-ssa-uninit.c,\n+\ttree-ssa.c, tree-stdarg.c, tree-switch-conversion.c, tree-tailcall.c,\n+\ttree-vect-generic.c, tree-vectorizer.c, tree-vrp.c, tsan.c, ubsan.c,\n+\tvar-tracking.c, vtable-verify.c, web.c: Adjust.\n+\n 2014-04-17  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* configure.ac: Check for -Woverloaded-virtual and enable it if found."}, {"sha": "3fe50ef2a09352c6a32185a1ecb8a2879e2c51bb", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2504,7 +2504,7 @@ class pass_asan : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_asan (m_ctxt); }\n-  bool gate () { return gate_asan (); }\n+  virtual bool gate (function *) { return gate_asan (); }\n   unsigned int execute () { return asan_instrument (); }\n \n }; // class pass_asan\n@@ -2517,12 +2517,6 @@ make_pass_asan (gcc::context *ctxt)\n   return new pass_asan (ctxt);\n }\n \n-static bool\n-gate_asan_O0 (void)\n-{\n-  return !optimize && gate_asan ();\n-}\n-\n namespace {\n \n const pass_data pass_data_asan_O0 =\n@@ -2548,7 +2542,7 @@ class pass_asan_O0 : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_asan_O0 (); }\n+  virtual bool gate (function *) { return !optimize && gate_asan (); }\n   unsigned int execute () { return asan_instrument (); }\n \n }; // class pass_asan_O0\n@@ -2599,12 +2593,6 @@ execute_sanopt (void)\n   return 0;\n }\n \n-static bool\n-gate_sanopt (void)\n-{\n-  return flag_sanitize;\n-}\n-\n namespace {\n \n const pass_data pass_data_sanopt =\n@@ -2630,7 +2618,7 @@ class pass_sanopt : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_sanopt (); }\n+  virtual bool gate (function *) { return flag_sanitize; }\n   unsigned int execute () { return execute_sanopt (); }\n \n }; // class pass_sanopt"}, {"sha": "e1485a3cb2a9aaf01cadc1ae0124dcec37804242", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1495,17 +1495,6 @@ rest_of_handle_auto_inc_dec (void)\n \n /* Discover auto-inc auto-dec instructions.  */\n \n-static bool\n-gate_auto_inc_dec (void)\n-{\n-#ifdef AUTO_INC_DEC\n-  return (optimize > 0 && flag_auto_inc_dec);\n-#else\n-  return false;\n-#endif\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_inc_dec =\n@@ -1530,7 +1519,16 @@ class pass_inc_dec : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_auto_inc_dec (); }\n+  virtual bool gate (function *)\n+    {\n+#ifdef AUTO_INC_DEC\n+      return (optimize > 0 && flag_auto_inc_dec);\n+#else\n+      return false;\n+#endif\n+    }\n+\n+\n   unsigned int execute () { return rest_of_handle_auto_inc_dec (); }\n \n }; // class pass_inc_dec"}, {"sha": "57103bd323a38f5863c3853857f004fdf0fd5399", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2302,15 +2302,6 @@ insert_section_boundary_note (void)\n     }\n }\n \n-static bool\n-gate_handle_reorder_blocks (void)\n-{\n-  if (targetm.cannot_modify_jumps_p ())\n-    return false;\n-  return (optimize > 0\n-\t  && (flag_reorder_blocks || flag_reorder_blocks_and_partition));\n-}\n-\n static unsigned int\n rest_of_handle_reorder_blocks (void)\n {\n@@ -2355,7 +2346,14 @@ class pass_reorder_blocks : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_reorder_blocks (); }\n+  virtual bool gate (function *)\n+    {\n+      if (targetm.cannot_modify_jumps_p ())\n+\treturn false;\n+      return (optimize > 0\n+\t      && (flag_reorder_blocks || flag_reorder_blocks_and_partition));\n+    }\n+\n   unsigned int execute () { return rest_of_handle_reorder_blocks (); }\n \n }; // class pass_reorder_blocks\n@@ -2374,16 +2372,6 @@ make_pass_reorder_blocks (gcc::context *ctxt)\n    which can seriously pessimize code with many computed jumps in the source\n    code, such as interpreters.  See e.g. PR15242.  */\n \n-static bool\n-gate_duplicate_computed_gotos (void)\n-{\n-  if (targetm.cannot_modify_jumps_p ())\n-    return false;\n-  return (optimize > 0\n-\t  && flag_expensive_optimizations\n-\t  && ! optimize_function_for_size_p (cfun));\n-}\n-\n \n static unsigned int\n duplicate_computed_gotos (void)\n@@ -2527,11 +2515,21 @@ class pass_duplicate_computed_gotos : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_duplicate_computed_gotos (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return duplicate_computed_gotos (); }\n \n }; // class pass_duplicate_computed_gotos\n \n+bool\n+pass_duplicate_computed_gotos::gate (function *fun)\n+{\n+  if (targetm.cannot_modify_jumps_p ())\n+    return false;\n+  return (optimize > 0\n+\t  && flag_expensive_optimizations\n+\t  && ! optimize_function_for_size_p (fun));\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -2540,22 +2538,6 @@ make_pass_duplicate_computed_gotos (gcc::context *ctxt)\n   return new pass_duplicate_computed_gotos (ctxt);\n }\n \n-static bool\n-gate_handle_partition_blocks (void)\n-{\n-  /* The optimization to partition hot/cold basic blocks into separate\n-     sections of the .o file does not work well with linkonce or with\n-     user defined section attributes.  Don't call it if either case\n-     arises.  */\n-  return (flag_reorder_blocks_and_partition\n-          && optimize\n-\t  /* See gate_handle_reorder_blocks.  We should not partition if\n-\t     we are going to omit the reordering.  */\n-\t  && optimize_function_for_speed_p (cfun)\n-\t  && !DECL_ONE_ONLY (current_function_decl)\n-\t  && !user_defined_section_attribute);\n-}\n-\n /* This function is the main 'entrance' for the optimization that\n    partitions hot and cold basic blocks into separate sections of the\n    .o file (to improve performance and cache locality).  Ideally it\n@@ -2750,11 +2732,27 @@ class pass_partition_blocks : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_partition_blocks (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return partition_hot_cold_basic_blocks (); }\n \n }; // class pass_partition_blocks\n \n+bool\n+pass_partition_blocks::gate (function *fun)\n+{\n+  /* The optimization to partition hot/cold basic blocks into separate\n+     sections of the .o file does not work well with linkonce or with\n+     user defined section attributes.  Don't call it if either case\n+     arises.  */\n+  return (flag_reorder_blocks_and_partition\n+\t  && optimize\n+\t  /* See gate_handle_reorder_blocks.  We should not partition if\n+\t     we are going to omit the reordering.  */\n+\t  && optimize_function_for_speed_p (fun)\n+\t  && !DECL_ONE_ONLY (current_function_decl)\n+\t  && !user_defined_section_attribute);\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "fc2aea7fd727cd7d54d08a1b020f01d7e6e529b0", "filename": "gcc/bt-load.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1494,12 +1494,6 @@ branch_target_load_optimize (bool after_prologue_epilogue_gen)\n     }\n }\n \f\n-static bool\n-gate_handle_branch_target_load_optimize1 (void)\n-{\n-  return flag_branch_target_load_optimize;\n-}\n-\n \n static unsigned int\n rest_of_handle_branch_target_load_optimize1 (void)\n@@ -1532,7 +1526,7 @@ class pass_branch_target_load_optimize1 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_branch_target_load_optimize1 (); }\n+  virtual bool gate (function *) { return flag_branch_target_load_optimize; }\n   unsigned int execute () {\n     return rest_of_handle_branch_target_load_optimize1 ();\n   }\n@@ -1547,12 +1541,6 @@ make_pass_branch_target_load_optimize1 (gcc::context *ctxt)\n   return new pass_branch_target_load_optimize1 (ctxt);\n }\n \n-static bool\n-gate_handle_branch_target_load_optimize2 (void)\n-{\n-  return (optimize > 0 && flag_branch_target_load_optimize2);\n-}\n-\n \n static unsigned int\n rest_of_handle_branch_target_load_optimize2 (void)\n@@ -1600,7 +1588,11 @@ class pass_branch_target_load_optimize2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_branch_target_load_optimize2 (); }\n+  virtual bool gate (function *)\n+    {\n+      return (optimize > 0 && flag_branch_target_load_optimize2);\n+    }\n+\n   unsigned int execute () {\n     return rest_of_handle_branch_target_load_optimize2 ();\n   }"}, {"sha": "37fc7a5d271dd7d03cd92de784afafedda07dcd9", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -619,21 +619,6 @@ combine_stack_adjustments_for_block (basic_block bb)\n     free_csa_reflist (reflist);\n }\n \f\n-\n-static bool\n-gate_handle_stack_adjustments (void)\n-{\n-  /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n-     even for machines with possibly nonzero TARGET_RETURN_POPS_ARGS\n-     and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n-     push instructions will have popping returns.  */\n-#ifndef PUSH_ROUNDING\n-  if (ACCUMULATE_OUTGOING_ARGS)\n-    return false;\n-#endif\n-  return flag_combine_stack_adjustments;\n-}\n-\n static unsigned int\n rest_of_handle_stack_adjustments (void)\n {\n@@ -667,11 +652,25 @@ class pass_stack_adjustments : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_stack_adjustments (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return rest_of_handle_stack_adjustments (); }\n \n }; // class pass_stack_adjustments\n \n+bool\n+pass_stack_adjustments::gate (function *)\n+{\n+  /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n+     even for machines with possibly nonzero TARGET_RETURN_POPS_ARGS\n+     and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n+     push instructions will have popping returns.  */\n+#ifndef PUSH_ROUNDING\n+  if (ACCUMULATE_OUTGOING_ARGS)\n+    return false;\n+#endif\n+  return flag_combine_stack_adjustments;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "1b1e33c9d08221003c7224b5d42f1c06ae88f7be", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -13854,12 +13854,6 @@ dump_combine_total_stats (FILE *file)\n      total_attempts, total_merges, total_extras, total_successes);\n }\n \f\n-static bool\n-gate_handle_combine (void)\n-{\n-  return (optimize > 0);\n-}\n-\n /* Try combining insns through substitution.  */\n static unsigned int\n rest_of_handle_combine (void)\n@@ -13914,7 +13908,7 @@ class pass_combine : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_combine (); }\n+  virtual bool gate (function *) { return (optimize > 0); }\n   unsigned int execute () { return rest_of_handle_combine (); }\n \n }; // class pass_combine"}, {"sha": "9cddb7a2d35778c36a32b0e515623b1780cfda25", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -643,15 +643,6 @@ execute_compare_elim_after_reload (void)\n   return 0;\n }\n \n-static bool\n-gate_compare_elim_after_reload (void)\n-{\n-  /* Setting this target hook value is how a backend indicates the need.  */\n-  if (targetm.flags_regnum == INVALID_REGNUM)\n-    return false;\n-  return flag_compare_elim_after_reload;\n-}\n-\n namespace {\n \n const pass_data pass_data_compare_elim_after_reload =\n@@ -677,7 +668,14 @@ class pass_compare_elim_after_reload : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_compare_elim_after_reload (); }\n+  virtual bool gate (function *)\n+    {\n+      /* Setting this target hook value is how a backend indicates the need.  */\n+      if (targetm.flags_regnum == INVALID_REGNUM)\n+\treturn false;\n+      return flag_compare_elim_after_reload;\n+    }\n+\n   unsigned int execute () { return execute_compare_elim_after_reload (); }\n \n }; // class pass_compare_elim_after_reload"}, {"sha": "31928fdb0ff8652374917051945dbc90cfd0b818", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -45,12 +45,6 @@ along with GCC; see the file COPYING3.  If not see\n    insert new mode setting insns on the edges where the other mode\n    becomes unambigous.  */\n \n-static bool\n-gate_resolve_sw_modes (void)\n-{\n-  return optimize;\n-}\n-\n static unsigned\n resolve_sw_modes (void)\n {\n@@ -185,7 +179,7 @@ class pass_resolve_sw_modes : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_resolve_sw_modes (); }\n+  virtual bool gate (function *) { return optimize; }\n   unsigned int execute () { return resolve_sw_modes (); }\n \n }; // class pass_resolve_sw_modes"}, {"sha": "10d2fcbea2964c0004d2f3d723319c0937963332", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2494,12 +2494,6 @@ static const struct ptt processor_target_table[PROCESSOR_max] =\n   {\"btver2\", &btver2_cost, 16, 10, 16, 7, 11}\n };\n \f\n-static bool\n-gate_insert_vzeroupper (void)\n-{\n-  return TARGET_AVX && !TARGET_AVX512F && TARGET_VZEROUPPER;\n-}\n-\n static unsigned int\n rest_of_handle_insert_vzeroupper (void)\n {\n@@ -2543,7 +2537,11 @@ class pass_insert_vzeroupper : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_insert_vzeroupper (); }\n+  virtual bool gate (function *)\n+    {\n+      return TARGET_AVX && !TARGET_AVX512F && TARGET_VZEROUPPER;\n+    }\n+\n   unsigned int execute () { return rest_of_handle_insert_vzeroupper (); }\n \n }; // class pass_insert_vzeroupper"}, {"sha": "988e1cd0ac00f2340c51d3adaf0a8aa1b72e311a", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -117,13 +117,6 @@ rl78_init_machine_status (void)\n   return m;\n }\n \n-/* Returns whether to run the devirtualization pass.  */\n-static bool\n-devirt_gate (void)\n-{\n-  return true;\n-}\n-\n /* Runs the devirtualization pass.  */\n static unsigned int\n devirt_pass (void)\n@@ -160,7 +153,6 @@ class pass_rl78_devirt : public rtl_opt_pass\n   }\n \n   /* opt_pass methods: */\n-  bool gate () { return devirt_gate (); }\n   unsigned int execute () { return devirt_pass (); }\n };\n \n@@ -243,7 +235,6 @@ class pass_rl78_move_elim : public rtl_opt_pass\n   }\n \n   /* opt_pass methods: */\n-  bool gate () { return devirt_gate (); }\n   unsigned int execute () { return move_elim_pass (); }\n };\n "}, {"sha": "5b1afcd961bf189e4978ed37dba47b04fd4ebd82", "filename": "gcc/config/sh/sh_optimize_sett_clrt.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -79,7 +79,7 @@ class sh_optimize_sett_clrt : public rtl_opt_pass\n public:\n   sh_optimize_sett_clrt (gcc::context* ctx, const char* name);\n   virtual ~sh_optimize_sett_clrt (void);\n-  virtual bool gate (void);\n+  virtual bool gate (function *);\n   virtual unsigned int execute (void);\n \n private:\n@@ -161,7 +161,7 @@ sh_optimize_sett_clrt::~sh_optimize_sett_clrt (void)\n }\n \n bool\n-sh_optimize_sett_clrt::gate (void)\n+sh_optimize_sett_clrt::gate (function *)\n {\n   return optimize > 0;\n }"}, {"sha": "57eddd29406f34d6dc5fcc592efe36a4597bbc54", "filename": "gcc/config/sh/sh_treg_combine.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -424,7 +424,7 @@ class sh_treg_combine : public rtl_opt_pass\n public:\n   sh_treg_combine (gcc::context* ctx, bool split_insns, const char* name);\n   virtual ~sh_treg_combine (void);\n-  virtual bool gate (void);\n+  virtual bool gate (function *);\n   virtual unsigned int execute (void);\n \n private:\n@@ -1435,7 +1435,7 @@ sh_treg_combine::try_optimize_cbranch (rtx insn)\n }\n \n bool\n-sh_treg_combine::gate (void)\n+sh_treg_combine::gate (function *)\n {\n   return optimize > 0;\n }"}, {"sha": "5578cb8afcb3d16f3f79b93b3d603377cb5140d1", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -871,13 +871,6 @@ mem_ref (rtx x)\n    pass runs as late as possible.  The pass is inserted in the pass pipeline\n    at the end of sparc_option_override.  */\n \n-static bool\n-sparc_gate_work_around_errata (void)\n-{\n-  /* The only errata we handle are those of the AT697F and UT699.  */\n-  return sparc_fix_at697f != 0 || sparc_fix_ut699 != 0;\n-}\n-\n static unsigned int\n sparc_do_work_around_errata (void)\n {\n@@ -1146,7 +1139,12 @@ class pass_work_around_errata : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return sparc_gate_work_around_errata (); }\n+  virtual bool gate (function *)\n+    {\n+      /* The only errata we handle are those of the AT697F and UT699.  */\n+      return sparc_fix_at697f != 0 || sparc_fix_ut699 != 0;\n+    }\n+\n   unsigned int execute () { return sparc_do_work_around_errata (); }\n \n }; // class pass_work_around_errata"}, {"sha": "9802b8a42b5824ab5b3eb58b018cfb2b39109c86", "filename": "gcc/cprop.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1896,14 +1896,6 @@ one_cprop_pass (void)\n    setjmp.\n    FIXME: Should just handle setjmp via REG_SETJMP notes.  */\n \n-static bool\n-gate_rtl_cprop (void)\n-{\n-  return optimize > 0 && flag_gcse\n-    && !cfun->calls_setjmp\n-    && dbg_cnt (cprop);\n-}\n-\n static unsigned int\n execute_rtl_cprop (void)\n {\n@@ -1944,7 +1936,13 @@ class pass_rtl_cprop : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_rtl_cprop (m_ctxt); }\n-  bool gate () { return gate_rtl_cprop (); }\n+  virtual bool gate (function *fun)\n+    {\n+      return optimize > 0 && flag_gcse\n+\t&& !fun->calls_setjmp\n+\t&& dbg_cnt (cprop);\n+    }\n+\n   unsigned int execute () { return execute_rtl_cprop (); }\n \n }; // class pass_rtl_cprop"}, {"sha": "60ec9a99d7523b0b39b43961d58bb04314c3c247", "filename": "gcc/cse.c", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -7457,12 +7457,6 @@ cse_condition_code_reg (void)\n /* Perform common subexpression elimination.  Nonzero value from\n    `cse_main' means that jumps were simplified and some code may now\n    be unreachable, so do jump optimization again.  */\n-static bool\n-gate_handle_cse (void)\n-{\n-  return optimize > 0;\n-}\n-\n static unsigned int\n rest_of_handle_cse (void)\n {\n@@ -7515,7 +7509,7 @@ class pass_cse : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_cse (); }\n+  virtual bool gate (function *) { return optimize > 0; }\n   unsigned int execute () { return rest_of_handle_cse (); }\n \n }; // class pass_cse\n@@ -7529,12 +7523,6 @@ make_pass_cse (gcc::context *ctxt)\n }\n \n \n-static bool\n-gate_handle_cse2 (void)\n-{\n-  return optimize > 0 && flag_rerun_cse_after_loop;\n-}\n-\n /* Run second CSE pass after loop optimizations.  */\n static unsigned int\n rest_of_handle_cse2 (void)\n@@ -7594,7 +7582,11 @@ class pass_cse2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_cse2 (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 0 && flag_rerun_cse_after_loop;\n+    }\n+\n   unsigned int execute () { return rest_of_handle_cse2 (); }\n \n }; // class pass_cse2\n@@ -7607,12 +7599,6 @@ make_pass_cse2 (gcc::context *ctxt)\n   return new pass_cse2 (ctxt);\n }\n \n-static bool\n-gate_handle_cse_after_global_opts (void)\n-{\n-  return optimize > 0 && flag_rerun_cse_after_global_opts;\n-}\n-\n /* Run second CSE pass after loop optimizations.  */\n static unsigned int\n rest_of_handle_cse_after_global_opts (void)\n@@ -7671,7 +7657,11 @@ class pass_cse_after_global_opts : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_cse_after_global_opts (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 0 && flag_rerun_cse_after_global_opts;\n+    }\n+\n   unsigned int execute () {\n     return rest_of_handle_cse_after_global_opts ();\n   }"}, {"sha": "1d290e37ee44ed982d16d8da44fd9f43e26d01e6", "filename": "gcc/dce.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -779,13 +779,6 @@ rest_of_handle_ud_dce (void)\n }\n \n \n-static bool\n-gate_ud_dce (void)\n-{\n-  return optimize > 1 && flag_dce\n-    && dbg_cnt (dce_ud);\n-}\n-\n namespace {\n \n const pass_data pass_data_ud_rtl_dce =\n@@ -810,7 +803,11 @@ class pass_ud_rtl_dce : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ud_dce (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 1 && flag_dce && dbg_cnt (dce_ud);\n+    }\n+\n   unsigned int execute () { return rest_of_handle_ud_dce (); }\n \n }; // class pass_ud_rtl_dce\n@@ -1211,13 +1208,6 @@ run_fast_dce (void)\n }\n \n \n-static bool\n-gate_fast_dce (void)\n-{\n-  return optimize > 0 && flag_dce\n-    && dbg_cnt (dce_fast);\n-}\n-\n namespace {\n \n const pass_data pass_data_fast_rtl_dce =\n@@ -1242,7 +1232,11 @@ class pass_fast_rtl_dce : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_fast_dce (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 0 && flag_dce && dbg_cnt (dce_fast);\n+    }\n+\n   unsigned int execute () { return rest_of_handle_fast_dce (); }\n \n }; // class pass_fast_rtl_dce"}, {"sha": "bd3cb31ebd92541065bc00725adb8e294b2e1a29", "filename": "gcc/df-core.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -740,13 +740,6 @@ rest_of_handle_df_initialize (void)\n }\n \n \n-static bool\n-gate_opt (void)\n-{\n-  return optimize > 0;\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_df_initialize_opt =\n@@ -771,7 +764,7 @@ class pass_df_initialize_opt : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_opt (); }\n+  virtual bool gate (function *) { return optimize > 0; }\n   unsigned int execute () { return rest_of_handle_df_initialize (); }\n \n }; // class pass_df_initialize_opt\n@@ -785,13 +778,6 @@ make_pass_df_initialize_opt (gcc::context *ctxt)\n }\n \n \n-static bool\n-gate_no_opt (void)\n-{\n-  return optimize == 0;\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_df_initialize_no_opt =\n@@ -816,7 +802,7 @@ class pass_df_initialize_no_opt : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_no_opt (); }\n+  virtual bool gate (function *) { return optimize == 0; }\n   unsigned int execute () { return rest_of_handle_df_initialize (); }\n \n }; // class pass_df_initialize_no_opt"}, {"sha": "a80c0259b38a9808d2527a8d7c7fa99a36bea2d3", "filename": "gcc/dse.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -608,11 +608,6 @@ static bitmap kill_on_calls;\n \n /* The number of bits used in the global bitmaps.  */\n static unsigned int current_position;\n-\n-\n-static bool gate_dse1 (void);\n-static bool gate_dse2 (void);\n-\n \f\n /*----------------------------------------------------------------------------\n    Zeroth step.\n@@ -3712,20 +3707,6 @@ rest_of_handle_dse (void)\n   return 0;\n }\n \n-static bool\n-gate_dse1 (void)\n-{\n-  return optimize > 0 && flag_dse\n-    && dbg_cnt (dse1);\n-}\n-\n-static bool\n-gate_dse2 (void)\n-{\n-  return optimize > 0 && flag_dse\n-    && dbg_cnt (dse2);\n-}\n-\n namespace {\n \n const pass_data pass_data_rtl_dse1 =\n@@ -3750,7 +3731,11 @@ class pass_rtl_dse1 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_dse1 (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 0 && flag_dse && dbg_cnt (dse1);\n+    }\n+\n   unsigned int execute () { return rest_of_handle_dse (); }\n \n }; // class pass_rtl_dse1\n@@ -3787,7 +3772,11 @@ class pass_rtl_dse2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_dse2 (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 0 && flag_dse && dbg_cnt (dse2);\n+    }\n+\n   unsigned int execute () { return rest_of_handle_dse (); }\n \n }; // class pass_rtl_dse2"}, {"sha": "37492776ca068a1ba1dfd3aec76905fb8795121d", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3377,21 +3377,6 @@ dwarf2out_do_cfi_asm (void)\n   return true;\n }\n \n-static bool\n-gate_dwarf2_frame (void)\n-{\n-#ifndef HAVE_prologue\n-  /* Targets which still implement the prologue in assembler text\n-     cannot use the generic dwarf2 unwinding.  */\n-  return false;\n-#endif\n-\n-  /* ??? What to do for UI_TARGET unwinding?  They might be able to benefit\n-     from the optimized shrink-wrapping annotations that we will compute.\n-     For now, only produce the CFI notes for dwarf2.  */\n-  return dwarf2out_do_frame ();\n-}\n-\n namespace {\n \n const pass_data pass_data_dwarf2_frame =\n@@ -3416,11 +3401,26 @@ class pass_dwarf2_frame : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_dwarf2_frame (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return execute_dwarf2_frame (); }\n \n }; // class pass_dwarf2_frame\n \n+bool\n+pass_dwarf2_frame::gate (function *)\n+{\n+#ifndef HAVE_prologue\n+  /* Targets which still implement the prologue in assembler text\n+     cannot use the generic dwarf2 unwinding.  */\n+  return false;\n+#endif\n+\n+  /* ??? What to do for UI_TARGET unwinding?  They might be able to benefit\n+     from the optimized shrink-wrapping annotations that we will compute.\n+     For now, only produce the CFI notes for dwarf2.  */\n+  return dwarf2out_do_frame ();\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "2015809f4db7542f93818159986627797f2779a5", "filename": "gcc/except.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2620,17 +2620,6 @@ convert_to_eh_region_ranges (void)\n   return 0;\n }\n \n-static bool\n-gate_convert_to_eh_region_ranges (void)\n-{\n-  /* Nothing to do for SJLJ exceptions or if no regions created.  */\n-  if (cfun->eh->region_tree == NULL)\n-    return false;\n-  if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)\n-    return false;\n-  return true;\n-}\n-\n namespace {\n \n const pass_data pass_data_convert_to_eh_region_ranges =\n@@ -2655,11 +2644,22 @@ class pass_convert_to_eh_region_ranges : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_convert_to_eh_region_ranges (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return convert_to_eh_region_ranges (); }\n \n }; // class pass_convert_to_eh_region_ranges\n \n+bool\n+pass_convert_to_eh_region_ranges::gate (function *)\n+{\n+  /* Nothing to do for SJLJ exceptions or if no regions created.  */\n+  if (cfun->eh->region_tree == NULL)\n+    return false;\n+  if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)\n+    return false;\n+  return true;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "c6fa4ee22d0c2bd2466138b32816528646875b30", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1508,7 +1508,7 @@ class pass_rtl_fwprop : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_fwprop (); }\n+  virtual bool gate (function *) { return gate_fwprop (); }\n   unsigned int execute () { return fwprop (); }\n \n }; // class pass_rtl_fwprop\n@@ -1573,7 +1573,7 @@ class pass_rtl_fwprop_addr : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_fwprop (); }\n+  virtual bool gate (function *) { return gate_fwprop (); }\n   unsigned int execute () { return fwprop_addr (); }\n \n }; // class pass_rtl_fwprop_addr"}, {"sha": "942ea64325f85a1b9519c00766fa6af1c9890b48", "filename": "gcc/gcse.c", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -4157,24 +4157,6 @@ is_too_expensive (const char *pass)\n   return false;\n }\n \f\n-/* All the passes implemented in this file.  Each pass has its\n-   own gate and execute function, and at the end of the file a\n-   pass definition for passes.c.\n-\n-   We do not construct an accurate cfg in functions which call\n-   setjmp, so none of these passes runs if the function calls\n-   setjmp.\n-   FIXME: Should just handle setjmp via REG_SETJMP notes.  */\n-\n-static bool\n-gate_rtl_pre (void)\n-{\n-  return optimize > 0 && flag_gcse\n-    && !cfun->calls_setjmp\n-    && optimize_function_for_speed_p (cfun)\n-    && dbg_cnt (pre);\n-}\n-\n static unsigned int\n execute_rtl_pre (void)\n {\n@@ -4188,18 +4170,6 @@ execute_rtl_pre (void)\n   return 0;\n }\n \n-static bool\n-gate_rtl_hoist (void)\n-{\n-  return optimize > 0 && flag_gcse\n-    && !cfun->calls_setjmp\n-    /* It does not make sense to run code hoisting unless we are optimizing\n-       for code size -- it rarely makes programs faster, and can make then\n-       bigger if we did PRE (when optimizing for space, we don't run PRE).  */\n-    && optimize_function_for_size_p (cfun)\n-    && dbg_cnt (hoist);\n-}\n-\n static unsigned int\n execute_rtl_hoist (void)\n {\n@@ -4238,11 +4208,25 @@ class pass_rtl_pre : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rtl_pre (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return execute_rtl_pre (); }\n \n }; // class pass_rtl_pre\n \n+/* We do not construct an accurate cfg in functions which call\n+   setjmp, so none of these passes runs if the function calls\n+   setjmp.\n+   FIXME: Should just handle setjmp via REG_SETJMP notes.  */\n+\n+bool\n+pass_rtl_pre::gate (function *fun)\n+{\n+  return optimize > 0 && flag_gcse\n+    && !fun->calls_setjmp\n+    && optimize_function_for_speed_p (fun)\n+    && dbg_cnt (pre);\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -4276,11 +4260,23 @@ class pass_rtl_hoist : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rtl_hoist (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return execute_rtl_hoist (); }\n \n }; // class pass_rtl_hoist\n \n+bool\n+pass_rtl_hoist::gate (function *)\n+{\n+  return optimize > 0 && flag_gcse\n+    && !cfun->calls_setjmp\n+    /* It does not make sense to run code hoisting unless we are optimizing\n+       for code size -- it rarely makes programs faster, and can make then\n+       bigger if we did PRE (when optimizing for space, we don't run PRE).  */\n+    && optimize_function_for_size_p (cfun)\n+    && dbg_cnt (hoist);\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "ab6185c276763246af51d88460fd1c95c01e1993", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -414,15 +414,6 @@ gimple_ssa_isolate_erroneous_paths (void)\n   return 0;\n }\n \n-static bool\n-gate_isolate_erroneous_paths (void)\n-{\n-  /* If we do not have a suitable builtin function for the trap statement,\n-     then do not perform the optimization.  */\n-  return (flag_isolate_erroneous_paths_dereference != 0\n-\t  || flag_isolate_erroneous_paths_attribute != 0);\n-}\n-\n namespace {\n const pass_data pass_data_isolate_erroneous_paths =\n {\n@@ -447,7 +438,14 @@ class pass_isolate_erroneous_paths : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_isolate_erroneous_paths (m_ctxt); }\n-  bool gate () { return gate_isolate_erroneous_paths (); }\n+  virtual bool gate (function *)\n+    {\n+      /* If we do not have a suitable builtin function for the trap statement,\n+\t then do not perform the optimization.  */\n+      return (flag_isolate_erroneous_paths_dereference != 0\n+\t      || flag_isolate_erroneous_paths_attribute != 0);\n+    }\n+\n   unsigned int execute () { return gimple_ssa_isolate_erroneous_paths (); }\n \n }; // class pass_isolate_erroneous_paths"}, {"sha": "a8596e0529baf6f6dab2c7c11ebf81b72510e9c4", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3646,12 +3646,6 @@ execute_strength_reduction (void)\n   return 0;\n }\n \n-static bool\n-gate_strength_reduction (void)\n-{\n-  return flag_tree_slsr;\n-}\n-\n namespace {\n \n const pass_data pass_data_strength_reduction =\n@@ -3676,7 +3670,7 @@ class pass_strength_reduction : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_strength_reduction (); }\n+  virtual bool gate (function *) { return flag_tree_slsr; }\n   unsigned int execute () { return execute_strength_reduction (); }\n \n }; // class pass_strength_reduction"}, {"sha": "68c93904fd90c5d27e0de1a8c3af69cd5f6681b6", "filename": "gcc/graphite.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -374,7 +374,7 @@ class pass_graphite : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_graphite_transforms (); }\n+  virtual bool gate (function *) { return gate_graphite_transforms (); }\n \n }; // class pass_graphite\n \n@@ -410,7 +410,7 @@ class pass_graphite_transforms : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_graphite_transforms (); }\n+  virtual bool gate (function *) { return gate_graphite_transforms (); }\n   unsigned int execute () { return graphite_transforms (); }\n \n }; // class pass_graphite_transforms"}, {"sha": "657b585a07acfa0a59073dc409a6d9497580ac43", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -4512,13 +4512,6 @@ if_convert (bool after_combine)\n #endif\n }\n \f\n-static bool\n-gate_handle_if_conversion (void)\n-{\n-  return (optimize > 0)\n-    && dbg_cnt (if_conversion);\n-}\n-\n /* If-conversion and CFG cleanup.  */\n static unsigned int\n rest_of_handle_if_conversion (void)\n@@ -4562,7 +4555,11 @@ class pass_rtl_ifcvt : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_if_conversion (); }\n+  virtual bool gate (function *)\n+    {\n+      return (optimize > 0) && dbg_cnt (if_conversion);\n+    }\n+\n   unsigned int execute () { return rest_of_handle_if_conversion (); }\n \n }; // class pass_rtl_ifcvt\n@@ -4575,13 +4572,6 @@ make_pass_rtl_ifcvt (gcc::context *ctxt)\n   return new pass_rtl_ifcvt (ctxt);\n }\n \n-static bool\n-gate_handle_if_after_combine (void)\n-{\n-  return optimize > 0 && flag_if_conversion\n-    && dbg_cnt (if_after_combine);\n-}\n-\n \n /* Rerun if-conversion, as combine may have simplified things enough\n    to now meet sequence length restrictions.  */\n@@ -4616,7 +4606,12 @@ class pass_if_after_combine : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_if_after_combine (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 0 && flag_if_conversion\n+\t&& dbg_cnt (if_after_combine);\n+    }\n+\n   unsigned int execute () { return rest_of_handle_if_after_combine (); }\n \n }; // class pass_if_after_combine\n@@ -4630,13 +4625,6 @@ make_pass_if_after_combine (gcc::context *ctxt)\n }\n \n \n-static bool\n-gate_handle_if_after_reload (void)\n-{\n-  return optimize > 0 && flag_if_conversion2\n-    && dbg_cnt (if_after_reload);\n-}\n-\n static unsigned int\n rest_of_handle_if_after_reload (void)\n {\n@@ -4669,7 +4657,12 @@ class pass_if_after_reload : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_if_after_reload (); }\n+  virtual bool gate (function *)\n+    {\n+      return optimize > 0 && flag_if_conversion2\n+\t&& dbg_cnt (if_after_reload);\n+    }\n+\n   unsigned int execute () { return rest_of_handle_if_after_reload (); }\n \n }; // class pass_if_after_reload"}, {"sha": "2025b777897bba70551dc8df598558d1c4ed94df", "filename": "gcc/init-regs.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -125,12 +125,6 @@ initialize_uninitialized_regs (void)\n   BITMAP_FREE (already_genned);\n }\n \n-static bool\n-gate_initialize_regs (void)\n-{\n-  return optimize > 0;\n-}\n-\n static unsigned int\n rest_of_handle_initialize_regs (void)\n {\n@@ -162,7 +156,7 @@ class pass_initialize_regs : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_initialize_regs (); }\n+  virtual bool gate (function *) { return optimize > 0; }\n   unsigned int execute () { return rest_of_handle_initialize_regs (); }\n \n }; // class pass_initialize_regs"}, {"sha": "ee48fc095ad53ea6462fe64421dd957b4680f1fb", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3762,16 +3762,6 @@ ipcp_read_summary (void)\n   ipa_prop_read_jump_functions ();\n }\n \n-/* Gate for IPCP optimization.  */\n-\n-static bool\n-cgraph_gate_cp (void)\n-{\n-  /* FIXME: We should remove the optimize check after we ensure we never run\n-     IPA passes when not optimizing.  */\n-  return flag_ipa_cp && optimize;\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_cp =\n@@ -3807,7 +3797,13 @@ class pass_ipa_cp : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return cgraph_gate_cp (); }\n+  virtual bool gate (function *)\n+    {\n+      /* FIXME: We should remove the optimize check after we ensure we never run\n+\t IPA passes when not optimizing.  */\n+      return flag_ipa_cp && optimize;\n+    }\n+\n   unsigned int execute () { return ipcp_driver (); }\n \n }; // class pass_ipa_cp"}, {"sha": "ee8091c21464ad63886fca3b9a2b898c99867622", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2096,16 +2096,6 @@ ipa_devirt (void)\n   return ndevirtualized ? TODO_remove_functions : 0;\n }\n \n-/* Gate for speculative IPA devirtualization optimization.  */\n-\n-static bool\n-gate_ipa_devirt (void)\n-{\n-  return (flag_devirtualize\n-\t  && flag_devirtualize_speculatively\n-\t  && optimize);\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_devirt =\n@@ -2139,7 +2129,13 @@ class pass_ipa_devirt : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ipa_devirt (); }\n+  virtual bool gate (function *)\n+    {\n+      return (flag_devirtualize\n+\t      && flag_devirtualize_speculatively\n+\t      && optimize);\n+    }\n+\n   unsigned int execute () { return ipa_devirt (); }\n \n }; // class pass_ipa_devirt"}, {"sha": "7b58716c45b04cf55ae162862a44610f7eacc586", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -711,12 +711,6 @@ ipa_profile (void)\n   return 0;\n }\n \n-static bool\n-gate_ipa_profile (void)\n-{\n-  return flag_ipa_profile;\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_profile =\n@@ -750,7 +744,7 @@ class pass_ipa_profile : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ipa_profile (); }\n+  virtual bool gate (function *) { return flag_ipa_profile; }\n   unsigned int execute () { return ipa_profile (); }\n \n }; // class pass_ipa_profile"}, {"sha": "eab7633b1de7911e8ae3d17ada8e5e1f84e0cf86", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1541,7 +1541,7 @@ class pass_ipa_pure_const : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_pure_const (); }\n+  virtual bool gate (function *) { return gate_pure_const (); }\n   unsigned int execute () { return propagate (); }\n \n }; // class pass_ipa_pure_const\n@@ -1716,7 +1716,7 @@ class pass_local_pure_const : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_local_pure_const (m_ctxt); }\n-  bool gate () { return gate_pure_const (); }\n+  virtual bool gate (function *) { return gate_pure_const (); }\n   unsigned int execute () { return local_pure_const (); }\n \n }; // class pass_local_pure_const\n@@ -1740,12 +1740,6 @@ execute_warn_function_noreturn (void)\n   return 0;\n }\n \n-static bool\n-gate_warn_function_noreturn (void)\n-{\n-  return warn_suggest_attribute_noreturn;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_function_noreturn =\n@@ -1770,7 +1764,7 @@ class pass_warn_function_noreturn : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_warn_function_noreturn (); }\n+  virtual bool gate (function *) { return warn_suggest_attribute_noreturn; }\n   unsigned int execute () { return execute_warn_function_noreturn (); }\n \n }; // class pass_warn_function_noreturn"}, {"sha": "51a57ac8d759759e602c987696dd27810548e801", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1148,14 +1148,6 @@ ipa_reference_read_optimization_summary (void)\n     }\n }\n \n-static bool\n-gate_reference (void)\n-{\n-  return (flag_ipa_reference\n-\t  /* Don't bother doing anything if the program has errors.  */\n-\t  && !seen_error ());\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_reference =\n@@ -1191,7 +1183,13 @@ class pass_ipa_reference : public ipa_opt_pass_d\n     {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_reference (); }\n+  virtual bool gate (function *)\n+    {\n+      return (flag_ipa_reference\n+\t      /* Don't bother doing anything if the program has errors.  */\n+\t      && !seen_error ());\n+    }\n+\n   unsigned int execute () { return propagate (); }\n \n }; // class pass_ipa_reference"}, {"sha": "187dc988489b7e44d54694484a0c16a08f1cbcc3", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1646,17 +1646,6 @@ execute_split_functions (void)\n   return todo;\n }\n \n-/* Gate function splitting pass.  When doing profile feedback, we want\n-   to execute the pass after profiling is read.  So disable one in \n-   early optimization.  */\n-\n-static bool\n-gate_split_functions (void)\n-{\n-  return (flag_partial_inlining\n-\t  && !profile_arc_flag && !flag_branch_probabilities);\n-}\n-\n namespace {\n \n const pass_data pass_data_split_functions =\n@@ -1681,11 +1670,20 @@ class pass_split_functions : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_split_functions (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return execute_split_functions (); }\n \n }; // class pass_split_functions\n \n+bool\n+pass_split_functions::gate (function *)\n+{\n+  /* When doing profile feedback, we want to execute the pass after profiling\n+     is read.  So disable one in early optimization.  */\n+  return (flag_partial_inlining\n+\t  && !profile_arc_flag && !flag_branch_probabilities);\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -1694,17 +1692,6 @@ make_pass_split_functions (gcc::context *ctxt)\n   return new pass_split_functions (ctxt);\n }\n \n-/* Gate feedback driven function splitting pass.\n-   We don't need to split when profiling at all, we are producing\n-   lousy code anyway.  */\n-\n-static bool\n-gate_feedback_split_functions (void)\n-{\n-  return (flag_partial_inlining\n-\t  && flag_branch_probabilities);\n-}\n-\n /* Execute function splitting pass.  */\n \n static unsigned int\n@@ -1740,11 +1727,20 @@ class pass_feedback_split_functions : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_feedback_split_functions (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return execute_feedback_split_functions (); }\n \n }; // class pass_feedback_split_functions\n \n+bool\n+pass_feedback_split_functions::gate (function *)\n+{\n+  /* We don't need to split when profiling at all, we are producing\n+     lousy code anyway.  */\n+  return (flag_partial_inlining\n+\t  && flag_branch_probabilities);\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "e14f0c42eb2f003dd3d525391c30292c637753ff", "filename": "gcc/ipa.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1283,14 +1283,6 @@ make_pass_ipa_free_inline_summary (gcc::context *ctxt)\n   return new pass_ipa_free_inline_summary (ctxt);\n }\n \n-/* Do not re-run on ltrans stage.  */\n-\n-static bool\n-gate_whole_program_function_and_variable_visibility (void)\n-{\n-  return !flag_ltrans;\n-}\n-\n /* Bring functionss local at LTO time with -fwhole-program.  */\n \n static unsigned int\n@@ -1335,9 +1327,12 @@ class pass_ipa_whole_program_visibility : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () {\n-    return gate_whole_program_function_and_variable_visibility ();\n-  }\n+\n+  virtual bool gate (function *)\n+    {\n+      /* Do not re-run on ltrans stage.  */\n+      return !flag_ltrans;\n+    }\n   unsigned int execute () {\n     return whole_program_function_and_variable_visibility ();\n   }\n@@ -1624,16 +1619,6 @@ ipa_cdtor_merge (void)\n   return 0;\n }\n \n-/* Perform the pass when we have no ctors/dtors support\n-   or at LTO time to merge multiple constructors into single\n-   function.  */\n-\n-static bool\n-gate_ipa_cdtor_merge (void)\n-{\n-  return !targetm.have_ctors_dtors || (optimize && in_lto_p);\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_cdtor_merge =\n@@ -1667,11 +1652,20 @@ class pass_ipa_cdtor_merge : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ipa_cdtor_merge (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return ipa_cdtor_merge (); }\n \n }; // class pass_ipa_cdtor_merge\n \n+bool\n+pass_ipa_cdtor_merge::gate (function *)\n+{\n+  /* Perform the pass when we have no ctors/dtors support\n+     or at LTO time to merge multiple constructors into single\n+     function.  */\n+  return !targetm.have_ctors_dtors || (optimize && in_lto_p);\n+}\n+\n } // anon namespace\n \n ipa_opt_pass_d *"}, {"sha": "6da29d3c0f15ef80fe5c8fd1bc79b4ec147e9366", "filename": "gcc/loop-init.c", "status": "modified", "additions": 44, "deletions": 61, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -287,31 +287,8 @@ fix_loop_structure (bitmap changed_bbs)\n   return number_of_loops (cfun) - old_nloops;\n }\n \f\n-/* Gate for the RTL loop superpass.  The actual passes are subpasses.\n-   See passes.c for more on that.  */\n-\n-static bool\n-gate_handle_loop2 (void)\n-{\n-  if (optimize > 0\n-      && (flag_move_loop_invariants\n-\t  || flag_unswitch_loops\n-\t  || flag_peel_loops\n-\t  || flag_unroll_loops\n-#ifdef HAVE_doloop_end\n-\t  || (flag_branch_on_count_reg && HAVE_doloop_end)\n-#endif\n-\t ))\n-    return true;\n-  else\n-    {\n-      /* No longer preserve loops, remove them now.  */\n-      cfun->curr_properties &= ~PROP_loops;\n-      if (current_loops)\n-\tloop_optimizer_finalize ();\n-      return false;\n-    } \n-}\n+/* The RTL loop superpass.  The actual passes are subpasses.  See passes.c for\n+   more on that.  */\n \n namespace {\n \n@@ -337,10 +314,33 @@ class pass_loop2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_loop2 (); }\n+  virtual bool gate (function *);\n \n }; // class pass_loop2\n \n+bool\n+pass_loop2::gate (function *fun)\n+{\n+  if (optimize > 0\n+      && (flag_move_loop_invariants\n+\t  || flag_unswitch_loops\n+\t  || flag_peel_loops\n+\t  || flag_unroll_loops\n+#ifdef HAVE_doloop_end\n+\t  || (flag_branch_on_count_reg && HAVE_doloop_end)\n+#endif\n+      ))\n+    return true;\n+  else\n+    {\n+      /* No longer preserve loops, remove them now.  */\n+      fun->curr_properties &= ~PROP_loops;\n+      if (current_loops)\n+\tloop_optimizer_finalize ();\n+      return false;\n+    } \n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -461,12 +461,6 @@ make_pass_rtl_loop_done (gcc::context *ctxt)\n \n \f\n /* Loop invariant code motion.  */\n-static bool\n-gate_rtl_move_loop_invariants (void)\n-{\n-  return flag_move_loop_invariants;\n-}\n-\n static unsigned int\n rtl_move_loop_invariants (void)\n {\n@@ -500,7 +494,7 @@ class pass_rtl_move_loop_invariants : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rtl_move_loop_invariants (); }\n+  virtual bool gate (function *) { return flag_move_loop_invariants; }\n   unsigned int execute () { return rtl_move_loop_invariants (); }\n \n }; // class pass_rtl_move_loop_invariants\n@@ -514,13 +508,6 @@ make_pass_rtl_move_loop_invariants (gcc::context *ctxt)\n }\n \n \f\n-/* Loop unswitching for RTL.  */\n-static bool\n-gate_rtl_unswitch (void)\n-{\n-  return flag_unswitch_loops;\n-}\n-\n static unsigned int\n rtl_unswitch (void)\n {\n@@ -553,7 +540,7 @@ class pass_rtl_unswitch : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rtl_unswitch (); }\n+  virtual bool gate (function *) { return flag_unswitch_loops; }\n   unsigned int execute () { return rtl_unswitch (); }\n \n }; // class pass_rtl_unswitch\n@@ -567,13 +554,6 @@ make_pass_rtl_unswitch (gcc::context *ctxt)\n }\n \n \f\n-/* Loop unswitching for RTL.  */\n-static bool\n-gate_rtl_unroll_and_peel_loops (void)\n-{\n-  return (flag_peel_loops || flag_unroll_loops || flag_unroll_all_loops);\n-}\n-\n static unsigned int\n rtl_unroll_and_peel_loops (void)\n {\n@@ -619,7 +599,11 @@ class pass_rtl_unroll_and_peel_loops : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rtl_unroll_and_peel_loops (); }\n+  virtual bool gate (function *)\n+    {\n+      return (flag_peel_loops || flag_unroll_loops || flag_unroll_all_loops);\n+    }\n+\n   unsigned int execute () { return rtl_unroll_and_peel_loops (); }\n \n }; // class pass_rtl_unroll_and_peel_loops\n@@ -633,17 +617,6 @@ make_pass_rtl_unroll_and_peel_loops (gcc::context *ctxt)\n }\n \n \f\n-/* The doloop optimization.  */\n-static bool\n-gate_rtl_doloop (void)\n-{\n-#ifdef HAVE_doloop_end\n-  return (flag_branch_on_count_reg && HAVE_doloop_end);\n-#else\n-  return 0;\n-#endif\n-}\n-\n static unsigned int\n rtl_doloop (void)\n {\n@@ -678,11 +651,21 @@ class pass_rtl_doloop : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rtl_doloop (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return rtl_doloop (); }\n \n }; // class pass_rtl_doloop\n \n+bool\n+pass_rtl_doloop::gate (function *)\n+{\n+#ifdef HAVE_doloop_end\n+  return (flag_branch_on_count_reg && HAVE_doloop_end);\n+#else\n+  return false;\n+#endif\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "89d976390a5639552d45ae390996df5e1ff1f422", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1687,14 +1687,6 @@ decompose_multiword_subregs (bool decompose_copies)\n   BITMAP_FREE (subreg_context);\n }\n \f\n-/* Gate function for lower subreg pass.  */\n-\n-static bool\n-gate_handle_lower_subreg (void)\n-{\n-  return flag_split_wide_types != 0;\n-}\n-\n /* Implement first lower subreg pass.  */\n \n static unsigned int\n@@ -1737,7 +1729,7 @@ class pass_lower_subreg : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_lower_subreg (); }\n+  virtual bool gate (function *) { return flag_split_wide_types != 0; }\n   unsigned int execute () { return rest_of_handle_lower_subreg (); }\n \n }; // class pass_lower_subreg\n@@ -1775,7 +1767,7 @@ class pass_lower_subreg2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_lower_subreg (); }\n+  virtual bool gate (function *) { return flag_split_wide_types != 0; }\n   unsigned int execute () { return rest_of_handle_lower_subreg2 (); }\n \n }; // class pass_lower_subreg2"}, {"sha": "e73d6ee3a9373992a3003fad7939ae61d38b03ab", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -789,16 +789,6 @@ optimize_mode_switching (void)\n \n #endif /* OPTIMIZE_MODE_SWITCHING */\n \f\n-static bool\n-gate_mode_switching (void)\n-{\n-#ifdef OPTIMIZE_MODE_SWITCHING\n-  return true;\n-#else\n-  return false;\n-#endif\n-}\n-\n static unsigned int\n rest_of_handle_mode_switching (void)\n {\n@@ -836,7 +826,15 @@ class pass_mode_switching : public rtl_opt_pass\n   /* The epiphany backend creates a second instance of this pass, so we need\n      a clone method.  */\n   opt_pass * clone () { return new pass_mode_switching (m_ctxt); }\n-  bool gate () { return gate_mode_switching (); }\n+  virtual bool gate (function *)\n+    {\n+#ifdef OPTIMIZE_MODE_SWITCHING\n+      return true;\n+#else\n+      return false;\n+#endif\n+    }\n+\n   unsigned int execute () { return rest_of_handle_mode_switching (); }\n \n }; // class pass_mode_switching"}, {"sha": "20e2e623e684ea3fa7d6e04492dfd9f6aafe5872", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3323,13 +3323,6 @@ rotate_partial_schedule (partial_schedule_ptr ps, int start_cycle)\n \n #endif /* INSN_SCHEDULING */\n \f\n-static bool\n-gate_handle_sms (void)\n-{\n-  return (optimize > 0 && flag_modulo_sched);\n-}\n-\n-\n /* Run instruction scheduler.  */\n /* Perform SMS module scheduling.  */\n static unsigned int\n@@ -3380,7 +3373,11 @@ class pass_sms : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_sms (); }\n+  virtual bool gate (function *)\n+{\n+  return (optimize > 0 && flag_modulo_sched);\n+}\n+\n   unsigned int execute () { return rest_of_handle_sms (); }\n \n }; // class pass_sms"}, {"sha": "0e96b881d77aa0e6681c0050888d4b948e4d1250", "filename": "gcc/omp-low.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -8326,13 +8326,6 @@ execute_expand_omp (void)\n \n /* OMP expansion -- the default pass, run before creation of SSA form.  */\n \n-static bool\n-gate_expand_omp (void)\n-{\n-  return ((flag_openmp != 0 || flag_openmp_simd != 0\n-\t   || flag_cilkplus != 0) && !seen_error ());\n-}\n-\n namespace {\n \n const pass_data pass_data_expand_omp =\n@@ -8357,7 +8350,12 @@ class pass_expand_omp : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_expand_omp (); }\n+  virtual bool gate (function *)\n+    {\n+      return ((flag_openmp != 0 || flag_openmp_simd != 0\n+\t       || flag_cilkplus != 0) && !seen_error ());\n+    }\n+\n   unsigned int execute () { return execute_expand_omp (); }\n \n }; // class pass_expand_omp\n@@ -10617,12 +10615,6 @@ diagnose_omp_structured_block_errors (void)\n   return 0;\n }\n \n-static bool\n-gate_diagnose_omp_blocks (void)\n-{\n-  return flag_openmp || flag_cilkplus;\n-}\n-\n namespace {\n \n const pass_data pass_data_diagnose_omp_blocks =\n@@ -10647,7 +10639,7 @@ class pass_diagnose_omp_blocks : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_diagnose_omp_blocks (); }\n+  virtual bool gate (function *) { return flag_openmp || flag_cilkplus; }\n   unsigned int execute () {\n     return diagnose_omp_structured_block_errors ();\n   }\n@@ -11811,13 +11803,19 @@ class pass_omp_simd_clone : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return ((flag_openmp || flag_openmp_simd\n-\t\t\t  || flag_cilkplus || (in_lto_p && !flag_wpa))\n-\t\t\t && (targetm.simd_clone.compute_vecsize_and_simdlen\n-\t\t\t     != NULL)); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return ipa_omp_simd_clone (); }\n };\n \n+bool\n+pass_omp_simd_clone::gate (function *)\n+{\n+  return ((flag_openmp || flag_openmp_simd\n+\t   || flag_cilkplus\n+\t   || (in_lto_p && !flag_wpa))\n+\t  && (targetm.simd_clone.compute_vecsize_and_simdlen != NULL));\n+}\n+\n } // anon namespace\n \n simple_ipa_opt_pass *"}, {"sha": "b71c11e3e3160ff81ca2f5f7f207dbc805e50e9d", "filename": "gcc/passes.c", "status": "modified", "additions": 30, "deletions": 64, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -108,7 +108,7 @@ opt_pass::clone ()\n }\n \n bool\n-opt_pass::gate ()\n+opt_pass::gate (function *)\n {\n   return true;\n }\n@@ -337,15 +337,6 @@ execute_all_early_local_passes (void)\n   return 0;\n }\n \n-/* Gate: execute, or not, all of the non-trivial optimizations.  */\n-\n-static bool\n-gate_all_early_local_passes (void)\n-{\n-\t  /* Don't bother doing anything if the program has errors.  */\n-  return (!seen_error () && !in_lto_p);\n-}\n-\n namespace {\n \n const pass_data pass_data_early_local_passes =\n@@ -370,7 +361,12 @@ class pass_early_local_passes : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_all_early_local_passes (); }\n+  virtual bool gate (function *)\n+    {\n+      /* Don't bother doing anything if the program has errors.  */\n+      return (!seen_error () && !in_lto_p);\n+    }\n+\n   unsigned int execute () { return execute_all_early_local_passes (); }\n \n }; // class pass_early_local_passes\n@@ -383,16 +379,6 @@ make_pass_early_local_passes (gcc::context *ctxt)\n   return new pass_early_local_passes (ctxt);\n }\n \n-/* Gate: execute, or not, all of the non-trivial optimizations.  */\n-\n-static bool\n-gate_all_early_optimizations (void)\n-{\n-  return (optimize >= 1\n-\t  /* Don't bother doing anything if the program has errors.  */\n-\t  && !seen_error ());\n-}\n-\n namespace {\n \n const pass_data pass_data_all_early_optimizations =\n@@ -417,7 +403,12 @@ class pass_all_early_optimizations : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_all_early_optimizations (); }\n+  virtual bool gate (function *)\n+    {\n+      return (optimize >= 1\n+\t      /* Don't bother doing anything if the program has errors.  */\n+\t      && !seen_error ());\n+    }\n \n }; // class pass_all_early_optimizations\n \n@@ -429,14 +420,6 @@ make_pass_all_early_optimizations (gcc::context *ctxt)\n   return new pass_all_early_optimizations (ctxt);\n }\n \n-/* Gate: execute, or not, all of the non-trivial optimizations.  */\n-\n-static bool\n-gate_all_optimizations (void)\n-{\n-  return optimize >= 1 && !optimize_debug;\n-}\n-\n namespace {\n \n const pass_data pass_data_all_optimizations =\n@@ -461,7 +444,7 @@ class pass_all_optimizations : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_all_optimizations (); }\n+  virtual bool gate (function *) { return optimize >= 1 && !optimize_debug; }\n \n }; // class pass_all_optimizations\n \n@@ -473,14 +456,6 @@ make_pass_all_optimizations (gcc::context *ctxt)\n   return new pass_all_optimizations (ctxt);\n }\n \n-/* Gate: execute, or not, all of the non-trivial optimizations.  */\n-\n-static bool\n-gate_all_optimizations_g (void)\n-{\n-  return optimize >= 1 && optimize_debug;\n-}\n-\n namespace {\n \n const pass_data pass_data_all_optimizations_g =\n@@ -505,7 +480,7 @@ class pass_all_optimizations_g : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_all_optimizations_g (); }\n+  virtual bool gate (function *) { return optimize >= 1 && optimize_debug; }\n \n }; // class pass_all_optimizations_g\n \n@@ -517,14 +492,6 @@ make_pass_all_optimizations_g (gcc::context *ctxt)\n   return new pass_all_optimizations_g (ctxt);\n }\n \n-static bool\n-gate_rest_of_compilation (void)\n-{\n-  /* Early return if there were errors.  We can run afoul of our\n-     consistency checks, and there's not really much point in fixing them.  */\n-  return !(rtl_dump_and_exit || flag_syntax_only || seen_error ());\n-}\n-\n namespace {\n \n const pass_data pass_data_rest_of_compilation =\n@@ -549,7 +516,12 @@ class pass_rest_of_compilation : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rest_of_compilation (); }\n+  virtual bool gate (function *)\n+    {\n+      /* Early return if there were errors.  We can run afoul of our\n+\t consistency checks, and there's not really much point in fixing them.  */\n+      return !(rtl_dump_and_exit || flag_syntax_only || seen_error ());\n+    }\n \n }; // class pass_rest_of_compilation\n \n@@ -561,12 +533,6 @@ make_pass_rest_of_compilation (gcc::context *ctxt)\n   return new pass_rest_of_compilation (ctxt);\n }\n \n-static bool\n-gate_postreload (void)\n-{\n-  return reload_completed;\n-}\n-\n namespace {\n \n const pass_data pass_data_postreload =\n@@ -591,7 +557,7 @@ class pass_postreload : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_postreload (); }\n+  virtual bool gate (function *) { return reload_completed; }\n \n }; // class pass_postreload\n \n@@ -823,7 +789,7 @@ dump_one_pass (opt_pass *pass, int pass_indent)\n   const char *pn;\n   bool is_on, is_really_on;\n \n-  is_on = pass->gate ();\n+  is_on = pass->gate (cfun);\n   is_really_on = override_gate_status (pass, current_function_decl, is_on);\n \n   if (pass->static_pass_number <= 0)\n@@ -1976,7 +1942,7 @@ execute_ipa_summary_passes (ipa_opt_pass_d *ipa_pass)\n \n       /* Execute all of the IPA_PASSes in the list.  */\n       if (ipa_pass->type == IPA_PASS\n-\t  && pass->gate ()\n+\t  && pass->gate (cfun)\n \t  && ipa_pass->generate_summary)\n \t{\n \t  pass_init_dump_file (pass);\n@@ -2128,7 +2094,7 @@ execute_one_pass (opt_pass *pass)\n \n   /* Check whether gate check should be avoided.\n      User controls the value of the gate through the parameter \"gate_status\". */\n-  gate_status = pass->gate ();\n+  gate_status = pass->gate (cfun);\n   gate_status = override_gate_status (pass, current_function_decl, gate_status);\n \n   /* Override gate with plugin.  */\n@@ -2274,7 +2240,7 @@ ipa_write_summaries_2 (opt_pass *pass, struct lto_out_decl_state *state)\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n       if (pass->type == IPA_PASS\n \t  && ipa_pass->write_summary\n-\t  && pass->gate ())\n+\t  && pass->gate (cfun))\n \t{\n \t  /* If a timevar is present, start it.  */\n \t  if (pass->tv_id)\n@@ -2392,7 +2358,7 @@ ipa_write_optimization_summaries_1 (opt_pass *pass,\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n       if (pass->type == IPA_PASS\n \t  && ipa_pass->write_optimization_summary\n-\t  && pass->gate ())\n+\t  && pass->gate (cfun))\n \t{\n \t  /* If a timevar is present, start it.  */\n \t  if (pass->tv_id)\n@@ -2470,7 +2436,7 @@ ipa_read_summaries_1 (opt_pass *pass)\n       gcc_assert (!cfun);\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n \n-      if (pass->gate ())\n+      if (pass->gate (cfun))\n \t{\n \t  if (pass->type == IPA_PASS && ipa_pass->read_summary)\n \t    {\n@@ -2520,7 +2486,7 @@ ipa_read_optimization_summaries_1 (opt_pass *pass)\n       gcc_assert (!cfun);\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n \n-      if (pass->gate ())\n+      if (pass->gate (cfun))\n \t{\n \t  if (pass->type == IPA_PASS && ipa_pass->read_optimization_summary)\n \t    {\n@@ -2597,7 +2563,7 @@ execute_ipa_stmt_fixups (opt_pass *pass,\n     {\n       /* Execute all of the IPA_PASSes in the list.  */\n       if (pass->type == IPA_PASS\n-\t  && pass->gate ())\n+\t  && pass->gate (cfun))\n \t{\n \t  ipa_opt_pass_d *ipa_pass = (ipa_opt_pass_d *) pass;\n "}, {"sha": "8a804fb98eab5f1363e321b339157656f3238ef6", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1308,13 +1308,6 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n }\n \n \f\n-static bool\n-gate_handle_gcse2 (void)\n-{\n-  return (optimize > 0 && flag_gcse_after_reload\n-\t  && optimize_function_for_speed_p (cfun));\n-}\n-\n \n static unsigned int\n rest_of_handle_gcse2 (void)\n@@ -1348,7 +1341,12 @@ class pass_gcse2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_gcse2 (); }\n+  virtual bool gate (function *fun)\n+    {\n+      return (optimize > 0 && flag_gcse_after_reload\n+\t      && optimize_function_for_speed_p (fun));\n+    }\n+\n   unsigned int execute () { return rest_of_handle_gcse2 (); }\n \n }; // class pass_gcse2"}, {"sha": "0568c53f78acd2db80514a76979917a046e36fdd", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2315,13 +2315,6 @@ move2add_note_store (rtx dst, const_rtx set, void *data)\n     }\n }\n \f\n-static bool\n-gate_handle_postreload (void)\n-{\n-  return (optimize > 0 && reload_completed);\n-}\n-\n-\n static unsigned int\n rest_of_handle_postreload (void)\n {\n@@ -2363,7 +2356,8 @@ class pass_postreload_cse : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_postreload (); }\n+  virtual bool gate (function *) { return (optimize > 0 && reload_completed); }\n+\n   unsigned int execute () { return rest_of_handle_postreload (); }\n \n }; // class pass_postreload_cse"}, {"sha": "068c1877a305f074b8a8078d9993e88528ea8ec7", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3131,12 +3131,6 @@ compute_function_frequency (void)\n     }\n }\n \n-static bool\n-gate_estimate_probability (void)\n-{\n-  return flag_guess_branch_prob;\n-}\n-\n /* Build PREDICT_EXPR.  */\n tree\n build_predict_expr (enum br_predictor predictor, enum prediction taken)\n@@ -3177,7 +3171,7 @@ class pass_profile : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_estimate_probability (); }\n+  virtual bool gate (function *) { return flag_guess_branch_prob; }\n   unsigned int execute () { return tree_estimate_probability_driver (); }\n \n }; // class pass_profile"}, {"sha": "8afea7eca617b3e8b7d7643a20ad9cde9e8f6c42", "filename": "gcc/recog.c", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3810,12 +3810,6 @@ if_test_bypass_p (rtx out_insn, rtx in_insn)\n   return true;\n }\n \f\n-static bool\n-gate_handle_peephole2 (void)\n-{\n-  return (optimize > 0 && flag_peephole2);\n-}\n-\n static unsigned int\n rest_of_handle_peephole2 (void)\n {\n@@ -3852,7 +3846,7 @@ class pass_peephole2 : public rtl_opt_pass\n   /* The epiphany backend creates a second instance of this pass, so we need\n      a clone method.  */\n   opt_pass * clone () { return new pass_peephole2 (m_ctxt); }\n-  bool gate () { return gate_handle_peephole2 (); }\n+  virtual bool gate (function *) { return (optimize > 0 && flag_peephole2); }\n   unsigned int execute () { return rest_of_handle_peephole2 (); }\n \n }; // class pass_peephole2\n@@ -3958,24 +3952,6 @@ make_pass_split_after_reload (gcc::context *ctxt)\n   return new pass_split_after_reload (ctxt);\n }\n \n-static bool\n-gate_handle_split_before_regstack (void)\n-{\n-#if HAVE_ATTR_length && defined (STACK_REGS)\n-  /* If flow2 creates new instructions which need splitting\n-     and scheduling after reload is not done, they might not be\n-     split until final which doesn't allow splitting\n-     if HAVE_ATTR_length.  */\n-# ifdef INSN_SCHEDULING\n-  return (optimize && !flag_schedule_insns_after_reload);\n-# else\n-  return (optimize);\n-# endif\n-#else\n-  return 0;\n-#endif\n-}\n-\n static unsigned int\n rest_of_handle_split_before_regstack (void)\n {\n@@ -4007,13 +3983,31 @@ class pass_split_before_regstack : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_split_before_regstack (); }\n+  virtual bool gate (function *);\n   unsigned int execute () {\n     return rest_of_handle_split_before_regstack ();\n   }\n \n }; // class pass_split_before_regstack\n \n+bool\n+pass_split_before_regstack::gate (function *)\n+{\n+#if HAVE_ATTR_length && defined (STACK_REGS)\n+  /* If flow2 creates new instructions which need splitting\n+     and scheduling after reload is not done, they might not be\n+     split until final which doesn't allow splitting\n+     if HAVE_ATTR_length.  */\n+# ifdef INSN_SCHEDULING\n+  return (optimize && !flag_schedule_insns_after_reload);\n+# else\n+  return (optimize);\n+# endif\n+#else\n+  return 0;\n+#endif\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -4022,16 +4016,6 @@ make_pass_split_before_regstack (gcc::context *ctxt)\n   return new pass_split_before_regstack (ctxt);\n }\n \n-static bool\n-gate_handle_split_before_sched2 (void)\n-{\n-#ifdef INSN_SCHEDULING\n-  return optimize > 0 && flag_schedule_insns_after_reload;\n-#else\n-  return 0;\n-#endif\n-}\n-\n static unsigned int\n rest_of_handle_split_before_sched2 (void)\n {\n@@ -4065,7 +4049,15 @@ class pass_split_before_sched2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_split_before_sched2 (); }\n+  virtual bool gate (function *)\n+    {\n+#ifdef INSN_SCHEDULING\n+      return optimize > 0 && flag_schedule_insns_after_reload;\n+#else\n+      return false;\n+#endif\n+    }\n+\n   unsigned int execute () { return rest_of_handle_split_before_sched2 (); }\n \n }; // class pass_split_before_sched2\n@@ -4078,18 +4070,6 @@ make_pass_split_before_sched2 (gcc::context *ctxt)\n   return new pass_split_before_sched2 (ctxt);\n }\n \n-/* The placement of the splitting that we do for shorten_branches\n-   depends on whether regstack is used by the target or not.  */\n-static bool\n-gate_do_final_split (void)\n-{\n-#if HAVE_ATTR_length && !defined (STACK_REGS)\n-  return 1;\n-#else\n-  return 0;\n-#endif\n-}\n-\n namespace {\n \n const pass_data pass_data_split_for_shorten_branches =\n@@ -4114,7 +4094,17 @@ class pass_split_for_shorten_branches : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_do_final_split (); }\n+  virtual bool gate (function *)\n+    {\n+      /* The placement of the splitting that we do for shorten_branches\n+\t depends on whether regstack is used by the target or not.  */\n+#if HAVE_ATTR_length && !defined (STACK_REGS)\n+      return true;\n+#else\n+      return false;\n+#endif\n+    }\n+\n   unsigned int execute () { return split_all_insns_noflow (); }\n \n }; // class pass_split_for_shorten_branches"}, {"sha": "435bb88747c58ff417c7b7879af7efcf9a154ec5", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1093,14 +1093,6 @@ rest_of_handle_ree (void)\n   return 0;\n }\n \n-/* Run REE pass when flag_ree is set at optimization level > 0.  */\n-\n-static bool\n-gate_handle_ree (void)\n-{\n-  return (optimize > 0 && flag_ree);\n-}\n-\n namespace {\n \n const pass_data pass_data_ree =\n@@ -1125,7 +1117,7 @@ class pass_ree : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_ree (); }\n+  virtual bool gate (function *) { return (optimize > 0 && flag_ree); }\n   unsigned int execute () { return rest_of_handle_ree (); }\n \n }; // class pass_ree"}, {"sha": "f8f865887c7d64cb049ac7685f5a11d1e8cb981d", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3285,16 +3285,6 @@ reg_to_stack (void)\n }\n #endif /* STACK_REGS */\n \f\n-static bool\n-gate_handle_stack_regs (void)\n-{\n-#ifdef STACK_REGS\n-  return 1;\n-#else\n-  return 0;\n-#endif\n-}\n-\n namespace {\n \n const pass_data pass_data_stack_regs =\n@@ -3319,7 +3309,14 @@ class pass_stack_regs : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_stack_regs (); }\n+  virtual bool gate (function *)\n+    {\n+#ifdef STACK_REGS\n+      return true;\n+#else\n+      return false;\n+#endif\n+    }\n \n }; // class pass_stack_regs\n "}, {"sha": "24992e4e2c5e47723febf48ada7d2717cc801aaf", "filename": "gcc/regcprop.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1247,13 +1247,6 @@ validate_value_data (struct value_data *vd)\n }\n #endif\n \f\n-static bool\n-gate_handle_cprop (void)\n-{\n-  return (optimize > 0 && (flag_cprop_registers));\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_cprop_hardreg =\n@@ -1278,7 +1271,11 @@ class pass_cprop_hardreg : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_cprop (); }\n+  virtual bool gate (function *)\n+    {\n+      return (optimize > 0 && (flag_cprop_registers));\n+    }\n+\n   unsigned int execute () { return copyprop_hardreg_forward (); }\n \n }; // class pass_cprop_hardreg"}, {"sha": "321d5bfbe5bee681538d37017f29f2e44e908fb7", "filename": "gcc/regrename.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1836,12 +1836,6 @@ regrename_optimize (void)\n   return 0;\n }\n \f\n-static bool\n-gate_handle_regrename (void)\n-{\n-  return (optimize > 0 && (flag_rename_registers));\n-}\n-\n namespace {\n \n const pass_data pass_data_regrename =\n@@ -1866,7 +1860,11 @@ class pass_regrename : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_regrename (); }\n+  virtual bool gate (function *)\n+    {\n+      return (optimize > 0 && (flag_rename_registers));\n+    }\n+\n   unsigned int execute () { return regrename_optimize (); }\n \n }; // class pass_regrename"}, {"sha": "22f0b5a8287b0a5bfe284dbed8f5ef6874b68cc3", "filename": "gcc/reorg.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3863,17 +3863,6 @@ dbr_schedule (rtx first)\n }\n #endif /* DELAY_SLOTS */\n \f\n-static bool\n-gate_handle_delay_slots (void)\n-{\n-#ifdef DELAY_SLOTS\n-  /* At -O0 dataflow info isn't updated after RA.  */\n-  return optimize > 0 && flag_delayed_branch && !crtl->dbr_scheduled_p;\n-#else\n-  return 0;\n-#endif\n-}\n-\n /* Run delay slot optimization.  */\n static unsigned int\n rest_of_handle_delay_slots (void)\n@@ -3908,11 +3897,22 @@ class pass_delay_slots : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_delay_slots (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return rest_of_handle_delay_slots (); }\n \n }; // class pass_delay_slots\n \n+bool\n+pass_delay_slots::gate (function *)\n+{\n+#ifdef DELAY_SLOTS\n+  /* At -O0 dataflow info isn't updated after RA.  */\n+  return optimize > 0 && flag_delayed_branch && !crtl->dbr_scheduled_p;\n+#else\n+  return 0;\n+#endif\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -3922,12 +3922,6 @@ make_pass_delay_slots (gcc::context *ctxt)\n }\n \n /* Machine dependent reorg pass.  */\n-static bool\n-gate_handle_machine_reorg (void)\n-{\n-  return targetm.machine_dependent_reorg != 0;\n-}\n-\n \n static unsigned int\n rest_of_handle_machine_reorg (void)\n@@ -3960,7 +3954,11 @@ class pass_machine_reorg : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_machine_reorg (); }\n+  virtual bool gate (function *)\n+    {\n+      return targetm.machine_dependent_reorg != 0;\n+    }\n+\n   unsigned int execute () { return rest_of_handle_machine_reorg (); }\n \n }; // class pass_machine_reorg"}, {"sha": "e0a80c229e945cef53a66f1dffeb3e89509b4fa3", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3591,16 +3591,6 @@ advance_target_bb (basic_block bb, rtx insn)\n \n #endif\n \f\n-static bool\n-gate_handle_live_range_shrinkage (void)\n-{\n-#ifdef INSN_SCHEDULING\n-  return flag_live_range_shrinkage;\n-#else\n-  return 0;\n-#endif\n-}\n-\n /* Run instruction scheduler.  */\n static unsigned int\n rest_of_handle_live_range_shrinkage (void)\n@@ -3618,16 +3608,6 @@ rest_of_handle_live_range_shrinkage (void)\n   return 0;\n }\n \n-static bool\n-gate_handle_sched (void)\n-{\n-#ifdef INSN_SCHEDULING\n-  return optimize > 0 && flag_schedule_insns && dbg_cnt (sched_func);\n-#else\n-  return 0;\n-#endif\n-}\n-\n /* Run instruction scheduler.  */\n static unsigned int\n rest_of_handle_sched (void)\n@@ -3642,17 +3622,6 @@ rest_of_handle_sched (void)\n   return 0;\n }\n \n-static bool\n-gate_handle_sched2 (void)\n-{\n-#ifdef INSN_SCHEDULING\n-  return optimize > 0 && flag_schedule_insns_after_reload\n-    && !targetm.delay_sched2 && dbg_cnt (sched2_func);\n-#else\n-  return 0;\n-#endif\n-}\n-\n /* Run second scheduling pass after reload.  */\n static unsigned int\n rest_of_handle_sched2 (void)\n@@ -3699,7 +3668,15 @@ class pass_live_range_shrinkage : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_live_range_shrinkage (); }\n+  virtual bool gate (function *)\n+    {\n+#ifdef INSN_SCHEDULING\n+      return flag_live_range_shrinkage;\n+#else\n+      return 0;\n+#endif\n+    }\n+\n   unsigned int execute () { return rest_of_handle_live_range_shrinkage (); }\n \n }; // class pass_live_range_shrinkage\n@@ -3737,11 +3714,21 @@ class pass_sched : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_sched (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return rest_of_handle_sched (); }\n \n }; // class pass_sched\n \n+bool\n+pass_sched::gate (function *)\n+{\n+#ifdef INSN_SCHEDULING\n+  return optimize > 0 && flag_schedule_insns && dbg_cnt (sched_func);\n+#else\n+  return 0;\n+#endif\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -3775,11 +3762,22 @@ class pass_sched2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_sched2 (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return rest_of_handle_sched2 (); }\n \n }; // class pass_sched2\n \n+bool\n+pass_sched2::gate (function *)\n+{\n+#ifdef INSN_SCHEDULING\n+  return optimize > 0 && flag_schedule_insns_after_reload\n+    && !targetm.delay_sched2 && dbg_cnt (sched2_func);\n+#else\n+  return 0;\n+#endif\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "7c57754d1c4bb969a259102988fc878e26d8904c", "filename": "gcc/store-motion.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1223,15 +1223,6 @@ one_store_motion_pass (void)\n }\n \n \f\n-static bool\n-gate_rtl_store_motion (void)\n-{\n-  return optimize > 0 && flag_gcse_sm\n-    && !cfun->calls_setjmp\n-    && optimize_function_for_speed_p (cfun)\n-    && dbg_cnt (store_motion);\n-}\n-\n static unsigned int\n execute_rtl_store_motion (void)\n {\n@@ -1266,11 +1257,20 @@ class pass_rtl_store_motion : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_rtl_store_motion (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return execute_rtl_store_motion (); }\n \n }; // class pass_rtl_store_motion\n \n+bool\n+pass_rtl_store_motion::gate (function *fun)\n+{\n+  return optimize > 0 && flag_gcse_sm\n+    && !fun->calls_setjmp\n+    && optimize_function_for_speed_p (fun)\n+    && dbg_cnt (store_motion);\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "a3cbef3abb5a915ae48cf40dcf677612d67cf4dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1,3 +1,8 @@\n+2014-04-17  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* g++.dg/plugin/dumb_plugin.c, g++.dg/plugin/selfasign.c,\n+\tgcc.dg/plugin/one_time_plugin.c, gcc.dg/plugin/selfasign.c: Adjust.\n+\n 2014-04-17  Trevor Saunders  <tsaunders@mozilla.com>\n \t\n \t* g++.dg/plugin/dumb_plugin.c, g++.dg/plugin/selfassign.c,"}, {"sha": "a3b04a24928ad0516d59abfe393cd254918a6a4c", "filename": "gcc/testsuite/g++.dg/plugin/dumb_plugin.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -52,12 +52,6 @@ execute_dumb_plugin_example (void)\n   return 0;\n }\n \n-static bool\n-gate_dumb_plugin_example (void)\n-{\n-  return true;\n-}\n-\n namespace {\n \n const pass_data pass_data_dumb_plugin_example =\n@@ -82,7 +76,6 @@ class pass_dumb_plugin_example : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_dumb_plugin_example (); }\n   unsigned int execute () { return execute_dumb_plugin_example (); }\n \n }; // class pass_dumb_plugin_example"}, {"sha": "033047b9894e86023af7e264c1a3fecad1f811df", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -270,14 +270,6 @@ execute_warn_self_assign (void)\n   return 0;\n }\n \n-/* Pass gate function. Currently always returns true.  */\n-\n-static bool\n-gate_warn_self_assign (void)\n-{\n-  return true;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_self_assign =\n@@ -302,7 +294,7 @@ class pass_warn_self_assign : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_warn_self_assign (); }\n+  bool gate (function *) { return true; }\n   unsigned int execute () { return execute_warn_self_assign (); }\n \n }; // class pass_warn_self_assign"}, {"sha": "18e8b07a77f32bcf8f7139c0474abadcd7db5f4f", "filename": "gcc/testsuite/gcc.dg/plugin/one_time_plugin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -49,7 +49,7 @@ class one_pass : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate ();\n+  virtual bool gate (function *);\n   unsigned int execute ();\n \n private:\n@@ -58,7 +58,7 @@ class one_pass : public gimple_opt_pass\n \n } // anon namespace\n \n-bool one_pass::gate (void)\n+bool one_pass::gate (function *)\n {\n   return true;\n }"}, {"sha": "098df060c82109b964703140b1694012e1343656", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -270,14 +270,6 @@ execute_warn_self_assign (void)\n   return 0;\n }\n \n-/* Pass gate function. Currently always returns true.  */\n-\n-static bool\n-gate_warn_self_assign (void)\n-{\n-  return true;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_self_assign =\n@@ -302,7 +294,6 @@ class pass_warn_self_assign : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_warn_self_assign (); }\n   unsigned int execute () { return execute_warn_self_assign (); }\n \n }; // class pass_warn_self_assign"}, {"sha": "794d385988f1fbd9aec5490cd6a8f090fb982573", "filename": "gcc/tracer.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -398,12 +398,6 @@ tracer (void)\n   return changed ? TODO_cleanup_cfg : 0;\n }\n \f\n-static bool\n-gate_tracer (void)\n-{\n-  return (optimize > 0 && flag_tracer && flag_reorder_blocks);\n-}\n-\n namespace {\n \n const pass_data pass_data_tracer =\n@@ -428,7 +422,11 @@ class pass_tracer : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tracer (); }\n+  virtual bool gate (function *)\n+    {\n+      return (optimize > 0 && flag_tracer && flag_reorder_blocks);\n+    }\n+\n   unsigned int execute () { return tracer (); }\n \n }; // class pass_tracer"}, {"sha": "eb172a6079b9fe05918c0c74b54d59c99457d07d", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -456,14 +456,6 @@ build_tm_abort_call (location_t loc, bool is_outer)\n \t\t\t\t\t     AR_USERABORT\n \t\t\t\t\t     | (is_outer ? AR_OUTERABORT : 0)));\n }\n-\n-/* Common gateing function for several of the TM passes.  */\n-\n-static bool\n-gate_tm (void)\n-{\n-  return flag_tm;\n-}\n \f\n /* Map for aribtrary function replacement under TM, as created\n    by the tm_wrap attribute.  */\n@@ -863,7 +855,7 @@ class pass_diagnose_tm_blocks : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tm (); }\n+  virtual bool gate (function *) { return flag_tm; }\n   unsigned int execute () { return diagnose_tm_blocks (); }\n \n }; // class pass_diagnose_tm_blocks\n@@ -1785,7 +1777,7 @@ class pass_lower_tm : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tm (); }\n+  virtual bool gate (function *) { return flag_tm; }\n   unsigned int execute () { return execute_lower_tm (); }\n \n }; // class pass_lower_tm\n@@ -2062,7 +2054,7 @@ class pass_tm_init : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tm_init (); }\n+  virtual bool gate (function *) { return gate_tm_init (); }\n \n }; // class pass_tm_init\n \n@@ -3929,12 +3921,6 @@ execute_tm_memopt (void)\n   return 0;\n }\n \n-static bool\n-gate_tm_memopt (void)\n-{\n-  return flag_tm && optimize > 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_tm_memopt =\n@@ -3959,7 +3945,7 @@ class pass_tm_memopt : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tm_memopt (); }\n+  virtual bool gate (function *) { return flag_tm && optimize > 0; }\n   unsigned int execute () { return execute_tm_memopt (); }\n \n }; // class pass_tm_memopt\n@@ -5595,7 +5581,7 @@ class pass_ipa_tm : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tm (); }\n+  virtual bool gate (function *) { return flag_tm; }\n   unsigned int execute () { return ipa_tm_execute (); }\n \n }; // class pass_ipa_tm"}, {"sha": "c27149321621bdf52cf506588b28c551bc5b81d1", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -917,15 +917,6 @@ tree_call_cdce (void)\n   return 0;\n }\n \n-static bool\n-gate_call_cdce (void)\n-{\n-  /* The limit constants used in the implementation\n-     assume IEEE floating point format.  Other formats\n-     can be supported in the future if needed.  */\n-  return flag_tree_builtin_call_dce != 0 && optimize_function_for_speed_p (cfun);\n-}\n-\n namespace {\n \n const pass_data pass_data_call_cdce =\n@@ -950,7 +941,15 @@ class pass_call_cdce : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_call_cdce (); }\n+  virtual bool gate (function *fun)\n+    {\n+      /* The limit constants used in the implementation\n+\t assume IEEE floating point format.  Other formats\n+\t can be supported in the future if needed.  */\n+      return flag_tree_builtin_call_dce != 0\n+       \t&& optimize_function_for_speed_p (fun);\n+    }\n+\n   unsigned int execute () { return tree_call_cdce (); }\n \n }; // class pass_call_cdce"}, {"sha": "8fcaae8c780214fb60c5f8268e8c6174ad8dc947", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -8355,12 +8355,6 @@ run_warn_unused_result (void)\n   return 0;\n }\n \n-static bool\n-gate_warn_unused_result (void)\n-{\n-  return flag_warn_unused_result;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_unused_result =\n@@ -8385,7 +8379,7 @@ class pass_warn_unused_result : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_warn_unused_result (); }\n+  virtual bool gate (function *) { return flag_warn_unused_result; }\n   unsigned int execute () { return run_warn_unused_result (); }\n \n }; // class pass_warn_unused_result"}, {"sha": "19433f9615664455af18485ee52bf8405f22bd41", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1035,12 +1035,6 @@ merge_phi_nodes (void)\n   return 0;\n }\n \n-static bool\n-gate_merge_phi (void)\n-{\n-  return 1;\n-}\n-\n namespace {\n \n const pass_data pass_data_merge_phi =\n@@ -1066,7 +1060,6 @@ class pass_merge_phi : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_merge_phi (m_ctxt); }\n-  bool gate () { return gate_merge_phi (); }\n   unsigned int execute () { return merge_phi_nodes (); }\n \n }; // class pass_merge_phi"}, {"sha": "9ec83d9830f21b828165ab668f79c30d85bd7761", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1693,14 +1693,6 @@ make_pass_lower_complex (gcc::context *ctxt)\n }\n \n \f\n-static bool\n-gate_no_optimization (void)\n-{\n-  /* With errors, normal optimization passes are not run.  If we don't\n-     lower complex operations at all, rtl expansion will abort.  */\n-  return !(cfun->curr_properties & PROP_gimple_lcx);\n-}\n-\n namespace {\n \n const pass_data pass_data_lower_complex_O0 =\n@@ -1725,7 +1717,13 @@ class pass_lower_complex_O0 : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_no_optimization (); }\n+  virtual bool gate (function *fun)\n+    {\n+      /* With errors, normal optimization passes are not run.  If we don't\n+\t lower complex operations at all, rtl expansion will abort.  */\n+      return !(fun->curr_properties & PROP_gimple_lcx);\n+    }\n+\n   unsigned int execute () { return tree_lower_complex (); }\n \n }; // class pass_lower_complex_O0"}, {"sha": "41f96c461bde701ffedb75aed88c502783305655", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3115,12 +3115,6 @@ refactor_eh (void)\n   return 0;\n }\n \n-static bool\n-gate_refactor_eh (void)\n-{\n-  return flag_exceptions != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_refactor_eh =\n@@ -3145,7 +3139,7 @@ class pass_refactor_eh : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_refactor_eh (); }\n+  virtual bool gate (function *) { return flag_exceptions != 0; }\n   unsigned int execute () { return refactor_eh (); }\n \n }; // class pass_refactor_eh\n@@ -3341,12 +3335,6 @@ execute_lower_resx (void)\n   return any_rewritten ? TODO_update_ssa_only_virtuals : 0;\n }\n \n-static bool\n-gate_lower_resx (void)\n-{\n-  return flag_exceptions != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_lower_resx =\n@@ -3371,7 +3359,7 @@ class pass_lower_resx : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_lower_resx (); }\n+  virtual bool gate (function *) { return flag_exceptions != 0; }\n   unsigned int execute () { return execute_lower_resx (); }\n \n }; // class pass_lower_resx\n@@ -3749,12 +3737,6 @@ execute_lower_eh_dispatch (void)\n   return flags;\n }\n \n-static bool\n-gate_lower_eh_dispatch (void)\n-{\n-  return cfun->eh->region_tree != NULL;\n-}\n-\n namespace {\n \n const pass_data pass_data_lower_eh_dispatch =\n@@ -3779,7 +3761,8 @@ class pass_lower_eh_dispatch : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_lower_eh_dispatch (); }\n+  virtual bool gate (function *fun) { return fun->eh->region_tree != NULL; }\n+\n   unsigned int execute () { return execute_lower_eh_dispatch (); }\n \n }; // class pass_lower_eh_dispatch\n@@ -4596,12 +4579,6 @@ execute_cleanup_eh (void)\n   return ret;\n }\n \n-static bool\n-gate_cleanup_eh (void)\n-{\n-  return cfun->eh != NULL && cfun->eh->region_tree != NULL;\n-}\n-\n namespace {\n \n const pass_data pass_data_cleanup_eh =\n@@ -4627,7 +4604,11 @@ class pass_cleanup_eh : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_cleanup_eh (m_ctxt); }\n-  bool gate () { return gate_cleanup_eh (); }\n+  virtual bool gate (function *fun)\n+    {\n+      return fun->eh != NULL && fun->eh->region_tree != NULL;\n+    }\n+\n   unsigned int execute () { return execute_cleanup_eh (); }\n \n }; // class pass_cleanup_eh"}, {"sha": "280a606221d8952c6526cf12bd9f30364d5b54bf", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -816,14 +816,6 @@ ipa_lower_emutls (void)\n   return TODO_verify_all;\n }\n \n-/* If the target supports TLS natively, we need do nothing here.  */\n-\n-static bool\n-gate_emutls (void)\n-{\n-  return !targetm.have_tls;\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_lower_emutls =\n@@ -848,7 +840,12 @@ class pass_ipa_lower_emutls : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_emutls (); }\n+  virtual bool gate (function *)\n+    {\n+      /* If the target supports TLS natively, we need do nothing here.  */\n+      return !targetm.have_tls;\n+    }\n+\n   unsigned int execute () { return ipa_lower_emutls (); }\n \n }; // class pass_ipa_lower_emutls"}, {"sha": "90b62a83a125a5392afd7d60f96aeee26a2d73c5", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2013,17 +2013,6 @@ main_tree_if_conversion (void)\n   return todo;\n }\n \n-/* Returns true when the if-conversion pass is enabled.  */\n-\n-static bool\n-gate_tree_if_conversion (void)\n-{\n-  return (((flag_tree_loop_vectorize || cfun->has_force_vectorize_loops)\n-\t   && flag_tree_loop_if_convert != 0)\n-\t  || flag_tree_loop_if_convert == 1\n-\t  || flag_tree_loop_if_convert_stores == 1);\n-}\n-\n namespace {\n \n const pass_data pass_data_if_conversion =\n@@ -2049,11 +2038,20 @@ class pass_if_conversion : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_if_conversion (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return main_tree_if_conversion (); }\n \n }; // class pass_if_conversion\n \n+bool\n+pass_if_conversion::gate (function *fun)\n+{\n+  return (((flag_tree_loop_vectorize || fun->has_force_vectorize_loops)\n+\t   && flag_tree_loop_if_convert != 0)\n+\t  || flag_tree_loop_if_convert == 1\n+\t  || flag_tree_loop_if_convert_stores == 1);\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "332901d3f41538e89fca5785d7830cd353d6f7ba", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2365,15 +2365,6 @@ rewrite_into_ssa (void)\n   return 0;\n }\n \n-/* Gate for IPCP optimization.  */\n-\n-static bool\n-gate_into_ssa (void)\n-{\n-  /* Do nothing for funcions that was produced already in SSA form.  */\n-  return !(cfun->curr_properties & PROP_ssa);\n-}\n-\n namespace {\n \n const pass_data pass_data_build_ssa =\n@@ -2398,7 +2389,12 @@ class pass_build_ssa : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_into_ssa (); }\n+  virtual bool gate (function *fun)\n+    {\n+      /* Do nothing for funcions that was produced already in SSA form.  */\n+      return !(fun->curr_properties & PROP_ssa);\n+    }\n+\n   unsigned int execute () { return rewrite_into_ssa (); }\n \n }; // class pass_build_ssa"}, {"sha": "0a154127f1771afeff8c88a4bcc8aa5aebe70a96", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1790,13 +1790,6 @@ tree_loop_distribution (void)\n   return 0;\n }\n \n-static bool\n-gate_tree_loop_distribution (void)\n-{\n-  return flag_tree_loop_distribution\n-    || flag_tree_loop_distribute_patterns;\n-}\n-\n namespace {\n \n const pass_data pass_data_loop_distribution =\n@@ -1821,7 +1814,12 @@ class pass_loop_distribution : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_loop_distribution (); }\n+  virtual bool gate (function *)\n+    {\n+      return flag_tree_loop_distribution\n+\t|| flag_tree_loop_distribute_patterns;\n+    }\n+\n   unsigned int execute () { return tree_loop_distribution (); }\n \n }; // class pass_loop_distribution"}, {"sha": "71f8d68fc3d1255731c29e9f7d6b4c7fb1135f9c", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -272,12 +272,6 @@ tree_nrv (void)\n   return 0;\n }\n \n-static bool\n-gate_pass_return_slot (void)\n-{\n-  return optimize > 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_nrv =\n@@ -302,7 +296,8 @@ class pass_nrv : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_pass_return_slot (); }\n+  virtual bool gate (function *) { return optimize > 0; }\n+\n   unsigned int execute () { return tree_nrv (); }\n \n }; // class pass_nrv"}, {"sha": "a46fa51d05e81e7157c3789a9344969558275ead", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2253,12 +2253,6 @@ parallelize_loops (void)\n \n /* Parallelization.  */\n \n-static bool\n-gate_tree_parallelize_loops (void)\n-{\n-  return flag_tree_parallelize_loops > 1;\n-}\n-\n static unsigned\n tree_parallelize_loops (void)\n {\n@@ -2294,7 +2288,7 @@ class pass_parallelize_loops : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_parallelize_loops (); }\n+  virtual bool gate (function *) { return flag_tree_parallelize_loops > 1; }\n   unsigned int execute () { return tree_parallelize_loops (); }\n \n }; // class pass_parallelize_loops"}, {"sha": "9de2822cccec6a76430aad6f9ce0e117eb54a9e3", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -25,6 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"dumpfile.h\"\n \n+struct function;\n+\n /* Optimization pass type.  */\n enum opt_pass_type\n {\n@@ -88,7 +90,7 @@ class opt_pass : public pass_data\n \n   /* This pass and all sub-passes are executed only if the function returns\n      true.  The default implementation returns true.  */\n-  virtual bool gate ();\n+  virtual bool gate (function *fun);\n \n   /* This is the code to run.  If has_execute is false, then there should\n      be sub-passes otherwise this pass does nothing."}, {"sha": "7dd86e1669101d50eacdbf67cbaa638041e158e1", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2573,12 +2573,6 @@ run_tree_predictive_commoning (void)\n   return tree_predictive_commoning ();\n }\n \n-static bool\n-gate_tree_predictive_commoning (void)\n-{\n-  return flag_predictive_commoning != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_predcom =\n@@ -2603,7 +2597,7 @@ class pass_predcom : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_predictive_commoning (); }\n+  virtual bool gate (function *) { return flag_predictive_commoning != 0; }\n   unsigned int execute () { return run_tree_predictive_commoning (); }\n \n }; // class pass_predcom"}, {"sha": "b7d04661eeb15ce318fce2523e2680917c6c3404", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -663,16 +663,6 @@ tree_profiling (void)\n   return 0;\n }\n \n-/* When profile instrumentation, use or test coverage shall be performed.  */\n-\n-static bool\n-gate_tree_profile_ipa (void)\n-{\n-  return (!in_lto_p\n-\t  && (flag_branch_probabilities || flag_test_coverage\n-\t      || profile_arc_flag));\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_tree_profile =\n@@ -697,11 +687,20 @@ class pass_ipa_tree_profile : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_profile_ipa (); }\n+  virtual bool gate (function *);\n   unsigned int execute () { return tree_profiling (); }\n \n }; // class pass_ipa_tree_profile\n \n+bool\n+pass_ipa_tree_profile::gate (function *)\n+{\n+  /* When profile instrumentation, use or test coverage shall be performed.  */\n+  return (!in_lto_p\n+\t  && (flag_branch_probabilities || flag_test_coverage\n+\t      || profile_arc_flag));\n+}\n+\n } // anon namespace\n \n simple_ipa_opt_pass *"}, {"sha": "27f71a37366f8280c987902a42c490ef51ff3bea", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3524,7 +3524,7 @@ class pass_sra_early : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_intra_sra (); }\n+  virtual bool gate (function *) { return gate_intra_sra (); }\n   unsigned int execute () { return early_intra_sra (); }\n \n }; // class pass_sra_early\n@@ -3561,7 +3561,7 @@ class pass_sra : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_intra_sra (); }\n+  virtual bool gate (function *) { return gate_intra_sra (); }\n   unsigned int execute () { return late_intra_sra (); }\n \n }; // class pass_sra\n@@ -5051,13 +5051,6 @@ ipa_early_sra (void)\n   return ret;\n }\n \n-/* Return if early ipa sra shall be performed.  */\n-static bool\n-ipa_early_sra_gate (void)\n-{\n-  return flag_ipa_sra && dbg_cnt (eipa_sra);\n-}\n-\n namespace {\n \n const pass_data pass_data_early_ipa_sra =\n@@ -5082,7 +5075,7 @@ class pass_early_ipa_sra : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return ipa_early_sra_gate (); }\n+  virtual bool gate (function *) { return flag_ipa_sra && dbg_cnt (eipa_sra); }\n   unsigned int execute () { return ipa_early_sra (); }\n \n }; // class pass_early_ipa_sra"}, {"sha": "c4a5c71f530a9e93f546a73e03f9bdb1bfc28fef", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2287,13 +2287,6 @@ do_ssa_ccp (void)\n }\n \n \n-static bool\n-gate_ccp (void)\n-{\n-  return flag_tree_ccp != 0;\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_ccp =\n@@ -2320,7 +2313,7 @@ class pass_ccp : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_ccp (m_ctxt); }\n-  bool gate () { return gate_ccp (); }\n+  virtual bool gate (function *) { return flag_tree_ccp != 0; }\n   unsigned int execute () { return do_ssa_ccp (); }\n \n }; // class pass_ccp"}, {"sha": "bd6ac04edbb88f4802a8baa1449c7a44dbf86766", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -644,12 +644,6 @@ execute_copy_prop (void)\n   return 0;\n }\n \n-static bool\n-gate_copy_prop (void)\n-{\n-  return flag_tree_copy_prop != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_copy_prop =\n@@ -676,7 +670,7 @@ class pass_copy_prop : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_copy_prop (m_ctxt); }\n-  bool gate () { return gate_copy_prop (); }\n+  virtual bool gate (function *) { return flag_tree_copy_prop != 0; }\n   unsigned int execute () { return execute_copy_prop (); }\n \n }; // class pass_copy_prop"}, {"sha": "65d80449c29b12611b3577dd2665c5340f66ef33", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -435,14 +435,6 @@ rename_ssa_copies (void)\n   return 0;\n }\n \n-/* Return true if copy rename is to be performed.  */\n-\n-static bool\n-gate_copyrename (void)\n-{\n-  return flag_tree_copyrename != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_rename_ssa_copies =\n@@ -468,7 +460,7 @@ class pass_rename_ssa_copies : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_rename_ssa_copies (m_ctxt); }\n-  bool gate () { return gate_copyrename (); }\n+  virtual bool gate (function *) { return flag_tree_copyrename != 0; }\n   unsigned int execute () { return rename_ssa_copies (); }\n \n }; // class pass_rename_ssa_copies"}, {"sha": "e5799b96d14f510c58ceb82c658a7234b54b9550", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1504,12 +1504,6 @@ tree_ssa_cd_dce (void)\n   return perform_tree_ssa_dce (/*aggressive=*/optimize >= 2);\n }\n \n-static bool\n-gate_dce (void)\n-{\n-  return flag_tree_dce != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_dce =\n@@ -1535,7 +1529,7 @@ class pass_dce : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_dce (m_ctxt); }\n-  bool gate () { return gate_dce (); }\n+  virtual bool gate (function *) { return flag_tree_dce != 0; }\n   unsigned int execute () { return tree_ssa_dce (); }\n \n }; // class pass_dce\n@@ -1573,7 +1567,7 @@ class pass_dce_loop : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_dce_loop (m_ctxt); }\n-  bool gate () { return gate_dce (); }\n+  virtual bool gate (function *) { return flag_tree_dce != 0; }\n   unsigned int execute () { return tree_ssa_dce_loop (); }\n \n }; // class pass_dce_loop\n@@ -1611,7 +1605,7 @@ class pass_cd_dce : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_cd_dce (m_ctxt); }\n-  bool gate () { return gate_dce (); }\n+  virtual bool gate (function *) { return flag_tree_dce != 0; }\n   unsigned int execute () { return tree_ssa_cd_dce (); }\n \n }; // class pass_cd_dce"}, {"sha": "b9cc5cc433dfd729f06a560dcc89a0970d30e6ad", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -952,12 +952,6 @@ tree_ssa_dominator_optimize (void)\n   return 0;\n }\n \n-static bool\n-gate_dominator (void)\n-{\n-  return flag_tree_dom != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_dominator =\n@@ -985,7 +979,7 @@ class pass_dominator : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_dominator (m_ctxt); }\n-  bool gate () { return gate_dominator (); }\n+  virtual bool gate (function *) { return flag_tree_dom != 0; }\n   unsigned int execute () { return tree_ssa_dominator_optimize (); }\n \n }; // class pass_dominator\n@@ -3142,7 +3136,7 @@ class pass_phi_only_cprop : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_phi_only_cprop (m_ctxt); }\n-  bool gate () { return gate_dominator (); }\n+  virtual bool gate (function *) { return flag_tree_dom != 0; }\n   unsigned int execute () { return eliminate_degenerate_phis (); }\n \n }; // class pass_phi_only_cprop"}, {"sha": "b6fbdaf55059d12547591b2ff2553d62de1942ba", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -80,7 +80,6 @@ along with GCC; see the file COPYING3.  If not see\n    remove their dead edges eventually.  */\n static bitmap need_eh_cleanup;\n \n-static bool gate_dse (void);\n static unsigned int tree_ssa_dse (void);\n \n \n@@ -363,12 +362,6 @@ tree_ssa_dse (void)\n   return 0;\n }\n \n-static bool\n-gate_dse (void)\n-{\n-  return flag_tree_dse != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_dse =\n@@ -394,7 +387,7 @@ class pass_dse : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_dse (m_ctxt); }\n-  bool gate () { return gate_dse (); }\n+  virtual bool gate (function *) { return flag_tree_dse != 0; }\n   unsigned int execute () { return tree_ssa_dse (); }\n \n }; // class pass_dse"}, {"sha": "8d5ca5f12527d76928066df0a4a8cdbcedfb1d0f", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -3831,13 +3831,6 @@ ssa_forward_propagate_and_combine (void)\n   return todoflags;\n }\n \n-\n-static bool\n-gate_forwprop (void)\n-{\n-  return flag_tree_forwprop;\n-}\n-\n namespace {\n \n const pass_data pass_data_forwprop =\n@@ -3863,7 +3856,7 @@ class pass_forwprop : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_forwprop (m_ctxt); }\n-  bool gate () { return gate_forwprop (); }\n+  virtual bool gate (function *) { return flag_tree_forwprop; }\n   unsigned int execute () { return ssa_forward_propagate_and_combine (); }\n \n }; // class pass_forwprop"}, {"sha": "b901f379c6b81d00cd7a31b6fb4ee14586470446", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -756,12 +756,6 @@ tree_ssa_ifcombine (void)\n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }\n \n-static bool\n-gate_ifcombine (void)\n-{\n-  return 1;\n-}\n-\n namespace {\n \n const pass_data pass_data_tree_ifcombine =\n@@ -786,7 +780,6 @@ class pass_tree_ifcombine : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ifcombine (); }\n   unsigned int execute () { return tree_ssa_ifcombine (); }\n \n }; // class pass_tree_ifcombine"}, {"sha": "34d1f7023ccadbcf41857bcb9c5b30e01dfeba71", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -257,12 +257,6 @@ copy_loop_headers (void)\n   return 0;\n }\n \n-static bool\n-gate_ch (void)\n-{\n-  return flag_tree_ch != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_ch =\n@@ -288,7 +282,7 @@ class pass_ch : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ch (); }\n+  virtual bool gate (function *) { return flag_tree_ch != 0; }\n   unsigned int execute () { return copy_loop_headers (); }\n \n }; // class pass_ch"}, {"sha": "f38ee95933b5b492422e8e3e8e9fd019916e474b", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2538,12 +2538,6 @@ tree_ssa_loop_im (void)\n   return tree_ssa_lim ();\n }\n \n-static bool\n-gate_tree_ssa_loop_im (void)\n-{\n-  return flag_tree_loop_im != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_lim =\n@@ -2569,7 +2563,7 @@ class pass_lim : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_lim (m_ctxt); }\n-  bool gate () { return gate_tree_ssa_loop_im (); }\n+  virtual bool gate (function *) { return flag_tree_loop_im != 0; }\n   unsigned int execute () { return tree_ssa_loop_im (); }\n \n }; // class pass_lim"}, {"sha": "df82816024130b1d4efddf505863050611c15826", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1265,12 +1265,6 @@ tree_ssa_loop_ivcanon (void)\n   return canonicalize_induction_variables ();\n }\n \n-static bool\n-gate_tree_ssa_loop_ivcanon (void)\n-{\n-  return flag_tree_loop_ivcanon != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_iv_canon =\n@@ -1295,7 +1289,7 @@ class pass_iv_canon : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_ssa_loop_ivcanon (); }\n+  virtual bool gate (function *) { return flag_tree_loop_ivcanon != 0; }\n   unsigned int execute () { return tree_ssa_loop_ivcanon (); }\n \n }; // class pass_iv_canon\n@@ -1321,12 +1315,6 @@ tree_complete_unroll (void)\n \t\t\t\t       || optimize >= 3, true);\n }\n \n-static bool\n-gate_tree_complete_unroll (void)\n-{\n-  return true;\n-}\n-\n namespace {\n \n const pass_data pass_data_complete_unroll =\n@@ -1351,7 +1339,6 @@ class pass_complete_unroll : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_complete_unroll (); }\n   unsigned int execute () { return tree_complete_unroll (); }\n \n }; // class pass_complete_unroll\n@@ -1385,12 +1372,6 @@ tree_complete_unroll_inner (void)\n   return ret;\n }\n \n-static bool\n-gate_tree_complete_unroll_inner (void)\n-{\n-  return optimize >= 2;\n-}\n-\n namespace {\n \n const pass_data pass_data_complete_unrolli =\n@@ -1415,7 +1396,7 @@ class pass_complete_unrolli : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_complete_unroll_inner (); }\n+  virtual bool gate (function *) { return optimize >= 2; }\n   unsigned int execute () { return tree_complete_unroll_inner (); }\n \n }; // class pass_complete_unrolli"}, {"sha": "17b13d11d71cb3d7b888a6beddba698be4ac48e8", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2013,12 +2013,6 @@ tree_ssa_loop_prefetch (void)\n   return tree_ssa_prefetch_arrays ();\n }\n \n-static bool\n-gate_tree_ssa_loop_prefetch (void)\n-{\n-  return flag_prefetch_loop_arrays > 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_loop_prefetch =\n@@ -2043,7 +2037,7 @@ class pass_loop_prefetch : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_ssa_loop_prefetch (); }\n+  virtual bool gate (function *) { return flag_prefetch_loop_arrays > 0; }\n   unsigned int execute () { return tree_ssa_loop_prefetch (); }\n \n }; // class pass_loop_prefetch"}, {"sha": "90bb205a5a6b2ed1861b9bea9a51d1c166bee5ca", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -411,12 +411,6 @@ tree_ssa_loop_unswitch (void)\n   return tree_ssa_unswitch_loops ();\n }\n \n-static bool\n-gate_tree_ssa_loop_unswitch (void)\n-{\n-  return flag_unswitch_loops != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_tree_unswitch =\n@@ -441,7 +435,7 @@ class pass_tree_unswitch : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_ssa_loop_unswitch (); }\n+  virtual bool gate (function *) { return flag_unswitch_loops != 0; }\n   unsigned int execute () { return tree_ssa_loop_unswitch (); }\n \n }; // class pass_tree_unswitch"}, {"sha": "38e7b13575c7a33b733a43d9b479f40131cdff97", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -44,12 +44,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* The loop superpass.  */\n \n-static bool\n-gate_tree_loop (void)\n-{\n-  return flag_tree_loop_optimize != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_tree_loop =\n@@ -74,7 +68,7 @@ class pass_tree_loop : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_loop (); }\n+  virtual bool gate (function *) { return flag_tree_loop_optimize != 0; }\n \n }; // class pass_tree_loop\n \n@@ -152,12 +146,6 @@ tree_loop_vectorize (void)\n   return vectorize_loops ();\n }\n \n-static bool\n-gate_tree_loop_vectorize (void)\n-{\n-  return flag_tree_loop_vectorize || cfun->has_force_vectorize_loops;\n-}\n-\n namespace {\n \n const pass_data pass_data_vectorize =\n@@ -182,7 +170,11 @@ class pass_vectorize : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_loop_vectorize (); }\n+  virtual bool gate (function *fun)\n+    {\n+      return flag_tree_loop_vectorize || fun->has_force_vectorize_loops;\n+    }\n+\n   unsigned int execute () { return tree_loop_vectorize (); }\n \n }; // class pass_vectorize\n@@ -207,12 +199,6 @@ check_data_deps (void)\n   return 0;\n }\n \n-static bool\n-gate_check_data_deps (void)\n-{\n-  return flag_check_data_deps != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_check_data_deps =\n@@ -237,7 +223,7 @@ class pass_check_data_deps : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_check_data_deps (); }\n+  virtual bool gate (function *) { return flag_check_data_deps != 0; }\n   unsigned int execute () { return check_data_deps (); }\n \n }; // class pass_check_data_deps\n@@ -252,12 +238,6 @@ make_pass_check_data_deps (gcc::context *ctxt)\n \n /* Propagation of constants using scev.  */\n \n-static bool\n-gate_scev_const_prop (void)\n-{\n-  return flag_tree_scev_cprop;\n-}\n-\n namespace {\n \n const pass_data pass_data_scev_cprop =\n@@ -283,7 +263,7 @@ class pass_scev_cprop : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_scev_const_prop (); }\n+  virtual bool gate (function *) { return flag_tree_scev_cprop; }\n   unsigned int execute () { return scev_const_prop (); }\n \n }; // class pass_scev_cprop\n@@ -357,12 +337,6 @@ tree_ssa_loop_ivopts (void)\n   return 0;\n }\n \n-static bool\n-gate_tree_ssa_loop_ivopts (void)\n-{\n-  return flag_ivopts != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_iv_optimize =\n@@ -387,7 +361,7 @@ class pass_iv_optimize : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_ssa_loop_ivopts (); }\n+  virtual bool gate (function *) { return flag_ivopts != 0; }\n   unsigned int execute () { return tree_ssa_loop_ivopts (); }\n \n }; // class pass_iv_optimize"}, {"sha": "fef1b1e659860a8c435bd6450a821c40f3eade20", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -504,12 +504,6 @@ execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)\n   occ_head = NULL;\n }\n \n-static bool\n-gate_cse_reciprocals (void)\n-{\n-  return optimize && flag_reciprocal_math;\n-}\n-\n /* Go through all the floating-point SSA_NAMEs, and call\n    execute_cse_reciprocals_1 on each of them.  */\n static unsigned int\n@@ -678,7 +672,7 @@ class pass_cse_reciprocals : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_cse_reciprocals (); }\n+  virtual bool gate (function *) { return optimize && flag_reciprocal_math; }\n   unsigned int execute () { return execute_cse_reciprocals (); }\n \n }; // class pass_cse_reciprocals\n@@ -1562,14 +1556,6 @@ execute_cse_sincos (void)\n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }\n \n-static bool\n-gate_cse_sincos (void)\n-{\n-  /* We no longer require either sincos or cexp, since powi expansion\n-     piggybacks on this pass.  */\n-  return optimize;\n-}\n-\n namespace {\n \n const pass_data pass_data_cse_sincos =\n@@ -1595,7 +1581,13 @@ class pass_cse_sincos : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_cse_sincos (); }\n+  virtual bool gate (function *)\n+    {\n+      /* We no longer require either sincos or cexp, since powi expansion\n+\t piggybacks on this pass.  */\n+      return optimize;\n+    }\n+\n   unsigned int execute () { return execute_cse_sincos (); }\n \n }; // class pass_cse_sincos\n@@ -2065,12 +2057,6 @@ execute_optimize_bswap (void)\n \t  | TODO_verify_stmts : 0);\n }\n \n-static bool\n-gate_optimize_bswap (void)\n-{\n-  return flag_expensive_optimizations && optimize;\n-}\n-\n namespace {\n \n const pass_data pass_data_optimize_bswap =\n@@ -2095,7 +2081,11 @@ class pass_optimize_bswap : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_optimize_bswap (); }\n+  virtual bool gate (function *)\n+    {\n+      return flag_expensive_optimizations && optimize;\n+    }\n+\n   unsigned int execute () { return execute_optimize_bswap (); }\n \n }; // class pass_optimize_bswap\n@@ -2874,12 +2864,6 @@ execute_optimize_widening_mul (void)\n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }\n \n-static bool\n-gate_optimize_widening_mul (void)\n-{\n-  return flag_expensive_optimizations && optimize;\n-}\n-\n namespace {\n \n const pass_data pass_data_optimize_widening_mul =\n@@ -2905,7 +2889,11 @@ class pass_optimize_widening_mul : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_optimize_widening_mul (); }\n+  virtual bool gate (function *)\n+    {\n+      return flag_expensive_optimizations && optimize;\n+    }\n+\n   unsigned int execute () { return execute_optimize_widening_mul (); }\n \n }; // class pass_optimize_widening_mul"}, {"sha": "1ee39a5444203cea24fbbfece3d2d555b4284d3c", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2202,11 +2202,6 @@ gate_hoist_loads (void)\n \n /* Always do these optimizations if we have SSA\n    trees to work on.  */\n-static bool\n-gate_phiopt (void)\n-{\n-  return 1;\n-}\n \n namespace {\n \n@@ -2234,7 +2229,6 @@ class pass_phiopt : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_phiopt (m_ctxt); }\n-  bool gate () { return gate_phiopt (); }\n   unsigned int execute () { return tree_ssa_phiopt (); }\n \n }; // class pass_phiopt\n@@ -2247,12 +2241,6 @@ make_pass_phiopt (gcc::context *ctxt)\n   return new pass_phiopt (ctxt);\n }\n \n-static bool\n-gate_cselim (void)\n-{\n-  return flag_tree_cselim;\n-}\n-\n namespace {\n \n const pass_data pass_data_cselim =\n@@ -2278,7 +2266,7 @@ class pass_cselim : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_cselim (); }\n+  virtual bool gate (function *) { return flag_tree_cselim; }\n   unsigned int execute () { return tree_ssa_cs_elim (); }\n \n }; // class pass_cselim"}, {"sha": "cbdbc6ea4295173d0ae7814520bb8086514568b3", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -409,12 +409,6 @@ tree_ssa_phiprop (void)\n   return 0;\n }\n \n-static bool\n-gate_phiprop (void)\n-{\n-  return flag_tree_phiprop;\n-}\n-\n namespace {\n \n const pass_data pass_data_phiprop =\n@@ -439,7 +433,7 @@ class pass_phiprop : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_phiprop (); }\n+  virtual bool gate (function *) { return flag_tree_phiprop; }\n   unsigned int execute () { return tree_ssa_phiprop (); }\n \n }; // class pass_phiprop"}, {"sha": "cda315a63792df6e2022c6f60147a94f695a58fd", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -4771,12 +4771,6 @@ do_pre (void)\n   return todo;\n }\n \n-static bool\n-gate_pre (void)\n-{\n-  return flag_tree_pre != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_pre =\n@@ -4803,7 +4797,7 @@ class pass_pre : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_pre (); }\n+  virtual bool gate (function *) { return flag_tree_pre != 0; }\n   unsigned int execute () { return do_pre (); }\n \n }; // class pass_pre\n@@ -4842,12 +4836,6 @@ execute_fre (void)\n   return todo;\n }\n \n-static bool\n-gate_fre (void)\n-{\n-  return flag_tree_fre != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_fre =\n@@ -4873,7 +4861,7 @@ class pass_fre : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_fre (m_ctxt); }\n-  bool gate () { return gate_fre (); }\n+  virtual bool gate (function *) { return flag_tree_fre != 0; }\n   unsigned int execute () { return execute_fre (); }\n \n }; // class pass_fre"}, {"sha": "57f260775d719293bb5d0b5a9c04023f33a3a55b", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -4694,12 +4694,6 @@ execute_reassoc (void)\n   return 0;\n }\n \n-static bool\n-gate_tree_ssa_reassoc (void)\n-{\n-  return flag_tree_reassoc != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_reassoc =\n@@ -4727,7 +4721,7 @@ class pass_reassoc : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_reassoc (m_ctxt); }\n-  bool gate () { return gate_tree_ssa_reassoc (); }\n+  virtual bool gate (function *) { return flag_tree_reassoc != 0; }\n   unsigned int execute () { return execute_reassoc (); }\n \n }; // class pass_reassoc"}, {"sha": "6803160ff7744aead6e859d521bfd50f54c18beb", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -588,12 +588,6 @@ do_sink (void)\n   return 0;\n }\n \n-static bool\n-gate_sink (void)\n-{\n-  return flag_tree_sink != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_sink_code =\n@@ -621,7 +615,7 @@ class pass_sink_code : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_sink (); }\n+  virtual bool gate (function *) { return flag_tree_sink != 0; }\n   unsigned int execute () { return do_sink (); }\n \n }; // class pass_sink_code"}, {"sha": "fb83093cca5aed077c11a88e5274d814c191bcda", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2089,12 +2089,6 @@ tree_ssa_strlen (void)\n   return 0;\n }\n \n-static bool\n-gate_strlen (void)\n-{\n-  return flag_optimize_strlen != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_strlen =\n@@ -2119,7 +2113,7 @@ class pass_strlen : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_strlen (); }\n+  virtual bool gate (function *) { return flag_optimize_strlen != 0; }\n   unsigned int execute () { return tree_ssa_strlen (); }\n \n }; // class pass_strlen"}, {"sha": "3548ac544b77f27adca85437a6a0047a1ad687be", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -6989,12 +6989,6 @@ compute_may_aliases (void)\n   return 0;\n }\n \n-static bool\n-gate_tree_pta (void)\n-{\n-  return flag_tree_pta;\n-}\n-\n /* A dummy pass to cause points-to information to be computed via\n    TODO_rebuild_alias.  */\n \n@@ -7022,7 +7016,7 @@ class pass_build_alias : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_pta (); }\n+  virtual bool gate (function *) { return flag_tree_pta; }\n \n }; // class pass_build_alias\n \n@@ -7061,7 +7055,7 @@ class pass_build_ealias : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_pta (); }\n+  virtual bool gate (function *) { return flag_tree_pta; }\n \n }; // class pass_build_ealias\n \n@@ -7074,16 +7068,6 @@ make_pass_build_ealias (gcc::context *ctxt)\n }\n \n \n-/* Return true if we should execute IPA PTA.  */\n-static bool\n-gate_ipa_pta (void)\n-{\n-  return (optimize\n-\t  && flag_ipa_pta\n-\t  /* Don't bother doing anything if the program has errors.  */\n-\t  && !seen_error ());\n-}\n-\n /* IPA PTA solutions for ESCAPED.  */\n struct pt_solution ipa_escaped_pt\n   = { true, false, false, false, false, false, false, false, NULL };\n@@ -7452,7 +7436,14 @@ class pass_ipa_pta : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ipa_pta (); }\n+  virtual bool gate (function *)\n+    {\n+      return (optimize\n+\t      && flag_ipa_pta\n+\t      /* Don't bother doing anything if the program has errors.  */\n+\t      && !seen_error ());\n+    }\n+\n   unsigned int execute () { return ipa_pta_execute (); }\n \n }; // class pass_ipa_pta"}, {"sha": "e39ce8898136ded85fc86f566c6f43f9b8100912", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -581,12 +581,6 @@ uncprop_dom_walker::before_dom_children (basic_block bb)\n   uncprop_into_successor_phis (bb);\n }\n \n-static bool\n-gate_uncprop (void)\n-{\n-  return flag_tree_dom != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_uncprop =\n@@ -612,7 +606,7 @@ class pass_uncprop : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_uncprop (m_ctxt); }\n-  bool gate () { return gate_uncprop (); }\n+  virtual bool gate (function *) { return flag_tree_dom != 0; }\n   unsigned int execute () { return tree_ssa_uncprop (); }\n \n }; // class pass_uncprop"}, {"sha": "89acd9b6b4b2debe892991501aeb0bbaa5e3bf99", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -2382,7 +2382,7 @@ class pass_late_warn_uninitialized : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_late_warn_uninitialized (m_ctxt); }\n-  bool gate () { return gate_warn_uninitialized (); }\n+  virtual bool gate (function *) { return gate_warn_uninitialized (); }\n   unsigned int execute () { return execute_late_warn_uninitialized (); }\n \n }; // class pass_late_warn_uninitialized\n@@ -2440,7 +2440,7 @@ class pass_early_warn_uninitialized : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_warn_uninitialized (); }\n+  virtual bool gate (function *) { return gate_warn_uninitialized (); }\n   unsigned int execute () { return execute_early_warn_uninitialized (); }\n \n }; // class pass_early_warn_uninitialized"}, {"sha": "52126ca07105e47b160b43a571f7e9c1e956a917", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1139,15 +1139,6 @@ execute_init_datastructures (void)\n   return 0;\n }\n \n-/* Gate for IPCP optimization.  */\n-\n-static bool\n-gate_init_datastructures (void)\n-{\n-  /* Do nothing for funcions that was produced already in SSA form.  */\n-  return !(cfun->curr_properties & PROP_ssa);\n-}\n-\n namespace {\n \n const pass_data pass_data_init_datastructures =\n@@ -1172,7 +1163,12 @@ class pass_init_datastructures : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_init_datastructures (); }\n+  virtual bool gate (function *fun)\n+    {\n+      /* Do nothing for funcions that was produced already in SSA form.  */\n+      return !(fun->curr_properties & PROP_ssa);\n+    }\n+\n   unsigned int execute () { return execute_init_datastructures (); }\n \n }; // class pass_init_datastructures"}, {"sha": "710711bcda6a9abdd13a32e4b3646cd89a31f926", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -663,18 +663,6 @@ check_all_va_list_escapes (struct stdarg_info *si)\n   return false;\n }\n \n-\n-/* Return true if this optimization pass should be done.\n-   It makes only sense for stdarg functions.  */\n-\n-static bool\n-gate_optimize_stdarg (void)\n-{\n-  /* This optimization is only for stdarg functions.  */\n-  return cfun->stdarg != 0;\n-}\n-\n-\n /* Entry point to the stdarg optimization pass.  */\n \n static unsigned int\n@@ -1023,7 +1011,12 @@ class pass_stdarg : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_optimize_stdarg (); }\n+  virtual bool gate (function *fun)\n+    {\n+      /* This optimization is only for stdarg functions.  */\n+      return fun->stdarg != 0;\n+    }\n+\n   unsigned int execute () { return execute_optimize_stdarg (); }\n \n }; // class pass_stdarg"}, {"sha": "a0f9d19c073700b60582229146023ed6f83a8390", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1465,14 +1465,6 @@ do_switchconv (void)\n   return 0;\n }\n \n-/* The pass gate. */\n-\n-static bool\n-switchconv_gate (void)\n-{\n-  return flag_tree_switch_conversion != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_convert_switch =\n@@ -1499,7 +1491,7 @@ class pass_convert_switch : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return switchconv_gate (); }\n+  virtual bool gate (function *) { return flag_tree_switch_conversion != 0; }\n   unsigned int execute () { return do_switchconv (); }\n \n }; // class pass_convert_switch"}, {"sha": "84cdbde94118c1fda484a4e1c9fc95d8be19e7e6", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1108,7 +1108,7 @@ class pass_tail_recursion : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_tail_recursion (m_ctxt); }\n-  bool gate () { return gate_tail_calls (); }\n+  virtual bool gate (function *) { return gate_tail_calls (); }\n   unsigned int execute () { return execute_tail_recursion (); }\n \n }; // class pass_tail_recursion\n@@ -1145,7 +1145,7 @@ class pass_tail_calls : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tail_calls (); }\n+  virtual bool gate (function *) { return gate_tail_calls (); }\n   unsigned int execute () { return execute_tail_calls (); }\n \n }; // class pass_tail_calls"}, {"sha": "4274417bd6b2c4bb14998c134f2e0ca006ec9e16", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -1528,12 +1528,6 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n /* Use this to lower vector operations introduced by the vectorizer,\n    if it may need the bit-twiddling tricks implemented in this file.  */\n \n-static bool\n-gate_expand_vector_operations_ssa (void)\n-{\n-  return !(cfun->curr_properties & PROP_gimple_lvec);\n-}\n-\n static unsigned int\n expand_vector_operations (void)\n {\n@@ -1586,7 +1580,11 @@ class pass_lower_vector : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_expand_vector_operations_ssa (); }\n+  virtual bool gate (function *fun)\n+    {\n+      return !(fun->curr_properties & PROP_gimple_lvec);\n+    }\n+\n   unsigned int execute () { return expand_vector_operations (); }\n \n }; // class pass_lower_vector"}, {"sha": "7b5691a3464adae77c18a215812f77275c21bd84", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -613,12 +613,6 @@ execute_vect_slp (void)\n   return 0;\n }\n \n-static bool\n-gate_vect_slp (void)\n-{\n-  return flag_tree_slp_vectorize != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_slp_vectorize =\n@@ -644,7 +638,7 @@ class pass_slp_vectorize : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_vect_slp (); }\n+  virtual bool gate (function *) { return flag_tree_slp_vectorize != 0; }\n   unsigned int execute () { return execute_vect_slp (); }\n \n }; // class pass_slp_vectorize\n@@ -702,13 +696,6 @@ increase_alignment (void)\n }\n \n \n-static bool\n-gate_increase_alignment (void)\n-{\n-  return flag_section_anchors && flag_tree_loop_vectorize;\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_ipa_increase_alignment =\n@@ -733,7 +720,11 @@ class pass_ipa_increase_alignment : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_increase_alignment (); }\n+  virtual bool gate (function *)\n+    {\n+      return flag_section_anchors && flag_tree_loop_vectorize;\n+    }\n+\n   unsigned int execute () { return increase_alignment (); }\n \n }; // class pass_ipa_increase_alignment"}, {"sha": "80f3888c1065dbec548413001d2a6e526da2f237", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -9894,12 +9894,6 @@ execute_vrp (void)\n   return 0;\n }\n \n-static bool\n-gate_vrp (void)\n-{\n-  return flag_tree_vrp != 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_vrp =\n@@ -9927,7 +9921,7 @@ class pass_vrp : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_vrp (m_ctxt); }\n-  bool gate () { return gate_vrp (); }\n+  virtual bool gate (function *) { return flag_tree_vrp != 0; }\n   unsigned int execute () { return execute_vrp (); }\n \n }; // class pass_vrp"}, {"sha": "b413bb50edd28caae2eeb74e542673ff53f799d9", "filename": "gcc/tsan.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -715,14 +715,6 @@ tsan_pass (void)\n   return 0;\n }\n \n-/* The pass's gate.  */\n-\n-static bool\n-tsan_gate (void)\n-{\n-  return (flag_sanitize & SANITIZE_THREAD) != 0;\n-}\n-\n /* Inserts __tsan_init () into the list of CTORs.  */\n \n void\n@@ -765,7 +757,11 @@ class pass_tsan : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_tsan (m_ctxt); }\n-  bool gate () { return tsan_gate (); }\n+  virtual bool gate (function *)\n+{\n+  return (flag_sanitize & SANITIZE_THREAD) != 0;\n+}\n+\n   unsigned int execute () { return tsan_pass (); }\n \n }; // class pass_tsan\n@@ -778,12 +774,6 @@ make_pass_tsan (gcc::context *ctxt)\n   return new pass_tsan (ctxt);\n }\n \n-static bool\n-tsan_gate_O0 (void)\n-{\n-  return (flag_sanitize & SANITIZE_THREAD) != 0 && !optimize;\n-}\n-\n namespace {\n \n const pass_data pass_data_tsan_O0 =\n@@ -808,7 +798,11 @@ class pass_tsan_O0 : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return tsan_gate_O0 (); }\n+  virtual bool gate (function *)\n+    {\n+      return (flag_sanitize & SANITIZE_THREAD) != 0 && !optimize;\n+    }\n+\n   unsigned int execute () { return tsan_pass (); }\n \n }; // class pass_tsan_O0"}, {"sha": "8e7dda54efeae8c72d29e46eec5a0e92ac293b56", "filename": "gcc/ubsan.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -902,13 +902,6 @@ ubsan_pass (void)\n   return 0;\n }\n \n-static bool\n-gate_ubsan (void)\n-{\n-  return flag_sanitize & (SANITIZE_NULL | SANITIZE_SI_OVERFLOW\n-\t\t\t  | SANITIZE_BOOL | SANITIZE_ENUM);\n-}\n-\n namespace {\n \n const pass_data pass_data_ubsan =\n@@ -933,7 +926,12 @@ class pass_ubsan : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_ubsan (); }\n+  virtual bool gate (function *)\n+    {\n+      return flag_sanitize & (SANITIZE_NULL | SANITIZE_SI_OVERFLOW\n+\t\t\t      | SANITIZE_BOOL | SANITIZE_ENUM);\n+    }\n+\n   unsigned int execute () { return ubsan_pass (); }\n \n }; // class pass_ubsan"}, {"sha": "4586afc4b208d765b4449a3505750fe2de98834f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -10344,14 +10344,6 @@ variable_tracking_main (void)\n   return ret;\n }\n \f\n-static bool\n-gate_handle_var_tracking (void)\n-{\n-  return (flag_var_tracking && !targetm.delay_vartrack);\n-}\n-\n-\n-\n namespace {\n \n const pass_data pass_data_variable_tracking =\n@@ -10376,7 +10368,11 @@ class pass_variable_tracking : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_var_tracking (); }\n+  virtual bool gate (function *)\n+    {\n+      return (flag_var_tracking && !targetm.delay_vartrack);\n+    }\n+\n   unsigned int execute () { return variable_tracking_main (); }\n \n }; // class pass_variable_tracking"}, {"sha": "601b2ced8dd838b2cc86a00898845359251a9a2f", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -740,14 +740,6 @@ vtable_verify_main (void)\n   return ret;\n }\n \n-/* Gate function for the pass.  */\n-\n-static bool\n-gate_tree_vtable_verify (void)\n-{\n-  return (flag_vtable_verify);\n-}\n-\n /* Definition of this optimization pass.  */\n \n namespace {\n@@ -774,7 +766,7 @@ class pass_vtable_verify : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_tree_vtable_verify (); }\n+  virtual bool gate (function *) { return (flag_vtable_verify); }\n   unsigned int execute () { return vtable_verify_main (); }\n \n }; // class pass_vtable_verify"}, {"sha": "50fc9e6b920acb987cf508fcdc90e7a60a92d87c", "filename": "gcc/web.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3d085cf2a0caa5daef7c0443b1d280bcef295e/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "patch": "@@ -325,12 +325,6 @@ replace_ref (df_ref ref, rtx reg)\n }\n \n \f\n-static bool\n-gate_handle_web (void)\n-{\n-  return (optimize > 0 && flag_web);\n-}\n-\n /* Main entry point.  */\n \n static unsigned int\n@@ -473,7 +467,7 @@ class pass_web : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  bool gate () { return gate_handle_web (); }\n+  virtual bool gate (function *) { return (optimize > 0 && flag_web); }\n   unsigned int execute () { return web_main (); }\n \n }; // class pass_web"}]}