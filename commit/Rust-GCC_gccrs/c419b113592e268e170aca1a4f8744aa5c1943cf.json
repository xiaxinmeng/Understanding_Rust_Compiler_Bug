{"sha": "c419b113592e268e170aca1a4f8744aa5c1943cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQxOWIxMTM1OTJlMjY4ZTE3MGFjYTFhNGY4NzQ0YWE1YzE5NDNjZg==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2003-03-31T20:02:40Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2003-03-31T20:02:40Z"}, "message": "cpppch.c (struct cpp_savedstate): Add defs and n_defs members.\n\n\t* cpppch.c (struct cpp_savedstate): Add defs and n_defs members.\n\t(count_defs): Keep track of number of defs as well as total size.\n\t(write_defs): Put every definition in cpp_savedstate's defs array.\n\t(comp_hashnode): Define.  Comparison function for qsort.\n\t(cpp_write_pch_deps): Sort definitions before writing them.\n\t(struct ht_node_list): Define. Like cpp_savedstate but simpler.\n\t(collect_ht_nodes): Define.\n\t(cpp_valid_state): When verifying that undefined identifiers in\n\tthe pch file are still undefined, read a sorted list of undefined\n\tidentifiers, collect all defined identifiers into a sorted list,\n\tand walk through both lists to make sure there's no match.\n\nFrom-SVN: r65101", "tree": {"sha": "f5fde18897a92ccbc7a569c6676d223f956f3a67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5fde18897a92ccbc7a569c6676d223f956f3a67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c419b113592e268e170aca1a4f8744aa5c1943cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c419b113592e268e170aca1a4f8744aa5c1943cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c419b113592e268e170aca1a4f8744aa5c1943cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c419b113592e268e170aca1a4f8744aa5c1943cf/comments", "author": null, "committer": null, "parents": [{"sha": "ef3a7d56e900e4e4d6d97d025a368fd7075db4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3a7d56e900e4e4d6d97d025a368fd7075db4e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3a7d56e900e4e4d6d97d025a368fd7075db4e6"}], "stats": {"total": 152, "additions": 126, "deletions": 26}, "files": [{"sha": "076192bc5d30ad11049b5006647fe55ba73a1526", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c419b113592e268e170aca1a4f8744aa5c1943cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c419b113592e268e170aca1a4f8744aa5c1943cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c419b113592e268e170aca1a4f8744aa5c1943cf", "patch": "@@ -1,3 +1,17 @@\n+2003-03-31  Matt Austern  <austern@apple.com>\n+\n+\t* cpppch.c (struct cpp_savedstate): Add defs and n_defs members.\n+\t(count_defs): Keep track of number of defs as well as total size.\n+\t(write_defs): Put every definition in cpp_savedstate's defs array.\n+\t(comp_hashnode): Define.  Comparison function for qsort.\n+\t(cpp_write_pch_deps): Sort definitions before writing them.\n+\t(struct ht_node_list): Define. Like cpp_savedstate but simpler.\n+\t(collect_ht_nodes): Define.\n+\t(cpp_valid_state): When verifying that undefined identifiers in\n+\tthe pch file are still undefined, read a sorted list of undefined\n+\tidentifiers, collect all defined identifiers into a sorted list,\n+\tand walk through both lists to make sure there's no match.\n+\t\n 2003-03-31  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (a peephole2): New."}, {"sha": "0ee04ea2024208d612c7bcb5d6c43fe9bdbf65e0", "filename": "gcc/cpppch.c", "status": "modified", "additions": 112, "deletions": 26, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c419b113592e268e170aca1a4f8744aa5c1943cf/gcc%2Fcpppch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c419b113592e268e170aca1a4f8744aa5c1943cf/gcc%2Fcpppch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpppch.c?ref=c419b113592e268e170aca1a4f8744aa5c1943cf", "patch": "@@ -30,6 +30,8 @@ static hashval_t hashmem PARAMS ((const void *, size_t));\n static hashval_t cpp_string_hash PARAMS ((const void *));\n static int cpp_string_eq PARAMS ((const void *, const void *));\n static int count_defs PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static int comp_hashnodes PARAMS ((const void *, const void *));\n+static int collect_ht_nodes PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n static int write_defs PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n static int save_macros PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n static int reset_ht PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n@@ -109,6 +111,10 @@ struct cpp_savedstate\n   /* The size of the definitions of those identifiers (the size of\n      'definedstrs').  */\n   size_t hashsize;\n+  /* Number of definitions */\n+  size_t n_defs;\n+  /* Array of definitions.  In cpp_write_pch_deps it is used for sorting. */\n+  cpp_hashnode **defs;\n   /* Space for the next definition.  Definitions are null-terminated\n      strings.  */\n   unsigned char *definedstrs;\n@@ -239,7 +245,10 @@ count_defs (pfile, hn, ss_p)\n \tnews.text = NODE_NAME (hn);\n \tslot = htab_find (ss->definedhash, &news);\n \tif (slot == NULL)\n-\t  ss->hashsize += NODE_LEN (hn) + 1;\n+\t  {\n+\t    ss->hashsize += NODE_LEN (hn) + 1;\n+\t    ss->n_defs += 1;\n+\t  }\n       }\n       return 1;\n \n@@ -252,8 +261,7 @@ count_defs (pfile, hn, ss_p)\n     }\n }\n \n-/* Write the identifiers into 'definedstrs' of the state.  */\n-\n+/* Collect the identifiers into the state's string table. */\n static int\n write_defs (pfile, hn, ss_p)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n@@ -280,9 +288,8 @@ write_defs (pfile, hn, ss_p)\n \tslot = htab_find (ss->definedhash, &news);\n \tif (slot == NULL)\n \t  {\n-\t    memcpy (ss->definedstrs, NODE_NAME (hn), NODE_LEN (hn));\n-\t    ss->definedstrs[NODE_LEN (hn)] = 0;\n-\t    ss->definedstrs += NODE_LEN (hn) + 1;\n+\t    ss->defs[ss->n_defs] = hn;\n+\t    ss->n_defs += 1;\n \t  }\n       }\n       return 1;\n@@ -296,6 +303,18 @@ write_defs (pfile, hn, ss_p)\n     }\n }\n \n+/* Comparison function for qsort.  The arguments point to pointers of\n+   type ht_hashnode *.  */\n+static int\n+comp_hashnodes (px, py)\n+     const void *px;\n+     const void *py;\n+{\n+  cpp_hashnode *x = *(cpp_hashnode **) px;\n+  cpp_hashnode *y = *(cpp_hashnode **) py;\n+  return ustrcmp (NODE_NAME (x), NODE_NAME (y));\n+}\n+\n /* Write out the remainder of the dependency information.  This should be\n    called after the PCH is ready to be saved.  */\n \n@@ -307,23 +326,37 @@ cpp_write_pch_deps (r, f)\n   struct macrodef_struct z;\n   struct cpp_savedstate *const ss = r->savedstate;\n   unsigned char *definedstrs;\n+  size_t i;\n   \n-  ss->hashsize = 0;\n-  \n-  /* Write out the list of identifiers which have been seen and\n+  /* Collect the list of identifiers which have been seen and\n      weren't defined to anything previously.  */\n+  ss->hashsize = 0;\n+  ss->n_defs = 0;\n   cpp_forall_identifiers (r, count_defs, ss);\n-  definedstrs = ss->definedstrs = xmalloc (ss->hashsize);\n+\n+  ss->defs = xmalloc (ss->n_defs * sizeof (cpp_hashnode *));\n+  ss->n_defs = 0;\n   cpp_forall_identifiers (r, write_defs, ss);\n+\n+  /* Sort the list, copy it into a buffer, and write it out. */\n+  qsort (ss->defs, ss->n_defs, sizeof (cpp_hashnode *), &comp_hashnodes);\n+  definedstrs = ss->definedstrs = xmalloc (ss->hashsize);\n+  for (i = 0; i < ss->n_defs; ++i)\n+    {\n+      size_t len = NODE_LEN (ss->defs[i]);\n+      memcpy (definedstrs, NODE_NAME (ss->defs[i]), len + 1);\n+      definedstrs += len + 1;\n+    }\n+\n   memset (&z, 0, sizeof (z));\n   z.definition_length = ss->hashsize;\n   if (fwrite (&z, sizeof (z), 1, f) != 1\n-      || fwrite (definedstrs, ss->hashsize, 1, f) != 1)\n+      || fwrite (ss->definedstrs, ss->hashsize, 1, f) != 1)\n     {\n       cpp_errno (r, DL_ERROR, \"while writing precompiled header\");\n       return -1;\n     }\n-  free (definedstrs);\n+  free (ss->definedstrs);\n \n   /* Free the saved state.  */\n   free (ss);\n@@ -362,6 +395,44 @@ cpp_write_pch_state (r, f)\n   return 0;\n }\n \n+\n+/* Data structure to transform hash table nodes into a sorted list */\n+\n+struct ht_node_list\n+{\n+  /* Array of nodes */\n+  cpp_hashnode **defs;\n+  /* Number of nodes in the array */\n+  size_t n_defs;\n+  /* Size of the allocated array */\n+  size_t asize;\n+};\n+\n+/* Callback for collecting identifiers from hash table */\n+\n+static int\n+collect_ht_nodes (pfile, hn, nl_p)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_hashnode *hn;\n+     void *nl_p;\n+{\n+  struct ht_node_list *const nl = (struct ht_node_list *)nl_p;\n+\n+  if (hn->type != NT_VOID || hn->flags & NODE_POISONED)\n+    {\n+      if (nl->n_defs == nl->asize)\n+        {\n+          nl->asize *= 2;\n+          nl->defs = xrealloc (nl->defs, nl->asize * sizeof (cpp_hashnode *));\n+        }\n+\n+      nl->defs[nl->n_defs] = hn;\n+      ++nl->n_defs;\n+    }\n+  return 1;\n+}\n+\n+\n /* Return nonzero if FD is a precompiled header which is consistent\n    with the preprocessor's current definitions.  It will be consistent\n    when:\n@@ -385,6 +456,8 @@ cpp_valid_state (r, name, fd)\n   size_t namebufsz = 256;\n   unsigned char *namebuf = xmalloc (namebufsz);\n   unsigned char *undeftab = NULL;\n+  struct ht_node_list nl;\n+  unsigned char *first, *last;\n   unsigned int i;\n   \n   /* Read in the list of identifiers that must be defined\n@@ -445,22 +518,33 @@ cpp_valid_state (r, name, fd)\n   undeftab = xmalloc (m.definition_length);\n   if ((size_t) read (fd, undeftab, m.definition_length) != m.definition_length)\n     goto error;\n-  for (i = 0; i < m.definition_length; )\n+\n+  /* Collect identifiers from the current hash table.  */\n+  nl.n_defs = 0;\n+  nl.asize = 10;\n+  nl.defs = xmalloc (nl.asize * sizeof (cpp_hashnode *));\n+  cpp_forall_identifiers (r, &collect_ht_nodes, &nl);\n+  qsort (nl.defs, nl.n_defs, sizeof (cpp_hashnode *), &comp_hashnodes);\n+ \n+  /* Loop through nl.defs and undeftab, both of which are sorted lists.\n+     There should be no matches. */\n+  first = undeftab;\n+  last = undeftab + m.definition_length;\n+  i = 0;\n+ \n+  while (first < last && i < nl.n_defs)\n     {\n-      int l = ustrlen (undeftab + i);\n-      cpp_hashnode *h;\n-      h = cpp_lookup (r, undeftab + i, l);\n-      if (h->type != NT_VOID\n-\t  || h->flags & NODE_POISONED)\n-\t{\n-\t  if (CPP_OPTION (r, warn_invalid_pch))\n-\t    cpp_error (r, DL_WARNING_SYSHDR, \n-\t\t       \"%s: not used because `%s' is defined\",\n-\t\t       name, undeftab + i);\n-\t  goto fail;\n-\t}\n-      i += l + 1;\n+      int cmp = ustrcmp (first, NODE_NAME (nl.defs[i]));\n+ \n+      if (cmp < 0)\n+ \tfirst += ustrlen (first) + 1;\n+      else if (cmp > 0)\n+ \t++i;\n+      else\n+\tgoto fail;\n     }\n+   \n+  free(nl.defs);\n   free (undeftab);\n \n   /* We win!  */\n@@ -475,6 +559,8 @@ cpp_valid_state (r, name, fd)\n     free (namebuf);\n   if (undeftab != NULL)\n     free (undeftab);\n+  if (nl.defs != NULL)\n+    free (nl.defs);\n   return 1;\n }\n "}]}