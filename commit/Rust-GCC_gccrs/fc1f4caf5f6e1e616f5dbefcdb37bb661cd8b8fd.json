{"sha": "fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxZjRjYWY1ZjZlMWU2MTZmNWRiZWZjZGIzN2JiNjYxY2Q4YjhmZA==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-10-14T19:30:42Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-10-14T19:30:42Z"}, "message": "gimplify.c (gimplify_expr): Take care that for bitwise-binary transformation the operands have compatible types.\n\n        * gimplify.c (gimplify_expr): Take care that for bitwise-binary\n        transformation the operands have compatible types.\n\n\t* gfortran.fortran-torture/compile/logical-2.f90: New test.\n\nFrom-SVN: r180006", "tree": {"sha": "698b6ce8800d81c73e13932058f99a12e5693a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/698b6ce8800d81c73e13932058f99a12e5693a1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/comments", "author": null, "committer": null, "parents": [{"sha": "1c4153dd029bb2c325eb2232b123abf940537178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4153dd029bb2c325eb2232b123abf940537178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c4153dd029bb2c325eb2232b123abf940537178"}], "stats": {"total": 36, "additions": 34, "deletions": 2}, "files": [{"sha": "ef5faf1790ca37089ab514b8665ed5b511f21482", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "patch": "@@ -1,3 +1,8 @@\n+2011-10-14  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* gimplify.c (gimplify_expr): Take care that for bitwise-binary\n+\ttransformation the operands have compatible types.\n+\n 2011-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/sse.md (vec_widen_smult_hi_v8hi,"}, {"sha": "8c2c5ac2c9c01e92efa3f2c51e283bacd727162f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "patch": "@@ -7256,8 +7256,10 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase TRUTH_XOR_EXPR:\n \t  {\n \t    tree orig_type = TREE_TYPE (*expr_p);\n+\t    tree new_type, xop0, xop1;\n \t    *expr_p = gimple_boolify (*expr_p);\n-\t    if (!useless_type_conversion_p (orig_type, TREE_TYPE (*expr_p)))\n+\t    new_type = TREE_TYPE (*expr_p);\n+\t    if (!useless_type_conversion_p (orig_type, new_type))\n \t      {\n \t\t*expr_p = fold_convert_loc (input_location, orig_type, *expr_p);\n \t\tret = GS_OK;\n@@ -7281,7 +7283,18 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      default:\n \t\tbreak;\n \t      }\n-\n+\t    /* Now make sure that operands have compatible type to\n+\t       expression's new_type.  */\n+\t    xop0 = TREE_OPERAND (*expr_p, 0);\n+\t    xop1 = TREE_OPERAND (*expr_p, 1);\n+\t    if (!useless_type_conversion_p (new_type, TREE_TYPE (xop0)))\n+\t      TREE_OPERAND (*expr_p, 0) = fold_convert_loc (input_location,\n+\t\t\t\t\t\t\t    new_type,\n+\t      \t\t\t\t\t\t    xop0);\n+\t    if (!useless_type_conversion_p (new_type, TREE_TYPE (xop1)))\n+\t      TREE_OPERAND (*expr_p, 1) = fold_convert_loc (input_location,\n+\t\t\t\t\t\t\t    new_type,\n+\t      \t\t\t\t\t\t    xop1);\n \t    /* Continue classified as tcc_binary.  */\n \t    goto expr_2;\n \t  }"}, {"sha": "f47bc70dcdb979a8fe52068f298d47ec0ef6cbb0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "patch": "@@ -1,3 +1,7 @@\n+2011-10-14  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* gfortran.fortran-torture/compile/logical-2.f90: New test.\n+\n 2011-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.target/i386/sse2-mul-1.c: New test."}, {"sha": "c31443f946882122add5b3340a52b64188782e9c", "filename": "gcc/testsuite/gfortran.fortran-torture/compile/logical-2.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Flogical-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Flogical-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Flogical-2.f90?ref=fc1f4caf5f6e1e616f5dbefcdb37bb661cd8b8fd", "patch": "@@ -0,0 +1,10 @@\n+! Check for operand type validity after gimplification\n+\n+subroutine whatever()\n+logical(kind=1) :: l1\n+logical(kind=2) :: l2\n+logical(kind=4) :: l3\n+if ((l1 .and. l2) .neqv. l3) then\n+   l1 = .true.\n+endif\n+end"}]}