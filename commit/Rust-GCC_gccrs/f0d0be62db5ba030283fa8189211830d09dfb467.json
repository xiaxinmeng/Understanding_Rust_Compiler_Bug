{"sha": "f0d0be62db5ba030283fa8189211830d09dfb467", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBkMGJlNjJkYjViYTAzMDI4M2ZhODE4OTIxMTgzMGQwOWRmYjQ2Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-15T13:00:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-15T13:05:41Z"}, "message": "c++: error recovery & pragmas\n\nParser error recovery can get confused by the tokens within a deferred\npragma, as treats those as regular tokens.  This adjusts the recovery\nso that the pragma is treated as a unit.  Also, the preprocessor now\nensures that we never have an EOF token inside a pragma -- the pragma\nis always closed first.\n\n\tgcc/cp/\n\t* parser.c (cp_parser_skip_to_closing_parenthesis_1): Deal with\n\tmeeting a deferred pragma.\n\t(cp_parser_skip_to_end_of_statement): Likewise.\n\t(cp_parser_skip_to_end_of_block_or_statement): Likewise.\n\t(cp_parser_skip_to_pragma_eol): We should never meet EOF.\n\t(cp_parser_omp_declare_simd): Likewise.\n\t(cp_parser_omp_declare_reduction, cp_parser_oacc_routine)\n\t(pragma_lex): Likewise.\n\tgcc/testsuite/\n\t* g++.dg/parse/pragma-recovery.C: New.", "tree": {"sha": "820947e511b6978f67725536c91b30755a344166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/820947e511b6978f67725536c91b30755a344166"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0d0be62db5ba030283fa8189211830d09dfb467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d0be62db5ba030283fa8189211830d09dfb467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d0be62db5ba030283fa8189211830d09dfb467", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d0be62db5ba030283fa8189211830d09dfb467/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0685fadb6aa7c9cc895bc14cbbe2b9026fa3a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0685fadb6aa7c9cc895bc14cbbe2b9026fa3a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0685fadb6aa7c9cc895bc14cbbe2b9026fa3a94"}], "stats": {"total": 79, "additions": 64, "deletions": 15}, "files": [{"sha": "1532431378ef0facfce0f8b9a2d530409d33ca64", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d0be62db5ba030283fa8189211830d09dfb467/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d0be62db5ba030283fa8189211830d09dfb467/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f0d0be62db5ba030283fa8189211830d09dfb467", "patch": "@@ -3689,6 +3689,11 @@ cp_parser_skip_to_closing_parenthesis_1 (cp_parser *parser,\n \t    condop_depth--;\n \t  break;\n \n+\tcase CPP_PRAGMA:\n+\t  /* We fell into a pragma.  Skip it, and continue. */\n+\t  cp_parser_skip_to_pragma_eol (parser, token);\n+\t  continue;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -3780,6 +3785,13 @@ cp_parser_skip_to_end_of_statement (cp_parser* parser)\n \t  ++nesting_depth;\n \t  break;\n \n+\tcase CPP_PRAGMA:\n+\t  /* We fell into a pragma.  Skip it, and continue or return. */\n+\t  cp_parser_skip_to_pragma_eol (parser, token);\n+\t  if (!nesting_depth)\n+\t    return;\n+\t  continue;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -3855,6 +3867,13 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n \t  nesting_depth++;\n \t  break;\n \n+\tcase CPP_PRAGMA:\n+\t  /* Skip it, and continue or return. */\n+\t  cp_parser_skip_to_pragma_eol (parser, token);\n+\t  if (!nesting_depth)\n+\t    return;\n+\t  continue;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -3921,8 +3940,15 @@ cp_parser_skip_to_pragma_eol (cp_parser* parser, cp_token *pragma_tok)\n   parser->lexer->in_pragma = false;\n \n   do\n-    token = cp_lexer_consume_token (parser->lexer);\n-  while (token->type != CPP_PRAGMA_EOL && token->type != CPP_EOF);\n+    {\n+      /* The preprocessor makes sure that a PRAGMA_EOL token appears\n+         before an EOF token, even when the EOF is on the pragma line.\n+         We should never get here without being inside a deferred\n+         pragma.  */\n+      gcc_checking_assert (cp_lexer_next_token_is_not (parser->lexer, CPP_EOF));\n+      token = cp_lexer_consume_token (parser->lexer);\n+    }\n+  while (token->type != CPP_PRAGMA_EOL);\n \n   /* Ensure that the pragma is not parsed again.  */\n   cp_lexer_purge_tokens_after (parser->lexer, pragma_tok);\n@@ -41470,11 +41496,8 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n     }\n \n   /* Store away all pragma tokens.  */\n-  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n-\t && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     cp_lexer_consume_token (parser->lexer);\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n-    parser->omp_declare_simd->error_seen = true;\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n   struct cp_token_cache *cp\n     = cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser->lexer));\n@@ -42534,11 +42557,8 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n \t{\n \t  if (cp == NULL)\n \t    {\n-\t      while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n-\t\t     && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n+\t      while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n \t\tcp_lexer_consume_token (parser->lexer);\n-\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n-\t\tgoto fail;\n \t      cp = cp_token_cache_new (first_token,\n \t\t\t\t       cp_lexer_peek_nth_token (parser->lexer,\n \t\t\t\t\t\t\t\t2));\n@@ -43017,11 +43037,8 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n   else /* No optional '( name )'.  */\n     {\n       /* Store away all pragma tokens.  */\n-      while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n-\t     && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n+      while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n \tcp_lexer_consume_token (parser->lexer);\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n-\tparser->oacc_routine->error_seen = true;\n       cp_parser_require_pragma_eol (parser, pragma_tok);\n       struct cp_token_cache *cp\n \t= cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser->lexer));\n@@ -44014,7 +44031,7 @@ pragma_lex (tree *value, location_t *loc)\n   if (loc)\n     *loc = tok->location;\n \n-  if (ret == CPP_PRAGMA_EOL || ret == CPP_EOF)\n+  if (ret == CPP_PRAGMA_EOL)\n     ret = CPP_EOF;\n   else if (ret == CPP_STRING)\n     *value = cp_parser_string_literal (the_parser, false, false);"}, {"sha": "cc9d323ad19fd41327b3bb314fe3b65bf2653b2a", "filename": "gcc/testsuite/g++.dg/parse/pragma-recovery.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d0be62db5ba030283fa8189211830d09dfb467/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma-recovery.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d0be62db5ba030283fa8189211830d09dfb467/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma-recovery.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma-recovery.C?ref=f0d0be62db5ba030283fa8189211830d09dfb467", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-additional-options -fopenmp }  */\n+/* { dg-require-effective-target fopenmp } */\n+\n+// Make sure error recovery doesn't get confused by tokens inside a\n+// deferred pragma.\n+// OpenMP is a convenient deferred pragma insertion mechanism.\n+\n+void foo  ()\n+{\n+  1 * \"\" // { dg-error \"invalid\" }\n+#pragma omp atomic {\n+    ;\n+    \n+    }\n+\n+void bar  ()\n+{\n+  1 * \"\" // { dg-error \"invalid\" }\n+#pragma omp atomic }\n+    ;\n+    \n+    }\n+\n+void baz  ()\n+{\n+  1 * \"\" // { dg-error \"invalid\" }\n+#pragma omp atomic ;\n+    0;\n+  \n+    \n+    }\n+"}]}