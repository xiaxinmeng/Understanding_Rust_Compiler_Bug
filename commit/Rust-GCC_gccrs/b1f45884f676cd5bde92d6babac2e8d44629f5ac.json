{"sha": "b1f45884f676cd5bde92d6babac2e8d44629f5ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFmNDU4ODRmNjc2Y2Q1YmRlOTJkNmJhYmFjMmU4ZDQ0NjI5ZjVhYw==", "commit": {"author": {"name": "Nicolas Koenig", "email": "koenigni@gcc.gnu.org", "date": "2018-07-25T18:48:39Z"}, "committer": {"name": "Nicolas Koenig", "email": "koenigni@gcc.gnu.org", "date": "2018-07-25T18:48:39Z"}, "message": "re PR fortran/25829 ([F03] Asynchronous IO support)\n\n2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* gfortran.texi: Add description of asynchronous I/O.\n\t* trans-decl.c (gfc_finish_var_decl): Treat asynchronous variables\n\tas volatile.\n\t* trans-io.c (gfc_build_io_library_fndecls): Rename st_wait to\n\tst_wait_async and change argument spec from \".X\" to \".w\".\n\t(gfc_trans_wait): Pass ID argument via reference.\n\n2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* gfortran.dg/f2003_inquire_1.f03: Add write statement.\n\t* gfortran.dg/f2003_io_1.f03: Add wait statement.\n\n2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* Makefile.am: Add async.c to gfor_io_src.\n\tAdd async.h to gfor_io_headers.\n\t* Makefile.in: Regenerated.\n\t* gfortran.map: Add _gfortran_st_wait_async.\n\t* io/async.c: New file.\n\t* io/async.h: New file.\n\t* io/close.c: Include async.h.\n\t(st_close): Call async_wait for an asynchronous unit.\n\t* io/file_pos.c (st_backspace): Likewise.\n\t(st_endfile): Likewise.\n\t(st_rewind): Likewise.\n\t(st_flush): Likewise.\n\t* io/inquire.c: Add handling for asynchronous PENDING\n\tand ID arguments.\n\t* io/io.h (st_parameter_dt): Add async bit.\n\t(st_parameter_wait): Correct.\n\t(gfc_unit): Add au pointer.\n\t(st_wait_async): Add prototype.\n\t(transfer_array_inner): Likewise.\n\t(st_write_done_worker): Likewise.\n\t* io/open.c: Include async.h.\n\t(new_unit): Initialize asynchronous unit.\n\t* io/transfer.c (async_opt): New struct.\n\t(wrap_scalar_transfer): New function.\n\t(transfer_integer): Call wrap_scalar_transfer to do the work.\n\t(transfer_real): Likewise.\n\t(transfer_real_write): Likewise.\n\t(transfer_character): Likewise.\n\t(transfer_character_wide): Likewise.\n\t(transfer_complex): Likewise.\n\t(transfer_array_inner): New function.\n\t(transfer_array): Call transfer_array_inner.\n\t(transfer_derived): Call wrap_scalar_transfer.\n\t(data_transfer_init): Check for asynchronous I/O.\n\tPerform a wait operation on any pending asynchronous I/O\n\tif the data transfer is synchronous. Copy PDT and enqueue\n\tthread for data transfer.\n\t(st_read_done_worker): New function.\n\t(st_read_done): Enqueue transfer or call st_read_done_worker.\n\t(st_write_done_worker): New function.\n\t(st_write_done): Enqueue transfer or call st_read_done_worker.\n\t(st_wait): Document as no-op for compatibility reasons.\n\t(st_wait_async): New function.\n\t* io/unit.c (insert_unit): Use macros LOCK, UNLOCK and TRYLOCK;\n\tadd NOTE where necessary.\n\t(get_gfc_unit): Likewise.\n\t(init_units): Likewise.\n\t(close_unit_1): Likewise. Call async_close if asynchronous.\n\t(close_unit): Use macros LOCK and UNLOCK.\n\t(finish_last_advance_record): Likewise.\n\t(newunit_alloc): Likewise.\n\t* io/unix.c (find_file): Likewise.\n\t(flush_all_units_1): Likewise.\n\t(flush_all_units): Likewise.\n\t* libgfortran.h (generate_error_common): Add prototype.\n\t* runtime/error.c: Include io.h and async.h.\n\t(generate_error_common): New function.\n\n2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* testsuite/libgomp.fortran/async_io_1.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_2.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_3.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_4.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_5.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_6.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_7.f90: New test.\n\n\nCo-Authored-By: Thomas Koenig <tkoenig@gcc.gnu.org>\n\nFrom-SVN: r262978", "tree": {"sha": "d02f3de667db3dd45796c412b0481a9661283c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d02f3de667db3dd45796c412b0481a9661283c83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1f45884f676cd5bde92d6babac2e8d44629f5ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f45884f676cd5bde92d6babac2e8d44629f5ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1f45884f676cd5bde92d6babac2e8d44629f5ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f45884f676cd5bde92d6babac2e8d44629f5ac/comments", "author": null, "committer": null, "parents": [{"sha": "16d0ab7f441a21b93fe28c5bd55fc32672ad510b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d0ab7f441a21b93fe28c5bd55fc32672ad510b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d0ab7f441a21b93fe28c5bd55fc32672ad510b"}], "stats": {"total": 1654, "additions": 1504, "deletions": 150}, "files": [{"sha": "94b63b71e2a7eeb79b8f4d8a77accd175dffe3f0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -1,3 +1,14 @@\n+2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* gfortran.texi: Add description of asynchronous I/O.\n+\t* trans-decl.c (gfc_finish_var_decl): Treat asynchronous variables\n+\tas volatile.\n+\t* trans-io.c (gfc_build_io_library_fndecls): Rename st_wait to\n+\tst_wait_async and change argument spec from \".X\" to \".w\".\n+\t(gfc_trans_wait): Pass ID argument via reference.\n+\n 2018-07-20  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/82063"}, {"sha": "392000273055c2d241877f1b79c3499d8e485d1e", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -879,8 +879,7 @@ than @code{(/.../)}.  Type-specification for array constructors like\n @item Extensions to the specification and initialization expressions,\n including the support for intrinsics with real and complex arguments.\n \n-@item Support for the asynchronous input/output syntax; however, the\n-data transfer is currently always synchronously performed. \n+@item Support for the asynchronous input/output.\n \n @item\n @cindex @code{FLUSH} statement\n@@ -1183,6 +1182,7 @@ might in some way or another become visible to the programmer.\n * Files opened without an explicit ACTION= specifier::\n * File operations on symbolic links::\n * File format of unformatted sequential files::\n+* Asynchronous I/O::\n @end menu\n \n \n@@ -1486,6 +1486,20 @@ program main\n end program main\n @end smallexample\n \n+@node Asynchronous I/O\n+@section Asynchronous I/O\n+@cindex input/output, asynchronous\n+@cindex asynchronous I/O\n+\n+Asynchronous I/O is supported if the program is linked against the\n+POSIX thread library. If that is not the case, all I/O is performed\n+as synchronous.\n+\n+On some systems, such as Darwin or Solaris, the POSIX thread library\n+is always linked in, so asynchronous I/O is always performed. On other\n+sytems, such as Linux, it is necessary to specify @option{-pthread},\n+@option{-lpthread} or @option{-fopenmp} during the linking step.\n+\n @c ---------------------------------------------------------------------\n @c Extensions\n @c ---------------------------------------------------------------------"}, {"sha": "eea6b81ebfa855a814109b15876c0872aa1bbfab", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -698,7 +698,8 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n \t      && CLASS_DATA (sym)->ts.u.derived->attr.has_dtio_procs)))\n     TREE_STATIC (decl) = 1;\n \n-  if (sym->attr.volatile_)\n+  /* Treat asynchronous variables the same as volatile, for now.  */\n+  if (sym->attr.volatile_ || sym->attr.asynchronous)\n     {\n       TREE_THIS_VOLATILE (decl) = 1;\n       TREE_SIDE_EFFECTS (decl) = 1;"}, {"sha": "88dbcb80a854dd71ebe53e218ade67e4a570efa5", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -438,10 +438,9 @@ gfc_build_io_library_fndecls (void)\n \tget_identifier (PREFIX(\"st_iolength\")), \".w\",\n \tvoid_type_node, 1, dt_parm_type);\n \n-  /* TODO: Change when asynchronous I/O is implemented.  */\n   parm_type = build_pointer_type (st_parameter[IOPARM_ptype_wait].type);\n   iocall[IOCALL_WAIT] = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"st_wait\")), \".X\",\n+\tget_identifier (PREFIX(\"st_wait_async\")), \".w\",\n \tvoid_type_node, 1, parm_type);\n \n   parm_type = build_pointer_type (st_parameter[IOPARM_ptype_filepos].type);\n@@ -1527,7 +1526,7 @@ gfc_trans_wait (gfc_code * code)\n     mask |= IOPARM_common_err;\n \n   if (p->id)\n-    mask |= set_parameter_value (&block, var, IOPARM_wait_id, p->id);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_wait_id, p->id);\n \n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n "}, {"sha": "f7b3866cd80f9cfb6d8d266655d55136cf4a3c8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -1,3 +1,10 @@\n+2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* gfortran.dg/f2003_inquire_1.f03: Add write statement.\n+\t* gfortran.dg/f2003_io_1.f03: Add wait statement.\n+\n 2018-07-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/85515"}, {"sha": "957cdae52767318215f7b5807e3b564cd259c9ec", "filename": "gcc/testsuite/gfortran.dg/f2003_inquire_1.f03", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_inquire_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_inquire_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_inquire_1.f03?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -7,10 +7,12 @@\n open(10, file='mydata_f2003_inquire_1', asynchronous=\"yes\", blank=\"null\", &\n & decimal=\"comma\", encoding=\"utf-8\", sign=\"plus\")\n \n+write (10,*, asynchronous=\"yes\", id=vid) 'asdf'\n+wait (10)\n+\n inquire(unit=10, round=sround, sign=ssign, size=vsize, id=vid, &\n & pending=vpending, asynchronous=sasynchronous, decimal=sdecimal, &\n & encoding=sencoding)\n-\n if (ssign.ne.\"PLUS\") STOP 1\n if (sasynchronous.ne.\"YES\") STOP 2\n if (sdecimal.ne.\"COMMA\") STOP 3"}, {"sha": "8c7fb4b994dbdf59c1978298a959d8e1c97eab31", "filename": "gcc/testsuite/gfortran.dg/f2003_io_1.f03", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_1.f03?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -13,6 +13,7 @@\n write(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"comma\", id=j) a\n rewind(10)\n read(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"comma\", blank=\"zero\") b\n+wait(10)\n if (any(b.ne.23.45)) STOP 1\n \n c = 3.14\n@@ -24,6 +25,7 @@\n write(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"point\") a\n rewind(10)\n read(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"point\") b\n+wait (10)\n if (any(b.ne.23.45)) STOP 3\n \n wait(unit=10, err=25, iostat=istat, iomsg=msg, end=35, id=j)"}, {"sha": "e895df751f73cf30dad0d2a722890420557b9c86", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -1,3 +1,65 @@\n+2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* Makefile.am: Add async.c to gfor_io_src.\n+\tAdd async.h to gfor_io_headers.\n+\t* Makefile.in: Regenerated.\n+\t* gfortran.map: Add _gfortran_st_wait_async.\n+\t* io/async.c: New file.\n+\t* io/async.h: New file.\n+\t* io/close.c: Include async.h.\n+\t(st_close): Call async_wait for an asynchronous unit.\n+\t* io/file_pos.c (st_backspace): Likewise.\n+\t(st_endfile): Likewise.\n+\t(st_rewind): Likewise.\n+\t(st_flush): Likewise.\n+\t* io/inquire.c: Add handling for asynchronous PENDING\n+\tand ID arguments.\n+\t* io/io.h (st_parameter_dt): Add async bit.\n+\t(st_parameter_wait): Correct.\n+\t(gfc_unit): Add au pointer.\n+\t(st_wait_async): Add prototype.\n+\t(transfer_array_inner): Likewise.\n+\t(st_write_done_worker): Likewise.\n+\t* io/open.c: Include async.h.\n+\t(new_unit): Initialize asynchronous unit.\n+\t* io/transfer.c (async_opt): New struct.\n+\t(wrap_scalar_transfer): New function.\n+\t(transfer_integer): Call wrap_scalar_transfer to do the work.\n+\t(transfer_real): Likewise.\n+\t(transfer_real_write): Likewise.\n+\t(transfer_character): Likewise.\n+\t(transfer_character_wide): Likewise.\n+\t(transfer_complex): Likewise.\n+\t(transfer_array_inner): New function.\n+\t(transfer_array): Call transfer_array_inner.\n+\t(transfer_derived): Call wrap_scalar_transfer.\n+\t(data_transfer_init): Check for asynchronous I/O.\n+\tPerform a wait operation on any pending asynchronous I/O\n+\tif the data transfer is synchronous. Copy PDT and enqueue\n+\tthread for data transfer.\n+\t(st_read_done_worker): New function.\n+\t(st_read_done): Enqueue transfer or call st_read_done_worker.\n+\t(st_write_done_worker): New function.\n+\t(st_write_done): Enqueue transfer or call st_read_done_worker.\n+\t(st_wait): Document as no-op for compatibility reasons.\n+\t(st_wait_async): New function.\n+\t* io/unit.c (insert_unit): Use macros LOCK, UNLOCK and TRYLOCK;\n+\tadd NOTE where necessary.\n+\t(get_gfc_unit): Likewise.\n+\t(init_units): Likewise.\n+\t(close_unit_1): Likewise. Call async_close if asynchronous.\n+\t(close_unit): Use macros LOCK and UNLOCK.\n+\t(finish_last_advance_record): Likewise.\n+\t(newunit_alloc): Likewise.\n+\t* io/unix.c (find_file): Likewise.\n+\t(flush_all_units_1): Likewise.\n+\t(flush_all_units): Likewise.\n+\t* libgfortran.h (generate_error_common): Add prototype.\n+\t* runtime/error.c: Include io.h and async.h.\n+\t(generate_error_common): New function.\n+\n 2018-06-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/86070"}, {"sha": "4ffc6cea780de89e44008f6bdd66bc2e38e044b2", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -100,15 +100,17 @@ io/transfer128.c \\\n io/unit.c \\\n io/unix.c \\\n io/write.c \\\n-io/fbuf.c\n+io/fbuf.c \\\n+io/async.c\n \n endif\n \n gfor_io_headers= \\\n io/io.h \\\n io/fbuf.h \\\n io/format.h \\\n-io/unix.h\n+io/unix.h \\\n+io/async.h\n \n gfor_helper_src= \\\n intrinsics/associated.c \\"}, {"sha": "94c3524ffb948ef7e661f4ac88d9b5e3a3237e12", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -70,7 +70,8 @@ target_triplet = @target@\n @LIBGFOR_MINIMAL_FALSE@io/unit.c \\\n @LIBGFOR_MINIMAL_FALSE@io/unix.c \\\n @LIBGFOR_MINIMAL_FALSE@io/write.c \\\n-@LIBGFOR_MINIMAL_FALSE@io/fbuf.c\n+@LIBGFOR_MINIMAL_FALSE@io/fbuf.c \\\n+@LIBGFOR_MINIMAL_FALSE@io/async.c\n \n @LIBGFOR_MINIMAL_FALSE@am__append_3 = \\\n @LIBGFOR_MINIMAL_FALSE@intrinsics/access.c \\\n@@ -352,7 +353,7 @@ am__objects_47 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n-@LIBGFOR_MINIMAL_FALSE@\tfbuf.lo\n+@LIBGFOR_MINIMAL_FALSE@\tfbuf.lo async.lo\n am__objects_49 = size_from_kind.lo $(am__objects_48)\n @LIBGFOR_MINIMAL_FALSE@am__objects_50 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n@@ -650,7 +651,8 @@ gfor_io_headers = \\\n io/io.h \\\n io/fbuf.h \\\n io/format.h \\\n-io/unix.h\n+io/unix.h \\\n+io/async.h\n \n gfor_helper_src = intrinsics/associated.c intrinsics/abort.c \\\n \tintrinsics/args.c intrinsics/cshift0.c intrinsics/eoshift0.c \\\n@@ -1551,6 +1553,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/any_l8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/args.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/associated.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/async.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backtrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r16.Plo@am__quote@\n@@ -5814,6 +5817,13 @@ fbuf.lo: io/fbuf.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o fbuf.lo `test -f 'io/fbuf.c' || echo '$(srcdir)/'`io/fbuf.c\n \n+async.lo: io/async.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT async.lo -MD -MP -MF $(DEPDIR)/async.Tpo -c -o async.lo `test -f 'io/async.c' || echo '$(srcdir)/'`io/async.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/async.Tpo $(DEPDIR)/async.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='io/async.c' object='async.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o async.lo `test -f 'io/async.c' || echo '$(srcdir)/'`io/async.c\n+\n associated.lo: intrinsics/associated.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT associated.lo -MD -MP -MF $(DEPDIR)/associated.Tpo -c -o associated.lo `test -f 'intrinsics/associated.c' || echo '$(srcdir)/'`intrinsics/associated.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/associated.Tpo $(DEPDIR)/associated.Plo"}, {"sha": "a303a2ef5733711987245402cebb5cd73cdb54d0", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -1483,3 +1483,8 @@ GFORTRAN_C99_8 {\n     y1f;\n     ynf;\n };\n+\n+GFORTRAN_9 {\n+  global:\n+  _gfortran_st_wait_async;\n+};"}, {"sha": "b32af16ccb423f6f32d7cef7fa7567d79ec12d12", "filename": "libgfortran/io/async.c", "status": "added", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fasync.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fasync.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fasync.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -0,0 +1,483 @@\n+/* Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Nicolas Koenig\n+\n+   This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+   Libgfortran is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgfortran is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+#define _GTHREAD_USE_COND_INIT_FUNC\n+#include \"../../libgcc/gthr.h\"\n+#include \"io.h\"\n+#include \"fbuf.h\"\n+#include \"format.h\"\n+#include \"unix.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+#include <sys/types.h>\n+\n+#include \"async.h\"\n+\n+DEBUG_LINE (__thread const char *aio_prefix = MPREFIX);\n+\n+DEBUG_LINE (__gthread_mutex_t debug_queue_lock = __GTHREAD_MUTEX_INIT;)\n+DEBUG_LINE (aio_lock_debug *aio_debug_head = NULL;)\n+\n+/* Current unit for asynchronous I/O.  Needed for error reporting.  */\n+\n+__thread gfc_unit *thread_unit = NULL;\n+\n+/* Queue entry for the asynchronous I/O entry.  */\n+typedef struct transfer_queue\n+{\n+  enum aio_do type;\n+  struct transfer_queue *next;\n+  struct st_parameter_dt *new_pdt;\n+  transfer_args arg;\n+  _Bool has_id;\n+  int read_flag;\n+} transfer_queue;\n+\n+struct error {\n+  st_parameter_dt *dtp;\n+  int id;\n+};\n+\n+/* Helper function to exchange the old vs. a new PDT.  */\n+\n+static void\n+update_pdt (st_parameter_dt **old, st_parameter_dt *new) {\n+  st_parameter_dt *temp;\n+  NOTE (\"Changing pdts, current_unit = %p\", (void *) (new->u.p.current_unit));\n+  temp = *old;\n+  *old = new;\n+  if (temp)\n+    free (temp);\n+}\n+\n+/* Destroy an adv_cond structure.  */\n+\n+static void\n+destroy_adv_cond (struct adv_cond *ac)\n+{\n+  T_ERROR (__gthread_mutex_destroy, &ac->lock);\n+  T_ERROR (__gthread_cond_destroy, &ac->signal);\n+}\n+\n+/* Function invoked as start routine for a new asynchronous I/O unit.\n+   Contains the main loop for accepting requests and handling them.  */\n+\n+static void *\n+async_io (void *arg)\n+{\n+  DEBUG_LINE (aio_prefix = TPREFIX);\n+  transfer_queue *ctq = NULL, *prev = NULL;\n+  gfc_unit *u = (gfc_unit *) arg;\n+  async_unit *au = u->au;\n+  LOCK (&au->lock);\n+  thread_unit = u;\n+  au->thread = __gthread_self ();\n+  while (true)\n+    {\n+      /* Main loop.  At this point, au->lock is always held. */\n+      WAIT_SIGNAL_MUTEX (&au->work, au->tail != NULL, &au->lock);\n+      LOCK (&au->lock);\n+      ctq = au->head;\n+      prev = NULL;\n+      /* Loop over the queue entries until they are finished.  */\n+      while (ctq)\n+\t{\n+\t  if (prev)\n+\t    free (prev);\n+\t  prev = ctq;\n+\t  if (!au->error.has_error)\n+\t    {\n+\t      UNLOCK (&au->lock);\n+\n+\t      switch (ctq->type)\n+\t\t{\n+\t\tcase AIO_WRITE_DONE:\n+\t\t  NOTE (\"Finalizing write\");\n+\t\t  st_write_done_worker (au->pdt);\n+\t\t  UNLOCK (&au->io_lock);\n+\t\t  break;\n+\n+\t\tcase AIO_READ_DONE:\n+\t\t  NOTE (\"Finalizing read\");\n+\t\t  st_read_done_worker (au->pdt);\n+\t\t  UNLOCK (&au->io_lock);\n+\t\t  break;\n+\n+\t\tcase AIO_DATA_TRANSFER_INIT:\n+\t\t  NOTE (\"Data transfer init\");\n+\t\t  LOCK (&au->io_lock);\n+\t\t  update_pdt (&au->pdt, ctq->new_pdt);\n+\t\t  data_transfer_init_worker (au->pdt, ctq->read_flag);\n+\t\t  break;\n+\n+\t\tcase AIO_TRANSFER_SCALAR:\n+\t\t  NOTE (\"Starting scalar transfer\");\n+\t\t  ctq->arg.scalar.transfer (au->pdt, ctq->arg.scalar.arg_bt,\n+\t\t\t\t\t    ctq->arg.scalar.data,\n+\t\t\t\t\t    ctq->arg.scalar.i,\n+\t\t\t\t\t    ctq->arg.scalar.s1,\n+\t\t\t\t\t    ctq->arg.scalar.s2);\n+\t\t  break;\n+\n+\t\tcase AIO_TRANSFER_ARRAY:\n+\t\t  NOTE (\"Starting array transfer\");\n+\t\t  NOTE (\"ctq->arg.array.desc = %p\",\n+\t\t\t(void *) (ctq->arg.array.desc));\n+\t\t  transfer_array_inner (au->pdt, ctq->arg.array.desc,\n+\t\t\t\t\tctq->arg.array.kind,\n+\t\t\t\t\tctq->arg.array.charlen);\n+\t\t  free (ctq->arg.array.desc);\n+\t\t  break;\n+\n+\t\tcase AIO_CLOSE:\n+\t\t  NOTE (\"Received AIO_CLOSE\");\n+\t\t  goto finish_thread;\n+\n+\t\tdefault:\n+\t\t  internal_error (NULL, \"Invalid queue type\");\n+\t\t  break;\n+\t\t}\n+\t      LOCK (&au->lock);\n+\t      if (unlikely (au->error.has_error))\n+\t\tau->error.last_good_id = au->id.low - 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (ctq->type == AIO_WRITE_DONE || ctq->type == AIO_READ_DONE)\n+\t\t{\n+\t\t  UNLOCK (&au->io_lock);\n+\t\t}\n+\t      else if (ctq->type == AIO_CLOSE)\n+\t\t{\n+\t\t  NOTE (\"Received AIO_CLOSE during error condition\");\n+\t\t  UNLOCK (&au->lock);\n+\t\t  goto finish_thread;\n+\t\t}\n+\t    }\n+\n+  \t  NOTE (\"Next ctq, current id: %d\", au->id.low);\n+  \t  if (ctq->has_id && au->id.waiting == au->id.low++)\n+\t    SIGNAL (&au->id.done);\n+\n+\t  ctq = ctq->next;\n+\t}\n+      au->tail = NULL;\n+      au->head = NULL;\n+      au->empty = 1;\n+      UNLOCK (&au->lock);\n+      SIGNAL (&au->emptysignal);\n+      LOCK (&au->lock);\n+    }\n+ finish_thread:\n+  au->tail = NULL;\n+  au->head = NULL;\n+  au->empty = 1;\n+  SIGNAL (&au->emptysignal);\n+  free (ctq);\n+  return NULL;\n+}\n+\n+/* Free an asynchronous unit.  */\n+\n+static void\n+free_async_unit (async_unit *au)\n+{\n+  if (au->tail)\n+    internal_error (NULL, \"Trying to free nonempty asynchronous unit\");\n+\n+  destroy_adv_cond (&au->work);\n+  destroy_adv_cond (&au->emptysignal);\n+  destroy_adv_cond (&au->id.done);\n+  T_ERROR (__gthread_mutex_destroy, &au->lock);\n+  free (au);\n+}\n+\n+/* Initialize an adv_cond structure.  */\n+\n+static void\n+init_adv_cond (struct adv_cond *ac)\n+{\n+  ac->pending = 0;\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&ac->lock);\n+  __gthread_cond_init_function (&ac->signal);\n+}\n+\n+/* Initialize an asyncronous unit, returning zero on success,\n+ nonzero on failure.  It also sets u->au.  */\n+\n+void\n+init_async_unit (gfc_unit *u)\n+{\n+  async_unit *au;\n+  if (!__gthread_active_p ())\n+    {\n+      u->au = NULL;\n+      return;\n+    }\n+  \n+  au = (async_unit *) xmalloc (sizeof (async_unit));\n+  u->au = au;\n+  init_adv_cond (&au->work);\n+  init_adv_cond (&au->emptysignal);\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&au->lock);\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&au->io_lock);\n+  LOCK (&au->lock);\n+  T_ERROR (__gthread_create, &au->thread, &async_io, (void *) u);\n+  au->pdt = NULL;\n+  au->head = NULL;\n+  au->tail = NULL;\n+  au->empty = true;\n+  au->id.waiting = -1;\n+  au->id.low = 0;\n+  au->id.high = 0;\n+  au->error.fatal_error = 0;\n+  au->error.has_error = 0;\n+  au->error.last_good_id = 0;\n+  init_adv_cond (&au->id.done);\n+  UNLOCK (&au->lock);\n+}\n+\n+/* Enqueue a transfer statement.  */\n+\n+void\n+enqueue_transfer (async_unit *au, transfer_args *arg, enum aio_do type)\n+{\n+  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n+  tq->arg = *arg;\n+  tq->type = type;\n+  tq->has_id = 0;\n+  LOCK (&au->lock);\n+  if (!au->tail)\n+    au->head = tq;\n+  else\n+    au->tail->next = tq;\n+  au->tail = tq;\n+  REVOKE_SIGNAL (&(au->emptysignal));\n+  au->empty = false;\n+  UNLOCK (&au->lock);\n+  SIGNAL (&au->work);\n+}\n+\n+/* Enqueue an st_write_done or st_read_done which contains an ID.  */\n+\n+int\n+enqueue_done_id (async_unit *au, enum aio_do type)\n+{\n+  int ret;\n+  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n+\n+  tq->type = type;\n+  tq->has_id = 1;\n+  LOCK (&au->lock);\n+  if (!au->tail)\n+    au->head = tq;\n+  else\n+    au->tail->next = tq;\n+  au->tail = tq;\n+  REVOKE_SIGNAL (&(au->emptysignal));\n+  au->empty = false;\n+  ret = au->id.high++;\n+  NOTE (\"Enqueue id: %d\", ret);\n+  UNLOCK (&au->lock);\n+  SIGNAL (&au->work);\n+  return ret;\n+}\n+\n+/* Enqueue an st_write_done or st_read_done without an ID.  */\n+\n+void\n+enqueue_done (async_unit *au, enum aio_do type)\n+{\n+  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n+  tq->type = type;\n+  tq->has_id = 0;\n+  LOCK (&au->lock);\n+  if (!au->tail)\n+    au->head = tq;\n+  else\n+    au->tail->next = tq;\n+  au->tail = tq;\n+  REVOKE_SIGNAL (&(au->emptysignal));\n+  au->empty = false;\n+  UNLOCK (&au->lock);\n+  SIGNAL (&au->work);\n+}\n+\n+/* Enqueue a CLOSE statement.  */\n+\n+void\n+enqueue_close (async_unit *au)\n+{\n+  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n+\n+  tq->type = AIO_CLOSE;\n+  LOCK (&au->lock);\n+  if (!au->tail)\n+    au->head = tq;\n+  else\n+    au->tail->next = tq;\n+  au->tail = tq;\n+  REVOKE_SIGNAL (&(au->emptysignal));\n+  au->empty = false;\n+  UNLOCK (&au->lock);\n+  SIGNAL (&au->work);\n+}\n+\n+/* The asynchronous unit keeps the currently active PDT around.\n+   This function changes that to the current one.  */\n+\n+void\n+enqueue_data_transfer_init (async_unit *au, st_parameter_dt *dt, int read_flag)\n+{\n+  st_parameter_dt *new = xmalloc (sizeof (st_parameter_dt));\n+  transfer_queue *tq = xmalloc (sizeof (transfer_queue));\n+\n+  memcpy ((void *) new, (void *) dt, sizeof (st_parameter_dt));\n+\n+  NOTE (\"dt->internal_unit_desc = %p\", dt->internal_unit_desc);\n+  NOTE (\"common.flags & mask = %d\", dt->common.flags & IOPARM_LIBRETURN_MASK);\n+  tq->next = NULL;\n+  tq->type = AIO_DATA_TRANSFER_INIT;\n+  tq->read_flag = read_flag;\n+  tq->has_id = 0;\n+  tq->new_pdt = new;\n+  LOCK (&au->lock);\n+\n+  if (!au->tail)\n+    au->head = tq;\n+  else\n+    au->tail->next = tq;\n+  au->tail = tq;\n+  REVOKE_SIGNAL (&(au->emptysignal));\n+  au->empty = 0;\n+  UNLOCK (&au->lock);\n+  SIGNAL (&au->work);\n+}\n+\n+/* Collect the errors that may have happened asynchronously.  Return true if\n+   an error has been encountered.  */\n+\n+bool\n+collect_async_errors (st_parameter_common *cmp, async_unit *au)\n+{\n+  bool has_error = au->error.has_error;\n+\n+  if (has_error)\n+    {\n+      if (generate_error_common (cmp, au->error.family, au->error.message))\n+\t{\n+\t  au->error.has_error = 0;\n+\t  au->error.cmp = NULL;\n+\t}\n+      else\n+\t{\n+\t  /* The program will exit later.  */\n+\t  au->error.fatal_error = true;\n+\t}\n+    }\n+  return has_error;\n+}\n+\n+/* Perform a wait operation on an asynchronous unit with an ID specified,\n+   which means collecting the errors that may have happened asynchronously.\n+   Return true if an error has been encountered.  */\n+\n+bool\n+async_wait_id (st_parameter_common *cmp, async_unit *au, int i)\n+{\n+  bool ret;\n+\n+  if (au == NULL)\n+    return false;\n+\n+  if (cmp == NULL)\n+    cmp = au->error.cmp;\n+\n+  if (au->error.has_error)\n+    {\n+      if (i <= au->error.last_good_id)\n+\treturn false;\n+\n+      return collect_async_errors (cmp, au);\n+    }\n+\n+  LOCK (&au->lock);\n+  NOTE (\"Waiting for id %d\", i);\n+  if (au->id.waiting < i)\n+    au->id.waiting = i;\n+  UNLOCK (&au->lock);\n+  SIGNAL (&(au->work));\n+  LOCK (&au->lock);\n+  WAIT_SIGNAL_MUTEX (&(au->id.done),\n+\t\t     (au->id.low >= au->id.waiting || au->empty), &au->lock);\n+  LOCK (&au->lock);\n+  ret = collect_async_errors (cmp, au);\n+  UNLOCK (&au->lock);\n+  return ret;\n+}\n+\n+/* Perform a wait operation an an asynchronous unit without an ID.  */\n+\n+bool\n+async_wait (st_parameter_common *cmp, async_unit *au)\n+{\n+  bool ret;\n+\n+  if (au == NULL)\n+    return false;\n+\n+  if (cmp == NULL)\n+    cmp = au->error.cmp;\n+\n+  SIGNAL (&(au->work));\n+  LOCK (&(au->lock));\n+\n+  if (au->empty)\n+    {\n+      ret = collect_async_errors (cmp, au);\n+      UNLOCK (&au->lock);\n+      return ret;\n+    }\n+\n+  WAIT_SIGNAL_MUTEX (&(au->emptysignal), (au->empty), &au->lock);\n+  ret = collect_async_errors (cmp, au);\n+  return ret;\n+}\n+\n+/* Close an asynchronous unit.  */\n+\n+void\n+async_close (async_unit *au)\n+{\n+  if (au == NULL)\n+    return;\n+\n+  NOTE (\"Closing async unit\");\n+  enqueue_close (au);\n+  T_ERROR (__gthread_join, au->thread, NULL);\n+  free_async_unit (au);\n+}"}, {"sha": "3581ae65931104574de31aa3051436d64b818cb3", "filename": "libgfortran/io/async.h", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fasync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fasync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fasync.h?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -0,0 +1,378 @@\n+/* Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Nicolas Koenig\n+\n+   This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+   Libgfortran is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgfortran is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef ASYNC_H\n+#define ASYNC_H\n+\n+/* Defining DEBUG_ASYNC will enable somewhat verbose debugging\n+   output for async I/O.  */\n+\n+#define DEBUG_ASYNC\n+#undef DEBUG_ASYNC\n+\n+#ifdef DEBUG_ASYNC\n+\n+/* Define this if you want to use ANSI color escape sequences in your\n+   debugging output.  */\n+\n+#define DEBUG_COLOR\n+\n+#ifdef DEBUG_COLOR\n+#define MPREFIX \"\\033[30;46mM:\\033[0m \"\n+#define TPREFIX \"\\033[37;44mT:\\033[0m \"\n+#define RPREFIX \"\\033[37;41mR:\\033[0m \"\n+#define DEBUG_RED \"\\033[31m\"\n+#define DEBUG_ORANGE \"\\033[33m\"\n+#define DEBUG_GREEN \"\\033[32m\"\n+#define DEBUG_DARKRED \"\\033[31;2m\"\n+#define DEBUG_PURPLE \"\\033[35m\"\n+#define DEBUG_NORM \"\\033[0m\"\n+#define DEBUG_REVERSE_RED \"\\033[41;37m\"\n+#define DEBUG_BLUE \"\\033[34m\"\n+\n+#else\n+\n+#define MPREFIX \"M: \"\n+#define TPREFIX \"T: \"\n+#define RPREFIX \"\"\n+#define DEBUG_RED \"\"\n+#define DEBUG_ORANGE \"\"\n+#define DEBUG_GREEN \"\"\n+#define DEBUG_DARKRED \"\"\n+#define DEBUG_PURPLE \"\"\n+#define DEBUG_NORM \"\"\n+#define DEBUG_REVERSE_RED \"\"\n+#define DEBUG_BLUE \"\"\n+\n+#endif\n+\n+#define DEBUG_PRINTF(...) fprintf (stderr,__VA_ARGS__)\n+\n+#define IN_DEBUG_QUEUE(mutex) ({\t\t\\\n+      __label__ end;\t\t\t\t\\\n+      aio_lock_debug *curr = aio_debug_head;\t\\\n+      while (curr) {\t\t\t\t\\\n+\tif (curr->m == mutex) {\t\t\t\\\n+\t  goto end;\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+\tcurr = curr->next;\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    end:;\t\t\t\t\t\\\n+      curr;\t\t\t\t\t\\\n+    })\n+\n+#define TAIL_DEBUG_QUEUE ({\t\t\t\\\n+      aio_lock_debug *curr = aio_debug_head;\t\\\n+      while (curr && curr->next) {\t\t\\\n+\tcurr = curr->next;\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+      curr;\t\t\t\t\t\\\n+    })\n+\n+#define CHECK_LOCK(mutex, status) do {\t\t\t\t\t\\\n+    aio_lock_debug *curr;\t\t\t\t\t\t\\\n+    INTERN_LOCK (&debug_queue_lock);\t\t\t\t\t\\\n+    if (__gthread_mutex_trylock (mutex)) {\t\t\t\t\\\n+      if ((curr = IN_DEBUG_QUEUE (mutex))) {\t\t\t\t\\\n+\tsprintf (status, DEBUG_RED \"%s():%d\" DEBUG_NORM, curr->func, curr->line); \\\n+      } else\t\t\t\t\t\t\t\t\\\n+\tsprintf (status, DEBUG_RED \"unknown\" DEBUG_NORM);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    else {\t\t\t\t\t\t\t\t\\\n+      __gthread_mutex_unlock (mutex);\t\t\t\t\t\\\n+      sprintf (status, DEBUG_GREEN \"unlocked\" DEBUG_NORM);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    INTERN_UNLOCK (&debug_queue_lock);\t\t\t\t\t\\\n+  }while (0)\n+\n+#define T_ERROR(func, ...) do {\t\t\t\t\\\n+    int t_error_temp;\t\t\t\t\t\\\n+    t_error_temp = func(__VA_ARGS__);\t\t\t\\\n+    if (t_error_temp)\t\t\t\t\t\\\n+      ERROR (t_error_temp, \"args: \" #__VA_ARGS__ \"\\n\");\t\\\n+  } while (0)\n+\n+#define NOTE(str, ...) do{\t\t\t\t\t\t\\\n+    char note_str[200];\t\t\t\t\t\t\t\\\n+    sprintf (note_str, \"%s\" DEBUG_PURPLE \"NOTE: \" DEBUG_NORM str, aio_prefix, ##__VA_ARGS__); \\\n+    DEBUG_PRINTF (\"%-90s %20s():%-5d\\n\", note_str, __FUNCTION__, __LINE__); \\\n+  }while (0);\n+\n+#define ERROR(errnum, str, ...) do{\t\t\t\t\t\\\n+    char note_str[200];\t\t\t\t\t\t\t\\\n+    sprintf (note_str, \"%s\" DEBUG_REVERSE_RED \"ERROR:\" DEBUG_NORM \" [%d] \" str, aio_prefix, \\\n+\t    errnum, ##__VA_ARGS__);\t\t\t\t\t\\\n+    DEBUG_PRINTF (\"%-68s %s():%-5d\\n\", note_str, __FUNCTION__, __LINE__);\t\\\n+  }while (0)\n+\n+#define MUTEX_DEBUG_ADD(mutex) do {\t\t\\\n+    aio_lock_debug *n;\t\t\t\t\\\n+    n = malloc (sizeof(aio_lock_debug));\t\\\n+    n->prev = TAIL_DEBUG_QUEUE;\t\t\t\\\n+    if (n->prev)\t\t\t\t\\\n+      n->prev->next = n;\t\t\t\\\n+    n->next = NULL;\t\t\t\t\\\n+    n->line = __LINE__;\t\t\t\t\\\n+    n->func = __FUNCTION__;\t\t\t\\\n+    n->m = mutex;\t\t\t\t\\\n+    if (!aio_debug_head) {\t\t\t\\\n+      aio_debug_head = n;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define UNLOCK(mutex) do {\t\t\t\t\t\t\\\n+    aio_lock_debug *curr;\t\t\t\t\t\t\\\n+    DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_GREEN \"UNLOCK: \" DEBUG_NORM #mutex, \\\n+\t\t __FUNCTION__, __LINE__, (void *) mutex);\t\t\\\n+    INTERN_LOCK (&debug_queue_lock);\t\t\t\t\t\\\n+    curr = IN_DEBUG_QUEUE (mutex);\t\t\t\t\t\\\n+    if (curr)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (curr->prev)\t\t\t\t\t\t\t\\\n+\t  curr->prev->next = curr->next;\t\t\t\t\\\n+\tif (curr->next) {\t\t\t\t\t\t\\\n+\t  curr->next->prev = curr->prev;\t\t\t\t\\\n+\t  if (curr == aio_debug_head)\t\t\t\t\t\\\n+\t    aio_debug_head = curr->next;\t\t\t\t\\\n+\t} else {\t\t\t\t\t\t\t\\\n+\t  if (curr == aio_debug_head)\t\t\t\t\t\\\n+\t    aio_debug_head = NULL;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tfree (curr);\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    INTERN_UNLOCK (&debug_queue_lock);\t\t\t\t\t\\\n+    INTERN_UNLOCK (mutex);\t\t\t\t\t\t\\\n+  }while (0)\n+\n+#define TRYLOCK(mutex) ({\t\t\t\t\t\t\\\n+\t\t\t char status[200];\t\t\t\t\\\n+\t\t\t int res;\t\t\t\t\t\\\n+\t\t\t aio_lock_debug *curr;\t\t\t\t\\\n+\t\t\t res = __gthread_mutex_trylock (mutex);\t\t\\\n+\t\t\t INTERN_LOCK (&debug_queue_lock);\t\t\\\n+\t\t\t if (res) {\t\t\t\t\t\\\n+\t\t\t   if ((curr = IN_DEBUG_QUEUE (mutex))) {\t\\\n+\t\t\t     sprintf (status, DEBUG_RED \"%s():%d\" DEBUG_NORM, curr->func, curr->line);\t\\\n+\t\t\t   } else\t\t\t\t\t\\\n+\t\t\t     sprintf (status, DEBUG_RED \"unknown\" DEBUG_NORM);\t\\\n+\t\t\t }\t\t\t\t\t\t\\\n+\t\t\t else {\t\t\t\t\t\t\\\n+\t\t\t   sprintf (status, DEBUG_GREEN \"unlocked\" DEBUG_NORM);\t\\\n+\t\t\t   MUTEX_DEBUG_ADD (mutex);\t\t\t\\\n+\t\t\t }\t\t\t\t\t\t\\\n+\t\t\t DEBUG_PRINTF (\"%s%-44s prev: %-35s %20s():%-5d %18p\\n\", aio_prefix, \\\n+\t\t\t\t      DEBUG_DARKRED \"TRYLOCK: \" DEBUG_NORM #mutex, status, __FUNCTION__, __LINE__, \\\n+\t\t\t\t      (void *) mutex);\t\t\t\\\n+\t\t\t INTERN_UNLOCK (&debug_queue_lock);\t\t\\\n+\t\t\t res;\t\t\t\t\t\t\\\n+    })\n+\n+#define LOCK(mutex) do {\t\t\t\t\t\t\\\n+    char status[200];\t\t\t\t\t\t\t\\\n+    CHECK_LOCK (mutex, status);\t\t\t\t\t\t\\\n+    DEBUG_PRINTF (\"%s%-42s prev: %-35s %20s():%-5d %18p\\n\", aio_prefix,\t\\\n+\t\t DEBUG_RED \"LOCK: \" DEBUG_NORM #mutex, status, __FUNCTION__, __LINE__, (void *) mutex); \\\n+    INTERN_LOCK (mutex);\t\t\t\t\t\t\t\\\n+    INTERN_LOCK (&debug_queue_lock);\t\t\t\t\t\\\n+    MUTEX_DEBUG_ADD (mutex);\t\t\t\t\t\t\\\n+    INTERN_UNLOCK (&debug_queue_lock);\t\t\t\t\t\\\n+    DEBUG_PRINTF (\"%s\" DEBUG_RED \"ACQ:\" DEBUG_NORM \" %-30s %78p\\n\", aio_prefix, #mutex, mutex); \\\n+  } while (0)\n+\n+#define DEBUG_LINE(...) __VA_ARGS__\n+\n+#else\n+#define DEBUG_PRINTF(...) {}\n+#define CHECK_LOCK(au, mutex, status) {}\n+#define NOTE(str, ...) {}\n+#define DEBUG_LINE(...)\n+#define T_ERROR(func, ...) func(__VA_ARGS__)\n+#define LOCK(mutex) INTERN_LOCK (mutex)\n+#define UNLOCK(mutex) INTERN_UNLOCK (mutex)\n+#define TRYLOCK(mutex) (__gthread_mutex_trylock (mutex))\n+#endif\n+\n+#define INTERN_LOCK(mutex) T_ERROR (__gthread_mutex_lock, mutex);\n+\n+#define INTERN_UNLOCK(mutex) T_ERROR (__gthread_mutex_unlock, mutex);\n+\n+#define SIGNAL(advcond) do{\t\t\t\t\t\t\\\n+    INTERN_LOCK (&(advcond)->lock);\t\t\t\t\t\\\n+    (advcond)->pending = 1;\t\t\t\t\t\t\\\n+    DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_ORANGE \"SIGNAL: \" DEBUG_NORM \\\n+\t\t #advcond, __FUNCTION__, __LINE__, (void *) advcond);\t\\\n+    T_ERROR (__gthread_cond_broadcast, &(advcond)->signal);\t\t\\\n+    INTERN_UNLOCK (&(advcond)->lock);\t\t\t\t\t\\\n+  } while (0)\n+\n+#define WAIT_SIGNAL_MUTEX(advcond, condition, mutex) do{\t\t\\\n+    __label__ finish;\t\t       \t\t\t\t\t\\\n+    INTERN_LOCK (&((advcond)->lock));\t\t\t\t\t\\\n+    DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_BLUE \"WAITING: \" DEBUG_NORM \\\n+\t\t #advcond, __FUNCTION__, __LINE__, (void *) advcond);\t\\\n+    if ((advcond)->pending || (condition)){\t\t\t\t\\\n+      UNLOCK (mutex);\t\t\t\t\t\t\t\\\n+      goto finish;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    UNLOCK (mutex);\t\t\t\t\t\t\t\\\n+     while (!__gthread_cond_wait(&(advcond)->signal, &(advcond)->lock)) {\t\\\n+       { int cond;\t\t\t\t\t\t\t\\\n+\t LOCK (mutex); cond = condition; UNLOCK (mutex);\t\\\n+\t   if (cond){\t\t\t\t\t\t\t\\\n+\t     DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_ORANGE \"REC: \" DEBUG_NORM \\\n+\t\t  #advcond,  __FUNCTION__, __LINE__, (void *)advcond);\t\\\n+\t   break;\t\t\t\t      \t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  finish:\t\t\t\t\t\t\t\t\\\n+\t\t (advcond)->pending = 0;\t\t\t\t\\\n+\t\t INTERN_UNLOCK (&((advcond)->lock));\t\t\t\\\n+\t\t } while (0)\n+\n+#define REVOKE_SIGNAL(advcond) do{\t\t\\\n+    INTERN_LOCK (&(advcond)->lock);\t\t\\\n+    (advcond)->pending = 0;\t\t\t\\\n+    INTERN_UNLOCK (&(advcond)->lock);\t\t\\\n+  } while (0)\n+\n+DEBUG_LINE (extern __thread const char *aio_prefix);\n+\n+DEBUG_LINE (typedef struct aio_lock_debug{\n+  __gthread_mutex_t *m;\n+  int line;\n+  const char *func;\n+  struct aio_lock_debug *next;\n+  struct aio_lock_debug *prev;\n+} aio_lock_debug;)\n+\n+DEBUG_LINE (extern aio_lock_debug *aio_debug_head;)\n+DEBUG_LINE (extern __gthread_mutex_t debug_queue_lock;)\n+\n+/* Thread - local storage of the current unit we are looking at. Needed for\n+   error reporting.  */\n+\n+extern __thread gfc_unit *thread_unit;\n+\n+enum aio_do {\n+  AIO_INVALID = 0,\n+  AIO_DATA_TRANSFER_INIT,\n+  AIO_TRANSFER_SCALAR,\n+  AIO_TRANSFER_ARRAY,\n+  AIO_WRITE_DONE,\n+  AIO_READ_DONE,\n+  AIO_CLOSE\n+};\n+\n+typedef union transfer_args\n+{\n+  struct\n+  {\n+    void (*transfer) (struct st_parameter_dt *, bt, void *, int, size_t, size_t);\n+    bt arg_bt;\n+    void *data;\n+    int i;\n+    size_t s1;\n+    size_t s2;\n+  } scalar;\n+  struct\n+  {\n+    gfc_array_char *desc;\n+    int kind;\n+    gfc_charlen_type charlen;\n+  } array;\n+} transfer_args;\n+\n+struct adv_cond\n+{\n+  int pending;\n+  __gthread_mutex_t lock;\n+  __gthread_cond_t signal;\n+};\n+\n+typedef struct async_unit\n+{\n+  pthread_mutex_t lock;      /* Lock for manipulating the queue structure.  */\n+  pthread_mutex_t io_lock;   /* Lock for doing actual I/O. */\n+  struct adv_cond work;\n+  struct adv_cond emptysignal;\n+  struct st_parameter_dt *pdt;\n+  pthread_t thread;\n+  struct transfer_queue *head;\n+  struct transfer_queue *tail;\n+  struct\n+  {\n+    int waiting;\n+    int low;\n+    int high;\n+    struct adv_cond done;\n+  } id;\n+\n+  bool empty;\n+\n+  struct {\n+    const char *message;\n+    st_parameter_common *cmp;\n+    bool has_error;\n+    int last_good_id;\n+    int family;\n+    bool fatal_error;\n+  } error;\n+\n+} async_unit;\n+\n+void init_async_unit (gfc_unit *);\n+internal_proto (init_async_unit);\n+\n+bool async_wait (st_parameter_common *, async_unit *);\n+internal_proto (async_wait);\n+\n+bool async_wait_id (st_parameter_common *, async_unit *, int);\n+internal_proto (async_wait_id);\n+\n+bool collect_async_errors (st_parameter_common *, async_unit *);\n+internal_proto (collect_async_errors); \n+\n+void async_close (async_unit *);\n+internal_proto (async_close);\n+\n+void enqueue_transfer (async_unit * au, transfer_args * arg, enum aio_do);\n+internal_proto (enqueue_transfer);\n+\n+void enqueue_done (async_unit *, enum aio_do type);\n+internal_proto (enqueue_done);\n+\n+int enqueue_done_id (async_unit *, enum aio_do type);\n+internal_proto (enqueue_done_id);\n+\n+void enqueue_init (async_unit *);\n+internal_proto (enqueue_init);\n+\n+void enqueue_data_transfer_init (async_unit *, st_parameter_dt *, int);\n+internal_proto (enqueue_data_transfer_init);\n+\n+void enqueue_close (async_unit *);\n+internal_proto (enqueue_close);\n+\n+#endif"}, {"sha": "36d9f94bb938ed419bb952db5e65b387b44aeaf6", "filename": "libgfortran/io/close.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fclose.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -24,6 +24,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"io.h\"\n #include \"unix.h\"\n+#include \"async.h\"\n #include <limits.h>\n \n typedef enum\n@@ -57,13 +58,21 @@ st_close (st_parameter_close *clp)\n     find_option (&clp->common, clp->status, clp->status_len,\n \t\t status_opt, \"Bad STATUS parameter in CLOSE statement\");\n \n+  u = find_unit (clp->common.unit);\n+\n+  if (u && u->au)\n+    if (async_wait (&(clp->common), u->au))\n+      {\n+\tlibrary_end ();\n+\treturn;\n+      }\n+\n   if ((clp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n   {\n     library_end ();\n     return;\n   }\n \n-  u = find_unit (clp->common.unit);\n   if (u != NULL)\n     {\n       if (close_share (u) < 0)"}, {"sha": "362885a37afb30502077b379eeb29ca052481f23", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -25,6 +25,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"io.h\"\n #include \"fbuf.h\"\n #include \"unix.h\"\n+#include \"async.h\"\n #include <string.h>\n \n /* file_pos.c-- Implement the file positioning statements, i.e. BACKSPACE,\n@@ -187,6 +188,7 @@ void\n st_backspace (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n+  bool needs_unlock = false;\n \n   library_start (&fpp->common);\n \n@@ -214,6 +216,17 @@ st_backspace (st_parameter_filepos *fpp)\n       goto done;\n     }\n \n+  if (u->au)\n+    {\n+      if (async_wait (&(fpp->common), u->au))\n+\treturn;\n+      else\n+\t{\n+\t  needs_unlock = true;\n+\t  LOCK (&u->au->io_lock);\n+\t}\n+    }\n+\n   /* Make sure format buffer is flushed and reset.  */\n   if (u->flags.form == FORM_FORMATTED)\n     {\n@@ -267,7 +280,12 @@ st_backspace (st_parameter_filepos *fpp)\n \n  done:\n   if (u != NULL)\n-    unlock_unit (u);\n+    {\n+      unlock_unit (u);\n+\n+      if (u->au && needs_unlock)\n+\tUNLOCK (&u->au->io_lock);\n+    }\n \n   library_end ();\n }\n@@ -280,6 +298,7 @@ void\n st_endfile (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n+  bool needs_unlock = false;\n \n   library_start (&fpp->common);\n \n@@ -294,6 +313,17 @@ st_endfile (st_parameter_filepos *fpp)\n \t  goto done;\n \t}\n \n+      if (u->au)\n+\t{\n+\t  if (async_wait (&(fpp->common), u->au))\n+\t    return;\n+\t  else\n+\t    {\n+\t      needs_unlock = true;\n+\t      LOCK (&u->au->io_lock);\n+\t    }\n+\t}\n+\n       if (u->flags.access == ACCESS_SEQUENTIAL\n       \t  && u->endfile == AFTER_ENDFILE)\n \t{\n@@ -376,8 +406,11 @@ st_endfile (st_parameter_filepos *fpp)\n \t}\n     }\n \n-  done:\n-    unlock_unit (u);\n+ done:\n+  if (u->au && needs_unlock)\n+    UNLOCK (&u->au->io_lock);\n+\n+  unlock_unit (u);\n \n   library_end ();\n }\n@@ -390,6 +423,7 @@ void\n st_rewind (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n+  bool needs_unlock = true;\n \n   library_start (&fpp->common);\n \n@@ -401,6 +435,17 @@ st_rewind (st_parameter_filepos *fpp)\n \t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n       else\n \t{\n+\t  if (u->au)\n+\t    {\n+\t      if (async_wait (&(fpp->common), u->au))\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  needs_unlock = true;\n+\t\t  LOCK (&u->au->io_lock);\n+\t\t}\n+\t    }\n+\n \t  /* If there are previously written bytes from a write with ADVANCE=\"no\",\n \t     add a record marker before performing the ENDFILE.  */\n \n@@ -436,6 +481,10 @@ st_rewind (st_parameter_filepos *fpp)\n \t}\n       /* Update position for INQUIRE.  */\n       u->flags.position = POSITION_REWIND;\n+\n+      if (u->au && needs_unlock)\n+\tUNLOCK (&u->au->io_lock);\n+\n       unlock_unit (u);\n     }\n \n@@ -450,12 +499,24 @@ void\n st_flush (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n+  bool needs_unlock = false;\n \n   library_start (&fpp->common);\n \n   u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n+      if (u->au)\n+\t{\n+\t  if (async_wait (&(fpp->common), u->au))\n+\t    return;\n+\t  else\n+\t    {\n+\t      needs_unlock = true;\n+\t      LOCK (&u->au->io_lock);\n+\t    }\n+\t}\n+\n       /* Make sure format buffer is flushed.  */\n       if (u->flags.form == FORM_FORMATTED)\n         fbuf_flush (u, u->mode);\n@@ -469,5 +530,8 @@ st_flush (st_parameter_filepos *fpp)\n     generate_error (&fpp->common, LIBERROR_BAD_OPTION,\n \t\t\t\"Specified UNIT in FLUSH is not connected\");\n \n+  if (needs_unlock)\n+    UNLOCK (&u->au->io_lock);\n+\n   library_end ();\n }"}, {"sha": "4b6a6f5c1d3712fc2b45215dd05f2773d1791635", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Implement the non-IOLENGTH variant of the INQUIRY statement */\n \n #include \"io.h\"\n+#include \"async.h\"\n #include \"unix.h\"\n #include <string.h>\n \n@@ -281,12 +282,6 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit *u)\n     {\n       GFC_INTEGER_4 cf2 = iqp->flags2;\n \n-      if ((cf2 & IOPARM_INQUIRE_HAS_PENDING) != 0)\n-\t*iqp->pending = 0;\n-  \n-      if ((cf2 & IOPARM_INQUIRE_HAS_ID) != 0)\n-        *iqp->id = 0;\n-\n       if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n \t{\n \t  if (u == NULL || u->flags.form != FORM_FORMATTED)\n@@ -332,21 +327,43 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit *u)\n \t  if (u == NULL)\n \t    p = undefined;\n \t  else\n-\t    switch (u->flags.async)\n \t    {\n-\t      case ASYNC_YES:\n-\t\tp = yes;\n-\t\tbreak;\n-\t      case ASYNC_NO:\n-\t\tp = no;\n-\t\tbreak;\n-\t      default:\n-\t\tinternal_error (&iqp->common, \"inquire_via_unit(): Bad async\");\n+\t      switch (u->flags.async)\n+\t\t{\n+\t\tcase ASYNC_YES:\n+\t\t  p = yes;\n+\t\t  break;\n+\t\tcase ASYNC_NO:\n+\t\t  p = no;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  internal_error (&iqp->common, \"inquire_via_unit(): Bad async\");\n+\t\t}\n \t    }\n-\n \t  cf_strcpy (iqp->asynchronous, iqp->asynchronous_len, p);\n \t}\n \n+      if ((cf2 & IOPARM_INQUIRE_HAS_PENDING) != 0)\n+\t{\n+\t  if (u->au == NULL)\n+\t    *(iqp->pending) = 0;\n+\t  else\n+\t    {\n+\t      LOCK (&(u->au->lock));\n+\t      if ((cf2 & IOPARM_INQUIRE_HAS_ID) != 0)\n+\t\t{\n+\t\t  int id;\n+\t\t  id = *(iqp->id);\n+\t\t  *(iqp->pending) = id > u->au->id.low;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *(iqp->pending) = ! u->au->empty;\n+\t\t}\n+\t      UNLOCK (&(u->au->lock));\n+\t    }\n+\t}\n+\n       if ((cf2 & IOPARM_INQUIRE_HAS_SIGN) != 0)\n \t{\n \t  if (u == NULL)"}, {"sha": "d31213106edaf23f89937d30ff7eb83963e4b74f", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -531,7 +531,9 @@ typedef struct st_parameter_dt\n \t  /* A flag used to identify when a non-standard expanded namelist read\n \t     has occurred.  */\n \t  unsigned expanded_read : 1;\n-\t  /* 13 unused bits.  */\n+\t  /* Flag to indicate if the statement has async=\"YES\". */\n+\t  unsigned async : 1;\n+\t  /* 12 unused bits.  */\n \n \t  int child_saved_iostat;\n \t  int nml_delim;\n@@ -590,7 +592,7 @@ extern char check_st_parameter_dt[sizeof (((st_parameter_dt *) 0)->u.pad)\n typedef struct\n {\n   st_parameter_common common;\n-  CHARACTER1 (id);\n+  GFC_INTEGER_4 *id;\n }\n st_parameter_wait;\n \n@@ -659,6 +661,9 @@ typedef struct gfc_unit\n \n   int continued;\n \n+  /* Contains the pointer to the async unit.  */\n+  struct async_unit *au;\n+\n   __gthread_mutex_t lock;\n   /* Number of threads waiting to acquire this unit's lock.\n      When non-zero, close_unit doesn't only removes the unit\n@@ -815,11 +820,18 @@ extern void next_record (st_parameter_dt *, int);\n internal_proto(next_record);\n \n extern void st_wait (st_parameter_wait *);\n-export_proto(st_wait);\n+export_proto (st_wait);\n+\n+extern void st_wait_async (st_parameter_wait *);\n+export_proto (st_wait_async);\n \n extern void hit_eof (st_parameter_dt *);\n internal_proto(hit_eof);\n \n+extern void transfer_array_inner (st_parameter_dt *, gfc_array_char *, int,\n+\t\t\t\t  gfc_charlen_type);\n+internal_proto (transfer_array_inner);\n+\n /* read.c */\n \n extern void set_integer (void *, GFC_INTEGER_LARGEST, int);\n@@ -988,3 +1000,14 @@ memset4 (gfc_char4_t *p, gfc_char4_t c, int k)\n \n #endif\n \n+extern void\n+st_write_done_worker (st_parameter_dt *);\n+internal_proto (st_write_done_worker);\n+\n+extern void\n+st_read_done_worker (st_parameter_dt *);\n+internal_proto (st_read_done_worker);\n+\n+extern void\n+data_transfer_init_worker (st_parameter_dt *, int);\n+internal_proto (data_transfer_init_worker);"}, {"sha": "266033815fd0078b93620443cf34a44a870bb214", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"io.h\"\n #include \"fbuf.h\"\n #include \"unix.h\"\n+#include \"async.h\"\n \n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n@@ -651,8 +652,12 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags *flags)\n   else\n     u->fbuf = NULL;\n \n-    \n-    \n+  /* Check if asynchrounous.  */\n+  if (flags->async == ASYNC_YES)\n+    init_async_unit (u);\n+  else\n+    u->au = NULL;\n+\n   return u;\n \n  cleanup:"}, {"sha": "f972858c146d0e60f7b7e6b5875686358e725201", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -30,6 +30,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <ctype.h>\n #include <assert.h>\n+#include \"async.h\"\n \n typedef unsigned char uchar;\n \n@@ -42,6 +43,7 @@ typedef unsigned char uchar;\n void\n set_integer (void *dest, GFC_INTEGER_LARGEST value, int length)\n {\n+  NOTE (\"set_integer: %lld %p\", (long long int) value, dest);\n   switch (length)\n     {\n #ifdef HAVE_GFC_INTEGER_16"}, {"sha": "fa66e0f362d6fc79793a9e7b52bafa2f2181353d", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 252, "deletions": 57, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -31,6 +31,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"fbuf.h\"\n #include \"format.h\"\n #include \"unix.h\"\n+#include \"async.h\"\n #include <string.h>\n #include <errno.h>\n \n@@ -184,6 +185,12 @@ static const st_option pad_opt[] = {\n   {NULL, 0}\n };\n \n+static const st_option async_opt[] = {\n+  {\"yes\", ASYNC_YES},\n+  {\"no\", ASYNC_NO},\n+  {NULL, 0}\n+};\n+\n typedef enum\n { FORMATTED_SEQUENTIAL, UNFORMATTED_SEQUENTIAL,\n   FORMATTED_DIRECT, UNFORMATTED_DIRECT, FORMATTED_STREAM, UNFORMATTED_STREAM\n@@ -1594,7 +1601,8 @@ formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind\n \t\tread_f (dtp, f, p, kind);\n \t\tbreak;\n \t      default:\n-\t\tinternal_error (&dtp->common, \"formatted_transfer(): Bad type\");\n+\t\tinternal_error (&dtp->common,\n+\t\t\t\t\"formatted_transfer (): Bad type\");\n \t    }\n \t  break;\n \n@@ -2066,7 +2074,7 @@ formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kin\n \t\tbreak;\n \t      default:\n \t\tinternal_error (&dtp->common,\n-\t\t\t\t\"formatted_transfer(): Bad type\");\n+\t\t\t\t\"formatted_transfer (): Bad type\");\n \t    }\n \t  break;\n \n@@ -2281,6 +2289,38 @@ formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n     }\n }\n \n+/* Wrapper function for I/O of scalar types.  If this should be an async I/O\n+   request, queue it.  For a synchronous write on an async unit, perform the\n+   wait operation and return an error.  For all synchronous writes, call the\n+   right transfer function.  */\n+\n+static void\n+wrap_scalar_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t      size_t size, size_t n_elem)\n+{\n+  if (dtp->u.p.current_unit && dtp->u.p.current_unit->au)\n+    {\n+      if (dtp->u.p.async)\n+\t{\n+\t  transfer_args args;\n+\t  args.scalar.transfer = dtp->u.p.transfer;\n+\t  args.scalar.arg_bt = type;\n+\t  args.scalar.data = p;\n+\t  args.scalar.i = kind;\n+\t  args.scalar.s1 = size;\n+\t  args.scalar.s2 = n_elem;\n+\t  enqueue_transfer (dtp->u.p.current_unit->au, &args,\n+\t\t\t    AIO_TRANSFER_SCALAR);\n+\t  return;\n+\t}\n+    }\n+  /* Come here if there was no asynchronous I/O to be scheduled.  */\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n+    return;\n+\n+  dtp->u.p.transfer (dtp, type, p, kind, size, 1);\n+}\n+\n \n /* Data transfer entry points.  The type of the data entity is\n    implicit in the subroutine call.  This prevents us from having to\n@@ -2289,9 +2329,7 @@ formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n void\n transfer_integer (st_parameter_dt *dtp, void *p, int kind)\n {\n-  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n-    return;\n-  dtp->u.p.transfer (dtp, BT_INTEGER, p, kind, kind, 1);\n+    wrap_scalar_transfer (dtp, BT_INTEGER, p, kind, kind, 1);\n }\n \n void\n@@ -2307,7 +2345,7 @@ transfer_real (st_parameter_dt *dtp, void *p, int kind)\n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n   size = size_from_real_kind (kind);\n-  dtp->u.p.transfer (dtp, BT_REAL, p, kind, size, 1);\n+  wrap_scalar_transfer (dtp, BT_REAL, p, kind, size, 1);\n }\n \n void\n@@ -2319,9 +2357,7 @@ transfer_real_write (st_parameter_dt *dtp, void *p, int kind)\n void\n transfer_logical (st_parameter_dt *dtp, void *p, int kind)\n {\n-  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n-    return;\n-  dtp->u.p.transfer (dtp, BT_LOGICAL, p, kind, kind, 1);\n+  wrap_scalar_transfer (dtp, BT_LOGICAL, p, kind, kind, 1);\n }\n \n void\n@@ -2345,7 +2381,7 @@ transfer_character (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n     p = empty_string;\n \n   /* Set kind here to 1.  */\n-  dtp->u.p.transfer (dtp, BT_CHARACTER, p, 1, len, 1);\n+  wrap_scalar_transfer (dtp, BT_CHARACTER, p, 1, len, 1);\n }\n \n void\n@@ -2369,7 +2405,7 @@ transfer_character_wide (st_parameter_dt *dtp, void *p, gfc_charlen_type len, in\n     p = empty_string;\n \n   /* Here we pass the actual kind value.  */\n-  dtp->u.p.transfer (dtp, BT_CHARACTER, p, kind, len, 1);\n+  wrap_scalar_transfer (dtp, BT_CHARACTER, p, kind, len, 1);\n }\n \n void\n@@ -2385,7 +2421,7 @@ transfer_complex (st_parameter_dt *dtp, void *p, int kind)\n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n   size = size_from_complex_kind (kind);\n-  dtp->u.p.transfer (dtp, BT_COMPLEX, p, kind, size, 1);\n+  wrap_scalar_transfer (dtp, BT_COMPLEX, p, kind, size, 1);\n }\n \n void\n@@ -2395,8 +2431,8 @@ transfer_complex_write (st_parameter_dt *dtp, void *p, int kind)\n }\n \n void\n-transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n-\t\tgfc_charlen_type charlen)\n+transfer_array_inner (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n+\t\t      gfc_charlen_type charlen)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -2407,7 +2443,7 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n   bt iotype;\n \n   /* Adjust item_count before emitting error message.  */\n- \n+\n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n@@ -2470,6 +2506,36 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n     }\n }\n \n+void\n+transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n+\t        gfc_charlen_type charlen)\n+{\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n+    return;\n+\n+  if (dtp->u.p.current_unit && dtp->u.p.current_unit->au)\n+    {\n+      if (dtp->u.p.async)\n+\t{\n+\t  transfer_args args;\n+\t  size_t sz = sizeof (gfc_array_char)\n+\t\t\t+ sizeof (descriptor_dimension)\n+       \t\t\t* GFC_DESCRIPTOR_RANK (desc);\n+\t  args.array.desc = xmalloc (sz);\n+\t  NOTE (\"desc = %p\", (void *) args.array.desc);\n+\t  memcpy (args.array.desc, desc, sz);\n+\t  args.array.kind = kind;\n+\t  args.array.charlen = charlen;\n+\t  enqueue_transfer (dtp->u.p.current_unit->au, &args,\n+\t\t\t    AIO_TRANSFER_ARRAY);\n+\t  return;\n+\t}\n+    }\n+  /* Come here if there was no asynchronous I/O to be scheduled.  */\n+  transfer_array_inner (dtp, desc, kind, charlen);\n+}\n+\n+\n void\n transfer_array_write (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n \t\t      gfc_charlen_type charlen)\n@@ -2492,7 +2558,7 @@ transfer_derived (st_parameter_dt *parent, void *dtio_source, void *dtio_proc)\n       else\n \tparent->u.p.fdtio_ptr = (formatted_dtio) dtio_proc;\n     }\n-  parent->u.p.transfer (parent, BT_CLASS, dtio_source, 0, 0, 1);\n+  wrap_scalar_transfer (parent, BT_CLASS, dtio_source, 0, 0, 1);\n }\n \n \n@@ -2667,6 +2733,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   unit_flags u_flags;  /* Used for creating a unit if needed.  */\n   GFC_INTEGER_4 cf = dtp->common.flags;\n   namelist_info *ionml;\n+  async_unit *au;\n+\n+  NOTE (\"data_transfer_init\");\n \n   ionml = ((cf & IOPARM_DT_IONML_SET) != 0) ? dtp->u.p.ionml : NULL;\n \n@@ -2693,9 +2762,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     }\n   else if (dtp->u.p.current_unit->s == NULL)\n     {  /* Open the unit with some default flags.  */\n-       st_parameter_open opp;\n-       unit_convert conv;\n-\n+      st_parameter_open opp;\n+      unit_convert conv;\n+      NOTE (\"Open the unit with some default flags.\");\n       memset (&u_flags, '\\0', sizeof (u_flags));\n       u_flags.access = ACCESS_SEQUENTIAL;\n       u_flags.action = ACTION_READWRITE;\n@@ -2770,6 +2839,42 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   else if (dtp->u.p.current_unit->internal_unit_kind > 0)\n     dtp->u.p.unit_is_internal = 1;\n \n+  if ((cf & IOPARM_DT_HAS_ASYNCHRONOUS) != 0)\n+    {\n+      int f;\n+      f = find_option (&dtp->common, dtp->asynchronous, dtp->asynchronous_len,\n+\t\t       async_opt, \"Bad ASYNCHRONOUS in data transfer \"\n+\t\t       \"statement\");\n+      if (f == ASYNC_YES && dtp->u.p.current_unit->flags.async != ASYNC_YES)\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t  \"ASYNCHRONOUS transfer without \"\n+\t\t\t  \"ASYHCRONOUS='YES' in OPEN\");\n+\t  return;\n+\t}\n+      dtp->u.p.async = f == ASYNC_YES;\n+    }\n+\n+  au = dtp->u.p.current_unit->au;\n+  if (au)\n+    {\n+      if (dtp->u.p.async)\n+\t{\n+\t  /* If this is an asynchronous I/O statement, collect errors and\n+\t     return if there are any.  */\n+\t  if (collect_async_errors (&dtp->common, au))\n+\t    return;\n+\t}\n+      else\n+\t{\n+\t  /* Synchronous statement: Perform a wait operation for any pending\n+\t     asynchronous I/O.  This needs to be done before all other error\n+\t     checks.  See F2008, 9.6.4.1.  */\n+\t  if (async_wait (&(dtp->common), au))\n+\t    return;\n+\t}\n+    }\n+\n   /* Check the action.  */\n \n   if (read_flag && dtp->u.p.current_unit->flags.action == ACTION_WRITE)\n@@ -3009,6 +3114,57 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n \tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n \n+  /* Set up the subroutine that will handle the transfers.  */\n+\n+  if (read_flag)\n+    {\n+      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+\tdtp->u.p.transfer = unformatted_read;\n+      else\n+\t{\n+\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n+\t    dtp->u.p.transfer = list_formatted_read;\n+\t  else\n+\t    dtp->u.p.transfer = formatted_transfer;\n+\t}\n+    }\n+  else\n+    {\n+      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+\tdtp->u.p.transfer = unformatted_write;\n+      else\n+\t{\n+\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n+\t    dtp->u.p.transfer = list_formatted_write;\n+\t  else\n+\t    dtp->u.p.transfer = formatted_transfer;\n+\t}\n+    }\n+\n+  if (au)\n+    {\n+      NOTE (\"enqueue_data_transfer\");\n+      enqueue_data_transfer_init (au, dtp, read_flag);\n+    }\n+  else\n+    {\n+      NOTE (\"invoking data_transfer_init_worker\");\n+      data_transfer_init_worker (dtp, read_flag);\n+    }\n+}\n+\n+void\n+data_transfer_init_worker (st_parameter_dt *dtp, int read_flag)\n+{\n+  GFC_INTEGER_4 cf = dtp->common.flags;\n+\n+  NOTE (\"starting worker...\");\n+\n+  if (read_flag && dtp->u.p.current_unit->flags.form != FORM_UNFORMATTED\n+      && ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n+      && dtp->u.p.current_unit->child_dtio  == 0)\n+    dtp->u.p.current_unit->last_char = EOF - 1;\n+\n   /* Check to see if we might be reading what we wrote before  */\n \n   if (dtp->u.p.mode != dtp->u.p.current_unit->mode\n@@ -3135,38 +3291,6 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n   pre_position (dtp);\n \n-\n-  /* Set up the subroutine that will handle the transfers.  */\n-\n-  if (read_flag)\n-    {\n-      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n-\tdtp->u.p.transfer = unformatted_read;\n-      else\n-\t{\n-\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n-\t    {\n-\t      if (dtp->u.p.current_unit->child_dtio  == 0)\n-\t        dtp->u.p.current_unit->last_char = EOF - 1;\n-\t      dtp->u.p.transfer = list_formatted_read;\n-\t    }\n-\t  else\n-\t    dtp->u.p.transfer = formatted_transfer;\n-\t}\n-    }\n-  else\n-    {\n-      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n-\tdtp->u.p.transfer = unformatted_write;\n-      else\n-\t{\n-\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n-\t    dtp->u.p.transfer = list_formatted_write;\n-\t  else\n-\t    dtp->u.p.transfer = formatted_transfer;\n-\t}\n-    }\n-\n   /* Make sure that we don't do a read after a nonadvancing write.  */\n \n   if (read_flag)\n@@ -4099,7 +4223,7 @@ extern void st_read_done (st_parameter_dt *);\n export_proto(st_read_done);\n \n void\n-st_read_done (st_parameter_dt *dtp)\n+st_read_done_worker (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n \n@@ -4127,14 +4251,38 @@ st_read_done (st_parameter_dt *dtp)\n \t  free_format_data (dtp->u.p.fmt);\n \t  free_format (dtp);\n \t}\n+    }\n+}\n+\n+void\n+st_read_done (st_parameter_dt *dtp)\n+{\n+  if (dtp->u.p.current_unit)\n+    {\n+      if (dtp->u.p.current_unit->au)\n+\t{\n+\t  if (dtp->common.flags & IOPARM_DT_HAS_ID)\n+\t    *dtp->id = enqueue_done_id (dtp->u.p.current_unit->au, AIO_READ_DONE);  \n+\t  else\n+\t    {\n+\t      enqueue_done (dtp->u.p.current_unit->au, AIO_READ_DONE);\n+\t      /* An asynchronous unit without ASYNCHRONOUS=\"YES\" - make this\n+\t\t synchronous by performing a wait operation.  */\n+\t      if (!dtp->u.p.async)\n+\t\tasync_wait (&dtp->common, dtp->u.p.current_unit->au);\n+\t    }\n+\t}\n+      else\n+\tst_read_done_worker (dtp);\n+\n       unlock_unit (dtp->u.p.current_unit);\n     }\n \n   library_end ();\n }\n \n extern void st_write (st_parameter_dt *);\n-export_proto(st_write);\n+export_proto (st_write);\n \n void\n st_write (st_parameter_dt *dtp)\n@@ -4143,11 +4291,9 @@ st_write (st_parameter_dt *dtp)\n   data_transfer_init (dtp, 0);\n }\n \n-extern void st_write_done (st_parameter_dt *);\n-export_proto(st_write_done);\n \n void\n-st_write_done (st_parameter_dt *dtp)\n+st_write_done_worker (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n \n@@ -4196,16 +4342,65 @@ st_write_done (st_parameter_dt *dtp)\n \t  free_format_data (dtp->u.p.fmt);\n \t  free_format (dtp);\n \t}\n+    }\n+}\n+\n+extern void st_write_done (st_parameter_dt *);\n+export_proto(st_write_done);\n+\n+void\n+st_write_done (st_parameter_dt *dtp)\n+{\n+  if (dtp->u.p.current_unit)\n+    {\n+      if (dtp->u.p.current_unit->au)\n+\t{\n+\t  if (dtp->common.flags & IOPARM_DT_HAS_ID)\n+\t    *dtp->id = enqueue_done_id (dtp->u.p.current_unit->au,\n+\t\t\t\t\tAIO_WRITE_DONE);\n+\t  else\n+\t    {\n+\t      enqueue_done (dtp->u.p.current_unit->au, AIO_WRITE_DONE);\n+\t      /* An asynchronous unit without ASYNCHRONOUS=\"YES\" - make this\n+\t\t synchronous by performing a wait operation.  */\n+\t      if (!dtp->u.p.async)\n+\t\tasync_wait (&dtp->common, dtp->u.p.current_unit->au);\n+\t    }\n+\t}\n+      else\n+\tst_write_done_worker (dtp);\n+\n       unlock_unit (dtp->u.p.current_unit);\n     }\n+\n   library_end ();\n }\n \n+/* Wait operation.  We need to keep around the do-nothing version\n+ of st_wait for compatibility with previous versions, which had marked\n+ the argument as unused (and thus liable to be removed).\n+\n+ TODO: remove at next bump in version number.  */\n \n-/* F2003: This is a stub for the runtime portion of the WAIT statement.  */\n void\n st_wait (st_parameter_wait *wtp __attribute__((unused)))\n {\n+  return;\n+}\n+\n+void\n+st_wait_async (st_parameter_wait *wtp)\n+{\n+  gfc_unit *u = find_unit (wtp->common.unit);\n+  if (u->au)\n+    {\n+      if (wtp->common.flags & IOPARM_WAIT_HAS_ID)\n+\tasync_wait_id (&(wtp->common), u->au, *wtp->id);\n+      else\n+\tasync_wait (&(wtp->common), u->au);\n+    }\n+\n+  unlock_unit (u);\n }\n \n "}, {"sha": "0d0ca8f60559f3d514e41967839fd21fff162d9b", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -27,6 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"fbuf.h\"\n #include \"format.h\"\n #include \"unix.h\"\n+#include \"async.h\"\n #include <string.h>\n #include <assert.h>\n \n@@ -240,7 +241,7 @@ insert_unit (int n)\n #else\n   __GTHREAD_MUTEX_INIT_FUNCTION (&u->lock);\n #endif\n-  __gthread_mutex_lock (&u->lock);\n+  LOCK (&u->lock);\n   u->priority = pseudo_random ();\n   unit_root = insert (u, unit_root);\n   return u;\n@@ -327,7 +328,9 @@ get_gfc_unit (int n, int do_create)\n   gfc_unit *p;\n   int c, created = 0;\n \n-  __gthread_mutex_lock (&unit_lock);\n+  NOTE (\"Unit n=%d, do_create = %d\", n, do_create);\n+  LOCK (&unit_lock);\n+\n retry:\n   for (c = 0; c < CACHE_SIZE; c++)\n     if (unit_cache[c] != NULL && unit_cache[c]->unit_number == n)\n@@ -366,34 +369,34 @@ get_gfc_unit (int n, int do_create)\n     {\n       /* Newly created units have their lock held already\n \t from insert_unit.  Just unlock UNIT_LOCK and return.  */\n-      __gthread_mutex_unlock (&unit_lock);\n+      UNLOCK (&unit_lock);\n       return p;\n     }\n \n found:\n   if (p != NULL && (p->child_dtio == 0))\n     {\n       /* Fast path.  */\n-      if (! __gthread_mutex_trylock (&p->lock))\n+      if (! TRYLOCK (&p->lock))\n \t{\n \t  /* assert (p->closed == 0); */\n-\t  __gthread_mutex_unlock (&unit_lock);\n+\t  UNLOCK (&unit_lock);\n \t  return p;\n \t}\n \n       inc_waiting_locked (p);\n     }\n \n \n-  __gthread_mutex_unlock (&unit_lock);\n+  UNLOCK (&unit_lock);\n \n   if (p != NULL && (p->child_dtio == 0))\n     {\n-      __gthread_mutex_lock (&p->lock);\n+      LOCK (&p->lock);\n       if (p->closed)\n \t{\n-\t  __gthread_mutex_lock (&unit_lock);\n-\t  __gthread_mutex_unlock (&p->lock);\n+\t  LOCK (&unit_lock);\n+\t  UNLOCK (&p->lock);\n \t  if (predec_waiting_locked (p) == 0)\n \t    destroy_unit_mutex (p);\n \t  goto retry;\n@@ -640,7 +643,7 @@ init_units (void)\n \n       fbuf_init (u, 0);\n \n-      __gthread_mutex_unlock (&u->lock);\n+      UNLOCK (&u->lock);\n     }\n \n   if (options.stdout_unit >= 0)\n@@ -671,7 +674,7 @@ init_units (void)\n \n       fbuf_init (u, 0);\n \n-      __gthread_mutex_unlock (&u->lock);\n+      UNLOCK (&u->lock);\n     }\n \n   if (options.stderr_unit >= 0)\n@@ -702,13 +705,13 @@ init_units (void)\n       fbuf_init (u, 256);  /* 256 bytes should be enough, probably not doing\n                               any kind of exotic formatting to stderr.  */\n \n-      __gthread_mutex_unlock (&u->lock);\n+      UNLOCK (&u->lock);\n     }\n   /* The default internal units.  */\n   u = insert_unit (GFC_INTERNAL_UNIT);\n-  __gthread_mutex_unlock (&u->lock);\n+  UNLOCK (&u->lock);\n   u = insert_unit (GFC_INTERNAL_UNIT4);\n-  __gthread_mutex_unlock (&u->lock);\n+  UNLOCK (&u->lock);\n }\n \n \n@@ -717,6 +720,9 @@ close_unit_1 (gfc_unit *u, int locked)\n {\n   int i, rc;\n \n+  if (u->au)\n+    async_close (u->au);\n+\n   /* If there are previously written bytes from a write with ADVANCE=\"no\"\n      Reposition the buffer before closing.  */\n   if (u->previous_nonadvancing_write)\n@@ -726,7 +732,7 @@ close_unit_1 (gfc_unit *u, int locked)\n \n   u->closed = 1;\n   if (!locked)\n-    __gthread_mutex_lock (&unit_lock);\n+    LOCK (&unit_lock);\n \n   for (i = 0; i < CACHE_SIZE; i++)\n     if (unit_cache[i] == u)\n@@ -744,7 +750,7 @@ close_unit_1 (gfc_unit *u, int locked)\n     newunit_free (u->unit_number);\n \n   if (!locked)\n-    __gthread_mutex_unlock (&u->lock);\n+    UNLOCK (&u->lock);\n \n   /* If there are any threads waiting in find_unit for this unit,\n      avoid freeing the memory, the last such thread will free it\n@@ -753,15 +759,17 @@ close_unit_1 (gfc_unit *u, int locked)\n     destroy_unit_mutex (u);\n \n   if (!locked)\n-    __gthread_mutex_unlock (&unit_lock);\n+    UNLOCK (&unit_lock);\n \n   return rc;\n }\n \n void\n unlock_unit (gfc_unit *u)\n {\n-  __gthread_mutex_unlock (&u->lock);\n+  NOTE (\"unlock_unit = %d\", u->unit_number);\n+  UNLOCK (&u->lock);\n+  NOTE (\"unlock_unit done\");\n }\n \n /* close_unit()-- Close a unit.  The stream is closed, and any memory\n@@ -785,10 +793,10 @@ close_unit (gfc_unit *u)\n void\n close_units (void)\n {\n-  __gthread_mutex_lock (&unit_lock);\n+  LOCK (&unit_lock);\n   while (unit_root != NULL)\n     close_unit_1 (unit_root, 1);\n-  __gthread_mutex_unlock (&unit_lock);\n+  UNLOCK (&unit_lock);\n \n   free (newunits);\n \n@@ -895,7 +903,7 @@ finish_last_advance_record (gfc_unit *u)\n int\n newunit_alloc (void)\n {\n-  __gthread_mutex_lock (&unit_lock);\n+  LOCK (&unit_lock);\n   if (!newunits)\n     {\n       newunits = xcalloc (16, 1);\n@@ -909,7 +917,7 @@ newunit_alloc (void)\n         {\n           newunits[ii] = true;\n           newunit_lwi = ii + 1;\n-\t  __gthread_mutex_unlock (&unit_lock);\n+\t  UNLOCK (&unit_lock);\n           return -ii + NEWUNIT_START;\n         }\n     }\n@@ -922,7 +930,7 @@ newunit_alloc (void)\n   memset (newunits + old_size, 0, old_size);\n   newunits[old_size] = true;\n   newunit_lwi = old_size + 1;\n-    __gthread_mutex_unlock (&unit_lock);\n+    UNLOCK (&unit_lock);\n   return -old_size + NEWUNIT_START;\n }\n "}, {"sha": "4a133fd44bd20d2e8424e0990dfc9c92b875a074", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -27,6 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"io.h\"\n #include \"unix.h\"\n+#include \"async.h\"\n #include <limits.h>\n \n #ifdef HAVE_UNISTD_H\n@@ -1742,7 +1743,7 @@ find_file (const char *file, gfc_charlen_type file_len)\n   id = id_from_path (path);\n #endif\n \n-  __gthread_mutex_lock (&unit_lock);\n+  LOCK (&unit_lock);\n retry:\n   u = find_file0 (unit_root, FIND_FILE0_ARGS);\n   if (u != NULL)\n@@ -1751,20 +1752,20 @@ find_file (const char *file, gfc_charlen_type file_len)\n       if (! __gthread_mutex_trylock (&u->lock))\n \t{\n \t  /* assert (u->closed == 0); */\n-\t  __gthread_mutex_unlock (&unit_lock);\n+\t  UNLOCK (&unit_lock);\n \t  goto done;\n \t}\n \n       inc_waiting_locked (u);\n     }\n-  __gthread_mutex_unlock (&unit_lock);\n+  UNLOCK (&unit_lock);\n   if (u != NULL)\n     {\n-      __gthread_mutex_lock (&u->lock);\n+      LOCK (&u->lock);\n       if (u->closed)\n \t{\n-\t  __gthread_mutex_lock (&unit_lock);\n-\t  __gthread_mutex_unlock (&u->lock);\n+\t  LOCK (&unit_lock);\n+\t  UNLOCK (&u->lock);\n \t  if (predec_waiting_locked (u) == 0)\n \t    free (u);\n \t  goto retry;\n@@ -1794,7 +1795,7 @@ flush_all_units_1 (gfc_unit *u, int min_unit)\n \t    return u;\n \t  if (u->s)\n \t    sflush (u->s);\n-\t  __gthread_mutex_unlock (&u->lock);\n+\t  UNLOCK (&u->lock);\n \t}\n       u = u->right;\n     }\n@@ -1807,31 +1808,31 @@ flush_all_units (void)\n   gfc_unit *u;\n   int min_unit = 0;\n \n-  __gthread_mutex_lock (&unit_lock);\n+  LOCK (&unit_lock);\n   do\n     {\n       u = flush_all_units_1 (unit_root, min_unit);\n       if (u != NULL)\n \tinc_waiting_locked (u);\n-      __gthread_mutex_unlock (&unit_lock);\n+      UNLOCK (&unit_lock);\n       if (u == NULL)\n \treturn;\n \n-      __gthread_mutex_lock (&u->lock);\n+      LOCK (&u->lock);\n \n       min_unit = u->unit_number + 1;\n \n       if (u->closed == 0)\n \t{\n \t  sflush (u->s);\n-\t  __gthread_mutex_lock (&unit_lock);\n-\t  __gthread_mutex_unlock (&u->lock);\n+\t  LOCK (&unit_lock);\n+\t  UNLOCK (&u->lock);\n \t  (void) predec_waiting_locked (u);\n \t}\n       else\n \t{\n-\t  __gthread_mutex_lock (&unit_lock);\n-\t  __gthread_mutex_unlock (&u->lock);\n+\t  LOCK (&unit_lock);\n+\t  UNLOCK (&u->lock);\n \t  if (predec_waiting_locked (u) == 0)\n \t    free (u);\n \t}"}, {"sha": "b5a742aac88772a2d7d73ee415582056f658e21f", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -738,6 +738,9 @@ internal_proto(translate_error);\n extern void generate_error (st_parameter_common *, int, const char *);\n iexport_proto(generate_error);\n \n+extern bool generate_error_common (st_parameter_common *, int, const char *);\n+iexport_proto(generate_error_common);\n+\n extern void generate_warning (st_parameter_common *, const char *);\n internal_proto(generate_warning);\n \n@@ -1743,5 +1746,7 @@ void cshift1_16_c16 (gfc_array_c16 * const restrict,\n internal_proto(cshift1_16_c16);\n #endif\n \n+/* Define this if we support asynchronous I/O on this platform.  This\n+   currently requires weak symbols.  */\n \n #endif  /* LIBGFOR_H  */"}, {"sha": "811d86b0737c0bc86efd7f78c386b7477461ff8d", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -24,6 +24,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n \n #include \"libgfortran.h\"\n+#include \"io.h\"\n+#include \"async.h\"\n+\n #include <assert.h>\n #include <string.h>\n #include <errno.h>\n@@ -526,24 +529,38 @@ translate_error (int code)\n }\n \n \n-/* generate_error()-- Come here when an error happens.  This\n- * subroutine is called if it is possible to continue on after the error.\n- * If an IOSTAT or IOMSG variable exists, we set it.  If IOSTAT or\n- * ERR labels are present, we return, otherwise we terminate the program\n- * after printing a message.  The error code is always required but the\n- * message parameter can be NULL, in which case a string describing\n- * the most recent operating system error is used. */\n+/* Worker function for generate_error and generate_error_async.  Return true\n+   if a straight return is to be done, zero if the program should abort. */\n \n-void\n-generate_error (st_parameter_common *cmp, int family, const char *message)\n+bool\n+generate_error_common (st_parameter_common *cmp, int family, const char *message)\n {\n   char errmsg[STRERR_MAXSZ];\n+  gfc_unit *u;\n+\n+  NOTE (\"Entering generate_error_common\");\n+\n+  u = thread_unit;\n+  if (u && u->au)\n+    {\n+      if (u->au->error.has_error)\n+\treturn true;\n+\n+      if (__gthread_equal (u->au->thread, __gthread_self ()))\n+\t{\n+\t  u->au->error.has_error = 1;\n+\t  u->au->error.cmp = cmp;\n+\t  u->au->error.family = family;\n+\t  u->au->error.message = message;\n+\t  return true;\n+\t}\n+    }\n \n   /* If there was a previous error, don't mask it with another\n      error message, EOF or EOR condition.  */\n \n   if ((cmp->flags & IOPARM_LIBRETURN_MASK) == IOPARM_LIBRETURN_ERROR)\n-    return;\n+    return true;\n \n   /* Set the error status.  */\n   if ((cmp->flags & IOPARM_HAS_IOSTAT))\n@@ -562,36 +579,56 @@ generate_error (st_parameter_common *cmp, int family, const char *message)\n   switch (family)\n     {\n     case LIBERROR_EOR:\n-      cmp->flags |= IOPARM_LIBRETURN_EOR;\n+      cmp->flags |= IOPARM_LIBRETURN_EOR;  NOTE(\"EOR\");\n       if ((cmp->flags & IOPARM_EOR))\n-\treturn;\n+\treturn true;\n       break;\n \n     case LIBERROR_END:\n-      cmp->flags |= IOPARM_LIBRETURN_END;\n+      cmp->flags |= IOPARM_LIBRETURN_END; NOTE(\"END\");\n       if ((cmp->flags & IOPARM_END))\n-\treturn;\n+\treturn true;\n       break;\n \n     default:\n-      cmp->flags |= IOPARM_LIBRETURN_ERROR;\n+      cmp->flags |= IOPARM_LIBRETURN_ERROR; NOTE(\"ERROR\");\n       if ((cmp->flags & IOPARM_ERR))\n-\treturn;\n+\treturn true;\n       break;\n     }\n \n   /* Return if the user supplied an iostat variable.  */\n   if ((cmp->flags & IOPARM_HAS_IOSTAT))\n-    return;\n+    return true;\n \n-  /* Terminate the program */\n+  /* Return code, caller is responsible for terminating\n+   the program if necessary.  */\n \n   recursion_check ();\n   show_locus (cmp);\n   estr_write (\"Fortran runtime error: \");\n   estr_write (message);\n   estr_write (\"\\n\");\n-  exit_error (2);\n+  return false;\n+}\n+\n+/* generate_error()-- Come here when an error happens.  This\n+ * subroutine is called if it is possible to continue on after the error.\n+ * If an IOSTAT or IOMSG variable exists, we set it.  If IOSTAT or\n+ * ERR labels are present, we return, otherwise we terminate the program\n+ * after printing a message.  The error code is always required but the\n+ * message parameter can be NULL, in which case a string describing\n+ * the most recent operating system error is used.\n+ * If the error is for an asynchronous unit and if the program is currently\n+ * executing the asynchronous thread, just mark the error and return.  */\n+\n+void\n+generate_error (st_parameter_common *cmp, int family, const char *message)\n+{\n+  if (generate_error_common (cmp, family, message))\n+    return;\n+\n+  exit_error(2);\n }\n iexport(generate_error);\n "}, {"sha": "098f469d61cf6b7e9601d47da6033fa27e0870a6", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f45884f676cd5bde92d6babac2e8d44629f5ac/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b1f45884f676cd5bde92d6babac2e8d44629f5ac", "patch": "@@ -1,3 +1,15 @@\n+2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* testsuite/libgomp.fortran/async_io_1.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_2.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_3.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_4.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_5.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_6.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_7.f90: New test.\n+\n 2018-07-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/86542"}]}