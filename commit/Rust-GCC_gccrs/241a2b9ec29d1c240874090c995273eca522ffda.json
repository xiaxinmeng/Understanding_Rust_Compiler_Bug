{"sha": "241a2b9ec29d1c240874090c995273eca522ffda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxYTJiOWVjMjlkMWMyNDA4NzQwOTBjOTk1MjczZWNhNTIyZmZkYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-08-03T14:23:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-08-03T14:23:04Z"}, "message": "ipa-split.c (struct split_point): Add split_part_set_retval.\n\n\n\t* ipa-split.c (struct split_point): Add split_part_set_retval.\n\t(find_retval): Forward declare.\n\t(test_nonssa_use, mark_nonssa_use): Special case return by reference.\n\t(consider_split): Compute current->split_part_set_retval.\n\t(visit_bb): Do not look into return value.\n\t(split_function): Handle !split_part_set_retval\n\nFrom-SVN: r162842", "tree": {"sha": "63022e11a0d93576ce7f9fde7799435930c0a171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63022e11a0d93576ce7f9fde7799435930c0a171"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/241a2b9ec29d1c240874090c995273eca522ffda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241a2b9ec29d1c240874090c995273eca522ffda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/241a2b9ec29d1c240874090c995273eca522ffda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241a2b9ec29d1c240874090c995273eca522ffda/comments", "author": null, "committer": null, "parents": [{"sha": "fc734382d1cc65ee8f7021e3f696d1b6c6f393cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc734382d1cc65ee8f7021e3f696d1b6c6f393cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc734382d1cc65ee8f7021e3f696d1b6c6f393cf"}], "stats": {"total": 197, "additions": 170, "deletions": 27}, "files": [{"sha": "4f689debf40f520be90ee901b94bbd04f334d8ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=241a2b9ec29d1c240874090c995273eca522ffda", "patch": "@@ -1,3 +1,12 @@\n+2010-08-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-split.c (struct split_point): Add split_part_set_retval.\n+\t(find_retval): Forward declare.\n+\t(test_nonssa_use, mark_nonssa_use): Special case return by reference.\n+\t(consider_split): Compute current->split_part_set_retval.\n+\t(visit_bb): Do not look into return value.\n+\t(split_function): Handle !split_part_set_retval\n+\n 2010-08-03  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-sra.c (completely_scalarize_record): New parameter REF, create"}, {"sha": "9c738bf0c66bb6321986bd69846227043ed4f1f3", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 112, "deletions": 27, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=241a2b9ec29d1c240874090c995273eca522ffda", "patch": "@@ -120,12 +120,18 @@ struct split_point\n \n   /* Basic blocks we are splitting away.  */\n   bitmap split_bbs;\n+\n+  /* True when return value is computed on split part and thus it needs\n+     to be returned.  */\n+  bool split_part_set_retval;\n };\n \n /* Best split point found.  */\n \n struct split_point best_split_point;\n \n+static tree find_retval (basic_block return_bb);\n+\n /* Callback for walk_stmt_load_store_addr_ops.  If T is non-ssa automatic\n    variable, check it if it is present in bitmap passed via DATA.  */\n \n@@ -141,6 +147,14 @@ test_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t,\n \t  || (TREE_CODE (t) == RESULT_DECL)\n \t  || (TREE_CODE (t) == PARM_DECL)))\n     return bitmap_bit_p ((bitmap)data, DECL_UID (t));\n+\n+  /* For DECL_BY_REFERENCE, the return value is actually pointer.  We want to pretend\n+     that the value pointed to is actual result decl.  */\n+  if (t && (TREE_CODE (t) == MEM_REF || INDIRECT_REF_P (t))\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n+      && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND (t, 0))) == RESULT_DECL\n+      && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+    return bitmap_bit_p ((bitmap)data, DECL_UID (DECL_RESULT (current_function_decl)));\n   return false;\n }\n \n@@ -260,6 +274,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   gimple_stmt_iterator bsi;\n   unsigned int i;\n   int incomming_freq = 0;\n+  tree retval;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_split_point (dump_file, current);\n@@ -388,6 +403,43 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"  Accepted!\\n\");\n \n+  /* See if retval used by return bb is computed by header or split part.\n+     When it is computed by split part, we need to produce return statement\n+     in the split part and add code to header to pass it around.\n+\n+     This is bit tricky to test:\n+       1) When there is no return_bb or no return value, we always pass\n+          value around.\n+       2) Invariants are always computed by caller.\n+       3) For SSA we need to look if defining statement is in header or split part\n+       4) For non-SSA we need to look where the var is computed. */\n+  retval = find_retval (return_bb);\n+  if (!retval)\n+    current->split_part_set_retval = true;\n+  else if (is_gimple_min_invariant (retval))\n+    current->split_part_set_retval = false;\n+  /* Special case is value returned by reference we record as if it was non-ssa\n+     set to result_decl.  */\n+  else if (TREE_CODE (retval) == SSA_NAME\n+\t   && TREE_CODE (SSA_NAME_VAR (retval)) == RESULT_DECL\n+\t   && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+    current->split_part_set_retval\n+       = bitmap_bit_p (non_ssa_vars, DECL_UID (SSA_NAME_VAR (retval)));\n+  else if (TREE_CODE (retval) == SSA_NAME)\n+    current->split_part_set_retval\n+      = (!SSA_NAME_IS_DEFAULT_DEF (retval)\n+\t && (bitmap_bit_p (current->split_bbs,\n+\t\t\t  gimple_bb (SSA_NAME_DEF_STMT (retval))->index)\n+\t     || gimple_bb (SSA_NAME_DEF_STMT (retval)) == return_bb));\n+  else if (TREE_CODE (retval) == PARM_DECL)\n+    current->split_part_set_retval = false;\n+  else if (TREE_CODE (retval) == VAR_DECL\n+\t   || TREE_CODE (retval) == RESULT_DECL)\n+    current->split_part_set_retval\n+      = bitmap_bit_p (non_ssa_vars, DECL_UID (retval));\n+  else\n+    current->split_part_set_retval = true;\n+\n   /* At the moment chose split point with lowest frequency and that leaves\n      out smallest size of header.\n      In future we might re-consider this heuristics.  */\n@@ -516,6 +568,14 @@ mark_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t,\n   if ((TREE_CODE (t) == VAR_DECL && auto_var_in_fn_p (t, current_function_decl))\n       || (TREE_CODE (t) == RESULT_DECL))\n     bitmap_set_bit ((bitmap)data, DECL_UID (t));\n+\n+  /* For DECL_BY_REFERENCE, the return value is actually pointer.  We want to pretend\n+     that the value pointed to is actual result decl.  */\n+  if (t && (TREE_CODE (t) == MEM_REF || INDIRECT_REF_P (t))\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n+      && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND (t, 0))) == RESULT_DECL\n+      && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+    return bitmap_bit_p ((bitmap)data, DECL_UID (DECL_RESULT (current_function_decl)));\n   return false;\n }\n \n@@ -630,7 +690,6 @@ visit_bb (basic_block bb, basic_block return_bb,\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     if (e->dest == return_bb)\n       {\n-\tbool found_phi = false;\n \tfor (bsi = gsi_start_phis (return_bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t  {\n \t    gimple stmt = gsi_stmt (bsi);\n@@ -640,25 +699,11 @@ visit_bb (basic_block bb, basic_block return_bb,\n \t      continue;\n \t    if (!is_gimple_reg (gimple_phi_result (stmt)))\n \t      continue;\n-\t    found_phi = true;\n \t    if (TREE_CODE (op) == SSA_NAME)\n \t      bitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n \t    else\n \t      can_split &= !mark_nonssa_use (stmt, op, non_ssa_vars);\n \t  }\n-\tif (!gsi_end_p (gsi_last_bb (return_bb)))\n-\t  {\n-\t    ssa_op_iter iter;\n-\t    gimple stmt = gsi_stmt (gsi_last_bb (return_bb));\n-\t    tree op;\n-\t    if (!found_phi)\n-\t      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n-\t\tbitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n-\t    can_split &= !walk_stmt_load_store_addr_ops (stmt, non_ssa_vars,\n-\t\t\t\t\t\t\t mark_nonssa_use,\n-\t\t\t\t\t\t\t mark_nonssa_use,\n-\t\t\t\t\t\t\t mark_nonssa_use);\n-\t  }\n       }\n   return can_split;\n }\n@@ -905,8 +950,55 @@ split_function (struct split_point *split_point)\n   if (e)\n     split_part_return_p = true;\n \n-  /* If we return, we will need the return block.  */\n-  if (return_bb != EXIT_BLOCK_PTR && split_part_return_p)\n+  /* Add return block to what will become the split function.\n+     We do not return; no return block is needed.  */\n+  if (!split_part_return_p)\n+    ;\n+  /* We have no return block, so nothing is needed.  */\n+  else if (return_bb == EXIT_BLOCK_PTR)\n+    ;\n+  /* When we do not want to return value, we need to construct\n+     new return block with empty return statement.\n+     FIXME: Once we are able to change return type, we should change function\n+     to return void instead of just outputting function with undefined return\n+     value.  For structures this affects quality of codegen.  */\n+  else if (!split_point->split_part_set_retval\n+           && find_retval (return_bb))\n+    {\n+      bool redirected = true;\n+      basic_block new_return_bb = create_basic_block (NULL, 0, return_bb);\n+      gimple_stmt_iterator gsi = gsi_start_bb (new_return_bb);\n+      gsi_insert_after (&gsi, gimple_build_return (NULL), GSI_NEW_STMT);\n+      while (redirected)\n+\t{\n+\t  redirected = false;\n+\t  FOR_EACH_EDGE (e, ei, return_bb->preds)\n+\t    if (bitmap_bit_p (split_point->split_bbs, e->src->index))\n+\t      {\n+\t\tnew_return_bb->count += e->count;\n+\t\tnew_return_bb->frequency += EDGE_FREQUENCY (e);\n+\t\tredirect_edge_and_branch (e, new_return_bb);\n+\t\tredirected = true;\n+\t\tbreak;\n+\t      }\n+\t}\n+      e = make_edge (new_return_bb, EXIT_BLOCK_PTR, 0);\n+      e->probability = REG_BR_PROB_BASE;\n+      e->count = new_return_bb->count;\n+      bitmap_set_bit (split_point->split_bbs, new_return_bb->index);\n+      /* We change CFG in a way tree-inline is not able to compensate on while\n+\t updating PHIs.  There are only virtuals in return_bb, so recompute\n+\t them.  */\n+      for (gsi = gsi_start_phis (return_bb); !gsi_end_p (gsi);)\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  gcc_assert (!is_gimple_reg (gimple_phi_result (stmt)));\n+\t  mark_sym_for_renaming (SSA_NAME_VAR (PHI_RESULT (stmt)));\n+\t  gsi_remove (&gsi, false);\n+\t}\n+    }\n+  /* When we pass aorund the value, use existing return block.  */\n+  else\n     bitmap_set_bit (split_point->split_bbs, return_bb->index);\n \n   /* Now create the actual clone.  */\n@@ -974,15 +1066,7 @@ split_function (struct split_point *split_point)\n \t{\n \t  real_retval = retval = find_retval (return_bb);\n \n-\t  /* See if return value is computed by split part;\n-\t     function might just return its argument, invariant or undefined\n-\t     value.  In this case we don't need to do any updating.  */\n-\t  if (real_retval\n-\t      && !is_gimple_min_invariant (retval)\n-\t      && (TREE_CODE (retval) != SSA_NAME\n-\t\t  || (!SSA_NAME_IS_DEFAULT_DEF (retval)\n-\t\t      || DECL_BY_REFERENCE\n-\t\t\t   (DECL_RESULT (current_function_decl)))))\n+\t  if (real_retval && split_point->split_part_set_retval)\n \t    {\n \t      gimple_stmt_iterator psi;\n \n@@ -1038,7 +1122,8 @@ split_function (struct split_point *split_point)\n       else\n \t{\n \t  gimple ret;\n-\t  if (!VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n+\t  if (split_point->split_part_set_retval\n+\t      && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n \t    {\n \t      retval = DECL_RESULT (current_function_decl);\n "}, {"sha": "8fbbb522c22465fdf58c488963c24b54137eb3bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=241a2b9ec29d1c240874090c995273eca522ffda", "patch": "@@ -1,3 +1,7 @@\n+2010-08-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.c-torture/compile/pr45085.c: New testcase.\n+\n 2010-08-03  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44584"}, {"sha": "5c1ec6a5c96a764ff1b6a6bd78f9ba05444304a9", "filename": "gcc/testsuite/gcc.c-torture/compile/pr45085.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr45085.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241a2b9ec29d1c240874090c995273eca522ffda/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr45085.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr45085.c?ref=241a2b9ec29d1c240874090c995273eca522ffda", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-options \"-O2  -Wuninitialized\" } */\n+struct S { char *s1; long s2; };\n+struct T { int t1; long t2; long t3; };\n+extern int fn2 (void);\n+extern int fn3 (struct T);\n+extern struct T fn4 ();\n+extern int fn5 (char **, long *, int);\n+extern void fn6 (void);\n+extern void fn7 (void *);\n+struct S *fn10 ();\n+static int p;\n+static void *q;\n+extern struct T r;\n+\n+static struct T\n+fn8 (struct T x, int y)\n+{\n+  struct S *u = fn10 ();\n+  int v = fn5 (&u->s1, &u->s2, 0);\n+  while (1)\n+    {\n+      if (p)\n+fn6 ();\n+      if (fn3 (x))\n+return fn4 ();\n+      if (y & 1)\n+return r;\n+      v = fn5 (&u->s1, &u->s2, 1);\n+    }\n+}\n+\n+struct T\n+fn9 (struct T x, int y)\n+{\n+  struct T t = fn8 (x, y);\n+  if (fn2 ())\n+    fn7 (q);\n+  return t;\n+}\n+\n+void *\n+fn1 (void)\n+{\n+  return fn9;\n+}"}]}