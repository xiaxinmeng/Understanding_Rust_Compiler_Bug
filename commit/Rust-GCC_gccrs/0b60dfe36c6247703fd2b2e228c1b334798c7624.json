{"sha": "0b60dfe36c6247703fd2b2e228c1b334798c7624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI2MGRmZTM2YzYyNDc3MDNmZDJiMmUyMjhjMWIzMzQ3OThjNzYyNA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "1998-05-15T20:13:22Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "1998-05-15T20:13:22Z"}, "message": "decl.c (duplicate_decls): Clean up, add DECL_DATA_AREA bits.\n\nP\nFri May 15 15:34:02 1998  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n        * decl.c (duplicate_decls): Clean up, add DECL_DATA_AREA bits.\ng++/15618\n\nFrom-SVN: r19784", "tree": {"sha": "98d551df769099221293cd53d00a5ac32dde57a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98d551df769099221293cd53d00a5ac32dde57a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b60dfe36c6247703fd2b2e228c1b334798c7624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b60dfe36c6247703fd2b2e228c1b334798c7624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b60dfe36c6247703fd2b2e228c1b334798c7624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b60dfe36c6247703fd2b2e228c1b334798c7624/comments", "author": null, "committer": null, "parents": [{"sha": "33f1e63e7b22ad75629845f4ae4ebd65afdc2b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f1e63e7b22ad75629845f4ae4ebd65afdc2b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f1e63e7b22ad75629845f4ae4ebd65afdc2b65"}], "stats": {"total": 89, "additions": 38, "deletions": 51}, "files": [{"sha": "078b31867783e7ca334a8ec9c3da6b4553596836", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 38, "deletions": 51, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b60dfe36c6247703fd2b2e228c1b334798c7624/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b60dfe36c6247703fd2b2e228c1b334798c7624/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0b60dfe36c6247703fd2b2e228c1b334798c7624", "patch": "@@ -2558,29 +2558,23 @@ duplicate_decls (newdecl, olddecl)\n   extern struct obstack permanent_obstack;\n   unsigned olddecl_uid = DECL_UID (olddecl);\n   int olddecl_friend = 0, types_match = 0;\n-  int new_defines_function;\n+  int new_defines_function = 0;\n \n   if (newdecl == olddecl)\n     return 1;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (olddecl)) == 'd')\n-    DECL_MACHINE_ATTRIBUTES (newdecl)\n-      = merge_machine_decl_attributes (olddecl, newdecl);\n-\n   types_match = decls_match (newdecl, olddecl);\n \n-  if (TREE_CODE (olddecl) != TREE_LIST)\n-    olddecl_friend = DECL_LANG_SPECIFIC (olddecl) && DECL_FRIEND_P (olddecl);\n-\n   /* If either the type of the new decl or the type of the old decl is an\n      error_mark_node, then that implies that we have already issued an\n      error (earlier) for some bogus type specification, and in that case,\n      it is rather pointless to harass the user with yet more error message\n-     about the same declaration, so well just pretent the types match here.  */\n+     about the same declaration, so just pretend the types match here.  */\n   if (TREE_TYPE (newdecl) == error_mark_node\n       || TREE_TYPE (olddecl) == error_mark_node)\n     types_match = 1;\n-\n+ \n+  /* Check for redeclaration and other discrepancies. */\n   if (TREE_CODE (olddecl) == FUNCTION_DECL\n       && DECL_ARTIFICIAL (olddecl)\n       && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl)))\n@@ -2834,6 +2828,21 @@ duplicate_decls (newdecl, olddecl)\n       DECL_ABSTRACT_VIRTUAL_P (newdecl) |= DECL_ABSTRACT_VIRTUAL_P (olddecl);\n       DECL_VIRTUAL_P (newdecl) |= DECL_VIRTUAL_P (olddecl);\n       DECL_NEEDS_FINAL_OVERRIDER_P (newdecl) |= DECL_NEEDS_FINAL_OVERRIDER_P (olddecl);\n+      new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n+      \n+      /* Optionally warn about more than one declaration for the same\n+         name, but don't warn about a function declaration followed by a\n+         definition.  */\n+      if (warn_redundant_decls && ! DECL_ARTIFICIAL (olddecl)\n+\t  && !(new_defines_function && DECL_INITIAL (olddecl) == NULL_TREE)\n+\t  /* Don't warn about extern decl followed by definition. */\n+\t  && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl))\n+\t  /* Don't warn about friends, let add_friend take care of it. */\n+\t  && ! DECL_FRIEND_P (newdecl))\n+\t{\n+\t  cp_warning (\"redundant redeclaration of `%D' in same scope\", newdecl);\n+\t  cp_warning_at (\"previous declaration of `%D'\", olddecl);\n+\t}\n     }\n \n   /* Deal with C++: must preserve virtual function table size.  */\n@@ -2851,26 +2860,10 @@ duplicate_decls (newdecl, olddecl)\n \t}\n     }\n \n-  /* Special handling ensues if new decl is a function definition.  */\n-  new_defines_function = (TREE_CODE (newdecl) == FUNCTION_DECL\n-\t\t\t  && DECL_INITIAL (newdecl) != NULL_TREE);\n-\n-  /* Optionally warn about more than one declaration for the same name,\n-     but don't warn about a function declaration followed by a definition.  */\n-  if (warn_redundant_decls\n-      && ! DECL_ARTIFICIAL (olddecl)\n-      && !(new_defines_function && DECL_INITIAL (olddecl) == NULL_TREE)\n-      /* Don't warn about extern decl followed by (tentative) definition.  */\n-      && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl))\n-      /* Don't warn about friends, let add_friend take care of it. */\n-      && (TREE_CODE (newdecl) == FUNCTION_DECL && ! DECL_FRIEND_P (newdecl)))\n-    {\n-      cp_warning (\"redundant redeclaration of `%D' in same scope\", newdecl);\n-      cp_warning_at (\"previous declaration of `%D'\", olddecl);\n-    }\n-\n   /* Copy all the DECL_... slots specified in the new decl\n      except for any that we copy here from the old type.  */\n+  DECL_MACHINE_ATTRIBUTES (newdecl) \n+    = merge_machine_decl_attributes (olddecl, newdecl);\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n@@ -2883,9 +2876,12 @@ duplicate_decls (newdecl, olddecl)\n \t  DECL_TEMPLATE_PARMS (olddecl) = DECL_TEMPLATE_PARMS (newdecl);\n \t  DECL_TEMPLATE_INFO (olddecl) = DECL_TEMPLATE_INFO (newdecl);\n \t}\n+      DECL_TEMPLATE_SPECIALIZATIONS (newdecl)\n+\t= DECL_TEMPLATE_SPECIALIZATIONS (olddecl);\n+ \n       return 1;\n     }\n-\n+    \n   if (types_match)\n     {\n       /* Automatically handles default parameters.  */\n@@ -2996,12 +2992,23 @@ duplicate_decls (newdecl, olddecl)\n   TREE_STATIC (olddecl) = TREE_STATIC (newdecl) |= TREE_STATIC (olddecl);\n   if (! DECL_EXTERNAL (olddecl))\n     DECL_EXTERNAL (newdecl) = 0;\n-\n-  if (DECL_LANG_SPECIFIC (newdecl))\n+  \n+  if (DECL_LANG_SPECIFIC (newdecl) && DECL_LANG_SPECIFIC (olddecl))\n     {\n       DECL_INTERFACE_KNOWN (newdecl) |= DECL_INTERFACE_KNOWN (olddecl);\n       DECL_NOT_REALLY_EXTERN (newdecl) |= DECL_NOT_REALLY_EXTERN (olddecl);\n       DECL_COMDAT (newdecl) |= DECL_COMDAT (olddecl);\n+      /* Don't really know how much of the language-specific\n+\t values we should copy from old to new.  */\n+      DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n+      DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);\n+      DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n+      if (DECL_TEMPLATE_INFO (newdecl) == NULL_TREE)\n+\t{\n+\t  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n+\t  DECL_USE_TEMPLATE (newdecl) = DECL_USE_TEMPLATE (olddecl);\n+\t}\n+      olddecl_friend = DECL_FRIEND_P (olddecl);\n     }\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -3086,32 +3093,12 @@ duplicate_decls (newdecl, olddecl)\n       NAMESPACE_LEVEL (newdecl) = NAMESPACE_LEVEL (olddecl);\n     }\n \n-  if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n-    {\n-      DECL_TEMPLATE_SPECIALIZATIONS (newdecl)\n-\t= DECL_TEMPLATE_SPECIALIZATIONS (olddecl);\n-    }\n-\n   /* Now preserve various other info from the definition.  */\n   TREE_ADDRESSABLE (newdecl) = TREE_ADDRESSABLE (olddecl);\n   TREE_ASM_WRITTEN (newdecl) = TREE_ASM_WRITTEN (olddecl);\n   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n   DECL_ASSEMBLER_NAME (newdecl) = DECL_ASSEMBLER_NAME (olddecl);\n \n-  /* Don't really know how much of the language-specific\n-     values we should copy from old to new.  */\n-  if (DECL_LANG_SPECIFIC (olddecl))\n-    {\n-      DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n-      DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);\n-      DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n-      if (DECL_TEMPLATE_INFO (newdecl) == NULL_TREE)\n-\t{\n-\t  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n-\t  DECL_USE_TEMPLATE (newdecl) = DECL_USE_TEMPLATE (olddecl);\n-\t}\n-    }\n-\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       int function_size;"}]}