{"sha": "50b2e859965b43c6537acabd9a4e882204c89b42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBiMmU4NTk5NjViNDNjNjUzN2FjYWJkOWE0ZTg4MjIwNGM4OWI0Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-22T16:02:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-22T16:02:34Z"}, "message": "Fix version of patch from previous commit ;(\n\nFrom-SVN: r161199", "tree": {"sha": "84b9b4144b79810bb743e2fb9bb71b47ba26829c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84b9b4144b79810bb743e2fb9bb71b47ba26829c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50b2e859965b43c6537acabd9a4e882204c89b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b2e859965b43c6537acabd9a4e882204c89b42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b2e859965b43c6537acabd9a4e882204c89b42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b2e859965b43c6537acabd9a4e882204c89b42/comments", "author": null, "committer": null, "parents": [{"sha": "c42bfef297354c8859e97ca7c3f32b0899b52f67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42bfef297354c8859e97ca7c3f32b0899b52f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42bfef297354c8859e97ca7c3f32b0899b52f67"}], "stats": {"total": 94, "additions": 60, "deletions": 34}, "files": [{"sha": "75f7bfe49aec3cb69bd909d6bf7e6567f6be14fd", "filename": "gcc/df-core.c", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b2e859965b43c6537acabd9a4e882204c89b42/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b2e859965b43c6537acabd9a4e882204c89b42/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=50b2e859965b43c6537acabd9a4e882204c89b42", "patch": "@@ -851,20 +851,33 @@ struct rtl_opt_pass pass_df_finish =\n    The general data flow analysis engine.\n ----------------------------------------------------------------------------*/\n \n+/* Return time BB when it was visited for last time.  */\n+#define BB_LAST_CHANGE_AGE(bb) ((ptrdiff_t)(bb)->aux)\n \n /* Helper function for df_worklist_dataflow.\n    Propagate the dataflow forward.\n    Given a BB_INDEX, do the dataflow propagation\n    and set bits on for successors in PENDING\n-   if the out set of the dataflow has changed. */\n+   if the out set of the dataflow has changed.\n+\n+   AGE specify time when BB was visited last time.\n+   AGE of 0 means we are visiting for first time and need to\n+   compute transfer function to initialize datastructures.\n+   Otherwise we re-do transfer function only if something change\n+   while computing confluence functions.\n+   We need to compute confluence only of basic block that are younger\n+   then last visit of the BB.\n+\n+   Return true if BB info has changed.  This is always the case\n+   in the first visit.  */\n \n static bool\n df_worklist_propagate_forward (struct dataflow *dataflow,\n                                unsigned bb_index,\n                                unsigned *bbindex_to_postorder,\n                                bitmap pending,\n                                sbitmap considered,\n-\t\t\t       size_t age)\n+\t\t\t       ptrdiff_t age)\n {\n   edge e;\n   edge_iterator ei;\n@@ -875,15 +888,12 @@ df_worklist_propagate_forward (struct dataflow *dataflow,\n   if (EDGE_COUNT (bb->preds) > 0)\n     FOR_EACH_EDGE (e, ei, bb->preds)\n       {\n-        if ((age <= (size_t)e->src->aux)\n-\t     && TEST_BIT (considered, e->src->index))\n+        if (age <= BB_LAST_CHANGE_AGE (e->src)\n+\t    && TEST_BIT (considered, e->src->index))\n           changed |= dataflow->problem->con_fun_n (e);\n       }\n   else if (dataflow->problem->con_fun_0)\n-    {\n-      dataflow->problem->con_fun_0 (bb);\n-      changed = true;\n-    }\n+    dataflow->problem->con_fun_0 (bb);\n \n   if (changed\n       && dataflow->problem->trans_fun (bb_index))\n@@ -912,7 +922,7 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n                                 unsigned *bbindex_to_postorder,\n                                 bitmap pending,\n                                 sbitmap considered,\n-\t\t\t        size_t age)\n+\t\t\t        ptrdiff_t age)\n {\n   edge e;\n   edge_iterator ei;\n@@ -923,15 +933,12 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n   if (EDGE_COUNT (bb->succs) > 0)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       {\n-        if ((age <= (size_t)e->dest->aux)\n-\t     && TEST_BIT (considered, e->dest->index))\n+        if (age <= BB_LAST_CHANGE_AGE (e->dest)\n+\t    && TEST_BIT (considered, e->dest->index))\n           changed |= dataflow->problem->con_fun_n (e);\n       }\n   else if (dataflow->problem->con_fun_0)\n-    {\n-      dataflow->problem->con_fun_0 (bb);\n-      changed = true;\n-    }\n+    dataflow->problem->con_fun_0 (bb);\n \n   if (changed\n       && dataflow->problem->trans_fun (bb_index))\n@@ -950,10 +957,24 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n   return false;\n }\n \n-DEF_VEC_I(size_t);\n-DEF_VEC_ALLOC_I(size_t,heap);\n+/* Main dataflow solver loop.\n+\n+   DATAFLOW is problem we are solving, PENDING is worklist of basic blocks we\n+   need to visit.\n+   BLOCK_IN_POSTORDER is array of size N_BLOCKS specifying postorder in BBs and\n+   BBINDEX_TO_POSTORDER is array mapping back BB->index to postorder possition.\n+   PENDING will be freed.\n+\n+   The worklists are bitmaps indexed by postorder positions.  \n+\n+   The function implements standard algorithm for dataflow solving with two\n+   worklists (we are processing WORKLIST and storing new BBs to visit in\n+   PENDING).\n \n-/* This will free \"pending\". */\n+   As an optimization we maintain ages when BB was changed (stored in bb->aux)\n+   and when it was last visited (stored in last_visit_age).  This avoids need\n+   to re-do confluence function for edges to basic blocks whose source\n+   did not change since destination was visited last time.  */\n \n static void\n df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n@@ -966,14 +987,14 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n   enum df_flow_dir dir = dataflow->problem->dir;\n   int dcount = 0;\n   bitmap worklist = BITMAP_ALLOC (&df_bitmap_obstack);\n-  size_t age = 0;\n+  int age = 0;\n   bool changed;\n-  VEC(size_t, heap) *last_age = NULL;\n-  size_t prev_age;\n+  VEC(int, heap) *last_visit_age = NULL;\n+  int prev_age;\n   basic_block bb;\n   int i;\n \n-  VEC_safe_grow_cleared (size_t, heap, last_age, n_blocks);\n+  VEC_safe_grow_cleared (int, heap, last_visit_age, n_blocks);\n \n   /* Double-queueing. Worklist is for the current iteration,\n      and pending is for the next. */\n@@ -992,9 +1013,10 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \t  unsigned bb_index;\n \t  dcount++;\n \n+\t  bitmap_clear_bit (pending, index);\n \t  bb_index = blocks_in_postorder[index];\n \t  bb = BASIC_BLOCK (bb_index);\n-\t  prev_age = VEC_index (size_t, last_age, index);\n+\t  prev_age = VEC_index (int, last_visit_age, index);\n \t  if (dir == DF_FORWARD)\n \t    changed = df_worklist_propagate_forward (dataflow, bb_index,\n \t\t\t\t\t\t     bbindex_to_postorder,\n@@ -1005,11 +1027,9 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \t\t\t\t\t\t      bbindex_to_postorder,\n \t\t\t\t\t\t      pending, considered,\n \t\t\t\t\t\t      prev_age);\n-\t  age++;\n+\t  VEC_replace (int, last_visit_age, index, ++age);\n \t  if (changed)\n-\t    bb->aux = (void *)age;\n-\t  VEC_replace (size_t, last_age, index, age);\n-\t  age++;\n+\t    bb->aux = (void *)(ptrdiff_t)age;\n \t}\n       bitmap_clear (worklist);\n     }\n@@ -1018,7 +1038,7 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \n   BITMAP_FREE (worklist);\n   BITMAP_FREE (pending);\n-  VEC_free (size_t, heap, last_age);\n+  VEC_free (int, heap, last_visit_age);\n \n   /* Dump statistics. */\n   if (dump_file)"}, {"sha": "1196e81e7291de4bbd1d63f16d87937cf5826c79", "filename": "gcc/df-problems.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b2e859965b43c6537acabd9a4e882204c89b42/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b2e859965b43c6537acabd9a4e882204c89b42/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=50b2e859965b43c6537acabd9a4e882204c89b42", "patch": "@@ -983,7 +983,8 @@ df_lr_confluence_n (edge e)\n   else\n     changed = bitmap_ior_into (op1, op2);\n \n-  return bitmap_ior_into (op1, &df->hardware_regs_used) || changed;\n+  changed |= bitmap_ior_into (op1, &df->hardware_regs_used);\n+  return changed;\n }\n \n \n@@ -2726,11 +2727,13 @@ df_byte_lr_confluence_n (edge e)\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n   if (e->flags & EDGE_EH)\n-    changed = bitmap_ior_and_compl_into (op1, op2, &problem_data->invalidated_by_call);\n+    changed = bitmap_ior_and_compl_into (op1, op2,\n+\t\t\t\t\t &problem_data->invalidated_by_call);\n   else\n     changed = bitmap_ior_into (op1, op2);\n \n-  return bitmap_ior_into (op1, &problem_data->hardware_regs_used) || changed;\n+  changed |= bitmap_ior_into (op1, &problem_data->hardware_regs_used);\n+  return changed;\n }\n \n \n@@ -4440,7 +4443,8 @@ df_md_confluence_n (edge e)\n     return false;\n \n   if (e->flags & EDGE_EH)\n-    return bitmap_ior_and_compl_into (op1, op2, regs_invalidated_by_call_regset);\n+    return bitmap_ior_and_compl_into (op1, op2,\n+\t\t\t\t      regs_invalidated_by_call_regset);\n   else\n     return bitmap_ior_into (op1, op2);\n }"}, {"sha": "fc3bb088ee5cc8c7283215c913bc91db1d80b27d", "filename": "gcc/df.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b2e859965b43c6537acabd9a4e882204c89b42/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b2e859965b43c6537acabd9a4e882204c89b42/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=50b2e859965b43c6537acabd9a4e882204c89b42", "patch": "@@ -222,10 +222,12 @@ typedef void (*df_dataflow_function) (struct dataflow *, bitmap, int *, int);\n /* Confluence operator for blocks with 0 out (or in) edges.  */\n typedef void (*df_confluence_function_0) (basic_block);\n \n-/* Confluence operator for blocks with 1 or more out (or in) edges.  */\n+/* Confluence operator for blocks with 1 or more out (or in) edges.\n+   Return true if BB input data has changed.  */\n typedef bool (*df_confluence_function_n) (edge);\n \n-/* Transfer function for blocks.  */\n+/* Transfer function for blocks. \n+   Return true if BB output data has changed.  */\n typedef bool (*df_transfer_function) (int);\n \n /* Function to massage the information after the problem solving.  */"}]}