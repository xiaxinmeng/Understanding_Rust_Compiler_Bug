{"sha": "b279b20ab3eacc439ecb98f26374f428d43eee77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI3OWIyMGFiM2VhY2M0MzllY2I5OGYyNjM3NGY0MjhkNDNlZWU3Nw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2005-03-01T10:22:53Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2005-03-01T10:22:53Z"}, "message": "(thumb_find_work_register): Check all of the argument registers to see if they are free...\n\n(thumb_find_work_register): Check all of the argument registers to see if they\nare free, and a couple of special cases where the last argument register but\ncan be proved to be available during the function's prologue.\n(print_multi_reg, arm_compute_save_reg0_reg12_mask, output_return_instruction,\nemit_multi_reg_push, thumb_pushpop, thumb_unexpanded_epilogue): Use unsigned\nlong as the type for the register bit-mask.\n(thumb_compute_save_reg_mask): Likewise.  Also use thumb_find_work_register()\nto ensure that there is agreement about which work register is going to be\nused in the prologue.\n(thumb_output_function_prologue): Use unsigned long as the type\tfor the\nregister bit-mask.  Also delay pushing the link register if other high\nregisters are going to be pushed.\n(thumb_compute_save_reg_mask, emit_multi_reg_push, print_multi-reg,\nnumber_of_first_bit_set, thumb_pushpop): Remove redundant prototypes.\n\nFrom-SVN: r95736", "tree": {"sha": "5eb33112261fe0a0e059cab4a19b100eb34b9268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eb33112261fe0a0e059cab4a19b100eb34b9268"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b279b20ab3eacc439ecb98f26374f428d43eee77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b279b20ab3eacc439ecb98f26374f428d43eee77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b279b20ab3eacc439ecb98f26374f428d43eee77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b279b20ab3eacc439ecb98f26374f428d43eee77/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "742f25b311bbf5cc4f25a975f53413a85410292a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742f25b311bbf5cc4f25a975f53413a85410292a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/742f25b311bbf5cc4f25a975f53413a85410292a"}], "stats": {"total": 380, "additions": 232, "deletions": 148}, "files": [{"sha": "fb3aa1b956b39d0cbcb496ee623a6f37028a6ca5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b279b20ab3eacc439ecb98f26374f428d43eee77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b279b20ab3eacc439ecb98f26374f428d43eee77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b279b20ab3eacc439ecb98f26374f428d43eee77", "patch": "@@ -1,3 +1,23 @@\n+2005-03-01  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/arm/arm.c (thumb_find_work_register): Check all of the\n+\targument registers to see if they are free, and a couple of\n+\tspecial cases where the last argument register but can be proved\n+\tto be available during the function's prologue.\n+\t(print_multi_reg, arm_compute_save_reg0_reg12_mask,\n+\toutput_return_instruction, emit_multi_reg_push, thumb_pushpop,\n+\tthumb_unexpanded_epilogue): Use unsigned long as the type for the\n+\tregister bit-mask.\n+\t(thumb_compute_save_reg_mask): Likewise.  Also use\n+\tthumb_find_work_register() to ensure that there is agreement about\n+\twhich work register is going to be used in the prologue.\n+\t(thumb_output_function_prologue): Use unsigned long as the type\n+\tfor the register bit-mask.  Also delay pushing the link register if\n+\tother high registers are going to be pushed.\n+\t(thumb_compute_save_reg_mask, emit_multi_reg_push,\n+\tprint_multi-reg, number_of_first_bit_set, thumb_pushpop): Remove\n+\tredundant prototypes.\n+\n 2005-02-28  John David Anglin  <dave.anglin#nrc-cnrc.gc.ca>\n \n \tPR target/19819"}, {"sha": "b307983892c12818622045ae909ade2e8c8b37e7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 212, "deletions": 148, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b279b20ab3eacc439ecb98f26374f428d43eee77/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b279b20ab3eacc439ecb98f26374f428d43eee77/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b279b20ab3eacc439ecb98f26374f428d43eee77", "patch": "@@ -71,9 +71,7 @@ static int thumb_base_register_rtx_p (rtx, enum machine_mode, int);\n inline static int thumb_index_register_rtx_p (rtx, int);\n static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n-static unsigned long thumb_compute_save_reg_mask (void);\n static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n-static rtx emit_multi_reg_push (int);\n static rtx emit_sfm (int, int);\n #ifndef AOF_ASSEMBLER\n static bool arm_assemble_integer (rtx, unsigned int, int);\n@@ -84,13 +82,10 @@ static HOST_WIDE_INT int_log2 (HOST_WIDE_INT);\n static rtx is_jump_table (rtx);\n static const char *output_multi_immediate (rtx *, const char *, const char *,\n \t\t\t\t\t   int, HOST_WIDE_INT);\n-static void print_multi_reg (FILE *, const char *, int, int);\n static const char *shift_op (rtx, HOST_WIDE_INT *);\n static struct machine_function *arm_init_machine_status (void);\n-static int number_of_first_bit_set (int);\n static void replace_symbols_in_block (tree, rtx, rtx);\n static void thumb_exit (FILE *, int);\n-static void thumb_pushpop (FILE *, int, int, int *, int);\n static rtx is_jump_table (rtx);\n static HOST_WIDE_INT get_jump_table_size (rtx);\n static Mnode *move_minipool_fix_forward_ref (Mnode *, Mnode *, HOST_WIDE_INT);\n@@ -3102,24 +3097,57 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n }\n \n \n-/* Find a spare low register.  */\n+/* Find a spare low register to use during the prolog of a function.  */\n \n static int\n-thumb_find_work_register (int live_regs_mask)\n+thumb_find_work_register (unsigned long pushed_regs_mask)\n {\n   int reg;\n \n-  /* Use a spare arg register.  */\n-  if (!regs_ever_live[LAST_ARG_REGNUM])\n+  /* Check the argument registers first as these are call-used.  The\n+     register allocation order means that sometimes r3 might be used\n+     but earlier argument registers might not, so check them all.  */\n+  for (reg = LAST_ARG_REGNUM; reg >= 0; reg --)\n+    if (!regs_ever_live[reg])\n+      return reg;\n+\n+  /* Before going on to check the call-saved registers we can try a couple\n+     more ways of deducing that r3 is available.  The first is when we are\n+     pushing anonymous arguments onto the stack and we have less than 4\n+     registers worth of fixed arguments(*).  In this case r3 will be part of\n+     the variable argument list and so we can be sure that it will be\n+     pushed right at the start of the function.  Hence it will be available\n+     for the rest of the prologue.\n+     (*): ie current_function_pretend_args_size is greater than 0.  */\n+  if (cfun->machine->uses_anonymous_args\n+      && current_function_pretend_args_size > 0)\n     return LAST_ARG_REGNUM;\n \n-  /* Look for a pushed register.  This is used before the frame pointer is\n-     setup, so r7 is a candidate.  */\n-  for (reg = LAST_LO_REGNUM; reg >=0; reg--)\n-    if (live_regs_mask & (1 << reg))\n+  /* The other case is when we have fixed arguments but less than 4 registers\n+     worth.  In this case r3 might be used in the body of the function, but\n+     it is not being used to convey an argument into the function.  In theory\n+     we could just check current_function_args_size to see how many bytes are\n+     being passed in argument registers, but it seems that it is unreliable.\n+     Sometimes it will have the value 0 when in fact arguments are being\n+     passed.  (See testcase execute/20021111-1.c for an example).  So we also\n+     check the args_info.nregs field as well.  The problem with this field is\n+     that it makes no allowances for arguments that are passed to the\n+     function but which are not used.  Hence we could miss an opportunity\n+     when a function has an unused argument in r3.  But it is better to be\n+     safe than to be sorry.  */\n+  if (! cfun->machine->uses_anonymous_args\n+      && current_function_args_size >= 0\n+      && current_function_args_size <= (LAST_ARG_REGNUM * UNITS_PER_WORD)\n+      && cfun->args_info.nregs < 4)\n+    return LAST_ARG_REGNUM;\n+  \n+  /* Otherwise look for a call-saved register that is going to be pushed.  */\n+  for (reg = LAST_LO_REGNUM; reg > LAST_ARG_REGNUM; reg --)\n+    if (pushed_regs_mask & (1 << reg))\n       return reg;\n \n-  /* Something went wrong.  */\n+  /* Something went wrong - thumb_compute_save_reg_mask()\n+     should have arranged for a suitable register to be pushed.  */\n   abort ();\n }\n \n@@ -7668,11 +7696,13 @@ fp_const_from_val (REAL_VALUE_TYPE *r)\n    MASK is the ARM register set mask of which only bits 0-15 are important.\n    REG is the base register, either the frame pointer or the stack pointer,\n    INSTR is the possibly suffixed load or store instruction.  */\n+\n static void\n-print_multi_reg (FILE *stream, const char *instr, int reg, int mask)\n+print_multi_reg (FILE *stream, const char *instr, unsigned reg,\n+\t\t unsigned long mask)\n {\n-  int i;\n-  int not_first = FALSE;\n+  unsigned i;\n+  bool not_first = FALSE;\n \n   fputc ('\\t', stream);\n   asm_fprintf (stream, instr, reg);\n@@ -8707,11 +8737,12 @@ output_ascii_pseudo_op (FILE *stream, const unsigned char *p, int len)\n \f\n /* Compute the register save mask for registers 0 through 12\n    inclusive.  This code is used by arm_compute_save_reg_mask.  */\n+\n static unsigned long\n arm_compute_save_reg0_reg12_mask (void)\n {\n   unsigned long func_type = arm_current_func_type ();\n-  unsigned int save_reg_mask = 0;\n+  unsigned long save_reg_mask = 0;\n   unsigned int reg;\n \n   if (IS_INTERRUPT (func_type))\n@@ -8871,31 +8902,42 @@ static unsigned long\n thumb_compute_save_reg_mask (void)\n {\n   unsigned long mask;\n-  int reg;\n+  unsigned reg;\n \n   mask = 0;\n   for (reg = 0; reg < 12; reg ++)\n-    {\n-      if (regs_ever_live[reg] && !call_used_regs[reg])\n-\tmask |= 1 << reg;\n-    }\n+    if (regs_ever_live[reg] && !call_used_regs[reg])\n+      mask |= 1 << reg;\n \n   if (flag_pic && !TARGET_SINGLE_PIC_BASE)\n     mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n+\n   if (TARGET_SINGLE_PIC_BASE)\n     mask &= ~(1 << arm_pic_register);\n+\n   /* See if we might need r11 for calls to _interwork_r11_call_via_rN().  */\n   if (!frame_pointer_needed && CALLER_INTERWORKING_SLOT_SIZE > 0)\n     mask |= 1 << ARM_HARD_FRAME_POINTER_REGNUM;\n \n-  /* lr will also be pushed if any lo regs are pushed.  */\n+  /* LR will also be pushed if any lo regs are pushed.  */\n   if (mask & 0xff || thumb_force_lr_save ())\n     mask |= (1 << LR_REGNUM);\n \n-  /* Make sure we have a low work register if we need one.  */\n-  if (((mask & 0xff) == 0 && regs_ever_live[LAST_ARG_REGNUM])\n+  /* Make sure we have a low work register if we need one.\n+     We will need one if we are going to push a high register,\n+     but we are not currently intending to push a low register.  */\n+  if ((mask & 0xff) == 0\n       && ((mask & 0x0f00) || TARGET_BACKTRACE))\n-    mask |= 1 << LAST_LO_REGNUM;\n+    {\n+      /* Use thumb_find_work_register to choose which register\n+\t we will use.  If the register is live then we will\n+\t have to push it.  Use LAST_LO_REGNUM as our fallback\n+\t choice for the register to select.  */\n+      reg = thumb_find_work_register (1 << LAST_LO_REGNUM);\n+\n+      if (! call_used_regs[reg])\n+\tmask |= 1 << reg;\n+    }\n \n   return mask;\n }\n@@ -8951,7 +8993,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n {\n   char conditional[10];\n   char instr[100];\n-  int reg;\n+  unsigned reg;\n   unsigned long live_regs_mask;\n   unsigned long func_type;\n   arm_stack_offsets *offsets;\n@@ -9030,10 +9072,9 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t we have to use LDM to load the PC so that the CPSR is also\n \t restored.  */\n       for (reg = 0; reg <= LAST_ARM_REGNUM; reg++)\n-\t{\n-\t  if (live_regs_mask == (unsigned int)(1 << reg))\n-\t    break;\n-\t}\n+\tif (live_regs_mask == (1U << reg))\n+\t  break;\n+\n       if (reg <= LAST_ARM_REGNUM\n \t  && (reg != LR_REGNUM\n \t      || ! really_return\n@@ -9064,8 +9105,8 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t\tsprintf (instr, \"ldm%sib\\t%%|sp, {\", conditional);\n \t      else\n \t\t{\n-\t\t  /* If we can't use ldmib (SA110 bug), then try to pop r3\n-\t\t     instead.  */\n+\t\t  /* If we can't use ldmib (SA110 bug),\n+\t\t     then try to pop r3 instead.  */\n \t\t  if (stack_adjust)\n \t\t    live_regs_mask |= 1 << 3;\n \t\t  sprintf (instr, \"ldm%sfd\\t%%|sp, {\", conditional);\n@@ -9663,7 +9704,7 @@ arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n    semantics of the operation, we need to annotate the insn for the benefit\n    of DWARF2 frame unwind information.  */\n static rtx\n-emit_multi_reg_push (int mask)\n+emit_multi_reg_push (unsigned long mask)\n {\n   int num_regs = 0;\n   int num_dwarf_regs;\n@@ -12352,7 +12393,7 @@ replace_symbols_in_block (tree block, rtx orig, rtx new)\n    the least significant set bit in MASK.  */\n \n inline static int\n-number_of_first_bit_set (int mask)\n+number_of_first_bit_set (unsigned mask)\n {\n   int bit;\n \n@@ -12364,6 +12405,102 @@ number_of_first_bit_set (int mask)\n   return bit;\n }\n \n+/* Emit code to push or pop registers to or from the stack.  F is the\n+   assembly file.  MASK is the registers to push or pop.  PUSH is\n+   nonzero if we should push, and zero if we should pop.  For debugging\n+   output, if pushing, adjust CFA_OFFSET by the amount of space added\n+   to the stack.  REAL_REGS should have the same number of bits set as\n+   MASK, and will be used instead (in the same order) to describe which\n+   registers were saved - this is used to mark the save slots when we\n+   push high registers after moving them to low registers.  */\n+static void\n+thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n+\t       unsigned long real_regs)\n+{\n+  int regno;\n+  int lo_mask = mask & 0xFF;\n+  int pushed_words = 0;\n+\n+  if (mask == 0)\n+    abort ();\n+\n+  if (lo_mask == 0 && !push && (mask & (1 << PC_REGNUM)))\n+    {\n+      /* Special case.  Do not generate a POP PC statement here, do it in\n+\t thumb_exit() */\n+      thumb_exit (f, -1);\n+      return;\n+    }\n+\n+  fprintf (f, \"\\t%s\\t{\", push ? \"push\" : \"pop\");\n+\n+  /* Look at the low registers first.  */\n+  for (regno = 0; regno <= LAST_LO_REGNUM; regno++, lo_mask >>= 1)\n+    {\n+      if (lo_mask & 1)\n+\t{\n+\t  asm_fprintf (f, \"%r\", regno);\n+\n+\t  if ((lo_mask & ~1) != 0)\n+\t    fprintf (f, \", \");\n+\n+\t  pushed_words++;\n+\t}\n+    }\n+\n+  if (push && (mask & (1 << LR_REGNUM)))\n+    {\n+      /* Catch pushing the LR.  */\n+      if (mask & 0xFF)\n+\tfprintf (f, \", \");\n+\n+      asm_fprintf (f, \"%r\", LR_REGNUM);\n+\n+      pushed_words++;\n+    }\n+  else if (!push && (mask & (1 << PC_REGNUM)))\n+    {\n+      /* Catch popping the PC.  */\n+      if (TARGET_INTERWORK || TARGET_BACKTRACE\n+\t  || current_function_calls_eh_return)\n+\t{\n+\t  /* The PC is never poped directly, instead\n+\t     it is popped into r3 and then BX is used.  */\n+\t  fprintf (f, \"}\\n\");\n+\n+\t  thumb_exit (f, -1);\n+\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  if (mask & 0xFF)\n+\t    fprintf (f, \", \");\n+\n+\t  asm_fprintf (f, \"%r\", PC_REGNUM);\n+\t}\n+    }\n+\n+  fprintf (f, \"}\\n\");\n+\n+  if (push && pushed_words && dwarf2out_do_frame ())\n+    {\n+      char *l = dwarf2out_cfi_label ();\n+      int pushed_mask = real_regs;\n+\n+      *cfa_offset += pushed_words * 4;\n+      dwarf2out_def_cfa (l, SP_REGNUM, *cfa_offset);\n+\n+      pushed_words = 0;\n+      pushed_mask = real_regs;\n+      for (regno = 0; regno <= 14; regno++, pushed_mask >>= 1)\n+\t{\n+\t  if (pushed_mask & 1)\n+\t    dwarf2out_reg_save (l, regno, 4 * pushed_words++ - *cfa_offset);\n+\t}\n+    }\n+}\n+\n /* Generate code to return from a thumb function.\n    If 'reg_containing_return_addr' is -1, then the return address is\n    actually on the stack, at the stack pointer.  */\n@@ -12641,97 +12778,6 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n   asm_fprintf (f, \"\\tbx\\t%r\\n\", reg_containing_return_addr);\n }\n \n-/* Emit code to push or pop registers to or from the stack.  F is the\n-   assembly file.  MASK is the registers to push or pop.  PUSH is\n-   nonzero if we should push, and zero if we should pop.  For debugging\n-   output, if pushing, adjust CFA_OFFSET by the amount of space added\n-   to the stack.  REAL_REGS should have the same number of bits set as\n-   MASK, and will be used instead (in the same order) to describe which\n-   registers were saved - this is used to mark the save slots when we\n-   push high registers after moving them to low registers.  */\n-static void\n-thumb_pushpop (FILE *f, int mask, int push, int *cfa_offset, int real_regs)\n-{\n-  int regno;\n-  int lo_mask = mask & 0xFF;\n-  int pushed_words = 0;\n-\n-  if (lo_mask == 0 && !push && (mask & (1 << PC_REGNUM)))\n-    {\n-      /* Special case.  Do not generate a POP PC statement here, do it in\n-\t thumb_exit() */\n-      thumb_exit (f, -1);\n-      return;\n-    }\n-\n-  fprintf (f, \"\\t%s\\t{\", push ? \"push\" : \"pop\");\n-\n-  /* Look at the low registers first.  */\n-  for (regno = 0; regno <= LAST_LO_REGNUM; regno++, lo_mask >>= 1)\n-    {\n-      if (lo_mask & 1)\n-\t{\n-\t  asm_fprintf (f, \"%r\", regno);\n-\n-\t  if ((lo_mask & ~1) != 0)\n-\t    fprintf (f, \", \");\n-\n-\t  pushed_words++;\n-\t}\n-    }\n-\n-  if (push && (mask & (1 << LR_REGNUM)))\n-    {\n-      /* Catch pushing the LR.  */\n-      if (mask & 0xFF)\n-\tfprintf (f, \", \");\n-\n-      asm_fprintf (f, \"%r\", LR_REGNUM);\n-\n-      pushed_words++;\n-    }\n-  else if (!push && (mask & (1 << PC_REGNUM)))\n-    {\n-      /* Catch popping the PC.  */\n-      if (TARGET_INTERWORK || TARGET_BACKTRACE\n-\t  || current_function_calls_eh_return)\n-\t{\n-\t  /* The PC is never poped directly, instead\n-\t     it is popped into r3 and then BX is used.  */\n-\t  fprintf (f, \"}\\n\");\n-\n-\t  thumb_exit (f, -1);\n-\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  if (mask & 0xFF)\n-\t    fprintf (f, \", \");\n-\n-\t  asm_fprintf (f, \"%r\", PC_REGNUM);\n-\t}\n-    }\n-\n-  fprintf (f, \"}\\n\");\n-\n-  if (push && pushed_words && dwarf2out_do_frame ())\n-    {\n-      char *l = dwarf2out_cfi_label ();\n-      int pushed_mask = real_regs;\n-\n-      *cfa_offset += pushed_words * 4;\n-      dwarf2out_def_cfa (l, SP_REGNUM, *cfa_offset);\n-\n-      pushed_words = 0;\n-      pushed_mask = real_regs;\n-      for (regno = 0; regno <= 14; regno++, pushed_mask >>= 1)\n-\t{\n-\t  if (pushed_mask & 1)\n-\t    dwarf2out_reg_save (l, regno, 4 * pushed_words++ - *cfa_offset);\n-\t}\n-    }\n-}\n \f\n void\n thumb_final_prescan_insn (rtx insn)\n@@ -12851,7 +12897,7 @@ const char *\n thumb_unexpanded_epilogue (void)\n {\n   int regno;\n-  int live_regs_mask = 0;\n+  unsigned long live_regs_mask = 0;\n   int high_regs_pushed = 0;\n   int had_to_push_lr;\n   int size;\n@@ -12890,7 +12936,7 @@ thumb_unexpanded_epilogue (void)\n \n   if (high_regs_pushed)\n     {\n-      int mask = live_regs_mask & 0xff;\n+      unsigned long mask = live_regs_mask & 0xff;\n       int next_hi_reg;\n \n       /* The available low registers depend on the size of the value we are\n@@ -13127,8 +13173,8 @@ thumb_expand_prologue (void)\n     }\n \n   live_regs_mask = thumb_compute_save_reg_mask ();\n-  /* Load the pic register before setting the frame pointer, so we can use r7\n-     as a temporary work register.  */\n+  /* Load the pic register before setting the frame pointer,\n+     so we can use r7 as a temporary work register.  */\n   if (flag_pic)\n     arm_load_pic_register (thumb_find_work_register (live_regs_mask));\n \n@@ -13302,9 +13348,9 @@ thumb_expand_epilogue (void)\n static void\n thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  int live_regs_mask = 0;\n-  int l_mask;\n-  int high_regs_pushed = 0;\n+  unsigned long live_regs_mask = 0;\n+  unsigned long l_mask;\n+  unsigned high_regs_pushed = 0;\n   int cfa_offset = 0;\n   int regno;\n \n@@ -13375,19 +13421,23 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       if (dwarf2out_do_frame ())\n \t{\n \t  char *l = dwarf2out_cfi_label ();\n+\n \t  cfa_offset = cfa_offset + current_function_pretend_args_size;\n \t  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);\n \t}\n     }\n \n+  /* Get the registers we are going to push.  */\n   live_regs_mask = thumb_compute_save_reg_mask ();\n-  /* Just low regs and lr. */\n+  /* Extract a mask of the ones we can give to the Thumb's push instruction.  */\n   l_mask = live_regs_mask & 0x40ff;\n+  /* Then count how many other high registers will need to be pushed.  */\n+  high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n \n   if (TARGET_BACKTRACE)\n     {\n-      int    offset;\n-      int    work_register;\n+      unsigned offset;\n+      unsigned work_register;\n \n       /* We have been asked to create a stack backtrace structure.\n          The code looks like this:\n@@ -13416,6 +13466,7 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       if (dwarf2out_do_frame ())\n \t{\n \t  char *l = dwarf2out_cfi_label ();\n+\n \t  cfa_offset = cfa_offset + 16;\n \t  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);\n \t}\n@@ -13465,15 +13516,18 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       asm_fprintf (f, \"\\tmov\\t%r, %r\\t\\t%@ Backtrace structure created\\n\",\n \t\t   ARM_HARD_FRAME_POINTER_REGNUM, work_register);\n     }\n-  else if (l_mask)\n+  /* Optimisation:  If we are not pushing any low registers but we are going\n+     to push some high registers then delay our first push.  This will just\n+     be a push of LR and we can combine it with the push of the first high\n+     register.  */\n+  else if ((l_mask & 0xff) != 0\n+\t   || (high_regs_pushed == 0 && l_mask))\n     thumb_pushpop (f, l_mask, 1, &cfa_offset, l_mask);\n \n-  high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n-\n   if (high_regs_pushed)\n     {\n-      int pushable_regs = 0;\n-      int next_hi_reg;\n+      unsigned pushable_regs;\n+      unsigned next_hi_reg;\n \n       for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)\n \tif (live_regs_mask & (1 << next_hi_reg))\n@@ -13486,21 +13540,21 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n       while (high_regs_pushed > 0)\n \t{\n-\t  int real_regs_mask = 0;\n+\t  unsigned long real_regs_mask = 0;\n \n-\t  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)\n+\t  for (regno = LAST_LO_REGNUM; regno >= 0; regno --)\n \t    {\n \t      if (pushable_regs & (1 << regno))\n \t\t{\n \t\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", regno, next_hi_reg);\n \n-\t\t  high_regs_pushed--;\n+\t\t  high_regs_pushed --;\n \t\t  real_regs_mask |= (1 << next_hi_reg);\n \n \t\t  if (high_regs_pushed)\n \t\t    {\n-\t\t      for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;\n-\t\t\t   next_hi_reg--)\n+\t\t      for (next_hi_reg --; next_hi_reg > LAST_LO_REGNUM;\n+\t\t\t   next_hi_reg --)\n \t\t\tif (live_regs_mask & (1 << next_hi_reg))\n \t\t\t  break;\n \t\t    }\n@@ -13512,7 +13566,17 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t\t}\n \t    }\n \n-\t  thumb_pushpop (f, pushable_regs, 1, &cfa_offset, real_regs_mask);\n+\t  /* If we had to find a work register and we have not yet\n+\t     saved the LR then add it to the list of regs to push.  */\n+\t  if (l_mask == (1 << LR_REGNUM))\n+\t    {\n+\t      thumb_pushpop (f, pushable_regs | (1 << LR_REGNUM),\n+\t\t\t     1, &cfa_offset,\n+\t\t\t     real_regs_mask | (1 << LR_REGNUM));\n+\t      l_mask = 0;\n+\t    }\n+\t  else\n+\t    thumb_pushpop (f, pushable_regs, 1, &cfa_offset, real_regs_mask);\n \t}\n     }\n }"}]}