{"sha": "18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThlOWQyZjllM2RlNTJlMmExZTVmYzZjNjMwMGFkNTdlMjQ1YmNjNQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2003-07-10T02:56:29Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2003-07-10T02:56:29Z"}, "message": "mn10300.h (PREDICATE_CODES): Define.\n\n* config/mn10300/mn10300.h (PREDICATE_CODES): Define.\n2001-05-01  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.md (sqrtsf2): flag_fast_math was renamed\nto flag_unsafe_math_optimizations.\n2001-04-14  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.c (expand_prologue): Mark\nFP-register-saving insns as frame-related.\n2001-02-13  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.c\n(mn10300_get_live_callee_saved_regs): Don't search past\nLAST_EXTENDED_REGNUM.\n(mn10300_gen_multiple_store, store_multiple_operation): Likewise.\n* config/mn10300/mn10300.md: Remove excessive line breaks from\n`@' output patterns that were accounted as additional\nalternatives.\n* config/mn10300/mn10300.md, config/mn10300/mn10300.c:\nRe-introduce changes accidentally removed in Richard Sandiford's\n2000-12-05's patch.\n* config/mn10300/t-mn10300 (MULTILIB_OPTIONS, MULTILIB_DIRNAMES):\nRe-instate am33-2 lost in merge from net GCC.\n2000-08-26  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.h (DBX_REGISTER_NUMBER): Added\nfloating-point registers.\n2000-08-07  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.md (movdf): Revert some am33-specific\npessimizations that had gone in on 2000-05-08.\n2000-06-28  Graham Stott  <grahams@cygnus.co.uk>\n* config/mn10300/mn10300.h (REG_CLASS_CONTENTS): Fix typo.\n2000-06-22  Graham Stott  <grahams@cygnus.co.uk>\n* config/mn10300/mn10300.md (movqi): Use nonimmediate_operand for\noperand 0.\n* (movhi): Likewise.\n* (movsi): Likewise.\n* (movsf): Likewise.\n* (movdi): Likewise.\n* (movdf): Likewise.\nWed May 24 13:16:09 2000  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.c (fp_regs_to_save): New function.\n(can_use_return_insn, initial_offset): Add fp_regs_to_save.\n(expand_prologue, expand_epilogue): Save and restore FP regs.\n2000-05-20  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.md (movdi, movdf): 64-bit clean-up.\n2000-05-13  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.md (abssf2, negsf2, rsqrtsf2, addsf3,\nsubsf3, mulsf3, divsf3, fmaddsf4, fmsubsf4, fnmaddsf4, fnmsubsf4):\nDo not clobber cc0.\n2000-05-12  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.md (abssf2, negsf2, rsqrtsf2):\nDiscourage the two-argument, longer opcodes.\n(addsf3, subsf3, mulsf3, divsf3): Likewise for three-argument\nones.\n* config/mn10300/mn10300.h (struct mn10300_cc_status_mdep): New.\n(CC_STATUS_MDEP, CC_STATUS_MDEP_INIT): Define.\n* config/mn10300/mn10300.md (cmpsf): New pattern.\n(branch): Test mdep.fpCC and output fbCC.\n* config/mn10300/mn10300.c (print_operand): Output conditions.\n(notice_cc_update): Recognize fcmp and set mdep.fpCC.\n2000-05-10  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.md (movsf, movdf, addsf3, subsf3,\nmulsf3, divsf3): Use the `F' constraint for FP values.\n* config/mn10300/mn10300.c (const_1f_operand): New function.\n* config/mn10300/mn10300-protos.h (const_1f_operand): Declare.\n* config/mn10300/mn10300.md (sqrtsf2): New expand.\n(rsqrtsf2): New insn.\n2000-05-09  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.md (movdf): Oops, I missed it in my\nprevious check-in.\n2000-05-08  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.md (abssf2, negdf2): On\nTARGET_AM33_2, expand to...\n(abssf2_am33_2, negdf2_am33_2): New insns.\n(addsf3, subsf3, mulsf3, divsf3): Likewise.\n(fmaddsf4, fmsubsf4, fnmaddsf4, fnmsubsf4): Likewise.\n* config/mn10300/mn10300.md (movqi, movhi, movsi, movsf,\nmovdi, movdf): Added FP regs.\n* invoke.texi (-mam33-2, -mno-am33-2): Document.\n2000-04-29  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.h (FIRST_FP_REGNUM, LAST_FP_REGNUM):\nNew macros.\n(REGNO_AM33_2_FP_P): Renamed to...\n(REGNO_FP_P): Redefine in terms of FIRST_* and LAST_*.\n(CONDITIONAL_REGISTER_USAGE, REGNO_REG_CLASS): Likewise.\n2000-04-27  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.h (REG_CLASS_CONTENTS): Remove FP\nregs from GENERAL_REGS.\n2000-04-27  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.h (REGNO_AM33_2_FP_P): New macro.\n* config/mn10300/mn10300.c (mn10300_address_cost): Added FP_REGS.\n* config/mn10300/mn10300.h (REGISTER_MOVE_COST): Added FP_REGS.\n2000-04-23  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.h (CLASS_CANNOT_CHANGE_SIZE): Defined\nas FP_REGS.\n2000-04-21  Alexandre Oliva  <aoliva@cygnus.com>\n* config/mn10300/mn10300.h (OK_FOR_Q): New macro.\n(EXTRA_CONSTRAINT): Added OK_FOR_Q.\n* config/mn10300/mn10300.c (secondary_reload_class): Adjust.\n* config/mn10300/mn10300.c (print_operand): Support `D' for doubles.\n* config/mn10300/mn10300.h (FIRST_PSEUDO_REGISTER): Adjust.\n(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER): Added\nAM33/2.0 floating-point registers.\n(CONDITIONAL_REGISTER_USAGE): Adjust.\n(enum reg_class, REG_CLASS_NAMES): Added FP_REGS and FP_ACC_REGS.\n(REG_CLASS_CONTENTS, REGNO_REG_CLASS): Adjust.\n(REG_CLASS_FROM_LETTER): Added `f' and `A'.\n(REGISTER_NAMES, ADDITIONAL_REGISTER_NAMES): Adjust.\n* config/mn10300/t-mn10300 (MULTILIB_OPTIONS): Added am33-2.\n(MULTILIB_DIRNAMES): Likewise.\n* config/mn10300/mn10300.h (CPP_SPEC): Define `__AM33__=2' and\n`__AM33_2__' when `-mam33-2' is given.\n(TARGET_AM33_2): Define.\n(TARGET_SWITCHES): Adjust.\n* config/mn10300/mn10300.c (asm_file_start): Print `.am33_2'\nwhen appropriate.\n\nFrom-SVN: r69167", "tree": {"sha": "ecefedbe1603c74086c9d6117c3c3c9692cecd7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecefedbe1603c74086c9d6117c3c3c9692cecd7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/comments", "author": null, "committer": null, "parents": [{"sha": "2ff167186bf0dc00e632bc7b9b50fd46d069d231", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff167186bf0dc00e632bc7b9b50fd46d069d231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ff167186bf0dc00e632bc7b9b50fd46d069d231"}], "stats": {"total": 1034, "additions": 975, "deletions": 59}, "files": [{"sha": "d01693a42131f2e805f7d0ede5e3abdff8d3d443", "filename": "gcc/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "patch": "@@ -1,3 +1,119 @@\n+2003-07-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/mn10300/mn10300.h (PREDICATE_CODES): Define.\n+\t2001-05-01  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.md (sqrtsf2): flag_fast_math was renamed\n+\tto flag_unsafe_math_optimizations.\n+\t2001-04-14  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.c (expand_prologue): Mark\n+\tFP-register-saving insns as frame-related.\n+\t2001-02-13  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.c\n+\t(mn10300_get_live_callee_saved_regs): Don't search past\n+\tLAST_EXTENDED_REGNUM.\n+\t(mn10300_gen_multiple_store, store_multiple_operation): Likewise.\n+\t* config/mn10300/mn10300.md: Remove excessive line breaks from\n+\t`@' output patterns that were accounted as additional\n+\talternatives.\n+\t* config/mn10300/mn10300.md, config/mn10300/mn10300.c:\n+\tRe-introduce changes accidentally removed in Richard Sandiford's\n+\t2000-12-05's patch.\n+\t* config/mn10300/t-mn10300 (MULTILIB_OPTIONS, MULTILIB_DIRNAMES):\n+\tRe-instate am33-2 lost in merge from net GCC.\n+\t2000-08-26  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.h (DBX_REGISTER_NUMBER): Added\n+\tfloating-point registers.\n+\t2000-08-07  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.md (movdf): Revert some am33-specific\n+\tpessimizations that had gone in on 2000-05-08.\n+\t2000-06-28  Graham Stott  <grahams@cygnus.co.uk>\n+\t* config/mn10300/mn10300.h (REG_CLASS_CONTENTS): Fix typo.\n+\t2000-06-22  Graham Stott  <grahams@cygnus.co.uk>\n+\t* config/mn10300/mn10300.md (movqi): Use nonimmediate_operand for\n+\toperand 0.\n+\t* (movhi): Likewise.\n+\t* (movsi): Likewise.\n+\t* (movsf): Likewise.\n+\t* (movdi): Likewise.\n+\t* (movdf): Likewise.\n+\tWed May 24 13:16:09 2000  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.c (fp_regs_to_save): New function.\n+\t(can_use_return_insn, initial_offset): Add fp_regs_to_save.\n+\t(expand_prologue, expand_epilogue): Save and restore FP regs.\n+\t2000-05-20  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.md (movdi, movdf): 64-bit clean-up.\n+\t2000-05-13  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.md (abssf2, negsf2, rsqrtsf2, addsf3,\n+\tsubsf3, mulsf3, divsf3, fmaddsf4, fmsubsf4, fnmaddsf4, fnmsubsf4):\n+\tDo not clobber cc0.\n+\t2000-05-12  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.md (abssf2, negsf2, rsqrtsf2):\n+\tDiscourage the two-argument, longer opcodes.\n+\t(addsf3, subsf3, mulsf3, divsf3): Likewise for three-argument\n+\tones.\n+\t* config/mn10300/mn10300.h (struct mn10300_cc_status_mdep): New.\n+\t(CC_STATUS_MDEP, CC_STATUS_MDEP_INIT): Define.\n+\t* config/mn10300/mn10300.md (cmpsf): New pattern.\n+\t(branch): Test mdep.fpCC and output fbCC.\n+\t* config/mn10300/mn10300.c (print_operand): Output conditions.\n+\t(notice_cc_update): Recognize fcmp and set mdep.fpCC.\n+\t2000-05-10  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.md (movsf, movdf, addsf3, subsf3,\n+\tmulsf3, divsf3): Use the `F' constraint for FP values.\n+\t* config/mn10300/mn10300.c (const_1f_operand): New function.\n+\t* config/mn10300/mn10300-protos.h (const_1f_operand): Declare.\n+\t* config/mn10300/mn10300.md (sqrtsf2): New expand.\n+\t(rsqrtsf2): New insn.\n+\t2000-05-09  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.md (movdf): Oops, I missed it in my\n+\tprevious check-in.\n+\t2000-05-08  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.md (abssf2, negdf2): On\n+\tTARGET_AM33_2, expand to...\n+\t(abssf2_am33_2, negdf2_am33_2): New insns.\n+\t(addsf3, subsf3, mulsf3, divsf3): Likewise.\n+\t(fmaddsf4, fmsubsf4, fnmaddsf4, fnmsubsf4): Likewise.\n+\t* config/mn10300/mn10300.md (movqi, movhi, movsi, movsf,\n+\tmovdi, movdf): Added FP regs.\n+\t* invoke.texi (-mam33-2, -mno-am33-2): Document.\n+\t2000-04-29  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.h (FIRST_FP_REGNUM, LAST_FP_REGNUM):\n+\tNew macros.\n+\t(REGNO_AM33_2_FP_P): Renamed to...\n+\t(REGNO_FP_P): Redefine in terms of FIRST_* and LAST_*.\n+\t(CONDITIONAL_REGISTER_USAGE, REGNO_REG_CLASS): Likewise.\n+\t2000-04-27  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.h (REG_CLASS_CONTENTS): Remove FP\n+\tregs from GENERAL_REGS.\n+\t2000-04-27  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.h (REGNO_AM33_2_FP_P): New macro.\n+\t* config/mn10300/mn10300.c (mn10300_address_cost): Added FP_REGS.\n+\t* config/mn10300/mn10300.h (REGISTER_MOVE_COST): Added FP_REGS.\n+\t2000-04-23  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.h (CLASS_CANNOT_CHANGE_SIZE): Defined\n+\tas FP_REGS.\n+\t2000-04-21  Alexandre Oliva  <aoliva@cygnus.com>\n+\t* config/mn10300/mn10300.h (OK_FOR_Q): New macro.\n+\t(EXTRA_CONSTRAINT): Added OK_FOR_Q.\n+\t* config/mn10300/mn10300.c (secondary_reload_class): Adjust.\n+\t* config/mn10300/mn10300.c (print_operand): Support `D' for doubles.\n+\t* config/mn10300/mn10300.h (FIRST_PSEUDO_REGISTER): Adjust.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER): Added\n+\tAM33/2.0 floating-point registers.\n+\t(CONDITIONAL_REGISTER_USAGE): Adjust.\n+\t(enum reg_class, REG_CLASS_NAMES): Added FP_REGS and FP_ACC_REGS.\n+\t(REG_CLASS_CONTENTS, REGNO_REG_CLASS): Adjust.\n+\t(REG_CLASS_FROM_LETTER): Added `f' and `A'.\n+\t(REGISTER_NAMES, ADDITIONAL_REGISTER_NAMES): Adjust.\n+\t* config/mn10300/t-mn10300 (MULTILIB_OPTIONS): Added am33-2.\n+\t(MULTILIB_DIRNAMES): Likewise.\n+\t* config/mn10300/mn10300.h (CPP_SPEC): Define `__AM33__=2' and\n+\t`__AM33_2__' when `-mam33-2' is given.\n+\t(TARGET_AM33_2): Define.\n+\t(TARGET_SWITCHES): Adjust.\n+\t* config/mn10300/mn10300.c (asm_file_start): Print `.am33_2'\n+\twhen appropriate.\n+\n 2003-07-09  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* doc/install.texi: Add missing @."}, {"sha": "bb14b4c902383425a6e133e0d458945591b20cbc", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 541, "deletions": 6, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "patch": "@@ -82,7 +82,9 @@ mn10300_file_start ()\n {\n   default_file_start ();\n \n-  if (TARGET_AM33)\n+  if (TARGET_AM33_2)\n+    fprintf (asm_out_file, \"\\t.am33_2\\n\");\n+  else if (TARGET_AM33)\n     fprintf (asm_out_file, \"\\t.am33\\n\");\n }\n \f\n@@ -100,6 +102,58 @@ print_operand (file, x, code)\n     {\n       case 'b':\n       case 'B':\n+\tif (cc_status.mdep.fpCC)\n+\t  {\n+\t    switch (code == 'b' ? GET_CODE (x)\n+\t\t    : reverse_condition_maybe_unordered (GET_CODE (x)))\n+\t      {\n+\t      case NE:\n+\t\tfprintf (file, \"ne\");\n+\t\tbreak;\n+\t      case EQ:\n+\t\tfprintf (file, \"eq\");\n+\t\tbreak;\n+\t      case GE:\n+\t\tfprintf (file, \"ge\");\n+\t\tbreak;\n+\t      case GT:\n+\t\tfprintf (file, \"gt\");\n+\t\tbreak;\n+\t      case LE:\n+\t\tfprintf (file, \"le\");\n+\t\tbreak;\n+\t      case LT:\n+\t\tfprintf (file, \"lt\");\n+\t\tbreak;\n+\t      case ORDERED:\n+\t\tfprintf (file, \"lge\");\n+\t\tbreak;\n+\t      case UNORDERED:\n+\t\tfprintf (file, \"uo\");\n+\t\tbreak;\n+\t      case LTGT:\n+\t\tfprintf (file, \"lg\");\n+\t\tbreak;\n+\t      case UNEQ:\n+\t\tfprintf (file, \"ue\");\n+\t\tbreak;\n+\t      case UNGE:\n+\t\tfprintf (file, \"uge\");\n+\t\tbreak;\n+\t      case UNGT:\n+\t\tfprintf (file, \"ug\");\n+\t\tbreak;\n+\t      case UNLE:\n+\t\tfprintf (file, \"ule\");\n+\t\tbreak;\n+\t      case UNLT:\n+\t\tfprintf (file, \"ul\");\n+\t\tbreak;\n+\t      default:\n+\t\tabort ();\n+\t      }\n+\t    break;\n+\t  }\n \t/* These are normal and reversed branches.  */\n \tswitch (code == 'b' ? GET_CODE (x) : reverse_condition (GET_CODE (x)))\n \t  {\n@@ -151,6 +205,24 @@ print_operand (file, x, code)\n \t  print_operand (file, x, 0);\n \tbreak;\n      \n+      case 'D':\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case MEM:\n+\t    fputc ('(', file);\n+\t    output_address (XEXP (x, 0));\n+\t    fputc (')', file);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (file, \"fd%d\", REGNO (x) - 18);\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n       /* These are the least significant word in a 64bit value.  */\n       case 'L':\n \tswitch (GET_CODE (x))\n@@ -388,6 +460,22 @@ print_operand_address (file, addr)\n     }\n }\n \n+/* Count the number of FP registers that have to be saved.  */\n+static int\n+fp_regs_to_save ()\n+{\n+  int i, n = 0;\n+\n+  if (! TARGET_AM33_2)\n+    return 0;\n+\n+  for (i = FIRST_FP_REGNUM; i <= LAST_FP_REGNUM; ++i)\n+    if (regs_ever_live[i] && ! call_used_regs[i])\n+      ++n;\n+\n+  return n;\n+}\n+\n /* Print a set of registers in the format required by \"movm\" and \"ret\".\n    Register K is saved if bit K of MASK is set.  The data and address\n    registers can be stored individually, but the extended registers cannot.\n@@ -446,6 +534,7 @@ can_use_return_insn ()\n \t  && !regs_ever_live[15]\n \t  && !regs_ever_live[16]\n \t  && !regs_ever_live[17]\n+\t  && fp_regs_to_save () == 0\n \t  && !frame_pointer_needed);\n }\n \n@@ -460,7 +549,7 @@ mn10300_get_live_callee_saved_regs ()\n   int i;\n \n   mask = 0;\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+  for (i = 0; i <= LAST_EXTENDED_REGNUM; i++)\n     if (regs_ever_live[i] && ! call_used_regs[i])\n       mask |= (1 << i);\n   if ((mask & 0x3c000) != 0)\n@@ -501,7 +590,7 @@ mn10300_gen_multiple_store (mask)\n \n       /* Count how many registers need to be saved. */\n       count = 0;\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      for (i = 0; i <= LAST_EXTENDED_REGNUM; i++)\n \tif ((mask & (1 << i)) != 0)\n \t  count += 1;\n \n@@ -519,7 +608,7 @@ mn10300_gen_multiple_store (mask)\n \n       /* Create each store. */\n       pari = 1;\n-      for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+      for (i = LAST_EXTENDED_REGNUM; i >= 0; i--)\n \tif ((mask & (1 << i)) != 0)\n \t  {\n \t    rtx address = gen_rtx_PLUS (SImode,\n@@ -549,6 +638,240 @@ expand_prologue ()\n   /* If we use any of the callee-saved registers, save them now. */\n   mn10300_gen_multiple_store (mn10300_get_live_callee_saved_regs ());\n \n+  if (TARGET_AM33_2 && fp_regs_to_save ())\n+    {\n+      int num_regs_to_save = fp_regs_to_save (), i;\n+      HOST_WIDE_INT xsize;\n+      enum { save_sp_merge,\n+\t     save_sp_no_merge,\n+\t     save_sp_partial_merge,\n+\t     save_a0_merge,\n+\t     save_a0_no_merge } strategy;\n+      unsigned int strategy_size = (unsigned)-1, this_strategy_size;\n+      rtx reg;\n+      rtx insn;\n+\n+      /* We have several different strategies to save FP registers.\n+\t We can store them using SP offsets, which is beneficial if\n+\t there are just a few registers to save, or we can use `a0' in\n+\t post-increment mode (`a0' is the only call-clobbered address\n+\t register that is never used to pass information to a\n+\t function).  Furthermore, if we don't need a frame pointer, we\n+\t can merge the two SP adds into a single one, but this isn't\n+\t always beneficial; sometimes we can just split the two adds\n+\t so that we don't exceed a 16-bit constant size.  The code\n+\t below will select which strategy to use, so as to generate\n+\t smallest code.  Ties are broken in favor or shorter sequences\n+\t (in terms of number of instructions).  */\n+\n+#define SIZE_ADD_AX(S) ((((S) >= (1 << 15)) || ((S) < -(1 << 15))) ? 6 \\\n+\t\t\t: (((S) >= (1 << 7)) || ((S) < -(1 << 7))) ? 4 : 2)\n+#define SIZE_ADD_SP(S) ((((S) >= (1 << 15)) || ((S) < -(1 << 15))) ? 6 \\\n+\t\t\t: (((S) >= (1 << 7)) || ((S) < -(1 << 7))) ? 4 : 3)\n+#define SIZE_FMOV_LIMIT(S,N,L,SIZE1,SIZE2,ELSE) \\\n+  (((S) >= (L)) ? (SIZE1) * (N) \\\n+   : ((S) + 4 * (N) >= (L)) ? (((L) - (S)) / 4 * (SIZE2) \\\n+\t\t\t       + ((S) + 4 * (N) - (L)) / 4 * (SIZE1)) \\\n+   : (ELSE))\n+#define SIZE_FMOV_SP_(S,N) \\\n+  (SIZE_FMOV_LIMIT ((S), (N), (1 << 24), 7, 6, \\\n+                   SIZE_FMOV_LIMIT ((S), (N), (1 << 8), 6, 4, \\\n+\t\t\t\t    (S) ? 4 * (N) : 3 + 4 * ((N) - 1))))\n+#define SIZE_FMOV_SP(S,N) (SIZE_FMOV_SP_ ((unsigned HOST_WIDE_INT)(S), (N)))\n+\n+      /* Consider alternative save_sp_merge only if we don't need the\n+\t frame pointer and size is non-zero.  */\n+      if (! frame_pointer_needed && size)\n+\t{\n+\t  /* Insn: add -(size + 4 * num_regs_to_save), sp.  */\n+\t  this_strategy_size = SIZE_ADD_SP (-(size + 4 * num_regs_to_save));\n+\t  /* Insn: fmov fs#, (##, sp), for each fs# to be saved.  */\n+\t  this_strategy_size += SIZE_FMOV_SP (size, num_regs_to_save);\n+\n+\t  if (this_strategy_size < strategy_size)\n+\t    {\n+\t      strategy = save_sp_merge;\n+\t      strategy_size = this_strategy_size;\n+\t    }\n+\t}\n+\n+      /* Consider alternative save_sp_no_merge unconditionally.  */\n+      /* Insn: add -4 * num_regs_to_save, sp.  */\n+      this_strategy_size = SIZE_ADD_SP (-4 * num_regs_to_save);\n+      /* Insn: fmov fs#, (##, sp), for each fs# to be saved.  */\n+      this_strategy_size += SIZE_FMOV_SP (0, num_regs_to_save);\n+      if (size)\n+\t{\n+\t  /* Insn: add -size, sp.  */\n+\t  this_strategy_size += SIZE_ADD_SP (-size);\n+\t}\n+\n+      if (this_strategy_size < strategy_size)\n+\t{\n+\t  strategy = save_sp_no_merge;\n+\t  strategy_size = this_strategy_size;\n+\t}\n+\n+      /* Consider alternative save_sp_partial_merge only if we don't\n+\t need a frame pointer and size is reasonably large.  */\n+      if (! frame_pointer_needed && size + 4 * num_regs_to_save > 128)\n+\t{\n+\t  /* Insn: add -128, sp.  */\n+\t  this_strategy_size = SIZE_ADD_SP (-128);\n+\t  /* Insn: fmov fs#, (##, sp), for each fs# to be saved.  */\n+\t  this_strategy_size += SIZE_FMOV_SP (128 - 4 * num_regs_to_save,\n+\t\t\t\t\t      num_regs_to_save);\n+\t  if (size)\n+\t    {\n+\t      /* Insn: add 128-size, sp.  */\n+\t      this_strategy_size += SIZE_ADD_SP (128 - size);\n+\t    }\n+\n+\t  if (this_strategy_size < strategy_size)\n+\t    {\n+\t      strategy = save_sp_partial_merge;\n+\t      strategy_size = this_strategy_size;\n+\t    }\n+\t}\n+\n+      /* Consider alternative save_a0_merge only if we don't need a\n+\t frame pointer, size is non-zero and the user hasn't\n+\t changed the calling conventions of a0.  */\n+      if (! frame_pointer_needed && size\n+\t  && call_used_regs[FIRST_ADDRESS_REGNUM]\n+\t  && ! fixed_regs[FIRST_ADDRESS_REGNUM])\n+\t{\n+\t  /* Insn: add -(size + 4 * num_regs_to_save), sp.  */\n+\t  this_strategy_size = SIZE_ADD_SP (-(size + 4 * num_regs_to_save));\n+\t  /* Insn: mov sp, a0.  */\n+\t  this_strategy_size++;\n+\t  if (size)\n+\t    {\n+\t      /* Insn: add size, a0.  */\n+\t      this_strategy_size += SIZE_ADD_AX (size);\n+\t    }\n+\t  /* Insn: fmov fs#, (a0+), for each fs# to be saved.  */\n+\t  this_strategy_size += 3 * num_regs_to_save;\n+\n+\t  if (this_strategy_size < strategy_size)\n+\t    {\n+\t      strategy = save_a0_merge;\n+\t      strategy_size = this_strategy_size;\n+\t    }\n+\t}\n+\n+      /* Consider alternative save_a0_no_merge if the user hasn't\n+\t changed the calling conventions of a0. */\n+      if (call_used_regs[FIRST_ADDRESS_REGNUM]\n+\t  && ! fixed_regs[FIRST_ADDRESS_REGNUM])\n+\t{\n+\t  /* Insn: add -4 * num_regs_to_save, sp.  */\n+\t  this_strategy_size = SIZE_ADD_SP (-4 * num_regs_to_save);\n+\t  /* Insn: mov sp, a0.  */\n+\t  this_strategy_size++;\n+\t  /* Insn: fmov fs#, (a0+), for each fs# to be saved.  */\n+\t  this_strategy_size += 3 * num_regs_to_save;\n+\t  if (size)\n+\t    {\n+\t      /* Insn: add -size, sp.  */\n+\t      this_strategy_size += SIZE_ADD_SP (-size);\n+\t    }\n+\n+\t  if (this_strategy_size < strategy_size)\n+\t    {\n+\t      strategy = save_a0_no_merge;\n+\t      strategy_size = this_strategy_size;\n+\t    }\n+\t}\n+\n+      /* Emit the initial SP add, common to all strategies.  */\n+      switch (strategy)\n+\t{\n+\tcase save_sp_no_merge:\n+\tcase save_a0_no_merge:\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t GEN_INT (-4 * num_regs_to_save)));\n+\t  xsize = 0;\n+\t  break;\n+\n+\tcase save_sp_partial_merge:\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t GEN_INT (-128)));\n+\t  xsize = 128 - 4 * num_regs_to_save;\n+\t  size -= xsize;\n+\t  break;\n+\n+\tcase save_sp_merge:\n+\tcase save_a0_merge:\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t GEN_INT (-(size + 4 * num_regs_to_save))));\n+\t  /* We'll have to adjust FP register saves according to the\n+\t     frame size. */\n+\t  xsize = size;\n+\t  /* Since we've already created the stack frame, don't do it\n+\t     again at the end of the function. */\n+\t  size = 0;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\t  \n+      /* Now prepare register a0, if we have decided to use it.  */\n+      switch (strategy)\n+\t{\n+\tcase save_sp_merge:\n+\tcase save_sp_no_merge:\n+\tcase save_sp_partial_merge:\n+\t  reg = 0;\n+\t  break;\n+\n+\tcase save_a0_merge:\n+\tcase save_a0_no_merge:\n+\t  reg = gen_rtx_REG (SImode, FIRST_ADDRESS_REGNUM);\n+\t  emit_insn (gen_movsi (reg, stack_pointer_rtx));\n+\t  if (xsize)\n+\t    emit_insn (gen_addsi3 (reg, reg, GEN_INT (xsize)));\n+\t  reg = gen_rtx_POST_INC (SImode, reg);\n+\t  break;\n+\t  \n+\tdefault:\n+\t  abort ();\n+\t}\n+      \n+      /* Now actually save the FP registers.  */\n+      for (i = FIRST_FP_REGNUM; i <= LAST_FP_REGNUM; ++i)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    rtx addr;\n+\n+\t    if (reg)\n+\t      addr = reg;\n+\t    else\n+\t      {\n+\t\t/* If we aren't using `a0', use an SP offset.  */\n+\t\tif (xsize)\n+\t\t  {\n+\t\t    addr = gen_rtx_PLUS (SImode,\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT (xsize));\n+\t\t  }\n+\t\telse\n+\t\t  addr = stack_pointer_rtx;\n+\t\t\n+\t\txsize += 4;\n+\t      }\n+\n+\t    insn = emit_insn (gen_movsi (gen_rtx_MEM (SImode, addr),\n+\t\t\t\t\t gen_rtx_REG (SImode, i)));\n+\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t  }\n+    }\n+\n   /* Now put the frame pointer into the frame pointer register.  */\n   if (frame_pointer_needed)\n     emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n@@ -569,6 +892,193 @@ expand_epilogue ()\n   size = get_frame_size () + current_function_outgoing_args_size;\n   size += (current_function_outgoing_args_size ? 4 : 0);\n \n+  if (TARGET_AM33_2 && fp_regs_to_save ())\n+    {\n+      int num_regs_to_save = fp_regs_to_save (), i;\n+      rtx reg = 0;\n+\n+      /* We have several options to restore FP registers.  We could\n+\t load them from SP offsets, but, if there are enough FP\n+\t registers to restore, we win if we use a post-increment\n+\t addressing mode.  */\n+\n+      /* If we have a frame pointer, it's the best option, because we\n+\t already know it has the value we want.  */\n+      if (frame_pointer_needed)\n+\treg = gen_rtx_REG (SImode, FRAME_POINTER_REGNUM);\n+      /* Otherwise, we may use `a1', since it's call-clobbered and\n+\t it's never used for return values.  But only do so if it's\n+\t smaller than using SP offsets.  */\n+      else\n+\t{\n+\t  enum { restore_sp_post_adjust,\n+\t\t restore_sp_pre_adjust,\n+\t\t restore_sp_partial_adjust,\n+\t\t restore_a1 } strategy;\n+\t  unsigned int this_strategy_size, strategy_size = (unsigned)-1;\n+\n+\t  /* Consider using sp offsets before adjusting sp.  */\n+\t  /* Insn: fmov (##,sp),fs#, for each fs# to be restored.  */\n+\t  this_strategy_size = SIZE_FMOV_SP (size, num_regs_to_save);\n+\t  /* If size is too large, we'll have to adjust SP with an\n+\t\t add.  */\n+\t  if (size + 4 * num_regs_to_save + REG_SAVE_BYTES > 255)\n+\t    {\n+\t      /* Insn: add size + 4 * num_regs_to_save, sp.  */\n+\t      this_strategy_size += SIZE_ADD_SP (size + 4 * num_regs_to_save);\n+\t    }\n+\t  /* If we don't have to restore any non-FP registers,\n+\t\t we'll be able to save one byte by using rets.  */\n+\t  if (! REG_SAVE_BYTES)\n+\t    this_strategy_size--;\n+\n+\t  if (this_strategy_size < strategy_size)\n+\t    {\n+\t      strategy = restore_sp_post_adjust;\n+\t      strategy_size = this_strategy_size;\n+\t    }\n+\n+\t  /* Consider using sp offsets after adjusting sp.  */\n+\t  /* Insn: add size, sp.  */\n+\t  this_strategy_size = SIZE_ADD_SP (size);\n+\t  /* Insn: fmov (##,sp),fs#, for each fs# to be restored.  */\n+\t  this_strategy_size += SIZE_FMOV_SP (0, num_regs_to_save);\n+\t  /* We're going to use ret to release the FP registers\n+\t\t save area, so, no savings. */\n+\n+\t  if (this_strategy_size < strategy_size)\n+\t    {\n+\t      strategy = restore_sp_pre_adjust;\n+\t      strategy_size = this_strategy_size;\n+\t    }\n+\n+\t  /* Consider using sp offsets after partially adjusting sp.\n+\t     When size is close to 32Kb, we may be able to adjust SP\n+\t     with an imm16 add instruction while still using fmov\n+\t     (d8,sp).  */\n+\t  if (size + 4 * num_regs_to_save + REG_SAVE_BYTES > 255)\n+\t    {\n+\t      /* Insn: add size + 4 * num_regs_to_save\n+\t\t\t\t+ REG_SAVE_BYTES - 252,sp.  */\n+\t      this_strategy_size = SIZE_ADD_SP (size + 4 * num_regs_to_save\n+\t\t\t\t\t\t+ REG_SAVE_BYTES - 252);\n+\t      /* Insn: fmov (##,sp),fs#, fo each fs# to be restored.  */\n+\t      this_strategy_size += SIZE_FMOV_SP (252 - REG_SAVE_BYTES\n+\t\t\t\t\t\t  - 4 * num_regs_to_save,\n+\t\t\t\t\t\t  num_regs_to_save);\n+\t      /* We're going to use ret to release the FP registers\n+\t\t save area, so, no savings. */\n+\n+\t      if (this_strategy_size < strategy_size)\n+\t\t{\n+\t\t  strategy = restore_sp_partial_adjust;\n+\t\t  strategy_size = this_strategy_size;\n+\t\t}\n+\t    }\n+\n+\t  /* Consider using a1 in post-increment mode, as long as the\n+\t     user hasn't changed the calling conventions of a1.  */\n+\t  if (call_used_regs[FIRST_ADDRESS_REGNUM+1]\n+\t      && ! fixed_regs[FIRST_ADDRESS_REGNUM+1])\n+\t    {\n+\t      /* Insn: mov sp,a1.  */\n+\t      this_strategy_size = 1;\n+\t      if (size)\n+\t\t{\n+\t\t  /* Insn: add size,a1.  */\n+\t\t  this_strategy_size += SIZE_ADD_AX (size);\n+\t\t}\n+\t      /* Insn: fmov (a1+),fs#, for each fs# to be restored.  */\n+\t      this_strategy_size += 3 * num_regs_to_save;\n+\t      /* If size is large enough, we may be able to save a\n+\t\t couple of bytes.  */\n+\t      if (size + 4 * num_regs_to_save + REG_SAVE_BYTES > 255)\n+\t\t{\n+\t\t  /* Insn: mov a1,sp.  */\n+\t\t  this_strategy_size += 2;\n+\t\t}\n+\t      /* If we don't have to restore any non-FP registers,\n+\t\t we'll be able to save one byte by using rets.  */\n+\t      if (! REG_SAVE_BYTES)\n+\t\tthis_strategy_size--;\n+\n+\t      if (this_strategy_size < strategy_size)\n+\t\t{\n+\t\t  strategy = restore_a1;\n+\t\t  strategy_size = this_strategy_size;\n+\t\t}\n+\t    }\n+\n+\t  switch (strategy)\n+\t    {\n+\t    case restore_sp_post_adjust:\n+\t      break;\n+\n+\t    case restore_sp_pre_adjust:\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (size)));\n+\t      size = 0;\n+\t      break;\n+\n+\t    case restore_sp_partial_adjust:\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (size + 4 * num_regs_to_save\n+\t\t\t\t\t      + REG_SAVE_BYTES - 252)));\n+\t      size = 252 - REG_SAVE_BYTES - 4 * num_regs_to_save;\n+\t      break;\n+\t      \n+\t    case restore_a1:\n+\t      reg = gen_rtx_REG (SImode, FIRST_ADDRESS_REGNUM + 1);\n+\t      emit_insn (gen_movsi (reg, stack_pointer_rtx));\n+\t      if (size)\n+\t\temit_insn (gen_addsi3 (reg, reg, GEN_INT (size)));\n+\t      break;\n+\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t}\n+\n+      /* Adjust the selected register, if any, for post-increment.  */\n+      if (reg)\n+\treg = gen_rtx_POST_INC (SImode, reg);\n+\n+      for (i = FIRST_FP_REGNUM; i <= LAST_FP_REGNUM; ++i)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    rtx addr;\n+\t    \n+\t    if (reg)\n+\t      addr = reg;\n+\t    else if (size)\n+\t      {\n+\t\t/* If we aren't using a post-increment register, use an\n+\t\t   SP offset. */\n+\t\taddr = gen_rtx_PLUS (SImode,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (size));\n+\t      }\n+\t    else\n+\t      addr = stack_pointer_rtx;\n+\n+\t    size += 4;\n+\n+\t    emit_insn (gen_movsi (gen_rtx_REG (SImode, i),\n+\t\t\t\t  gen_rtx_MEM (SImode, addr)));\n+\t  }\n+\n+      /* If we were using the restore_a1 strategy and the number of\n+\t bytes to be released won't fit in the `ret' byte, copy `a1'\n+\t to `sp', to avoid having to use `add' to adjust it.  */\n+      if (! frame_pointer_needed && reg && size + REG_SAVE_BYTES > 255)\n+\t{\n+\t  emit_move_insn (stack_pointer_rtx, XEXP (reg, 0));\n+\t  size = 0;\n+\t}\n+    }\n+\n   /* Maybe cut back the stack, except for the register save area.\n \n      If the frame pointer exists, then use the frame pointer to\n@@ -649,6 +1159,9 @@ notice_update_cc (body, insn)\n       /* The insn is a compare instruction.  */\n       CC_STATUS_INIT;\n       cc_status.value1 = SET_SRC (body);\n+      if (GET_CODE (cc_status.value1) == COMPARE\n+\t  && GET_MODE (XEXP (cc_status.value1, 0)) == SFmode)\n+\tcc_status.mdep.fpCC = 1;\n       break;\n \n     case CC_INVERT:\n@@ -714,7 +1227,7 @@ store_multiple_operation (op, mode)\n \n      LAST keeps track of the smallest-numbered register stored so far.\n      MASK is the set of stored registers. */\n-  last = FIRST_PSEUDO_REGISTER;\n+  last = LAST_EXTENDED_REGNUM + 1;\n   mask = 0;\n   for (i = 1; i < count; i++)\n     {\n@@ -810,6 +1323,14 @@ secondary_reload_class (class, mode, in)\n       return DATA_REGS;\n     }\n  \n+  if (TARGET_AM33_2 && class == FP_REGS\n+      && GET_CODE (in) == MEM && ! OK_FOR_Q (in))\n+    {\n+      if (TARGET_AM33)\n+\treturn DATA_OR_EXTENDED_REGS;\n+      return DATA_REGS;\n+    }\n+\n   /* Otherwise assume no secondary reloads are needed.  */\n   return NO_REGS;\n }\n@@ -826,8 +1347,10 @@ initial_offset (from, to)\n \t  || regs_ever_live[6] || regs_ever_live[7]\n \t  || regs_ever_live[14] || regs_ever_live[15]\n \t  || regs_ever_live[16] || regs_ever_live[17]\n+\t  || fp_regs_to_save ()\n \t  || frame_pointer_needed)\n-\treturn REG_SAVE_BYTES;\n+\treturn REG_SAVE_BYTES\n+\t  + 4 * fp_regs_to_save ();\n       else\n \treturn 0;\n     }\n@@ -841,8 +1364,10 @@ initial_offset (from, to)\n \t  || regs_ever_live[6] || regs_ever_live[7]\n \t  || regs_ever_live[14] || regs_ever_live[15]\n \t  || regs_ever_live[16] || regs_ever_live[17]\n+\t  || fp_regs_to_save ()\n \t  || frame_pointer_needed)\n \treturn (get_frame_size () + REG_SAVE_BYTES\n+\t\t+ 4 * fp_regs_to_save ()\n \t\t+ (current_function_outgoing_args_size\n \t\t   ? current_function_outgoing_args_size + 4 : 0)); \n       else\n@@ -1155,6 +1680,15 @@ const_8bit_operand (op, mode)\n \t  && INTVAL (op) < 256);\n }\n \n+/* Return true if the operand is the 1.0f constant.  */\n+int\n+const_1f_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (op == CONST1_RTX (SFmode));\n+}\n+\n /* Similarly, but when using a zero_extract pattern for a btst where\n    the source operand might end up in memory.  */\n int\n@@ -1271,6 +1805,7 @@ mn10300_address_cost_1 (x, unsig)\n \n \tcase DATA_REGS:\n \tcase EXTENDED_REGS:\n+\tcase FP_REGS:\n \t  return 3;\n \n \tcase NO_REGS:"}, {"sha": "75d4183af74a44c8d0c4747cf7d0e4e7dd5eb267", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 83, "deletions": 19, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    Matsushita MN10300 series\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n@@ -40,7 +40,7 @@ Boston, MA 02111-1307, USA.  */\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-#define CPP_SPEC \"%{mam33:-D__AM33__}\"\n+#define CPP_SPEC \"%{mam33:-D__AM33__} %{mam33-2:-D__AM33__=2 -D__AM33_2__}\"\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -60,13 +60,19 @@ extern int target_flags;\n /* Generate code for the AM33 processor.  */\n #define TARGET_AM33\t\t\t(target_flags & 0x2)\n \n+/* Generate code for the AM33/2.0 processor.  */\n+#define TARGET_AM33_2\t\t\t(target_flags & 0x4)\n+\n #define TARGET_SWITCHES  \\\n   {{ \"mult-bug\",\t0x1,  N_(\"Work around hardware multiply bug\")},\t\\\n    { \"no-mult-bug\", \t-0x1, N_(\"Do not work around hardware multiply bug\")},\\\n    { \"am33\", \t\t0x2,  N_(\"Target the AM33 processor\")},\t\\\n    { \"am33\", \t\t-(0x1), \"\"},\\\n    { \"no-am33\", \t-0x2, \"\"},\t\\\n    { \"no-crt0\",\t\t0,    N_(\"No default crt0.o\") }, \\\n+   { \"am33-2\",\t\t0x6,  N_(\"Target the AM33/2.0 processor\")},   \\\n+   { \"am33-2\",\t\t-(0x1), \"\"},\\\n+   { \"no-am33-2\",\t-0x4,   \"\"},  \\\n    { \"relax\",\t\t0,    N_(\"Enable linker relaxations\") }, \\\n    { \"\", TARGET_DEFAULT, NULL}}\n \n@@ -131,7 +137,7 @@ extern int target_flags;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n \n-#define FIRST_PSEUDO_REGISTER 18\n+#define FIRST_PSEUDO_REGISTER 50\n \n /* Specify machine-specific register numbers.  */\n #define FIRST_DATA_REGNUM 0\n@@ -140,6 +146,8 @@ extern int target_flags;\n #define LAST_ADDRESS_REGNUM 8\n #define FIRST_EXTENDED_REGNUM 10\n #define LAST_EXTENDED_REGNUM 17\n+#define FIRST_FP_REGNUM 18\n+#define LAST_FP_REGNUM 49\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -162,7 +170,10 @@ extern int target_flags;\n    and are not available for the register allocator.  */\n \n #define FIXED_REGISTERS \\\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0}\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 \\\n+  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n+  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n+  }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -173,10 +184,16 @@ extern int target_flags;\n    like.  */\n \n #define CALL_USED_REGISTERS \\\n-  { 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0}\n+  { 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 \\\n+  , 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n+  , 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 \\\n+  }\n \n #define REG_ALLOC_ORDER \\\n-  { 0, 1, 4, 5, 2, 3, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 8, 9}\n+  { 0, 1, 4, 5, 2, 3, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 8, 9 \\\n+  , 42, 43, 44, 45, 46, 47, 48, 49, 34, 35, 36, 37, 38, 39, 40, 41 \\\n+  , 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33 \\\n+  }\n \n #define CONDITIONAL_REGISTER_USAGE \\\n {\t\t\t\t\t\t\\\n@@ -188,6 +205,13 @@ extern int target_flags;\n \t   i <= LAST_EXTENDED_REGNUM; i++) \t\\\n \tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n     }\t\t\t\t\t\t\\\n+  if (!TARGET_AM33_2)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      for (i = FIRST_FP_REGNUM;\t\t\t\\\n+\t   i <= LAST_FP_REGNUM; \t\t\\\n+           i++) \t\t\t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1;\t\\\n+    }\t\t\t\t\t\t\\\n }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -247,6 +271,7 @@ enum reg_class {\n   DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS, \n   EXTENDED_REGS, DATA_OR_EXTENDED_REGS, ADDRESS_OR_EXTENDED_REGS,\n   SP_OR_EXTENDED_REGS, SP_OR_ADDRESS_OR_EXTENDED_REGS, \n+  FP_REGS, FP_ACC_REGS,\n   GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -260,26 +285,29 @@ enum reg_class {\n   \"EXTENDED_REGS\", \\\n   \"DATA_OR_EXTENDED_REGS\", \"ADDRESS_OR_EXTENDED_REGS\", \\\n   \"SP_OR_EXTENDED_REGS\", \"SP_OR_ADDRESS_OR_EXTENDED_REGS\", \\\n+  \"FP_REGS\", \"FP_ACC_REGS\", \\\n   \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS  \t\t\t\\\n-{      {0},\t\t/* No regs      */\t\\\n-   {0x0000f},\t\t/* DATA_REGS */\t\t\\\n-   {0x001f0},\t\t/* ADDRESS_REGS */\t\\\n-   {0x00200},\t\t/* SP_REGS */\t\t\\\n-   {0x001ff},\t\t/* DATA_OR_ADDRESS_REGS */\\\n-   {0x003f0},\t\t/* SP_OR_ADDRESS_REGS */\\\n-   {0x3fc00},\t\t/* EXTENDED_REGS */\t\\\n-   {0x3fc0f},\t\t/* DATA_OR_EXTENDED_REGS */\t\\\n-   {0x3fdf0},\t\t/* ADDRESS_OR_EXTENDED_REGS */\t\\\n-   {0x3fe00},\t\t/* SP_OR_EXTENDED_REGS */\t\\\n-   {0x3fff0},\t\t/* SP_OR_ADDRESS_OR_EXTENDED_REGS */\t\\\n-   {0x3fdff},\t\t/* GENERAL_REGS */    \t\\\n-   {0x3ffff},\t\t/* ALL_REGS \t*/\t\\\n+{  { 0,\t0 },\t\t/* No regs      */\t\\\n+ { 0x0000f, 0 },\t/* DATA_REGS */\t\t\\\n+ { 0x001f0, 0 },\t/* ADDRESS_REGS */\t\\\n+ { 0x00200, 0 },\t/* SP_REGS */\t\t\\\n+ { 0x001ff, 0 },\t/* DATA_OR_ADDRESS_REGS */\\\n+ { 0x003f0, 0 },\t/* SP_OR_ADDRESS_REGS */\\\n+ { 0x3fc00, 0 },\t/* EXTENDED_REGS */\t\\\n+ { 0x3fc0f, 0 },\t/* DATA_OR_EXTENDED_REGS */\t\\\n+ { 0x3fdf0, 0 },\t/* ADDRESS_OR_EXTENDED_REGS */\t\\\n+ { 0x3fe00, 0 },\t/* SP_OR_EXTENDED_REGS */\t\\\n+ { 0x3fff0, 0 },\t/* SP_OR_ADDRESS_OR_EXTENDED_REGS */\t\\\n+ { 0xfffc0000, 0x3ffff }, /* FP_REGS */\t\t\\\n+ { 0x03fc0000, 0 },\t/* FP_ACC_REGS */\t\\\n+ { 0x3fdff, 0 }, \t/* GENERAL_REGS */\t\\\n+ { 0xffffffff, 0x3ffff } /* ALL_REGS \t*/\t\\\n }\n \n /* The same information, inverted:\n@@ -292,6 +320,7 @@ enum reg_class {\n    (REGNO) <= LAST_ADDRESS_REGNUM ? ADDRESS_REGS : \\\n    (REGNO) == STACK_POINTER_REGNUM ? SP_REGS : \\\n    (REGNO) <= LAST_EXTENDED_REGNUM ? EXTENDED_REGS : \\\n+   (REGNO) <= LAST_FP_REGNUM ? FP_REGS : \\\n    NO_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -306,6 +335,9 @@ enum reg_class {\n    (C) == 'y' ? SP_REGS : \\\n    ! TARGET_AM33 ? NO_REGS : \\\n    (C) == 'x' ? EXTENDED_REGS : \\\n+   ! TARGET_AM33_2 ? NO_REGS : \\\n+   (C) == 'f' ? FP_REGS : \\\n+   (C) == 'A' ? FP_ACC_REGS : \\\n    NO_REGS)\n \n /* Macros to check register numbers against specific register classes.  */\n@@ -350,6 +382,8 @@ enum reg_class {\n #define REGNO_AM33_P(regno) \\\n   (REGNO_DATA_P ((regno)) || REGNO_ADDRESS_P ((regno)) \\\n    || REGNO_EXTENDED_P ((regno)))\n+#define REGNO_FP_P(regno) \\\n+  REGNO_IN_RANGE_P ((regno), FIRST_FP_REGNUM, LAST_FP_REGNUM)\n \n #define REGNO_OK_FOR_BASE_P(regno) \\\n   (REGNO_SP_P ((regno)) \\\n@@ -397,6 +431,11 @@ enum reg_class {\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n+/* A class that contains registers which the compiler must always\n+   access in a mode that is the same size as the mode in which it\n+   loaded the register.  */\n+#define CLASS_CANNOT_CHANGE_SIZE FP_REGS\n+\n /* The letters I, J, K, L, M, N, O, P in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n    This macro defines what the ranges are.\n@@ -669,6 +708,9 @@ struct cum_arg {int nbytes; };\n \n /* Extra constraints.  */\n  \n+#define OK_FOR_Q(OP) \\\n+   (GET_CODE (OP) == MEM && ! CONSTANT_ADDRESS_P (XEXP (OP, 0)))\n+\n #define OK_FOR_R(OP) \\\n    (GET_CODE (OP) == MEM\t\t\t\t\t\\\n     && GET_MODE (OP) == QImode\t\t\t\t\t\\\n@@ -692,6 +734,7 @@ struct cum_arg {int nbytes; };\n \n #define EXTRA_CONSTRAINT(OP, C) \\\n  ((C) == 'R' ? OK_FOR_R (OP) \\\n+  : (C) == 'Q' ? OK_FOR_Q (OP) \\\n   : (C) == 'S' ? GET_CODE (OP) == SYMBOL_REF \\\n   : (C) == 'T' ? OK_FOR_T (OP) \\\n   : 0)\n@@ -814,6 +857,7 @@ struct cum_arg {int nbytes; };\n    ! TARGET_AM33 ? 6 : \\\n    (CLASS1 == SP_REGS || CLASS2 == SP_REGS) ? 6 : \\\n    (CLASS1 == CLASS2 && CLASS1 == EXTENDED_REGS) ? 6 : \\\n+   (CLASS1 == FP_REGS || CLASS2 == FP_REGS) ? 6 : \\\n    (CLASS1 == EXTENDED_REGS || CLASS2 == EXTENDED_REGS) ? 4 : \\\n    4)\n \n@@ -885,13 +929,21 @@ struct cum_arg {int nbytes; };\n #define REGISTER_NAMES \\\n { \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"ap\", \"sp\", \\\n   \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\" \\\n+, \"fs0\", \"fs1\", \"fs2\", \"fs3\", \"fs4\", \"fs5\", \"fs6\", \"fs7\" \\\n+, \"fs8\", \"fs9\", \"fs10\", \"fs11\", \"fs12\", \"fs13\", \"fs14\", \"fs15\" \\\n+, \"fs16\", \"fs17\", \"fs18\", \"fs19\", \"fs20\", \"fs21\", \"fs22\", \"fs23\" \\\n+, \"fs24\", \"fs25\", \"fs26\", \"fs27\", \"fs28\", \"fs29\", \"fs30\", \"fs31\" \\\n }\n \n #define ADDITIONAL_REGISTER_NAMES \\\n { {\"r8\",  4}, {\"r9\",  5}, {\"r10\", 6}, {\"r11\", 7}, \\\n   {\"r12\", 0}, {\"r13\", 1}, {\"r14\", 2}, {\"r15\", 3}, \\\n   {\"e0\", 10}, {\"e1\", 11}, {\"e2\", 12}, {\"e3\", 13}, \\\n   {\"e4\", 14}, {\"e5\", 15}, {\"e6\", 16}, {\"e7\", 17} \\\n+, {\"fd0\", 18}, {\"fd2\", 20}, {\"fd4\", 22}, {\"fd6\", 24} \\\n+, {\"fd8\", 26}, {\"fd10\", 28}, {\"fd12\", 30}, {\"fd14\", 32} \\\n+, {\"fd16\", 34}, {\"fd18\", 36}, {\"fd20\", 38}, {\"fd22\", 40} \\\n+, {\"fd24\", 42}, {\"fd26\", 44}, {\"fd28\", 46}, {\"fd30\", 48} \\\n }\n \n /* Print an instruction operand X on file FILE.\n@@ -994,3 +1046,15 @@ struct cum_arg {int nbytes; };\n \n #define FILE_ASM_OP \"\\t.file\\n\"\n \n+#define PREDICATE_CODES \\\n+  {\"const_1f_operand\", {CONST_INT, CONST_DOUBLE}},\n+\n+typedef struct mn10300_cc_status_mdep\n+  {\n+    int fpCC;\n+  }\n+cc_status_mdep;\n+\n+#define CC_STATUS_MDEP cc_status_mdep\n+\n+#define CC_STATUS_MDEP_INIT (cc_status.mdep.fpCC = 0)"}, {"sha": "a615f6b97eaf392f094b396e828e4d1928b79c03", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 232, "deletions": 32, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "patch": "@@ -57,8 +57,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*x*a,d*x,d*x*a,d*x*a,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"0,I,d*xai,m,d*xa\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x,d*x*a,d*x*a,m,*f,d*x*a\")\n+\t(match_operand:QI 1 \"general_operand\" \"0,I,d*xai,m,d*xa,d*xa*f,*f\"))]\n   \"TARGET_AM33\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n@@ -93,11 +93,14 @@\n     case 3:\n     case 4:\n       return \\\"movbu %1,%0\\\";\n+    case 5:\n+    case 6:\n+      return \\\"fmov %1,%0\\\";\n     default:\n       abort ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit\")])\n+  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*a,d,d*a,d,m\")\n@@ -147,8 +150,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*x*a,d*x,d*x*a,d*x*a,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"0,I,d*x*ai,m,d*x*a\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x,d*x*a,d*x*a,m,*f,d*x*a\")\n+\t(match_operand:HI 1 \"general_operand\" \"0,I,d*x*ai,m,d*x*a,d*x*a*f,*f\"))]\n   \"TARGET_AM33\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n@@ -183,11 +186,14 @@\n     case 3:\n     case 4:\n       return \\\"movhu %1,%0\\\";\n+    case 5:\n+    case 6:\n+      return \\\"fmov %1,%0\\\";\n     default:\n       abort ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit\")])\n+  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*a,d,d*a,d,m\")\n@@ -277,9 +283,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax,axR,!*y\")\n+\t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax,axR,!*y,*f,*f,dxaQ\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dixm,aixm,dixm,aixm,!*y,axR\"))]\n+\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dixm,aixm,dixm,aixm,!*y,axR,0,dxaQi*f,*f\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n   \"*\n@@ -321,11 +327,16 @@\n \t    return \\\"movu %1,%0\\\";\n \t}\n       return \\\"mov %1,%0\\\";\n+    case 14:\n+      return \\\"nop\\\";\n+    case 15:\n+    case 16:\n+      return \\\"fmov %1,%0\\\";\n     default:\n       abort ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none,none_0hit,none_0hit\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n@@ -340,8 +351,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=dx,ax,dx,a,daxm,dax\")\n-\t(match_operand:SF 1 \"general_operand\" \"0,0,G,G,dax,daxFm\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,dx,ax,dx,a,f,dxaQ,daxm,dax\")\n+\t(match_operand:SF 1 \"general_operand\" \"0,0,0,G,G,fdxaQF,f,dax,daxFm\"))]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\"\n   \"*\n@@ -350,12 +361,17 @@\n     {\n     case 0:\n     case 1:\n-      return \\\"nop\\\";\n     case 2:\n-      return \\\"clr %0\\\";\n+      return \\\"nop\\\";\n     case 3:\n-    case 4:\n+      return \\\"clr %0\\\";\n+    /* case 4: below */\n     case 5:\n+    case 6:\n+      return \\\"fmov %1, %0\\\";\n+    case 4:\n+    case 7:\n+    case 8:\n       if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n \t  && GET_CODE (operands[1]) == CONST_INT)\n \t{\n@@ -370,7 +386,7 @@\n       abort ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit\")])\n+  [(set_attr \"cc\" \"none,none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n \n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n@@ -386,9 +402,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n+\t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax,*f,*f,*f,dxa,*f,Q\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dxim,axim,dxim,axim\"))]\n+\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dxim,axim,dxim,axim,0,*f,dxai,*f,Q,*f\"))]\n   \"register_operand (operands[0], DImode)\n    || register_operand (operands[1], DImode)\"\n   \"*\n@@ -516,15 +532,36 @@\n \t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t    return \\\"\\\";\n \t  }\n+      case 12:\n+        return \\\"nop\\\";\n+      case 13:\n+      case 14:\n+      case 15:\n+        return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n+      case 16:\n+\tif (GET_CODE (operands[1]) == MEM\n+\t    && GET_CODE (XEXP (operands[1], 0)) == CONST_INT\n+\t    && (INTVAL (XEXP (operands[1], 0)) & 7) == 0)\n+\t  return \\\"fmov %D1, %D0\\\";\n+\telse\n+          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n+      case 17:\n+\tif (GET_CODE (operands[0]) == MEM\n+\t    && GET_CODE (XEXP (operands[0], 0)) == CONST_INT\n+\t    && (INTVAL (XEXP (operands[0], 0)) & 7) == 0)\n+\t  return \\\"fmov %D1, %D0\\\";\n+\telse\n+          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n     default:\n       abort ();\n     }\n }\"\n   [(set (attr \"cc\")\n \t(cond\n \t [\n-\t (lt (symbol_ref \"which_alternative\") (const_int 2)\n-\t     ) (const_string \"none\")\n+\t (ior (lt (symbol_ref \"which_alternative\") (const_int 2))\n+\t      (eq (symbol_ref \"which_alternative\") (const_int 12))\n+\t      ) (const_string \"none\")\n \t (eq (symbol_ref \"which_alternative\") (const_int 2)\n \t     ) (const_string \"clobber\")\n \t (eq (symbol_ref \"which_alternative\") (const_int 3)\n@@ -555,9 +592,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n+\t\t\t\t\"=f,dx,ax,dx,f,f,dxa,f,Q,a,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\t\t\"0,0,G,G,dx,ax,dx,ax,dxFm,axFm,dxFm,axFm\"))]\n+\t\t\t\t\"0,0,0,G,f,dxaF,f,Q,f,G,dx,ax,dx,ax,dxFm,axFm,dxFm,axFm\"))]\n   \"register_operand (operands[0], DFmode)\n    || register_operand (operands[1], DFmode)\"\n   \"*\n@@ -569,24 +606,46 @@\n     {\n       case 0:\n       case 1:\n+      case 2:\n \treturn \\\"nop\\\";\n \n-      case 2:\n+      case 3:\n \treturn \\\"clr %L0\\;clr %H0\\\";\n \n-      case 3:\n-\t if (rtx_equal_p (operands[0], operands[1]))\n-\t   return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n-\t else\n-\t   return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n       case 4:\n       case 5:\n       case 6:\n+        return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n+\n       case 7:\n+\tif (GET_CODE (operands[1]) == MEM\n+\t    && GET_CODE (XEXP (operands[1], 0)) == CONST_INT\n+\t    && (INTVAL (XEXP (operands[1], 0)) & 7) == 0)\n+\t  return \\\"fmov %D1, %D0\\\";\n+\telse\n+          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n+\n       case 8:\n+\tif (GET_CODE (operands[0]) == MEM\n+\t    && GET_CODE (XEXP (operands[0], 0)) == CONST_INT\n+\t    && (INTVAL (XEXP (operands[0], 0)) & 7) == 0)\n+\t  return \\\"fmov %D1, %D0\\\";\n+\telse\n+          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n+\n       case 9:\n+\t if (rtx_equal_p (operands[0], operands[1]))\n+\t   return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n+\t else\n+\t   return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n       case 10:\n       case 11:\n+      case 12:\n+      case 13:\n+      case 14:\n+      case 15:\n+      case 16:\n+      case 17:\n \tif (GET_CODE (operands[1]) == CONST_INT)\n \t  {\n \t    rtx low, high;\n@@ -692,17 +751,17 @@\n   [(set (attr \"cc\")\n \t(cond\n \t [\n-\t (lt (symbol_ref \"which_alternative\") (const_int 2)\n+\t (lt (symbol_ref \"which_alternative\") (const_int 3)\n \t     ) (const_string \"none\")\n-\t (eq (symbol_ref \"which_alternative\") (const_int 2)\n-\t     ) (const_string \"clobber\")\n \t (eq (symbol_ref \"which_alternative\") (const_int 3)\n+\t     ) (const_string \"clobber\")\n+\t (eq (symbol_ref \"which_alternative\") (const_int 9)\n \t     ) (if_then_else\n \t\t(ne (symbol_ref \"rtx_equal_p (operands[0], operands[1])\")\n \t\t    (const_int 0)) (const_string \"clobber\")\n \t\t    (const_string \"none_0hit\"))\n-\t (ior (eq (symbol_ref \"which_alternative\") (const_int 8))\n-\t      (eq (symbol_ref \"which_alternative\") (const_int 9))\n+\t (ior (eq (symbol_ref \"which_alternative\") (const_int 14))\n+\t      (eq (symbol_ref \"which_alternative\") (const_int 15))\n \t      ) (if_then_else\n \t\t (ne (symbol_ref \"mn10300_wide_const_load_uses_clr\n \t\t\t\t  (operands)\")\n@@ -773,6 +832,14 @@\n   btst 0,d0\n   cmp %1,%0\"\n   [(set_attr \"cc\" \"compare,compare\")])\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"register_operand\" \"f,f\")\n+\t\t (match_operand:SF 1 \"nonmemory_operand\" \"f,F\")))]\n+  \"TARGET_AM33_2\"\n+  \"fcmp %1,%0\"\n+  [(set_attr \"cc\" \"compare,compare\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n@@ -1551,6 +1618,8 @@\n   \"\"\n   \"*\n {\n+  if (cc_status.mdep.fpCC)\n+    return \\\"fb%b1 %0\\\";\n   if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n       && (GET_CODE (operands[1]) == GT\n \t  || GET_CODE (operands[1]) == GE\n@@ -1570,6 +1639,8 @@\n   \"\"\n   \"*\n {\n+  if (cc_status.mdep.fpCC)\n+    return \\\"fb%B1 %0\\\";\n   if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n       && (GET_CODE (operands[1]) == GT\n \t  || GET_CODE (operands[1]) == GE\n@@ -1996,6 +2067,12 @@\n   rtx result;\n   rtx target;\n \n+  if (TARGET_AM33_2)\n+    {\n+      emit_insn (gen_abssf2_am33_2 (operands[0], operands[1]));\n+      DONE;\n+    }\n+\n   target = operand_subword_force (operands[0], 0, SFmode);\n   result = expand_binop (SImode, and_optab,\n \t\t\t operand_subword_force (operands[1], 0, SFmode),\n@@ -2012,6 +2089,15 @@\n }\")\n \n \n+(define_insn \"abssf2_am33_2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0,?f\")))]\n+  \"TARGET_AM33_2\"\n+  \"@\n+   fabs %0\n+   fabs %1, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n (define_expand \"negdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n@@ -2052,6 +2138,12 @@\n   rtx result;\n   rtx target;\n \n+  if (TARGET_AM33_2)\n+    {\n+      emit_insn (gen_negsf2_am33_2 (operands[0], operands[1]));\n+      DONE;\n+    }\n+\n   target = operand_subword_force (operands[0], 0, SFmode);\n   result = expand_binop (SImode, xor_optab,\n \t\t\t operand_subword_force (operands[1], 0, SFmode),\n@@ -2068,6 +2160,114 @@\n   DONE;\n }\")\n \n+(define_insn \"negsf2_am33_2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"0,?f\")))]\n+  \"TARGET_AM33_2\"\n+  \"@\n+   fneg %0\n+   fneg %1, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_expand \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"TARGET_AM33_2 && flag_unsafe_math_optimizations\"\n+  \"\n+{\n+  rtx scratch = gen_reg_rtx (SFmode);\n+  emit_insn (gen_rsqrtsf2 (scratch, operands[1], CONST1_RTX (SFmode)));\n+  emit_insn (gen_divsf3 (operands[0], force_reg (SFmode, CONST1_RTX (SFmode)),\n+\t\t\t scratch));\n+  DONE;\n+}\")\n+\n+(define_insn \"rsqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(div:SF (match_operand:SF 2 \"const_1f_operand\" \"F,F\")\n+\t\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0,?f\"))))]\n+  \"TARGET_AM33_2\"\n+  \"@\n+   frsqrt %0\n+   frsqrt %1, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0,f\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+  \"TARGET_AM33_2\"\n+  \"@\n+   fadd %2, %0\n+   fadd %2, %1, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"0,f\")\n+\t\t  (match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+  \"TARGET_AM33_2\"\n+  \"@\n+   fsub %2, %0\n+   fsub %2, %1, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0,f\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+  \"TARGET_AM33_2\"\n+  \"@\n+   fmul %2, %0\n+   fmul %2, %1, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"0,f\")\n+\t\t(match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+  \"TARGET_AM33_2\"\n+  \"@\n+   fdiv %2, %0\n+   fdiv %2, %1, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"fmaddsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n+\t(plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n+\t\t\t  (match_operand:SF 2 \"register_operand\" \"f\"))\n+\t\t (match_operand:SF 3 \"register_operand\" \"f\")))]\n+  \"TARGET_AM33_2\"\n+  \"fmadd %1, %2, %3, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"fmsubsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n+\t(minus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n+\t\t\t   (match_operand:SF 2 \"register_operand\" \"f\"))\n+\t\t  (match_operand:SF 3 \"register_operand\" \"f\")))]\n+  \"TARGET_AM33_2\"\n+  \"fmsub %1, %2, %3, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"fnmaddsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n+\t(minus:SF (match_operand:SF 3 \"register_operand\" \"f\")\n+\t\t  (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n+\t\t\t   (match_operand:SF 2 \"register_operand\" \"f\"))))]\n+  \"TARGET_AM33_2\"\n+  \"fnmadd %1, %2, %3, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"fnmsubsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n+\t(minus:SF (neg:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n+\t\t\t\t   (match_operand:SF 2 \"register_operand\" \"f\")))\n+\t\t  (match_operand:SF 3 \"register_operand\" \"f\")))]\n+  \"TARGET_AM33_2\"\n+  \"fnmsub %1, %2, %3, %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n \n ;; ----------------------------------------------------------------------\n ;; PROLOGUE/EPILOGUE"}, {"sha": "a35b2c5018539a60b3f0906378685d25d3932e93", "filename": "gcc/config/mn10300/t-mn10300", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Ft-mn10300?ref=18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "patch": "@@ -10,8 +10,8 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#define FLOAT' > fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-MULTILIB_OPTIONS = mam33\n-MULTILIB_DIRNAMES = am33\n+MULTILIB_OPTIONS = mam33/mam33-2\n+MULTILIB_DIRNAMES = am33 am33-2\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}, {"sha": "bd49134720387e812ada38347268d982f3240056", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=18e9d2f9e3de52e2a1e5fc6c6300ad57e245bcc5", "patch": "@@ -386,6 +386,7 @@ in the following sections.\n @emph{MN10300 Options}\n @gccoptlist{-mmult-bug  -mno-mult-bug @gol\n -mam33  -mno-am33 @gol\n+-mam33-2  -mno-am33-2 @gol\n -mno-crt0  -mrelax}\n \n @emph{M32R/D Options}"}]}