{"sha": "f313d112b04b691b736a75f72af49ca6779e9236", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxM2QxMTJiMDRiNjkxYjczNmE3NWY3MmFmNDljYTY3NzllOTIzNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-12-02T14:57:54Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-02T14:57:54Z"}, "message": "nvptx-protos.h (nvptx_output_mov_insn): Declare.\n\n\t* config/nvptx/nvptx-protos.h (nvptx_output_mov_insn): Declare.\n\t(nvptx_underlying_object_mode): Delete.\n\t* config/nvptx/nvptx.c (nvptx_underlying_object_mode): Delete.\n\t(output_reg): New.\n\t(nvptx_declare_function_name): Use output_reg.  Remove punning\n\tbuffer.\n\t(nvptx_output_mov_insn): New.\n\t(nvptx_print_operand): Separate SUBREG handling, remove 'f' case,\n\tUse output_reg. Merge 't' and 'u' handling.\n\t* config/nvptx/nvptx.h (NVPTX_PUNNING_BUFFER_REGNUM): Delete.\n\t(struct machine_function): Remvoe punning_buffer_size.\n\t(REGISTER_NAMES): Remove %punbuffer.\n\t* config/nvptx/nvptx.md (UNSPEC_CPLX_LOWPART,\n\tUNSPEC_CPLX_HIGHPART): Delete.\n\t(*mov<mode>_insn [QHSDIM): Remove unnecessary constraints, use\n\tnvptx_output_mov_insn.\n\t(*mov<mode>_insn [SDFM): Reorder constraints to match integer\n\tmoc.  Use nvptx_output_mov_insn.\n\t(highpartscsf2,  set_highpartscsf2, lowpartscsf2,\n\tset_lowpartscsf2): Delete.\n\t(mov<mode> [SDCM]): Delete.\n\nFrom-SVN: r231180", "tree": {"sha": "6d35b54b0739ec9b350c4036cd152956829c788a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d35b54b0739ec9b350c4036cd152956829c788a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f313d112b04b691b736a75f72af49ca6779e9236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f313d112b04b691b736a75f72af49ca6779e9236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f313d112b04b691b736a75f72af49ca6779e9236", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f313d112b04b691b736a75f72af49ca6779e9236/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b2eca00295325f4029b71bee8263df7a1275091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b2eca00295325f4029b71bee8263df7a1275091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b2eca00295325f4029b71bee8263df7a1275091"}], "stats": {"total": 370, "additions": 135, "deletions": 235}, "files": [{"sha": "990aab8813cdb40e41f64af55876c2076c0755e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f313d112b04b691b736a75f72af49ca6779e9236", "patch": "@@ -1,3 +1,27 @@\n+2015-12-02  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx-protos.h (nvptx_output_mov_insn): Declare.\n+\t(nvptx_underlying_object_mode): Delete.\n+\t* config/nvptx/nvptx.c (nvptx_underlying_object_mode): Delete.\n+\t(output_reg): New.\n+\t(nvptx_declare_function_name): Use output_reg.  Remove punning\n+\tbuffer.\n+\t(nvptx_output_mov_insn): New.\n+\t(nvptx_print_operand): Separate SUBREG handling, remove 'f' case,\n+\tUse output_reg. Merge 't' and 'u' handling.\n+\t* config/nvptx/nvptx.h (NVPTX_PUNNING_BUFFER_REGNUM): Delete.\n+\t(struct machine_function): Remvoe punning_buffer_size.\n+\t(REGISTER_NAMES): Remove %punbuffer.\n+\t* config/nvptx/nvptx.md (UNSPEC_CPLX_LOWPART,\n+\tUNSPEC_CPLX_HIGHPART): Delete.\n+\t(*mov<mode>_insn [QHSDIM): Remove unnecessary constraints, use\n+\tnvptx_output_mov_insn.\n+\t(*mov<mode>_insn [SDFM): Reorder constraints to match integer\n+\tmoc.  Use nvptx_output_mov_insn.\n+\t(highpartscsf2,  set_highpartscsf2, lowpartscsf2,\n+\tset_lowpartscsf2): Delete.\n+\t(mov<mode> [SDCM]): Delete.\n+\n 2015-12-02  Richard Biener  <rguenther@suse.de>\n \n \t* tree.h (tree_invariant_p): Declare."}, {"sha": "de364fa4da770a44fd8b9f0d4d00d2054cd71992", "filename": "gcc/config/nvptx/nvptx-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h?ref=f313d112b04b691b736a75f72af49ca6779e9236", "patch": "@@ -38,9 +38,9 @@ extern void nvptx_expand_oacc_join (unsigned);\n extern void nvptx_expand_call (rtx, rtx);\n extern rtx nvptx_expand_compare (rtx);\n extern const char *nvptx_ptx_type_from_mode (machine_mode, bool);\n+extern const char *nvptx_output_mov_insn (rtx, rtx);\n extern const char *nvptx_output_call_insn (rtx_insn *, rtx, rtx);\n extern const char *nvptx_output_return (void);\n-extern machine_mode nvptx_underlying_object_mode (rtx);\n extern const char *nvptx_section_from_addr_space (addr_space_t);\n extern bool nvptx_hard_regno_mode_ok (int, machine_mode);\n extern rtx nvptx_maybe_convert_symbolic_operand (rtx);"}, {"sha": "17e129c537356f7209aad0e65f0f846874965782", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 100, "deletions": 66, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=f313d112b04b691b736a75f72af49ca6779e9236", "patch": "@@ -155,23 +155,6 @@ nvptx_option_override (void)\n   worker_red_align = GET_MODE_ALIGNMENT (SImode) / BITS_PER_UNIT;\n }\n \n-/* Return the mode to be used when declaring a ptx object for OBJ.\n-   For objects with subparts such as complex modes this is the mode\n-   of the subpart.  */\n-\n-machine_mode\n-nvptx_underlying_object_mode (rtx obj)\n-{\n-  if (GET_CODE (obj) == SUBREG)\n-    obj = SUBREG_REG (obj);\n-  machine_mode mode = GET_MODE (obj);\n-  if (mode == TImode)\n-    return DImode;\n-  if (COMPLEX_MODE_P (mode))\n-    return GET_MODE_INNER (mode);\n-  return mode;\n-}\n-\n /* Return a ptx type for MODE.  If PROMOTE, then use .u32 for QImode to\n    deal with ptx ideosyncracies.  */\n \n@@ -257,6 +240,37 @@ maybe_split_mode (machine_mode mode)\n   return VOIDmode;\n }\n \n+/* Output a register, subreg, or register pair (with optional\n+   enclosing braces).  */\n+\n+static void\n+output_reg (FILE *file, unsigned regno, machine_mode inner_mode,\n+\t    int subreg_offset = -1)\n+{\n+  if (inner_mode == VOIDmode)\n+    {\n+      if (HARD_REGISTER_NUM_P (regno))\n+\tfprintf (file, \"%s\", reg_names[regno]);\n+      else\n+\tfprintf (file, \"%%r%d\", regno);\n+    }\n+  else if (subreg_offset >= 0)\n+    {\n+      output_reg (file, regno, VOIDmode);\n+      fprintf (file, \"$%d\", subreg_offset);\n+    }\n+  else\n+    {\n+      if (subreg_offset == -1)\n+\tfprintf (file, \"{\");\n+      output_reg (file, regno, inner_mode, GET_MODE_SIZE (inner_mode));\n+      fprintf (file, \",\");\n+      output_reg (file, regno, inner_mode, 0);\n+      if (subreg_offset == -1)\n+\tfprintf (file, \"}\");\n+    }\n+}\n+\n /* Emit forking instructions for MASK.  */\n \n static void\n@@ -724,16 +738,12 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \t{\n \t  machine_mode mode = PSEUDO_REGNO_MODE (i);\n \t  machine_mode split = maybe_split_mode (mode);\n+\n \t  if (split != VOIDmode)\n-\t    {\n-\t      fprintf (file, \"\\t.reg%s %%r%d$%d;\\n\",\n-\t\t       nvptx_ptx_type_from_mode (split, true), i, 0);\n-\t      fprintf (file, \"\\t.reg%s %%r%d$%d;\\n\",\n-\t\t       nvptx_ptx_type_from_mode (split, true), i, 1);\n-\t    }\n-\t  else\n-\t    fprintf (file, \"\\t.reg%s %%r%d;\\n\",\n-\t\t     nvptx_ptx_type_from_mode (mode, true), i);\n+\t    mode = split;\n+\t  fprintf (file, \"\\t.reg%s \", nvptx_ptx_type_from_mode (mode, true));\n+\t  output_reg (file, i, split, -2);\n+\t  fprintf (file, \";\\n\");\n \t}\n     }\n \n@@ -754,15 +764,6 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \t       BITS_PER_WORD);\n     }\n \n-  if (cfun->machine->punning_buffer_size > 0)\n-    {\n-      fprintf (file, \"\\t.reg.u%d %%punbuffer;\\n\"\n-\t       \"\\t.local.align 8 .b8 %%punbuffer_ar[%d];\\n\",\n-\t       BITS_PER_WORD, cfun->machine->punning_buffer_size);\n-      fprintf (file, \"\\tcvta.local.u%d %%punbuffer, %%punbuffer_ar;\\n\",\n-\t       BITS_PER_WORD);\n-    }\n-\n   /* Declare a local variable for the frame.  */\n   sz = get_frame_size ();\n   if (sz > 0 || cfun->machine->has_call_with_sc)\n@@ -1755,6 +1756,7 @@ nvptx_globalize_label (FILE *, const char *)\n \n /* Implement TARGET_ASM_ASSEMBLE_UNDEFINED_DECL.  Write an extern\n    declaration only for variable DECL with NAME to FILE.  */\n+\n static void\n nvptx_assemble_undefined_decl (FILE *file, const char *name, const_tree decl)\n {\n@@ -1772,6 +1774,37 @@ nvptx_assemble_undefined_decl (FILE *file, const char *name, const_tree decl)\n   fprintf (file, \";\\n\\n\");\n }\n \n+/* Output a pattern for a move instruction.  */\n+\n+const char *\n+nvptx_output_mov_insn (rtx dst, rtx src)\n+{\n+  machine_mode dst_mode = GET_MODE (dst);\n+  machine_mode dst_inner = (GET_CODE (dst) == SUBREG\n+\t\t\t    ? GET_MODE (XEXP (dst, 0)) : dst_mode);\n+  machine_mode src_inner = (GET_CODE (src) == SUBREG\n+\t\t\t    ? GET_MODE (XEXP (src, 0)) : dst_mode);\n+\n+  if (REG_P (dst) && REGNO (dst) == NVPTX_RETURN_REGNUM && dst_mode == HImode)\n+    /* Special handling for the return register.  It's never really an\n+       HI object, and only occurs as the destination of a move\n+       insn.  */\n+    dst_inner = SImode;\n+\n+  if (src_inner == dst_inner)\n+    return \"%.\\tmov%t0\\t%0, %1;\";\n+\n+  if (CONSTANT_P (src))\n+    return (GET_MODE_CLASS (dst_inner) == MODE_INT\n+\t    && GET_MODE_CLASS (src_inner) != MODE_FLOAT\n+\t    ? \"%.\\tmov%t0\\t%0, %1;\" : \"%.\\tmov.b%T0\\t%0, %1;\");\n+\n+  if (GET_MODE_SIZE (dst_inner) == GET_MODE_SIZE (src_inner))\n+    return \"%.\\tmov.b%T0\\t%0, %1;\";\n+\n+  return \"%.\\tcvt%t0%t1\\t%0, %1;\";\n+}\n+\n /* Output INSN, which is a call to CALLEE with result RESULT.  For ptx, this\n    involves writing .param declarations and in/out copies into them.  For\n    indirect calls, also write the .callprototype.  */\n@@ -1921,7 +1954,6 @@ nvptx_print_operand_address (FILE *file, machine_mode mode, rtx addr)\n \n    A -- print an address space identifier for a MEM\n    c -- print an opcode suffix for a comparison operator, including a type code\n-   f -- print a full reg even for something that must always be split\n    S -- print a shuffle kind specified by CONST_INT\n    t -- print a type opcode suffix, promoting QImode to 32 bits\n    T -- print a type size in bits\n@@ -1930,9 +1962,6 @@ nvptx_print_operand_address (FILE *file, machine_mode mode, rtx addr)\n static void\n nvptx_print_operand (FILE *file, rtx x, int code)\n {\n-  rtx orig_x = x;\n-  machine_mode op_mode;\n-\n   if (code == '.')\n     {\n       x = current_insn_predicate;\n@@ -1954,6 +1983,7 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n     }\n \n   enum rtx_code x_code = GET_CODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   switch (code)\n     {\n@@ -1975,13 +2005,16 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n       break;\n \n     case 't':\n-      op_mode = nvptx_underlying_object_mode (x);\n-      fprintf (file, \"%s\", nvptx_ptx_type_from_mode (op_mode, true));\n-      break;\n-\n     case 'u':\n-      op_mode = nvptx_underlying_object_mode (x);\n-      fprintf (file, \"%s\", nvptx_ptx_type_from_mode (op_mode, false));\n+      if (x_code == SUBREG)\n+\t{\n+\t  mode = GET_MODE (SUBREG_REG (x));\n+\t  if (mode == TImode)\n+\t    mode = DImode;\n+\t  else if (COMPLEX_MODE_P (mode))\n+\t    mode = GET_MODE_INNER (mode);\n+\t}\n+      fprintf (file, \"%s\", nvptx_ptx_type_from_mode (mode, code == 't'));\n       break;\n \n     case 'S':\n@@ -1994,7 +2027,7 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n       break;\n \n     case 'T':\n-      fprintf (file, \"%d\", GET_MODE_BITSIZE (GET_MODE (x)));\n+      fprintf (file, \"%d\", GET_MODE_BITSIZE (mode));\n       break;\n \n     case 'j':\n@@ -2006,14 +2039,14 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n       goto common;\n \n     case 'c':\n-      op_mode = GET_MODE (XEXP (x, 0));\n+      mode = GET_MODE (XEXP (x, 0));\n       switch (x_code)\n \t{\n \tcase EQ:\n \t  fputs (\".eq\", file);\n \t  break;\n \tcase NE:\n-\t  if (FLOAT_MODE_P (op_mode))\n+\t  if (FLOAT_MODE_P (mode))\n \t    fputs (\".neu\", file);\n \t  else\n \t    fputs (\".ne\", file);\n@@ -2069,38 +2102,39 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      if (FLOAT_MODE_P (op_mode)\n+      if (FLOAT_MODE_P (mode)\n \t  || x_code == EQ || x_code == NE\n \t  || x_code == GEU || x_code == GTU\n \t  || x_code == LEU || x_code == LTU)\n-\tfputs (nvptx_ptx_type_from_mode (op_mode, true), file);\n+\tfputs (nvptx_ptx_type_from_mode (mode, true), file);\n       else\n-\tfprintf (file, \".s%d\", GET_MODE_BITSIZE (op_mode));\n+\tfprintf (file, \".s%d\", GET_MODE_BITSIZE (mode));\n       break;\n     default:\n     common:\n       switch (x_code)\n \t{\n \tcase SUBREG:\n-\t  x = SUBREG_REG (x);\n-\t  /* fall through */\n+\t  {\n+\t    rtx inner_x = SUBREG_REG (x);\n+\t    machine_mode inner_mode = GET_MODE (inner_x);\n+\t    machine_mode split = maybe_split_mode (inner_mode);\n+\n+\t    if (split != VOIDmode\n+\t\t&& (GET_MODE_SIZE (inner_mode) == GET_MODE_SIZE (mode)))\n+\t      output_reg (file, REGNO (inner_x), split);\n+\t    else\n+\t      output_reg (file, REGNO (inner_x), split, SUBREG_BYTE (x));\n+\t  }\n+\t  break;\n \n \tcase REG:\n-\t  if (HARD_REGISTER_P (x))\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t  else\n-\t    fprintf (file, \"%%r%d\", REGNO (x));\n-\t  if (code != 'f' && maybe_split_mode (GET_MODE (x)) != VOIDmode)\n-\t    {\n-\t      gcc_assert (GET_CODE (orig_x) == SUBREG\n-\t\t\t  && maybe_split_mode (GET_MODE (orig_x)) == VOIDmode);\n-\t      fprintf (file, \"$%d\", SUBREG_BYTE (orig_x) / UNITS_PER_WORD);\n-\t    }\n+\t  output_reg (file, REGNO (x), maybe_split_mode (mode));\n \t  break;\n \n \tcase MEM:\n \t  fputc ('[', file);\n-\t  nvptx_print_address_operand (file, XEXP (x, 0), GET_MODE (x));\n+\t  nvptx_print_address_operand (file, XEXP (x, 0), mode);\n \t  fputc (']', file);\n \t  break;\n \n@@ -2119,10 +2153,10 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n \n \tcase CONST_DOUBLE:\n \t  long vals[2];\n-\t  real_to_target (vals, CONST_DOUBLE_REAL_VALUE (x), GET_MODE (x));\n+\t  real_to_target (vals, CONST_DOUBLE_REAL_VALUE (x), mode);\n \t  vals[0] &= 0xffffffff;\n \t  vals[1] &= 0xffffffff;\n-\t  if (GET_MODE (x) == SFmode)\n+\t  if (mode == SFmode)\n \t    fprintf (file, \"0f%08lx\", vals[0]);\n \t  else\n \t    fprintf (file, \"0d%08lx%08lx\", vals[1], vals[0]);"}, {"sha": "a6e74eaabb85eff0ab0489af570441200b7c6250", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=f313d112b04b691b736a75f72af49ca6779e9236", "patch": "@@ -156,7 +156,6 @@ enum reg_class\n \n #define STACK_POINTER_REGNUM 1\n #define HARD_FRAME_POINTER_REGNUM 2\n-#define NVPTX_PUNNING_BUFFER_REGNUM 3\n #define NVPTX_RETURN_REGNUM 4\n #define FRAME_POINTER_REGNUM 15\n #define ARG_POINTER_REGNUM 14\n@@ -231,7 +230,6 @@ struct GTY(()) machine_function\n   bool has_call_with_sc;\n   HOST_WIDE_INT outgoing_stdarg_size;\n   int ret_reg_mode; /* machine_mode not defined yet. */\n-  int punning_buffer_size;\n   rtx axis_predicate[2];\n };\n #endif\n@@ -264,7 +262,7 @@ struct GTY(()) machine_function\n \n #define REGISTER_NAMES\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    \"%hr0\", \"%outargs\", \"%hfp\", \"%punbuffer\", \"%retval\", \"%retval_in\", \"%hr6\", \"%hr7\",\t\\\n+    \"%hr0\", \"%outargs\", \"%hfp\", \"%hr3\", \"%retval\", \"%retval_in\", \"%hr6\", \"%hr7\",\t\\\n     \"%hr8\", \"%hr9\", \"%hr10\", \"%hr11\", \"%hr12\", \"%hr13\", \"%argp\", \"%frame\" \\\n   }\n "}, {"sha": "913afc11139fe7736468ebb3aa289b76d7d8556e", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 9, "deletions": 165, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f313d112b04b691b736a75f72af49ca6779e9236/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=f313d112b04b691b736a75f72af49ca6779e9236", "patch": "@@ -31,9 +31,6 @@\n    UNSPEC_TO_SHARED\n    UNSPEC_TO_CONST\n \n-   UNSPEC_CPLX_LOWPART\n-   UNSPEC_CPLX_HIGHPART\n-\n    UNSPEC_COPYSIGN\n    UNSPEC_LOG2\n    UNSPEC_EXP2\n@@ -258,74 +255,31 @@\n    %.\\\\tsetp.eq.u32\\\\t%0, 1, 1;\")\n \n (define_insn \"*mov<mode>_insn\"\n-  [(set (match_operand:QHSDIM 0 \"nvptx_nonimmediate_operand\" \"=R,R,R,m\")\n-\t(match_operand:QHSDIM 1 \"general_operand\" \"n,Ri,m,R\"))]\n-  \"!(MEM_P (operands[0])\n-     && (!REG_P (operands[1]) || REGNO (operands[1]) <= LAST_VIRTUAL_REGISTER))\"\n+  [(set (match_operand:QHSDIM 0 \"nvptx_nonimmediate_operand\" \"=R,R,m\")\n+\t(match_operand:QHSDIM 1 \"general_operand\" \"Ri,m,R\"))]\n+  \"!MEM_P (operands[0])\n+   || (REG_P (operands[1]) && REGNO (operands[1]) > LAST_VIRTUAL_REGISTER)\"\n {\n-  if (which_alternative == 2)\n+  if (which_alternative == 1)\n     return \"%.\\\\tld%A1%u1\\\\t%0, %1;\";\n-  if (which_alternative == 3)\n+  if (which_alternative == 2)\n     return \"%.\\\\tst%A0%u0\\\\t%0, %1;\";\n \n-  rtx dst = operands[0];\n-  rtx src = operands[1];\n-\n-  enum machine_mode dst_mode = nvptx_underlying_object_mode (dst);\n-  enum machine_mode src_mode = nvptx_underlying_object_mode (src);\n-  if (GET_CODE (dst) == SUBREG)\n-    dst = SUBREG_REG (dst);\n-  if (GET_CODE (src) == SUBREG)\n-    src = SUBREG_REG (src);\n-  if (src_mode == QImode)\n-    src_mode = SImode;\n-  if (dst_mode == QImode)\n-    dst_mode = SImode;\n-  if (CONSTANT_P (src))\n-    {\n-      if (GET_MODE_CLASS (dst_mode) != MODE_INT)\n-        return \"%.\\\\tmov.b%T0\\\\t%0, %1;\";\n-      else\n-        return \"%.\\\\tmov%t0\\\\t%0, %1;\";\n-    }\n-\n-  /* Special handling for the return register; we allow this register to\n-     only occur in the destination of a move insn.  */\n-  if (REG_P (dst) && REGNO (dst) == NVPTX_RETURN_REGNUM\n-      && dst_mode == HImode)\n-    dst_mode = SImode;\n-  if (dst_mode == src_mode)\n-    return \"%.\\\\tmov%t0\\\\t%0, %1;\";\n-  /* Mode-punning between floating point and integer.  */\n-  if (GET_MODE_SIZE (dst_mode) == GET_MODE_SIZE (src_mode))\n-    return \"%.\\\\tmov.b%T0\\\\t%0, %1;\";\n-  return \"%.\\\\tcvt%t0%t1\\\\t%0, %1;\";\n+  return nvptx_output_mov_insn (operands[0], operands[1]);\n }\n   [(set_attr \"subregs_ok\" \"true\")])\n \n (define_insn \"*mov<mode>_insn\"\n   [(set (match_operand:SDFM 0 \"nvptx_nonimmediate_operand\" \"=R,R,m\")\n \t(match_operand:SDFM 1 \"general_operand\" \"RF,m,R\"))]\n-  \"!(MEM_P (operands[0]) && !REG_P (operands[1]))\"\n+  \"!MEM_P (operands[0]) || REG_P (operands[1])\"\n {\n   if (which_alternative == 1)\n     return \"%.\\\\tld%A1%u0\\\\t%0, %1;\";\n   if (which_alternative == 2)\n     return \"%.\\\\tst%A0%u1\\\\t%0, %1;\";\n \n-  rtx dst = operands[0];\n-  rtx src = operands[1];\n-  if (GET_CODE (dst) == SUBREG)\n-    dst = SUBREG_REG (dst);\n-  if (GET_CODE (src) == SUBREG)\n-    src = SUBREG_REG (src);\n-  enum machine_mode dst_mode = GET_MODE (dst);\n-  enum machine_mode src_mode = GET_MODE (src);\n-  if (dst_mode == src_mode)\n-    return \"%.\\\\tmov%t0\\\\t%0, %1;\";\n-  if (GET_MODE_SIZE (dst_mode) == GET_MODE_SIZE (src_mode))\n-    return \"%.\\\\tmov.b%T0\\\\t%0, %1;\";\n-  gcc_unreachable ();\n+  return nvptx_output_mov_insn (operands[0], operands[1]);\n }\n   [(set_attr \"subregs_ok\" \"true\")])\n \n@@ -373,116 +327,6 @@\n     }\n })\n \n-(define_insn \"highpartscsf2\"\n-  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n-\t(unspec:SF [(match_operand:SC 1 \"nvptx_register_operand\")]\n-\t\t   UNSPEC_CPLX_HIGHPART))]\n-  \"\"\n-  \"%.\\\\tmov%t0\\\\t%0, %f1$1;\")\n-\n-(define_insn \"set_highpartsfsc2\"\n-  [(set (match_operand:SC 0 \"nvptx_register_operand\" \"+R\")\n-\t(unspec:SC [(match_dup 0)\n-\t\t    (match_operand:SF 1 \"nvptx_register_operand\")]\n-\t\t   UNSPEC_CPLX_HIGHPART))]\n-  \"\"\n-  \"%.\\\\tmov%t1\\\\t%f0$1, %1;\")\n-\n-(define_insn \"lowpartscsf2\"\n-  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n-\t(unspec:SF [(match_operand:SC 1 \"nvptx_register_operand\")]\n-\t\t   UNSPEC_CPLX_LOWPART))]\n-  \"\"\n-  \"%.\\\\tmov%t0\\\\t%0, %f1$0;\")\n-\n-(define_insn \"set_lowpartsfsc2\"\n-  [(set (match_operand:SC 0 \"nvptx_register_operand\" \"+R\")\n-\t(unspec:SC [(match_dup 0)\n-\t\t    (match_operand:SF 1 \"nvptx_register_operand\")]\n-\t\t   UNSPEC_CPLX_LOWPART))]\n-  \"\"\n-  \"%.\\\\tmov%t1\\\\t%f0$0, %1;\")\n-\n-(define_expand \"mov<mode>\"\n-  [(set (match_operand:SDCM 0 \"nvptx_nonimmediate_operand\" \"\")\n-\t(match_operand:SDCM 1 \"general_operand\" \"\"))]\n-  \"\"\n-{\n-  enum machine_mode submode = <MODE>mode == SCmode ? SFmode : DFmode;\n-  int sz = GET_MODE_SIZE (submode);\n-  rtx xops[4];\n-  rtx punning_reg = NULL_RTX;\n-  rtx copyback = NULL_RTX;\n-\n-  if (GET_CODE (operands[0]) == SUBREG)\n-    {\n-      rtx inner = SUBREG_REG (operands[0]);\n-      enum machine_mode inner_mode = GET_MODE (inner);\n-      int sz2 = GET_MODE_SIZE (inner_mode);\n-      gcc_assert (sz2 >= sz);\n-      cfun->machine->punning_buffer_size\n-        = MAX (cfun->machine->punning_buffer_size, sz2);\n-      if (punning_reg == NULL_RTX)\n-\tpunning_reg = gen_rtx_REG (Pmode, NVPTX_PUNNING_BUFFER_REGNUM);\n-      copyback = gen_move_insn (inner, gen_rtx_MEM (inner_mode, punning_reg));\n-      operands[0] = gen_rtx_MEM (<MODE>mode, punning_reg);\n-    }\n-  if (GET_CODE (operands[1]) == SUBREG)\n-    {\n-      rtx inner = SUBREG_REG (operands[1]);\n-      enum machine_mode inner_mode = GET_MODE (inner);\n-      int sz2 = GET_MODE_SIZE (inner_mode);\n-      gcc_assert (sz2 >= sz);\n-      cfun->machine->punning_buffer_size\n-        = MAX (cfun->machine->punning_buffer_size, sz2);\n-      if (punning_reg == NULL_RTX)\n-\tpunning_reg = gen_rtx_REG (Pmode, NVPTX_PUNNING_BUFFER_REGNUM);\n-      emit_move_insn (gen_rtx_MEM (inner_mode, punning_reg), inner);\n-      operands[1] = gen_rtx_MEM (<MODE>mode, punning_reg);\n-    }\n-\n-  if (REG_P (operands[0]) && submode == SFmode)\n-    {\n-      xops[0] = gen_reg_rtx (submode);\n-      xops[1] = gen_reg_rtx (submode);\n-    }\n-  else\n-    {\n-      xops[0] = gen_lowpart (submode, operands[0]);\n-      if (MEM_P (operands[0]))\n-\txops[1] = adjust_address_nv (operands[0], submode, sz);\n-      else\n-\txops[1] = gen_highpart (submode, operands[0]);\n-    }\n-\n-  if (REG_P (operands[1]) && submode == SFmode)\n-    {\n-      xops[2] = gen_reg_rtx (submode);\n-      xops[3] = gen_reg_rtx (submode);\n-      emit_insn (gen_lowpartscsf2 (xops[2], operands[1]));\n-      emit_insn (gen_highpartscsf2 (xops[3], operands[1]));\n-    }\n-  else\n-    {\n-      xops[2] = gen_lowpart (submode, operands[1]);\n-      if (MEM_P (operands[1]))\n-\txops[3] = adjust_address_nv (operands[1], submode, sz);\n-      else\n-\txops[3] = gen_highpart (submode, operands[1]);\n-    }\n-\n-  emit_move_insn (xops[0], xops[2]);\n-  emit_move_insn (xops[1], xops[3]);\n-  if (REG_P (operands[0]) && submode == SFmode)\n-    {\n-      emit_insn (gen_set_lowpartsfsc2 (operands[0], xops[0]));\n-      emit_insn (gen_set_highpartsfsc2 (operands[0], xops[1]));\n-    }\n-  if (copyback)\n-    emit_insn (copyback);\n-  DONE;\n-})\n-\n (define_insn \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"nvptx_register_operand\" \"=R,R\")\n \t(zero_extend:HI (match_operand:QI 1 \"nvptx_reg_or_mem_operand\" \"R,m\")))]"}]}