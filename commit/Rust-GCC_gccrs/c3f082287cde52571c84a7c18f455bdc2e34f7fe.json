{"sha": "c3f082287cde52571c84a7c18f455bdc2e34f7fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNmMDgyMjg3Y2RlNTI1NzFjODRhN2MxOGY0NTViZGMyZTM0ZjdmZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-03-05T10:22:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-03-05T10:22:16Z"}, "message": "call.c (convert_like): Macrofy.\n\n\t* call.c (convert_like): Macrofy.\n\t(convert_like_with_context): New macro.\n\t(convert_like_real): Renamed from convert_like.  Add calling\n\tcontext parameters, for diagnostics. Add recursive flag.  Call\n\tdubious_conversion_warnings for outer conversion.\n\t(build_user_type_conversion): Use convert_like_with_context.\n\t(build_over_call): Likewise. Don't warn about dubious\n\tconversions here. Adjust convert_default_arg calls.\n\t(convert_default_arg): Add context parameters for diagnostics.\n\tPass throught to convert_like_with_context.\n\t* cp-tree.h (convert_default_arg): Add context parameters.\n\t(dubious_conversion_warnings): Prototype new function.\n\t* typeck.c (convert_arguments): Adjust convert_default_arg call.\n\t(dubious_conversion_warnings): New function, broken\n\tout of convert_for_assignment.\n\t(convert_for_assignment): Adjust.\n\nFrom-SVN: r32341", "tree": {"sha": "5ff56b9f3a4de9b423c89fa746c6586c5497c90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ff56b9f3a4de9b423c89fa746c6586c5497c90e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3f082287cde52571c84a7c18f455bdc2e34f7fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f082287cde52571c84a7c18f455bdc2e34f7fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f082287cde52571c84a7c18f455bdc2e34f7fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f082287cde52571c84a7c18f455bdc2e34f7fe/comments", "author": null, "committer": null, "parents": [{"sha": "18ca9ce7234bb110f3a8aaaae334955cf49d17e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ca9ce7234bb110f3a8aaaae334955cf49d17e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18ca9ce7234bb110f3a8aaaae334955cf49d17e5"}], "stats": {"total": 170, "additions": 111, "deletions": 59}, "files": [{"sha": "2213278eb88cc6a5068fcdea06ccbabedc55a3cd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c3f082287cde52571c84a7c18f455bdc2e34f7fe", "patch": "@@ -1,3 +1,22 @@\n+2000-03-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (convert_like): Macrofy.\n+\t(convert_like_with_context): New macro.\n+\t(convert_like_real): Renamed from convert_like.  Add calling\n+\tcontext parameters, for diagnostics. Add recursive flag.  Call \n+\tdubious_conversion_warnings for outer conversion.\n+\t(build_user_type_conversion): Use convert_like_with_context.\n+\t(build_over_call): Likewise. Don't warn about dubious\n+\tconversions here. Adjust convert_default_arg calls.\n+\t(convert_default_arg): Add context parameters for diagnostics.\n+\tPass throught to convert_like_with_context.\n+\t* cp-tree.h (convert_default_arg): Add context parameters.\n+\t(dubious_conversion_warnings): Prototype new function.\n+\t* typeck.c (convert_arguments): Adjust convert_default_arg call.\n+\t(dubious_conversion_warnings): New function, broken\n+\tout of convert_for_assignment. \n+\t(convert_for_assignment): Adjust.\n+\n 2000-03-03  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* decl2.c (key_method): Break out from..."}, {"sha": "0589cfdcc9f1d5b482df836ab8fadb8ab5c1f899", "filename": "gcc/cp/call.c", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c3f082287cde52571c84a7c18f455bdc2e34f7fe", "patch": "@@ -49,7 +49,9 @@ static int equal_functions PARAMS ((tree, tree));\n static int joust PARAMS ((struct z_candidate *, struct z_candidate *, int));\n static int compare_ics PARAMS ((tree, tree));\n static tree build_over_call PARAMS ((struct z_candidate *, tree, int));\n-static tree convert_like PARAMS ((tree, tree));\n+#define convert_like(CONV, EXPR) convert_like_real (CONV, EXPR, NULL_TREE, 0, 0)\n+#define convert_like_with_context(CONV, EXPR, FN, ARGNO) convert_like_real (CONV, EXPR, FN, ARGNO, 0)\n+static tree convert_like_real PARAMS ((tree, tree, tree, int, int));\n static void op_error PARAMS ((enum tree_code, enum tree_code, tree, tree,\n \t\t\t    tree, const char *));\n static tree build_object_call PARAMS ((tree, tree));\n@@ -2450,7 +2452,9 @@ build_user_type_conversion (totype, expr, flags)\n     {\n       if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n \treturn error_mark_node;\n-      return convert_from_reference (convert_like (cand->second_conv, expr));\n+      return convert_from_reference\n+              (convert_like_with_context\n+                (cand->second_conv, expr, cand->fn, 0));\n     }\n   return NULL_TREE;\n }\n@@ -2654,7 +2658,8 @@ build_object_call (obj, args)\n       && DECL_NAME (cand->fn) == ansi_opname [CALL_EXPR])\n     return build_over_call (cand, mem_args, LOOKUP_NORMAL);\n \n-  obj = convert_like (TREE_VEC_ELT (cand->convs, 0), obj);\n+  obj = convert_like_with_context\n+          (TREE_VEC_ELT (cand->convs, 0), obj, cand->fn, -1);\n \n   /* FIXME */\n   return build_function_call (obj, args);\n@@ -3593,11 +3598,17 @@ enforce_access (basetype_path, decl)\n   return 1;\n }\n \n-/* Perform the conversions in CONVS on the expression EXPR.  */\n+/* Perform the conversions in CONVS on the expression EXPR. \n+   FN and ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n+   indicates the `this' argument of a method.  INNER is non-zero when\n+   being called to continue a conversion chain. */\n \n static tree\n-convert_like (convs, expr)\n+convert_like_real (convs, expr, fn, argnum, inner)\n      tree convs, expr;\n+     tree fn;\n+     int argnum;\n+     int inner;\n {\n   if (ICS_BAD_FLAG (convs)\n       && TREE_CODE (convs) != USER_CONV\n@@ -3609,19 +3620,22 @@ convert_like (convs, expr)\n \t{\n \t  if (TREE_CODE (t) == USER_CONV)\n \t    {\n-\t      expr = convert_like (t, expr);\n+\t      expr = convert_like_real (t, expr, fn, argnum, 1);\n \t      break;\n \t    }\n \t  else if (TREE_CODE (t) == AMBIG_CONV)\n-\t    return convert_like (t, expr);\n+\t    return convert_like_real (t, expr, fn, argnum, 1);\n \t  else if (TREE_CODE (t) == IDENTITY_CONV)\n \t    break;\n \t}\n       return convert_for_initialization\n \t(NULL_TREE, TREE_TYPE (convs), expr, LOOKUP_NORMAL,\n-\t \"conversion\", NULL_TREE, 0);\n+\t \"conversion\", fn, argnum);\n     }\n-\n+  \n+  if (!inner)\n+    expr = dubious_conversion_warnings\n+             (TREE_TYPE (convs), expr, \"argument\", fn, argnum);\n   switch (TREE_CODE (convs))\n     {\n     case USER_CONV:\n@@ -3665,7 +3679,7 @@ convert_like (convs, expr)\n       break;\n     };\n \n-  expr = convert_like (TREE_OPERAND (convs, 0), expr);\n+  expr = convert_like_real (TREE_OPERAND (convs, 0), expr, fn, argnum, 1);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n@@ -3840,10 +3854,11 @@ convert_type_from_ellipsis (type)\n    conversions.  Return the converted value.  */\n \n tree\n-convert_default_arg (type, arg, fn)\n+convert_default_arg (type, arg, fn, parmnum)\n      tree type;\n      tree arg;\n      tree fn;\n+     int parmnum;\n {\n   if (fn && DECL_TEMPLATE_INFO (fn))\n     arg = tsubst_default_argument (fn, type, arg);\n@@ -3854,7 +3869,7 @@ convert_default_arg (type, arg, fn)\n     {\n       arg = digest_init (type, arg, 0);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", 0, 0);\n+\t\t\t\t\t\"default argument\", fn, parmnum);\n     }\n   else\n     {\n@@ -3863,7 +3878,7 @@ convert_default_arg (type, arg, fn)\n \targ = copy_node (arg);\n \n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", 0, 0);\n+\t\t\t\t\t\"default argument\", fn, parmnum);\n       if (PROMOTE_PROTOTYPES\n \t  && (TREE_CODE (type) == INTEGER_TYPE\n \t      || TREE_CODE (type) == ENUMERAL_TYPE)\n@@ -3956,24 +3971,21 @@ build_over_call (cand, args, flags)\n \t      if (TREE_CODE (t) == USER_CONV\n \t\t  || TREE_CODE (t) == AMBIG_CONV)\n \t\t{\n-\t\t  val = convert_like (t, val);\n+\t\t  val = convert_like_with_context (t, val, fn, i - is_method);\n \t\t  break;\n \t\t}\n \t      else if (TREE_CODE (t) == IDENTITY_CONV)\n \t\tbreak;\n \t    }\n \t  val = convert_for_initialization\n \t    (NULL_TREE, type, val, LOOKUP_NORMAL,\n-\t     \"argument passing\", fn, i - is_method);\n+\t     \"argument\", fn, i - is_method);\n \t}\n       else\n \t{\n-\t  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n-\t  if (ARITHMETIC_TYPE_P (TREE_VALUE (parm))\n-\t      && TREE_VALUE (arg) == null_node)\n-\t    cp_warning (\"converting NULL to non-pointer type\");\n-\t    \n-\t  val = convert_like (conv, TREE_VALUE (arg));\n+\t  val = TREE_VALUE (arg);\n+\t  val = convert_like_with_context\n+\t          (conv, TREE_VALUE (arg), fn, i - is_method);\n \t}\n \n       if (PROMOTE_PROTOTYPES\n@@ -3985,12 +3997,12 @@ build_over_call (cand, args, flags)\n     }\n \n   /* Default arguments */\n-  for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n+  for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm), i++)\n     converted_args \n       = tree_cons (NULL_TREE, \n \t\t   convert_default_arg (TREE_VALUE (parm), \n \t\t\t\t\tTREE_PURPOSE (parm),\n-\t\t\t\t\tfn),\n+\t\t\t\t\tfn, i - is_method),\n \t\t   converted_args);\n \n   /* Ellipsis */"}, {"sha": "9086292aa4ae1cc2d1f0d102fdd3d9c8d15d84aa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c3f082287cde52571c84a7c18f455bdc2e34f7fe", "patch": "@@ -3616,7 +3616,7 @@ extern tree build_op_delete_call\t\tPARAMS ((enum tree_code, tree, tree, int, tree\n extern int can_convert\t\t\t\tPARAMS ((tree, tree));\n extern int can_convert_arg\t\t\tPARAMS ((tree, tree, tree));\n extern int enforce_access                       PARAMS ((tree, tree));\n-extern tree convert_default_arg                 PARAMS ((tree, tree, tree));\n+extern tree convert_default_arg                 PARAMS ((tree, tree, tree, int));\n extern tree convert_arg_to_ellipsis             PARAMS ((tree));\n extern tree build_x_va_arg                      PARAMS ((tree, tree));\n extern tree convert_type_from_ellipsis          PARAMS ((tree));\n@@ -4407,6 +4407,7 @@ extern tree build_const_cast\t\t\tPARAMS ((tree, tree));\n extern tree build_c_cast\t\t\tPARAMS ((tree, tree));\n extern tree build_x_modify_expr\t\t\tPARAMS ((tree, enum tree_code, tree));\n extern tree build_modify_expr\t\t\tPARAMS ((tree, enum tree_code, tree));\n+extern tree dubious_conversion_warnings         PARAMS ((tree, tree, const char *, tree, int));\n extern tree convert_for_initialization\t\tPARAMS ((tree, tree, tree, int, const char *, tree, int));\n extern void c_expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int, char *, int));\n extern void c_expand_return\t\t\tPARAMS ((tree));"}, {"sha": "219ca3984f3e765fa703929f2b460402e91e5fbc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f082287cde52571c84a7c18f455bdc2e34f7fe/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c3f082287cde52571c84a7c18f455bdc2e34f7fe", "patch": "@@ -3215,7 +3215,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \t      tree parmval \n \t\t= convert_default_arg (TREE_VALUE (typetail), \n \t\t\t\t       TREE_PURPOSE (typetail), \n-\t\t\t\t       fndecl);\n+\t\t\t\t       fndecl, i);\n \n \t      if (parmval == error_mark_node)\n \t\treturn error_mark_node;\n@@ -6421,6 +6421,59 @@ pfn_from_ptrmemfunc (t)\n \t     pfn_identifier, NULL_TREE, 0)); \n }\n \n+/* Expression EXPR is about to be implicitly converted to TYPE.  Warn\n+   if this is a potentially dangerous thing to do.  Returns a possibly\n+   marked EXPR.  */\n+\n+tree\n+dubious_conversion_warnings (type, expr, errtype, fndecl, parmnum)\n+     tree type;\n+     tree expr;\n+     const char *errtype;\n+     tree fndecl;\n+     int parmnum;\n+{\n+  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+  if (ARITHMETIC_TYPE_P (type) && expr == null_node)\n+    {\n+      if (fndecl)\n+        cp_warning (\"passing NULL used for non-pointer %s %P of `%D'\",\n+                    errtype, parmnum, fndecl);\n+      else\n+        cp_warning (\"%s to non-pointer type `%T' from NULL\", errtype, type);\n+    }\n+  \n+  /* Warn about assigning a floating-point type to an integer type.  */\n+  if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+      && TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      if (fndecl)\n+\tcp_warning (\"passing `%T' for %s %P of `%D'\",\n+\t\t    TREE_TYPE (expr), errtype, parmnum, fndecl);\n+      else\n+\tcp_warning (\"%s to `%T' from `%T'\", errtype, type, TREE_TYPE (expr));\n+    }\n+  /* And warn about assigning a negative value to an unsigned\n+     variable.  */\n+  else if (TREE_UNSIGNED (type) && TREE_CODE (type) != BOOLEAN_TYPE)\n+    {\n+      if (TREE_CODE (expr) == INTEGER_CST\n+\t  && TREE_NEGATED_INT (expr))\n+\t{\n+\t  if (fndecl)\n+\t    cp_warning (\"passing negative value `%E' for %s %P of `%D'\",\n+\t\t\texpr, errtype, parmnum, fndecl);\n+\t  else\n+\t    cp_warning (\"%s of negative value `%E' to `%T'\",\n+\t\t\terrtype, expr, type);\n+\t}\n+      overflow_warning (expr);\n+      if (TREE_CONSTANT (expr))\n+\texpr = fold (expr);\n+    }\n+  return expr;\n+}\n+\n /* Convert value RHS to type TYPE as preparation for an assignment to\n    an lvalue of type TYPE.  ERRTYPE is a string to use in error\n    messages: \"assignment\", \"return\", etc.  If FNDECL is non-NULL, we\n@@ -6456,12 +6509,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   if (TREE_CODE (rhs) == TREE_LIST && TREE_VALUE (rhs) == error_mark_node)\n     return error_mark_node;\n \n-  /* Issue warnings about peculiar, but legal, uses of NULL.  We\n-     do this *before* the call to decl_constant_value so as to\n-     avoid duplicate warnings on code like `const int I = NULL;\n-     f(I);'.  */\n-  if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n-    cp_warning (\"converting NULL to non-pointer type\");\n+  rhs = dubious_conversion_warnings (type, rhs, errtype, fndecl, parmnum);\n \n   /* The RHS of an assignment cannot have void type.  */\n   if (coder == VOID_TYPE)\n@@ -6476,34 +6524,6 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   else if (TREE_READONLY_DECL_P (rhs))\n     rhs = decl_constant_value (rhs);\n \n-  /* Warn about assigning a floating-point type to an integer type.  */\n-  if (coder == REAL_TYPE && codel == INTEGER_TYPE)\n-    {\n-      if (fndecl)\n-\tcp_warning (\"`%T' used for argument %P of `%D'\",\n-\t\t    rhstype, parmnum, fndecl);\n-      else\n-\tcp_warning (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n-    }\n-  /* And warn about assigning a negative value to an unsigned\n-     variable.  */\n-  else if (TREE_UNSIGNED (type) && codel != BOOLEAN_TYPE)\n-    {\n-      if (TREE_CODE (rhs) == INTEGER_CST\n-\t  && TREE_NEGATED_INT (rhs))\n-\t{\n-\t  if (fndecl)\n-\t    cp_warning (\"negative value `%E' passed as argument %P of `%D'\",\n-\t\t\trhs, parmnum, fndecl);\n-\t  else\n-\t    cp_warning (\"%s of negative value `%E' to `%T'\",\n-\t\t\terrtype, rhs, type);\n-\t}\n-      overflow_warning (rhs);\n-      if (TREE_CONSTANT (rhs))\n-\trhs = fold (rhs);\n-    }\n-\n   /* [expr.ass]\n \n      The expression is implicitly converted (clause _conv_) to the"}]}