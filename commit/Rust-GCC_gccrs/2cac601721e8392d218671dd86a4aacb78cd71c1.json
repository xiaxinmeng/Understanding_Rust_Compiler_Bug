{"sha": "2cac601721e8392d218671dd86a4aacb78cd71c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNhYzYwMTcyMWU4MzkyZDIxODY3MWRkODZhNGFhY2I3OGNkNzFjMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-09-29T11:13:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-09-29T11:13:29Z"}, "message": "decl.c (gnat_to_gnu_entity): Factor out common code processing the component type into...\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Factor out\n\tcommon code processing the component type into...\n\t<E_Array_Subtype>: Likewise.\n\t(gnat_to_gnu_component_type): ...this new static function.\n\t(maybe_pad_type): Minor cleanup.\n\nFrom-SVN: r152273", "tree": {"sha": "eb7c1207865071fcf83aa222a4d9c07827f8882c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb7c1207865071fcf83aa222a4d9c07827f8882c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cac601721e8392d218671dd86a4aacb78cd71c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cac601721e8392d218671dd86a4aacb78cd71c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cac601721e8392d218671dd86a4aacb78cd71c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cac601721e8392d218671dd86a4aacb78cd71c1/comments", "author": null, "committer": null, "parents": [{"sha": "95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c1c4bb9ae848b5b801dace9f32c8460430aaa8"}], "stats": {"total": 260, "additions": 108, "deletions": 152}, "files": [{"sha": "f0577bd9e26aca8a4fc02eb92a050302258e80bc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cac601721e8392d218671dd86a4aacb78cd71c1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cac601721e8392d218671dd86a4aacb78cd71c1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2cac601721e8392d218671dd86a4aacb78cd71c1", "patch": "@@ -1,7 +1,15 @@\n 2009-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n-\t* decl.c (gnat_to_gnu_entity) <E_Record_Subtype>: Rewrite the handling\n-\tof constrained discriminated record subtypes.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Factor out\n+\tcommon code processing the component type into...\n+\t<E_Array_Subtype>: Likewise.\n+\t(gnat_to_gnu_component_type): ...this new static function.\n+\t(maybe_pad_type): Minor cleanup.\n+\n+2009-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Subtype>: Rewrite\n+\tthe handling of constrained discriminated record subtypes.\n \t(components_to_record): Declare the type of the variants and of the\n \tqualified union.\n \t(build_subst_list): Move around."}, {"sha": "3fb7c807614f9533de46a97c9776fb055269077d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 98, "deletions": 150, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cac601721e8392d218671dd86a4aacb78cd71c1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cac601721e8392d218671dd86a4aacb78cd71c1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=2cac601721e8392d218671dd86a4aacb78cd71c1", "patch": "@@ -130,9 +130,10 @@ static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n static bool is_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, tree, bool, bool);\n static tree make_packable_type (tree, bool);\n-static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);\n+static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n+static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (Entity_Id, tree);\n static bool compile_time_known_address_p (Node_Id);\n@@ -1799,8 +1800,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_fat_type = make_node (RECORD_TYPE);\n \ttree *gnu_index_types = (tree *) alloca (ndim * sizeof (tree));\n \ttree *gnu_temp_fields = (tree *) alloca (ndim * sizeof (tree));\n-\ttree gnu_max_size = size_one_node, gnu_max_size_unit;\n-\ttree gnu_comp_size, tem;\n+\ttree gnu_max_size = size_one_node, gnu_max_size_unit, tem;\n \tint index;\n \n \tTYPE_NAME (gnu_template_type)\n@@ -1946,73 +1946,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Now make the array of arrays and update the pointer to the array\n \t   in the fat pointer.  Note that it is the first field.  */\n-\ttem = gnat_to_gnu_type (Component_Type (gnat_entity));\n-\n-\t/* Try to get a smaller form of the component if needed.  */\n-\tif ((Is_Packed (gnat_entity)\n-\t     || Has_Component_Size_Clause (gnat_entity))\n-\t    && !Is_Bit_Packed_Array (gnat_entity)\n-\t    && !Has_Aliased_Components (gnat_entity)\n-\t    && !Strict_Alignment (Component_Type (gnat_entity))\n-\t    && TREE_CODE (tem) == RECORD_TYPE\n-\t    && !TYPE_IS_FAT_POINTER_P (tem)\n-\t    && host_integerp (TYPE_SIZE (tem), 1))\n-\t  tem = make_packable_type (tem, false);\n-\n-\tif (Has_Atomic_Components (gnat_entity))\n-\t  check_ok_for_atomic (tem, gnat_entity, true);\n-\n-\t/* Get and validate any specified Component_Size, but if Packed,\n-\t   ignore it since the front end will have taken care of it.  */\n-\tgnu_comp_size\n-\t  = validate_size (Component_Size (gnat_entity), tem,\n-\t\t\t   gnat_entity,\n-\t\t\t   (Is_Bit_Packed_Array (gnat_entity)\n-\t\t\t    ? TYPE_DECL : VAR_DECL),\n-\t\t\t   true, Has_Component_Size_Clause (gnat_entity));\n-\n-\t/* If the component type is a RECORD_TYPE that has a self-referential\n-\t   size, use the maximum size.  */\n-\tif (!gnu_comp_size\n-\t    && TREE_CODE (tem) == RECORD_TYPE\n-\t    && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (tem)))\n-\t  gnu_comp_size = max_size (TYPE_SIZE (tem), true);\n-\n-\tif (gnu_comp_size && !Is_Bit_Packed_Array (gnat_entity))\n-\t  {\n-\t    tree orig_tem = tem;\n-\t    unsigned int max_align;\n-\n-\t    /* If an alignment is specified, use it as a cap on the component\n-\t       type so that it can be honored for the whole type.  But ignore\n-\t       it for the original type of packed array types.  */\n-\t    if (No (Packed_Array_Type (gnat_entity))\n-\t\t&& Known_Alignment (gnat_entity))\n-\t      max_align = validate_alignment (Alignment (gnat_entity),\n-\t\t\t\t\t      gnat_entity, 0);\n-\t    else\n-\t      max_align = 0;\n-\n-\t    tem = make_type_from_size (tem, gnu_comp_size, false);\n-\t    if (max_align > 0 && TYPE_ALIGN (tem) > max_align)\n-\t      tem = orig_tem;\n-\t    else\n-\t      orig_tem = tem;\n-\n-\t    tem = maybe_pad_type (tem, gnu_comp_size, 0, gnat_entity,\n-\t\t\t\t  \"C_PAD\", false, definition, true);\n-\n-\t    /* If a padding record was made, declare it now since it will\n-\t       never be declared otherwise.  This is necessary to ensure\n-\t       that its subtrees are properly marked.  */\n-\t    if (tem != orig_tem && !DECL_P (TYPE_NAME (tem)))\n-\t      create_type_decl (TYPE_NAME (tem), tem, NULL, true,\n-\t\t\t\tdebug_info_p, gnat_entity);\n-\t  }\n-\n-\tif (Has_Volatile_Components (gnat_entity))\n-\t  tem = build_qualified_type (tem,\n-\t\t\t\t      TYPE_QUALS (tem) | TYPE_QUAL_VOLATILE);\n+        tem = gnat_to_gnu_component_type (gnat_entity, definition,\n+\t\t\t\t\t  debug_info_p);\n \n \t/* If Component_Size is not already specified, annotate it with the\n \t   size of the component.  */\n@@ -2356,9 +2291,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \t  else\n \t    {\n-\t      tree gnu_comp_size;\n-\n-\t      gnu_type = gnat_to_gnu_type (Component_Type (gnat_entity));\n+\t      gnu_type = gnat_to_gnu_component_type (gnat_entity, definition,\n+\t\t\t\t\t\t     debug_info_p);\n \n \t      /* One of the above calls might have caused us to be elaborated,\n \t\t so don't blow up if so.  */\n@@ -2367,73 +2301,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  maybe_present = true;\n \t\t  break;\n \t\t}\n-\n-\t      /* Try to get a smaller form of the component if needed.  */\n-\t      if ((Is_Packed (gnat_entity)\n-\t\t   || Has_Component_Size_Clause (gnat_entity))\n-\t\t  && !Is_Bit_Packed_Array (gnat_entity)\n-\t\t  && !Has_Aliased_Components (gnat_entity)\n-\t\t  && !Strict_Alignment (Component_Type (gnat_entity))\n-\t\t  && TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t  && !TYPE_IS_FAT_POINTER_P (gnu_type)\n-\t\t  && host_integerp (TYPE_SIZE (gnu_type), 1))\n-\t\tgnu_type = make_packable_type (gnu_type, false);\n-\n-\t      /* Get and validate any specified Component_Size, but if Packed,\n-\t\t ignore it since the front end will have taken care of it.  */\n-\t      gnu_comp_size\n-\t\t= validate_size (Component_Size (gnat_entity), gnu_type,\n-\t\t\t\t gnat_entity,\n-\t\t\t\t (Is_Bit_Packed_Array (gnat_entity)\n-\t\t\t\t  ? TYPE_DECL : VAR_DECL), true,\n-\t\t\t\t Has_Component_Size_Clause (gnat_entity));\n-\n-\t      /* If the component type is a RECORD_TYPE that has a\n-\t\t self-referential size, use the maximum size.  */\n-\t      if (!gnu_comp_size\n-\t\t  && TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t  && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n-\t\tgnu_comp_size = max_size (TYPE_SIZE (gnu_type), true);\n-\n-\t      if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_entity))\n-\t\t{\n-\t\t  tree orig_type = gnu_type;\n-\t\t  unsigned int max_align;\n-\n-\t\t  /* If an alignment is specified, use it as a cap on the\n-\t\t     component type so that it can be honored for the whole\n-\t\t     type.  But ignore it for the original type of packed\n-\t\t     array types.  */\n-\t\t  if (No (Packed_Array_Type (gnat_entity))\n-\t\t      && Known_Alignment (gnat_entity))\n-\t\t    max_align = validate_alignment (Alignment (gnat_entity),\n-\t\t\t\t\t\t    gnat_entity, 0);\n-\t\t  else\n-\t\t    max_align = 0;\n-\n-\t\t  gnu_type\n-\t\t    = make_type_from_size (gnu_type, gnu_comp_size, false);\n-\t\t  if (max_align > 0 && TYPE_ALIGN (gnu_type) > max_align)\n-\t\t    gnu_type = orig_type;\n-\t\t  else\n-\t\t    orig_type = gnu_type;\n-\n-\t\t  gnu_type = maybe_pad_type (gnu_type, gnu_comp_size, 0,\n-\t\t\t\t\t     gnat_entity, \"C_PAD\", false,\n-\t\t\t\t\t     definition, true);\n-\n-\t\t  /* If a padding record was made, declare it now since it\n-\t\t     will never be declared otherwise.  This is necessary\n-\t\t     to ensure that its subtrees are properly marked.  */\n-\t\t  if (gnu_type != orig_type && !DECL_P (TYPE_NAME (gnu_type)))\n-\t\t    create_type_decl (TYPE_NAME (gnu_type), gnu_type, NULL,\n-\t\t\t\t      true, debug_info_p, gnat_entity);\n-\t\t}\n-\n-\t      if (Has_Volatile_Components (Base_Type (gnat_entity)))\n-\t\tgnu_type = build_qualified_type (gnu_type,\n-\t\t\t\t\t\t (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t\t  | TYPE_QUAL_VOLATILE));\n \t    }\n \n \t  /* Compute the maximum size of the array in units and bits.  */\n@@ -5091,6 +4958,84 @@ Gigi_Equivalent_Type (Entity_Id gnat_entity)\n   return gnat_equiv;\n }\n \n+/* Return a GCC tree for a type corresponding to the component type of the\n+   array type or subtype GNAT_ARRAY.  DEFINITION is true if this component\n+   is for an array being defined.  DEBUG_INFO_P is true if we need to write\n+   debug information for other types that we may create in the process.  */\n+\n+static tree\n+gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n+\t\t\t    bool debug_info_p)\n+{\n+  tree gnu_type = gnat_to_gnu_type (Component_Type (gnat_array));\n+  tree gnu_comp_size;\n+\n+  /* Try to get a smaller form of the component if needed.  */\n+  if ((Is_Packed (gnat_array)\n+       || Has_Component_Size_Clause (gnat_array))\n+      && !Is_Bit_Packed_Array (gnat_array)\n+      && !Has_Aliased_Components (gnat_array)\n+      && !Strict_Alignment (Component_Type (gnat_array))\n+      && TREE_CODE (gnu_type) == RECORD_TYPE\n+      && !TYPE_IS_FAT_POINTER_P (gnu_type)\n+      && host_integerp (TYPE_SIZE (gnu_type), 1))\n+    gnu_type = make_packable_type (gnu_type, false);\n+\n+  if (Has_Atomic_Components (gnat_array))\n+    check_ok_for_atomic (gnu_type, gnat_array, true);\n+\n+  /* Get and validate any specified Component_Size.  */\n+  gnu_comp_size\n+    = validate_size (Component_Size (gnat_array), gnu_type, gnat_array,\n+\t\t     Is_Bit_Packed_Array (gnat_array) ? TYPE_DECL : VAR_DECL,\n+\t\t     true, Has_Component_Size_Clause (gnat_array));\n+\n+  /* If the component type is a RECORD_TYPE that has a self-referential size,\n+     then use the maximum size for the component size.  */\n+  if (!gnu_comp_size\n+      && TREE_CODE (gnu_type) == RECORD_TYPE\n+      && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n+    gnu_comp_size = max_size (TYPE_SIZE (gnu_type), true);\n+\n+  /* Honor the component size.  This is not needed for bit-packed arrays.  */\n+  if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_array))\n+    {\n+      tree orig_type = gnu_type;\n+      unsigned int max_align;\n+\n+      /* If an alignment is specified, use it as a cap on the component type\n+\t so that it can be honored for the whole type.  But ignore it for the\n+\t original type of packed array types.  */\n+      if (No (Packed_Array_Type (gnat_array)) && Known_Alignment (gnat_array))\n+\tmax_align = validate_alignment (Alignment (gnat_array), gnat_array, 0);\n+      else\n+\tmax_align = 0;\n+\n+      gnu_type = make_type_from_size (gnu_type, gnu_comp_size, false);\n+      if (max_align > 0 && TYPE_ALIGN (gnu_type) > max_align)\n+\tgnu_type = orig_type;\n+      else\n+\torig_type = gnu_type;\n+\n+      gnu_type = maybe_pad_type (gnu_type, gnu_comp_size, 0, gnat_array,\n+\t\t\t\t \"C_PAD\", false, definition, true);\n+\n+      /* If a padding record was made, declare it now since it will never be\n+\t declared otherwise.  This is necessary to ensure that its subtrees\n+\t are properly marked.  */\n+      if (gnu_type != orig_type && !DECL_P (TYPE_NAME (gnu_type)))\n+\tcreate_type_decl (TYPE_NAME (gnu_type), gnu_type, NULL, true,\n+\t\t\t  debug_info_p, gnat_array);\n+    }\n+\n+  if (Has_Volatile_Components (Base_Type (gnat_array)))\n+    gnu_type\n+      = build_qualified_type (gnu_type,\n+\t\t\t      TYPE_QUALS (gnu_type) | TYPE_QUAL_VOLATILE);\n+\n+  return gnu_type;\n+}\n+\n /* Return a GCC tree for a parameter corresponding to GNAT_PARAM and\n    using MECH as its passing mechanism, to be placed in the parameter\n    list built for GNAT_SUBPROG.  Assume a foreign convention for the\n@@ -6263,7 +6208,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (align)\n     orig_size = round_up (orig_size, align);\n \n-  if (size && Present (gnat_entity)\n+  if (Present (gnat_entity)\n+      && size\n       && !operand_equal_p (size, orig_size, 0)\n       && !(TREE_CODE (size) == INTEGER_CST\n \t   && TREE_CODE (orig_size) == INTEGER_CST\n@@ -6284,15 +6230,17 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n       /* Generate message only for entities that come from source, since\n \t if we have an entity created by expansion, the message will be\n \t generated for some other corresponding source entity.  */\n-      if (Comes_From_Source (gnat_entity) && Present (gnat_error_node))\n-\tpost_error_ne_tree (\"{^ }bits of & unused?\", gnat_error_node,\n-\t\t\t    gnat_entity,\n-\t\t\t    size_diffop (size, orig_size));\n-\n-      else if (*name_trailer == 'C' && !Is_Internal (gnat_entity))\n-\tpost_error_ne_tree (\"component of& padded{ by ^ bits}?\",\n-\t\t\t    gnat_entity, gnat_entity,\n-\t\t\t    size_diffop (size, orig_size));\n+      if (Comes_From_Source (gnat_entity))\n+\t{\n+\t  if (Present (gnat_error_node))\n+\t    post_error_ne_tree (\"{^ }bits of & unused?\",\n+\t\t\t\tgnat_error_node, gnat_entity,\n+\t\t\t\tsize_diffop (size, orig_size));\n+\t  else if (name_trailer[0] == 'C')\n+\t    post_error_ne_tree (\"component of& padded{ by ^ bits}?\",\n+\t\t\t\tgnat_entity, gnat_entity,\n+\t\t\t\tsize_diffop (size, orig_size));\n+\t}\n     }\n \n   return record;"}]}