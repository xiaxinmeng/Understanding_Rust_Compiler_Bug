{"sha": "268987713c7105c691f4efaf82a3f1f4ec394b07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4OTg3NzEzYzcxMDVjNjkxZjRlZmFmODJhM2YxZjRlYzM5NGIwNw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-08-27T17:38:58Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-08-27T17:38:58Z"}, "message": "rtl.texi (simple_return): Document.\n\n\t* doc/rtl.texi (simple_return): Document.\n\t(parallel, PATTERN): Here too.\n\t* doc/md.texi (return): Mention it's allowed to expand to simple_return\n\tin some cases.\n\t(simple_return): Document standard pattern.\n\t* gengenrtl.c (special_rtx): SIMPLE_RETURN is special.\n\t* final.c (final_scan_insn): Use ANY_RETURN_P on body.\n\t* reorg.c (function_return_label, function_simple_return_label):\n\tNew static variables, replacing...\n\t(end_of_function_label): ... this.\n\t(simplejump_or_return_p): New static function.\n\t(optimize_skip, steal_delay_list_from_fallthrough,\n\tfill_slots_from_thread): Use it.\n\t(relax_delay_slots): Likewise.  Use ANY_RETURN_P on body.\n\t(rare_destination, follow_jumps): Use ANY_RETURN_P on body.\n\t(find_end_label): Take a new arg which is one of the two return\n\trtxs.  Depending on which, set either function_return_label or\n\tfunction_simple_return_label.  All callers changed.\n\t(make_return_insns): Make both kinds.\n\t(dbr_schedule): Adjust for two kinds of end labels.\n\t* function.c (emit_return_into_block): Set JUMP_LABEL properly.\n\t* genemit.c (gen_exp): Handle SIMPLE_RETURN.\n\t(gen_expand, gen_split): Use ANY_RETURN_P.\n\t* df-scan.c (df_uses_record): Handle SIMPLE_RETURN.\n\t* rtl.def (SIMPLE_RETURN): New code.\n\t* ifcvt.c (find_if_case_1): Be more careful about\n\tredirecting jumps to the EXIT_BLOCK.\n\t* jump.c (condjump_p, condjump_in_parallel_p, any_condjump_p,\n\treturnjump_p_1): Handle SIMPLE_RETURNs.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* rtl.c (copy_rtx): Likewise.\n\t* bt-load.c (compute_defs_uses_and_gen): Use ANY_RETURN_P.\n\t* combine.c (simplify_set): Likewise.\n\t* resource.c (find_dead_or_set_registers, mark_set_resources):\n\tLikewise.\n\t* emit-rtl.c (verify_rtx_sharing, classify_insn, copy_insn_1,\n\tcopy_rtx_if_shared_1, mark_used_flags): Handle SIMPLE_RETURNs.\n\t(init_emit_regs): Initialize simple_return_rtx.\n\t* cfglayout.c (fixup_reorder_chain): Pass a JUMP_LABEL to\n\tforce_nonfallthru_and_redirect.\n\t* rtl.h (ANY_RETURN_P): Allow SIMPLE_RETURN.\n\t(GR_SIMPLE_RETURN): New enum value.\n\t(simple_return_rtx): New macro.\n\t* basic-block.h (force_nonfallthru_and_redirect): Adjust\n\tdeclaration.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Take a new jump_label\n\targument.  All callers changed.  Be careful about what kinds of\n\treturnjumps to generate.\n\t* config/i386/3i86.c (ix86_pad_returns, ix86_count_insn_bb,\n\tix86_pad_short_function): Likewise.\n\t* config/arm/arm.c (arm_final_prescan_insn): Handle both kinds\n\tof return.\n\t* config/mips/mips.md (any_return): New code_iterator.\n\t(optab): Add cases for return and simple_return.\n\t(return): Expand to a simple_return.\n\t(simple_return): New pattern.\n\t(*<optab>, *<optab>_internal for any_return): New patterns.\n\t(return_internal): Remove.\n\t* config/mips/mips.c (mips_expand_epilogue): Make the last insn\n\ta simple_return_internal.\n\nFrom-SVN: r178135", "tree": {"sha": "96c64ae5371e1ab349170887878b88e9fec9c9a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96c64ae5371e1ab349170887878b88e9fec9c9a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/268987713c7105c691f4efaf82a3f1f4ec394b07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268987713c7105c691f4efaf82a3f1f4ec394b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268987713c7105c691f4efaf82a3f1f4ec394b07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268987713c7105c691f4efaf82a3f1f4ec394b07/comments", "author": null, "committer": null, "parents": [{"sha": "3b0eee5d58175e688fe3fe6f7538db7b96e7f9b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0eee5d58175e688fe3fe6f7538db7b96e7f9b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0eee5d58175e688fe3fe6f7538db7b96e7f9b8"}], "stats": {"total": 599, "additions": 402, "deletions": 197}, "files": [{"sha": "69b05cc10986831556e5b11fd4cd85ee7ecdec36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -1,3 +1,66 @@\n+2011-08-27  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* doc/rtl.texi (simple_return): Document.\n+\t(parallel, PATTERN): Here too.\n+\t* doc/md.texi (return): Mention it's allowed to expand to simple_return\n+\tin some cases.\n+\t(simple_return): Document standard pattern.\n+\t* gengenrtl.c (special_rtx): SIMPLE_RETURN is special.\n+\t* final.c (final_scan_insn): Use ANY_RETURN_P on body.\n+\t* reorg.c (function_return_label, function_simple_return_label):\n+\tNew static variables, replacing...\n+\t(end_of_function_label): ... this.\n+\t(simplejump_or_return_p): New static function.\n+\t(optimize_skip, steal_delay_list_from_fallthrough,\n+\tfill_slots_from_thread): Use it.\n+\t(relax_delay_slots): Likewise.  Use ANY_RETURN_P on body.\n+\t(rare_destination, follow_jumps): Use ANY_RETURN_P on body.\n+\t(find_end_label): Take a new arg which is one of the two return\n+\trtxs.  Depending on which, set either function_return_label or\n+\tfunction_simple_return_label.  All callers changed.\n+\t(make_return_insns): Make both kinds.\n+\t(dbr_schedule): Adjust for two kinds of end labels.\n+\t* function.c (emit_return_into_block): Set JUMP_LABEL properly.\n+\t* genemit.c (gen_exp): Handle SIMPLE_RETURN.\n+\t(gen_expand, gen_split): Use ANY_RETURN_P.\n+\t* df-scan.c (df_uses_record): Handle SIMPLE_RETURN.\n+\t* rtl.def (SIMPLE_RETURN): New code.\n+\t* ifcvt.c (find_if_case_1): Be more careful about\n+\tredirecting jumps to the EXIT_BLOCK.\n+\t* jump.c (condjump_p, condjump_in_parallel_p, any_condjump_p,\n+\treturnjump_p_1): Handle SIMPLE_RETURNs.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* rtl.c (copy_rtx): Likewise.\n+\t* bt-load.c (compute_defs_uses_and_gen): Use ANY_RETURN_P.\n+\t* combine.c (simplify_set): Likewise.\n+\t* resource.c (find_dead_or_set_registers, mark_set_resources):\n+\tLikewise.\n+\t* emit-rtl.c (verify_rtx_sharing, classify_insn, copy_insn_1,\n+\tcopy_rtx_if_shared_1, mark_used_flags): Handle SIMPLE_RETURNs.\n+\t(init_emit_regs): Initialize simple_return_rtx.\n+\t* cfglayout.c (fixup_reorder_chain): Pass a JUMP_LABEL to\n+\tforce_nonfallthru_and_redirect.\n+\t* rtl.h (ANY_RETURN_P): Allow SIMPLE_RETURN.\n+\t(GR_SIMPLE_RETURN): New enum value.\n+\t(simple_return_rtx): New macro.\n+\t* basic-block.h (force_nonfallthru_and_redirect): Adjust\n+\tdeclaration.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Take a new jump_label\n+\targument.  All callers changed.  Be careful about what kinds of\n+\treturnjumps to generate.\n+\t* config/i386/3i86.c (ix86_pad_returns, ix86_count_insn_bb,\n+\tix86_pad_short_function): Likewise.\n+\t* config/arm/arm.c (arm_final_prescan_insn): Handle both kinds\n+\tof return.\n+\t* config/mips/mips.md (any_return): New code_iterator.\n+\t(optab): Add cases for return and simple_return.\n+\t(return): Expand to a simple_return.\n+\t(simple_return): New pattern.\n+\t(*<optab>, *<optab>_internal for any_return): New patterns.\n+\t(return_internal): Remove.\n+\t* config/mips/mips.c (mips_expand_epilogue): Make the last insn\n+\ta simple_return_internal.\n+\n 2011-08-27  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (*absneg<mode>2): Fix split condition."}, {"sha": "e36b20a38923e98fe78cae0898296fe435d4ba9c", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -804,7 +804,7 @@ extern rtx block_label (basic_block);\n extern bool purge_all_dead_edges (void);\n extern bool purge_dead_edges (basic_block);\n extern bool fixup_abnormal_edges (void);\n-extern basic_block force_nonfallthru_and_redirect (edge, basic_block);\n+extern basic_block force_nonfallthru_and_redirect (edge, basic_block, rtx);\n \n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);"}, {"sha": "a93d2b9bffe57a4cdefd1a19e763230883fda6ea", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -558,7 +558,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t\t      /* Check for sibcall.  */\n \t\t      if (GET_CODE (pat) == PARALLEL)\n \t\t\tfor (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n-\t\t\t  if (GET_CODE (XVECEXP (pat, 0, i)) == RETURN)\n+\t\t\t  if (ANY_RETURN_P (XVECEXP (pat, 0, i)))\n \t\t\t    {\n \t\t\t      COMPL_HARD_REG_SET (call_saved,\n \t\t\t\t\t\t  call_used_reg_set);"}, {"sha": "62ac6bfe151e71e6d4bda8129579d8167927b625", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -767,6 +767,7 @@ fixup_reorder_chain (void)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n+      rtx ret_label = NULL_RTX;\n       basic_block nb, src_bb;\n       edge_iterator ei;\n \n@@ -786,6 +787,7 @@ fixup_reorder_chain (void)\n       bb_end_insn = BB_END (bb);\n       if (JUMP_P (bb_end_insn))\n \t{\n+\t  ret_label = JUMP_LABEL (bb_end_insn);\n \t  if (any_condjump_p (bb_end_insn))\n \t    {\n \t      /* This might happen if the conditional jump has side\n@@ -899,7 +901,7 @@ fixup_reorder_chain (void)\n \t Note force_nonfallthru can delete E_FALL and thus we have to\n \t save E_FALL->src prior to the call to force_nonfallthru.  */\n       src_bb = e_fall->src;\n-      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest);\n+      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);\n       if (nb)\n \t{\n \t  nb->il.rtl->visited = 1;"}, {"sha": "b3f045bbbcb6bab229ae8cd468748007328033cb", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -1117,10 +1117,13 @@ rtl_redirect_edge_and_branch (edge e, basic_block target)\n }\n \n /* Like force_nonfallthru below, but additionally performs redirection\n-   Used by redirect_edge_and_branch_force.  */\n+   Used by redirect_edge_and_branch_force.  JUMP_LABEL is used only\n+   when redirecting to the EXIT_BLOCK, it is either ret_rtx or\n+   simple_return_rtx, indicating which kind of returnjump to create.\n+   It should be NULL otherwise.  */\n \n basic_block\n-force_nonfallthru_and_redirect (edge e, basic_block target)\n+force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n {\n   basic_block jump_block, new_bb = NULL, src = e->src;\n   rtx note;\n@@ -1252,12 +1255,25 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   e->flags &= ~EDGE_FALLTHRU;\n   if (target == EXIT_BLOCK_PTR)\n     {\n+      if (jump_label == ret_rtx)\n+\t{\n #ifdef HAVE_return\n-\temit_jump_insn_after_setloc (gen_return (), BB_END (jump_block), loc);\n-\tJUMP_LABEL (BB_END (jump_block)) = ret_rtx;\n+\t  emit_jump_insn_after_setloc (gen_return (), BB_END (jump_block), loc);\n #else\n-\tgcc_unreachable ();\n+\t  gcc_unreachable ();\n #endif\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (jump_label == simple_return_rtx);\n+#ifdef HAVE_simple_return\n+\t  emit_jump_insn_after_setloc (gen_simple_return (),\n+\t\t\t\t       BB_END (jump_block), loc);\n+#else\n+\t  gcc_unreachable ();\n+#endif\n+\t}\n+      JUMP_LABEL (BB_END (jump_block)) = jump_label;\n     }\n   else\n     {\n@@ -1284,7 +1300,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n static basic_block\n rtl_force_nonfallthru (edge e)\n {\n-  return force_nonfallthru_and_redirect (e, e->dest);\n+  return force_nonfallthru_and_redirect (e, e->dest, NULL_RTX);\n }\n \n /* Redirect edge even at the expense of creating new jump insn or\n@@ -1301,7 +1317,7 @@ rtl_redirect_edge_and_branch_force (edge e, basic_block target)\n   /* In case the edge redirection failed, try to force it to be non-fallthru\n      and redirect newly created simplejump.  */\n   df_set_bb_dirty (e->src);\n-  return force_nonfallthru_and_redirect (e, target);\n+  return force_nonfallthru_and_redirect (e, target, NULL_RTX);\n }\n \n /* The given edge should potentially be a fallthru edge.  If that is in"}, {"sha": "6c3b17ca6ea40346f4d7294d9d0de8360d339fd7", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -6303,7 +6303,7 @@ simplify_set (rtx x)\n   rtx *cc_use;\n \n   /* (set (pc) (return)) gets written as (return).  */\n-  if (GET_CODE (dest) == PC && GET_CODE (src) == RETURN)\n+  if (GET_CODE (dest) == PC && ANY_RETURN_P (src))\n     return src;\n \n   /* Now that we know for sure which bits of SRC we are using, see if we can"}, {"sha": "0490da23b5eeef59b8a060189fb0dd9e8aa23315", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -17836,6 +17836,7 @@ arm_final_prescan_insn (rtx insn)\n \n   /* If we start with a return insn, we only succeed if we find another one.  */\n   int seeking_return = 0;\n+  enum rtx_code return_code = UNKNOWN;\n \n   /* START_INSN will hold the insn from where we start looking.  This is the\n      first insn after the following code_label if REVERSE is true.  */\n@@ -17874,7 +17875,7 @@ arm_final_prescan_insn (rtx insn)\n \t  else\n \t    return;\n \t}\n-      else if (GET_CODE (body) == RETURN)\n+      else if (ANY_RETURN_P (body))\n         {\n \t  start_insn = next_nonnote_insn (start_insn);\n \t  if (GET_CODE (start_insn) == BARRIER)\n@@ -17885,6 +17886,7 @@ arm_final_prescan_insn (rtx insn)\n \t    {\n \t      reverse = TRUE;\n \t      seeking_return = 1;\n+\t      return_code = GET_CODE (body);\n \t    }\n \t  else\n \t    return;\n@@ -17925,11 +17927,15 @@ arm_final_prescan_insn (rtx insn)\n \t  label = XEXP (XEXP (SET_SRC (body), 2), 0);\n \t  then_not_else = FALSE;\n \t}\n-      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == RETURN)\n-\tseeking_return = 1;\n-      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == RETURN)\n+      else if (ANY_RETURN_P (XEXP (SET_SRC (body), 1)))\n+\t{\n+\t  seeking_return = 1;\n+\t  return_code = GET_CODE (XEXP (SET_SRC (body), 1));\n+\t}\n+      else if (ANY_RETURN_P (XEXP (SET_SRC (body), 2)))\n         {\n \t  seeking_return = 1;\n+\t  return_code = GET_CODE (XEXP (SET_SRC (body), 2));\n \t  then_not_else = FALSE;\n         }\n       else\n@@ -18026,12 +18032,11 @@ arm_final_prescan_insn (rtx insn)\n \t\t}\n \t      /* Fail if a conditional return is undesirable (e.g. on a\n \t\t StrongARM), but still allow this if optimizing for size.  */\n-\t      else if (GET_CODE (scanbody) == RETURN\n+\t      else if (GET_CODE (scanbody) == return_code\n \t\t       && !use_return_insn (TRUE, NULL)\n \t\t       && !optimize_size)\n \t\tfail = TRUE;\n-\t      else if (GET_CODE (scanbody) == RETURN\n-\t\t       && seeking_return)\n+\t      else if (GET_CODE (scanbody) == return_code)\n \t        {\n \t\t  arm_ccfsm_state = 2;\n \t\t  succeed = TRUE;"}, {"sha": "48b9be0b118a83eb5ad91747ed3616f4706a068b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -30585,7 +30585,7 @@ ix86_pad_returns (void)\n       rtx prev;\n       bool replace = false;\n \n-      if (!JUMP_P (ret) || GET_CODE (PATTERN (ret)) != RETURN\n+      if (!JUMP_P (ret) || !ANY_RETURN_P (PATTERN (ret))\n \t  || optimize_bb_for_size_p (bb))\n \tcontinue;\n       for (prev = PREV_INSN (ret); prev; prev = PREV_INSN (prev))\n@@ -30636,7 +30636,7 @@ ix86_count_insn_bb (basic_block bb)\n     {\n       /* Only happen in exit blocks.  */\n       if (JUMP_P (insn)\n-\t  && GET_CODE (PATTERN (insn)) == RETURN)\n+\t  && ANY_RETURN_P (PATTERN (insn)))\n \tbreak;\n \n       if (NONDEBUG_INSN_P (insn)\n@@ -30709,7 +30709,7 @@ ix86_pad_short_function (void)\n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     {\n       rtx ret = BB_END (e->src);\n-      if (JUMP_P (ret) && GET_CODE (PATTERN (ret)) == RETURN)\n+      if (JUMP_P (ret) && ANY_RETURN_P (PATTERN (ret)))\n \t{\n \t  int insn_count = ix86_count_insn (e->src);\n "}, {"sha": "f5c4cbe60f6c92e56334a7de6d50723c36364c44", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -10453,7 +10453,8 @@ mips_expand_epilogue (bool sibcall_p)\n \t    regno = GP_REG_FIRST + 7;\n \t  else\n \t    regno = RETURN_ADDR_REGNUM;\n-\t  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));\n+\t  emit_jump_insn (gen_simple_return_internal (gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t\t\t   regno)));\n \t}\n     }\n "}, {"sha": "0606f92f7b6e982c3b51e4b02194e65db9da0361", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -777,6 +777,8 @@\n (define_code_iterator any_lt [lt ltu])\n (define_code_iterator any_le [le leu])\n \n+(define_code_iterator any_return [return simple_return])\n+\n ;; <u> expands to an empty string when doing a signed operation and\n ;; \"u\" when doing an unsigned operation.\n (define_code_attr u [(sign_extend \"\") (zero_extend \"u\")\n@@ -798,7 +800,9 @@\n \t\t\t (xor \"xor\")\n \t\t\t (and \"and\")\n \t\t\t (plus \"add\")\n-\t\t\t (minus \"sub\")])\n+\t\t\t (minus \"sub\")\n+\t\t\t (return \"return\")\n+\t\t\t (simple_return \"simple_return\")])\n \n ;; <insn> expands to the name of the insn that implements a particular code.\n (define_code_attr insn [(ashift \"sll\")\n@@ -5713,21 +5717,26 @@\n ;; allows jump optimizations to work better.\n \n (define_expand \"return\"\n-  [(return)]\n+  [(simple_return)]\n   \"mips_can_use_return_insn ()\"\n   { mips_expand_before_return (); })\n \n-(define_insn \"*return\"\n-  [(return)]\n-  \"mips_can_use_return_insn ()\"\n+(define_expand \"simple_return\"\n+  [(simple_return)]\n+  \"\"\n+  { mips_expand_before_return (); })\n+\n+(define_insn \"*<optab>\"\n+  [(any_return)]\n+  \"\"\n   \"%*j\\t$31%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n ;; Normal return.\n \n-(define_insn \"return_internal\"\n-  [(return)\n+(define_insn \"<optab>_internal\"\n+  [(any_return)\n    (use (match_operand 0 \"pmode_register_operand\" \"\"))]\n   \"\"\n   \"%*j\\t%0%/\""}, {"sha": "deaa9f96d5323aff8bde0369943ec0659ca243d1", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -3181,6 +3181,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       }\n \n     case RETURN:\n+    case SIMPLE_RETURN:\n       break;\n \n     case ASM_OPERANDS:"}, {"sha": "ffb8843633ef2932fccc1a8b80f27ff7970bfb06", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -4992,6 +4992,20 @@ some class of functions only requires one instruction to implement a\n return.  Normally, the applicable functions are those which do not need\n to save any registers or allocate stack space.\n \n+It is valid for this pattern to expand to an instruction using\n+@code{simple_return} if no epilogue is required.\n+\n+@cindex @code{simple_return} instruction pattern\n+@item @samp{simple_return}\n+Subroutine return instruction.  This instruction pattern name should be\n+defined only if a single instruction can do all the work of returning\n+from a function on a path where no epilogue is required.  This pattern\n+is very similar to the @code{return} instruction pattern, but it is emitted\n+only by the shrink-wrapping optimization on paths where the function\n+prologue has not been executed, and a function return should occur without\n+any of the effects of the epilogue.  Additional uses may be introduced on\n+paths where both the prologue and the epilogue have executed.\n+\n @findex reload_completed\n @findex leaf_function_p\n For such machines, the condition specified in this pattern should only"}, {"sha": "4cb51eec1aa5bfe050cc57f6a3b056e727cfafeb", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -2915,6 +2915,13 @@ placed in @code{pc} to return to the caller.\n Note that an insn pattern of @code{(return)} is logically equivalent to\n @code{(set (pc) (return))}, but the latter form is never used.\n \n+@findex simple_return\n+@item (simple_return)\n+Like @code{(return)}, but truly represents only a function return, while\n+@code{(return)} may represent an insn that also performs other functions\n+of the function epilogue.  Like @code{(return)}, this may also occur in\n+conditional jumps.\n+\n @findex call\n @item (call @var{function} @var{nargs})\n Represents a function call.  @var{function} is a @code{mem} expression\n@@ -3044,7 +3051,7 @@ Represents several side effects performed in parallel.  The square\n brackets stand for a vector; the operand of @code{parallel} is a\n vector of expressions.  @var{x0}, @var{x1} and so on are individual\n side effect expressions---expressions of code @code{set}, @code{call},\n-@code{return}, @code{clobber} or @code{use}.\n+@code{return}, @code{simple_return}, @code{clobber} or @code{use}.\n \n ``In parallel'' means that first all the values used in the individual\n side-effects are computed, and second all the actual side-effects are\n@@ -3683,14 +3690,16 @@ and @code{call_insn} insns:\n @table @code\n @findex PATTERN\n @item PATTERN (@var{i})\n-An expression for the side effect performed by this insn.  This must be\n-one of the following codes: @code{set}, @code{call}, @code{use},\n-@code{clobber}, @code{return}, @code{asm_input}, @code{asm_output},\n-@code{addr_vec}, @code{addr_diff_vec}, @code{trap_if}, @code{unspec},\n-@code{unspec_volatile}, @code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a @code{parallel},\n-each element of the @code{parallel} must be one these codes, except that\n-@code{parallel} expressions cannot be nested and @code{addr_vec} and\n-@code{addr_diff_vec} are not permitted inside a @code{parallel} expression.\n+An expression for the side effect performed by this insn.  This must\n+be one of the following codes: @code{set}, @code{call}, @code{use},\n+@code{clobber}, @code{return}, @code{simple_return}, @code{asm_input},\n+@code{asm_output}, @code{addr_vec}, @code{addr_diff_vec},\n+@code{trap_if}, @code{unspec}, @code{unspec_volatile},\n+@code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a\n+@code{parallel}, each element of the @code{parallel} must be one these\n+codes, except that @code{parallel} expressions cannot be nested and\n+@code{addr_vec} and @code{addr_diff_vec} are not permitted inside a\n+@code{parallel} expression.\n \n @findex INSN_CODE\n @item INSN_CODE (@var{i})"}, {"sha": "b97d7c47a0bbbb071e582d7bf2fa9ca219937e9d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -2518,6 +2518,7 @@ verify_rtx_sharing (rtx orig, rtx insn)\n     case PC:\n     case CC0:\n     case RETURN:\n+    case SIMPLE_RETURN:\n     case SCRATCH:\n       return;\n       /* SCRATCH must be shared because they represent distinct values.  */\n@@ -2725,6 +2726,7 @@ copy_rtx_if_shared_1 (rtx *orig1)\n     case PC:\n     case CC0:\n     case RETURN:\n+    case SIMPLE_RETURN:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return;\n@@ -2845,6 +2847,7 @@ mark_used_flags (rtx x, int flag)\n     case PC:\n     case CC0:\n     case RETURN:\n+    case SIMPLE_RETURN:\n       return;\n \n     case DEBUG_INSN:\n@@ -5008,7 +5011,7 @@ classify_insn (rtx x)\n     return CODE_LABEL;\n   if (GET_CODE (x) == CALL)\n     return CALL_INSN;\n-  if (GET_CODE (x) == RETURN)\n+  if (ANY_RETURN_P (x))\n     return JUMP_INSN;\n   if (GET_CODE (x) == SET)\n     {\n@@ -5264,6 +5267,7 @@ copy_insn_1 (rtx orig)\n     case PC:\n     case CC0:\n     case RETURN:\n+    case SIMPLE_RETURN:\n       return orig;\n     case CLOBBER:\n       if (REG_P (XEXP (orig, 0)) && REGNO (XEXP (orig, 0)) < FIRST_PSEUDO_REGISTER)\n@@ -5521,6 +5525,7 @@ init_emit_regs (void)\n   /* Assign register numbers to the globally defined register rtx.  */\n   pc_rtx = gen_rtx_fmt_ (PC, VOIDmode);\n   ret_rtx = gen_rtx_fmt_ (RETURN, VOIDmode);\n+  simple_return_rtx = gen_rtx_fmt_ (SIMPLE_RETURN, VOIDmode);\n   cc0_rtx = gen_rtx_fmt_ (CC0, VOIDmode);\n   stack_pointer_rtx = gen_raw_REG (Pmode, STACK_POINTER_REGNUM);\n   frame_pointer_rtx = gen_raw_REG (Pmode, FRAME_POINTER_REGNUM);"}, {"sha": "328599c42c4ffb8544c653441b82fd30c2206fdf", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -2492,7 +2492,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t        delete_insn (insn);\n \t\tbreak;\n \t      }\n-\t    else if (GET_CODE (SET_SRC (body)) == RETURN)\n+\t    else if (ANY_RETURN_P (SET_SRC (body)))\n \t      /* Replace (set (pc) (return)) with (return).  */\n \t      PATTERN (insn) = body = SET_SRC (body);\n "}, {"sha": "27fe70328c6a9ea1d808092845fdeaf02d5e4b1a", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -5306,7 +5306,11 @@ static void\n emit_return_into_block (basic_block bb)\n {\n   rtx jump = emit_jump_insn_after (gen_return (), BB_END (bb));\n-  JUMP_LABEL (jump) = ret_rtx;\n+  rtx pat = PATTERN (jump);\n+  if (GET_CODE (pat) == PARALLEL)\n+    pat = XVECEXP (pat, 0, 0);\n+  gcc_assert (ANY_RETURN_P (pat));\n+  JUMP_LABEL (jump) = pat;\n }\n #endif /* HAVE_return */\n "}, {"sha": "662d8ca59b3c5658bec9ab5878cc2d9ac1f74a81", "filename": "gcc/genemit.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -169,6 +169,9 @@ gen_exp (rtx x, enum rtx_code subroutine_type, char *used)\n     case RETURN:\n       printf (\"ret_rtx\");\n       return;\n+    case SIMPLE_RETURN:\n+      printf (\"simple_return_rtx\");\n+      return;\n     case CLOBBER:\n       if (REG_P (XEXP (x, 0)))\n \t{\n@@ -489,8 +492,8 @@ gen_expand (rtx expand)\n \t  || (GET_CODE (next) == PARALLEL\n \t      && ((GET_CODE (XVECEXP (next, 0, 0)) == SET\n \t\t   && GET_CODE (SET_DEST (XVECEXP (next, 0, 0))) == PC)\n-\t\t  || GET_CODE (XVECEXP (next, 0, 0)) == RETURN))\n-\t  || GET_CODE (next) == RETURN)\n+\t\t  || ANY_RETURN_P (XVECEXP (next, 0, 0))))\n+\t  || ANY_RETURN_P (next))\n \tprintf (\"  emit_jump_insn (\");\n       else if ((GET_CODE (next) == SET && GET_CODE (SET_SRC (next)) == CALL)\n \t       || GET_CODE (next) == CALL\n@@ -607,7 +610,7 @@ gen_split (rtx split)\n \t  || (GET_CODE (next) == PARALLEL\n \t      && GET_CODE (XVECEXP (next, 0, 0)) == SET\n \t      && GET_CODE (SET_DEST (XVECEXP (next, 0, 0))) == PC)\n-\t  || GET_CODE (next) == RETURN)\n+\t  || ANY_RETURN_P (next))\n \tprintf (\"  emit_jump_insn (\");\n       else if ((GET_CODE (next) == SET && GET_CODE (SET_SRC (next)) == CALL)\n \t       || GET_CODE (next) == CALL"}, {"sha": "67688aca98ca265929b6caaff766c993558ad08d", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -131,6 +131,7 @@ special_rtx (int idx)\n \t  || strcmp (defs[idx].enumname, \"PC\") == 0\n \t  || strcmp (defs[idx].enumname, \"CC0\") == 0\n \t  || strcmp (defs[idx].enumname, \"RETURN\") == 0\n+\t  || strcmp (defs[idx].enumname, \"SIMPLE_RETURN\") == 0\n \t  || strcmp (defs[idx].enumname, \"CONST_VECTOR\") == 0);\n }\n "}, {"sha": "0fcacb6141fd8ec004b281ed9a3c87b28a4b6113", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -3796,6 +3796,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   basic_block new_bb;\n+  rtx else_target = NULL_RTX;\n   int then_bb_index;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n@@ -3845,6 +3846,13 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \t\t\t\t    predictable_edge_p (then_edge)))))\n     return FALSE;\n \n+  if (else_bb == EXIT_BLOCK_PTR)\n+    {\n+      rtx jump = BB_END (else_edge->src);\n+      gcc_assert (JUMP_P (jump));\n+      else_target = JUMP_LABEL (jump);\n+    }\n+\n   /* Registers set are dead, or are predicable.  */\n   if (! dead_or_predicable (test_bb, then_bb, else_bb,\n \t\t\t    single_succ_edge (then_bb), 1))\n@@ -3864,6 +3872,9 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n       redirect_edge_succ (FALLTHRU_EDGE (test_bb), else_bb);\n       new_bb = 0;\n     }\n+  else if (else_bb == EXIT_BLOCK_PTR)\n+    new_bb = force_nonfallthru_and_redirect (FALLTHRU_EDGE (test_bb),\n+\t\t\t\t\t     else_bb, else_target);\n   else\n     new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb),\n \t\t\t\t\t     else_bb);"}, {"sha": "0273adf4af693351ce62c62eb2e336cfbf4092b1", "filename": "gcc/jump.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -29,7 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n    JUMP_LABEL internal field.  With this we can detect labels that\n    become unused because of the deletion of all the jumps that\n    formerly used them.  The JUMP_LABEL info is sometimes looked\n-   at by later passes.\n+   at by later passes.  For return insns, it contains either a\n+   RETURN or a SIMPLE_RETURN rtx.\n \n    The subroutines redirect_jump and invert_jump are used\n    from other passes as well.  */\n@@ -775,10 +776,10 @@ condjump_p (const_rtx insn)\n     return (GET_CODE (x) == IF_THEN_ELSE\n \t    && ((GET_CODE (XEXP (x, 2)) == PC\n \t\t && (GET_CODE (XEXP (x, 1)) == LABEL_REF\n-\t\t     || GET_CODE (XEXP (x, 1)) == RETURN))\n+\t\t     || ANY_RETURN_P (XEXP (x, 1))))\n \t\t|| (GET_CODE (XEXP (x, 1)) == PC\n \t\t    && (GET_CODE (XEXP (x, 2)) == LABEL_REF\n-\t\t\t|| GET_CODE (XEXP (x, 2)) == RETURN))));\n+\t\t\t|| ANY_RETURN_P (XEXP (x, 2))))));\n }\n \n /* Return nonzero if INSN is a (possibly) conditional jump inside a\n@@ -807,11 +808,11 @@ condjump_in_parallel_p (const_rtx insn)\n     return 0;\n   if (XEXP (SET_SRC (x), 2) == pc_rtx\n       && (GET_CODE (XEXP (SET_SRC (x), 1)) == LABEL_REF\n-\t  || GET_CODE (XEXP (SET_SRC (x), 1)) == RETURN))\n+\t  || ANY_RETURN_P (XEXP (SET_SRC (x), 1))))\n     return 1;\n   if (XEXP (SET_SRC (x), 1) == pc_rtx\n       && (GET_CODE (XEXP (SET_SRC (x), 2)) == LABEL_REF\n-\t  || GET_CODE (XEXP (SET_SRC (x), 2)) == RETURN))\n+\t  || ANY_RETURN_P (XEXP (SET_SRC (x), 2))))\n     return 1;\n   return 0;\n }\n@@ -873,8 +874,9 @@ any_condjump_p (const_rtx insn)\n   a = GET_CODE (XEXP (SET_SRC (x), 1));\n   b = GET_CODE (XEXP (SET_SRC (x), 2));\n \n-  return ((b == PC && (a == LABEL_REF || a == RETURN))\n-\t  || (a == PC && (b == LABEL_REF || b == RETURN)));\n+  return ((b == PC && (a == LABEL_REF || a == RETURN || a == SIMPLE_RETURN))\n+\t  || (a == PC\n+\t      && (b == LABEL_REF || b == RETURN || b == SIMPLE_RETURN)));\n }\n \n /* Return the label of a conditional jump.  */\n@@ -911,6 +913,7 @@ returnjump_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n   switch (GET_CODE (x))\n     {\n     case RETURN:\n+    case SIMPLE_RETURN:\n     case EH_RETURN:\n       return true;\n "}, {"sha": "db9c0fbbdd0b3086bb2877a246ef90587c85d82d", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -328,6 +328,8 @@ print_rtx (const_rtx in_rtx)\n \t    fprintf (outfile, \"\\n%s%*s -> \", print_rtx_head, indent * 2, \"\");\n \t    if (GET_CODE (JUMP_LABEL (in_rtx)) == RETURN)\n \t      fprintf (outfile, \"return\");\n+\t    else if (GET_CODE (JUMP_LABEL (in_rtx)) == SIMPLE_RETURN)\n+\t      fprintf (outfile, \"simple_return\");\n \t    else\n \t      fprintf (outfile, \"%d\", INSN_UID (JUMP_LABEL (in_rtx)));\n \t  }"}, {"sha": "8880545a74c16d4e7b91a6af2291913cf2d7ce74", "filename": "gcc/reorg.c", "status": "modified", "additions": 185, "deletions": 142, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -161,8 +161,11 @@ static rtx *unfilled_firstobj;\n #define unfilled_slots_next\t\\\n   ((rtx *) obstack_next_free (&unfilled_slots_obstack))\n \n-/* Points to the label before the end of the function.  */\n-static rtx end_of_function_label;\n+/* Points to the label before the end of the function, or before a\n+   return insn.  */\n+static rtx function_return_label;\n+/* Likewise for a simple_return.  */\n+static rtx function_simple_return_label;\n \n /* Mapping between INSN_UID's and position in the code since INSN_UID's do\n    not always monotonically increase.  */\n@@ -175,7 +178,7 @@ static int stop_search_p (rtx, int);\n static int resource_conflicts_p (struct resources *, struct resources *);\n static int insn_references_resource_p (rtx, struct resources *, bool);\n static int insn_sets_resource_p (rtx, struct resources *, bool);\n-static rtx find_end_label (void);\n+static rtx find_end_label (rtx);\n static rtx emit_delay_sequence (rtx, rtx, int);\n static rtx add_to_delay_list (rtx, rtx);\n static rtx delete_from_delay_slot (rtx);\n@@ -231,6 +234,15 @@ first_active_target_insn (rtx insn)\n   return next_active_insn (insn);\n }\n \f\n+/* Return true iff INSN is a simplejump, or any kind of return insn.  */\n+\n+static bool\n+simplejump_or_return_p (rtx insn)\n+{\n+  return (JUMP_P (insn)\n+\t  && (simplejump_p (insn) || ANY_RETURN_P (PATTERN (insn))));\n+}\n+\f\n /* Return TRUE if this insn should stop the search for insn to fill delay\n    slots.  LABELS_P indicates that labels should terminate the search.\n    In all cases, jumps terminate the search.  */\n@@ -346,23 +358,34 @@ insn_sets_resource_p (rtx insn, struct resources *res,\n \n    ??? There may be a problem with the current implementation.  Suppose\n    we start with a bare RETURN insn and call find_end_label.  It may set\n-   end_of_function_label just before the RETURN.  Suppose the machinery\n+   function_return_label just before the RETURN.  Suppose the machinery\n    is able to fill the delay slot of the RETURN insn afterwards.  Then\n-   end_of_function_label is no longer valid according to the property\n+   function_return_label is no longer valid according to the property\n    described above and find_end_label will still return it unmodified.\n    Note that this is probably mitigated by the following observation:\n-   once end_of_function_label is made, it is very likely the target of\n+   once function_return_label is made, it is very likely the target of\n    a jump, so filling the delay slot of the RETURN will be much more\n-   difficult.  */\n+   difficult.\n+   KIND is either simple_return_rtx or ret_rtx, indicating which type of\n+   return we're looking for.  */\n \n static rtx\n-find_end_label (void)\n+find_end_label (rtx kind)\n {\n   rtx insn;\n+  rtx *plabel;\n+\n+  if (kind == ret_rtx)\n+    plabel = &function_return_label;\n+  else\n+    {\n+      gcc_assert (kind == simple_return_rtx);\n+      plabel = &function_simple_return_label;\n+    }\n \n   /* If we found one previously, return it.  */\n-  if (end_of_function_label)\n-    return end_of_function_label;\n+  if (*plabel)\n+    return *plabel;\n \n   /* Otherwise, see if there is a label at the end of the function.  If there\n      is, it must be that RETURN insns aren't needed, so that is our return\n@@ -377,44 +400,45 @@ find_end_label (void)\n \n   /* When a target threads its epilogue we might already have a\n      suitable return insn.  If so put a label before it for the\n-     end_of_function_label.  */\n+     function_return_label.  */\n   if (BARRIER_P (insn)\n       && JUMP_P (PREV_INSN (insn))\n-      && GET_CODE (PATTERN (PREV_INSN (insn))) == RETURN)\n+      && PATTERN (PREV_INSN (insn)) == kind)\n     {\n       rtx temp = PREV_INSN (PREV_INSN (insn));\n-      end_of_function_label = gen_label_rtx ();\n-      LABEL_NUSES (end_of_function_label) = 0;\n+      rtx label = gen_label_rtx ();\n+      LABEL_NUSES (label) = 0;\n \n-      /* Put the label before an USE insns that may precede the RETURN insn.  */\n+      /* Put the label before any USE insns that may precede the RETURN\n+\t insn.  */\n       while (GET_CODE (temp) == USE)\n \ttemp = PREV_INSN (temp);\n \n-      emit_label_after (end_of_function_label, temp);\n+      emit_label_after (label, temp);\n+      *plabel = label;\n     }\n \n   else if (LABEL_P (insn))\n-    end_of_function_label = insn;\n+    *plabel = insn;\n   else\n     {\n-      end_of_function_label = gen_label_rtx ();\n-      LABEL_NUSES (end_of_function_label) = 0;\n+      rtx label = gen_label_rtx ();\n+      LABEL_NUSES (label) = 0;\n       /* If the basic block reorder pass moves the return insn to\n \t some other place try to locate it again and put our\n-\t end_of_function_label there.  */\n-      while (insn && ! (JUMP_P (insn)\n-\t\t        && (GET_CODE (PATTERN (insn)) == RETURN)))\n+\t function_return_label there.  */\n+      while (insn && ! (JUMP_P (insn) && (PATTERN (insn) == kind)))\n \tinsn = PREV_INSN (insn);\n       if (insn)\n \t{\n \t  insn = PREV_INSN (insn);\n \n-\t  /* Put the label before an USE insns that may proceed the\n+\t  /* Put the label before any USE insns that may precede the\n \t     RETURN insn.  */\n \t  while (GET_CODE (insn) == USE)\n \t    insn = PREV_INSN (insn);\n \n-\t  emit_label_after (end_of_function_label, insn);\n+\t  emit_label_after (label, insn);\n \t}\n       else\n \t{\n@@ -424,19 +448,16 @@ find_end_label (void)\n \t      && ! HAVE_return\n #endif\n \t      )\n-\t    {\n-\t      /* The RETURN insn has its delay slot filled so we cannot\n-\t\t emit the label just before it.  Since we already have\n-\t\t an epilogue and cannot emit a new RETURN, we cannot\n-\t\t emit the label at all.  */\n-\t      end_of_function_label = NULL_RTX;\n-\t      return end_of_function_label;\n-\t    }\n+\t    /* The RETURN insn has its delay slot filled so we cannot\n+\t       emit the label just before it.  Since we already have\n+\t       an epilogue and cannot emit a new RETURN, we cannot\n+\t       emit the label at all.  */\n+\t    return NULL_RTX;\n #endif /* HAVE_epilogue */\n \n \t  /* Otherwise, make a new label and emit a RETURN and BARRIER,\n \t     if needed.  */\n-\t  emit_label (end_of_function_label);\n+\t  emit_label (label);\n #ifdef HAVE_return\n \t  /* We don't bother trying to create a return insn if the\n \t     epilogue has filled delay-slots; we would have to try and\n@@ -455,13 +476,14 @@ find_end_label (void)\n \t    }\n #endif\n \t}\n+      *plabel = label;\n     }\n \n   /* Show one additional use for this label so it won't go away until\n      we are done.  */\n-  ++LABEL_NUSES (end_of_function_label);\n+  ++LABEL_NUSES (*plabel);\n \n-  return end_of_function_label;\n+  return *plabel;\n }\n \f\n /* Put INSN and LIST together in a SEQUENCE rtx of LENGTH, and replace\n@@ -809,10 +831,8 @@ optimize_skip (rtx insn)\n   if ((next_trial == next_active_insn (JUMP_LABEL (insn))\n        && ! (next_trial == 0 && crtl->epilogue_delay_list != 0))\n       || (next_trial != 0\n-\t  && JUMP_P (next_trial)\n-\t  && JUMP_LABEL (insn) == JUMP_LABEL (next_trial)\n-\t  && (simplejump_p (next_trial)\n-\t      || GET_CODE (PATTERN (next_trial)) == RETURN)))\n+\t  && simplejump_or_return_p (next_trial)\n+\t  && JUMP_LABEL (insn) == JUMP_LABEL (next_trial)))\n     {\n       if (eligible_for_annul_false (insn, 0, trial, flags))\n \t{\n@@ -831,13 +851,11 @@ optimize_skip (rtx insn)\n \t branch, thread our jump to the target of that branch.  Don't\n \t change this into a RETURN here, because it may not accept what\n \t we have in the delay slot.  We'll fix this up later.  */\n-      if (next_trial && JUMP_P (next_trial)\n-\t  && (simplejump_p (next_trial)\n-\t      || GET_CODE (PATTERN (next_trial)) == RETURN))\n+      if (next_trial && simplejump_or_return_p (next_trial))\n \t{\n \t  rtx target_label = JUMP_LABEL (next_trial);\n \t  if (ANY_RETURN_P (target_label))\n-\t    target_label = find_end_label ();\n+\t    target_label = find_end_label (target_label);\n \n \t  if (target_label)\n \t    {\n@@ -951,7 +969,7 @@ rare_destination (rtx insn)\n \t     return.  */\n \t  return 2;\n \tcase JUMP_INSN:\n-\t  if (GET_CODE (PATTERN (insn)) == RETURN)\n+\t  if (ANY_RETURN_P (PATTERN (insn)))\n \t    return 1;\n \t  else if (simplejump_p (insn)\n \t\t   && jump_count++ < 10)\n@@ -1368,8 +1386,7 @@ steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,\n   /* We can't do anything if SEQ's delay insn isn't an\n      unconditional branch.  */\n \n-  if (! simplejump_p (XVECEXP (seq, 0, 0))\n-      && GET_CODE (PATTERN (XVECEXP (seq, 0, 0))) != RETURN)\n+  if (! simplejump_or_return_p (XVECEXP (seq, 0, 0)))\n     return delay_list;\n \n   for (i = 1; i < XVECLEN (seq, 0); i++)\n@@ -2383,7 +2400,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      if (new_label != 0)\n \t\tnew_label = get_label_before (new_label);\n \t      else\n-\t\tnew_label = find_end_label ();\n+\t\tnew_label = find_end_label (simple_return_rtx);\n \n \t      if (new_label)\n \t        {\n@@ -2515,7 +2532,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \f\n /* Follow any unconditional jump at LABEL;\n    return the ultimate label reached by any such chain of jumps.\n-   Return ret_rtx if the chain ultimately leads to a return instruction.\n+   Return a suitable return rtx if the chain ultimately leads to a\n+   return instruction.\n    If LABEL is not followed by a jump, return LABEL.\n    If the chain loops or we can't find end, return LABEL,\n    since that tells caller to avoid changing the insn.  */\n@@ -2536,7 +2554,7 @@ follow_jumps (rtx label)\n \t&& JUMP_P (insn)\n \t&& JUMP_LABEL (insn) != NULL_RTX\n \t&& ((any_uncondjump_p (insn) && onlyjump_p (insn))\n-\t    || GET_CODE (PATTERN (insn)) == RETURN)\n+\t    || ANY_RETURN_P (PATTERN (insn)))\n \t&& (next = NEXT_INSN (insn))\n \t&& BARRIER_P (next));\n        depth++)\n@@ -3003,16 +3021,14 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \n       gcc_assert (thread_if_true);\n \n-      if (new_thread && JUMP_P (new_thread)\n-\t  && (simplejump_p (new_thread)\n-\t      || GET_CODE (PATTERN (new_thread)) == RETURN)\n+      if (new_thread && simplejump_or_return_p (new_thread)\n \t  && redirect_with_delay_list_safe_p (insn,\n \t\t\t\t\t      JUMP_LABEL (new_thread),\n \t\t\t\t\t      delay_list))\n \tnew_thread = follow_jumps (JUMP_LABEL (new_thread));\n \n       if (ANY_RETURN_P (new_thread))\n-\tlabel = find_end_label ();\n+\tlabel = find_end_label (new_thread);\n       else if (LABEL_P (new_thread))\n \tlabel = new_thread;\n       else\n@@ -3362,7 +3378,7 @@ relax_delay_slots (rtx first)\n \t{\n \t  target_label = skip_consecutive_labels (follow_jumps (target_label));\n \t  if (ANY_RETURN_P (target_label))\n-\t    target_label = find_end_label ();\n+\t    target_label = find_end_label (target_label);\n \n \t  if (target_label && next_active_insn (target_label) == next\n \t      && ! condjump_in_parallel_p (insn))\n@@ -3377,9 +3393,8 @@ relax_delay_slots (rtx first)\n \t  /* See if this jump conditionally branches around an unconditional\n \t     jump.  If so, invert this jump and point it to the target of the\n \t     second jump.  */\n-\t  if (next && JUMP_P (next)\n+\t  if (next && simplejump_or_return_p (next)\n \t      && any_condjump_p (insn)\n-\t      && (simplejump_p (next) || GET_CODE (PATTERN (next)) == RETURN)\n \t      && target_label\n \t      && next_active_insn (target_label) == next_active_insn (next)\n \t      && no_labels_between_p (insn, next))\n@@ -3421,8 +3436,7 @@ relax_delay_slots (rtx first)\n \t Don't do this if we expect the conditional branch to be true, because\n \t we would then be making the more common case longer.  */\n \n-      if (JUMP_P (insn)\n-\t  && (simplejump_p (insn) || GET_CODE (PATTERN (insn)) == RETURN)\n+      if (simplejump_or_return_p (insn)\n \t  && (other = prev_active_insn (insn)) != 0\n \t  && any_condjump_p (other)\n \t  && no_labels_between_p (other, insn)\n@@ -3463,10 +3477,10 @@ relax_delay_slots (rtx first)\n \t Only do so if optimizing for size since this results in slower, but\n \t smaller code.  */\n       if (optimize_function_for_size_p (cfun)\n-\t  && GET_CODE (PATTERN (delay_insn)) == RETURN\n+\t  && ANY_RETURN_P (PATTERN (delay_insn))\n \t  && next\n \t  && JUMP_P (next)\n-\t  && GET_CODE (PATTERN (next)) == RETURN)\n+\t  && PATTERN (next) == PATTERN (delay_insn))\n \t{\n \t  rtx after;\n \t  int i;\n@@ -3505,73 +3519,71 @@ relax_delay_slots (rtx first)\n \tcontinue;\n \n       target_label = JUMP_LABEL (delay_insn);\n+      if (target_label && ANY_RETURN_P (target_label))\n+\tcontinue;\n \n-      if (!ANY_RETURN_P (target_label))\n-\t{\n-\t  /* If this jump goes to another unconditional jump, thread it, but\n-\t     don't convert a jump into a RETURN here.  */\n-\t  trial = skip_consecutive_labels (follow_jumps (target_label));\n-\t  if (ANY_RETURN_P (trial))\n-\t    trial = find_end_label ();\n-\n-\t  if (trial && trial != target_label\n-\t      && redirect_with_delay_slots_safe_p (delay_insn, trial, insn))\n-\t    {\n-\t      reorg_redirect_jump (delay_insn, trial);\n-\t      target_label = trial;\n-\t    }\n+      /* If this jump goes to another unconditional jump, thread it, but\n+\t don't convert a jump into a RETURN here.  */\n+      trial = skip_consecutive_labels (follow_jumps (target_label));\n+      if (ANY_RETURN_P (trial))\n+\ttrial = find_end_label (trial);\n \n-\t  /* If the first insn at TARGET_LABEL is redundant with a previous\n-\t     insn, redirect the jump to the following insn and process again.\n-\t     We use next_real_insn instead of next_active_insn so we\n-\t     don't skip USE-markers, or we'll end up with incorrect\n-\t     liveness info.  */\n-\t  trial = next_real_insn (target_label);\n-\t  if (trial && GET_CODE (PATTERN (trial)) != SEQUENCE\n-\t      && redundant_insn (trial, insn, 0)\n-\t      && ! can_throw_internal (trial))\n-\t    {\n-\t      /* Figure out where to emit the special USE insn so we don't\n-\t\t later incorrectly compute register live/death info.  */\n-\t      rtx tmp = next_active_insn (trial);\n-\t      if (tmp == 0)\n-\t\ttmp = find_end_label ();\n+      if (trial && trial != target_label\n+\t  && redirect_with_delay_slots_safe_p (delay_insn, trial, insn))\n+\t{\n+\t  reorg_redirect_jump (delay_insn, trial);\n+\t  target_label = trial;\n+\t}\n \n-\t      if (tmp)\n-\t        {\n-\t\t  /* Insert the special USE insn and update dataflow info.  */\n-\t\t  update_block (trial, tmp);\n+      /* If the first insn at TARGET_LABEL is redundant with a previous\n+\t insn, redirect the jump to the following insn and process again.\n+\t We use next_real_insn instead of next_active_insn so we\n+\t don't skip USE-markers, or we'll end up with incorrect\n+\t liveness info.  */\n+      trial = next_real_insn (target_label);\n+      if (trial && GET_CODE (PATTERN (trial)) != SEQUENCE\n+\t  && redundant_insn (trial, insn, 0)\n+\t  && ! can_throw_internal (trial))\n+\t{\n+\t  /* Figure out where to emit the special USE insn so we don't\n+\t     later incorrectly compute register live/death info.  */\n+\t  rtx tmp = next_active_insn (trial);\n+\t  if (tmp == 0)\n+\t    tmp = find_end_label (simple_return_rtx);\n \n-\t\t  /* Now emit a label before the special USE insn, and\n-\t\t     redirect our jump to the new label.  */\n-\t\t  target_label = get_label_before (PREV_INSN (tmp));\n-\t\t  reorg_redirect_jump (delay_insn, target_label);\n-\t\t  next = insn;\n-\t\t  continue;\n-\t\t}\n+\t  if (tmp)\n+\t    {\n+\t      /* Insert the special USE insn and update dataflow info.  */\n+\t      update_block (trial, tmp);\n+\t      \n+\t      /* Now emit a label before the special USE insn, and\n+\t\t redirect our jump to the new label.  */\n+\t      target_label = get_label_before (PREV_INSN (tmp));\n+\t      reorg_redirect_jump (delay_insn, target_label);\n+\t      next = insn;\n+\t      continue;\n \t    }\n+\t}\n \n-\t  /* Similarly, if it is an unconditional jump with one insn in its\n-\t     delay list and that insn is redundant, thread the jump.  */\n-\t  if (trial && GET_CODE (PATTERN (trial)) == SEQUENCE\n-\t      && XVECLEN (PATTERN (trial), 0) == 2\n-\t      && JUMP_P (XVECEXP (PATTERN (trial), 0, 0))\n-\t      && (simplejump_p (XVECEXP (PATTERN (trial), 0, 0))\n-\t\t  || GET_CODE (PATTERN (XVECEXP (PATTERN (trial), 0, 0))) == RETURN)\n-\t      && redundant_insn (XVECEXP (PATTERN (trial), 0, 1), insn, 0))\n+      /* Similarly, if it is an unconditional jump with one insn in its\n+\t delay list and that insn is redundant, thread the jump.  */\n+      if (trial && GET_CODE (PATTERN (trial)) == SEQUENCE\n+\t  && XVECLEN (PATTERN (trial), 0) == 2\n+\t  && JUMP_P (XVECEXP (PATTERN (trial), 0, 0))\n+\t  && simplejump_or_return_p (XVECEXP (PATTERN (trial), 0, 0))\n+\t  && redundant_insn (XVECEXP (PATTERN (trial), 0, 1), insn, 0))\n+\t{\n+\t  target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));\n+\t  if (ANY_RETURN_P (target_label))\n+\t    target_label = find_end_label (target_label);\n+\t  \n+\t  if (target_label\n+\t      && redirect_with_delay_slots_safe_p (delay_insn, target_label,\n+\t\t\t\t\t\t   insn))\n \t    {\n-\t      target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));\n-\t      if (ANY_RETURN_P (target_label))\n-\t\ttarget_label = find_end_label ();\n-\n-\t      if (target_label\n-\t          && redirect_with_delay_slots_safe_p (delay_insn, target_label,\n-\t\t\t\t\t\t       insn))\n-\t\t{\n-\t\t  reorg_redirect_jump (delay_insn, target_label);\n-\t\t  next = insn;\n-\t\t  continue;\n-\t\t}\n+\t      reorg_redirect_jump (delay_insn, target_label);\n+\t      next = insn;\n+\t      continue;\n \t    }\n \t}\n \n@@ -3640,16 +3652,15 @@ relax_delay_slots (rtx first)\n \t a RETURN here.  */\n       if (! INSN_ANNULLED_BRANCH_P (delay_insn)\n \t  && any_condjump_p (delay_insn)\n-\t  && next && JUMP_P (next)\n-\t  && (simplejump_p (next) || GET_CODE (PATTERN (next)) == RETURN)\n+\t  && next && simplejump_or_return_p (next)\n \t  && next_active_insn (target_label) == next_active_insn (next)\n \t  && no_labels_between_p (insn, next))\n \t{\n \t  rtx label = JUMP_LABEL (next);\n \t  rtx old_label = JUMP_LABEL (delay_insn);\n \n \t  if (ANY_RETURN_P (label))\n-\t    label = find_end_label ();\n+\t    label = find_end_label (label);\n \n \t  /* find_end_label can generate a new label. Check this first.  */\n \t  if (label\n@@ -3710,7 +3721,8 @@ static void\n make_return_insns (rtx first)\n {\n   rtx insn, jump_insn, pat;\n-  rtx real_return_label = end_of_function_label;\n+  rtx real_return_label = function_return_label;\n+  rtx real_simple_return_label = function_simple_return_label;\n   int slots, i;\n \n #ifdef DELAY_SLOTS_FOR_EPILOGUE\n@@ -3728,44 +3740,63 @@ make_return_insns (rtx first)\n      made for END_OF_FUNCTION_LABEL.  If so, set up anything we can't change\n      into a RETURN to jump to it.  */\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n-    if (JUMP_P (insn) && GET_CODE (PATTERN (insn)) == RETURN)\n+    if (JUMP_P (insn) && ANY_RETURN_P (PATTERN (insn)))\n       {\n-\treal_return_label = get_label_before (insn);\n+\trtx t = get_label_before (insn);\n+\tif (PATTERN (insn) == ret_rtx)\n+\t  real_return_label = t;\n+\telse\n+\t  real_simple_return_label = t;\n \tbreak;\n       }\n \n   /* Show an extra usage of REAL_RETURN_LABEL so it won't go away if it\n      was equal to END_OF_FUNCTION_LABEL.  */\n-  LABEL_NUSES (real_return_label)++;\n+  if (real_return_label)\n+    LABEL_NUSES (real_return_label)++;\n+  if (real_simple_return_label)\n+    LABEL_NUSES (real_simple_return_label)++;\n \n   /* Clear the list of insns to fill so we can use it.  */\n   obstack_free (&unfilled_slots_obstack, unfilled_firstobj);\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       int flags;\n+      rtx kind, real_label;\n \n       /* Only look at filled JUMP_INSNs that go to the end of function\n \t label.  */\n       if (!NONJUMP_INSN_P (insn)\n \t  || GET_CODE (PATTERN (insn)) != SEQUENCE\n-\t  || !JUMP_P (XVECEXP (PATTERN (insn), 0, 0))\n-\t  || JUMP_LABEL (XVECEXP (PATTERN (insn), 0, 0)) != end_of_function_label)\n+\t  || !jump_to_label_p (XVECEXP (PATTERN (insn), 0, 0)))\n+\tcontinue;\n+\n+      if (JUMP_LABEL (XVECEXP (PATTERN (insn), 0, 0)) == function_return_label)\n+\t{\n+\t  kind = ret_rtx;\n+\t  real_label = real_return_label;\n+\t}\n+      else if (JUMP_LABEL (XVECEXP (PATTERN (insn), 0, 0))\n+\t       == function_simple_return_label)\n+\t{\n+\t  kind = simple_return_rtx;\n+\t  real_label = real_simple_return_label;\n+\t}\n+      else\n \tcontinue;\n \n       pat = PATTERN (insn);\n       jump_insn = XVECEXP (pat, 0, 0);\n \n       /* If we can't make the jump into a RETURN, try to redirect it to the best\n \t RETURN and go on to the next insn.  */\n-      if (! reorg_redirect_jump (jump_insn, ret_rtx))\n+      if (!reorg_redirect_jump (jump_insn, kind))\n \t{\n \t  /* Make sure redirecting the jump will not invalidate the delay\n \t     slot insns.  */\n-\t  if (redirect_with_delay_slots_safe_p (jump_insn,\n-\t\t\t\t\t\treal_return_label,\n-\t\t\t\t\t\tinsn))\n-\t    reorg_redirect_jump (jump_insn, real_return_label);\n+\t  if (redirect_with_delay_slots_safe_p (jump_insn, real_label, insn))\n+\t    reorg_redirect_jump (jump_insn, real_label);\n \t  continue;\n \t}\n \n@@ -3805,7 +3836,7 @@ make_return_insns (rtx first)\n \t RETURN, delete the SEQUENCE and output the individual insns,\n \t followed by the RETURN.  Then set things up so we try to find\n \t insns for its delay slots, if it needs some.  */\n-      if (GET_CODE (PATTERN (jump_insn)) == RETURN)\n+      if (ANY_RETURN_P (PATTERN (jump_insn)))\n \t{\n \t  rtx prev = PREV_INSN (insn);\n \n@@ -3822,13 +3853,16 @@ make_return_insns (rtx first)\n       else\n \t/* It is probably more efficient to keep this with its current\n \t   delay slot as a branch to a RETURN.  */\n-\treorg_redirect_jump (jump_insn, real_return_label);\n+\treorg_redirect_jump (jump_insn, real_label);\n     }\n \n   /* Now delete REAL_RETURN_LABEL if we never used it.  Then try to fill any\n      new delay slots we have created.  */\n-  if (--LABEL_NUSES (real_return_label) == 0)\n+  if (real_return_label != NULL_RTX && --LABEL_NUSES (real_return_label) == 0)\n     delete_related_insns (real_return_label);\n+  if (real_simple_return_label != NULL_RTX\n+      && --LABEL_NUSES (real_simple_return_label) == 0)\n+    delete_related_insns (real_simple_return_label);\n \n   fill_simple_delay_slots (1);\n   fill_simple_delay_slots (0);\n@@ -3842,6 +3876,7 @@ dbr_schedule (rtx first)\n {\n   rtx insn, next, epilogue_insn = 0;\n   int i;\n+  bool need_return_insns;\n \n   /* If the current function has no insns other than the prologue and\n      epilogue, then do not try to fill any delay slots.  */\n@@ -3897,7 +3932,7 @@ dbr_schedule (rtx first)\n   init_resource_info (epilogue_insn);\n \n   /* Show we haven't computed an end-of-function label yet.  */\n-  end_of_function_label = 0;\n+  function_return_label = function_simple_return_label = NULL_RTX;\n \n   /* Initialize the statistics for this function.  */\n   memset (num_insns_needing_delays, 0, sizeof num_insns_needing_delays);\n@@ -3919,13 +3954,21 @@ dbr_schedule (rtx first)\n   /* If we made an end of function label, indicate that it is now\n      safe to delete it by undoing our prior adjustment to LABEL_NUSES.\n      If it is now unused, delete it.  */\n-  if (end_of_function_label && --LABEL_NUSES (end_of_function_label) == 0)\n-    delete_related_insns (end_of_function_label);\n+  if (function_return_label && --LABEL_NUSES (function_return_label) == 0)\n+    delete_related_insns (function_return_label);\n+  if (function_simple_return_label\n+      && --LABEL_NUSES (function_simple_return_label) == 0)\n+    delete_related_insns (function_simple_return_label);\n \n+  need_return_insns = false;\n #ifdef HAVE_return\n-  if (HAVE_return && end_of_function_label != 0)\n-    make_return_insns (first);\n+  need_return_insns |= HAVE_return && function_return_label != 0;\n+#endif\n+#ifdef HAVE_simple_return\n+  need_return_insns |= HAVE_simple_return && function_simple_return_label != 0;\n #endif\n+  if (need_return_insns)\n+    make_return_insns (first);\n \n   /* Delete any USE insns made by update_block; subsequent passes don't need\n      them or know how to deal with them.  */"}, {"sha": "1a8cb1be4944a5c4a6816b9f5d5b38569dc8eb42", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -492,7 +492,7 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t  if (jump_count++ < 10)\n \t    {\n \t      if (any_uncondjump_p (this_jump_insn)\n-\t\t  || GET_CODE (PATTERN (this_jump_insn)) == RETURN)\n+\t\t  || ANY_RETURN_P (PATTERN (this_jump_insn)))\n \t\t{\n \t\t  next = JUMP_LABEL (this_jump_insn);\n \t\t  if (ANY_RETURN_P (next))\n@@ -829,7 +829,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n static bool\n return_insn_p (const_rtx insn)\n {\n-  if (JUMP_P (insn) && GET_CODE (PATTERN (insn)) == RETURN)\n+  if (JUMP_P (insn) && ANY_RETURN_P (PATTERN (insn)))\n     return true;\n \n   if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)"}, {"sha": "0e11eeffa090ae1a1bc8b4715aa9abb87342b767", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -256,6 +256,7 @@ copy_rtx (rtx orig)\n     case PC:\n     case CC0:\n     case RETURN:\n+    case SIMPLE_RETURN:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return orig;"}, {"sha": "b098123cc592b39abc90b87b891c0e572cf54b6b", "filename": "gcc/rtl.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -296,6 +296,12 @@ DEF_RTL_EXPR(CALL, \"call\", \"ee\", RTX_EXTRA)\n \n DEF_RTL_EXPR(RETURN, \"return\", \"\", RTX_EXTRA)\n \n+/* Like RETURN, but truly represents only a function return, while\n+   RETURN may represent an insn that also performs other functions\n+   of the function epilogue.  Like RETURN, this may also occur in\n+   conditional jumps.  */\n+DEF_RTL_EXPR(SIMPLE_RETURN, \"simple_return\", \"\", RTX_EXTRA)\n+\n /* Special for EH return from subroutine.  */\n \n DEF_RTL_EXPR(EH_RETURN, \"eh_return\", \"\", RTX_EXTRA)"}, {"sha": "860f6c47af274272fa2c2a4875d83752dd898a3a", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -432,8 +432,9 @@ struct GTY((variable_size)) rtvec_def {\n   (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \\\n \t\t     GET_CODE (PATTERN (INSN)) == ADDR_DIFF_VEC))\n \n-/* Predicate yielding nonzero iff X is a return.  */\n-#define ANY_RETURN_P(X) ((X) == ret_rtx)\n+/* Predicate yielding nonzero iff X is a return or simple_return.  */\n+#define ANY_RETURN_P(X) \\\n+  (GET_CODE (X) == RETURN || GET_CODE (X) == SIMPLE_RETURN)\n \n /* 1 if X is a unary operator.  */\n \n@@ -2111,6 +2112,7 @@ enum global_rtl_index\n   GR_PC,\n   GR_CC0,\n   GR_RETURN,\n+  GR_SIMPLE_RETURN,\n   GR_STACK_POINTER,\n   GR_FRAME_POINTER,\n /* For register elimination to work properly these hard_frame_pointer_rtx,\n@@ -2206,6 +2208,7 @@ extern struct target_rtl *this_target_rtl;\n /* Standard pieces of rtx, to be substituted directly into things.  */\n #define pc_rtx                  (global_rtl[GR_PC])\n #define ret_rtx                 (global_rtl[GR_RETURN])\n+#define simple_return_rtx       (global_rtl[GR_SIMPLE_RETURN])\n #define cc0_rtx                 (global_rtl[GR_CC0])\n \n /* All references to certain hard regs, except those created"}, {"sha": "8c15788eecdfa5b80a8a17631016eb6ac23935c5", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268987713c7105c691f4efaf82a3f1f4ec394b07/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=268987713c7105c691f4efaf82a3f1f4ec394b07", "patch": "@@ -554,6 +554,9 @@ print_pattern (char *buf, const_rtx x, int verbose)\n     case RETURN:\n       sprintf (buf, \"return\");\n       break;\n+    case SIMPLE_RETURN:\n+      sprintf (buf, \"simple_return\");\n+      break;\n     case CALL:\n       print_exp (buf, x, verbose);\n       break;"}]}