{"sha": "a923a4639434f9c845db002c8445e61cf5dda545", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkyM2E0NjM5NDM0ZjljODQ1ZGIwMDJjODQ0NWU2MWNmNWRkYTU0NQ==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2019-09-19T01:19:25Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2019-09-19T01:19:25Z"}, "message": "RISC-V: Fix more splitters accidentally calling gen_reg_rtx.\n\n\tPR target/91683\n\t* config/riscv/riscv-protos.h (riscv_split_symbol): New bool parameter.\n\t(riscv_move_integer): Likewise.\n\t* config/riscv/riscv.c (riscv_split_integer): Pass FALSE for new\n\triscv_move_integer arg.\n\t(riscv_legitimize_move): Likewise.\n\t(riscv_force_temporary): New parameter in_splitter.  Don't call\n\tforce_reg if true.\n\t(riscv_unspec_offset_high): Pass FALSE for new riscv_force_temporary\n\targ.\n\t(riscv_add_offset): Likewise.\n\t(riscv_split_symbol): New parameter in_splitter.  Pass to\n\triscv_force_temporary.\n\t(riscv_legitimize_address): Pass FALSE for new riscv_split_symbol\n\targ.\n\t(riscv_move_integer): New parameter in_splitter.  New local\n\tcan_create_psuedo.  Don't call riscv_split_integer or force_reg when\n\tin_splitter TRUE.\n\t(riscv_legitimize_const_move): Pass FALSE for new riscv_move_integer,\n\triscv_split_symbol, and riscv_force_temporary args.\n\t* config/riscv/riscv.md (low<mode>+1): Pass TRUE for new\n\triscv_move_integer arg.\n\t(low<mode>+2): Pass TRUE for new riscv_split_symbol arg.\n\nFrom-SVN: r275925", "tree": {"sha": "a415e74fb15947219c655855682ab242b64a1df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a415e74fb15947219c655855682ab242b64a1df2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a923a4639434f9c845db002c8445e61cf5dda545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a923a4639434f9c845db002c8445e61cf5dda545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a923a4639434f9c845db002c8445e61cf5dda545", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a923a4639434f9c845db002c8445e61cf5dda545/comments", "author": null, "committer": null, "parents": [{"sha": "b9a7fd9bde14693e949d744146ab3e9bd8a05f21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a7fd9bde14693e949d744146ab3e9bd8a05f21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a7fd9bde14693e949d744146ab3e9bd8a05f21"}], "stats": {"total": 82, "additions": 59, "deletions": 23}, "files": [{"sha": "051093341ec9a14c5daca4edbbe7d1b8b052ef5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a923a4639434f9c845db002c8445e61cf5dda545", "patch": "@@ -1,3 +1,29 @@\n+2019-09-18  Jim Wilson  <jimw@sifive.com>\n+\n+\tPR target/91683\n+\t* config/riscv/riscv-protos.h (riscv_split_symbol): New bool parameter.\n+\t(riscv_move_integer): Likewise.\n+\t* config/riscv/riscv.c (riscv_split_integer): Pass FALSE for new\n+\triscv_move_integer arg.\n+\t(riscv_legitimize_move): Likewise.\n+\t(riscv_force_temporary): New parameter in_splitter.  Don't call\n+\tforce_reg if true.\n+\t(riscv_unspec_offset_high): Pass FALSE for new riscv_force_temporary\n+\targ.\n+\t(riscv_add_offset): Likewise.\n+\t(riscv_split_symbol): New parameter in_splitter.  Pass to\n+\triscv_force_temporary.\n+\t(riscv_legitimize_address): Pass FALSE for new riscv_split_symbol\n+\targ.\n+\t(riscv_move_integer): New parameter in_splitter.  New local\n+\tcan_create_psuedo.  Don't call riscv_split_integer or force_reg when\n+\tin_splitter TRUE.\n+\t(riscv_legitimize_const_move): Pass FALSE for new riscv_move_integer,\n+\triscv_split_symbol, and riscv_force_temporary args.\n+\t* config/riscv/riscv.md (low<mode>+1): Pass TRUE for new\n+\triscv_move_integer arg.\n+\t(low<mode>+2): Pass TRUE for new riscv_split_symbol arg.\n+\n 2019-09-18  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/90878"}, {"sha": "5092294803cd5dcc274f87d361ece3b87727026e", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=a923a4639434f9c845db002c8445e61cf5dda545", "patch": "@@ -44,10 +44,10 @@ extern int riscv_const_insns (rtx);\n extern int riscv_split_const_insns (rtx);\n extern int riscv_load_store_insns (rtx, rtx_insn *);\n extern rtx riscv_emit_move (rtx, rtx);\n-extern bool riscv_split_symbol (rtx, rtx, machine_mode, rtx *);\n+extern bool riscv_split_symbol (rtx, rtx, machine_mode, rtx *, bool);\n extern bool riscv_split_symbol_type (enum riscv_symbol_type);\n extern rtx riscv_unspec_address (rtx, enum riscv_symbol_type);\n-extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT, machine_mode);\n+extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT, machine_mode, bool);\n extern bool riscv_legitimize_move (machine_mode, rtx, rtx);\n extern rtx riscv_subword (rtx, bool);\n extern bool riscv_split_64bit_move_p (rtx, rtx);"}, {"sha": "b8a8778b92c62321bf0a752b211d266046c46591", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=a923a4639434f9c845db002c8445e61cf5dda545", "patch": "@@ -508,8 +508,8 @@ riscv_split_integer (HOST_WIDE_INT val, machine_mode mode)\n   unsigned HOST_WIDE_INT hival = sext_hwi ((val - loval) >> 32, 32);\n   rtx hi = gen_reg_rtx (mode), lo = gen_reg_rtx (mode);\n \n-  riscv_move_integer (hi, hi, hival, mode);\n-  riscv_move_integer (lo, lo, loval, mode);\n+  riscv_move_integer (hi, hi, hival, mode, FALSE);\n+  riscv_move_integer (lo, lo, loval, mode, FALSE);\n \n   hi = gen_rtx_fmt_ee (ASHIFT, mode, hi, GEN_INT (32));\n   hi = force_reg (mode, hi);\n@@ -1021,9 +1021,12 @@ riscv_force_binary (machine_mode mode, enum rtx_code code, rtx x, rtx y)\n    are allowed, copy it into a new register, otherwise use DEST.  */\n \n static rtx\n-riscv_force_temporary (rtx dest, rtx value)\n+riscv_force_temporary (rtx dest, rtx value, bool in_splitter)\n {\n-  if (can_create_pseudo_p ())\n+  /* We can't call gen_reg_rtx from a splitter, because this might realloc\n+     the regno_reg_rtx array, which would invalidate reg rtx pointers in the\n+     combine undo buffer.  */\n+  if (can_create_pseudo_p () && !in_splitter)\n     return force_reg (Pmode, value);\n   else\n     {\n@@ -1082,7 +1085,7 @@ static rtx\n riscv_unspec_offset_high (rtx temp, rtx addr, enum riscv_symbol_type symbol_type)\n {\n   addr = gen_rtx_HIGH (Pmode, riscv_unspec_address (addr, symbol_type));\n-  return riscv_force_temporary (temp, addr);\n+  return riscv_force_temporary (temp, addr, FALSE);\n }\n \n /* Load an entry from the GOT for a TLS GD access.  */\n@@ -1130,7 +1133,8 @@ static rtx riscv_tls_add_tp_le (rtx dest, rtx base, rtx sym)\n    is guaranteed to be a legitimate address for mode MODE.  */\n \n bool\n-riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)\n+riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out,\n+\t\t    bool in_splitter)\n {\n   enum riscv_symbol_type symbol_type;\n \n@@ -1146,7 +1150,7 @@ riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)\n       case SYMBOL_ABSOLUTE:\n \t{\n \t  rtx high = gen_rtx_HIGH (Pmode, copy_rtx (addr));\n-\t  high = riscv_force_temporary (temp, high);\n+\t  high = riscv_force_temporary (temp, high, in_splitter);\n \t  *low_out = gen_rtx_LO_SUM (Pmode, high, addr);\n \t}\n \tbreak;\n@@ -1205,8 +1209,9 @@ riscv_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)\n \t overflow, so we need to force a sign-extension check.  */\n       high = gen_int_mode (CONST_HIGH_PART (offset), Pmode);\n       offset = CONST_LOW_PART (offset);\n-      high = riscv_force_temporary (temp, high);\n-      reg = riscv_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg));\n+      high = riscv_force_temporary (temp, high, FALSE);\n+      reg = riscv_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg),\n+\t\t\t\t   FALSE);\n     }\n   return plus_constant (Pmode, reg, offset);\n }\n@@ -1315,7 +1320,7 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     return riscv_legitimize_tls_address (x);\n \n   /* See if the address can split into a high part and a LO_SUM.  */\n-  if (riscv_split_symbol (NULL, x, mode, &addr))\n+  if (riscv_split_symbol (NULL, x, mode, &addr, FALSE))\n     return riscv_force_address (addr, mode);\n \n   /* Handle BASE + OFFSET using riscv_add_offset.  */\n@@ -1339,19 +1344,24 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \n void\n riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value,\n-\t\t    machine_mode orig_mode)\n+\t\t    machine_mode orig_mode, bool in_splitter)\n {\n   struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS];\n   machine_mode mode;\n   int i, num_ops;\n   rtx x;\n \n+  /* We can't call gen_reg_rtx from a splitter, because this might realloc\n+     the regno_reg_rtx array, which would invalidate reg rtx pointers in the\n+     combine undo buffer.  */\n+  bool can_create_pseudo = can_create_pseudo_p () && ! in_splitter;\n+\n   mode = GET_MODE (dest);\n   /* We use the original mode for the riscv_build_integer call, because HImode\n      values are given special treatment.  */\n   num_ops = riscv_build_integer (codes, value, orig_mode);\n \n-  if (can_create_pseudo_p () && num_ops > 2 /* not a simple constant */\n+  if (can_create_pseudo && num_ops > 2 /* not a simple constant */\n       && num_ops >= riscv_split_integer_cost (value))\n     x = riscv_split_integer (value, mode);\n   else\n@@ -1361,7 +1371,7 @@ riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value,\n \n       for (i = 1; i < num_ops; i++)\n \t{\n-\t  if (!can_create_pseudo_p ())\n+\t  if (!can_create_pseudo)\n \t    x = riscv_emit_set (temp, x);\n \t  else\n \t    x = force_reg (mode, x);\n@@ -1385,12 +1395,12 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n   /* Split moves of big integers into smaller pieces.  */\n   if (splittable_const_int_operand (src, mode))\n     {\n-      riscv_move_integer (dest, dest, INTVAL (src), mode);\n+      riscv_move_integer (dest, dest, INTVAL (src), mode, FALSE);\n       return;\n     }\n \n   /* Split moves of symbolic constants into high/low pairs.  */\n-  if (riscv_split_symbol (dest, src, MAX_MACHINE_MODE, &src))\n+  if (riscv_split_symbol (dest, src, MAX_MACHINE_MODE, &src, FALSE))\n     {\n       riscv_emit_set (dest, src);\n       return;\n@@ -1411,7 +1421,7 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n   if (offset != const0_rtx\n       && (targetm.cannot_force_const_mem (mode, src) || can_create_pseudo_p ()))\n     {\n-      base = riscv_force_temporary (dest, base);\n+      base = riscv_force_temporary (dest, base, FALSE);\n       riscv_emit_move (dest, riscv_add_offset (NULL, base, INTVAL (offset)));\n       return;\n     }\n@@ -1420,7 +1430,7 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n \n   /* When using explicit relocs, constant pool references are sometimes\n      not legitimate addresses.  */\n-  riscv_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0));\n+  riscv_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0), FALSE);\n   riscv_emit_move (dest, src);\n }\n \n@@ -1446,7 +1456,7 @@ riscv_legitimize_move (machine_mode mode, rtx dest, rtx src)\n \t  if (splittable_const_int_operand (src, mode))\n \t    {\n \t      reg = gen_reg_rtx (promoted_mode);\n-\t      riscv_move_integer (reg, reg, INTVAL (src), mode);\n+\t      riscv_move_integer (reg, reg, INTVAL (src), mode, FALSE);\n \t    }\n \t  else\n \t    reg = force_reg (promoted_mode, src);"}, {"sha": "d3c8f65974877e17631f2eaeef7380e066846986", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a923a4639434f9c845db002c8445e61cf5dda545/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=a923a4639434f9c845db002c8445e61cf5dda545", "patch": "@@ -1285,7 +1285,7 @@\n   [(const_int 0)]\n {\n   riscv_move_integer (operands[2], operands[0], INTVAL (operands[1]),\n-\t\t      <GPR:MODE>mode);\n+\t\t      <GPR:MODE>mode, TRUE);\n   DONE;\n })\n \n@@ -1294,11 +1294,11 @@\n   [(set (match_operand:P 0 \"register_operand\")\n \t(match_operand:P 1))\n    (clobber (match_operand:P 2 \"register_operand\"))]\n-  \"riscv_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL)\"\n+  \"riscv_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL, TRUE)\"\n   [(set (match_dup 0) (match_dup 3))]\n {\n   riscv_split_symbol (operands[2], operands[1],\n-\t\t     MAX_MACHINE_MODE, &operands[3]);\n+\t\t      MAX_MACHINE_MODE, &operands[3], TRUE);\n })\n \n ;; 64-bit integer moves"}]}