{"sha": "e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBmNjlmMzZlYTFlMDY4Y2I5YWE0OGVhMGQyNzRiOTg1MzBmMjQ4OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-06T00:36:33Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-06T00:36:33Z"}, "message": "libgo: change build procedure to use build tags\n    \n    Previously the libgo Makefile explicitly listed the set of files to\n    compile for each package.  For packages that use build tags, this\n    required a lot of awkward automake conditionals in the Makefile.\n    \n    This CL changes the build to look at the build tags in the files.\n    The new shell script libgo/match.sh does the matching.  This required\n    adjusting a lot of build tags, and removing some files that are never\n    used.  I verified that the exact same sets of files are compiled on\n    amd64 GNU/Linux.  I also tested the build on i386 Solaris.\n    \n    Writing match.sh revealed some bugs in the build tag handling that\n    already exists, in a slightly different form, in the gotest shell\n    script.  This CL fixes those problems as well.\n    \n    The old code used automake conditionals to handle systems that were\n    missing strerror_r and wait4.  Rather than deal with those in Go, those\n    functions are now implemented in runtime/go-nosys.c when necessary, so\n    the Go code can simply assume that they exist.\n    \n    The os testsuite looked for dir_unix.go, which was never built for gccgo\n    and has now been removed.  I changed the testsuite to look for dir.go\n    instead.\n    \n    Reviewed-on: https://go-review.googlesource.com/25546\n\nFrom-SVN: r239189", "tree": {"sha": "8925fdf222aa5a7635a6eb748602b694043eafb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8925fdf222aa5a7635a6eb748602b694043eafb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/comments", "author": null, "committer": null, "parents": [{"sha": "d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3"}], "stats": {"total": 7017, "additions": 1165, "deletions": 5852}, "files": [{"sha": "185d9e9d678d26c732f3be44e4230545c5457c8b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -1,4 +1,4 @@\n-ae44ca35b0b1c2ab925cadbcd7d47b334be5a318\n+8473b709ebd46c03c0e36e140656bd8c5d32d883\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "8c4022d3afedd672925e4dc94fb4caaa8db9427f", "filename": "libgo/Makefile.am", "status": "modified", "additions": 364, "deletions": 1931, "changes": 2295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488"}, {"sha": "be0798ffb0670611f8bba7c72a002665b55f5699", "filename": "libgo/Makefile.in", "status": "modified", "additions": 388, "deletions": 1673, "changes": 2061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488"}, {"sha": "b59e8671006ba9d6f2087514aca0d3ee3ac55475", "filename": "libgo/go/crypto/aes/aes_gcm.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64\n+// +build ignore\n+// -build amd64\n \n package aes\n "}, {"sha": "22769b9eef0425a97d5a4e9c4d35deb09da3824d", "filename": "libgo/go/crypto/aes/cipher_amd64.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package aes\n \n import ("}, {"sha": "2c8d299c88028cea9aafb95bb24389c8a419986c", "filename": "libgo/go/crypto/aes/cipher_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!s390x\n+// -build !amd64,!s390x\n \n package aes\n "}, {"sha": "c9d60e905954502636fe884a0f3e239384ff97aa", "filename": "libgo/go/crypto/aes/cipher_s390x.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package aes\n \n import ("}, {"sha": "688e0b412e0e3a395bfcd354d82b5893f5d25717", "filename": "libgo/go/crypto/elliptic/p256.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64\n+// -build !amd64\n \n package elliptic\n "}, {"sha": "8f3db0718b35356065526ceb5b076ec8abdf4059", "filename": "libgo/go/crypto/elliptic/p256_amd64.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_amd64.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -10,6 +10,7 @@\n // http://link.springer.com/article/10.1007%2Fs13389-014-0090-x\n // https://eprint.iacr.org/2013/816.pdf\n \n+// +build ignore\n // +build amd64\n \n package elliptic"}, {"sha": "4de38cf822afb06e9be6e64ee173f86460ca9615", "filename": "libgo/go/crypto/md5/md5block_decl.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 amd64p32 386 arm ppc64le s390x\n+// +build ignore\n+// -build amd64 amd64p32 386 arm ppc64le s390x\n \n package md5\n "}, {"sha": "c23d02b8d408e1acf52d21604c4037031e53919f", "filename": "libgo/go/crypto/md5/md5block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!amd64p32,!386,!arm,!ppc64le,!s390x\n+// -build !amd64,!amd64p32,!386,!arm,!ppc64le,!s390x\n \n package md5\n "}, {"sha": "687ea237fcdce64052253cdc40ee0250d8322a57", "filename": "libgo/go/crypto/rc4/rc4_asm.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // +build amd64 amd64p32 arm,!nacl 386\n \n package rc4"}, {"sha": "bf56b51db9a55fa5e8ac086bcaf307780e8e4c65", "filename": "libgo/go/crypto/rc4/rc4_ref.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!amd64p32,!arm,!386 arm,nacl\n+// -build !amd64,!amd64p32,!arm,!386 arm,nacl\n \n package rc4\n "}, {"sha": "a47b3f404474c8cee97436983ddab95acfa4ef2e", "filename": "libgo/go/crypto/sha1/fallback_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Ffallback_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Ffallback_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Ffallback_test.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n // +build s390x\n \n package sha1"}, {"sha": "95d89a755f810b7c04b63a3c3c452fe95c1af582", "filename": "libgo/go/crypto/sha1/sha1block_amd64.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package sha1\n \n //go:noescape"}, {"sha": "bb18cbf73469c7febd5b1c8afea466f58949514e", "filename": "libgo/go/crypto/sha1/sha1block_decl.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n // +build amd64p32 arm 386 s390x\n \n package sha1"}, {"sha": "e7515c915a78f27d409fb6281bb6eb0b64e3db5f", "filename": "libgo/go/crypto/sha1/sha1block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_generic.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!amd64p32,!386,!arm,!s390x\n+// -build !amd64,!amd64p32,!386,!arm,!s390x\n \n package sha1\n "}, {"sha": "9edcbb0d4b4399984cd2fadcda2e75dc6226843a", "filename": "libgo/go/crypto/sha1/sha1block_s390x.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package sha1\n \n // featureCheck reports whether the CPU supports the"}, {"sha": "eca42c245d8905124e1e243b34dc8cf7d55af4bc", "filename": "libgo/go/crypto/sha256/sha256block_decl.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n // +build 386 amd64 s390x\n \n package sha256"}, {"sha": "d7d78fd51b390eb89abe8bd939c6847e1c519e3c", "filename": "libgo/go/crypto/sha256/sha256block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!386,!s390x\n+// -build !amd64,!386,!s390x\n \n package sha256\n "}, {"sha": "8e5f69d4e5b7831df675ade71b30f50515bb3859", "filename": "libgo/go/crypto/sha256/sha256block_s390x.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_s390x.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package sha256\n \n // featureCheck reports whether the CPU supports the"}, {"sha": "14081318ad11ea3ed4c5ebfb7a496ddf77ea892a", "filename": "libgo/go/crypto/sha512/fallback_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Ffallback_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Ffallback_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Ffallback_test.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n // +build s390x\n \n package sha512"}, {"sha": "1c8f66eb96badb0fbd2462269555b5b91e9b1d36", "filename": "libgo/go/crypto/sha512/sha512block_decl.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 s390x\n+// +build ignore\n+// -build amd64 s390x\n \n package sha512\n "}, {"sha": "67ac94812f00f8e06521c6f8afa2507b6c4b1722", "filename": "libgo/go/crypto/sha512/sha512block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!s390x\n+// -build !amd64,!s390x\n \n package sha512\n "}, {"sha": "26896fcec4c4c73b07111cdd6c02e7976dba3bca", "filename": "libgo/go/crypto/sha512/sha512block_s390x.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_s390x.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package sha512\n \n // featureCheck reports whether the CPU supports the"}, {"sha": "8eae850bbf3ab85f803c0eaaa1cbe364da8a0994", "filename": "libgo/go/hash/crc32/crc32_amd64.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_amd64.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package crc32\n \n // This file contains the code to call the SSE 4.2 version of the Castagnoli"}, {"sha": "e9096cef7863e18d7399a9aa5850cdd27892e282", "filename": "libgo/go/hash/crc32/crc32_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_generic.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!amd64p32,!s390x\n+// -build !amd64,!amd64p32,!s390x\n \n package crc32\n "}, {"sha": "48963b4350b42382ea375880e8d6aa416f61c4fa", "filename": "libgo/go/log/syslog/syslog_libc.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_libc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_libc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_libc.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build solaris irix\n+\n // gccgo specific implementation of syslog for Solaris.  Solaris uses\n // STREAMS to communicate with syslogd.  That is enough of a pain that\n // we just call the libc function."}, {"sha": "356b98d18ed49aacadcc6788ed2cc39e3400ce53", "filename": "libgo/go/log/syslog/syslog_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !windows,!nacl,!plan9\n+// +build !windows,!nacl,!plan9,!solaris,!irix\n \n package syslog\n "}, {"sha": "553883394f0e195c45b52ed0324bf9402dc26ee8", "filename": "libgo/go/math/big/arith_decl.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n // +build !math_big_pure_go\n \n package big"}, {"sha": "5c04414b06663e8f48ab2443dc6f1f1c6f07aea7", "filename": "libgo/go/math/big/arith_decl_pure.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl_pure.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl_pure.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl_pure.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build math_big_pure_go\n+// -build math_big_pure_go\n \n package big\n "}, {"sha": "9a2487af3e8465390d67975ab76bf65695f24bf6", "filename": "libgo/go/math/floor_asm.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fmath%2Ffloor_asm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fmath%2Ffloor_asm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ffloor_asm.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 amd64p32\n+// +build ignore\n+// -build amd64 amd64p32\n \n package math\n "}, {"sha": "4103c57e2cbacfe22c73364ed0a069e2a4b1ea8e", "filename": "libgo/go/net/fd_select.go", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fnet%2Ffd_select.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fnet%2Ffd_select.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_select.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,182 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Waiting for FDs via select(2).\n-\n-package net\n-\n-import (\n-\t\"errors\"\n-\t\"os\"\n-\t\"syscall\"\n-)\n-\n-type pollster struct {\n-\treadFds, writeFds, repeatFds *syscall.FdSet\n-\tmaxFd                        int\n-\treadyReadFds, readyWriteFds  *syscall.FdSet\n-\tnReady                       int\n-\tlastFd                       int\n-\tclosed                       bool\n-}\n-\n-func newpollster() (p *pollster, err error) {\n-\tp = new(pollster)\n-\tp.readFds = new(syscall.FdSet)\n-\tp.writeFds = new(syscall.FdSet)\n-\tp.repeatFds = new(syscall.FdSet)\n-\tp.readyReadFds = new(syscall.FdSet)\n-\tp.readyWriteFds = new(syscall.FdSet)\n-\tp.maxFd = -1\n-\tp.nReady = 0\n-\tp.lastFd = 0\n-\treturn p, nil\n-}\n-\n-func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n-\t// pollServer is locked.\n-\n-\tif p.closed {\n-\t\treturn false, errors.New(\"pollster closed\")\n-\t}\n-\n-\tif mode == 'r' {\n-\t\tsyscall.FDSet(fd, p.readFds)\n-\t} else {\n-\t\tsyscall.FDSet(fd, p.writeFds)\n-\t}\n-\n-\tif repeat {\n-\t\tsyscall.FDSet(fd, p.repeatFds)\n-\t}\n-\n-\tif fd > p.maxFd {\n-\t\tp.maxFd = fd\n-\t}\n-\n-\treturn true, nil\n-}\n-\n-func (p *pollster) DelFD(fd int, mode int) bool {\n-\t// pollServer is locked.\n-\n-\tif p.closed {\n-\t\treturn false\n-\t}\n-\n-\tif mode == 'r' {\n-\t\tif !syscall.FDIsSet(fd, p.readFds) {\n-\t\t\tprint(\"Select unexpected fd=\", fd, \" for read\\n\")\n-\t\t\treturn false\n-\t\t}\n-\t\tsyscall.FDClr(fd, p.readFds)\n-\t} else {\n-\t\tif !syscall.FDIsSet(fd, p.writeFds) {\n-\t\t\tprint(\"Select unexpected fd=\", fd, \" for write\\n\")\n-\t\t\treturn false\n-\t\t}\n-\t\tsyscall.FDClr(fd, p.writeFds)\n-\t}\n-\n-\t// Doesn't matter if not already present.\n-\tsyscall.FDClr(fd, p.repeatFds)\n-\n-\t// We don't worry about maxFd here.\n-\n-\treturn true\n-}\n-\n-func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err error) {\n-\tif p.nReady == 0 {\n-\t\tvar timeout *syscall.Timeval\n-\t\tvar tv syscall.Timeval\n-\t\ttimeout = nil\n-\t\tif nsec > 0 {\n-\t\t\ttv = syscall.NsecToTimeval(nsec)\n-\t\t\ttimeout = &tv\n-\t\t}\n-\n-\t\tvar n int\n-\t\tvar e error\n-\t\tvar tmpReadFds, tmpWriteFds syscall.FdSet\n-\t\tfor {\n-\t\t\tif p.closed {\n-\t\t\t\treturn -1, 0, errors.New(\"pollster closed\")\n-\t\t\t}\n-\n-\t\t\t// Temporary syscall.FdSet's into which the values are copied\n-\t\t\t// because select mutates the values.\n-\t\t\ttmpReadFds = *p.readFds\n-\t\t\ttmpWriteFds = *p.writeFds\n-\n-\t\t\ts.Unlock()\n-\t\t\tn, e = syscall.Select(p.maxFd+1, &tmpReadFds, &tmpWriteFds, nil, timeout)\n-\t\t\ts.Lock()\n-\n-\t\t\tif e != syscall.EINTR {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif e == syscall.EBADF {\n-\t\t\t// Some file descriptor has been closed.\n-\t\t\ttmpReadFds = syscall.FdSet{}\n-\t\t\ttmpWriteFds = syscall.FdSet{}\n-\t\t\tn = 0\n-\t\t\tfor i := 0; i < p.maxFd+1; i++ {\n-\t\t\t\tif syscall.FDIsSet(i, p.readFds) {\n-\t\t\t\t\tvar s syscall.Stat_t\n-\t\t\t\t\tif syscall.Fstat(i, &s) == syscall.EBADF {\n-\t\t\t\t\t\tsyscall.FDSet(i, &tmpReadFds)\n-\t\t\t\t\t\tn++\n-\t\t\t\t\t}\n-\t\t\t\t} else if syscall.FDIsSet(i, p.writeFds) {\n-\t\t\t\t\tvar s syscall.Stat_t\n-\t\t\t\t\tif syscall.Fstat(i, &s) == syscall.EBADF {\n-\t\t\t\t\t\tsyscall.FDSet(i, &tmpWriteFds)\n-\t\t\t\t\t\tn++\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if e != nil {\n-\t\t\treturn -1, 0, os.NewSyscallError(\"select\", e)\n-\t\t}\n-\t\tif n == 0 {\n-\t\t\treturn -1, 0, nil\n-\t\t}\n-\n-\t\tp.nReady = n\n-\t\t*p.readyReadFds = tmpReadFds\n-\t\t*p.readyWriteFds = tmpWriteFds\n-\t\tp.lastFd = 0\n-\t}\n-\n-\tflag := false\n-\tfor i := p.lastFd; i < p.maxFd+1; i++ {\n-\t\tif syscall.FDIsSet(i, p.readyReadFds) {\n-\t\t\tflag = true\n-\t\t\tmode = 'r'\n-\t\t\tsyscall.FDClr(i, p.readyReadFds)\n-\t\t} else if syscall.FDIsSet(i, p.readyWriteFds) {\n-\t\t\tflag = true\n-\t\t\tmode = 'w'\n-\t\t\tsyscall.FDClr(i, p.readyWriteFds)\n-\t\t}\n-\t\tif flag {\n-\t\t\tif !syscall.FDIsSet(i, p.repeatFds) {\n-\t\t\t\tp.DelFD(i, mode)\n-\t\t\t}\n-\t\t\tp.nReady--\n-\t\t\tp.lastFd = i\n-\t\t\treturn i, mode, nil\n-\t\t}\n-\t}\n-\n-\t// Will not reach here.  Just to shut up the compiler.\n-\treturn -1, 0, nil\n-}\n-\n-func (p *pollster) Close() error {\n-\tp.closed = true\n-\treturn nil\n-}"}, {"sha": "2add81467b93a3e965bfb1a451b3df078f953a26", "filename": "libgo/go/net/newpollserver_rtems.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fnet%2Fnewpollserver_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fnet%2Fnewpollserver_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnewpollserver_rtems.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build rtems\n+\n package net\n \n import ("}, {"sha": "28733428fd910d6665809333c9d92acf7f7b6767", "filename": "libgo/go/os/dir_largefile.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fdir_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fdir_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_largefile.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -5,6 +5,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux solaris,386 solaris,sparc\n+\n package os\n \n import \"syscall\""}, {"sha": "adea87d5430416017f96fb7b5f77d1cbb2a45a68", "filename": "libgo/go/os/dir_regfile.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fdir_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fdir_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_regfile.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -5,6 +5,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !linux\n+// +build !solaris,386\n+// +build !solaris,sparc\n+\n package os\n \n import \"syscall\""}, {"sha": "589db85274077b2e09ddd1596be40cd2f9d1ebbc", "filename": "libgo/go/os/dir_unix.go", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fos%2Fdir_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fos%2Fdir_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_unix.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris\n-\n-package os\n-\n-import (\n-\t\"io\"\n-\t\"syscall\"\n-)\n-\n-const (\n-\tblockSize = 4096\n-)\n-\n-func (f *File) readdirnames(n int) (names []string, err error) {\n-\t// If this file has no dirinfo, create one.\n-\tif f.dirinfo == nil {\n-\t\tf.dirinfo = new(dirInfo)\n-\t\t// The buffer must be at least a block long.\n-\t\tf.dirinfo.buf = make([]byte, blockSize)\n-\t}\n-\td := f.dirinfo\n-\n-\tsize := n\n-\tif size <= 0 {\n-\t\tsize = 100\n-\t\tn = -1\n-\t}\n-\n-\tnames = make([]string, 0, size) // Empty with room to grow.\n-\tfor n != 0 {\n-\t\t// Refill the buffer if necessary\n-\t\tif d.bufp >= d.nbuf {\n-\t\t\td.bufp = 0\n-\t\t\tvar errno error\n-\t\t\td.nbuf, errno = fixCount(syscall.ReadDirent(f.fd, d.buf))\n-\t\t\tif errno != nil {\n-\t\t\t\treturn names, NewSyscallError(\"readdirent\", errno)\n-\t\t\t}\n-\t\t\tif d.nbuf <= 0 {\n-\t\t\t\tbreak // EOF\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Drain the buffer\n-\t\tvar nb, nc int\n-\t\tnb, nc, names = syscall.ParseDirent(d.buf[d.bufp:d.nbuf], n, names)\n-\t\td.bufp += nb\n-\t\tn -= nc\n-\t}\n-\tif n >= 0 && len(names) == 0 {\n-\t\treturn names, io.EOF\n-\t}\n-\treturn names, nil\n-}"}, {"sha": "a3885a899c38d93d6a730831cd3fe52edb0e0c72", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -28,7 +28,7 @@ import (\n var supportsSymlinks = true\n \n var dot = []string{\n-\t\"dir_unix.go\",\n+\t\"dir.go\",\n \t\"env.go\",\n \t\"error.go\",\n \t\"file.go\","}, {"sha": "59cac9c7cedba52fa9a51ff32600a839df281a2e", "filename": "libgo/go/os/stat.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,13 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !darwin\n+// +build !freebsd\n+// +build !linux\n+// +build !netbsd\n+// +build !openbsd\n+// +build !solaris\n+\n package os\n \n import ("}, {"sha": "ef8a574e7bbd8be08f28e44af7c09d308a5e1f75", "filename": "libgo/go/os/stat_atim.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat_atim.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat_atim.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_atim.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux openbsd solaristag\n+\n package os\n \n import ("}, {"sha": "c6ce2bc8f48429a74adf6a6234b6a22607757c6a", "filename": "libgo/go/os/stat_atimespec.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat_atimespec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat_atimespec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_atimespec.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd netbsd\n+\n package os\n \n import ("}, {"sha": "1f1b4ab825d69a893f60eaa0f2e89559db125fc5", "filename": "libgo/go/os/stat_solaris.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fstat_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_solaris.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !solaristag\n+\n package os\n \n import ("}, {"sha": "71fa86759555028ed8ad22451624dd287a5096c1", "filename": "libgo/go/os/sys_uname.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fsys_uname.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fos%2Fsys_uname.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_uname.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,8 @@\n \n // For systems which only store the hostname in uname (Solaris).\n \n+// +build solaris irix rtems\n+\n package os\n \n import \"syscall\""}, {"sha": "f718e929126b2a7828aeece477f0b593271c19f3", "filename": "libgo/go/runtime/cgo_mips64x.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fcgo_mips64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fcgo_mips64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_mips64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2016 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build mips64 mips64le\n-\n-package runtime\n-\n-// crosscall1 calls into the runtime to set up the registers the\n-// Go runtime expects and so the symbol it calls needs to be exported\n-// for external linking to work.\n-//go:cgo_export_static _cgo_reginit"}, {"sha": "bcdd6cd6961a6c7ea9bf6e31872cb785c050a58e", "filename": "libgo/go/runtime/cgo_mmap.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fcgo_mmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fcgo_mmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_mmap.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Support for memory sanitizer. See runtime/cgo/mmap.go.\n \n // +build linux,amd64"}, {"sha": "fb2da32c7e0e769f4d95cf9eaccb54982acd59a0", "filename": "libgo/go/runtime/cgo_ppc64x.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fcgo_ppc64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fcgo_ppc64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_ppc64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ppc64 ppc64le\n-\n-package runtime\n-\n-// crosscall_ppc64 calls into the runtime to set up the registers the\n-// Go runtime expects and so the symbol it calls needs to be exported\n-// for external linking to work.\n-//go:cgo_export_static _cgo_reginit"}, {"sha": "7e38d9c449a4c92d14015754ac669fe56db1eb23", "filename": "libgo/go/runtime/cgocheck.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fcgocheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fcgocheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgocheck.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Code to check that pointer writes follow the cgo rules.\n // These functions are invoked via the write barrier when debug.cgocheck > 1.\n "}, {"sha": "bb3cd9801e882be0e237c40de606da38fc20dc8b", "filename": "libgo/go/runtime/defs_linux_mips64x.go", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fdefs_linux_mips64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fdefs_linux_mips64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdefs_linux_mips64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,183 +0,0 @@\n-// +build mips64 mips64le\n-// +build linux\n-\n-package runtime\n-\n-const (\n-\t_EINTR  = 0x4\n-\t_EAGAIN = 0xb\n-\t_ENOMEM = 0xc\n-\n-\t_PROT_NONE  = 0x0\n-\t_PROT_READ  = 0x1\n-\t_PROT_WRITE = 0x2\n-\t_PROT_EXEC  = 0x4\n-\n-\t_MAP_ANON    = 0x800\n-\t_MAP_PRIVATE = 0x2\n-\t_MAP_FIXED   = 0x10\n-\n-\t_MADV_DONTNEED   = 0x4\n-\t_MADV_HUGEPAGE   = 0xe\n-\t_MADV_NOHUGEPAGE = 0xf\n-\n-\t_SA_RESTART = 0x10000000\n-\t_SA_ONSTACK = 0x8000000\n-\t_SA_SIGINFO = 0x8\n-\n-\t_SIGHUP    = 0x1\n-\t_SIGINT    = 0x2\n-\t_SIGQUIT   = 0x3\n-\t_SIGILL    = 0x4\n-\t_SIGTRAP   = 0x5\n-\t_SIGABRT   = 0x6\n-\t_SIGEMT    = 0x7\n-\t_SIGFPE    = 0x8\n-\t_SIGKILL   = 0x9\n-\t_SIGBUS    = 0xa\n-\t_SIGSEGV   = 0xb\n-\t_SIGSYS    = 0xc\n-\t_SIGPIPE   = 0xd\n-\t_SIGALRM   = 0xe\n-\t_SIGUSR1   = 0x10\n-\t_SIGUSR2   = 0x11\n-\t_SIGCHLD   = 0x12\n-\t_SIGPWR    = 0x13\n-\t_SIGWINCH  = 0x14\n-\t_SIGURG    = 0x15\n-\t_SIGIO     = 0x16\n-\t_SIGSTOP   = 0x17\n-\t_SIGTSTP   = 0x18\n-\t_SIGCONT   = 0x19\n-\t_SIGTTIN   = 0x1a\n-\t_SIGTTOU   = 0x1b\n-\t_SIGVTALRM = 0x1c\n-\t_SIGPROF   = 0x1d\n-\t_SIGXCPU   = 0x1e\n-\t_SIGXFSZ   = 0x1f\n-\n-\t_FPE_INTDIV = 0x1\n-\t_FPE_INTOVF = 0x2\n-\t_FPE_FLTDIV = 0x3\n-\t_FPE_FLTOVF = 0x4\n-\t_FPE_FLTUND = 0x5\n-\t_FPE_FLTRES = 0x6\n-\t_FPE_FLTINV = 0x7\n-\t_FPE_FLTSUB = 0x8\n-\n-\t_BUS_ADRALN = 0x1\n-\t_BUS_ADRERR = 0x2\n-\t_BUS_OBJERR = 0x3\n-\n-\t_SEGV_MAPERR = 0x1\n-\t_SEGV_ACCERR = 0x2\n-\n-\t_ITIMER_REAL    = 0x0\n-\t_ITIMER_VIRTUAL = 0x1\n-\t_ITIMER_PROF    = 0x2\n-\n-\t_EPOLLIN       = 0x1\n-\t_EPOLLOUT      = 0x4\n-\t_EPOLLERR      = 0x8\n-\t_EPOLLHUP      = 0x10\n-\t_EPOLLRDHUP    = 0x2000\n-\t_EPOLLET       = 0x80000000\n-\t_EPOLL_CLOEXEC = 0x80000\n-\t_EPOLL_CTL_ADD = 0x1\n-\t_EPOLL_CTL_DEL = 0x2\n-\t_EPOLL_CTL_MOD = 0x3\n-)\n-\n-//struct Sigset {\n-//\tuint64\tsig[1];\n-//};\n-//typedef uint64 Sigset;\n-\n-type timespec struct {\n-\ttv_sec  int64\n-\ttv_nsec int64\n-}\n-\n-func (ts *timespec) set_sec(x int64) {\n-\tts.tv_sec = x\n-}\n-\n-func (ts *timespec) set_nsec(x int32) {\n-\tts.tv_nsec = int64(x)\n-}\n-\n-type timeval struct {\n-\ttv_sec  int64\n-\ttv_usec int64\n-}\n-\n-func (tv *timeval) set_usec(x int32) {\n-\ttv.tv_usec = int64(x)\n-}\n-\n-type sigactiont struct {\n-\tsa_flags   uint32\n-\tsa_handler uintptr\n-\tsa_mask    [2]uint64\n-\t// linux header does not have sa_restorer field,\n-\t// but it is used in setsig(). it is no harm to put it here\n-\tsa_restorer uintptr\n-}\n-\n-type siginfo struct {\n-\tsi_signo int32\n-\tsi_code  int32\n-\tsi_errno int32\n-\t__pad0   [1]int32\n-\t// below here is a union; si_addr is the only field we use\n-\tsi_addr uint64\n-}\n-\n-type itimerval struct {\n-\tit_interval timeval\n-\tit_value    timeval\n-}\n-\n-type epollevent struct {\n-\tevents    uint32\n-\tpad_cgo_0 [4]byte\n-\tdata      [8]byte // unaligned uintptr\n-}\n-\n-const (\n-\t_O_RDONLY    = 0x0\n-\t_O_CLOEXEC   = 0x80000\n-\t_SA_RESTORER = 0\n-)\n-\n-type sigaltstackt struct {\n-\tss_sp    *byte\n-\tss_size  uintptr\n-\tss_flags int32\n-}\n-\n-type sigcontext struct {\n-\tsc_regs      [32]uint64\n-\tsc_fpregs    [32]uint64\n-\tsc_mdhi      uint64\n-\tsc_hi1       uint64\n-\tsc_hi2       uint64\n-\tsc_hi3       uint64\n-\tsc_mdlo      uint64\n-\tsc_lo1       uint64\n-\tsc_lo2       uint64\n-\tsc_lo3       uint64\n-\tsc_pc        uint64\n-\tsc_fpc_csr   uint32\n-\tsc_used_math uint32\n-\tsc_dsp       uint32\n-\tsc_reserved  uint32\n-}\n-\n-type ucontext struct {\n-\tuc_flags    uint64\n-\tuc_link     *ucontext\n-\tuc_stack    sigaltstackt\n-\tuc_mcontext sigcontext\n-\tuc_sigmask  uint64\n-}"}, {"sha": "5f55d5a8894c5809144097821f1d62b79f7670f2", "filename": "libgo/go/runtime/defs_linux_s390x.go", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fdefs_linux_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fdefs_linux_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdefs_linux_s390x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,167 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-const (\n-\t_EINTR  = 0x4\n-\t_EAGAIN = 0xb\n-\t_ENOMEM = 0xc\n-\n-\t_PROT_NONE  = 0x0\n-\t_PROT_READ  = 0x1\n-\t_PROT_WRITE = 0x2\n-\t_PROT_EXEC  = 0x4\n-\n-\t_MAP_ANON    = 0x20\n-\t_MAP_PRIVATE = 0x2\n-\t_MAP_FIXED   = 0x10\n-\n-\t_MADV_DONTNEED   = 0x4\n-\t_MADV_HUGEPAGE   = 0xe\n-\t_MADV_NOHUGEPAGE = 0xf\n-\n-\t_SA_RESTART = 0x10000000\n-\t_SA_ONSTACK = 0x8000000\n-\t_SA_SIGINFO = 0x4\n-\n-\t_SIGHUP    = 0x1\n-\t_SIGINT    = 0x2\n-\t_SIGQUIT   = 0x3\n-\t_SIGILL    = 0x4\n-\t_SIGTRAP   = 0x5\n-\t_SIGABRT   = 0x6\n-\t_SIGBUS    = 0x7\n-\t_SIGFPE    = 0x8\n-\t_SIGKILL   = 0x9\n-\t_SIGUSR1   = 0xa\n-\t_SIGSEGV   = 0xb\n-\t_SIGUSR2   = 0xc\n-\t_SIGPIPE   = 0xd\n-\t_SIGALRM   = 0xe\n-\t_SIGSTKFLT = 0x10\n-\t_SIGCHLD   = 0x11\n-\t_SIGCONT   = 0x12\n-\t_SIGSTOP   = 0x13\n-\t_SIGTSTP   = 0x14\n-\t_SIGTTIN   = 0x15\n-\t_SIGTTOU   = 0x16\n-\t_SIGURG    = 0x17\n-\t_SIGXCPU   = 0x18\n-\t_SIGXFSZ   = 0x19\n-\t_SIGVTALRM = 0x1a\n-\t_SIGPROF   = 0x1b\n-\t_SIGWINCH  = 0x1c\n-\t_SIGIO     = 0x1d\n-\t_SIGPWR    = 0x1e\n-\t_SIGSYS    = 0x1f\n-\n-\t_FPE_INTDIV = 0x1\n-\t_FPE_INTOVF = 0x2\n-\t_FPE_FLTDIV = 0x3\n-\t_FPE_FLTOVF = 0x4\n-\t_FPE_FLTUND = 0x5\n-\t_FPE_FLTRES = 0x6\n-\t_FPE_FLTINV = 0x7\n-\t_FPE_FLTSUB = 0x8\n-\n-\t_BUS_ADRALN = 0x1\n-\t_BUS_ADRERR = 0x2\n-\t_BUS_OBJERR = 0x3\n-\n-\t_SEGV_MAPERR = 0x1\n-\t_SEGV_ACCERR = 0x2\n-\n-\t_ITIMER_REAL    = 0x0\n-\t_ITIMER_VIRTUAL = 0x1\n-\t_ITIMER_PROF    = 0x2\n-\n-\t_EPOLLIN       = 0x1\n-\t_EPOLLOUT      = 0x4\n-\t_EPOLLERR      = 0x8\n-\t_EPOLLHUP      = 0x10\n-\t_EPOLLRDHUP    = 0x2000\n-\t_EPOLLET       = 0x80000000\n-\t_EPOLL_CLOEXEC = 0x80000\n-\t_EPOLL_CTL_ADD = 0x1\n-\t_EPOLL_CTL_DEL = 0x2\n-\t_EPOLL_CTL_MOD = 0x3\n-)\n-\n-type timespec struct {\n-\ttv_sec  int64\n-\ttv_nsec int64\n-}\n-\n-func (ts *timespec) set_sec(x int64) {\n-\tts.tv_sec = x\n-}\n-\n-func (ts *timespec) set_nsec(x int32) {\n-\tts.tv_nsec = int64(x)\n-}\n-\n-type timeval struct {\n-\ttv_sec  int64\n-\ttv_usec int64\n-}\n-\n-func (tv *timeval) set_usec(x int32) {\n-\ttv.tv_usec = int64(x)\n-}\n-\n-type sigactiont struct {\n-\tsa_handler  uintptr\n-\tsa_flags    uint64\n-\tsa_restorer uintptr\n-\tsa_mask     uint64\n-}\n-\n-type siginfo struct {\n-\tsi_signo int32\n-\tsi_errno int32\n-\tsi_code  int32\n-\t// below here is a union; si_addr is the only field we use\n-\tsi_addr uint64\n-}\n-\n-type itimerval struct {\n-\tit_interval timeval\n-\tit_value    timeval\n-}\n-\n-type epollevent struct {\n-\tevents    uint32\n-\tpad_cgo_0 [4]byte\n-\tdata      [8]byte // unaligned uintptr\n-}\n-\n-const (\n-\t_O_RDONLY    = 0x0\n-\t_O_CLOEXEC   = 0x80000\n-\t_SA_RESTORER = 0\n-)\n-\n-type sigaltstackt struct {\n-\tss_sp    *byte\n-\tss_flags int32\n-\tss_size  uintptr\n-}\n-\n-type sigcontext struct {\n-\tpsw_mask uint64\n-\tpsw_addr uint64\n-\tgregs    [16]uint64\n-\taregs    [16]uint32\n-\tfpc      uint32\n-\tfpregs   [16]uint64\n-}\n-\n-type ucontext struct {\n-\tuc_flags    uint64\n-\tuc_link     *ucontext\n-\tuc_stack    sigaltstackt\n-\tuc_mcontext sigcontext\n-\tuc_sigmask  uint64\n-}"}, {"sha": "9c700ae1c0b8aafbd57825b1600d60cee1857776", "filename": "libgo/go/runtime/defs_plan9_arm.go", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fdefs_plan9_arm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fdefs_plan9_arm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdefs_plan9_arm.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-const _PAGESIZE = 0x1000\n-\n-type ureg struct {\n-\tr0   uint32 /* general registers */\n-\tr1   uint32 /* ... */\n-\tr2   uint32 /* ... */\n-\tr3   uint32 /* ... */\n-\tr4   uint32 /* ... */\n-\tr5   uint32 /* ... */\n-\tr6   uint32 /* ... */\n-\tr7   uint32 /* ... */\n-\tr8   uint32 /* ... */\n-\tr9   uint32 /* ... */\n-\tr10  uint32 /* ... */\n-\tr11  uint32 /* ... */\n-\tr12  uint32 /* ... */\n-\tsp   uint32\n-\tlink uint32 /* ... */\n-\ttrap uint32 /* trap type */\n-\tpsr  uint32\n-\tpc   uint32 /* interrupted addr */\n-}\n-\n-type sigctxt struct {\n-\tu *ureg\n-}\n-\n-func (c *sigctxt) pc() uintptr { return uintptr(c.u.pc) }\n-func (c *sigctxt) sp() uintptr { return uintptr(c.u.sp) }\n-func (c *sigctxt) lr() uintptr { return uintptr(c.u.link) }\n-\n-func (c *sigctxt) setpc(x uintptr)  { c.u.pc = uint32(x) }\n-func (c *sigctxt) setsp(x uintptr)  { c.u.sp = uint32(x) }\n-func (c *sigctxt) setlr(x uintptr)  { c.u.link = uint32(x) }\n-func (c *sigctxt) savelr(x uintptr) { c.u.r0 = uint32(x) }\n-\n-func dumpregs(u *ureg) {\n-\tprint(\"r0    \", hex(u.r0), \"\\n\")\n-\tprint(\"r1    \", hex(u.r1), \"\\n\")\n-\tprint(\"r2    \", hex(u.r2), \"\\n\")\n-\tprint(\"r3    \", hex(u.r3), \"\\n\")\n-\tprint(\"r4    \", hex(u.r4), \"\\n\")\n-\tprint(\"r5    \", hex(u.r5), \"\\n\")\n-\tprint(\"r6    \", hex(u.r6), \"\\n\")\n-\tprint(\"r7    \", hex(u.r7), \"\\n\")\n-\tprint(\"r8    \", hex(u.r8), \"\\n\")\n-\tprint(\"r9    \", hex(u.r9), \"\\n\")\n-\tprint(\"r10   \", hex(u.r10), \"\\n\")\n-\tprint(\"r11   \", hex(u.r11), \"\\n\")\n-\tprint(\"r12   \", hex(u.r12), \"\\n\")\n-\tprint(\"sp    \", hex(u.sp), \"\\n\")\n-\tprint(\"link  \", hex(u.link), \"\\n\")\n-\tprint(\"pc    \", hex(u.pc), \"\\n\")\n-\tprint(\"psr   \", hex(u.psr), \"\\n\")\n-}\n-\n-func sigpanictramp()"}, {"sha": "1029de2dbaee033549e6a1c052a208c16a7b78f0", "filename": "libgo/go/runtime/fastlog2.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Ffastlog2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Ffastlog2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ffastlog2.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package runtime\n \n import \"unsafe\""}, {"sha": "47ae5e81fb11cde439a0007b4d13c444416ad2da", "filename": "libgo/go/runtime/fastlog2table.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Ffastlog2table.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Ffastlog2table.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ffastlog2table.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Run go generate from src/runtime to update.\n // See mkfastlog2table.go for comments.\n \n+// +build ignore\n+\n package runtime\n \n const fastlogNumBits = 5"}, {"sha": "3b0eb986ce3d8746335741f0b672ca2ce57f5798", "filename": "libgo/go/runtime/lfstack_64bit.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // +build amd64 arm64 mips64 mips64le ppc64 ppc64le s390x\n \n package runtime"}, {"sha": "02aafdd210e6a09e934a067b26e6d63df9604a24", "filename": "libgo/go/runtime/mmap.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fmmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fmmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmmap.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // +build !plan9\n // +build !solaris\n // +build !windows"}, {"sha": "7177c8e611b5dfdeff286b892b7f8a85e192c1c5", "filename": "libgo/go/runtime/msan.go", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fmsan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fmsan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmsan.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build msan\n-\n-package runtime\n-\n-import (\n-\t\"unsafe\"\n-)\n-\n-// Public memory sanitizer API.\n-\n-func MSanRead(addr unsafe.Pointer, len int) {\n-\tmsanread(addr, uintptr(len))\n-}\n-\n-func MSanWrite(addr unsafe.Pointer, len int) {\n-\tmsanwrite(addr, uintptr(len))\n-}\n-\n-// Private interface for the runtime.\n-const msanenabled = true\n-\n-// If we are running on the system stack, the C program may have\n-// marked part of that stack as uninitialized. We don't instrument\n-// the runtime, but operations like a slice copy can call msanread\n-// anyhow for values on the stack. Just ignore msanread when running\n-// on the system stack. The other msan functions are fine.\n-func msanread(addr unsafe.Pointer, sz uintptr) {\n-\tg := getg()\n-\tif g == g.m.g0 || g == g.m.gsignal {\n-\t\treturn\n-\t}\n-\tdomsanread(addr, sz)\n-}\n-\n-//go:noescape\n-func domsanread(addr unsafe.Pointer, sz uintptr)\n-\n-//go:noescape\n-func msanwrite(addr unsafe.Pointer, sz uintptr)\n-\n-//go:noescape\n-func msanmalloc(addr unsafe.Pointer, sz uintptr)\n-\n-//go:noescape\n-func msanfree(addr unsafe.Pointer, sz uintptr)\n-\n-// These are called from msan_amd64.s\n-//go:cgo_import_static __msan_read_go\n-//go:cgo_import_static __msan_write_go\n-//go:cgo_import_static __msan_malloc_go\n-//go:cgo_import_static __msan_free_go"}, {"sha": "48ae3e4ffdc9127eca23609d3500a29e84cc4ff8", "filename": "libgo/go/runtime/msan0.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fmsan0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fmsan0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmsan0.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n // +build !msan\n \n // Dummy MSan support API, used when not built with -msan."}, {"sha": "6d0b5ac211b7df11bd1478a9b58711146e6a4e89", "filename": "libgo/go/runtime/mstkbar.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fmstkbar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fmstkbar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmstkbar.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Garbage collector: stack barriers\n //\n // Stack barriers enable the garbage collector to determine how much"}, {"sha": "52c8c86ee85ff27cdd85b91ecb2b1ae4bc3af378", "filename": "libgo/go/runtime/os_android.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_android.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_android.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_android.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import _ \"unsafe\" // for go:cgo_export_static and go:cgo_export_dynamic\n-\n-// Export the main function.\n-//\n-// Used by the app package to start all-Go Android apps that are\n-// loaded via JNI. See golang.org/x/mobile/app.\n-\n-//go:cgo_export_static main.main\n-//go:cgo_export_dynamic main.main"}, {"sha": "a16d14077617690dc491b68f9e6b53b4fcbb6c17", "filename": "libgo/go/runtime/os_linux_generic.go", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux_generic.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !mips64\n-// +build !mips64le\n-// +build !s390x\n-// +build linux\n-\n-package runtime\n-\n-const (\n-\t_SS_DISABLE  = 2\n-\t_NSIG        = 65\n-\t_SI_USER     = 0\n-\t_SIG_BLOCK   = 0\n-\t_SIG_UNBLOCK = 1\n-\t_SIG_SETMASK = 2\n-\t_RLIMIT_AS   = 9\n-)\n-\n-// It's hard to tease out exactly how big a Sigset is, but\n-// rt_sigprocmask crashes if we get it wrong, so if binaries\n-// are running, this is right.\n-type sigset [2]uint32\n-\n-type rlimit struct {\n-\trlim_cur uintptr\n-\trlim_max uintptr\n-}\n-\n-var sigset_all = sigset{^uint32(0), ^uint32(0)}\n-\n-func sigaddset(mask *sigset, i int) {\n-\t(*mask)[(i-1)/32] |= 1 << ((uint32(i) - 1) & 31)\n-}\n-\n-func sigdelset(mask *sigset, i int) {\n-\t(*mask)[(i-1)/32] &^= 1 << ((uint32(i) - 1) & 31)\n-}\n-\n-func sigfillset(mask *uint64) {\n-\t*mask = ^uint64(0)\n-}\n-\n-func sigcopyset(mask *sigset, m sigmask) {\n-\tcopy((*mask)[:], m[:])\n-}"}, {"sha": "8039b2fac9b7a34de683d8dd41e9b20df7e8b51f", "filename": "libgo/go/runtime/os_linux_mips64x.go", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_mips64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_mips64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux_mips64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build linux\n-// +build mips64 mips64le\n-\n-package runtime\n-\n-var randomNumber uint32\n-\n-func archauxv(tag, val uintptr) {\n-\tswitch tag {\n-\tcase _AT_RANDOM:\n-\t\t// sysargs filled in startupRandomData, but that\n-\t\t// pointer may not be word aligned, so we must treat\n-\t\t// it as a byte array.\n-\t\trandomNumber = uint32(startupRandomData[4]) | uint32(startupRandomData[5])<<8 |\n-\t\t\tuint32(startupRandomData[6])<<16 | uint32(startupRandomData[7])<<24\n-\t}\n-}\n-\n-//go:nosplit\n-func cputicks() int64 {\n-\t// Currently cputicks() is used in blocking profiler and to seed fastrand1().\n-\t// nanotime() is a poor approximation of CPU ticks that is enough for the profiler.\n-\t// randomNumber provides better seeding of fastrand1.\n-\treturn nanotime() + int64(randomNumber)\n-}\n-\n-const (\n-\t_SS_DISABLE  = 2\n-\t_NSIG        = 65\n-\t_SI_USER     = 0\n-\t_SIG_BLOCK   = 1\n-\t_SIG_UNBLOCK = 2\n-\t_SIG_SETMASK = 3\n-\t_RLIMIT_AS   = 6\n-)\n-\n-type sigset [2]uint64\n-\n-type rlimit struct {\n-\trlim_cur uintptr\n-\trlim_max uintptr\n-}\n-\n-var sigset_all = sigset{^uint64(0), ^uint64(0)}\n-\n-func sigaddset(mask *sigset, i int) {\n-\t(*mask)[(i-1)/64] |= 1 << ((uint32(i) - 1) & 63)\n-}\n-\n-func sigdelset(mask *sigset, i int) {\n-\t(*mask)[(i-1)/64] &^= 1 << ((uint32(i) - 1) & 63)\n-}\n-\n-func sigfillset(mask *[2]uint64) {\n-\t(*mask)[0], (*mask)[1] = ^uint64(0), ^uint64(0)\n-}\n-\n-func sigcopyset(mask *sigset, m sigmask) {\n-\t(*mask)[0] = uint64(m[0]) | uint64(m[1])<<32\n-}"}, {"sha": "22522dd803dc02704b9e27c91c1bd9027689a5d0", "filename": "libgo/go/runtime/os_linux_noauxv.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_noauxv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_noauxv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux_noauxv.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,10 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !amd64,!arm,!arm64,!mips64,!mips64le\n-\n-package runtime\n-\n-func archauxv(tag, val uintptr) {\n-}"}, {"sha": "e659dff7169396c6c5081b776e129cfdefc0df3c", "filename": "libgo/go/runtime/os_linux_s390x.go", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_linux_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux_s390x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,46 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-const (\n-\t_SS_DISABLE  = 2\n-\t_NSIG        = 65\n-\t_SI_USER     = 0\n-\t_SIG_BLOCK   = 0\n-\t_SIG_UNBLOCK = 1\n-\t_SIG_SETMASK = 2\n-\t_RLIMIT_AS   = 9\n-)\n-\n-type sigset uint64\n-\n-type rlimit struct {\n-\trlim_cur uintptr\n-\trlim_max uintptr\n-}\n-\n-var sigset_all = sigset(^uint64(0))\n-\n-func sigaddset(mask *sigset, i int) {\n-\tif i > 64 {\n-\t\tthrow(\"unexpected signal greater than 64\")\n-\t}\n-\t*mask |= 1 << (uint(i) - 1)\n-}\n-\n-func sigdelset(mask *sigset, i int) {\n-\tif i > 64 {\n-\t\tthrow(\"unexpected signal greater than 64\")\n-\t}\n-\t*mask &^= 1 << (uint(i) - 1)\n-}\n-\n-func sigfillset(mask *uint64) {\n-\t*mask = ^uint64(0)\n-}\n-\n-func sigcopyset(mask *sigset, m sigmask) {\n-\t*mask = sigset(uint64(m[0]) | uint64(m[1])<<32)\n-}"}, {"sha": "037f7e36dc6ae730321f68e2b9f2c777cd49a06b", "filename": "libgo/go/runtime/os_netbsd_386.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_netbsd_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_netbsd_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_netbsd_386.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-func lwp_mcontext_init(mc *mcontextt, stk unsafe.Pointer, mp *m, gp *g, fn uintptr) {\n-\t// Machine dependent mcontext initialisation for LWP.\n-\tmc.__gregs[_REG_EIP] = uint32(funcPC(lwp_tramp))\n-\tmc.__gregs[_REG_UESP] = uint32(uintptr(stk))\n-\tmc.__gregs[_REG_EBX] = uint32(uintptr(unsafe.Pointer(mp)))\n-\tmc.__gregs[_REG_EDX] = uint32(uintptr(unsafe.Pointer(gp)))\n-\tmc.__gregs[_REG_ESI] = uint32(fn)\n-}"}, {"sha": "5118b0c4ffda78c82406ef194c5575f7d445cbbe", "filename": "libgo/go/runtime/os_netbsd_amd64.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_netbsd_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_netbsd_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_netbsd_amd64.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-func lwp_mcontext_init(mc *mcontextt, stk unsafe.Pointer, mp *m, gp *g, fn uintptr) {\n-\t// Machine dependent mcontext initialisation for LWP.\n-\tmc.__gregs[_REG_RIP] = uint64(funcPC(lwp_tramp))\n-\tmc.__gregs[_REG_RSP] = uint64(uintptr(stk))\n-\tmc.__gregs[_REG_R8] = uint64(uintptr(unsafe.Pointer(mp)))\n-\tmc.__gregs[_REG_R9] = uint64(uintptr(unsafe.Pointer(gp)))\n-\tmc.__gregs[_REG_R12] = uint64(fn)\n-}"}, {"sha": "30cde8f74b047da5164a2fbf62d87c9a3f2628d8", "filename": "libgo/go/runtime/os_plan9_arm.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_plan9_arm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fos_plan9_arm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_plan9_arm.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-func checkgoarm() {\n-\treturn // TODO(minux)\n-}\n-\n-//go:nosplit\n-func cputicks() int64 {\n-\t// Currently cputicks() is used in blocking profiler and to seed runtime\u00b7fastrand1().\n-\t// runtime\u00b7nanotime() is a poor approximation of CPU ticks that is enough for the profiler.\n-\t// TODO: need more entropy to better seed fastrand1.\n-\treturn nanotime()\n-}"}, {"sha": "97d595fb2fbd33a5626fb7ee6f17908ecfc58f0e", "filename": "libgo/go/runtime/print.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fprint.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package runtime\n \n import \"unsafe\""}, {"sha": "b7479a71a778991a8c40678f55a54982e1669ed6", "filename": "libgo/go/runtime/signal2_unix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fsignal2_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fsignal2_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal2_unix.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // +build darwin dragonfly freebsd linux netbsd openbsd\n \n package runtime"}, {"sha": "0f590e49eab6ee9c702105be3ef0ca935cfac448", "filename": "libgo/go/runtime/signal_linux_mips64x.go", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsignal_linux_mips64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsignal_linux_mips64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_linux_mips64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,70 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build linux\n-// +build mips64 mips64le\n-\n-package runtime\n-\n-import (\n-\t\"runtime/internal/sys\"\n-\t\"unsafe\"\n-)\n-\n-type sigctxt struct {\n-\tinfo *siginfo\n-\tctxt unsafe.Pointer\n-}\n-\n-func (c *sigctxt) regs() *sigcontext { return &(*ucontext)(c.ctxt).uc_mcontext }\n-func (c *sigctxt) r0() uint64        { return c.regs().sc_regs[0] }\n-func (c *sigctxt) r1() uint64        { return c.regs().sc_regs[1] }\n-func (c *sigctxt) r2() uint64        { return c.regs().sc_regs[2] }\n-func (c *sigctxt) r3() uint64        { return c.regs().sc_regs[3] }\n-func (c *sigctxt) r4() uint64        { return c.regs().sc_regs[4] }\n-func (c *sigctxt) r5() uint64        { return c.regs().sc_regs[5] }\n-func (c *sigctxt) r6() uint64        { return c.regs().sc_regs[6] }\n-func (c *sigctxt) r7() uint64        { return c.regs().sc_regs[7] }\n-func (c *sigctxt) r8() uint64        { return c.regs().sc_regs[8] }\n-func (c *sigctxt) r9() uint64        { return c.regs().sc_regs[9] }\n-func (c *sigctxt) r10() uint64       { return c.regs().sc_regs[10] }\n-func (c *sigctxt) r11() uint64       { return c.regs().sc_regs[11] }\n-func (c *sigctxt) r12() uint64       { return c.regs().sc_regs[12] }\n-func (c *sigctxt) r13() uint64       { return c.regs().sc_regs[13] }\n-func (c *sigctxt) r14() uint64       { return c.regs().sc_regs[14] }\n-func (c *sigctxt) r15() uint64       { return c.regs().sc_regs[15] }\n-func (c *sigctxt) r16() uint64       { return c.regs().sc_regs[16] }\n-func (c *sigctxt) r17() uint64       { return c.regs().sc_regs[17] }\n-func (c *sigctxt) r18() uint64       { return c.regs().sc_regs[18] }\n-func (c *sigctxt) r19() uint64       { return c.regs().sc_regs[19] }\n-func (c *sigctxt) r20() uint64       { return c.regs().sc_regs[20] }\n-func (c *sigctxt) r21() uint64       { return c.regs().sc_regs[21] }\n-func (c *sigctxt) r22() uint64       { return c.regs().sc_regs[22] }\n-func (c *sigctxt) r23() uint64       { return c.regs().sc_regs[23] }\n-func (c *sigctxt) r24() uint64       { return c.regs().sc_regs[24] }\n-func (c *sigctxt) r25() uint64       { return c.regs().sc_regs[25] }\n-func (c *sigctxt) r26() uint64       { return c.regs().sc_regs[26] }\n-func (c *sigctxt) r27() uint64       { return c.regs().sc_regs[27] }\n-func (c *sigctxt) r28() uint64       { return c.regs().sc_regs[28] }\n-func (c *sigctxt) r29() uint64       { return c.regs().sc_regs[29] }\n-func (c *sigctxt) r30() uint64       { return c.regs().sc_regs[30] }\n-func (c *sigctxt) r31() uint64       { return c.regs().sc_regs[31] }\n-func (c *sigctxt) sp() uint64        { return c.regs().sc_regs[29] }\n-func (c *sigctxt) pc() uint64        { return c.regs().sc_pc }\n-func (c *sigctxt) link() uint64      { return c.regs().sc_regs[31] }\n-func (c *sigctxt) lo() uint64        { return c.regs().sc_mdlo }\n-func (c *sigctxt) hi() uint64        { return c.regs().sc_mdhi }\n-\n-func (c *sigctxt) sigcode() uint32 { return uint32(c.info.si_code) }\n-func (c *sigctxt) sigaddr() uint64 { return c.info.si_addr }\n-\n-func (c *sigctxt) set_r30(x uint64)  { c.regs().sc_regs[30] = x }\n-func (c *sigctxt) set_pc(x uint64)   { c.regs().sc_pc = x }\n-func (c *sigctxt) set_sp(x uint64)   { c.regs().sc_regs[29] = x }\n-func (c *sigctxt) set_link(x uint64) { c.regs().sc_regs[31] = x }\n-\n-func (c *sigctxt) set_sigcode(x uint32) { c.info.si_code = int32(x) }\n-func (c *sigctxt) set_sigaddr(x uint64) {\n-\t*(*uintptr)(add(unsafe.Pointer(c.info), 2*sys.PtrSize)) = uintptr(x)\n-}"}, {"sha": "155d3a326f5fb6cc6cb1aa3901acde3fe1d007b5", "filename": "libgo/go/runtime/signal_linux_s390x.go", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsignal_linux_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsignal_linux_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_linux_s390x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,208 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import (\n-\t\"runtime/internal/sys\"\n-\t\"unsafe\"\n-)\n-\n-type sigctxt struct {\n-\tinfo *siginfo\n-\tctxt unsafe.Pointer\n-}\n-\n-func (c *sigctxt) regs() *sigcontext {\n-\treturn (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))\n-}\n-func (c *sigctxt) r0() uint64      { return c.regs().gregs[0] }\n-func (c *sigctxt) r1() uint64      { return c.regs().gregs[1] }\n-func (c *sigctxt) r2() uint64      { return c.regs().gregs[2] }\n-func (c *sigctxt) r3() uint64      { return c.regs().gregs[3] }\n-func (c *sigctxt) r4() uint64      { return c.regs().gregs[4] }\n-func (c *sigctxt) r5() uint64      { return c.regs().gregs[5] }\n-func (c *sigctxt) r6() uint64      { return c.regs().gregs[6] }\n-func (c *sigctxt) r7() uint64      { return c.regs().gregs[7] }\n-func (c *sigctxt) r8() uint64      { return c.regs().gregs[8] }\n-func (c *sigctxt) r9() uint64      { return c.regs().gregs[9] }\n-func (c *sigctxt) r10() uint64     { return c.regs().gregs[10] }\n-func (c *sigctxt) r11() uint64     { return c.regs().gregs[11] }\n-func (c *sigctxt) r12() uint64     { return c.regs().gregs[12] }\n-func (c *sigctxt) r13() uint64     { return c.regs().gregs[13] }\n-func (c *sigctxt) r14() uint64     { return c.regs().gregs[14] }\n-func (c *sigctxt) r15() uint64     { return c.regs().gregs[15] }\n-func (c *sigctxt) link() uint64    { return c.regs().gregs[14] }\n-func (c *sigctxt) sp() uint64      { return c.regs().gregs[15] }\n-func (c *sigctxt) pc() uint64      { return c.regs().psw_addr }\n-func (c *sigctxt) sigcode() uint32 { return uint32(c.info.si_code) }\n-func (c *sigctxt) sigaddr() uint64 { return c.info.si_addr }\n-\n-func (c *sigctxt) set_r0(x uint64)      { c.regs().gregs[0] = x }\n-func (c *sigctxt) set_r13(x uint64)     { c.regs().gregs[13] = x }\n-func (c *sigctxt) set_link(x uint64)    { c.regs().gregs[14] = x }\n-func (c *sigctxt) set_sp(x uint64)      { c.regs().gregs[15] = x }\n-func (c *sigctxt) set_pc(x uint64)      { c.regs().psw_addr = x }\n-func (c *sigctxt) set_sigcode(x uint32) { c.info.si_code = int32(x) }\n-func (c *sigctxt) set_sigaddr(x uint64) {\n-\t*(*uintptr)(add(unsafe.Pointer(c.info), 2*sys.PtrSize)) = uintptr(x)\n-}\n-\n-func dumpregs(c *sigctxt) {\n-\tprint(\"r0   \", hex(c.r0()), \"\\t\")\n-\tprint(\"r1   \", hex(c.r1()), \"\\n\")\n-\tprint(\"r2   \", hex(c.r2()), \"\\t\")\n-\tprint(\"r3   \", hex(c.r3()), \"\\n\")\n-\tprint(\"r4   \", hex(c.r4()), \"\\t\")\n-\tprint(\"r5   \", hex(c.r5()), \"\\n\")\n-\tprint(\"r6   \", hex(c.r6()), \"\\t\")\n-\tprint(\"r7   \", hex(c.r7()), \"\\n\")\n-\tprint(\"r8   \", hex(c.r8()), \"\\t\")\n-\tprint(\"r9   \", hex(c.r9()), \"\\n\")\n-\tprint(\"r10  \", hex(c.r10()), \"\\t\")\n-\tprint(\"r11  \", hex(c.r11()), \"\\n\")\n-\tprint(\"r12  \", hex(c.r12()), \"\\t\")\n-\tprint(\"r13  \", hex(c.r13()), \"\\n\")\n-\tprint(\"r14  \", hex(c.r14()), \"\\t\")\n-\tprint(\"r15  \", hex(c.r15()), \"\\n\")\n-\tprint(\"pc   \", hex(c.pc()), \"\\t\")\n-\tprint(\"link \", hex(c.link()), \"\\n\")\n-}\n-\n-var crashing int32\n-\n-// May run during STW, so write barriers are not allowed.\n-//\n-//go:nowritebarrierrec\n-func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {\n-\t_g_ := getg()\n-\tc := &sigctxt{info, ctxt}\n-\n-\tif sig == _SIGPROF {\n-\t\tsigprof(uintptr(c.pc()), uintptr(c.sp()), uintptr(c.link()), gp, _g_.m)\n-\t\treturn\n-\t}\n-\tflags := int32(_SigThrow)\n-\tif sig < uint32(len(sigtable)) {\n-\t\tflags = sigtable[sig].flags\n-\t}\n-\tif c.sigcode() != _SI_USER && flags&_SigPanic != 0 {\n-\t\t// Make it look like a call to the signal func.\n-\t\t// Have to pass arguments out of band since\n-\t\t// augmenting the stack frame would break\n-\t\t// the unwinding code.\n-\t\tgp.sig = sig\n-\t\tgp.sigcode0 = uintptr(c.sigcode())\n-\t\tgp.sigcode1 = uintptr(c.sigaddr())\n-\t\tgp.sigpc = uintptr(c.pc())\n-\n-\t\t// We arrange link, and pc to pretend the panicking\n-\t\t// function calls sigpanic directly.\n-\t\t// Always save LINK to stack so that panics in leaf\n-\t\t// functions are correctly handled. This smashes\n-\t\t// the stack frame but we're not going back there\n-\t\t// anyway.\n-\t\tsp := c.sp() - sys.MinFrameSize\n-\t\tc.set_sp(sp)\n-\t\t*(*uint64)(unsafe.Pointer(uintptr(sp))) = c.link()\n-\n-\t\tpc := uintptr(gp.sigpc)\n-\n-\t\t// If we don't recognize the PC as code\n-\t\t// but we do recognize the link register as code,\n-\t\t// then assume this was a call to non-code and treat like\n-\t\t// pc == 0, to make unwinding show the context.\n-\t\tif pc != 0 && findfunc(pc) == nil && findfunc(uintptr(c.link())) != nil {\n-\t\t\tpc = 0\n-\t\t}\n-\n-\t\t// Don't bother saving PC if it's zero, which is\n-\t\t// probably a call to a nil func: the old link register\n-\t\t// is more useful in the stack trace.\n-\t\tif pc != 0 {\n-\t\t\tc.set_link(uint64(pc))\n-\t\t}\n-\n-\t\t// In case we are panicking from external C code\n-\t\tc.set_r0(0)\n-\t\tc.set_r13(uint64(uintptr(unsafe.Pointer(gp))))\n-\t\tc.set_pc(uint64(funcPC(sigpanic)))\n-\t\treturn\n-\t}\n-\n-\tif c.sigcode() == _SI_USER || flags&_SigNotify != 0 {\n-\t\tif sigsend(sig) {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tif c.sigcode() == _SI_USER && signal_ignored(sig) {\n-\t\treturn\n-\t}\n-\n-\tif flags&_SigKill != 0 {\n-\t\tdieFromSignal(int32(sig))\n-\t}\n-\n-\tif flags&_SigThrow == 0 {\n-\t\treturn\n-\t}\n-\n-\t_g_.m.throwing = 1\n-\t_g_.m.caughtsig.set(gp)\n-\n-\tif crashing == 0 {\n-\t\tstartpanic()\n-\t}\n-\n-\tif sig < uint32(len(sigtable)) {\n-\t\tprint(sigtable[sig].name, \"\\n\")\n-\t} else {\n-\t\tprint(\"Signal \", sig, \"\\n\")\n-\t}\n-\n-\tprint(\"PC=\", hex(c.pc()), \" m=\", _g_.m.id, \"\\n\")\n-\tif _g_.m.lockedg != nil && _g_.m.ncgo > 0 && gp == _g_.m.g0 {\n-\t\tprint(\"signal arrived during cgo execution\\n\")\n-\t\tgp = _g_.m.lockedg\n-\t}\n-\tprint(\"\\n\")\n-\n-\tlevel, _, docrash := gotraceback()\n-\tif level > 0 {\n-\t\tgoroutineheader(gp)\n-\t\ttracebacktrap(uintptr(c.pc()), uintptr(c.sp()), uintptr(c.link()), gp)\n-\t\tif crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {\n-\t\t\t// tracebackothers on original m skipped this one; trace it now.\n-\t\t\tgoroutineheader(_g_.m.curg)\n-\t\t\ttraceback(^uintptr(0), ^uintptr(0), 0, gp)\n-\t\t} else if crashing == 0 {\n-\t\t\ttracebackothers(gp)\n-\t\t\tprint(\"\\n\")\n-\t\t}\n-\t\tdumpregs(c)\n-\t}\n-\n-\tif docrash {\n-\t\tcrashing++\n-\t\tif crashing < sched.mcount {\n-\t\t\t// There are other m's that need to dump their stacks.\n-\t\t\t// Relay SIGQUIT to the next m by sending it to the current process.\n-\t\t\t// All m's that have already received SIGQUIT have signal masks blocking\n-\t\t\t// receipt of any signals, so the SIGQUIT will go to an m that hasn't seen it yet.\n-\t\t\t// When the last m receives the SIGQUIT, it will fall through to the call to\n-\t\t\t// crash below. Just in case the relaying gets botched, each m involved in\n-\t\t\t// the relay sleeps for 5 seconds and then does the crash/exit itself.\n-\t\t\t// In expected operation, the last m has received the SIGQUIT and run\n-\t\t\t// crash/exit and the process is gone, all long before any of the\n-\t\t\t// 5-second sleeps have finished.\n-\t\t\tprint(\"\\n-----\\n\\n\")\n-\t\t\traiseproc(_SIGQUIT)\n-\t\t\tusleep(5 * 1000 * 1000)\n-\t\t}\n-\t\tcrash()\n-\t}\n-\n-\texit(2)\n-}"}, {"sha": "4dbeb42fe5c4a6c9b9b3f2026c15783a9204e03c", "filename": "libgo/go/runtime/signal_mips64x.go", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsignal_mips64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsignal_mips64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_mips64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,188 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build linux\n-// +build mips64 mips64le\n-\n-package runtime\n-\n-import (\n-\t\"runtime/internal/sys\"\n-\t\"unsafe\"\n-)\n-\n-func dumpregs(c *sigctxt) {\n-\tprint(\"r0   \", hex(c.r0()), \"\\t\")\n-\tprint(\"r1   \", hex(c.r1()), \"\\n\")\n-\tprint(\"r2   \", hex(c.r2()), \"\\t\")\n-\tprint(\"r3   \", hex(c.r3()), \"\\n\")\n-\tprint(\"r4   \", hex(c.r4()), \"\\t\")\n-\tprint(\"r5   \", hex(c.r5()), \"\\n\")\n-\tprint(\"r6   \", hex(c.r6()), \"\\t\")\n-\tprint(\"r7   \", hex(c.r7()), \"\\n\")\n-\tprint(\"r8   \", hex(c.r8()), \"\\t\")\n-\tprint(\"r9   \", hex(c.r9()), \"\\n\")\n-\tprint(\"r10  \", hex(c.r10()), \"\\t\")\n-\tprint(\"r11  \", hex(c.r11()), \"\\n\")\n-\tprint(\"r12  \", hex(c.r12()), \"\\t\")\n-\tprint(\"r13  \", hex(c.r13()), \"\\n\")\n-\tprint(\"r14  \", hex(c.r14()), \"\\t\")\n-\tprint(\"r15  \", hex(c.r15()), \"\\n\")\n-\tprint(\"r16  \", hex(c.r16()), \"\\t\")\n-\tprint(\"r17  \", hex(c.r17()), \"\\n\")\n-\tprint(\"r18  \", hex(c.r18()), \"\\t\")\n-\tprint(\"r19  \", hex(c.r19()), \"\\n\")\n-\tprint(\"r20  \", hex(c.r20()), \"\\t\")\n-\tprint(\"r21  \", hex(c.r21()), \"\\n\")\n-\tprint(\"r22  \", hex(c.r22()), \"\\t\")\n-\tprint(\"r23  \", hex(c.r23()), \"\\n\")\n-\tprint(\"r24  \", hex(c.r24()), \"\\t\")\n-\tprint(\"r25  \", hex(c.r25()), \"\\n\")\n-\tprint(\"r26  \", hex(c.r26()), \"\\t\")\n-\tprint(\"r27  \", hex(c.r27()), \"\\n\")\n-\tprint(\"r28  \", hex(c.r28()), \"\\t\")\n-\tprint(\"r29  \", hex(c.r29()), \"\\n\")\n-\tprint(\"r30  \", hex(c.r30()), \"\\t\")\n-\tprint(\"r31  \", hex(c.r31()), \"\\n\")\n-\tprint(\"pc   \", hex(c.pc()), \"\\t\")\n-\tprint(\"link \", hex(c.link()), \"\\n\")\n-\tprint(\"lo   \", hex(c.lo()), \"\\t\")\n-\tprint(\"hi   \", hex(c.hi()), \"\\n\")\n-}\n-\n-var crashing int32\n-\n-// May run during STW, so write barriers are not allowed.\n-//\n-//go:nowritebarrierrec\n-func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {\n-\t_g_ := getg()\n-\tc := &sigctxt{info, ctxt}\n-\n-\tif sig == _SIGPROF {\n-\t\tsigprof(uintptr(c.pc()), uintptr(c.sp()), uintptr(c.link()), gp, _g_.m)\n-\t\treturn\n-\t}\n-\tflags := int32(_SigThrow)\n-\tif sig < uint32(len(sigtable)) {\n-\t\tflags = sigtable[sig].flags\n-\t}\n-\tif c.sigcode() != _SI_USER && flags&_SigPanic != 0 {\n-\t\t// Make it look like a call to the signal func.\n-\t\t// Have to pass arguments out of band since\n-\t\t// augmenting the stack frame would break\n-\t\t// the unwinding code.\n-\t\tgp.sig = sig\n-\t\tgp.sigcode0 = uintptr(c.sigcode())\n-\t\tgp.sigcode1 = uintptr(c.sigaddr())\n-\t\tgp.sigpc = uintptr(c.pc())\n-\n-\t\t// We arrange link, and pc to pretend the panicking\n-\t\t// function calls sigpanic directly.\n-\t\t// Always save LINK to stack so that panics in leaf\n-\t\t// functions are correctly handled. This smashes\n-\t\t// the stack frame but we're not going back there\n-\t\t// anyway.\n-\t\tsp := c.sp() - sys.PtrSize\n-\t\tc.set_sp(sp)\n-\t\t*(*uint64)(unsafe.Pointer(uintptr(sp))) = c.link()\n-\n-\t\tpc := gp.sigpc\n-\n-\t\t// If we don't recognize the PC as code\n-\t\t// but we do recognize the link register as code,\n-\t\t// then assume this was a call to non-code and treat like\n-\t\t// pc == 0, to make unwinding show the context.\n-\t\tif pc != 0 && findfunc(pc) == nil && findfunc(uintptr(c.link())) != nil {\n-\t\t\tpc = 0\n-\t\t}\n-\n-\t\t// Don't bother saving PC if it's zero, which is\n-\t\t// probably a call to a nil func: the old link register\n-\t\t// is more useful in the stack trace.\n-\t\tif pc != 0 {\n-\t\t\tc.set_link(uint64(pc))\n-\t\t}\n-\n-\t\t// In case we are panicking from external C code\n-\t\tc.set_r30(uint64(uintptr(unsafe.Pointer(gp))))\n-\t\tc.set_pc(uint64(funcPC(sigpanic)))\n-\t\treturn\n-\t}\n-\n-\tif c.sigcode() == _SI_USER || flags&_SigNotify != 0 {\n-\t\tif sigsend(sig) {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tif c.sigcode() == _SI_USER && signal_ignored(sig) {\n-\t\treturn\n-\t}\n-\n-\tif flags&_SigKill != 0 {\n-\t\tdieFromSignal(int32(sig))\n-\t}\n-\n-\tif flags&_SigThrow == 0 {\n-\t\treturn\n-\t}\n-\n-\t_g_.m.throwing = 1\n-\t_g_.m.caughtsig.set(gp)\n-\n-\tif crashing == 0 {\n-\t\tstartpanic()\n-\t}\n-\n-\tif sig < uint32(len(sigtable)) {\n-\t\tprint(sigtable[sig].name, \"\\n\")\n-\t} else {\n-\t\tprint(\"Signal \", sig, \"\\n\")\n-\t}\n-\n-\tprint(\"PC=\", hex(c.pc()), \" m=\", _g_.m.id, \"\\n\")\n-\tif _g_.m.lockedg != nil && _g_.m.ncgo > 0 && gp == _g_.m.g0 {\n-\t\tprint(\"signal arrived during cgo execution\\n\")\n-\t\tgp = _g_.m.lockedg\n-\t}\n-\tprint(\"\\n\")\n-\n-\tlevel, _, docrash := gotraceback()\n-\tif level > 0 {\n-\t\tgoroutineheader(gp)\n-\t\ttracebacktrap(uintptr(c.pc()), uintptr(c.sp()), uintptr(c.link()), gp)\n-\t\tif crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {\n-\t\t\t// tracebackothers on original m skipped this one; trace it now.\n-\t\t\tgoroutineheader(_g_.m.curg)\n-\t\t\ttraceback(^uintptr(0), ^uintptr(0), 0, gp)\n-\t\t} else if crashing == 0 {\n-\t\t\ttracebackothers(gp)\n-\t\t\tprint(\"\\n\")\n-\t\t}\n-\t\tdumpregs(c)\n-\t}\n-\n-\tif docrash {\n-\t\tcrashing++\n-\t\tif crashing < sched.mcount {\n-\t\t\t// There are other m's that need to dump their stacks.\n-\t\t\t// Relay SIGQUIT to the next m by sending it to the current process.\n-\t\t\t// All m's that have already received SIGQUIT have signal masks blocking\n-\t\t\t// receipt of any signals, so the SIGQUIT will go to an m that hasn't seen it yet.\n-\t\t\t// When the last m receives the SIGQUIT, it will fall through to the call to\n-\t\t\t// crash below. Just in case the relaying gets botched, each m involved in\n-\t\t\t// the relay sleeps for 5 seconds and then does the crash/exit itself.\n-\t\t\t// In expected operation, the last m has received the SIGQUIT and run\n-\t\t\t// crash/exit and the process is gone, all long before any of the\n-\t\t\t// 5-second sleeps have finished.\n-\t\t\tprint(\"\\n-----\\n\\n\")\n-\t\t\traiseproc(_SIGQUIT)\n-\t\t\tusleep(5 * 1000 * 1000)\n-\t\t}\n-\t\tcrash()\n-\t}\n-\n-\texit(2)\n-}"}, {"sha": "f4a6ebd71c1c9b024a87ece4f5cbb320e0490d6e", "filename": "libgo/go/runtime/signal_sigtramp.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // +build dragonfly linux netbsd\n \n package runtime"}, {"sha": "ea36bf3645254c4f76b7a1b6e7aee97ec05cc262", "filename": "libgo/go/runtime/sigtab_linux_generic.go", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsigtab_linux_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsigtab_linux_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigtab_linux_generic.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,82 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !mips64\n-// +build !mips64le\n-// +build linux\n-\n-package runtime\n-\n-type sigTabT struct {\n-\tflags int32\n-\tname  string\n-}\n-\n-var sigtable = [...]sigTabT{\n-\t/* 0 */ {0, \"SIGNONE: no trap\"},\n-\t/* 1 */ {_SigNotify + _SigKill, \"SIGHUP: terminal line hangup\"},\n-\t/* 2 */ {_SigNotify + _SigKill, \"SIGINT: interrupt\"},\n-\t/* 3 */ {_SigNotify + _SigThrow, \"SIGQUIT: quit\"},\n-\t/* 4 */ {_SigThrow + _SigUnblock, \"SIGILL: illegal instruction\"},\n-\t/* 5 */ {_SigThrow + _SigUnblock, \"SIGTRAP: trace trap\"},\n-\t/* 6 */ {_SigNotify + _SigThrow, \"SIGABRT: abort\"},\n-\t/* 7 */ {_SigPanic + _SigUnblock, \"SIGBUS: bus error\"},\n-\t/* 8 */ {_SigPanic + _SigUnblock, \"SIGFPE: floating-point exception\"},\n-\t/* 9 */ {0, \"SIGKILL: kill\"},\n-\t/* 10 */ {_SigNotify, \"SIGUSR1: user-defined signal 1\"},\n-\t/* 11 */ {_SigPanic + _SigUnblock, \"SIGSEGV: segmentation violation\"},\n-\t/* 12 */ {_SigNotify, \"SIGUSR2: user-defined signal 2\"},\n-\t/* 13 */ {_SigNotify, \"SIGPIPE: write to broken pipe\"},\n-\t/* 14 */ {_SigNotify, \"SIGALRM: alarm clock\"},\n-\t/* 15 */ {_SigNotify + _SigKill, \"SIGTERM: termination\"},\n-\t/* 16 */ {_SigThrow + _SigUnblock, \"SIGSTKFLT: stack fault\"},\n-\t/* 17 */ {_SigNotify + _SigUnblock, \"SIGCHLD: child status has changed\"},\n-\t/* 18 */ {_SigNotify + _SigDefault, \"SIGCONT: continue\"},\n-\t/* 19 */ {0, \"SIGSTOP: stop, unblockable\"},\n-\t/* 20 */ {_SigNotify + _SigDefault, \"SIGTSTP: keyboard stop\"},\n-\t/* 21 */ {_SigNotify + _SigDefault, \"SIGTTIN: background read from tty\"},\n-\t/* 22 */ {_SigNotify + _SigDefault, \"SIGTTOU: background write to tty\"},\n-\t/* 23 */ {_SigNotify, \"SIGURG: urgent condition on socket\"},\n-\t/* 24 */ {_SigNotify, \"SIGXCPU: cpu limit exceeded\"},\n-\t/* 25 */ {_SigNotify, \"SIGXFSZ: file size limit exceeded\"},\n-\t/* 26 */ {_SigNotify, \"SIGVTALRM: virtual alarm clock\"},\n-\t/* 27 */ {_SigNotify + _SigUnblock, \"SIGPROF: profiling alarm clock\"},\n-\t/* 28 */ {_SigNotify, \"SIGWINCH: window size change\"},\n-\t/* 29 */ {_SigNotify, \"SIGIO: i/o now possible\"},\n-\t/* 30 */ {_SigNotify, \"SIGPWR: power failure restart\"},\n-\t/* 31 */ {_SigThrow, \"SIGSYS: bad system call\"},\n-\t/* 32 */ {_SigSetStack + _SigUnblock, \"signal 32\"}, /* SIGCANCEL; see issue 6997 */\n-\t/* 33 */ {_SigSetStack + _SigUnblock, \"signal 33\"}, /* SIGSETXID; see issues 3871, 9400, 12498 */\n-\t/* 34 */ {_SigNotify, \"signal 34\"},\n-\t/* 35 */ {_SigNotify, \"signal 35\"},\n-\t/* 36 */ {_SigNotify, \"signal 36\"},\n-\t/* 37 */ {_SigNotify, \"signal 37\"},\n-\t/* 38 */ {_SigNotify, \"signal 38\"},\n-\t/* 39 */ {_SigNotify, \"signal 39\"},\n-\t/* 40 */ {_SigNotify, \"signal 40\"},\n-\t/* 41 */ {_SigNotify, \"signal 41\"},\n-\t/* 42 */ {_SigNotify, \"signal 42\"},\n-\t/* 43 */ {_SigNotify, \"signal 43\"},\n-\t/* 44 */ {_SigNotify, \"signal 44\"},\n-\t/* 45 */ {_SigNotify, \"signal 45\"},\n-\t/* 46 */ {_SigNotify, \"signal 46\"},\n-\t/* 47 */ {_SigNotify, \"signal 47\"},\n-\t/* 48 */ {_SigNotify, \"signal 48\"},\n-\t/* 49 */ {_SigNotify, \"signal 49\"},\n-\t/* 50 */ {_SigNotify, \"signal 50\"},\n-\t/* 51 */ {_SigNotify, \"signal 51\"},\n-\t/* 52 */ {_SigNotify, \"signal 52\"},\n-\t/* 53 */ {_SigNotify, \"signal 53\"},\n-\t/* 54 */ {_SigNotify, \"signal 54\"},\n-\t/* 55 */ {_SigNotify, \"signal 55\"},\n-\t/* 56 */ {_SigNotify, \"signal 56\"},\n-\t/* 57 */ {_SigNotify, \"signal 57\"},\n-\t/* 58 */ {_SigNotify, \"signal 58\"},\n-\t/* 59 */ {_SigNotify, \"signal 59\"},\n-\t/* 60 */ {_SigNotify, \"signal 60\"},\n-\t/* 61 */ {_SigNotify, \"signal 61\"},\n-\t/* 62 */ {_SigNotify, \"signal 62\"},\n-\t/* 63 */ {_SigNotify, \"signal 63\"},\n-\t/* 64 */ {_SigNotify, \"signal 64\"},\n-}"}, {"sha": "201fe3deeb73513a4fd394c9968b6b7bae38af7f", "filename": "libgo/go/runtime/sigtab_linux_mips64x.go", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsigtab_linux_mips64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsigtab_linux_mips64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigtab_linux_mips64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build mips64 mips64le\n-// +build linux\n-\n-package runtime\n-\n-type sigTabT struct {\n-\tflags int32\n-\tname  string\n-}\n-\n-var sigtable = [...]sigTabT{\n-\t/* 0 */ {0, \"SIGNONE: no trap\"},\n-\t/* 1 */ {_SigNotify + _SigKill, \"SIGHUP: terminal line hangup\"},\n-\t/* 2 */ {_SigNotify + _SigKill, \"SIGINT: interrupt\"},\n-\t/* 3 */ {_SigNotify + _SigThrow, \"SIGQUIT: quit\"},\n-\t/* 4 */ {_SigThrow + _SigUnblock, \"SIGILL: illegal instruction\"},\n-\t/* 5 */ {_SigThrow + _SigUnblock, \"SIGTRAP: trace trap\"},\n-\t/* 6 */ {_SigNotify + _SigThrow, \"SIGABRT: abort\"},\n-\t/* 7 */ {_SigThrow, \"SIGEMT\"},\n-\t/* 8 */ {_SigPanic + _SigUnblock, \"SIGFPE: floating-point exception\"},\n-\t/* 9 */ {0, \"SIGKILL: kill\"},\n-\t/* 10 */ {_SigPanic + _SigUnblock, \"SIGBUS: bus error\"},\n-\t/* 11 */ {_SigPanic + _SigUnblock, \"SIGSEGV: segmentation violation\"},\n-\t/* 12 */ {_SigThrow, \"SIGSYS: bad system call\"},\n-\t/* 13 */ {_SigNotify, \"SIGPIPE: write to broken pipe\"},\n-\t/* 14 */ {_SigNotify, \"SIGALRM: alarm clock\"},\n-\t/* 15 */ {_SigNotify + _SigKill, \"SIGTERM: termination\"},\n-\t/* 16 */ {_SigNotify, \"SIGUSR1: user-defined signal 1\"},\n-\t/* 17 */ {_SigNotify, \"SIGUSR2: user-defined signal 2\"},\n-\t/* 18 */ {_SigNotify + _SigUnblock, \"SIGCHLD: child status has changed\"},\n-\t/* 19 */ {_SigNotify, \"SIGPWR: power failure restart\"},\n-\t/* 20 */ {_SigNotify, \"SIGWINCH: window size change\"},\n-\t/* 21 */ {_SigNotify, \"SIGURG: urgent condition on socket\"},\n-\t/* 22 */ {_SigNotify, \"SIGIO: i/o now possible\"},\n-\t/* 23 */ {0, \"SIGSTOP: stop, unblockable\"},\n-\t/* 24 */ {_SigNotify + _SigDefault, \"SIGTSTP: keyboard stop\"},\n-\t/* 25 */ {_SigNotify + _SigDefault, \"SIGCONT: continue\"},\n-\t/* 26 */ {_SigNotify + _SigDefault, \"SIGTTIN: background read from tty\"},\n-\t/* 27 */ {_SigNotify + _SigDefault, \"SIGTTOU: background write to tty\"},\n-\t/* 28 */ {_SigNotify, \"SIGVTALRM: virtual alarm clock\"},\n-\t/* 29 */ {_SigNotify + _SigUnblock, \"SIGPROF: profiling alarm clock\"},\n-\t/* 30 */ {_SigNotify, \"SIGXCPU: cpu limit exceeded\"},\n-\t/* 31 */ {_SigNotify, \"SIGXFSZ: file size limit exceeded\"},\n-\t/* 32 */ {_SigSetStack + _SigUnblock, \"signal 32\"}, /* SIGCANCEL; see issue 6997 */\n-\t/* 33 */ {_SigSetStack + _SigUnblock, \"signal 33\"}, /* SIGSETXID; see issues 3871, 9400, 12498 */\n-\t/* 34 */ {_SigNotify, \"signal 34\"},\n-\t/* 35 */ {_SigNotify, \"signal 35\"},\n-\t/* 36 */ {_SigNotify, \"signal 36\"},\n-\t/* 37 */ {_SigNotify, \"signal 37\"},\n-\t/* 38 */ {_SigNotify, \"signal 38\"},\n-\t/* 39 */ {_SigNotify, \"signal 39\"},\n-\t/* 40 */ {_SigNotify, \"signal 40\"},\n-\t/* 41 */ {_SigNotify, \"signal 41\"},\n-\t/* 42 */ {_SigNotify, \"signal 42\"},\n-\t/* 43 */ {_SigNotify, \"signal 43\"},\n-\t/* 44 */ {_SigNotify, \"signal 44\"},\n-\t/* 45 */ {_SigNotify, \"signal 45\"},\n-\t/* 46 */ {_SigNotify, \"signal 46\"},\n-\t/* 47 */ {_SigNotify, \"signal 47\"},\n-\t/* 48 */ {_SigNotify, \"signal 48\"},\n-\t/* 49 */ {_SigNotify, \"signal 49\"},\n-\t/* 50 */ {_SigNotify, \"signal 50\"},\n-\t/* 51 */ {_SigNotify, \"signal 51\"},\n-\t/* 52 */ {_SigNotify, \"signal 52\"},\n-\t/* 53 */ {_SigNotify, \"signal 53\"},\n-\t/* 54 */ {_SigNotify, \"signal 54\"},\n-\t/* 55 */ {_SigNotify, \"signal 55\"},\n-\t/* 56 */ {_SigNotify, \"signal 56\"},\n-\t/* 57 */ {_SigNotify, \"signal 57\"},\n-\t/* 58 */ {_SigNotify, \"signal 58\"},\n-\t/* 59 */ {_SigNotify, \"signal 59\"},\n-\t/* 60 */ {_SigNotify, \"signal 60\"},\n-\t/* 61 */ {_SigNotify, \"signal 61\"},\n-\t/* 62 */ {_SigNotify, \"signal 62\"},\n-\t/* 63 */ {_SigNotify, \"signal 63\"},\n-\t/* 64 */ {_SigNotify, \"signal 64\"},\n-}"}, {"sha": "708a4c299cc39feea7522a4396c4c84ffff0f08b", "filename": "libgo/go/runtime/stack.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fruntime%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstack.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package runtime\n \n import ("}, {"sha": "9e7d805d7d63990f22d3f484f10c4e669e505758", "filename": "libgo/go/runtime/sys_mips64x.go", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsys_mips64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsys_mips64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsys_mips64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build mips64 mips64le\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-// adjust Gobuf as if it executed a call to fn with context ctxt\n-// and then did an immediate Gosave.\n-func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {\n-\tif buf.lr != 0 {\n-\t\tthrow(\"invalid use of gostartcall\")\n-\t}\n-\tbuf.lr = buf.pc\n-\tbuf.pc = uintptr(fn)\n-\tbuf.ctxt = ctxt\n-}\n-\n-// Called to rewind context saved during morestack back to beginning of function.\n-// To help us, the linker emits a jmp back to the beginning right after the\n-// call to morestack. We just have to decode and apply that jump.\n-func rewindmorestack(buf *gobuf) {\n-\tvar inst uint32\n-\tif buf.pc&3 == 0 && buf.pc != 0 {\n-\t\tinst = *(*uint32)(unsafe.Pointer(buf.pc))\n-\t\tif inst>>26 == 2 { // JMP addr\n-\t\t\t//print(\"runtime: rewind pc=\", hex(buf.pc), \" to pc=\", hex(buf.pc &^ uintptr(1<<28-1) | uintptr((inst&^0xfc000000)<<2)), \"\\n\");\n-\t\t\tbuf.pc &^= 1<<28 - 1\n-\t\t\tbuf.pc |= uintptr((inst &^ 0xfc000000) << 2)\n-\t\t\treturn\n-\t\t}\n-\t\tif inst>>16 == 0x1000 { // BEQ\tR0, R0, offset\n-\t\t\t//print(\"runtime: rewind pc=\", hex(buf.pc), \" to pc=\", hex(buf.pc + uintptr(int32(int16(inst&0xffff))<<2 + 4)), \"\\n\");\n-\t\t\tbuf.pc += uintptr(int32(int16(inst&0xffff))<<2 + 4)\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tprint(\"runtime: pc=\", hex(buf.pc), \" \", hex(inst), \"\\n\")\n-\tthrow(\"runtime: misuse of rewindmorestack\")\n-}"}, {"sha": "440937498f72eda623fcdc9ebde45ba51ea50d66", "filename": "libgo/go/runtime/sys_nonppc64x.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsys_nonppc64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsys_nonppc64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsys_nonppc64x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,10 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !ppc64,!ppc64le\n-\n-package runtime\n-\n-func prepGoExitFrame(sp uintptr) {\n-}"}, {"sha": "2aa81e75c06c572b7b93637852f334e8a764395f", "filename": "libgo/go/runtime/sys_s390x.go", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsys_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fsys_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsys_s390x.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-// adjust Gobuf as if it executed a call to fn with context ctxt\n-// and then did an immediate Gosave.\n-func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {\n-\tif buf.lr != 0 {\n-\t\tthrow(\"invalid use of gostartcall\")\n-\t}\n-\tbuf.lr = buf.pc\n-\tbuf.pc = uintptr(fn)\n-\tbuf.ctxt = ctxt\n-}\n-\n-// Called to rewind context saved during morestack back to beginning of function.\n-// To help us, the linker emits a jmp back to the beginning right after the\n-// call to morestack. We just have to decode and apply that jump.\n-func rewindmorestack(buf *gobuf) {\n-\tvar inst uint64\n-\tif buf.pc&1 == 0 && buf.pc != 0 {\n-\t\tinst = *(*uint64)(unsafe.Pointer(buf.pc))\n-\t\tswitch inst >> 48 {\n-\t\tcase 0xa7f4: // BRC (branch relative on condition) instruction.\n-\t\t\tinst >>= 32\n-\t\t\tinst &= 0xFFFF\n-\t\t\toffset := int64(int16(inst))\n-\t\t\toffset <<= 1\n-\t\t\tbuf.pc += uintptr(offset)\n-\t\t\treturn\n-\t\tcase 0xc0f4: // BRCL (branch relative on condition long) instruction.\n-\t\t\tinst >>= 16\n-\t\t\tinst = inst & 0xFFFFFFFF\n-\t\t\tinst = (inst << 1) & 0xFFFFFFFF\n-\t\t\tbuf.pc += uintptr(int32(inst))\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tprint(\"runtime: pc=\", hex(buf.pc), \" \", hex(inst), \"\\n\")\n-\tthrow(\"runtime: misuse of rewindmorestack\")\n-}"}, {"sha": "cd37828ae4c8821844daa186504c1610afd0c10e", "filename": "libgo/go/runtime/vlrt.go", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fvlrt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fvlrt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fvlrt.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,257 +0,0 @@\n-// Inferno's libkern/vlrt-arm.c\n-// http://code.google.com/p/inferno-os/source/browse/libkern/vlrt-arm.c\n-//\n-//         Copyright \u00a9 1994-1999 Lucent Technologies Inc. All rights reserved.\n-//         Revisions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com).  All rights reserved.\n-//         Portions Copyright 2009 The Go Authors. All rights reserved.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a copy\n-// of this software and associated documentation files (the \"Software\"), to deal\n-// in the Software without restriction, including without limitation the rights\n-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-// copies of the Software, and to permit persons to whom the Software is\n-// furnished to do so, subject to the following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included in\n-// all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-// THE SOFTWARE.\n-\n-// +build arm 386\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-const (\n-\tsign32 = 1 << (32 - 1)\n-\tsign64 = 1 << (64 - 1)\n-)\n-\n-func float64toint64(d float64) (y uint64) {\n-\t_d2v(&y, d)\n-\treturn\n-}\n-\n-func float64touint64(d float64) (y uint64) {\n-\t_d2v(&y, d)\n-\treturn\n-}\n-\n-func int64tofloat64(y int64) float64 {\n-\tif y < 0 {\n-\t\treturn -uint64tofloat64(-uint64(y))\n-\t}\n-\treturn uint64tofloat64(uint64(y))\n-}\n-\n-func uint64tofloat64(y uint64) float64 {\n-\thi := float64(uint32(y >> 32))\n-\tlo := float64(uint32(y))\n-\td := hi*(1<<32) + lo\n-\treturn d\n-}\n-\n-func _d2v(y *uint64, d float64) {\n-\tx := *(*uint64)(unsafe.Pointer(&d))\n-\n-\txhi := uint32(x>>32)&0xfffff | 0x100000\n-\txlo := uint32(x)\n-\tsh := 1075 - int32(uint32(x>>52)&0x7ff)\n-\n-\tvar ylo, yhi uint32\n-\tif sh >= 0 {\n-\t\tsh := uint32(sh)\n-\t\t/* v = (hi||lo) >> sh */\n-\t\tif sh < 32 {\n-\t\t\tif sh == 0 {\n-\t\t\t\tylo = xlo\n-\t\t\t\tyhi = xhi\n-\t\t\t} else {\n-\t\t\t\tylo = xlo>>sh | xhi<<(32-sh)\n-\t\t\t\tyhi = xhi >> sh\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif sh == 32 {\n-\t\t\t\tylo = xhi\n-\t\t\t} else if sh < 64 {\n-\t\t\t\tylo = xhi >> (sh - 32)\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\t/* v = (hi||lo) << -sh */\n-\t\tsh := uint32(-sh)\n-\t\tif sh <= 11 {\n-\t\t\tylo = xlo << sh\n-\t\t\tyhi = xhi<<sh | xlo>>(32-sh)\n-\t\t} else {\n-\t\t\t/* overflow */\n-\t\t\tyhi = uint32(d) /* causes something awful */\n-\t\t}\n-\t}\n-\tif x&sign64 != 0 {\n-\t\tif ylo != 0 {\n-\t\t\tylo = -ylo\n-\t\t\tyhi = ^yhi\n-\t\t} else {\n-\t\t\tyhi = -yhi\n-\t\t}\n-\t}\n-\n-\t*y = uint64(yhi)<<32 | uint64(ylo)\n-}\n-\n-func uint64div(n, d uint64) uint64 {\n-\t// Check for 32 bit operands\n-\tif uint32(n>>32) == 0 && uint32(d>>32) == 0 {\n-\t\tif uint32(d) == 0 {\n-\t\t\tpanicdivide()\n-\t\t}\n-\t\treturn uint64(uint32(n) / uint32(d))\n-\t}\n-\tq, _ := dodiv(n, d)\n-\treturn q\n-}\n-\n-func uint64mod(n, d uint64) uint64 {\n-\t// Check for 32 bit operands\n-\tif uint32(n>>32) == 0 && uint32(d>>32) == 0 {\n-\t\tif uint32(d) == 0 {\n-\t\t\tpanicdivide()\n-\t\t}\n-\t\treturn uint64(uint32(n) % uint32(d))\n-\t}\n-\t_, r := dodiv(n, d)\n-\treturn r\n-}\n-\n-func int64div(n, d int64) int64 {\n-\t// Check for 32 bit operands\n-\tif int64(int32(n)) == n && int64(int32(d)) == d {\n-\t\tif int32(n) == -0x80000000 && int32(d) == -1 {\n-\t\t\t// special case: 32-bit -0x80000000 / -1 = -0x80000000,\n-\t\t\t// but 64-bit -0x80000000 / -1 = 0x80000000.\n-\t\t\treturn 0x80000000\n-\t\t}\n-\t\tif int32(d) == 0 {\n-\t\t\tpanicdivide()\n-\t\t}\n-\t\treturn int64(int32(n) / int32(d))\n-\t}\n-\n-\tnneg := n < 0\n-\tdneg := d < 0\n-\tif nneg {\n-\t\tn = -n\n-\t}\n-\tif dneg {\n-\t\td = -d\n-\t}\n-\tuq, _ := dodiv(uint64(n), uint64(d))\n-\tq := int64(uq)\n-\tif nneg != dneg {\n-\t\tq = -q\n-\t}\n-\treturn q\n-}\n-\n-func int64mod(n, d int64) int64 {\n-\t// Check for 32 bit operands\n-\tif int64(int32(n)) == n && int64(int32(d)) == d {\n-\t\tif int32(d) == 0 {\n-\t\t\tpanicdivide()\n-\t\t}\n-\t\treturn int64(int32(n) % int32(d))\n-\t}\n-\n-\tnneg := n < 0\n-\tif nneg {\n-\t\tn = -n\n-\t}\n-\tif d < 0 {\n-\t\td = -d\n-\t}\n-\t_, ur := dodiv(uint64(n), uint64(d))\n-\tr := int64(ur)\n-\tif nneg {\n-\t\tr = -r\n-\t}\n-\treturn r\n-}\n-\n-//go:noescape\n-func _mul64by32(lo64 *uint64, a uint64, b uint32) (hi32 uint32)\n-\n-//go:noescape\n-func _div64by32(a uint64, b uint32, r *uint32) (q uint32)\n-\n-func dodiv(n, d uint64) (q, r uint64) {\n-\tif GOARCH == \"arm\" {\n-\t\t// arm doesn't have a division instruction, so\n-\t\t// slowdodiv is the best that we can do.\n-\t\treturn slowdodiv(n, d)\n-\t}\n-\n-\tif d > n {\n-\t\treturn 0, n\n-\t}\n-\n-\tif uint32(d>>32) != 0 {\n-\t\tt := uint32(n>>32) / uint32(d>>32)\n-\t\tvar lo64 uint64\n-\t\thi32 := _mul64by32(&lo64, d, t)\n-\t\tif hi32 != 0 || lo64 > n {\n-\t\t\treturn slowdodiv(n, d)\n-\t\t}\n-\t\treturn uint64(t), n - lo64\n-\t}\n-\n-\t// d is 32 bit\n-\tvar qhi uint32\n-\tif uint32(n>>32) >= uint32(d) {\n-\t\tif uint32(d) == 0 {\n-\t\t\tpanicdivide()\n-\t\t}\n-\t\tqhi = uint32(n>>32) / uint32(d)\n-\t\tn -= uint64(uint32(d)*qhi) << 32\n-\t} else {\n-\t\tqhi = 0\n-\t}\n-\n-\tvar rlo uint32\n-\tqlo := _div64by32(n, uint32(d), &rlo)\n-\treturn uint64(qhi)<<32 + uint64(qlo), uint64(rlo)\n-}\n-\n-func slowdodiv(n, d uint64) (q, r uint64) {\n-\tif d == 0 {\n-\t\tpanicdivide()\n-\t}\n-\n-\t// Set up the divisor and find the number of iterations needed.\n-\tcapn := n\n-\tif n >= sign64 {\n-\t\tcapn = sign64\n-\t}\n-\ti := 0\n-\tfor d < capn {\n-\t\td <<= 1\n-\t\ti++\n-\t}\n-\n-\tfor ; i >= 0; i-- {\n-\t\tq <<= 1\n-\t\tif n >= d {\n-\t\t\tn -= d\n-\t\t\tq |= 1\n-\t\t}\n-\t\td >>= 1\n-\t}\n-\treturn q, n\n-}"}, {"sha": "6b1467b1c48aefe65671e7354262cdec2b853780", "filename": "libgo/go/runtime/write_err.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fwrite_err.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fwrite_err.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fwrite_err.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !android\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-func writeErr(b []byte) {\n-\twrite(2, unsafe.Pointer(&b[0]), int32(len(b)))\n-}"}, {"sha": "4411a1475548994e4cf2e990fb5bf90bb3c1456b", "filename": "libgo/go/runtime/write_err_android.go", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fwrite_err_android.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fruntime%2Fwrite_err_android.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fwrite_err_android.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,160 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-var (\n-\twriteHeader = []byte{6 /* ANDROID_LOG_ERROR */, 'G', 'o', 0}\n-\twritePath   = []byte(\"/dev/log/main\\x00\")\n-\twriteLogd   = []byte(\"/dev/socket/logdw\\x00\")\n-\n-\t// guarded by printlock/printunlock.\n-\twriteFD  uintptr\n-\twriteBuf [1024]byte\n-\twritePos int\n-)\n-\n-// Prior to Android-L, logging was done through writes to /dev/log files implemented\n-// in kernel ring buffers. In Android-L, those /dev/log files are no longer\n-// accessible and logging is done through a centralized user-mode logger, logd.\n-//\n-// https://android.googlesource.com/platform/system/core/+/master/liblog/logd_write.c\n-type loggerType int32\n-\n-const (\n-\tunknown loggerType = iota\n-\tlegacy\n-\tlogd\n-\t// TODO(hakim): logging for emulator?\n-)\n-\n-var logger loggerType\n-\n-func writeErr(b []byte) {\n-\tif logger == unknown {\n-\t\t// Use logd if /dev/socket/logdw is available.\n-\t\tif v := uintptr(access(&writeLogd[0], 0x02 /* W_OK */)); v == 0 {\n-\t\t\tlogger = logd\n-\t\t\tinitLogd()\n-\t\t} else {\n-\t\t\tlogger = legacy\n-\t\t\tinitLegacy()\n-\t\t}\n-\t}\n-\n-\t// Write to stderr for command-line programs.\n-\twrite(2, unsafe.Pointer(&b[0]), int32(len(b)))\n-\n-\t// Log format: \"<header>\\x00<message m bytes>\\x00\"\n-\t//\n-\t// <header>\n-\t//   In legacy mode: \"<priority 1 byte><tag n bytes>\".\n-\t//   In logd mode: \"<android_log_header_t 11 bytes><priority 1 byte><tag n bytes>\"\n-\t//\n-\t// The entire log needs to be delivered in a single syscall (the NDK\n-\t// does this with writev). Each log is its own line, so we need to\n-\t// buffer writes until we see a newline.\n-\tvar hlen int\n-\tswitch logger {\n-\tcase logd:\n-\t\thlen = writeLogdHeader()\n-\tcase legacy:\n-\t\thlen = len(writeHeader)\n-\t}\n-\n-\tdst := writeBuf[hlen:]\n-\tfor _, v := range b {\n-\t\tif v == 0 { // android logging won't print a zero byte\n-\t\t\tv = '0'\n-\t\t}\n-\t\tdst[writePos] = v\n-\t\twritePos++\n-\t\tif v == '\\n' || writePos == len(dst)-1 {\n-\t\t\tdst[writePos] = 0\n-\t\t\twrite(writeFD, unsafe.Pointer(&writeBuf[0]), int32(hlen+writePos))\n-\t\t\tmemclrBytes(dst)\n-\t\t\twritePos = 0\n-\t\t}\n-\t}\n-}\n-\n-func initLegacy() {\n-\t// In legacy mode, logs are written to /dev/log/main\n-\twriteFD = uintptr(open(&writePath[0], 0x1 /* O_WRONLY */, 0))\n-\tif writeFD == 0 {\n-\t\t// It is hard to do anything here. Write to stderr just\n-\t\t// in case user has root on device and has run\n-\t\t//\tadb shell setprop log.redirect-stdio true\n-\t\tmsg := []byte(\"runtime: cannot open /dev/log/main\\x00\")\n-\t\twrite(2, unsafe.Pointer(&msg[0]), int32(len(msg)))\n-\t\texit(2)\n-\t}\n-\n-\t// Prepopulate the invariant header part.\n-\tcopy(writeBuf[:len(writeHeader)], writeHeader)\n-}\n-\n-// used in initLogdWrite but defined here to avoid heap allocation.\n-var logdAddr sockaddr_un\n-\n-func initLogd() {\n-\t// In logd mode, logs are sent to the logd via a unix domain socket.\n-\tlogdAddr.family = _AF_UNIX\n-\tcopy(logdAddr.path[:], writeLogd)\n-\n-\t// We are not using non-blocking I/O because writes taking this path\n-\t// are most likely triggered by panic, we cannot think of the advantage of\n-\t// non-blocking I/O for panic but see disadvantage (dropping panic message),\n-\t// and blocking I/O simplifies the code a lot.\n-\tfd := socket(_AF_UNIX, _SOCK_DGRAM|_O_CLOEXEC, 0)\n-\tif fd < 0 {\n-\t\tmsg := []byte(\"runtime: cannot create a socket for logging\\x00\")\n-\t\twrite(2, unsafe.Pointer(&msg[0]), int32(len(msg)))\n-\t\texit(2)\n-\t}\n-\n-\terrno := connect(fd, unsafe.Pointer(&logdAddr), int32(unsafe.Sizeof(logdAddr)))\n-\tif errno < 0 {\n-\t\tmsg := []byte(\"runtime: cannot connect to /dev/socket/logdw\\x00\")\n-\t\twrite(2, unsafe.Pointer(&msg[0]), int32(len(msg)))\n-\t\t// TODO(hakim): or should we just close fd and hope for better luck next time?\n-\t\texit(2)\n-\t}\n-\twriteFD = uintptr(fd)\n-\n-\t// Prepopulate invariant part of the header.\n-\t// The first 11 bytes will be populated later in writeLogdHeader.\n-\tcopy(writeBuf[11:11+len(writeHeader)], writeHeader)\n-}\n-\n-// writeLogdHeader populates the header and returns the length of the payload.\n-func writeLogdHeader() int {\n-\thdr := writeBuf[:11]\n-\n-\t// The first 11 bytes of the header corresponds to android_log_header_t\n-\t// as defined in system/core/include/private/android_logger.h\n-\t//   hdr[0] log type id (unsigned char), defined in <log/log.h>\n-\t//   hdr[1:2] tid (uint16_t)\n-\t//   hdr[3:11] log_time defined in <log/log_read.h>\n-\t//      hdr[3:7] sec unsigned uint32, little endian.\n-\t//      hdr[7:11] nsec unsigned uint32, little endian.\n-\thdr[0] = 0 // LOG_ID_MAIN\n-\tsec, nsec := time_now()\n-\tpackUint32(hdr[3:7], uint32(sec))\n-\tpackUint32(hdr[7:11], uint32(nsec))\n-\n-\t// TODO(hakim):  hdr[1:2] = gettid?\n-\n-\treturn 11 + len(writeHeader)\n-}\n-\n-func packUint32(b []byte, v uint32) {\n-\t// little-endian.\n-\tb[0] = byte(v)\n-\tb[1] = byte(v >> 8)\n-\tb[2] = byte(v >> 16)\n-\tb[3] = byte(v >> 24)\n-}"}, {"sha": "4b06f8a0c18f353d2ca03500f657a7475d601e57", "filename": "libgo/go/strings/strings_amd64.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fstrings%2Fstrings_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fstrings%2Fstrings_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_amd64.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package strings\n \n // indexShortStr returns the index of the first instance of c in s, or -1 if c is not present in s."}, {"sha": "aef2c1e355b2b6d9603855dd31251ce908361fda", "filename": "libgo/go/strings/strings_generic.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fstrings%2Fstrings_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fstrings%2Fstrings_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_generic.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64\n-\n package strings\n \n // TODO: implements short string optimization on non amd64 platforms"}, {"sha": "25b0063e76f49e3b0d5d1da234dac3feb654f539", "filename": "libgo/go/syscall/errstr.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Ferrstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Ferrstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !linux\n+\n package syscall\n \n //sysnb\tstrerror_r(errnum int, buf []byte) (err Errno)"}, {"sha": "7156b790da5e96ce27b6fa113bb89ed5c9a7b69c", "filename": "libgo/go/syscall/errstr_linux.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Ferrstr_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Ferrstr_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr_linux.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -1,9 +1,12 @@\n-// errstr_rtems.go -- RTEMS specific error strings.\n+// errstr_linux.go -- GNU/Linux specific error strings.\n \n // Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// We use this rather than errstr.go because on GNU/Linux sterror_r\n+// returns a pointer to the error message, and may not use buf at all.\n+\n package syscall\n \n import \"unsafe\""}, {"sha": "796561adda08a5fd34fe808f616fbcb4ce9a8b20", "filename": "libgo/go/syscall/errstr_nor.go", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fsyscall%2Ferrstr_nor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fsyscall%2Ferrstr_nor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr_nor.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,41 +0,0 @@\n-// errstr.go -- Error strings when there is no strerror_r.\n-\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import (\n-\t\"sync\"\n-\t\"unsafe\"\n-)\n-\n-//sysnb\tstrerror(errnum int) (buf *byte)\n-//strerror(errnum _C_int) *byte\n-\n-var errstr_lock sync.Mutex\n-\n-func Errstr(errno int) string {\n-\terrstr_lock.Lock()\n-\n-\tbp := strerror(errno)\n-\tb := (*[1000]byte)(unsafe.Pointer(bp))\n-\ti := 0\n-\tfor b[i] != 0 {\n-\t\ti++\n-\t}\n-\n-\t// Lowercase first letter: Bad -> bad, but STREAM -> STREAM.\n-\tvar s string\n-\tif i > 1 && 'A' <= b[0] && b[0] <= 'Z' && 'a' <= b[1] && b[1] <= 'z' {\n-\t\tc := b[0] + 'a' - 'A'\n-\t\ts = string(c) + string(b[1:i])\n-\t} else {\n-\t\ts = string(b[:i])\n-\t}\n-\n-\terrstr_lock.Unlock()\n-\n-\treturn s\n-}"}, {"sha": "af025e4c0472dc76e984d44008568143de6f23e3", "filename": "libgo/go/syscall/exec_bsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin dragonfly freebsd netbsd openbsd\n+// +build darwin dragonfly freebsd netbsd openbsd solaris\n \n package syscall\n "}, {"sha": "e95b4158e1a073a80370e0b0eebe56fed9f67b33", "filename": "libgo/go/syscall/exec_stubs.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build rtems\n+\n // Stubs for fork, exec and wait.\n \n package syscall"}, {"sha": "9a4b2d65825fe985c8a59b56f03f7fb86eb53461", "filename": "libgo/go/syscall/libcall_bsd.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_bsd.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin dragonfly freebsd netbsd openbsd solaris\n+\n // BSD library calls.\n \n package syscall"}, {"sha": "9b6cdcca2c81cfbcceb3b5a2941827a91522bd9b", "filename": "libgo/go/syscall/libcall_irix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_irix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_irix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_irix.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build irix\n+\n package syscall\n \n //sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (err Errno)"}, {"sha": "261f086f47e2f8647287fc11cbdd746f2570d069", "filename": "libgo/go/syscall/libcall_linux_ustat.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_linux_ustat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_linux_ustat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux_ustat.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,7 @@\n \n // GNU/Linux library ustat call.\n // This is not supported on some kernels, such as arm64.\n+// +build !arm64\n \n package syscall\n "}, {"sha": "1f437b41fb260b04795fc3016c91f28bc83819b7", "filename": "libgo/go/syscall/libcall_posix_largefile.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux solaris,386 solaris,sparc\n+\n // POSIX library calls on systems which use the largefile interface.\n \n package syscall"}, {"sha": "d106a7b6f68b2705e8544183f55139b63cfb6de5", "filename": "libgo/go/syscall/libcall_posix_regfile.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !linux\n+// +build !solaris !386\n+// +build !solaris !sparc\n+\n // POSIX library calls on systems which do not use the largefile\n // interface.\n "}, {"sha": "5d9d02eba34ed8455a801240ed0d5a39776cdc4f", "filename": "libgo/go/syscall/libcall_posix_utimesnano.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_posix_utimesnano.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_posix_utimesnano.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_utimesnano.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin dragonfly freebsd openbsd netbsd solaris\n+\n // General POSIX version of UtimesNano.\n \n package syscall"}, {"sha": "165b3251b6e1ff1f482d82939f16bb805cb37d16", "filename": "libgo/go/syscall/libcall_uname.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// Build on all systems other than solaris/386.\n+// 32-bit Solaris 2/x86 needs _nuname, handled in libcall_solaris_386.go.\n+// +build !386 !solaris\n+\n package syscall\n \n //sysnb\tUname(buf *Utsname) (err error)"}, {"sha": "b0e04b5bab3ba27bf4d7c0787d21a7d727cf2ea8", "filename": "libgo/go/syscall/libcall_waitpid.go", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// For systems with the waitpid library call.\n-\n-package syscall\n-\n-//sys\twaitpid(pid Pid_t, status *_C_int, options int) (wpid Pid_t, err error)\n-//waitpid(pid Pid_t, status *_C_int, options _C_int) Pid_t\n-\n-func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {\n-\tvar status _C_int\n-\tr, err := waitpid(Pid_t(pid), &status, options)\n-\twpid = int(r)\n-\tif wstatus != nil {\n-\t\t*wstatus = WaitStatus(status)\n-\t}\n-\treturn\n-}"}, {"sha": "baaad6df984cbf93f3489df2bb488375736792d5", "filename": "libgo/go/syscall/msan.go", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fsyscall%2Fmsan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d712e9a7e2ec4de5e6e9f72b85b620e719757ee3/libgo%2Fgo%2Fsyscall%2Fmsan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fmsan.go?ref=d712e9a7e2ec4de5e6e9f72b85b620e719757ee3", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build msan\n-\n-package syscall\n-\n-import (\n-\t\"runtime\"\n-\t\"unsafe\"\n-)\n-\n-const msanenabled = true\n-\n-func msanRead(addr unsafe.Pointer, len int) {\n-\truntime.MSanRead(addr, len)\n-}\n-\n-func msanWrite(addr unsafe.Pointer, len int) {\n-\truntime.MSanWrite(addr, len)\n-}"}, {"sha": "480c77556540d17a1d6bfc8d1b85d69fc03c21a5", "filename": "libgo/go/syscall/sleep_rtems.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build rtems\n+\n package syscall\n \n func Sleep(nsec int64) (err error) {"}, {"sha": "bb1694fceec37d61dcedb929240eaff4f6820916", "filename": "libgo/go/syscall/sleep_select.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsleep_select.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsleep_select.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsleep_select.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,10 +4,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !rtems\n+\n package syscall\n \n func Sleep(nsec int64) (err error) {\n-\ttv := NsecToTimeval(nsec);\n-\t_, err = Select(0, nil, nil, nil, &tv);\n-\treturn err;\n+\ttv := NsecToTimeval(nsec)\n+\t_, err = Select(0, nil, nil, nil, &tv)\n+\treturn err\n }"}, {"sha": "0f0962729ed1d9d43a15701ea6a34d6092c36b31", "filename": "libgo/go/syscall/socket_bsd.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin dragonfly freebsd openbsd netbsd\n+\n package syscall\n \n const SizeofSockaddrInet4 = 16"}, {"sha": "dc50fdd24fa39384cac2760bb2395e4adcf764b5", "filename": "libgo/go/syscall/socket_irix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build irix\n+\n package syscall\n \n const SizeofSockaddrInet4 = 16"}, {"sha": "96afdeb85fdf68dd31638350d0eb96b9ac202fbb", "filename": "libgo/go/syscall/socket_linux_ppc64x_type.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_linux_ppc64x_type.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_linux_ppc64x_type.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_linux_ppc64x_type.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux,ppc64 linux,ppc64le\n+\n package syscall\n \n // Type needed on ppc64le & ppc64"}, {"sha": "190c11cc27037e806e6ba6bee0de12fa23819bbc", "filename": "libgo/go/syscall/socket_linux_type.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_linux_type.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_linux_type.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_linux_type.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux\n+// +build !ppc64\n+// +build !ppc64le\n+\n package syscall\n \n // Type needed if not on ppc64le or ppc64"}, {"sha": "fe835d3c43e40d1abdb74e28eb21dc760e3d34d6", "filename": "libgo/go/syscall/socket_posix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_posix.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -4,6 +4,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !solaris\n+\n package syscall\n \n //sys\tbind(fd int, sa *RawSockaddrAny, len Socklen_t) (err error)"}, {"sha": "c0699c44a894308f2e309d08580eea7c2e8cc7da", "filename": "libgo/go/syscall/socket_xnet.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_xnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsocket_xnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_xnet.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -5,6 +5,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build solaris\n+\n package syscall\n \n //sys\tbind(fd int, sa *RawSockaddrAny, len Socklen_t) (err error)"}, {"sha": "00288ee5ea7284a0e538bd210da7f89dcdaf67af", "filename": "libgo/go/syscall/syscall_stubs.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsyscall_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgo%2Fsyscall%2Fsyscall_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_stubs.go?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build rtems\n+\n // These are stubs.\n \n package syscall"}, {"sha": "0da5d07bdf9db53a44b5657f86482f67b6252a60", "filename": "libgo/godeps.sh", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgodeps.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fgodeps.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgodeps.sh?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -22,11 +22,12 @@ fi\n output=$1\n shift\n \n-deps=`for f in $*; do cat $f; done | \n+files=$*\n+deps=`for f in $files; do cat $f; done | \n   sed -n -e '/^import.*\"/p; /^import[ \t]*(/,/^)/p' |\n   grep '\"' |\n   grep -v '\"unsafe\"' |\n   sed -e 's/^.*\"\\([^\"]*\\)\".*$/\\1/' -e 's/$/.gox/' |\n   sort -u`\n \n-echo $output: $deps\n+echo $output: $files $deps"}, {"sha": "e415acdbc2cf4e1e6a682ef85dff2edad3de576a", "filename": "libgo/match.sh", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fmatch.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fmatch.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmatch.sh?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -0,0 +1,197 @@\n+#!/bin/sh\n+\n+# Copyright 2016 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# Given a source directory, returns the non-test Go files that should\n+# be built for this target.  This implements Go's build constraints in\n+# a shell script.  There is similar code in testsuite/gotest.\n+\n+set -e\n+\n+unset LANG\n+LC_ALL=C\n+LC_CTYPE=C\n+export LC_ALL LC_CTYPE\n+\n+srcdir=\"\"\n+goarch=\"\"\n+goos=\"\"\n+extrafiles=\"\"\n+cmdlinetag=\"nosuchtag\"\n+cgotag=\"cgo\"\n+\n+for arg; do\n+    case \"x$arg\" in\n+\tx--srcdir)\n+\t    srcdir=$2\n+\t    shift\n+\t    shift\n+\t    ;;\n+\tx--srcdir=*)\n+\t    srcdir=`echo $1 | sed -e 's/^--srcdir=//'`\n+\t    shift\n+\t    ;;\n+\tx--goarch)\n+\t    goarch=$2\n+\t    shift\n+\t    shift\n+\t    ;;\n+\tx--goarch=*)\n+\t    goarch=`echo $1 | sed -e 's/^--goarch=//'`\n+\t    shift\n+\t    ;;\n+\tx--goos)\n+\t    goos=$2\n+\t    shift\n+\t    shift\n+\t    ;;\n+\tx--goos=*)\n+\t    goos=`echo $1 | sed -e 's/^--goos=//'`\n+\t    shift\n+\t    ;;\n+\tx--extrafiles)\n+\t    extrafiles=$2\n+\t    shift\n+\t    shift\n+\t    ;;\n+\tx--extrafiles=*)\n+\t    extrafiles=`echo $1 | sed -e 's/^--extrafiles=//'`\n+\t    shift\n+\t    ;;\n+\tx--tag)\n+\t    cmdlinetag=$2\n+\t    shift\n+\t    shift\n+\t    ;;\n+\tx--tag=*)\n+\t    cmdlinetag=`echo $1 | sed -e 's/^--tag=//'`\n+\t    shift\n+\t    ;;\n+\tx--nocgo)\n+\t    cgotag=\"nosuchtag\"\n+\t    shift\n+\t    ;;\n+\t*)\n+\t    echo 1>&2 \"unknown argument $arg\"\n+\t    exit 1\n+\t    ;;\n+    esac\n+done\n+\n+cd $srcdir\n+\n+gofiles=\n+for f in *.go; do\n+    case $f in\n+\t*_test.go)\n+\t    ;;\n+\t*.go)\n+\t    gofiles=\"$gofiles $f\"\n+\t    ;;\n+    esac\n+done\n+\n+if test \"$gofiles\" = \"\"; then\n+    echo 1>&2 \"no non-test .go files in $srcdir\"\n+    exit 1\n+fi\n+\n+matched=\n+for f in $gofiles; do\n+    tag1=`echo $f | sed -e 's/^.*_\\([^_]*\\).go$/\\1/'`\n+    tag2=`echo $f | sed -e 's/^.*_\\([^_]*\\)_[^_]*.go$/\\1/'`\n+    if test x$tag1 = x$f; then\n+\ttag1=\n+    fi\n+    if test x$tag2 = x$f; then\n+\ttag2=\n+    fi\n+\n+    case \"$tag1\" in\n+\t\"\") ;;\n+\t$goarch) ;;\n+\t$goos) ;;\n+\tandroid | darwin | dragonfly | freebsd | linux | nacl | netbsd | openbsd | plan9 | solaris | windows)\n+\t    tag1=nonmatchingtag\n+\t    ;;\n+\t386 | amd64 | amd64p32 | arm | armbe | arm64 | arm64be | alpha | m68k | ppc64 | ppc64le | mips | mipsle | mips64 | mips64le | mips64p32 | mips64p32le | mipso32 | mipsn32 | mipsn64 | mipso64 | ppc | s390 | s390x | sparc | sparc64)\n+\t    tag1=nonmatchingtag\n+\t    ;;\n+    esac\n+\n+    case \"$tag2\" in\n+\t\"\") ;;\n+\t$goarch) ;;\n+\t$goos) ;;\n+\tandroid | darwin | dragonfly | freebsd | linux | nacl | netbsd | openbsd | plan9 | solaris | windows)\n+\t    tag2=nonmatchingtag\n+\t    ;;\n+\t386 | amd64 | amd64p32 | arm | armbe | arm64 | arm64be | alpha | m68k | ppc64 | ppc64le | mips | mipsle | mips64 | mips64le | mips64p32 | mips64p32le | mipso32 | mipsn32 | mipsn64 | mipso64 | ppc | s390 | s390x | sparc | sparc64)\n+\t    tag2=nonmatchingtag\n+\t    ;;\n+    esac\n+\n+    if test x$tag1 != xnonmatchingtag -a x$tag2 != xnonmatchingtag; then\n+\t# Pipe through cat so that `set -e` doesn't affect fgrep.\n+\ttags=`sed '/^package /q' < $f | grep '^// +build ' | cat`\n+\tomatch=true\n+\tfirst=true\n+\tmatch=false\n+\tfor tag in $tags; do\n+\t    case $tag in\n+\t\t\"//\")\n+\t\t    ;;\n+\t\t\"+build\")\n+\t\t    if test \"$first\" = \"true\"; then\n+\t\t\tfirst=false\n+\t\t    elif test \"$match\" = \"false\"; then\n+\t\t\tomatch=false\n+\t\t    fi\n+\t\t    match=false\n+\t\t    ;;\n+\t\t$goos | $goarch | $cgotag | $cmdlinetag)\n+\t\t    match=true\n+\t\t    ;;\n+\t\t\"!\"$goos | \"!\"$goarch | \"!\"$cgotag | \"!\"$cmdlinetag)\n+\t\t    ;;\n+\t\t*,*)\n+\t\t    cmatch=true\n+\t\t    for ctag in `echo $tag | sed -e 's/,/ /g'`; do\n+\t\t\tcase $ctag in\n+\t\t\t    $goos | $goarch | $cgotag | $cmdlinetag)\n+\t\t\t\t;;\n+\t\t\t    \"!\"$goos | \"!\"$goarch | \"!\"$cgotag | \"!\"$cmdlinetag)\n+\t\t\t\tcmatch=false\n+\t\t\t\t;;\n+\t\t\t    \"!\"*)\n+\t\t\t\t;;\n+\t\t\t    *)\n+\t\t\t\tcmatch=false\n+\t\t\t\t;;\n+\t\t\tesac\n+\t\t    done\n+\t\t    if test \"$cmatch\" = \"true\"; then\n+\t\t\tmatch=true\n+\t\t    fi\n+\t\t    ;;\n+\t\t\"!\"*)\n+\t\t    match=true\n+\t\t    ;;\n+\t    esac\n+\tdone\n+\n+\tif test \"$match\" = \"false\" -a \"$first\" = \"false\"; then\n+\t    omatch=false\n+\tfi\n+\n+\tif test \"$omatch\" = \"true\"; then\n+\t    matched=\"$matched $srcdir/$f\"\n+\tfi\n+    fi\n+done\n+\n+echo $matched $extrafiles\n+\n+exit 0"}, {"sha": "be8fb3ef19b936f1baf07e37081bb096fd3f7f66", "filename": "libgo/runtime/go-nosys.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fruntime%2Fgo-nosys.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Fruntime%2Fgo-nosys.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-nosys.c?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -14,11 +14,16 @@\n #include <errno.h>\n #include <fcntl.h>\n #include <math.h>\n+#include <pthread.h>\n #include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n #include <sys/types.h>\n+#include <sys/resource.h>\n #include <sys/socket.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n+#include <sys/wait.h>\n #include <time.h>\n #include <unistd.h>\n \n@@ -448,3 +453,54 @@ log1pl (long double a)\n   return (long double) log1p ((double) a);\n }\n #endif\n+\n+#ifndef HAVE_STRERROR_R\n+\n+/* Some old systems do not have strerror_r.  This is a replacement.\n+   It assumes that nothing else in the program calls strerror.  */\n+\n+static pthread_mutex_t strerror_lock = PTHREAD_MUTEX_INITIALIZER;\n+\n+int\n+strerror_r (int errnum, char *buf, size_t buflen)\n+{\n+  int i;\n+  char *errmsg;\n+  size_t len;\n+  int ret;\n+\n+  i = pthread_mutex_lock (&strerror_lock);\n+  if (i != 0)\n+    abort ();\n+\n+  errmsg = strerror (errnum);\n+  len = strlen (errmsg);\n+  if (len >= buflen)\n+    ret = ERANGE;\n+  else\n+    {\n+      memcpy (buf, errmsg, len + 1);\n+      ret = 0;\n+    }\n+\n+  i = pthread_mutex_unlock (&strerror_lock);\n+  if (i != 0)\n+    abort ();\n+\n+  return ret;\n+}\n+\n+#endif /* ! HAVE_STRERROR_R */\n+\n+#ifndef HAVE_WAIT4\n+\n+/* Some old systems do not have wait4.  This is a replacement that\n+   uses waitpid.  */\n+\n+pid_t\n+wait4 (pid_t pid, int *status, int options, struct rusage *rusage __attribute__ ((unused)))\n+{\n+  return waitpid (pid, status, options);\n+}\n+\n+#endif"}, {"sha": "0957805a78d4837a6a52c7ce23c7c9deff994cab", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f69f36ea1e068cb9aa48ea0d274b98530f2488/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=e0f69f36ea1e068cb9aa48ea0d274b98530f2488", "patch": "@@ -313,19 +313,11 @@ x)\n \t    esac\n \n \t    if test x$tag1 != xnonmatchingtag -a x$tag2 != xnonmatchingtag; then\n-\t\ttags=`sed '/^package /q' < $f | fgrep '// +build '`\n+\t\ttags=`sed '/^package /q' < $f | grep '^// +build '`\n \t\tomatch=true\n \t\tfirst=true\n \t\tmatch=false\n \t\tfor tag in $tags; do\n-\t\t    reverse=false\n-\t\t    case $tag in\n-\t\t    \"!\"*)\n-\t\t\treverse=true\n-\t\t\ttag=`echo $tag | sed -e 's/^!//'`\n-\t\t\t;;\n-\t\t    esac\n-\n \t\t    case $tag in\n \t\t    \"//\")\n \t\t\t;;\n@@ -340,27 +332,32 @@ x)\n \t\t    $goos | $goarch | cgo)\n \t\t\tmatch=true\n \t\t\t;;\n+\t\t    \"!\"$goos | \"!\"$goarch | \"!cgo\")\n+\t\t\t;;\n \t\t    *,*)\n-\t\t\tmatch=true\n+\t\t\tcmatch=true\n \t\t\tfor ctag in `echo $tag | sed -e 's/,/ /g'`; do\n \t\t\t    case $ctag in\n \t\t\t    $goos | $goarch | cgo)\n \t\t\t\t;;\n+\t\t\t    \"!\"$goos | \"!\"$goarch | \"!cgo\")\n+\t\t\t\tcmatch=false\n+\t\t\t\t;;\n+\t\t\t    \"!\"*)\n+\t\t\t        ;;\n \t\t\t    *)\n-\t\t\t\tmatch=false\n+\t\t\t\tcmatch=false\n \t\t\t\t;;\n \t\t\t    esac\n \t\t\tdone\n-\t\t\t;;\n-\t\t    esac\n-\n-\t\t    if test \"$reverse\" = true; then\n-\t\t\tif test \"$match\" = true; then\n-\t\t\t    match=false\n-\t\t\telse\n+\t\t\tif test \"$cmatch\" = \"true\"; then\n \t\t\t    match=true\n \t\t\tfi\n-\t\t    fi\n+\t\t\t;;\n+\t\t    \"!\"*)\n+\t\t\tmatch=true\n+\t\t\t;;\n+\t\t    esac\n \t\tdone\n \n \t\tif test \"$match\" = \"false\" -a \"$first\" = \"false\"; then"}]}