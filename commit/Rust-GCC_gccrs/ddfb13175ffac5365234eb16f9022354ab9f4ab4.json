{"sha": "ddfb13175ffac5365234eb16f9022354ab9f4ab4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRmYjEzMTc1ZmZhYzUzNjUyMzRlYjE2ZjkwMjIzNTRhYjlmNGFiNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-12-16T12:05:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-12-16T12:05:04Z"}, "message": "ipa-fnsummary.c (analyze_function_body): Do not loeak conds and size_time_table.\n\n\n\t* ipa-fnsummary.c (analyze_function_body): Do not loeak conds and\n\tsize_time_table.\n\t(ipa_fn_summary_generate): Add prevails parameter; do not allocate\n\tdata when symbol is not prevailing.\n\t(inline_read_section): Likewise.\n\nFrom-SVN: r267185", "tree": {"sha": "36416e9d74f31f38a52be034c239b0d0e188f743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36416e9d74f31f38a52be034c239b0d0e188f743"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddfb13175ffac5365234eb16f9022354ab9f4ab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddfb13175ffac5365234eb16f9022354ab9f4ab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddfb13175ffac5365234eb16f9022354ab9f4ab4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddfb13175ffac5365234eb16f9022354ab9f4ab4/comments", "author": null, "committer": null, "parents": [{"sha": "19adb97a310cd398814c5ccb75580b1658433cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19adb97a310cd398814c5ccb75580b1658433cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19adb97a310cd398814c5ccb75580b1658433cfc"}], "stats": {"total": 96, "additions": 72, "deletions": 24}, "files": [{"sha": "eda1061497bdb5b76c7b2089fdc968096a5a6ebf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfb13175ffac5365234eb16f9022354ab9f4ab4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfb13175ffac5365234eb16f9022354ab9f4ab4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddfb13175ffac5365234eb16f9022354ab9f4ab4", "patch": "@@ -1,3 +1,11 @@\n+2018-12-15  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (analyze_function_body): Do not loeak conds and\n+\tsize_time_table.\n+\t(ipa_fn_summary_generate): Add prevails parameter; do not allocate\n+\tdata when symbol is not prevailing.\n+\t(inline_read_section): Likewise.\n+\n 2018-12-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraph.h (cgraph_node): Add predicate prevailing_p."}, {"sha": "2f038909ab4677cfaf4eabe12177976ff5a5f5bb", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfb13175ffac5365234eb16f9022354ab9f4ab4/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfb13175ffac5365234eb16f9022354ab9f4ab4/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=ddfb13175ffac5365234eb16f9022354ab9f4ab4", "patch": "@@ -1990,7 +1990,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   gcc_assert (cfun == my_function);\n \n   memset(&fbi, 0, sizeof(fbi));\n+  vec_free (info->conds);\n   info->conds = NULL;\n+  vec_free (info->size_time_table);\n   info->size_time_table = NULL;\n \n   /* When optimizing and analyzing for IPA inliner, initialize loop optimizer\n@@ -3193,28 +3195,46 @@ ipa_fn_summary_generate (void)\n /* Write inline summary for edge E to OB.  */\n \n static void\n-read_ipa_call_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n+read_ipa_call_summary (struct lto_input_block *ib, struct cgraph_edge *e,\n+\t\t       bool prevails)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+  struct ipa_call_summary *es = prevails\n+\t\t\t\t? ipa_call_summaries->get_create (e) : NULL;\n   predicate p;\n   int length, i;\n \n-  es->call_stmt_size = streamer_read_uhwi (ib);\n-  es->call_stmt_time = streamer_read_uhwi (ib);\n-  es->loop_depth = streamer_read_uhwi (ib);\n+  int size = streamer_read_uhwi (ib);\n+  int time = streamer_read_uhwi (ib);\n+  int depth = streamer_read_uhwi (ib);\n+\n+  if (es)\n+    {\n+      es->call_stmt_size = size;\n+      es->call_stmt_time = time;\n+      es->loop_depth = depth;\n+    }\n \n   bitpack_d bp = streamer_read_bitpack (ib);\n-  es->is_return_callee_uncaptured = bp_unpack_value (&bp, 1);\n+  if (es)\n+    es->is_return_callee_uncaptured = bp_unpack_value (&bp, 1);\t\n+  else\n+    bp_unpack_value (&bp, 1);\t\n \n   p.stream_in (ib);\n-  edge_set_predicate (e, &p);\n+  if (es)\n+    edge_set_predicate (e, &p);\n   length = streamer_read_uhwi (ib);\n-  if (length)\n+  if (length && es && e->possibly_call_in_translation_unit_p ())\n     {\n       es->param.safe_grow_cleared (length);\n       for (i = 0; i < length; i++)\n \tes->param[i].change_prob = streamer_read_uhwi (ib);\n     }\n+  else\n+    {\n+      for (i = 0; i < length; i++)\n+\tstreamer_read_uhwi (ib);\n+    }\n }\n \n \n@@ -3254,19 +3274,34 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       encoder = file_data->symtab_node_encoder;\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n-      info = ipa_fn_summaries->get_create (node);\n+      info = node->prevailing_p () ? ipa_fn_summaries->get_create (node) : NULL;\n \n-      info->estimated_stack_size\n-\t= info->estimated_self_stack_size = streamer_read_uhwi (&ib);\n-      info->size = info->self_size = streamer_read_uhwi (&ib);\n-      info->time = sreal::stream_in (&ib);\n+      int stack_size = streamer_read_uhwi (&ib);\n+      int size = streamer_read_uhwi (&ib);\n+      sreal time = sreal::stream_in (&ib);\n+\n+      if (info)\n+\t{\n+\t  info->estimated_stack_size\n+\t    = info->estimated_self_stack_size = stack_size;\n+\t  info->size = info->self_size = size;\n+\t  info->time = time;\n+\t}\n \n       bp = streamer_read_bitpack (&ib);\n-      info->inlinable = bp_unpack_value (&bp, 1);\n-      info->fp_expressions = bp_unpack_value (&bp, 1);\n+      if (info)\n+\t{\n+          info->inlinable = bp_unpack_value (&bp, 1);\n+          info->fp_expressions = bp_unpack_value (&bp, 1);\n+\t}\n+      else\n+\t{\n+          bp_unpack_value (&bp, 1);\n+          bp_unpack_value (&bp, 1);\n+\t}\n \n       count2 = streamer_read_uhwi (&ib);\n-      gcc_assert (!info->conds);\n+      gcc_assert (!info || !info->conds);\n       for (j = 0; j < count2; j++)\n \t{\n \t  struct condition c;\n@@ -3279,10 +3314,11 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  c.by_ref = bp_unpack_value (&bp, 1);\n \t  if (c.agg_contents)\n \t    c.offset = streamer_read_uhwi (&ib);\n-\t  vec_safe_push (info->conds, c);\n+\t  if (info)\n+\t    vec_safe_push (info->conds, c);\n \t}\n       count2 = streamer_read_uhwi (&ib);\n-      gcc_assert (!info->size_time_table);\n+      gcc_assert (!info || !info->size_time_table);\n       for (j = 0; j < count2; j++)\n \t{\n \t  struct size_time_entry e;\n@@ -3292,19 +3328,23 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  e.exec_predicate.stream_in (&ib);\n \t  e.nonconst_predicate.stream_in (&ib);\n \n-\t  vec_safe_push (info->size_time_table, e);\n+\t  if (info)\n+\t    vec_safe_push (info->size_time_table, e);\n \t}\n \n       p.stream_in (&ib);\n-      set_hint_predicate (&info->loop_iterations, p);\n+      if (info)\n+        set_hint_predicate (&info->loop_iterations, p);\n       p.stream_in (&ib);\n-      set_hint_predicate (&info->loop_stride, p);\n+      if (info)\n+        set_hint_predicate (&info->loop_stride, p);\n       p.stream_in (&ib);\n-      set_hint_predicate (&info->array_index, p);\n+      if (info)\n+        set_hint_predicate (&info->array_index, p);\n       for (e = node->callees; e; e = e->next_callee)\n-\tread_ipa_call_summary (&ib, e);\n+\tread_ipa_call_summary (&ib, e, info != NULL);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n-\tread_ipa_call_summary (&ib, e);\n+\tread_ipa_call_summary (&ib, e, info != NULL);\n     }\n \n   lto_free_section_data (file_data, LTO_section_ipa_fn_summary, NULL, data,"}]}