{"sha": "bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIwNzQ5MGFiYmE4NTBmZDViMWQyZDA5ZDc2ZDE4YjhiZGM3ZDgxNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-25T19:51:26Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-25T19:51:26Z"}, "message": "Add EAF_NODIRECTESCAPE flag\n\nMain limitation of modref is the fact that it does not\ntrack anything in memory. This is intentional - I wanted the initial\nimplementation to be cheap. However it also makes it very limited when it comes\nto detecting noescape especially because it is paranoid about what memory\naccesses may be used to copy (bits of) pointers.\n\nThis patch adds EAF_NODIRECTSCAPE that is weaker vairant of EAF_NOESCAPE where\nwe only know that the pointer itself does not escape, but memory pointed to\nmay.  This is a lot more reliable to auto-detect that EAF_NOESCAPE and still\nenables additional optimization.  With patch we get nodirectscape flag for b\nthat enables in practice similar optimization as EAF_NOESCAPE for arrays of\nintegers that points nowhere :)\n\ngcc/ChangeLog:\n\t* gimple.c (gimple_call_arg_flags): Also imply EAF_NODIRECTESCAPE.\n\t* tree-core.h (EAF_NODRECTESCAPE): New flag.\n\t* tree-ssa-structalias.c (make_indirect_escape_constraint): New\n\tfunction.\n\t(handle_rhs_call): Hanlde EAF_NODIRECTESCAPE.\n\t* ipa-modref.c (dump_eaf_flags): Print EAF_NODIRECTESCAPE.\n\t(deref_flags): Dereference is always EAF_NODIRECTESCAPE.\n\t(modref_lattice::init): Also set EAF_NODIRECTESCAPE.\n\t(analyze_ssa_name_flags): Pure functions do not affect\n\tEAF_NODIRECTESCAPE.\n\t(analyze_params): Likewise.\n\t(ipa_merge_modref_summary_after_inlining): Likewise.\n\t(modref_merge_call_site_flags): Likewise.", "tree": {"sha": "088a7d9ff0a070269412fd9c22a3ce3861066442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/088a7d9ff0a070269412fd9c22a3ce3861066442"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/comments", "author": null, "committer": null, "parents": [{"sha": "5962efe9186559ada404ac8f9f56006648a5858e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5962efe9186559ada404ac8f9f56006648a5858e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5962efe9186559ada404ac8f9f56006648a5858e"}], "stats": {"total": 51, "additions": 40, "deletions": 11}, "files": [{"sha": "e8246b72cc983e53e44afe93add3b61d7d9179f9", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "patch": "@@ -1543,7 +1543,7 @@ gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n \t  if (fnspec.arg_direct_p (arg))\n \t    flags |= EAF_DIRECT;\n \t  if (fnspec.arg_noescape_p (arg))\n-\t    flags |= EAF_NOESCAPE;\n+\t    flags |= EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n \t  if (fnspec.arg_readonly_p (arg))\n \t    flags |= EAF_NOCLOBBER;\n \t}"}, {"sha": "d1d4ba786a4829a92c34faa272f2c03d3a57006f", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "patch": "@@ -151,6 +151,8 @@ dump_eaf_flags (FILE *out, int flags, bool newline = true)\n     fprintf (out, \" noclobber\");\n   if (flags & EAF_NOESCAPE)\n     fprintf (out, \" noescape\");\n+  if (flags & EAF_NODIRECTESCAPE)\n+    fprintf (out, \" nodirectescape\");\n   if (flags & EAF_UNUSED)\n     fprintf (out, \" unused\");\n   if (newline)\n@@ -1303,7 +1305,7 @@ memory_access_to (tree op, tree ssa_name)\n static int\n deref_flags (int flags, bool ignore_stores)\n {\n-  int ret = 0;\n+  int ret = EAF_NODIRECTESCAPE;\n   if (flags & EAF_UNUSED)\n     ret |= EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE;\n   else\n@@ -1361,7 +1363,8 @@ class modref_lattice\n void\n modref_lattice::init ()\n {\n-  flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+  flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED\n+\t  | EAF_NODIRECTESCAPE;\n   open = true;\n   known = false;\n }\n@@ -1653,7 +1656,8 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t      {\n \t\t\tint call_flags = gimple_call_arg_flags (call, i);\n \t\t\tif (ignore_stores)\n-\t\t\t  call_flags |= EAF_NOCLOBBER | EAF_NOESCAPE;\n+\t\t\t  call_flags |= EAF_NOCLOBBER | EAF_NOESCAPE\n+\t\t\t\t\t| EAF_NODIRECTESCAPE;\n \n \t\t\tif (!record_ipa)\n \t\t\t  lattice[index].merge (call_flags);\n@@ -1829,7 +1833,7 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n       /* For pure functions we have implicit NOCLOBBER\n \t and NOESCAPE.  */\n       if (ecf_flags & ECF_PURE)\n-\tflags &= ~(EAF_NOCLOBBER | EAF_NOESCAPE);\n+\tflags &= ~(EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NODIRECTESCAPE);\n \n       if (flags)\n \t{\n@@ -3102,7 +3106,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t    if (!ee->direct)\n \t      flags = deref_flags (flags, ignore_stores);\n \t    else if (ignore_stores)\n-\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE;\n+\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n \t    flags |= ee->min_flags;\n \t    to_info->arg_flags[ee->parm_index] &= flags;\n \t    if (to_info->arg_flags[ee->parm_index])\n@@ -3116,7 +3120,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t    if (!ee->direct)\n \t      flags = deref_flags (flags, ignore_stores);\n \t    else if (ignore_stores)\n-\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE;\n+\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n \t    flags |= ee->min_flags;\n \t    to_info_lto->arg_flags[ee->parm_index] &= flags;\n \t    if (to_info_lto->arg_flags[ee->parm_index])\n@@ -3627,8 +3631,8 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t}\n       else if (ignore_stores)\n \t{\n-\t  flags |= EAF_NOESCAPE | EAF_NOCLOBBER;\n-\t  flags_lto |= EAF_NOESCAPE | EAF_NOCLOBBER;\n+\t  flags |= EAF_NOESCAPE | EAF_NOCLOBBER | EAF_NODIRECTESCAPE;\n+\t  flags_lto |= EAF_NOESCAPE | EAF_NOCLOBBER | EAF_NODIRECTESCAPE;\n \t}\n       flags |= ee->min_flags;\n       flags_lto |= ee->min_flags;"}, {"sha": "e457b917b98e08a2fe83adc0610ef364169bc9de", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "patch": "@@ -110,6 +110,10 @@ struct die_struct;\n /* Nonzero if the argument is not used by the function.  */\n #define EAF_UNUSED\t\t(1 << 3)\n \n+/* Nonzero if the argument itself does not escape but memory\n+   referenced by it can escape.  */\n+#define EAF_NODIRECTESCAPE\t(1 << 4)\n+\n /* Call return flags.  */\n /* Mask for the argument number that is returned.  Lower two bits of\n    the return flags, encodes argument slots zero to three.  */"}, {"sha": "9f4de96d5442593ec291a62ff00008307a6afff9", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb07490abba850fd5b1d2d09d76d18b8bdc7d817/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=bb07490abba850fd5b1d2d09d76d18b8bdc7d817", "patch": "@@ -3851,6 +3851,23 @@ make_escape_constraint (tree op)\n   make_constraint_to (escaped_id, op);\n }\n \n+/* Make constraint necessary to make all indirect references\n+   from VI escape.  */\n+\n+static void\n+make_indirect_escape_constraint (varinfo_t vi)\n+{\n+  struct constraint_expr lhs, rhs;\n+  /* escaped = *(VAR + UNKNOWN);  */\n+  lhs.type = SCALAR;\n+  lhs.var = escaped_id;\n+  lhs.offset = 0;\n+  rhs.type = DEREF;\n+  rhs.var = vi->id;\n+  rhs.offset = UNKNOWN_OFFSET;\n+  process_constraint (new_constraint (lhs, rhs));\n+}\n+\n /* Add constraints to that the solution of VI is transitively closed.  */\n \n static void\n@@ -4026,7 +4043,7 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t set.  The argument would still get clobbered through the\n \t escape solution.  */\n       if ((flags & EAF_NOCLOBBER)\n-\t   && (flags & EAF_NOESCAPE))\n+\t   && (flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE)))\n \t{\n \t  varinfo_t uses = get_call_use_vi (stmt);\n \t  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n@@ -4036,9 +4053,11 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  if (!(flags & EAF_DIRECT))\n \t    make_transitive_closure_constraints (tem);\n \t  make_copy_constraint (uses, tem->id);\n+\t  if (!(flags & (EAF_NOESCAPE | EAF_DIRECT)))\n+\t    make_indirect_escape_constraint (tem);\n \t  returns_uses = true;\n \t}\n-      else if (flags & EAF_NOESCAPE)\n+      else if (flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE))\n \t{\n \t  struct constraint_expr lhs, rhs;\n \t  varinfo_t uses = get_call_use_vi (stmt);\n@@ -4061,6 +4080,8 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  rhs.var = nonlocal_id;\n \t  rhs.offset = 0;\n \t  process_constraint (new_constraint (lhs, rhs));\n+\t  if (!(flags & (EAF_NOESCAPE | EAF_DIRECT)))\n+\t    make_indirect_escape_constraint (tem);\n \t  returns_uses = true;\n \t}\n       else"}]}