{"sha": "631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMxMjM4YWMzZjUwYjQyZGQ1NWU4N2NkOGJlYTAyYzdmYmVjMGY1Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-05-09T02:47:14Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-05-09T02:47:14Z"}, "message": "PR translation/80280 - Missing closing quote (%>) c/semantics.c and c/c-typeck.c\n\ngcc/c-family/ChangeLog:\n\n\tPR translation/80280\n\t* c-format.h (struct format_flag_spec): Add new member.\n\t(T89_T): New macro.\n\t* c-format.c (local_tree_type_node): New global.\n\t(printf_flag_specs, asm_fprintf_flag_spec): Initialize new data.\n\t(gcc_diag_flag_specs, scanf_flag_specs, strftime_flag_specs): Ditto.\n\t(strfmon_flag_specs): Likewise.\n\t(gcc_diag_char_table, gcc_cdiag_char_table): Split up specifiers\n\twith distinct quoting properties.\n\t(gcc_tdiag_char_table, gcc_cxxdiag_char_table): Same.\n\t(flag_chars_t::validate): Add argument and handle bad quoting.\n\t(check_format_info_main): Handle quoting problems.\n\t(init_dynamic_diag_info): Simplify.\n\ngcc/testsuite/ChangeLog:\n\n\tPR translation/80280\n\t* gcc.dg/format/gcc_diag-10.c: New test.\n\nFrom-SVN: r247778", "tree": {"sha": "4be7c50f7014900235195c4b730590f7cf4e7a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4be7c50f7014900235195c4b730590f7cf4e7a12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ba86ba72f9d437275d9352244fb833ea471e494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba86ba72f9d437275d9352244fb833ea471e494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba86ba72f9d437275d9352244fb833ea471e494"}], "stats": {"total": 608, "additions": 432, "deletions": 176}, "files": [{"sha": "7e882e1cf2455cc9a82de826bedf7165be6c3df7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "patch": "@@ -1,3 +1,19 @@\n+2017-05-08  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR translation/80280\n+\t* c-format.h (struct format_flag_spec): Add new member.\n+\t(T89_T): New macro.\n+\t* c-format.c (local_tree_type_node): New global.\n+\t(printf_flag_specs, asm_fprintf_flag_spec): Initialize new data.\n+\t(gcc_diag_flag_specs, scanf_flag_specs, strftime_flag_specs): Ditto.\n+\t(strfmon_flag_specs): Likewise.\n+\t(gcc_diag_char_table, gcc_cdiag_char_table): Split up specifiers\n+\twith distinct quoting properties.\n+\t(gcc_tdiag_char_table, gcc_cxxdiag_char_table): Same.\n+\t(flag_chars_t::validate): Add argument and handle bad quoting.\n+\t(check_format_info_main): Handle quoting problems.\n+\t(init_dynamic_diag_info): Simplify.\n+\n 2017-05-08  Jason Merrill  <jason@redhat.com>\n \n \t* c-opts.c (c_common_post_options): Update defaults for"}, {"sha": "2dba0629f5f5b9497e868a05a177688194d810d5", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 247, "deletions": 175, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "patch": "@@ -53,6 +53,9 @@ struct function_format_info\n   unsigned HOST_WIDE_INT first_arg_num;\t/* number of first arg (zero for varargs) */\n };\n \n+/* Initialized in init_dynamic_diag_info.  */\n+static tree local_tree_type_node;\n+\n static bool decode_format_attr (tree, function_format_info *, int);\n static int decode_format_type (const char *);\n \n@@ -492,17 +495,17 @@ static const format_length_info gcc_gfc_length_specs[] =\n \n static const format_flag_spec printf_flag_specs[] =\n {\n-  { ' ',  0, 0, N_(\"' ' flag\"),        N_(\"the ' ' printf flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n-  { '#',  0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n-  { '0',  0, 0, N_(\"'0' flag\"),        N_(\"the '0' printf flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"'-' flag\"),        N_(\"the '-' printf flag\"),              STD_C89 },\n-  { '\\'', 0, 0, N_(\"''' flag\"),        N_(\"the ''' printf flag\"),              STD_EXT },\n-  { 'I',  0, 0, N_(\"'I' flag\"),        N_(\"the 'I' printf flag\"),              STD_EXT },\n-  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n-  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n-  { 0, 0, 0, NULL, NULL, STD_C89 }\n+  { ' ',  0, 0, 0, N_(\"' ' flag\"),        N_(\"the ' ' printf flag\"),              STD_C89 },\n+  { '+',  0, 0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n+  { '0',  0, 0, 0, N_(\"'0' flag\"),        N_(\"the '0' printf flag\"),              STD_C89 },\n+  { '-',  0, 0, 0, N_(\"'-' flag\"),        N_(\"the '-' printf flag\"),              STD_C89 },\n+  { '\\'', 0, 0, 0, N_(\"''' flag\"),        N_(\"the ''' printf flag\"),              STD_EXT },\n+  { 'I',  0, 0, 0, N_(\"'I' flag\"),        N_(\"the 'I' printf flag\"),              STD_EXT },\n+  { 'w',  0, 0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n+  { 'p',  0, 0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, 0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, 0, NULL, NULL, STD_C89 }\n };\n \n \n@@ -516,15 +519,15 @@ static const format_flag_pair printf_flag_pairs[] =\n \n static const format_flag_spec asm_fprintf_flag_specs[] =\n {\n-  { ' ',  0, 0, N_(\"' ' flag\"),        N_(\"the ' ' printf flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n-  { '#',  0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n-  { '0',  0, 0, N_(\"'0' flag\"),        N_(\"the '0' printf flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"'-' flag\"),        N_(\"the '-' printf flag\"),              STD_C89 },\n-  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n-  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n-  { 0, 0, 0, NULL, NULL, STD_C89 }\n+  { ' ',  0, 0, 0, N_(\"' ' flag\"),        N_(\"the ' ' printf flag\"),              STD_C89 },\n+  { '+',  0, 0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n+  { '0',  0, 0, 0, N_(\"'0' flag\"),        N_(\"the '0' printf flag\"),              STD_C89 },\n+  { '-',  0, 0, 0, N_(\"'-' flag\"),        N_(\"the '-' printf flag\"),              STD_C89 },\n+  { 'w',  0, 0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n+  { 'p',  0, 0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, 0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, 0, NULL, NULL, STD_C89 }\n };\n \n static const format_flag_pair asm_fprintf_flag_pairs[] =\n@@ -547,12 +550,12 @@ static const format_flag_pair gcc_diag_flag_pairs[] =\n \n static const format_flag_spec gcc_diag_flag_specs[] =\n {\n-  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n-  { '#',  0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n-  { 'q',  0, 0, N_(\"'q' flag\"),        N_(\"the 'q' diagnostic flag\"),          STD_C89 },\n-  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n-  { 0, 0, 0, NULL, NULL, STD_C89 }\n+  { '+',  0, 0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n+  { 'q',  0, 0, 1, N_(\"'q' flag\"),        N_(\"the 'q' diagnostic flag\"),          STD_C89 },\n+  { 'p',  0, 0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, 0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, 0, NULL, NULL, STD_C89 }\n };\n \n #define gcc_tdiag_flag_specs gcc_diag_flag_specs\n@@ -562,14 +565,14 @@ static const format_flag_spec gcc_diag_flag_specs[] =\n \n static const format_flag_spec scanf_flag_specs[] =\n {\n-  { '*',  0, 0, N_(\"assignment suppression\"), N_(\"the assignment suppression scanf feature\"), STD_C89 },\n-  { 'a',  0, 0, N_(\"'a' flag\"),               N_(\"the 'a' scanf flag\"),                       STD_EXT },\n-  { 'm',  0, 0, N_(\"'m' flag\"),               N_(\"the 'm' scanf flag\"),                       STD_EXT },\n-  { 'w',  0, 0, N_(\"field width\"),            N_(\"field width in scanf format\"),              STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"),        N_(\"length modifier in scanf format\"),          STD_C89 },\n-  { '\\'', 0, 0, N_(\"''' flag\"),               N_(\"the ''' scanf flag\"),                       STD_EXT },\n-  { 'I',  0, 0, N_(\"'I' flag\"),               N_(\"the 'I' scanf flag\"),                       STD_EXT },\n-  { 0, 0, 0, NULL, NULL, STD_C89 }\n+  { '*',  0, 0, 0, N_(\"assignment suppression\"), N_(\"the assignment suppression scanf feature\"), STD_C89 },\n+  { 'a',  0, 0, 0, N_(\"'a' flag\"),               N_(\"the 'a' scanf flag\"),                       STD_EXT },\n+  { 'm',  0, 0, 0, N_(\"'m' flag\"),               N_(\"the 'm' scanf flag\"),                       STD_EXT },\n+  { 'w',  0, 0, 0, N_(\"field width\"),            N_(\"field width in scanf format\"),              STD_C89 },\n+  { 'L',  0, 0, 0, N_(\"length modifier\"),        N_(\"length modifier in scanf format\"),          STD_C89 },\n+  { '\\'', 0, 0, 0, N_(\"''' flag\"),               N_(\"the ''' scanf flag\"),                       STD_EXT },\n+  { 'I',  0, 0, 0, N_(\"'I' flag\"),               N_(\"the 'I' scanf flag\"),                       STD_EXT },\n+  { 0, 0, 0, 0, NULL, NULL, STD_C89 }\n };\n \n \n@@ -583,16 +586,16 @@ static const format_flag_pair scanf_flag_pairs[] =\n \n static const format_flag_spec strftime_flag_specs[] =\n {\n-  { '_', 0,   0, N_(\"'_' flag\"),     N_(\"the '_' strftime flag\"),          STD_EXT },\n-  { '-', 0,   0, N_(\"'-' flag\"),     N_(\"the '-' strftime flag\"),          STD_EXT },\n-  { '0', 0,   0, N_(\"'0' flag\"),     N_(\"the '0' strftime flag\"),          STD_EXT },\n-  { '^', 0,   0, N_(\"'^' flag\"),     N_(\"the '^' strftime flag\"),          STD_EXT },\n-  { '#', 0,   0, N_(\"'#' flag\"),     N_(\"the '#' strftime flag\"),          STD_EXT },\n-  { 'w', 0,   0, N_(\"field width\"),  N_(\"field width in strftime format\"), STD_EXT },\n-  { 'E', 0,   0, N_(\"'E' modifier\"), N_(\"the 'E' strftime modifier\"),      STD_C99 },\n-  { 'O', 0,   0, N_(\"'O' modifier\"), N_(\"the 'O' strftime modifier\"),      STD_C99 },\n-  { 'O', 'o', 0, NULL,               N_(\"the 'O' modifier\"),               STD_EXT },\n-  { 0, 0, 0, NULL, NULL, STD_C89 }\n+  { '_', 0,   0, 0, N_(\"'_' flag\"),     N_(\"the '_' strftime flag\"),          STD_EXT },\n+  { '-', 0,   0, 0, N_(\"'-' flag\"),     N_(\"the '-' strftime flag\"),          STD_EXT },\n+  { '0', 0,   0, 0, N_(\"'0' flag\"),     N_(\"the '0' strftime flag\"),          STD_EXT },\n+  { '^', 0,   0, 0, N_(\"'^' flag\"),     N_(\"the '^' strftime flag\"),          STD_EXT },\n+  { '#', 0,   0, 0, N_(\"'#' flag\"),     N_(\"the '#' strftime flag\"),          STD_EXT },\n+  { 'w', 0,   0, 0, N_(\"field width\"),  N_(\"field width in strftime format\"), STD_EXT },\n+  { 'E', 0,   0, 0, N_(\"'E' modifier\"), N_(\"the 'E' strftime modifier\"),      STD_C99 },\n+  { 'O', 0,   0, 0, N_(\"'O' modifier\"), N_(\"the 'O' strftime modifier\"),      STD_C99 },\n+  { 'O', 'o', 0, 0, NULL,               N_(\"the 'O' modifier\"),               STD_EXT },\n+  { 0, 0, 0, 0, NULL, NULL, STD_C89 }\n };\n \n \n@@ -609,17 +612,17 @@ static const format_flag_pair strftime_flag_pairs[] =\n \n static const format_flag_spec strfmon_flag_specs[] =\n {\n-  { '=',  0, 1, N_(\"fill character\"),  N_(\"fill character in strfmon format\"),  STD_C89 },\n-  { '^',  0, 0, N_(\"'^' flag\"),        N_(\"the '^' strfmon flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' strfmon flag\"),              STD_C89 },\n-  { '(',  0, 0, N_(\"'(' flag\"),        N_(\"the '(' strfmon flag\"),              STD_C89 },\n-  { '!',  0, 0, N_(\"'!' flag\"),        N_(\"the '!' strfmon flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"'-' flag\"),        N_(\"the '-' strfmon flag\"),              STD_C89 },\n-  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in strfmon format\"),     STD_C89 },\n-  { '#',  0, 0, N_(\"left precision\"),  N_(\"left precision in strfmon format\"),  STD_C89 },\n-  { 'p',  0, 0, N_(\"right precision\"), N_(\"right precision in strfmon format\"), STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in strfmon format\"), STD_C89 },\n-  { 0, 0, 0, NULL, NULL, STD_C89 }\n+  { '=',  0, 1, 0, N_(\"fill character\"),  N_(\"fill character in strfmon format\"),  STD_C89 },\n+  { '^',  0, 0, 0, N_(\"'^' flag\"),        N_(\"the '^' strfmon flag\"),              STD_C89 },\n+  { '+',  0, 0, 0, N_(\"'+' flag\"),        N_(\"the '+' strfmon flag\"),              STD_C89 },\n+  { '(',  0, 0, 0, N_(\"'(' flag\"),        N_(\"the '(' strfmon flag\"),              STD_C89 },\n+  { '!',  0, 0, 0, N_(\"'!' flag\"),        N_(\"the '!' strfmon flag\"),              STD_C89 },\n+  { '-',  0, 0, 0, N_(\"'-' flag\"),        N_(\"the '-' strfmon flag\"),              STD_C89 },\n+  { 'w',  0, 0, 0, N_(\"field width\"),     N_(\"field width in strfmon format\"),     STD_C89 },\n+  { '#',  0, 0, 0, N_(\"left precision\"),  N_(\"left precision in strfmon format\"),  STD_C89 },\n+  { 'p',  0, 0, 0, N_(\"right precision\"), N_(\"right precision in strfmon format\"), STD_C89 },\n+  { 'L',  0, 0, 0, N_(\"length modifier\"), N_(\"length modifier in strfmon format\"), STD_C89 },\n+  { 0, 0, 0, 0, NULL, NULL, STD_C89 }\n };\n \n static const format_flag_pair strfmon_flag_pairs[] =\n@@ -685,10 +688,13 @@ static const format_char_info gcc_diag_char_table[] =\n   /* Custom conversion specifiers.  */\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"K\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",    \"\",   NULL },\n+  { \"K\",   1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"\\\"\",   NULL },\n \n-  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"cR\",   NULL },\n-  { \"<>'R\",0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"//cR\",   NULL },\n+  { \"<\",   0, STD_C89, NOARGUMENTS, \"\",      \"<\",   NULL },\n+  { \">\",   0, STD_C89, NOARGUMENTS, \"\",      \">\",   NULL },\n+  { \"'\" ,  0, STD_C89, NOARGUMENTS, \"\",      \"\",    NULL },\n+  { \"R\",   0, STD_C89, NOARGUMENTS, \"\",     \"\\\\\",   NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n   { NULL,  0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n };\n@@ -706,12 +712,17 @@ static const format_char_info gcc_tdiag_char_table[] =\n   /* Custom conversion specifiers.  */\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"DFKTEV\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"\",   NULL },\n+  { \"DFTV\", 1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"'\",   NULL },\n+  { \"E\", 1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"\",   NULL },\n+  { \"K\", 1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL },\n \n   { \"v\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q#\",  \"\",   NULL },\n \n-  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"cR\",   NULL },\n-  { \"<>'R\",0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"/cR\",   NULL },\n+  { \"<\",   0, STD_C89, NOARGUMENTS, \"\",      \"<\",   NULL },\n+  { \">\",   0, STD_C89, NOARGUMENTS, \"\",      \">\",   NULL },\n+  { \"'\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",    NULL },\n+  { \"R\",   0, STD_C89, NOARGUMENTS, \"\",     \"\\\\\",   NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n   { \"Z\",   1, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"\", &gcc_tdiag_char_table[0] },\n   { NULL,  0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n@@ -730,12 +741,17 @@ static const format_char_info gcc_cdiag_char_table[] =\n   /* Custom conversion specifiers.  */\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"DEFKTV\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"\",   NULL },\n+  { \"DFTV\", 1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"'\",   NULL },\n+  { \"E\",   1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"\",   NULL },\n+  { \"K\",   1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL },\n \n   { \"v\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q#\",  \"\",   NULL },\n \n-  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"cR\",   NULL },\n-  { \"<>'R\",0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"/cR\",   NULL },\n+  { \"<\",   0, STD_C89, NOARGUMENTS, \"\",      \"<\",  NULL },\n+  { \">\",   0, STD_C89, NOARGUMENTS, \"\",      \">\",  NULL },\n+  { \"'\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"R\",   0, STD_C89, NOARGUMENTS, \"\",     \"\\\\\",  NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n   { \"Z\",   1, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"\", &gcc_tdiag_char_table[0] },\n   { NULL,  0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n@@ -754,15 +770,19 @@ static const format_char_info gcc_cxxdiag_char_table[] =\n   /* Custom conversion specifiers.  */\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"ADEFKSTVX\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\",   NULL },\n-\n+  { \"ADFSTVX\",1,STD_C89,{ T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"'\",   NULL },\n+  { \"E\", 1,STD_C89,{ T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\",   NULL },\n+  { \"K\", 1, STD_C89,{ T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\\\"\",   NULL },\n   { \"v\", 0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q#\",  \"\",   NULL },\n \n   /* These accept either an 'int' or an 'enum tree_code' (which is handled as an 'int'.)  */\n   { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n-  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"cR\",   NULL },\n-  { \"<>'R\",0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"/cR\",   NULL },\n+  { \"<\",   0, STD_C89, NOARGUMENTS, \"\",      \"<\",   NULL },\n+  { \">\",   0, STD_C89, NOARGUMENTS, \"\",      \">\",   NULL },\n+  { \"'\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",    NULL },\n+  { \"R\",   0, STD_C89, NOARGUMENTS, \"\",      \"\\\\\",  NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n   { \"Z\",   1, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"\", &gcc_tdiag_char_table[0] },\n   { NULL,  0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n@@ -1689,7 +1709,8 @@ class flag_chars_t\n \t\t tree format_string_cst,\n \t\t location_t format_string_loc,\n \t\t const char * const orig_format_chars,\n-\t\t char format_char);\n+\t\t char format_char,\n+\t\t bool quoted);\n   int get_alloc_flag (const format_kind_info *fki);\n   int assignment_suppression_p (const format_kind_info *fki);\n \n@@ -1849,17 +1870,24 @@ flag_chars_t::validate (const format_kind_info *fki,\n \t\t\ttree format_string_cst,\n \t\t\tlocation_t format_string_loc,\n \t\t\tconst char * const orig_format_chars,\n-\t\t\tchar format_char)\n+\t\t\tchar format_char,\n+\t\t\tbool quoted)\n {\n   int i;\n   int d = 0;\n+  bool quotflag = false;\n+\n   for (i = 0; m_flag_chars[i] != 0; i++)\n     {\n       const format_flag_spec *s = get_flag_spec (flag_specs,\n \t\t\t\t\t\t m_flag_chars[i], NULL);\n       m_flag_chars[i - d] = m_flag_chars[i];\n       if (m_flag_chars[i] == fki->length_code_char)\n \tcontinue;\n+\n+      /* Remember if a quoting flag is seen.  */\n+      quotflag |= s->quoting;\n+\n       if (strchr (fci->flag_chars, m_flag_chars[i]) == 0)\n \t{\n \t  format_warning_at_char (format_string_loc, format_string_cst,\n@@ -1891,8 +1919,30 @@ flag_chars_t::validate (const format_kind_info *fki,\n \t\t\t    format_char, fki->name);\n \t    }\n \t}\n+\n+      /* Detect quoting directives used within a quoted sequence, such\n+\t as GCC's \"%<...%qE\".  */\n+      if (quoted && s->quoting)\n+\t{\n+\t  format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t  format_chars - orig_format_chars - 1,\n+\t\t\t\t  OPT_Wformat_,\n+\t\t\t\t  \"%s used within a quoted sequence\",\n+\t\t\t\t  _(s->name));\n+\t}\n     }\n   m_flag_chars[i - d] = 0;\n+\n+  if (!quoted\n+      && !quotflag\n+      && strchr (fci->flags2, '\\''))\n+    {\n+      format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t      format_chars - orig_format_chars,\n+\t\t\t      OPT_Wformat_,\n+\t\t\t      \"%qc conversion used unquoted\",\n+\t\t\t      format_char);\n+    }\n }\n \n /* Determine if an assignment-allocation has been set, requiring\n@@ -2704,6 +2754,16 @@ check_format_info_main (format_check_results *res,\n      and it didn't use $; 1 if $ formats are in use.  */\n   int has_operand_number = -1;\n \n+  /* Vector of pointers to opening quoting directives (like GCC \"%<\").  */\n+  auto_vec<const char*> quotdirs;\n+\n+  /* Pointers to the most recent color directives (like GCC's \"%r or %R\").\n+     A starting color directive much be terminated before the end of\n+     the format string.  A terminating directive makes no sense without\n+     a prior starting directive.  */\n+  const char *color_begin = NULL;\n+  const char *color_end = NULL;\n+\n   init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n \n   while (*format_chars != 0)\n@@ -2785,11 +2845,72 @@ check_format_info_main (format_check_results *res,\n \n       flag_chars.validate (fki, fci, flag_specs, format_chars,\n \t\t\t   format_string_cst,\n-\t\t\t   format_string_loc, orig_format_chars, format_char);\n+\t\t\t   format_string_loc, orig_format_chars, format_char,\n+\t\t\t   quotdirs.length () > 0);\n \n       const int alloc_flag = flag_chars.get_alloc_flag (fki);\n       const bool suppressed = flag_chars.assignment_suppression_p (fki);\n \n+      /* Diagnose nested or unmatched quoting directives such as GCC's\n+\t \"%<...%<\" and \"%>...%>\".  */\n+      bool quot_begin_p = strchr (fci->flags2, '<');\n+      bool quot_end_p = strchr (fci->flags2, '>');\n+\n+      if (quot_begin_p && !quot_end_p)\n+\t{\n+\t  if (quotdirs.length ())\n+\t    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t    format_chars - orig_format_chars,\n+\t\t\t\t    OPT_Wformat_,\n+\t\t\t\t    \"nested quoting directive\");\n+\t  quotdirs.safe_push (format_chars);\n+\t}\n+      else if (!quot_begin_p && quot_end_p)\n+\t{\n+\t  if (quotdirs.length ())\n+\t    quotdirs.pop ();\n+\t  else\n+\t    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t    format_chars - orig_format_chars,\n+\t\t\t\t    OPT_Wformat_,\n+\t\t\t\t    \"unmatched quoting directive\");\n+\t}\n+\n+      bool color_begin_p = strchr (fci->flags2, '/');\n+      if (color_begin_p)\n+\t{\n+\t  color_begin = format_chars;\n+\t  color_end = NULL;\n+\t}\n+      else if (strchr (fci->flags2, '\\\\'))\n+\t{\n+\t  if (color_end)\n+\t    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t    format_chars - orig_format_chars,\n+\t\t\t\t    OPT_Wformat_,\n+\t\t\t\t    \"%qc directive redundant after prior \"\n+\t\t\t\t    \"occurence of the same\", format_char);\n+\t  else if (!color_begin)\n+\t    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t    format_chars - orig_format_chars,\n+\t\t\t\t    OPT_Wformat_,\n+\t\t\t\t    \"unmatched color reset directive\");\n+\t  color_end = format_chars;\n+\t}\n+\n+      /* Diagnose directives that shouldn't appear in a quoted sequence.\n+\t (They are denoted by a double quote in FLAGS2.)  */\n+      if (quotdirs.length ())\n+\t{\n+\t  if (strchr (fci->flags2, '\"'))\n+\t    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t    format_chars - orig_format_chars,\n+\t\t\t\t    OPT_Wformat_,\n+\t\t\t\t    \"%qc conversion used within a quoted \"\n+\t\t\t\t    \"sequence\",\n+\t\t\t\t    format_char);\n+\t}\n+\n       /* Validate the pairs of flags used.  */\n       arg_parser.validate_flag_pairs (fci, format_char);\n \n@@ -2834,6 +2955,15 @@ check_format_info_main (format_check_results *res,\n     }\n   if (has_operand_number > 0)\n     finish_dollar_format_checking (res, fki->flags & (int) FMT_FLAG_DOLLAR_GAP_POINTER_OK);\n+\n+  if (quotdirs.length ())\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t    quotdirs.pop () - orig_format_chars,\n+\t\t\t    OPT_Wformat_, \"unterminated quoting directive\");\n+  if (color_begin && !color_end)\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t    color_begin - orig_format_chars,\n+\t\t\t    OPT_Wformat_, \"unterminated color directive\");\n }\n \n /* Check the argument types from a single format conversion (possibly\n@@ -3654,58 +3784,58 @@ init_dynamic_gfc_info (void)\n static void\n init_dynamic_diag_info (void)\n {\n-  static tree t, loc, hwi;\n-\n-  if (!loc || !t || !hwi)\n+  /* For the GCC-diagnostics custom format specifiers to work, one\n+     must have declared 'tree' and 'location_t' prior to using those\n+     attributes.  If we haven't seen these declarations then\n+     the specifiers requiring these types shouldn't be used.\n+     However we don't force a hard ICE because we may see only one\n+     or the other type.  */\n+  if (tree loc = maybe_get_identifier (\"location_t\"))\n     {\n-      static format_char_info *diag_fci, *tdiag_fci, *cdiag_fci, *cxxdiag_fci;\n-      static format_length_info *diag_ls;\n-      unsigned int i;\n-\n-      /* For the GCC-diagnostics custom format specifiers to work, one\n-\t must have declared 'tree' and/or 'location_t' prior to using\n-\t those attributes.  If we haven't seen these declarations then\n-\t you shouldn't use the specifiers requiring these types.\n-\t However we don't force a hard ICE because we may see only one\n-\t or the other type.  */\n-      if ((loc = maybe_get_identifier (\"location_t\")))\n-\t{\n-\t  loc = identifier_global_value (loc);\n-\t  if (loc)\n-\t    {\n-\t      if (TREE_CODE (loc) != TYPE_DECL)\n-\t\t{\n-\t\t  error (\"%<location_t%> is not defined as a type\");\n-\t\t  loc = 0;\n-\t\t}\n-\t      else\n-\t\tloc = TREE_TYPE (loc);\n-\t    }\n-\t}\n+      loc = identifier_global_value (loc);\n+      if (loc && TREE_CODE (loc) != TYPE_DECL)\n+\terror (\"%<location_t%> is not defined as a type\");\n+    }\n \n+  /* Initialize the global tree node type local to this file.  */\n+  if (!local_tree_type_node\n+      || local_tree_type_node == void_type_node)\n+    {\n       /* We need to grab the underlying 'union tree_node' so peek into\n \t an extra type level.  */\n-      if ((t = maybe_get_identifier (\"tree\")))\n+      if ((local_tree_type_node = maybe_get_identifier (\"tree\")))\n \t{\n-\t  t = identifier_global_value (t);\n-\t  if (t)\n+\t  local_tree_type_node = identifier_global_value (local_tree_type_node);\n+\t  if (local_tree_type_node)\n \t    {\n-\t      if (TREE_CODE (t) != TYPE_DECL)\n+\t      if (TREE_CODE (local_tree_type_node) != TYPE_DECL)\n \t\t{\n \t\t  error (\"%<tree%> is not defined as a type\");\n-\t\t  t = 0;\n+\t\t  local_tree_type_node = 0;\n \t\t}\n-\t      else if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n+\t      else if (TREE_CODE (TREE_TYPE (local_tree_type_node))\n+\t\t       != POINTER_TYPE)\n \t\t{\n \t\t  error (\"%<tree%> is not defined as a pointer type\");\n-\t\t  t = 0;\n+\t\t  local_tree_type_node = 0;\n \t\t}\n \t      else\n-\t\tt = TREE_TYPE (TREE_TYPE (t));\n+\t\tlocal_tree_type_node =\n+\t\t  TREE_TYPE (TREE_TYPE (local_tree_type_node));\n \t    }\n \t}\n+      else\n+\tlocal_tree_type_node = void_type_node;\n+    }\n \n-      /* Find the underlying type for HOST_WIDE_INT.  For the %w\n+  static tree hwi;\n+\n+  if (!hwi)\n+    {\n+      static format_length_info *diag_ls;\n+      unsigned int i;\n+\n+      /* Find the underlying type for HOST_WIDE_INT.  For the 'w'\n \t length modifier to work, one must have issued: \"typedef\n \t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n \t prior to using that modifier.  */\n@@ -3757,75 +3887,17 @@ init_dynamic_diag_info (void)\n \t  else\n \t    gcc_unreachable ();\n \t}\n-\n-      /* Handle the __gcc_diag__ format specifics.  */\n-      if (!diag_fci)\n-\tdynamic_format_types[gcc_diag_format_type].conversion_specs =\n-\t  diag_fci = (format_char_info *)\n-\t\t     xmemdup (gcc_diag_char_table,\n-\t\t\t      sizeof (gcc_diag_char_table),\n-\t\t\t      sizeof (gcc_diag_char_table));\n-      if (t)\n-\t{\n-\t  i = find_char_info_specifier_index (diag_fci, 'K');\n-\t  diag_fci[i].types[0].type = &t;\n-\t  diag_fci[i].pointer_count = 1;\n-\t}\n-\n-      /* Handle the __gcc_tdiag__ format specifics.  */\n-      if (!tdiag_fci)\n-\tdynamic_format_types[gcc_tdiag_format_type].conversion_specs =\n-\t  tdiag_fci = (format_char_info *)\n-\t\t      xmemdup (gcc_tdiag_char_table,\n-\t\t\t       sizeof (gcc_tdiag_char_table),\n-\t\t\t       sizeof (gcc_tdiag_char_table));\n-      if (t)\n-\t{\n-\t  /* All specifiers taking a tree share the same struct.  */\n-\t  i = find_char_info_specifier_index (tdiag_fci, 'D');\n-\t  tdiag_fci[i].types[0].type = &t;\n-\t  tdiag_fci[i].pointer_count = 1;\n-\t  i = find_char_info_specifier_index (tdiag_fci, 'K');\n-\t  tdiag_fci[i].types[0].type = &t;\n-\t  tdiag_fci[i].pointer_count = 1;\n-\t}\n-\n-      /* Handle the __gcc_cdiag__ format specifics.  */\n-      if (!cdiag_fci)\n-\tdynamic_format_types[gcc_cdiag_format_type].conversion_specs =\n-\t  cdiag_fci = (format_char_info *)\n-\t\t      xmemdup (gcc_cdiag_char_table,\n-\t\t\t       sizeof (gcc_cdiag_char_table),\n-\t\t\t       sizeof (gcc_cdiag_char_table));\n-      if (t)\n-\t{\n-\t  /* All specifiers taking a tree share the same struct.  */\n-\t  i = find_char_info_specifier_index (cdiag_fci, 'D');\n-\t  cdiag_fci[i].types[0].type = &t;\n-\t  cdiag_fci[i].pointer_count = 1;\n-\t  i = find_char_info_specifier_index (cdiag_fci, 'K');\n-\t  cdiag_fci[i].types[0].type = &t;\n-\t  cdiag_fci[i].pointer_count = 1;\n-\t}\n-\n-      /* Handle the __gcc_cxxdiag__ format specifics.  */\n-      if (!cxxdiag_fci)\n-\tdynamic_format_types[gcc_cxxdiag_format_type].conversion_specs =\n-\t  cxxdiag_fci = (format_char_info *)\n-\t\t\txmemdup (gcc_cxxdiag_char_table,\n-\t\t\t\t sizeof (gcc_cxxdiag_char_table),\n-\t\t\t\t sizeof (gcc_cxxdiag_char_table));\n-      if (t)\n-\t{\n-\t  /* All specifiers taking a tree share the same struct.  */\n-\t  i = find_char_info_specifier_index (cxxdiag_fci, 'D');\n-\t  cxxdiag_fci[i].types[0].type = &t;\n-\t  cxxdiag_fci[i].pointer_count = 1;\n-\t  i = find_char_info_specifier_index (cxxdiag_fci, 'K');\n-\t  cxxdiag_fci[i].types[0].type = &t;\n-\t  cxxdiag_fci[i].pointer_count = 1;\n-\t}\n     }\n+\n+  /* It's safe to \"re-initialize these to the same values.  */\n+  dynamic_format_types[gcc_diag_format_type].conversion_specs =\n+    gcc_diag_char_table;\n+  dynamic_format_types[gcc_tdiag_format_type].conversion_specs =\n+    gcc_tdiag_char_table;\n+  dynamic_format_types[gcc_cdiag_format_type].conversion_specs =\n+    gcc_cdiag_char_table;\n+  dynamic_format_types[gcc_cxxdiag_format_type].conversion_specs =\n+    gcc_cxxdiag_char_table;\n }\n \n #ifdef TARGET_FORMAT_TYPES"}, {"sha": "37fa3828485a4fe5016a40e8b8278f8f8c83462f", "filename": "gcc/c-family/c-format.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Fc-family%2Fc-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Fc-family%2Fc-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.h?ref=631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "patch": "@@ -151,7 +151,16 @@ struct format_char_info\n      \"W\" if the argument is a pointer which is dereferenced and written into,\n      \"R\" if the argument is a pointer which is dereferenced and read from,\n      \"i\" for printf integer formats where the '0' flag is ignored with\n-     precision, and \"[\" for the starting character of a scanf scanset.  */\n+     precision, and \"[\" for the starting character of a scanf scanset,\n+     \"<\" if the specifier introduces a quoted sequence (such as \"%<\"),\n+     \">\" if the specifier terminates a quoted sequence (such as \"%>\"),\n+     \"[\" if the specifier introduces a color sequence (such as \"%r\"),\n+     \"]\" if the specifier terminates a color sequence (such as \"%R\"),\n+     \"'\" (single quote) if the specifier is expected to be quoted when\n+     it appears outside a quoted sequence and unquoted otherwise (such\n+     as the GCC internal printf format directive \"%T\"), and\n+     \"\\\"\" (double quote) if the specifier is not expected to appear in\n+     a quoted sequence (such as the GCC internal format directive \"%K\".  */\n   const char *flags2;\n   /* If this format conversion character consumes more than one argument,\n      CHAIN points to information about the next argument.  For later\n@@ -178,6 +187,8 @@ struct format_flag_spec\n   /* Nonzero if the next character after this flag in the format should\n      be skipped ('=' in strfmon), zero otherwise.  */\n   int skip_next_char;\n+  /* True if the flag introduces quoting (as in GCC's %qE).  */\n+  bool quoting;\n   /* The name to use for this flag in diagnostic messages.  For example,\n      N_(\"'0' flag\"), N_(\"field width\").  */\n   const char *name;\n@@ -287,6 +298,7 @@ struct format_kind_info\n #define T_UC\t&unsigned_char_type_node\n #define T99_UC\t{ STD_C99, NULL, T_UC }\n #define T_V\t&void_type_node\n+#define T89_T   { STD_C89, NULL, &local_tree_type_node }\n #define T89_V\t{ STD_C89, NULL, T_V }\n #define T_W\t&wchar_type_node\n #define T94_W\t{ STD_C94, \"wchar_t\", T_W }"}, {"sha": "8930e38406458a761ef9bb3970c9dcb00f3e0da2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "patch": "@@ -1,3 +1,8 @@\n+2017-05-08  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR translation/80280\n+\t* gcc.dg/format/gcc_diag-10.c: New test.\n+\n 2017-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \tPR target/80101"}, {"sha": "b3be27739570b033655762618ae6f22cc373bc61", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-10.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631238ac3f50b42dd55e87cd8bea02c7fbec0f53/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c?ref=631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "patch": "@@ -0,0 +1,151 @@\n+/* Test for GCC internal format directives.\n+   { dg-do compile }\n+   { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+/* Magic identifiers must be set before the attribute is used.  */\n+\n+typedef long long __gcc_host_wide_int__;\n+\n+typedef struct location_s\n+{\n+  const char *file;\n+  int line;\n+} location_t;\n+\n+union tree_node;\n+typedef union tree_node *tree;\n+\n+\n+#define FORMAT(kind) __attribute__ ((format (__gcc_## kind ##__, 1, 2)))\n+\n+void diag (const char*, ...) FORMAT (diag);\n+void cdiag (const char*, ...) FORMAT (cdiag);\n+void tdiag (const char*, ...) FORMAT (tdiag);\n+void cxxdiag (const char*, ...) FORMAT (cxxdiag);\n+\n+void test_diag (tree t)\n+{\n+  diag (\"%<\");   /* { dg-warning \"unterminated quoting directive\" } */\n+  diag (\"%>\");   /* { dg-warning \"unmatched quoting directive \" } */\n+  diag (\"%<foo%<bar%>%>\");   /* { dg-warning \"nested quoting directive\" } */\n+\n+  diag (\"%K\", t);\n+\n+  diag (\"%R\");       /* { dg-warning \"unmatched color reset directive\" } */\n+  diag (\"%r\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  diag (\"%r%r\", \"\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  diag (\"%r%R\", \"\");\n+  diag (\"%r%r%R\", \"\", \"\");\n+  diag (\"%r%R%r%R\", \"\", \"\");\n+\n+  diag (\"%<%K%>\", t);   /* { dg-warning \".K. conversion used within a quoted sequence\" } */\n+\n+  diag (\"%<%R%>\");      /* { dg-warning \"unmatched color reset directive\" } */\n+  diag (\"%<%r%>\", \"\");  /* { dg-warning \"unterminated color directive\" } */\n+  diag (\"%<%r%R%>\", \"\");\n+}\n+\n+void test_cdiag (tree t)\n+{\n+  cdiag (\"%<\");   /* { dg-warning \"unterminated quoting directive\" } */\n+  cdiag (\"%>\");   /* { dg-warning \"unmatched quoting directive \" } */\n+  cdiag (\"%<foo%<bar%>%>\");   /* { dg-warning \"nested quoting directive\" } */\n+\n+  cdiag (\"%D\", t);       /* { dg-warning \".D. conversion used unquoted\" } */\n+  cdiag (\"%E\", t);\n+  cdiag (\"%F\", t);       /* { dg-warning \".F. conversion used unquoted\" } */\n+  cdiag (\"%K\", t);\n+\n+  cdiag (\"%R\");       /* { dg-warning \"unmatched color reset directive\" } */\n+  cdiag (\"%r\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  cdiag (\"%r%r\", \"\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  cdiag (\"%r%R\", \"\");\n+  cdiag (\"%r%r%R\", \"\", \"\");\n+  cdiag (\"%r%R%r%R\", \"\", \"\");\n+\n+  cdiag (\"%T\", t);       /* { dg-warning \".T. conversion used unquoted\" } */\n+  cdiag (\"%V\", t);       /* { dg-warning \".V. conversion used unquoted\" } */\n+\n+  cdiag (\"%<%D%>\", t);\n+  cdiag (\"%<%E%>\", t);\n+  cdiag (\"%<%F%>\", t);\n+  cdiag (\"%<%K%>\", t);   /* { dg-warning \".K. conversion used within a quoted sequence\" } */\n+\n+  cdiag (\"%<%R%>\");      /* { dg-warning \"unmatched color reset directive\" } */\n+  cdiag (\"%<%r%>\", \"\");  /* { dg-warning \"unterminated color directive\" } */\n+  cdiag (\"%<%r%R%>\", \"\");\n+\n+  cdiag (\"%<%T%>\", t);\n+  cdiag (\"%<%V%>\", t);\n+\n+  cdiag (\"%<%qD%>\", t);  /* { dg-warning \".q. flag used within a quoted sequence\" } */\n+  cdiag (\"%<%qE%>\", t);  /* { dg-warning \".q. flag used within a quoted sequence\" } */\n+  cdiag (\"%<%qT%>\", t);  /* { dg-warning \".q. flag used within a quoted sequence\" } */\n+}\n+\n+void test_tdiag (tree t)\n+{\n+  tdiag (\"%<\");       /* { dg-warning \"unterminated quoting directive\" } */\n+  tdiag (\"%>\");       /* { dg-warning \"unmatched quoting directive \" } */\n+  tdiag (\"%<foo%<bar%>%>\");   /* { dg-warning \"nested quoting directive\" } */\n+\n+  tdiag (\"%D\", t);       /* { dg-warning \".D. conversion used unquoted\" } */\n+  tdiag (\"%E\", t);\n+  tdiag (\"%K\", t);\n+\n+  tdiag (\"%R\");          /* { dg-warning \"unmatched color reset directive\" } */\n+  tdiag (\"%r\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  tdiag (\"%r%r\", \"\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  tdiag (\"%r%R\", \"\");\n+  tdiag (\"%r%R\", \"\");\n+  tdiag (\"%r%r%R\", \"\", \"\");\n+  tdiag (\"%r%R%r%R\", \"\", \"\");\n+\n+  tdiag (\"%T\", t);       /* { dg-warning \".T. conversion used unquoted\" } */\n+\n+  tdiag (\"%<%D%>\", t);\n+  tdiag (\"%<%E%>\", t);\n+  tdiag (\"%<%K%>\", t);   /* { dg-warning \".K. conversion used within a quoted sequence\" } */\n+\n+  tdiag (\"%<%R%>\");      /* { dg-warning \"unmatched color reset directive\" } */\n+  tdiag (\"%<%r%>\", \"\");  /* { dg-warning \"unterminated color directive\" } */\n+  tdiag (\"%<%r%R%>\", \"\");\n+\n+  tdiag (\"%<%T%>\", t);\n+\n+  tdiag (\"%<%qD%>\", t);  /* { dg-warning \".q. flag used within a quoted sequence\" } */\n+  tdiag (\"%<%qE%>\", t);  /* { dg-warning \".q. flag used within a quoted sequence\" } */\n+  tdiag (\"%<%qT%>\", t);  /* { dg-warning \".q. flag used within a quoted sequence\" } */\n+}\n+\n+void test_cxxdiag (tree t)\n+{\n+  cxxdiag (\"%A\", t);     /* { dg-warning \".A. conversion used unquoted\" } */\n+  cxxdiag (\"%D\", t);     /* { dg-warning \".D. conversion used unquoted\" } */\n+  cxxdiag (\"%E\", t);\n+  cxxdiag (\"%F\", t);     /* { dg-warning \".F. conversion used unquoted\" } */\n+\n+  cxxdiag (\"%R\");        /* { dg-warning \"unmatched color reset directive\" } */\n+  cxxdiag (\"%r\", \"\");    /* { dg-warning \"unterminated color directive\" } */\n+  cxxdiag (\"%r%r\", \"\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  cxxdiag (\"%r%R\", \"\");\n+  cxxdiag (\"%r%R\", \"\");\n+  cxxdiag (\"%r%r%R\", \"\", \"\");\n+  cxxdiag (\"%r%R%r%R\", \"\", \"\");\n+\n+  cxxdiag (\"%S\", t);     /* { dg-warning \".S. conversion used unquoted\" } */\n+  cxxdiag (\"%T\", t);     /* { dg-warning \".T. conversion used unquoted\" } */\n+  cxxdiag (\"%V\", t);     /* { dg-warning \".V. conversion used unquoted\" } */\n+  cxxdiag (\"%X\", t);     /* { dg-warning \".X. conversion used unquoted\" } */\n+\n+  cxxdiag (\"%<%A%>\", t);\n+  cxxdiag (\"%<%D%>\", t);\n+  cxxdiag (\"%<%E%>\", t);\n+  cxxdiag (\"%<%F%>\", t);\n+  cxxdiag (\"%<%R%>\");    /* { dg-warning \"unmatched color reset\" } */\n+  cxxdiag (\"%<%r%R%>\", \"\");\n+  cxxdiag (\"%<%S%>\", t);\n+  cxxdiag (\"%<%T%>\", t);\n+  cxxdiag (\"%<%V%>\", t);\n+  cxxdiag (\"%<%X%>\", t);\n+}"}]}