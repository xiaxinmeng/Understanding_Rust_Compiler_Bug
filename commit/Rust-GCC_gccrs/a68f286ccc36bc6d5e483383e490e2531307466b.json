{"sha": "a68f286ccc36bc6d5e483383e490e2531307466b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY4ZjI4NmNjYzM2YmM2ZDVlNDgzMzgzZTQ5MGUyNTMxMzA3NDY2Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-10-13T07:02:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-10-13T07:02:55Z"}, "message": "re PR tree-optimization/82451 ([GRAPHITE] codegen error in get_rename_from_scev)\n\n2017-10-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/82451\n\tRevert\n\t2017-10-02  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/82355\n\t* graphite-isl-ast-to-gimple.c (build_iv_mapping): Also build\n\ta mapping for the enclosing loop but avoid generating one for\n\tthe loop tree root.\n\t(copy_bb_and_scalar_dependences): Remove premature codegen\n\terror on PHIs in blocks duplicated into multiple places.\n\t* graphite-scop-detection.c\n\t(scop_detection::stmt_has_simple_data_refs_p): For a loop not\n\tin the region use it as loop and nest to analyze the DR in.\n\t(try_generate_gimple_bb): Likewise.\n\t* graphite-sese-to-poly.c (extract_affine_chrec): Adjust.\n\t(add_loop_constraints): For blocks in a loop not in the region\n\tcreate a dimension with a single iteration.\n\t* sese.h (gbb_loop_at_index): Remove assert.\n\n\t* cfgloop.c (loop_preheader_edge): For the loop tree root\n\treturn the single successor of the entry block.\n\t* graphite-isl-ast-to-gimple.c (graphite_regenerate_ast_isl):\n\tReset the SCEV hashtable and niters.\n\t* graphite-scop-detection.c\n\t(scop_detection::graphite_can_represent_scev): Add SCOP parameter,\n\tassert that we only have POLYNOMIAL_CHREC that vary in loops\n\tcontained in the region.\n\t(scop_detection::graphite_can_represent_expr): Adjust.\n\t(scop_detection::stmt_has_simple_data_refs_p): For loops\n\tnot in the region set loop to NULL.  The nest is now the\n\tentry edge to the region.\n\t(try_generate_gimple_bb): Likewise.\n\t* sese.c (scalar_evolution_in_region): Adjust for\n\tinstantiate_scev change.\n\t* tree-data-ref.h (graphite_find_data_references_in_stmt):\n\tMake nest parameter the edge into the region.\n\t(create_data_ref): Likewise.\n\t* tree-data-ref.c (dr_analyze_indices): Make nest parameter an\n\tentry edge into a region and adjust instantiate_scev calls.\n\t(create_data_ref): Likewise.\n\t(graphite_find_data_references_in_stmt): Likewise.\n\t(find_data_references_in_stmt): Pass the loop preheader edge\n\tfrom the nest argument.\n\t* tree-scalar-evolution.h (instantiate_scev): Make instantiate_below\n\tparameter the edge into the region.\n\t(instantiate_parameters): Use the loop preheader edge as entry.\n\t* tree-scalar-evolution.c (analyze_scalar_evolution): Handle\n\tNULL loop.\n\t(get_instantiated_value_entry): Make instantiate_below parameter\n\tthe edge into the region.\n\t(instantiate_scev_name): Likewise.  Adjust dominance checks,\n\twhen we cannot use loop-based instantiation instantiate by\n\twalking use-def chains.\n\t(instantiate_scev_poly): Adjust.\n\t(instantiate_scev_binary): Likewise.\n\t(instantiate_scev_convert): Likewise.\n\t(instantiate_scev_not): Likewise.\n\t(instantiate_array_ref): Remove.\n\t(instantiate_scev_3): Likewise.\n\t(instantiate_scev_2): Likewise.\n\t(instantiate_scev_1): Likewise.\n\t(instantiate_scev_r): Do not blindly handle N-operand trees.\n\tDo not instantiate array-refs.  Handle all constants and invariants.\n\t(instantiate_scev): Make instantiate_below parameter\n\tthe edge into the region.\n\t(resolve_mixers): Use the loop preheader edge for the region\n\tparameter to instantiate_scev_r.\n\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Adjust.\n\n\t* gcc.dg/graphite/pr82451.c: New testcase.\n\t* gfortran.dg/graphite/id-27.f90: Likewise.\n\t* gfortran.dg/graphite/pr82451.f: Likewise.\n\nFrom-SVN: r253707", "tree": {"sha": "680ab0c2d5a23c72aba53e272d03154fe7b9a7d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/680ab0c2d5a23c72aba53e272d03154fe7b9a7d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a68f286ccc36bc6d5e483383e490e2531307466b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a68f286ccc36bc6d5e483383e490e2531307466b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a68f286ccc36bc6d5e483383e490e2531307466b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a68f286ccc36bc6d5e483383e490e2531307466b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c"}], "stats": {"total": 604, "additions": 324, "deletions": 280}, "files": [{"sha": "bff2a6fe00dc71b4e7e0b55834958a60c5e9db64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -1,3 +1,74 @@\n+2017-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82451\n+\tRevert\n+\t2017-10-02  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82355\n+\t* graphite-isl-ast-to-gimple.c (build_iv_mapping): Also build\n+\ta mapping for the enclosing loop but avoid generating one for\n+\tthe loop tree root.\n+\t(copy_bb_and_scalar_dependences): Remove premature codegen\n+\terror on PHIs in blocks duplicated into multiple places.\n+\t* graphite-scop-detection.c\n+\t(scop_detection::stmt_has_simple_data_refs_p): For a loop not\n+\tin the region use it as loop and nest to analyze the DR in.\n+\t(try_generate_gimple_bb): Likewise.\n+\t* graphite-sese-to-poly.c (extract_affine_chrec): Adjust.\n+\t(add_loop_constraints): For blocks in a loop not in the region\n+\tcreate a dimension with a single iteration.\n+\t* sese.h (gbb_loop_at_index): Remove assert.\n+\n+\t* cfgloop.c (loop_preheader_edge): For the loop tree root\n+\treturn the single successor of the entry block.\n+\t* graphite-isl-ast-to-gimple.c (graphite_regenerate_ast_isl):\n+\tReset the SCEV hashtable and niters.\n+\t* graphite-scop-detection.c\n+\t(scop_detection::graphite_can_represent_scev): Add SCOP parameter,\n+\tassert that we only have POLYNOMIAL_CHREC that vary in loops\n+\tcontained in the region.\n+\t(scop_detection::graphite_can_represent_expr): Adjust.\n+\t(scop_detection::stmt_has_simple_data_refs_p): For loops\n+\tnot in the region set loop to NULL.  The nest is now the\n+\tentry edge to the region.\n+\t(try_generate_gimple_bb): Likewise.\n+\t* sese.c (scalar_evolution_in_region): Adjust for\n+\tinstantiate_scev change.\n+\t* tree-data-ref.h (graphite_find_data_references_in_stmt):\n+\tMake nest parameter the edge into the region.\n+\t(create_data_ref): Likewise.\n+\t* tree-data-ref.c (dr_analyze_indices): Make nest parameter an\n+\tentry edge into a region and adjust instantiate_scev calls.\n+\t(create_data_ref): Likewise.\n+\t(graphite_find_data_references_in_stmt): Likewise.\n+\t(find_data_references_in_stmt): Pass the loop preheader edge\n+\tfrom the nest argument.\n+\t* tree-scalar-evolution.h (instantiate_scev): Make instantiate_below\n+\tparameter the edge into the region.\n+\t(instantiate_parameters): Use the loop preheader edge as entry.\n+\t* tree-scalar-evolution.c (analyze_scalar_evolution): Handle\n+\tNULL loop.\n+\t(get_instantiated_value_entry): Make instantiate_below parameter\n+\tthe edge into the region.\n+\t(instantiate_scev_name): Likewise.  Adjust dominance checks,\n+\twhen we cannot use loop-based instantiation instantiate by\n+\twalking use-def chains.\n+\t(instantiate_scev_poly): Adjust.\n+\t(instantiate_scev_binary): Likewise.\n+\t(instantiate_scev_convert): Likewise.\n+\t(instantiate_scev_not): Likewise.\n+\t(instantiate_array_ref): Remove.\n+\t(instantiate_scev_3): Likewise.\n+\t(instantiate_scev_2): Likewise.\n+\t(instantiate_scev_1): Likewise.\n+\t(instantiate_scev_r): Do not blindly handle N-operand trees.\n+\tDo not instantiate array-refs.  Handle all constants and invariants.\n+\t(instantiate_scev): Make instantiate_below parameter\n+\tthe edge into the region.\n+\t(resolve_mixers): Use the loop preheader edge for the region\n+\tparameter to instantiate_scev_r.\n+\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Adjust.\n+\n 2017-10-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82525"}, {"sha": "c3bd9c05013d81a197bfd659261e872c499c886a", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -1713,12 +1713,19 @@ loop_preheader_edge (const struct loop *loop)\n   edge e;\n   edge_iterator ei;\n \n-  gcc_assert (loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS));\n+  gcc_assert (loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS)\n+\t      && ! loops_state_satisfies_p (LOOPS_MAY_HAVE_MULTIPLE_LATCHES));\n \n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     if (e->src != loop->latch)\n       break;\n \n+  if (! e)\n+    {\n+      gcc_assert (! loop_outer (loop));\n+      return single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+    }\n+\n   return e;\n }\n "}, {"sha": "874941824cd98ed505de5930b5ebf16e46e0de46", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -750,10 +750,8 @@ build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n       if (codegen_error_p ())\n \tt = integer_zero_node;\n \n-      loop_p old_loop = gbb_loop_at_index (gbb, region, i - 2);\n-      /* Record sth only for real loops.  */\n-      if (loop_in_sese_p (old_loop, region))\n-\tiv_map[old_loop->num] = t;\n+      loop_p old_loop = gbb_loop_at_index (gbb, region, i - 1);\n+      iv_map[old_loop->num] = t;\n     }\n }\n \n@@ -1571,6 +1569,12 @@ graphite_regenerate_ast_isl (scop_p scop)\n       update_ssa (TODO_update_ssa);\n       checking_verify_ssa (true, true);\n       rewrite_into_loop_closed_ssa (NULL, 0);\n+      /* We analyzed evolutions of all SCOPs during SCOP detection\n+         which cached evolutions.  Now we've introduced PHIs for\n+\t liveouts which causes those cached solutions to be invalid\n+\t for code-generation purposes given we'd insert references\n+\t to SSA names not dominating their new use.  */\n+      scev_reset ();\n     }\n \n   if (t.codegen_error_p ())"}, {"sha": "c7e1dba9423a177b5e1806391112c7a0ada9d79a", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -381,7 +381,7 @@ class scop_detection\n \n      Something like \"i * n\" or \"n * m\" is not allowed.  */\n \n-  static bool graphite_can_represent_scev (tree scev);\n+  static bool graphite_can_represent_scev (sese_l scop, tree scev);\n \n   /* Return true when EXPR can be represented in the polyhedral model.\n \n@@ -934,7 +934,7 @@ scop_detection::graphite_can_represent_init (tree e)\n    Something like \"i * n\" or \"n * m\" is not allowed.  */\n \n bool\n-scop_detection::graphite_can_represent_scev (tree scev)\n+scop_detection::graphite_can_represent_scev (sese_l scop, tree scev)\n {\n   if (chrec_contains_undetermined (scev))\n     return false;\n@@ -945,32 +945,34 @@ scop_detection::graphite_can_represent_scev (tree scev)\n     case BIT_NOT_EXPR:\n     CASE_CONVERT:\n     case NON_LVALUE_EXPR:\n-      return graphite_can_represent_scev (TREE_OPERAND (scev, 0));\n+      return graphite_can_represent_scev (scop, TREE_OPERAND (scev, 0));\n \n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n-      return graphite_can_represent_scev (TREE_OPERAND (scev, 0))\n-\t&& graphite_can_represent_scev (TREE_OPERAND (scev, 1));\n+      return graphite_can_represent_scev (scop, TREE_OPERAND (scev, 0))\n+\t&& graphite_can_represent_scev (scop, TREE_OPERAND (scev, 1));\n \n     case MULT_EXPR:\n       return !CONVERT_EXPR_CODE_P (TREE_CODE (TREE_OPERAND (scev, 0)))\n \t&& !CONVERT_EXPR_CODE_P (TREE_CODE (TREE_OPERAND (scev, 1)))\n \t&& !(chrec_contains_symbols (TREE_OPERAND (scev, 0))\n \t     && chrec_contains_symbols (TREE_OPERAND (scev, 1)))\n \t&& graphite_can_represent_init (scev)\n-\t&& graphite_can_represent_scev (TREE_OPERAND (scev, 0))\n-\t&& graphite_can_represent_scev (TREE_OPERAND (scev, 1));\n+\t&& graphite_can_represent_scev (scop, TREE_OPERAND (scev, 0))\n+\t&& graphite_can_represent_scev (scop, TREE_OPERAND (scev, 1));\n \n     case POLYNOMIAL_CHREC:\n       /* Check for constant strides.  With a non constant stride of\n \t 'n' we would have a value of 'iv * n'.  Also check that the\n \t initial value can represented: for example 'n * m' cannot be\n \t represented.  */\n+      gcc_assert (loop_in_sese_p (get_loop (cfun,\n+\t\t\t\t\t    CHREC_VARIABLE (scev)), scop));\n       if (!evolution_function_right_is_integer_cst (scev)\n \t  || !graphite_can_represent_init (scev))\n \treturn false;\n-      return graphite_can_represent_scev (CHREC_LEFT (scev));\n+      return graphite_can_represent_scev (scop, CHREC_LEFT (scev));\n \n     default:\n       break;\n@@ -994,7 +996,7 @@ scop_detection::graphite_can_represent_expr (sese_l scop, loop_p loop,\n \t\t\t\t\t     tree expr)\n {\n   tree scev = scalar_evolution_in_region (scop, loop, expr);\n-  return graphite_can_represent_scev (scev);\n+  return graphite_can_represent_scev (scop, scev);\n }\n \n /* Return true if the data references of STMT can be represented by Graphite.\n@@ -1003,12 +1005,15 @@ scop_detection::graphite_can_represent_expr (sese_l scop, loop_p loop,\n bool\n scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n {\n-  loop_p nest;\n+  edge nest;\n   loop_p loop = loop_containing_stmt (stmt);\n   if (!loop_in_sese_p (loop, scop))\n-    nest = loop;\n+    {\n+      nest = scop.entry;\n+      loop = NULL;\n+    }\n   else\n-    nest = outermost_loop_in_sese (scop, gimple_bb (stmt));\n+    nest = loop_preheader_edge (outermost_loop_in_sese (scop, gimple_bb (stmt)));\n \n   auto_vec<data_reference_p> drs;\n   if (! graphite_find_data_references_in_stmt (nest, loop, stmt, &drs))\n@@ -1019,7 +1024,7 @@ scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n   FOR_EACH_VEC_ELT (drs, j, dr)\n     {\n       for (unsigned i = 0; i < DR_NUM_DIMENSIONS (dr); ++i)\n-\tif (! graphite_can_represent_scev (DR_ACCESS_FN (dr, i)))\n+\tif (! graphite_can_represent_scev (scop, DR_ACCESS_FN (dr, i)))\n \t  return false;\n     }\n \n@@ -1376,12 +1381,15 @@ try_generate_gimple_bb (scop_p scop, basic_block bb)\n   vec<scalar_use> reads = vNULL;\n \n   sese_l region = scop->scop_info->region;\n-  loop_p nest;\n+  edge nest;\n   loop_p loop = bb->loop_father;\n   if (!loop_in_sese_p (loop, region))\n-    nest = loop;\n+    {\n+      nest = region.entry;\n+      loop = NULL;\n+    }\n   else\n-    nest = outermost_loop_in_sese (region, bb);\n+    nest = loop_preheader_edge (outermost_loop_in_sese (region, bb));\n \n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n        gsi_next (&gsi))"}, {"sha": "ed6cbeccca1f6f5a97d3924313fe1da0e842a789", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -86,7 +86,7 @@ extract_affine_chrec (scop_p s, tree e, __isl_take isl_space *space)\n   isl_pw_aff *lhs = extract_affine (s, CHREC_LEFT (e), isl_space_copy (space));\n   isl_pw_aff *rhs = extract_affine (s, CHREC_RIGHT (e), isl_space_copy (space));\n   isl_local_space *ls = isl_local_space_from_space (space);\n-  unsigned pos = sese_loop_depth (s->scop_info->region, get_chrec_loop (e));\n+  unsigned pos = sese_loop_depth (s->scop_info->region, get_chrec_loop (e)) - 1;\n   isl_aff *loop = isl_aff_set_coefficient_si\n     (isl_aff_zero_on_domain (ls), isl_dim_in, pos, 1);\n   isl_pw_aff *l = isl_pw_aff_from_aff (loop);\n@@ -763,10 +763,10 @@ add_loop_constraints (scop_p scop, __isl_take isl_set *domain, loop_p loop,\n     return domain;\n   const sese_l &region = scop->scop_info->region;\n   if (!loop_in_sese_p (loop, region))\n-    ;\n-  else\n-    /* Recursion all the way up to the context loop.  */\n-    domain = add_loop_constraints (scop, domain, loop_outer (loop), context);\n+    return domain;\n+\n+  /* Recursion all the way up to the context loop.  */\n+  domain = add_loop_constraints (scop, domain, loop_outer (loop), context);\n \n   /* Then, build constraints over the loop in post-order: outer to inner.  */\n \n@@ -777,21 +777,6 @@ add_loop_constraints (scop_p scop, __isl_take isl_set *domain, loop_p loop,\n   domain = add_iter_domain_dimension (domain, loop, scop);\n   isl_space *space = isl_set_get_space (domain);\n \n-  if (!loop_in_sese_p (loop, region))\n-    {\n-      /* 0 == loop_i */\n-      isl_local_space *ls = isl_local_space_from_space (space);\n-      isl_constraint *c = isl_equality_alloc (ls);\n-      c = isl_constraint_set_coefficient_si (c, isl_dim_set, loop_index, 1);\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[sese-to-poly] adding constraint to the domain: \");\n-\t  print_isl_constraint (dump_file, c);\n-\t}\n-      domain = isl_set_add_constraint (domain, c);\n-      return domain;\n-    }\n-\n   /* 0 <= loop_i */\n   isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n   isl_constraint *c = isl_inequality_alloc (ls);"}, {"sha": "8aa8015290ddacd6c8c3bda425fc9f669b824e3d", "filename": "gcc/sese.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -461,7 +461,6 @@ scalar_evolution_in_region (const sese_l &region, loop_p loop, tree t)\n {\n   gimple *def;\n   struct loop *def_loop;\n-  basic_block before = region.entry->src;\n \n   /* SCOP parameters.  */\n   if (TREE_CODE (t) == SSA_NAME\n@@ -472,7 +471,7 @@ scalar_evolution_in_region (const sese_l &region, loop_p loop, tree t)\n       || loop_in_sese_p (loop, region))\n     /* FIXME: we would need instantiate SCEV to work on a region, and be more\n        flexible wrt. memory loads that may be invariant in the region.  */\n-    return instantiate_scev (before, loop,\n+    return instantiate_scev (region.entry, loop,\n \t\t\t     analyze_scalar_evolution (loop, t));\n \n   def = SSA_NAME_DEF_STMT (t);\n@@ -494,7 +493,7 @@ scalar_evolution_in_region (const sese_l &region, loop_p loop, tree t)\n   if (has_vdefs)\n     return chrec_dont_know;\n \n-  return instantiate_scev (before, loop, t);\n+  return instantiate_scev (region.entry, loop, t);\n }\n \n /* Return true if BB is empty, contains only DEBUG_INSNs.  */"}, {"sha": "faefd806d9da788b0ae7685e9c6020a77c1e80ed", "filename": "gcc/sese.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -334,6 +334,8 @@ gbb_loop_at_index (gimple_poly_bb_p gbb, sese_l &region, int index)\n   while (--depth > index)\n     loop = loop_outer (loop);\n \n+  gcc_assert (loop_in_sese_p (loop, region));\n+\n   return loop;\n }\n "}, {"sha": "a830453eabdf646605119acc34344814d7be8ed3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -1,3 +1,10 @@\n+2017-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82451\n+\t* gcc.dg/graphite/pr82451.c: New testcase.\n+\t* gfortran.dg/graphite/id-27.f90: Likewise.\n+\t* gfortran.dg/graphite/pr82451.f: Likewise.\n+\n 2017-10-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82525"}, {"sha": "204d3b20703e18098e023e537f539bb63db3fd16", "filename": "gcc/testsuite/gcc.dg/graphite/fuse-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Ffuse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Ffuse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Ffuse-1.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -1,15 +1,15 @@\n /* Check that the two loops are fused and that we manage to fold the two xor\n    operations.  */\n-/* { dg-options \"-O2 -floop-nest-optimize -fdump-tree-forwprop4-all -fdump-tree-graphite-all\" } */\n+/* { dg-options \"-O2 -floop-nest-optimize -fdump-tree-forwprop-all -fdump-tree-graphite-all\" } */\n \n /* Make sure we fuse the loops like this:\n AST generated by isl:\n for (int c0 = 0; c0 <= 99; c0 += 1) {\n-  S_3(0, c0);\n-  S_6(0, c0);\n-  S_9(0, c0);\n+  S_3(c0);\n+  S_6(c0);\n+  S_9(c0);\n } */\n-/* { dg-final { scan-tree-dump-times \"AST generated by isl:.*for \\\\(int c0 = 0; c0 <= 99; c0 \\\\+= 1\\\\) \\\\{.*S_.*\\\\(0, c0\\\\);.*S_.*\\\\(0, c0\\\\);.*S_.*\\\\(0, c0\\\\);.*\\\\}\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"AST generated by isl:.*for \\\\(int c0 = 0; c0 <= 99; c0 \\\\+= 1\\\\) \\\\{.*S_.*\\\\(c0\\\\);.*S_.*\\\\(c0\\\\);.*S_.*\\\\(c0\\\\);.*\\\\}\" 1 \"graphite\" } } */\n \n /* Check that after fusing the loops, the scalar computation is also fused.  */\n /* { dg-final { scan-tree-dump-times \"gimple_simplified to\\[^\\\\n\\]*\\\\^ 12\" 1 \"forwprop4\" } } */"}, {"sha": "f4cea4360d9e5deb8a73ff5c145b8e9cfb243995", "filename": "gcc/testsuite/gcc.dg/graphite/fuse-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Ffuse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Ffuse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Ffuse-2.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -3,13 +3,13 @@\n /* Make sure we fuse the loops like this:\n AST generated by isl:\n for (int c0 = 0; c0 <= 99; c0 += 1) {\n-  S_3(0, c0);\n-  S_6(0, c0);\n-  S_9(0, c0);\n+  S_3(c0);\n+  S_6(c0);\n+  S_9(c0);\n }\n */\n \n-/* { dg-final { scan-tree-dump-times \"AST generated by isl:.*for \\\\(int c0 = 0; c0 <= 99; c0 \\\\+= 1\\\\) \\\\{.*S_.*\\\\(0, c0\\\\);.*S_.*\\\\(0, c0\\\\);.*S_.*\\\\(0, c0\\\\);.*\\\\}\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"AST generated by isl:.*for \\\\(int c0 = 0; c0 <= 99; c0 \\\\+= 1\\\\) \\\\{.*S_.*\\\\(c0\\\\);.*S_.*\\\\(c0\\\\);.*S_.*\\\\(c0\\\\);.*\\\\}\" 1 \"graphite\" } } */\n \n #define MAX 100\n int A[MAX], B[MAX], C[MAX];"}, {"sha": "802b931fdddd2934854507129f108c64605a2778", "filename": "gcc/testsuite/gcc.dg/graphite/pr82451.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr82451.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr82451.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr82451.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -floop-parallelize-all\" } */\n+\n+static int a[];\n+int b[1];\n+int c;\n+static void\n+d (int *f, int *g)\n+{\n+  int e;\n+  for (e = 0; e < 2; e++)\n+    g[e] = 1;\n+  for (e = 0; e < 2; e++)\n+    g[e] = f[e] + f[e + 1];\n+}\n+void\n+h ()\n+{\n+  for (;; c += 8)\n+    d (&a[c], b);\n+}"}, {"sha": "e1e7ec0951faa51da01f9d61114237affe12ac10", "filename": "gcc/testsuite/gfortran.dg/graphite/id-27.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-27.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-27.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-27.f90?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -0,0 +1,40 @@\n+! { dg-additional-options \"-Ofast\" }\n+MODULE module_ra_gfdleta\n+      INTEGER, PARAMETER              :: NBLY=15\n+      REAL   , SAVE :: EM1(28,180),EM1WDE(28,180),TABLE1(28,180),     &\n+                           TABLE2(28,180),TABLE3(28,180),EM3(28,180), &\n+                           SOURCE(28,NBLY), DSRCE(28,NBLY)\n+CONTAINS\n+      SUBROUTINE TABLE \n+ INTEGER, PARAMETER :: NBLX=47\n+ INTEGER , PARAMETER:: NBLW = 163\n+      REAL ::  &\n+               SUM(28,180),PERTSM(28,180),SUM3(28,180),       &\n+               SUMWDE(28,180),SRCWD(28,NBLX),SRC1NB(28,NBLW), &\n+               DBDTNB(28,NBLW)\n+      REAL ::  &\n+               ZMASS(181),ZROOT(181),SC(28),DSC(28),XTEMV(28), &\n+               TFOUR(28),FORTCU(28),X(28),X1(28),X2(180),SRCS(28), &\n+               R1T(28),R2(28),S2(28),T3(28),R1WD(28)\n+      REAL ::  EXPO(180),FAC(180)\n+      I = 0\n+      DO 417 J=121,180\n+      FAC(J)=ZMASS(J)*(ONE-(ONE+X2(J))*EXPO(J))/(X2(J)*X2(J))\n+417   CONTINUE\n+      DO 421 J=121,180\n+      SUM3(I,J)=SUM3(I,J)+DBDTNB(I,N)*FAC(J)\n+421   CONTINUE\n+      IF (CENT.GT.160. .AND. CENT.LT.560.) THEN\n+         DO 420 J=1,180\n+         DO 420 I=1,28\n+         SUMWDE(I,J)=SUMWDE(I,J)+SRC1NB(I,N)*EXPO(J)\n+420      CONTINUE\n+      ENDIF\n+      DO 433 J=121,180\n+      EM3(I,J)=SUM3(I,J)/FORTCU(I)\n+433   CONTINUE\n+      DO 501 I=1,28\n+      EM1WDE(I,J)=SUMWDE(I,J)/TFOUR(I)\n+501   CONTINUE\n+      END SUBROUTINE TABLE\n+      END MODULE module_RA_GFDLETA"}, {"sha": "88ff85b1a99ec7b86e037a0995a28d5366412d86", "filename": "gcc/testsuite/gfortran.dg/graphite/pr82451.f", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr82451.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr82451.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr82451.f?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -floop-nest-optimize\" }\n+      MODULE LES3D_DATA\n+      PARAMETER ( NSCHEME = 4, ICHEM = 0, ISGSK = 0, IVISC = 1 )\n+      DOUBLE PRECISION DT, TIME, STATTIME, CFL, RELNO, TSTND, ALREF\n+      INTEGER IDYN, IMAX, JMAX, KMAX\n+      PARAMETER( RUNIV =  8.3145D3,\n+     >        TPRANDLT =    0.91D0)\n+      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:) ::\n+     >             U, V, W, P, T, H, EK,\n+     >         UAV, VAV, WAV, PAV, TAV, HAV, EKAV\n+      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:,:) ::\n+     >             CONC, HF, QAV, COAV, HFAV, DU\n+      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:,:,:) ::\n+     >             Q\n+      END MODULE LES3D_DATA\n+      SUBROUTINE FLUXJ()\n+      USE LES3D_DATA\n+      ALLOCATABLE QS(:), FSJ(:,:,:)\n+      ALLOCATABLE DWDX(:),DWDY(:),DWDZ(:)\n+      ALLOCATABLE DHDY(:), DKDY(:)\n+      PARAMETER (  R12I = 1.0D0 / 12.0D0,\n+     >             TWO3 = 2.0D0 / 3.0D0 )\n+      ALLOCATE( QS(IMAX-1), FSJ(IMAX-1,0:JMAX-1,ND))\n+      ALLOCATE( DWDX(IMAX-1),DWDY(IMAX-1),DWDZ(IMAX-1))\n+      I1 = 1\n+      DO K = K1,K2\n+         DO J = J1,J2\n+            DO I = I1, I2\n+               FSJ(I,J,5) = FSJ(I,J,5) + PAV(I,J,K) * QS(I)\n+            END DO\n+            DO I = I1, I2\n+               DWDX(I) = DXI * R12I * (WAV(I-2,J,K) - WAV(I+2,J,K) +\n+     >                        8.0D0 * (WAV(I+1,J,K) - WAV(I-1,J,K)))\n+            END DO\n+         END DO\n+      END DO\n+      DEALLOCATE( QS, FSJ, DHDY, DKDY)\n+      END"}, {"sha": "559a8e4b8457208c4c8200cd686fb02015c6fb1a", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -957,15 +957,14 @@ access_fn_component_p (tree op)\n }\n \n /* Determines the base object and the list of indices of memory reference\n-   DR, analyzed in LOOP and instantiated in loop nest NEST.  */\n+   DR, analyzed in LOOP and instantiated before NEST.  */\n \n static void\n-dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n+dr_analyze_indices (struct data_reference *dr, edge nest, loop_p loop)\n {\n   vec<tree> access_fns = vNULL;\n   tree ref, op;\n   tree base, off, access_fn;\n-  basic_block before_loop;\n \n   /* If analyzing a basic-block there are no indices to analyze\n      and thus no access functions.  */\n@@ -977,7 +976,6 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n     }\n \n   ref = DR_REF (dr);\n-  before_loop = block_before_loop (nest);\n \n   /* REALPART_EXPR and IMAGPART_EXPR can be handled like accesses\n      into a two element array with a constant index.  The base is\n@@ -1002,7 +1000,7 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n \t{\n \t  op = TREE_OPERAND (ref, 1);\n \t  access_fn = analyze_scalar_evolution (loop, op);\n-\t  access_fn = instantiate_scev (before_loop, loop, access_fn);\n+\t  access_fn = instantiate_scev (nest, loop, access_fn);\n \t  access_fns.safe_push (access_fn);\n \t}\n       else if (TREE_CODE (ref) == COMPONENT_REF\n@@ -1034,7 +1032,7 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n     {\n       op = TREE_OPERAND (ref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n-      access_fn = instantiate_scev (before_loop, loop, access_fn);\n+      access_fn = instantiate_scev (nest, loop, access_fn);\n       if (TREE_CODE (access_fn) == POLYNOMIAL_CHREC)\n \t{\n \t  tree orig_type;\n@@ -1139,7 +1137,7 @@ free_data_ref (data_reference_p dr)\n    in which the data reference should be analyzed.  */\n \n struct data_reference *\n-create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n+create_data_ref (edge nest, loop_p loop, tree memref, gimple *stmt,\n \t\t bool is_read, bool is_conditional_in_stmt)\n {\n   struct data_reference *dr;\n@@ -4970,7 +4968,8 @@ find_data_references_in_stmt (struct loop *nest, gimple *stmt,\n \n   FOR_EACH_VEC_ELT (references, i, ref)\n     {\n-      dr = create_data_ref (nest, loop_containing_stmt (stmt), ref->ref,\n+      dr = create_data_ref (nest ? loop_preheader_edge (nest) : NULL,\n+\t\t\t    loop_containing_stmt (stmt), ref->ref,\n \t\t\t    stmt, ref->is_read, ref->is_conditional_in_stmt);\n       gcc_assert (dr != NULL);\n       datarefs->safe_push (dr);\n@@ -4986,7 +4985,7 @@ find_data_references_in_stmt (struct loop *nest, gimple *stmt,\n    should be analyzed.  */\n \n bool\n-graphite_find_data_references_in_stmt (loop_p nest, loop_p loop, gimple *stmt,\n+graphite_find_data_references_in_stmt (edge nest, loop_p loop, gimple *stmt,\n \t\t\t\t       vec<data_reference_p> *datarefs)\n {\n   unsigned i;"}, {"sha": "d9d297ad9709ef6357c33079d2a656996206fad0", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -436,11 +436,11 @@ extern void free_data_ref (data_reference_p);\n extern void free_data_refs (vec<data_reference_p> );\n extern bool find_data_references_in_stmt (struct loop *, gimple *,\n \t\t\t\t\t  vec<data_reference_p> *);\n-extern bool graphite_find_data_references_in_stmt (loop_p, loop_p, gimple *,\n+extern bool graphite_find_data_references_in_stmt (edge, loop_p, gimple *,\n \t\t\t\t\t\t   vec<data_reference_p> *);\n tree find_data_references_in_loop (struct loop *, vec<data_reference_p> *);\n bool loop_nest_has_data_refs (loop_p loop);\n-struct data_reference *create_data_ref (loop_p, loop_p, tree, gimple *, bool,\n+struct data_reference *create_data_ref (edge, loop_p, tree, gimple *, bool,\n \t\t\t\t\tbool);\n extern bool find_loop_nest (struct loop *, vec<loop_p> *);\n extern struct data_dependence_relation *initialize_data_dependence_relation"}, {"sha": "b6c1fcef6a18790bca35b38e8a135b445770c7c4", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 74, "deletions": 213, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -2095,6 +2095,10 @@ analyze_scalar_evolution (struct loop *loop, tree var)\n {\n   tree res;\n \n+  /* ???  Fix callers.  */\n+  if (! loop)\n+    return var;\n+\n   if (dump_file && (dump_flags & TDF_SCEV))\n     {\n       fprintf (dump_file, \"(analyze_scalar_evolution \\n\");\n@@ -2271,7 +2275,7 @@ eq_idx_scev_info (const void *e1, const void *e2)\n \n static unsigned\n get_instantiated_value_entry (instantiate_cache_type &cache,\n-\t\t\t      tree name, basic_block instantiate_below)\n+\t\t\t      tree name, edge instantiate_below)\n {\n   if (!cache.map)\n     {\n@@ -2281,7 +2285,7 @@ get_instantiated_value_entry (instantiate_cache_type &cache,\n \n   scev_info_str e;\n   e.name_version = SSA_NAME_VERSION (name);\n-  e.instantiated_below = instantiate_below->index;\n+  e.instantiated_below = instantiate_below->dest->index;\n   void **slot = htab_find_slot_with_hash (cache.map, &e,\n \t\t\t\t\t  scev_info_hasher::hash (&e), INSERT);\n   if (!*slot)\n@@ -2325,7 +2329,7 @@ loop_closed_phi_def (tree var)\n   return NULL_TREE;\n }\n \n-static tree instantiate_scev_r (basic_block, struct loop *, struct loop *,\n+static tree instantiate_scev_r (edge, struct loop *, struct loop *,\n \t\t\t\ttree, bool *, int);\n \n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n@@ -2344,7 +2348,7 @@ static tree instantiate_scev_r (basic_block, struct loop *, struct loop *,\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n-instantiate_scev_name (basic_block instantiate_below,\n+instantiate_scev_name (edge instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *inner_loop,\n \t\t       tree chrec,\n \t\t       bool *fold_conversions,\n@@ -2358,7 +2362,7 @@ instantiate_scev_name (basic_block instantiate_below,\n      evolutions in outer loops), nothing to do.  */\n   if (!def_bb\n       || loop_depth (def_bb->loop_father) == 0\n-      || dominated_by_p (CDI_DOMINATORS, instantiate_below, def_bb))\n+      || ! dominated_by_p (CDI_DOMINATORS, def_bb, instantiate_below->dest))\n     return chrec;\n \n   /* We cache the value of instantiated variable to avoid exponential\n@@ -2380,6 +2384,51 @@ instantiate_scev_name (basic_block instantiate_below,\n \n   def_loop = find_common_loop (evolution_loop, def_bb->loop_father);\n \n+  if (! dominated_by_p (CDI_DOMINATORS,\n+\t\t\tdef_loop->header, instantiate_below->dest))\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (chrec);\n+      if (gassign *ass = dyn_cast <gassign *> (def))\n+\t{\n+\t  switch (gimple_assign_rhs_class (ass))\n+\t    {\n+\t    case GIMPLE_UNARY_RHS:\n+\t      {\n+\t\ttree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n+\t\t\t\t\t       inner_loop, gimple_assign_rhs1 (ass),\n+\t\t\t\t\t       fold_conversions, size_expr);\n+\t\tif (op0 == chrec_dont_know)\n+\t\t  return chrec_dont_know;\n+\t\tres = fold_build1 (gimple_assign_rhs_code (ass),\n+\t\t\t\t   TREE_TYPE (chrec), op0);\n+\t\tbreak;\n+\t      }\n+\t    case GIMPLE_BINARY_RHS:\n+\t      {\n+\t\ttree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n+\t\t\t\t\t       inner_loop, gimple_assign_rhs1 (ass),\n+\t\t\t\t\t       fold_conversions, size_expr);\n+\t\tif (op0 == chrec_dont_know)\n+\t\t  return chrec_dont_know;\n+\t\ttree op1 = instantiate_scev_r (instantiate_below, evolution_loop,\n+\t\t\t\t\t       inner_loop, gimple_assign_rhs2 (ass),\n+\t\t\t\t\t       fold_conversions, size_expr);\n+\t\tif (op1 == chrec_dont_know)\n+\t\t  return chrec_dont_know;\n+\t\tres = fold_build2 (gimple_assign_rhs_code (ass),\n+\t\t\t\t   TREE_TYPE (chrec), op0, op1);\n+\t\tbreak;\n+\t      }\n+\t    default:\n+\t      res = chrec_dont_know;\n+\t    }\n+\t}\n+      else\n+\tres = chrec_dont_know;\n+      global_cache->set (si, res);\n+      return res;\n+    }\n+\n   /* If the analysis yields a parametric chrec, instantiate the\n      result again.  */\n   res = analyze_scalar_evolution (def_loop, chrec);\n@@ -2411,8 +2460,9 @@ instantiate_scev_name (basic_block instantiate_below,\n \t\t\t\t    inner_loop, res,\n \t\t\t\t    fold_conversions, size_expr);\n \t}\n-      else if (!dominated_by_p (CDI_DOMINATORS, instantiate_below,\n-\t\t\t\tgimple_bb (SSA_NAME_DEF_STMT (res))))\n+      else if (dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\tgimple_bb (SSA_NAME_DEF_STMT (res)),\n+\t\t\t\tinstantiate_below->dest))\n \tres = chrec_dont_know;\n     }\n \n@@ -2450,7 +2500,7 @@ instantiate_scev_name (basic_block instantiate_below,\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n-instantiate_scev_poly (basic_block instantiate_below,\n+instantiate_scev_poly (edge instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *,\n \t\t       tree chrec, bool *fold_conversions, int size_expr)\n {\n@@ -2495,7 +2545,7 @@ instantiate_scev_poly (basic_block instantiate_below,\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n-instantiate_scev_binary (basic_block instantiate_below,\n+instantiate_scev_binary (edge instantiate_below,\n \t\t\t struct loop *evolution_loop, struct loop *inner_loop,\n \t\t\t tree chrec, enum tree_code code,\n \t\t\t tree type, tree c0, tree c1,\n@@ -2538,43 +2588,6 @@ instantiate_scev_binary (basic_block instantiate_below,\n   return chrec ? chrec : fold_build2 (code, type, c0, c1);\n }\n \n-/* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n-   and EVOLUTION_LOOP, that were left under a symbolic form.\n-\n-   \"CHREC\" is an array reference to be instantiated.\n-\n-   CACHE is the cache of already instantiated values.\n-\n-   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n-   conversions that may wrap in signed/pointer type are folded, as long\n-   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n-   then we don't do such fold.\n-\n-   SIZE_EXPR is used for computing the size of the expression to be\n-   instantiated, and to stop if it exceeds some limit.  */\n-\n-static tree\n-instantiate_array_ref (basic_block instantiate_below,\n-\t\t       struct loop *evolution_loop, struct loop *inner_loop,\n-\t\t       tree chrec, bool *fold_conversions, int size_expr)\n-{\n-  tree res;\n-  tree index = TREE_OPERAND (chrec, 1);\n-  tree op1 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t\t inner_loop, index,\n-\t\t\t\t fold_conversions, size_expr);\n-\n-  if (op1 == chrec_dont_know)\n-    return chrec_dont_know;\n-\n-  if (chrec && op1 == index)\n-    return chrec;\n-\n-  res = unshare_expr (chrec);\n-  TREE_OPERAND (res, 1) = op1;\n-  return res;\n-}\n-\n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n    and EVOLUTION_LOOP, that were left under a symbolic form.\n \n@@ -2592,7 +2605,7 @@ instantiate_array_ref (basic_block instantiate_below,\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n-instantiate_scev_convert (basic_block instantiate_below,\n+instantiate_scev_convert (edge instantiate_below,\n \t\t\t  struct loop *evolution_loop, struct loop *inner_loop,\n \t\t\t  tree chrec, tree type, tree op,\n \t\t\t  bool *fold_conversions, int size_expr)\n@@ -2643,7 +2656,7 @@ instantiate_scev_convert (basic_block instantiate_below,\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n-instantiate_scev_not (basic_block instantiate_below,\n+instantiate_scev_not (edge instantiate_below,\n \t\t      struct loop *evolution_loop, struct loop *inner_loop,\n \t\t      tree chrec,\n \t\t      enum tree_code code, tree type, tree op,\n@@ -2678,130 +2691,6 @@ instantiate_scev_not (basic_block instantiate_below,\n   return chrec ? chrec : fold_build1 (code, type, op0);\n }\n \n-/* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n-   and EVOLUTION_LOOP, that were left under a symbolic form.\n-\n-   CHREC is an expression with 3 operands to be instantiated.\n-\n-   CACHE is the cache of already instantiated values.\n-\n-   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n-   conversions that may wrap in signed/pointer type are folded, as long\n-   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n-   then we don't do such fold.\n-\n-   SIZE_EXPR is used for computing the size of the expression to be\n-   instantiated, and to stop if it exceeds some limit.  */\n-\n-static tree\n-instantiate_scev_3 (basic_block instantiate_below,\n-\t\t    struct loop *evolution_loop, struct loop *inner_loop,\n-\t\t    tree chrec,\n-\t\t    bool *fold_conversions, int size_expr)\n-{\n-  tree op1, op2;\n-  tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t\t inner_loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t fold_conversions, size_expr);\n-  if (op0 == chrec_dont_know)\n-    return chrec_dont_know;\n-\n-  op1 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t    inner_loop, TREE_OPERAND (chrec, 1),\n-\t\t\t    fold_conversions, size_expr);\n-  if (op1 == chrec_dont_know)\n-    return chrec_dont_know;\n-\n-  op2 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t    inner_loop, TREE_OPERAND (chrec, 2),\n-\t\t\t    fold_conversions, size_expr);\n-  if (op2 == chrec_dont_know)\n-    return chrec_dont_know;\n-\n-  if (op0 == TREE_OPERAND (chrec, 0)\n-      && op1 == TREE_OPERAND (chrec, 1)\n-      && op2 == TREE_OPERAND (chrec, 2))\n-    return chrec;\n-\n-  return fold_build3 (TREE_CODE (chrec),\n-\t\t      TREE_TYPE (chrec), op0, op1, op2);\n-}\n-\n-/* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n-   and EVOLUTION_LOOP, that were left under a symbolic form.\n-\n-   CHREC is an expression with 2 operands to be instantiated.\n-\n-   CACHE is the cache of already instantiated values.\n-\n-   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n-   conversions that may wrap in signed/pointer type are folded, as long\n-   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n-   then we don't do such fold.\n-\n-   SIZE_EXPR is used for computing the size of the expression to be\n-   instantiated, and to stop if it exceeds some limit.  */\n-\n-static tree\n-instantiate_scev_2 (basic_block instantiate_below,\n-\t\t    struct loop *evolution_loop, struct loop *inner_loop,\n-\t\t    tree chrec,\n-\t\t    bool *fold_conversions, int size_expr)\n-{\n-  tree op1;\n-  tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t\t inner_loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t fold_conversions, size_expr);\n-  if (op0 == chrec_dont_know)\n-    return chrec_dont_know;\n-\n-  op1 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t    inner_loop, TREE_OPERAND (chrec, 1),\n-\t\t\t    fold_conversions, size_expr);\n-  if (op1 == chrec_dont_know)\n-    return chrec_dont_know;\n-\n-  if (op0 == TREE_OPERAND (chrec, 0)\n-      && op1 == TREE_OPERAND (chrec, 1))\n-    return chrec;\n-\n-  return fold_build2 (TREE_CODE (chrec), TREE_TYPE (chrec), op0, op1);\n-}\n-\n-/* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n-   and EVOLUTION_LOOP, that were left under a symbolic form.\n-\n-   CHREC is an expression with 2 operands to be instantiated.\n-\n-   CACHE is the cache of already instantiated values.\n-\n-   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n-   conversions that may wrap in signed/pointer type are folded, as long\n-   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n-   then we don't do such fold.\n-\n-   SIZE_EXPR is used for computing the size of the expression to be\n-   instantiated, and to stop if it exceeds some limit.  */\n-\n-static tree\n-instantiate_scev_1 (basic_block instantiate_below,\n-\t\t    struct loop *evolution_loop, struct loop *inner_loop,\n-\t\t    tree chrec,\n-\t\t    bool *fold_conversions, int size_expr)\n-{\n-  tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t\t inner_loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t fold_conversions, size_expr);\n-\n-  if (op0 == chrec_dont_know)\n-    return chrec_dont_know;\n-\n-  if (op0 == TREE_OPERAND (chrec, 0))\n-    return chrec;\n-\n-  return fold_build1 (TREE_CODE (chrec), TREE_TYPE (chrec), op0);\n-}\n-\n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n    and EVOLUTION_LOOP, that were left under a symbolic form.\n \n@@ -2818,7 +2707,7 @@ instantiate_scev_1 (basic_block instantiate_below,\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n-instantiate_scev_r (basic_block instantiate_below,\n+instantiate_scev_r (edge instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n \t\t    bool *fold_conversions, int size_expr)\n@@ -2870,50 +2759,20 @@ instantiate_scev_r (basic_block instantiate_below,\n \t\t\t\t   fold_conversions, size_expr);\n \n     case ADDR_EXPR:\n+      if (is_gimple_min_invariant (chrec))\n+\treturn chrec;\n+      /* Fallthru.  */\n     case SCEV_NOT_KNOWN:\n       return chrec_dont_know;\n \n     case SCEV_KNOWN:\n       return chrec_known;\n \n-    case ARRAY_REF:\n-      return instantiate_array_ref (instantiate_below, evolution_loop,\n-\t\t\t\t    inner_loop, chrec,\n-\t\t\t\t    fold_conversions, size_expr);\n-\n     default:\n-      break;\n-    }\n-\n-  if (VL_EXP_CLASS_P (chrec))\n-    return chrec_dont_know;\n-\n-  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n-    {\n-    case 3:\n-      return instantiate_scev_3 (instantiate_below, evolution_loop,\n-\t\t\t\t inner_loop, chrec,\n-\t\t\t\t fold_conversions, size_expr);\n-\n-    case 2:\n-      return instantiate_scev_2 (instantiate_below, evolution_loop,\n-\t\t\t\t inner_loop, chrec,\n-\t\t\t\t fold_conversions, size_expr);\n-\n-    case 1:\n-      return instantiate_scev_1 (instantiate_below, evolution_loop,\n-\t\t\t\t inner_loop, chrec,\n-\t\t\t\t fold_conversions, size_expr);\n-\n-    case 0:\n-      return chrec;\n-\n-    default:\n-      break;\n+      if (CONSTANT_CLASS_P (chrec))\n+\treturn chrec;\n+      return chrec_dont_know;\n     }\n-\n-  /* Too complicated to handle.  */\n-  return chrec_dont_know;\n }\n \n /* Analyze all the parameters of the chrec that were left under a\n@@ -2923,16 +2782,18 @@ instantiate_scev_r (basic_block instantiate_below,\n    a function parameter.  */\n \n tree\n-instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,\n+instantiate_scev (edge instantiate_below, struct loop *evolution_loop,\n \t\t  tree chrec)\n {\n   tree res;\n \n   if (dump_file && (dump_flags & TDF_SCEV))\n     {\n       fprintf (dump_file, \"(instantiate_scev \\n\");\n-      fprintf (dump_file, \"  (instantiate_below = %d)\\n\", instantiate_below->index);\n-      fprintf (dump_file, \"  (evolution_loop = %d)\\n\", evolution_loop->num);\n+      fprintf (dump_file, \"  (instantiate_below = %d -> %d)\\n\",\n+\t       instantiate_below->src->index, instantiate_below->dest->index);\n+      if (evolution_loop)\n+\tfprintf (dump_file, \"  (evolution_loop = %d)\\n\", evolution_loop->num);\n       fprintf (dump_file, \"  (chrec = \");\n       print_generic_expr (dump_file, chrec);\n       fprintf (dump_file, \")\\n\");\n@@ -2980,7 +2841,7 @@ resolve_mixers (struct loop *loop, tree chrec, bool *folded_casts)\n       destr = true;\n     }\n \n-  tree ret = instantiate_scev_r (block_before_loop (loop), loop, NULL,\n+  tree ret = instantiate_scev_r (loop_preheader_edge (loop), loop, NULL,\n \t\t\t\t chrec, &fold_conversions, 0);\n \n   if (folded_casts && !*folded_casts)"}, {"sha": "55b8ca49faea465706bf938d600a47fbf3756e01", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -30,7 +30,7 @@ extern void scev_reset (void);\n extern void scev_reset_htab (void);\n extern void scev_finalize (void);\n extern tree analyze_scalar_evolution (struct loop *, tree);\n-extern tree instantiate_scev (basic_block, struct loop *, tree);\n+extern tree instantiate_scev (edge, struct loop *, tree);\n extern tree resolve_mixers (struct loop *, tree, bool *);\n extern void gather_stats_on_scev_database (void);\n extern void final_value_replacement_loop (struct loop *);\n@@ -60,7 +60,7 @@ block_before_loop (loop_p loop)\n static inline tree\n instantiate_parameters (struct loop *loop, tree chrec)\n {\n-  return instantiate_scev (block_before_loop (loop), loop, chrec);\n+  return instantiate_scev (loop_preheader_edge (loop), loop, chrec);\n }\n \n /* Returns the loop of the polynomial chrec CHREC.  */"}, {"sha": "67767e1516a67e6f20aded15042df56fbe524b45", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68f286ccc36bc6d5e483383e490e2531307466b/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=a68f286ccc36bc6d5e483383e490e2531307466b", "patch": "@@ -1632,7 +1632,8 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n   for (gr = refs; gr; gr = gr->next)\n     for (ref = gr->refs; ref; ref = ref->next)\n       {\n-\tdr = create_data_ref (nest, loop_containing_stmt (ref->stmt),\n+\tdr = create_data_ref (loop_preheader_edge (nest),\n+\t\t\t      loop_containing_stmt (ref->stmt),\n \t\t\t      ref->mem, ref->stmt, !ref->write_p, false);\n \n \tif (dr)"}]}