{"sha": "0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ2MDE0ZmFkN2EyNmJhNGNiZmMyN2FjYWEzZWM5NzdjNDU3YzBhZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:19:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:19:26Z"}, "message": "[multiple changes]\n\n2016-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* layout.adb: Fix more minor typos in comments.\n\n2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-calend.ads, sem_prag.adb, sem_ch6.adb: Minor reformatting.\n\nFrom-SVN: r235114", "tree": {"sha": "6563c39bfd0a0998adad070ca6b35739fd3e9cc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6563c39bfd0a0998adad070ca6b35739fd3e9cc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/comments", "author": null, "committer": null, "parents": [{"sha": "539ca5ec98443a3140523337f1dc131fd709f17a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539ca5ec98443a3140523337f1dc131fd709f17a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539ca5ec98443a3140523337f1dc131fd709f17a"}], "stats": {"total": 274, "additions": 147, "deletions": 127}, "files": [{"sha": "e59b0672df3ed9d616ef467309d15e514b5dc01a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "patch": "@@ -1,3 +1,11 @@\n+2016-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* layout.adb: Fix more minor typos in comments.\n+\n+2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-calend.ads, sem_prag.adb, sem_ch6.adb: Minor reformatting.\n+\n 2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): In GNATprove"}, {"sha": "d7651037c797197de25c0037bbb3b164eb3debc1", "filename": "gcc/ada/a-calend.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "patch": "@@ -115,8 +115,9 @@ is\n    Time_Error : exception;\n \n private\n-   --  Mark private part as SPARK_Mode Off to avoid accounting for variable\n+   --  Mark the private part as SPARK_Mode Off to avoid accounting for variable\n    --  Invalid_Time_Zone_Offset in abstract state.\n+\n    pragma SPARK_Mode (Off);\n \n    pragma Inline (Clock);"}, {"sha": "97c653c0f0d89ceac346fa25912f11ce4a6513db", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "patch": "@@ -3247,7 +3247,7 @@ package body Layout is\n             A := 2 * A;\n          end loop;\n \n-         --  If alignment is currently not set, then we can safetly set it to\n+         --  If alignment is currently not set, then we can safely set it to\n          --  this new calculated value.\n \n          if Unknown_Alignment (E) then\n@@ -3256,7 +3256,7 @@ package body Layout is\n          --  Cases where we have inherited an alignment\n \n          --  For constructed types, always reset the alignment, these are\n-         --  Generally invisible to the user anyway, and that way we are\n+         --  generally invisible to the user anyway, and that way we are\n          --  sure that no constructed types have weird alignments.\n \n          elsif not Comes_From_Source (E) then\n@@ -3282,23 +3282,23 @@ package body Layout is\n \n             --  It seems quite bogus in this case to inherit an alignment of 1\n             --  from the parent type Character. Furthermore, if that's what the\n-            --  programmer really wanted for some odd reason, then they could\n-            --  specify the alignment they wanted.\n+            --  programmer really wanted for some odd reason, then he could\n+            --  specify the alignment directly.\n \n             --  Furthermore we really don't want to inherit the alignment in\n             --  the case of a specified Object_Size for a subtype, since then\n             --  there would be no way of overriding to give a reasonable value\n             --  (we don't have an Object_Subtype attribute). Consider:\n \n-            --    subtype R is new Character;\n+            --    subtype R is Character;\n             --    for R'Object_Size use 16;\n \n-            --  If we inherit the alignment of 1, then we have an odd\n-            --  inefficient alignment for the subtype, which cannot be fixed.\n+            --  If we inherit the alignment of 1, then we have an inefficient\n+            --  alignment for the subtype, which cannot be fixed.\n \n             --  So we make the decision that if Size (or Object_Size) is given\n             --  (and, in the case of a first subtype, the alignment is not set\n-            --  with a specific alignment clause). We reset the alignment to\n+            --  with a specific alignment clause), we reset the alignment to\n             --  the appropriate value for the specified size. This is a nice\n             --  simple rule to implement and document.\n \n@@ -3311,15 +3311,15 @@ package body Layout is\n             --    type S is new R;\n             --    for S'Size use Character'Size;\n \n-            --  Now the alignment of S is 1 instead of 2, as a result of\n-            --  applying the above rule to the confirming rep clause for S. Not\n-            --  clear this is worth worrying about. If we recorded whether a\n-            --  size clause was confirming we could avoid this, but right now\n+            --  Now the alignment of S is changed to 1 instead of 2 as a result\n+            --  of applying the above rule to the confirming rep clause for S.\n+            --  Not clear this is worth worrying about. If we recorded whether\n+            --  a size clause was confirming we could avoid this, but right now\n             --  we have no way of doing that or easily figuring it out, so we\n             --  don't bother.\n \n-            --  Historical note. In versions of GNAT prior to Nov 6th, 2011, an\n-            --  odd distinction was made between inherited alignments greater\n+            --  Historical note: in versions of GNAT prior to Nov 6th, 2011, an\n+            --  odd distinction was made between inherited alignments larger\n             --  than the computed alignment (where the larger alignment was\n             --  inherited) and inherited alignments smaller than the computed\n             --  alignment (where the smaller alignment was overridden). This\n@@ -3337,7 +3337,7 @@ package body Layout is\n          --    for R'Alignment use 1;\n          --    subtype S is R;\n \n-         --  Here we have R has a default Object_Size of 32, and a specified\n+         --  Here we have R with a default Object_Size of 32, and a specified\n          --  alignment of 1, and it seeems right for S to inherit both values.\n \n          else"}, {"sha": "437ca14195425a4c85934fe2748c218dc5bee60a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "patch": "@@ -3754,9 +3754,9 @@ package body Sem_Ch6 is\n          Build_Body_To_Inline (N, Spec_Id);\n       end if;\n \n-      --  When generating code, inherited pre/postconditions are handled\n-      --  when expanding the corresponding contract. If GNATprove mode we\n-      --  must process them when the body is analyzed.\n+      --  When generating code, inherited pre/postconditions are handled when\n+      --  expanding the corresponding contract. In GNATprove the annotations\n+      --  must be processed when the body is analyzed.\n \n       if GNATprove_Mode\n         and then Present (Spec_Id)"}, {"sha": "46a30390c8624925851edf402365a5c8fcbbfcb4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 119, "deletions": 108, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0d6014fad7a26ba4cbfc27acaa3ec977c457c0ae", "patch": "@@ -23198,8 +23198,8 @@ package body Sem_Prag is\n \n       if Class_Present (N) then\n \n-         --  Verify that a class-wide condition is legal, i.e. the operation\n-         --  is a primitive of a tagged type.\n+         --  Verify that a class-wide condition is legal, i.e. the operation is\n+         --  a primitive of a tagged type.\n \n          Disp_Typ := Find_Dispatching_Type (Spec_Id);\n \n@@ -26045,61 +26045,32 @@ package body Sem_Prag is\n       Subp_Id  : Entity_Id := Empty;\n       Inher_Id : Entity_Id := Empty) return Node_Id\n    is\n+      Map : Elist_Id;\n+      --  List containing the following mappings\n+      --    * Formal parameters of inherited subprogram Inher_Id and subprogram\n+      --    Subp_Id.\n+      --\n+      --    * The dispatching type of Inher_Id and the dispatching type of\n+      --    Subp_Id.\n+      --\n+      --    * Primitives of the dispatching type of Inher_Id and primitives of\n+      --    the dispatching type of Subp_Id.\n+\n+      function Replace_Entity (N : Node_Id) return Traverse_Result;\n+      --  Replace reference to formal of inherited operation or to primitive\n+      --  operation of root type, with corresponding entity for derived type.\n+\n       function Suppress_Reference (N : Node_Id) return Traverse_Result;\n       --  Detect whether node N references a formal parameter subject to\n       --  pragma Unreferenced. If this is the case, set Comes_From_Source\n       --  to False to suppress the generation of a reference when analyzing\n       --  N later on.\n \n-      ------------------------\n-      -- Suppress_Reference --\n-      ------------------------\n-\n-      function Suppress_Reference (N : Node_Id) return Traverse_Result is\n-         Formal : Entity_Id;\n-\n-      begin\n-         if Is_Entity_Name (N) and then Present (Entity (N)) then\n-            Formal := Entity (N);\n-\n-            --  The formal parameter is subject to pragma Unreferenced.\n-            --  Prevent the generation of a reference by resetting the\n-            --  Comes_From_Source flag.\n-\n-            if Is_Formal (Formal)\n-              and then Has_Pragma_Unreferenced (Formal)\n-            then\n-               Set_Comes_From_Source (N, False);\n-            end if;\n-         end if;\n-\n-         return OK;\n-      end Suppress_Reference;\n-\n-      procedure Suppress_References is\n-        new Traverse_Proc (Suppress_Reference);\n-\n-      --  Local variables\n-\n-      Loc          : constant Source_Ptr := Sloc (Prag);\n-      Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n-      Check_Prag   : Node_Id;\n-      Formals_Map  : Elist_Id;\n-      Inher_Formal : Entity_Id;\n-      Msg_Arg      : Node_Id;\n-      Nam          : Name_Id;\n-      Subp_Formal  : Entity_Id;\n-\n-      function Replace_Entity (N : Node_Id) return Traverse_Result;\n-      --  Replace reference to formal of inherited operation or to primitive\n-      --  operation of root type, with corresponding entity for derived type.\n-\n       --------------------\n       -- Replace_Entity --\n       --------------------\n \n-      function Replace_Entity (N : Node_Id) return Traverse_Result\n-      is\n+      function Replace_Entity (N : Node_Id) return Traverse_Result is\n          Elmt  : Elmt_Id;\n          New_E : Entity_Id;\n \n@@ -26112,9 +26083,9 @@ package body Sem_Prag is\n              (Nkind (Parent (N)) /= N_Attribute_Reference\n                or else Attribute_Name (Parent (N)) /= Name_Class)\n          then\n-            --  The replacement does not apply to dispatching calls within\n-            --  the condition, but only to calls whose static tag is that\n-            --  of the parent type.\n+            --  The replacement does not apply to dispatching calls within the\n+            --  condition, but only to calls whose static tag is that of the\n+            --  parent type.\n \n             if Is_Subprogram (Entity (N))\n               and then Nkind (Parent (N)) = N_Function_Call\n@@ -26126,7 +26097,7 @@ package body Sem_Prag is\n             --  Loop to find out if entity has a renaming\n \n             New_E := Empty;\n-            Elmt := First_Elmt (Formals_Map);\n+            Elmt  := First_Elmt (Map);\n             while Present (Elmt) loop\n                if Node (Elmt) = Entity (N) then\n                   New_E := Node (Next_Elmt (Elmt));\n@@ -26142,7 +26113,7 @@ package body Sem_Prag is\n          end if;\n \n          if not Is_Abstract_Subprogram (Inher_Id)\n-           and then  Nkind (N) = N_Function_Call\n+           and then Nkind (N) = N_Function_Call\n            and then Present (Entity (Name (N)))\n            and then Is_Abstract_Subprogram (Entity (Name (N)))\n          then\n@@ -26157,114 +26128,154 @@ package body Sem_Prag is\n          return OK;\n       end Replace_Entity;\n \n+      ------------------------\n+      -- Suppress_Reference --\n+      ------------------------\n+\n+      function Suppress_Reference (N : Node_Id) return Traverse_Result is\n+         Formal : Entity_Id;\n+\n+      begin\n+         if Is_Entity_Name (N) and then Present (Entity (N)) then\n+            Formal := Entity (N);\n+\n+            --  The formal parameter is subject to pragma Unreferenced.\n+            --  Prevent the generation of a reference by resetting the\n+            --  Comes_From_Source flag.\n+\n+            if Is_Formal (Formal)\n+              and then Has_Pragma_Unreferenced (Formal)\n+            then\n+               Set_Comes_From_Source (N, False);\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Suppress_Reference;\n+\n       procedure Replace_Condition_Entities is\n         new Traverse_Proc (Replace_Entity);\n \n+      procedure Suppress_References is\n+        new Traverse_Proc (Suppress_Reference);\n+\n+      --  Local variables\n+\n+      Loc          : constant Source_Ptr := Sloc (Prag);\n+      Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n+      Check_Prag   : Node_Id;\n+      Inher_Formal : Entity_Id;\n+      Msg_Arg      : Node_Id;\n+      Nam          : Name_Id;\n+      Subp_Formal  : Entity_Id;\n+\n    --  Start of processing for Build_Pragma_Check_Equivalent\n \n    begin\n-      Formals_Map := No_Elist;\n+      Map := No_Elist;\n \n-      --  When the pre- or postcondition is inherited, map the formals of\n-      --  the inherited subprogram to those of the current subprogram.\n-      --  In addition, map primitive operations of the parent type into the\n-      --  corresponding primitive operations of the descendant.\n+      --  When the pre- or postcondition is inherited, map the formals of the\n+      --  inherited subprogram to those of the current subprogram. In addition,\n+      --  map primitive operations of the parent type into the corresponding\n+      --  primitive operations of the descendant.\n \n       if Present (Inher_Id) then\n          pragma Assert (Present (Subp_Id));\n \n-         Formals_Map := New_Elmt_List;\n+         Map := New_Elmt_List;\n \n          --  Create a mapping  <inherited formal> => <subprogram formal>\n \n          Inher_Formal := First_Formal (Inher_Id);\n          Subp_Formal  := First_Formal (Subp_Id);\n          while Present (Inher_Formal) and then Present (Subp_Formal) loop\n-            Append_Elmt (Inher_Formal, Formals_Map);\n-            Append_Elmt (Subp_Formal, Formals_Map);\n+            Append_Elmt (Inher_Formal, Map);\n+            Append_Elmt (Subp_Formal,  Map);\n \n             Next_Formal (Inher_Formal);\n             Next_Formal (Subp_Formal);\n          end loop;\n \n-      --  Map primitive operations of the parent type into the corresponding\n-      --  operations of the descendant. The descendant type might not be\n-      --  frozen yet, so we cannot use the dispatch table directly.\n+         --  Map primitive operations of the parent type to the corresponding\n+         --  operations of the descendant. Note that the descendant type may\n+         --  not be frozen yet, so we cannot use the dispatch table directly.\n \n          declare\n-            T     : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n-            Old_T : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n-            D     : Node_Id;\n-            E     : Entity_Id;\n-            Old_E : Entity_Id;\n+            Old_Typ  : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n+            Typ      : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n+            Decl     : Node_Id;\n+            Old_Prim : Entity_Id;\n+            Prim     : Entity_Id;\n \n          begin\n-            D := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n+            Decl := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n \n             --  Look for primitive operations of the current type that have\n             --  overridden an operation of the type related to the original\n             --  class-wide precondition. There may be several intermediate\n             --  overridings between them.\n \n-            while Present (D) loop\n-               if Nkind (D) = N_Subprogram_Declaration then\n-                  E := Defining_Entity (D);\n-                  if Is_Subprogram (E)\n-                    and then Present (Overridden_Operation (E))\n-                    and then Find_Dispatching_Type (E) = T\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Subprogram_Declaration then\n+                  Prim := Defining_Entity (Decl);\n+\n+                  if Is_Subprogram (Prim)\n+                    and then Present (Overridden_Operation (Prim))\n+                    and then Find_Dispatching_Type (Prim) = Typ\n                   then\n-                     Old_E := Overridden_Operation (E);\n-                     while Present (Overridden_Operation (Old_E))\n-                       and then Scope (Old_E) /= Scope (Inher_Id)\n+                     Old_Prim := Overridden_Operation (Prim);\n+                     while Present (Overridden_Operation (Old_Prim))\n+                       and then Scope (Old_Prim) /= Scope (Inher_Id)\n                      loop\n-                        Old_E := Overridden_Operation (Old_E);\n+                        Old_Prim := Overridden_Operation (Old_Prim);\n                      end loop;\n \n-                     Append_Elmt (Old_E, Formals_Map);\n-                     Append_Elmt (E, Formals_Map);\n+                     Append_Elmt (Old_Prim, Map);\n+                     Append_Elmt (Prim,     Map);\n                   end if;\n                end if;\n \n-               Next (D);\n+               Next (Decl);\n             end loop;\n \n-            E := First_Entity (Scope (Subp_Id));\n-            while Present (E) loop\n-               if not Comes_From_Source (E)\n-                 and then Ekind (E) = E_Function\n-                 and then Present (Alias (E))\n+            Prim := First_Entity (Scope (Subp_Id));\n+            while Present (Prim) loop\n+               if not Comes_From_Source (Prim)\n+                 and then Ekind (Prim) = E_Function\n+                 and then Present (Alias (Prim))\n                then\n-                  Old_E := Alias (E);\n-                  while Present (Alias (Old_E))\n-                    and then Scope (Old_E) /= Scope (Inher_Id)\n+                  Old_Prim := Alias (Prim);\n+                  while Present (Alias (Old_Prim))\n+                    and then Scope (Old_Prim) /= Scope (Inher_Id)\n                   loop\n-                     Old_E := Alias (Old_E);\n+                     Old_Prim := Alias (Old_Prim);\n                   end loop;\n \n-                  Append_Elmt (Old_E, Formals_Map);\n-                  Append_Elmt (E, Formals_Map);\n+                  Append_Elmt (Old_Prim, Map);\n+                  Append_Elmt (Prim,     Map);\n                end if;\n-               Next_Entity (E);\n+\n+               Next_Entity (Prim);\n             end loop;\n \n-            if Formals_Map /= No_Elist then\n-               Append_Elmt (Old_T, Formals_Map);\n-               Append_Elmt (T, Formals_Map);\n+            if Map /= No_Elist then\n+               Append_Elmt (Old_Typ, Map);\n+               Append_Elmt (Typ,     Map);\n             end if;\n          end;\n       end if;\n \n       --  Copy the original pragma while performing substitutions (if\n       --  applicable).\n \n-      Check_Prag := New_Copy_Tree (Source    => Prag);\n+      Check_Prag := New_Copy_Tree (Source => Prag);\n \n-      if Formals_Map /= No_Elist then\n+      if Map /= No_Elist then\n          Replace_Condition_Entities (Check_Prag);\n       end if;\n \n-      --  Mark the pragma as being internally generated and reset the\n-      --  Analyzed flag.\n+      --  Mark the pragma as being internally generated and reset the Analyzed\n+      --  flag.\n \n       Set_Analyzed          (Check_Prag, False);\n       Set_Comes_From_Source (Check_Prag, False);\n@@ -26294,8 +26305,8 @@ package body Sem_Prag is\n          Nam := Prag_Nam;\n       end if;\n \n-      --  Convert the copy into pragma Check by correcting the name and\n-      --  adding a check_kind argument.\n+      --  Convert the copy into pragma Check by correcting the name and adding\n+      --  a check_kind argument.\n \n       Set_Pragma_Identifier\n         (Check_Prag, Make_Identifier (Loc, Name_Check));\n@@ -26795,7 +26806,7 @@ package body Sem_Prag is\n       Bod  : Node_Id)\n    is\n       Parent_Subp : constant Entity_Id := Overridden_Operation (Subp);\n-      Prags       : constant Node_Id := Contract (Parent_Subp);\n+      Prags       : constant Node_Id   := Contract (Parent_Subp);\n       Prag        : Node_Id;\n \n    begin\n@@ -26806,15 +26817,15 @@ package body Sem_Prag is\n          Prag := Pre_Post_Conditions (Prags);\n \n          while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Precondition\n-              or else Pragma_Name (Prag) = Name_Postcondition\n+            if Nam_In (Pragma_Name (Prag), Name_Precondition,\n+                                           Name_Postcondition)\n             then\n                if No (Declarations (Bod)) then\n                   Set_Declarations (Bod, Empty_List);\n                end if;\n \n-               Append (Build_Pragma_Check_Equivalent (Prag, Subp, Parent_Subp),\n-                 To => Declarations (Bod));\n+               Append_To (Declarations (Bod),\n+                 Build_Pragma_Check_Equivalent (Prag, Subp, Parent_Subp));\n             end if;\n \n             Prag := Next_Pragma (Prag);"}]}