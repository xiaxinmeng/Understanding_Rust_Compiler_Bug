{"sha": "632469d01e0652c465f9074d2ec7f5de1cb7dac9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMyNDY5ZDAxZTA2NTJjNDY1ZjkwNzRkMmVjN2Y1ZGUxY2I3ZGFjOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-01-14T01:21:51Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-01-14T01:21:51Z"}, "message": "[multiple changes]\n\n2011-01-13  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* testsuite/25_algorithms/is_permutation/check_type.cc: New.\n\t* testsuite/25_algorithms/is_permutation/requirements/\n\texplicit_instantiation/2.cc: Likewise.\n\t* testsuite/25_algorithms/is_permutation/requirements/\n\texplicit_instantiation/pod.cc: Likewise.\n\t* testsuite/25_algorithms/is_permutation/1.cc: Likewise.\n\n2011-01-13  John Lakos  <jlakos@bloomberg.net>\n\t    Pablo Halpern  <phalpern@halpernwightsoftware.com>\n\t    Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/bits/stl_algo.h (is_permutation): Add, per N3068.\n\t* include/bits/algorithmfwd.h: Add.\n\nFrom-SVN: r168773", "tree": {"sha": "8bf9761158c981a039a27f0283dd87949cc696bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bf9761158c981a039a27f0283dd87949cc696bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/632469d01e0652c465f9074d2ec7f5de1cb7dac9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/632469d01e0652c465f9074d2ec7f5de1cb7dac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/632469d01e0652c465f9074d2ec7f5de1cb7dac9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/632469d01e0652c465f9074d2ec7f5de1cb7dac9/comments", "author": null, "committer": null, "parents": [{"sha": "57d5062695245b0fa88920efb3df798242b19aaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d5062695245b0fa88920efb3df798242b19aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d5062695245b0fa88920efb3df798242b19aaf"}], "stats": {"total": 359, "additions": 356, "deletions": 3}, "files": [{"sha": "33c7f73ab17224c15b23948e32ce46055111766f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=632469d01e0652c465f9074d2ec7f5de1cb7dac9", "patch": "@@ -1,3 +1,19 @@\n+2011-01-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* testsuite/25_algorithms/is_permutation/check_type.cc: New.\n+\t* testsuite/25_algorithms/is_permutation/requirements/\n+\texplicit_instantiation/2.cc: Likewise.\n+\t* testsuite/25_algorithms/is_permutation/requirements/\n+\texplicit_instantiation/pod.cc: Likewise.\n+\t* testsuite/25_algorithms/is_permutation/1.cc: Likewise.\n+\n+2011-01-13  John Lakos  <jlakos@bloomberg.net>\n+\t    Pablo Halpern  <phalpern@halpernwightsoftware.com>\n+\t    Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/bits/stl_algo.h (is_permutation): Add, per N3068.\n+\t* include/bits/algorithmfwd.h: Add.\n+\n 2011-01-13  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/47045"}, {"sha": "fd5dbb211e169cf2d342e61b6727fcd5fb6d7584", "filename": "libstdc++-v3/include/bits/algorithmfwd.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h?ref=632469d01e0652c465f9074d2ec7f5de1cb7dac9", "patch": "@@ -1,6 +1,6 @@\n // <algorithm> declarations  -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -301,6 +301,15 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     bool\n     is_partitioned(_IIter, _IIter, _Predicate);\n \n+  template<typename _FIter1, typename _FIter2>\n+    bool\n+    is_permutation(_FIter1, _FIter1, _FIter2);\n+\n+  template<typename _FIter1, typename _FIter2,\n+\t   typename _BinaryPredicate>\n+    bool\n+    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);\n+\n   template<typename _FIter>\n     bool \n     is_sorted(_FIter, _FIter);"}, {"sha": "c55c44ff2d0a2e522fda0f6fd7430d13435c08bc", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=632469d01e0652c465f9074d2ec7f5de1cb7dac9", "patch": "@@ -1,6 +1,7 @@\n // Algorithm implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+// 2010, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -63,7 +64,8 @@\n #include <bits/stl_tempbuf.h>  // for _Temporary_buffer\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#include <random> // for std::uniform_int_distribution\n+#include <random>     // for std::uniform_int_distribution\n+#include <functional> // for std::bind\n #endif\n \n // See concept_check.h for the __glibcxx_*_requires macros.\n@@ -4109,6 +4111,99 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return std::make_pair(*__p.first, *__p.second);\n     }\n \n+  /**\n+   *  @brief  Checks whether a permutaion of the second sequence is equal\n+   *          to the first sequence.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @return true if there exists a permutation of the elements in the range\n+   *          [first2, first2 + (last1 - first1)), beginning with \n+   *          ForwardIterator2 begin, such that equal(first1, last1, begin)\n+   *          returns true; otherwise, returns false.\n+  */\n+  template<typename _ForwardIterator1, typename _ForwardIterator2>\n+    bool\n+    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+\t\t   _ForwardIterator2 __first2)\n+    {\n+      // Efficiently compare identical prefixes:  O(N) if sequences\n+      // have the same elements in the same order.\n+      for (; __first1 != __last1; ++__first1, ++__first2)\n+\tif (!(*__first1 == *__first2))\n+\t  break;\n+\n+      if (__first1 == __last1)\n+\treturn true;\n+\n+      // Establish __last2 assuming equal ranges by iterating over the\n+      // rest of the list.\n+      _ForwardIterator2 __last2 = __first2;\n+      std::advance(__last2, std::distance(__first1, __last1));\n+      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)\n+\t{\n+\t  if (__scan != _GLIBCXX_STD_P::find(__first1, __scan, *__scan))\n+\t    continue; // We've seen this one before.\n+\n+\t  auto __matches = std::count(__first2, __last2, *__scan);\n+\t  if (0 == __matches\n+\t      || std::count(__scan, __last1, *__scan) != __matches)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  /**\n+   *  @brief  Checks whether a permutation of the second sequence is equal\n+   *          to the first sequence.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  pred    A binary predicate.\n+   *  @return true if there exists a permutation of the elements in the range\n+   *          [first2, first2 + (last1 - first1)), beginning with \n+   *          ForwardIterator2 begin, such that equal(first1, last1, begin,\n+   *          pred) returns true; otherwise, returns false.\n+  */\n+  template<typename _ForwardIterator1, typename _ForwardIterator2,\n+\t   typename _BinaryPredicate>\n+    bool\n+    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+\t\t   _ForwardIterator2 __first2, _BinaryPredicate __pred)\n+    {\n+      // Efficiently compare identical prefixes:  O(N) if sequences\n+      // have the same elements in the same order.\n+      for (; __first1 != __last1; ++__first1, ++__first2)\n+\tif (!bool(__pred(*__first1, *__first2)))\n+\t  break;\n+\n+      if (__first1 == __last1)\n+\treturn true;\n+\n+      // Establish __last2 assuming equal ranges by iterating over the\n+      // rest of the list.\n+      _ForwardIterator2 __last2 = __first2;\n+      std::advance(__last2, std::distance(__first1, __last1));\n+      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)\n+\t{\n+\t  using std::placeholders::_1;\n+\n+\t  if (__scan != _GLIBCXX_STD_P::find_if(__first1, __scan,\n+\t\t\t\t\t\tstd::bind(__pred, _1, *__scan)))\n+\t    continue; // We've seen this one before.\n+\t  \n+\t  auto __matches = std::count_if(__first2, __last2,\n+\t\t\t\t\t std::bind(__pred, _1, *__scan));\n+\t  if (0 == __matches\n+\t      || std::count_if(__scan, __last1,\n+\t\t\t       std::bind(__pred, _1, *__scan)) != __matches)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n   /**\n    *  @brief Shuffle the elements of a sequence using a uniform random"}, {"sha": "264cb13b92cab6dfc421407bb9ae70993403a529", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/1.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2F1.cc?ref=632469d01e0652c465f9074d2ec7f5de1cb7dac9", "patch": "@@ -0,0 +1,104 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2011-01-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.12 [alg.is_permutation] Is permutation\n+\n+#include <algorithm>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct my_equal_to\n+{\n+  bool\n+  operator()(int __x, int __y) const\n+  { return __x % 10 == __y % 10; }\n+};\n+\n+const int arr0[] = { 11, 22, 33, 44, 55 };\n+\n+void\n+do_test(int arr1[5], bool np = true)\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  do\n+    VERIFY( std::is_permutation(arr1, arr1 + 5, arr0) == np );\n+  while (std::next_permutation(arr1, arr1 + 5));\n+}\n+\n+template<typename Predicate>\n+  void\n+  do_test(int arr1[5], Predicate pred, bool np = true)\n+  {\n+    bool test __attribute__((unused)) = true;\n+\n+    do\n+      VERIFY( std::is_permutation(arr1, arr1 + 5, arr0, pred) == np );\n+    while (std::next_permutation(arr1, arr1 + 5));\n+  }\n+\n+void test01()\n+{\n+  int arr1[] = { 11, 22, 33, 44, 55 };\n+  do_test(arr1);\n+\n+  int arr2[] = { 11, 33, 33, 44, 55 };\n+  do_test(arr2, false);\n+\n+  int arr3[] = { 33, 33, 33, 44, 44 };\n+  do_test(arr3, false);\n+\n+  int arr4[] = { 11, 22, 33, 44, 55 };\n+  do_test(arr4, std::equal_to<int>());\n+\n+  int arr5[] = { 11, 33, 33, 44, 55 };\n+  do_test(arr5, std::equal_to<int>(), false);\n+\n+  int arr6[] = { 33, 33, 33, 44, 44 };\n+  do_test(arr6, std::equal_to<int>(), false);\n+\n+  int arr7[] = { 1, 2, 3, 4, 5 };\n+  do_test(arr7,  my_equal_to());\n+\n+  int arr8[] = { 1, 3, 3, 4, 5 };\n+  do_test(arr8,  my_equal_to(), false);\n+\n+  int arr9[] = { 3, 3, 3, 4, 4 };\n+  do_test(arr9,  my_equal_to(), false);\n+\n+  int arr10[] = { 111, 222, 333, 444, 555 };\n+  do_test(arr10,  my_equal_to());\n+\n+  int arr11[] = { 1, 222, 33, 4, 55 };\n+  do_test(arr11,  my_equal_to());\n+\n+  int arr12[] = { 111, 333, 333, 444, 555 };\n+  do_test(arr12,  my_equal_to(), false);\n+\n+  int arr13[] = { 333, 333, 333, 444, 444 };\n+  do_test(arr13,  my_equal_to(), false);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "fe4ec1f8be3b701f6393f8e3b38a98c4a641591a", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/check_type.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fcheck_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fcheck_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fcheck_type.cc?ref=632469d01e0652c465f9074d2ec7f5de1cb7dac9", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2011-01-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.12 [alg.is_permutation] Is permutation\n+\n+// { dg-do compile }\n+\n+#include <algorithm>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::forward_iterator_wrapper;\n+\n+struct X { };\n+\n+bool operator==(const X&, const X) { return true; }\n+bool predicate(const X&, const X&) { return true; }\n+\n+bool\n+test1(forward_iterator_wrapper<X>& lhs1, \n+      forward_iterator_wrapper<X>& rhs1)\n+{\n+  return std::is_permutation(lhs1, lhs1, rhs1);\n+}\n+\n+bool\n+test2(forward_iterator_wrapper<X>& x1,\n+      forward_iterator_wrapper<X>& x2)\n+{\n+  return std::is_permutation(x1, x1, x2, predicate);\n+}"}, {"sha": "1d629d4909233c62509919040c9daf08309bf64f", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/requirements/explicit_instantiation/2.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Frequirements%2Fexplicit_instantiation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Frequirements%2Fexplicit_instantiation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Frequirements%2Fexplicit_instantiation%2F2.cc?ref=632469d01e0652c465f9074d2ec7f5de1cb7dac9", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// 2011-01-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <functional>\n+#include <testsuite_api.h>\n+\n+namespace std\n+{\n+  using __gnu_test::NonDefaultConstructible;\n+\n+  typedef NonDefaultConstructible \t\tvalue_type;\n+  typedef value_type* \t\t                iterator_type;\n+  typedef std::pointer_to_binary_function<value_type, value_type, bool>\n+                                                predicate_type;\n+\n+  template bool is_permutation(iterator_type, iterator_type,\n+\t\t\t       iterator_type);\n+\n+  template bool is_permutation(iterator_type, iterator_type,\n+\t\t\t       iterator_type, predicate_type);\n+}"}, {"sha": "fcf878afbace2ca94ade1cd2fad3ca465e88b38f", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/requirements/explicit_instantiation/pod.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Frequirements%2Fexplicit_instantiation%2Fpod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632469d01e0652c465f9074d2ec7f5de1cb7dac9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Frequirements%2Fexplicit_instantiation%2Fpod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Frequirements%2Fexplicit_instantiation%2Fpod.cc?ref=632469d01e0652c465f9074d2ec7f5de1cb7dac9", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// 2011-01-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <testsuite_character.h>\n+\n+namespace std\n+{\n+  using __gnu_test::pod_int;\n+\n+  typedef pod_int \t\tvalue_type;\n+  typedef value_type* \t\titerator_type;\n+  typedef std::pointer_to_binary_function<value_type, value_type, bool>\n+                                predicate_type;\n+\n+  template bool is_permutation(iterator_type, iterator_type,\n+\t\t\t       iterator_type);\n+\n+  template bool is_permutation(iterator_type, iterator_type,\n+\t\t\t       iterator_type, predicate_type);\n+}"}]}