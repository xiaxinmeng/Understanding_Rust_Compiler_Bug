{"sha": "f0103f7bb010405798fe14afc5972f327835ae57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxMDNmN2JiMDEwNDA1Nzk4ZmUxNGFmYzU5NzJmMzI3ODM1YWU1Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-03-04T18:57:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-03-04T18:57:13Z"}, "message": "re PR c++/71446 (Incorrect overload resolution when using designated initializers)\n\n\tPR c++/71446\n\t* call.c (field_in_pset): New function.\n\t(build_aggr_conv): Handle CONSTRUCTOR_IS_DESIGNATED_INIT correctly.\n\n\t* g++.dg/cpp2a/desig12.C: New test.\n\t* g++.dg/cpp2a/desig13.C: New test.\n\nFrom-SVN: r269371", "tree": {"sha": "fb7a50e5c8217a9d5958492b77333d7ea47a78ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb7a50e5c8217a9d5958492b77333d7ea47a78ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0103f7bb010405798fe14afc5972f327835ae57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0103f7bb010405798fe14afc5972f327835ae57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0103f7bb010405798fe14afc5972f327835ae57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0103f7bb010405798fe14afc5972f327835ae57/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "209cd3bd47287d4dabb94a7c2ce965588fd0389d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/209cd3bd47287d4dabb94a7c2ce965588fd0389d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/209cd3bd47287d4dabb94a7c2ce965588fd0389d"}], "stats": {"total": 126, "additions": 121, "deletions": 5}, "files": [{"sha": "8c0bfd994ebe7fb4e5847ee3cc0256619c8efafc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f0103f7bb010405798fe14afc5972f327835ae57", "patch": "@@ -1,3 +1,9 @@\n+2019-03-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/71446\n+\t* call.c (field_in_pset): New function.\n+\t(build_aggr_conv): Handle CONSTRUCTOR_IS_DESIGNATED_INIT correctly.\n+\n 2019-03-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/71446"}, {"sha": "1a29eb7bb192c52609cfceea424f0b0500f56f10", "filename": "gcc/cp/call.c", "status": "modified", "additions": 78, "deletions": 5, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f0103f7bb010405798fe14afc5972f327835ae57", "patch": "@@ -902,6 +902,28 @@ can_convert_array (tree atype, tree ctor, int flags, tsubst_flags_t complain)\n   return true;\n }\n \n+/* Helper for build_aggr_conv.  Return true if FIELD is in PSET, or if\n+   FIELD has ANON_AGGR_TYPE_P and any initializable field in there recursively\n+   is in PSET.  */\n+\n+static bool\n+field_in_pset (hash_set<tree> *pset, tree field)\n+{\n+  if (pset->contains (field))\n+    return true;\n+  if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+    for (field = TYPE_FIELDS (TREE_TYPE (field));\n+\t field; field = DECL_CHAIN (field))\n+      {\n+\tfield = next_initializable_field (field);\n+\tif (field == NULL_TREE)\n+\t  break;\n+\tif (field_in_pset (pset, field))\n+\t  return true;\n+      }\n+  return false;\n+}\n+\n /* Represent a conversion from CTOR, a braced-init-list, to TYPE, an\n    aggregate class, if such a conversion is possible.  */\n \n@@ -912,33 +934,77 @@ build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n   conversion *c;\n   tree field = next_initializable_field (TYPE_FIELDS (type));\n   tree empty_ctor = NULL_TREE;\n+  hash_set<tree> *pset = NULL;\n \n   /* We already called reshape_init in implicit_conversion.  */\n \n   /* The conversions within the init-list aren't affected by the enclosing\n      context; they're always simple copy-initialization.  */\n   flags = LOOKUP_IMPLICIT|LOOKUP_NO_NARROWING;\n \n+  /* For designated initializers, verify that each initializer is convertible\n+     to corresponding TREE_TYPE (ce->index) and mark those FIELD_DECLs as\n+     visited.  In the following loop then ignore already visited\n+     FIELD_DECLs.  */\n+  if (CONSTRUCTOR_IS_DESIGNATED_INIT (ctor))\n+    {\n+      tree idx, val;\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), i, idx, val)\n+\t{\n+\t  if (idx && TREE_CODE (idx) == FIELD_DECL)\n+\t    {\n+\t      tree ftype = TREE_TYPE (idx);\n+\t      bool ok;\n+\n+\t      if (TREE_CODE (ftype) == ARRAY_TYPE\n+\t\t  && TREE_CODE (val) == CONSTRUCTOR)\n+\t\tok = can_convert_array (ftype, val, flags, complain);\n+\t      else\n+\t\tok = can_convert_arg (ftype, TREE_TYPE (val), val, flags,\n+\t\t\t\t      complain);\n+\n+\t      if (!ok)\n+\t\tgoto fail;\n+\t      /* For unions, there should be just one initializer.  */\n+\t      if (TREE_CODE (type) == UNION_TYPE)\n+\t\t{\n+\t\t  field = NULL_TREE;\n+\t\t  i = 1;\n+\t\t  break;\n+\t\t}\n+\t      if (pset == NULL)\n+\t\tpset = new hash_set<tree>;\n+\t      pset->add (idx);\n+\t    }\n+\t  else\n+\t    goto fail;\n+\t}\n+    }\n+\n   for (; field; field = next_initializable_field (DECL_CHAIN (field)))\n     {\n       tree ftype = TREE_TYPE (field);\n       tree val;\n       bool ok;\n \n+      if (pset && field_in_pset (pset, field))\n+\tcontinue;\n       if (i < CONSTRUCTOR_NELTS (ctor))\n-\tval = CONSTRUCTOR_ELT (ctor, i)->value;\n+\t{\n+\t  val = CONSTRUCTOR_ELT (ctor, i)->value;\n+\t  ++i;\n+\t}\n       else if (DECL_INITIAL (field))\n \tval = get_nsdmi (field, /*ctor*/false, complain);\n       else if (TYPE_REF_P (ftype))\n \t/* Value-initialization of reference is ill-formed.  */\n-\treturn NULL;\n+\tgoto fail;\n       else\n \t{\n \t  if (empty_ctor == NULL_TREE)\n \t    empty_ctor = build_constructor (init_list_type_node, NULL);\n \t  val = empty_ctor;\n \t}\n-      ++i;\n \n       if (TREE_CODE (ftype) == ARRAY_TYPE\n \t  && TREE_CODE (val) == CONSTRUCTOR)\n@@ -948,15 +1014,22 @@ build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n \t\t\t      complain);\n \n       if (!ok)\n-\treturn NULL;\n+\tgoto fail;\n \n       if (TREE_CODE (type) == UNION_TYPE)\n \tbreak;\n     }\n \n   if (i < CONSTRUCTOR_NELTS (ctor))\n-    return NULL;\n+    {\n+    fail:\n+      if (pset)\n+\tdelete pset;\n+      return NULL;\n+    }\n \n+  if (pset)\n+    delete pset;\n   c = alloc_conversion (ck_aggr);\n   c->type = type;\n   c->rank = cr_exact;"}, {"sha": "3186805c9cb2afbc079dbf02a9485038981d4e12", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0103f7bb010405798fe14afc5972f327835ae57", "patch": "@@ -1,3 +1,9 @@\n+2019-03-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/71446\n+\t* g++.dg/cpp2a/desig12.C: New test.\n+\t* g++.dg/cpp2a/desig13.C: New test.\n+\n 2019-03-04  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/88530"}, {"sha": "cfff9a79c63f41d1829f7b9d58dad9eee6fe571a", "filename": "gcc/testsuite/g++.dg/cpp2a/desig12.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig12.C?ref=f0103f7bb010405798fe14afc5972f327835ae57", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/71446\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+struct T { void *a; int b; };\n+struct U { int a; union { int b; union { long c; short d; }; }; int e; };\n+void bar (T);\n+void baz (U);\n+\n+void\n+foo ()\n+{\n+  bar ({.b = 1});\n+  baz ({.c = 5L, .e = 6});\n+}"}, {"sha": "442e8b74aa4d086d7f6f20dd0e6b6f7be67f9bdb", "filename": "gcc/testsuite/g++.dg/cpp2a/desig13.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0103f7bb010405798fe14afc5972f327835ae57/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig13.C?ref=f0103f7bb010405798fe14afc5972f327835ae57", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/71446\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+struct S { int a, b, c, d, e; };\n+struct T { int a, b; };\n+void foo (S);\n+void bar (T);\n+\n+void\n+baz ()\n+{\n+  foo ({.d = 5, 6, .b = 2, 3});\t// { dg-error \"designator order for field 'S::b' does not match declaration order in 'S'\" }\n+\t\t\t\t// { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } .-1 }\n+  bar ({.b = 1, .a = 2});\t// { dg-error \"designator order for field 'T::a' does not match declaration order in 'T'\" }\n+}"}]}