{"sha": "c07757e53626133cd0f248f1f690e3fd9b059f6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA3NzU3ZTUzNjI2MTMzY2QwZjI0OGYxZjY5MGUzZmQ5YjA1OWY2ZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-10-19T12:32:25Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-10-19T12:32:25Z"}, "message": "mode-switching.c (create_pre_exit): Rename maybe_builtin_apply to multi_reg_return.\n\n\t* mode-switching.c (create_pre_exit): Rename maybe_builtin_apply\n\tto multi_reg_return.  Clarify that we are skipping USEs of multiple\n\treturn registers.  Use bool type where appropriate.\n\nFrom-SVN: r203856", "tree": {"sha": "c73888a4600c2e287636b6d703dc6b82f4ad242d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c73888a4600c2e287636b6d703dc6b82f4ad242d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c07757e53626133cd0f248f1f690e3fd9b059f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c07757e53626133cd0f248f1f690e3fd9b059f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c07757e53626133cd0f248f1f690e3fd9b059f6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c07757e53626133cd0f248f1f690e3fd9b059f6e/comments", "author": null, "committer": null, "parents": [{"sha": "41ee845b75a5025e4d376d8df8661e1340b59d0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ee845b75a5025e4d376d8df8661e1340b59d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41ee845b75a5025e4d376d8df8661e1340b59d0a"}], "stats": {"total": 41, "additions": 25, "deletions": 16}, "files": [{"sha": "7deefce85e64f293c2459d6106541cfbb872a729", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07757e53626133cd0f248f1f690e3fd9b059f6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07757e53626133cd0f248f1f690e3fd9b059f6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c07757e53626133cd0f248f1f690e3fd9b059f6e", "patch": "@@ -1,3 +1,9 @@\n+2013-10-19  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* mode-switching.c (create_pre_exit): Rename maybe_builtin_apply\n+\tto multi_reg_return.  Clarify that we are skipping USEs of multiple\n+\treturn registers.  Use bool type where appropriate.\n+\n 2013-10-18  Jan Hubicka  <jh@suse.cz>\n \n \t* config/i386/i386.h (ACCUMULATE_OUTGOING_ARGS): Disable accumulation\n@@ -6,7 +12,8 @@\n \t(X86_TUNE_PUSH_MEMORY): Likewise.\n \t(X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL,\n \tX86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL): New.\n-\t(X86_TUNE_ACCUMULATE_OUTGOING_ARGS, X86_TUNE_ALWAYS_FANCY_MATH_387): New.\n+\t(X86_TUNE_ACCUMULATE_OUTGOING_ARGS, X86_TUNE_ALWAYS_FANCY_MATH_387):\n+\tNew.\n \t* i386.c (x86_accumulate_outgoing_args, x86_arch_always_fancy_math_387,\n \tx86_avx256_split_unaligned_load, x86_avx256_split_unaligned_store):\n \tRemove.\n@@ -21,8 +28,8 @@\n \n 2013-10-18  Andrew MacLeod  <amacleod@redhat.com>\n \n-\t* tree-ssa.h: Don't include gimple-low.h, tree-ssa-address.h, sbitmap.h,\n-\ttree-ssa-threadedge.h, tree-ssa-dom.h, and tree-cfgcleanup.h.\n+\t* tree-ssa.h: Don't include gimple-low.h, tree-ssa-address.h,\n+\tsbitmap.h, tree-ssa-threadedge.h, tree-ssa-dom.h and tree-cfgcleanup.h.\n \t* gimple-low.c (gimple_check_call_arg,\n \tgimple_check_call_matching_types): Move to cgraph.c.\n \t* gimple-low.h: Remove prototype.\n@@ -90,7 +97,8 @@\n \t* tree-ssa-threadupdate.c: Do not include \"tm.h\" or \"tm_p.h\".\n \n \t* tree-ssa-threadupdate.c: Include \"dbgcnt.h\".\n-\t(register_jump_thread): Add \"registered_jump_thread\" debug counter support.\n+\t(register_jump_thread): Add \"registered_jump_thread\" debug\n+\tcounter support.\n \t* dbgcnt.def (registered_jump_thread): New debug counter.\n \n 2013-10-18  Andrew MacLeod  <amacleod@redhat.com>"}, {"sha": "0b08998372f34d5d64bf01bf55932f7af6da4ca3", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07757e53626133cd0f248f1f690e3fd9b059f6e/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07757e53626133cd0f248f1f690e3fd9b059f6e/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=c07757e53626133cd0f248f1f690e3fd9b059f6e", "patch": "@@ -229,9 +229,9 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t    int ret_start = REGNO (ret_reg);\n \t    int nregs = hard_regno_nregs[ret_start][GET_MODE (ret_reg)];\n \t    int ret_end = ret_start + nregs;\n-\t    int short_block = 0;\n-\t    int maybe_builtin_apply = 0;\n-\t    int forced_late_switch = 0;\n+\t    bool short_block = false;\n+\t    bool multi_reg_return = false;\n+\t    bool forced_late_switch = false;\n \t    rtx before_return_copy;\n \n \t    do\n@@ -251,19 +251,20 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t       copy yet, the copy must have been deleted.  */\n \t\t    if (CALL_P (return_copy))\n \t\t      {\n-\t\t\tshort_block = 1;\n+\t\t\tshort_block = true;\n \t\t\tbreak;\n \t\t      }\n \t\t    return_copy_pat = PATTERN (return_copy);\n \t\t    switch (GET_CODE (return_copy_pat))\n \t\t      {\n \t\t      case USE:\n-\t\t\t/* Skip __builtin_apply pattern.  */\n+\t\t\t/* Skip USEs of multiple return registers.\n+\t\t\t   __builtin_apply pattern is also handled here.  */\n \t\t\tif (GET_CODE (XEXP (return_copy_pat, 0)) == REG\n \t\t\t    && (targetm.calls.function_value_regno_p\n \t\t\t\t(REGNO (XEXP (return_copy_pat, 0)))))\n \t\t\t  {\n-\t\t\t    maybe_builtin_apply = 1;\n+\t\t\t    multi_reg_return = true;\n \t\t\t    last_insn = return_copy;\n \t\t\t    continue;\n \t\t\t  }\n@@ -326,7 +327,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t\t   there are no return copy insns at all.  This\n \t\t\t   avoids an ice on that invalid function.  */\n \t\t\tif (ret_start + nregs == ret_end)\n-\t\t\t  short_block = 1;\n+\t\t\t  short_block = true;\n \t\t\tbreak;\n \t\t      }\n \t\t    if (!targetm.calls.function_value_regno_p (copy_start))\n@@ -354,10 +355,10 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t\t   another mode than MODE_EXIT, even if it is\n \t\t\t   unrelated to the return value, so we want to put\n \t\t\t   the final mode switch after it.  */\n-\t\t\tif (maybe_builtin_apply\n+\t\t\tif (multi_reg_return\n \t\t\t    && targetm.calls.function_value_regno_p\n \t\t\t        (copy_start))\n-\t\t\t  forced_late_switch = 1;\n+\t\t\t  forced_late_switch = true;\n \n \t\t\t/* For the SH4, floating point loads depend on fpscr,\n \t\t\t   thus we might need to put the final mode switch\n@@ -367,7 +368,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t\tif (copy_start >= ret_start\n \t\t\t    && copy_start + copy_num <= ret_end\n \t\t\t    && OBJECT_P (SET_SRC (return_copy_pat)))\n-\t\t\t  forced_late_switch = 1;\n+\t\t\t  forced_late_switch = true;\n \t\t\tbreak;\n \t\t      }\n \t\t    if (copy_num == 0)\n@@ -379,7 +380,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t    if (copy_start >= ret_start\n \t\t\t&& copy_start + copy_num <= ret_end)\n \t\t      nregs -= copy_num;\n-\t\t    else if (!maybe_builtin_apply\n+\t\t    else if (!multi_reg_return\n \t\t\t     || !targetm.calls.function_value_regno_p\n \t\t\t\t (copy_start))\n \t\t      break;\n@@ -393,7 +394,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t   isolated use.  */\n \t\tif (return_copy == BB_HEAD (src_bb))\n \t\t  {\n-\t\t    short_block = 1;\n+\t\t    short_block = true;\n \t\t    break;\n \t\t  }\n \t\tlast_insn = return_copy;"}]}