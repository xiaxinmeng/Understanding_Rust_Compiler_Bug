{"sha": "262767053ee39b37d4e34b4fae01bfb1697bd081", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYyNzY3MDUzZWUzOWIzN2Q0ZTM0YjRmYWUwMWJmYjE2OTdiZDA4MQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-09-02T02:00:55Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-09-02T02:00:55Z"}, "message": "expmed.c (enum alg_code): Remove long unused enumeration values.\n\n\n\t* expmed.c (enum alg_code): Remove long unused enumeration values.\n        (struct mult_cost): New structure to hold the \"score\" of a synthetic\n\tmultiply sequence, including both a rtx_cost and a latency field.\n\t(MULT_COST_LESS): New macro to compare mult_cost to a constant.\n\t(CHEAPER_MULT_COST): New macro to compare two mult_costs.\n\t(struct algorithm): Change type of cost field to be mult_cost.\n\t(synth_mult): Change type of cost_limit argument to be a\n\tpointer to a mult_cost.  Update all cost comparisons to use the\n\tnew mult_cost infrastructure.  For alg_add_factor and\n\talg_sub_factor operations, latency is lower than the rtx_cost.\n\t(choose_mult_variant):  Update calls to synth_mult.  Perform\n\tcost comparisons using the new mult_cost infrastructure.\n\t(expand_mult_highpart): Use alg.cost.cost instead of alg.cost\n\tto optain the total rtx_cost of a synth_mult \"algorithm\".\n\nFrom-SVN: r86954", "tree": {"sha": "c09b8510a43b24546efee3e6150e55ce41b0c5a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09b8510a43b24546efee3e6150e55ce41b0c5a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/262767053ee39b37d4e34b4fae01bfb1697bd081", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/262767053ee39b37d4e34b4fae01bfb1697bd081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/262767053ee39b37d4e34b4fae01bfb1697bd081", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/262767053ee39b37d4e34b4fae01bfb1697bd081/comments", "author": null, "committer": null, "parents": [{"sha": "594a35657ae16ce4390cbcd478e367a306762797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594a35657ae16ce4390cbcd478e367a306762797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/594a35657ae16ce4390cbcd478e367a306762797"}], "stats": {"total": 274, "additions": 201, "deletions": 73}, "files": [{"sha": "8a4a14b86baedc12687879c9ec60ac5c71989fa8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/262767053ee39b37d4e34b4fae01bfb1697bd081/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/262767053ee39b37d4e34b4fae01bfb1697bd081/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=262767053ee39b37d4e34b4fae01bfb1697bd081", "patch": "@@ -1,3 +1,20 @@\n+2004-09-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (enum alg_code): Remove long unused enumeration values.\n+        (struct mult_cost): New structure to hold the \"score\" of a synthetic\n+\tmultiply sequence, including both a rtx_cost and a latency field.\n+\t(MULT_COST_LESS): New macro to compare mult_cost to a constant.\n+\t(CHEAPER_MULT_COST): New macro to compare two mult_costs.\n+\t(struct algorithm): Change type of cost field to be mult_cost.\n+\t(synth_mult): Change type of cost_limit argument to be a\n+\tpointer to a mult_cost.  Update all cost comparisons to use the\n+\tnew mult_cost infrastructure.  For alg_add_factor and \n+\talg_sub_factor operations, latency is lower than the rtx_cost.\n+\t(choose_mult_variant):  Update calls to synth_mult.  Perform\n+\tcost comparisons using the new mult_cost infrastructure.\n+\t(expand_mult_highpart): Use alg.cost.cost instead of alg.cost\n+\tto optain the total rtx_cost of a synth_mult \"algorithm\".\n+\n 2004-09-01  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/power4.md: Increase store latency to 12."}, {"sha": "10084e5ae8b4cb4fd475fc6aed26a4910c7d8c23", "filename": "gcc/expmed.c", "status": "modified", "additions": 184, "deletions": 73, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/262767053ee39b37d4e34b4fae01bfb1697bd081/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/262767053ee39b37d4e34b4fae01bfb1697bd081/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=262767053ee39b37d4e34b4fae01bfb1697bd081", "patch": "@@ -2153,8 +2153,37 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n enum alg_code { alg_zero, alg_m, alg_shift,\n \t\t  alg_add_t_m2, alg_sub_t_m2,\n \t\t  alg_add_factor, alg_sub_factor,\n-\t\t  alg_add_t2_m, alg_sub_t2_m,\n-\t\t  alg_add, alg_subtract, alg_factor, alg_shiftop };\n+\t\t  alg_add_t2_m, alg_sub_t2_m };\n+\n+/* This structure holds the \"cost\" of a multiply sequence.  The\n+   \"cost\" field holds the total rtx_cost of every operator in the\n+   synthetic multiplication sequence, hence cost(a op b) is defined\n+   as rtx_cost(op) + cost(a) + cost(b), where cost(leaf) is zero.\n+   The \"latency\" field holds the minimum possible latency of the\n+   synthetic multiply, on a hypothetical infinitely parallel CPU.\n+   This is the critical path, or the maximum height, of the expression\n+   tree which is the sum of rtx_costs on the most expensive path from\n+   any leaf to the root.  Hence latency(a op b) is defined as zero for\n+   leaves and rtx_cost(op) + max(latency(a), latency(b)) otherwise.  */\n+\n+struct mult_cost {\n+  short cost;     /* Total rtx_cost of the multiplication sequence.  */\n+  short latency;  /* The latency of the multiplication sequence.  */\n+};\n+\n+/* This macro is used to compare a pointer to a mult_cost against an\n+   single integer \"rtx_cost\" value.  This is equivalent to the macro\n+   CHEAPER_MULT_COST(X,Z) where Z = {Y,Y}.  */\n+#define MULT_COST_LESS(X,Y) ((X)->cost < (Y)\t\\\n+\t\t\t     || ((X)->cost == (Y) && (X)->latency < (Y)))\n+\n+/* This macro is used to compare two pointers to mult_costs against\n+   each other.  The macro returns true if X is cheaper than Y.\n+   Currently, the cheaper of two mult_costs is the one with the\n+   lower \"cost\".  If \"cost\"s are tied, the lower latency is cheaper.  */\n+#define CHEAPER_MULT_COST(X,Y)  ((X)->cost < (Y)->cost\t\t\\\n+\t\t\t\t || ((X)->cost == (Y)->cost\t\\\n+\t\t\t\t     && (X)->latency < (Y)->latency))\n \n /* This structure records a sequence of operations.\n    `ops' is the number of operations recorded.\n@@ -2177,7 +2206,7 @@ enum alg_code { alg_zero, alg_m, alg_shift,\n \n struct algorithm\n {\n-  short cost;\n+  struct mult_cost cost;\n   short ops;\n   /* The size of the OP and LOG fields are not directly related to the\n      word size, but the worst-case algorithms will be if we have few\n@@ -2195,7 +2224,7 @@ struct algorithm\n enum mult_variant {basic_variant, negate_variant, add_variant};\n \n static void synth_mult (struct algorithm *, unsigned HOST_WIDE_INT,\n-\t\t\tint, enum machine_mode mode);\n+\t\t\tconst struct mult_cost *, enum machine_mode mode);\n static bool choose_mult_variant (enum machine_mode, HOST_WIDE_INT,\n \t\t\t\t struct algorithm *, enum mult_variant *, int);\n static rtx expand_mult_const (enum machine_mode, rtx, HOST_WIDE_INT, rtx,\n@@ -2215,19 +2244,22 @@ static rtx expand_mult_highpart_optab (enum machine_mode, rtx, rtx, rtx,\n \n static void\n synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n-\t    int cost_limit, enum machine_mode mode)\n+\t    const struct mult_cost *cost_limit, enum machine_mode mode)\n {\n   int m;\n   struct algorithm *alg_in, *best_alg;\n-  int cost;\n+  struct mult_cost best_cost;\n+  struct mult_cost new_limit;\n+  int op_cost, op_latency;\n   unsigned HOST_WIDE_INT q;\n   int maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n      is found, this value will be returned and indicate failure.  */\n-  alg_out->cost = cost_limit;\n+  alg_out->cost.cost = cost_limit->cost + 1;\n \n-  if (cost_limit <= 0)\n+  if (cost_limit->cost < 0\n+      || (cost_limit->cost == 0 && cost_limit->latency <= 0))\n     return;\n \n   /* Restrict the bits of \"t\" to the multiplication's mode.  */\n@@ -2237,7 +2269,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   if (t == 1)\n     {\n       alg_out->ops = 1;\n-      alg_out->cost = 0;\n+      alg_out->cost.cost = 0;\n+      alg_out->cost.latency = 0;\n       alg_out->op[0] = alg_m;\n       return;\n     }\n@@ -2246,12 +2279,13 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n      fail now.  */\n   if (t == 0)\n     {\n-      if (zero_cost >= cost_limit)\n+      if (MULT_COST_LESS (cost_limit, zero_cost))\n \treturn;\n       else\n \t{\n \t  alg_out->ops = 1;\n-\t  alg_out->cost = zero_cost;\n+\t  alg_out->cost.cost = zero_cost;\n+\t  alg_out->cost.latency = zero_cost;\n \t  alg_out->op[0] = alg_zero;\n \t  return;\n \t}\n@@ -2261,6 +2295,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \n   alg_in = alloca (sizeof (struct algorithm));\n   best_alg = alloca (sizeof (struct algorithm));\n+  best_cost = *cost_limit;\n \n   /* If we have a group of zero bits at the low-order part of T, try\n      multiplying by the remaining bits and then doing a shift.  */\n@@ -2274,19 +2309,22 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  /* The function expand_shift will choose between a shift and\n \t     a sequence of additions, so the observed cost is given as\n \t     MIN (m * add_cost[mode], shift_cost[mode][m]).  */\n-\t  cost = m * add_cost[mode];\n-\t  if (shift_cost[mode][m] < cost)\n-\t    cost = shift_cost[mode][m];\n-\t  synth_mult (alg_in, q, cost_limit - cost, mode);\n-\n-\t  cost += alg_in->cost;\n-\t  if (cost < cost_limit)\n+\t  op_cost = m * add_cost[mode];\n+\t  if (shift_cost[mode][m] < op_cost)\n+\t    op_cost = shift_cost[mode][m];\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.latency = best_cost.latency - op_cost;\n+\t  synth_mult (alg_in, q, &new_limit, mode);\n+\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n \t    {\n \t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops] = alg_shift;\n-\t      cost_limit = cost;\n \t    }\n \t}\n     }\n@@ -2311,34 +2349,40 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n \n-\t  cost = add_cost[mode];\n-\t  synth_mult (alg_in, t + 1, cost_limit - cost, mode);\n+\t  op_cost = add_cost[mode];\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.latency = best_cost.latency - op_cost;\n+\t  synth_mult (alg_in, t + 1, &new_limit, mode);\n \n-\t  cost += alg_in->cost;\n-\t  if (cost < cost_limit)\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n \t    {\n \t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = 0;\n \t      best_alg->op[best_alg->ops] = alg_sub_t_m2;\n-\t      cost_limit = cost;\n \t    }\n \t}\n       else\n \t{\n \t  /* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n \n-\t  cost = add_cost[mode];\n-\t  synth_mult (alg_in, t - 1, cost_limit - cost, mode);\n+\t  op_cost = add_cost[mode];\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.latency = best_cost.latency - op_cost;\n+\t  synth_mult (alg_in, t - 1, &new_limit, mode);\n \n-\t  cost += alg_in->cost;\n-\t  if (cost < cost_limit)\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n \t    {\n \t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = 0;\n \t      best_alg->op[best_alg->ops] = alg_add_t_m2;\n-\t      cost_limit = cost;\n \t    }\n \t}\n     }\n@@ -2360,19 +2404,36 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n       if (t % d == 0 && t > d && m < maxm)\n \t{\n-\t  cost = add_cost[mode] + shift_cost[mode][m];\n-\t  if (shiftadd_cost[mode][m] < cost)\n-\t    cost = shiftadd_cost[mode][m];\n-\t  synth_mult (alg_in, t / d, cost_limit - cost, mode);\n+\t  /* If the target has a cheap shift-and-add instruction use\n+\t     that in preference to a shift insn followed by an add insn.\n+\t     Assume that the shift-and-add is \"atomic\" with a latency\n+\t     equal to it's cost, otherwise assume that on superscalar\n+\t     hardware the shift may be executed concurrently with the\n+\t     earlier steps in the algorithm.  */\n+\t  op_cost = add_cost[mode] + shift_cost[mode][m];\n+\t  if (shiftadd_cost[mode][m] < op_cost)\n+\t    {\n+\t      op_cost = shiftadd_cost[mode][m];\n+\t      op_latency = op_cost;\n+\t    }\n+\t  else\n+\t    op_latency = add_cost[mode];\n+\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.latency = best_cost.latency - op_latency;\n+\t  synth_mult (alg_in, t / d, &new_limit, mode);\n \n-\t  cost += alg_in->cost;\n-\t  if (cost < cost_limit)\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_latency;\n+\t  if (alg_in->cost.latency < op_cost)\n+\t    alg_in->cost.latency = op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n \t    {\n \t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops] = alg_add_factor;\n-\t      cost_limit = cost;\n \t    }\n \t  /* Other factors will have been taken care of in the recursion.  */\n \t  break;\n@@ -2381,19 +2442,36 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n       if (t % d == 0 && t > d && m < maxm)\n \t{\n-\t  cost = add_cost[mode] + shift_cost[mode][m];\n-\t  if (shiftsub_cost[mode][m] < cost)\n-\t    cost = shiftsub_cost[mode][m];\n-\t  synth_mult (alg_in, t / d, cost_limit - cost, mode);\n+\t  /* If the target has a cheap shift-and-subtract insn use\n+\t     that in preference to a shift insn followed by a sub insn.\n+\t     Assume that the shift-and-sub is \"atomic\" with a latency\n+\t     equal to it's cost, otherwise assume that on superscalar\n+\t     hardware the shift may be executed concurrently with the\n+\t     earlier steps in the algorithm.  */\n+\t  op_cost = add_cost[mode] + shift_cost[mode][m];\n+\t  if (shiftsub_cost[mode][m] < op_cost)\n+\t    {\n+\t      op_cost = shiftsub_cost[mode][m];\n+\t      op_latency = op_cost;\n+\t    }\n+\t  else\n+\t    op_latency = add_cost[mode];\n+\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.cost = best_cost.cost - op_latency;\n+\t  synth_mult (alg_in, t / d, &new_limit, mode);\n \n-\t  cost += alg_in->cost;\n-\t  if (cost < cost_limit)\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_latency;\n+\t  if (alg_in->cost.latency < op_cost)\n+\t    alg_in->cost.latency = op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n \t    {\n \t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops] = alg_sub_factor;\n-\t      cost_limit = cost;\n \t    }\n \t  break;\n \t}\n@@ -2408,17 +2486,20 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  cost = shiftadd_cost[mode][m];\n-\t  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost, mode);\n-\n-\t  cost += alg_in->cost;\n-\t  if (cost < cost_limit)\n+\t  op_cost = shiftadd_cost[mode][m];\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.latency = best_cost.latency - op_cost;\n+\t  synth_mult (alg_in, (t - 1) >> m, &new_limit, mode);\n+\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n \t    {\n \t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops] = alg_add_t2_m;\n-\t      cost_limit = cost;\n \t    }\n \t}\n \n@@ -2427,36 +2508,38 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  cost = shiftsub_cost[mode][m];\n-\t  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost, mode);\n-\n-\t  cost += alg_in->cost;\n-\t  if (cost < cost_limit)\n+\t  op_cost = shiftsub_cost[mode][m];\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.latency = best_cost.latency - op_cost;\n+\t  synth_mult (alg_in, (t + 1) >> m, &new_limit, mode);\n+\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n \t    {\n \t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops] = alg_sub_t2_m;\n-\t      cost_limit = cost;\n \t    }\n \t}\n     }\n \n-  /* If cost_limit has not decreased since we stored it in alg_out->cost,\n-     we have not found any algorithm.  */\n-  if (cost_limit == alg_out->cost)\n-    return;\n-\n   /* If we are getting a too long sequence for `struct algorithm'\n      to record, make this search fail.  */\n   if (best_alg->ops == MAX_BITS_PER_WORD)\n     return;\n \n+  /* If best_cost has not decreased, we have not found any algorithm.  */\n+  if (!CHEAPER_MULT_COST (&best_cost, cost_limit))\n+    return;\n+\n   /* Copy the algorithm from temporary space to the space at alg_out.\n      We avoid using structure assignment because the majority of\n      best_alg is normally undefined, and this is a critical function.  */\n   alg_out->ops = best_alg->ops + 1;\n-  alg_out->cost = cost_limit;\n+  alg_out->cost = best_cost;\n   memcpy (alg_out->op, best_alg->op,\n \t  alg_out->ops * sizeof *alg_out->op);\n   memcpy (alg_out->log, best_alg->log,\n@@ -2479,29 +2562,57 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n \t\t     int mult_cost)\n {\n   struct algorithm alg2;\n+  struct mult_cost limit;\n+  int op_cost;\n \n   *variant = basic_variant;\n-  synth_mult (alg, val, mult_cost, mode);\n+  limit.cost = mult_cost;\n+  limit.latency = mult_cost;\n+  synth_mult (alg, val, &limit, mode);\n \n   /* This works only if the inverted value actually fits in an\n      `unsigned int' */\n   if (HOST_BITS_PER_INT >= GET_MODE_BITSIZE (mode))\n     {\n-      synth_mult (&alg2, -val, MIN (alg->cost, mult_cost) - neg_cost[mode],\n-\t\t  mode);\n-      alg2.cost += neg_cost[mode];\n-      if (alg2.cost < alg->cost)\n+      op_cost = neg_cost[mode];\n+      if (MULT_COST_LESS (&alg->cost, mult_cost))\n+\t{\n+\t  limit.cost = alg->cost.cost - op_cost;\n+\t  limit.latency = alg->cost.latency - op_cost;\n+\t}\n+      else\n+\t{\n+\t  limit.cost = mult_cost - op_cost;\n+\t  limit.latency = mult_cost - op_cost;\n+\t}\n+\n+      synth_mult (&alg2, -val, &limit, mode);\n+      alg2.cost.cost += op_cost;\n+      alg2.cost.latency += op_cost;\n+      if (CHEAPER_MULT_COST (&alg2.cost, &alg->cost))\n \t*alg = alg2, *variant = negate_variant;\n     }\n \n   /* This proves very useful for division-by-constant.  */\n-  synth_mult (&alg2, val - 1, MIN (alg->cost, mult_cost) - add_cost[mode],\n-\t      mode);\n-  alg2.cost += add_cost[mode];\n-  if (alg2.cost < alg->cost)\n+  op_cost = add_cost[mode];\n+  if (MULT_COST_LESS (&alg->cost, mult_cost))\n+    {\n+      limit.cost = alg->cost.cost - op_cost;\n+      limit.latency = alg->cost.latency - op_cost;\n+    }\n+  else\n+    {\n+      limit.cost = mult_cost - op_cost;\n+      limit.latency = mult_cost - op_cost;\n+    }\n+\n+  synth_mult (&alg2, val - 1, &limit, mode);\n+  alg2.cost.cost += op_cost;\n+  alg2.cost.latency += op_cost;\n+  if (CHEAPER_MULT_COST (&alg2.cost, &alg->cost))\n     *alg = alg2, *variant = add_variant;\n \n-  return alg->cost < mult_cost;\n+  return MULT_COST_LESS (&alg->cost, mult_cost);\n }\n \n /* A subroutine of expand_mult, used for constant multiplications.\n@@ -3074,8 +3185,8 @@ expand_mult_highpart (enum machine_mode mode, rtx op0,\n     {\n       /* See whether the specialized multiplication optabs are\n \t cheaper than the shift/add version.  */\n-      tem = expand_mult_highpart_optab (mode, op0, op1, target,\n-\t\t\t\t\tunsignedp, alg.cost + extra_cost);\n+      tem = expand_mult_highpart_optab (mode, op0, op1, target, unsignedp,\n+\t\t\t\t\talg.cost.cost + extra_cost);\n       if (tem)\n \treturn tem;\n "}]}