{"sha": "87c166683a971ac241f06423db6af2b45d1c39ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjMTY2NjgzYTk3MWFjMjQxZjA2NDIzZGI2YWYyYjQ1ZDFjMzllZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-05-28T16:50:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-05-28T16:50:38Z"}, "message": "pa.md (jump): Handle out of range unconditional jump when not optimizing.\n\n        * pa.md (jump): Handle out of range unconditional jump\n        when not optimizing.\n\nFrom-SVN: r14133", "tree": {"sha": "d62295ab72955bb0761c9e2a21e9ae69064260fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d62295ab72955bb0761c9e2a21e9ae69064260fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87c166683a971ac241f06423db6af2b45d1c39ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c166683a971ac241f06423db6af2b45d1c39ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c166683a971ac241f06423db6af2b45d1c39ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c166683a971ac241f06423db6af2b45d1c39ed/comments", "author": null, "committer": null, "parents": [{"sha": "380d5b3249be1265d2112b06c6a63f23b5f6a4b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/380d5b3249be1265d2112b06c6a63f23b5f6a4b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/380d5b3249be1265d2112b06c6a63f23b5f6a4b8"}], "stats": {"total": 76, "additions": 66, "deletions": 10}, "files": [{"sha": "e0d599683a5407135f9b30216eae0c3477a3b626", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c166683a971ac241f06423db6af2b45d1c39ed/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c166683a971ac241f06423db6af2b45d1c39ed/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=87c166683a971ac241f06423db6af2b45d1c39ed", "patch": "@@ -3940,19 +3940,75 @@\n (define_insn \"jump\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n-  \"bl%* %l0,0\"\n+  \"*\n+{\n+  extern int optimize;\n+  /* An unconditional branch which can reach its target.  */\n+  if (get_attr_length (insn) != 24\n+      && get_attr_length (insn) != 16)\n+    return \\\"bl%* %l0,0\\\";\n+\n+  /* An unconditional branch which can not reach its target.\n+\n+     We need to be able to use %r1 as a scratch register; however,\n+     we can never be sure whether or not it's got a live value in\n+     it.  Therefore, we must restore its original value after the\n+     jump.\n+\n+     To make matters worse, we don't have a stack slot which we\n+     can always clobber.  sp-12/sp-16 shouldn't ever have a live\n+     value during a non-optimizing compilation, so we use those\n+     slots for now.  We don't support very long branches when\n+     optimizing -- they should be quite rare when optimizing.\n+\n+     Really the way to go long term is a register scavenger; goto\n+     the target of the jump and find a register which we can use\n+     as a scratch to hold the value in %r1.  */\n+\n+  /* We don't know how to register scavenge yet.  */\n+  if (optimize)\n+    abort ();\n+\n+  /* First store %r1 into the stack.  */\n+  output_asm_insn (\\\"stw %%r1,-16(%%r30)\\\", operands);\n+\n+  /* Now load the target address into %r1 and do an indirect jump\n+     to the value specified in %r1.  Be careful to generate PIC\n+     code as needed.  */\n+  if (flag_pic)\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = operands[0];\n+      xoperands[1] = gen_label_rtx ();\n+\n+      output_asm_insn (\\\"bl .+8,%%r1\\\\n\\\\taddil L'%l0-%l1,%%r1\\\", xoperands);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+                                 CODE_LABEL_NUMBER (xoperands[1]));\n+      output_asm_insn (\\\"ldo R'%l0-%l1(%%r1),%%r1\\\\n\\\\tbv 0(%%r1)\\\",\n+\t\t       xoperands);\n+    }\n+  else\n+    output_asm_insn (\\\"ldil L'%l0,%%r1\\\\n\\\\tbe R'%l0(%%sr4,%%r1)\\\", operands);;\n+\n+  /* And restore the value of %r1 in the delay slot.  We're not optimizing,\n+     so we know nothing else can be in the delay slot.  */\n+  return \\\"ldw -16(%%r30),%%r1\\\";\n+}\"\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"pa_combine_type\" \"uncond_branch\")\n    (set (attr \"length\")\n-    (cond [(eq (symbol_ref \"jump_in_call_delay (insn)\") (const_int 0))\n-\t   (const_int 4)\n-;; If the jump is in the delay slot of a call, then its length depends\n-;; on whether or not we can add the proper offset to %r2 with an ldo\n-;; instruction.\n-\t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n-\t\t    (const_int 8184))\n-           (const_int 4)]\n-\t  (const_int 8)))])\n+    (cond [(eq (symbol_ref \"jump_in_call_delay (insn)\") (const_int 1))\n+\t   (if_then_else (lt (abs (minus (match_dup 0)\n+\t\t\t\t\t (plus (pc) (const_int 8))))\n+\t\t\t     (const_int 8184))\n+\t\t\t (const_int 4)\n+\t\t\t (const_int 8))\n+\t   (ge (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t\t (const_int 16)\n+\t\t\t (const_int 24))]\n+\t  (const_int 4)))])\n \n ;; Subroutines of \"casesi\".\n ;; operand 0 is index"}]}