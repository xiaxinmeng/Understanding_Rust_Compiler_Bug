{"sha": "d78d243c9c2801c8bf3acd42f2b1dc369819d98a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc4ZDI0M2M5YzI4MDFjOGJmM2FjZDQyZjJiMWRjMzY5ODE5ZDk4YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-10T19:41:37Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-10T19:41:37Z"}, "message": "(expand_assignment): Use a smaller alignment when storing\ninto a field with a variable offset.\n\nFrom-SVN: r6051", "tree": {"sha": "c7bbebb0035aa87f5c38cbd8006f8b52ae5e863b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7bbebb0035aa87f5c38cbd8006f8b52ae5e863b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d78d243c9c2801c8bf3acd42f2b1dc369819d98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78d243c9c2801c8bf3acd42f2b1dc369819d98a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d78d243c9c2801c8bf3acd42f2b1dc369819d98a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78d243c9c2801c8bf3acd42f2b1dc369819d98a/comments", "author": null, "committer": null, "parents": [{"sha": "f820ace744fc98106c880d0d2c54e56e698c6f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f820ace744fc98106c880d0d2c54e56e698c6f87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f820ace744fc98106c880d0d2c54e56e698c6f87"}], "stats": {"total": 12, "additions": 11, "deletions": 1}, "files": [{"sha": "4d99bca4937d6bac2a8ff1a010b72ffe200f40e9", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d78d243c9c2801c8bf3acd42f2b1dc369819d98a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d78d243c9c2801c8bf3acd42f2b1dc369819d98a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d78d243c9c2801c8bf3acd42f2b1dc369819d98a", "patch": "@@ -2347,6 +2347,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       int unsignedp;\n       int volatilep = 0;\n       tree tem;\n+      int alignment;\n \n       push_temp_slots ();\n       tem = get_inner_reference (to, &bitsize, &bitpos, &offset,\n@@ -2358,6 +2359,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (mode1 == VOIDmode && want_value)\n \ttem = stabilize_reference (tem);\n \n+      alignment = TYPE_ALIGN (TREE_TYPE (tem)) / BITS_PER_UNIT;\n       to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, 0);\n       if (offset != 0)\n \t{\n@@ -2368,6 +2370,14 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  to_rtx = change_address (to_rtx, VOIDmode,\n \t\t\t\t   gen_rtx (PLUS, Pmode, XEXP (to_rtx, 0),\n \t\t\t\t\t    force_reg (Pmode, offset_rtx)));\n+\t  /* If we have a variable offset, the known alignment\n+\t     is only that of the innermost structure containing the field.\n+\t     (Actually, we could sometimes do better by using the\n+\t     align of an element of the innermost array, but no need.)  */\n+\t  if (TREE_CODE (to) == COMPONENT_REF\n+\t      || TREE_CODE (to) == BIT_FIELD_REF)\n+\t    alignment\n+\t      = TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (to, 0))) / BITS_PER_UNIT;\n \t}\n       if (volatilep)\n \t{\n@@ -2388,7 +2398,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t\t\t     : VOIDmode),\n \t\t\t    unsignedp,\n \t\t\t    /* Required alignment of containing datum.  */\n-\t\t\t    TYPE_ALIGN (TREE_TYPE (tem)) / BITS_PER_UNIT,\n+\t\t\t    alignment,\n \t\t\t    int_size_in_bytes (TREE_TYPE (tem)));\n       preserve_temp_slots (result);\n       free_temp_slots ();"}]}