{"sha": "cd8b6dc554e8ca488ec5d3f975250e29b316397c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q4YjZkYzU1NGU4Y2E0ODhlYzVkM2Y5NzUyNTBlMjliMzE2Mzk3Yw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2012-10-01T15:50:09Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2012-10-01T15:50:09Z"}, "message": "re PR target/54087 (__atomic_fetch_add does not use xadd instruction)\n\n\n2012-10-01  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR target/54087\n\t* optabs.c (expand_atomic_fetch_op_no_fallback): New.  Factored code\n\tfrom expand_atomic_fetch_op.\n\t(expand_atomic_fetch_op):  Try atomic_{add|sub} operations in terms of\n\tthe other one if direct opcode fails.\n\t* testsuite/gcc.dg/pr54087.c:  New testcase for atomic_sub -> \n\tatomic_add when atomic_sub fails.\n\nFrom-SVN: r191929", "tree": {"sha": "a9e7aba800558d9f52393d40679b24f9f4b5aa3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9e7aba800558d9f52393d40679b24f9f4b5aa3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd8b6dc554e8ca488ec5d3f975250e29b316397c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8b6dc554e8ca488ec5d3f975250e29b316397c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8b6dc554e8ca488ec5d3f975250e29b316397c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8b6dc554e8ca488ec5d3f975250e29b316397c/comments", "author": null, "committer": null, "parents": [{"sha": "992103ad6991bfbd908d10b18b3fba28196ff7a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992103ad6991bfbd908d10b18b3fba28196ff7a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/992103ad6991bfbd908d10b18b3fba28196ff7a8"}], "stats": {"total": 98, "additions": 94, "deletions": 4}, "files": [{"sha": "9a20ab5e05794b56371bedca4fbefd8ec6671bc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd8b6dc554e8ca488ec5d3f975250e29b316397c", "patch": "@@ -1,3 +1,11 @@\n+2012-10-01  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR target/54087\n+\t* optabs.c (expand_atomic_fetch_op_no_fallback): New.  Factored code\n+\tfrom expand_atomic_fetch_op.\n+\t(expand_atomic_fetch_op):  Try atomic_{add|sub} operations in terms of\n+\tthe other one if direct opcode fails.\n+\n 2012-10-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/54457"}, {"sha": "8a6c6a330b49270385da5eacfa9bb409d7c0e77b", "filename": "gcc/optabs.c", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=cd8b6dc554e8ca488ec5d3f975250e29b316397c", "patch": "@@ -7733,10 +7733,15 @@ maybe_emit_op (const struct atomic_op_functions *optab, rtx target, rtx mem,\n    CODE is the operation being performed (OP)\n    MEMMODEL is the memory model variant to use.\n    AFTER is true to return the result of the operation (OP_fetch).\n-   AFTER is false to return the value before the operation (fetch_OP).  */\n-rtx\n-expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n-\t\t\tenum memmodel model, bool after)\n+   AFTER is false to return the value before the operation (fetch_OP).  \n+\n+   This function will *only* generate instructions if there is a direct\n+   optab. No compare and swap loops or libcalls will be generated. */\n+\n+static rtx\n+expand_atomic_fetch_op_no_fallback (rtx target, rtx mem, rtx val,\n+\t\t\t\t    enum rtx_code code, enum memmodel model,\n+\t\t\t\t    bool after)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   struct atomic_op_functions optab;\n@@ -7809,13 +7814,66 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \t}\n     }\n \n+  /* No direct opcode can be generated.  */\n+  return NULL_RTX;\n+}\n+\n+\n+\n+/* This function expands an atomic fetch_OP or OP_fetch operation:\n+   TARGET is an option place to stick the return value.  const0_rtx indicates\n+   the result is unused. \n+   atomically fetch MEM, perform the operation with VAL and return it to MEM.\n+   CODE is the operation being performed (OP)\n+   MEMMODEL is the memory model variant to use.\n+   AFTER is true to return the result of the operation (OP_fetch).\n+   AFTER is false to return the value before the operation (fetch_OP).  */\n+rtx\n+expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n+\t\t\tenum memmodel model, bool after)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx result;\n+  bool unused_result = (target == const0_rtx);\n+\n+  result = expand_atomic_fetch_op_no_fallback (target, mem, val, code, model,\n+\t\t\t\t\t       after);\n+  \n+  if (result)\n+    return result;\n+\n+  /* Add/sub can be implemented by doing the reverse operation with -(val).  */\n+  if (code == PLUS || code == MINUS)\n+    {\n+      rtx tmp;\n+      enum rtx_code reverse = (code == PLUS ? MINUS : PLUS);\n+\n+      start_sequence ();\n+      tmp = expand_simple_unop (mode, NEG, val, NULL_RTX, true);\n+      result = expand_atomic_fetch_op_no_fallback (target, mem, tmp, reverse,\n+\t\t\t\t\t\t   model, after);\n+      if (result)\n+\t{\n+\t  /* PLUS worked so emit the insns and return.  */\n+\t  tmp = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn (tmp);\n+          return result;\n+\t}\n+\n+      /* PLUS did not work, so throw away the negation code and continue.  */\n+      end_sequence ();\n+    }\n+\n   /* Try the __sync libcalls only if we can't do compare-and-swap inline.  */\n   if (!can_compare_and_swap_p (mode, false))\n     {\n       rtx libfunc;\n       bool fixup = false;\n       enum rtx_code orig_code = code;\n+      struct atomic_op_functions optab;\n \n+      get_atomic_op_for_code (&optab, code);\n       libfunc = optab_libfunc (after ? optab.fetch_after\n \t\t\t       : optab.fetch_before, mode);\n       if (libfunc == NULL"}, {"sha": "dc6956a533b9480767f0587b9b07a55dbea3fb94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd8b6dc554e8ca488ec5d3f975250e29b316397c", "patch": "@@ -1,3 +1,9 @@\n+2012-10-01  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR target/54087\n+\t* gcc.dg/pr54087.c:  New testcase for atomic_sub -> atomic_add when\n+\tatomic_sub fails.\n+\n 2012-10-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/54457"}, {"sha": "abb0af3d9bb36deb7e7c88bf3b4e1f579dbd19b6", "filename": "gcc/testsuite/gcc.dg/pr54087.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr54087.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8b6dc554e8ca488ec5d3f975250e29b316397c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr54087.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr54087.c?ref=cd8b6dc554e8ca488ec5d3f975250e29b316397c", "patch": "@@ -0,0 +1,18 @@\n+/* PR54087.  Verify __atomic_sub (val) uses __atomic_add (-val) if there is no\n+             atomic_aub.  */\n+/* { dg-require-effective-target sync_int_long } */\n+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-assembler-times \"xadd\" 2 } } */\n+\n+\n+int a;\n+\n+int f1(int p)\n+{\n+  return __atomic_sub_fetch(&a, p, __ATOMIC_SEQ_CST) == 0;\n+}\n+\n+int f2(int p)\n+{\n+  return __atomic_fetch_sub(&a, p, __ATOMIC_SEQ_CST) - p == 0;\n+}"}]}