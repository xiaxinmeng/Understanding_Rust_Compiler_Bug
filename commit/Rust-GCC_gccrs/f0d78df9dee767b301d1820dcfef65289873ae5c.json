{"sha": "f0d78df9dee767b301d1820dcfef65289873ae5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBkNzhkZjlkZWU3NjdiMzAxZDE4MjBkY2ZlZjY1Mjg5ODczYWU1Yw==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2014-11-28T12:23:55Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2014-11-28T12:23:55Z"}, "message": "cgraphunit.c (ipa_passes): Handle flag_generate_offload.\n\ngcc/\n\t* cgraphunit.c (ipa_passes): Handle flag_generate_offload.\n\t(symbol_table::compile): Set flag_generate_offload if there is something\n\tto offload.\n\t* common.opt (flag_generate_offload): New Variable declaration.\n\t* dwarf2out.c (dwarf2out_finish): Handle flag_generate_offload.\n\t* ipa-inline-analysis.c (inline_generate_summary): Do not skip if\n\tflag_generate_offload is set.\n\t* lto-streamer.c (gate_lto_out): Handle flag_generate_offload.\n\t* passes.c (ipa_write_summaries): Do not skip if flag_generate_offload\n\tis set.\n\t* toplev.c (compile_file): Emit LTO marker if offload info has been\n\tpreviously emitted.  Do not emit lto_slim marker if\n\tflag_generate_offload is without flag_generate_lto.\n\t* tree.c (free_lang_data): Do not skip if flag_generate_offload is set.\n\nFrom-SVN: r218147", "tree": {"sha": "8ae049e61f4b3c8ed32152bf198318da139f64c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ae049e61f4b3c8ed32152bf198318da139f64c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0d78df9dee767b301d1820dcfef65289873ae5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d78df9dee767b301d1820dcfef65289873ae5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d78df9dee767b301d1820dcfef65289873ae5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d78df9dee767b301d1820dcfef65289873ae5c/comments", "author": null, "committer": null, "parents": [{"sha": "0f4fe89599663cf9759cda1ecb64f0d60733c0cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4fe89599663cf9759cda1ecb64f0d60733c0cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4fe89599663cf9759cda1ecb64f0d60733c0cc"}], "stats": {"total": 68, "additions": 45, "deletions": 23}, "files": [{"sha": "4e6da0cd27996b607b7b4dc04698b63cb2282037", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -1,3 +1,20 @@\n+2014-11-28  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* cgraphunit.c (ipa_passes): Handle flag_generate_offload.\n+\t(symbol_table::compile): Set flag_generate_offload if there is something\n+\tto offload.\n+\t* common.opt (flag_generate_offload): New Variable declaration.\n+\t* dwarf2out.c (dwarf2out_finish): Handle flag_generate_offload.\n+\t* ipa-inline-analysis.c (inline_generate_summary): Do not skip if\n+\tflag_generate_offload is set.\n+\t* lto-streamer.c (gate_lto_out): Handle flag_generate_offload.\n+\t* passes.c (ipa_write_summaries): Do not skip if flag_generate_offload\n+\tis set.\n+\t* toplev.c (compile_file): Emit LTO marker if offload info has been\n+\tpreviously emitted.  Do not emit lto_slim marker if\n+\tflag_generate_offload is without flag_generate_lto.\n+\t* tree.c (free_lang_data): Do not skip if flag_generate_offload is set.\n+\n 2014-11-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm-cores.def (cortex-a17.cortex-a7): New entry."}, {"sha": "fed1a3e0053723fe76579c39580b495283ad55c3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -2075,7 +2075,7 @@ ipa_passes (void)\n     }\n \n   /* Some targets need to handle LTO assembler output specially.  */\n-  if (flag_generate_lto)\n+  if (flag_generate_lto || flag_generate_offload)\n     targetm.asm_out.lto_start ();\n \n   if (!in_lto_p)\n@@ -2092,7 +2092,7 @@ ipa_passes (void)\n \t}\n     }\n \n-  if (flag_generate_lto)\n+  if (flag_generate_lto || flag_generate_offload)\n     targetm.asm_out.lto_end ();\n \n   if (!flag_ltrans && (in_lto_p || !flag_lto || flag_fat_lto_objects))\n@@ -2176,10 +2176,10 @@ symbol_table::compile (void)\n \n   /* Offloading requires LTO infrastructure.  */\n   if (!in_lto_p && g->have_offload)\n-    flag_generate_lto = 1;\n+    flag_generate_offload = 1;\n \n   /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n-  if (flag_generate_lto)\n+  if (flag_generate_lto || flag_generate_offload)\n     lto_streamer_hooks_init ();\n \n   /* Don't run the IPA passes if there was any error or sorry messages.  */"}, {"sha": "752d939ed67f9122589e4c7f2f378fd210f31434", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -67,6 +67,10 @@ int *param_values\n Variable\n int flag_generate_lto\n \n+; Nonzero if we should write GIMPLE bytecode for offload compilation.\n+Variable\n+int flag_generate_offload = 0\n+\n ; True to warn about any objects definitions whose size is larger\n ; than N bytes.  Also want about function definitions whose returned\n ; values are larger than N bytes, where N is 'larger_than_size'."}, {"sha": "ca1e3ef63f019c1a85792d3fb736aa1f25ecdf76", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -24423,7 +24423,8 @@ dwarf2out_finish (const char *filename)\n       /* When generating LTO bytecode we can not generate new assembler\n          names at this point and all important decls got theirs via\n \t free-lang-data.  */\n-      if ((!flag_generate_lto || DECL_ASSEMBLER_NAME_SET_P (decl))\n+      if (((!flag_generate_lto && !flag_generate_offload)\n+\t   || DECL_ASSEMBLER_NAME_SET_P (decl))\n \t  && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n \t{\n \t  add_linkage_attr (node->die, decl);"}, {"sha": "9d62722980999fb4688bf466d76813c99433808b", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -4031,7 +4031,7 @@ inline_generate_summary (void)\n \n   /* When not optimizing, do not bother to analyze.  Inlining is still done\n      because edge redirection needs to happen there.  */\n-  if (!optimize && !flag_generate_lto && !flag_wpa)\n+  if (!optimize && !flag_generate_lto && !flag_generate_offload && !flag_wpa)\n     return;\n \n   function_insertion_hook_holder ="}, {"sha": "af203302243ca137204be1b1427c8ca4f664b4c1", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -328,7 +328,7 @@ lto_streamer_init (void)\n bool\n gate_lto_out (void)\n {\n-  return ((flag_generate_lto || in_lto_p)\n+  return ((flag_generate_lto || flag_generate_offload || in_lto_p)\n \t  /* Don't bother doing anything if the program has errors.  */\n \t  && !seen_error ());\n }"}, {"sha": "74b40e5d80b3ea80ab18d8825d830c54d01b2068", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -2466,7 +2466,7 @@ ipa_write_summaries (bool offload_lto_mode)\n   struct cgraph_node *node;\n   struct cgraph_node **order;\n \n-  if (!flag_generate_lto || seen_error ())\n+  if ((!flag_generate_lto && !flag_generate_offload) || seen_error ())\n     return;\n \n   select_what_to_stream (offload_lto_mode);"}, {"sha": "2f547bfd9510b5c034b5d914d4930b2a6211dab6", "filename": "gcc/toplev.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -639,7 +639,7 @@ compile_file (void)\n      We used to emit an undefined reference here, but this produces\n      link errors if an object file with IL is stored into a shared\n      library without invoking lto1.  */\n-  if (flag_generate_lto)\n+  if (flag_generate_lto || flag_generate_offload)\n     {\n #if defined ASM_OUTPUT_ALIGNED_DECL_COMMON\n       ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, NULL_TREE,\n@@ -653,23 +653,23 @@ compile_file (void)\n \t\t\t (unsigned HOST_WIDE_INT) 1,\n \t\t\t (unsigned HOST_WIDE_INT) 1);\n #endif\n-      /* Let linker plugin know that this is a slim object and must be LTOed\n-         even when user did not ask for it.  */\n-      if (!flag_fat_lto_objects)\n-        {\n+    }\n+\n+  /* Let linker plugin know that this is a slim object and must be LTOed\n+     even when user did not ask for it.  */\n+  if (flag_generate_lto && !flag_fat_lto_objects)\n+    {\n #if defined ASM_OUTPUT_ALIGNED_DECL_COMMON\n-\t  ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, NULL_TREE,\n-\t\t\t\t\t  \"__gnu_lto_slim\",\n-\t\t\t\t\t  (unsigned HOST_WIDE_INT) 1, 8);\n+      ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, NULL_TREE, \"__gnu_lto_slim\",\n+\t\t\t\t      (unsigned HOST_WIDE_INT) 1, 8);\n #elif defined ASM_OUTPUT_ALIGNED_COMMON\n-\t  ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, \"__gnu_lto_slim\",\n-\t\t\t\t     (unsigned HOST_WIDE_INT) 1, 8);\n+      ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, \"__gnu_lto_slim\",\n+\t\t\t\t (unsigned HOST_WIDE_INT) 1, 8);\n #else\n-\t  ASM_OUTPUT_COMMON (asm_out_file, \"__gnu_lto_slim\",\n-\t\t\t     (unsigned HOST_WIDE_INT) 1,\n-\t\t\t     (unsigned HOST_WIDE_INT) 1);\n+      ASM_OUTPUT_COMMON (asm_out_file, \"__gnu_lto_slim\",\n+\t\t\t (unsigned HOST_WIDE_INT) 1,\n+\t\t\t (unsigned HOST_WIDE_INT) 1);\n #endif\n-        }\n     }\n \n   /* Attach a special .ident directive to the end of the file to identify"}, {"sha": "f6a6d04a14ac8436fb1834c49229c6ade6d6a463", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d78df9dee767b301d1820dcfef65289873ae5c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f0d78df9dee767b301d1820dcfef65289873ae5c", "patch": "@@ -5730,7 +5730,7 @@ free_lang_data (void)\n \n   /* If we are the LTO frontend we have freed lang-specific data already.  */\n   if (in_lto_p\n-      || !flag_generate_lto)\n+      || (!flag_generate_lto && !flag_generate_offload))\n     return 0;\n \n   /* Allocate and assign alias sets to the standard integer types"}]}