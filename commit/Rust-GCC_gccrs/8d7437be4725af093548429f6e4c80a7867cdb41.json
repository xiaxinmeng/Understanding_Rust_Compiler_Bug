{"sha": "8d7437be4725af093548429f6e4c80a7867cdb41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ3NDM3YmU0NzI1YWYwOTM1NDg0MjlmNmU0YzgwYTc4NjdjZGI0MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-03-16T19:21:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-03-16T19:21:23Z"}, "message": "re PR tree-optimization/71437 (Performance regression after r235817)\n\n\tPR tree-optimization/71437\n\t* tree-ssa-dom.c (pfn_simplify): Add basic_block argument.  All\n\tcallers changed.\n\t(simplify_stmt_for_jump_threading): Add basic_block argument.  All\n\tcallers changed.\n\t(lhs_of_dominating_assert): Moved from here into tree-vrp.c.\n\t(dom_opt_dom_walker::thread_across_edge): Remove\n\thandle_dominating_asserts argument.  All callers changed.\n\t(record_temporary_equivalences_from_stmts_at_dest): Corresponding\n\tchanges.  Remove calls to lhs_of_dominating_assert.  Other\n\tuses of handle_dominating_asserts turn into unconditional code\n\t(simplify_control_stmt_condition_1): Likewise.\n\t(simplify_control_stmt_condition): Likewise.\n\t(thread_through_normal_block, thread_across_edge): Likewise.\n\t* tree-ssa-threadedge.h (thread_across_edge): Corresponding changes.\n\t* tree-vrp.c (lhs_of_dominating_assert): Move here.  Return original\n\tobject if it is not an SSA_NAME.\n\t(simplify_stmt_for_jump_threading): Call lhs_of_dominating_assert\n\tbefore calling into the VRP specific simplifiers.\n\t(identify_jump_threads): Remove handle_dominating_asserts\n\targument.\n\nFrom-SVN: r246207", "tree": {"sha": "e61e028074af01a48111ce51857df9f8bfae080a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e61e028074af01a48111ce51857df9f8bfae080a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d7437be4725af093548429f6e4c80a7867cdb41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d7437be4725af093548429f6e4c80a7867cdb41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d7437be4725af093548429f6e4c80a7867cdb41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d7437be4725af093548429f6e4c80a7867cdb41/comments", "author": null, "committer": null, "parents": [{"sha": "9fc900af68527b00d67f11f897e1fe77a176bee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc900af68527b00d67f11f897e1fe77a176bee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc900af68527b00d67f11f897e1fe77a176bee2"}], "stats": {"total": 191, "additions": 93, "deletions": 98}, "files": [{"sha": "c8e5bdc7826172e58f98a381ed666830d07bbc51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d7437be4725af093548429f6e4c80a7867cdb41", "patch": "@@ -1,3 +1,27 @@\n+2017-03-16  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/71437\n+\t* tree-ssa-dom.c (pfn_simplify): Add basic_block argument.  All\n+\tcallers changed.\n+\t(simplify_stmt_for_jump_threading): Add basic_block argument.  All\n+\tcallers changed.\n+\t(lhs_of_dominating_assert): Moved from here into tree-vrp.c.\n+\t(dom_opt_dom_walker::thread_across_edge): Remove \n+\thandle_dominating_asserts argument.  All callers changed.\n+\t(record_temporary_equivalences_from_stmts_at_dest): Corresponding\n+\tchanges.  Remove calls to lhs_of_dominating_assert.  Other\n+\tuses of handle_dominating_asserts turn into unconditional code\n+\t(simplify_control_stmt_condition_1): Likewise.\n+\t(simplify_control_stmt_condition): Likewise.\n+\t(thread_through_normal_block, thread_across_edge): Likewise.\n+\t* tree-ssa-threadedge.h (thread_across_edge): Corresponding changes.\n+\t* tree-vrp.c (lhs_of_dominating_assert): Move here.  Return original\n+\tobject if it is not an SSA_NAME.\n+\t(simplify_stmt_for_jump_threading): Call lhs_of_dominating_assert\n+\tbefore calling into the VRP specific simplifiers.\n+\t(identify_jump_threads): Remove handle_dominating_asserts\n+\targument.\n+\n 2017-03-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/79886"}, {"sha": "32468e947778e0e653b44c33ca2bcb062788d3e2", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=8d7437be4725af093548429f6e4c80a7867cdb41", "patch": "@@ -604,7 +604,8 @@ make_pass_dominator (gcc::context *ctxt)\n static tree\n simplify_stmt_for_jump_threading (gimple *stmt,\n \t\t\t\t  gimple *within_stmt ATTRIBUTE_UNUSED,\n-\t\t\t\t  class avail_exprs_stack *avail_exprs_stack)\n+\t\t\t\t  class avail_exprs_stack *avail_exprs_stack,\n+\t\t\t\t  basic_block bb ATTRIBUTE_UNUSED)\n {\n   return avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n }\n@@ -835,7 +836,7 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n \n   /* With all the edge equivalences in the tables, go ahead and attempt\n      to thread through E->dest.  */\n-  ::thread_across_edge (m_dummy_cond, e, false,\n+  ::thread_across_edge (m_dummy_cond, e,\n \t\t        m_const_and_copies, m_avail_exprs_stack,\n \t\t        simplify_stmt_for_jump_threading);\n "}, {"sha": "7f70b40fd0c779c8aaa8d6aeee360638fc745062", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 22, "deletions": 88, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=8d7437be4725af093548429f6e4c80a7867cdb41", "patch": "@@ -47,7 +47,9 @@ static int stmt_count;\n /* Array to record value-handles per SSA_NAME.  */\n vec<tree> ssa_name_values;\n \n-typedef tree (pfn_simplify) (gimple *, gimple *, class avail_exprs_stack *);\n+typedef tree (pfn_simplify) (gimple *, gimple *,\n+\t\t\t     class avail_exprs_stack *,\n+\t\t\t     basic_block);\n \n /* Set the value for the SSA name NAME to VALUE.  */\n \n@@ -111,32 +113,6 @@ potentially_threadable_block (basic_block bb)\n   return true;\n }\n \n-/* Return the LHS of any ASSERT_EXPR where OP appears as the first\n-   argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n-   BB.  If no such ASSERT_EXPR is found, return OP.  */\n-\n-static tree\n-lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)\n-{\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n-  use_operand_p use_p;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)\n-    {\n-      use_stmt = USE_STMT (use_p);\n-      if (use_stmt != stmt\n-          && gimple_assign_single_p (use_stmt)\n-          && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ASSERT_EXPR\n-          && TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == op\n-\t  && dominated_by_p (CDI_DOMINATORS, bb, gimple_bb (use_stmt)))\n-\t{\n-\t  return gimple_assign_lhs (use_stmt);\n-\t}\n-    }\n-  return op;\n-}\n-\n /* Record temporary equivalences created by PHIs at the target of the\n    edge E.  Record unwind information for the equivalences onto STACK.\n \n@@ -357,7 +333,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t\t    SET_USE (use_p, tmp);\n \t\t}\n \n-\t      cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n+\t      cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack, e->src);\n \n \t      /* Restore the statement's original uses/defs.  */\n \t      i = 0;\n@@ -380,7 +356,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n static tree simplify_control_stmt_condition_1 (edge, gimple *,\n \t\t\t\t\t       class avail_exprs_stack *,\n \t\t\t\t\t       tree, enum tree_code, tree,\n-\t\t\t\t\t       gcond *, pfn_simplify, bool,\n+\t\t\t\t\t       gcond *, pfn_simplify,\n \t\t\t\t\t       unsigned);\n \n /* Simplify the control statement at the end of the block E->dest.\n@@ -402,8 +378,7 @@ simplify_control_stmt_condition (edge e,\n \t\t\t\t gimple *stmt,\n \t\t\t\t class avail_exprs_stack *avail_exprs_stack,\n \t\t\t\t gcond *dummy_cond,\n-\t\t\t\t pfn_simplify simplify,\n-\t\t\t\t bool handle_dominating_asserts)\n+\t\t\t\t pfn_simplify simplify)\n {\n   tree cond, cached_lhs;\n   enum gimple_code code = gimple_code (stmt);\n@@ -450,7 +425,6 @@ simplify_control_stmt_condition (edge e,\n \t= simplify_control_stmt_condition_1 (e, stmt, avail_exprs_stack,\n \t\t\t\t\t     op0, cond_code, op1,\n \t\t\t\t\t     dummy_cond, simplify,\n-\t\t\t\t\t     handle_dominating_asserts,\n \t\t\t\t\t     recursion_limit);\n \n       /* If we were testing an integer/pointer against a constant, then\n@@ -508,28 +482,24 @@ simplify_control_stmt_condition (edge e,\n \t    }\n \t}\n \n-      /* If we're dominated by a suitable ASSERT_EXPR, then\n-\t update CACHED_LHS appropriately.  */\n-      if (handle_dominating_asserts && TREE_CODE (cached_lhs) == SSA_NAME)\n-\tcached_lhs = lhs_of_dominating_assert (cached_lhs, e->src, stmt);\n-\n       /* If we haven't simplified to an invariant yet, then use the\n \t pass specific callback to try and simplify it further.  */\n       if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n \t{\n-\t  if (handle_dominating_asserts && code == GIMPLE_SWITCH)\n+\t  if (code == GIMPLE_SWITCH)\n \t    {\n-\t      /* Replace the index operand of the GIMPLE_SWITCH with the\n-\t\t dominating ASSERT_EXPR before handing it off to VRP.  If\n-\t\t simplification is possible, the simplified value will be a\n-\t\t CASE_LABEL_EXPR of the label that is proven to be taken.  */\n+\t      /* Replace the index operand of the GIMPLE_SWITCH with any LHS\n+\t\t we found before handing off to VRP.  If simplification is\n+\t         possible, the simplified value will be a CASE_LABEL_EXPR of\n+\t\t the label that is proven to be taken.  */\n \t      gswitch *dummy_switch = as_a<gswitch *> (gimple_copy (stmt));\n \t      gimple_switch_set_index (dummy_switch, cached_lhs);\n-\t      cached_lhs = (*simplify) (dummy_switch, stmt, avail_exprs_stack);\n+\t      cached_lhs = (*simplify) (dummy_switch, stmt,\n+\t\t\t\t\tavail_exprs_stack, e->src);\n \t      ggc_free (dummy_switch);\n \t    }\n \t  else\n-\t    cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n+\t    cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack, e->src);\n \t}\n \n       /* We couldn't find an invariant.  But, callers of this\n@@ -555,7 +525,6 @@ simplify_control_stmt_condition_1 (edge e,\n \t\t\t\t   tree op1,\n \t\t\t\t   gcond *dummy_cond,\n \t\t\t\t   pfn_simplify simplify,\n-\t\t\t\t   bool handle_dominating_asserts,\n \t\t\t\t   unsigned limit)\n {\n   if (limit == 0)\n@@ -575,8 +544,7 @@ simplify_control_stmt_condition_1 (edge e,\n      recurse into the LHS to see if there is a dominating ASSERT_EXPR\n      of A or of B that makes this condition always true or always false\n      along the edge E.  */\n-  if (handle_dominating_asserts\n-      && (cond_code == EQ_EXPR || cond_code == NE_EXPR)\n+  if ((cond_code == EQ_EXPR || cond_code == NE_EXPR)\n       && TREE_CODE (op0) == SSA_NAME\n       && integer_zerop (op1))\n     {\n@@ -595,7 +563,6 @@ simplify_control_stmt_condition_1 (edge e,\n \t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n \t\t\t\t\t\t rhs1, NE_EXPR, op1,\n \t\t\t\t\t\t dummy_cond, simplify,\n-\t\t\t\t\t\t handle_dominating_asserts,\n \t\t\t\t\t\t limit - 1);\n \t  if (res1 == NULL_TREE)\n \t    ;\n@@ -623,7 +590,6 @@ simplify_control_stmt_condition_1 (edge e,\n \t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n \t\t\t\t\t\t rhs2, NE_EXPR, op1,\n \t\t\t\t\t\t dummy_cond, simplify,\n-\t\t\t\t\t\t handle_dominating_asserts,\n \t\t\t\t\t\t limit - 1);\n \t  if (res2 == NULL_TREE)\n \t    ;\n@@ -689,25 +655,12 @@ simplify_control_stmt_condition_1 (edge e,\n \t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n \t\t\t\t\t\t rhs1, new_cond, rhs2,\n \t\t\t\t\t\t dummy_cond, simplify,\n-\t\t\t\t\t\t handle_dominating_asserts,\n \t\t\t\t\t\t limit - 1);\n \t  if (res != NULL_TREE && is_gimple_min_invariant (res))\n \t    return res;\n \t}\n     }\n \n-  if (handle_dominating_asserts)\n-    {\n-      /* Now see if the operand was consumed by an ASSERT_EXPR\n-\t which dominates E->src.  If so, we want to replace the\n-\t operand with the LHS of the ASSERT_EXPR.  */\n-      if (TREE_CODE (op0) == SSA_NAME)\n-\top0 = lhs_of_dominating_assert (op0, e->src, stmt);\n-\n-      if (TREE_CODE (op1) == SSA_NAME)\n-\top1 = lhs_of_dominating_assert (op1, e->src, stmt);\n-    }\n-\n   gimple_cond_set_code (dummy_cond, cond_code);\n   gimple_cond_set_lhs (dummy_cond, op0);\n   gimple_cond_set_rhs (dummy_cond, op1);\n@@ -728,7 +681,7 @@ simplify_control_stmt_condition_1 (edge e,\n      then use the pass specific callback to simplify the condition.  */\n   if (!res\n       || !is_gimple_min_invariant (res))\n-    res = (*simplify) (dummy_cond, stmt, avail_exprs_stack);\n+    res = (*simplify) (dummy_cond, stmt, avail_exprs_stack, e->src);\n \n   return res;\n }\n@@ -868,16 +821,15 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n    returning TRUE from the toplevel call.   Otherwise do nothing and\n    return false.\n \n-   DUMMY_COND, HANDLE_DOMINATING_ASSERTS and SIMPLIFY are used to\n-   try and simplify the condition at the end of TAKEN_EDGE->dest.\n+   DUMMY_COND, SIMPLIFY are used to try and simplify the condition at the\n+   end of TAKEN_EDGE->dest.\n \n    The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n \n static bool\n thread_around_empty_blocks (edge taken_edge,\n \t\t\t    gcond *dummy_cond,\n \t\t\t    class avail_exprs_stack *avail_exprs_stack,\n-\t\t\t    bool handle_dominating_asserts,\n \t\t\t    pfn_simplify simplify,\n \t\t\t    bitmap visited,\n \t\t\t    vec<jump_thread_edge *> *path)\n@@ -928,7 +880,6 @@ thread_around_empty_blocks (edge taken_edge,\n \t      return thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t\t dummy_cond,\n \t\t\t\t\t\t avail_exprs_stack,\n-\t\t\t\t\t\t handle_dominating_asserts,\n \t\t\t\t\t\t simplify,\n \t\t\t\t\t\t visited,\n \t\t\t\t\t\t path);\n@@ -950,7 +901,7 @@ thread_around_empty_blocks (edge taken_edge,\n   /* Extract and simplify the condition.  */\n   cond = simplify_control_stmt_condition (taken_edge, stmt,\n \t\t\t\t\t  avail_exprs_stack, dummy_cond,\n-\t\t\t\t\t  simplify, handle_dominating_asserts);\n+\t\t\t\t\t  simplify);\n \n   /* If the condition can be statically computed and we have not already\n      visited the destination edge, then add the taken edge to our thread\n@@ -978,7 +929,6 @@ thread_around_empty_blocks (edge taken_edge,\n       thread_around_empty_blocks (taken_edge,\n \t\t\t\t  dummy_cond,\n \t\t\t\t  avail_exprs_stack,\n-\t\t\t\t  handle_dominating_asserts,\n \t\t\t\t  simplify,\n \t\t\t\t  visited,\n \t\t\t\t  path);\n@@ -1004,10 +954,6 @@ thread_around_empty_blocks (edge taken_edge,\n    DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n    to avoid allocating memory.\n \n-   HANDLE_DOMINATING_ASSERTS is true if we should try to replace operands of\n-   the simplified condition with left-hand sides of ASSERT_EXPRs they are\n-   used in.\n-\n    STACK is used to undo temporary equivalences created during the walk of\n    E->dest.\n \n@@ -1024,16 +970,14 @@ thread_around_empty_blocks (edge taken_edge,\n static int\n thread_through_normal_block (edge e,\n \t\t\t     gcond *dummy_cond,\n-\t\t\t     bool handle_dominating_asserts,\n \t\t\t     const_and_copies *const_and_copies,\n \t\t\t     avail_exprs_stack *avail_exprs_stack,\n \t\t\t     pfn_simplify simplify,\n \t\t\t     vec<jump_thread_edge *> *path,\n \t\t\t     bitmap visited)\n {\n   /* We want to record any equivalences created by traversing E.  */\n-  if (!handle_dominating_asserts)\n-    record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);\n+  record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);\n \n   /* PHIs create temporary equivalences.\n      Note that if we found a PHI that made the block non-threadable, then\n@@ -1085,8 +1029,7 @@ thread_through_normal_block (edge e,\n \n       /* Extract and simplify the condition.  */\n       cond = simplify_control_stmt_condition (e, stmt, avail_exprs_stack,\n-\t\t\t\t\t      dummy_cond, simplify,\n-\t\t\t\t\t      handle_dominating_asserts);\n+\t\t\t\t\t      dummy_cond, simplify);\n \n       if (!cond)\n \treturn 0;\n@@ -1135,7 +1078,6 @@ thread_through_normal_block (edge e,\n \t  thread_around_empty_blocks (taken_edge,\n \t\t\t\t      dummy_cond,\n \t\t\t\t      avail_exprs_stack,\n-\t\t\t\t      handle_dominating_asserts,\n \t\t\t\t      simplify,\n \t\t\t\t      visited,\n \t\t\t\t      path);\n@@ -1151,10 +1093,6 @@ thread_through_normal_block (edge e,\n    DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n    to avoid allocating memory.\n \n-   HANDLE_DOMINATING_ASSERTS is true if we should try to replace operands of\n-   the simplified condition with left-hand sides of ASSERT_EXPRs they are\n-   used in.\n-\n    CONST_AND_COPIES is used to undo temporary equivalences created during the\n    walk of E->dest.\n \n@@ -1165,11 +1103,10 @@ thread_through_normal_block (edge e,\n void\n thread_across_edge (gcond *dummy_cond,\n \t\t    edge e,\n-\t\t    bool handle_dominating_asserts,\n \t\t    class const_and_copies *const_and_copies,\n \t\t    class avail_exprs_stack *avail_exprs_stack,\n \t\t    tree (*simplify) (gimple *, gimple *,\n-\t\t\t\t      class avail_exprs_stack *))\n+\t\t\t\t      class avail_exprs_stack *, basic_block))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n \n@@ -1183,7 +1120,6 @@ thread_across_edge (gcond *dummy_cond,\n   int threaded;\n   if ((e->flags & EDGE_DFS_BACK) == 0)\n     threaded = thread_through_normal_block (e, dummy_cond,\n-\t\t\t\t\t    handle_dominating_asserts,\n \t\t\t\t\t    const_and_copies,\n \t\t\t\t\t    avail_exprs_stack,\n \t\t\t\t\t    simplify, path,\n@@ -1281,14 +1217,12 @@ thread_across_edge (gcond *dummy_cond,\n \tfound = thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t    dummy_cond,\n \t\t\t\t\t    avail_exprs_stack,\n-\t\t\t\t\t    handle_dominating_asserts,\n \t\t\t\t\t    simplify,\n \t\t\t\t\t    visited,\n \t\t\t\t\t    path);\n \n \tif (!found)\n \t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n-\t\t\t\t\t       handle_dominating_asserts,\n \t\t\t\t\t       const_and_copies,\n \t\t\t\t\t       avail_exprs_stack,\n \t\t\t\t\t       simplify, path,"}, {"sha": "3516f1494852db74e3ee8a5961899898e3063516", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=8d7437be4725af093548429f6e4c80a7867cdb41", "patch": "@@ -30,10 +30,10 @@ extern void threadedge_initialize_values (void);\n extern void threadedge_finalize_values (void);\n extern bool potentially_threadable_block (basic_block);\n extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n-extern void thread_across_edge (gcond *, edge, bool,\n+extern void thread_across_edge (gcond *, edge,\n \t\t\t\tconst_and_copies *,\n \t\t\t\tavail_exprs_stack *,\n \t\t\t\ttree (*) (gimple *, gimple *,\n-\t\t\t\t\t  avail_exprs_stack *));\n+\t\t\t\t\t  avail_exprs_stack *, basic_block));\n \n #endif /* GCC_TREE_SSA_THREADEDGE_H */"}, {"sha": "82ef74261e46393304711bfe59434f0fdc7adae4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7437be4725af093548429f6e4c80a7867cdb41/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8d7437be4725af093548429f6e4c80a7867cdb41", "patch": "@@ -10749,20 +10749,54 @@ vrp_fold_stmt (gimple_stmt_iterator *si)\n /* Unwindable const/copy equivalences.  */\n const_and_copies *equiv_stack;\n \n+/* Return the LHS of any ASSERT_EXPR where OP appears as the first\n+   argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n+   BB.  If no such ASSERT_EXPR is found, return OP.  */\n+\n+static tree\n+lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)\n+{\n+  imm_use_iterator imm_iter;\n+  gimple *use_stmt;\n+  use_operand_p use_p;\n+\n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)\n+\t{\n+\t  use_stmt = USE_STMT (use_p);\n+\t  if (use_stmt != stmt\n+\t      && gimple_assign_single_p (use_stmt)\n+\t      && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ASSERT_EXPR\n+\t      && TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == op\n+\t      && dominated_by_p (CDI_DOMINATORS, bb, gimple_bb (use_stmt)))\n+\t    return gimple_assign_lhs (use_stmt);\n+\t}\n+    }\n+  return op;\n+}\n+\n /* A trivial wrapper so that we can present the generic jump threading\n    code with a simple API for simplifying statements.  STMT is the\n    statement we want to simplify, WITHIN_STMT provides the location\n    for any overflow warnings.  */\n \n static tree\n simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n-    class avail_exprs_stack *avail_exprs_stack ATTRIBUTE_UNUSED)\n+    class avail_exprs_stack *avail_exprs_stack ATTRIBUTE_UNUSED,\n+    basic_block bb)\n {\n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    return vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t     gimple_cond_lhs (cond_stmt),\n-\t\t\t\t     gimple_cond_rhs (cond_stmt),\n-\t\t\t\t     within_stmt);\n+    {\n+      tree op0 = gimple_cond_lhs (cond_stmt);\n+      op0 = lhs_of_dominating_assert (op0, bb, stmt);\n+\n+      tree op1 = gimple_cond_rhs (cond_stmt);\n+      op1 = lhs_of_dominating_assert (op1, bb, stmt);\n+\n+      return vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t       op0, op1, within_stmt);\n+    }\n \n   /* We simplify a switch statement by trying to determine which case label\n      will be taken.  If we are successful then we return the corresponding\n@@ -10773,6 +10807,8 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n       if (TREE_CODE (op) != SSA_NAME)\n \treturn NULL_TREE;\n \n+      op = lhs_of_dominating_assert (op, bb, stmt);\n+\n       value_range *vr = get_value_range (op);\n       if ((vr->type != VR_RANGE && vr->type != VR_ANTI_RANGE)\n \t  || symbolic_range_p (vr))\n@@ -10948,7 +10984,7 @@ identify_jump_threads (void)\n \t      if (e->flags & (EDGE_IGNORE | EDGE_COMPLEX))\n \t\tcontinue;\n \n-\t      thread_across_edge (dummy, e, true, equiv_stack, NULL,\n+\t      thread_across_edge (dummy, e, equiv_stack, NULL,\n \t\t\t\t  simplify_stmt_for_jump_threading);\n \t    }\n \t}"}]}