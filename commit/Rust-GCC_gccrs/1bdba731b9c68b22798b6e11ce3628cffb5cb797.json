{"sha": "1bdba731b9c68b22798b6e11ce3628cffb5cb797", "node_id": "C_kwDOANBUbNoAKDFiZGJhNzMxYjljNjhiMjI3OThiNmUxMWNlMzYyOGNmZmI1Y2I3OTc", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-12-10T01:44:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-12-10T01:45:20Z"}, "message": "libbacktrace: rewrite and simplify main zstd loop\n\n\t* elf.c (ZSTD_TABLE_*): Use elf_zstd_fse_baseline_entry.\n\t(ZSTD_ENCODE_BASELINE_BITS): Define.\n\t(ZSTD_DECODE_BASELINE, ZSTD_DECODE_BASEBITS): Define.\n\t(elf_zstd_literal_length_base): New static const array.\n\t(elf_zstd_match_length_base): Likewise.\n\t(struct elf_zstd_fse_baseline_entry): Define.\n\t(elf_zstd_make_literal_baseline_fse): New static function.\n\t(elf_zstd_make_offset_baseline_fse): Likewise.\n\t(elf_zstd_make_match_baseline_fse): Likewise.\n\t(print_table, main): Use elf_zstd_fse_baseline_entry.\n\t(elf_zstd_lit_table, elf_zstd_match_table): Likewise.\n\t(elf_zstd_offset_table): Likewise.\n\t(struct elf_zstd_seq_decode): Likewise.  Remove use_rle and rle\n\tfields.\n\t(elf_zstd_unpack_seq_decode): Use elf_zstd_fse_baseline_entry,\n\ttaking a conversion function.  Convert RLE to FSE.\n\t(elf_zstd_literal_length_baseline): Remove.\n\t(elf_zstd_literal_length_bits): Remove.\n\t(elf_zstd_match_length_baseline): Remove.\n\t(elf_zstd_match_length_bits): Remove.\n\t(elf_zstd_decompress): Use elf_zstd_fse_baseline_entry.  Rewrite\n\tand simplify main loop.", "tree": {"sha": "d2253f1892a75352d1c5b4be15d9462f4c991c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2253f1892a75352d1c5b4be15d9462f4c991c3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bdba731b9c68b22798b6e11ce3628cffb5cb797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bdba731b9c68b22798b6e11ce3628cffb5cb797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bdba731b9c68b22798b6e11ce3628cffb5cb797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bdba731b9c68b22798b6e11ce3628cffb5cb797/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ce6485f3682c0eb1df4a00c31e371616c72dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ce6485f3682c0eb1df4a00c31e371616c72dd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40ce6485f3682c0eb1df4a00c31e371616c72dd4"}], "stats": {"total": 948, "additions": 592, "deletions": 356}, "files": [{"sha": "ece02db27f124f8fbeebfb544acb66b05e72cbd4", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 592, "deletions": 356, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bdba731b9c68b22798b6e11ce3628cffb5cb797/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bdba731b9c68b22798b6e11ce3628cffb5cb797/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=1bdba731b9c68b22798b6e11ce3628cffb5cb797", "patch": "@@ -2610,31 +2610,34 @@ elf_zlib_inflate_and_verify (const unsigned char *pin, size_t sin,\n }\n \n /* For working memory during zstd compression, we need\n-   - a literal length FSE table: 512 32-bit values == 2048 bytes\n-   - a match length FSE table: 512 32-bit values == 2048 bytes\n-   - a offset FSE table: 256 32-bit values == 1024 bytes\n+   - a literal length FSE table: 512 64-bit values == 4096 bytes\n+   - a match length FSE table: 512 64-bit values == 4096 bytes\n+   - a offset FSE table: 256 64-bit values == 2048 bytes\n    - a Huffman tree: 2048 uint16_t values == 4096 bytes\n    - scratch space, one of\n      - to build an FSE table: 512 uint16_t values == 1024 bytes\n      - to build a Huffman tree: 512 uint16_t + 256 uint32_t == 2048 bytes\n      - buffer for literal values == 2048 bytes\n */\n \n-#define ZSTD_TABLE_SIZE\t\t\t\t\\\n-  (2 * 512 * sizeof (struct elf_zstd_fse_entry)\t\\\n-   + 256 * sizeof (struct elf_zstd_fse_entry)\t\\\n-   + 2048 * sizeof (uint16_t)\t\t\t\\\n+#define ZSTD_TABLE_SIZE\t\t\t\t\t\\\n+  (2 * 512 * sizeof (struct elf_zstd_fse_baseline_entry)\t\\\n+   + 256 * sizeof (struct elf_zstd_fse_baseline_entry)\t\t\\\n+   + 2048 * sizeof (uint16_t)\t\t\t\t\t\\\n    + 2048)\n \n #define ZSTD_TABLE_LITERAL_FSE_OFFSET (0)\n \n-#define ZSTD_TABLE_MATCH_FSE_OFFSET (512 * sizeof (struct elf_zstd_fse_entry))\n+#define ZSTD_TABLE_MATCH_FSE_OFFSET\t\t\t\\\n+  (512 * sizeof (struct elf_zstd_fse_baseline_entry))\n \n-#define ZSTD_TABLE_OFFSET_FSE_OFFSET \\\n-  (ZSTD_TABLE_MATCH_FSE_OFFSET + 512 * sizeof (struct elf_zstd_fse_entry))\n+#define ZSTD_TABLE_OFFSET_FSE_OFFSET\t\t\t\\\n+  (ZSTD_TABLE_MATCH_FSE_OFFSET\t\t\t\t\\\n+   + 512 * sizeof (struct elf_zstd_fse_baseline_entry))\n \n-#define ZSTD_TABLE_HUFFMAN_OFFSET \\\n-  (ZSTD_TABLE_OFFSET_FSE_OFFSET + 256 * sizeof (struct elf_zstd_fse_entry))\n+#define ZSTD_TABLE_HUFFMAN_OFFSET\t\t\t\t\t\\\n+  (ZSTD_TABLE_OFFSET_FSE_OFFSET\t\t\t\t\t\t\\\n+   + 256 * sizeof (struct elf_zstd_fse_baseline_entry))\n \n #define ZSTD_TABLE_WORK_OFFSET \\\n   (ZSTD_TABLE_HUFFMAN_OFFSET + 2048 * sizeof (uint16_t))\n@@ -2645,8 +2648,11 @@ elf_zlib_inflate_and_verify (const unsigned char *pin, size_t sin,\n \n struct elf_zstd_fse_entry\n {\n+  /* The value that this FSE entry represents.  */\n   unsigned char symbol;\n+  /* The number of bits to read to determine the next state.  */\n   unsigned char bits;\n+  /* Add the bits to this base to get the next state.  */\n   uint16_t base;\n };\n \n@@ -2925,6 +2931,270 @@ elf_zstd_build_fse (const int16_t *norm, int idx, uint16_t *next,\n   return 1;\n }\n \n+/* Encode the baseline and bits into a single 32-bit value.  */\n+\n+#define ZSTD_ENCODE_BASELINE_BITS(baseline, basebits)\t\\\n+  ((uint32_t)(baseline) | ((uint32_t)(basebits) << 24))\n+\n+#define ZSTD_DECODE_BASELINE(baseline_basebits)\t\\\n+  ((uint32_t)(baseline_basebits) & 0xffffff)\n+\n+#define ZSTD_DECODE_BASEBITS(baseline_basebits)\t\\\n+  ((uint32_t)(baseline_basebits) >> 24)\n+\n+/* Given a literal length code, we need to read a number of bits and add that\n+   to a baseline.  For states 0 to 15 the baseline is the state and the number\n+   of bits is zero.  */\n+\n+#define ZSTD_LITERAL_LENGTH_BASELINE_OFFSET (16)\n+\n+static const uint32_t elf_zstd_literal_length_base[] =\n+{\n+  ZSTD_ENCODE_BASELINE_BITS(16, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(18, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(20, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(22, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(24, 2),\n+  ZSTD_ENCODE_BASELINE_BITS(28, 2),\n+  ZSTD_ENCODE_BASELINE_BITS(32, 3),\n+  ZSTD_ENCODE_BASELINE_BITS(40, 3),\n+  ZSTD_ENCODE_BASELINE_BITS(48, 4),\n+  ZSTD_ENCODE_BASELINE_BITS(64, 6),\n+  ZSTD_ENCODE_BASELINE_BITS(128, 7),\n+  ZSTD_ENCODE_BASELINE_BITS(256, 8),\n+  ZSTD_ENCODE_BASELINE_BITS(512, 9),\n+  ZSTD_ENCODE_BASELINE_BITS(1024, 10),\n+  ZSTD_ENCODE_BASELINE_BITS(2048, 11),\n+  ZSTD_ENCODE_BASELINE_BITS(4096, 12),\n+  ZSTD_ENCODE_BASELINE_BITS(8192, 13),\n+  ZSTD_ENCODE_BASELINE_BITS(16384, 14),\n+  ZSTD_ENCODE_BASELINE_BITS(32768, 15),\n+  ZSTD_ENCODE_BASELINE_BITS(65536, 16)\n+};\n+\n+/* The same applies to match length codes.  For states 0 to 31 the baseline is\n+   the state + 3 and the number of bits is zero.  */\n+\n+#define ZSTD_MATCH_LENGTH_BASELINE_OFFSET (32)\n+\n+static const uint32_t elf_zstd_match_length_base[] =\n+{\n+  ZSTD_ENCODE_BASELINE_BITS(35, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(37, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(39, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(41, 1),\n+  ZSTD_ENCODE_BASELINE_BITS(43, 2),\n+  ZSTD_ENCODE_BASELINE_BITS(47, 2),\n+  ZSTD_ENCODE_BASELINE_BITS(51, 3),\n+  ZSTD_ENCODE_BASELINE_BITS(59, 3),\n+  ZSTD_ENCODE_BASELINE_BITS(67, 4),\n+  ZSTD_ENCODE_BASELINE_BITS(83, 4),\n+  ZSTD_ENCODE_BASELINE_BITS(99, 5),\n+  ZSTD_ENCODE_BASELINE_BITS(131, 7),\n+  ZSTD_ENCODE_BASELINE_BITS(259, 8),\n+  ZSTD_ENCODE_BASELINE_BITS(515, 9),\n+  ZSTD_ENCODE_BASELINE_BITS(1027, 10),\n+  ZSTD_ENCODE_BASELINE_BITS(2051, 11),\n+  ZSTD_ENCODE_BASELINE_BITS(4099, 12),\n+  ZSTD_ENCODE_BASELINE_BITS(8195, 13),\n+  ZSTD_ENCODE_BASELINE_BITS(16387, 14),\n+  ZSTD_ENCODE_BASELINE_BITS(32771, 15),\n+  ZSTD_ENCODE_BASELINE_BITS(65539, 16)\n+};\n+\n+/* An entry in an FSE table used for literal/match/length values.  For these we\n+   have to map the symbol to a baseline value, and we have to read zero or more\n+   bits and add that value to the baseline value.  Rather than look the values\n+   up in a separate table, we grow the FSE table so that we get better memory\n+   caching.  */\n+\n+struct elf_zstd_fse_baseline_entry\n+{\n+  /* The baseline for the value that this FSE entry represents..  */\n+  uint32_t baseline;\n+  /* The number of bits to read to add to the baseline.  */\n+  unsigned char basebits;\n+  /* The number of bits to read to determine the next state.  */\n+  unsigned char bits;\n+  /* Add the bits to this base to get the next state.  */\n+  uint16_t base;\n+};\n+\n+/* Convert the literal length FSE table FSE_TABLE to an FSE baseline table at\n+   BASELINE_TABLE.  Note that FSE_TABLE and BASELINE_TABLE will overlap.  */\n+\n+static int\n+elf_zstd_make_literal_baseline_fse (\n+    const struct elf_zstd_fse_entry *fse_table,\n+    int table_bits,\n+    struct elf_zstd_fse_baseline_entry *baseline_table)\n+{\n+  size_t count;\n+  const struct elf_zstd_fse_entry *pfse;\n+  struct elf_zstd_fse_baseline_entry *pbaseline;\n+\n+  /* Convert backward to avoid overlap.  */\n+\n+  count = 1U << table_bits;\n+  pfse = fse_table + count;\n+  pbaseline = baseline_table + count;\n+  while (pfse > fse_table)\n+    {\n+      unsigned char symbol;\n+      unsigned char bits;\n+      uint16_t base;\n+\n+      --pfse;\n+      --pbaseline;\n+      symbol = pfse->symbol;\n+      bits = pfse->bits;\n+      base = pfse->base;\n+      if (symbol < ZSTD_LITERAL_LENGTH_BASELINE_OFFSET)\n+\t{\n+\t  pbaseline->baseline = (uint32_t)symbol;\n+\t  pbaseline->basebits = 0;\n+\t}\n+      else\n+\t{\n+\t  unsigned int idx;\n+\t  uint32_t basebits;\n+\n+\t  if (unlikely (symbol > 35))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  idx = symbol - ZSTD_LITERAL_LENGTH_BASELINE_OFFSET;\n+\t  basebits = elf_zstd_literal_length_base[idx];\n+\t  pbaseline->baseline = ZSTD_DECODE_BASELINE(basebits);\n+\t  pbaseline->basebits = ZSTD_DECODE_BASEBITS(basebits);\n+\t}\n+      pbaseline->bits = bits;\n+      pbaseline->base = base;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Convert the offset length FSE table FSE_TABLE to an FSE baseline table at\n+   BASELINE_TABLE.  Note that FSE_TABLE and BASELINE_TABLE will overlap.  */\n+\n+static int\n+elf_zstd_make_offset_baseline_fse (\n+    const struct elf_zstd_fse_entry *fse_table,\n+    int table_bits,\n+    struct elf_zstd_fse_baseline_entry *baseline_table)\n+{\n+  size_t count;\n+  const struct elf_zstd_fse_entry *pfse;\n+  struct elf_zstd_fse_baseline_entry *pbaseline;\n+\n+  /* Convert backward to avoid overlap.  */\n+\n+  count = 1U << table_bits;\n+  pfse = fse_table + count;\n+  pbaseline = baseline_table + count;\n+  while (pfse > fse_table)\n+    {\n+      unsigned char symbol;\n+      unsigned char bits;\n+      uint16_t base;\n+\n+      --pfse;\n+      --pbaseline;\n+      symbol = pfse->symbol;\n+      bits = pfse->bits;\n+      base = pfse->base;\n+      if (unlikely (symbol > 31))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+\n+      /* The simple way to write this is\n+\n+\t   pbaseline->baseline = (uint32_t)1 << symbol;\n+\t   pbaseline->basebits = symbol;\n+\n+\t That will give us an offset value that corresponds to the one\n+\t described in the RFC.  However, for offset values > 3, we have to\n+\t subtract 3.  And for offset values 1, 2, 3 we use a repeated offset.\n+\t The baseline is always a power of 2, and is never 0, so for these low\n+\t values we will see one entry that is baseline 1, basebits 0, and one\n+\t entry that is baseline 2, basebits 1.  All other entries will have\n+\t baseline >= 4 and basebits >= 2.\n+\n+\t So we can check for RFC offset <= 3 by checking for basebits <= 1.\n+\t And that means that we can subtract 3 here and not worry about doing\n+\t it in the hot loop.  */\n+\n+      pbaseline->baseline = (uint32_t)1 << symbol;\n+      if (symbol >= 2)\n+\tpbaseline->baseline -= 3;\n+      pbaseline->basebits = symbol;\n+      pbaseline->bits = bits;\n+      pbaseline->base = base;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Convert the match length FSE table FSE_TABLE to an FSE baseline table at\n+   BASELINE_TABLE.  Note that FSE_TABLE and BASELINE_TABLE will overlap.  */\n+\n+static int\n+elf_zstd_make_match_baseline_fse (\n+    const struct elf_zstd_fse_entry *fse_table,\n+    int table_bits,\n+    struct elf_zstd_fse_baseline_entry *baseline_table)\n+{\n+  size_t count;\n+  const struct elf_zstd_fse_entry *pfse;\n+  struct elf_zstd_fse_baseline_entry *pbaseline;\n+\n+  /* Convert backward to avoid overlap.  */\n+\n+  count = 1U << table_bits;\n+  pfse = fse_table + count;\n+  pbaseline = baseline_table + count;\n+  while (pfse > fse_table)\n+    {\n+      unsigned char symbol;\n+      unsigned char bits;\n+      uint16_t base;\n+\n+      --pfse;\n+      --pbaseline;\n+      symbol = pfse->symbol;\n+      bits = pfse->bits;\n+      base = pfse->base;\n+      if (symbol < ZSTD_MATCH_LENGTH_BASELINE_OFFSET)\n+\t{\n+\t  pbaseline->baseline = (uint32_t)symbol + 3;\n+\t  pbaseline->basebits = 0;\n+\t}\n+      else\n+\t{\n+\t  unsigned int idx;\n+\t  uint32_t basebits;\n+\n+\t  if (unlikely (symbol > 52))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  idx = symbol - ZSTD_MATCH_LENGTH_BASELINE_OFFSET;\n+\t  basebits = elf_zstd_match_length_base[idx];\n+\t  pbaseline->baseline = ZSTD_DECODE_BASELINE(basebits);\n+\t  pbaseline->basebits = ZSTD_DECODE_BASEBITS(basebits);\n+\t}\n+      pbaseline->bits = bits;\n+      pbaseline->base = base;\n+    }\n+\n+  return 1;\n+}\n+\n #ifdef BACKTRACE_GENERATE_ZSTD_FSE_TABLES\n \n /* Used to generate the predefined FSE decoding tables for zstd.  */\n@@ -2957,18 +3227,19 @@ static int16_t offset[29] =\n static uint16_t next[256];\n \n static void\n-print_table (const struct elf_zstd_fse_entry *table, size_t size)\n+print_table (const struct elf_zstd_fse_baseline_entry *table, size_t size)\n {\n   size_t i;\n \n   printf (\"{\\n\");\n-  for (i = 0; i < size; i += 4)\n+  for (i = 0; i < size; i += 3)\n     {\n       int j;\n \n       printf (\" \");\n-      for (j = 0; j < 4 && i + j < size; ++j)\n-\tprintf (\" { %d, %d, %d },\", table[i + j].symbol, table[i + j].bits,\n+      for (j = 0; j < 3 && i + j < size; ++j)\n+\tprintf (\" { %u, %d, %d, %d },\", table[i + j].baseline,\n+\t\ttable[i + j].basebits, table[i + j].bits,\n \t\ttable[i + j].base);\n       printf (\"\\n\");\n     }\n@@ -2979,8 +3250,11 @@ int\n main ()\n {\n   struct elf_zstd_fse_entry lit_table[64];\n+  struct elf_zstd_fse_baseline_entry lit_baseline[64];\n   struct elf_zstd_fse_entry match_table[64];\n+  struct elf_zstd_fse_baseline_entry match_baseline[64];\n   struct elf_zstd_fse_entry offset_table[32];\n+  struct elf_zstd_fse_baseline_entry offset_baseline[32];\n \n   if (!elf_zstd_build_fse (lit, sizeof lit / sizeof lit[0], next,\n \t\t\t   6, lit_table))\n@@ -2989,9 +3263,16 @@ main ()\n       exit (EXIT_FAILURE);\n     }\n \n-  printf (\"static const struct elf_zstd_fse_entry \"\n+  if (!elf_zstd_make_literal_baseline_fse (lit_table, 6, lit_baseline))\n+    {\n+      fprintf (stderr, \"elf_zstd_make_literal_baseline_fse failed\\n\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  printf (\"static const struct elf_zstd_fse_baseline_entry \"\n \t  \"elf_zstd_lit_table[64] =\\n\");\n-  print_table (lit_table, sizeof lit_table / sizeof lit_table[0]);\n+  print_table (lit_baseline,\n+\t       sizeof lit_baseline / sizeof lit_baseline[0]);\n   printf (\"\\n\");\n \n   if (!elf_zstd_build_fse (match, sizeof match / sizeof match[0], next,\n@@ -3001,9 +3282,16 @@ main ()\n       exit (EXIT_FAILURE);\n     }\n \n-  printf (\"static const struct elf_zstd_fse_entry \"\n+  if (!elf_zstd_make_match_baseline_fse (match_table, 6, match_baseline))\n+    {\n+      fprintf (stderr, \"elf_zstd_make_match_baseline_fse failed\\n\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  printf (\"static const struct elf_zstd_fse_baseline_entry \"\n \t  \"elf_zstd_match_table[64] =\\n\");\n-  print_table (match_table, sizeof match_table / sizeof match_table[0]);\n+  print_table (match_baseline,\n+\t       sizeof match_baseline / sizeof match_baseline[0]);\n   printf (\"\\n\");\n \n   if (!elf_zstd_build_fse (offset, sizeof offset / sizeof offset[0], next,\n@@ -3013,9 +3301,16 @@ main ()\n       exit (EXIT_FAILURE);\n     }\n \n-  printf (\"static const struct elf_zstd_fse_entry \"\n+  if (!elf_zstd_make_offset_baseline_fse (offset_table, 5, offset_baseline))\n+    {\n+      fprintf (stderr, \"elf_zstd_make_offset_baseline_fse failed\\n\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  printf (\"static const struct elf_zstd_fse_baseline_entry \"\n \t  \"elf_zstd_offset_table[32] =\\n\");\n-  print_table (offset_table, sizeof offset_table / sizeof offset_table[0]);\n+  print_table (offset_baseline,\n+\t       sizeof offset_baseline / sizeof offset_baseline[0]);\n   printf (\"\\n\");\n \n   return 0;\n@@ -3026,56 +3321,71 @@ main ()\n /* The fixed tables generated by the #ifdef'ed out main function\n    above.  */\n \n-static const struct elf_zstd_fse_entry elf_zstd_lit_table[64] =\n+static const struct elf_zstd_fse_baseline_entry elf_zstd_lit_table[64] =\n {\n-  { 0, 4, 0 }, { 0, 4, 16 }, { 1, 5, 32 }, { 3, 5, 0 },\n-  { 4, 5, 0 }, { 6, 5, 0 }, { 7, 5, 0 }, { 9, 5, 0 },\n-  { 10, 5, 0 }, { 12, 5, 0 }, { 14, 6, 0 }, { 16, 5, 0 },\n-  { 18, 5, 0 }, { 19, 5, 0 }, { 21, 5, 0 }, { 22, 5, 0 },\n-  { 24, 5, 0 }, { 25, 5, 32 }, { 26, 5, 0 }, { 27, 6, 0 },\n-  { 29, 6, 0 }, { 31, 6, 0 }, { 0, 4, 32 }, { 1, 4, 0 },\n-  { 2, 5, 0 }, { 4, 5, 32 }, { 5, 5, 0 }, { 7, 5, 32 },\n-  { 8, 5, 0 }, { 10, 5, 32 }, { 11, 5, 0 }, { 13, 6, 0 },\n-  { 16, 5, 32 }, { 17, 5, 0 }, { 19, 5, 32 }, { 20, 5, 0 },\n-  { 22, 5, 32 }, { 23, 5, 0 }, { 25, 4, 0 }, { 25, 4, 16 },\n-  { 26, 5, 32 }, { 28, 6, 0 }, { 30, 6, 0 }, { 0, 4, 48 },\n-  { 1, 4, 16 }, { 2, 5, 32 }, { 3, 5, 32 }, { 5, 5, 32 },\n-  { 6, 5, 32 }, { 8, 5, 32 }, { 9, 5, 32 }, { 11, 5, 32 },\n-  { 12, 5, 32 }, { 15, 6, 0 }, { 17, 5, 32 }, { 18, 5, 32 },\n-  { 20, 5, 32 }, { 21, 5, 32 }, { 23, 5, 32 }, { 24, 5, 32 },\n-  { 35, 6, 0 }, { 34, 6, 0 }, { 33, 6, 0 }, { 32, 6, 0 },\n+  { 0, 0, 4, 0 }, { 0, 0, 4, 16 }, { 1, 0, 5, 32 },\n+  { 3, 0, 5, 0 }, { 4, 0, 5, 0 }, { 6, 0, 5, 0 },\n+  { 7, 0, 5, 0 }, { 9, 0, 5, 0 }, { 10, 0, 5, 0 },\n+  { 12, 0, 5, 0 }, { 14, 0, 6, 0 }, { 16, 1, 5, 0 },\n+  { 20, 1, 5, 0 }, { 22, 1, 5, 0 }, { 28, 2, 5, 0 },\n+  { 32, 3, 5, 0 }, { 48, 4, 5, 0 }, { 64, 6, 5, 32 },\n+  { 128, 7, 5, 0 }, { 256, 8, 6, 0 }, { 1024, 10, 6, 0 },\n+  { 4096, 12, 6, 0 }, { 0, 0, 4, 32 }, { 1, 0, 4, 0 },\n+  { 2, 0, 5, 0 }, { 4, 0, 5, 32 }, { 5, 0, 5, 0 },\n+  { 7, 0, 5, 32 }, { 8, 0, 5, 0 }, { 10, 0, 5, 32 },\n+  { 11, 0, 5, 0 }, { 13, 0, 6, 0 }, { 16, 1, 5, 32 },\n+  { 18, 1, 5, 0 }, { 22, 1, 5, 32 }, { 24, 2, 5, 0 },\n+  { 32, 3, 5, 32 }, { 40, 3, 5, 0 }, { 64, 6, 4, 0 },\n+  { 64, 6, 4, 16 }, { 128, 7, 5, 32 }, { 512, 9, 6, 0 },\n+  { 2048, 11, 6, 0 }, { 0, 0, 4, 48 }, { 1, 0, 4, 16 },\n+  { 2, 0, 5, 32 }, { 3, 0, 5, 32 }, { 5, 0, 5, 32 },\n+  { 6, 0, 5, 32 }, { 8, 0, 5, 32 }, { 9, 0, 5, 32 },\n+  { 11, 0, 5, 32 }, { 12, 0, 5, 32 }, { 15, 0, 6, 0 },\n+  { 18, 1, 5, 32 }, { 20, 1, 5, 32 }, { 24, 2, 5, 32 },\n+  { 28, 2, 5, 32 }, { 40, 3, 5, 32 }, { 48, 4, 5, 32 },\n+  { 65536, 16, 6, 0 }, { 32768, 15, 6, 0 }, { 16384, 14, 6, 0 },\n+  { 8192, 13, 6, 0 },\n };\n \n-static const struct elf_zstd_fse_entry elf_zstd_match_table[64] =\n+static const struct elf_zstd_fse_baseline_entry elf_zstd_match_table[64] =\n {\n-  { 0, 6, 0 }, { 1, 4, 0 }, { 2, 5, 32 }, { 3, 5, 0 },\n-  { 5, 5, 0 }, { 6, 5, 0 }, { 8, 5, 0 }, { 10, 6, 0 },\n-  { 13, 6, 0 }, { 16, 6, 0 }, { 19, 6, 0 }, { 22, 6, 0 },\n-  { 25, 6, 0 }, { 28, 6, 0 }, { 31, 6, 0 }, { 33, 6, 0 },\n-  { 35, 6, 0 }, { 37, 6, 0 }, { 39, 6, 0 }, { 41, 6, 0 },\n-  { 43, 6, 0 }, { 45, 6, 0 }, { 1, 4, 16 }, { 2, 4, 0 },\n-  { 3, 5, 32 }, { 4, 5, 0 }, { 6, 5, 32 }, { 7, 5, 0 },\n-  { 9, 6, 0 }, { 12, 6, 0 }, { 15, 6, 0 }, { 18, 6, 0 },\n-  { 21, 6, 0 }, { 24, 6, 0 }, { 27, 6, 0 }, { 30, 6, 0 },\n-  { 32, 6, 0 }, { 34, 6, 0 }, { 36, 6, 0 }, { 38, 6, 0 },\n-  { 40, 6, 0 }, { 42, 6, 0 }, { 44, 6, 0 }, { 1, 4, 32 },\n-  { 1, 4, 48 }, { 2, 4, 16 }, { 4, 5, 32 }, { 5, 5, 32 },\n-  { 7, 5, 32 }, { 8, 5, 32 }, { 11, 6, 0 }, { 14, 6, 0 },\n-  { 17, 6, 0 }, { 20, 6, 0 }, { 23, 6, 0 }, { 26, 6, 0 },\n-  { 29, 6, 0 }, { 52, 6, 0 }, { 51, 6, 0 }, { 50, 6, 0 },\n-  { 49, 6, 0 }, { 48, 6, 0 }, { 47, 6, 0 }, { 46, 6, 0 },\n+  { 3, 0, 6, 0 }, { 4, 0, 4, 0 }, { 5, 0, 5, 32 },\n+  { 6, 0, 5, 0 }, { 8, 0, 5, 0 }, { 9, 0, 5, 0 },\n+  { 11, 0, 5, 0 }, { 13, 0, 6, 0 }, { 16, 0, 6, 0 },\n+  { 19, 0, 6, 0 }, { 22, 0, 6, 0 }, { 25, 0, 6, 0 },\n+  { 28, 0, 6, 0 }, { 31, 0, 6, 0 }, { 34, 0, 6, 0 },\n+  { 37, 1, 6, 0 }, { 41, 1, 6, 0 }, { 47, 2, 6, 0 },\n+  { 59, 3, 6, 0 }, { 83, 4, 6, 0 }, { 131, 7, 6, 0 },\n+  { 515, 9, 6, 0 }, { 4, 0, 4, 16 }, { 5, 0, 4, 0 },\n+  { 6, 0, 5, 32 }, { 7, 0, 5, 0 }, { 9, 0, 5, 32 },\n+  { 10, 0, 5, 0 }, { 12, 0, 6, 0 }, { 15, 0, 6, 0 },\n+  { 18, 0, 6, 0 }, { 21, 0, 6, 0 }, { 24, 0, 6, 0 },\n+  { 27, 0, 6, 0 }, { 30, 0, 6, 0 }, { 33, 0, 6, 0 },\n+  { 35, 1, 6, 0 }, { 39, 1, 6, 0 }, { 43, 2, 6, 0 },\n+  { 51, 3, 6, 0 }, { 67, 4, 6, 0 }, { 99, 5, 6, 0 },\n+  { 259, 8, 6, 0 }, { 4, 0, 4, 32 }, { 4, 0, 4, 48 },\n+  { 5, 0, 4, 16 }, { 7, 0, 5, 32 }, { 8, 0, 5, 32 },\n+  { 10, 0, 5, 32 }, { 11, 0, 5, 32 }, { 14, 0, 6, 0 },\n+  { 17, 0, 6, 0 }, { 20, 0, 6, 0 }, { 23, 0, 6, 0 },\n+  { 26, 0, 6, 0 }, { 29, 0, 6, 0 }, { 32, 0, 6, 0 },\n+  { 65539, 16, 6, 0 }, { 32771, 15, 6, 0 }, { 16387, 14, 6, 0 },\n+  { 8195, 13, 6, 0 }, { 4099, 12, 6, 0 }, { 2051, 11, 6, 0 },\n+  { 1027, 10, 6, 0 },\n };\n \n-static const struct elf_zstd_fse_entry elf_zstd_offset_table[32] =\n+static const struct elf_zstd_fse_baseline_entry elf_zstd_offset_table[32] =\n {\n-  { 0, 5, 0 }, { 6, 4, 0 }, { 9, 5, 0 }, { 15, 5, 0 },\n-  { 21, 5, 0 }, { 3, 5, 0 }, { 7, 4, 0 }, { 12, 5, 0 },\n-  { 18, 5, 0 }, { 23, 5, 0 }, { 5, 5, 0 }, { 8, 4, 0 },\n-  { 14, 5, 0 }, { 20, 5, 0 }, { 2, 5, 0 }, { 7, 4, 16 },\n-  { 11, 5, 0 }, { 17, 5, 0 }, { 22, 5, 0 }, { 4, 5, 0 },\n-  { 8, 4, 16 }, { 13, 5, 0 }, { 19, 5, 0 }, { 1, 5, 0 },\n-  { 6, 4, 16 }, { 10, 5, 0 }, { 16, 5, 0 }, { 28, 5, 0 },\n-  { 27, 5, 0 }, { 26, 5, 0 }, { 25, 5, 0 }, { 24, 5, 0 },\n+  { 1, 0, 5, 0 }, { 64, 6, 4, 0 }, { 512, 9, 5, 0 },\n+  { 32768, 15, 5, 0 }, { 2097152, 21, 5, 0 }, { 8, 3, 5, 0 },\n+  { 128, 7, 4, 0 }, { 4096, 12, 5, 0 }, { 262144, 18, 5, 0 },\n+  { 8388608, 23, 5, 0 }, { 32, 5, 5, 0 }, { 256, 8, 4, 0 },\n+  { 16384, 14, 5, 0 }, { 1048576, 20, 5, 0 }, { 4, 2, 5, 0 },\n+  { 128, 7, 4, 16 }, { 2048, 11, 5, 0 }, { 131072, 17, 5, 0 },\n+  { 4194304, 22, 5, 0 }, { 16, 4, 5, 0 }, { 256, 8, 4, 16 },\n+  { 8192, 13, 5, 0 }, { 524288, 19, 5, 0 }, { 2, 1, 5, 0 },\n+  { 64, 6, 4, 16 }, { 1024, 10, 5, 0 }, { 65536, 16, 5, 0 },\n+  { 268435456, 28, 5, 0 }, { 134217728, 27, 5, 0 }, { 67108864, 26, 5, 0 },\n+  { 33554432, 25, 5, 0 }, { 16777216, 24, 5, 0 },\n };\n \n /* Read a zstd Huffman table and build the decoding table in *TABLE, reading\n@@ -3397,10 +3707,8 @@ elf_zstd_read_huff (const unsigned char **ppin, const unsigned char *pinend,\n \n struct elf_zstd_seq_decode\n {\n-  const struct elf_zstd_fse_entry *table;\n+  const struct elf_zstd_fse_baseline_entry *table;\n   int table_bits;\n-  int use_rle;\n-  unsigned char rle;\n };\n \n /* Unpack a sequence code compression mode.  */\n@@ -3409,43 +3717,62 @@ static int\n elf_zstd_unpack_seq_decode (int mode,\n \t\t\t    const unsigned char **ppin,\n \t\t\t    const unsigned char *pinend,\n-\t\t\t    const struct elf_zstd_fse_entry *predefined,\n-\t\t\t    int predefined_bits, uint16_t *scratch,\n-\t\t\t    int maxidx, struct elf_zstd_fse_entry *fse_table,\n-\t\t\t    int fse_table_bits,\n+\t\t\t    const struct elf_zstd_fse_baseline_entry *predef,\n+\t\t\t    int predef_bits,\n+\t\t\t    uint16_t *scratch,\n+\t\t\t    int maxidx,\n+\t\t\t    struct elf_zstd_fse_baseline_entry *table,\n+\t\t\t    int table_bits,\n+\t\t\t    int (*conv)(const struct elf_zstd_fse_entry *,\n+\t\t\t\t\tint,\n+\t\t\t\t\tstruct elf_zstd_fse_baseline_entry *),\n \t\t\t    struct elf_zstd_seq_decode *decode)\n {\n   switch (mode)\n     {\n     case 0:\n-      decode->table = predefined;\n-      decode->table_bits = predefined_bits;\n-      decode->use_rle = 0;\n+      decode->table = predef;\n+      decode->table_bits = predef_bits;\n       break;\n \n     case 1:\n-      if (unlikely (*ppin >= pinend))\n-\t{\n-\t  elf_uncompress_failed ();\n+      {\n+\tstruct elf_zstd_fse_entry entry;\n+\n+\tif (unlikely (*ppin >= pinend))\n+\t  {\n+\t    elf_uncompress_failed ();\n+\t    return 0;\n+\t  }\n+\tentry.symbol = **ppin;\n+\t++*ppin;\n+\tentry.bits = 0;\n+\tentry.base = 0;\n+\tdecode->table_bits = 0;\n+\tif (!conv (&entry, 0, table))\n \t  return 0;\n-\t}\n-      decode->use_rle = 1;\n-      decode->rle = **ppin;\n-      decode->table_bits = 0;\n-      ++*ppin;\n+      }\n       break;\n \n     case 2:\n-      decode->table_bits = fse_table_bits;\n-      if (!elf_zstd_read_fse (ppin, pinend, scratch, maxidx, fse_table,\n-\t\t\t      &decode->table_bits))\n-\treturn 0;\n-      decode->table = fse_table;\n-      decode->use_rle = 0;\n+      {\n+\tstruct elf_zstd_fse_entry *fse_table;\n+\n+\t/* We use the same space for the simple FSE table and the baseline\n+\t   table.  */\n+\tfse_table = (struct elf_zstd_fse_entry *)table;\n+\tdecode->table_bits = table_bits;\n+\tif (!elf_zstd_read_fse (ppin, pinend, scratch, maxidx, fse_table,\n+\t\t\t\t&decode->table_bits))\n+\t  return 0;\n+\tif (!conv (fse_table, decode->table_bits, table))\n+\t  return 0;\n+\tdecode->table = table;\n+      }\n       break;\n \n     case 3:\n-      if (unlikely (decode->table_bits == 0 && !decode->use_rle))\n+      if (unlikely (decode->table_bits == -1))\n \t{\n \t  elf_uncompress_failed ();\n \t  return 0;\n@@ -3703,39 +4030,6 @@ elf_zstd_literal_output (struct elf_zstd_literals *literals,\n   return 1;\n }\n \n-/* Given a literal length code, we need to read a number of bits and add that\n-   to a baseline.  For states 0 to 15 the baseline is the state and the number\n-   of bits is zero.  */\n-\n-#define ZSTD_LITERAL_LENGTH_BASELINE_OFFSET (16)\n-\n-static const uint32_t elf_zstd_literal_length_baseline[] =\n-{\n-  16, 18, 20, 22, 24, 28, 32, 40, 48, 64, 128, 256, 512,\n-  1024, 2048, 4096, 8192, 16384, 32768, 65536\n-};\n-\n-static const unsigned char elf_zstd_literal_length_bits[] =\n-{\n-  1, 1, 1, 1, 2, 2, 3, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\n-};\n-\n-/* The same applies to match length codes.  For states 0 to 31 the baseline is\n-   the state + 3 and the number of bits is zero.  */\n-\n-#define ZSTD_MATCH_LENGTH_BASELINE_OFFSET (32)\n-\n-static const uint32_t elf_zstd_match_length_baseline[] =\n-{\n-  35, 37, 39, 41, 43, 47, 51, 59, 67, 83, 99, 131, 259, 515,\n-  1027, 2051, 4099, 8195, 16387, 32771, 65539\n-};\n-\n-static const unsigned char elf_zstd_match_length_bits[] =\n-{\n-  1, 1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\n-};\n-\n /* Decompress a zstd stream from PIN/SIN to POUT/SOUT.  Code based on RFC 8878.\n    Return 1 on success, 0 on error.  */\n \n@@ -3748,11 +4042,11 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n   unsigned char *poutstart;\n   unsigned char *poutend;\n   struct elf_zstd_seq_decode literal_decode;\n-  struct elf_zstd_fse_entry *literal_fse_table;\n+  struct elf_zstd_fse_baseline_entry *literal_fse_table;\n   struct elf_zstd_seq_decode match_decode;\n-  struct elf_zstd_fse_entry *match_fse_table;\n+  struct elf_zstd_fse_baseline_entry *match_fse_table;\n   struct elf_zstd_seq_decode offset_decode;\n-  struct elf_zstd_fse_entry *offset_fse_table;\n+  struct elf_zstd_fse_baseline_entry *offset_fse_table;\n   uint16_t *huffman_table;\n   int huffman_table_bits;\n   uint32_t repeated_offset1;\n@@ -3769,21 +4063,18 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n   poutend = pout + sout;\n \n   literal_decode.table = NULL;\n-  literal_decode.table_bits = 0;\n-  literal_decode.use_rle = 0;\n-  literal_fse_table = ((struct elf_zstd_fse_entry *)\n+  literal_decode.table_bits = -1;\n+  literal_fse_table = ((struct elf_zstd_fse_baseline_entry *)\n \t\t       (zdebug_table + ZSTD_TABLE_LITERAL_FSE_OFFSET));\n \n   match_decode.table = NULL;\n-  match_decode.table_bits = 0;\n-  match_decode.use_rle = 0;\n-  match_fse_table = ((struct elf_zstd_fse_entry *)\n+  match_decode.table_bits = -1;\n+  match_fse_table = ((struct elf_zstd_fse_baseline_entry *)\n \t\t     (zdebug_table + ZSTD_TABLE_MATCH_FSE_OFFSET));\n \n   offset_decode.table = NULL;\n-  offset_decode.table_bits = 0;\n-  offset_decode.use_rle = 0;\n-  offset_fse_table = ((struct elf_zstd_fse_entry *)\n+  offset_decode.table_bits = -1;\n+  offset_fse_table = ((struct elf_zstd_fse_baseline_entry *)\n \t\t      (zdebug_table + ZSTD_TABLE_OFFSET_FSE_OFFSET));\n   huffman_table = ((uint16_t *)\n \t\t   (zdebug_table + ZSTD_TABLE_HUFFMAN_OFFSET));\n@@ -4259,6 +4550,9 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t    if (seq_count > 0)\n \t      {\n+\t\tint (*pfn)(const struct elf_zstd_fse_entry *,\n+\t\t\t   int, struct elf_zstd_fse_baseline_entry *);\n+\n \t\tif (unlikely (pin >= pinend))\n \t\t  {\n \t\t    elf_uncompress_failed ();\n@@ -4267,27 +4561,30 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\tseq_hdr = *pin;\n \t\t++pin;\n \n+\t\tpfn = elf_zstd_make_literal_baseline_fse;\n \t\tif (!elf_zstd_unpack_seq_decode ((seq_hdr >> 6) & 3,\n \t\t\t\t\t\t &pin, pinend,\n \t\t\t\t\t\t &elf_zstd_lit_table[0], 6,\n \t\t\t\t\t\t scratch, 35,\n-\t\t\t\t\t\t literal_fse_table, 9,\n+\t\t\t\t\t\t literal_fse_table, 9, pfn,\n \t\t\t\t\t\t &literal_decode))\n \t\t  return 0;\n \n+\t\tpfn = elf_zstd_make_offset_baseline_fse;\n \t\tif (!elf_zstd_unpack_seq_decode ((seq_hdr >> 4) & 3,\n \t\t\t\t\t\t &pin, pinend,\n \t\t\t\t\t\t &elf_zstd_offset_table[0], 5,\n \t\t\t\t\t\t scratch, 31,\n-\t\t\t\t\t\t offset_fse_table, 8,\n+\t\t\t\t\t\t offset_fse_table, 8, pfn,\n \t\t\t\t\t\t &offset_decode))\n \t\t  return 0;\n \n+\t\tpfn = elf_zstd_make_match_baseline_fse;\n \t\tif (!elf_zstd_unpack_seq_decode ((seq_hdr >> 2) & 3,\n \t\t\t\t\t\t &pin, pinend,\n \t\t\t\t\t\t &elf_zstd_match_table[0], 6,\n \t\t\t\t\t\t scratch, 52,\n-\t\t\t\t\t\t match_fse_table, 9,\n+\t\t\t\t\t\t match_fse_table, 9, pfn,\n \t\t\t\t\t\t &match_decode))\n \t\t  return 0;\n \t      }\n@@ -4337,77 +4634,53 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t    bits -= __builtin_clz (stream_start) - 24 + 1;\n \n-\t    if (unlikely (literal_decode.use_rle))\n-\t      literal_state = 0;\n-\t    else\n-\t      {\n-\t\tif (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t\t  return 0;\n-\t\tbits -= literal_decode.table_bits;\n-\t\tliteral_state = ((val >> bits)\n-\t\t\t\t & ((1U << literal_decode.table_bits) - 1));\n-\t      }\n+\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t      return 0;\n+\t    bits -= literal_decode.table_bits;\n+\t    literal_state = ((val >> bits)\n+\t\t\t     & ((1U << literal_decode.table_bits) - 1));\n \n-\t    if (unlikely (offset_decode.use_rle))\n-\t      offset_state = 0;\n-\t    else\n-\t      {\n-\t\tif (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t\t  return 0;\n-\t\tbits -= offset_decode.table_bits;\n-\t\toffset_state = ((val >> bits)\n-\t\t\t\t& ((1U << offset_decode.table_bits) - 1));\n-\t      }\n+\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t      return 0;\n+\t    bits -= offset_decode.table_bits;\n+\t    offset_state = ((val >> bits)\n+\t\t\t    & ((1U << offset_decode.table_bits) - 1));\n \n-\t    if (unlikely (match_decode.use_rle))\n-\t      match_state = 0;\n-\t    else\n-\t      {\n-\t\tif (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t\t  return 0;\n-\t\tbits -= match_decode.table_bits;\n-\t\tmatch_state = ((val >> bits)\n-\t\t\t       & ((1U << match_decode.table_bits) - 1));\n-\t      }\n+\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t      return 0;\n+\t    bits -= match_decode.table_bits;\n+\t    match_state = ((val >> bits)\n+\t\t\t   & ((1U << match_decode.table_bits) - 1));\n \n \t    seq = 0;\n \t    while (1)\n \t      {\n+\t\tconst struct elf_zstd_fse_baseline_entry *pt;\n+\t\tuint32_t offset_basebits;\n+\t\tuint32_t offset_baseline;\n+\t\tuint32_t offset_bits;\n \t\tuint32_t offset_base;\n-\t\tuint32_t need;\n-\t\tuint32_t add;\n \t\tuint32_t offset;\n-\t\tuint32_t use_offset;\n+\t\tuint32_t match_baseline;\n+\t\tuint32_t match_bits;\n \t\tuint32_t match_base;\n \t\tuint32_t match;\n+\t\tuint32_t literal_baseline;\n+\t\tuint32_t literal_bits;\n \t\tuint32_t literal_base;\n \t\tuint32_t literal;\n-\t\tconst struct elf_zstd_fse_entry *pt;\n-\t\tuint64_t v;\n-\n-\t\tif (unlikely (offset_decode.use_rle))\n-\t\t  offset_base = offset_decode.rle;\n-\t\telse\n-\t\t  offset_base = offset_decode.table[offset_state].symbol;\n-\n-\t\tif (unlikely (match_decode.use_rle))\n-\t\t  match_base = match_decode.rle;\n-\t\telse\n-\t\t  match_base = match_decode.table[match_state].symbol;\n-\n-\t\tif (unlikely (literal_decode.use_rle))\n-\t\t  literal_base = literal_decode.rle;\n-\t\telse\n-\t\t  literal_base = literal_decode.table[literal_state].symbol;\n+\t\tuint32_t need;\n+\t\tuint32_t add;\n \n-\t\tneed = offset_base;\n-\t\tif (unlikely (need > 31))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n+\t\tpt = &offset_decode.table[offset_state];\n+\t\toffset_basebits = pt->basebits;\n+\t\toffset_baseline = pt->baseline;\n+\t\toffset_bits = pt->bits;\n+\t\toffset_base = pt->base;\n \n-\t\t/* elf_fetch_bits_backward only promises us 16 bits.  */\n+\t\t/* This case can be more than 16 bits, which is all that\n+\t\t   elf_fetch_bits_backward promises.  */\n+\t\tneed = offset_basebits;\n \t\tadd = 0;\n \t\tif (unlikely (need > 16))\n \t\t  {\n@@ -4418,147 +4691,122 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\t    need -= 16;\n \t\t    add <<= need;\n \t\t  }\n-\t\tif (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t\t  return 0;\n-\t\tbits -= need;\n-\t\tadd += (val >> bits) & ((1U << need) - 1);\n-\n-\t\toffset = (1U << offset_base) + add;\n-\n-\t\tif (match_base < ZSTD_MATCH_LENGTH_BASELINE_OFFSET)\n-\t\t  match = match_base + 3;\n-\t\telse\n+\t\tif (need > 0)\n \t\t  {\n-\t\t    unsigned int idx;\n-\t\t    unsigned int baseline;\n+\t\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t\t      return 0;\n+\t\t    bits -= need;\n+\t\t    add += (val >> bits) & ((1U << need) - 1);\n+\t\t  }\n \n-\t\t    if (unlikely (match_base > 52))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n+\t\toffset = offset_baseline + add;\n \n-\t\t    idx = match_base - ZSTD_MATCH_LENGTH_BASELINE_OFFSET;\n-\t\t    baseline = elf_zstd_match_length_baseline[idx];\n-\t\t    need = elf_zstd_match_length_bits[idx];\n+\t\tpt = &match_decode.table[match_state];\n+\t\tneed = pt->basebits;\n+\t\tmatch_baseline = pt->baseline;\n+\t\tmatch_bits = pt->bits;\n+\t\tmatch_base = pt->base;\n \n+\t\tadd = 0;\n+\t\tif (need > 0)\n+\t\t  {\n \t\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n \t\t      return 0;\n \t\t    bits -= need;\n \t\t    add = (val >> bits) & ((1U << need) - 1);\n-\n-\t\t    match = baseline + add;\n \t\t  }\n \n-\t\tif (literal_base < ZSTD_LITERAL_LENGTH_BASELINE_OFFSET)\n-\t\t  literal = literal_base;\n-\t\telse\n-\t\t  {\n-\t\t    unsigned int idx;\n-\t\t    unsigned int baseline;\n-\n-\t\t    if (unlikely (literal_base > 35))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n+\t\tmatch = match_baseline + add;\n \n-\t\t    idx = literal_base - ZSTD_LITERAL_LENGTH_BASELINE_OFFSET;\n-\t\t    baseline = elf_zstd_literal_length_baseline[idx];\n-\t\t    need = elf_zstd_literal_length_bits[idx];\n+\t\tpt = &literal_decode.table[literal_state];\n+\t\tneed = pt->basebits;\n+\t\tliteral_baseline = pt->baseline;\n+\t\tliteral_bits = pt->bits;\n+\t\tliteral_base = pt->base;\n \n+\t\tadd = 0;\n+\t\tif (need > 0)\n+\t\t  {\n \t\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n \t\t      return 0;\n \t\t    bits -= need;\n \t\t    add = (val >> bits) & ((1U << need) - 1);\n-\n-\t\t    literal = baseline + add;\n \t\t  }\n \n-\t\tswitch (offset)\n+\t\tliteral = literal_baseline + add;\n+\n+\t\t/* See the comment in elf_zstd_make_offset_baseline_fse.  */\n+\t\tif (offset_basebits > 1)\n \t\t  {\n-\t\t  case 0:\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  case 1:\n-\t\t    if (literal == 0)\n+\t\t    repeated_offset3 = repeated_offset2;\n+\t\t    repeated_offset2 = repeated_offset1;\n+\t\t    repeated_offset1 = offset;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (unlikely (literal == 0))\n+\t\t      ++offset;\n+\t\t    switch (offset)\n \t\t      {\n-\t\t\tuse_offset = repeated_offset2;\n+\t\t      case 1:\n+\t\t\toffset = repeated_offset1;\n+\t\t\tbreak;\n+\t\t      case 2:\n+\t\t\toffset = repeated_offset2;\n \t\t\trepeated_offset2 = repeated_offset1;\n-\t\t      }\n-\t\t    else\n-\t\t      use_offset = repeated_offset1;\n-\t\t    break;\n-\t\t  case 2:\n-\t\t    if (literal == 0)\n-\t\t      {\n-\t\t\tuse_offset = repeated_offset3;\n+\t\t\trepeated_offset1 = offset;\n+\t\t\tbreak;\n+\t\t      case 3:\n+\t\t\toffset = repeated_offset3;\n+\t\t\trepeated_offset3 = repeated_offset2;\n+\t\t\trepeated_offset2 = repeated_offset1;\n+\t\t\trepeated_offset1 = offset;\n+\t\t\tbreak;\n+\t\t      case 4:\n+\t\t\toffset = repeated_offset1 - 1;\n \t\t\trepeated_offset3 = repeated_offset2;\n+\t\t\trepeated_offset2 = repeated_offset1;\n+\t\t\trepeated_offset1 = offset;\n+\t\t\tbreak;\n \t\t      }\n-\t\t    else\n-\t\t      use_offset = repeated_offset2;\n-\t\t    repeated_offset2 = repeated_offset1;\n-\t\t    break;\n-\t\t  case 3:\n-\t\t    if (literal == 0)\n-\t\t      use_offset = repeated_offset1 - 1;\n-\t\t    else\n-\t\t      use_offset = repeated_offset3;\n-\t\t    repeated_offset3 = repeated_offset2;\n-\t\t    repeated_offset2 = repeated_offset1;\n-\t\t    break;\n-\t\t  default:\n-\t\t    use_offset = offset - 3;\n-\t\t    repeated_offset3 = repeated_offset2;\n-\t\t    repeated_offset2 = repeated_offset1;\n-\t\t    break;\n \t\t  }\n \n-\t\trepeated_offset1 = use_offset;\n-\n \t\t++seq;\n \t\tif (seq < seq_count)\n \t\t  {\n+\t\t    uint32_t v;\n+\n \t\t    /* Update the three states.  */\n \n-\t\t    if (unlikely (literal_decode.use_rle))\n-\t\t      ;\n-\t\t    else\n-\t\t      {\n-\t\t\tif (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t\t\t  return 0;\n-\t\t\tpt = &literal_decode.table[literal_state];\n-\t\t\tbits -= pt->bits;\n-\t\t\tv = (val >> bits) & (((uint64_t)1 << pt->bits) - 1);\n-\t\t\tliteral_state = pt->base + v;\n-\t\t      }\n+\t\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t\t      return 0;\n \n-\t\t    if (unlikely (match_decode.use_rle))\n-\t\t      ;\n-\t\t    else\n-\t\t      {\n-\t\t\tif (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t\t\t  return 0;\n-\t\t\tpt = &match_decode.table[match_state];\n-\t\t\tbits -= pt->bits;\n-\t\t\tv = (val >> bits) & (((uint64_t)1 << pt->bits) - 1);\n-\t\t\tmatch_state = pt->base + v;\n-\t\t      }\n+\t\t    need = literal_bits;\n+\t\t    bits -= need;\n+\t\t    v = (val >> bits) & (((uint32_t)1 << need) - 1);\n \n-\t\t    if (unlikely (offset_decode.use_rle))\n-\t\t      ;\n-\t\t    else\n-\t\t      {\n-\t\t\tif (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t\t\t  return 0;\n-\t\t\tpt = &offset_decode.table[offset_state];\n-\t\t\tbits -= pt->bits;\n-\t\t\tv = (val >> bits) & (((uint64_t)1 << pt->bits) - 1);\n-\t\t\toffset_state = pt->base + v;\n-\t\t      }\n+\t\t    literal_state = literal_base + v;\n+\n+\t\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t\t      return 0;\n+\n+\t\t    need = match_bits;\n+\t\t    bits -= need;\n+\t\t    v = (val >> bits) & (((uint32_t)1 << need) - 1);\n+\n+\t\t    match_state = match_base + v;\n+\n+\t\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t\t      return 0;\n+\n+\t\t    need = offset_bits;\n+\t\t    bits -= need;\n+\t\t    v = (val >> bits) & (((uint32_t)1 << need) - 1);\n+\n+\t\t    offset_state = offset_base + v;\n \t\t  }\n \n-\t\t/* The next sequence is now in LITERAL, USE_OFFSET, MATCH.  */\n+\t\t/* The next sequence is now in LITERAL, OFFSET, MATCH.  */\n \n \t\tif (literal > 0)\n \t\t  {\n@@ -4570,7 +4818,14 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\t\treturn 0;\n \t\t      }\n \n-\t\t    if (literal <= litexp_count)\n+\t\t    if (literals.type != ZSTD_LIT_HUFF)\n+\t\t      {\n+\t\t\tif (!elf_zstd_literal_output (&literals, literal,\n+\t\t\t\t\t\t      pout))\n+\t\t\t  return 0;\n+\t\t\tpout += literal;\n+\t\t      }\n+\t\t    else if (literal <= litexp_count)\n \t\t      {\n \t\t\tmemcpy (pout, plitexp, literal);\n \t\t\tplitexp += literal;\n@@ -4579,17 +4834,12 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\tif (litexp_count > 0)\n-\t\t\t  {\n-\t\t\t    memcpy (pout, plitexp, litexp_count);\n-\t\t\t    pout += litexp_count;\n-\t\t\t    literal -= litexp_count;\n-\t\t\t    plitexp = NULL;\n-\t\t\t    litexp_count = 0;\n-\t\t\t  }\n+\t\t\tmemcpy (pout, plitexp, litexp_count);\n+\t\t\tpout += litexp_count;\n+\t\t\tliteral -= litexp_count;\n+\t\t\tlitexp_count = 0;\n \n-\t\t\tif (literals.type != ZSTD_LIT_HUFF\n-\t\t\t    || literal >= ZSTD_TABLE_WORK_LIT_SIZE)\n+\t\t\tif (unlikely (literal >= ZSTD_TABLE_WORK_LIT_SIZE))\n \t\t\t  {\n \t\t\t    if (!elf_zstd_literal_output (&literals, literal,\n \t\t\t\t\t\t\t  pout))\n@@ -4598,61 +4848,47 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\t\t    literal = 0;\n \t\t\t  }\n \n-\t\t\tif (literals.type != ZSTD_LIT_HUFF\n-\t\t\t    || literals.regenerated_size == 0)\n+\t\t\tplitexp = (unsigned char *)scratch;\n+\t\t\tlitexp_count = ZSTD_TABLE_WORK_LIT_SIZE;\n+\t\t\tif (litexp_count > literals.regenerated_size)\n+\t\t\t  litexp_count = literals.regenerated_size;\n+\t\t\tif (!elf_zstd_literal_output (&literals,\n+\t\t\t\t\t\t      litexp_count,\n+\t\t\t\t\t\t      plitexp))\n+\t\t\t  return 0;\n+\n+\t\t\tif (unlikely (literal > litexp_count))\n \t\t\t  {\n-\t\t\t    plitexp = NULL;\n-\t\t\t    litexp_count = 0;\n-\t\t\t    if (unlikely (literal > 0))\n-\t\t\t      {\n-\t\t\t\telf_uncompress_failed ();\n-\t\t\t\treturn 0;\n-\t\t\t      }\n+\t\t\t    elf_uncompress_failed ();\n+\t\t\t    return 0;\n \t\t\t  }\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    plitexp = (unsigned char *)scratch;\n-\t\t\t    litexp_count = ZSTD_TABLE_WORK_LIT_SIZE;\n-\t\t\t    if (litexp_count > literals.regenerated_size)\n-\t\t\t      litexp_count = literals.regenerated_size;\n-\t\t\t    if (!elf_zstd_literal_output (&literals,\n-\t\t\t\t\t\t\t  litexp_count,\n-\t\t\t\t\t\t\t  plitexp))\n-\t\t\t      return 0;\n \n-\t\t\t    if (unlikely (literal > litexp_count))\n-\t\t\t      {\n-\t\t\t\telf_uncompress_failed ();\n-\t\t\t\treturn 0;\n-\t\t\t      }\n-\n-\t\t\t    memcpy (pout, plitexp, literal);\n-\t\t\t    plitexp += literal;\n-\t\t\t    litexp_count -= literal;\n-\t\t\t    pout += literal;\n-\t\t\t  }\n+\t\t\tmemcpy (pout, plitexp, literal);\n+\t\t\tplitexp += literal;\n+\t\t\tlitexp_count -= literal;\n+\t\t\tpout += literal;\n \t\t      }\n \t\t  }\n \n-\t\t/* Copy MATCH bytes from the decoded output at USE_OFFSET.  */\n-\n-\t\tif (unlikely ((size_t)(poutend - pout) < match))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\n \t\tif (match > 0)\n \t\t  {\n-\t\t    if (unlikely ((size_t)(pout - poutstart) < use_offset))\n+\t\t    /* Copy MATCH bytes from the decoded output at OFFSET.  */\n+\n+\t\t    if (unlikely ((size_t)(poutend - pout) < match))\n+\t\t      {\n+\t\t\telf_uncompress_failed ();\n+\t\t\treturn 0;\n+\t\t      }\n+\n+\t\t    if (unlikely ((size_t)(pout - poutstart) < offset))\n \t\t      {\n \t\t\telf_uncompress_failed ();\n \t\t\treturn 0;\n \t\t      }\n \n-\t\t    if (use_offset >= match)\n+\t\t    if (offset >= match)\n \t\t      {\n-\t\t\tmemcpy (pout, pout - use_offset, match);\n+\t\t\tmemcpy (pout, pout - offset, match);\n \t\t\tpout += match;\n \t\t      }\n \t\t    else\n@@ -4661,8 +4897,8 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\t\t  {\n \t\t\t    uint32_t copy;\n \n-\t\t\t    copy = match < use_offset ? match : use_offset;\n-\t\t\t    memcpy (pout, pout - use_offset, copy);\n+\t\t\t    copy = match < offset ? match : offset;\n+\t\t\t    memcpy (pout, pout - offset, copy);\n \t\t\t    match -= copy;\n \t\t\t    pout += copy;\n \t\t\t  }"}]}