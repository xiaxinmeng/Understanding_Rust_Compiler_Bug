{"sha": "ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI3ZTYwY2VjMWE2ZjQxODViMDQyOGYzYTJiM2U3MWRmMGJhZTUzMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-08-24T13:05:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-08-24T13:05:36Z"}, "message": "Handle SLP permutations for variable-length vectors\n\nThe SLP code currently punts for all variable-length permutes.\nThis patch makes it handle the easy case of N->N permutes in which\nthe number of vector lanes is a multiple of N.  Every permute then\nuses the same mask, and that mask repeats (with a stride) every\nN elements.\n\nThe patch uses the same path for constant-length vectors,\nsince it should be slightly cheaper in terms of compile time.\n\n2018-08-24  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-slp.c (vect_transform_slp_perm_load): Separate out\n\tthe case in which the permute needs only a single element and\n\trepeats for every vector of the result.  Extend that case to\n\thandle variable-length vectors.\n\t* tree-vect-stmts.c (vectorizable_load): Update accordingly.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/slp_perm_1.c: New test.\n\t* gcc.target/aarch64/sve/slp_perm_2.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_perm_3.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_perm_4.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_perm_5.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_perm_6.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_perm_7.c: Likewise.\n\nFrom-SVN: r263832", "tree": {"sha": "c666f7a31ae111b41e904e26bb4df9009c6db203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c666f7a31ae111b41e904e26bb4df9009c6db203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ade64c9d8cd37c8db0a07383189f1719c7164da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ade64c9d8cd37c8db0a07383189f1719c7164da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ade64c9d8cd37c8db0a07383189f1719c7164da"}], "stats": {"total": 349, "additions": 281, "deletions": 68}, "files": [{"sha": "ac459b66076146237089a2e382abcc87ac698676", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -1,3 +1,11 @@\n+2018-08-24  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-slp.c (vect_transform_slp_perm_load): Separate out\n+\tthe case in which the permute needs only a single element and\n+\trepeats for every vector of the result.  Extend that case to\n+\thandle variable-length vectors.\n+\t* tree-vect-stmts.c (vectorizable_load): Update accordingly.\n+\n 2018-08-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR debug/79342"}, {"sha": "db0596469cb1baff79861207751b8161c11072d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -1,3 +1,13 @@\n+2018-08-24  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/slp_perm_1.c: New test.\n+\t* gcc.target/aarch64/sve/slp_perm_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_perm_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_perm_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_perm_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_perm_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_perm_7.c: Likewise.\n+\n 2018-08-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR debug/79342"}, {"sha": "0d4892eab81d8d6b8395144c28ac773c348e741c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_perm_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_1.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f (uint8_t *restrict a, uint8_t *restrict b)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[i * 8] = b[i * 8 + 7] + 1;\n+      a[i * 8 + 1] = b[i * 8 + 6] + 2;\n+      a[i * 8 + 2] = b[i * 8 + 5] + 3;\n+      a[i * 8 + 3] = b[i * 8 + 4] + 4;\n+      a[i * 8 + 4] = b[i * 8 + 3] + 5;\n+      a[i * 8 + 5] = b[i * 8 + 2] + 6;\n+      a[i * 8 + 6] = b[i * 8 + 1] + 7;\n+      a[i * 8 + 7] = b[i * 8 + 0] + 8;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\trevb\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d\\n} 1 } } */"}, {"sha": "86ace58498f36648d68888110ede7e3c040adfe0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_perm_2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_2.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f (uint8_t *restrict a, uint8_t *restrict b)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[i * 8] = b[i * 8 + 3] + 1;\n+      a[i * 8 + 1] = b[i * 8 + 2] + 2;\n+      a[i * 8 + 2] = b[i * 8 + 1] + 3;\n+      a[i * 8 + 3] = b[i * 8 + 0] + 4;\n+      a[i * 8 + 4] = b[i * 8 + 7] + 5;\n+      a[i * 8 + 5] = b[i * 8 + 6] + 6;\n+      a[i * 8 + 6] = b[i * 8 + 5] + 7;\n+      a[i * 8 + 7] = b[i * 8 + 4] + 8;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\trevb\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s\\n} 1 } } */"}, {"sha": "d15215ff94f23340a06bb32fe474d116b9d2d206", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_perm_3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_3.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f (uint8_t *restrict a, uint8_t *restrict b)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[i * 8] = b[i * 8 + 1] + 1;\n+      a[i * 8 + 1] = b[i * 8 + 0] + 2;\n+      a[i * 8 + 2] = b[i * 8 + 3] + 3;\n+      a[i * 8 + 3] = b[i * 8 + 2] + 4;\n+      a[i * 8 + 4] = b[i * 8 + 5] + 5;\n+      a[i * 8 + 5] = b[i * 8 + 4] + 6;\n+      a[i * 8 + 6] = b[i * 8 + 7] + 7;\n+      a[i * 8 + 7] = b[i * 8 + 6] + 8;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\trevb\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h\\n} 1 } } */"}, {"sha": "dc5262a00745284ed910ed022004f320bd29bd08", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_perm_4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_4.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f (uint8_t *restrict a, uint8_t *restrict b, uint8_t *restrict c)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[i * 8] = b[i * 8] + c[i * 8];\n+      a[i * 8 + 1] = b[i * 8] + c[i * 8 + 1];\n+      a[i * 8 + 2] = b[i * 8 + 2] + c[i * 8 + 2];\n+      a[i * 8 + 3] = b[i * 8 + 2] + c[i * 8 + 3];\n+      a[i * 8 + 4] = b[i * 8 + 4] + c[i * 8 + 4];\n+      a[i * 8 + 5] = b[i * 8 + 4] + c[i * 8 + 5];\n+      a[i * 8 + 6] = b[i * 8 + 6] + c[i * 8 + 6];\n+      a[i * 8 + 7] = b[i * 8 + 6] + c[i * 8 + 7];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler {\\ttrn1\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} } } */"}, {"sha": "d5a48af6d9e0910d8a20168d6d671d7780f1d2e4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_perm_5.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_5.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f (uint8_t *restrict a, uint8_t *restrict b,\n+   uint8_t *restrict c, uint8_t *restrict d)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[i * 8] = c[i * 8] + d[i * 8];\n+      a[i * 8 + 1] = c[i * 8] + d[i * 8 + 1];\n+      a[i * 8 + 2] = c[i * 8 + 2] + d[i * 8 + 2];\n+      a[i * 8 + 3] = c[i * 8 + 2] + d[i * 8 + 3];\n+      a[i * 8 + 4] = c[i * 8 + 4] + d[i * 8 + 4];\n+      a[i * 8 + 5] = c[i * 8 + 4] + d[i * 8 + 5];\n+      a[i * 8 + 6] = c[i * 8 + 6] + d[i * 8 + 6];\n+      a[i * 8 + 7] = c[i * 8 + 6] + d[i * 8 + 7];\n+      b[i * 8] = c[i * 8 + 1] + d[i * 8];\n+      b[i * 8 + 1] = c[i * 8 + 1] + d[i * 8 + 1];\n+      b[i * 8 + 2] = c[i * 8 + 3] + d[i * 8 + 2];\n+      b[i * 8 + 3] = c[i * 8 + 3] + d[i * 8 + 3];\n+      b[i * 8 + 4] = c[i * 8 + 5] + d[i * 8 + 4];\n+      b[i * 8 + 5] = c[i * 8 + 5] + d[i * 8 + 5];\n+      b[i * 8 + 6] = c[i * 8 + 7] + d[i * 8 + 6];\n+      b[i * 8 + 7] = c[i * 8 + 7] + d[i * 8 + 7];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler {\\ttrn1\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} } } */\n+/* { dg-final { scan-assembler {\\ttrn2\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} } } */"}, {"sha": "28824611be8ffde31e29aa1feef389e920d318bd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_perm_6.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_6.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f (uint8_t *restrict a, uint8_t *restrict b)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[i * 8] = b[i * 8 + 3] + 1;\n+      a[i * 8 + 1] = b[i * 8 + 6] + 1;\n+      a[i * 8 + 2] = b[i * 8 + 0] + 1;\n+      a[i * 8 + 3] = b[i * 8 + 2] + 1;\n+      a[i * 8 + 4] = b[i * 8 + 1] + 1;\n+      a[i * 8 + 5] = b[i * 8 + 7] + 1;\n+      a[i * 8 + 6] = b[i * 8 + 5] + 1;\n+      a[i * 8 + 7] = b[i * 8 + 4] + 1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\ttbl\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */"}, {"sha": "da9e0a271a05a0ea7a55fe81f2e937134b53c77d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_perm_7.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_perm_7.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f (uint8_t *restrict a, uint8_t *restrict b)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[i * 8] = b[i * 8 + 1] + 1;\n+      a[i * 8 + 1] = b[i * 8 + 7] + 2;\n+      a[i * 8 + 2] = b[i * 8 + 1] + 3;\n+      a[i * 8 + 3] = b[i * 8 + 7] + 4;\n+      a[i * 8 + 4] = b[i * 8 + 1] + 5;\n+      a[i * 8 + 5] = b[i * 8 + 7] + 6;\n+      a[i * 8 + 6] = b[i * 8 + 1] + 7;\n+      a[i * 8 + 7] = b[i * 8 + 7] + 8;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler {\\ttbl\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} } } */"}, {"sha": "0ab7bd8086cc86b70830a93e88508ca7d02698b9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 88, "deletions": 62, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -3606,36 +3606,19 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n {\n   stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n   vec_info *vinfo = stmt_info->vinfo;\n-  tree mask_element_type = NULL_TREE, mask_type;\n   int vec_index = 0;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n+  unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n   unsigned int mask_element;\n   machine_mode mode;\n-  unsigned HOST_WIDE_INT nunits, const_vf;\n \n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return false;\n \n   stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \n   mode = TYPE_MODE (vectype);\n-\n-  /* At the moment, all permutations are represented using per-element\n-     indices, so we can't cope with variable vector lengths or\n-     vectorization factors.  */\n-  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits)\n-      || !vf.is_constant (&const_vf))\n-    return false;\n-\n-  /* The generic VEC_PERM_EXPR code always uses an integral type of the\n-     same size as the vector element being permuted.  */\n-  mask_element_type = lang_hooks.types.type_for_mode\n-    (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n-  mask_type = get_vectype_for_scalar_type (mask_element_type);\n-  vec_perm_builder mask (nunits, nunits, 1);\n-  mask.quick_grow (nunits);\n-  vec_perm_indices indices;\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   /* Initialize the vect stmts of NODE to properly insert the generated\n      stmts later.  */\n@@ -3669,14 +3652,53 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   bool noop_p = true;\n   *n_perms = 0;\n \n-  for (unsigned int j = 0; j < const_vf; j++)\n+  vec_perm_builder mask;\n+  unsigned int nelts_to_build;\n+  unsigned int nvectors_per_build;\n+  bool repeating_p = (group_size == DR_GROUP_SIZE (stmt_info)\n+\t\t      && multiple_p (nunits, group_size));\n+  if (repeating_p)\n     {\n-      for (int k = 0; k < group_size; k++)\n+      /* A single vector contains a whole number of copies of the node, so:\n+\t (a) all permutes can use the same mask; and\n+\t (b) the permutes only need a single vector input.  */\n+      mask.new_vector (nunits, group_size, 3);\n+      nelts_to_build = mask.encoded_nelts ();\n+      nvectors_per_build = SLP_TREE_VEC_STMTS (node).length ();\n+    }\n+  else\n+    {\n+      /* We need to construct a separate mask for each vector statement.  */\n+      unsigned HOST_WIDE_INT const_nunits, const_vf;\n+      if (!nunits.is_constant (&const_nunits)\n+\t  || !vf.is_constant (&const_vf))\n+\treturn false;\n+      mask.new_vector (const_nunits, const_nunits, 1);\n+      nelts_to_build = const_vf * group_size;\n+      nvectors_per_build = 1;\n+    }\n+\n+  unsigned int count = mask.encoded_nelts ();\n+  mask.quick_grow (count);\n+  vec_perm_indices indices;\n+\n+  for (unsigned int j = 0; j < nelts_to_build; j++)\n+    {\n+      unsigned int iter_num = j / group_size;\n+      unsigned int stmt_num = j % group_size;\n+      unsigned int i = (iter_num * DR_GROUP_SIZE (stmt_info)\n+\t\t\t+ SLP_TREE_LOAD_PERMUTATION (node)[stmt_num]);\n+      if (repeating_p)\n \t{\n-\t  unsigned int i = (SLP_TREE_LOAD_PERMUTATION (node)[k]\n-\t\t\t    + j * DR_GROUP_SIZE (stmt_info));\n-\t  vec_index = i / nunits;\n-\t  mask_element = i % nunits;\n+\t  first_vec_index = 0;\n+\t  mask_element = i;\n+\t}\n+      else\n+\t{\n+\t  /* Enforced before the loop when !repeating_p.  */\n+\t  unsigned int const_nunits = nunits.to_constant ();\n+\t  vec_index = i / const_nunits;\n+\t  mask_element = i % const_nunits;\n \t  if (vec_index == first_vec_index\n \t      || first_vec_index == -1)\n \t    {\n@@ -3686,7 +3708,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t   || second_vec_index == -1)\n \t    {\n \t      second_vec_index = vec_index;\n-\t      mask_element += nunits;\n+\t      mask_element += const_nunits;\n \t    }\n \t  else\n \t    {\n@@ -3702,50 +3724,54 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t      return false;\n \t    }\n \n-\t  gcc_assert (mask_element < 2 * nunits);\n-\t  if (mask_element != index)\n-\t    noop_p = false;\n-\t  mask[index++] = mask_element;\n+\t  gcc_assert (mask_element < 2 * const_nunits);\n+\t}\n+\n+      if (mask_element != index)\n+\tnoop_p = false;\n+      mask[index++] = mask_element;\n \n-\t  if (index == nunits && !noop_p)\n+      if (index == count && !noop_p)\n+\t{\n+\t  indices.new_vector (mask, second_vec_index == -1 ? 1 : 2, nunits);\n+\t  if (!can_vec_perm_const_p (mode, indices))\n \t    {\n-\t      indices.new_vector (mask, 2, nunits);\n-\t      if (!can_vec_perm_const_p (mode, indices))\n+\t      if (dump_enabled_p ())\n \t\t{\n-\t\t  if (dump_enabled_p ())\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t   vect_location,\n+\t\t\t\t   \"unsupported vect permute { \");\n+\t\t  for (i = 0; i < count; ++i)\n \t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t       vect_location, \n-\t\t\t\t       \"unsupported vect permute { \");\n-\t\t      for (i = 0; i < nunits; ++i)\n-\t\t\t{\n-\t\t\t  dump_dec (MSG_MISSED_OPTIMIZATION, mask[i]);\n-\t\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" \");\n-\t\t\t}\n-\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"}\\n\");\n+\t\t      dump_dec (MSG_MISSED_OPTIMIZATION, mask[i]);\n+\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \" \");\n \t\t    }\n-\t\t  gcc_assert (analyze_only);\n-\t\t  return false;\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"}\\n\");\n \t\t}\n-\n-\t      ++*n_perms;\n+\t      gcc_assert (analyze_only);\n+\t      return false;\n \t    }\n \n-\t  if (index == nunits)\n+\t  ++*n_perms;\n+\t}\n+\n+      if (index == count)\n+\t{\n+\t  if (!analyze_only)\n \t    {\n-\t      if (!analyze_only)\n-\t\t{\n-\t\t  tree mask_vec = NULL_TREE;\n+\t      tree mask_vec = NULL_TREE;\n \t\t  \n-\t\t  if (! noop_p)\n-\t\t    mask_vec = vec_perm_indices_to_tree (mask_type, indices);\n+\t      if (! noop_p)\n+\t\tmask_vec = vect_gen_perm_mask_checked (vectype, indices);\n \n-\t\t  if (second_vec_index == -1)\n-\t\t    second_vec_index = first_vec_index;\n+\t      if (second_vec_index == -1)\n+\t\tsecond_vec_index = first_vec_index;\n \n+\t      for (unsigned int ri = 0; ri < nvectors_per_build; ++ri)\n+\t\t{\n \t\t  /* Generate the permute statement if necessary.  */\n-\t\t  tree first_vec = dr_chain[first_vec_index];\n-\t\t  tree second_vec = dr_chain[second_vec_index];\n+\t\t  tree first_vec = dr_chain[first_vec_index + ri];\n+\t\t  tree second_vec = dr_chain[second_vec_index + ri];\n \t\t  stmt_vec_info perm_stmt_info;\n \t\t  if (! noop_p)\n \t\t    {\n@@ -3771,12 +3797,12 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t  SLP_TREE_VEC_STMTS (node)[vect_stmts_counter++]\n \t\t    = perm_stmt_info;\n \t\t}\n-\n-\t      index = 0;\n-\t      first_vec_index = -1;\n-\t      second_vec_index = -1;\n-\t      noop_p = true;\n \t    }\n+\n+\t  index = 0;\n+\t  first_vec_index = -1;\n+\t  second_vec_index = -1;\n+\t  noop_p = true;\n \t}\n     }\n "}, {"sha": "63fb1fb17aaad67542f2df7848ffa2d7128459ff", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e60cec1a6f4185b0428f3a2b3e71df0bae533/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ab7e60cec1a6f4185b0428f3a2b3e71df0bae533", "patch": "@@ -8003,13 +8003,18 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (slp)\n \t{\n \t  grouped_load = false;\n-\t  /* For SLP permutation support we need to load the whole group,\n-\t     not only the number of vector stmts the permutation result\n-\t     fits in.  */\n-\t  if (slp_perm)\n+\t  /* If an SLP permutation is from N elements to N elements,\n+\t     and if one vector holds a whole number of N, we can load\n+\t     the inputs to the permutation in the same way as an\n+\t     unpermuted sequence.  In other cases we need to load the\n+\t     whole group, not only the number of vector stmts the\n+\t     permutation result fits in.  */\n+\t  if (slp_perm\n+\t      && (group_size != SLP_INSTANCE_GROUP_SIZE (slp_node_instance)\n+\t\t  || !multiple_p (nunits, group_size)))\n \t    {\n-\t      /* We don't yet generate SLP_TREE_LOAD_PERMUTATIONs for\n-\t\t variable VF.  */\n+\t      /* We don't yet generate such SLP_TREE_LOAD_PERMUTATIONs for\n+\t\t variable VF; see vect_transform_slp_perm_load.  */\n \t      unsigned int const_vf = vf.to_constant ();\n \t      unsigned int const_nunits = nunits.to_constant ();\n \t      vec_num = CEIL (group_size * const_vf, const_nunits);"}]}