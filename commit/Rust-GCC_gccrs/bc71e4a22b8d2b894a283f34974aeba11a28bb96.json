{"sha": "bc71e4a22b8d2b894a283f34974aeba11a28bb96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM3MWU0YTIyYjhkMmI4OTRhMjgzZjM0OTc0YWViYTExYTI4YmI5Ng==", "commit": {"author": {"name": "Thomas Fitzsimmons", "email": "fitzsim@redhat.com", "date": "2005-02-23T17:36:26Z"}, "committer": {"name": "Thomas Fitzsimmons", "email": "fitzsim@gcc.gnu.org", "date": "2005-02-23T17:36:26Z"}, "message": "re PR libgcj/16923 (-D* Options passed to JNI_CreateJavaVM are ignored)\n\n2005-02-23  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\tPR libgcj/16923\n\t* gcj.texi (Invocation): Add descriptions of JvVMInitArgs and\n\tJvVMOption.\n\n2005-02-23  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\tPR libgcj/16923\n\t* jni.cc (JNI_CreateJavaVM): Check JNI version.  Cast args to\n\tJvVMInitArgs.  Pass args to _Jv_CreateJavaVM and check return\n\tvalue.  Move argument parsing code to prims.cc.\n\t* prims.cc (no_properties): Remove.\n\t(_Jv_Compiler_Properties): Initialize to NULL.\n\t(_Jv_Properties_Count): Initialize to 0.\n\t(parse_verbose_args): New function.\n\t(parse_init_args): New function.\n\t(_Jv_CreateJavaVM): Call parse_init_args.\n\t(_Jv_RunMain): Check return value of _Jv_CreateJavaVM.\n\t* gcj/cni.h (JvVMOption): New struct.\n\t(JvVMInitArgs): Likewise.\n\t(JvCreateJavaVM): Declare vm_args as JvVMInitArgs* rather than\n\tvoid*.\n\t* libjava/gcj/javaprims.h (_Jv_VMOption): New struct.\n\t(_Jv_VMInitArgs): Likewise.\n\t* include/java-props.h (_Jv_Properties_Count): Declare.\n\t* java/lang/natRuntime.cc (insertSystemProperties): Use\n\t_Jv_Properties_Count in for loop exit condition.\n\t* testsuite/libjava.jni/jni.exp\n\t(gcj_invocation_compile_c_to_binary): New procedure.\n\t(gcj_invocation_test_one): Likewise.\n\t(gcj_jni_run): Run JNI invocation API tests.\n\t* testsuite/libjava.jni/invocation/PR16923.c,\n\ttestsuite/libjava.jni/invocation/PR16923.java,\n\ttestsuite/libjava.jni/invocation/PR16923.out: New test.\n\nFrom-SVN: r95459", "tree": {"sha": "9b2cca6c033589c537e103cd0b5bbf64f75f3359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b2cca6c033589c537e103cd0b5bbf64f75f3359"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc71e4a22b8d2b894a283f34974aeba11a28bb96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc71e4a22b8d2b894a283f34974aeba11a28bb96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc71e4a22b8d2b894a283f34974aeba11a28bb96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc71e4a22b8d2b894a283f34974aeba11a28bb96/comments", "author": null, "committer": null, "parents": [{"sha": "c150a271b1fa7ad02b245dea1579b3f2e981e85a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c150a271b1fa7ad02b245dea1579b3f2e981e85a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c150a271b1fa7ad02b245dea1579b3f2e981e85a"}], "stats": {"total": 481, "additions": 424, "deletions": 57}, "files": [{"sha": "5f9cd4a92274b2bd5c315f6b598e598c43747a15", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -1,3 +1,9 @@\n+2005-02-23  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\tPR libgcj/16923\n+\t* gcj.texi (Invocation): Add descriptions of JvVMInitArgs and\n+\tJvVMOption.\n+\n 2005-02-22  Tom Tromey  <tromey@redhat.com>\n \n \tPR java/20056:"}, {"sha": "b270b6fbbcffab314a7639169cfcc3380b10e7aa", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -2110,7 +2110,8 @@ CNI permits C++ applications to make calls into Java classes, in addition to\n allowing Java code to call into C++. Several functions, known as the \n @dfn{invocation API}, are provided to support this.\n \n-@deftypefun jint JvCreateJavaVM (void* @var{vm_args})\n+@deftypefun jint JvCreateJavaVM (JvVMInitArgs* @var{vm_args})\n+\n Initializes the Java runtime. This function performs essential initialization\n of the threads interface, garbage collector, exception handling and other key\n aspects of the runtime. It must be called once by an application with\n@@ -2119,11 +2120,40 @@ It is safe, but not recommended, to call @code{JvCreateJavaVM()} more than\n once provided it is only called from a single thread.\n The @var{vmargs} parameter can be used to specify initialization parameters \n for the Java runtime. It may be @code{NULL}.\n-This function returns @code{0} upon success, or @code{-1} if the runtime is\n-already initialized.\n \n-@emph{Note:} In GCJ 3.1, the @code{vm_args} parameter is ignored. It may be \n-used in a future release.\n+JvVMInitArgs represents a list of virtual machine initialization\n+arguments. @code{JvCreateJavaVM()} ignores the version field.\n+\n+@example\n+typedef struct JvVMOption\n+@{\n+  // a VM initialization option\n+  char* optionString;\n+  // extra information associated with this option\n+  void* extraInfo;\n+@} JvVMOption;\n+\n+typedef struct JvVMInitArgs\n+@{\n+  // for compatibility with JavaVMInitArgs\n+  jint version;\n+\n+  // number of VM initialization options\n+  jint nOptions;\n+\n+  // an array of VM initialization options\n+  JvVMOption* options;\n+\n+  // true if the option parser should ignore unrecognized options\n+  jboolean ignoreUnrecognized;\n+@} JvVMInitArgs;\n+@end example\n+\n+@code{JvCreateJavaVM()} returns @code{0} upon success, or @code{-1} if\n+the runtime is already initialized.\n+\n+@emph{Note:} In GCJ 3.1, the @code{vm_args} parameter is ignored. It\n+is recognized and used as of release 4.0.\n @end deftypefun\n \n @deftypefun java::lang::Thread* JvAttachCurrentThread (jstring @var{name}, java::lang::ThreadGroup* @var{group})"}, {"sha": "b12241c9caf6d970435375167f8734f7557234d7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -1,3 +1,33 @@\n+2005-02-23  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\tPR libgcj/16923\n+\t* jni.cc (JNI_CreateJavaVM): Check JNI version.  Cast args to\n+\tJvVMInitArgs.  Pass args to _Jv_CreateJavaVM and check return\n+\tvalue.  Move argument parsing code to prims.cc.\n+\t* prims.cc (no_properties): Remove.\n+\t(_Jv_Compiler_Properties): Initialize to NULL.\n+\t(_Jv_Properties_Count): Initialize to 0.\n+\t(parse_verbose_args): New function.\n+\t(parse_init_args): New function.\n+\t(_Jv_CreateJavaVM): Call parse_init_args.\n+\t(_Jv_RunMain): Check return value of _Jv_CreateJavaVM.\n+\t* gcj/cni.h (JvVMOption): New struct.\n+\t(JvVMInitArgs): Likewise.\n+\t(JvCreateJavaVM): Declare vm_args as JvVMInitArgs* rather than\n+\tvoid*.\n+\t* libjava/gcj/javaprims.h (_Jv_VMOption): New struct.\n+\t(_Jv_VMInitArgs): Likewise.\n+\t* include/java-props.h (_Jv_Properties_Count): Declare.\n+\t* java/lang/natRuntime.cc (insertSystemProperties): Use\n+\t_Jv_Properties_Count in for loop exit condition.\n+\t* testsuite/libjava.jni/jni.exp\n+\t(gcj_invocation_compile_c_to_binary): New procedure.\n+\t(gcj_invocation_test_one): Likewise.\n+\t(gcj_jni_run): Run JNI invocation API tests.\n+\t* testsuite/libjava.jni/invocation/PR16923.c,\n+\ttestsuite/libjava.jni/invocation/PR16923.java,\n+\ttestsuite/libjava.jni/invocation/PR16923.out: New test.\n+\n 2005-02-23  Michael Koch  <konqueror@gmx.de>\n \n \t* Makefile.am: Added new file gnu/java/nio/ChannelReader.java."}, {"sha": "4aea4b6e4a7b6490859b112e91ba23de01a097fd", "filename": "libjava/gcj/cni.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fgcj%2Fcni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fgcj%2Fcni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fcni.h?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -17,6 +17,7 @@ details.  */\n #include <java/lang/Class.h>\n \n #include <gcj/array.h>\n+#include <gcj/javaprims.h>\n \n #include <string.h>\n \n@@ -113,8 +114,11 @@ JvFree (void *ptr)\n   return _Jv_Free (ptr);\n }\n \n+typedef struct _Jv_VMOption JvVMOption;\n+typedef struct _Jv_VMInitArgs JvVMInitArgs;\n+\n extern inline jint\n-JvCreateJavaVM (void* vm_args)\n+JvCreateJavaVM (JvVMInitArgs* vm_args)\n {\n   return _Jv_CreateJavaVM (vm_args);\n }"}, {"sha": "e972f7ba518f4604209ffb33e752b1ad54707474", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -487,7 +487,30 @@ extern \"C\" jsize _Jv_GetStringUTFLength (jstring);\n extern \"C\" jsize _Jv_GetStringUTFRegion (jstring, jsize, jsize, char *);\n extern \"C\" jint _Jv_hashUtf8String (char*, int);\n \n-extern jint _Jv_CreateJavaVM (void* /*vm_args*/);\n+struct _Jv_VMOption\n+{\n+  // a VM initialization option\n+  char* optionString;\n+  // extra information associated with this option\n+  void* extraInfo;\n+};\n+\n+struct _Jv_VMInitArgs\n+{\n+  // for compatibility with JavaVMInitArgs\n+  jint version;\n+\n+  // number of VM initialization options\n+  jint nOptions;\n+\n+  // an array of VM initialization options\n+  struct _Jv_VMOption* options;\n+\n+  // true if the option parser should ignore unrecognized options\n+  jboolean ignoreUnrecognized;\n+};\n+\n+extern jint _Jv_CreateJavaVM (struct _Jv_VMInitArgs*);\n \n void\n _Jv_ThreadRun (java::lang::Thread* thread);"}, {"sha": "19d7106f8f22b897c0f59207ef21eebcd0159234", "filename": "libjava/include/java-props.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Finclude%2Fjava-props.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Finclude%2Fjava-props.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-props.h?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -21,6 +21,7 @@ typedef struct\n \n // Set to NULL-terminated list of properties set at compile time.\n extern const char **_Jv_Compiler_Properties;\n+extern int _Jv_Properties_Count;\n \n // The JAR file to add to the beginning of java.class.path.\n extern const char *_Jv_Jar_Class_Path;"}, {"sha": "31f9b90b6fa4d3a6b4e1b104ae2e5f05370aec9d", "filename": "libjava/java/lang/natRuntime.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -557,7 +557,7 @@ java::lang::Runtime::insertSystemProperties (java::util::Properties *newprops)\n   // `-D'.  Important: after this point, the only properties that\n   // should be set are those which either the user cannot meaningfully\n   // override, or which augment whatever value the user has provided.\n-  for (int i = 0; _Jv_Compiler_Properties[i]; ++i)\n+  for (int i = 0; i < _Jv_Properties_Count; ++i)\n     {\n       const char *s, *p;\n       // Find the `='."}, {"sha": "5f9d5f79e719d50fba1d0b4df97d6382554251ee", "filename": "libjava/jni.cc", "status": "modified", "additions": 10, "deletions": 43, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -2498,56 +2498,23 @@ JNI_CreateJavaVM (JavaVM **vm, void **penv, void *args)\n {\n   JvAssert (! the_vm);\n \n-  _Jv_CreateJavaVM (NULL);\n+  jint version = * (jint *) args;\n+  // We only support 1.2 and 1.4.\n+  if (version != JNI_VERSION_1_2 && version != JNI_VERSION_1_4)\n+    return JNI_EVERSION;\n+\n+  JvVMInitArgs* vm_args = reinterpret_cast<JvVMInitArgs *> (args);\n+\n+  jint result = _Jv_CreateJavaVM (vm_args);\n+  if (result)\n+    return result;\n \n   // FIXME: synchronize\n   JavaVM *nvm = (JavaVM *) _Jv_MallocUnchecked (sizeof (JavaVM));\n   if (nvm == NULL)\n     return JNI_ERR;\n   nvm->functions = &_Jv_JNI_InvokeFunctions;\n \n-  // Parse the arguments.\n-  if (args != NULL)\n-    {\n-      jint version = * (jint *) args;\n-      // We only support 1.2 and 1.4.\n-      if (version != JNI_VERSION_1_2 && version != JNI_VERSION_1_4)\n-\treturn JNI_EVERSION;\n-      JavaVMInitArgs *ia = reinterpret_cast<JavaVMInitArgs *> (args);\n-      for (int i = 0; i < ia->nOptions; ++i)\n-\t{\n-\t  if (! strcmp (ia->options[i].optionString, \"vfprintf\")\n-\t      || ! strcmp (ia->options[i].optionString, \"exit\")\n-\t      || ! strcmp (ia->options[i].optionString, \"abort\"))\n-\t    {\n-\t      // We are required to recognize these, but for now we\n-\t      // don't handle them in any way.  FIXME.\n-\t      continue;\n-\t    }\n-\t  else if (! strncmp (ia->options[i].optionString,\n-\t\t\t      \"-verbose\", sizeof (\"-verbose\") - 1))\n-\t    {\n-\t      // We don't do anything with this option either.  We\n-\t      // might want to make sure the argument is valid, but we\n-\t      // don't really care all that much for now.\n-\t      continue;\n-\t    }\n-\t  else if (! strncmp (ia->options[i].optionString, \"-D\", 2))\n-\t    {\n-\t      // FIXME.\n-\t      continue;\n-\t    }\n-\t  else if (ia->ignoreUnrecognized)\n-\t    {\n-\t      if (ia->options[i].optionString[0] == '_'\n-\t\t  || ! strncmp (ia->options[i].optionString, \"-X\", 2))\n-\t\tcontinue;\n-\t    }\n-\n-\t  return JNI_ERR;\n-\t}\n-    }\n-\n   jint r =_Jv_JNI_AttachCurrentThread (nvm, penv, NULL);\n   if (r < 0)\n     return r;"}, {"sha": "cf0fed10dd4654407871b573c692bcc8ceaa07bb", "filename": "libjava/prims.cc", "status": "modified", "additions": 175, "deletions": 6, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -80,10 +80,9 @@ static java::lang::OutOfMemoryError *no_memory;\n // functions are changed to take a size_t argument instead of jint.\n #define MAX_OBJECT_SIZE ((1<<31) - 1)\n \n-static const char *no_properties[] = { NULL };\n-\n // Properties set at compile time.\n-const char **_Jv_Compiler_Properties = no_properties;\n+const char **_Jv_Compiler_Properties = NULL;\n+int _Jv_Properties_Count = 0;\n \n // The JAR file to add to the beginning of java.class.path.\n const char *_Jv_Jar_Class_Path;\n@@ -909,16 +908,181 @@ namespace gcj\n   bool runtimeInitialized = false;\n }\n \n+static jint\n+parse_verbose_args (char* option_string,\n+\t\t    bool ignore_unrecognized)\n+{\n+  size_t len = sizeof (\"-verbose\");\n+\n+  if (strlen (option_string) < len)\n+    return -1;\n+\n+  if (option_string[len] == ':'\n+      && option_string[len + 1] != '\\0')\n+    {\n+      char* verbose_args = option_string + len + 1;\n+      size_t last = 0;\n+\n+      do\n+\t{\n+\t  if (! strncmp (verbose_args,\n+\t\t\t \"gc\", (last = sizeof (\"gc\")) - 1)\n+\t      && (verbose_args[last] == '\\0'\n+\t\t  || verbose_args[last] == ','))\n+\t    {\n+\t      // FIXME: we should add functions to boehm-gc that\n+\t      // toggle GC_print_stats, GC_PRINT_ADDRESS_MAP and\n+\t      // GC_print_back_height.\n+\n+\t    }\n+\t  else if (! strncmp (verbose_args,\n+\t\t\t      \"class\",\n+\t\t\t      (last = sizeof (\"class\")) - 1)\n+\t\t   && (verbose_args[last] == '\\0'\n+\t\t       || verbose_args[last] == ','))\n+\t    {\n+\t      gcj::verbose_class_flag = true;\n+\t    }\n+\t  else if (! strncmp (verbose_args, \"jni\",\n+\t\t\t      (last = sizeof (\"jni\")) - 1)\n+\t\t   && (verbose_args[last] == '\\0'\n+\t\t       || verbose_args[last] == ','))\n+\t    {\n+\t      // FIXME: enable JNI messages.\n+\t    }\n+\t  else if (ignore_unrecognized\n+\t\t   && verbose_args[0] == 'X')\n+\t    {\n+\t      // ignore unrecognized non-standard verbose option\n+\t      last = 0;\n+\t      while (verbose_args[last] != '\\0'\n+\t\t     && verbose_args[last++] != ',');\n+\t    }\n+\n+\t  if (strlen (verbose_args) >= last)\n+\t    {\n+\t      if (verbose_args[last] == ',')\n+\t\t{\n+\t\t  if (verbose_args[last + 1] == '\\0')\n+\t\t    // trailing comma\n+\t\t    return -1;\n+\t\t  else\n+\t\t    {\n+\t\t      verbose_args = verbose_args + last + 1;\n+\t\t      last = 0;\n+\t\t    }\n+\t\t}\n+\t      // here verbose_args[last] is either '\\0' or\n+\t      // the first character in the next verbose\n+\t      // argument.\n+\t    }\n+\t  else\n+\t    // partial option\n+\t    return -1;\n+\n+\t  // verbose_args[last] will be '\\0' here if we're\n+\t  // done.\n+\t}\n+      while (verbose_args[last] != '\\0');\n+    }\n+  else if (option_string[len] == 'g'\n+\t   && option_string[len + 1] == 'c'\n+\t   && option_string[len + 2] == '\\0')\n+    {\n+      // FIXME: we should add functions to boehm-gc that\n+      // toggle GC_print_stats, GC_PRINT_ADDRESS_MAP and\n+      // GC_print_back_height.\n+      return 0;\n+    }\n+  else if (option_string[len] == '\\0')\n+    {\n+      gcj::verbose_class_flag = true;\n+      return 0;\n+    }\n+  else\n+    {\n+      // unrecognized option beginning with -verbose\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+static jint\n+parse_init_args (JvVMInitArgs* vm_args)\n+{\n+  // if _Jv_Compiler_Properties is non-NULL then it needs to be\n+  // re-allocated dynamically.\n+  if (_Jv_Compiler_Properties)\n+    {\n+      const char** props = _Jv_Compiler_Properties;\n+      _Jv_Compiler_Properties = NULL;\n+\n+      for (int i = 0; props[i]; i++)\n+\t{\n+\t  _Jv_Compiler_Properties = (const char**) _Jv_Realloc\n+\t    (_Jv_Compiler_Properties,\n+\t     (_Jv_Properties_Count + 1) * sizeof (const char*));\n+\t  _Jv_Compiler_Properties[_Jv_Properties_Count++] = props[i];\n+\t}\n+    }\n+\n+  if (vm_args == NULL)\n+    return 0;\n+\n+  for (int i = 0; i < vm_args->nOptions; ++i)\n+    {\n+      char* option_string = vm_args->options[i].optionString;\n+      if (! strcmp (option_string, \"vfprintf\")\n+\t  || ! strcmp (option_string, \"exit\")\n+\t  || ! strcmp (option_string, \"abort\"))\n+\t{\n+\t  // FIXME: we are required to recognize these, but for\n+\t  // now we don't handle them in any way.\n+\t  continue;\n+\t}\n+      else if (! strncmp (option_string,\n+\t\t\t  \"-verbose\", sizeof (\"-verbose\") - 1))\n+\t{\n+\t  jint result = parse_verbose_args (option_string,\n+\t\t\t\t\t    vm_args->ignoreUnrecognized);\n+\t  if (result < 0)\n+\t    return result;\n+\t}\n+      else if (! strncmp (option_string, \"-D\", 2))\n+\t{\n+\t  _Jv_Compiler_Properties = (const char**) _Jv_Realloc\n+\t    (_Jv_Compiler_Properties,\n+\t     (_Jv_Properties_Count + 1) * sizeof (char*));\n+\n+\t  _Jv_Compiler_Properties[_Jv_Properties_Count++] =\n+\t    strdup (option_string + 2);\n+\n+\t  continue;\n+\t}\n+      else if (vm_args->ignoreUnrecognized)\n+\t{\n+\t  if (option_string[0] == '_'\n+\t      || ! strncmp (option_string, \"-X\", 2))\n+\t    continue;\n+\t}\n+    }\n+  return 0;\n+}\n+\n jint\n-_Jv_CreateJavaVM (void* /*vm_args*/)\n+_Jv_CreateJavaVM (JvVMInitArgs* vm_args)\n {\n   using namespace gcj;\n-  \n+\n   if (runtimeInitialized)\n     return -1;\n \n   runtimeInitialized = true;\n \n+  jint result = parse_init_args (vm_args);\n+  if (result < 0)\n+    return -1;\n+\n   PROCESS_GCJ_PROPERTIES;\n \n   /* Threads must be initialized before the GC, so that it inherits the\n@@ -1016,7 +1180,12 @@ _Jv_RunMain (jclass klass, const char *name, int argc, const char **argv,\n       // is initialized.\n       if (is_jar)\n \t_Jv_Jar_Class_Path = strdup (name);\n-      _Jv_CreateJavaVM (NULL);\n+\n+      if (_Jv_CreateJavaVM (NULL) < 0)\n+\t{\n+\t  fprintf (stderr, \"libgcj: couldn't create virtual machine\\n\");\n+\t  exit (1);\n+\t}\n \n       // Get the Runtime here.  We want to initialize it before searching\n       // for `main'; that way it will be set up if `main' is a JNI method."}, {"sha": "881738b61ca9f68e95ed88e6b8895a29418c01cd", "filename": "libjava/testsuite/libjava.jni/invocation/PR16923.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.c?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -0,0 +1,43 @@\n+#include <assert.h>\n+#include <jni.h>\n+\n+union env_union\n+{\n+  void *void_env;\n+  JNIEnv *jni_env;\n+};\n+\n+int\n+main (int argc, const char** argv)\n+{\n+  union env_union tmp;\n+  JNIEnv* env;\n+  JavaVM* jvm;\n+  JavaVMInitArgs vm_args;\n+  JavaVMOption options[1];\n+  jclass class_id;\n+  jmethodID method_id;\n+  jint result;\n+\n+  options[0].optionString = \"-DPR16923=optionReceived\";\n+\n+  vm_args.version = JNI_VERSION_1_2;\n+  vm_args.ignoreUnrecognized = JNI_TRUE;\n+  vm_args.options = options;\n+  vm_args.nOptions = 1;\n+\n+  result = JNI_CreateJavaVM (&jvm, &tmp.void_env, &vm_args);\n+  assert (result >= 0);\n+\n+  env = tmp.jni_env;\n+\n+  class_id = (*env)->FindClass (env, \"PR16923\");\n+  assert (class_id);\n+\n+  method_id = (*env)->GetStaticMethodID (env, class_id, \"printIt\", \"()V\");\n+  assert (method_id);\n+\n+  (*env)->CallStaticVoidMethod (env, class_id, method_id, NULL);\n+\n+  return 0;\n+}"}, {"sha": "efda4bd755a2d095ff48ab3d7791bee79b47b211", "filename": "libjava/testsuite/libjava.jni/invocation/PR16923.java", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.java?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -0,0 +1,7 @@\n+public class PR16923\n+{\n+  public static void printIt ()\n+  {\n+    System.out.println (System.getProperty (\"PR16923\"));\n+  }\n+}"}, {"sha": "58bf3fe1982bcc13a6cc36eb694730f570f398fd", "filename": "libjava/testsuite/libjava.jni/invocation/PR16923.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jni%2Finvocation%2FPR16923.out?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -0,0 +1 @@\n+optionReceived"}, {"sha": "d736b8690d670939bae7c74763cad20ff30b8a26", "filename": "libjava/testsuite/libjava.jni/jni.exp", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Fjni.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc71e4a22b8d2b894a283f34974aeba11a28bb96/libjava%2Ftestsuite%2Flibjava.jni%2Fjni.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jni%2Fjni.exp?ref=bc71e4a22b8d2b894a283f34974aeba11a28bb96", "patch": "@@ -181,6 +181,85 @@ proc gcj_jni_test_one {file} {\n   return 1\n }\n \n+# Compile a single C file and produce a binary.  OPTIONS is a list of\n+# options to pass to the compiler.  Returns 0 on failure, 1 on\n+# success.\n+proc gcj_jni_invocation_compile_c_to_binary {file {options {}}} {\n+  global srcdir\n+  global host_triplet\n+  verbose \"options: $options\"\n+  set options_cxx $options\n+  set options \"\"\n+\n+  set filename [file tail $file]\n+  set name [file rootname $filename]\n+\n+  # Find jni.h.\n+  lappend options \"additional_flags=-I$srcdir/../include\"\n+\n+  # Append C++ options\n+  lappend options \"additional_flags=$options_cxx\"\n+\n+  set x [libjava_prune_warnings \\\n+\t   [target_compile $file $name executable $options]]\n+  if {$x != \"\"} {\n+    verbose \"target_compile failed: $x\" 2\n+    fail \"$filename compilation\"\n+    return 0\n+  }\n+\n+  pass \"$filename compilation\"\n+  return 1\n+}\n+\n+# Do all the work for a single invocation API test.  Return 0 on\n+# failure.\n+proc gcj_jni_invocation_test_one {file} {\n+  global runtests\n+  global host_triplet\n+  global INTERPRETER\n+\n+  # The base name.  We use it for several purposes.\n+  set main [file rootname [file tail $file]]\n+  if {! [runtest_file_p $runtests $main]} {\n+    # Simply skip it.\n+    return 1\n+  }\n+\n+  if {! [bytecompile_file $file [pwd]]} {\n+    fail \"bytecompile $file\"\n+    # FIXME - should use `untested' on all remaining tests.\n+    # But that is hard.\n+    return 0\n+  }\n+  pass \"bytecompile $file\"\n+\n+  set cfile [file rootname $file].c\n+  set cxxflags \"-lgcj\"\n+\n+  if {! [gcj_jni_invocation_compile_c_to_binary $cfile $cxxflags]} {\n+    # FIXME\n+    return 0\n+  }\n+\n+  set resultfile [file rootname $file].out\n+\n+  if {! [gcj_invoke $main $resultfile \"\"]} {\n+    # FIXME\n+    return 0\n+  }\n+\n+  # We purposely ignore errors here; we still want to run the other\n+  # appropriate tests.\n+  set errname [file rootname [file tail $file]]\n+\n+  # When we succeed we remove all our clutter.\n+  eval gcj_cleanup [glob -nocomplain -- ${main}.*] \\\n+    [list $main]\n+\n+  return 1\n+}\n+\n # Run the JNI tests.\n proc gcj_jni_run {} {\n   global srcdir subdir\n@@ -193,6 +272,13 @@ proc gcj_jni_run {} {\n     foreach x $srcfiles {\n       gcj_jni_test_one $x\n     }\n+\n+    # Run JNI invocation API tests\n+    catch { lsort [glob -nocomplain ${srcdir}/${subdir}/invocation/*.java] } srcfiles\n+\n+    foreach x $srcfiles {\n+      gcj_jni_invocation_test_one $x\n+    }\n   } else {\n     verbose \"JNI tests not run in cross-compilation environment\"\n   }"}]}