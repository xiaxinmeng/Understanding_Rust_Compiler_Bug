{"sha": "069f46c71e9432eda3d48a366e5c2a750cf8d612", "node_id": "C_kwDOANBUbNoAKDA2OWY0NmM3MWU5NDMyZWRhM2Q0OGEzNjZlNWMyYTc1MGNmOGQ2MTI", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-24T12:57:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-07-05T15:08:50Z"}, "message": "c++: Prune ordinary locations\n\nLike macro locations, we only need to emit ordinary location\ninformation for locations emitted into the CMI. This adds a hash table\nnoting which ordinary lines are needed.  These are then sorted and\n(sufficiently) adjacent lines are coalesced to a single map.  There is\na tradeoff here, allowing greater separation reduces the number of\nline maps, but increases the number of locations.  It appears allowing\n2 or 3 intervening lines is the sweet spot, and this patch chooses 2.\n\nCompiling a hello-world #includeing <iostream> in it's GMF gives a\nreduction in number of locations of 5 fold, but an increase in number\nof maps about 4 fold.  Examining one of the xtreme-header tests we\nhalve the number of locations and increase the number of maps by 9\nfold.\n\nModule interfaces that emit no entities (or macros, if a header-unit),\nwill now have no location tables.\n\n\tgcc/cp/\n\t* module.cc\n\t(struct ord_loc_info, ord_loc_traits): New.\n\t(ord_loc_tabke, ord_loc_remap): New globals.\n\t(struct location_map_info): Delete.\n\t(struct module_state_config): Rename ordinary_loc_align to\n\tloc_range_bits.\n\t(module_for_ordinary_loc): Adjust.\n\t(module_state::note_location): Note ordinary locations,\n\treturn bool.\n\t(module_state::write_location): Adjust ordinary location\n\tstreaming.\n\t(module_state::read_location): Likewise.\n\t(module_state::write_init_maps): Allocate ord_loc_table.\n\t(module_state::write_prepare_maps): Reimplement ordinary\n\tmap preparation.\n\t(module_state::read_prepare_maps): Adjust.\n\t(module_state::write_ordinary_maps): Reimplement.\n\t(module_state::write_macro_maps): Adjust.\n\t(module_state::read_ordinary_maps): Reimplement.\n\t(module_state::write_macros): Adjust.\n\t(module_state::write_config): Adjust.\n\t(module_state::read_config): Adjust.\n\t(module_state::write_begin): Adjust.\n\t(module_state::read_initial): Adjust.\n\tgcc/testsuite/\n\t* g++.dg/modules/loc-prune-1.C: Adjust.\n\t* g++.dg/modules/loc-prune-4.C: New.\n\t* g++.dg/modules/pr98718_a.C: Adjust.\n\t* g++.dg/modules/pr98718_b.C: Adjust.\n\t* g++.dg/modules/pr99072.H: Adjust.", "tree": {"sha": "3c3b3c58a1773b04d170446a6e991122d0701351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c3b3c58a1773b04d170446a6e991122d0701351"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/069f46c71e9432eda3d48a366e5c2a750cf8d612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/069f46c71e9432eda3d48a366e5c2a750cf8d612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/069f46c71e9432eda3d48a366e5c2a750cf8d612", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/069f46c71e9432eda3d48a366e5c2a750cf8d612/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07dd0f7ba27d1fe9f0ce5b049ac5735dc5d361ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07dd0f7ba27d1fe9f0ce5b049ac5735dc5d361ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07dd0f7ba27d1fe9f0ce5b049ac5735dc5d361ad"}], "stats": {"total": 661, "additions": 375, "deletions": 286}, "files": [{"sha": "f27f4d091e5e3a95a6ba55a18e67b7003861b39d", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 347, "deletions": 282, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=069f46c71e9432eda3d48a366e5c2a750cf8d612", "patch": "@@ -3240,6 +3240,66 @@ class loc_spans {\n \n static loc_spans spans;\n \n+/* Information about ordinary locations we stream out.  */\n+struct ord_loc_info\n+{\n+  const line_map_ordinary *src; // line map we're based on\n+  unsigned offset;\t// offset to this line\n+  unsigned span;\t// number of locs we span\n+  unsigned remap;\t// serialization\n+\n+  static int compare (const void *a_, const void *b_)\n+  {\n+    auto *a = static_cast<const ord_loc_info *> (a_);\n+    auto *b = static_cast<const ord_loc_info *> (b_);\n+\n+    if (a->src != b->src)\n+      return a->src < b->src ? -1 : +1;\n+\n+    // Ensure no overlap\n+    gcc_checking_assert (a->offset + a->span <= b->offset\n+\t\t\t || b->offset + b->span <= a->offset);\n+\n+    gcc_checking_assert (a->offset != b->offset);\n+    return a->offset < b->offset ? -1 : +1;\n+  }\n+};\n+struct ord_loc_traits\n+{\n+  typedef ord_loc_info value_type;\n+  typedef value_type compare_type;\n+\n+  static const bool empty_zero_p = false;\n+\n+  static hashval_t hash (const value_type &v)\n+  {\n+    auto h = pointer_hash<const line_map_ordinary>::hash (v.src);\n+    return iterative_hash_hashval_t (v.offset, h);\n+  }\n+  static bool equal (const value_type &v, const compare_type p)\n+  {\n+    return v.src == p.src && v.offset == p.offset;\n+  }\n+\n+  static void mark_empty (value_type &v)\n+  {\n+    v.src = nullptr;\n+  }\n+  static bool is_empty (value_type &v)\n+  {\n+    return !v.src;\n+  }\n+\n+  static bool is_deleted (value_type &) { return false; }\n+  static void mark_deleted (value_type &) { gcc_unreachable (); }\n+  \n+  static void remove (value_type &) {}\n+};\n+/* Table keyed by ord_loc_info, used for noting.  */\n+static  hash_table<ord_loc_traits> *ord_loc_table;\n+/* Sorted vector, used for writing.  */\n+static vec<ord_loc_info> *ord_loc_remap;\n+\n /* Information about macro locations we stream out.  */\n struct macro_loc_info\n {\n@@ -3401,15 +3461,7 @@ void slurping::release_macros ()\n     elf_in::release (from, macro_tbl);\n }\n \n-/* Information about location maps used during writing.  */\n-\n-struct location_map_info {\n-  range_t num_maps;\n-\n-  unsigned max_range;\n-};\n-\n-/* Flage for extensions that end up being streamed.  */\n+/* Flags for extensions that end up being streamed.  */\n \n enum streamed_extensions {\n   SE_OPENMP = 1 << 0,\n@@ -3652,14 +3704,13 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n \n  private:\n   void write_init_maps ();\n-  location_map_info write_prepare_maps (module_state_config *);\n+  range_t write_prepare_maps (module_state_config *, bool);\n   bool read_prepare_maps (const module_state_config *);\n \n-  void write_ordinary_maps (elf_out *to, location_map_info &,\n-\t\t\t    module_state_config *, bool, unsigned *crc_ptr);\n-  bool read_ordinary_maps ();\n-  void write_macro_maps (elf_out *to, location_map_info &,\n-\t\t\t module_state_config *, unsigned *crc_ptr);\n+  void write_ordinary_maps (elf_out *to, range_t &,\n+\t\t\t    bool, unsigned *crc_ptr);\n+  bool read_ordinary_maps (unsigned, unsigned);\n+  void write_macro_maps (elf_out *to, range_t &, unsigned *crc_ptr);\n   bool read_macro_maps (unsigned);\n \n  private:\n@@ -3678,7 +3729,7 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n   static cpp_macro *deferred_macro (cpp_reader *, location_t, cpp_hashnode *);\n \n  public:\n-  static void note_location (location_t);\n+  static bool note_location (location_t);\n   static void write_location (bytes_out &, location_t);\n   location_t read_location (bytes_in &) const;\n \n@@ -14444,14 +14495,14 @@ struct module_state_config {\n   unsigned num_entities;\n   unsigned ordinary_locs;\n   unsigned macro_locs;\n-  unsigned ordinary_loc_align;\n+  unsigned loc_range_bits;\n   unsigned active_init;\n \n public:\n   module_state_config ()\n     :dialect_str (get_dialect ()),\n      num_imports (0), num_partitions (0), num_entities (0),\n-     ordinary_locs (0), macro_locs (0), ordinary_loc_align (0),\n+     ordinary_locs (0), macro_locs (0), loc_range_bits (0),\n      active_init (0)\n   {\n   }\n@@ -15562,7 +15613,7 @@ module_for_ordinary_loc (location_t loc)\n       module_state *probe = (*ool)[pos + half];\n       if (loc < probe->ordinary_locs.first)\n \tlen = half;\n-      else if (loc < probe->ordinary_locs.second)\n+      else if (loc < probe->ordinary_locs.first + probe->ordinary_locs.second)\n \treturn probe;\n       else\n \t{\n@@ -15589,7 +15640,7 @@ module_for_macro_loc (location_t loc)\n \t  pos += half + 1;\n \t  len = len - (half + 1);\n \t}\n-      else if (loc >= (probe->macro_locs.first + probe->macro_locs.second))\n+      else if (loc >= probe->macro_locs.first + probe->macro_locs.second)\n \tlen = half;\n       else\n \treturn probe;\n@@ -15614,10 +15665,11 @@ module_state::imported_from () const\n /* Note that LOC will need writing.  This allows us to prune locations\n    that are not needed.  */\n \n-void\n+bool\n module_state::note_location (location_t loc)\n {\n-  if (!macro_loc_table)\n+  bool added = false;\n+  if (!macro_loc_table && !ord_loc_table)\n     ;\n   else if (loc < RESERVED_LOCATION_COUNT)\n     ;\n@@ -15654,17 +15706,33 @@ module_state::note_location (location_t loc)\n \t\t    tloc = mac_map->macro_locations[ix];\n \t\t    note_location (tloc);\n \t\t  }\n+\t      added = true;\n \t    }\n \t}\t\t\t\t       \n     }\n   else if (IS_ORDINARY_LOC (loc))\n     {\n-      /* This is where we should note we use this location.  See comment\n-\t about write_ordinary_maps.  */\n+      if (spans.ordinary (loc))\n+\t{\n+\t  const line_map *map = linemap_lookup (line_table, loc);\n+\t  const line_map_ordinary *ord_map = linemap_check_ordinary (map);\n+\t  ord_loc_info lkup;\n+\t  lkup.src = ord_map;\n+\t  lkup.span = 1 << ord_map->m_column_and_range_bits;\n+\t  lkup.offset = (loc - MAP_START_LOCATION (ord_map)) & ~(lkup.span - 1);\n+\t  lkup.remap = 0;\n+\t  ord_loc_info *slot = (ord_loc_table->find_slot_with_hash\n+\t\t\t\t(lkup, ord_loc_traits::hash (lkup), INSERT));\n+\t  if (!slot->src)\n+\t    {\n+\t      *slot = lkup;\n+\t      added = true;\n+\t    }\n+\t}\n     }\n   else\n     gcc_unreachable ();\n-  return;\n+  return added;\n }\n \n /* If we're not streaming, record that we need location LOC.\n@@ -15745,16 +15813,37 @@ module_state::write_location (bytes_out &sec, location_t loc)\n     }\n   else if (IS_ORDINARY_LOC (loc))\n     {\n-      if (const loc_spans::span *span = spans.ordinary (loc))\n+      const ord_loc_info *info = nullptr;\n+      unsigned offset = 0;\n+      if (unsigned hwm = ord_loc_remap->length ())\n \t{\n-\t  unsigned off = loc;\n+\t  info = ord_loc_remap->begin ();\n+\t  while (hwm != 1)\n+\t    {\n+\t      unsigned mid = hwm / 2;\n+\t      if (MAP_START_LOCATION (info[mid].src) + info[mid].offset <= loc)\n+\t\t{\n+\t\t  info += mid;\n+\t\t  hwm -= mid;\n+\t\t}\n+\t      else\n+\t\thwm = mid;\n+\t    }\n+\t  offset = loc - MAP_START_LOCATION (info->src) - info->offset;\n+\t  if (offset > info->span)\n+\t    info = nullptr;\n+\t}\n+\n+      gcc_checking_assert (bool (info) == bool (spans.ordinary (loc)));\n \n-\t  off += span->ordinary_delta;\n+      if (info)\n+\t{\n+\t  offset += info->remap;\n \t  sec.u (LK_ORDINARY);\n-\t  sec.u (off);\n+\t  sec.u (offset);\n \n \t  dump (dumper::LOCATION)\n-\t    && dump (\"Ordinary location %u output %u\", loc, off);\n+\t    && dump (\"Ordinary location %u output %u\", loc, offset);\n \t}\n       else if (const module_state *import = module_for_ordinary_loc (loc))\n \t{\n@@ -15809,7 +15898,7 @@ module_state::read_location (bytes_in &sec) const\n       {\n \tunsigned off = sec.u ();\n \n-\tif (macro_locs.first)\n+\tif (macro_locs.second)\n \t  {\n \t    if (off < macro_locs.second)\n \t      locus = off + macro_locs.first;\n@@ -15828,15 +15917,10 @@ module_state::read_location (bytes_in &sec) const\n \tunsigned off = sec.u ();\n \tif (ordinary_locs.second)\n \t  {\n-\t    location_t adjusted = off;\n-\n-\t    adjusted += slurp->loc_deltas.first;\n-\t    if (adjusted >= ordinary_locs.second)\n+\t    if (off < ordinary_locs.second)\n+\t      locus = off + ordinary_locs.first;\n+\t    else\n \t      sec.set_overrun ();\n-\t    else if (adjusted >= ordinary_locs.first)\n-\t      locus = adjusted;\n-\t    else if (adjusted < spans.main_start ())\n-\t      locus = off;\n \t  }\n \telse\n \t  locus = loc;\n@@ -15870,7 +15954,7 @@ module_state::read_location (bytes_in &sec) const\n \t   {\n \t     if (kind == LK_IMPORT_MACRO)\n \t       {\n-\t\t if (!import->macro_locs.first)\n+\t\t if (!import->macro_locs.second)\n \t\t   locus = import->loc;\n \t\t else if (off < import->macro_locs.second)\n \t\t   locus = off + import->macro_locs.first;\n@@ -15881,8 +15965,7 @@ module_state::read_location (bytes_in &sec) const\n \t       {\n \t\t if (!import->ordinary_locs.second)\n \t\t   locus = import->loc;\n-\t\t else if (off < (import->ordinary_locs.second\n-\t\t\t    - import->ordinary_locs.first))\n+\t\t else if (off < import->ordinary_locs.second)\n \t\t   locus = import->ordinary_locs.first + off;\n \t\t else\n \t\t   sec.set_overrun ();\n@@ -15895,26 +15978,21 @@ module_state::read_location (bytes_in &sec) const\n   return locus;\n }\n \n-/* Prepare the span adjustments.  */\n-\n-// FIXME:QOI I do not prune the unreachable locations.  Modules with\n-// textually-large GMFs could well cause us to run out of locations.\n-// Regular single-file modules could also be affected.  We should\n-// determine which locations we need to represent, so that we do not\n-// grab more locations than necessary.  An example is in\n-// write_macro_maps where we work around macro expansions that are not\n-// covering any locations -- the macro expands to nothing.  Perhaps we\n-// should decompose locations so that we can have a more graceful\n-// degradation upon running out?\n+/* Allocate hash tables to record needed locations.  */\n \n void\n module_state::write_init_maps ()\n {\n   macro_loc_table = new hash_table<macro_loc_traits> (EXPERIMENT (1, 400));\n+  ord_loc_table = new hash_table<ord_loc_traits> (EXPERIMENT (1, 400));\n }\n \n-location_map_info\n-module_state::write_prepare_maps (module_state_config *cfg)\n+/* Prepare the span adjustments.  We prune unneeded locations -- at\n+   this point every needed location must have been seen by\n+   note_location.  */\n+\n+range_t\n+module_state::write_prepare_maps (module_state_config *cfg, bool has_partitions)\n {\n   dump () && dump (\"Preparing locations\");\n   dump.indent ();\n@@ -15925,82 +16003,98 @@ module_state::write_prepare_maps (module_state_config *cfg)\n \t\t   spans[loc_spans::SPAN_RESERVED].macro.first,\n \t\t   spans[loc_spans::SPAN_RESERVED].macro.second);\n \n-  location_map_info info;\n-\n-  info.num_maps.first = info.num_maps.second = 0;\n-\n-  /* Figure the alignment of ordinary location spans.  */\n-  unsigned max_range = 0;\n-  for (unsigned ix = loc_spans::SPAN_FIRST; ix != spans.length (); ix++)\n-    {\n-      loc_spans::span &span = spans[ix];\n+  range_t info {0, 0};\n \n-      if (span.ordinary.first != span.ordinary.second)\n-\t{\n-\t  line_map_ordinary const *omap\n-\t    = linemap_check_ordinary (linemap_lookup (line_table,\n-\t\t\t\t\t\t      span.ordinary.first));\n+  // Sort the noted lines.\n+  vec_alloc (ord_loc_remap, ord_loc_table->size ());\n+  for (auto iter = ord_loc_table->begin (), end = ord_loc_table->end ();\n+       iter != end; ++iter)\n+    ord_loc_remap->quick_push (*iter);\n+  ord_loc_remap->qsort (&ord_loc_info::compare);\n \n-\t  /* We should exactly match up.  */\n-\t  gcc_checking_assert (MAP_START_LOCATION (omap) == span.ordinary.first);\n+  // Note included-from maps.\n+  bool added = false;\n+  const line_map_ordinary *current = nullptr;\n+  for (auto iter = ord_loc_remap->begin (), end = ord_loc_remap->end ();\n+       iter != end; ++iter)\n+    if (iter->src != current)\n+      {\n+\tcurrent = iter->src;\n+\tfor (auto probe = current;\n+\t     auto from = linemap_included_from (probe);\n+\t     probe = linemap_check_ordinary (linemap_lookup (line_table, from)))\n+\t  {\n+\t    if (has_partitions)\n+\t      {\n+\t\t// Partition locations need to elide their module map\n+\t\t// entry.\n+\t\tprobe\n+\t\t  = linemap_check_ordinary (linemap_lookup (line_table, from));\n+\t\tif (MAP_MODULE_P (probe))\n+\t\t  from = linemap_included_from (probe);\n+\t      }\n \n-\t  line_map_ordinary const *fmap = omap;\n-\t  for (; MAP_START_LOCATION (omap) < span.ordinary.second; omap++)\n+\t    if (!note_location (from))\n+\t      break;\n+\t    added = true;\n+\t  }\n+      }\n+  if (added)\n+    {\n+      // Reconstruct the line array as we added items to the hash table.\n+      vec_free (ord_loc_remap);\n+      vec_alloc (ord_loc_remap, ord_loc_table->size ());\n+      for (auto iter = ord_loc_table->begin (), end = ord_loc_table->end ();\n+\t   iter != end; ++iter)\n+\tord_loc_remap->quick_push (*iter);\n+      ord_loc_remap->qsort (&ord_loc_info::compare);\n+    }\n+  delete ord_loc_table;\n+  ord_loc_table = nullptr;\n+\n+  // Merge (sufficiently) adjacent spans, and calculate remapping.\n+  constexpr unsigned adjacency = 2; // Allow 2 missing lines.\n+  auto begin = ord_loc_remap->begin (), end = ord_loc_remap->end ();\n+  auto dst = begin;\n+  unsigned offset = 0, range_bits = 0;\n+  ord_loc_info *base = nullptr;\n+  for (auto iter = begin; iter != end; ++iter)\n+    {    \n+      if (base && iter->src == base->src)\n+\t{\n+\t  if (base->offset + base->span +\n+\t      ((adjacency << base->src->m_column_and_range_bits)\n+\t       // If there are few c&r bits, allow further separation.\n+\t       | (adjacency << 4))\n+\t      >= iter->offset)\n \t    {\n-\t      /* We should never find a module linemap in an interval.  */\n-\t      gcc_checking_assert (!MAP_MODULE_P (omap));\n-\n-\t      if (max_range < omap->m_range_bits)\n-\t\tmax_range = omap->m_range_bits;\n+\t      // Merge.\n+\t      offset -= base->span;\n+\t      base->span = iter->offset + iter->span - base->offset;\n+\t      offset += base->span;\n+\t      continue;\n \t    }\n-\n-\t  info.num_maps.first += omap - fmap;\n-\t}\n-    }\n-\n-  /* Adjust the maps.  Ordinary ones ascend, and we must maintain\n-     alignment.  Macro ones descend, but are unaligned.  */\n-  location_t ord_off = spans[loc_spans::SPAN_FIRST].ordinary.first;\n-  location_t range_mask = (1u << max_range) - 1;\n-\n-  dump () && dump (\"Ordinary maps range bits:%u, preserve:%x, zero:%u\",\n-\t\t   max_range, ord_off & range_mask, ord_off & ~range_mask);\n-\n-  for (unsigned ix = loc_spans::SPAN_FIRST; ix != spans.length (); ix++)\n-    {\n-      loc_spans::span &span = spans[ix];\n-\n-      line_map_ordinary const *omap\n-\t= linemap_check_ordinary (linemap_lookup (line_table,\n-\t\t\t\t\t\t  span.ordinary.first));\n-      location_t base = MAP_START_LOCATION (omap);\n-\n-      /* Preserve the low MAX_RANGE bits of base by incrementing ORD_OFF.  */\n-      unsigned low_bits = base & range_mask;\n-      if ((ord_off & range_mask) > low_bits)\n-\tlow_bits += range_mask + 1;\n-      ord_off = (ord_off & ~range_mask) + low_bits;\n-      span.ordinary_delta = ord_off - base;\n-\n-      for (; MAP_START_LOCATION (omap) < span.ordinary.second; omap++)\n-\t{\n-\t  location_t start_loc = MAP_START_LOCATION (omap);\n-\t  unsigned to = start_loc + span.ordinary_delta;\n-\t  location_t end_loc = MAP_START_LOCATION (omap + 1);\n-\n-\t  dump () && dump (\"Ordinary span:%u [%u,%u):%u->%d(%u)\",\n-\t\t\t   ix, start_loc,\n-\t\t\t   end_loc, end_loc - start_loc,\n-\t\t\t   span.ordinary_delta, to);\n-\n-\t  /* There should be no change in the low order bits.  */\n-\t  gcc_checking_assert (((start_loc ^ to) & range_mask) == 0);\n \t}\n+      else if (range_bits < iter->src->m_range_bits)\n+\trange_bits = iter->src->m_range_bits;\n \n-      /* The ending serialized value.  */\n-      ord_off = span.ordinary.second + span.ordinary_delta;\n+      offset += ((1u << iter->src->m_range_bits) - 1);\n+      offset &= ~((1u << iter->src->m_range_bits) - 1);\n+      iter->remap = offset;\n+      offset += iter->span;\n+      base = dst;\n+      *dst++ = *iter;\n     }\n+  ord_loc_remap->truncate (dst - begin);\n+\n+  info.first = ord_loc_remap->length ();\n+  cfg->ordinary_locs = offset;\n+  cfg->loc_range_bits = range_bits;\n+  dump () && dump (\"Ordinary maps:%u locs:%u range_bits:%u\",\n+\t\t   info.first, cfg->ordinary_locs,\n+\t\t   cfg->loc_range_bits);\n \n+  // Remap the macro locations.\n   vec_alloc (macro_loc_remap, macro_loc_table->size ());\n   for (auto iter = macro_loc_table->begin (), end = macro_loc_table->end ();\n        iter != end; ++iter)\n@@ -16009,24 +16103,23 @@ module_state::write_prepare_maps (module_state_config *cfg)\n   macro_loc_table = nullptr;\n \n   macro_loc_remap->qsort (&macro_loc_info::compare);\n-  unsigned offset = 0;\n+  offset = 0;\n   for (auto iter = macro_loc_remap->begin (), end = macro_loc_remap->end ();\n        iter != end; ++iter)\n     {\n       auto mac = iter->src;\n       iter->remap = offset;\n       offset += mac->n_tokens;\n     }\n-  info.num_maps.second = macro_loc_remap->length ();\n+  info.second = macro_loc_remap->length ();\n   cfg->macro_locs = offset;\n \n-  dump () && dump (\"Ordinary:%u maps hwm:%u macro:%u maps %u locs\",\n-\t\t   info.num_maps.first, ord_off,\n-\t\t   info.num_maps.second, cfg->macro_locs);\n+  dump () && dump (\"Macro maps:%u locs:%u\", info.second, cfg->macro_locs);\n \n   dump.outdent ();\n \n-  info.max_range = max_range;\n+  // If we have no ordinary locs, we must also have no macro locs.\n+  gcc_checking_assert (cfg->ordinary_locs || !cfg->macro_locs);\n \n   return info;\n }\n@@ -16035,8 +16128,6 @@ bool\n module_state::read_prepare_maps (const module_state_config *cfg)\n {\n   location_t ordinary = line_table->highest_location + 1;\n-  ordinary = ((ordinary + (1u << cfg->ordinary_loc_align))\n-\t      & ~((1u << cfg->ordinary_loc_align) - 1));\n   ordinary += cfg->ordinary_locs;\n \n   location_t macro = LINEMAPS_MACRO_LOWEST_LOCATION (line_table);\n@@ -16061,13 +16152,12 @@ module_state::read_prepare_maps (const module_state_config *cfg)\n   return false;\n }\n \n-/* Write the location maps.  This also determines the shifts for the\n-   location spans.  */\n+/* Write & read the location maps. Not called if there are no\n+   locations.   */\n \n void\n-module_state::write_ordinary_maps (elf_out *to, location_map_info &info,\n-\t\t\t\t   module_state_config *cfg, bool has_partitions,\n-\t\t\t\t   unsigned *crc_p)\n+module_state::write_ordinary_maps (elf_out *to, range_t &info,\n+\t\t\t\t   bool has_partitions, unsigned *crc_p)\n {\n   dump () && dump (\"Writing ordinary location maps\");\n   dump.indent ();\n@@ -16076,45 +16166,36 @@ module_state::write_ordinary_maps (elf_out *to, location_map_info &info,\n   filenames.create (20);\n \n   /* Determine the unique filenames.  */\n-  // FIXME:QOI We should find the set of filenames when working out\n-  // which locations we actually need.  See write_prepare_maps.\n-  for (unsigned ix = loc_spans::SPAN_FIRST; ix != spans.length (); ix++)\n-    {\n-      loc_spans::span &span = spans[ix];\n-      line_map_ordinary const *omap\n-\t= linemap_check_ordinary (linemap_lookup (line_table,\n-\t\t\t\t\t\t  span.ordinary.first));\n-\n-      /* We should exactly match up.  */\n-      gcc_checking_assert (MAP_START_LOCATION (omap) == span.ordinary.first);\n-\n-      for (; MAP_START_LOCATION (omap) < span.ordinary.second; omap++)\n-\t{\n-\t  const char *fname = ORDINARY_MAP_FILE_NAME (omap);\n+  const line_map_ordinary *current = nullptr;\n+  for (auto iter = ord_loc_remap->begin (), end = ord_loc_remap->end ();\n+       iter != end; ++iter)\n+    if (iter->src != current)\n+      {\n+\tcurrent = iter->src;\n+\tconst char *fname = ORDINARY_MAP_FILE_NAME (iter->src);\n \n-\t  /* We should never find a module linemap in an interval.  */\n-\t  gcc_checking_assert (!MAP_MODULE_P (omap));\n+\t/* We should never find a module linemap in an interval.  */\n+\tgcc_checking_assert (!MAP_MODULE_P (iter->src));\n \n-\t  /* We expect very few filenames, so just an array.\n-\t     (Not true when headers are still in play :()  */\n-\t  for (unsigned jx = filenames.length (); jx--;)\n-\t    {\n-\t      const char *name = filenames[jx];\n-\t      if (0 == strcmp (name, fname))\n-\t\t{\n-\t\t  /* Reset the linemap's name, because for things like\n-\t\t     preprocessed input we could have multiple\n-\t\t     instances of the same name, and we'd rather not\n-\t\t     percolate that.  */\n-\t\t  const_cast<line_map_ordinary *> (omap)->to_file = name;\n-\t\t  fname = NULL;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (fname)\n-\t    filenames.safe_push (fname);\n-\t}\n-    }\n+\t/* We expect very few filenames, so just an array.\n+\t   (Not true when headers are still in play :()  */\n+\tfor (unsigned jx = filenames.length (); jx--;)\n+\t  {\n+\t    const char *name = filenames[jx];\n+\t    if (0 == strcmp (name, fname))\n+\t      {\n+\t\t/* Reset the linemap's name, because for things like\n+\t\t   preprocessed input we could have multiple instances\n+\t\t   of the same name, and we'd rather not percolate\n+\t\t   that.  */\n+\t\tconst_cast<line_map_ordinary *> (iter->src)->to_file = name;\n+\t\tfname = NULL;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tif (fname)\n+\t  filenames.safe_push (fname);\n+      }\n \n   bytes_out sec (to);\n   sec.begin ();\n@@ -16130,56 +16211,45 @@ module_state::write_ordinary_maps (elf_out *to, location_map_info &info,\n       sec.str (fname);\n     }\n \n-  location_t offset = spans[loc_spans::SPAN_FIRST].ordinary.first;\n-  location_t range_mask = (1u << info.max_range) - 1;\n-\n-  dump () && dump (\"Ordinary maps:%u, range bits:%u, preserve:%x, zero:%u\",\n-\t\t   info.num_maps.first, info.max_range, offset & range_mask,\n-\t\t   offset & ~range_mask);\n-  sec.u (info.num_maps.first);\t/* Num maps.  */\n-  sec.u (info.max_range);\t\t/* Maximum range bits  */\n-  sec.u (offset & range_mask);\t/* Bits to preserve.  */\n-  sec.u (offset & ~range_mask);\n-\n-  for (unsigned ix = loc_spans::SPAN_FIRST; ix != spans.length (); ix++)\n+  sec.u (info.first);\t/* Num maps.  */\n+  const ord_loc_info *base = nullptr;\n+  for (auto iter = ord_loc_remap->begin (), end = ord_loc_remap->end ();\n+       iter != end; ++iter)\n     {\n-      loc_spans::span &span = spans[ix];\n-      line_map_ordinary const *omap\n-\t= linemap_check_ordinary (linemap_lookup (line_table,\n-\t\t\t\t\t\t  span.ordinary.first));\n-      for (; MAP_START_LOCATION (omap) < span.ordinary.second; omap++)\n-\t{\n-\t  location_t start_loc = MAP_START_LOCATION (omap);\n-\t  unsigned to = start_loc + span.ordinary_delta;\n-\n-\t  dump (dumper::LOCATION)\n-\t    && dump (\"Span:%u ordinary [%u,%u)->%u\", ix, start_loc,\n-\t\t     MAP_START_LOCATION (omap + 1), to);\n-\n-\t  /* There should be no change in the low order bits.  */\n-\t  gcc_checking_assert (((start_loc ^ to) & range_mask) == 0);\n-\t  sec.u (to);\n+      dump (dumper::LOCATION)\n+\t&& dump (\"Span:%u ordinary [%u+%u,+%u)->[%u,+%u)\",\n+\t\t iter - ord_loc_remap->begin (),\n+\t\t MAP_START_LOCATION (iter->src), iter->offset, iter->span,\n+\t\t iter->remap, iter->span);\n \n-\t  /* Making accessors just for here, seems excessive.  */\n-\t  sec.u (omap->reason);\n-\t  sec.u (omap->sysp);\n-\t  sec.u (omap->m_range_bits);\n-\t  sec.u (omap->m_column_and_range_bits - omap->m_range_bits);\n+      if (!base || iter->src != base->src)\n+\tbase = iter;\n+      sec.u (iter->offset - base->offset);\n+      if (base == iter)\n+\t{\n+\t  sec.u (iter->src->sysp);\n+\t  sec.u (iter->src->m_range_bits);\n+\t  sec.u (iter->src->m_column_and_range_bits - iter->src->m_range_bits);\n \n-\t  const char *fname = ORDINARY_MAP_FILE_NAME (omap);\n+\t  const char *fname = ORDINARY_MAP_FILE_NAME (iter->src);\n \t  for (unsigned ix = 0; ix != filenames.length (); ix++)\n \t    if (filenames[ix] == fname)\n \t      {\n \t\tsec.u (ix);\n \t\tbreak;\n \t      }\n-\t  sec.u (ORDINARY_MAP_STARTING_LINE_NUMBER (omap));\n-\n+\t  unsigned line = ORDINARY_MAP_STARTING_LINE_NUMBER (iter->src);\n+\t  line += iter->offset >> iter->src->m_column_and_range_bits;\n+\t  sec.u (line);\n+\t}\n+      sec.u (iter->remap);\n+      if (base == iter)\n+\t{\n \t  /* Write the included from location, which means reading it\n \t     while reading in the ordinary maps.  So we'd better not\n \t     be getting ahead of ourselves.  */\n-\t  location_t from = linemap_included_from (omap);\n-\t  gcc_checking_assert (from < MAP_START_LOCATION (omap));\n+\t  location_t from = linemap_included_from (iter->src);\n+\t  gcc_checking_assert (from < MAP_START_LOCATION (iter->src));\n \t  if (from != UNKNOWN_LOCATION && has_partitions)\n \t    {\n \t      /* A partition's span will have a from pointing at a\n@@ -16191,15 +16261,7 @@ module_state::write_ordinary_maps (elf_out *to, location_map_info &info,\n \t    }\n \t  write_location (sec, from);\n \t}\n-      /* The ending serialized value.  */\n-      offset = MAP_START_LOCATION (omap) + span.ordinary_delta;\n     }\n-  dump () && dump (\"Ordinary location hwm:%u\", offset);\n-  sec.u (offset);\n-\n-  // Record number of locations and alignment.\n-  cfg->ordinary_loc_align = info.max_range;\n-  cfg->ordinary_locs = offset;\n \n   filenames.release ();\n \n@@ -16208,17 +16270,16 @@ module_state::write_ordinary_maps (elf_out *to, location_map_info &info,\n }\n \n void\n-module_state::write_macro_maps (elf_out *to, location_map_info &info,\n-\t\t\t\tmodule_state_config *, unsigned *crc_p)\n+module_state::write_macro_maps (elf_out *to, range_t &info, unsigned *crc_p)\n {\n   dump () && dump (\"Writing macro location maps\");\n   dump.indent ();\n \n   bytes_out sec (to);\n   sec.begin ();\n \n-  dump () && dump (\"Macro maps:%u\", info.num_maps.second);\n-  sec.u (info.num_maps.second);\n+  dump () && dump (\"Macro maps:%u\", info.second);\n+  sec.u (info.second);\n \n   unsigned macro_num = 0;\n   for (auto iter = macro_loc_remap->end (), begin = macro_loc_remap->begin ();\n@@ -16258,14 +16319,14 @@ module_state::write_macro_maps (elf_out *to, location_map_info &info,\n \t\t iter->remap);\n       macro_num++;\n     }\n-  gcc_assert (macro_num == info.num_maps.second);\n+  gcc_assert (macro_num == info.second);\n \n   sec.end (to, to->name (MOD_SNAME_PFX \".mlm\"), crc_p);\n   dump.outdent ();\n }\n \n bool\n-module_state::read_ordinary_maps ()\n+module_state::read_ordinary_maps (unsigned num_ord_locs, unsigned range_bits)\n {\n   bytes_in sec;\n \n@@ -16291,70 +16352,62 @@ module_state::read_ordinary_maps ()\n       filenames.quick_push (fname);\n     }\n \n-  unsigned num_ordinary = sec.u (); \n-  unsigned max_range = sec.u ();\n-  unsigned low_bits = sec.u ();\n-  location_t zero = sec.u ();\n-  location_t range_mask = (1u << max_range) - 1;\n-\n-  dump () && dump (\"Ordinary maps:%u, range bits:%u, preserve:%x, zero:%u\",\n-\t\t   num_ordinary, max_range, low_bits, zero);\n+  unsigned num_ordinary = sec.u ();\n+  dump () && dump (\"Ordinary maps:%u, range_bits:%u\", num_ordinary, range_bits);\n \n   location_t offset = line_table->highest_location + 1;\n-  /* Ensure offset doesn't go backwards at the start.  */\n-  if ((offset & range_mask) > low_bits)\n-    offset += range_mask + 1;\n-  offset = (offset & ~range_mask);\n-\n-  bool propagated = spans.maybe_propagate (this, offset + low_bits);\n+  offset += ((1u << range_bits) - 1);\n+  offset &= ~((1u << range_bits) - 1);\n+  ordinary_locs.first = offset;\n \n+  bool propagated = spans.maybe_propagate (this, offset);\n   line_map_ordinary *maps = static_cast<line_map_ordinary *>\n     (line_map_new_raw (line_table, false, num_ordinary));\n \n-  location_t lwm = offset;\n-  slurp->loc_deltas.first = offset - zero;\n-  ordinary_locs.first = zero + low_bits + slurp->loc_deltas.first;\n-  dump () && dump (\"Ordinary loc delta %d\", slurp->loc_deltas.first);\n-\n+  const line_map_ordinary *base = nullptr;\n   for (unsigned ix = 0; ix != num_ordinary && !sec.get_overrun (); ix++)\n     {\n       line_map_ordinary *map = &maps[ix];\n-      unsigned hwm = sec.u ();\n \n-      /* Record the current HWM so that the below read_location is\n-\t ok.  */\n-      ordinary_locs.second = hwm + slurp->loc_deltas.first;\n-      map->start_location = hwm + (offset - zero);\n-      if (map->start_location < lwm)\n-\tsec.set_overrun ();\n-      lwm = map->start_location;\n-      dump (dumper::LOCATION) && dump (\"Map:%u %u->%u\", ix, hwm, lwm);\n-      map->reason = lc_reason (sec.u ());\n-      map->sysp = sec.u ();\n-      map->m_range_bits = sec.u ();\n-      map->m_column_and_range_bits = map->m_range_bits + sec.u ();\n-\n-      unsigned fnum = sec.u ();\n-      map->to_file = (fnum < filenames.length () ? filenames[fnum] : \"\");\n-      map->to_line = sec.u ();\n-\n-      /* Root the outermost map at our location.  */\n-      location_t from = read_location (sec);\n-      map->included_from = from != UNKNOWN_LOCATION ? from : loc;\n+      unsigned offset = sec.u ();\n+      if (!offset)\n+\t{\n+\t  map->reason = LC_RENAME;\n+\t  map->sysp = sec.u ();\n+\t  map->m_range_bits = sec.u ();\n+\t  map->m_column_and_range_bits = sec.u () + map->m_range_bits;\n+\t  unsigned fnum = sec.u ();\n+\t  map->to_file = (fnum < filenames.length () ? filenames[fnum] : \"\");\n+\t  map->to_line = sec.u ();\n+\t  base = map;\n+\t}\n+      else\n+\t{\n+\t  *map = *base;\n+\t  map->to_line += offset >> map->m_column_and_range_bits;\n+\t}\n+      unsigned remap = sec.u ();\n+      map->start_location = remap + ordinary_locs.first;\n+      if (base == map)\n+\t{\n+\t  /* Root the outermost map at our location.  */\n+\t  ordinary_locs.second = remap;\n+\t  location_t from = read_location (sec);\n+\t  map->included_from = from != UNKNOWN_LOCATION ? from : loc;\n+\t}\n     }\n \n-  location_t hwm = sec.u ();\n-  ordinary_locs.second = hwm + slurp->loc_deltas.first;\n-\n+  ordinary_locs.second = num_ord_locs;\n   /* highest_location is the one handed out, not the next one to\n      hand out.  */\n-  line_table->highest_location = ordinary_locs.second - 1;\n+  line_table->highest_location = ordinary_locs.first + ordinary_locs.second - 1;\n \n   if (line_table->highest_location >= LINE_MAP_MAX_LOCATION_WITH_COLS)\n     /* We shouldn't run out of locations, as we checked before\n        starting.  */\n     sec.set_overrun ();\n-  dump () && dump (\"Ordinary location hwm:%u\", ordinary_locs.second);\n+  dump () && dump (\"Ordinary location [%u,+%u)\",\n+\t\t   ordinary_locs.first, ordinary_locs.second);\n \n   if (propagated)\n     spans.close ();\n@@ -16988,6 +17041,10 @@ module_state::write_macros (elf_out *to, vec<cpp_hashnode *> *macros,\n       if (mac.def)\n \twrite_define (sec, mac.def);\n     }\n+  if (count)\n+    // We may have ended on a tokenless macro with a very short\n+    // location, that will cause problems reading its bit flags.\n+    sec.u (0);\n   sec.end (to, to->name (MOD_SNAME_PFX \".def\"), crc_p);\n \n   if (count)\n@@ -17453,7 +17510,7 @@ module_state::write_config (elf_out *to, module_state_config &config,\n \n   cfg.u (config.ordinary_locs);\n   cfg.u (config.macro_locs);\n-  cfg.u (config.ordinary_loc_align);\n+  cfg.u (config.loc_range_bits);\n \n   cfg.u (config.active_init);\n \n@@ -17639,7 +17696,7 @@ module_state::read_config (module_state_config &config)\n \n   config.ordinary_locs = cfg.u ();\n   config.macro_locs = cfg.u ();\n-  config.ordinary_loc_align = cfg.u ();\n+  config.loc_range_bits = cfg.u ();\n \n   config.active_init = cfg.u ();\n \n@@ -17656,7 +17713,7 @@ ool_cmp (const void *a_, const void *b_)\n   auto *b = *static_cast<const module_state *const *> (b_);\n   if (a == b)\n     return 0;\n-  else if (a->ordinary_locs.first < b->ordinary_locs.second)\n+  else if (a->ordinary_locs.first < b->ordinary_locs.first)\n     return -1;\n   else\n     return +1;\n@@ -17690,6 +17747,7 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n   bitmap partitions = NULL;\n   if (!is_header () && !is_partition ())\n     partitions = BITMAP_GGC_ALLOC ();\n+  write_init_maps ();\n \n   unsigned mod_hwm = 1;\n   for (unsigned ix = 1; ix != modules->length (); ix++)\n@@ -17727,14 +17785,15 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n \t\tgcc_checking_assert (!slot->is_lazy ());\n \t      }\n \t}\n+\n+      if (imp->is_direct () && (imp->remap || imp->is_partition ()))\n+\tnote_location (imp->imported_from ());\n     }\n \n   if (partitions && bitmap_empty_p (partitions))\n     /* No partitions present.  */\n     partitions = nullptr;\n \n-  write_init_maps ();\n-\n   /* Find the set of decls we must write out.  */\n   depset::hash table (DECL_NAMESPACE_BINDINGS (global_namespace)->size () * 8);\n   /* Add the specializations before the writables, so that we can\n@@ -17785,11 +17844,10 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n   if (is_header ())\n     macros = prepare_macros (reader);\n \n-  location_map_info map_info = write_prepare_maps (&config);\n-  unsigned counts[MSC_HWM];\n-\n   config.num_imports = mod_hwm;\n   config.num_partitions = modules->length () - mod_hwm;\n+  auto map_info = write_prepare_maps (&config, bool (config.num_partitions));\n+  unsigned counts[MSC_HWM];\n   memset (counts, 0, sizeof (counts));\n \n   /* depset::cluster is the cluster number,\n@@ -17926,8 +17984,10 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n     write_partitions (to, config.num_partitions, &crc);\n \n   /* Write the line maps.  */\n-  write_ordinary_maps (to, map_info, &config, config.num_partitions, &crc);\n-  write_macro_maps (to, map_info, &config, &crc);\n+  if (config.ordinary_locs)\n+    write_ordinary_maps (to, map_info, bool (config.num_partitions), &crc);\n+  if (config.macro_locs)\n+    write_macro_maps (to, map_info, &crc);\n \n   if (is_header ())\n     {\n@@ -17947,6 +18007,7 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n   sccs.release ();\n \n   vec_free (macro_loc_remap);\n+  vec_free (ord_loc_remap);\n   vec_free (ool);\n \n   // FIXME:QOI:  Have a command line switch to control more detailed\n@@ -17990,7 +18051,9 @@ module_state::read_initial (cpp_reader *reader)\n   bool have_locs = ok && read_prepare_maps (&config);\n \n   /* Ordinary maps before the imports.  */\n-  if (have_locs && !read_ordinary_maps ())\n+  if (!(have_locs && config.ordinary_locs))\n+    ordinary_locs.first = line_table->highest_location + 1;\n+  else if (!read_ordinary_maps (config.ordinary_locs, config.loc_range_bits))\n     ok = false;\n \n   /* Allocate the REMAP vector.  */\n@@ -18017,7 +18080,7 @@ module_state::read_initial (cpp_reader *reader)\n \n   {\n     /* Allocate space in the entities array now -- that array must be\n-       monotionically in step with the modules array.  */\n+       monotonically in step with the modules array.  */\n     entity_lwm = vec_safe_length (entity_ary);\n     entity_num = config.num_entities;\n     gcc_checking_assert (modules->length () == 1\n@@ -18048,7 +18111,9 @@ module_state::read_initial (cpp_reader *reader)\n   gcc_assert (!from ()->is_frozen ());\n \n   /* Macro maps after the imports.  */\n-  if (ok && have_locs && !read_macro_maps (config.macro_locs))\n+  if (!(ok && have_locs && config.macro_locs))\n+    macro_locs.first = LINEMAPS_MACRO_LOWEST_LOCATION (line_table);\n+  else if (!read_macro_maps (config.macro_locs))\n     ok = false;\n \n   /* Note whether there's an active initializer.  */"}, {"sha": "55d46e415230d0e97f495d7294fe598f6b081a08", "filename": "gcc/testsuite/g++.dg/modules/loc-prune-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-1.C?ref=069f46c71e9432eda3d48a366e5c2a750cf8d612", "patch": "@@ -14,6 +14,6 @@ int foo (int = YES)\n \n // { dg-final { scan-lang-dump { Macro maps:1} module } }\n // { dg-final { scan-lang-dump { Macro:0 YES 1/1.2 locations } module } }\n-// { dg-final { scan-lang-dump { Ordinary:[0-9]* maps hwm:[0-9]* macro:1 maps 1 locs} module } }\n+// { dg-final { scan-lang-dump { Macro maps:1 locs:1} module } }\n // { dg-final { scan-lang-dump-not {Macro:. NOT } module } }\n // { dg-final { scan-lang-dump-not {Macro:. AGAIN_NO } module } }"}, {"sha": "765c378e51e4e769401e1f6e83016f5a2edc5f0c", "filename": "gcc/testsuite/g++.dg/modules/loc-prune-4.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-4.C?ref=069f46c71e9432eda3d48a366e5c2a750cf8d612", "patch": "@@ -0,0 +1,22 @@\n+//  { dg-additional-options {-Wno-pedantic -fmodules-ts -fdump-lang-module-lineno} }\n+\n+# 4 \"unused\" 1\n+# 5 \"\" 2\n+\n+export module foo;\n+\n+int foo (int) // separate\n+{\n+\n+\n+  return 0;\n+}\n+\n+int bar (int); // merge lines\n+int baz (int);\n+\n+\n+// { dg-final { scan-lang-dump {Ordinary maps:2 locs:12288 range_bits:5} module } }\n+// { dg-final { scan-lang-dump { 1 source file names\\n Source file...=[^\\n]*loc-prune-4.C\\n} module } }\n+// { dg-final { scan-lang-dump { Span:0 ordinary \\[2.....\\+12288,\\+4096\\)->\\[0,\\+4096\\)} module } }\n+// { dg-final { scan-lang-dump { Span:1 ordinary \\[2.....\\+40960,\\+8192\\)->\\[4096,\\+8192\\)} module } }"}, {"sha": "01242d9e676cbe3547ddd88e6f19192f881bf349", "filename": "gcc/testsuite/g++.dg/modules/pr98718_a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C?ref=069f46c71e9432eda3d48a366e5c2a750cf8d612", "patch": "@@ -14,5 +14,5 @@ namespace std _GLIBCXX_VISIBILITY(default)\n export  module  hello:format;\n // { dg-module-cmi hello:format }\n \n-// { dg-final { scan-lang-dump { Ordinary:4 maps hwm:[0-9]* macro:0 maps 0 locs} module } }\n+// { dg-final { scan-lang-dump { Macro maps:0 locs:0} module } }\n // { dg-final { scan-lang-dump-not { Macro:. _GLIBCXX_VISIBILITY} module } }"}, {"sha": "d2a1c53f93e022092d2192735dba7da814d8e78c", "filename": "gcc/testsuite/g++.dg/modules/pr98718_b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C?ref=069f46c71e9432eda3d48a366e5c2a750cf8d612", "patch": "@@ -14,5 +14,5 @@ export  module  hello;\n export  import  :format;\n // { dg-module-cmi hello }\n \n-// { dg-final { scan-lang-dump { Ordinary:8 maps hwm:[0-9]* macro:0 maps 0 locs} module } }\n+// { dg-final { scan-lang-dump { Macro maps:0 locs:0} module } }\n // { dg-final { scan-lang-dump-not { Macro:. _GLIBCXX_VISIBILITY} module } }"}, {"sha": "3be69964f39668b2de08115c02762f69f00ebbb3", "filename": "gcc/testsuite/g++.dg/modules/pr99072.H", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99072.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069f46c71e9432eda3d48a366e5c2a750cf8d612/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99072.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99072.H?ref=069f46c71e9432eda3d48a366e5c2a750cf8d612", "patch": "@@ -7,4 +7,6 @@\n # 1 \"REALNAME\"\n \n // { dg-additional-options {-fmodule-header -fpreprocessed -fdump-lang-module-lineno} }\n-// { dg-final { scan-lang-dump { 4 source file names\\n Source file\\[0\\]=REALNAME\\n Source file\\[1\\]=<built-in>\\n Source file\\[2\\]=<command-line>\\n Source file\\[3\\]=/usr/include/stdc-predef.h\\n} module } }\n+// All locations are pruned.\n+// { dg-final { scan-lang-dump-not {Writing ordinary location maps} module } }\n+// { dg-final { scan-lang-dump-not {  Span:. ordinary } module } }"}]}