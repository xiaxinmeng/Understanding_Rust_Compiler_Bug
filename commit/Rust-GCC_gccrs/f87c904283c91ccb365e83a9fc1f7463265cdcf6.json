{"sha": "f87c904283c91ccb365e83a9fc1f7463265cdcf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg3YzkwNDI4M2M5MWNjYjM2NWU4M2E5ZmMxZjc0NjMyNjVjZGNmNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-26T23:35:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-26T23:35:27Z"}, "message": "ipa-pure-const.c (struct funct_state_d): New fields state_previously_known, looping_previously_known...\n\n\t* ipa-pure-const.c (struct funct_state_d): New fields\n\tstate_previously_known, looping_previously_known; remove\n\tstate_set_in_source.\n\t(analyze_function): Use new fields.\n\t(propagate): Avoid assumption that state_set_in_source imply\n\tnonlooping.\n\n\t* tree-ssa-loop-niter.c (finite_loop_p): New function.\n\t* tree-ssa-loop-ivcanon.c (empty_loop_p): Use it.\n\t* cfgloop.h (finite_loop_p): Declare.\n\nFrom-SVN: r146821", "tree": {"sha": "fa24152c68bb24d01ebfd5359eabb80b6d0be1a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa24152c68bb24d01ebfd5359eabb80b6d0be1a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f87c904283c91ccb365e83a9fc1f7463265cdcf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f87c904283c91ccb365e83a9fc1f7463265cdcf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f87c904283c91ccb365e83a9fc1f7463265cdcf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f87c904283c91ccb365e83a9fc1f7463265cdcf6/comments", "author": null, "committer": null, "parents": [{"sha": "33abd7188ed10fdc1a4b66a2208490fc58df041b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33abd7188ed10fdc1a4b66a2208490fc58df041b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33abd7188ed10fdc1a4b66a2208490fc58df041b"}], "stats": {"total": 87, "additions": 73, "deletions": 14}, "files": [{"sha": "1231e593a7d386cf60b152ef1efbc367d99f8d51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f87c904283c91ccb365e83a9fc1f7463265cdcf6", "patch": "@@ -1,3 +1,16 @@\n+2009-04-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-pure-const.c (struct funct_state_d): New fields\n+\tstate_previously_known, looping_previously_known; remove\n+\tstate_set_in_source.\n+\t(analyze_function): Use new fields.\n+\t(propagate): Avoid assumption that state_set_in_source imply\n+\tnonlooping.\n+\n+\t* tree-ssa-loop-niter.c (finite_loop_p): New function.\n+\t* tree-ssa-loop-ivcanon.c (empty_loop_p): Use it.\n+\t* cfgloop.h (finite_loop_p): Declare.\n+\n 2009-04-26  Michael Matz  <matz@suse.de>\n \n \t* tree-flow.h (tree_ann_common_d): Remove aux and value_handle"}, {"sha": "fe0120ec9df4ff433f87af513b8a0ac18905e941", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f87c904283c91ccb365e83a9fc1f7463265cdcf6", "patch": "@@ -640,5 +640,6 @@ enum\n extern void unroll_and_peel_loops (int);\n extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n+extern bool finite_loop_p (struct loop *);\n \n #endif /* GCC_CFGLOOP_H */"}, {"sha": "9575468ec7c316dae9baec7629482acc3b12c917", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=f87c904283c91ccb365e83a9fc1f7463265cdcf6", "patch": "@@ -72,7 +72,8 @@ struct funct_state_d\n   /* See above.  */\n   enum pure_const_state_e pure_const_state;\n   /* What user set here; we can be always sure about this.  */\n-  enum pure_const_state_e state_set_in_source; \n+  enum pure_const_state_e state_previously_known; \n+  bool looping_previously_known; \n \n   /* True if the function could possibly infinite loop.  There are a\n      lot of ways that this could be determined.  We are pretty\n@@ -485,7 +486,8 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \n   l = XCNEW (struct funct_state_d);\n   l->pure_const_state = IPA_CONST;\n-  l->state_set_in_source = IPA_NEITHER;\n+  l->state_previously_known = IPA_NEITHER;\n+  l->looping_previously_known = true;\n   l->looping = false;\n   l->can_throw = false;\n \n@@ -528,17 +530,17 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   if (TREE_READONLY (decl))\n     {\n       l->pure_const_state = IPA_CONST;\n-      l->state_set_in_source = IPA_CONST;\n+      l->state_previously_known = IPA_CONST;\n       if (!DECL_LOOPING_CONST_OR_PURE_P (decl))\n-        l->looping = false;\n+        l->looping = false, l->looping_previously_known = false;\n     }\n   if (DECL_PURE_P (decl))\n     {\n       if (l->pure_const_state != IPA_CONST)\n         l->pure_const_state = IPA_PURE;\n-      l->state_set_in_source = IPA_PURE;\n+      l->state_previously_known = IPA_PURE;\n       if (!DECL_LOOPING_CONST_OR_PURE_P (decl))\n-        l->looping = false;\n+        l->looping = false, l->looping_previously_known = false;\n     }\n   if (TREE_NOTHROW (decl))\n     l->can_throw = false;\n@@ -728,12 +730,11 @@ propagate (void)\n \t  enum pure_const_state_e this_state = pure_const_state;\n \t  bool this_looping = looping;\n \n-\t  if (w_l->state_set_in_source != IPA_NEITHER)\n-\t    {\n-\t      if (this_state > w_l->state_set_in_source)\n-\t        this_state = w_l->state_set_in_source;\n-\t      this_looping = false;\n-\t    }\n+\t  if (w_l->state_previously_known != IPA_NEITHER\n+\t      && this_state > w_l->state_previously_known)\n+            this_state = w_l->state_previously_known;\n+\t  if (!w_l->looping_previously_known)\n+\t    this_looping = false;\n \n \t  /* All nodes within a cycle share the same info.  */\n \t  w_l->pure_const_state = this_state;"}, {"sha": "21010734be61fc1a9c3b15d730965cc907528a47", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=f87c904283c91ccb365e83a9fc1f7463265cdcf6", "patch": "@@ -395,7 +395,6 @@ static bool\n empty_loop_p (struct loop *loop)\n {\n   edge exit;\n-  struct tree_niter_desc niter;\n   basic_block *body;\n   gimple_stmt_iterator gsi;\n   unsigned i;\n@@ -408,7 +407,7 @@ empty_loop_p (struct loop *loop)\n     return false;\n \n   /* The loop must be finite.  */\n-  if (!number_of_iterations_exit (loop, exit, &niter, false))\n+  if (!finite_loop_p (loop))\n     return false;\n \n   /* Values of all loop exit phi nodes must be invariants.  */"}, {"sha": "3892a43e2133e0dc053a0358ddced9c4df8ad49d", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c904283c91ccb365e83a9fc1f7463265cdcf6/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f87c904283c91ccb365e83a9fc1f7463265cdcf6", "patch": "@@ -1953,6 +1953,51 @@ find_loop_niter (struct loop *loop, edge *exit)\n   return niter ? niter : chrec_dont_know;\n }\n \n+/* Return true if loop is known to have bounded number of iterations.  */\n+\n+bool\n+finite_loop_p (struct loop *loop)\n+{\n+  unsigned i;\n+  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n+  edge ex;\n+  struct tree_niter_desc desc;\n+  bool finite = false;\n+\n+  if (flag_unsafe_loop_optimizations)\n+    return true;\n+  if ((TREE_READONLY (current_function_decl)\n+       || DECL_PURE_P (current_function_decl))\n+      && !DECL_LOOPING_CONST_OR_PURE_P (current_function_decl))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Found loop %i to be finite: it is within pure or const function.\\n\",\n+\t\t loop->num);\n+      return true;\n+    }\n+   \n+  exits = get_loop_exit_edges (loop);\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+    {\n+      if (!just_once_each_iteration_p (loop, ex->src))\n+\tcontinue;\n+\n+      if (number_of_iterations_exit (loop, ex, &desc, false))\n+        {\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Found loop %i to be finite: iterating \", loop->num);\n+\t      print_generic_expr (dump_file, desc.niter, TDF_SLIM);\n+\t      fprintf (dump_file, \" times\\n\");\n+\t    }\n+\t  finite = true;\n+\t  break;\n+\t}\n+    }\n+  VEC_free (edge, heap, exits);\n+  return finite;\n+}\n+\n /*\n \n    Analysis of a number of iterations of a loop by a brute-force evaluation."}]}