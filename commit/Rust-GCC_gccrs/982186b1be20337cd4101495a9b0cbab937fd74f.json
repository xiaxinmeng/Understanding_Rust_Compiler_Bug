{"sha": "982186b1be20337cd4101495a9b0cbab937fd74f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgyMTg2YjFiZTIwMzM3Y2Q0MTAxNDk1YTliMGNiYWI5MzdmZDc0Zg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-13T12:51:07Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-13T12:51:07Z"}, "message": "re PR fortran/29373 (implicit type declaration and contained function clash)\n\n2006-10-13 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/29373\n\t* decl.c (get_proc_name, gfc_match_function_decl): Add\n\tattr.implicit_type to conditions that throw error for\n\texisting explicit interface and that allow new type-\n\tspec to be applied.\n\n\tPR fortran/29407\n\t* resolve.c (resolve_fl_namelist): Do not check for\n\tnamelist/procedure conflict, if the symbol corresponds\n\tto a good local variable declaration.\n\n\tPR fortran/27701\n\t* decl.c (get_proc_name): Replace the detection of a declared\n\tprocedure by the presence of a formal argument list by the\n\tattributes of the symbol and the presence of an explicit\n\tinterface.\n\n\tPR fortran/29232\n\t* resolve.c (resolve_fl_variable): See if the host association\n\tof a derived type is blocked by the presence of another type I\n\tobject in the current namespace.\n\n\tPR fortran/29364\n\t* resolve.c (resolve_fl_derived): Check for the presence of\n\tthe derived type for a derived type component.\n\n\tPR fortran/24398\n\t* module.c (gfc_use_module): Check that the first words in a\n\tmodule file are 'GFORTRAN module'.\n\n\tPR fortran/29422\n\t* resolve.c (resolve_transfer): Test functions for suitability\n\tfor IO, as well as variables.\n\n\tPR fortran/29428\n\t* trans-expr.c (gfc_trans_scalar_assign): Remove nullify of\n\trhs expression.\n\n\n2006-10-13 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/29373\n\t* gfortran.dg/implicit_9.f90: New test.\n\n\tPR fortran/29407\n\t* gfortran.dg/namelist_25.f90: New test.\n\n\tPR fortran/27701\n\t* gfortran.dg/same_name_2.f90: New test.\n\n\tPR fortran/29232\n\t* gfortran.dg/host_assoc_types_1.f90: New test.\n\n\tPR fortran/29364\n\t* gfortran.dg/missing_derived_type_1.f90: New test.\n\t* gfortran.dg/implicit_actual.f90: Comment out USE GLOBAL.\n\n\tPR fortran/29422\n\t* gfortran.dg/alloc_comp_constraint_4.f90: New test.\n\n\tPR fortran/29428\n\t* gfortran.dg/alloc_comp_assign_5.f90: New test.\n\nFrom-SVN: r117692", "tree": {"sha": "1d53d33e42e171e630c8781c3fdee5e851cb8967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d53d33e42e171e630c8781c3fdee5e851cb8967"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/982186b1be20337cd4101495a9b0cbab937fd74f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/982186b1be20337cd4101495a9b0cbab937fd74f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/982186b1be20337cd4101495a9b0cbab937fd74f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/982186b1be20337cd4101495a9b0cbab937fd74f/comments", "author": null, "committer": null, "parents": [{"sha": "ac677cc88956d8b2022022610eb79112136267f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac677cc88956d8b2022022610eb79112136267f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac677cc88956d8b2022022610eb79112136267f3"}], "stats": {"total": 296, "additions": 270, "deletions": 26}, "files": [{"sha": "2708abb31ed0c56db9c45973d7863df6383fb95c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -1,3 +1,43 @@\n+2006-10-13 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29373\n+\t* decl.c (get_proc_name, gfc_match_function_decl): Add\n+\tattr.implicit_type to conditions that throw error for\n+\texisting explicit interface and that allow new type-\n+\tspec to be applied.\n+\n+\tPR fortran/29407\n+\t* resolve.c (resolve_fl_namelist): Do not check for\n+\tnamelist/procedure conflict, if the symbol corresponds\n+\tto a good local variable declaration.\n+\n+\tPR fortran/27701\n+\t* decl.c (get_proc_name): Replace the detection of a declared\n+\tprocedure by the presence of a formal argument list by the\n+\tattributes of the symbol and the presence of an explicit\n+\tinterface.\n+\n+\tPR fortran/29232\n+\t* resolve.c (resolve_fl_variable): See if the host association\n+\tof a derived type is blocked by the presence of another type I\n+\tobject in the current namespace.\n+\n+\tPR fortran/29364\n+\t* resolve.c (resolve_fl_derived): Check for the presence of\n+\tthe derived type for a derived type component.\n+\n+\tPR fortran/24398\n+\t* module.c (gfc_use_module): Check that the first words in a\n+\tmodule file are 'GFORTRAN module'.\n+\n+\tPR fortran/29422\n+\t* resolve.c (resolve_transfer): Test functions for suitability\n+\tfor IO, as well as variables.\n+\n+\tPR fortran/29428\n+\t* trans-expr.c (gfc_trans_scalar_assign): Remove nullify of\n+\trhs expression.\n+\n 2006-10-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/29391"}, {"sha": "02dc38cc8bb49664fc4effaa97cfee2f22cdcd9f", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -635,14 +635,16 @@ get_proc_name (const char *name, gfc_symbol ** result,\n \t accessible names.  */\n       if (sym->attr.flavor != 0\n \t    && sym->attr.proc != 0\n-\t    && sym->formal)\n+\t    && (sym->attr.subroutine || sym->attr.function)\n+\t    && sym->attr.if_source != IFSRC_UNKNOWN)\n \tgfc_error_now (\"Procedure '%s' at %C is already defined at %L\",\n \t\t       name, &sym->declared_at);\n \n       /* Trap declarations of attributes in encompassing scope.  The\n \t signature for this is that ts.kind is set.  Legitimate\n \t references only set ts.type.  */\n       if (sym->ts.kind != 0\n+\t    && !sym->attr.implicit_type\n \t    && sym->attr.proc == 0\n \t    && gfc_current_ns->parent != NULL\n \t    && sym->attr.access == 0\n@@ -2679,7 +2681,9 @@ gfc_match_function_decl (void)\n       || copy_prefix (&sym->attr, &sym->declared_at) == FAILURE)\n     goto cleanup;\n \n-  if (current_ts.type != BT_UNKNOWN && sym->ts.type != BT_UNKNOWN)\n+  if (current_ts.type != BT_UNKNOWN\n+\t&& sym->ts.type != BT_UNKNOWN\n+\t&& !sym->attr.implicit_type)\n     {\n       gfc_error (\"Function '%s' at %C already has a type of %s\", name,\n \t\t gfc_basic_typename (sym->ts.type));"}, {"sha": "f525ab644950466f09e6c1232fdcf84da739574b", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -3790,7 +3790,7 @@ gfc_use_module (void)\n {\n   char *filename;\n   gfc_state_data *p;\n-  int c, line;\n+  int c, line, start;\n \n   filename = (char *) alloca(strlen(module_name) + strlen(MODULE_EXTENSION)\n \t\t\t     + 1);\n@@ -3805,15 +3805,23 @@ gfc_use_module (void)\n   iomode = IO_INPUT;\n   module_line = 1;\n   module_column = 1;\n+  start = 0;\n \n-  /* Skip the first two lines of the module.  */\n-  /* FIXME: Could also check for valid two lines here, instead.  */\n+  /* Skip the first two lines of the module, after checking that this is\n+     a gfortran module file.  */\n   line = 0;\n   while (line < 2)\n     {\n       c = module_char ();\n       if (c == EOF)\n \tbad_module (\"Unexpected end of module\");\n+      if (start++ < 2)\n+\tparse_name (c);\n+      if ((start == 1 && strcmp (atom_name, \"GFORTRAN\") != 0)\n+\t    || (start == 2 && strcmp (atom_name, \" module\") != 0))\n+\tgfc_fatal_error (\"File '%s' opened at %C is not a GFORTRAN module \"\n+\t\t\t  \"file\", filename);\n+\n       if (c == '\\n')\n \tline++;\n     }"}, {"sha": "6b9062db8571cf798820ab68b926f0bf3214ef7c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -4167,7 +4167,8 @@ resolve_transfer (gfc_code * code)\n \n   exp = code->expr;\n \n-  if (exp->expr_type != EXPR_VARIABLE)\n+  if (exp->expr_type != EXPR_VARIABLE\n+\t&& exp->expr_type != EXPR_FUNCTION)\n     return;\n \n   sym = exp->symtree->n.sym;\n@@ -5384,6 +5385,24 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n       return FAILURE;\n     }\n \n+  /* Check to see if a derived type is blocked from being host associated\n+     by the presence of another class I symbol in the same namespace.\n+     14.6.1.3 of the standard and the discussion on comp.lang.fortran.  */\n+  if (sym->ts.type == BT_DERIVED && sym->ns != sym->ts.derived->ns)\n+    {\n+      gfc_symbol *s;\n+      gfc_find_symbol (sym->ts.derived->name, sym->ns, 0, &s);\n+      if (s && (s->attr.flavor != FL_DERIVED\n+\t\t  || !gfc_compare_derived_types (s, sym->ts.derived)))\n+\t{\n+\t  gfc_error (\"The type %s cannot be host associated at %L because \"\n+\t\t     \"it is blocked by an incompatible object of the same \"\n+\t\t     \"name at %L\", sym->ts.derived->name, &sym->declared_at,\n+\t\t     &s->declared_at);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n   /* 4th constraint in section 11.3:  \"If an object of a type for which\n      component-initialization is specified (R429) appears in the\n      specification-part of a module and does not have the ALLOCATABLE\n@@ -5577,6 +5596,15 @@ resolve_fl_derived (gfc_symbol *sym)\n \t    }\n \t}\n \n+      if (c->ts.type == BT_DERIVED && c->pointer\n+\t    && c->ts.derived->components == NULL)\n+\t{\n+\t  gfc_error (\"The pointer component '%s' of '%s' at %L is a type \"\n+\t\t     \"that has not been declared\", c->name, sym->name,\n+\t\t     &c->loc);\n+\t  return FAILURE;\n+\t}\n+\n       if (c->pointer || c->allocatable ||  c->as == NULL)\n \tcontinue;\n \n@@ -5668,16 +5696,18 @@ resolve_fl_namelist (gfc_symbol *sym)\n      same message has been used.  */\n   for (nl = sym->namelist; nl; nl = nl->next)\n     {\n+      if (nl->sym->ts.kind != 0 && nl->sym->attr.flavor == FL_VARIABLE)\n+\tcontinue;\n       nlsym = NULL;\n-\tif (sym->ns->parent && nl->sym && nl->sym->name)\n-\t  gfc_find_symbol (nl->sym->name, sym->ns->parent, 0, &nlsym);\n-\tif (nlsym && nlsym->attr.flavor == FL_PROCEDURE)\n-\t  {\n-\t    gfc_error (\"PROCEDURE attribute conflicts with NAMELIST \"\n-\t\t       \"attribute in '%s' at %L\", nlsym->name,\n-\t\t       &sym->declared_at);\n-\t    return FAILURE;\n-\t  }\n+      if (sym->ns->parent && nl->sym && nl->sym->name)\n+\tgfc_find_symbol (nl->sym->name, sym->ns->parent, 0, &nlsym);\n+      if (nlsym && nlsym->attr.flavor == FL_PROCEDURE)\n+\t{\n+\t  gfc_error (\"PROCEDURE attribute conflicts with NAMELIST \"\n+\t\t     \"attribute in '%s' at %L\", nlsym->name,\n+\t\t     &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n     }\n \n   return SUCCESS;"}, {"sha": "875092fbea197fb653013528261fa340fb00d8c7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -3261,19 +3261,13 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));\n \n       /* Do a deep copy if the rhs is a variable, if it is not the\n-\t same as the lhs.  Otherwise, nullify the data fields so that the\n-\t lhs retains the allocated resources.  */\n+\t same as the lhs.  */\n       if (r_is_var)\n \t{\n \t  tmp = gfc_copy_alloc_comp (ts.derived, rse->expr, lse->expr, 0);\n \t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (), tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n-      else\n-\t{\n-\t  tmp = gfc_nullify_alloc_comp (ts.derived, rse->expr, 0);\n-\t  gfc_add_expr_to_block (&block, tmp);\n-\t}\n     }\n   else\n     {"}, {"sha": "fe584c23a2888f0613262e1ff0843d46dab24c9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -1,3 +1,27 @@\n+2006-10-13 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29373\n+\t* gfortran.dg/implicit_9.f90: New test.\n+\n+\tPR fortran/29407\n+\t* gfortran.dg/namelist_25.f90: New test.\n+\n+\tPR fortran/27701\n+\t* gfortran.dg/same_name_2.f90: New test.\n+\n+\tPR fortran/29232\n+\t* gfortran.dg/host_assoc_types_1.f90: New test.\n+\n+\tPR fortran/29364\n+\t* gfortran.dg/missing_derived_type_1.f90: New test.\n+\t* gfortran.dg/implicit_actual.f90: Comment out USE GLOBAL.\n+\n+\tPR fortran/29422\n+\t* gfortran.dg/alloc_comp_constraint_4.f90: New test.\n+\n+\tPR fortran/29428\n+\t* gfortran.dg/alloc_comp_assign_5.f90: New test.\n+\n 2006-10-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/29391"}, {"sha": "3cc3695c4cf81108fa8311a04a6ce5a03f3d49d1", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_5.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_5.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! { dg-options \"-O2\" }\n+! Tests the fix for PR29428, in which the assignment of\n+! a function result would result in the function being\n+! called twice, if it were not a result by reference,\n+! because of a spurious nullify in gfc_trans_scalar_assign.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program test\n+implicit none\n+\n+  type A\n+    integer, allocatable :: j(:)\n+  end type A\n+\n+  type(A):: x\n+  integer :: ctr = 0\n+\n+  x = f()\n+\n+  if (ctr /= 1) call abort ()\n+\n+contains\n+\n+  function f()\n+    type(A):: f\n+      ctr = ctr + 1\n+      f = A ((/1,2/))\n+  end function f\n+\n+end program\n+"}, {"sha": "e24bfe0a2987a4f428d14b3087ee2dfa4bd28e02", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constraint_4.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_4.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! Tests the fix for PR29422, in which function results\n+! were not tested for suitability in IO statements.\n+!\n+! Contributed by Dominique d'Humieres  <dominiq@lps.ens.fr>\n+!\n+Type drv\n+ Integer :: i\n+ Integer, allocatable :: arr(:)\n+End type drv\n+\n+  print *, fun1 () ! { dg-error \"cannot have ALLOCATABLE\" }\n+\n+contains\n+  Function fun1 ()\n+\n+    Type(drv) :: fun1\n+    fun1%i = 10\n+  end function fun1\n+end\n+"}, {"sha": "53c968410e0744d6724a57afd1e9582443a2eab5", "filename": "gcc/testsuite/gfortran.dg/host_assoc_types_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_types_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_types_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_types_1.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! Tests the fix for PR29232, in which the invalid code below was not\n+! diagnosed.\n+!\n+! Contributed by Tobias Burnus  <tobias.burnus@physik.fu-berlin.de>\n+!\n+MODULE test\n+     TYPE vertex\n+           INTEGER :: k\n+     END TYPE vertex\n+CONTAINS\n+     SUBROUTINE S1()\n+         TYPE(vertex) :: a  ! { dg-error \"cannot be host associated\" }\n+         vertex : DO i=1,2  ! { dg-error \"incompatible object of the same name\" }\n+         ENDDO vertex\n+     END SUBROUTINE\n+END MODULE test\n+! { dg-final { cleanup-modules \"test\" } }"}, {"sha": "335c85bffb17ea06f3f5684dee2255400761af39", "filename": "gcc/testsuite/gfortran.dg/implicit_9.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_9.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! Tests patch for PR29373, in which the implicit character\n+! statement messes up the function declaration because the\n+! requisite functions in decl.c were told nothing about\n+! implicit types.\n+!\n+! Contributed by Tobias Schlueter  <tobi@gcc.gnu.org>\n+!\n+  implicit character*32 (a-z)\n+  CHARACTER(len=255), DIMENSION(1,2)  :: a\n+\n+! Reporters original, which triggers another error:\n+! gfc_todo: Not Implemented: complex character array\n+! constructors.=> PR29431\n+!  a = reshape((/ to_string(1.0) /), (/ 1, 2 /))\n+\n+  a = to_string(1.0)\n+  print *, a\n+  CONTAINS\n+    CHARACTER*(32) FUNCTION to_string(x)\n+      REAL, INTENT(in) :: x\n+      WRITE(to_string, FMT=\"(F6.3)\") x\n+    END FUNCTION\n+END PROGRAM"}, {"sha": "2a6dd66c565b00f257ed4cb977ba15616463abd0", "filename": "gcc/testsuite/gfortran.dg/implicit_actual.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -1,19 +1,19 @@\n ! { dg-do compile }\n-! { dg-options \"-O0\" }\n ! Tests patch for problem that was found whilst investigating\n ! PR24158. The call to foo would cause an ICE because the\n-! actual argument was of a type that was not defined.\n+! actual argument was of a type that was not defined.  The USE\n+! GLOBAL was commented out, following the fix for PR29364.\n !\n ! Contributed by Paul Thomas <pault@gcc.gnu.org>\n !\n module global\n   type :: t2\n-    type(t3), pointer :: d\n+    type(t3), pointer :: d ! { dg-error \"has not been declared\" }\n   end type t2\n end module global\n \n program snafu\n-  use global\n+!  use global\n   implicit type (t3) (z)\n \n   call foo (zin) ! { dg-error \"defined|Type/rank\" }"}, {"sha": "49c1ec8cedf535c4c17c809f46cec508de0b1f5d", "filename": "gcc/testsuite/gfortran.dg/missing_derived_type_1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_derived_type_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_derived_type_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_derived_type_1.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! Tests the fix for PR29364, in which the the absence of the derived type\n+! 'nonexist' was not diagnosed.\n+!\n+! Contributed by Tobias Burnus  <tobias.burnus@physik.fu-berlin.de>\n+!\n+module test\n+  implicit none\n+  type epot_t\n+    integer :: c\n+    type(nonexist),pointer :: l ! { dg-error \"has not been declared\" }\n+  end type epot_t\n+end module test\n+! { dg-final { cleanup-modules \"test\" } }"}, {"sha": "16bcee86c3d00eca8de8cfd2e32b4d2ff7620776", "filename": "gcc/testsuite/gfortran.dg/namelist_25.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_25.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! Tests patch for PR29407, in which the declaration of 'my' as\n+! a local variable was ignored, so that the procedure and namelist\n+! attributes for 'my' clashed..\n+!\n+! Contributed by Tobias Burnus  <tobias.burnus@physik.fu-berlin.de>\n+!\n+program main\n+  implicit none\n+contains\n+  subroutine my\n+  end subroutine my\n+  subroutine bar\n+    integer :: my\n+    namelist /ops/ my\n+  end subroutine bar\n+end program main\n+"}, {"sha": "948ff757baeeb96042c1f62b9e16ffa8c48ca978", "filename": "gcc/testsuite/gfortran.dg/same_name_2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_name_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982186b1be20337cd4101495a9b0cbab937fd74f/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_name_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_name_2.f90?ref=982186b1be20337cd4101495a9b0cbab937fd74f", "patch": "@@ -0,0 +1,16 @@\n+! ( dg-do compile }\n+! Tests the fix for PR27701, in which two same name procedures\n+! were not diagnosed if they had no arguments.\n+!\n+! Contributed by Arjen Markus  <arjen.markus@wldelft.nl>\n+!\n+module aha\n+contains\n+subroutine aa ! { dg-error \"Procedure\" }\n+   write(*,*) 'AA'\n+end subroutine aa\n+subroutine aa ! { dg-error \"is already defined\" }\n+   write(*,*) 'BB'\n+end subroutine aa\n+end module\n+! { dg-final { cleanup-modules \"aha\" } }"}]}