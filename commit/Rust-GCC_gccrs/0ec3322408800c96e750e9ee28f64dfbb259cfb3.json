{"sha": "0ec3322408800c96e750e9ee28f64dfbb259cfb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjMzMyMjQwODgwMGM5NmU3NTBlOWVlMjhmNjRkZmJiMjU5Y2ZiMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2013-05-17T15:27:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2013-05-17T15:27:37Z"}, "message": "re PR target/49146 (segv from libgcc_s when raising an exception, or unwinding stack with backtrace with ms_abi)\n\nPR target/49146\n\n\t* unwind-dw2.c (UNWIND_COLUMN_IN_RANGE): New macro.\n\t(execute_cfa_program): Use it when storing to fs->regs.\n\nFrom-SVN: r199019", "tree": {"sha": "545aebc5456658d87774829e39cd3651a5e27df8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/545aebc5456658d87774829e39cd3651a5e27df8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ec3322408800c96e750e9ee28f64dfbb259cfb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec3322408800c96e750e9ee28f64dfbb259cfb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec3322408800c96e750e9ee28f64dfbb259cfb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec3322408800c96e750e9ee28f64dfbb259cfb3/comments", "author": null, "committer": null, "parents": [{"sha": "38c821cf31574eb73cf27eec4573fd7e51217fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c821cf31574eb73cf27eec4573fd7e51217fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c821cf31574eb73cf27eec4573fd7e51217fcb"}], "stats": {"total": 131, "additions": 101, "deletions": 30}, "files": [{"sha": "2617c7e06072bf1bc3349a5478f334dae87a5abb", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec3322408800c96e750e9ee28f64dfbb259cfb3/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec3322408800c96e750e9ee28f64dfbb259cfb3/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0ec3322408800c96e750e9ee28f64dfbb259cfb3", "patch": "@@ -1,3 +1,9 @@\n+2013-05-17  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/49146\n+\t* unwind-dw2.c (UNWIND_COLUMN_IN_RANGE): New macro.\n+\t(execute_cfa_program): Use it when storing to fs->regs.\n+\n 2013-05-08  Kai Tietz  <ktietz@redhat.com>\n \n \t* config/i386/cygming-crtbegin.c (__register_frame_info): Make weak."}, {"sha": "041f9d5c3f06dc676df38516f6c2bd3e5413c902", "filename": "libgcc/unwind-dw2.c", "status": "modified", "additions": 95, "deletions": 30, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec3322408800c96e750e9ee28f64dfbb259cfb3/libgcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec3322408800c96e750e9ee28f64dfbb259cfb3/libgcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2.c?ref=0ec3322408800c96e750e9ee28f64dfbb259cfb3", "patch": "@@ -59,6 +59,35 @@\n #define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)\n #endif\n \n+/* ??? For the public function interfaces, we tend to gcc_assert that the\n+   column numbers are in range.  For the dwarf2 unwind info this does happen,\n+   although so far in a case that doesn't actually matter.\n+\n+   See PR49146, in which a call from x86_64 ms abi to x86_64 unix abi stores\n+   the call-saved xmm registers and annotates them.  We havn't bothered\n+   providing support for the xmm registers for the x86_64 port primarily\n+   because the 64-bit windows targets don't use dwarf2 unwind, using sjlj or\n+   SEH instead.  Adding the support for unix targets would generally be a\n+   waste.  However, some runtime libraries supplied with ICC do contain such\n+   an unorthodox transition, as well as the unwind info to match.  This loss\n+   of register restoration doesn't matter in practice, because the exception\n+   is caught in the native unix abi, where all of the xmm registers are \n+   call clobbered.\n+\n+   Ideally, we'd record some bit to notice when we're failing to restore some\n+   register recorded in the unwind info, but to do that we need annotation on\n+   the unix->ms abi edge, so that we know when the register data may be\n+   discarded.  And since this edge is also within the ICC library, we're\n+   unlikely to be able to get the new annotation.\n+\n+   Barring a magic solution to restore the ms abi defined 128-bit xmm registers\n+   (as distictly opposed to the full runtime width) without causing extra\n+   overhead for normal unix abis, the best solution seems to be to simply\n+   ignore unwind data for unknown columns.  */\n+\n+#define UNWIND_COLUMN_IN_RANGE(x) \\\n+    __builtin_expect((x) <= DWARF_FRAME_REGISTERS, 1)\n+\n #ifdef REG_VALUE_IN_UNWIND_CONTEXT\n typedef _Unwind_Word _Unwind_Context_Reg_Val;\n \n@@ -939,14 +968,19 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  reg = insn & 0x3f;\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  offset = (_Unwind_Sword) utmp * fs->data_align;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n-\t    = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = offset;\n+\t    }\n \t}\n       else if ((insn & 0xc0) == DW_CFA_restore)\n \t{\n \t  reg = insn & 0x3f;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_UNSAVED;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    fs->regs.reg[reg].how = REG_UNSAVED;\n \t}\n       else switch (insn)\n \t{\n@@ -977,26 +1011,35 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  offset = (_Unwind_Sword) utmp * fs->data_align;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n-\t    = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = offset;\n+\t    }\n \t  break;\n \n \tcase DW_CFA_restore_extended:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  /* FIXME, this is wrong; the CIE might have said that the\n \t     register was saved somewhere.  */\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    fs->regs.reg[reg].how = REG_UNSAVED;\n \t  break;\n \n \tcase DW_CFA_same_value:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    fs->regs.reg[reg].how = REG_UNSAVED;\n \t  break;\n \n \tcase DW_CFA_undefined:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNDEFINED;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    fs->regs.reg[reg].how = REG_UNDEFINED;\n \t  break;\n \n \tcase DW_CFA_nop:\n@@ -1007,9 +1050,12 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t    _uleb128_t reg2;\n \t    insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t    insn_ptr = read_uleb128 (insn_ptr, &reg2);\n-\t    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_REG;\n-\t    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.reg =\n-\t      (_Unwind_Word)reg2;\n+\t    reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t    if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t      {\n+\t        fs->regs.reg[reg].how = REG_SAVED_REG;\n+\t        fs->regs.reg[reg].loc.reg = (_Unwind_Word)reg2;\n+\t      }\n \t  }\n \t  break;\n \n@@ -1067,8 +1113,12 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \n \tcase DW_CFA_expression:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_EXP;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.exp = insn_ptr;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_EXP;\n+\t      fs->regs.reg[reg].loc.exp = insn_ptr;\n+\t    }\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  insn_ptr += utmp;\n \t  break;\n@@ -1078,9 +1128,12 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n \t  offset = stmp * fs->data_align;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n-\t    = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = offset;\n+\t    }\n \t  break;\n \n \tcase DW_CFA_def_cfa_sf:\n@@ -1103,25 +1156,34 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  offset = (_Unwind_Sword) utmp * fs->data_align;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n-\t    = REG_SAVED_VAL_OFFSET;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_VAL_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = offset;\n+\t    }\n \t  break;\n \n \tcase DW_CFA_val_offset_sf:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n \t  offset = stmp * fs->data_align;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n-\t    = REG_SAVED_VAL_OFFSET;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_VAL_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = offset;\n+\t    }\n \t  break;\n \n \tcase DW_CFA_val_expression:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n-\t    = REG_SAVED_VAL_EXP;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.exp = insn_ptr;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_VAL_EXP;\n+\t      fs->regs.reg[reg].loc.exp = insn_ptr;\n+\t    }\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  insn_ptr += utmp;\n \t  break;\n@@ -1147,9 +1209,12 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  offset = (_Unwind_Word) utmp * fs->data_align;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n-\t    = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = -offset;\n+\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n+\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = -offset;\n+\t    }\n \t  break;\n \n \tdefault:"}]}