{"sha": "477daf831aea18923733772d686eb1ed448d96e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc3ZGFmODMxYWVhMTg5MjM3MzM3NzJkNjg2ZWIxZWQ0NDhkOTZlNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-27T12:22:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-27T12:22:02Z"}, "message": "target.def (TARGET_VECTORIZE_BUILTIN_CONVERSION): Remove.\n\n2019-11-27  Richard Biener  <rguenther@suse.de>\n\n\t* target.def (TARGET_VECTORIZE_BUILTIN_CONVERSION): Remove.\n\t* targhooks.c (default_builtin_vectorized_conversion): Likewise.\n\t* targhooks.h (default_builtin_vectorized_conversion): Likewise.\n\t* optabs-tree.c (supportable_convert_operation): Do not call\n\ttargetm.vectorize.builtin_conversion.  Remove unused decl parameter.\n\t* optabs-tree.h (supportable_convert_operation): Adjust.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_CONVERSION): Remove.\n\t* doc/tm.texi: Regenerate.\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Adjust.\n\t* tree-vect-generic.c (expand_vector_conversion): Likewise.\n\t* tree-vect-stmts.c (vect_gen_widened_results_half): Remove\n\tunused decl parameter and adjust.\n\t(vect_create_vectorized_promotion_stmts): Likewise.\n\t(vectorizable_conversion): Adjust.\n\nFrom-SVN: r278765", "tree": {"sha": "d91ff4c3a8535e380adfa6b1b37ab5f0055e8ef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d91ff4c3a8535e380adfa6b1b37ab5f0055e8ef8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/477daf831aea18923733772d686eb1ed448d96e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477daf831aea18923733772d686eb1ed448d96e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477daf831aea18923733772d686eb1ed448d96e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477daf831aea18923733772d686eb1ed448d96e7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88feafba3cb5b186d53080c4958474065c4bd5d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88feafba3cb5b186d53080c4958474065c4bd5d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88feafba3cb5b186d53080c4958474065c4bd5d2"}], "stats": {"total": 220, "additions": 58, "deletions": 162}, "files": [{"sha": "e15d2e598c862342154aa8d2773c6b2dd088b6f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -1,3 +1,20 @@\n+2019-11-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* target.def (TARGET_VECTORIZE_BUILTIN_CONVERSION): Remove.\n+\t* targhooks.c (default_builtin_vectorized_conversion): Likewise.\n+\t* targhooks.h (default_builtin_vectorized_conversion): Likewise.\n+\t* optabs-tree.c (supportable_convert_operation): Do not call\n+\ttargetm.vectorize.builtin_conversion.  Remove unused decl parameter.\n+\t* optabs-tree.h (supportable_convert_operation): Adjust.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_CONVERSION): Remove.\n+\t* doc/tm.texi: Regenerate.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Adjust.\n+\t* tree-vect-generic.c (expand_vector_conversion): Likewise.\n+\t* tree-vect-stmts.c (vect_gen_widened_results_half): Remove\n+\tunused decl parameter and adjust.\n+\t(vect_create_vectorized_promotion_stmts): Likewise.\n+\t(vectorizable_conversion): Adjust.\n+\n 2019-11-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92690"}, {"sha": "7116450f5329c0ca4a8e36b5f43d0ab331d48771", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -5959,18 +5959,6 @@ instruction pattern.  There is no need for the hook to handle these two\n implementation approaches itself.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_CONVERSION (unsigned @var{code}, tree @var{dest_type}, tree @var{src_type})\n-This hook should return the DECL of a function that implements conversion of the\n-input vector of type @var{src_type} to type @var{dest_type}.\n-The value of @var{code} is one of the enumerators in @code{enum tree_code} and\n-specifies how the conversion is to be applied\n-(truncation, rounding, etc.).\n-\n-If this hook is defined, the autovectorizer will use the\n-@code{TARGET_VECTORIZE_BUILTIN_CONVERSION} target hook when vectorizing\n-conversion. Otherwise, it will return @code{NULL_TREE}.\n-@end deftypefn\n-\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (unsigned @var{code}, tree @var{vec_type_out}, tree @var{vec_type_in})\n This hook should return the decl of a function that implements the\n vectorized variant of the function with the @code{combined_fn} code"}, {"sha": "403468682bfc2461775083cf6daa3fa3234deac2", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -4163,8 +4163,6 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_VEC_PERM_CONST\n \n-@hook TARGET_VECTORIZE_BUILTIN_CONVERSION\n-\n @hook TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION\n \n @hook TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION"}, {"sha": "a04e4ffd05c1a3d0bb478c7a4b1b852fbcb05f4c", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -270,20 +270,16 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n \n    Convert operations we currently support directly are FIX_TRUNC and FLOAT.\n    This function checks if these operations are supported\n-   by the target platform either directly (via vector tree-codes), or via\n-   target builtins.\n+   by the target platform directly (via vector tree-codes).\n \n    Output:\n    - CODE1 is code of vector operation to be used when\n-   vectorizing the operation, if available.\n-   - DECL is decl of target builtin functions to be used\n-   when vectorizing the operation, if available.  In this case,\n-   CODE1 is CALL_EXPR.  */\n+   vectorizing the operation, if available.  */\n \n bool\n supportable_convert_operation (enum tree_code code,\n \t\t\t       tree vectype_out, tree vectype_in,\n-\t\t\t       tree *decl, enum tree_code *code1)\n+\t\t\t       enum tree_code *code1)\n {\n   machine_mode m1,m2;\n   bool truncp;\n@@ -317,15 +313,6 @@ supportable_convert_operation (enum tree_code code,\n       return true;\n     }\n \n-  /* Now check for builtin.  */\n-  if (targetm.vectorize.builtin_conversion\n-      && targetm.vectorize.builtin_conversion (code, vectype_out, vectype_in))\n-    {\n-      *code1 = CALL_EXPR;\n-      *decl = targetm.vectorize.builtin_conversion (code, vectype_out,\n-\t\t\t\t\t\t    vectype_in);\n-      return true;\n-    }\n   return false;\n }\n "}, {"sha": "dac35014234220e2a2ceb5eee30a3cf318e5f67e", "filename": "gcc/optabs-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Foptabs-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Foptabs-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.h?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -36,7 +36,7 @@ enum optab_subtype\n    the second argument.  The third argument distinguishes between the types of\n    vector shifts and rotates.  */\n optab optab_for_tree_code (enum tree_code, const_tree, enum optab_subtype);\n-bool supportable_convert_operation (enum tree_code, tree, tree, tree *,\n+bool supportable_convert_operation (enum tree_code, tree, tree,\n \t\t\t\t    enum tree_code *);\n bool expand_vec_cmp_expr_p (tree, tree, enum tree_code);\n bool expand_vec_cond_expr_p (tree, tree, enum tree_code);"}, {"sha": "cce71cd5b205f8868e2ebfba6f59243eeb49166e", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -1797,22 +1797,6 @@ return type of the vectorized function shall be of vector type\\n\\\n  tree, (tree fndecl, tree vec_type_out, tree vec_type_in),\n  default_builtin_md_vectorized_function)\n \n-/* Returns a function declaration for a builtin that realizes the\n-   vector conversion, or NULL_TREE if not available.  */\n-DEFHOOK\n-(builtin_conversion,\n- \"This hook should return the DECL of a function that implements conversion of the\\n\\\n-input vector of type @var{src_type} to type @var{dest_type}.\\n\\\n-The value of @var{code} is one of the enumerators in @code{enum tree_code} and\\n\\\n-specifies how the conversion is to be applied\\n\\\n-(truncation, rounding, etc.).\\n\\\n-\\n\\\n-If this hook is defined, the autovectorizer will use the\\n\\\n-@code{TARGET_VECTORIZE_BUILTIN_CONVERSION} target hook when vectorizing\\n\\\n-conversion. Otherwise, it will return @code{NULL_TREE}.\",\n- tree, (unsigned code, tree dest_type, tree src_type),\n- default_builtin_vectorized_conversion)\n-\n /* Cost of different vector/scalar statements in vectorization cost\n    model. In case of misaligned vector loads and stores the cost depends\n    on the data type and misalignment value.  */"}, {"sha": "2d3bcbf3e89a38e753b15592d5c66b130ab96049", "filename": "gcc/targhooks.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -688,16 +688,6 @@ default_builtin_md_vectorized_function (tree, tree, tree)\n   return NULL_TREE;\n }\n \n-/* Vectorized conversion.  */\n-\n-tree\n-default_builtin_vectorized_conversion (unsigned int code ATTRIBUTE_UNUSED,\n-\t\t\t\t       tree dest_type ATTRIBUTE_UNUSED,\n-\t\t\t\t       tree src_type ATTRIBUTE_UNUSED)\n-{\n-  return NULL_TREE;\n-}\n-\n /* Default vectorizer cost model values.  */\n \n int"}, {"sha": "34987bbcdb3fcac9818990fc67ebf0d8199d312d", "filename": "gcc/targhooks.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -93,8 +93,6 @@ extern const char * default_invalid_within_doloop (const rtx_insn *);\n extern tree default_builtin_vectorized_function (unsigned int, tree, tree);\n extern tree default_builtin_md_vectorized_function (tree, tree, tree);\n \n-extern tree default_builtin_vectorized_conversion (unsigned int, tree, tree);\n-\n extern int default_builtin_vectorization_cost (enum vect_cost_for_stmt, tree, int);\n \n extern tree default_builtin_reciprocal (tree);"}, {"sha": "f95b05b2832e5a415b7825f9fa155ebc954515a7", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -2150,11 +2150,9 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t      ? build_vector_type (TREE_TYPE (TREE_TYPE (orig[0])), nelts)\n \t      : type)\n \t   : TREE_TYPE (orig[0]));\n-      tree tem;\n       if (conv_code != ERROR_MARK\n-\t  && (!supportable_convert_operation (conv_code, type, conv_src_type,\n-\t\t\t\t\t      &tem, &conv_code)\n-\t      || conv_code == CALL_EXPR))\n+\t  && !supportable_convert_operation (conv_code, type, conv_src_type,\n+\t\t\t\t\t     &conv_code))\n \treturn false;\n       if (nelts != refnelts)\n \t{\n@@ -2179,10 +2177,9 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n       conv_src_type = (nelts == refnelts\n \t\t       ? perm_type\n \t\t       : build_vector_type (TREE_TYPE (perm_type), nelts));\n-      tree tem;\n       if (conv_code != ERROR_MARK\n \t  && (!supportable_convert_operation (conv_code, type, conv_src_type,\n-\t\t\t\t\t      &tem, &conv_code)\n+\t\t\t\t\t      &conv_code)\n \t      || conv_code == CALL_EXPR))\n \treturn false;\n "}, {"sha": "7ec6b5fc51eba76947b7f324a3180e06cab70617", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -1697,7 +1697,6 @@ expand_vector_conversion (gimple_stmt_iterator *gsi)\n   gimple *g;\n   tree lhs = gimple_call_lhs (stmt);\n   tree arg = gimple_call_arg (stmt, 0);\n-  tree decl = NULL_TREE;\n   tree ret_type = TREE_TYPE (lhs);\n   tree arg_type = TREE_TYPE (arg);\n   tree new_rhs, compute_type = TREE_TYPE (arg_type);\n@@ -1724,16 +1723,9 @@ expand_vector_conversion (gimple_stmt_iterator *gsi)\n \n   if (modifier == NONE && (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR))\n     {\n-      if (supportable_convert_operation (code, ret_type, arg_type, &decl,\n-\t\t\t\t\t &code1))\n+      if (supportable_convert_operation (code, ret_type, arg_type, &code1))\n \t{\n-\t  if (code1 == CALL_EXPR)\n-\t    {\n-\t      g = gimple_build_call (decl, 1, arg);\n-\t      gimple_call_set_lhs (g, lhs);\n-\t    }\n-\t  else\n-\t    g = gimple_build_assign (lhs, code1, arg);\n+\t  g = gimple_build_assign (lhs, code1, arg);\n \t  gsi_replace (gsi, g, false);\n \t  return;\n \t}\n@@ -1752,11 +1744,11 @@ expand_vector_conversion (gimple_stmt_iterator *gsi)\n \t      tree ret1_type = build_vector_type (TREE_TYPE (ret_type), nelts);\n \t      tree arg1_type = build_vector_type (TREE_TYPE (arg_type), nelts);\n \t      if (supportable_convert_operation (code, ret1_type, arg1_type,\n-\t\t\t\t\t\t &decl, &code1))\n+\t\t\t\t\t\t &code1))\n \t\t{\n \t\t  new_rhs = expand_vector_piecewise (gsi, do_vec_conversion,\n \t\t\t\t\t\t     ret_type, arg1_type, arg,\n-\t\t\t\t\t\t     decl, code1);\n+\t\t\t\t\t\t     NULL_TREE, code1);\n \t\t  g = gimple_build_assign (lhs, new_rhs);\n \t\t  gsi_replace (gsi, g, false);\n \t\t  return;"}, {"sha": "426ae2c9faee1ee61967a83e4541e2055bcfc386", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 30, "deletions": 85, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477daf831aea18923733772d686eb1ed448d96e7/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=477daf831aea18923733772d686eb1ed448d96e7", "patch": "@@ -4482,7 +4482,6 @@ vectorizable_simd_clone_call (stmt_vec_info stmt_info,\n \n static gimple *\n vect_gen_widened_results_half (enum tree_code code,\n-\t\t\t       tree decl,\n                                tree vec_oprnd0, tree vec_oprnd1, int op_type,\n \t\t\t       tree vec_dest, gimple_stmt_iterator *gsi,\n \t\t\t       stmt_vec_info stmt_info)\n@@ -4491,26 +4490,12 @@ vect_gen_widened_results_half (enum tree_code code,\n   tree new_temp;\n \n   /* Generate half of the widened result:  */\n-  if (code == CALL_EXPR)\n-    {\n-      /* Target specific support  */\n-      if (op_type == binary_op)\n-\tnew_stmt = gimple_build_call (decl, 2, vec_oprnd0, vec_oprnd1);\n-      else\n-\tnew_stmt = gimple_build_call (decl, 1, vec_oprnd0);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      gimple_call_set_lhs (new_stmt, new_temp);\n-    }\n-  else\n-    {\n-      /* Generic support */\n-      gcc_assert (op_type == TREE_CODE_LENGTH (code));\n-      if (op_type != binary_op)\n-\tvec_oprnd1 = NULL;\n-      new_stmt = gimple_build_assign (vec_dest, code, vec_oprnd0, vec_oprnd1);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      gimple_assign_set_lhs (new_stmt, new_temp);\n-    }\n+  gcc_assert (op_type == TREE_CODE_LENGTH (code));\n+  if (op_type != binary_op)\n+    vec_oprnd1 = NULL;\n+  new_stmt = gimple_build_assign (vec_dest, code, vec_oprnd0, vec_oprnd1);\n+  new_temp = make_ssa_name (vec_dest, new_stmt);\n+  gimple_assign_set_lhs (new_stmt, new_temp);\n   vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \n   return new_stmt;\n@@ -4636,8 +4621,7 @@ vect_create_vectorized_promotion_stmts (vec<tree> *vec_oprnds0,\n \t\t\t\t\tstmt_vec_info stmt_info, tree vec_dest,\n \t\t\t\t\tgimple_stmt_iterator *gsi,\n \t\t\t\t\tenum tree_code code1,\n-\t\t\t\t\tenum tree_code code2, tree decl1,\n-\t\t\t\t\ttree decl2, int op_type)\n+\t\t\t\t\tenum tree_code code2, int op_type)\n {\n   int i;\n   tree vop0, vop1, new_tmp1, new_tmp2;\n@@ -4653,10 +4637,10 @@ vect_create_vectorized_promotion_stmts (vec<tree> *vec_oprnds0,\n \tvop1 = NULL_TREE;\n \n       /* Generate the two halves of promotion operation.  */\n-      new_stmt1 = vect_gen_widened_results_half (code1, decl1, vop0, vop1,\n+      new_stmt1 = vect_gen_widened_results_half (code1, vop0, vop1,\n \t\t\t\t\t\t op_type, vec_dest, gsi,\n \t\t\t\t\t\t stmt_info);\n-      new_stmt2 = vect_gen_widened_results_half (code2, decl2, vop0, vop1,\n+      new_stmt2 = vect_gen_widened_results_half (code2, vop0, vop1,\n \t\t\t\t\t\t op_type, vec_dest, gsi,\n \t\t\t\t\t\t stmt_info);\n       if (is_gimple_call (new_stmt1))\n@@ -4697,7 +4681,6 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code, code1 = ERROR_MARK, code2 = ERROR_MARK;\n   enum tree_code codecvt1 = ERROR_MARK, codecvt2 = ERROR_MARK;\n-  tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   tree new_temp;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 2;\n@@ -4868,8 +4851,7 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  && code != FLOAT_EXPR\n \t  && !CONVERT_EXPR_CODE_P (code))\n \treturn false;\n-      if (supportable_convert_operation (code, vectype_out, vectype_in,\n-\t\t\t\t\t &decl1, &code1))\n+      if (supportable_convert_operation (code, vectype_out, vectype_in, &code1))\n \tbreak;\n       /* FALLTHRU */\n     unsupported:\n@@ -4909,7 +4891,7 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  if (GET_MODE_SIZE (rhs_mode) == fltsz)\n \t    {\n \t      if (!supportable_convert_operation (code, vectype_out,\n-\t\t\t\t\t\t  cvt_type, &decl1, &codecvt1))\n+\t\t\t\t\t\t  cvt_type, &codecvt1))\n \t\tgoto unsupported;\n \t    }\n \t  else if (!supportable_widening_operation (code, stmt_info,\n@@ -4960,7 +4942,7 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (cvt_type == NULL_TREE)\n \tgoto unsupported;\n       if (!supportable_convert_operation (code, cvt_type, vectype_in,\n-\t\t\t\t\t  &decl1, &codecvt1))\n+\t\t\t\t\t  &codecvt1))\n \tgoto unsupported;\n       if (supportable_narrowing_operation (NOP_EXPR, vectype_out, cvt_type,\n \t\t\t\t\t   &code1, &multi_step_cvt,\n@@ -5079,24 +5061,12 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    {\n \t      stmt_vec_info new_stmt_info;\n \t      /* Arguments are ready, create the new vector stmt.  */\n-\t      if (code1 == CALL_EXPR)\n-\t\t{\n-\t\t  gcall *new_stmt = gimple_build_call (decl1, 1, vop0);\n-\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t  gimple_call_set_lhs (new_stmt, new_temp);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (TREE_CODE_LENGTH (code1) == unary_op);\n-\t\t  gassign *new_stmt\n-\t\t    = gimple_build_assign (vec_dest, code1, vop0);\n-\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n-\t\t}\n+\t      gcc_assert (TREE_CODE_LENGTH (code1) == unary_op);\n+\t      gassign *new_stmt = gimple_build_assign (vec_dest, code1, vop0);\n+\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t      gimple_assign_set_lhs (new_stmt, new_temp);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \n \t      if (slp_node)\n \t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n@@ -5188,34 +5158,20 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      vect_create_vectorized_promotion_stmts (&vec_oprnds0,\n \t\t\t\t\t\t      &vec_oprnds1, stmt_info,\n \t\t\t\t\t\t      this_dest, gsi,\n-\t\t\t\t\t\t      c1, c2, decl1, decl2,\n-\t\t\t\t\t\t      op_type);\n+\t\t\t\t\t\t      c1, c2, op_type);\n \t    }\n \n \t  FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n \t    {\n \t      stmt_vec_info new_stmt_info;\n \t      if (cvt_type)\n \t\t{\n-\t\t  if (codecvt1 == CALL_EXPR)\n-\t\t    {\n-\t\t      gcall *new_stmt = gimple_build_call (decl1, 1, vop0);\n-\t\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t      gimple_call_set_lhs (new_stmt, new_temp);\n-\t\t      new_stmt_info\n-\t\t\t= vect_finish_stmt_generation (stmt_info, new_stmt,\n-\t\t\t\t\t\t       gsi);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n-\t\t      new_temp = make_ssa_name (vec_dest);\n-\t\t      gassign *new_stmt\n-\t\t\t= gimple_build_assign (new_temp, codecvt1, vop0);\n-\t\t      new_stmt_info\n-\t\t\t= vect_finish_stmt_generation (stmt_info, new_stmt,\n-\t\t\t\t\t\t       gsi);\n-\t\t    }\n+\t\t  gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n+\t\t  new_temp = make_ssa_name (vec_dest);\n+\t\t  gassign *new_stmt\n+\t\t    = gimple_build_assign (new_temp, codecvt1, vop0);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \t\t}\n \t      else\n \t\tnew_stmt_info = vinfo->lookup_def (vop0);\n@@ -5258,22 +5214,11 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  if (cvt_type)\n \t    FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n \t      {\n-\t\tif (codecvt1 == CALL_EXPR)\n-\t\t  {\n-\t\t    gcall *new_stmt = gimple_build_call (decl1, 1, vop0);\n-\t\t    new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t    gimple_call_set_lhs (new_stmt, new_temp);\n-\t\t    vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n-\t\t    new_temp = make_ssa_name (vec_dest);\n-\t\t    gassign *new_stmt\n-\t\t      = gimple_build_assign (new_temp, codecvt1, vop0);\n-\t\t    vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n-\t\t  }\n-\n+\t\tgcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n+\t\tnew_temp = make_ssa_name (vec_dest);\n+\t\tgassign *new_stmt\n+\t\t    = gimple_build_assign (new_temp, codecvt1, vop0);\n+\t\tvect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \t\tvec_oprnds0[i] = new_temp;\n \t      }\n "}]}