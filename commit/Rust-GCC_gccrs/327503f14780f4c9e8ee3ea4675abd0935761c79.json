{"sha": "327503f14780f4c9e8ee3ea4675abd0935761c79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI3NTAzZjE0NzgwZjRjOWU4ZWUzZWE0Njc1YWJkMDkzNTc2MWM3OQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2009-07-28T08:46:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-28T08:46:39Z"}, "message": "gnat1drv.adb (Adjust_Global_Switches): Disable generation of SCIL nodes if we are not generating code.\n\n2009-07-28  Javier Miranda  <miranda@adacore.com>\n\n\t* gnat1drv.adb (Adjust_Global_Switches): Disable generation of SCIL\n\tnodes if we are not generating code.\n\t* frontend.adb (Check_SCIL_Node): New subprogram. Used to check\n\tattribute SCIL_Related_Node of SCIL dispatching nodes.\n\t(Check_SCIL_Nodes): New instantiation of Traverse_Proc.\n\t* sinfo.ads (Is_SCIL_Node,Set_Is_SCIL_Node): Removed\n\t(SCIL_Nkind,Set_SCIL_Nkind): Removed.\n\t(SCIL_Entity): Update documentation.\n\t(SCIL_Related_Node): Update documentation.\n\t(SCIL_Controlling_Tag): New attribute.\n\t(SCIL_Target_Prim): Update documentation.\n\t(N_Null_Statement): Remove attributes associated with SCIL nodes.\n\t(N_SCIL_Dispatch_Table_Object_Init): New node.\n\t(N_SCIL_Dispatch_Table_Tag_Init): New node.\n\t(N_SCIL_Dispatching_Call): New node.\n\t(N_SCIL_Tag_Init): New node.\n\t* sinfo.adb (Is_SCIL_Node,Set_Is_SCIL_Node): Removed\n\t(SCIL_Nkind,Set_SCIL_Nkind): Removed.\n\t(SCIL_Controlling_Tag/Set_SCIL_Controlling_Tag): New subprogram.\n\t(SCIL_Entity,Set_SCIL_Entity): Applicable only to SCIL nodes.\n\t(SCIL_Related_Node,Set_SCIL_Related_Node): Applicable only to SCIL nodes\n\t(SCIL_Target_Prim,Set_SCIL_Target_Prim): Applicable only to\n\tN_SCIL_Dispatching_Call nodes.\n\t* sem.adb (Analyze): No need to analyze SCIL nodes.\n\t* sem_aux.ads, sem_aux.adb (First_Non_SCIL_Node): New subprogram\n\t(Next_Non_SCIL_Node): New subprogram\n\t* sem_ch4.adb (Analyze_Type_Conversion): Adjust relocated SCIL\n\tdispatching nodes.\n\t* sem_ch5.adb (Analyze_Iteration_Scheme): Adjust relocated SCIL\n\tdispatching node.\n\t* sem_util.adb (Insert_Explicit_Dereference): Adjust relocated SCIL\n\tdispatching node.\n\t* exp_ch3.adb (Build_Array_Init_Proc): Skip SCIL nodes when processing\n\tnull statement nodes.\n\t(Build_Init_Procedure): Generate new SCIL node.\n\t* exp_ch4.adb (Expand_N_And_Then): Adjust relocated SCIL dispatching\n\tnode.\n\t* exp_ch6.adb (Is_Null_Procedure): Skip SCIL nodes. Required because\n\tthey are currently implemented as special N_Null_Statement nodes.\n\t* exp_ch7.adb (Wrap_Transient_Statement): If the relocated node is a\n\tprocedure call then check if some SCIL node references it and needs\n\treadjustment.\n\t* exp_disp.ads (SCIL_Node_Kind): Removed.\n\t(Adjust_SCIL_Node): New subprogram.\n\t(Find_SCIL_Node): New subprogram.\n\t(Get_SCIL_Node_Kind): Removed.\n\t(New_SCIL_Node): Removed.\n\t* exp_disp.adb (Adjust_SCIL_Node): New subprogram\n\t(Expand_Dispatching_Call): Generate new SCIL dispatching node including\n\tdecoration of its new controlling_tag attribute.\n\t(Get_SCIL_Node_Kind): Removed.\n\t(Find_SCIL_Node): New subprogram.\n\t(Make_Secondary_DT): Generate new SCIL nodes.\n\t(Make_Tags): Generate new SCIL nodes.\n\t(New_SCIL_Node): Removed.\n\t* exp_util.adb (Insert_Actions): Handle SCIL nodes.\n\t(Remove_Side_Effects): Check if relocated nodes require readjustment\n\tof some SCIL dispatching node.\n\t* gcc-interface/trans.c (gnat_to_gnu): Do nothing with new SCIL nodes.\n\nFrom-SVN: r150149", "tree": {"sha": "cd9ef3438c64c9d0d618df9a367d8d3ff506ca25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd9ef3438c64c9d0d618df9a367d8d3ff506ca25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/327503f14780f4c9e8ee3ea4675abd0935761c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/327503f14780f4c9e8ee3ea4675abd0935761c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/327503f14780f4c9e8ee3ea4675abd0935761c79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/327503f14780f4c9e8ee3ea4675abd0935761c79/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b125fe15d745572a8fbcde73996bf82037130253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b125fe15d745572a8fbcde73996bf82037130253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b125fe15d745572a8fbcde73996bf82037130253"}], "stats": {"total": 1192, "additions": 973, "deletions": 219}, "files": [{"sha": "0fe4ef446242fe6386ce31cca0a32221f6b1ab3d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -1,3 +1,65 @@\n+2009-07-28  Javier Miranda  <miranda@adacore.com>\n+\n+\t* gnat1drv.adb (Adjust_Global_Switches): Disable generation of SCIL\n+\tnodes if we are not generating code.\n+\t* frontend.adb (Check_SCIL_Node): New subprogram. Used to check\n+\tattribute SCIL_Related_Node of SCIL dispatching nodes.\n+\t(Check_SCIL_Nodes): New instantiation of Traverse_Proc.\n+\t* sinfo.ads (Is_SCIL_Node,Set_Is_SCIL_Node): Removed\n+\t(SCIL_Nkind,Set_SCIL_Nkind): Removed.\n+\t(SCIL_Entity): Update documentation.\n+\t(SCIL_Related_Node): Update documentation.\n+\t(SCIL_Controlling_Tag): New attribute.\n+\t(SCIL_Target_Prim): Update documentation.\n+\t(N_Null_Statement): Remove attributes associated with SCIL nodes.\n+\t(N_SCIL_Dispatch_Table_Object_Init): New node.\n+\t(N_SCIL_Dispatch_Table_Tag_Init): New node.\n+\t(N_SCIL_Dispatching_Call): New node.\n+\t(N_SCIL_Tag_Init): New node.\n+\t* sinfo.adb (Is_SCIL_Node,Set_Is_SCIL_Node): Removed\n+\t(SCIL_Nkind,Set_SCIL_Nkind): Removed.\n+\t(SCIL_Controlling_Tag/Set_SCIL_Controlling_Tag): New subprogram.\n+\t(SCIL_Entity,Set_SCIL_Entity): Applicable only to SCIL nodes.\n+\t(SCIL_Related_Node,Set_SCIL_Related_Node): Applicable only to SCIL nodes\n+\t(SCIL_Target_Prim,Set_SCIL_Target_Prim): Applicable only to\n+\tN_SCIL_Dispatching_Call nodes.\n+\t* sem.adb (Analyze): No need to analyze SCIL nodes.\n+\t* sem_aux.ads, sem_aux.adb (First_Non_SCIL_Node): New subprogram\n+\t(Next_Non_SCIL_Node): New subprogram\n+\t* sem_ch4.adb (Analyze_Type_Conversion): Adjust relocated SCIL\n+\tdispatching nodes.\n+\t* sem_ch5.adb (Analyze_Iteration_Scheme): Adjust relocated SCIL\n+\tdispatching node.\n+\t* sem_util.adb (Insert_Explicit_Dereference): Adjust relocated SCIL\n+\tdispatching node.\n+\t* exp_ch3.adb (Build_Array_Init_Proc): Skip SCIL nodes when processing\n+\tnull statement nodes.\n+\t(Build_Init_Procedure): Generate new SCIL node.\n+\t* exp_ch4.adb (Expand_N_And_Then): Adjust relocated SCIL dispatching\n+\tnode.\n+\t* exp_ch6.adb (Is_Null_Procedure): Skip SCIL nodes. Required because\n+\tthey are currently implemented as special N_Null_Statement nodes.\n+\t* exp_ch7.adb (Wrap_Transient_Statement): If the relocated node is a\n+\tprocedure call then check if some SCIL node references it and needs\n+\treadjustment.\n+\t* exp_disp.ads (SCIL_Node_Kind): Removed.\n+\t(Adjust_SCIL_Node): New subprogram.\n+\t(Find_SCIL_Node): New subprogram.\n+\t(Get_SCIL_Node_Kind): Removed.\n+\t(New_SCIL_Node): Removed.\n+\t* exp_disp.adb (Adjust_SCIL_Node): New subprogram\n+\t(Expand_Dispatching_Call): Generate new SCIL dispatching node including\n+\tdecoration of its new controlling_tag attribute.\n+\t(Get_SCIL_Node_Kind): Removed.\n+\t(Find_SCIL_Node): New subprogram.\n+\t(Make_Secondary_DT): Generate new SCIL nodes.\n+\t(Make_Tags): Generate new SCIL nodes.\n+\t(New_SCIL_Node): Removed.\n+\t* exp_util.adb (Insert_Actions): Handle SCIL nodes.\n+\t(Remove_Side_Effects): Check if relocated nodes require readjustment\n+\tof some SCIL dispatching node.\n+\t* gcc-interface/trans.c (gnat_to_gnu): Do nothing with new SCIL nodes.\n+\n 2009-07-28  Robert Dewar  <dewar@adacore.com>\n \n \t* prj-nmsc.adb, g-expect.adb, prj.ads: Minor reformatting"}, {"sha": "4ff1f3e12dad2a7a7b4bd659e43328ed7d466c4b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -752,7 +752,11 @@ package body Exp_Ch3 is\n          Set_Init_Proc (A_Type, Proc_Id);\n \n          if List_Length (Body_Stmts) = 1\n-           and then Nkind (First (Body_Stmts)) = N_Null_Statement\n+\n+           --  We must skip SCIL nodes because they may have been added to this\n+           --  list by Insert_Actions.\n+\n+           and then Nkind (First_Non_SCIL_Node (Body_Stmts)) = N_Null_Statement\n          then\n             Set_Is_Null_Init_Proc (Proc_Id);\n \n@@ -763,7 +767,7 @@ package body Exp_Ch3 is\n \n             Set_Static_Initialization\n               (Proc_Id,\n-                Build_Equivalent_Array_Aggregate (First_Subtype (A_Type)));\n+               Build_Equivalent_Array_Aggregate (First_Subtype (A_Type)));\n          end if;\n       end if;\n    end Build_Array_Init_Proc;\n@@ -1939,6 +1943,7 @@ package body Exp_Ch3 is\n             D := First_Discriminant (Rec_Type);\n \n             while Present (D) loop\n+\n                --  Don't generate the assignment for discriminants in derived\n                --  tagged types if the discriminant is a renaming of some\n                --  ancestor discriminant. This initialization will be done\n@@ -2330,11 +2335,16 @@ package body Exp_Ch3 is\n             --  the tag component.\n \n             if Generate_SCIL then\n-               Prepend_To (Init_Tags_List,\n-                 New_SCIL_Node\n-                   (SN_Kind      => IP_Tag_Init,\n-                    Related_Node => First (Init_Tags_List),\n-                    Entity       => Rec_Type));\n+               declare\n+                  New_Node : Node_Id;\n+\n+               begin\n+                  New_Node :=\n+                    Make_SCIL_Tag_Init (Sloc (First (Init_Tags_List)));\n+                  Set_SCIL_Related_Node (New_Node, First (Init_Tags_List));\n+                  Set_SCIL_Entity (New_Node, Rec_Type);\n+                  Prepend_To (Init_Tags_List, New_Node);\n+               end;\n             end if;\n \n             --  Ada 2005 (AI-251): Initialize the secondary tags components\n@@ -2496,7 +2506,11 @@ package body Exp_Ch3 is\n          Set_Init_Proc (Rec_Type, Proc_Id);\n \n          if List_Length (Body_Stmts) = 1\n-           and then Nkind (First (Body_Stmts)) = N_Null_Statement\n+\n+           --  We must skip SCIL nodes because they are currently implemented\n+           --  as special N_Null_Statement nodes.\n+\n+           and then Nkind (First_Non_SCIL_Node (Body_Stmts)) = N_Null_Statement\n            and then VM_Target = No_VM\n          then\n             --  Even though the init proc may be null at this time it might get"}, {"sha": "167582374fb084f1ef26099b0d12c4969520fcd7", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -3965,6 +3965,16 @@ package body Exp_Ch4 is\n                 Right,\n                 New_Occurrence_Of (Standard_False, Loc))));\n \n+         --  If the right part of the expression is a function call then it can\n+         --  be part of the expansion of the predefined equality operator of a\n+         --  tagged type and we may need to adjust its SCIL dispatching node.\n+\n+         if Generate_SCIL\n+           and then Nkind (Right) = N_Function_Call\n+         then\n+            Adjust_SCIL_Node (N, Right);\n+         end if;\n+\n          Set_Then_Actions (N, Actlist);\n          Analyze_And_Resolve (N, Standard_Boolean);\n          Adjust_Result_Type (N, Typ);"}, {"sha": "13f6d9d0a1d7eace23f47e3073d4b89b01f10263", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -4972,10 +4972,13 @@ package body Exp_Ch6 is\n                if Nkind (Orig_Bod) /= N_Subprogram_Body then\n                   return False;\n                else\n+                  --  We must skip SCIL nodes because they are currently\n+                  --  implemented as special N_Null_Statement nodes.\n+\n                   Stat :=\n-                     First\n+                     First_Non_SCIL_Node\n                        (Statements (Handled_Statement_Sequence (Orig_Bod)));\n-                  Stat2 := Next (Stat);\n+                  Stat2 := Next_Non_SCIL_Node (Stat);\n \n                   return\n                      Is_Empty_List (Declarations (Orig_Bod))"}, {"sha": "28704052c29d4129d716398c70398d6cdf41c450", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -3602,6 +3602,15 @@ package body Exp_Ch7 is\n       New_Statement : constant Node_Id := Relocate_Node (N);\n \n    begin\n+      --  If the relocated node is a procedure call then check if some SCIL\n+      --  node references it and needs readjustment.\n+\n+      if Generate_SCIL\n+        and then Nkind (New_Statement) = N_Procedure_Call_Statement\n+      then\n+         Adjust_SCIL_Node (N, New_Statement);\n+      end if;\n+\n       Rewrite (N, Make_Transient_Block (Loc, New_Statement));\n \n       --  With the scope stack back to normal, we can call analyze on the"}, {"sha": "634d7647c39a776ed25b48687e6fe008e1ecd3da", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 532, "deletions": 77, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -100,6 +100,66 @@ package body Exp_Disp is\n    --  Ada 2005 (AI-345): Determine the tagged kind of T and return a reference\n    --  to an RE_Tagged_Kind enumeration value.\n \n+   ----------------------\n+   -- Adjust_SCIL_Node --\n+   ----------------------\n+\n+   procedure Adjust_SCIL_Node (Old_Node : Node_Id; New_Node : Node_Id) is\n+      SCIL_Node : Node_Id;\n+\n+   begin\n+      pragma Assert (Generate_SCIL);\n+\n+      --  Check cases in which no action is required. Currently the only SCIL\n+      --  nodes that may require adjustment are those of dispatching calls\n+      --  internally generated by the frontend.\n+\n+      if Comes_From_Source (Old_Node)\n+        or else not\n+          Nkind_In (New_Node, N_Function_Call, N_Procedure_Call_Statement)\n+      then\n+         return;\n+\n+      --  Conditional expression associated with equality operator. Old_Node\n+      --  may be part of the expansion of the predefined equality operator of\n+      --  a tagged type and hence we need to check if it has a SCIL dispatching\n+      --  node that needs adjustment.\n+\n+      elsif Nkind (Old_Node) = N_Conditional_Expression\n+        and then (Nkind (Original_Node (Old_Node)) = N_Op_Eq\n+                    or else\n+                      (Nkind (Original_Node (Old_Node)) = N_Function_Call\n+                        and then Chars (Name (Original_Node (Old_Node)))\n+                                   = Name_Op_Eq))\n+      then\n+         null;\n+\n+      --  Type conversions may involve dispatching calls to functions whose\n+      --  associated SCIL dispatching node needs adjustment.\n+\n+      elsif Nkind (Old_Node) = N_Type_Conversion then\n+         null;\n+\n+      --  Relocated subprogram call\n+\n+      elsif Nkind (Old_Node) = Nkind (New_Node)\n+        and then Original_Node (Old_Node) = Original_Node (New_Node)\n+      then\n+         null;\n+\n+      else\n+         return;\n+      end if;\n+\n+      --  Search for the SCIL node and update it (if found)\n+\n+      SCIL_Node := Find_SCIL_Node (Old_Node);\n+\n+      if Present (SCIL_Node) then\n+         Set_SCIL_Related_Node (SCIL_Node, New_Node);\n+      end if;\n+   end Adjust_SCIL_Node;\n+\n    ----------------------\n    -- Apply_Tag_Checks --\n    ----------------------\n@@ -575,6 +635,10 @@ package body Exp_Disp is\n          end if;\n       end New_Value;\n \n+      --  Local variables\n+\n+      SCIL_Node : Node_Id;\n+\n    --  Start of processing for Expand_Dispatching_Call\n \n    begin\n@@ -649,12 +713,11 @@ package body Exp_Disp is\n       --  BEFORE the expanded nodes associated with the call node are found.\n \n       if Generate_SCIL then\n-         Insert_Action (Call_Node,\n-           New_SCIL_Node\n-             (SN_Kind      => Dispatching_Call,\n-              Related_Node => Call_Node,\n-              Entity       => Typ,\n-              Target_Prim  => Subp));\n+         SCIL_Node := Make_SCIL_Dispatching_Call (Sloc (Call_Node));\n+         Set_SCIL_Related_Node (SCIL_Node, Call_Node);\n+         Set_SCIL_Entity       (SCIL_Node, Typ);\n+         Set_SCIL_Target_Prim  (SCIL_Node, Subp);\n+         Insert_Action (Call_Node, SCIL_Node);\n       end if;\n \n       if not Is_Limited_Type (Typ) then\n@@ -811,6 +874,12 @@ package body Exp_Disp is\n              Selector_Name => New_Reference_To (DTC_Entity (Subp), Loc));\n       end if;\n \n+      --  Complete decoration of SCIL dispatching node\n+\n+      if Generate_SCIL then\n+         Set_SCIL_Controlling_Tag (SCIL_Node, Controlling_Tag);\n+      end if;\n+\n       --  Handle dispatching calls to predefined primitives\n \n       if Is_Predefined_Dispatching_Operation (Subp)\n@@ -1610,16 +1679,424 @@ package body Exp_Disp is\n       end if;\n    end Expand_Interface_Thunk;\n \n-   ------------------------\n-   -- Get_SCIL_Node_Kind --\n-   ------------------------\n+   --------------------\n+   -- Find_SCIL_Node --\n+   --------------------\n+\n+   function Find_SCIL_Node (Node : Node_Id) return Node_Id is\n+      Found_Node : Node_Id;\n+      --  This variable stores the last node found by the nested subprogram\n+      --  Find_SCIL_Node.\n+\n+      function Find_SCIL_Node (L : List_Id) return Boolean;\n+      --  Searches in list L for a SCIL node associated with a dispatching call\n+      --  whose SCIL_Related_Node is Node. If found returns true and stores the\n+      --  SCIL node in Found_Node; otherwise returns False and sets Found_Node\n+      --  to Empty.\n+\n+      function Find_SCIL_Node (L : List_Id) return Boolean is\n+         N : Node_Id;\n+\n+      begin\n+         N := First (L);\n+         while Present (N) loop\n+            if Nkind (N) in N_SCIL_Node\n+              and then SCIL_Related_Node (N) = Node\n+            then\n+               Found_Node := N;\n+               return True;\n+            end if;\n+\n+            Next (N);\n+         end loop;\n+\n+         Found_Node := Empty;\n+         return False;\n+      end Find_SCIL_Node;\n+\n+      --  Local variables\n+\n+      P : Node_Id;\n+\n+   --  Start of processing for Find_SCIL_Node\n \n-   function Get_SCIL_Node_Kind (Node : Node_Id) return SCIL_Node_Kind is\n    begin\n-      pragma Assert\n-        (Nkind (Node) = N_Null_Statement and then Is_SCIL_Node (Node));\n-      return SCIL_Node_Kind'Val (UI_To_Int (SCIL_Nkind (Node)));\n-   end Get_SCIL_Node_Kind;\n+      pragma Assert (Generate_SCIL);\n+\n+      --  Search for the SCIL node in the list associated with a transient\n+      --  scope\n+\n+      if Scope_Is_Transient then\n+         declare\n+            SE : Scope_Stack_Entry\n+                   renames Scope_Stack.Table (Scope_Stack.Last);\n+         begin\n+            if SE.Is_Transient\n+              and then Present (SE.Actions_To_Be_Wrapped_Before)\n+              and then Find_SCIL_Node (SE.Actions_To_Be_Wrapped_Before)\n+            then\n+               return Found_Node;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Otherwise climb up the tree searching for the SCIL node analyzing\n+      --  all the lists in which Insert_Actions may have inserted it\n+\n+      P := Node;\n+      while Present (P) loop\n+         case Nkind (P) is\n+\n+            --  Actions associated with AND THEN or OR ELSE\n+\n+            when N_Short_Circuit =>\n+               if Present (Actions (P))\n+                 and then Find_SCIL_Node (Actions (P))\n+               then\n+                  return Found_Node;\n+               end if;\n+\n+            --  Actions of conditional expressions\n+\n+            when N_Conditional_Expression =>\n+               if (Present (Then_Actions (P))\n+                     and then Find_SCIL_Node (Actions (P)))\n+                 or else\n+                  (Present (Else_Actions (P))\n+                     and then Find_SCIL_Node (Else_Actions (P)))\n+               then\n+                  return Found_Node;\n+               end if;\n+\n+            --  Conditions of while expression or elsif.\n+\n+            when N_Iteration_Scheme |\n+                 N_Elsif_Part\n+            =>\n+               if Present (Condition_Actions (P))\n+                 and then Find_SCIL_Node (Condition_Actions (P))\n+               then\n+                  return Found_Node;\n+               end if;\n+\n+            --  Statements, declarations, pragmas, representation clauses\n+\n+            when\n+               --  Statements\n+\n+               N_Procedure_Call_Statement               |\n+               N_Statement_Other_Than_Procedure_Call    |\n+\n+               --  Pragmas\n+\n+               N_Pragma                                 |\n+\n+               --  Representation_Clause\n+\n+               N_At_Clause                              |\n+               N_Attribute_Definition_Clause            |\n+               N_Enumeration_Representation_Clause      |\n+               N_Record_Representation_Clause           |\n+\n+               --  Declarations\n+\n+               N_Abstract_Subprogram_Declaration        |\n+               N_Entry_Body                             |\n+               N_Exception_Declaration                  |\n+               N_Exception_Renaming_Declaration         |\n+               N_Formal_Abstract_Subprogram_Declaration |\n+               N_Formal_Concrete_Subprogram_Declaration |\n+               N_Formal_Object_Declaration              |\n+               N_Formal_Type_Declaration                |\n+               N_Full_Type_Declaration                  |\n+               N_Function_Instantiation                 |\n+               N_Generic_Function_Renaming_Declaration  |\n+               N_Generic_Package_Declaration            |\n+               N_Generic_Package_Renaming_Declaration   |\n+               N_Generic_Procedure_Renaming_Declaration |\n+               N_Generic_Subprogram_Declaration         |\n+               N_Implicit_Label_Declaration             |\n+               N_Incomplete_Type_Declaration            |\n+               N_Number_Declaration                     |\n+               N_Object_Declaration                     |\n+               N_Object_Renaming_Declaration            |\n+               N_Package_Body                           |\n+               N_Package_Body_Stub                      |\n+               N_Package_Declaration                    |\n+               N_Package_Instantiation                  |\n+               N_Package_Renaming_Declaration           |\n+               N_Private_Extension_Declaration          |\n+               N_Private_Type_Declaration               |\n+               N_Procedure_Instantiation                |\n+               N_Protected_Body                         |\n+               N_Protected_Body_Stub                    |\n+               N_Protected_Type_Declaration             |\n+               N_Single_Task_Declaration                |\n+               N_Subprogram_Body                        |\n+               N_Subprogram_Body_Stub                   |\n+               N_Subprogram_Declaration                 |\n+               N_Subprogram_Renaming_Declaration        |\n+               N_Subtype_Declaration                    |\n+               N_Task_Body                              |\n+               N_Task_Body_Stub                         |\n+               N_Task_Type_Declaration                  |\n+\n+               --  Freeze entity behaves like a declaration or statement\n+\n+               N_Freeze_Entity\n+            =>\n+               --  Do not search here if the item is not a list member\n+\n+               if not Is_List_Member (P) then\n+                  null;\n+\n+               --  Do not search if parent of P is an N_Component_Association\n+               --  node (i.e. we are in the context of an N_Aggregate or\n+               --  N_Extension_Aggregate node). In this case the node should\n+               --  have been added before the entire aggregate.\n+\n+               elsif Nkind (Parent (P)) = N_Component_Association then\n+                  null;\n+\n+               --  Do not search if the parent of P is either an N_Variant\n+               --  node or an N_Record_Definition node. In this case the node\n+               --  should have been added before the entire record.\n+\n+               elsif Nkind (Parent (P)) = N_Variant\n+                 or else Nkind (Parent (P)) = N_Record_Definition\n+               then\n+                  null;\n+\n+               --  Otherwise search it in the list containing this node\n+\n+               elsif Find_SCIL_Node (List_Containing (P)) then\n+                  return Found_Node;\n+               end if;\n+\n+            --  A special case, N_Raise_xxx_Error can act either as a\n+            --  statement or a subexpression. We diferentiate them by\n+            --  looking at the Etype. It is set to Standard_Void_Type\n+            --  in the statement case.\n+\n+            when\n+               N_Raise_xxx_Error =>\n+                  if Etype (P) = Standard_Void_Type then\n+                     if Is_List_Member (P)\n+                       and then Find_SCIL_Node (List_Containing (P))\n+                     then\n+                        return Found_Node;\n+                     end if;\n+\n+                  --  In the subexpression case, keep climbing\n+\n+                  else\n+                     null;\n+                  end if;\n+\n+            --  If a component association appears within a loop created for\n+            --  an array aggregate, check if the SCIL node was added to the\n+            --  the list of nodes attached to the association.\n+\n+            when\n+               N_Component_Association =>\n+                  if Nkind (Parent (P)) = N_Aggregate\n+                    and then Present (Loop_Actions (P))\n+                    and then Find_SCIL_Node (Loop_Actions (P))\n+                  then\n+                     return Found_Node;\n+                  end if;\n+\n+            --  Another special case, an attribute denoting a procedure call\n+\n+            when\n+               N_Attribute_Reference =>\n+                  if Is_Procedure_Attribute_Name (Attribute_Name (P))\n+                    and then Find_SCIL_Node (List_Containing (P))\n+                  then\n+                     return Found_Node;\n+\n+                  --  In the subexpression case, keep climbing\n+\n+                  else\n+                     null;\n+                  end if;\n+\n+            --  SCIL nodes do not have subtrees and hence they can never be\n+            --  found climbing tree\n+\n+            when\n+               N_SCIL_Dispatch_Table_Object_Init        |\n+               N_SCIL_Dispatch_Table_Tag_Init           |\n+               N_SCIL_Dispatching_Call                  |\n+               N_SCIL_Tag_Init\n+            =>\n+               pragma Assert (False);\n+               raise Program_Error;\n+\n+            --  For all other node types, keep climbing tree\n+\n+            when\n+               N_Abortable_Part                         |\n+               N_Accept_Alternative                     |\n+               N_Access_Definition                      |\n+               N_Access_Function_Definition             |\n+               N_Access_Procedure_Definition            |\n+               N_Access_To_Object_Definition            |\n+               N_Aggregate                              |\n+               N_Allocator                              |\n+               N_Case_Statement_Alternative             |\n+               N_Character_Literal                      |\n+               N_Compilation_Unit                       |\n+               N_Compilation_Unit_Aux                   |\n+               N_Component_Clause                       |\n+               N_Component_Declaration                  |\n+               N_Component_Definition                   |\n+               N_Component_List                         |\n+               N_Constrained_Array_Definition           |\n+               N_Decimal_Fixed_Point_Definition         |\n+               N_Defining_Character_Literal             |\n+               N_Defining_Identifier                    |\n+               N_Defining_Operator_Symbol               |\n+               N_Defining_Program_Unit_Name             |\n+               N_Delay_Alternative                      |\n+               N_Delta_Constraint                       |\n+               N_Derived_Type_Definition                |\n+               N_Designator                             |\n+               N_Digits_Constraint                      |\n+               N_Discriminant_Association               |\n+               N_Discriminant_Specification             |\n+               N_Empty                                  |\n+               N_Entry_Body_Formal_Part                 |\n+               N_Entry_Call_Alternative                 |\n+               N_Entry_Declaration                      |\n+               N_Entry_Index_Specification              |\n+               N_Enumeration_Type_Definition            |\n+               N_Error                                  |\n+               N_Exception_Handler                      |\n+               N_Expanded_Name                          |\n+               N_Explicit_Dereference                   |\n+               N_Extension_Aggregate                    |\n+               N_Floating_Point_Definition              |\n+               N_Formal_Decimal_Fixed_Point_Definition  |\n+               N_Formal_Derived_Type_Definition         |\n+               N_Formal_Discrete_Type_Definition        |\n+               N_Formal_Floating_Point_Definition       |\n+               N_Formal_Modular_Type_Definition         |\n+               N_Formal_Ordinary_Fixed_Point_Definition |\n+               N_Formal_Package_Declaration             |\n+               N_Formal_Private_Type_Definition         |\n+               N_Formal_Signed_Integer_Type_Definition  |\n+               N_Function_Call                          |\n+               N_Function_Specification                 |\n+               N_Generic_Association                    |\n+               N_Handled_Sequence_Of_Statements         |\n+               N_Identifier                             |\n+               N_In                                     |\n+               N_Index_Or_Discriminant_Constraint       |\n+               N_Indexed_Component                      |\n+               N_Integer_Literal                        |\n+               N_Itype_Reference                        |\n+               N_Label                                  |\n+               N_Loop_Parameter_Specification           |\n+               N_Mod_Clause                             |\n+               N_Modular_Type_Definition                |\n+               N_Not_In                                 |\n+               N_Null                                   |\n+               N_Op_Abs                                 |\n+               N_Op_Add                                 |\n+               N_Op_And                                 |\n+               N_Op_Concat                              |\n+               N_Op_Divide                              |\n+               N_Op_Eq                                  |\n+               N_Op_Expon                               |\n+               N_Op_Ge                                  |\n+               N_Op_Gt                                  |\n+               N_Op_Le                                  |\n+               N_Op_Lt                                  |\n+               N_Op_Minus                               |\n+               N_Op_Mod                                 |\n+               N_Op_Multiply                            |\n+               N_Op_Ne                                  |\n+               N_Op_Not                                 |\n+               N_Op_Or                                  |\n+               N_Op_Plus                                |\n+               N_Op_Rem                                 |\n+               N_Op_Rotate_Left                         |\n+               N_Op_Rotate_Right                        |\n+               N_Op_Shift_Left                          |\n+               N_Op_Shift_Right                         |\n+               N_Op_Shift_Right_Arithmetic              |\n+               N_Op_Subtract                            |\n+               N_Op_Xor                                 |\n+               N_Operator_Symbol                        |\n+               N_Ordinary_Fixed_Point_Definition        |\n+               N_Others_Choice                          |\n+               N_Package_Specification                  |\n+               N_Parameter_Association                  |\n+               N_Parameter_Specification                |\n+               N_Pop_Constraint_Error_Label             |\n+               N_Pop_Program_Error_Label                |\n+               N_Pop_Storage_Error_Label                |\n+               N_Pragma_Argument_Association            |\n+               N_Procedure_Specification                |\n+               N_Protected_Definition                   |\n+               N_Push_Constraint_Error_Label            |\n+               N_Push_Program_Error_Label               |\n+               N_Push_Storage_Error_Label               |\n+               N_Qualified_Expression                   |\n+               N_Range                                  |\n+               N_Range_Constraint                       |\n+               N_Real_Literal                           |\n+               N_Real_Range_Specification               |\n+               N_Record_Definition                      |\n+               N_Reference                              |\n+               N_Selected_Component                     |\n+               N_Signed_Integer_Type_Definition         |\n+               N_Single_Protected_Declaration           |\n+               N_Slice                                  |\n+               N_String_Literal                         |\n+               N_Subprogram_Info                        |\n+               N_Subtype_Indication                     |\n+               N_Subunit                                |\n+               N_Task_Definition                        |\n+               N_Terminate_Alternative                  |\n+               N_Triggering_Alternative                 |\n+               N_Type_Conversion                        |\n+               N_Unchecked_Expression                   |\n+               N_Unchecked_Type_Conversion              |\n+               N_Unconstrained_Array_Definition         |\n+               N_Unused_At_End                          |\n+               N_Unused_At_Start                        |\n+               N_Use_Package_Clause                     |\n+               N_Use_Type_Clause                        |\n+               N_Variant                                |\n+               N_Variant_Part                           |\n+               N_Validate_Unchecked_Conversion          |\n+               N_With_Clause\n+            =>\n+               null;\n+\n+         end case;\n+\n+         --  If we fall through above tests, keep climbing tree\n+\n+         if Nkind (Parent (P)) = N_Subunit then\n+\n+            --  This is the proper body corresponding to a stub. Insertion\n+            --  done at the point of the stub, which is in the declarative\n+            --  part of the parent unit.\n+\n+            P := Corresponding_Stub (Parent (P));\n+\n+         else\n+            P := Parent (P);\n+         end if;\n+      end loop;\n+\n+      --  SCIL node not found\n+\n+      return Empty;\n+   end Find_SCIL_Node;\n \n    ------------\n    -- Has_DT --\n@@ -4250,11 +4727,11 @@ package body Exp_Disp is\n             --  because it has a null dispatch table.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Object_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -4287,11 +4764,11 @@ package body Exp_Disp is\n             --  because it has a tag initialization.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Tag_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n \n          --  Generate:\n@@ -4327,11 +4804,11 @@ package body Exp_Disp is\n             --  because it contains a dispatch table.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Object_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -4364,11 +4841,11 @@ package body Exp_Disp is\n             --  because it has a tag initialization.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Tag_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -5143,11 +5620,11 @@ package body Exp_Disp is\n             --  because it has a null dispatch table.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Object_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -5460,11 +5937,11 @@ package body Exp_Disp is\n             --  because it contains a dispatch table.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Object_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -6098,6 +6575,7 @@ package body Exp_Disp is\n       Predef_Prims_Ptr : Node_Id;\n       Iface_DT         : Node_Id;\n       Iface_DT_Ptr     : Node_Id;\n+      New_Node         : Node_Id;\n       Suffix_Index     : Int;\n       Typ_Name         : Name_Id;\n       Typ_Comps        : Elist_Id;\n@@ -6161,11 +6639,11 @@ package body Exp_Disp is\n             --  because it has a tag initialization.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Tag_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -6207,11 +6685,11 @@ package body Exp_Disp is\n             --  because it has a tag initialization.\n \n             if Generate_SCIL then\n-               Insert_Before (Last (Result),\n-                 New_SCIL_Node\n-                   (SN_Kind      => Dispatch_Table_Tag_Init,\n-                    Related_Node => Last (Result),\n-                    Entity       => Typ));\n+               New_Node :=\n+                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n+               Set_SCIL_Related_Node (New_Node, Last (Result));\n+               Set_SCIL_Entity (New_Node, Typ);\n+               Insert_Before (Last (Result), New_Node);\n             end if;\n          end if;\n \n@@ -6436,29 +6914,6 @@ package body Exp_Disp is\n       end if;\n    end New_Value;\n \n-   -------------------\n-   -- New_SCIL_Node --\n-   -------------------\n-\n-   function New_SCIL_Node\n-     (SN_Kind      : SCIL_Node_Kind;\n-      Related_Node : Node_Id;\n-      Entity       : Entity_Id := Empty;\n-      Target_Prim  : Entity_Id := Empty) return Node_Id\n-   is\n-      New_N : constant Node_Id :=\n-                New_Node (N_Null_Statement, Sloc (Related_Node));\n-   begin\n-      Set_Is_SCIL_Node (New_N);\n-\n-      Set_SCIL_Nkind (New_N, UI_From_Int (SCIL_Node_Kind'Pos (SN_Kind)));\n-      Set_SCIL_Related_Node (New_N, Related_Node);\n-      Set_SCIL_Entity (New_N, Entity);\n-      Set_SCIL_Target_Prim (New_N, Target_Prim);\n-\n-      return New_N;\n-   end New_SCIL_Node;\n-\n    -----------------------------------\n    -- Original_View_In_Visible_Part --\n    -----------------------------------"}, {"sha": "4c7c9e8a57a341c7e4dd8eb1661a810bc3e088b0", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 7, "deletions": 39, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -30,34 +30,6 @@ with Types; use Types;\n \n package Exp_Disp is\n \n-   -------------------------------\n-   -- SCIL Node Type Definition --\n-   -------------------------------\n-\n-   --  SCIL nodes are a special kind of nodes added to the tree when the\n-   --  CodePeer mode is active. They are stored in the tree as special\n-   --  N_Null_Statement nodes that have extra attributes. The information\n-   --  available through these extra attributes relies on the kind of SCIL\n-   --  node. The SCIL node kind is stored in the Scil_Nkind attribute of\n-   --  the N_Null_Statement node, and indicates the type of the SCIL node.\n-\n-   type SCIL_Node_Kind is\n-     (Unused,\n-      --  What is this for ???\n-\n-      IP_Tag_Init,\n-      --  SCIL node for tag component initialization\n-\n-      Dispatching_Call,\n-      --  SCIL node for dispatching call. Used by the CodePeer backend to\n-      --  locate nodes associated with dispatching calls.\n-\n-      Dispatch_Table_Object_Init,\n-      --  SCIL node for object declaration containing a dispatch table\n-\n-      Dispatch_Table_Tag_Init);\n-      --  SCIL node for tag initialization\n-\n    -------------------------------------\n    -- Predefined primitive operations --\n    -------------------------------------\n@@ -198,6 +170,10 @@ package Exp_Disp is\n    --    Exp_Disp.Default_Prim_Op_Position - indirect use\n    --    Exp_Disp.Set_All_DT_Position      - direct   use\n \n+   procedure Adjust_SCIL_Node (Old_Node : Node_Id; New_Node : Node_Id);\n+   --  Searches for a SCIL dispatching node associated with Old_Node. If found\n+   --  then update its SCIL_Related_Node field to reference New_Node.\n+\n    procedure Apply_Tag_Checks (Call_Node : Node_Id);\n    --  Generate checks required on dispatching calls\n \n@@ -243,8 +219,9 @@ package Exp_Disp is\n    --  Otherwise they are set to the defining identifier and the subprogram\n    --  body of the generated thunk.\n \n-   function Get_SCIL_Node_Kind (Node : Node_Id) return SCIL_Node_Kind;\n-   --  Returns the kind of an SCIL node\n+   function Find_SCIL_Node (Node : Node_Id) return Node_Id;\n+   --  Searches for a SCIL dispatching node associated with Node. If not found\n+   --  then return Empty.\n \n    function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation\n@@ -340,15 +317,6 @@ package Exp_Disp is\n    --  tagged types this routine imports the forward declaration of the tag\n    --  entity, that will be declared and exported by Make_DT.\n \n-   function New_SCIL_Node\n-     (SN_Kind      : SCIL_Node_Kind;\n-      Related_Node : Node_Id;\n-      Entity       : Entity_Id := Empty;\n-      Target_Prim  : Entity_Id := Empty) return Node_Id;\n-   --  Creates a new Scil node. Related_Node is the AST node associated with\n-   --  this Scil node. Entity is the tagged type associated with the Scil node.\n-   --  For Dispatching_Call nodes, Target_Prim is the dispatching primitive.\n-\n    function Register_Primitive\n      (Loc     : Source_Ptr;\n       Prim    : Entity_Id) return List_Id;"}, {"sha": "d77b1db7a3b775f73bd6c9542fc975801716a5a1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -32,6 +32,7 @@ with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n+with Exp_Disp; use Exp_Disp;\n with Inline;   use Inline;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n@@ -2755,6 +2756,10 @@ package body Exp_Util is\n                N_Real_Range_Specification               |\n                N_Record_Definition                      |\n                N_Reference                              |\n+               N_SCIL_Dispatch_Table_Object_Init        |\n+               N_SCIL_Dispatch_Table_Tag_Init           |\n+               N_SCIL_Dispatching_Call                  |\n+               N_SCIL_Tag_Init                          |\n                N_Selected_Component                     |\n                N_Signed_Integer_Type_Definition         |\n                N_Single_Protected_Declaration           |\n@@ -4634,6 +4639,15 @@ package body Exp_Util is\n              Constant_Present    => True,\n              Expression          => Relocate_Node (Exp));\n \n+         --  Check if the previous node relocation requires readjustment of\n+         --  some SCIL Dispatching node.\n+\n+         if Generate_SCIL\n+           and then Nkind (Exp) = N_Function_Call\n+         then\n+            Adjust_SCIL_Node (Exp, Expression (E));\n+         end if;\n+\n          Set_Assignment_OK (E);\n          Insert_Action (Exp, E);\n \n@@ -4794,6 +4808,16 @@ package body Exp_Util is\n                    Defining_Identifier => Obj,\n                    Object_Definition   => New_Occurrence_Of (Exp_Type, Loc),\n                    Expression          => Relocate_Node (Exp));\n+\n+               --  Check if the previous node relocation requires readjustment\n+               --  of some SCIL Dispatching node.\n+\n+               if Generate_SCIL\n+                 and then Nkind (Exp) = N_Function_Call\n+               then\n+                  Adjust_SCIL_Node (Exp, Expression (Decl));\n+               end if;\n+\n                Insert_Action (Exp, Decl);\n                Set_Etype (Obj, Exp_Type);\n                Rewrite (Exp, New_Occurrence_Of (Obj, Loc));\n@@ -4853,6 +4877,15 @@ package body Exp_Util is\n              Defining_Identifier => Def_Id,\n              Object_Definition   => New_Reference_To (Ref_Type, Loc),\n              Expression          => New_Exp));\n+\n+         --  Check if the previous node relocation requires readjustment\n+         --  of some SCIL Dispatching node.\n+\n+         if Generate_SCIL\n+           and then Nkind (Exp) = N_Function_Call\n+         then\n+            Adjust_SCIL_Node (Exp, Prefix (New_Exp));\n+         end if;\n       end if;\n \n       --  Preserve the Assignment_OK flag in all copies, since at least"}, {"sha": "00eb5ca443ffcc59499ce6f3d07cc1fd61c14620", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,6 +63,40 @@ with Tbuild;   use Tbuild;\n with Types;    use Types;\n \n procedure Frontend is\n+\n+   --  Comment: I think SCIL processing is gettings scattered too much, this\n+   --  is a good case, why should the top level frontend driver be doing stuff\n+   --  at this level, seems wrong to me. I think we should introduce a new\n+   --  unit Sem_SCIL, and move a lot of this SCIL stuff there. ???\n+\n+   function Check_SCIL_Node (N : Node_Id) return Traverse_Result;\n+   --  Process a single node during the tree traversal, verifying that field\n+   --  SCIL_Related_Node of SCIL dispatching call nodes reference subprogram\n+   --  calls.\n+\n+   procedure Check_SCIL_Nodes is new Traverse_Proc (Check_SCIL_Node);\n+   --  The traversal procedure itself\n+\n+   ---------------------\n+   -- Check_SCIL_Node --\n+   ---------------------\n+\n+   function Check_SCIL_Node (N : Node_Id) return Traverse_Result is\n+   begin\n+      if Nkind (N) = N_SCIL_Dispatching_Call then\n+         if not Nkind_In (SCIL_Related_Node (N), N_Function_Call,\n+                                                 N_Procedure_Call_Statement)\n+         then\n+            pragma Assert (False);\n+            raise Program_Error;\n+         end if;\n+\n+         return Skip;\n+      else\n+         return OK;\n+      end if;\n+   end Check_SCIL_Node;\n+\n    Config_Pragmas : List_Id;\n    --  Gather configuration pragmas\n \n@@ -366,6 +400,13 @@ begin\n       Exp_Dbug.Qualify_All_Entity_Names;\n    end if;\n \n+   --  SCIL backend requirement. Check that SCIL nodes associated with\n+   --  dispatching calls reference subprogram calls.\n+\n+   if Generate_SCIL then\n+      Check_SCIL_Nodes (Cunit (Main_Unit));\n+   end if;\n+\n    --  Dump the source now. Note that we do this as soon as the analysis\n    --  of the tree is complete, because it is not just a dump in the case\n    --  of -gnatD, where it rewrites all source locations in the tree."}, {"sha": "0dcc5937e1a76fb9c52bdbc4b8fff6efbc6a929e", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -3494,7 +3494,11 @@ gnat_to_gnu (Node_Id gnat_node)\n      If we are in the elaboration procedure, check if we are violating a\n      No_Elaboration_Code restriction by having a statement there.  */\n   if ((IN (Nkind (gnat_node), N_Statement_Other_Than_Procedure_Call)\n-       && Nkind (gnat_node) != N_Null_Statement)\n+       && Nkind (gnat_node) != N_Null_Statement\n+       && Nkind (gnat_node) != N_SCIL_Dispatch_Table_Object_Init\n+       && Nkind (gnat_node) != N_SCIL_Dispatch_Table_Tag_Init\n+       && Nkind (gnat_node) != N_SCIL_Dispatching_Call\n+       && Nkind (gnat_node) != N_SCIL_Tag_Init)\n       || Nkind (gnat_node) == N_Procedure_Call_Statement\n       || Nkind (gnat_node) == N_Label\n       || Nkind (gnat_node) == N_Implicit_Label_Declaration\n@@ -5290,6 +5294,15 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = alloc_stmt_list ();\n       break;\n \n+    /* SCIL nodes require no processing by this backend */\n+\n+    case N_SCIL_Dispatch_Table_Object_Init:\n+    case N_SCIL_Dispatch_Table_Tag_Init:\n+    case N_SCIL_Dispatching_Call:\n+    case N_SCIL_Tag_Init:\n+      gnu_result = alloc_stmt_list ();\n+      break;\n+\n     case N_Raise_Statement:\n     case N_Function_Specification:\n     case N_Procedure_Specification:"}, {"sha": "ca4fe86c8f6a59d7bc40ba5a2ca4c4ea048f7903", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -112,9 +112,12 @@ procedure Gnat1drv is\n \n    procedure Adjust_Global_Switches is\n    begin\n-      --  Debug flag -gnatd.I is a synonym of Generate_SCIL\n+      --  Debug flag -gnatd.I is a synonym for Generate_SCIL and requires code\n+      --  generation.\n \n-      if Debug_Flag_Dot_II then\n+      if Debug_Flag_Dot_II\n+        and then Operating_Mode = Generate_Code\n+      then\n          Generate_SCIL := True;\n       end if;\n "}, {"sha": "8e2acdda7cae6ffba0ef06c97cbb117856bf8016", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -603,6 +603,18 @@ package body Sem is\n          when N_Push_Pop_xxx_Label =>\n             null;\n \n+         --  SCIL nodes don't need analysis because they are decorated when\n+         --  they are built. They are added to the tree by Insert_Actions and\n+         --  the call to analyze them is generated when the full list is\n+         --  analyzed.\n+\n+         when\n+           N_SCIL_Dispatch_Table_Object_Init        |\n+           N_SCIL_Dispatch_Table_Tag_Init           |\n+           N_SCIL_Dispatching_Call                  |\n+           N_SCIL_Tag_Init                          =>\n+            null;\n+\n          --  For the remaining node types, we generate compiler abort, because\n          --  these nodes are always analyzed within the Sem_Chn routines and\n          --  there should never be a case of making a call to the main Analyze"}, {"sha": "20e254e8be6c993636173a77aca3e606ff5c847a", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -33,6 +33,7 @@\n with Atree;  use Atree;\n with Einfo;  use Einfo;\n with Namet;  use Namet;\n+with Nlists; use Nlists;\n with Sinfo;  use Sinfo;\n with Snames; use Snames;\n with Stand;  use Stand;\n@@ -235,6 +236,22 @@ package body Sem_Aux is\n       return Ent;\n    end First_Discriminant;\n \n+   -------------------------\n+   -- First_Non_SCIL_Node --\n+   -------------------------\n+\n+   function First_Non_SCIL_Node (L : List_Id) return Node_Id is\n+      N : Node_Id;\n+\n+   begin\n+      N := First (L);\n+      while Nkind (N) in N_SCIL_Node loop\n+         Next (N);\n+      end loop;\n+\n+      return N;\n+   end First_Non_SCIL_Node;\n+\n    -------------------------------\n    -- First_Stored_Discriminant --\n    -------------------------------\n@@ -736,6 +753,22 @@ package body Sem_Aux is\n       end if;\n    end Nearest_Dynamic_Scope;\n \n+   ------------------------\n+   -- Next_Non_SCIL_Node --\n+   ------------------------\n+\n+   function Next_Non_SCIL_Node (N : Node_Id) return Node_Id is\n+      Aux_N : Node_Id;\n+\n+   begin\n+      Aux_N := Next (N);\n+      while Nkind (Aux_N) in N_SCIL_Node loop\n+         Next (Aux_N);\n+      end loop;\n+\n+      return Aux_N;\n+   end Next_Non_SCIL_Node;\n+\n    ------------------------\n    -- Next_Tag_Component --\n    ------------------------"}, {"sha": "6756968fc9c8610d83b513a68f7745fc605f86f7", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -138,6 +138,9 @@ package Sem_Aux is\n    --  discriminants from Gigi's standpoint, i.e. those that will be stored in\n    --  actual objects of the type.\n \n+   function First_Non_SCIL_Node (L : List_Id) return Node_Id;\n+   --  Returns the first non-SCIL node of list L\n+\n    function First_Subtype (Typ : Entity_Id) return Entity_Id;\n    --  Applies to all types and subtypes. For types, yields the first subtype\n    --  of the type. For subtypes, yields the first subtype of the base type of\n@@ -185,6 +188,10 @@ package Sem_Aux is\n    --  a dynamic scope, then it is returned. Otherwise the result is the same\n    --  as that returned by Enclosing_Dynamic_Scope.\n \n+   function Next_Non_SCIL_Node (N : Node_Id) return Node_Id;\n+   --  N must be a member of a list. Returns the next non SCIL node in the list\n+   --  containing N, or Empty if this is the last non SCIL node in the list.\n+\n    function Next_Tag_Component (Tag : Entity_Id) return Entity_Id;\n    --  Tag must be an entity representing a _Tag field of a tagged record.\n    --  The result returned is the next _Tag field in this record, or Empty"}, {"sha": "7ec6ab38083ce3ba349ec093d42bea49388dcb76", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -28,6 +28,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Itypes;   use Itypes;\n@@ -3875,6 +3876,15 @@ package body Sem_Ch4 is\n       T    : Entity_Id;\n \n    begin\n+      --  Check if the expression is a function call for which we need to\n+      --  adjust a SCIL dispatching node.\n+\n+      if Generate_SCIL\n+        and then Nkind (Expr) = N_Function_Call\n+      then\n+         Adjust_SCIL_Node (N, Expr);\n+      end if;\n+\n       --  If Conversion_OK is set, then the Etype is already set, and the\n       --  only processing required is to analyze the expression. This is\n       --  used to construct certain \"illegal\" conversions which are not"}, {"sha": "3e0919f7dd786841c15352249b011d19a7538e7a", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -28,6 +28,7 @@ with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Expander; use Expander;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n@@ -1570,6 +1571,15 @@ package body Sem_Ch5 is\n                 Name        => New_Occurrence_Of (Id, Loc),\n                 Expression  => Relocate_Node (Original_Bound));\n \n+            --  If the relocated node is a function call then check if some\n+            --  SCIL node references it and needs readjustment.\n+\n+            if Generate_SCIL\n+              and then Nkind (Original_Bound) = N_Function_Call\n+            then\n+               Adjust_SCIL_Node (Original_Bound, Expression (Assign));\n+            end if;\n+\n             Insert_Before (Parent (N), Assign);\n             Analyze (Assign);\n "}, {"sha": "6497be32cb09866526555f654d71b7709788852e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -5229,6 +5229,16 @@ package body Sem_Util is\n \n    begin\n       Save_Interps (N, New_Prefix);\n+\n+      --  Check if the node relocation requires readjustment of some SCIL\n+      --  dispatching node.\n+\n+      if Generate_SCIL\n+        and then Nkind (N) = N_Function_Call\n+      then\n+         Adjust_SCIL_Node (N, New_Prefix);\n+      end if;\n+\n       Rewrite (N, Make_Explicit_Dereference (Sloc (N), Prefix => New_Prefix));\n \n       Set_Etype (N, Designated_Type (Etype (New_Prefix)));"}, {"sha": "816adcf5afcf4d870bf21028aedf0c56a5820e41", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -1703,14 +1703,6 @@ package body Sinfo is\n       return Flag7 (N);\n    end Is_Protected_Subprogram_Body;\n \n-   function Is_SCIL_Node\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      return Flag4 (N);\n-   end Is_SCIL_Node;\n-\n    function Is_Static_Coextension\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2541,35 +2533,41 @@ package body Sinfo is\n       return Flag18 (N);\n    end Rounded_Result;\n \n-   function SCIL_Entity\n+   function SCIL_Controlling_Tag\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      return Node4 (N);\n-   end SCIL_Entity;\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call);\n+      return Node5 (N);\n+   end SCIL_Controlling_Tag;\n \n-   function SCIL_Nkind\n-      (N : Node_Id) return Uint is\n+   function SCIL_Entity\n+      (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      return Uint3 (N);\n-   end SCIL_Nkind;\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call\n+        or else NT (N).Nkind = N_SCIL_Tag_Init);\n+      return Node4 (N);\n+   end SCIL_Entity;\n \n    function SCIL_Related_Node\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call\n+        or else NT (N).Nkind = N_SCIL_Tag_Init);\n       return Node1 (N);\n    end SCIL_Related_Node;\n \n    function SCIL_Target_Prim\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call);\n       return Node2 (N);\n    end SCIL_Target_Prim;\n \n@@ -4557,14 +4555,6 @@ package body Sinfo is\n       Set_Flag7 (N, Val);\n    end Set_Is_Protected_Subprogram_Body;\n \n-   procedure Set_Is_SCIL_Node\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      Set_Flag4 (N, Val);\n-   end Set_Is_SCIL_Node;\n-\n    procedure Set_Is_Static_Coextension\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5395,36 +5385,42 @@ package body Sinfo is\n       Set_Flag18 (N, Val);\n    end Set_Rounded_Result;\n \n-   procedure Set_SCIL_Entity\n+   procedure Set_SCIL_Controlling_Tag\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      Set_Node4 (N, Val); -- semantic field, no parent set\n-   end Set_SCIL_Entity;\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call);\n+      Set_Node5 (N, Val); -- semantic field, no parent set\n+   end Set_SCIL_Controlling_Tag;\n \n-   procedure Set_SCIL_Nkind\n-      (N : Node_Id; Val : Uint) is\n+   procedure Set_SCIL_Entity\n+      (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      Set_Uint3 (N, Val);\n-   end Set_SCIL_Nkind;\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call\n+        or else NT (N).Nkind = N_SCIL_Tag_Init);\n+      Set_Node4 (N, Val); -- semantic field, no parent set\n+   end Set_SCIL_Entity;\n \n    procedure Set_SCIL_Related_Node\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      Set_Node1 (N, Val);\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call\n+        or else NT (N).Nkind = N_SCIL_Tag_Init);\n+      Set_Node1 (N, Val); -- semantic field, no parent set\n    end Set_SCIL_Related_Node;\n \n    procedure Set_SCIL_Target_Prim\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Null_Statement);\n-      Set_Node2 (N, Val);\n+        or else NT (N).Nkind = N_SCIL_Dispatching_Call);\n+      Set_Node2 (N, Val); -- semantic field, no parent set\n    end Set_SCIL_Target_Prim;\n \n    procedure Set_Scope"}, {"sha": "2b51273a93930ea8863c17fc3af20bb52fac512d", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 97, "deletions": 49, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -1251,15 +1251,6 @@ package Sinfo is\n    --    handler to make sure that the associated protected object is unlocked\n    --    when the subprogram completes.\n \n-   --  Is_SCIL_Node (Flag4-Sem)\n-   --    Present in N_Null_Statement nodes. Set to indicate that it is a SCIL\n-   --    node. SCIL nodes are special nodes that help the CodePeer backend\n-   --    locating nodes that require special processing. In order to minimize\n-   --    the impact on the compiler and ASIS, and also to maximize flexibility\n-   --    when adding SCIL nodes to the tree, instead of adding new kind of\n-   --    nodes, SCIL nodes are added to the tree as N_Null_Statement nodes on\n-   --    which this attribute is set.\n-\n    --  Is_Static_Coextension (Flag14-Sem)\n    --    Present in N_Allocator nodes. Set if the allocator is a coextension\n    --    of an object allocated on the stack rather than the heap.\n@@ -1599,21 +1590,20 @@ package Sinfo is\n    --    and multiplication operations.\n \n    --  SCIL_Entity (Node4-Sem)\n-   --    Present in N_Null_Statement nodes that are SCIL nodes. Used to\n-   --    reference the tagged type associated with the SCIL node.\n-\n-   --  SCIL_Nkind (Uint3-Sem)\n-   --    Present in N_Null_Statement nodes that are SCIL nodes. Used to\n-   --    indicate the kind of SCIL node (see SCIL node kinds in exp_disp.ads).\n+   --    Present in SCIL nodes. Used to reference the tagged type associated\n+   --    with the SCIL node.\n \n    --  SCIL_Related_Node (Node1-Sem)\n-   --    Present in N_Null_Statement nodes that are SCIL nodes. Used to\n-   --    reference a tree node that requires special processing in the\n-   --    CodePeer backend.\n+   --    Present in SCIL nodes. Used to reference a tree node that requires\n+   --    special processing in the CodePeer backend.\n+\n+   --  SCIL_Controlling_Tag (Node5-Sem)\n+   --    Present in N_SCIL_Dispatching_Call nodes. Used to reference the\n+   --    controlling tag of a dispatching call.\n \n    --  SCIL_Target_Prim (Node2-Sem)\n-   --    Present in N_Null_Statement nodes. Used to reference the tagged type\n-   --    primitive associated with the SCIL node.\n+   --    Present in N_SCIL_Dispatching_Call nodes. Used to reference the tagged\n+   --    type primitive associated with the SCIL node.\n \n    --  Scope (Node3-Sem)\n    --    Present in defining identifiers, defining character literals and\n@@ -3862,11 +3852,6 @@ package Sinfo is\n \n       --  N_Null_Statement\n       --  Sloc points to NULL\n-      --  Is_SCIL_Node (Flag4-Sem)\n-      --  SCIL_Nkind (Uint3-Sem)\n-      --  SCIL_Related_Node (Node1-Sem)\n-      --  SCIL_Entity (Node4-Sem)\n-      --  SCIL_Target_Prim (Node2-Sem)\n \n       ----------------\n       -- 5.1  Label --\n@@ -6861,6 +6846,42 @@ package Sinfo is\n       --  Note: in the case where a debug source file is generated, the Sloc\n       --  for this node points to the quote in the Sprint file output.\n \n+      -----------------\n+      --  SCIL Nodes --\n+      -----------------\n+\n+      --  SCIL nodes are special nodes added to the tree when the CodePeer mode\n+      --  is active. They help CodePeer backend to locate nodes that require\n+      --  special processing.\n+\n+      --  Where is the detailed description of what these nodes are for??? The\n+      --  above is not sufficient. The description should be here, or perhaps\n+      --  it could be in a new Sem_SCIL unit, with a pointer from here. But\n+      --  right now I am afraid this documentation is missing and the purpose\n+      --  of these nodes remains secret???\n+\n+      --  N_SCIL_Dispatch_Table_Object_Init\n+      --  Sloc references a declaration node containing a dispatch table\n+      --  SCIL_Related_Node (Node1-Sem)\n+      --  SCIL_Entity (Node4-Sem)\n+\n+      --  N_SCIL_Dispatch_Table_Tag_Init\n+      --  Sloc references a node for a tag initialization\n+      --  SCIL_Related_Node (Node1-Sem)\n+      --  SCIL_Entity (Node4-Sem)\n+\n+      --  N_SCIL_Dispatching_Call\n+      --  Sloc references the node of a dispatching call\n+      --  SCIL_Related_Node (Node1-Sem)\n+      --  SCIL_Target_Prim (Node2-Sem)\n+      --  SCIL_Entity (Node4-Sem)\n+      --  SCIL_Controlling_Tag (Node5-Sem)\n+\n+      --  N_SCIL_Tag_Init\n+      --  Sloc references the node of a tag component initialization\n+      --  SCIL_Related_Node (Node1-Sem)\n+      --  SCIL_Entity (Node4-Sem)\n+\n       ---------------------\n       -- Subprogram_Info --\n       ---------------------\n@@ -7298,6 +7319,13 @@ package Sinfo is\n       N_Pop_Program_Error_Label,\n       N_Pop_Storage_Error_Label,\n \n+      --  SCIL nodes\n+\n+      N_SCIL_Dispatch_Table_Object_Init,\n+      N_SCIL_Dispatch_Table_Tag_Init,\n+      N_SCIL_Dispatching_Call,\n+      N_SCIL_Tag_Init,\n+\n       --  Other nodes (not part of any subtype class)\n \n       N_Abortable_Part,\n@@ -7430,12 +7458,6 @@ package Sinfo is\n      N_Attribute_Reference;\n    --  Nodes that have Entity fields\n    --  Warning: DOES NOT INCLUDE N_Freeze_Entity!\n-   --\n-   --  Warning: DOES NOT INCLUDE N_Null_Assignment because it not always\n-   --  available. The Entity attribute is only available in SCIL nodes\n-   --  (that is, N_Null_Assignment nodes that have Is_Scil_Node set to true).\n-   --  Processing such nodes never requires testing if the node is in\n-   --  N_Has_Entity node kind.\n \n    subtype N_Has_Etype is Node_Kind range\n      N_Error ..\n@@ -7511,8 +7533,12 @@ package Sinfo is\n      N_Attribute_Definition_Clause;\n \n    subtype N_Short_Circuit is Node_Kind range\n-      N_And_Then ..\n-      N_Or_Else;\n+     N_And_Then ..\n+     N_Or_Else;\n+\n+   subtype N_SCIL_Node is Node_Kind range\n+     N_SCIL_Dispatch_Table_Object_Init ..\n+     N_SCIL_Tag_Init;\n \n    subtype N_Statement_Other_Than_Procedure_Call is Node_Kind range\n      N_Abort_Statement ..\n@@ -8088,9 +8114,6 @@ package Sinfo is\n    function Is_Protected_Subprogram_Body\n      (N : Node_Id) return Boolean;    -- Flag7\n \n-   function Is_SCIL_Node\n-     (N : Node_Id) return Boolean;    -- Flag4\n-\n    function Is_Static_Coextension\n      (N : Node_Id) return Boolean;    -- Flag14\n \n@@ -8346,12 +8369,12 @@ package Sinfo is\n    function Rounded_Result\n      (N : Node_Id) return Boolean;    -- Flag18\n \n+   function SCIL_Controlling_Tag\n+     (N : Node_Id) return Node_Id;    -- Node5\n+\n    function SCIL_Entity\n      (N : Node_Id) return Node_Id;    -- Node4\n \n-   function SCIL_Nkind\n-      (N : Node_Id) return Uint;      -- Uint3\n-\n    function SCIL_Related_Node\n      (N : Node_Id) return Node_Id;    -- Node1\n \n@@ -9000,9 +9023,6 @@ package Sinfo is\n    procedure Set_Is_Protected_Subprogram_Body\n      (N : Node_Id; Val : Boolean := True);    -- Flag7\n \n-   procedure Set_Is_SCIL_Node\n-     (N : Node_Id; Val : Boolean := True);    -- Flag4\n-\n    procedure Set_Is_Static_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag14\n \n@@ -9258,12 +9278,12 @@ package Sinfo is\n    procedure Set_Rounded_Result\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n+   procedure Set_SCIL_Controlling_Tag\n+     (N : Node_Id; Val : Node_Id);            -- Node5\n+\n    procedure Set_SCIL_Entity\n      (N : Node_Id; Val : Node_Id);            -- Node4\n \n-   procedure Set_SCIL_Nkind\n-      (N : Node_Id; Val : Uint);              -- Uint3\n-\n    procedure Set_SCIL_Related_Node\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n@@ -10998,6 +11018,36 @@ package Sinfo is\n \n    --  End of inserted output from makeisf program\n \n+   --  Entries for SCIL nodes\n+\n+     N_SCIL_Dispatch_Table_Object_Init =>\n+       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n+        2 => False,   --  unused\n+        3 => False,   --  unused\n+        4 => False,   --  SCIL_Entity (Node4-Sem)\n+        5 => False),  --  unused\n+\n+     N_SCIL_Dispatch_Table_Tag_Init =>\n+       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n+        2 => False,   --  unused\n+        3 => False,   --  unused\n+        4 => False,   --  SCIL_Entity (Node4-Sem)\n+        5 => False),  --  unused\n+\n+     N_SCIL_Dispatching_Call =>\n+       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n+        2 => False,   --  SCIL_Target_Prim (Node2-Sem)\n+        3 => False,   --  unused\n+        4 => False,   --  SCIL_Entity (Node4-Sem)\n+        5 => False),  --  SCIL_Controlling_Tag (Node5-Sem)\n+\n+     N_SCIL_Tag_Init =>\n+       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n+        2 => False,   --  unused\n+        3 => False,   --  unused\n+        4 => False,   --  SCIL_Entity (Node4-Sem)\n+        5 => False),  --  unused\n+\n    --  Entries for Empty, Error and Unused. Even thought these have a Chars\n    --  field for debugging purposes, they are not really syntactic fields, so\n    --  we mark all fields as unused.\n@@ -11210,7 +11260,6 @@ package Sinfo is\n    pragma Inline (Is_Overloaded);\n    pragma Inline (Is_Power_Of_2_For_Shift);\n    pragma Inline (Is_Protected_Subprogram_Body);\n-   pragma Inline (Is_SCIL_Node);\n    pragma Inline (Is_Static_Coextension);\n    pragma Inline (Is_Static_Expression);\n    pragma Inline (Is_Subprogram_Descriptor);\n@@ -11296,8 +11345,8 @@ package Sinfo is\n    pragma Inline (Reverse_Present);\n    pragma Inline (Right_Opnd);\n    pragma Inline (Rounded_Result);\n+   pragma Inline (SCIL_Controlling_Tag);\n    pragma Inline (SCIL_Entity);\n-   pragma Inline (SCIL_Nkind);\n    pragma Inline (SCIL_Related_Node);\n    pragma Inline (SCIL_Target_Prim);\n    pragma Inline (Scope);\n@@ -11510,7 +11559,6 @@ package Sinfo is\n    pragma Inline (Set_Is_Overloaded);\n    pragma Inline (Set_Is_Power_Of_2_For_Shift);\n    pragma Inline (Set_Is_Protected_Subprogram_Body);\n-   pragma Inline (Set_Is_SCIL_Node);\n    pragma Inline (Set_Has_Self_Reference);\n    pragma Inline (Set_Is_Static_Coextension);\n    pragma Inline (Set_Is_Static_Expression);\n@@ -11596,8 +11644,8 @@ package Sinfo is\n    pragma Inline (Set_Reverse_Present);\n    pragma Inline (Set_Right_Opnd);\n    pragma Inline (Set_Rounded_Result);\n+   pragma Inline (Set_SCIL_Controlling_Tag);\n    pragma Inline (Set_SCIL_Entity);\n-   pragma Inline (Set_SCIL_Nkind);\n    pragma Inline (Set_SCIL_Related_Node);\n    pragma Inline (Set_SCIL_Target_Prim);\n    pragma Inline (Set_Scope);"}, {"sha": "e73d204d758633a34b001319d11e5d180b6259c0", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327503f14780f4c9e8ee3ea4675abd0935761c79/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=327503f14780f4c9e8ee3ea4675abd0935761c79", "patch": "@@ -2637,6 +2637,23 @@ package body Sprint is\n \n             Write_Char (';');\n \n+         --  Don't we want to print more detail???\n+\n+         --  Doc of this extended syntax belongs in sinfo.ads and/or\n+         --  sprint.ads ???\n+\n+         when N_SCIL_Dispatch_Table_Object_Init =>\n+            Write_Indent_Str (\"[N_SCIL_Dispatch_Table_Object_Init]\");\n+\n+         when N_SCIL_Dispatch_Table_Tag_Init =>\n+            Write_Indent_Str (\"[N_SCIL_Dispatch_Table_Tag_Init]\");\n+\n+         when N_SCIL_Dispatching_Call =>\n+            Write_Indent_Str (\"[N_SCIL_Dispatching_Node]\");\n+\n+         when N_SCIL_Tag_Init =>\n+            Write_Indent_Str (\"[N_SCIL_Dispatch_Table_Tag_Init]\");\n+\n          when N_Simple_Return_Statement =>\n             if Present (Expression (Node)) then\n                Write_Indent_Str_Sloc (\"return \");"}]}