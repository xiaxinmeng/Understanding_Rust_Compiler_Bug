{"sha": "c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVmNjUxYmYzZmYxZWMyN2MyNWViZGNkMTRkNTViYzEyNWMwMjBhNA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2000-11-18T02:00:06Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2000-11-18T02:00:06Z"}, "message": "backport: *.java: Reformat all to unofficial standard coding style.\n\n\tMerge with Classpath (changes by Bryce McKinlay)\n\t* java/util/jar/*.java: Reformat all to unofficial standard coding\n\tstyle. No changes of substance.\n\nFrom-SVN: r37538", "tree": {"sha": "1cdd2c04005f269ae818823da99af56069055ae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cdd2c04005f269ae818823da99af56069055ae4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/comments", "author": null, "committer": null, "parents": [{"sha": "c003f37865e09e796e26de62b6eb9c1dfa03e632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c003f37865e09e796e26de62b6eb9c1dfa03e632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c003f37865e09e796e26de62b6eb9c1dfa03e632"}], "stats": {"total": 2784, "additions": 1461, "deletions": 1323}, "files": [{"sha": "ce80cd0faa71cdb6d0d395e06889abe5c3fdeee9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -1,3 +1,9 @@\n+2000-11-17  Mark Wielaar <mark@klomp.org>\n+\n+\tMerge with Classpath (changes by Bryce McKinlay)\n+\t* java/util/jar/*.java: Reformat all to unofficial standard coding\n+\tstyle. No changes of substance.\n+\n 2000-11-17  Mark Wielaard  <mark@klomp.org>\n \n \t* java/util/zip/*.java: Javadoc updates."}, {"sha": "b18b5d8ca8a91e0c3581d0e8f5f133f3f9a2ae90", "filename": "libjava/java/util/jar/Attributes.java", "status": "modified", "additions": 491, "deletions": 464, "changes": 955, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -54,533 +54,560 @@\n  * @see java.util.jar.Attributes.Name\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n-public class Attributes implements Cloneable, Map {\n+public class Attributes implements Cloneable, Map\n+{\n+\n+  // Fields\n+\n+  /**\n+   * The map that holds all the attribute name/value pairs. In this\n+   * implementation it is actually a Hashtable, but that can be different in\n+   * other implementations.\n+   */\n+  protected Map map;\n+\n+  // Inner class\n+\n+  /**\n+   * Represents a name of a Manifest Attribute. Defines a couple of well\n+   * know names for the general main attributes, stand alone application\n+   * attributes, applet attributes, extension identification attributes,\n+   * package versioning and sealing attributes, file contents attributes,\n+   * bean objects attribute and signing attributes. See the \n+   * <p>\n+   * The characters of a Name must obey the following restrictions:\n+   * <ul>\n+   * <li> Must contain at least one character\n+   * <li> The first character must be alphanumeric (a-z, A-Z, 0-9)\n+   * <li> All other characters must be alphanumeric, a '-' or a '_'\n+   * </ul>\n+   * <p>\n+   * When comparing Names (with <code>equals</code>) all characters are\n+   * converted to lowercase. But you can get the original case sensitive\n+   * string with the <code>toString()</code> method.\n+   *\n+   * @since 1.2\n+   * @author Mark Wielaard (mark@klomp.org)\n+   */\n+  public static class Name\n+  {\n \n     // Fields\n \n+    // General Main Attributes\n+\n     /**\n-     * The map that holds all the attribute name/value pairs. In this\n-     * implementation it is actually a Hashtable, but that can be different in\n-     * other implementations.\n+     * General main attribute -\n+     * the version of this Manifest file.\n      */\n-    protected Map map;\n-\n-    // Inner class\n-\n+    public static final Name MANIFEST_VERSION = new Name(\"Manifest-Version\");\n     /**\n-     * Represents a name of a Manifest Attribute. Defines a couple of well\n-     * know names for the general main attributes, stand alone application\n-     * attributes, applet attributes, extension identification attributes,\n-     * package versioning and sealing attributes, file contents attributes,\n-     * bean objects attribute and signing attributes. See the \n-     * <p>\n-     * The characters of a Name must obey the following restrictions:\n-     * <ul>\n-     * <li> Must contain at least one character\n-     * <li> The first character must be alphanumeric (a-z, A-Z, 0-9)\n-     * <li> All other characters must be alphanumeric, a '-' or a '_'\n-     * </ul>\n-     * <p>\n-     * When comparing Names (with <code>equals</code>) all characters are\n-     * converted to lowercase. But you can get the original case sensitive\n-     * string with the <code>toString()</code> method.\n-     *\n-     * @since 1.2\n-     * @author Mark Wielaard (mark@klomp.org)\n+     * General main attribute -\n+     * tool and version that created this Manifest file.\n      */\n-    public static class Name {\n-\n-        // Fields\n-\n-        // General Main Attributes\n-\n-        /**\n-         * General main attribute -\n-         * the version of this Manifest file.\n-         */\n-        public static final Name MANIFEST_VERSION\n-                                = new Name(\"Manifest-Version\");\n-        /**\n-         * General main attribute -\n-         * tool and version that created this Manifest file.\n-         */\n-        public static final Name CREATED_BY\n-                                = new Name(\"Created-By\");\n-        /**\n-         * General main attribute -\n-         * the version of the jar file signature.\n-         */\n-        public static final Name SIGNATURE_VERSION\n-                                = new Name(\"Signature-Version\");\n-        /**\n-         * General main attribute -\n-         * (relative) URLs of the libraries/classpaths that the Classes in\n-         * this jar file depend on.\n-         */\n-        public static final Name CLASS_PATH\n-                                = new Name(\"Class-Path\");\n-\n-        /**\n-         * Stand alone application attribute -\n-         * the entry (without the .class ending) that is the main\n-         * class of this jar file.\n-         */\n-        public static final Name MAIN_CLASS\n-                                = new Name(\"Main-Class\");\n-\n-        /**\n-         * Applet attribute -\n-         * a list of extension libraries that the applet in this\n-         * jar file depends on.\n-         * For every named extension there should be some Attributes in the\n-         * Manifest manifest file with the following Names:\n-         * <ul>\n-         * <li> &lt;extension&gt;-Extension-Name:\n-         * unique name of the extension\n-         * <li> &lt;extension&gt;-Specification-Version:\n-         * minimum specification version\n-         * <li> &lt;extension&gt;-Implementation-Version:\n-         * minimum implementation version\n-         * <li> &lt;extension&gt;-Implementation-Vendor-Id:\n-         * unique id of implementation vendor\n-         * <li> &lt;extension&gt;-Implementation-URL:\n-         * where the latest version of the extension library can be found\n-         * </ul>\n-         */\n-        public static final Name EXTENSION_LIST\n-                                = new Name(\"Extension-List\");\n-\n-        /**\n-         * Extension identification attribute -\n-         * the name if the extension library contained in the jar.\n-         */\n-        public static final Name EXTENSION_NAME\n-                                = new Name(\"Extension-Name\");\n-        /**\n-         * Extension identification attribute -\n-         * synonym for <code>EXTENSTION_NAME</code>.\n-         */\n-        public static final Name EXTENSION_INSTALLATION\n-                                = EXTENSION_NAME;\n-\n-        // Package versioning and sealing attributes\n-        /**\n-         * Package versioning -\n-         * name of extension library contained in this jar.\n-         */\n-        public static final Name IMPLEMENTATION_TITLE\n-                                = new Name(\"Implementation-Title\");\n-        /**\n-         * Package versioning -\n-         * version of the extension library contained in this jar.\n-         */\n-        public static final Name IMPLEMENTATION_VERSION\n-                                = new Name(\"Implementation-Version\");\n-        /**\n-         * Package versioning -\n-         * name of extension library creator contained in this jar.\n-         */\n-        public static final Name IMPLEMENTATION_VENDOR\n-                                = new Name(\"Implementation-Vendor\");\n-        /**\n-         * Package versioning -\n-         * unique id of extension library creator.\n-         */\n-        public static final Name IMPLEMENTATION_VENDOR_ID\n-                                = new Name(\"Implementation-Vendor-Id\");\n-        /**\n-         * Package versioning -\n-         * location where this implementation can be downloaded.\n-         */\n-        public static final Name IMPLEMENTATION_URL\n-                                = new Name(\"Implementation-URL\");\n-        /**\n-         * Package versioning -\n-         * title of the specification contained in this jar.\n-         */\n-        public static final Name SPECIFICATION_TITLE\n-                                = new Name(\"Specification-Title\");\n-        /**\n-         * Package versioning -\n-         * version of the specification contained in this jar.\n-         */\n-        public static final Name SPECIFICATION_VERSION\n-                                = new Name(\"Specification-Version\");\n-        /**\n-         * Package versioning -\n-         * organisation that maintains the specification contains in this\n-         * jar.\n-         */\n-        public static final Name SPECIFICATION_VENDOR\n-                                = new Name(\"Specification-Vendor\");\n-        /**\n-         * Package sealing -\n-         * whether (all) package(s) is(/are) sealed. Value is either \"true\"\n-         * or \"false\".\n-         */\n-        public static final Name SEALED\n-                                = new Name(\"Sealed\");\n-\n-        /**\n-         * File contents attribute -\n-         * Mime type and subtype for the jar entry.\n-         */\n-        public static final Name CONTENT_TYPE\n-                                = new Name(\"Content-Type\");\n-\n-        /**\n-         * Bean objects attribute -\n-         * whether the entry is a Java Bean. Value is either \"true\" or \"false\".\n-         */\n-        public static final Name JAVA_BEAN\n-                                = new Name(\"Java-Bean\");\n-\n-        /**\n-         * Signing attribute -\n-         * application specific signing attribute. Must be understood by\n-         * the manifest parser when present to validate the jar (entry).\n-         */\n-        public static final Name MAGIC\n-                                = new Name(\"Magic\");\n-\n-        /** The (lowercase) String representation of this Name */\n-        private final String name;\n-        /** The original String given to the constructor */\n-        private final String origName;\n-\n-        // Constructor\n-\n-        /**\n-         * Creates a new Name from the given String.\n-         * Throws an IllegalArgumentException if the given String is empty or\n-         * contains any illegal Name characters.\n-         * \n-         * @param name the name of the new Name\n-         * @exception IllegalArgumentException if name isn't a valid String\n-         * representation of a Name\n-         * @exception NullPointerException if name is null\n-         */\n-        public Name(String name) throws IllegalArgumentException,\n-                                        NullPointerException {\n-            // name must not be null\n-            // this will throw a NullPointerException if it is\n-            char chars[] = name.toCharArray();\n-                                             \n-            // there must be at least one character\n-            if (chars.length == 0)\n-                throw new IllegalArgumentException(\n-                            \"There must be at least one character in a name\");\n-\n-            // first character must be alphanum\n-            char c = chars[0];\n-            if (!((c >= 'a' && c <= 'z') ||\n-                  (c >= 'A' && c <= 'Z') ||\n-                  (c >= '0' && c <= '9')))\n-                throw new IllegalArgumentException(\n-                                        \"First character must be alphanum\");\n-\n-            // all other characters must be alphanums, '-' or '_'\n-            for (int i = 1; i < chars.length; i++) {\n-                if (!((c >= 'a' && c <= 'z') ||\n-                      (c >= 'A' && c <= 'Z') ||\n-                      (c >= '0' && c <= '9') ||\n-                      (c == '-') || (c == '_')))\n-                    throw new IllegalArgumentException(\n-                                \"Characters must be alphanums, '-' or '_'\");\n-            }\n-\n-            // Still here? Then convert to lower case and be done.\n-            // Store the original name for toString();\n-            this.origName = name;\n-            this.name = name.toLowerCase();\n-        }\n-\n-        /**\n-         * Returns the hash code of the (lowercase) String representation of\n-         * this Name.\n-         */\n-        public int hashCode() {\n-            return name.hashCode();\n-        }\n-\n-        /**\n-         * Checks if another object is equal to this Name object.\n-         * Another object is equal to this Name object if it is an instance of\n-         * Name and the (lowercase) string representation of the name is equal.\n-         */\n-        public boolean equals(Object o) {\n-            // Quick and dirty check\n-            if (name == o)\n-                return true;\n-\n-            try {\n-                // Note that the constructor already converts the strings to\n-                // lowercase.\n-                String otherName = ((Name)o).name;\n-                return name.equals(otherName);\n-            } catch (ClassCastException cce) {\n-                return false;\n-            } catch (NullPointerException npe) {\n-                return false;\n-            }\n-        }\n-\n-        /**\n-         * Returns the string representation of this Name as given to the\n-         * constructor (not neccesarily the lower case representation).\n-         */\n-        public String toString() {\n-            return origName;\n-        }\n-    }\n-\n-    // Constructors\n-\n+    public static final Name CREATED_BY = new Name(\"Created-By\");\n     /**\n-     * Creates an empty Attributes map.\n+     * General main attribute -\n+     * the version of the jar file signature.\n      */\n-    public Attributes() {\n-        map = new Hashtable();\n-    }\n-\n+    public static final Name SIGNATURE_VERSION\n+      = new Name(\"Signature-Version\");\n     /**\n-     * Creates an empty Attributes map with the given initial size.\n-     * @param size the initial size of the underlying map\n+     * General main attribute -\n+     * (relative) URLs of the libraries/classpaths that the Classes in\n+     * this jar file depend on.\n      */\n-    public Attributes(int size) {\n-        map = new Hashtable(size);\n-    }\n+    public static final Name CLASS_PATH = new Name(\"Class-Path\");\n \n     /**\n-     * Creates an Attributes map with the initial values taken from another\n-     * Attributes map.\n-     * @param attr Attributes map to take the initial values from\n+     * Stand alone application attribute -\n+     * the entry (without the .class ending) that is the main\n+     * class of this jar file.\n      */\n-    public Attributes(Attributes attr) {\n-        map = new Hashtable(attr.map);\n-    }\n-\n-    // Methods\n+    public static final Name MAIN_CLASS = new Name(\"Main-Class\");\n \n     /**\n-     * Gets the value of an attribute name given as a String.\n-     *\n-     * @param name a String describing the Name to look for\n-     * @return the value gotten from the map of null when not found\n+     * Applet attribute -\n+     * a list of extension libraries that the applet in this\n+     * jar file depends on.\n+     * For every named extension there should be some Attributes in the\n+     * Manifest manifest file with the following Names:\n+     * <ul>\n+     * <li> &lt;extension&gt;-Extension-Name:\n+     * unique name of the extension\n+     * <li> &lt;extension&gt;-Specification-Version:\n+     * minimum specification version\n+     * <li> &lt;extension&gt;-Implementation-Version:\n+     * minimum implementation version\n+     * <li> &lt;extension&gt;-Implementation-Vendor-Id:\n+     * unique id of implementation vendor\n+     * <li> &lt;extension&gt;-Implementation-URL:\n+     * where the latest version of the extension library can be found\n+     * </ul>\n      */\n-    public String getValue(String name) {\n-        return (String)get(new Name(name));\n-    }\n+    public static final Name EXTENSION_LIST = new Name(\"Extension-List\");\n \n     /**\n-     * Gets the value of the given attribute name.\n-     *\n-     * @param name the Name to look for\n-     * @return the value gotten from the map of null when not found\n+     * Extension identification attribute -\n+     * the name if the extension library contained in the jar.\n      */\n-    public String getValue(Name name) {\n-        return (String)get(name);\n-    }\n-\n+    public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");\n     /**\n-     * Stores an attribute name (represented by a String) and value in this\n-     * Attributes map.\n-     * When the (case insensitive string) name already exists the value is\n-     * replaced and the old value is returned.\n-     *\n-     * @param name a (case insensitive) String representation of the attribite\n-     * name to add/replace\n-     * @param value the (new) value of the attribute name\n-     * @returns the old value of the attribute name or null if it didn't exist\n-     * yet\n+     * Extension identification attribute -\n+     * synonym for <code>EXTENSTION_NAME</code>.\n      */\n-    public String putValue(String name, String value)\n-    {\n-        return putValue(new Name(name), value);\n-    }\n+    public static final Name EXTENSION_INSTALLATION = EXTENSION_NAME;\n \n+    // Package versioning and sealing attributes\n     /**\n-     * Stores an attribute name (represented by a String) and value in this\n-     * Attributes map.\n-     * When the name already exists the value is replaced and the old value\n-     * is returned.\n-     * <p>\n-     * I don't know why there is no public method with this signature. I think\n-     * there should be one.\n-     *\n-     * @param name the attribite name to add/replace\n-     * @param value the (new) value of the attribute name\n-     * @returns the old value of the attribute name or null if it didn't exist\n-     * yet\n+     * Package versioning -\n+     * name of extension library contained in this jar.\n      */\n-    private String putValue(Name name, String value)\n-    {\n-        return (String)put(name, value);\n-    }\n-\n-    // Methods from Cloneable interface\n-\n+    public static final Name IMPLEMENTATION_TITLE\n+      = new Name(\"Implementation-Title\");\n     /**\n-     * Return a clone of this attribute map.\n+     * Package versioning -\n+     * version of the extension library contained in this jar.\n      */\n-    public Object clone() {\n-        return new Attributes(this);\n-    }\n-\n-    // Methods from Map interface\n-\n+    public static final Name IMPLEMENTATION_VERSION\n+      = new Name(\"Implementation-Version\");\n     /**\n-     * Removes all attributes.\n+     * Package versioning -\n+     * name of extension library creator contained in this jar.\n      */\n-    public void clear() {\n-        map.clear();\n-    }\n-\n+    public static final Name IMPLEMENTATION_VENDOR\n+      = new Name(\"Implementation-Vendor\");\n     /**\n-     * Checks to see if there is an attribute with the specified name.\n-     * XXX - what if the object is a String?\n-     *\n-     * @param attrName the name of the attribute to check\n-     * @return true if there is an attribute with the specified name, false\n-     * otherwise\n+     * Package versioning -\n+     * unique id of extension library creator.\n      */\n-    public boolean containsKey(Object attrName) {\n-        return map.containsKey(attrName);\n-    }\n-\n+    public static final Name IMPLEMENTATION_VENDOR_ID\n+      = new Name(\"Implementation-Vendor-Id\");\n     /**\n-     * Checks to see if there is an attribute name with the specified value.\n-     *\n-     * @param attrValue the value of a attribute to check\n-     * @return true if there is an attribute name with the specified value,\n-     * false otherwise\n+     * Package versioning -\n+     * location where this implementation can be downloaded.\n      */\n-    public boolean containsValue(Object attrValue) {\n-        return map.containsValue(attrValue);\n-    }\n-\n+    public static final Name IMPLEMENTATION_URL\n+      = new Name(\"Implementation-URL\");\n     /**\n-     * Gives a Set of attribute name and values pairs as MapEntries.\n-     * @see java.util.Map.Entry\n-     * @see java.util.Map#entrySet()\n-     *\n-     * @return a set of attribute name value pairs\n+     * Package versioning -\n+     * title of the specification contained in this jar.\n      */\n-    public Set entrySet() {\n-        return map.entrySet();\n-    }\n-\n+    public static final Name SPECIFICATION_TITLE\n+      = new Name(\"Specification-Title\");\n     /**\n-     * Checks to see if two Attributes are equal. The supplied object must be\n-     * a real instance of Attributes and contain the same attribute name/value\n-     * pairs.\n-     *\n-     * @param o another Attribute object which should be checked for equality\n-     * @return true if the object is an instance of Attributes and contains the\n-     * same name/value pairs, false otherwise\n+     * Package versioning -\n+     * version of the specification contained in this jar.\n      */\n-    public boolean equals(Object o) {\n-        // quick and dirty check\n-        if (this == o)\n-            return true;\n-\n-        try {\n-            return map.equals(((Attributes)o).map);\n-        } catch (ClassCastException cce) {\n-            return false;\n-        } catch (NullPointerException npe) {\n-            return false;\n-        }\n-    }\n-\n+    public static final Name SPECIFICATION_VERSION\n+      = new Name(\"Specification-Version\");\n     /**\n-     * Gets the value of a specified attribute name.\n-     * XXX - what if the object is a String?\n-     *\n-     * @param attrName the name of the attribute we want the value of\n-     * @return the value of the specified attribute name or null when there is\n-     * no such attribute name\n+     * Package versioning -\n+     * organisation that maintains the specification contains in this\n+     * jar.\n      */\n-    public Object get(Object attrName) {\n-        return map.get(attrName);\n-    }\n-\n+    public static final Name SPECIFICATION_VENDOR\n+      = new Name(\"Specification-Vendor\");\n     /**\n-     * Returns the hashcode of the attribute name/value map.\n+     * Package sealing -\n+     * whether (all) package(s) is(/are) sealed. Value is either \"true\"\n+     * or \"false\".\n      */\n-    public int hashCode() {\n-        return map.hashCode();\n-    }\n+    public static final Name SEALED = new Name(\"Sealed\");\n \n     /**\n-     * Returns true if there are no attributes set, false otherwise.\n+     * File contents attribute -\n+     * Mime type and subtype for the jar entry.\n      */\n-    public boolean isEmpty() {\n-        return map.isEmpty();\n-    }\n+    public static final Name CONTENT_TYPE = new Name(\"Content-Type\");\n \n     /**\n-     * Gives a Set of all the values of defined attribute names.\n+     * Bean objects attribute -\n+     * whether the entry is a Java Bean. Value is either \"true\" or \"false\".\n      */\n-    public Set keySet() {\n-        return map.keySet();\n-    }\n+    public static final Name JAVA_BEAN = new Name(\"Java-Bean\");\n \n     /**\n-     * Adds or replaces a attribute name/value pair.\n-     * XXX - What if the name is a string? What if the name is neither a Name\n-     * nor a String? What if the value is not a string?\n-     *\n-     * @param name the name of the attribute\n-     * @param value the (new) value of the attribute\n-     * @return the old value of the attribute or null when there was no old\n-     * attribute with this name\n+     * Signing attribute -\n+     * application specific signing attribute. Must be understood by\n+     * the manifest parser when present to validate the jar (entry).\n      */\n-    public Object put(Object name, Object value) {\n-        return map.put(name, value);\n-    }\n+    public static final Name MAGIC = new Name(\"Magic\");\n+\n+    /** The (lowercase) String representation of this Name */\n+    private final String name;\n+    /** The original String given to the constructor */\n+    private final String origName;\n+\n+    // Constructor\n \n     /**\n-     * Adds or replaces all attribute name/value pairs from another\n-     * Attributes object to this one. The supplied Map must be an instance of\n-     * Attributes.\n-     *\n-     * @param attr the Attributes object to merge with this one\n-     * @exception ClassCastException if the supplied map is not an instance of\n-     * Attributes\n+     * Creates a new Name from the given String.\n+     * Throws an IllegalArgumentException if the given String is empty or\n+     * contains any illegal Name characters.\n+     * \n+     * @param name the name of the new Name\n+     * @exception IllegalArgumentException if name isn't a valid String\n+     * representation of a Name\n+     * @exception NullPointerException if name is null\n      */\n-    public void putAll(Map attr) {\n-        if (!(attr instanceof Attributes)) {\n-            throw new ClassCastException(\n-                        \"Supplied Map is not an instance of Attributes\");\n-        }\n-        map.putAll(attr);\n+    public Name(String name) throws IllegalArgumentException,\n+      NullPointerException\n+    {\n+      // name must not be null\n+      // this will throw a NullPointerException if it is\n+      char chars[] = name.toCharArray();\n+\n+      // there must be at least one character\n+      if (chars.length == 0)\n+\tthrow new\n+\t  IllegalArgumentException\n+\t  (\"There must be at least one character in a name\");\n+\n+      // first character must be alphanum\n+      char c = chars[0];\n+      if (!((c >= 'a' && c <= 'z') ||\n+\t    (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')))\n+\tthrow new\n+\t  IllegalArgumentException(\"First character must be alphanum\");\n+\n+      // all other characters must be alphanums, '-' or '_'\n+      for (int i = 1; i < chars.length; i++)\n+\t{\n+\t  if (!((c >= 'a' && c <= 'z') ||\n+\t\t(c >= 'A' && c <= 'Z') ||\n+\t\t(c >= '0' && c <= '9') || (c == '-') || (c == '_')))\n+\t    throw new\n+\t      IllegalArgumentException\n+\t      (\"Characters must be alphanums, '-' or '_'\");\n+\t}\n+\n+      // Still here? Then convert to lower case and be done.\n+      // Store the original name for toString();\n+      this.origName = name;\n+      this.name = name.toLowerCase();\n     }\n \n     /**\n-     * Remove a attribute name/value pair.\n-     * XXX - What if the name is a String?\n-     *\n-     * @param name the name of the attribute name/value pair to remove\n-     * @return the old value of the attribute or null if the attribute didn't\n-     * exist\n+     * Returns the hash code of the (lowercase) String representation of\n+     * this Name.\n      */\n-    public Object remove(Object name) {\n-        return map.remove(name);\n+    public int hashCode()\n+    {\n+      return name.hashCode();\n     }\n \n     /**\n-     * Returns the number of defined attribute name/value pairs.\n+     * Checks if another object is equal to this Name object.\n+     * Another object is equal to this Name object if it is an instance of\n+     * Name and the (lowercase) string representation of the name is equal.\n      */\n-    public int size() {\n-        return map.size();\n+    public boolean equals(Object o)\n+    {\n+      // Quick and dirty check\n+      if (name == o)\n+\treturn true;\n+\n+      try\n+\t{\n+\t  // Note that the constructor already converts the strings to\n+\t  // lowercase.\n+\t  String otherName = ((Name) o).name;\n+\t  return name.equals(otherName);\n+\t}\n+      catch (ClassCastException cce)\n+\t{\n+\t  return false;\n+\t}\n+      catch (NullPointerException npe)\n+\t{\n+\t  return false;\n+\t}\n     }\n \n     /**\n-     * Returns all the values of the defined attribute name/value pairs as a\n-     * Collection.\n+     * Returns the string representation of this Name as given to the\n+     * constructor (not neccesarily the lower case representation).\n      */\n-    public Collection values() {\n-        return map.values();\n+    public String toString()\n+    {\n+      return origName;\n     }\n+  }\n+\n+  // Constructors\n+\n+  /**\n+   * Creates an empty Attributes map.\n+   */\n+  public Attributes()\n+  {\n+    map = new Hashtable();\n+  }\n+\n+  /**\n+   * Creates an empty Attributes map with the given initial size.\n+   * @param size the initial size of the underlying map\n+   */\n+  public Attributes(int size)\n+  {\n+    map = new Hashtable(size);\n+  }\n+\n+  /**\n+   * Creates an Attributes map with the initial values taken from another\n+   * Attributes map.\n+   * @param attr Attributes map to take the initial values from\n+   */\n+  public Attributes(Attributes attr)\n+  {\n+    map = new Hashtable(attr.map);\n+  }\n+\n+  // Methods\n+\n+  /**\n+   * Gets the value of an attribute name given as a String.\n+   *\n+   * @param name a String describing the Name to look for\n+   * @return the value gotten from the map of null when not found\n+   */\n+  public String getValue(String name)\n+  {\n+    return (String) get(new Name(name));\n+  }\n+\n+  /**\n+   * Gets the value of the given attribute name.\n+   *\n+   * @param name the Name to look for\n+   * @return the value gotten from the map of null when not found\n+   */\n+  public String getValue(Name name)\n+  {\n+    return (String) get(name);\n+  }\n+\n+  /**\n+   * Stores an attribute name (represented by a String) and value in this\n+   * Attributes map.\n+   * When the (case insensitive string) name already exists the value is\n+   * replaced and the old value is returned.\n+   *\n+   * @param name a (case insensitive) String representation of the attribite\n+   * name to add/replace\n+   * @param value the (new) value of the attribute name\n+   * @returns the old value of the attribute name or null if it didn't exist\n+   * yet\n+   */\n+  public String putValue(String name, String value)\n+  {\n+    return putValue(new Name(name), value);\n+  }\n+\n+  /**\n+   * Stores an attribute name (represented by a String) and value in this\n+   * Attributes map.\n+   * When the name already exists the value is replaced and the old value\n+   * is returned.\n+   * <p>\n+   * I don't know why there is no public method with this signature. I think\n+   * there should be one.\n+   *\n+   * @param name the attribite name to add/replace\n+   * @param value the (new) value of the attribute name\n+   * @returns the old value of the attribute name or null if it didn't exist\n+   * yet\n+   */\n+  private String putValue(Name name, String value)\n+  {\n+    return (String) put(name, value);\n+  }\n+\n+  // Methods from Cloneable interface\n+\n+  /**\n+   * Return a clone of this attribute map.\n+   */\n+  public Object clone()\n+  {\n+    return new Attributes(this);\n+  }\n+\n+  // Methods from Map interface\n+\n+  /**\n+   * Removes all attributes.\n+   */\n+  public void clear()\n+  {\n+    map.clear();\n+  }\n+\n+  /**\n+   * Checks to see if there is an attribute with the specified name.\n+   * XXX - what if the object is a String?\n+   *\n+   * @param attrName the name of the attribute to check\n+   * @return true if there is an attribute with the specified name, false\n+   * otherwise\n+   */\n+  public boolean containsKey(Object attrName)\n+  {\n+    return map.containsKey(attrName);\n+  }\n+\n+  /**\n+   * Checks to see if there is an attribute name with the specified value.\n+   *\n+   * @param attrValue the value of a attribute to check\n+   * @return true if there is an attribute name with the specified value,\n+   * false otherwise\n+   */\n+  public boolean containsValue(Object attrValue)\n+  {\n+    return map.containsValue(attrValue);\n+  }\n+\n+  /**\n+   * Gives a Set of attribute name and values pairs as MapEntries.\n+   * @see java.util.Map.Entry\n+   * @see java.util.Map#entrySet()\n+   *\n+   * @return a set of attribute name value pairs\n+   */\n+  public Set entrySet()\n+  {\n+    return map.entrySet();\n+  }\n+\n+  /**\n+   * Checks to see if two Attributes are equal. The supplied object must be\n+   * a real instance of Attributes and contain the same attribute name/value\n+   * pairs.\n+   *\n+   * @param o another Attribute object which should be checked for equality\n+   * @return true if the object is an instance of Attributes and contains the\n+   * same name/value pairs, false otherwise\n+   */\n+  public boolean equals(Object o)\n+  {\n+    // quick and dirty check\n+    if (this == o)\n+      return true;\n+\n+    try\n+      {\n+\treturn map.equals(((Attributes) o).map);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+\treturn false;\n+      }\n+    catch (NullPointerException npe)\n+      {\n+\treturn false;\n+      }\n+  }\n+\n+  /**\n+   * Gets the value of a specified attribute name.\n+   * XXX - what if the object is a String?\n+   *\n+   * @param attrName the name of the attribute we want the value of\n+   * @return the value of the specified attribute name or null when there is\n+   * no such attribute name\n+   */\n+  public Object get(Object attrName)\n+  {\n+    return map.get(attrName);\n+  }\n+\n+  /**\n+   * Returns the hashcode of the attribute name/value map.\n+   */\n+  public int hashCode()\n+  {\n+    return map.hashCode();\n+  }\n+\n+  /**\n+   * Returns true if there are no attributes set, false otherwise.\n+   */\n+  public boolean isEmpty()\n+  {\n+    return map.isEmpty();\n+  }\n+\n+  /**\n+   * Gives a Set of all the values of defined attribute names.\n+   */\n+  public Set keySet()\n+  {\n+    return map.keySet();\n+  }\n+\n+  /**\n+   * Adds or replaces a attribute name/value pair.\n+   * XXX - What if the name is a string? What if the name is neither a Name\n+   * nor a String? What if the value is not a string?\n+   *\n+   * @param name the name of the attribute\n+   * @param value the (new) value of the attribute\n+   * @return the old value of the attribute or null when there was no old\n+   * attribute with this name\n+   */\n+  public Object put(Object name, Object value)\n+  {\n+    return map.put(name, value);\n+  }\n+\n+  /**\n+   * Adds or replaces all attribute name/value pairs from another\n+   * Attributes object to this one. The supplied Map must be an instance of\n+   * Attributes.\n+   *\n+   * @param attr the Attributes object to merge with this one\n+   * @exception ClassCastException if the supplied map is not an instance of\n+   * Attributes\n+   */\n+  public void putAll(Map attr)\n+  {\n+    if (!(attr instanceof Attributes))\n+      {\n+\tthrow new\n+\t  ClassCastException(\"Supplied Map is not an instance of Attributes\");\n+      }\n+    map.putAll(attr);\n+  }\n+\n+  /**\n+   * Remove a attribute name/value pair.\n+   * XXX - What if the name is a String?\n+   *\n+   * @param name the name of the attribute name/value pair to remove\n+   * @return the old value of the attribute or null if the attribute didn't\n+   * exist\n+   */\n+  public Object remove(Object name)\n+  {\n+    return map.remove(name);\n+  }\n+\n+  /**\n+   * Returns the number of defined attribute name/value pairs.\n+   */\n+  public int size()\n+  {\n+    return map.size();\n+  }\n+\n+  /**\n+   * Returns all the values of the defined attribute name/value pairs as a\n+   * Collection.\n+   */\n+  public Collection values()\n+  {\n+    return map.values();\n+  }\n }"}, {"sha": "7238d5b5164808aba0690ddc2bf77cf65da81119", "filename": "libjava/java/util/jar/JarEntry.java", "status": "modified", "additions": 109, "deletions": 94, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarEntry.java?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -43,97 +43,112 @@\n  * @since 1.2\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n- \n-public class JarEntry extends ZipEntry {\n-\n-    // (Packge local) fields\n-\n-    Attributes attr;\n-    Certificate certs[];\n-\n-    // Constructors\n-\n-    /**\n-     * Creates a new JarEntry with the specified name and no attributes or\n-     * or certificates. Calls <code>super(name)</code> so all other (zip)entry\n-     * fields are null or -1.\n-     *\n-     * @param name the name of the new jar entry\n-     * @exception NullPointerException when the supplied name is null\n-     * @exception IllegalArgumentException when the supplied name is longer\n-     * than 65535 bytes\n-     */\n-    public JarEntry(String name) throws NullPointerException,\n-                                 IllegalArgumentException {\n-        super(name);\n-        attr = null;\n-        certs = null;\n-    }\n-\n-    /**\n-     * Creates a new JarEntry with the specified ZipEntry as template for\n-     * all properties of the entry. Both attributes and certificates will be\n-     * null.\n-     *\n-     * @param entry the ZipEntry whose fields should be copied\n-     */\n-    public JarEntry(ZipEntry entry) {\n-        super(entry);\n-        attr = null;\n-        certs = null;\n-    }\n-\n-    /**\n-     * Creates a new JarEntry with the specified JarEntry as template for\n-     * all properties of the entry.\n-     *\n-     * @param entry the jarEntry whose fields should be copied\n-     */\n-    public JarEntry(JarEntry entry) {\n-        super(entry);\n-        try {\n-            attr = entry.getAttributes();\n-        } catch(IOException _) {}\n-        certs = entry.getCertificates();\n-    }\n-\n-    // Methods\n-\n-    /**\n-     * Returns a copy of the Attributes set for this entry.\n-     * When no Attributes are set in the manifest null is returned.\n-     *\n-     * @return a copy of the Attributes set for this entry\n-     * @exception IOException This will never be thrown. It is here for\n-     * binary compatibility.\n-     */\n-    public Attributes getAttributes() throws IOException {\n-        if (attr != null) {\n-            return (Attributes) attr.clone();\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Returns a copy of the certificates set for this entry.\n-     * When no certificates are set or when not all data of this entry has\n-     * been read null is returned.\n-     * <p>\n-     * To make sure that this call returns a valid value you must read all\n-     * data from the JarInputStream for this entry.\n-     * When you don't need the data for an entry but want to know the\n-     * certificates that are set for the entry then you can skip all data by\n-     * calling <code>skip(entry.getSize())</code> on the JarInputStream for\n-     * the entry.\n-     *\n-     * @return a copy of the certificates set for this entry\n-     */\n-    public Certificate[] getCertificates() {\n-        if (certs != null) {\n-            return (Certificate []) certs.clone();\n-        } else {\n-            return null;\n-        }\n-    }\n+\n+public class JarEntry extends ZipEntry\n+{\n+  // (Packge local) fields\n+\n+  Attributes attr;\n+  Certificate certs[];\n+\n+  // Constructors\n+\n+  /**\n+   * Creates a new JarEntry with the specified name and no attributes or\n+   * or certificates. Calls <code>super(name)</code> so all other (zip)entry\n+   * fields are null or -1.\n+   *\n+   * @param name the name of the new jar entry\n+   * @exception NullPointerException when the supplied name is null\n+   * @exception IllegalArgumentException when the supplied name is longer\n+   * than 65535 bytes\n+   */\n+  public JarEntry(String name) throws NullPointerException,\n+    IllegalArgumentException\n+  {\n+    super(name);\n+    attr = null;\n+    certs = null;\n+  }\n+\n+  /**\n+   * Creates a new JarEntry with the specified ZipEntry as template for\n+   * all properties of the entry. Both attributes and certificates will be\n+   * null.\n+   *\n+   * @param entry the ZipEntry whose fields should be copied\n+   */\n+  public JarEntry(ZipEntry entry)\n+  {\n+    super(entry);\n+    attr = null;\n+    certs = null;\n+  }\n+\n+  /**\n+   * Creates a new JarEntry with the specified JarEntry as template for\n+   * all properties of the entry.\n+   *\n+   * @param entry the jarEntry whose fields should be copied\n+   */\n+  public JarEntry(JarEntry entry)\n+  {\n+    super(entry);\n+    try\n+      {\n+\tattr = entry.getAttributes();\n+      }\n+    catch (IOException _)\n+      {\n+      }\n+    certs = entry.getCertificates();\n+  }\n+\n+  // Methods\n+\n+  /**\n+   * Returns a copy of the Attributes set for this entry.\n+   * When no Attributes are set in the manifest null is returned.\n+   *\n+   * @return a copy of the Attributes set for this entry\n+   * @exception IOException This will never be thrown. It is here for\n+   * binary compatibility.\n+   */\n+  public Attributes getAttributes() throws IOException\n+  {\n+    if (attr != null)\n+      {\n+\treturn (Attributes) attr.clone();\n+      }\n+    else\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  /**\n+   * Returns a copy of the certificates set for this entry.\n+   * When no certificates are set or when not all data of this entry has\n+   * been read null is returned.\n+   * <p>\n+   * To make sure that this call returns a valid value you must read all\n+   * data from the JarInputStream for this entry.\n+   * When you don't need the data for an entry but want to know the\n+   * certificates that are set for the entry then you can skip all data by\n+   * calling <code>skip(entry.getSize())</code> on the JarInputStream for\n+   * the entry.\n+   *\n+   * @return a copy of the certificates set for this entry\n+   */\n+  public Certificate[] getCertificates()\n+  {\n+    if (certs != null)\n+      {\n+\treturn (Certificate[])certs.clone();\n+      }\n+    else\n+      {\n+\treturn null;\n+      }\n+  }\n }"}, {"sha": "2b73c0546284746c0c18dd571472fbb5efd26c3a", "filename": "libjava/java/util/jar/JarException.java", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarException.java?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -39,27 +39,29 @@\n  * @since 1.2\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n- \n-public class JarException extends ZipException {\n \n-    // Constructors\n+public class JarException extends ZipException\n+{\n+  // Constructors\n \n-    /**\n-     * Create a new JarException without a descriptive error message.\n-     */\n-    public JarException() {\n-        super();\n-    }\n+  /**\n+   * Create a new JarException without a descriptive error message.\n+   */\n+  public JarException()\n+  {\n+    super();\n+  }\n \n-    /**\n-     * Create a new JarException with a descriptive error message indicating\n-     * what went wrong. This message can later be retrieved by calling the\n-     * <code>getMessage()</code> method.\n-     * @see java.lang.Throwable@getMessage()\n-     *\n-     * @param message The descriptive error message\n-     */\n-    public JarException(String message) {\n-        super(message);\n-    }\n+  /**\n+   * Create a new JarException with a descriptive error message indicating\n+   * what went wrong. This message can later be retrieved by calling the\n+   * <code>getMessage()</code> method.\n+   * @see java.lang.Throwable@getMessage()\n+   *\n+   * @param message The descriptive error message\n+   */\n+  public JarException(String message)\n+  {\n+    super(message);\n+  }\n }"}, {"sha": "588f1f85765e506d82e0ac06f823de4ef011450e", "filename": "libjava/java/util/jar/JarFile.java", "status": "modified", "additions": 224, "deletions": 204, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -47,231 +47,251 @@\n  * @since 1.2\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n-public class JarFile extends ZipFile {\n-\n-    // Fields\n-\n-    /** The name of the manifest entry: META-INF/MANIFEST.MF */\n-    public static final String MANIFEST_NAME = \"META-INF/MANIFEST.MF\";\n-\n-    /**\n-     * The manifest of this file, if any, otherwise null.\n-     * Read by the constructor.\n-     */\n-    private final Manifest manifest;\n+public class JarFile extends ZipFile\n+{\n+  // Fields\n \n-    /** Wether to verify the manifest and all entries */\n-    private boolean verify;\n+  /** The name of the manifest entry: META-INF/MANIFEST.MF */\n+  public static final String MANIFEST_NAME = \"META-INF/MANIFEST.MF\";\n \n-    // Constructors\n+  /**\n+   * The manifest of this file, if any, otherwise null.\n+   * Read by the constructor.\n+   */\n+  private final Manifest manifest;\n \n-    /**\n-     * Creates a new JarFile, tries to read the manifest and if the manifest\n-     * exists verifies it.\n-     *\n-     * @param fileName the name of the file to open\n-     * @exception FileNotFoundException if the fileName cannot be found\n-     * @exception IOException if another IO exception occurs while reading\n-     */\n-    public JarFile(String fileName) throws FileNotFoundException,\n-                                           IOException {\n-        this (fileName, true);\n-    }\n+  /** Wether to verify the manifest and all entries */\n+  private boolean verify;\n \n-    /**\n-     * Creates a new JarFile, tries to read the manifest and if the manifest\n-     * exists and verify is true verfies it.\n-     *\n-     * @param fileName the name of the file to open\n-     * @param verify checks manifest and entries when true and a manifest\n-     * exists, when false no checks are made\n-     * @exception FileNotFoundException if the fileName cannot be found\n-     * @exception IOException if another IO exception occurs while reading\n-     */\n-    public JarFile(String fileName, boolean verify) throws\n-                                                    FileNotFoundException,\n-                                                    IOException {\n-        super(fileName);\n-        manifest = readManifest();\n-        if (verify)\n-            verify();\n-    }\n+  // Constructors\n \n-    /**\n-     * Creates a new JarFile, tries to read the manifest and if the manifest\n-     * exists verifies it.\n-     *\n-     * @param file the file to open as a jar file\n-     * @exception FileNotFoundException if the file does not exits\n-     * @exception IOException if another IO exception occurs while reading\n-     */\n-    public JarFile(File file) throws FileNotFoundException,\n-                                     IOException {\n-        this (file, true);\n-    }\n+  /**\n+   * Creates a new JarFile, tries to read the manifest and if the manifest\n+   * exists verifies it.\n+   *\n+   * @param fileName the name of the file to open\n+   * @exception FileNotFoundException if the fileName cannot be found\n+   * @exception IOException if another IO exception occurs while reading\n+   */\n+  public JarFile(String fileName) throws FileNotFoundException, IOException\n+  {\n+    this(fileName, true);\n+  }\n \n-    /**\n-     * Creates a new JarFile, tries to read the manifest and if the manifest\n-     * exists and verify is true verfies it.\n-     *\n-     * @param file the file to open to open as a jar file\n-     * @param verify checks manifest and entries when true and a manifest\n-     * exists, when false no checks are made\n-     * @exception FileNotFoundException if file does not exist\n-     * @exception IOException if another IO exception occurs while reading\n-     */\n-    public JarFile(File file, boolean verify) throws FileNotFoundException,\n-                                                     IOException {\n-        super(file);\n-        manifest = readManifest();\n-        if (verify)\n-            verify();\n-    }\n+  /**\n+   * Creates a new JarFile, tries to read the manifest and if the manifest\n+   * exists and verify is true verfies it.\n+   *\n+   * @param fileName the name of the file to open\n+   * @param verify checks manifest and entries when true and a manifest\n+   * exists, when false no checks are made\n+   * @exception FileNotFoundException if the fileName cannot be found\n+   * @exception IOException if another IO exception occurs while reading\n+   */\n+  public JarFile(String fileName, boolean verify) throws\n+    FileNotFoundException, IOException\n+  {\n+    super(fileName);\n+    manifest = readManifest();\n+    if (verify)\n+      verify();\n+  }\n \n-    /**\n-     * Creates a new JarFile with the indicated mode, tries to read the\n-     * manifest and if the manifest exists and verify is true verfies it.\n-     *\n-     * @param file the file to open to open as a jar file\n-     * @param verify checks manifest and entries when true and a manifest\n-     * exists, when false no checks are made\n-     * @param mode either ZipFile.OPEN_READ or\n-     *             (ZipFile.OPEN_READ | ZipFile.OPEN_DELETE)\n-     * @exception FileNotFoundException if the file does not exist\n-     * @exception IOException if another IO exception occurs while reading\n-     * @exception IllegalArgumentException when given an illegal mode\n-     * \n-     * @since 1.3\n-     */\n-    public JarFile(File file, boolean verify, int mode) throws\n-                                                    FileNotFoundException,\n-                                                    IOException,\n-                                                    IllegalArgumentException {\n-        super(file, mode);\n-        manifest = readManifest();\n-        if (verify)\n-            verify();\n-    }\n+  /**\n+   * Creates a new JarFile, tries to read the manifest and if the manifest\n+   * exists verifies it.\n+   *\n+   * @param file the file to open as a jar file\n+   * @exception FileNotFoundException if the file does not exits\n+   * @exception IOException if another IO exception occurs while reading\n+   */\n+  public JarFile(File file) throws FileNotFoundException, IOException\n+  {\n+    this(file, true);\n+  }\n \n-    // Methods\n+  /**\n+   * Creates a new JarFile, tries to read the manifest and if the manifest\n+   * exists and verify is true verfies it.\n+   *\n+   * @param file the file to open to open as a jar file\n+   * @param verify checks manifest and entries when true and a manifest\n+   * exists, when false no checks are made\n+   * @exception FileNotFoundException if file does not exist\n+   * @exception IOException if another IO exception occurs while reading\n+   */\n+  public JarFile(File file, boolean verify) throws FileNotFoundException,\n+    IOException\n+  {\n+    super(file);\n+    manifest = readManifest();\n+    if (verify)\n+      verify();\n+  }\n \n-    /**\n-     * XXX - should verify the manifest file\n-     */\n-    private void verify() {\n-        // only check if manifest is not null\n-        if (manifest == null) {\n-            verify = false;\n-            return;\n-        }\n+  /**\n+   * Creates a new JarFile with the indicated mode, tries to read the\n+   * manifest and if the manifest exists and verify is true verfies it.\n+   *\n+   * @param file the file to open to open as a jar file\n+   * @param verify checks manifest and entries when true and a manifest\n+   * exists, when false no checks are made\n+   * @param mode either ZipFile.OPEN_READ or\n+   *             (ZipFile.OPEN_READ | ZipFile.OPEN_DELETE)\n+   * @exception FileNotFoundException if the file does not exist\n+   * @exception IOException if another IO exception occurs while reading\n+   * @exception IllegalArgumentException when given an illegal mode\n+   * \n+   * @since 1.3\n+   */\n+  public JarFile(File file, boolean verify, int mode) throws\n+    FileNotFoundException, IOException, IllegalArgumentException\n+  {\n+    super(file, mode);\n+    manifest = readManifest();\n+    if (verify)\n+      verify();\n+  }\n \n-        verify = true;\n-        // XXX - verify manifest\n-    }\n+  // Methods\n \n-    /**\n-     * Parses and returns the manifest if it exists, otherwise returns null.\n-     */\n-    private Manifest readManifest() {\n-        try {\n-            ZipEntry manEntry = super.getEntry(MANIFEST_NAME);\n-            if (manEntry != null) {\n-                InputStream in = super.getInputStream(manEntry);\n-                return new Manifest(in);\n-            } else {\n-                return null;\n-            }\n-        } catch (IOException ioe) {\n-            return null;\n-        }\n-    }\n+  /**\n+   * XXX - should verify the manifest file\n+   */\n+  private void verify()\n+  {\n+    // only check if manifest is not null\n+    if (manifest == null)\n+      {\n+\tverify = false;\n+\treturn;\n+      }\n \n-    /**\n-     * Returns a enumeration of all the entries in the JarFile.\n-     * Note that also the Jar META-INF entries are returned.\n-     *\n-     * @exception IllegalStateException when the JarFile is already closed\n-     */\n-    public Enumeration entries() throws IllegalStateException {\n-        return new JarEnumeration(super.entries());\n-    }\n+    verify = true;\n+    // XXX - verify manifest\n+  }\n \n-    /**\n-     * Wraps a given Zip Entries Enumeration. For every zip entry a\n-     * JarEntry is created and the corresponding Attributes are looked up.\n-     * XXX - Should also look up the certificates.\n-     */\n-    private class JarEnumeration implements Enumeration {\n+  /**\n+   * Parses and returns the manifest if it exists, otherwise returns null.\n+   */\n+  private Manifest readManifest()\n+  {\n+    try\n+      {\n+\tZipEntry manEntry = super.getEntry(MANIFEST_NAME);\n+\tif (manEntry != null)\n+\t  {\n+\t    InputStream in = super.getInputStream(manEntry);\n+\t    return new Manifest(in);\n+\t  }\n+\telse\n+\t  {\n+\t    return null;\n+\t  }\n+      }\n+    catch (IOException ioe)\n+      {\n+\treturn null;\n+      }\n+  }\n \n-        private final Enumeration entries;\n+  /**\n+   * Returns a enumeration of all the entries in the JarFile.\n+   * Note that also the Jar META-INF entries are returned.\n+   *\n+   * @exception IllegalStateException when the JarFile is already closed\n+   */\n+  public Enumeration entries() throws IllegalStateException\n+  {\n+    return new JarEnumeration(super.entries());\n+  }\n \n-        JarEnumeration(Enumeration e) {\n-            entries = e;\n-        }\n+  /**\n+   * Wraps a given Zip Entries Enumeration. For every zip entry a\n+   * JarEntry is created and the corresponding Attributes are looked up.\n+   * XXX - Should also look up the certificates.\n+   */\n+  private class JarEnumeration implements Enumeration\n+  {\n \n-        public boolean hasMoreElements() {\n-            return entries.hasMoreElements();\n-        }\n+    private final Enumeration entries;\n \n-        public Object nextElement() {\n-            ZipEntry zip = (ZipEntry) entries.nextElement();\n-            JarEntry jar = new JarEntry(zip);\n-            if (manifest != null) {\n-                jar.attr = manifest.getAttributes(jar.getName());\n-            }\n-            // XXX jar.certs\n-            return jar;\n-        }\n+    JarEnumeration(Enumeration e)\n+    {\n+      entries = e;\n     }\n \n-    /**\n-     * XXX\n-     * It actually returns a JarEntry not a zipEntry\n-     * @param name XXX\n-     */\n-    public ZipEntry getEntry(String name) {\n-        ZipEntry entry = super.getEntry(name);\n-        if (entry != null) {\n-            JarEntry jarEntry = new JarEntry(entry);\n-            if (manifest != null) {\n-                jarEntry.attr = manifest.getAttributes(name);\n-                // XXX jarEntry.certs\n-            }\n-            return jarEntry;\n-        }\n-        return null;\n+    public boolean hasMoreElements()\n+    {\n+      return entries.hasMoreElements();\n     }\n \n-    /**\n-     * XXX should verify the inputstream\n-     * @param entry XXX\n-     * @exception ZipException XXX\n-     * @exception IOException XXX\n-     */\n-    public synchronized InputStream getInputStream(ZipEntry entry) throws\n-                                                                ZipException,\n-                                                                IOException {\n-        return super.getInputStream(entry); // XXX verify\n+    public Object nextElement()\n+    {\n+      ZipEntry zip = (ZipEntry) entries.nextElement();\n+      JarEntry jar = new JarEntry(zip);\n+      if (manifest != null)\n+\t{\n+\t  jar.attr = manifest.getAttributes(jar.getName());\n+\t}\n+      // XXX jar.certs\n+      return jar;\n     }\n+  }\n \n-    /**\n-     * Returns the JarEntry that belongs to the name if such an entry\n-     * exists in the JarFile. Returns null otherwise\n-     * Convenience method that just casts the result from <code>getEntry</code>\n-     * to a JarEntry.\n-     *\n-     * @param name the jar entry name to look up\n-     * @return the JarEntry if it exists, null otherwise\n-     */\n-    public JarEntry getJarEntry(String name) {\n-        return (JarEntry)getEntry(name);\n-    }\n+  /**\n+   * XXX\n+   * It actually returns a JarEntry not a zipEntry\n+   * @param name XXX\n+   */\n+  public ZipEntry getEntry(String name)\n+  {\n+    ZipEntry entry = super.getEntry(name);\n+    if (entry != null)\n+      {\n+\tJarEntry jarEntry = new JarEntry(entry);\n+\tif (manifest != null)\n+\t  {\n+\t    jarEntry.attr = manifest.getAttributes(name);\n+\t    // XXX jarEntry.certs\n+\t  }\n+\treturn jarEntry;\n+      }\n+    return null;\n+  }\n \n-    /**\n-     * Returns the manifest for this JarFile or null when the JarFile does not\n-     * contain a manifest file.\n-     */\n-    public Manifest getManifest() {\n-        return manifest;\n-    }\n+  /**\n+   * XXX should verify the inputstream\n+   * @param entry XXX\n+   * @exception ZipException XXX\n+   * @exception IOException XXX\n+   */\n+  public synchronized InputStream getInputStream(ZipEntry entry) throws\n+    ZipException, IOException\n+  {\n+    return super.getInputStream(entry);\t// XXX verify\n+  }\n+\n+  /**\n+   * Returns the JarEntry that belongs to the name if such an entry\n+   * exists in the JarFile. Returns null otherwise\n+   * Convenience method that just casts the result from <code>getEntry</code>\n+   * to a JarEntry.\n+   *\n+   * @param name the jar entry name to look up\n+   * @return the JarEntry if it exists, null otherwise\n+   */\n+  public JarEntry getJarEntry(String name)\n+  {\n+    return (JarEntry) getEntry(name);\n+  }\n+\n+  /**\n+   * Returns the manifest for this JarFile or null when the JarFile does not\n+   * contain a manifest file.\n+   */\n+  public Manifest getManifest()\n+  {\n+    return manifest;\n+  }\n }"}, {"sha": "c63758e4daf5b19831ff3e6059972ca762fec01f", "filename": "libjava/java/util/jar/JarInputStream.java", "status": "modified", "additions": 149, "deletions": 134, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarInputStream.java?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,137 +39,152 @@\n  * @since 1.2\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n- \n-public class JarInputStream extends ZipInputStream {\n-\n-    // Fields\n-\n-    /** The manifest for this file or null when there was no manifest. */\n-    private Manifest manifest;\n-\n-    /** The first real JarEntry for this file. Used by readManifest() to store\n-        an entry that isn't the manifest but that should be returned by\n-        getNextEntry next time it is called. Null when no firstEntry was read\n-        while searching for the manifest entry, or when it has already been\n-        returned by getNextEntry(). */\n-    private JarEntry firstEntry;\n-\n-    // Constructors\n-\n-    /**\n-     * Creates a new JarInputStream and tries to read the manifest.\n-     * If such a manifest is present the JarInputStream tries to verify all\n-     * the entry signatures while reading.\n-     *\n-     * @param in InputStream to read the jar from\n-     * @exception IOException when an error occurs when opening or reading\n-     */\n-    public JarInputStream(InputStream in) throws IOException {\n-        this(in, true);\n-    }\n-\n-    /**\n-     * Creates a new JarInputStream and tries to read the manifest.\n-     * If such a manifest is present and verify is true, the JarInputStream\n-     * tries to verify all the entry signatures while reading.\n-     *\n-     * @param in InputStream to read the jar from\n-     * @param verify wheter or not to verify the manifest entries\n-     * @exception IOException when an error occurs when opening or reading\n-     */\n-    public JarInputStream(InputStream in, boolean verify) throws IOException {\n-        super(in);\n-        readManifest(verify);\n-    }\n-\n-    // Methods\n-\n-    /**\n-     * Set the manifest if found. Skips all entries that start with \"META-INF/\"\n-     *\n-     * @param verify when true (and a Manifest is found) checks the Manifest,\n-     * when false no check is performed\n-     * @exception IOException if an error occurs while reading\n-     */\n-    private void readManifest(boolean verify) throws IOException {\n-        firstEntry = (JarEntry) super.getNextEntry();\n-        while ((firstEntry != null) &&\n-               firstEntry.getName().startsWith(\"META-INF/\")) {\n-            if(firstEntry.getName().equals(JarFile.MANIFEST_NAME)) {\n-                manifest = new Manifest(this);\n-            }\n-            firstEntry = (JarEntry) super.getNextEntry();\n-        }\n-        closeEntry();\n-\n-        if (verify) {\n-            // XXX\n-        }\n-    }\n-\n-    /**\n-     * Creates a JarEntry for a particular name and consults the manifest\n-     * for the Attributes of the entry.\n-     * Used by <code>ZipEntry.getNextEntry()</code>\n-     *\n-     * @param name the name of the new entry\n-     */\n-    protected ZipEntry createZipEntry(String name) {\n-        ZipEntry zipEntry = super.createZipEntry(name);\n-        JarEntry jarEntry = new JarEntry(zipEntry);\n-        if (manifest != null) {\n-            jarEntry.attr = manifest.getAttributes(name);\n-        }\n-        return jarEntry;\n-    }\n-    \n-    /**\n-     * Returns the Manifest for the jar file or null if there was no Manifest.\n-     */\n-    public Manifest getManifest() {\n-        return manifest;\n-    }\n-\n-    /**\n-     * Returns the next entry or null when there are no more entries.\n-     * Does actually return a JarEntry, if you don't want to cast it yourself\n-     * use <code>getNextJarEntry()</code>. Does not return any entries found\n-     * at the beginning of the ZipFile that are special\n-     * (those that start with \"META-INF/\").\n-     *\n-     * @exception IOException if an IO error occurs when reading the entry\n-     */\n-    public ZipEntry getNextEntry() throws IOException {\n-        ZipEntry entry;\n-        if (firstEntry != null) {\n-            entry = firstEntry;\n-            firstEntry = null;\n-        } else {\n-            entry = super.getNextEntry();\n-        }\n-        return entry;\n-    }\n-\n-    /**\n-     * Returns the next jar entry or null when there are no more entries.\n-     *\n-     * @exception IOException if an IO error occurs when reading the entry\n-     */\n-    public JarEntry getNextJarEntry() throws IOException {\n-        return (JarEntry)getNextEntry();\n-    }\n-\n-    /**\n-     * XXX\n-     *\n-     * @param buf XXX\n-     * @param off XXX\n-     * @param len XXX\n-     * @return XXX\n-     * @exception IOException XXX\n-     */\n-    public int read(byte[] buf, int off, int len) throws IOException {\n-        // XXX if (verify) {}\n-        return super.read(buf, off, len);\n-    }\n+\n+public class JarInputStream extends ZipInputStream\n+{\n+  // Fields\n+\n+  /** The manifest for this file or null when there was no manifest. */\n+  private Manifest manifest;\n+\n+  /** The first real JarEntry for this file. Used by readManifest() to store\n+     an entry that isn't the manifest but that should be returned by\n+     getNextEntry next time it is called. Null when no firstEntry was read\n+     while searching for the manifest entry, or when it has already been\n+     returned by getNextEntry(). */\n+  private JarEntry firstEntry;\n+\n+  // Constructors\n+\n+  /**\n+   * Creates a new JarInputStream and tries to read the manifest.\n+   * If such a manifest is present the JarInputStream tries to verify all\n+   * the entry signatures while reading.\n+   *\n+   * @param in InputStream to read the jar from\n+   * @exception IOException when an error occurs when opening or reading\n+   */\n+  public JarInputStream(InputStream in) throws IOException\n+  {\n+    this(in, true);\n+  }\n+\n+  /**\n+   * Creates a new JarInputStream and tries to read the manifest.\n+   * If such a manifest is present and verify is true, the JarInputStream\n+   * tries to verify all the entry signatures while reading.\n+   *\n+   * @param in InputStream to read the jar from\n+   * @param verify wheter or not to verify the manifest entries\n+   * @exception IOException when an error occurs when opening or reading\n+   */\n+  public JarInputStream(InputStream in, boolean verify) throws IOException\n+  {\n+    super(in);\n+    readManifest(verify);\n+  }\n+\n+  // Methods\n+\n+  /**\n+   * Set the manifest if found. Skips all entries that start with \"META-INF/\"\n+   *\n+   * @param verify when true (and a Manifest is found) checks the Manifest,\n+   * when false no check is performed\n+   * @exception IOException if an error occurs while reading\n+   */\n+  private void readManifest(boolean verify) throws IOException\n+  {\n+    firstEntry = (JarEntry) super.getNextEntry();\n+    while ((firstEntry != null) &&\n+\t   firstEntry.getName().startsWith(\"META-INF/\"))\n+      {\n+\tif (firstEntry.getName().equals(JarFile.MANIFEST_NAME))\n+\t  {\n+\t    manifest = new Manifest(this);\n+\t  }\n+\tfirstEntry = (JarEntry) super.getNextEntry();\n+      }\n+    closeEntry();\n+\n+    if (verify)\n+      {\n+\t// XXX\n+      }\n+  }\n+\n+  /**\n+   * Creates a JarEntry for a particular name and consults the manifest\n+   * for the Attributes of the entry.\n+   * Used by <code>ZipEntry.getNextEntry()</code>\n+   *\n+   * @param name the name of the new entry\n+   */\n+  protected ZipEntry createZipEntry(String name)\n+  {\n+    ZipEntry zipEntry = super.createZipEntry(name);\n+    JarEntry jarEntry = new JarEntry(zipEntry);\n+    if (manifest != null)\n+      {\n+\tjarEntry.attr = manifest.getAttributes(name);\n+      }\n+    return jarEntry;\n+  }\n+\n+  /**\n+   * Returns the Manifest for the jar file or null if there was no Manifest.\n+   */\n+  public Manifest getManifest()\n+  {\n+    return manifest;\n+  }\n+\n+  /**\n+   * Returns the next entry or null when there are no more entries.\n+   * Does actually return a JarEntry, if you don't want to cast it yourself\n+   * use <code>getNextJarEntry()</code>. Does not return any entries found\n+   * at the beginning of the ZipFile that are special\n+   * (those that start with \"META-INF/\").\n+   *\n+   * @exception IOException if an IO error occurs when reading the entry\n+   */\n+  public ZipEntry getNextEntry() throws IOException\n+  {\n+    ZipEntry entry;\n+    if (firstEntry != null)\n+      {\n+\tentry = firstEntry;\n+\tfirstEntry = null;\n+      }\n+    else\n+      {\n+\tentry = super.getNextEntry();\n+      }\n+    return entry;\n+  }\n+\n+  /**\n+   * Returns the next jar entry or null when there are no more entries.\n+   *\n+   * @exception IOException if an IO error occurs when reading the entry\n+   */\n+  public JarEntry getNextJarEntry() throws IOException\n+  {\n+    return (JarEntry) getNextEntry();\n+  }\n+\n+  /**\n+   * XXX\n+   *\n+   * @param buf XXX\n+   * @param off XXX\n+   * @param len XXX\n+   * @return XXX\n+   * @exception IOException XXX\n+   */\n+  public int read(byte[]buf, int off, int len) throws IOException\n+  {\n+    // XXX if (verify) {}\n+    return super.read(buf, off, len);\n+  }\n }"}, {"sha": "ca7729df02e706a507a4e705e68a8cb5413cdfb9", "filename": "libjava/java/util/jar/JarOutputStream.java", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FJarOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarOutputStream.java?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -38,61 +38,65 @@\n  *\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n- \n-public class JarOutputStream extends ZipOutputStream {\n \n-    // Constructors\n+public class JarOutputStream extends ZipOutputStream\n+{\n+  // Constructors\n \n-    /**\n-     * Creates a new JarOutputStream without a manifest entry.\n-     *\n-     * @param out the stream to create the new jar on\n-     * @exception IOException if something unexpected happend\n-     */\n-    public JarOutputStream(OutputStream out) throws IOException {\n-        this(out, null);\n-    }\n+  /**\n+   * Creates a new JarOutputStream without a manifest entry.\n+   *\n+   * @param out the stream to create the new jar on\n+   * @exception IOException if something unexpected happend\n+   */\n+  public JarOutputStream(OutputStream out) throws IOException\n+  {\n+    this(out, null);\n+  }\n \n-    /**\n-     * Creates a new JarOutputStream with a manifest entry.\n-     * The manifest will be the first entry in the jar.\n-     *\n-     * @param out the stream to create the new jar on\n-     * @param man the manifest that should be put in the jar file or null\n-     * for no manifest entry\n-     * @exception IOException if something unexpected happend\n-     */\n-    public JarOutputStream(OutputStream out, Manifest man) throws IOException {\n-        super(out);\n-        if (man != null)\n-            writeManifest(man);\n-    }\n+  /**\n+   * Creates a new JarOutputStream with a manifest entry.\n+   * The manifest will be the first entry in the jar.\n+   *\n+   * @param out the stream to create the new jar on\n+   * @param man the manifest that should be put in the jar file or null\n+   * for no manifest entry\n+   * @exception IOException if something unexpected happend\n+   */\n+  public JarOutputStream(OutputStream out, Manifest man) throws IOException\n+  {\n+    super(out);\n+    if (man != null)\n+      writeManifest(man);\n+  }\n \n-    // Methods\n+  // Methods\n \n-    /**\n-     * Writes the manifest to a new JarEntry in this JarOutputStream with as\n-     * name JarFile.MANIFEST_NAME.\n-     *\n-     * @param manifest the non null manifest to be written\n-     * @exception IOException if something unexpected happend\n-     */\n-    private void writeManifest(Manifest manifest) throws IOException {\n-        // Create a new Jar Entry for the Manifest\n-        JarEntry entry = new JarEntry(JarFile.MANIFEST_NAME);\n-        putNextEntry(entry);\n-        manifest.write(this);\n-        closeEntry();\n-    }\n+  /**\n+   * Writes the manifest to a new JarEntry in this JarOutputStream with as\n+   * name JarFile.MANIFEST_NAME.\n+   *\n+   * @param manifest the non null manifest to be written\n+   * @exception IOException if something unexpected happend\n+   */\n+  private void writeManifest(Manifest manifest) throws IOException\n+  {\n+    // Create a new Jar Entry for the Manifest\n+    JarEntry entry = new JarEntry(JarFile.MANIFEST_NAME);\n+    putNextEntry(entry);\n+    manifest.write(this);\n+    closeEntry();\n+  }\n \n-    /**\n-     * Prepares the JarOutputStream for writing the next entry. \n-     * This implementation just calls <code>super.putNextEntre()</code>.\n-     *\n-     * @param entry The information for the next entry\n-     * @exception IOException when some unexpected I/O exception occured\n-     */\n-    public void putNextEntry(ZipEntry entry) throws IOException {\n-        super.putNextEntry(entry); // XXX\n-    }\n+  /**\n+   * Prepares the JarOutputStream for writing the next entry. \n+   * This implementation just calls <code>super.putNextEntre()</code>.\n+   *\n+   * @param entry The information for the next entry\n+   * @exception IOException when some unexpected I/O exception occured\n+   */\n+  public void putNextEntry(ZipEntry entry) throws IOException\n+  {\n+    super.putNextEntry(entry);\t// XXX\n+  }\n }"}, {"sha": "833ac26540df750f5cbca23ca8932182bb16c91b", "filename": "libjava/java/util/jar/Manifest.java", "status": "modified", "additions": 404, "deletions": 355, "changes": 759, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FManifest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4/libjava%2Fjava%2Futil%2Fjar%2FManifest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FManifest.java?ref=c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -48,359 +48,408 @@\n  * @since 1.2\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n-public class Manifest implements Cloneable {\n-\n-    // Fields\n-\n-    /** The main attributes of the manifest (jar file). */\n-    private final Attributes mainAttr;\n-\n-    /** A map of atrributes for all entries described in this Manifest. */\n-    private final Map entries;\n-\n-    // Constructors\n-\n-    /**\n-     * Creates a new empty Manifest.\n-     */\n-    public Manifest() {\n-        mainAttr = new Attributes();\n-        entries = new Hashtable();\n-    }\n-\n-    /**\n-     * Creates a Manifest from the supplied input stream.\n-     *\n-     * @see read(Inputstream)\n-     * @see write(OutputStream)\n-     *\n-     * @param InputStream the input stream to read the manifest from\n-     * @exception IOException when an i/o exception occurs or the input stream\n-     * does not describe a valid manifest\n-     */\n-    public Manifest(InputStream in) throws IOException {\n-        this();\n-        read(in);\n-    }\n-\n-    /**\n-     * Creates a Manifest from another Manifest.\n-     * Makes a deep copy of the main attributes, but a shallow copy of\n-     * the other entries. This means that you can freely add, change or remove\n-     * the main attributes or the entries of the new manifest without effecting\n-     * the original manifest, but adding, changing or removing attributes from\n-     * a particular entry also changes the attributes of that entry in the\n-     * original manifest.\n-     *\n-     * @see clone()\n-     * @param man the Manifest to copy from\n-     */\n-    public Manifest (Manifest man) {\n-        mainAttr = new Attributes(man.getMainAttributes());\n-        entries = new Hashtable(man.getEntries());\n-    }\n-\n-    // Methods\n-\n-    /**\n-     * Gets the main attributes of this Manifest.\n-     */\n-    public Attributes getMainAttributes() {\n-        return mainAttr;\n-    }\n-\n-    /**\n-     * Gets a map of entry Strings to Attributes for all the entries described\n-     * in this manifest. Adding, changing or removing from this entries map\n-     * changes the entries of this manifest.\n-     */\n-    public Map getEntries() {\n-        return entries;\n-    }\n-\n-    /**\n-     * Returns the Attributes associated with the Entry.\n-     * <p>\n-     * Implemented as:\n-     * <code>return (Attributes)getEntries().get(entryName)</code>\n-     *\n-     * @param entryName the name of the entry to look up\n-     * @return the attributes associated with the entry or null when none\n-     */\n-    public Attributes getAttributes(String entryName) {\n-        return (Attributes)getEntries().get(entryName);\n-    }\n-\n-    /**\n-     * Clears the main attributes and removes all the entries from the\n-     * manifest.\n-     */\n-    public void clear() {\n-        mainAttr.clear();\n-        entries.clear();\n-    }\n-\n-    /**\n-     * XXX\n-     */\n-    public void read(InputStream in) throws IOException {\n-        BufferedReader br = new BufferedReader(\n-                                new InputStreamReader(in, \"8859_1\"));\n-        read_main_section(getMainAttributes(), br);\n-        read_individual_sections(getEntries(), br);\n-    }\n-\n-    // Private Static methods for reading the Manifest file from BufferedReader\n-\n-    private static void read_main_section(Attributes attr,\n-                                          BufferedReader br) throws\n-                                                             IOException {\n-        read_version_info(attr, br);\n-        read_attributes(attr, br);\n-    }\n-\n-    private static void read_version_info(Attributes attr,\n-                                          BufferedReader br) throws\n-                                                             IOException {\n-        String version_header = Attributes.Name.MANIFEST_VERSION.toString();\n-        try {\n-            String value = expect_header(version_header, br);\n-            attr.putValue(version_header, value);\n-        } catch (IOException ioe) {\n-            throw new JarException(\n-                            \"Manifest should start with a \" + version_header\n-                            + \": \" + ioe.getMessage());\n-        }\n-    }\n-\n-    private static String expect_header(String header, BufferedReader br)\n-        throws IOException {\n-\n-        String s = br.readLine();\n-        if (s == null) {\n-            throw new JarException(\"unexpected end of file\");\n-        }\n-        return expect_header(header, br, s);\n-    }\n-\n-    private static String expect_header(String header, BufferedReader br,\n-                                        String s) throws IOException {\n-        try {\n-            String name = s.substring(0, header.length() + 1);\n-            if (name.equalsIgnoreCase(header + \":\")) {\n-                String value_start = s.substring(header.length() + 2);\n-                return read_header_value(value_start, br);\n-            }\n-        } catch (IndexOutOfBoundsException iobe) {}\n-        // If we arrive here, something went wrong\n-        throw new JarException(\"unexpected '\" + s + \"'\");\n-    }\n-\n-    private static String read_header_value(String s, BufferedReader br)\n-                                                        throws IOException {\n-        boolean try_next = true;\n-        while (try_next) {\n-            // Lets see if there is something on the next line\n-            br.mark(1);\n-            if (br.read() == ' ') {\n-                s += br.readLine();\n-            } else {\n-                br.reset();\n-                try_next = false;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    private static void read_attributes(Attributes attr,\n-                                        BufferedReader br) throws\n-                                                           IOException {\n-        String s = br.readLine();\n-        while (s != null && (!s.equals(\"\"))) {\n-            read_attribute(attr, s, br);\n-            s = br.readLine();\n-        }\n-    }\n-\n-    private static void read_attribute(Attributes attr, String s,\n-                                       BufferedReader br) throws IOException {\n-        try {\n-            int colon = s.indexOf(\": \");\n-            String name = s.substring(0, colon);\n-            String value_start = s.substring(colon+2);\n-            String value = read_header_value(value_start, br);\n-            attr.putValue(name, value);\n-        } catch (IndexOutOfBoundsException iobe) {\n-            throw new JarException(\n-                            \"Manifest contains a bad header: \" + s);\n-        }\n-    }\n-\n-    private static void read_individual_sections(Map entries,\n-                                                 BufferedReader br) throws\n-                                                                IOException {\n-        String s = br.readLine();\n-        while (s != null && (!s.equals(\"\"))) {\n-            Attributes attr = read_section_name(s, br, entries);\n-            read_attributes(attr, br);\n-            s = br.readLine();\n-        }\n-    }\n-\n-    private static Attributes read_section_name(String s, BufferedReader br,\n-                                                Map entries) throws\n-                                                                JarException {\n-        try {\n-            String name = expect_header(\"Name\", br, s);\n-            Attributes attr = new Attributes();\n-            entries.put(name, attr);\n-            return attr;\n-        } catch(IOException ioe) {\n-            throw new JarException\n-                (\"Section should start with a Name header: \"\n-                 + ioe.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * XXX\n-     */\n-    public void write(OutputStream out) throws IOException {\n-        PrintWriter pw = new PrintWriter(\n-                            new BufferedWriter(\n-                                new OutputStreamWriter(out, \"8859_1\")));\n-        write_main_section(getMainAttributes(), pw);\n-        pw.println();\n-        write_individual_sections(getEntries(), pw);\n-        if (pw.checkError()) {\n-            throw new JarException(\"Error while writing manifest\");\n-        }\n-    }\n-\n-    // Private Static functions for writing the Manifest file to a PrintWriter\n-\n-    private static void write_main_section(Attributes attr,\n-                                           PrintWriter pw)\n-        throws JarException {\n-\n-        write_version_info(attr, pw);\n-        write_main_attributes(attr, pw);\n-    }\n-\n-    private static void write_version_info(Attributes attr, PrintWriter pw) {\n-        // First check if there is already a version attribute set\n-        String version = attr.getValue(Attributes.Name.MANIFEST_VERSION);\n-        if (version == null) {\n-            version = \"1.0\";\n-        }\n-        write_header(Attributes.Name.MANIFEST_VERSION.toString(), version, pw);\n-    }\n-\n-    private static void write_header(String name, String value,\n-                                     PrintWriter pw) {\n-        pw.print(name + \": \");\n-\n-        int last = 68 - name.length();\n-        if (last > value.length()) {\n-            pw.println(value);\n-        } else {\n-            pw.println(value.substring(0, last));\n-        }\n-        while (last < value.length()) {\n-            pw.print(\" \");\n-            int end = (last + 69);\n-            if (end > value.length()) {\n-                pw.println(value.substring(last));\n-            } else {\n-                pw.println(value.substring(last, end));\n-            }\n-            last = end;\n-        }\n-    }\n-\n-    private static void write_main_attributes(Attributes attr,\n-                                              PrintWriter pw) throws\n-                                                              JarException {\n-        Iterator it = attr.entrySet().iterator();\n-        while(it.hasNext()) {\n-            Map.Entry entry = (Map.Entry)it.next();\n-            // Don't print the manifest version again\n-            if (!Attributes.Name.MANIFEST_VERSION.equals(entry.getKey())) {\n-                write_attribute_entry(entry, pw);\n-            }\n-        }\n-    }\n-\n-    private static void write_attribute_entry(Map.Entry entry,\n-                                              PrintWriter pw) throws\n-                                                              JarException {\n-        String name = entry.getKey().toString();\n-        String value = entry.getValue().toString();\n-\n-        if (name.equalsIgnoreCase(\"Name\")) {\n-            throw new JarException(\"Attributes cannot be called 'Name'\");\n-        }\n-        if (name.startsWith(\"From\")) {\n-            throw new JarException(\n-                        \"Header cannot start with the four letters 'From'\"\n-                        + name);\n-        }\n-        write_header(name, value, pw);\n-    }\n-\n-    private static void write_individual_sections(Map entries,\n-                                                  PrintWriter pw)\n-        throws JarException {\n-\n-        Iterator it = entries.entrySet().iterator();\n-        while (it.hasNext()) {\n-            Map.Entry entry = (Map.Entry)it.next();\n-            write_header(\"Name\", entry.getKey().toString(), pw);\n-            write_entry_attributes((Attributes)entry.getValue(), pw);\n-            pw.println();\n-        }\n-    }\n-\n-    private static void write_entry_attributes(Attributes attr,\n-                                               PrintWriter pw) throws\n-                                                               JarException {\n-        Iterator it = attr.entrySet().iterator();\n-        while(it.hasNext()) {\n-            Map.Entry entry = (Map.Entry)it.next();\n-            write_attribute_entry(entry, pw);\n-        }\n-    }\n-\n-    /**\n-     * Makes a deep copy of the main attributes, but a shallow copy of\n-     * the other entries. This means that you can freely add, change or remove\n-     * the main attributes or the entries of the new manifest without effecting\n-     * the original manifest, but adding, changing or removing attributes from\n-     * a particular entry also changes the attributes of that entry in the\n-     * original manifest. Calls <CODE>new Manifest(this)</CODE>.\n-     */\n-    public Object clone() {\n-        return new Manifest(this);\n-    }\n-\n-    /**\n-     * Checks if another object is equal to this Manifest object.\n-     * Another Object is equal to this Manifest object if it is an instance of\n-     * Manifest and the main attributes and the entries of the other manifest\n-     * are equal to this one.\n-     */\n-    public boolean equals(Object o) {\n-        return (o instanceof Manifest) &&\n-               (mainAttr.equals(((Manifest)o).mainAttr)) &&\n-               (entries.equals(((Manifest)o).entries));\n-    }\n-\n-    /**\n-     * Calculates the hash code of the manifest. Implemented by a xor of the\n-     * hash code of the main attributes with the hash code of the entries map.\n-     */\n-    public int hashCode() {\n-        return mainAttr.hashCode() ^ entries.hashCode();\n-    }\n+public class Manifest implements Cloneable\n+{\n+  // Fields\n+\n+  /** The main attributes of the manifest (jar file). */\n+  private final Attributes mainAttr;\n+\n+  /** A map of atrributes for all entries described in this Manifest. */\n+  private final Map entries;\n+\n+  // Constructors\n+\n+  /**\n+   * Creates a new empty Manifest.\n+   */\n+  public Manifest()\n+  {\n+    mainAttr = new Attributes();\n+    entries = new Hashtable();\n+  }\n+\n+  /**\n+   * Creates a Manifest from the supplied input stream.\n+   *\n+   * @see read(Inputstream)\n+   * @see write(OutputStream)\n+   *\n+   * @param InputStream the input stream to read the manifest from\n+   * @exception IOException when an i/o exception occurs or the input stream\n+   * does not describe a valid manifest\n+   */\n+  public Manifest(InputStream in) throws IOException\n+  {\n+    this();\n+    read(in);\n+  }\n+\n+  /**\n+   * Creates a Manifest from another Manifest.\n+   * Makes a deep copy of the main attributes, but a shallow copy of\n+   * the other entries. This means that you can freely add, change or remove\n+   * the main attributes or the entries of the new manifest without effecting\n+   * the original manifest, but adding, changing or removing attributes from\n+   * a particular entry also changes the attributes of that entry in the\n+   * original manifest.\n+   *\n+   * @see clone()\n+   * @param man the Manifest to copy from\n+   */\n+  public Manifest(Manifest man)\n+  {\n+    mainAttr = new Attributes(man.getMainAttributes());\n+    entries = new Hashtable(man.getEntries());\n+  }\n+\n+  // Methods\n+\n+  /**\n+   * Gets the main attributes of this Manifest.\n+   */\n+  public Attributes getMainAttributes()\n+  {\n+    return mainAttr;\n+  }\n+\n+  /**\n+   * Gets a map of entry Strings to Attributes for all the entries described\n+   * in this manifest. Adding, changing or removing from this entries map\n+   * changes the entries of this manifest.\n+   */\n+  public Map getEntries()\n+  {\n+    return entries;\n+  }\n+\n+  /**\n+   * Returns the Attributes associated with the Entry.\n+   * <p>\n+   * Implemented as:\n+   * <code>return (Attributes)getEntries().get(entryName)</code>\n+   *\n+   * @param entryName the name of the entry to look up\n+   * @return the attributes associated with the entry or null when none\n+   */\n+  public Attributes getAttributes(String entryName)\n+  {\n+    return (Attributes) getEntries().get(entryName);\n+  }\n+\n+  /**\n+   * Clears the main attributes and removes all the entries from the\n+   * manifest.\n+   */\n+  public void clear()\n+  {\n+    mainAttr.clear();\n+    entries.clear();\n+  }\n+\n+  /**\n+   * XXX\n+   */\n+  public void read(InputStream in) throws IOException\n+  {\n+    BufferedReader br =\n+      new BufferedReader(new InputStreamReader(in, \"8859_1\"));\n+    read_main_section(getMainAttributes(), br);\n+    read_individual_sections(getEntries(), br);\n+  }\n+\n+  // Private Static methods for reading the Manifest file from BufferedReader\n+\n+  private static void read_main_section(Attributes attr,\n+\t\t\t\t\tBufferedReader br) throws IOException\n+  {\n+    read_version_info(attr, br);\n+    read_attributes(attr, br);\n+  }\n+\n+  private static void read_version_info(Attributes attr,\n+\t\t\t\t\tBufferedReader br) throws IOException\n+  {\n+    String version_header = Attributes.Name.MANIFEST_VERSION.toString();\n+    try\n+      {\n+\tString value = expect_header(version_header, br);\n+\tattr.putValue(version_header, value);\n+      }\n+    catch (IOException ioe)\n+      {\n+\tthrow new JarException(\"Manifest should start with a \" +\n+\t\t\t       version_header + \": \" + ioe.getMessage());\n+      }\n+  }\n+\n+  private static String expect_header(String header, BufferedReader br)\n+    throws IOException\n+  {\n+    String s = br.readLine();\n+    if (s == null)\n+      {\n+\tthrow new JarException(\"unexpected end of file\");\n+      }\n+    return expect_header(header, br, s);\n+  }\n+\n+  private static String expect_header(String header, BufferedReader br,\n+\t\t\t\t      String s) throws IOException\n+  {\n+    try\n+      {\n+\tString name = s.substring(0, header.length() + 1);\n+\tif (name.equalsIgnoreCase(header + \":\"))\n+\t  {\n+\t    String value_start = s.substring(header.length() + 2);\n+\t    return read_header_value(value_start, br);\n+\t  }\n+      }\n+    catch (IndexOutOfBoundsException iobe)\n+      {\n+      }\n+    // If we arrive here, something went wrong\n+    throw new JarException(\"unexpected '\" + s + \"'\");\n+  }\n+\n+  private static String read_header_value(String s, BufferedReader br)\n+    throws IOException\n+  {\n+    boolean try_next = true;\n+    while (try_next)\n+      {\n+\t// Lets see if there is something on the next line\n+\tbr.mark(1);\n+\tif (br.read() == ' ')\n+\t  {\n+\t    s += br.readLine();\n+\t  }\n+\telse\n+\t  {\n+\t    br.reset();\n+\t    try_next = false;\n+\t  }\n+      }\n+    return s;\n+  }\n+\n+  private static void read_attributes(Attributes attr,\n+\t\t\t\t      BufferedReader br) throws IOException\n+  {\n+    String s = br.readLine();\n+    while (s != null && (!s.equals(\"\")))\n+      {\n+\tread_attribute(attr, s, br);\n+\ts = br.readLine();\n+      }\n+  }\n+\n+  private static void read_attribute(Attributes attr, String s,\n+\t\t\t\t     BufferedReader br) throws IOException\n+  {\n+    try\n+      {\n+\tint colon = s.indexOf(\": \");\n+\tString name = s.substring(0, colon);\n+\tString value_start = s.substring(colon + 2);\n+\tString value = read_header_value(value_start, br);\n+\tattr.putValue(name, value);\n+      }\n+    catch (IndexOutOfBoundsException iobe)\n+      {\n+\tthrow new JarException(\"Manifest contains a bad header: \" + s);\n+      }\n+  }\n+\n+  private static void read_individual_sections(Map entries,\n+\t\t\t\t\t       BufferedReader br) throws\n+    IOException\n+  {\n+    String s = br.readLine();\n+    while (s != null && (!s.equals(\"\")))\n+      {\n+\tAttributes attr = read_section_name(s, br, entries);\n+\tread_attributes(attr, br);\n+\ts = br.readLine();\n+      }\n+  }\n+\n+  private static Attributes read_section_name(String s, BufferedReader br,\n+\t\t\t\t\t      Map entries) throws JarException\n+  {\n+    try\n+      {\n+\tString name = expect_header(\"Name\", br, s);\n+\tAttributes attr = new Attributes();\n+\tentries.put(name, attr);\n+\treturn attr;\n+      }\n+    catch (IOException ioe)\n+      {\n+\tthrow new JarException\n+\t  (\"Section should start with a Name header: \" + ioe.getMessage());\n+      }\n+  }\n+\n+  /**\n+   * XXX\n+   */\n+  public void write(OutputStream out) throws IOException\n+  {\n+    PrintWriter pw =\n+      new PrintWriter(new\n+\t\t      BufferedWriter(new OutputStreamWriter(out, \"8859_1\")));\n+    write_main_section(getMainAttributes(), pw);\n+    pw.println();\n+    write_individual_sections(getEntries(), pw);\n+    if (pw.checkError())\n+      {\n+\tthrow new JarException(\"Error while writing manifest\");\n+      }\n+  }\n+\n+  // Private Static functions for writing the Manifest file to a PrintWriter\n+\n+  private static void write_main_section(Attributes attr,\n+\t\t\t\t\t PrintWriter pw) throws JarException\n+  {\n+    write_version_info(attr, pw);\n+    write_main_attributes(attr, pw);\n+  }\n+\n+  private static void write_version_info(Attributes attr, PrintWriter pw)\n+  {\n+    // First check if there is already a version attribute set\n+    String version = attr.getValue(Attributes.Name.MANIFEST_VERSION);\n+    if (version == null)\n+      {\n+\tversion = \"1.0\";\n+      }\n+    write_header(Attributes.Name.MANIFEST_VERSION.toString(), version, pw);\n+  }\n+\n+  private static void write_header(String name, String value, PrintWriter pw)\n+  {\n+    pw.print(name + \": \");\n+\n+    int last = 68 - name.length();\n+    if (last > value.length())\n+      {\n+\tpw.println(value);\n+      }\n+    else\n+      {\n+\tpw.println(value.substring(0, last));\n+      }\n+    while (last < value.length())\n+      {\n+\tpw.print(\" \");\n+\tint end = (last + 69);\n+\tif (end > value.length())\n+\t  {\n+\t    pw.println(value.substring(last));\n+\t  }\n+\telse\n+\t  {\n+\t    pw.println(value.substring(last, end));\n+\t  }\n+\tlast = end;\n+      }\n+  }\n+\n+  private static void write_main_attributes(Attributes attr, PrintWriter pw) \n+    throws JarException\n+  {\n+    Iterator it = attr.entrySet().iterator();\n+    while (it.hasNext())\n+      {\n+\tMap.Entry entry = (Map.Entry) it.next();\n+\t// Don't print the manifest version again\n+\tif (!Attributes.Name.MANIFEST_VERSION.equals(entry.getKey()))\n+\t  {\n+\t    write_attribute_entry(entry, pw);\n+\t  }\n+      }\n+  }\n+\n+  private static void write_attribute_entry(Map.Entry entry, PrintWriter pw) \n+    throws JarException\n+  {\n+    String name = entry.getKey().toString();\n+    String value = entry.getValue().toString();\n+\n+    if (name.equalsIgnoreCase(\"Name\"))\n+      {\n+\tthrow new JarException(\"Attributes cannot be called 'Name'\");\n+      }\n+    if (name.startsWith(\"From\"))\n+      {\n+\tthrow new\n+\t  JarException(\"Header cannot start with the four letters 'From'\" +\n+\t\t       name);\n+      }\n+    write_header(name, value, pw);\n+  }\n+\n+  private static void write_individual_sections(Map entries, PrintWriter pw)\n+    throws JarException\n+  {\n+\n+    Iterator it = entries.entrySet().iterator();\n+    while (it.hasNext())\n+      {\n+\tMap.Entry entry = (Map.Entry) it.next();\n+\twrite_header(\"Name\", entry.getKey().toString(), pw);\n+\twrite_entry_attributes((Attributes) entry.getValue(), pw);\n+\tpw.println();\n+      }\n+  }\n+\n+  private static void write_entry_attributes(Attributes attr, PrintWriter pw) \n+    throws JarException\n+  {\n+    Iterator it = attr.entrySet().iterator();\n+    while (it.hasNext())\n+      {\n+\tMap.Entry entry = (Map.Entry) it.next();\n+\twrite_attribute_entry(entry, pw);\n+      }\n+  }\n+\n+  /**\n+   * Makes a deep copy of the main attributes, but a shallow copy of\n+   * the other entries. This means that you can freely add, change or remove\n+   * the main attributes or the entries of the new manifest without effecting\n+   * the original manifest, but adding, changing or removing attributes from\n+   * a particular entry also changes the attributes of that entry in the\n+   * original manifest. Calls <CODE>new Manifest(this)</CODE>.\n+   */\n+  public Object clone()\n+  {\n+    return new Manifest(this);\n+  }\n+\n+  /**\n+   * Checks if another object is equal to this Manifest object.\n+   * Another Object is equal to this Manifest object if it is an instance of\n+   * Manifest and the main attributes and the entries of the other manifest\n+   * are equal to this one.\n+   */\n+  public boolean equals(Object o)\n+  {\n+    return (o instanceof Manifest) &&\n+      (mainAttr.equals(((Manifest) o).mainAttr)) &&\n+      (entries.equals(((Manifest) o).entries));\n+  }\n+\n+  /**\n+   * Calculates the hash code of the manifest. Implemented by a xor of the\n+   * hash code of the main attributes with the hash code of the entries map.\n+   */\n+  public int hashCode()\n+  {\n+    return mainAttr.hashCode() ^ entries.hashCode();\n+  }\n \n }"}]}