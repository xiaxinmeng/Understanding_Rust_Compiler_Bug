{"sha": "169304de7bea9c4f303ec981b889f090366a1538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY5MzA0ZGU3YmVhOWM0ZjMwM2VjOTgxYjg4OWYwOTAzNjZhMTUzOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-04-20T06:10:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-04-20T06:10:13Z"}, "message": "mips.c (mips_legitimize_move): Generate special patterns for mflo and mfhi instructions.\n\n\t* config/mips/mips.c (mips_legitimize_move): Generate special patterns\n\tfor mflo and mfhi instructions.\n\t(mips_output_move): Remove mflo and mfhi handling.\n\t* config/mips/mips.md (UNSPEC_MFHILO): New unspec.\n\t(*mulsidi3_64bit): Update for new mfhi/mflo representation.\n\tLikewise various define_peephole2s.\n\t(*movdi_32bit, *movdi_64bit, *movsi_internal): Merge x<-J and x<-d\n\talternatives.\n\t(*movdi_64bit, *movdi_64bit_mips16, *mov[shq]i_internal)\n\t(*mov[shq]i_mips16): Remove mflo and mfhi alternatives.\n\t(mfhilo_di, mfhilo_si): New patterns.\n\nFrom-SVN: r80883", "tree": {"sha": "c7b2d7cabc7ede1be6cf9f7e3577319e6ba602b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7b2d7cabc7ede1be6cf9f7e3577319e6ba602b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/169304de7bea9c4f303ec981b889f090366a1538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/169304de7bea9c4f303ec981b889f090366a1538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/169304de7bea9c4f303ec981b889f090366a1538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/169304de7bea9c4f303ec981b889f090366a1538/comments", "author": null, "committer": null, "parents": [{"sha": "c6ca23fb140f2842711b96e3104a62ddb94fa024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ca23fb140f2842711b96e3104a62ddb94fa024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6ca23fb140f2842711b96e3104a62ddb94fa024"}], "stats": {"total": 249, "additions": 184, "deletions": 65}, "files": [{"sha": "4742f4dab03737e91f06ddc3a8937a611fefb0f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169304de7bea9c4f303ec981b889f090366a1538/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169304de7bea9c4f303ec981b889f090366a1538/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=169304de7bea9c4f303ec981b889f090366a1538", "patch": "@@ -1,3 +1,17 @@\n+2004-04-20  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_legitimize_move): Generate special patterns\n+\tfor mflo and mfhi instructions.\n+\t(mips_output_move): Remove mflo and mfhi handling.\n+\t* config/mips/mips.md (UNSPEC_MFHILO): New unspec.\n+\t(*mulsidi3_64bit): Update for new mfhi/mflo representation.\n+\tLikewise various define_peephole2s.\n+\t(*movdi_32bit, *movdi_64bit, *movsi_internal): Merge x<-J and x<-d\n+\talternatives.\n+\t(*movdi_64bit, *movdi_64bit_mips16, *mov[shq]i_internal)\n+\t(*mov[shq]i_mips16): Remove mflo and mfhi alternatives.\n+\t(mfhilo_di, mfhilo_si): New patterns.\n+\n 2004-04-20  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* function.c (assign_parms): Force"}, {"sha": "46a22e334bb33cb09d0c1dd7fbfc7e96e8be7efe", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=169304de7bea9c4f303ec981b889f090366a1538", "patch": "@@ -1990,6 +1990,23 @@ mips_legitimize_move (enum machine_mode mode, rtx dest, rtx src)\n       return true;\n     }\n \n+  /* Check for individual, fully-reloaded mflo and mfhi instructions.  */\n+  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+      && REG_P (src) && MD_REG_P (REGNO (src))\n+      && REG_P (dest) && GP_REG_P (REGNO (dest)))\n+    {\n+      int other_regno = REGNO (src) == HI_REGNUM ? LO_REGNUM : HI_REGNUM;\n+      if (GET_MODE_SIZE (mode) <= 4)\n+\temit_insn (gen_mfhilo_si (gen_rtx_REG (SImode, REGNO (dest)),\n+\t\t\t\t  gen_rtx_REG (SImode, REGNO (src)),\n+\t\t\t\t  gen_rtx_REG (SImode, other_regno)));\n+      else\n+\temit_insn (gen_mfhilo_di (gen_rtx_REG (DImode, REGNO (dest)),\n+\t\t\t\t  gen_rtx_REG (DImode, REGNO (src)),\n+\t\t\t\t  gen_rtx_REG (DImode, other_regno)));\n+      return true;\n+    }\n+\n   /* We need to deal with constants that would be legitimate\n      immediate_operands but not legitimate move_operands.  */\n   if (CONSTANT_P (src) && !move_operand (src, mode))\n@@ -2600,9 +2617,6 @@ mips_output_move (rtx dest, rtx src)\n     {\n       if (src_code == REG)\n \t{\n-\t  if (MD_REG_P (REGNO (src)))\n-\t    return \"mf%1\\t%0\";\n-\n \t  if (ST_REG_P (REGNO (src)) && ISA_HAS_8CC)\n \t    return \"lui\\t%0,0x3f80\\n\\tmovf\\t%0,%.,%1\";\n "}, {"sha": "fad3b8d6c50a2e5602758a8caff8f8c1b4954e5b", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 74, "deletions": 62, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=169304de7bea9c4f303ec981b889f090366a1538", "patch": "@@ -51,6 +51,7 @@\n    (UNSPEC_LOAD_CALL\t\t27)\n    (UNSPEC_LOAD_GOT\t\t28)\n    (UNSPEC_GP\t\t\t29)\n+   (UNSPEC_MFHILO\t\t30)\n \n    (UNSPEC_ADDRESS_FIRST\t100)\n \n@@ -1544,11 +1545,8 @@\n         (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n         (clobber (scratch:SI))])\n    (set (match_operand:SI 4 \"register_operand\" \"\")\n-        (match_dup 0))]\n-  \"GENERATE_MULT3_SI\n-   && true_regnum (operands[0]) == LO_REGNUM\n-   && GP_REG_P (true_regnum (operands[4]))\n-   && peep2_reg_dead_p (2, operands[0])\"\n+\t(unspec [(match_dup 0) (match_dup 3)] UNSPEC_MFHILO))]\n+  \"GENERATE_MULT3_SI && peep2_reg_dead_p (2, operands[0])\"\n   [(parallel\n        [(set (match_dup 4)\n \t     (mult:SI (match_dup 1)\n@@ -1737,9 +1735,8 @@\n \t(clobber (match_operand:SI 2 \"register_operand\" \"\"))\n \t(clobber (scratch:SI))])\n    (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(match_dup 0))]\n-  \"true_regnum (operands[0]) == LO_REGNUM\n-   && GP_REG_P (true_regnum (operands[3]))\"\n+\t(unspec:SI [(match_dup 0) (match_dup 2)] UNSPEC_MFHILO))]\n+  \"\"\n   [(parallel [(set (match_dup 0)\n \t\t   (match_dup 1))\n \t      (set (match_dup 3)\n@@ -1810,11 +1807,8 @@\n \t(clobber (scratch:SI))])\n    (match_dup 0)\n    (set (match_operand:SI 5 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"GENERATE_MULT3_SI\n-   && true_regnum (operands[1]) == LO_REGNUM\n-   && peep2_reg_dead_p (3, operands[1])\n-   && GP_REG_P (true_regnum (operands[5]))\"\n+\t(unspec:SI [(match_dup 1) (match_dup 4)] UNSPEC_MFHILO))]\n+  \"GENERATE_MULT3_SI && peep2_reg_dead_p (3, operands[1])\"\n   [(parallel [(set (match_dup 0)\n \t\t   (match_dup 6))\n \t      (clobber (match_dup 4))\n@@ -2018,8 +2012,8 @@\n \t\t(const_int 32)))])\n \n    ;; OP7 <- LO, OP0 <- HI\n-   (set (match_dup 7) (match_dup 5))\n-   (set (match_dup 0) (match_dup 6))\n+   (set (match_dup 7) (unspec:DI [(match_dup 5) (match_dup 6)] UNSPEC_MFHILO))\n+   (set (match_dup 0) (unspec:DI [(match_dup 6) (match_dup 5)] UNSPEC_MFHILO))\n \n    ;; Zero-extend OP7.\n    (set (match_dup 7)\n@@ -4556,15 +4550,15 @@ dsrl\\t%3,%3,1\\n\\\n    (set_attr \"mode\"\t\"DI\")])\n \n (define_insn \"*movdi_32bit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*x,*d,*x,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,J,*x,*d,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*x,*d,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*x,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"arith,arith,load,store,mthilo,mfhilo,mthilo,xfer,load,xfer,store\")\n+  [(set_attr \"type\"\t\"arith,arith,load,store,mthilo,mfhilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"   \"8,16,*,*,8,8,8,8,*,8,*\")])\n+   (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n \n (define_insn \"*movdi_32bit_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -4578,24 +4572,24 @@ dsrl\\t%3,%3,1\\n\\\n    (set_attr \"length\"\t\"8,8,8,8,12,*,*,8\")])\n \n (define_insn \"*movdi_64bit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*x,*d,*x,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*J,*x,*d,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*x,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*J*d,*d,*m,*B*C*D,*B*C*D\"))]\n   \"TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"arith,const,const,load,store,fmove,xfer,fpload,xfer,fpstore,mthilo,mfhilo,mthilo,xfer,load,xfer,store\")\n+  [(set_attr \"type\"\t\"arith,const,const,load,store,fmove,xfer,fpload,xfer,fpstore,mthilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,8,*,8,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,8,*,8,*\")])\n \n (define_insn \"*movdi_64bit_mips16\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m,*d\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,U,m,d,*x\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,U,m,d\"))]\n   \"TARGET_64BIT && TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,const,load,store,mfhilo\")\n+  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,const,load,store\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n@@ -4609,8 +4603,7 @@ dsrl\\t%3,%3,1\\n\\\n \t\t\t       (const_int 12))\n \t\t (const_string \"*\")\n \t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_int 4)])])\n+\t\t (const_string \"*\")])])\n \n \n ;; On the mips16, we can split ld $r,N($r) into an add and a load,\n@@ -4702,24 +4695,24 @@ dsrl\\t%3,%3,1\\n\\\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"*movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*d,*z,*x,*d,*x,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*z,*d,J,*x,*d,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*d,*z,*x,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*z,*d,*J*d,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"arith,const,const,load,store,fmove,xfer,fpload,xfer,fpstore,xfer,xfer,mthilo,mfhilo,mthilo,xfer,load,xfer,store\")\n+  [(set_attr \"type\"\t\"arith,const,const,load,store,fmove,xfer,fpload,xfer,fpstore,xfer,xfer,mthilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,4,4,*,4,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,*,4,*\")])\n \n (define_insn \"*movsi_mips16\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m,*d\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,U,m,d,*x\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,U,m,d\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,const,load,store,mfhilo\")\n+  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,const,load,store\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n@@ -4733,8 +4726,7 @@ dsrl\\t%3,%3,1\\n\\\n \t\t\t       (const_int 12))\n \t\t (const_string \"*\")\n \t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_int 4)])])\n+\t\t (const_string \"*\")])])\n \n ;; On the mips16, we can split lw $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n@@ -4974,8 +4966,8 @@ dsrl\\t%3,%3,1\\n\\\n })\n \n (define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x,*d\")\n-\t(match_operand:HI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*f,*d,*x\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x\")\n+\t(match_operand:HI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*f,*d\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || reg_or_0_operand (operands[1], HImode))\"\n@@ -4987,15 +4979,14 @@ dsrl\\t%3,%3,1\\n\\\n     mfc1\\t%0,%1\n     mtc1\\t%1,%0\n     mov.s\\t%0,%1\n-    mt%0\\t%1\n-    mf%1\\t%0\"\n-  [(set_attr \"type\"\t\"arith,arith,load,store,xfer,xfer,fmove,mthilo,mfhilo\")\n+    mt%0\\t%1\"\n+  [(set_attr \"type\"\t\"arith,arith,load,store,xfer,xfer,fmove,mthilo\")\n    (set_attr \"mode\"\t\"HI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4,4,4,4,4\")])\n+   (set_attr \"length\"\t\"4,4,*,*,4,4,4,4\")])\n \n (define_insn \"*movhi_mips16\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n-\t(match_operand:HI 1 \"move_operand\"         \"d,d,y,K,N,m,d,*x\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m\")\n+\t(match_operand:HI 1 \"move_operand\"         \"d,d,y,K,N,m,d\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n@@ -5006,9 +4997,8 @@ dsrl\\t%3,%3,1\\n\\\n     li\\t%0,%1\n     li\\t%0,%n1\\;neg\\t%0\n     lhu\\t%0,%1\n-    sh\\t%1,%0\n-    mf%1\\t%0\"\n-  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,load,store,mfhilo\")\n+    sh\\t%1,%0\"\n+  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,load,store\")\n    (set_attr \"mode\"\t\"HI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n@@ -5021,8 +5011,7 @@ dsrl\\t%3,%3,1\\n\\\n \t\t\t       (const_int 8)\n \t\t\t       (const_int 12))\n \t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_int 4)])])\n+\t\t (const_string \"*\")])])\n \n \n ;; On the mips16, we can split lh $r,N($r) into an add and a load,\n@@ -5084,8 +5073,8 @@ dsrl\\t%3,%3,1\\n\\\n })\n \n (define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x,*d\")\n-\t(match_operand:QI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*f,*d,*x\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x\")\n+\t(match_operand:QI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*f,*d\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || reg_or_0_operand (operands[1], QImode))\"\n@@ -5097,15 +5086,14 @@ dsrl\\t%3,%3,1\\n\\\n     mfc1\\t%0,%1\n     mtc1\\t%1,%0\n     mov.s\\t%0,%1\n-    mt%0\\t%1\n-    mf%1\\t%0\"\n-  [(set_attr \"type\"\t\"arith,arith,load,store,xfer,xfer,fmove,mthilo,mfhilo\")\n+    mt%0\\t%1\"\n+  [(set_attr \"type\"\t\"arith,arith,load,store,xfer,xfer,fmove,mthilo\")\n    (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4,4,4,4,4\")])\n+   (set_attr \"length\"\t\"4,4,*,*,4,4,4,4\")])\n \n (define_insn \"*movqi_mips16\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n-\t(match_operand:QI 1 \"move_operand\"         \"d,d,y,K,N,m,d,*x\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m\")\n+\t(match_operand:QI 1 \"move_operand\"         \"d,d,y,K,N,m,d\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n@@ -5116,11 +5104,10 @@ dsrl\\t%3,%3,1\\n\\\n     li\\t%0,%1\n     li\\t%0,%n1\\;neg\\t%0\n     lbu\\t%0,%1\n-    sb\\t%1,%0\n-    mf%1\\t%0\"\n-  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,load,store,mfhilo\")\n+    sb\\t%1,%0\"\n+  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,load,store\")\n    (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,4,4,8,*,*,4\")])\n+   (set_attr \"length\"\t\"4,4,4,4,8,*,*\")])\n \n ;; On the mips16, we can split lb $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n@@ -5274,6 +5261,31 @@ dsrl\\t%3,%3,1\\n\\\n   DONE;\n })\n \n+;; The HI and LO registers are not truly independent.  If we move an mthi\n+;; instruction before an mflo instruction, it will make the result of the\n+;; mflo unpredicatable.  The same goes for mtlo and mfhi.\n+;;\n+;; We cope with this by making the mflo and mfhi patterns use both HI and LO.\n+;; Operand 1 is the register we want, operand 2 is the other one.\n+\n+(define_insn \"mfhilo_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"h,l\")\n+\t\t    (match_operand:DI 2 \"register_operand\" \"l,h\")]\n+\t\t   UNSPEC_MFHILO))]\n+  \"TARGET_64BIT\"\n+  \"mf%1\\t%0\"\n+  [(set_attr \"type\" \"mfhilo\")])\n+\n+(define_insn \"mfhilo_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"h,l\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"l,h\")]\n+\t\t   UNSPEC_MFHILO))]\n+  \"\"\n+  \"mf%1\\t%0\"\n+  [(set_attr \"type\" \"mfhilo\")])\n+\n ;; Patterns for loading or storing part of a paired floating point\n ;; register.  We need them because odd-numbered floating-point registers\n ;; are not fully independent: see mips_split_64bit_move."}, {"sha": "e76df31c2f69ccdaf9e1d993cf687279b345180e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=169304de7bea9c4f303ec981b889f090366a1538", "patch": "@@ -1,3 +1,7 @@\n+2004-04-20  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.dg/torture/mips-hilo-1.c: New test.\n+\n 2004-04-19  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* gcc.c-torture/compile/20040419-1.c: New test."}, {"sha": "2b0d668fc696c4d987d9d22e1e0cefb46e0f239f", "filename": "gcc/testsuite/gcc.dg/torture/mips-hilo-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169304de7bea9c4f303ec981b889f090366a1538/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-1.c?ref=169304de7bea9c4f303ec981b889f090366a1538", "patch": "@@ -0,0 +1,75 @@\n+/* f1 checks that an mtlo is not moved before an mfhi.  f2 does the same\n+   for an mthi and an mflo.  */\n+/* { dg-do run { target mips*-*-* } } */\n+/* { dg-options \"-mtune=rm7000\" } */\n+\n+#if !defined(__mips16)\n+\n+#define DECLARE(TYPE)\t\t\t\t\t\t\t\\\n+  TYPE __attribute__ ((noinline))\t\t\t\t\t\\\n+  f1##TYPE (TYPE x1, TYPE x2, TYPE x3)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE t1, t2;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    asm (\"mult\\t%1,%2\" : \"=h\" (t1) : \"d\" (x1), \"d\" (x2) : \"lo\");\t\\\n+    asm (\"mflo\\t%0\" : \"=r\" (t2) : \"l\" (x3) : \"hi\");\t\t\t\\\n+    return t1 + t2;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TYPE __attribute__ ((noinline))\t\t\t\t\t\\\n+  f2##TYPE (TYPE x1, TYPE x2, TYPE x3)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE t1, t2;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    asm (\"mult\\t%1,%2\" : \"=l\" (t1) : \"d\" (x1), \"d\" (x2) : \"hi\");\t\\\n+    asm (\"mfhi\\t%0\" : \"=r\" (t2) : \"h\" (x3) : \"lo\");\t\t\t\\\n+    return t1 + t2;\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST(TYPE)\t\t\t\t\t\t\t\\\n+  if (f1##TYPE (1, 2, 10) != 10)\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+  if (f2##TYPE (1, 2, 40) != 42)\t\t\t\t\t\\\n+    abort ()\n+\n+typedef char c;\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef short s;\n+typedef unsigned short us;\n+typedef int i;\n+typedef unsigned int ui;\n+typedef long long ll;\n+typedef unsigned long long ull;\n+\n+DECLARE (c)\n+DECLARE (sc)\n+DECLARE (uc)\n+DECLARE (s)\n+DECLARE (us)\n+DECLARE (i)\n+DECLARE (ui)\n+#if defined (__mips64)\n+DECLARE (ll)\n+DECLARE (ull)\n+#endif\n+\n+int\n+main ()\n+{\n+  TEST (c);\n+  TEST (sc);\n+  TEST (uc);\n+  TEST (s);\n+  TEST (us);\n+  TEST (i);\n+  TEST (ui);\n+#if defined (__mips64)\n+  TEST (ll);\n+  TEST (ull);\n+#endif\n+  exit (0);\n+}\n+#else\n+int main () { exit (0); }\n+#endif"}]}