{"sha": "1218d701f7de691254c06b4599abab6ca7361703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIxOGQ3MDFmN2RlNjkxMjU0YzA2YjQ1OTlhYmFiNmNhNzM2MTcwMw==", "commit": {"author": {"name": "Silvius Rus", "email": "silvius.rus@gmail.com", "date": "2009-10-03T02:17:41Z"}, "committer": {"name": "Silvius Rus", "email": "rus@gcc.gnu.org", "date": "2009-10-03T02:17:41Z"}, "message": "merge branch profile-stdlib\n\nFrom-SVN: r152431", "tree": {"sha": "4ee10967bd743d512cc41a7b4610019f4ca6adfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ee10967bd743d512cc41a7b4610019f4ca6adfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1218d701f7de691254c06b4599abab6ca7361703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1218d701f7de691254c06b4599abab6ca7361703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1218d701f7de691254c06b4599abab6ca7361703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1218d701f7de691254c06b4599abab6ca7361703/comments", "author": {"login": "silviusrus", "id": 2181423, "node_id": "MDQ6VXNlcjIxODE0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/2181423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/silviusrus", "html_url": "https://github.com/silviusrus", "followers_url": "https://api.github.com/users/silviusrus/followers", "following_url": "https://api.github.com/users/silviusrus/following{/other_user}", "gists_url": "https://api.github.com/users/silviusrus/gists{/gist_id}", "starred_url": "https://api.github.com/users/silviusrus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/silviusrus/subscriptions", "organizations_url": "https://api.github.com/users/silviusrus/orgs", "repos_url": "https://api.github.com/users/silviusrus/repos", "events_url": "https://api.github.com/users/silviusrus/events{/privacy}", "received_events_url": "https://api.github.com/users/silviusrus/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3930dbe9d6c9849e32ce39d7ff585348d4716329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3930dbe9d6c9849e32ce39d7ff585348d4716329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3930dbe9d6c9849e32ce39d7ff585348d4716329"}], "stats": {"total": 10285, "additions": 10252, "deletions": 33}, "files": [{"sha": "a68aec525e91a92e147271519441ff2dbd8814d6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -1,3 +1,64 @@\n+2009-10-02  Silvius Rus  <silvius.rus@gmail.com>\n+\t* configure: Add check for execinfo.h.\n+\t* config.h.in: Add undef for HAVE_EXECINFO_H.\n+\t* include/Makefile.am: Add build support for profile mode.\n+\t* include/Makefile.in: Same.\n+\t* include/profile/base.h: New file.\n+\t* include/profile/bitset: Same.\n+\t* include/profile/deque: Same.\n+\t* include/profile/hashtable.h: Same.\n+\t* include/profile/list: Same.\n+\t* include/profile/map: Same.\n+\t* include/profile/map.h: Same.\n+\t* include/profile/multimap.h: Same.\n+\t* include/profile/multiset.h: Same.\n+\t* include/profile/set: Same.\n+\t* include/profile/set.h: Same.\n+\t* include/profile/unordered_map: Same.\n+\t* include/profile/unordered_set: Same.\n+\t* include/profile/vector: Same.\n+\t* include/profile/impl/profiler.h: Same.\n+\t* include/profile/impl/profiler_container_size.h: Same.\n+\t* include/profile/impl/profiler_hash_func.h: Same.\n+\t* include/profile/impl/profiler_hashtable_size.h: Same.\n+\t* include/profile/impl/profiler_map_to_unordered_map.h: Same.\n+\t* include/profile/impl/profiler_node.h: Same.\n+\t* include/profile/impl/profiler_state.h: Same.\n+\t* include/profile/impl/profiler_trace.h: Same.\n+\t* include/profile/impl/profiler_vector_size.h: Same.\n+\t* include/profile/impl/profiler_vector_to_list.h: Same.\n+\t* include/std/vector: Include corresponding profile header guarded by \n+\t_GLIBCXX_PROFILE.\n+\t* include/std/deque: Same.\n+\t* include/std/list: Same.\n+\t* include/std/map: Same.\n+\t* include/std/unordered_map: Same.\n+\t* include/std/bitset: Same.\n+\t* include/std/set: Same.\n+\t* include/std/unordered_set: Same.\n+\t* include/backward/hash_map: Same.\n+\t* include/backward/hash_set: Same.\n+\t* include/tr1_impl/hashtable (_Hashtable): Expose insert_return_type.\n+\t* include/bits/c++config: Define profile namespace.\n+\t* testsuite/Makefile.in: Add check-profile.\n+\t* testsuite/Makefile.am: Same.\n+\t* testsuite/ext/profile/all.cc: New file.\n+\t* testsuite/ext/profile/mh.cc: Same.\n+\t* testsuite/ext/profile/mutex_extensions.cc: Same.\n+\t* testsuite/23_containers/unordered_map/profile/hash_map.cc: Same.\n+\t* testsuite/23_containers/unordered_map/profile/unordered.cc: Same.\n+\t* testsuite/23_containers/vector/profile/vector.cc: Same.\n+\t* testsuite/23_containers/vector/resize/moveable.cc: Make it pass\n+\tin profile mode.\n+\t* testsuite/23_containers/deque/capacity/moveable.cc: Same.\n+\t* testsuite/23_containers/list/capacity/29134.cc: Same.\n+\t* doc/Makefile.in: Add reference to profile_mode.xml.\n+\t* doc/Makefile.am: Same.\n+\t* doc/xml/manual/profile_mode.xml: New file.\n+\t* doc/xml/manual/debug.xml: Add link to profile mode section.\n+\t* doc/xml/manual/extensions.xml: Add profile mode.  Update numbering.\n+\t* doc/doxygen/user.cfg.in: Add profile mode files.\n+\n 2009-10-02  Johannes Singler  <singler@ira.uka.de>\n \n         * include/parallel/base.h: Take integer types from <tr1/cstdint>."}, {"sha": "506b00e31b29fa90dfa3bfe4bde4c15e35672725", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -262,6 +262,9 @@\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n+/* Define to 1 if you have the <execinfo.h> header file. */\n+#undef HAVE_EXECINFO_H\n+\n /* Define to 1 if you have the `modf' function. */\n #undef HAVE_MODF\n "}, {"sha": "0ba287cec5ab036a78187895108a791c0934b372", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -7926,7 +7926,7 @@ fi\n \n # On IRIX 5.3, sys/types and inttypes.h are conflicting.\n for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \\\n-\t\t  inttypes.h stdint.h unistd.h\n+\t\t  inttypes.h stdint.h unistd.h execinfo.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_compile \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default"}, {"sha": "22c549c9cfecb856f7e8493fb92f427919123726", "filename": "libstdc++-v3/doc/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2FMakefile.am?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -100,6 +100,7 @@ xml_sources = \\\n \t${xml_srcdir}/manual/numerics.xml \\\n \t${xml_srcdir}/manual/parallel_mode.xml \\\n \t${xml_srcdir}/manual/prerequisites.xml \\\n+\t${xml_srcdir}/manual/profile_mode.xml \\\n \t${xml_srcdir}/manual/internals.xml \\\n \t${xml_srcdir}/manual/shared_ptr.xml \\\n \t${xml_srcdir}/manual/spine.xml \\"}, {"sha": "fd56f3c3e9d73a72f714113fc6c1bafb32142e2b", "filename": "libstdc++-v3/doc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2FMakefile.in?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -312,6 +312,7 @@ xml_sources = \\\n \t${xml_srcdir}/manual/numerics.xml \\\n \t${xml_srcdir}/manual/parallel_mode.xml \\\n \t${xml_srcdir}/manual/prerequisites.xml \\\n+\t${xml_srcdir}/manual/profile_mode.xml \\\n \t${xml_srcdir}/manual/internals.xml \\\n \t${xml_srcdir}/manual/shared_ptr.xml \\\n \t${xml_srcdir}/manual/spine.xml \\"}, {"sha": "9ffcf1ef75c3e6a8fd656e7eddc3b4fa61c29fd6", "filename": "libstdc++-v3/doc/doxygen/user.cfg.in", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -661,6 +661,25 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/debug/unordered_map \\\n                          include/debug/unordered_set \\\n                          include/debug/vector \\\n+                         include/profile/bitset \\\n+                         include/profile/deque \\\n+                         include/profile/list \\\n+                         include/profile/map \\\n+                         include/profile/set \\\n+                         include/profile/unordered_map \\\n+                         include/profile/unordered_set \\\n+                         include/profile/vector \\\n+                         include/profile/base.h \\\n+                         include/profile/impl/profiler.h \\\n+                         include/profile/impl/profiler_container_size.h \\\n+                         include/profile/impl/profiler_hash_func.h \\\n+                         include/profile/impl/profiler_hashtable_size.h \\\n+                         include/profile/impl/profiler_map_to_unordered_map.h \\\n+                         include/profile/impl/profiler_node.h \\\n+                         include/profile/impl/profiler_state.h \\\n+                         include/profile/impl/profiler_trace.h \\\n+                         include/profile/impl/profiler_vector_size.h \\\n+                         include/profile/impl/profiler_vector_to_list.h \\\n                          include/ext/algorithm \\\n                          include/ext/functional \\\n                          include/ext/iterator \\\n@@ -715,6 +734,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/bits/shared_ptr.h \\\n                          include/debug \\\n                          include/parallel \\\n+                         include/profile \\\n                          include/ext \\\n                          include/ext/pb_ds \\\n                          include/ext/pb_ds/detail "}, {"sha": "8aa530703779305fb758454baee1bf9caf9e7ac2", "filename": "libstdc++-v3/doc/xml/manual/debug.xml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdebug.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdebug.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdebug.xml?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -243,4 +243,12 @@\n   </para>\n </sect2>\n \n+<sect2 id=\"debug.profile_mode\" xreflabel=\"debug.profile_mode\">\n+<title>Profile-based Performance Analysis</title>\n+  <para> The <link linkend=\"manual.ext.profile_mode\">Profile-based \n+  Performance Analysis</link> Extension has performance checks for many \n+  algorithms.\n+  </para>\n+</sect2>\n+\n </sect1>"}, {"sha": "889fe1db014da3e9db6b1b8c8e022ddfc7c0f204", "filename": "libstdc++-v3/doc/xml/manual/extensions.xml", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fextensions.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fextensions.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fextensions.xml?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -113,7 +113,13 @@ extensions, be aware of two things:\n \t    parse=\"xml\" href=\"parallel_mode.xml\">\n </xi:include>\n \n-<!-- Chapter 04 : Allocators -->\n+<!-- Chapter 04 : Profile Mode -->\n+<xi:include xmlns:xi=\"http://www.w3.org/2001/XInclude\" \n+\t    parse=\"xml\" href=\"profile_mode.xml\">\n+</xi:include>\n+\n+\n+<!-- Chapter 05 : Allocators -->\n <chapter id=\"manual.ext.allocator\" xreflabel=\"Allocators\">\n <?dbhtml filename=\"ext_allocators.html\"?>\n   <title>Allocators</title>\n@@ -130,7 +136,7 @@ extensions, be aware of two things:\n \n </chapter>\n \n-<!-- Chapter 05 : Containers -->\n+<!-- Chapter 06 : Containers -->\n <chapter id=\"manual.ext.containers\" xreflabel=\"Containers\">\n <?dbhtml filename=\"ext_containers.html\"?>\n   <title>Containers</title>\n@@ -266,7 +272,7 @@ extensions, be aware of two things:\n   </sect1>  \n </chapter>\n \n-<!-- Chapter 06 : Utilities -->\n+<!-- Chapter 07 : Utilities -->\n <chapter id=\"manual.ext.util\" xreflabel=\"Utilities\">\n <?dbhtml filename=\"ext_utilities.html\"?>\n   <title>Utilities</title>\n@@ -336,7 +342,7 @@ get_temporary_buffer(5, (int*)0);\n \n </chapter>\n \n-<!-- Chapter 07 : Algorithms -->\n+<!-- Chapter 08 : Algorithms -->\n <chapter id=\"manual.ext.algorithms\" xreflabel=\"Algorithms\">\n <?dbhtml filename=\"ext_algorithms.html\"?>\n   <title>Algorithms</title>\n@@ -374,7 +380,7 @@ get_temporary_buffer(5, (int*)0);\n \n </chapter>\n \n-<!-- Chapter 08 : Numerics -->\n+<!-- Chapter 09 : Numerics -->\n <chapter id=\"manual.ext.numerics\" xreflabel=\"Numerics\">\n <?dbhtml filename=\"ext_numerics.html\"?>\n   <title>Numerics</title>\n@@ -399,7 +405,7 @@ get_temporary_buffer(5, (int*)0);\n    void iota(_ForwardIter first, _ForwardIter last, _Tp value);</programlisting>\n </chapter>\n \n-<!-- Chapter 09 : Iterators -->\n+<!-- Chapter 10 : Iterators -->\n <chapter id=\"manual.ext.iterators\" xreflabel=\"Iterators\">\n <?dbhtml filename=\"ext_iterators.html\"?>\n   <title>Iterators</title>\n@@ -423,7 +429,7 @@ get_temporary_buffer(5, (int*)0);\n \n </chapter>\n \n-<!-- Chapter 08 : IO -->\n+<!-- Chapter 11 : IO -->\n <chapter id=\"manual.ext.io\" xreflabel=\"IO\">\n <?dbhtml filename=\"ext_io.html\"?>\n   <title>Input and Output</title>\n@@ -493,7 +499,7 @@ get_temporary_buffer(5, (int*)0);\n   </sect1>\n </chapter>\n \n-<!-- Chapter 09 : Demangling -->\n+<!-- Chapter 12 : Demangling -->\n <chapter id=\"manual.ext.demangle\" xreflabel=\"Demangling\">\n <?dbhtml filename=\"ext_demangling.html\"?>\n   <title>Demangling</title>\n@@ -579,7 +585,7 @@ int main()\n    </para>\n </chapter>\n \n-<!-- Chapter 10 : Concurrency -->\n+<!-- Chapter 13 : Concurrency -->\n <xi:include xmlns:xi=\"http://www.w3.org/2001/XInclude\" \n \t    parse=\"xml\" href=\"concurrency.xml\">\n </xi:include>"}, {"sha": "5bf8eb1320765dd65ebb9e4c18db7c63de2f1d6b", "filename": "libstdc++-v3/doc/xml/manual/profile_mode.xml", "status": "added", "additions": 1718, "deletions": 0, "changes": 1718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fprofile_mode.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fprofile_mode.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fprofile_mode.xml?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,1718 @@\n+<?xml version='1.0'?>\n+<!DOCTYPE chapter PUBLIC \"-//OASIS//DTD DocBook XML V4.5//EN\" \n+ \"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd\" \n+[ ]>\n+\n+<chapter id=\"manual.ext.profile_mode\" xreflabel=\"Profile Mode\">\n+<?dbhtml filename=\"profile_mode.html\"?>\n+ \n+<chapterinfo>\n+  <keywordset>\n+    <keyword>\n+      C++\n+    </keyword>\n+    <keyword>\n+      library\n+    </keyword>\n+    <keyword>\n+      profile\n+    </keyword>\n+  </keywordset>\n+</chapterinfo>\n+\n+<title>Profile Mode</title>\n+\n+\n+<sect1 id=\"manual.ext.profile_mode.intro\" xreflabel=\"Intro\">\n+  <title>Intro</title>\n+  <para>\n+  <emphasis>Goal: </emphasis>Give performance improvement advice based on\n+  recognition of suboptimal usage patterns of the standard library.\n+  </para>\n+\n+  <para>\n+  <emphasis>Method: </emphasis>Wrap the standard library code.  Insert\n+  calls to an instrumentation library to record the internal state of\n+  various components at interesting entry/exit points to/from the standard\n+  library.  Process trace, recognize suboptimal patterns, give advice.\n+  For details, see \n+  <ulink url=\"http://dx.doi.org/10.1109/CGO.2009.36\">paper presented at\n+   CGO 2009</ulink>.\n+  </para>\n+  <para>\n+  <emphasis>Strengths: </emphasis>\n+<itemizedlist>\n+  <listitem><para>\n+  Unintrusive solution.  The application code does not require any \n+  modification.\n+  </para></listitem>\n+  <listitem><para> The advice is call context sensitive, thus capable of\n+  identifying precisely interesting dynamic performance behavior.\n+  </para></listitem>\n+  <listitem><para>\n+  The overhead model is pay-per-view.  When you turn off a diagnostic class\n+  at compile time, its overhead disappears.\n+  </para></listitem>\n+</itemizedlist>\n+  </para>\n+  <para>\n+  <emphasis>Drawbacks: </emphasis>\n+<itemizedlist>\n+  <listitem><para>\n+  You must recompile the application code with custom options.\n+  </para></listitem>\n+  <listitem><para>You must run the application on representative input.\n+  The advice is input dependent.\n+  </para></listitem>\n+  <listitem><para>\n+  The execution time will increase, in some cases by factors.\n+  </para></listitem>\n+</itemizedlist>\n+  </para>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.using\" xreflabel=\"Using\">\n+  <title>Using the Profile Mode</title>\n+\n+  <para>\n+  This is the anticipated common workflow for program <code>foo.cc</code>:\n+<programlisting>\n+$ cat foo.cc\n+#include &lt;vector&gt;\n+int main() {\n+  vector&lt;int&gt; v;\n+  for (int k = 0; k &lt; 1024; ++k) v.insert(v.begin(), k);\n+}\n+\n+$ g++ -D_GLIBCXX_PROFILE foo.cc\n+$ ./a.out\n+$ cat libstdcxx-profile.txt\n+vector-to-list: improvement = 5: call stack = 0x804842c ...\n+    : advice = change std::vector to std::list\n+vector-size: improvement = 3: call stack = 0x804842c ...\n+    : advice = change initial container size from 0 to 1024\n+</programlisting>\n+  </para>\n+\n+  <para>\n+  Anatomy of a warning:\n+  <itemizedlist>\n+  <listitem>\n+  <para>\n+  Warning id.  This is a short descriptive string for the class\n+  that this warning belongs to.  E.g., \"vector-to-list\".\n+  </para>\n+  </listitem>\n+  <listitem>\n+  <para>\n+  Estimated improvement.  This is an approximation of the benefit expected\n+  from implementing the change suggested by the warning.  It is given on\n+  a log10 scale.  Negative values mean that the alternative would actually\n+  do worse than the current choice.\n+  In the example above, 5 comes from the fact that the overhead of\n+  inserting at the beginning of a vector vs. a list is around 1024 * 1024 / 2,\n+  which is around 10e5.  The improvement from setting the initial size to\n+  1024 is in the range of 10e3, since the overhead of dynamic resizing is\n+  linear in this case.\n+  </para>\n+  </listitem>\n+  <listitem>\n+  <para>\n+  Call stack.  Currently, the addresses are printed without\n+  symbol name or code location attribution.\n+  Users are expected to postprocess the output using, for instance, addr2line.\n+  </para>\n+  </listitem>\n+  <listitem>\n+  <para>\n+  The warning message.  For some warnings, this is static text, e.g.,\n+  \"change vector to list\".  For other warnings, such as the one above,\n+  the message contains numeric advice, e.g., the suggested initial size\n+  of the hashtable.\n+  </para>\n+  </listitem>\n+  </itemizedlist>\n+  </para>\n+\n+  <para>Two files are generated.  <code>libstdcxx-profile.txt</code>\n+   contains human readable advice.  <code>libstdcxx-profile.raw</code>\n+   contains implementation specific data about each diagnostic.\n+   Their format is not documented.  They are sufficient to generate\n+   all the advice given in <code>libstdcxx-profile.txt</code>.  The advantage\n+   of keeping this raw format is that traces from multiple executions can\n+   be aggregated simply by concatenating the raw traces.  We intend to\n+   offer an external utility program that can issue advice from a trace.\n+  </para>\n+\n+  <para>Advice is given regardless whether the transformation is valid.\n+  For instance, we advise changing a map to an unordered_map even if the\n+  application semantics require that data be ordered.\n+  We believe such warnings can help users understand the performance\n+  behavior of their application better, which can lead to changes\n+  at a higher abstraction level.\n+  </para>\n+\n+</sect2>\n+\n+<sect2 id=\"manual.ext.profile_mode.tuning\" xreflabel=\"Tuning\">\n+  <title>Tuning the Profile Mode</title>\n+\n+  <para>Compile time switches and environment variables (see also file\n+   profiler.h).  Unless specified otherwise, they can be set at compile time\n+   using -D_&lt;name&gt; or by setting variable &lt;name&gt;\n+   in the environment where the program is run, before starting execution.\n+  <itemizedlist>\n+  <listitem><para>\n+   <code>[NO]_GLIBCXX_PROFILE_&lt;diagnostic&gt;</code>:\n+   enable/disable specific diagnostics.\n+   See section Diagnostics for possible values.\n+   (Environment variables not supported.)\n+   </para></listitem>\n+  <listitem><para>\n+   <code>GLIBCXX_PROFILE_TRACE_PATH_ROOT</code>: set an alternative root\n+   path for the output files.\n+   </para></listitem>\n+  <listitem><para>GLIBCXX_PROFILE_MAX_WARN_COUNT: set it to the maximum\n+   number of warnings desired.  The default value is 10.</para></listitem>\n+  <listitem><para>\n+   <code>GLIBCXX_PROFILE_MAX_STACK_DEPTH</code>: if set to 0, \n+   the advice will\n+   be collected and reported for the program as a whole, and not for each\n+   call context.\n+   This could also be used in continuous regression tests, where you\n+   just need to know whether there is a regression or not.\n+   The default value is 32.\n+   </para></listitem>\n+  <listitem><para>\n+   <code>GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC</code>:\n+   set a limit on how much memory to use for the accounting tables for each\n+   diagnostic type.  When this limit is reached, new events are ignored\n+   until the memory usage decreases under the limit.  Generally, this means\n+   that newly created containers will not be instrumented until some\n+   live containers are deleted.  The default is 128 MB.\n+   </para></listitem>\n+  <listitem><para>\n+   <code>GLIBCXX_PROFILE_NOTHREADS</code>:\n+   Make the library not use threads.  Otherwise, pthread mutexes are used\n+   to protect access to internal data structures.  This should be useful\n+   only if the program is single threaded and you want to avoid the overhead\n+   of aquiring/releasing locks unnecessarily.\n+   (Environment variable not supported.)\n+   </para></listitem>\n+  <listitem><para>\n+   <code>HAVE_EXECINFO_H</code>:\n+   This name should be defined at library configuration time.\n+   If your library was configured without <code>execinfo.h</code>, but\n+   you have it in your include path, you can define it explicitly.  Without\n+   it, advice is collected for the program as a whole, and not for each\n+   call context.\n+   (Environment variable not supported.)\n+   </para></listitem>\n+  </itemizedlist>\n+  </para>\n+\n+</sect2>\n+\n+</sect1>\n+\n+\n+<sect1 id=\"manual.ext.profile_mode.design\" xreflabel=\"Design\">\n+  <title>Design</title>\n+\n+<para>\n+</para>\n+<table frame='all'>\n+<title>Code Location</title>\n+<tgroup cols='2' align='left' colsep='1' rowsep='1'>\n+<colspec colname='c1'></colspec>\n+<colspec colname='c2'></colspec>\n+\n+<thead>\n+  <row>\n+    <entry>Code Location</entry>\n+    <entry>Use</entry>\n+  </row>\n+</thead>\n+<tbody>\n+  <row>\n+    <entry><code>libstdc++-v3/include/std/*</code></entry>\n+    <entry>Preprocessor code to redirect to profile extension headers.</entry>\n+  </row>\n+  <row>\n+    <entry><code>libstdc++-v3/include/profile/*</code></entry>\n+    <entry>Profile extension public headers (map, vector, ...).</entry>\n+  </row>\n+  <row>\n+    <entry><code>libstdc++-v3/include/profile/impl/*</code></entry>\n+    <entry>Profile extension internals.  Implementation files are\n+     only included from <code>impl/profiler.h</code>, which is the only\n+     file included from the public headers.</entry>\n+  </row>\n+</tbody>\n+</tgroup>\n+</table>\n+\n+<para>\n+</para>\n+\n+<sect2 id=\"manual.ext.profile_mode.design.wrapper\" \n+ xreflabel=\"Wrapper\">\n+<title>Wrapper Model</title>\n+  <para>\n+  In order to get our instrumented library version included instead of the\n+  release one,\n+  we use the same wrapper model as the debug mode.\n+  We subclass entities from the release version.  Wherever\n+  <code>_GLIBCXX_PROFILE</code> is defined, the release namespace is\n+  <code>std::__norm</code>, whereas the profile namespace is \n+  <code>std::__profile</code>.  Using plain <code>std</code> translates\n+  into <code>std::__profile</code>.\n+  </para>\n+  <para>\n+  Whenever possible, we try to wrap at the public interface level, e.g.,\n+  in <code>unordered_set</code> rather than in <code>hashtable</code>, \n+  in order not to depend on implementation.\n+  </para>\n+  <para>\n+  Mixing object files built with and without the profile mode must\n+  not affect the program execution.  However, there are no guarantees to\n+  the accuracy of diagnostics when using even a single object not built with\n+  <code>-D_GLIBCXX_PROFILE</code>.\n+  Currently, mixing the profile mode with debug and parallel extensions is\n+  not allowed.  Mixing them at compile time will result in preprocessor errors.\n+  Mixing them at link time is undefined.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.design.instrumentation\" \n+ xreflabel=\"Instrumentation\">\n+<title>Instrumentation</title>\n+  <para>\n+  Instead of instrumenting every public entry and exit point,\n+  we chose to add instrumentation on demand, as needed\n+  by individual diagnostics.\n+  The main reason is that some diagnostics require us to extract bits of \n+  internal state that are particular only to that diagnostic.\n+  We plan to formalize this later, after we learn more about the requirements\n+  of several diagnostics.\n+  </para>\n+  <para>\n+  All the instrumentation points can be switched on and off using \n+  <code>-D[_NO]_GLIBCXX_PROFILE_&lt;diagnostic&gt;</code> options.\n+  With all the instrumentation calls off, there should be negligible\n+  overhead over the release version.  This property is needed to support\n+  diagnostics based on timing of internal operations.  For such diagnostics,\n+  we anticipate turning most of the instrumentation off in order to prevent\n+  profiling overhead from polluting time measurements, and thus diagnostics.\n+  </para>\n+  <para>\n+  All the instrumentation on/off compile time switches live in \n+  <code>include/profile/profiler.h</code>.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.design.rtlib\" \n+ xreflabel=\"Run Time Behavior\">\n+<title>Run Time Behavior</title>\n+  <para>\n+  For practical reasons, the instrumentation library processes the trace\n+  partially\n+  rather than dumping it to disk in raw form.  Each event is processed when\n+  it occurs.  It is usually attached a cost and it is aggregated into\n+  the database of a specific diagnostic class.  The cost model\n+  is based largely on the standard performance guarantees, but in some\n+  cases we use knowledge about GCC's standard library implementation.\n+  </para>\n+  <para>\n+  Information is indexed by (1) call stack and (2) instance id or address\n+  to be able to understand and summarize precise creation-use-destruction\n+  dynamic chains.  Although the analysis is sensitive to dynamic instances,\n+  the reports are only sensitive to call context.  Whenever a dynamic instance\n+  is destroyed, we accumulate its effect to the corresponding entry for the\n+  call stack of its constructor location.\n+  </para>\n+\n+  <para>\n+  For details, see \n+   <ulink url=\"http://dx.doi.org/10.1109/CGO.2009.36\">paper presented at\n+   CGO 2009</ulink>.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.design.analysis\"\n+ xreflabel=\"Analysis and Diagnostics\">\n+<title>Analysis and Diagnostics</title>\n+  <para>\n+  Final analysis takes place offline, and it is based entirely on the\n+  generated trace and debugging info in the application binary.\n+  See section Diagnostics for a list of analysis types that we plan to support.\n+  </para>\n+  <para>\n+  The input to the analysis is a table indexed by profile type and call stack.\n+  The data type for each entry depends on the profile type.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.design.cost-model\"\n+ xreflabel=\"Cost Model\">\n+<title>Cost Model</title>\n+  <para>\n+  While it is likely that cost models become complex as we get into \n+  more sophisticated analysis, we will try to follow a simple set of rules\n+  at the beginning.\n+  </para>\n+<itemizedlist>\n+  <listitem><para><emphasis>Relative benefit estimation:</emphasis>\n+  The idea is to estimate or measure the cost of all operations\n+  in the original scenario versus the scenario we advise to switch to.\n+  For instance, when advising to change a vector to a list, an occurrence\n+  of the <code>insert</code> method will generally count as a benefit.\n+  Its magnitude depends on (1) the number of elements that get shifted\n+  and (2) whether it triggers a reallocation.\n+  </para></listitem>\n+  <listitem><para><emphasis>Synthetic measurements:</emphasis>\n+  We will measure the relative difference between similar operations on\n+  different containers.  We plan to write a battery of small tests that\n+  compare the times of the executions of similar methods on different\n+  containers.  The idea is to run these tests on the target machine.\n+  If this training phase is very quick, we may decide to perform it at\n+  library initialization time.  The results can be cached on disk and reused\n+  across runs.\n+  </para></listitem>\n+  <listitem><para><emphasis>Timers:</emphasis>\n+  We plan to use timers for operations of larger granularity, such as sort.\n+  For instance, we can switch between different sort methods on the fly\n+  and report the one that performs best for each call context.\n+  </para></listitem>\n+  <listitem><para><emphasis>Show stoppers:</emphasis>\n+  We may decide that the presence of an operation nullifies the advice.\n+  For instance, when considering switching from <code>set</code> to \n+  <code>unordered_set</code>, if we detect use of operator <code>++</code>,\n+  we will simply not issue the advice, since this could signal that the use\n+  care require a sorted container.</para></listitem>\n+</itemizedlist>\n+\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.design.reports\"\n+ xreflabel=\"Reports\">\n+<title>Reports</title>\n+  <para>\n+There are two types of reports.  First, if we recognize a pattern for which\n+we have a substitute that is likely to give better performance, we print\n+the advice and estimated performance gain.  The advice is usually associated\n+to a code position and possibly a call stack.\n+  </para>\n+  <para>\n+Second, we report performance characteristics for which we do not have\n+a clear solution for improvement.  For instance, we can point to the user\n+the top 10 <code>multimap</code> locations\n+which have the worst data locality in actual traversals.\n+Although this does not offer a solution,\n+it helps the user focus on the key problems and ignore the uninteresting ones.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.design.testing\"\n+ xreflabel=\"Testing\">\n+<title>Testing</title>\n+  <para>\n+  First, we want to make sure we preserve the behavior of the release mode.\n+  You can just type <code>\"make check-profile\"</code>, which\n+  builds and runs the whole test suite in profile mode.\n+  </para>\n+  <para>\n+  Second, we want to test the correctness of each diagnostic.\n+  We created a <code>profile</code> directory in the test suite.\n+  Each diagnostic must come with at least two tests, one for false positives\n+  and one for false negatives.\n+  </para>\n+</sect2>\n+\n+</sect1>\n+\n+<sect1 id=\"manual.ext.profile_mode.api\"\n+ xreflabel=\"API\">\n+<title>Extensions for Custom Containers</title>\n+\n+  <para>\n+  Many large projects use their own data structures instead of the ones in the\n+  standard library.  If these data structures are similar in functionality\n+  to the standard library, they can be instrumented with the same hooks\n+  that are used to instrument the standard library.\n+  The instrumentation API is exposed in file\n+  <code>profiler.h</code> (look for \"Instrumentation hooks\").\n+  </para>\n+\n+</sect1>\n+\n+\n+<sect1 id=\"manual.ext.profile_mode.cost_model\"\n+ xreflabel=\"Cost Model\">\n+<title>Empirical Cost Model</title>\n+\n+  <para>\n+  Currently, the cost model uses formulas with predefined relative weights\n+  for alternative containers or container implementations.  For instance,\n+  iterating through a vector is X times faster than iterating through a list.\n+  </para>\n+  <para>\n+  (Under development.)\n+  We are working on customizing this to a particular machine by providing\n+  an automated way to compute the actual relative weights for operations\n+  on the given machine.\n+  </para>\n+  <para>\n+  (Under development.)\n+  We plan to provide a performance parameter database format that can be\n+  filled in either by hand or by an automated training mechanism.\n+  The analysis module will then use this database instead of the built in.\n+  generic parameters.\n+  </para>\n+\n+</sect1>\n+\n+\n+<sect1 id=\"manual.ext.profile_mode.implementation\"\n+ xreflabel=\"Implementation\">\n+<title>Implementation Issues</title>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.implementation.stack\"\n+ xreflabel=\"Stack Traces\">\n+<title>Stack Traces</title>\n+  <para>\n+  Accurate stack traces are needed during profiling since we group events by\n+  call context and dynamic instance.  Without accurate traces, diagnostics\n+  may be hard to interpret.  For instance, when giving advice to the user\n+  it is imperative to reference application code, not library code.\n+  </para>\n+  <para>\n+  Currently we are using the libc <code>backtrace</code> routine to get\n+  stack traces.\n+  <code>_GLIBCXX_PROFILE_STACK_DEPTH</code> can be set\n+  to 0 if you are willing to give up call context information, or to a small\n+  positive value to reduce run time overhead.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.implementation.symbols\"\n+ xreflabel=\"Symbolization\">\n+<title>Symbolization of Instruction Addresses</title>\n+  <para>\n+  The profiling and analysis phases use only instruction addresses.\n+  An external utility such as addr2line is needed to postprocess the result.\n+  We do not plan to add symbolization support in the profile extension.\n+  This would require access to symbol tables, debug information tables,\n+  external programs or libraries and other system dependent information.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.implementation.concurrency\"\n+ xreflabel=\"Concurrency\">\n+<title>Concurrency</title>\n+  <para>\n+  Our current model is simplistic, but precise.\n+  We cannot afford to approximate because some of our diagnostics require\n+  precise matching of operations to container instance and call context.\n+  During profiling, we keep a single information table per diagnostic.\n+  There is a single lock per information table.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.implementation.stdlib-in-proflib\"\n+ xreflabel=\"Using the Standard Library in the Runtime Library\">\n+<title>Using the Standard Library in the Instrumentation Implementation</title>\n+  <para>\n+  As much as we would like to avoid uses of stdlibc++ within our \n+  instrumentation library, containers such as unordered_map are very \n+  appealing.  We plan to use them as long as they are named properly \n+  to avoid ambiguity.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.implementation.malloc-hooks\"\n+ xreflabel=\"Malloc Hooks\">\n+<title>Malloc Hooks</title>\n+  <para>\n+  User applications/libraries can provide malloc hooks.\n+  When the implementation of the malloc hooks uses stdlibc++, there can\n+  be an infinite cycle between the profile mode instrumentation and the\n+  the malloc hook code.\n+  </para>\n+  <para>\n+  We protect against reentrance to the profile mode instrumentation code,\n+  which should avoid this problem in most cases.\n+  The protection mechanism is thread safe and exception safe.\n+  This mechanism does not prevent reentrance to the malloc hook itself,\n+  which could still result in deadlock, if, for instance, the malloc hook\n+  uses non-recursive locks.\n+  XXX: A definitive solution to this problem would be for the profile extension\n+  to use a custom allocator internally, and perhaps not to use libstdc++.\n+  </para>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.implementation.construction-destruction\"\n+ xreflabel=\"Construction and Destruction of Global Objects\">\n+<title>Construction and Destruction of Global Objects</title>\n+  <para>\n+  The profiling library state is initialized at the first call to a profiling\n+  method.  This allows us to record the construction of all global objects.\n+  However, we cannot do the same at destruction time.  The trace is written\n+  by a function registered by <code>atexit</code>, thus invoked by \n+  <code>exit</code>.\n+  </para>\n+</sect2>\n+\n+</sect1>\n+\n+\n+<sect1 id=\"manual.ext.profile_mode.developer\"\n+ xreflabel=\"Developer Information\">\n+<title>Developer Information</title>\n+\n+<sect2 id=\"manual.ext.profile_mode.developer.bigpic\"\n+ xreflabel=\"Big Picture\">\n+<title>Big Picture</title>\n+\n+  <para>The profile mode headers are included with\n+   <code>-D_GLIBCXX_PROFILE</code> through preprocessor directives in \n+   <code>include/std/*</code>.\n+  </para>\n+\n+  <para>Instrumented implementations are provided in \n+   <code>include/profile/*</code>.  All instrumentation hooks are macros\n+   defined in <code>include/profile/profiler.h</code>.\n+  </para>\n+\n+  <para>All the implementation of the instrumentation hooks is in \n+   <code>include/profile/impl/*</code>.  Although all the code gets included,\n+   thus is publicly visible, only a small number of functions are called from\n+   outside this directory.  All calls to hook implementations must be\n+   done through macros defined in <code>profiler.h</code>.  The macro\n+   must ensure (1) that the call is guarded against reentrance and \n+   (2) that the call can be turned off at compile time using a\n+   <code>-D_GLIBCXX_PROFILE_...</code> compiler option.\n+  </para>\n+\n+</sect2>\n+\n+<sect2 id=\"manual.ext.profile_mode.developer.howto\"\n+ xreflabel=\"How To Add A Diagnostic\">\n+<title>How To Add A Diagnostic</title>\n+\n+  <para>Let's say the diagnostic name is \"magic\".\n+  </para>\n+\n+  <para>If you need to instrument a header not already under \n+   <code>include/profile/*</code>, first edit the corresponding header\n+   under <code>include/std/</code> and add a preprocessor directive such\n+   as the one in <code>include/std/vector</code>:\n+<programlisting>\n+#ifdef _GLIBCXX_PROFILE\n+# include &lt;profile/vector&gt;\n+#endif\n+</programlisting>\n+  </para>\n+\n+  <para>If the file you need to instrument is not yet under\n+   <code>include/profile/</code>, make a copy of the one in\n+   <code>include/debug</code>, or the main implementation.\n+   You'll need to include the main implementation and inherit the classes\n+   you want to instrument.  Then define the methods you want to instrument,\n+   define the instrumentation hooks and add calls to them.\n+   Look at <code>include/profile/vector</code> for an example.\n+  </para>\n+\n+  <para>Add macros for the instrumentation hooks in\n+   <code>include/profile/impl/profiler.h</code>.\n+   Hook names must start with <code>__profcxx_</code>.\n+   Make sure they transform\n+   in no code with <code>-D_NO_GLBICXX_PROFILE_MAGIC</code>.\n+   Make sure all calls to any method in namespace <code>__cxxprof_impl</code>\n+   is protected against reentrance using macro\n+   <code>_GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD</code>.\n+   All names of methods in namespace <code>__cxxprof_impl</code> called from\n+   <code>profiler.h</code> must start with <code>__trace_magic_</code>.\n+  </para>\n+\n+  <para>Add the implementation of the diagnostic.\n+   <itemizedlist>\n+     <listitem><para>\n+      Create new file <code>include/profile/impl/profiler_magic.h</code>.\n+     </para></listitem>\n+     <listitem><para>\n+      Define class <code>__magic_info: public __object_info_base</code>.\n+      This is the representation of a line in the object table.\n+      The <code>__merge</code> method is used to aggregate information\n+      across all dynamic instances created at the same call context.\n+      The <code>__magnitude</code> must return the estimation of the benefit\n+      as a number of small operations, e.g., number of words copied.\n+      The <code>__write</code> method is used to produce the raw trace.\n+      The <code>__advice</code> method is used to produce the advice string.\n+     </para></listitem>\n+     <listitem><para>\n+      Define class <code>__magic_stack_info: public __magic_info</code>.\n+      This defines the content of a line in the stack table.\n+     </para></listitem>\n+     <listitem><para>\n+      Define class <code>__trace_magic: public __trace_base&lt;__magic_info, \n+      __magic_stack_info&gt;</code>.\n+      It defines the content of the trace associated with this diagnostic.\n+     </para></listitem>\n+    </itemizedlist>\n+  </para>\n+\n+  <para>Add initialization and reporting calls in\n+   <code>include/profile/impl/profiler_trace.h</code>.  Use\n+   <code>__trace_vector_to_list</code> as an example.\n+  </para>\n+\n+  <para>Add documentation in file <code>doc/xml/manual/profile_mode.xml</code>.\n+  </para>\n+</sect2>\n+</sect1>\n+\n+<sect1 id=\"manual.ext.profile_mode.diagnostics\">\n+<title>Diagnostics</title>\n+\n+  <para>\n+  The table below presents all the diagnostics we intend to implement.\n+  Each diagnostic has a corresponding compile time switch\n+  <code>-D_GLIBCXX_PROFILE_&lt;diagnostic&gt;</code>.\n+  Groups of related diagnostics can be turned on with a single switch.\n+  For instance, <code>-D_GLIBCXX_PROFILE_LOCALITY</code> is equivalent to\n+  <code>-D_GLIBCXX_PROFILE_SOFTWARE_PREFETCH \n+  -D_GLIBCXX_PROFILE_RBTREE_LOCALITY</code>.\n+  </para>\n+\n+  <para>\n+  The benefit, cost, expected frequency and accuracy of each diagnostic\n+  was given a grade from 1 to 10, where 10 is highest.\n+  A high benefit means that, if the diagnostic is accurate, the expected\n+  performance improvement is high.\n+  A high cost means that turning this diagnostic on leads to high slowdown.\n+  A high frequency means that we expect this to occur relatively often.\n+  A high accuracy means that the diagnostic is unlikely to be wrong.\n+  These grades are not perfect.  They are just meant to guide users with\n+  specific needs or time budgets.\n+  </para>\n+\n+<table frame='all'>\n+<title>Diagnostics</title>\n+<tgroup cols='6' align='left' colsep='1' rowsep='1'>\n+<colspec colname='c1'></colspec>\n+<colspec colname='c2'></colspec>\n+<colspec colname='c3'></colspec>\n+<colspec colname='c4'></colspec>\n+<colspec colname='c5'></colspec>\n+<colspec colname='c6'></colspec>\n+<colspec colname='c7'></colspec>\n+\n+<thead>\n+  <row>\n+    <entry>Group</entry>\n+    <entry>Flag</entry>\n+    <entry>Benefit</entry>\n+    <entry>Cost</entry>\n+    <entry>Freq.</entry>\n+    <entry>Implemented</entry>\n+  </row>\n+</thead>\n+<tbody>\n+  <row>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.containers\">\n+    CONTAINERS</ulink></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.hashtable_too_small\">\n+    HASHTABLE_TOO_SMALL</ulink></entry>\n+    <entry>10</entry>\n+    <entry>1</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>yes</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.hashtable_too_large\">\n+    HASHTABLE_TOO_LARGE</ulink></entry>\n+    <entry>5</entry>\n+    <entry>1</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>yes</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.inefficient_hash\">\n+    INEFFICIENT_HASH</ulink></entry>\n+    <entry>7</entry>\n+    <entry>3</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>yes</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.vector_too_small\">\n+    VECTOR_TOO_SMALL</ulink></entry>\n+    <entry>8</entry>\n+    <entry>1</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>yes</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.vector_too_large\">\n+    VECTOR_TOO_LARGE</ulink></entry>\n+    <entry>5</entry>\n+    <entry>1</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>yes</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.vector_to_hashtable\">\n+    VECTOR_TO_HASHTABLE</ulink></entry>\n+    <entry>7</entry>\n+    <entry>7</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>no</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.hashtable_to_vector\">\n+    HASHTABLE_TO_VECTOR</ulink></entry>\n+    <entry>7</entry>\n+    <entry>7</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>no</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.vector_to_list\">\n+    VECTOR_TO_LIST</ulink></entry>\n+    <entry>8</entry>\n+    <entry>5</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>yes</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.list_to_vector\">\n+    LIST_TO_VECTOR</ulink></entry>\n+    <entry>10</entry>\n+    <entry>5</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>no</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.assoc_ord_to_unord\">\n+    ORDERED_TO_UNORDERED</ulink></entry>\n+    <entry>10</entry>\n+    <entry>5</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>only map/unordered_map</entry>\n+  </row>\n+  <row>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.algorithms\">\n+    ALGORITHMS</ulink></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.algorithms.sort\">\n+    SORT</ulink></entry>\n+    <entry>7</entry>\n+    <entry>8</entry>\n+    <entry></entry>\n+    <entry>7</entry>\n+    <entry>no</entry>\n+  </row>\n+  <row>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.locality\">\n+    LOCALITY</ulink></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.locality.sw_prefetch\">\n+    SOFTWARE_PREFETCH</ulink></entry>\n+    <entry>8</entry>\n+    <entry>8</entry>\n+    <entry></entry>\n+    <entry>5</entry>\n+    <entry>no</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.locality.linked\">\n+    RBTREE_LOCALITY</ulink></entry>\n+    <entry>4</entry>\n+    <entry>8</entry>\n+    <entry></entry>\n+    <entry>5</entry>\n+    <entry>no</entry>\n+  </row>\n+  <row>\n+    <entry></entry>\n+    <entry><ulink url=\"#manual.ext.profile_mode.analysis.mthread.false_share\">\n+    FALSE_SHARING</ulink></entry>\n+    <entry>8</entry>\n+    <entry>10</entry>\n+    <entry></entry>\n+    <entry>10</entry>\n+    <entry>no</entry>\n+  </row>\n+</tbody>\n+</tgroup>\n+</table>\n+\n+<sect2 id=\"manual.ext.profile_mode.analysis.template\" \n+ xreflabel=\"Template\">\n+<title>Diagnostic Template</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_&lt;diagnostic&gt;</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis>  What problem will it diagnose?\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>.\n+  What is the fundamental reason why this is a problem</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>\n+  Percentage reduction in execution time.  When reduction is more than\n+  a constant factor, describe the reduction rate formula.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>\n+  What would the advise look like?</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis>\n+  What stdlibc++ components need to be instrumented?</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  How do we decide when to issue the advice?</para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  How do we measure benefits?  Math goes here.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis>\n+<programlisting>\n+program code\n+...\n+advice sample\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.analysis.containers\" \n+ xreflabel=\"Containers\">\n+<title>Containers</title>\n+\n+<para>\n+<emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_CONTAINERS</code>.\n+</para>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.hashtable_too_small\" \n+ xreflabel=\"Hashtable Too Small\">\n+<title>Hashtable Too Small</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect hashtables with many \n+  rehash operations, small construction size and large destruction size.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis> Rehash is very expensive.\n+  Read content, follow chains within bucket, evaluate hash function, place at\n+  new location in different order.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis> 36%.\n+  Code similar to example below.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis> \n+  Set initial size to N at construction site S.\n+  </para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis> \n+  <code>unordered_set, unordered_map</code> constructor, destructor, rehash.\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  For each dynamic instance of <code>unordered_[multi]set|map</code>,\n+  record initial size and call context of the constructor.\n+  Record size increase, if any, after each relevant operation such as insert.\n+  Record the estimated rehash cost.</para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Number of individual rehash operations * cost per rehash.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1 unordered_set&lt;int&gt; us;\n+2 for (int k = 0; k &lt; 1000000; ++k) {\n+3   us.insert(k);\n+4 }\n+\n+foo.cc:1: advice: Changing initial unordered_set size from 10 to 1000000 saves 1025530 rehash operations.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.hashtable_too_large\" \n+ xreflabel=\"Hashtable Too Large\">\n+<title>Hashtable Too Large</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect hashtables which are\n+  never filled up because fewer elements than reserved are ever\n+  inserted.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis> Save memory, which\n+  is good in itself and may also improve memory reference performance through\n+  fewer cache and TLB misses.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis> unknown.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis> \n+  Set initial size to N at construction site S.\n+  </para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis> \n+  <code>unordered_set, unordered_map</code> constructor, destructor, rehash.\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  For each dynamic instance of <code>unordered_[multi]set|map</code>,\n+  record initial size and call context of the constructor, and correlate it\n+  with its size at destruction time.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Number of iteration operations + memory saved.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1 vector&lt;unordered_set&lt;int&gt;&gt; v(100000, unordered_set&lt;int&gt;(100)) ;\n+2 for (int k = 0; k &lt; 100000; ++k) {\n+3   for (int j = 0; j &lt; 10; ++j) {\n+4     v[k].insert(k + j);\n+5  }\n+6 }\n+\n+foo.cc:1: advice: Changing initial unordered_set size from 100 to 10 saves N\n+bytes of memory and M iteration steps.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.inefficient_hash\"\n+ xreflabel=\"Inefficient Hash\">\n+<title>Inefficient Hash</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_INEFFICIENT_HASH</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect hashtables with polarized\n+  distribution.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis> A non-uniform \n+  distribution may lead to long chains, thus possibly increasing complexity\n+  by a factor up to the number of elements.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis> factor up\n+   to container size.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis> Change hash function\n+  for container built at site S.  Distribution score = N.  Access score = S.\n+  Longest chain = C, in bucket B.\n+  </para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis>\n+  <code>unordered_set, unordered_map</code> constructor, destructor, [],\n+  insert, iterator.\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  Count the exact number of link traversals.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Total number of links traversed.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+class dumb_hash {\n+ public:\n+  size_t operator() (int i) const { return 0; }\n+};\n+...\n+  unordered_set&lt;int, dumb_hash&gt; hs;\n+  ...\n+  for (int i = 0; i &lt; COUNT; ++i) {\n+    hs.find(i);\n+  }\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.vector_too_small\" \n+ xreflabel=\"Vector Too Small\">\n+<title>Vector Too Small</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_VECTOR_TOO_SMALL</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis>Detect vectors with many \n+  resize operations, small construction size and large destruction size..\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>Resizing can be expensive.\n+  Copying large amounts of data takes time.  Resizing many small vectors may\n+  have allocation overhead and affect locality.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>\n+  Set initial size to N at construction site S.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis><code>vector</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  For each dynamic instance of <code>vector</code>,\n+  record initial size and call context of the constructor.\n+  Record size increase, if any, after each relevant operation such as \n+  <code>push_back</code>.  Record the estimated resize cost.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Total number of words copied * time to copy a word.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1 vector&lt;int&gt; v;\n+2 for (int k = 0; k &lt; 1000000; ++k) {\n+3   v.push_back(k);\n+4 }\n+\n+foo.cc:1: advice: Changing initial vector size from 10 to 1000000 saves \n+copying 4000000 bytes and 20 memory allocations and deallocations.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.vector_too_large\" \n+ xreflabel=\"Vector Too Large\">\n+<title>Vector Too Large</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_VECTOR_TOO_LARGE</code>\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis>Detect vectors which are\n+  never filled up because fewer elements than reserved are ever\n+  inserted.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>Save memory, which\n+  is good in itself and may also improve memory reference performance through\n+  fewer cache and TLB misses.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>\n+  Set initial size to N at construction site S.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis><code>vector</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  For each dynamic instance of <code>vector</code>,\n+  record initial size and call context of the constructor, and correlate it\n+  with its size at destruction time.</para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Total amount of memory saved.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1 vector&lt;vector&lt;int&gt;&gt; v(100000, vector&lt;int&gt;(100)) ;\n+2 for (int k = 0; k &lt; 100000; ++k) {\n+3   for (int j = 0; j &lt; 10; ++j) {\n+4     v[k].insert(k + j);\n+5  }\n+6 }\n+\n+foo.cc:1: advice: Changing initial vector size from 100 to 10 saves N\n+bytes of memory and may reduce the number of cache and TLB misses.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.vector_to_hashtable\" \n+ xreflabel=\"Vector to Hashtable\">\n+<title>Vector to Hashtable</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_VECTOR_TO_HASHTABLE</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect uses of \n+  <code>vector</code> that can be substituted with <code>unordered_set</code>\n+  to reduce execution time.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  Linear search in a vector is very expensive, whereas searching in a hashtable\n+  is very quick.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>factor up\n+   to container size.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>Replace \n+  <code>vector</code> with <code>unordered_set</code> at site S.\n+  </para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis><code>vector</code>\n+  operations and access methods.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  For each dynamic instance of <code>vector</code>,\n+  record call context of the constructor.  Issue the advice only if the\n+  only methods called on this <code>vector</code> are <code>push_back</code>, \n+  <code>insert</code> and <code>find</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Cost(vector::push_back) + cost(vector::insert) + cost(find, vector) -\n+  cost(unordered_set::insert) + cost(unordered_set::find).\n+  </para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis>\n+<programlisting>\n+1  vector&lt;int&gt; v;\n+...\n+2  for (int i = 0; i &lt; 1000; ++i) {\n+3    find(v.begin(), v.end(), i);\n+4  }\n+\n+foo.cc:1: advice: Changing \"vector\" to \"unordered_set\" will save about 500,000\n+comparisons.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.hashtable_to_vector\" \n+ xreflabel=\"Hashtable to Vector\">\n+<title>Hashtable to Vector</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_HASHTABLE_TO_VECTOR</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect uses of \n+  <code>unordered_set</code> that can be substituted with <code>vector</code>\n+  to reduce execution time.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  Hashtable iterator is slower than vector iterator.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>95%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>Replace \n+  <code>unordered_set</code> with <code>vector</code> at site S.\n+  </para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis><code>unordered_set</code>\n+  operations and access methods.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  For each dynamic instance of <code>unordered_set</code>,\n+  record call context of the constructor.  Issue the advice only if the\n+  number of <code>find</code>, <code>insert</code> and <code>[]</code> \n+  operations on this <code>unordered_set</code> are small relative to the\n+  number of elements, and methods <code>begin</code> or <code>end</code>\n+  are invoked (suggesting iteration).</para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Number of .</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis>\n+<programlisting>\n+1  unordered_set&lt;int&gt; us;\n+...\n+2  int s = 0;\n+3  for (unordered_set&lt;int&gt;::iterator it = us.begin(); it != us.end(); ++it) {\n+4    s += *it;\n+5  }\n+\n+foo.cc:1: advice: Changing \"unordered_set\" to \"vector\" will save about N\n+indirections and may achieve better data locality.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.vector_to_list\"\n+ xreflabel=\"Vector to List\">\n+<title>Vector to List</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_VECTOR_TO_LIST</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect cases where \n+  <code>vector</code> could be substituted with <code>list</code> for\n+  better performance.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  Inserting in the middle of a vector is expensive compared to inserting in a \n+  list.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>factor up to\n+   container size.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>Replace vector with list\n+  at site S.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis><code>vector</code>\n+  operations and access methods.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  For each dynamic instance of <code>vector</code>,\n+  record the call context of the constructor.  Record the overhead of each\n+  <code>insert</code> operation based on current size and insert position.\n+  Report instance with high insertion overhead.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  (Sum(cost(vector::method)) - Sum(cost(list::method)), for\n+  method in [push_back, insert, erase])\n+  + (Cost(iterate vector) - Cost(iterate list))</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1  vector&lt;int&gt; v;\n+2  for (int i = 0; i &lt; 10000; ++i) {\n+3    v.insert(v.begin(), i);\n+4  }\n+\n+foo.cc:1: advice: Changing \"vector\" to \"list\" will save about 5,000,000 \n+operations.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.list_to_vector\"\n+ xreflabel=\"List to Vector\">\n+<title>List to Vector</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_LIST_TO_VECTOR</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect cases where \n+  <code>list</code> could be substituted with <code>vector</code> for\n+  better performance.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  Iterating through a vector is faster than through a list.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>64%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>Replace list with vector\n+  at site S.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis><code>vector</code>\n+  operations and access methods.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  Issue the advice if there are no <code>insert</code> operations.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+    (Sum(cost(vector::method)) - Sum(cost(list::method)), for\n+  method in [push_back, insert, erase])\n+  + (Cost(iterate vector) - Cost(iterate list))</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1  list&lt;int&gt; l;\n+...\n+2  int sum = 0;\n+3  for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); ++it) {\n+4    sum += *it;\n+5  }\n+\n+foo.cc:1: advice: Changing \"list\" to \"vector\" will save about 1000000 indirect\n+memory references.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.assoc_ord_to_unord\"\n+ xreflabel=\"Ordered to Unordered Associative Container\">\n+<title>Ordered to Unordered Associative Container</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_ORDERED_TO_UNORDERED</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis>  Detect cases where ordered\n+  associative containers can be replaced with unordered ones.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  Insert and search are quicker in a hashtable than in \n+  a red-black tree.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>52%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>\n+  Replace set with unordered_set at site S.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis>\n+  <code>set</code>, <code>multiset</code>, <code>map</code>,\n+  <code>multimap</code> methods.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  Issue the advice only if we are not using operator <code>++</code> on any\n+  iterator on a particular <code>[multi]set|map</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  (Sum(cost(hashtable::method)) - Sum(cost(rbtree::method)), for\n+  method in [insert, erase, find])\n+  + (Cost(iterate hashtable) - Cost(iterate rbtree))</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis>\n+<programlisting>\n+1  set&lt;int&gt; s;\n+2  for (int i = 0; i &lt; 100000; ++i) {\n+3    s.insert(i);\n+4  }\n+5  int sum = 0;\n+6  for (int i = 0; i &lt; 100000; ++i) {\n+7    sum += *s.find(i);\n+8  }\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+</sect2>\n+\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.analysis.algorithms\"\n+ xreflabel=\"Algorithms\">\n+<title>Algorithms</title>\n+\n+  <para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_ALGORITHMS</code>.\n+  </para>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.algorithms.sort\"\n+ xreflabel=\"Sorting\">\n+<title>Sort Algorithm Performance</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_SORT</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Give measure of sort algorithm\n+  performance based on actual input.  For instance, advise Radix Sort over\n+  Quick Sort for a particular call context.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  See papers: \n+  <ulink url=\"http://portal.acm.org/citation.cfm?doid=1065944.1065981\">\n+  A framework for adaptive algorithm selection in STAPL</ulink> and \n+  <ulink url=\"http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=4228227\">\n+  Optimizing Sorting with Machine Learning Algorithms</ulink>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>60%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis> Change sort algorithm\n+  at site S from X Sort to Y Sort.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis> <code>sort</code>\n+  algorithm.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  Issue the advice if the cost model tells us that another sort algorithm\n+  would do better on this input.  Requires us to know what algorithm we \n+  are using in our sort implementation in release mode.</para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Runtime(algo) for algo in [radix, quick, merge, ...]</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis>\n+<programlisting>\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.analysis.locality\"\n+ xreflabel=\"Data Locality\">\n+<title>Data Locality</title>\n+\n+  <para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_LOCALITY</code>.\n+  </para>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.locality.sw_prefetch\"\n+ xreflabel=\"Need Software Prefetch\">\n+<title>Need Software Prefetch</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_SOFTWARE_PREFETCH</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Discover sequences of indirect\n+  memory accesses that are not regular, thus cannot be predicted by\n+  hardware prefetchers.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  Indirect references are hard to predict and are very expensive when they\n+  miss in caches.</para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>25%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis> Insert prefetch \n+  instruction.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis> Vector iterator and\n+  access operator [].\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  First, get cache line size and page size from system.\n+  Then record iterator dereference sequences for which the value is a pointer.\n+  For each sequence within a container, issue a warning if successive pointer \n+  addresses are not within cache lines and do not form a linear pattern\n+  (otherwise they may be prefetched by hardware).\n+  If they also step across page boundaries, make the warning stronger.\n+  </para>\n+  <para>The same analysis applies to containers other than vector.\n+  However, we cannot give the same advice for linked structures, such as list,\n+  as there is no random access to the n-th element.  The user may still be\n+  able to benefit from this information, for instance by employing frays (user\n+  level light weight threads) to hide the latency of chasing pointers.\n+  </para>\n+  <para>\n+  This analysis is a little oversimplified.  A better cost model could be\n+  created by understanding the capability of the hardware prefetcher.\n+  This model could be trained automatically by running a set of synthetic \n+  cases.\n+  </para>\n+  </listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Total distance between pointer values of successive elements in vectors\n+  of pointers.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1 int zero = 0;\n+2 vector&lt;int*&gt; v(10000000, &amp;zero);\n+3 for (int k = 0; k &lt; 10000000; ++k) {\n+4   v[random() % 10000000] = new int(k);\n+5 }\n+6 for (int j = 0; j &lt; 10000000; ++j) {\n+7   count += (*v[j] == 0 ? 0 : 1);\n+8 }\n+\n+foo.cc:7: advice: Insert prefetch instruction.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.locality.linked\"\n+ xreflabel=\"Linked Structure Locality\">\n+<title>Linked Structure Locality</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_RBTREE_LOCALITY</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Give measure of locality of\n+  objects stored in linked structures (lists, red-black trees and hashtables)\n+  with respect to their actual traversal patterns.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>Allocation can be tuned\n+  to a specific traversal pattern, to result in better data locality.\n+  See paper: \n+  <ulink url=\"http://www.springerlink.com/content/8085744l00x72662/\">\n+  Custom Memory Allocation for Free</ulink>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>30%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>\n+  High scatter score N for container built at site S.\n+  Consider changing allocation sequence or choosing a structure conscious\n+  allocator.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis> Methods of all \n+  containers using linked structures.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  First, get cache line size and page size from system.\n+  Then record the number of successive elements that are on different line\n+  or page, for each traversal method such as <code>find</code>.  Give advice\n+  only if the ratio between this number and the number of total node hops\n+  is above a threshold.</para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Sum(same_cache_line(this,previous))</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis>\n+<programlisting>\n+ 1  set&lt;int&gt; s;\n+ 2  for (int i = 0; i &lt; 10000000; ++i) {\n+ 3    s.insert(i);\n+ 4  }\n+ 5  set&lt;int&gt; s1, s2;\n+ 6  for (int i = 0; i &lt; 10000000; ++i) {\n+ 7    s1.insert(i);\n+ 8    s2.insert(i);\n+ 9  }\n+...\n+      // Fast, better locality.\n+10    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); ++it) {\n+11      sum += *it;\n+12    }\n+      // Slow, elements are further apart.\n+13    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); ++it) {\n+14      sum += *it;\n+15    }\n+\n+foo.cc:5: advice: High scatter score NNN for set built here.  Consider changing\n+the allocation sequence or switching to a structure conscious allocator.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.analysis.mthread\"\n+ xreflabel=\"Multithreaded Data Access\">\n+<title>Multithreaded Data Access</title>\n+\n+  <para>\n+  The diagnostics in this group are not meant to be implemented short term.\n+  They require compiler support to know when container elements are written\n+  to.  Instrumentation can only tell us when elements are referenced.\n+  </para>\n+\n+  <para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_MULTITHREADED</code>.\n+  </para>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.mthread.ddtest\"\n+ xreflabel=\"Dependence Violations at Container Level\">\n+<title>Data Dependence Violations at Container Level</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_DDTEST</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect container elements\n+  that are referenced from multiple threads in the parallel region or\n+  across parallel regions.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  Sharing data between threads requires communication and perhaps locking,\n+  which may be expensive.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>?%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis> Change data\n+  distribution or parallel algorithm.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis> Container access methods\n+  and iterators.\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  Keep a shadow for each container.  Record iterator dereferences and\n+  container member accesses.  Issue advice for elements referenced by\n+  multiple threads.\n+  See paper: <ulink url=\"http://portal.acm.org/citation.cfm?id=207110.207148\">\n+  The LRPD test: speculative run-time parallelization of loops with \n+  privatization and reduction parallelization</ulink>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Number of accesses to elements referenced from multiple threads\n+  </para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis>\n+<programlisting>\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+<sect3 id=\"manual.ext.profile_mode.analysis.mthread.false_share\"\n+ xreflabel=\"False Sharing\">\n+<title>False Sharing</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_FALSE_SHARING</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect elements in the\n+  same container which share a cache line, are written by at least one \n+  thread, and accessed by different threads.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis> Under these assumptions,\n+  cache protocols require\n+  communication to invalidate lines, which may be expensive.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>68%.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis> Reorganize container\n+  or use padding to avoid false sharing.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis> Container access methods\n+  and iterators.\n+  </para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  First, get the cache line size.\n+  For each shared container, record all the associated iterator dereferences \n+  and member access methods with the thread id.  Compare the address lists\n+  across threads to detect references in two different threads to the same \n+  cache line.  Issue a warning only if the ratio to total references is \n+  significant.  Do the same for iterator dereference values if they are \n+  pointers.</para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Number of accesses to same cache line from different threads.\n+  </para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1     vector&lt;int&gt; v(2, 0);\n+2 #pragma omp parallel for shared(v, SIZE) schedule(static, 1)\n+3     for (i = 0; i &lt; SIZE; ++i) {\n+4       v[i % 2] += i;\n+5     }\n+\n+OMP_NUM_THREADS=2 ./a.out\n+foo.cc:1: advice: Change container structure or padding to avoid false \n+sharing in multithreaded access at foo.cc:4.  Detected N shared cache lines.\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n+</sect2>\n+\n+\n+<sect2 id=\"manual.ext.profile_mode.analysis.statistics\" \n+ xreflabel=\"Statistics\">\n+<title>Statistics</title>\n+\n+<para>\n+<emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_STATISTICS</code>.\n+</para>\n+\n+<para>\n+  In some cases the cost model may not tell us anything because the costs\n+  appear to offset the benefits.  Consider the choice between a vector and\n+  a list.  When there are both inserts and iteration, an automatic advice\n+  may not be issued.  However, the programmer may still be able to make use\n+  of this information in a different way.\n+</para>\n+<para>\n+  This diagnostic will not issue any advice, but it will print statistics for\n+  each container construction site.  The statistics will contain the cost\n+  of each operation actually performed on the container.\n+</para>\n+\n+</sect2>\n+\n+\n+</sect1>\n+\n+\n+<bibliography id=\"profile_mode.biblio\">\n+<title>Bibliography</title>\n+\n+  <biblioentry>\n+    <title>\n+      Perflint: A Context Sensitive Performance Advisor for C++ Programs\n+    </title>\n+\n+    <author>\n+      <firstname>Lixia</firstname>\n+      <surname>Liu</surname>\n+    </author>\n+    <author>\n+      <firstname>Silvius</firstname>\n+      <surname>Rus</surname>\n+    </author>\n+\n+    <copyright>\n+      <year>2009</year>\n+      <holder></holder>\n+    </copyright>\n+\n+    <publisher>\n+      <publishername>\n+\tProceedings of the 2009 International Symposium on Code Generation\n+        and Optimization\n+      </publishername>\n+    </publisher>\n+  </biblioentry> \n+</bibliography>\n+\n+\n+</chapter>"}, {"sha": "f3dcd19b79f1236f1ca769580efe64540b540278", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -1,4 +1,4 @@\n-## Makefile for the include subdirectory of the GNU C++ Standard library.\n+#o# Makefile for the include subdirectory of the GNU C++ Standard library.\n ##\n ## Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n ## Free Software Foundation, Inc.\n@@ -771,6 +771,37 @@ else\n parallel_headers =\n endif\n \n+# Profile mode headers\n+profile_srcdir = ${glibcxx_srcdir}/include/profile\n+profile_builddir = ./profile\n+profile_headers = \\\n+\t${profile_srcdir}/base.h \\\n+\t${profile_srcdir}/unordered_map \\\n+\t${profile_srcdir}/unordered_set \\\n+\t${profile_srcdir}/vector \\\n+\t${profile_srcdir}/bitset \\\n+\t${profile_srcdir}/deque \\\n+\t${profile_srcdir}/list \\\n+\t${profile_srcdir}/map \\\n+\t${profile_srcdir}/map.h \\\n+\t${profile_srcdir}/multimap.h \\\n+\t${profile_srcdir}/multiset.h \\\n+\t${profile_srcdir}/set \\\n+\t${profile_srcdir}/set.h \\\n+\t${profile_srcdir}/hashtable.h\n+profile_impl_srcdir = ${glibcxx_srcdir}/include/profile/impl\n+profile_impl_builddir = ./profile/impl\n+profile_impl_headers = \\\n+\t${profile_impl_srcdir}/profiler.h \\\n+\t${profile_impl_srcdir}/profiler_container_size.h \\\n+\t${profile_impl_srcdir}/profiler_hash_func.h \\\n+\t${profile_impl_srcdir}/profiler_hashtable_size.h \\\n+\t${profile_impl_srcdir}/profiler_map_to_unordered_map.h \\\n+\t${profile_impl_srcdir}/profiler_node.h \\\n+\t${profile_impl_srcdir}/profiler_state.h \\\n+\t${profile_impl_srcdir}/profiler_trace.h \\\n+\t${profile_impl_srcdir}/profiler_vector_size.h \\\n+\t${profile_impl_srcdir}/profiler_vector_to_list.h\n \n # Some of the different \"C\" header models need extra files.\n # Some \"C\" header schemes require the \"C\" compatibility headers.\n@@ -865,7 +896,8 @@ endif\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_base_extra \\\n \tstamp-c_compatibility  stamp-backward stamp-ext stamp-pb \\\n-\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-parallel stamp-host\n+\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-parallel stamp-host \\\n+    stamp-profile stamp-profile-impl\n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -989,6 +1021,16 @@ stamp-parallel: ${parallel_headers}\n \t@-cd ${parallel_builddir} && $(LN_S) $? . 2>/dev/null\n \t@$(STAMP) stamp-parallel\n \n+stamp-profile: ${profile_headers}\n+\t@-mkdir -p ${profile_builddir}\n+\t@-cd ${profile_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-profile\n+\n+stamp-profile-impl: ${profile_impl_headers}\n+\t@-mkdir -p ${profile_impl_builddir}\n+\t@-cd ${profile_impl_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-profile-impl\n+\n stamp-${host_alias}:\n \t@-mkdir -p ${host_builddir}\n \t@$(STAMP) stamp-${host_alias}\n@@ -1217,6 +1259,12 @@ install-headers:\n \t  $(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${parallel_builddir};\\\n \tfor file in $$parallel_headers_install; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${parallel_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${profile_builddir}\n+\tfor file in ${profile_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${profile_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${profile_impl_builddir}\n+\tfor file in ${profile_impl_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${profile_impl_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${host_installdir}\n \tfor file in ${host_headers} ${host_headers_extra} \\\n \t ${thread_host_headers}; do \\"}, {"sha": "4c69a2be288093a9b58e81d7ca035c92fc8f1e57", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -1001,6 +1001,39 @@ parallel_builddir = ./parallel\n @ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/unique_copy.h \\\n @ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/workstealing.h\n \n+\n+# Profile mode headers\n+profile_srcdir = ${glibcxx_srcdir}/include/profile\n+profile_builddir = ./profile\n+profile_headers = \\\n+    ${profile_srcdir}/base.h \\\n+    ${profile_srcdir}/unordered_map \\\n+    ${profile_srcdir}/unordered_set \\\n+    ${profile_srcdir}/vector \\\n+    ${profile_srcdir}/bitset \\\n+    ${profile_srcdir}/deque \\\n+    ${profile_srcdir}/list \\\n+    ${profile_srcdir}/map \\\n+    ${profile_srcdir}/map.h \\\n+    ${profile_srcdir}/multimap.h \\\n+    ${profile_srcdir}/multiset.h \\\n+    ${profile_srcdir}/set \\\n+    ${profile_srcdir}/set.h \\\n+    ${profile_srcdir}/hashtable.h\n+profile_impl_srcdir = ${glibcxx_srcdir}/include/profile/impl\n+profile_impl_builddir = ./profile/impl\n+profile_impl_headers = \\\n+\t${profile_impl_srcdir}/profiler.h \\\n+\t${profile_impl_srcdir}/profiler_container_size.h \\\n+\t${profile_impl_srcdir}/profiler_hash_func.h \\\n+\t${profile_impl_srcdir}/profiler_hashtable_size.h \\\n+\t${profile_impl_srcdir}/profiler_map_to_unordered_map.h \\\n+\t${profile_impl_srcdir}/profiler_node.h \\\n+\t${profile_impl_srcdir}/profiler_state.h \\\n+\t${profile_impl_srcdir}/profiler_trace.h \\\n+\t${profile_impl_srcdir}/profiler_vector_size.h \\\n+\t${profile_impl_srcdir}/profiler_vector_to_list.h\n+\n @GLIBCXX_C_HEADERS_EXTRA_FALSE@c_base_headers_extra = \n \n # Some of the different \"C\" header models need extra files.\n@@ -1083,7 +1116,8 @@ PCHFLAGS = -x c++-header $(CXXFLAGS)\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_base_extra \\\n \tstamp-c_compatibility  stamp-backward stamp-ext stamp-pb \\\n-\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-parallel stamp-host\n+\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-parallel stamp-host \\\n+    stamp-profile stamp-profile-impl\n \n \n # List of all files that are created by explicit building, editing, or\n@@ -1400,6 +1434,16 @@ stamp-parallel: ${parallel_headers}\n \t@-cd ${parallel_builddir} && $(LN_S) $? . 2>/dev/null\n \t@$(STAMP) stamp-parallel\n \n+stamp-profile: ${profile_headers}\n+\t@-mkdir -p ${profile_builddir}\n+\t@-cd ${profile_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-profile\n+\n+stamp-profile-impl: ${profile_impl_headers}\n+\t@-mkdir -p ${profile_impl_builddir}\n+\t@-cd ${profile_impl_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-profile-impl\n+\n stamp-${host_alias}:\n \t@-mkdir -p ${host_builddir}\n \t@$(STAMP) stamp-${host_alias}\n@@ -1616,6 +1660,13 @@ install-headers:\n \t  $(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${parallel_builddir};\\\n \tfor file in $$parallel_headers_install; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${parallel_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${profile_builddir} \\\n+\t\t$(DESTDIR)${gxx_include_dir}/${profile_builddir}/impl\n+\tfor file in ${profile_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${profile_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${profile_impl_builddir}\n+\tfor file in ${profile_impl_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${profile_impl_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${host_installdir}\n \tfor file in ${host_headers} ${host_headers_extra} \\\n \t ${thread_host_headers}; do \\"}, {"sha": "cb31687c0086601a8140d043c9f26bfe29aee0c4", "filename": "libstdc++-v3/include/backward/hash_map", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -58,7 +58,11 @@\n \n #include \"backward_warning.h\"\n #include <bits/c++config.h>\n+#ifdef _GLIBCXX_PROFILE\n+#include <profile/hashtable.h>\n+#else\n #include <backward/hashtable.h>\n+#endif\n #include <bits/concept_check.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)"}, {"sha": "d2bd03bb0b3dfc4994856f233763b1c1cfccfccc", "filename": "libstdc++-v3/include/backward/hash_set", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -58,7 +58,11 @@\n \n #include \"backward_warning.h\"\n #include <bits/c++config.h>\n+#ifdef _GLIBCXX_PROFILE\n+#include <profile/hashtable.h>\n+#else\n #include <backward/hashtable.h>\n+#endif\n #include <bits/concept_check.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)"}, {"sha": "724f373ebae87cf90edebc533de1dbe46e966cb1", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -85,11 +85,17 @@\n # define _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL 1\n #endif\n \n+// Namespace association for profile\n+#ifdef _GLIBCXX_PROFILE\n+# define _GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE 1\n+#endif\n+\n #define _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION \n \n // Defined if any namespace association modes are active.\n #if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG \\\n   || _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL \\\n+  || _GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE \\\n   || _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION\n # define _GLIBCXX_USE_NAMESPACE_ASSOCIATION 1\n #endif\n@@ -108,6 +114,7 @@\n #ifndef _GLIBCXX_USE_NAMESPACE_ASSOCIATION\n # define _GLIBCXX_STD_D _GLIBCXX_STD\n # define _GLIBCXX_STD_P _GLIBCXX_STD\n+# define _GLIBCXX_STD_PR _GLIBCXX_STD\n # define _GLIBCXX_STD std\n # define _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, Y) _GLIBCXX_BEGIN_NAMESPACE(X)\n # define _GLIBCXX_END_NESTED_NAMESPACE _GLIBCXX_END_NAMESPACE\n@@ -124,7 +131,7 @@\n # endif\n \n //  debug\n-# if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG && !_GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL\n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG && !_GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL && !_GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE\n #  define _GLIBCXX_STD_D __norm\n #  define _GLIBCXX_STD_P _GLIBCXX_STD\n #  define _GLIBCXX_STD __cxx1998\n@@ -134,7 +141,7 @@\n # endif\n \n // parallel\n-# if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL && !_GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG \n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL && !_GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG && !_GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE\n #  define _GLIBCXX_STD_D _GLIBCXX_STD\n #  define _GLIBCXX_STD_P __norm\n #  define _GLIBCXX_STD __cxx1998\n@@ -144,7 +151,7 @@\n # endif\n \n // debug + parallel\n-# if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL && _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG \n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL && _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG  && !_GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE\n #  define _GLIBCXX_STD_D __norm\n #  define _GLIBCXX_STD_P __norm\n #  define _GLIBCXX_STD __cxx1998\n@@ -153,6 +160,21 @@\n #  define _GLIBCXX_EXTERN_TEMPLATE -1\n # endif\n \n+// profile\n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE\n+#  if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL || _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG\n+#   error Cannot use -D_GLIBCXX_PROFILE with -D_GLIBCXX_DEBUG or \\\n+    -D_GLIBCXX_PARALLEL\n+#  endif\n+#  define _GLIBCXX_STD_D __norm\n+#  define _GLIBCXX_STD_P _GLIBCXX_STD\n+#  define _GLIBCXX_STD_PR __norm\n+#  define _GLIBCXX_STD __cxx1998\n+#  define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY_ATTR(default) { \n+#  define _GLIBCXX_END_NAMESPACE }\n+#  define _GLIBCXX_EXTERN_TEMPLATE -1\n+# endif\n+\n # if __NO_INLINE__ && !__GXX_WEAK__\n #  warning currently using namespace associated mode which may fail \\\n    without inlining due to lack of weak symbols\n@@ -163,7 +185,7 @@\n #endif\n \n // Namespace associations for debug mode.\n-#if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG\n+#if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG && !_GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE\n namespace std\n { \n   namespace __norm { } \n@@ -182,6 +204,16 @@ namespace std\n }\n #endif\n \n+// Namespace associations for profile mode\n+#if _GLIBCXX_NAMESPACE_ASSOCIATION_PROFILE\n+namespace std\n+{ \n+  namespace __norm { } \n+  inline namespace __profile { }\n+  inline namespace __cxx1998 { }\n+}\n+#endif\n+\n // Namespace associations for versioning mode.\n #if _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION\n namespace std"}, {"sha": "de7bfe9a56f877c1016a08f2a15c84258781af92", "filename": "libstdc++-v3/include/profile/base.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbase.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,68 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/base.h\n+ *  @brief Sequential helper functions.\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+// Written by Lixia Liu\n+\n+#ifndef _GLIBCXX_PROFILE_BASE_H\n+#define _GLIBCXX_PROFILE_BASE_H 1\n+\n+#include <cstdio>\n+#include <functional>\n+#include <bits/c++config.h>\n+#include <profile/impl/profiler.h>\n+\n+// Profiling mode namespaces.\n+\n+/**\n+ * @namespace std::__profile\n+ * @brief GNU profile code, replaces standard behavior with profile behavior.\n+ */\n+namespace std \n+{ \n+  namespace __profile { } \n+}\n+\n+/**\n+ * @namespace __gnu_profile\n+ * @brief GNU profile code for public use.\n+ */\n+namespace __gnu_profile\n+{\n+  // Import all the profile versions of components in namespace std.\n+  using namespace std::__profile;\n+}\n+\n+\n+#endif /* _GLIBCXX_PROFILE_BASE_H */"}, {"sha": "96a59ea4ad99aea287287d8107499daac7cf9f37", "filename": "libstdc++-v3/include/profile/bitset", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbitset?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,345 @@\n+// Profiling bitset implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/bitset\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_BITSET\n+#define _GLIBCXX_PROFILE_BITSET\n+\n+#include <bitset>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Bitset wrapper with performance instrumentation.  */\n+  template<size_t _Nb>\n+    class bitset\n+    : public _GLIBCXX_STD_D::bitset<_Nb>\n+    {\n+      typedef _GLIBCXX_STD_D::bitset<_Nb> _Base;\n+\n+    public:\n+      // bit reference:\n+      class reference\n+      : private _Base::reference\n+      {\n+\ttypedef typename _Base::reference _Base_ref;\n+\n+\tfriend class bitset;\n+\treference();\n+\n+\treference(const _Base_ref& __base, bitset* __seq)\n+\t: _Base_ref(__base)\n+\t{ }\n+\n+      public:\n+\treference(const reference& __x)\n+\t: _Base_ref(__x)\n+\t{ }\n+\n+\treference&\n+\toperator=(bool __x)\n+\t{\n+\t  *static_cast<_Base_ref*>(this) = __x;\n+\t  return *this;\n+\t}\n+\n+\treference&\n+\toperator=(const reference& __x)\n+\t{\n+\t  *static_cast<_Base_ref*>(this) = __x;\n+\t  return *this;\n+\t}\n+\n+\tbool\n+\toperator~() const\n+\t{\n+\t  return ~(*static_cast<const _Base_ref*>(this));\n+\t}\n+\n+\toperator bool() const\n+\t{\n+\t  return *static_cast<const _Base_ref*>(this);\n+\t}\n+\n+\treference&\n+\tflip()\n+\t{\n+\t  _Base_ref::flip();\n+\t  return *this;\n+\t}\n+      };\n+\n+      // 23.3.5.1 constructors:\n+      bitset() : _Base() { }\n+\n+      bitset(unsigned long __val) : _Base(__val) { }\n+\n+      template<typename _CharT, typename _Traits, typename _Alloc>\n+        explicit\n+        bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __str,\n+\t       typename std::basic_string<_CharT, _Traits, _Alloc>::size_type\n+\t       __pos = 0,\n+\t       typename std::basic_string<_CharT, _Traits, _Alloc>::size_type\n+\t       __n = (std::basic_string<_CharT, _Traits, _Alloc>::npos))\n+\t: _Base(__str, __pos, __n) { }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 396. what are characters zero and one.\n+      template<class _CharT, class _Traits, class _Alloc>\n+\tbitset(const std::basic_string<_CharT, _Traits, _Alloc>& __str,\n+\t       typename std::basic_string<_CharT, _Traits, _Alloc>::size_type\n+\t       __pos,\n+\t       typename std::basic_string<_CharT, _Traits, _Alloc>::size_type\n+\t       __n,\n+\t       _CharT __zero, _CharT __one = _CharT('1'))\n+\t: _Base(__str, __pos, __n, __zero, __one) { }\n+\n+      bitset(const _Base& __x) : _Base(__x) { }\n+\n+      // 23.3.5.2 bitset operations:\n+      bitset<_Nb>&\n+      operator&=(const bitset<_Nb>& __rhs)\n+      {\n+\t_M_base() &= __rhs;\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      operator|=(const bitset<_Nb>& __rhs)\n+      {\n+\t_M_base() |= __rhs;\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      operator^=(const bitset<_Nb>& __rhs)\n+      {\n+\t_M_base() ^= __rhs;\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      operator<<=(size_t __pos)\n+      {\n+\t_M_base() <<= __pos;\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      operator>>=(size_t __pos)\n+      {\n+\t_M_base() >>= __pos;\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      set()\n+      {\n+\t_Base::set();\n+\treturn *this;\n+      }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 186. bitset::set() second parameter should be bool\n+      bitset<_Nb>&\n+      set(size_t __pos, bool __val = true)\n+      {\n+\t_Base::set(__pos, __val);\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      reset()\n+      {\n+\t_Base::reset();\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      reset(size_t __pos)\n+      {\n+\t_Base::reset(__pos);\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb> operator~() const { return bitset(~_M_base()); }\n+\n+      bitset<_Nb>&\n+      flip()\n+      {\n+\t_Base::flip();\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      flip(size_t __pos)\n+      {\n+\t_Base::flip(__pos);\n+\treturn *this;\n+      }\n+\n+      // element access:\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 11. Bitset minor problems\n+      reference\n+      operator[](size_t __pos)\n+      {\n+\treturn reference(_M_base()[__pos], this);\n+      }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 11. Bitset minor problems\n+      bool\n+      operator[](size_t __pos) const\n+      {\n+\treturn _M_base()[__pos];\n+      }\n+\n+      using _Base::to_ulong;\n+\n+      template <typename _CharT, typename _Traits, typename _Alloc>\n+        std::basic_string<_CharT, _Traits, _Alloc>\n+        to_string() const\n+        { return _M_base().template to_string<_CharT, _Traits, _Alloc>(); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 396. what are characters zero and one.\n+      template<class _CharT, class _Traits, class _Alloc>\n+\tstd::basic_string<_CharT, _Traits, _Alloc>\n+\tto_string(_CharT __zero, _CharT __one = _CharT('1')) const\n+\t{\n+\t  return _M_base().template\n+\t    to_string<_CharT, _Traits, _Alloc>(__zero, __one);\n+\t}\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 434. bitset::to_string() hard to use.\n+      template<typename _CharT, typename _Traits>\n+        std::basic_string<_CharT, _Traits, std::allocator<_CharT> >\n+        to_string() const\n+        { return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 853. to_string needs updating with zero and one.\n+      template<class _CharT, class _Traits>\n+\tstd::basic_string<_CharT, _Traits, std::allocator<_CharT> >\n+\tto_string(_CharT __zero, _CharT __one = _CharT('1')) const\n+\t{ return to_string<_CharT, _Traits,\n+\t                   std::allocator<_CharT> >(__zero, __one); }\n+\n+      template<typename _CharT>\n+        std::basic_string<_CharT, std::char_traits<_CharT>,\n+                          std::allocator<_CharT> >\n+        to_string() const\n+        {\n+          return to_string<_CharT, std::char_traits<_CharT>,\n+                           std::allocator<_CharT> >();\n+        }\n+\n+      template<class _CharT>\n+\tstd::basic_string<_CharT, std::char_traits<_CharT>,\n+\t                  std::allocator<_CharT> >\n+\tto_string(_CharT __zero, _CharT __one = _CharT('1')) const\n+\t{\n+\t  return to_string<_CharT, std::char_traits<_CharT>,\n+\t                   std::allocator<_CharT> >(__zero, __one);\n+\t}\n+\n+      std::basic_string<char, std::char_traits<char>, std::allocator<char> >\n+      to_string() const\n+      {\n+\treturn to_string<char,std::char_traits<char>,std::allocator<char> >();\n+      }\n+\n+      std::basic_string<char, std::char_traits<char>, std::allocator<char> >\n+      to_string(char __zero, char __one = '1') const\n+      {\n+\treturn to_string<char, std::char_traits<char>,\n+\t                 std::allocator<char> >(__zero, __one);\n+      }\n+\n+      using _Base::count;\n+      using _Base::size;\n+\n+      bool\n+      operator==(const bitset<_Nb>& __rhs) const\n+      { return _M_base() == __rhs; }\n+\n+      bool\n+      operator!=(const bitset<_Nb>& __rhs) const\n+      { return _M_base() != __rhs; }\n+\n+      using _Base::test;\n+      using _Base::all;\n+      using _Base::any;\n+      using _Base::none;\n+\n+      bitset<_Nb>\n+      operator<<(size_t __pos) const\n+      { return bitset<_Nb>(_M_base() << __pos); }\n+\n+      bitset<_Nb>\n+      operator>>(size_t __pos) const\n+      { return bitset<_Nb>(_M_base() >> __pos); }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+    };\n+\n+  template<size_t _Nb>\n+    bitset<_Nb>\n+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    { return bitset<_Nb>(__x) &= __y; }\n+\n+  template<size_t _Nb>\n+    bitset<_Nb>\n+    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    { return bitset<_Nb>(__x) |= __y; }\n+\n+  template<size_t _Nb>\n+    bitset<_Nb>\n+    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    { return bitset<_Nb>(__x) ^= __y; }\n+\n+  template<typename _CharT, typename _Traits, size_t _Nb>\n+    std::basic_istream<_CharT, _Traits>&\n+    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n+    { return __is >> __x._M_base(); }\n+\n+  template<typename _CharT, typename _Traits, size_t _Nb>\n+    std::basic_ostream<_CharT, _Traits>&\n+    operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n+\t       const bitset<_Nb>& __x)\n+    { return __os << __x._M_base(); }\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "6ba3679e0c6332f020f9c39a7a016f11c33c0ee0", "filename": "libstdc++-v3/include/profile/deque", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,420 @@\n+// Profiling deque implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/deque\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_DEQUE\n+#define _GLIBCXX_PROFILE_DEQUE 1\n+\n+#include <deque>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Deque wrapper with performance instrumentation.  */\n+  template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n+    class deque\n+    : public _GLIBCXX_STD_D::deque<_Tp, _Allocator>\n+    {\n+      typedef  _GLIBCXX_STD_D::deque<_Tp, _Allocator> _Base;\n+\n+    public:\n+      typedef typename _Base::reference             reference;\n+      typedef typename _Base::const_reference       const_reference;\n+\n+      typedef typename _Base::iterator             iterator;\n+      typedef typename _Base::const_iterator       const_iterator;\n+      typedef typename _Base::reverse_iterator     reverse_iterator;\n+      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+\n+      typedef _Tp\t\t\t\t    value_type;\n+      typedef _Allocator\t\t\t    allocator_type;\n+      typedef typename _Base::pointer               pointer;\n+      typedef typename _Base::const_pointer         const_pointer;\n+\n+      // 23.2.1.1 construct/copy/destroy:\n+      explicit deque(const _Allocator& __a = _Allocator())\n+      : _Base(__a) { }\n+\n+      explicit deque(size_type __n, const _Tp& __value = _Tp(),\n+\t\t     const _Allocator& __a = _Allocator())\n+      : _Base(__n, __value, __a) { }\n+\n+      template<class _InputIterator>\n+        deque(_InputIterator __first, _InputIterator __last,\n+\t      const _Allocator& __a = _Allocator())\n+\t: _Base(__first, __last, __a)\n+        { }\n+\n+      deque(const deque& __x)\n+      : _Base(__x) { }\n+\n+      deque(const _Base& __x)\n+      : _Base(__x) { }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      deque(deque&& __x)\n+      : _Base(std::forward<deque>(__x))\n+      { }\n+\n+      deque(initializer_list<value_type> __l,\n+\t    const allocator_type& __a = allocator_type())\n+      : _Base(__l, __a) { }\n+#endif\n+\n+      ~deque() { }\n+\n+      deque&\n+      operator=(const deque& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      deque&\n+      operator=(deque&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\t  \n+\treturn *this;\n+      }\n+\n+      deque&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\t*static_cast<_Base*>(this) = __l;\n+\treturn *this;\n+      }\n+#endif\n+\n+      template<class _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  _Base::assign(__first, __last);\n+\t}\n+\n+      void\n+      assign(size_type __n, const _Tp& __t)\n+      {\n+\t_Base::assign(__n, __t);\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      assign(initializer_list<value_type> __l)\n+      {\n+\t_Base::assign(__l);\n+      }\n+#endif\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin()); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end()); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end()); }\n+\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end()); }\n+\n+      const_reverse_iterator\n+      crbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      crend() const\n+      { return const_reverse_iterator(begin()); }\n+#endif\n+\n+      // 23.2.1.2 capacity:\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      void\n+      resize(size_type __sz, _Tp __c = _Tp())\n+      {\n+\t_Base::resize(__sz, __c);\n+      }\n+\n+      using _Base::empty;\n+\n+      // element access:\n+      reference\n+      operator[](size_type __n)\n+      {\n+\treturn _M_base()[__n];\n+      }\n+\n+      const_reference\n+      operator[](size_type __n) const\n+      {\n+\treturn _M_base()[__n];\n+      }\n+\n+      using _Base::at;\n+\n+      reference\n+      front()\n+      {\n+\treturn _Base::front();\n+      }\n+\n+      const_reference\n+      front() const\n+      {\n+\treturn _Base::front();\n+      }\n+\n+      reference\n+      back()\n+      {\n+\treturn _Base::back();\n+      }\n+\n+      const_reference\n+      back() const\n+      {\n+\treturn _Base::back();\n+      }\n+\n+      // 23.2.1.3 modifiers:\n+      void\n+      push_front(const _Tp& __x)\n+      {\n+\t_Base::push_front(__x);\n+      }\n+\n+      void\n+      push_back(const _Tp& __x)\n+      {\n+\t_Base::push_back(__x);\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      push_front(_Tp&& __x)\n+      { emplace_front(std::move(__x)); }\n+\n+      void\n+      push_back(_Tp&& __x)\n+      { emplace_back(std::move(__x)); }\n+\n+      template<typename... _Args>\n+        void\n+        emplace_front(_Args&&... __args)\n+\t{\n+\t  _Base::emplace_front(std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename... _Args>\n+        void\n+        emplace_back(_Args&&... __args)\n+\t{\n+\t  _Base::emplace_back(std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename... _Args>\n+        iterator\n+        emplace(iterator __position, _Args&&... __args)\n+\t{\n+\t  typename _Base::iterator __res = _Base::emplace(__position,\n+\t\t\t\t\t    std::forward<_Args>(__args)...);\n+\t  return iterator(__res);\n+\t}\n+#endif\n+\n+      iterator\n+      insert(iterator __position, const _Tp& __x)\n+      {\n+\ttypename _Base::iterator __res = _Base::insert(__position, __x);\n+\treturn iterator(__res);\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(iterator __position, _Tp&& __x)\n+      { return emplace(__position, std::move(__x)); }\n+\n+      void\n+      insert(iterator __p, initializer_list<value_type> __l)\n+      {\n+\t_Base::insert(__p, __l);\n+      }\n+#endif\n+\n+      void\n+      insert(iterator __position, size_type __n, const _Tp& __x)\n+      {\n+\t_Base::insert(__position, __n, __x);\n+      }\n+\n+      template<class _InputIterator>\n+        void\n+        insert(iterator __position,\n+\t       _InputIterator __first, _InputIterator __last)\n+        {\n+\t  _Base::insert(__position, __first, __last);\n+\t}\n+\n+      void\n+      pop_front()\n+      {\n+\t_Base::pop_front();\n+      }\n+\n+      void\n+      pop_back()\n+      {\n+\t_Base::pop_back();\n+      }\n+\n+      iterator\n+      erase(iterator __position)\n+      {\n+\tif (__position == begin() || __position == end()-1)\n+\t  {\n+\t    return iterator(_Base::erase(__position));\n+\t  }\n+\telse\n+\t  {\n+\t    typename _Base::iterator __res = _Base::erase(__position);\n+\t    return iterator(__res);\n+\t  }\n+      }\n+\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+        return iterator(_Base::erase(__first, __last));\n+      }\n+\n+      void\n+      swap(deque& __x)\n+      {\n+\t_Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      {\n+\t_Base::clear();\n+      }\n+\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const deque<_Tp, _Alloc>& __lhs,\n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const deque<_Tp, _Alloc>& __lhs,\n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const deque<_Tp, _Alloc>& __lhs,\n+\t      const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const deque<_Tp, _Alloc>& __lhs,\n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const deque<_Tp, _Alloc>& __lhs,\n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const deque<_Tp, _Alloc>& __lhs,\n+\t      const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(deque<_Tp, _Alloc>& __lhs, deque<_Tp, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "20891877121291e0194afcabe834a88a21e0a718", "filename": "libstdc++-v3/include/profile/hashtable.h", "status": "added", "additions": 1151, "deletions": 0, "changes": 1151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fhashtable.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,1151 @@\n+// Hashtable implementation used by containers -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+/** @file profile/hashtable.h copied from backward/hashtable.h\n+ *  This file is a GNU extension to the Standard C++ Library (possibly\n+ *  containing extensions from the HP/SGI STL subset).\n+ */\n+\n+#ifndef _HASHTABLE_H\n+#define _HASHTABLE_H 1\n+\n+// Hashtable class, used to implement the hashed associative containers\n+// hash_set, hash_map, hash_multiset, and hash_multimap.\n+// Skip instrumentation on vector.\n+#include <vector>\n+#include <iterator>\n+#include <algorithm>\n+#include <bits/stl_function.h>\n+#include <backward/hash_fun.h>\n+#include <profile/base.h>\n+\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n+\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  using std::forward_iterator_tag;\n+  using std::input_iterator_tag;\n+  using std::_Construct;\n+  using std::_Destroy;\n+  using std::distance;\n+  using std::_GLIBCXX_STD_D::vector;\n+  using std::pair;\n+  using std::__iterator_category;\n+\n+  template<class _Val>\n+    struct _Hashtable_node\n+    {\n+      _Hashtable_node* _M_next;\n+      _Val _M_val;\n+    };\n+\n+  template<class _Val, class _Key, class _HashFcn, class _ExtractKey, \n+\t   class _EqualKey, class _Alloc = std::allocator<_Val> >\n+    class hashtable;\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_iterator;\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_const_iterator;\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_iterator\n+    {\n+      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n+        _Hashtable;\n+      typedef _Hashtable_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t  _ExtractKey, _EqualKey, _Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n+        const_iterator;\n+      typedef _Hashtable_node<_Val> _Node;\n+      typedef forward_iterator_tag iterator_category;\n+      typedef _Val value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef size_t size_type;\n+      typedef _Val& reference;\n+      typedef _Val* pointer;\n+      \n+      _Node* _M_cur;\n+      _Hashtable* _M_ht;\n+\n+      _Hashtable_iterator(_Node* __n, _Hashtable* __tab)\n+      : _M_cur(__n), _M_ht(__tab) { }\n+\n+      _Hashtable_iterator() { }\n+\n+      reference\n+      operator*() const\n+      { return _M_cur->_M_val; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      iterator&\n+      operator++();\n+\n+      iterator\n+      operator++(int);\n+\n+      bool\n+      operator==(const iterator& __it) const\n+      { return _M_cur == __it._M_cur; }\n+\n+      bool\n+      operator!=(const iterator& __it) const\n+      { return _M_cur != __it._M_cur; }\n+    };\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_const_iterator\n+    {\n+      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n+        _Hashtable;\n+      typedef _Hashtable_iterator<_Val,_Key,_HashFcn,\n+\t\t\t\t  _ExtractKey,_EqualKey,_Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n+        const_iterator;\n+      typedef _Hashtable_node<_Val> _Node;\n+\n+      typedef forward_iterator_tag iterator_category;\n+      typedef _Val value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef size_t size_type;\n+      typedef const _Val& reference;\n+      typedef const _Val* pointer;\n+      \n+      const _Node* _M_cur;\n+      const _Hashtable* _M_ht;\n+\n+      _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n+      : _M_cur(__n), _M_ht(__tab) { }\n+\n+      _Hashtable_const_iterator() { }\n+\n+      _Hashtable_const_iterator(const iterator& __it)\n+      : _M_cur(__it._M_cur), _M_ht(__it._M_ht) { }\n+\n+      reference\n+      operator*() const\n+      { return _M_cur->_M_val; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      const_iterator&\n+      operator++();\n+\n+      const_iterator\n+      operator++(int);\n+\n+      bool\n+      operator==(const const_iterator& __it) const\n+      { return _M_cur == __it._M_cur; }\n+\n+      bool\n+      operator!=(const const_iterator& __it) const\n+      { return _M_cur != __it._M_cur; }\n+    };\n+\n+  // Note: assumes long is at least 32 bits.\n+  enum { _S_num_primes = 28 };\n+\n+  static const unsigned long __stl_prime_list[_S_num_primes] =\n+    {\n+      53ul,         97ul,         193ul,       389ul,       769ul,\n+      1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n+      49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n+      1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n+      50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,\n+      1610612741ul, 3221225473ul, 4294967291ul\n+    };\n+\n+  inline unsigned long\n+  __stl_next_prime(unsigned long __n)\n+  {\n+    const unsigned long* __first = __stl_prime_list;\n+    const unsigned long* __last = __stl_prime_list + (int)_S_num_primes;\n+    const unsigned long* pos = std::lower_bound(__first, __last, __n);\n+    return pos == __last ? *(__last - 1) : *pos;\n+  }\n+\n+  // Forward declaration of operator==.  \n+  template<class _Val, class _Key, class _HF, class _Ex,\n+\t   class _Eq, class _All>\n+    class hashtable;\n+\n+  template<class _Val, class _Key, class _HF, class _Ex,\n+\t   class _Eq, class _All>\n+    bool\n+    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2);\n+\n+  // Hashtables handle allocators a bit differently than other\n+  // containers do.  If we're using standard-conforming allocators, then\n+  // a hashtable unconditionally has a member variable to hold its\n+  // allocator, even if it so happens that all instances of the\n+  // allocator type are identical.  This is because, for hashtables,\n+  // this extra storage is negligible.  Additionally, a base class\n+  // wouldn't serve any other purposes; it wouldn't, for example,\n+  // simplify the exception-handling code.  \n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    class hashtable\n+    {\n+    public:\n+      typedef _Key key_type;\n+      typedef _Val value_type;\n+      typedef _HashFcn hasher;\n+      typedef _EqualKey key_equal;\n+\n+      typedef size_t            size_type;\n+      typedef ptrdiff_t         difference_type;\n+      typedef value_type*       pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type&       reference;\n+      typedef const value_type& const_reference;\n+\n+      hasher\n+      hash_funct() const\n+      { return _M_hash; }\n+\n+      key_equal\n+      key_eq() const\n+      { return _M_equals; }\n+\n+    private:\n+      typedef _Hashtable_node<_Val> _Node;\n+\n+    public:\n+      typedef typename _Alloc::template rebind<value_type>::other allocator_type;\n+      allocator_type\n+      get_allocator() const\n+      { return _M_node_allocator; }\n+\n+    private:\n+      typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n+      typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n+      typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n+\n+      _Node_Alloc _M_node_allocator;\n+\n+      _Node*\n+      _M_get_node()\n+      { return _M_node_allocator.allocate(1); }\n+\n+      void\n+      _M_put_node(_Node* __p)\n+      { _M_node_allocator.deallocate(__p, 1); }\n+\n+    private:\n+      hasher                _M_hash;\n+      key_equal             _M_equals;\n+      _ExtractKey           _M_get_key;\n+      _Vector_type          _M_buckets;\n+      size_type             _M_num_elements;\n+      \n+    public:\n+      typedef _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t  _EqualKey, _Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t\t_EqualKey, _Alloc>\n+        const_iterator;\n+\n+      friend struct\n+      _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>;\n+\n+      friend struct\n+      _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t_EqualKey, _Alloc>;\n+\n+    public:\n+      hashtable(size_type __n, const _HashFcn& __hf,\n+\t\tconst _EqualKey& __eql, const _ExtractKey& __ext,\n+\t\tconst allocator_type& __a = allocator_type())\n+      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n+\t_M_get_key(__ext), _M_buckets(__a), _M_num_elements(0)\n+      { _M_initialize_buckets(__n); }\n+\n+      hashtable(size_type __n, const _HashFcn& __hf,\n+\t\tconst _EqualKey& __eql,\n+\t\tconst allocator_type& __a = allocator_type())\n+      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n+\t_M_get_key(_ExtractKey()), _M_buckets(__a), _M_num_elements(0)\n+      { _M_initialize_buckets(__n); }\n+\n+      hashtable(const hashtable& __ht)\n+      : _M_node_allocator(__ht.get_allocator()), _M_hash(__ht._M_hash),\n+      _M_equals(__ht._M_equals), _M_get_key(__ht._M_get_key),\n+      _M_buckets(__ht.get_allocator()), _M_num_elements(0)\n+      { _M_copy_from(__ht); }\n+\n+      hashtable&\n+      operator= (const hashtable& __ht)\n+      {\n+\tif (&__ht != this)\n+\t  {\n+\t    clear();\n+\t    _M_hash = __ht._M_hash;\n+\t    _M_equals = __ht._M_equals;\n+\t    _M_get_key = __ht._M_get_key;\n+\t    _M_copy_from(__ht);\n+\t  }\n+\treturn *this;\n+      }\n+\n+      ~hashtable()\n+      { clear(); }\n+\n+      size_type\n+      size() const\n+      { return _M_num_elements; }\n+\n+      size_type\n+      max_size() const\n+      { return size_type(-1); }\n+\n+      bool\n+      empty() const\n+      { return size() == 0; }\n+\n+      void\n+      swap(hashtable& __ht)\n+      {\n+\tstd::swap(_M_hash, __ht._M_hash);\n+\tstd::swap(_M_equals, __ht._M_equals);\n+\tstd::swap(_M_get_key, __ht._M_get_key);\n+\t_M_buckets.swap(__ht._M_buckets);\n+\tstd::swap(_M_num_elements, __ht._M_num_elements);\n+      }\n+\n+      iterator\n+      begin()\n+      {\n+\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+\t  if (_M_buckets[__n])\n+\t    return iterator(_M_buckets[__n], this);\n+\treturn end();\n+      }\n+\n+      iterator\n+      end()\n+      { return iterator(0, this); }\n+\n+      const_iterator\n+      begin() const\n+      {\n+\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+\t  if (_M_buckets[__n])\n+\t    return const_iterator(_M_buckets[__n], this);\n+\treturn end();\n+      }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(0, this); }\n+\n+      template<class _Vl, class _Ky, class _HF, class _Ex, class _Eq,\n+\t\tclass _Al>\n+        friend bool\n+        operator==(const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n+\t\t   const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n+\n+    public:\n+      size_type\n+      bucket_count() const\n+      { return _M_buckets.size(); }\n+\n+      size_type\n+      max_bucket_count() const\n+      { return __stl_prime_list[(int)_S_num_primes - 1]; }\n+\n+      size_type\n+      elems_in_bucket(size_type __bucket) const\n+      {\n+\tsize_type __result = 0;\n+\tfor (_Node* __n = _M_buckets[__bucket]; __n; __n = __n->_M_next)\n+\t  __result += 1;\n+\treturn __result;\n+      }\n+\n+      pair<iterator, bool>\n+      insert_unique(const value_type& __obj)\n+      {\n+\tresize(_M_num_elements + 1);\n+\treturn insert_unique_noresize(__obj);\n+      }\n+\n+      iterator\n+      insert_equal(const value_type& __obj)\n+      {\n+\tresize(_M_num_elements + 1);\n+\treturn insert_equal_noresize(__obj);\n+      }\n+\n+      pair<iterator, bool>\n+      insert_unique_noresize(const value_type& __obj);\n+\n+      iterator\n+      insert_equal_noresize(const value_type& __obj);\n+\n+      template<class _InputIterator>\n+        void\n+        insert_unique(_InputIterator __f, _InputIterator __l)\n+        { insert_unique(__f, __l, __iterator_category(__f)); }\n+\n+      template<class _InputIterator>\n+        void\n+        insert_equal(_InputIterator __f, _InputIterator __l)\n+        { insert_equal(__f, __l, __iterator_category(__f)); }\n+\n+      template<class _InputIterator>\n+        void\n+        insert_unique(_InputIterator __f, _InputIterator __l,\n+\t\t      input_iterator_tag)\n+        {\n+\t  for ( ; __f != __l; ++__f)\n+\t    insert_unique(*__f);\n+\t}\n+\n+      template<class _InputIterator>\n+        void\n+        insert_equal(_InputIterator __f, _InputIterator __l,\n+\t\t     input_iterator_tag)\n+        {\n+\t  for ( ; __f != __l; ++__f)\n+\t    insert_equal(*__f);\n+\t}\n+\n+      template<class _ForwardIterator>\n+        void\n+        insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n+\t\t      forward_iterator_tag)\n+        {\n+\t  size_type __n = distance(__f, __l);\n+\t  resize(_M_num_elements + __n);\n+\t  for ( ; __n > 0; --__n, ++__f)\n+\t    insert_unique_noresize(*__f);\n+\t}\n+\n+      template<class _ForwardIterator>\n+        void\n+        insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n+\t\t     forward_iterator_tag)\n+        {\n+\t  size_type __n = distance(__f, __l);\n+\t  resize(_M_num_elements + __n);\n+\t  for ( ; __n > 0; --__n, ++__f)\n+\t    insert_equal_noresize(*__f);\n+\t}\n+\n+      reference\n+      find_or_insert(const value_type& __obj);\n+\n+      iterator\n+      find(const key_type& __key)\n+      {\n+\tsize_type __n = _M_bkt_num_key(__key);\n+\t_Node* __first;\n+\tfor (__first = _M_buckets[__n];\n+\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+\t     __first = __first->_M_next)\n+\t  { }\n+\treturn iterator(__first, this);\n+      }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      {\n+\tsize_type __n = _M_bkt_num_key(__key);\n+\tconst _Node* __first;\n+\tfor (__first = _M_buckets[__n];\n+\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+\t     __first = __first->_M_next)\n+\t  { }\n+\treturn const_iterator(__first, this);\n+      }\n+\n+      size_type\n+      count(const key_type& __key) const\n+      {\n+\tconst size_type __n = _M_bkt_num_key(__key);\n+\tsize_type __result = 0;\n+\t\n+\tfor (const _Node* __cur = _M_buckets[__n]; __cur;\n+\t     __cur = __cur->_M_next)\n+\t  if (_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t    ++__result;\n+\treturn __result;\n+      }\n+\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __key);\n+\n+      pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const;\n+\n+      size_type\n+      erase(const key_type& __key);\n+      \n+      void\n+      erase(const iterator& __it);\n+\n+      void\n+      erase(iterator __first, iterator __last);\n+\n+      void\n+      erase(const const_iterator& __it);\n+\n+      void\n+      erase(const_iterator __first, const_iterator __last);\n+\n+      void\n+      resize(size_type __num_elements_hint);\n+\n+      void\n+      clear();\n+\n+    private:\n+      size_type\n+      _M_next_size(size_type __n) const\n+      { return __stl_next_prime(__n); }\n+\n+      void\n+      _M_initialize_buckets(size_type __n)\n+      {\n+\tconst size_type __n_buckets = _M_next_size(__n);\n+\t_M_buckets.reserve(__n_buckets);\n+\t_M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n+\t_M_num_elements = 0;\n+        __profcxx_hashtable_construct(this, __n_buckets);\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      size_type\n+      _M_bkt_num_key(const key_type& __key) const\n+      { return _M_bkt_num_key(__key, _M_buckets.size()); }\n+\n+      size_type\n+      _M_bkt_num(const value_type& __obj) const\n+      { return _M_bkt_num_key(_M_get_key(__obj)); }\n+\n+      size_type\n+      _M_bkt_num_key(const key_type& __key, size_t __n) const\n+      { return _M_hash(__key) % __n; }\n+\n+      size_type\n+      _M_bkt_num(const value_type& __obj, size_t __n) const\n+      { return _M_bkt_num_key(_M_get_key(__obj), __n); }\n+\n+      _Node*\n+      _M_new_node(const value_type& __obj)\n+      {\n+\t_Node* __n = _M_get_node();\n+\t__n->_M_next = 0;\n+\ttry\n+\t  {\n+\t    this->get_allocator().construct(&__n->_M_val, __obj);\n+\t    return __n;\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    _M_put_node(__n);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+      void\n+      _M_delete_node(_Node* __n)\n+      {\n+\tthis->get_allocator().destroy(&__n->_M_val);\n+\t_M_put_node(__n);\n+      }\n+      \n+      void\n+      _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n+\n+      void\n+      _M_erase_bucket(const size_type __n, _Node* __last);\n+\n+      void\n+      _M_copy_from(const hashtable& __ht);\n+    };\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++()\n+    {\n+      const _Node* __old = _M_cur;\n+      _M_cur = _M_cur->_M_next;\n+      if (!_M_cur)\n+\t{\n+\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+\t    _M_cur = _M_ht->_M_buckets[__bucket];\n+\t}\n+      return *this;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    inline _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++(int)\n+    {\n+      iterator __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++()\n+    {\n+      const _Node* __old = _M_cur;\n+      _M_cur = _M_cur->_M_next;\n+      if (!_M_cur)\n+\t{\n+\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+\t    _M_cur = _M_ht->_M_buckets[__bucket];\n+\t}\n+      return *this;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    inline _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++(int)\n+    {\n+      const_iterator __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    bool\n+    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n+    {\n+      typedef typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::_Node _Node;\n+\n+      if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n+\treturn false;\n+\n+      for (size_t __n = 0; __n < __ht1._M_buckets.size(); ++__n)\n+\t{\n+\t  _Node* __cur1 = __ht1._M_buckets[__n];\n+\t  _Node* __cur2 = __ht2._M_buckets[__n];\n+\t  // Check same length of lists\n+\t  for (; __cur1 && __cur2;\n+\t       __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n+\t    { } \n+\t  if (__cur1 || __cur2)\n+\t    return false;\n+\t  // Now check one's elements are in the other\n+\t  for (__cur1 = __ht1._M_buckets[__n] ; __cur1;\n+\t       __cur1 = __cur1->_M_next)\n+\t    {\n+\t      bool _found__cur1 = false;\n+\t      for (__cur2 = __ht2._M_buckets[__n];\n+\t\t   __cur2; __cur2 = __cur2->_M_next)\n+\t\t{\n+\t\t  if (__cur1->_M_val == __cur2->_M_val)\n+\t\t    {\n+\t\t      _found__cur1 = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (!_found__cur1)\n+\t\treturn false;\n+\t    }\n+\t}\n+      return true;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline bool\n+    operator!=(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n+    { return !(__ht1 == __ht2); }\n+\n+  template<class _Val, class _Key, class _HF, class _Extract, class _EqKey,\n+\t    class _All>\n+    inline void\n+    swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n+\t hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2)\n+    { __ht1.swap(__ht2); }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator, bool>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    insert_unique_noresize(const value_type& __obj)\n+    {\n+      const size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  return pair<iterator, bool>(iterator(__cur, this), false);\n+      \n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return pair<iterator, bool>(iterator(__tmp, this), true);\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    insert_equal_noresize(const value_type& __obj)\n+    {\n+      const size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  {\n+\t    _Node* __tmp = _M_new_node(__obj);\n+\t    __tmp->_M_next = __cur->_M_next;\n+\t    __cur->_M_next = __tmp;\n+\t    ++_M_num_elements;\n+\t    return iterator(__tmp, this);\n+\t  }\n+\n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return iterator(__tmp, this);\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::reference\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    find_or_insert(const value_type& __obj)\n+    {\n+      resize(_M_num_elements + 1);\n+\n+      size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  return __cur->_M_val;\n+      \n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return __tmp->_M_val;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator,\n+\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    equal_range(const key_type& __key)\n+    {\n+      typedef pair<iterator, iterator> _Pii;\n+      const size_type __n = _M_bkt_num_key(__key);\n+\n+      for (_Node* __first = _M_buckets[__n]; __first;\n+\t   __first = __first->_M_next)\n+\tif (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t  {\n+\t    for (_Node* __cur = __first->_M_next; __cur;\n+\t\t __cur = __cur->_M_next)\n+\t      if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t\treturn _Pii(iterator(__first, this), iterator(__cur, this));\n+\t    for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+\t      if (_M_buckets[__m])\n+\t\treturn _Pii(iterator(__first, this),\n+\t\t\t    iterator(_M_buckets[__m], this));\n+\t    return _Pii(iterator(__first, this), end());\n+\t  }\n+      return _Pii(end(), end());\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator,\n+\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    equal_range(const key_type& __key) const\n+    {\n+      typedef pair<const_iterator, const_iterator> _Pii;\n+      const size_type __n = _M_bkt_num_key(__key);\n+\n+      for (const _Node* __first = _M_buckets[__n]; __first;\n+\t   __first = __first->_M_next)\n+\t{\n+\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t    {\n+\t      for (const _Node* __cur = __first->_M_next; __cur;\n+\t\t   __cur = __cur->_M_next)\n+\t\tif (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t\t  return _Pii(const_iterator(__first, this),\n+\t\t\t      const_iterator(__cur, this));\n+\t      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+\t\tif (_M_buckets[__m])\n+\t\t  return _Pii(const_iterator(__first, this),\n+\t\t\t      const_iterator(_M_buckets[__m], this));\n+\t      return _Pii(const_iterator(__first, this), end());\n+\t    }\n+\t}\n+      return _Pii(end(), end());\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::size_type\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const key_type& __key)\n+    {\n+      const size_type __n = _M_bkt_num_key(__key);\n+      _Node* __first = _M_buckets[__n];\n+      size_type __erased = 0;\n+      \n+      if (__first)\n+\t{\n+\t  _Node* __cur = __first;\n+\t  _Node* __next = __cur->_M_next;\n+\t  while (__next)\n+\t    {\n+\t      if (_M_equals(_M_get_key(__next->_M_val), __key))\n+\t\t{\n+\t\t  __cur->_M_next = __next->_M_next;\n+\t\t  _M_delete_node(__next);\n+\t\t  __next = __cur->_M_next;\n+\t\t  ++__erased;\n+\t\t  --_M_num_elements;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __cur = __next;\n+\t\t  __next = __cur->_M_next;\n+\t\t}\n+\t    }\n+\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t    {\n+\t      _M_buckets[__n] = __first->_M_next;\n+\t      _M_delete_node(__first);\n+\t      ++__erased;\n+\t      --_M_num_elements;\n+\t    }\n+\t}\n+      return __erased;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const iterator& __it)\n+    {\n+      _Node* __p = __it._M_cur;\n+      if (__p)\n+\t{\n+\t  const size_type __n = _M_bkt_num(__p->_M_val);\n+\t  _Node* __cur = _M_buckets[__n];\n+\t  \n+\t  if (__cur == __p)\n+\t    {\n+\t      _M_buckets[__n] = __cur->_M_next;\n+\t      _M_delete_node(__cur);\n+\t      --_M_num_elements;\n+\t    }\n+\t  else\n+\t    {\n+\t      _Node* __next = __cur->_M_next;\n+\t      while (__next)\n+\t\t{\n+\t\t  if (__next == __p)\n+\t\t    {\n+\t\t      __cur->_M_next = __next->_M_next;\n+\t\t      _M_delete_node(__next);\n+\t\t      --_M_num_elements;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      __cur = __next;\n+\t\t      __next = __cur->_M_next;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(iterator __first, iterator __last)\n+    {\n+      size_type __f_bucket = __first._M_cur ? _M_bkt_num(__first._M_cur->_M_val)\n+\t                                    : _M_buckets.size();\n+\n+      size_type __l_bucket = __last._M_cur ? _M_bkt_num(__last._M_cur->_M_val)\n+\t                                   : _M_buckets.size();\n+\n+      if (__first._M_cur == __last._M_cur)\n+\treturn;\n+      else if (__f_bucket == __l_bucket)\n+\t_M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n+      else\n+\t{\n+\t  _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n+\t  for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n+\t    _M_erase_bucket(__n, 0);\n+\t  if (__l_bucket != _M_buckets.size())\n+\t    _M_erase_bucket(__l_bucket, __last._M_cur);\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const_iterator __first, const_iterator __last)\n+    {\n+      erase(iterator(const_cast<_Node*>(__first._M_cur),\n+\t\t     const_cast<hashtable*>(__first._M_ht)),\n+\t    iterator(const_cast<_Node*>(__last._M_cur),\n+\t\t     const_cast<hashtable*>(__last._M_ht)));\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const const_iterator& __it)\n+    { erase(iterator(const_cast<_Node*>(__it._M_cur),\n+\t\t     const_cast<hashtable*>(__it._M_ht))); }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    resize(size_type __num_elements_hint)\n+    {\n+      const size_type __old_n = _M_buckets.size();\n+      if (__num_elements_hint > __old_n)\n+\t{\n+\t  const size_type __n = _M_next_size(__num_elements_hint);\n+\t  if (__n > __old_n)\n+\t    {\n+\t      _Vector_type __tmp(__n, (_Node*)(0), _M_buckets.get_allocator());\n+\t      try\n+\t\t{\n+\t\t  for (size_type __bucket = 0; __bucket < __old_n; ++__bucket)\n+\t\t    {\n+\t\t      _Node* __first = _M_buckets[__bucket];\n+\t\t      while (__first)\n+\t\t\t{\n+\t\t\t  size_type __new_bucket = _M_bkt_num(__first->_M_val,\n+\t\t\t\t\t\t\t      __n);\n+\t\t\t  _M_buckets[__bucket] = __first->_M_next;\n+\t\t\t  __first->_M_next = __tmp[__new_bucket];\n+\t\t\t  __tmp[__new_bucket] = __first;\n+\t\t\t  __first = _M_buckets[__bucket];\n+\t\t\t}\n+\t\t    }\n+\t\t  _M_buckets.swap(__tmp);\n+\t\t}\n+\t      catch(...)\n+\t\t{\n+\t\t  for (size_type __bucket = 0; __bucket < __tmp.size();\n+\t\t       ++__bucket)\n+\t\t    {\n+\t\t      while (__tmp[__bucket])\n+\t\t\t{\n+\t\t\t  _Node* __next = __tmp[__bucket]->_M_next;\n+\t\t\t  _M_delete_node(__tmp[__bucket]);\n+\t\t\t  __tmp[__bucket] = __next;\n+\t\t\t}\n+\t\t    }\n+\t\t  __throw_exception_again;\n+\t\t}\n+        __profcxx_hashtable_resize(this, __num_elements_hint, __n);\n+\t    }\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n+    {\n+      _Node* __cur = _M_buckets[__n];\n+      if (__cur == __first)\n+\t_M_erase_bucket(__n, __last);\n+      else\n+\t{\n+\t  _Node* __next;\n+\t  for (__next = __cur->_M_next;\n+\t       __next != __first;\n+\t       __cur = __next, __next = __cur->_M_next)\n+\t    ;\n+\t  while (__next != __last)\n+\t    {\n+\t      __cur->_M_next = __next->_M_next;\n+\t      _M_delete_node(__next);\n+\t      __next = __cur->_M_next;\n+\t      --_M_num_elements;\n+\t    }\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_erase_bucket(const size_type __n, _Node* __last)\n+    {\n+      _Node* __cur = _M_buckets[__n];\n+      while (__cur != __last)\n+\t{\n+\t  _Node* __next = __cur->_M_next;\n+\t  _M_delete_node(__cur);\n+\t  __cur = __next;\n+\t  _M_buckets[__n] = __cur;\n+\t  --_M_num_elements;\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    clear()\n+    {\n+      size_type __hops=0, __lc = 0, __chain = 0;\n+      if (_M_num_elements != 0) \n+         __profcxx_hashtable_destruct(this, _M_buckets.size(), _M_num_elements);\n+      \n+      for (size_type __i = 0; __i < _M_buckets.size(); ++__i)\n+\t{\n+\t  _Node* __cur = _M_buckets[__i];\n+\t  while (__cur != 0)\n+\t    {\n+\t      _Node* __next = __cur->_M_next;\n+\t      _M_delete_node(__cur);\n+\t      __cur = __next;\n+\n+          // Compute the longest chain count.\n+          __chain++;\n+\t    }\n+\t  _M_buckets[__i] = 0;\n+\n+      // Collect number of hops.\n+      if (__chain > 1) {\n+        __lc = __lc > __chain ? __lc : __chain;\n+        __hops += (__chain-1) * __chain / 2;\n+      }\n+      __chain = 0;\n+\t}\n+      if (_M_num_elements) {\n+        __profcxx_hashtable_destruct2(this, __lc, _M_num_elements, __hops);\n+      }\n+      _M_num_elements = 0;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_copy_from(const hashtable& __ht)\n+    {\n+      _M_buckets.clear();\n+      _M_buckets.reserve(__ht._M_buckets.size());\n+      _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n+      try\n+\t{\n+\t  for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n+\t    const _Node* __cur = __ht._M_buckets[__i];\n+\t    if (__cur)\n+\t      {\n+\t\t_Node* __local_copy = _M_new_node(__cur->_M_val);\n+\t\t_M_buckets[__i] = __local_copy;\n+\t\t\n+\t\tfor (_Node* __next = __cur->_M_next;\n+\t\t     __next;\n+\t\t     __cur = __next, __next = __cur->_M_next)\n+\t\t  {\n+\t\t    __local_copy->_M_next = _M_new_node(__next->_M_val);\n+\t\t    __local_copy = __local_copy->_M_next;\n+\t\t  }\n+\t      }\n+\t  }\n+\t  _M_num_elements = __ht._M_num_elements;\n+\t}\n+      catch(...)\n+\t{\n+\t  clear();\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif"}, {"sha": "f86920344fcd860699283e2cad1dc7533a5e8e4d", "filename": "libstdc++-v3/include/profile/impl/profiler.h", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,326 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler.h\n+ *  @brief Interface of the profiling runtime library.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_H__\n+#define PROFCXX_PROFILER_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstddef>\n+#else\n+#include <stddef.h>\n+#endif\n+\n+/**\n+ * @namespace std::__cxxprof_guard\n+ * @brief Mechanism to protect all __cxxprof_impl operations against\n+ * multithreaded and exception reentrance.\n+ */\n+namespace __cxxprof_guard\n+{\n+\n+/** @brief Reentrance guard.\n+ *\n+ * Mechanism to protect all __cxxprof_impl operations against recursion,\n+ * multithreaded and exception reentrance.\n+ */\n+template <int _Unused=0>\n+class __reentrance_guard\n+{\n+ public:\n+  static __thread bool __inside_cxxprof_impl;\n+  static bool __get_in();\n+  __reentrance_guard() {}\n+  ~__reentrance_guard() { __inside_cxxprof_impl = false; }\n+};\n+\n+template <int _Unused>\n+__thread bool __reentrance_guard<_Unused>::__inside_cxxprof_impl = false;\n+\n+template <int _Unused>\n+bool __reentrance_guard<_Unused>::__get_in()\n+{\n+  if (__inside_cxxprof_impl) {\n+    return false;\n+  } else {\n+    __inside_cxxprof_impl = true;\n+    return true;\n+  }\n+}\n+\n+} // namespace __cxxprof_guard\n+\n+#define _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD(__x...)             \\\n+  {                                                                \\\n+    if (__cxxprof_guard::__reentrance_guard<0>::__get_in())        \\\n+    {                                                              \\\n+      __cxxprof_guard::__reentrance_guard<0> __auto_get_out;       \\\n+      __x;                                                         \\\n+    }                                                              \\\n+  }\n+\n+/**\n+ * @namespace std::__cxxprof_impl\n+ * @brief Implementation of profile extension.\n+ */\n+namespace __cxxprof_impl\n+{\n+// Forward declarations of implementation functions.\n+// Don't use any __cxxprof_impl:: in user code.\n+// Instead, use the __profcxx... macros, which offer guarded access.\n+void __turn_on();\n+void __turn_off();\n+bool __is_invalid();\n+bool __is_on();\n+bool __is_off();\n+void __report(void);\n+void __trace_hashtable_size_resize(const void*, size_t, size_t);\n+void __trace_hashtable_size_destruct(const void*, size_t, size_t);\n+void __trace_hashtable_size_construct(const void*, size_t);\n+void __trace_vector_size_resize(const void*, size_t, size_t);\n+void __trace_vector_size_destruct(const void*, size_t, size_t);\n+void __trace_vector_size_construct(const void*, size_t);\n+void __trace_hash_func_destruct(const void*, size_t, size_t, size_t);\n+void __trace_hash_func_construct(const void*);\n+void __trace_vector_to_list_destruct(const void*);\n+void __trace_vector_to_list_construct(const void*);\n+void __trace_vector_to_list_insert(const void*, size_t, size_t);\n+void __trace_vector_to_list_iterate(const void*, size_t);\n+void __trace_vector_to_list_invalid_operator(const void*);\n+void __trace_vector_to_list_resize(const void*, size_t, size_t);\n+void __trace_map_to_unordered_map_construct(const void*);\n+void __trace_map_to_unordered_map_invalidate(const void*);\n+void __trace_map_to_unordered_map_insert(const void*, size_t, size_t);\n+void __trace_map_to_unordered_map_erase(const void*, size_t, size_t);\n+void __trace_map_to_unordered_map_iterate(const void*, size_t);\n+void __trace_map_to_unordered_map_find(const void*, size_t);\n+void __trace_map_to_unordered_map_destruct(const void*);\n+} // namespace __cxxprof_impl\n+\n+// Master switch turns on all diagnostics.\n+#ifdef _GLIBCXX_PROFILE\n+#define _GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL\n+#define _GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE\n+#define _GLIBCXX_PROFILE_VECTOR_TOO_SMALL\n+#define _GLIBCXX_PROFILE_VECTOR_TOO_LARGE\n+#define _GLIBCXX_PROFILE_INEFFICIENT_HASH\n+#define _GLIBCXX_PROFILE_VECTOR_TO_LIST\n+#define _GLIBCXX_PROFILE_MAP_TO_UNORDERED_MAP\n+#endif\n+\n+// Expose global management routines to user code.\n+#ifdef _GLIBCXX_PROFILE\n+#define __profcxx_report() \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD(__cxxprof_impl::__report())\n+#define __profcxx_turn_on() \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD(__cxxprof_impl::__turn_on())\n+#define __profcxx_turn_off() \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD(__cxxprof_impl::__turn_off())\n+#define __profcxx_is_invalid() \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD(__cxxprof_impl::__is_invalid())\n+#define __profcxx_is_on() \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD(__cxxprof_impl::__is_on())\n+#define __profcxx__is_off() \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD(__cxxprof_impl::__is_off())\n+#else\n+#define __profcxx_report()\n+#define __profcxx_turn_on()\n+#define __profcxx_turn_off()\n+#define __profcxx_is_invalid()\n+#define __profcxx_is_on()\n+#define __profcxx_is_off()\n+#endif\n+\n+// Turn on/off instrumentation for HASHTABLE_TOO_SMALL and HASHTABLE_TOO_LARGE.\n+#if ((defined(_GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL) \\\n+      && !defined(_NO_GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL)) \\\n+     || (defined(_GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE) \\\n+         && !defined(_NO_GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE)))\n+#define __profcxx_hashtable_resize(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_hashtable_size_resize(__x))\n+#define __profcxx_hashtable_destruct(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_hashtable_size_destruct(__x))\n+#define __profcxx_hashtable_construct(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_hashtable_size_construct(__x))\n+#else\n+#define __profcxx_hashtable_resize(__x...)  \n+#define __profcxx_hashtable_destruct(__x...) \n+#define __profcxx_hashtable_construct(__x...)  \n+#endif\n+\n+// Turn on/off instrumentation for VECTOR_TOO_SMALL and VECTOR_TOO_LARGE.\n+#if ((defined(_GLIBCXX_PROFILE_VECTOR_TOO_SMALL) \\\n+      && !defined(_NO_GLIBCXX_PROFILE_VECTOR_TOO_SMALL)) \\\n+     || (defined(_GLIBCXX_PROFILE_VECTOR_TOO_LARGE) \\\n+         && !defined(_NO_GLIBCXX_PROFILE_VECTOR_TOO_LARGE)))\n+#define __profcxx_vector_resize(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_size_resize(__x))\n+#define __profcxx_vector_destruct(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_size_destruct(__x))\n+#define __profcxx_vector_construct(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_size_construct(__x))\n+#else\n+#define __profcxx_vector_resize(__x...)  \n+#define __profcxx_vector_destruct(__x...) \n+#define __profcxx_vector_construct(__x...)  \n+#endif \n+\n+// Turn on/off instrumentation for INEFFICIENT_HASH.\n+#if (defined(_GLIBCXX_PROFILE_INEFFICIENT_HASH) \\\n+     && !defined(_NO_GLIBCXX_PROFILE_INEFFICIENT_HASH))\n+#define __profcxx_hashtable_construct2(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_hash_func_construct(__x))\n+#define __profcxx_hashtable_destruct2(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_hash_func_destruct(__x))\n+#else\n+#define __profcxx_hashtable_destruct2(__x...) \n+#define __profcxx_hashtable_construct2(__x...)  \n+#endif\n+\n+// Turn on/off instrumentation for VECTOR_TO_LIST.\n+#if (defined(_GLIBCXX_PROFILE_VECTOR_TO_LIST) \\\n+     && !defined(_NO_GLIBCXX_PROFILE_VECTOR_TO_LIST))\n+#define __profcxx_vector_construct2(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_to_list_construct(__x))\n+#define __profcxx_vector_destruct2(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_to_list_destruct(__x))\n+#define __profcxx_vector_insert(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_to_list_insert(__x))\n+#define __profcxx_vector_iterate(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_to_list_iterate(__x))\n+#define __profcxx_vector_invalid_operator(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_to_list_invalid_operator(__x))\n+#define __profcxx_vector_resize2(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_vector_to_list_resize(__x))\n+#else\n+#define __profcxx_vector_destruct2(__x...)\n+#define __profcxx_vector_construct2(__x...)\n+#define __profcxx_vector_insert(__x...)\n+#define __profcxx_vector_iterate(__x...)\n+#define __profcxx_vector_invalid_operator(__x...)\n+#define __profcxx_vector_resize2(__x...)\n+#endif\n+\n+// Turn on/off instrumentation for MAP_TO_UNORDERED_MAP.\n+#if (defined(_GLIBCXX_PROFILE_MAP_TO_UNORDERED_MAP) \\\n+     && !defined(_NO_GLIBCXX_PROFILE_MAP_TO_UNORDERED_MAP))\n+#define __profcxx_map_to_unordered_map_construct(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_map_to_unordered_map_construct(__x))\n+#define __profcxx_map_to_unordered_map_destruct(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_map_to_unordered_map_destruct(__x))\n+#define __profcxx_map_to_unordered_map_insert(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_map_to_unordered_map_insert(__x))\n+#define __profcxx_map_to_unordered_map_erase(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_map_to_unordered_map_erase(__x))\n+#define __profcxx_map_to_unordered_map_iterate(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_map_to_unordered_map_iterate(__x))\n+#define __profcxx_map_to_unordered_map_invalidate(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_map_to_unordered_map_invalidate(__x))\n+#define __profcxx_map_to_unordered_map_find(__x...) \\\n+  _GLIBCXX_PROFILE_IMPL_REENTRANCE_GUARD( \\\n+      __cxxprof_impl::__trace_map_to_unordered_map_find(__x))\n+#else\n+#define __profcxx_map_to_unordered_map_construct(__x...) \\\n+  \n+#define __profcxx_map_to_unordered_map_destruct(__x...)\n+#define __profcxx_map_to_unordered_map_insert(__x...)\n+#define __profcxx_map_to_unordered_map_erase(__x...)\n+#define __profcxx_map_to_unordered_map_iterate(__x...)\n+#define __profcxx_map_to_unordered_map_invalidate(__x...)\n+#define __profcxx_map_to_unordered_map_find(__x...)\n+#endif\n+\n+// Run multithreaded unless instructed not to do so.\n+#ifndef _GLIBCXX_PROFILE_NOTHREADS\n+#define _GLIBCXX_PROFILE_THREADS\n+#endif\n+\n+// Set default values for compile-time customizable variables.\n+#ifndef _GLIBCXX_PROFILE_TRACE_PATH_ROOT\n+#define _GLIBCXX_PROFILE_TRACE_PATH_ROOT \"libstdcxx-profile\"\n+#endif\n+#ifndef _GLIBCXX_PROFILE_TRACE_ENV_VAR\n+#define _GLIBCXX_PROFILE_TRACE_ENV_VAR \"GLIBCXX_PROFILE_TRACE_PATH_ROOT\"\n+#endif\n+#ifndef _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR\n+#define _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR \\\n+  \"GLIBCXX_PROFILE_MAX_WARN_COUNT\"\n+#endif\n+#ifndef _GLIBCXX_PROFILE_MAX_WARN_COUNT\n+#define _GLIBCXX_PROFILE_MAX_WARN_COUNT 10\n+#endif\n+#ifndef _GLIBCXX_PROFILE_MAX_STACK_DEPTH\n+#define _GLIBCXX_PROFILE_MAX_STACK_DEPTH 32\n+#endif\n+#ifndef _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR\n+#define _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR \\\n+  \"GLIBCXX_PROFILE_MAX_STACK_DEPTH\"\n+#endif\n+#ifndef _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC\n+#define _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC 2 << 27\n+#endif\n+#ifndef _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR\n+#define _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR \\\n+  \"GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC\"\n+#endif\n+\n+// Instrumentation hook implementations.\n+#include \"profile/impl/profiler_hash_func.h\"\n+#include \"profile/impl/profiler_hashtable_size.h\"\n+#include \"profile/impl/profiler_map_to_unordered_map.h\"\n+#include \"profile/impl/profiler_vector_size.h\"\n+#include \"profile/impl/profiler_vector_to_list.h\"\n+\n+#endif // PROFCXX_PROFILER_H__"}, {"sha": "330afc5ba794bfa10aa2f67a95195bac85521d28", "filename": "libstdc++-v3/include/profile/impl/profiler_container_size.h", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,250 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_trace.h\n+ *  @brief Diagnostics for container sizes.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_CONTAINER_SIZE_H__\n+#define PROFCXX_PROFILER_CONTAINER_SIZE_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstring>\n+#else\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#endif\n+\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+\n+namespace __cxxprof_impl\n+{\n+\n+/** @brief A container size instrumentation line in the object table.  */\n+class __container_size_info: public __object_info_base \n+{\n+ public:\n+  __container_size_info();\n+  __container_size_info(const __container_size_info& __o);\n+  __container_size_info(__stack_t __stack, size_t __num);\n+  virtual ~__container_size_info() {}\n+\n+  void __write(FILE* f) const;\n+  float __magnitude() const { return static_cast<float>(_M_cost); }\n+  const char* __advice() const;\n+\n+  void __merge(const __container_size_info& __o);\n+  // Call if a container is destructed or cleaned.\n+  void __destruct(size_t __num, size_t __inum);\n+  // Estimate the cost of resize/rehash. \n+  float __resize_cost(size_t __from, size_t __to) { return __from; }\n+  // Call if container is resized.\n+  void __resize(size_t __from, size_t __to);\n+\n+ private:\n+  size_t _M_init;\n+  size_t _M_max;  // range of # buckets\n+  size_t _M_min;\n+  size_t _M_total;\n+  size_t _M_item_min;  // range of # items\n+  size_t _M_item_max;\n+  size_t _M_item_total;\n+  size_t _M_count;\n+  size_t _M_resize;\n+  size_t _M_cost;\n+};\n+\n+inline const char* __container_size_info::__advice() const\n+{\n+  const size_t __max_chars_size_t_printed = 20;\n+  const char* __message_pattern = \n+      \"change initial container size from %d to %d\";\n+  size_t __message_size = (strlen(__message_pattern) \n+                           + 2 * __max_chars_size_t_printed\n+                           - 2 * 2);\n+  char* __message = new char[__message_size + 1];\n+\n+  if (_M_init < _M_item_max)\n+    snprintf(__message, __message_size, __message_pattern, _M_init,\n+             _M_item_max);\n+  else\n+    snprintf(__message, __message_size, __message_pattern, _M_init,\n+             _M_item_max);\n+\n+  return __message;\n+}\n+\n+inline void __container_size_info::__destruct(size_t __num, size_t __inum) \n+{\n+  _M_max = __max(_M_max, __num);\n+  _M_item_max = __max(_M_item_max, __inum);\n+  if (_M_min == 0) {\n+    _M_min = __num; \n+    _M_item_min = __inum;\n+  } else {\n+    _M_min = __min(_M_min, __num);\n+    _M_item_min = __min(_M_item_min, __inum);\n+  }\n+  _M_total += __num;\n+  _M_item_total += __inum;\n+  _M_count += 1;\n+}\n+\n+inline void __container_size_info::__resize(size_t __from, size_t __to) \n+{\n+  _M_cost += this->__resize_cost(__from, __to);\n+  _M_resize += 1;\n+  _M_max = __max(_M_max, __to);\n+}\n+\n+inline __container_size_info::__container_size_info(__stack_t __stack, \n+                                                    size_t __num)\n+    : __object_info_base(__stack), _M_init(0), _M_max(0), _M_item_max(0), \n+      _M_min(0), _M_item_min(0), _M_total(0), _M_item_total(0), _M_cost(0), \n+      _M_count(0), _M_resize(0)\n+{\n+  _M_init = _M_max = __num;\n+  _M_item_min = _M_item_max = _M_item_total = _M_total = 0;\n+  _M_min = 0;\n+  _M_count = 0;\n+  _M_resize = 0;\n+}\n+\n+inline void __container_size_info::__merge(const __container_size_info& __o)\n+{\n+  _M_init        = __max(_M_init, __o._M_init);\n+  _M_max         = __max(_M_max, __o._M_max);\n+  _M_item_max    = __max(_M_item_max, __o._M_item_max);\n+  _M_min         = __min(_M_min, __o._M_min);\n+  _M_item_min    = __min(_M_item_min, __o._M_item_min);\n+  _M_total      += __o._M_total;\n+  _M_item_total += __o._M_item_total;\n+  _M_count      += __o._M_count;\n+  _M_cost       += __o._M_cost;\n+  _M_resize     += __o._M_resize;\n+}\n+\n+inline __container_size_info::__container_size_info()\n+    : _M_init(0), _M_max(0), _M_item_max(0), _M_min(0), _M_item_min(0),\n+      _M_total(0), _M_item_total(0), _M_cost(0), _M_count(0), _M_resize(0)\n+{\n+}\n+\n+inline __container_size_info::__container_size_info(\n+    const __container_size_info& __o)\n+    : __object_info_base(__o)\n+{\n+  _M_init        = __o._M_init;\n+  _M_max         = __o._M_max;\n+  _M_item_max    = __o._M_item_max;\n+  _M_min         = __o._M_min;\n+  _M_item_min    = __o._M_item_min;\n+  _M_total       = __o._M_total;\n+  _M_item_total  = __o._M_item_total;\n+  _M_cost        = __o._M_cost;\n+  _M_count       = __o._M_count;\n+  _M_resize      = __o._M_resize;\n+}\n+\n+/** @brief A container size instrumentation line in the stack table.  */\n+class __container_size_stack_info: public __container_size_info\n+{\n+ public:\n+  __container_size_stack_info(const __container_size_info& __o)\n+      : __container_size_info(__o) {}\n+};\n+\n+/** @brief Container size instrumentation trace producer.  */\n+class __trace_container_size\n+    : public __trace_base<__container_size_info, __container_size_stack_info> \n+{\n+ public:\n+  ~__trace_container_size() {}\n+  __trace_container_size()\n+      : __trace_base<__container_size_info, __container_size_stack_info>() {};\n+\n+  // Insert a new node at construct with object, callstack and initial size. \n+  void __insert(const __object_t __obj, __stack_t __stack, size_t __num);\n+  // Call at destruction/clean to set container final size.\n+  void __destruct(const void* __obj, size_t __num, size_t __inum);\n+  void __construct(const void* __obj, size_t __inum);\n+  // Call at resize to set resize/cost information.\n+  void __resize(const void* __obj, int __from, int __to);\n+};\n+\n+inline void __trace_container_size::__insert(const __object_t __obj,\n+                                             __stack_t __stack, size_t __num)\n+{\n+  __add_object(__obj, __container_size_info(__stack, __num));\n+}\n+\n+inline void __container_size_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu\\n\", \n+          _M_init, _M_count, _M_cost, _M_resize, _M_min, _M_max, _M_total,\n+          _M_item_min, _M_item_max, _M_item_total);\n+}\n+\n+inline void __trace_container_size::__destruct(const void* __obj, \n+                                               size_t __num, size_t __inum)\n+{\n+  if (!__is_on()) return;\n+\n+  __object_t __obj_handle = static_cast<__object_t>(__obj);\n+\n+  __container_size_info* __object_info = __get_object_info(__obj_handle);\n+  if (!__object_info)\n+    return;\n+\n+  __object_info->__destruct(__num, __inum);\n+  __retire_object(__obj_handle);\n+}\n+\n+inline void __trace_container_size::__resize(const void* __obj, int __from, \n+                                             int __to)\n+{\n+  if (!__is_on()) return;\n+\n+  __container_size_info* __object_info = __get_object_info(__obj);\n+  if (!__object_info)\n+    return;\n+\n+  __object_info->__resize(__from, __to);\n+}\n+\n+} // namespace __cxxprof_impl\n+#endif /* PROFCXX_PROFILER_CONTAINER_SIZE_H__ */"}, {"sha": "cf6395451635b0058280bad5c2c4222001df4c81", "filename": "libstdc++-v3/include/profile/impl/profiler_hash_func.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,192 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_trace.h\n+ *  @brief Data structures to represent profiling traces.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_HASH_FUNC_H__\n+#define PROFCXX_PROFILER_HASH_FUNC_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstring>\n+#else\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#endif\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+\n+namespace __cxxprof_impl\n+{\n+\n+/** @brief A hash performance instrumentation line in the object table.  */\n+class __hashfunc_info: public __object_info_base\n+{\n+ public:\n+  __hashfunc_info()\n+      :_M_longest_chain(0), _M_accesses(0), _M_hops(0) {}\n+  __hashfunc_info(const __hashfunc_info& o);\n+  __hashfunc_info(__stack_t __stack)\n+      : __object_info_base(__stack),\n+        _M_longest_chain(0), _M_accesses(0), _M_hops(0){} \n+  virtual ~__hashfunc_info() {}\n+\n+  void __merge(const __hashfunc_info& __o);\n+  void __destruct(size_t __chain, size_t __accesses, size_t __hops);\n+  void __write(FILE* __f) const;\n+  float __magnitude() const { return static_cast<float>(_M_hops); }\n+  const char* __advice() const { return \"change hash function\"; }\n+\n+private:\n+  size_t _M_longest_chain;\n+  size_t _M_accesses;\n+  size_t _M_hops;\n+};\n+\n+inline __hashfunc_info::__hashfunc_info(const __hashfunc_info& __o)\n+    : __object_info_base(__o)\n+{\n+  _M_longest_chain = __o._M_longest_chain;\n+  _M_accesses      = __o._M_accesses;\n+  _M_hops          = __o._M_hops;\n+}\n+\n+inline void __hashfunc_info::__merge(const __hashfunc_info& __o)\n+{\n+  _M_longest_chain  = __max(_M_longest_chain, __o._M_longest_chain);\n+  _M_accesses      += __o._M_accesses;\n+  _M_hops          += __o._M_hops;\n+}\n+\n+inline void __hashfunc_info::__destruct(size_t __chain, size_t __accesses, \n+                                        size_t __hops)\n+{ \n+  _M_longest_chain  = __max(_M_longest_chain, __chain);\n+  _M_accesses      += __accesses;\n+  _M_hops          += __hops;\n+}\n+\n+/** @brief A hash performance instrumentation line in the stack table.  */\n+class __hashfunc_stack_info: public __hashfunc_info {\n+ public:\n+  __hashfunc_stack_info(const __hashfunc_info& __o) : __hashfunc_info(__o) {}\n+};\n+\n+/** @brief Hash performance instrumentation producer.  */\n+class __trace_hash_func\n+    : public __trace_base<__hashfunc_info, __hashfunc_stack_info> \n+{\n+ public:\n+  __trace_hash_func();\n+  ~__trace_hash_func() {}\n+\n+  // Insert a new node at construct with object, callstack and initial size. \n+  void __insert(__object_t __obj, __stack_t __stack);\n+  // Call at destruction/clean to set container final size.\n+  void __destruct(const void* __obj, size_t __chain,\n+                  size_t __accesses, size_t __hops);\n+};\n+\n+inline __trace_hash_func::__trace_hash_func()\n+    : __trace_base<__hashfunc_info, __hashfunc_stack_info>()\n+{\n+  __id = \"hash-distr\";\n+}\n+\n+inline void __trace_hash_func::__insert(__object_t __obj, __stack_t __stack)\n+{\n+  __add_object(__obj, __hashfunc_info(__stack));\n+}\n+\n+inline void __hashfunc_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu\\n\", _M_hops, _M_accesses, _M_longest_chain);\n+}\n+\n+inline void __trace_hash_func::__destruct(const void* __obj, size_t __chain,\n+                                          size_t __accesses, size_t __hops)\n+{\n+  if (!__is_on()) return;\n+\n+  // First find the item from the live objects and update the informations.\n+  __hashfunc_info* __objs = __get_object_info(__obj);\n+  if (!__objs)\n+    return;\n+\n+  __objs->__destruct(__chain, __accesses, __hops);\n+  __retire_object(__obj);\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Initialization and report.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_hash_func_init()\n+{\n+  __tables<0>::_S_hash_func = new __trace_hash_func();\n+}\n+\n+inline void __trace_hash_func_report(FILE* __f,\n+                                     __warning_vector_t& __warnings)\n+{\n+  if (__tables<0>::_S_hash_func) {\n+    __tables<0>::_S_hash_func->__collect_warnings(__warnings);\n+    __tables<0>::_S_hash_func->__write(__f);\n+  }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Implementations of instrumentation hooks.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_hash_func_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_hash_func->__insert(__obj, __get_stack());\n+}\n+\n+inline void __trace_hash_func_destruct(const void* __obj, size_t __chain,\n+                                       size_t __accesses, size_t __hops)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_hash_func->__destruct(__obj, __chain, __accesses, __hops);\n+}\n+\n+} // namespace __cxxprof_impl\n+#endif /* PROFCXX_PROFILER_HASH_FUNC_H__ */"}, {"sha": "2192879325eb8cb3cbf8484ba31ea661282a8b82", "filename": "libstdc++-v3/include/profile/impl/profiler_hashtable_size.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,115 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_hashtable_size.cc\n+ *  @brief Collection of hashtable size traces.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_HASHTABLE_SIZE_H__\n+#define PROFCXX_PROFILER_HASHTABLE_SIZE_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstring>\n+#else\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#endif\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+#include \"profile/impl/profiler_state.h\"\n+#include \"profile/impl/profiler_container_size.h\"\n+\n+namespace __cxxprof_impl\n+{\n+\n+/** @brief Hashtable size instrumentation trace producer.  */\n+class __trace_hashtable_size : public __trace_container_size\n+{\n+ public:\n+  __trace_hashtable_size() : __trace_container_size()\n+  {\n+    __id = \"hashtable-size\";\n+  }\n+};\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Initialization and report.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_hashtable_size_init()\n+{\n+  __tables<0>::_S_hashtable_size = new __trace_hashtable_size();\n+}\n+\n+inline void __trace_hashtable_size_report(FILE* __f, \n+                                          __warning_vector_t& __warnings)\n+{\n+  if (__tables<0>::_S_hashtable_size) {\n+    __tables<0>::_S_hashtable_size->__collect_warnings(__warnings);\n+    __tables<0>::_S_hashtable_size->__write(__f);\n+  }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Implementations of instrumentation hooks.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_hashtable_size_construct(const void* __obj, size_t __num)\n+{\n+  if (!__profcxx_init()) return;\n+  \n+  __tables<0>::_S_hashtable_size->__insert(__obj, __get_stack(), __num);\n+}\n+\n+inline void __trace_hashtable_size_destruct(const void* __obj, size_t __num, \n+                                            size_t __inum)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_hashtable_size->__destruct(__obj, __num, __inum);\n+}\n+\n+inline void __trace_hashtable_size_resize(const void* __obj, size_t __from, \n+                                          size_t __to)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_hashtable_size->__resize(__obj, __from, __to);\n+}\n+\n+} // namespace __cxxprof_impl\n+\n+#endif /* PROFCXX_PROFILER_HASHTABLE_SIZE_H__ */"}, {"sha": "cdb88a86bcb7b3e0ca922267fba9d402ad7fd134", "filename": "libstdc++-v3/include/profile/impl/profiler_map_to_unordered_map.h", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,305 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_map_to_unordered_map.h\n+ *  @brief Diagnostics for map to unordered_map.\n+ */\n+\n+// Written by Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_MAP_TO_UNORDERED_MAP_H__\n+#define PROFCXX_PROFILER_MAP_TO_UNORDERED_MAP_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstring>\n+#else\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#endif\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+\n+namespace __cxxprof_impl\n+{\n+\n+// Cost model. XXX: this must be taken from the machine model instead.\n+//  Map operations:\n+//   - insert: 1.5 * log(size)\n+//   - erase: 1.5 * log(size)\n+//   - find: log(size)\n+//   - iterate: 2.3\n+//  Unordered map operations:\n+//   - insert: 12\n+//   - erase: 12\n+//   - find: 10\n+//   - iterate: 1.7\n+\n+const float __map_insert_cost_factor = 1.5;\n+const float __map_erase_cost_factor = 1.5;\n+const float __map_find_cost_factor = 1;\n+const float __map_iterate_cost = 2.3;\n+\n+const float __umap_insert_cost = 12.0;\n+const float __umap_erase_cost = 12.0;\n+const float __umap_find_cost = 10.0;\n+const float __umap_iterate_cost = 1.7;\n+\n+inline int __log2(size_t __size)\n+{\n+  for (int __bit_count = sizeof(size_t) - 1; __bit_count >= 0; --__bit_count) {\n+    if ((2 << __bit_count) & __size) {\n+      return __bit_count;\n+    }\n+  }\n+  return 0;\n+}\n+\n+inline float __map_insert_cost(size_t __size)\n+{\n+  return __map_insert_cost_factor * static_cast<float>(__log2(__size));\n+}\n+\n+inline float __map_erase_cost(size_t __size)\n+{\n+  return __map_erase_cost_factor * static_cast<float>(__log2(__size));\n+}\n+\n+inline float __map_find_cost(size_t __size)\n+{\n+  return __map_find_cost_factor * static_cast<float>(__log2(__size));\n+}\n+\n+/** @brief A map-to-unordered_map instrumentation line in the object table.  */\n+class __map2umap_info: public __object_info_base\n+{\n+ public:\n+  __map2umap_info()\n+      : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n+        _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {}\n+  __map2umap_info(__stack_t __stack)\n+      : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n+        _M_iterate(0), _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {} \n+  virtual ~__map2umap_info() {}\n+  __map2umap_info(const __map2umap_info& o);\n+  void __merge(const __map2umap_info& o);\n+  void __write(FILE* __f) const;\n+  float __magnitude() const { return _M_map_cost - _M_umap_cost; }\n+  const char* __advice() const;\n+\n+  void __record_insert(size_t __size, size_t __count);\n+  void __record_erase(size_t __size, size_t __count);\n+  void __record_find(size_t __size);\n+  void __record_iterate(size_t __count);\n+  void __record_invalidate();\n+\n+ private:\n+  size_t _M_insert;\n+  size_t _M_erase;\n+  size_t _M_find;\n+  size_t _M_iterate;\n+  float _M_umap_cost;\n+  float _M_map_cost;\n+  bool  _M_valid;\n+};\n+\n+inline const char* __map2umap_info::__advice() const\n+{\n+  return \"change std::map to std::unordered_map\";\n+}\n+\n+inline __map2umap_info::__map2umap_info(const __map2umap_info& __o)\n+    : __object_info_base(__o), \n+      _M_insert(__o._M_insert),\n+      _M_erase(__o._M_erase),\n+      _M_find(__o._M_find),\n+      _M_iterate(__o._M_iterate),\n+      _M_map_cost(__o._M_map_cost),\n+      _M_umap_cost(__o._M_umap_cost),\n+      _M_valid(__o._M_valid)\n+{}\n+\n+inline void __map2umap_info::__merge(const __map2umap_info& __o)\n+{\n+  _M_insert    += __o._M_insert;\n+  _M_erase     += __o._M_erase;\n+  _M_find      += __o._M_find;\n+  _M_map_cost  += __o._M_map_cost;\n+  _M_umap_cost += __o._M_umap_cost;\n+  _M_valid     &= __o._M_valid;\n+}\n+\n+inline void __map2umap_info:: __record_insert(size_t __size, size_t __count)\n+{\n+  _M_insert += __count;\n+  _M_map_cost += __count * __map_insert_cost(__size);\n+  _M_umap_cost += __count * __umap_insert_cost;\n+}\n+\n+inline void __map2umap_info:: __record_erase(size_t __size, size_t __count)\n+{\n+  _M_erase += __count;\n+  _M_map_cost += __count * __map_erase_cost(__size);\n+  _M_umap_cost += __count * __umap_erase_cost;\n+}\n+\n+inline void __map2umap_info:: __record_find(size_t __size)\n+{\n+  _M_find += 1;\n+  _M_map_cost += __map_find_cost(__size);\n+  _M_umap_cost += __umap_find_cost;\n+}\n+\n+inline void __map2umap_info:: __record_iterate(size_t __count)\n+{\n+  _M_iterate += __count;\n+  _M_map_cost += __count * __map_iterate_cost;\n+  _M_umap_cost += __count * __umap_iterate_cost;\n+}\n+\n+inline void __map2umap_info:: __record_invalidate()\n+{\n+  _M_valid = false;\n+}\n+\n+inline void __map2umap_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu %Zu %.0f %.0f %s\\n\",\n+          _M_insert, _M_erase, _M_find, _M_iterate, _M_map_cost, _M_umap_cost,\n+          _M_valid ? \"valid\" : \"invalid\");\n+}\n+\n+/** @brief A map-to-unordered_map instrumentation line in the stack table.  */\n+class __map2umap_stack_info: public __map2umap_info\n+{\n+ public:\n+  __map2umap_stack_info(const __map2umap_info& o) : __map2umap_info(o) {}\n+};\n+\n+/** @brief Map-to-unordered_map instrumentation producer.  */\n+class __trace_map2umap\n+    : public __trace_base<__map2umap_info, __map2umap_stack_info> \n+{\n+ public:\n+  __trace_map2umap();\n+};\n+\n+inline __trace_map2umap::__trace_map2umap()\n+    : __trace_base<__map2umap_info, __map2umap_stack_info>()\n+{\n+  __id = \"map-to-unordered-map\";\n+}\n+\n+inline void __trace_map_to_unordered_map_init()\n+{\n+  __tables<0>::_S_map2umap = new __trace_map2umap();\n+}\n+\n+inline void __trace_map_to_unordered_map_report(\n+    FILE* __f, __warning_vector_t& __warnings)\n+{\n+  if (__tables<0>::_S_map2umap) {\n+    __tables<0>::_S_map2umap->__collect_warnings(__warnings);\n+    __tables<0>::_S_map2umap->__write(__f);\n+  }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Implementations of instrumentation hooks.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_map_to_unordered_map_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_map2umap->__add_object(__obj, \n+                                         __map2umap_info(__get_stack()));\n+}\n+\n+inline void __trace_map_to_unordered_map_destruct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_map2umap->__retire_object(__obj);\n+}\n+\n+inline void __trace_map_to_unordered_map_insert(const void* __obj, \n+                                                size_t __size, size_t __count)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+\n+  if (__info) __info->__record_insert(__size, __count);\n+}\n+\n+inline void __trace_map_to_unordered_map_erase(const void* __obj, \n+                                               size_t __size, size_t __count)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+\n+  if (__info) __info->__record_erase(__size, __count);\n+}\n+\n+inline void __trace_map_to_unordered_map_find(const void* __obj, size_t __size)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+\n+  if (__info) __info->__record_find(__size);\n+}\n+\n+inline void __trace_map_to_unordered_map_iterate(const void* __obj, \n+                                                 size_t __count)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+\n+  if (__info) __info->__record_iterate(__count);\n+}\n+\n+inline void __trace_map_to_unordered_map_invalidate(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+\n+  if (__info) __info->__record_invalidate();\n+}\n+\n+} // namespace __cxxprof_impl\n+#endif /* PROFCXX_PROFILER_MAP_TO_UNORDERED_MAP_H__ */"}, {"sha": "cd2b9ab20162980501831949bbb5dda6f134464f", "filename": "libstdc++-v3/include/profile/impl/profiler_node.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,172 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_node.h\n+ *  @brief Data structures to represent a single profiling event.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_NODE_H__\n+#define PROFCXX_PROFILER_NODE_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdio>\n+#include <cstdint>\n+#include <cstring>\n+#else\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <string.h>\n+#endif\n+#include <vector>\n+#if defined HAVE_EXECINFO_H\n+#include <execinfo.h>\n+#endif\n+\n+namespace __cxxprof_impl\n+{\n+typedef const void* __object_t;\n+typedef void* __instruction_address_t;\n+typedef std::_GLIBCXX_STD_PR::vector<__instruction_address_t> __stack_npt;\n+typedef __stack_npt* __stack_t;\n+\n+size_t __stack_max_depth();\n+\n+inline __stack_t __get_stack()\n+{\n+#if defined HAVE_EXECINFO_H\n+  size_t __max_depth = __stack_max_depth();\n+  if (__max_depth == 0)\n+    return NULL;\n+  __stack_npt __buffer(__max_depth);\n+  int __depth = backtrace(&__buffer[0], __max_depth);\n+  __stack_t __stack = new __stack_npt(__depth);\n+  memcpy(&(*__stack)[0], &__buffer[0], __depth * sizeof(__object_t));\n+  return __stack;\n+#else\n+  return NULL;\n+#endif\n+}\n+\n+inline __size(const __stack_t& __stack)\n+{\n+  if (!__stack) {\n+    return 0;\n+  } else {\n+    return __stack->size();\n+  }\n+}\n+\n+inline void __write(FILE* __f, const __stack_t __stack)\n+{\n+  if (!__stack) {\n+    return;\n+  }\n+\n+  __stack_npt::const_iterator __it;\n+  for (__it = __stack->begin(); __it != __stack->end(); ++__it) {\n+    fprintf(__f, \"%p \", *__it);\n+  }\n+}\n+\n+/** @brief Hash function for summary trace using call stack as index.  */\n+class __stack_hash \n+{\n+ public:\n+  size_t operator()(const __stack_t __s) const\n+  {\n+    if (!__s) {\n+      return 0;\n+    }\n+\n+    uintptr_t __index = 0;\n+    __stack_npt::const_iterator __it;\n+    for (__it = __s->begin(); __it != __s->end(); ++__it) {\n+      __index += reinterpret_cast<uintptr_t>(*__it);\n+    } \n+    return __index;\n+  }\n+\n+  bool operator() (const __stack_t __stack1, const __stack_t __stack2) const\n+  {\n+    if (!__stack1 && !__stack2) return true;\n+    if (!__stack1 || !__stack2) return false;\n+    if (__stack1->size() != __stack2->size()) return false;\n+\n+    size_t __byte_size = __stack1->size() * sizeof(__stack_npt::value_type);\n+    return memcmp(&(*__stack1)[0], &(*__stack2)[0], __byte_size) == 0;\n+  }\n+};\n+\n+/** @brief Base class for a line in the object table.  */\n+class __object_info_base\n+{\n+ public:\n+  __object_info_base() {}\n+  __object_info_base(__stack_t __stack);\n+  __object_info_base(const __object_info_base& o);\n+  virtual ~__object_info_base() {}\n+  bool __is_valid() const { return _M_valid; }\n+  __stack_t __stack() const { return _M_stack; }\n+  virtual void __write(FILE* f) const = 0;\n+\n+ protected:\n+  __stack_t _M_stack;\n+  bool _M_valid;\n+};\n+\n+inline __object_info_base::__object_info_base(__stack_t __stack)\n+{\n+  _M_stack = __stack;\n+  _M_valid = true;\n+}\n+\n+inline __object_info_base::__object_info_base(const __object_info_base& __o)\n+{\n+  _M_stack = __o._M_stack;\n+  _M_valid = __o._M_valid;\n+}\n+\n+/** @brief Base class for a line in the stack table.  */\n+template<typename __object_info>\n+class __stack_info_base\n+{\n+ public:\n+  __stack_info_base() {}\n+  __stack_info_base(const __object_info& __info) = 0;\n+  virtual ~__stack_info_base() {}\n+  void __merge(const __object_info& __info) = 0;\n+  virtual float __magnitude() const = 0;\n+  virtual const char* __get_id() const = 0;\n+};\n+\n+} // namespace __cxxprof_impl\n+#endif /* PROFCXX_PROFILER_NODE_H__ */"}, {"sha": "64c10db616c3b30401571271f41e606a25e7f88c", "filename": "libstdc++-v3/include/profile/impl/profiler_state.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,107 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_state.cc\n+ *  @brief Global profiler state.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_STATE_H__\n+#define PROFCXX_PROFILER_STATE_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdio>\n+#else\n+#include <stdio.h>\n+#endif\n+\n+namespace __cxxprof_impl\n+{\n+\n+/** @brief Profiling mode on/off state.  */\n+template <int _Unused=0>\n+class __state\n+{\n+ public:\n+\n+  static __state<_Unused>* _S_diag_state;\n+\n+  __state() : _M_state(__INVALID) {}\n+  ~__state() {}\n+\n+  bool __is_on() { return _M_state == __ON; }\n+  bool __is_off() { return _M_state == __OFF; }\n+  bool __is_invalid() { return _M_state == __INVALID; }\n+  void __turn_on() { _M_state = __ON; }\n+  void __turn_off() { _M_state = __OFF; }\n+\n+ private:\n+  enum __state_type { __ON, __OFF, __INVALID };\n+  __state_type _M_state;\n+};\n+\n+template <int _Unused>\n+__state<_Unused>* __state<_Unused>::_S_diag_state = NULL;\n+\n+inline bool __is_on()\n+{\n+  return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_on();\n+}\n+\n+inline bool __is_off()\n+{\n+  return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_off();\n+}\n+\n+inline bool __is_invalid()\n+{\n+  return (!__state<0>::_S_diag_state \n+          || __state<0>::_S_diag_state->__is_invalid());\n+}\n+\n+inline void __turn_on()\n+{\n+  if (!__state<0>::_S_diag_state) { \n+    __state<0>::_S_diag_state = new __state<0>();\n+  }\n+  __state<0>::_S_diag_state->__turn_on();\n+}\n+\n+inline void __turn_off()\n+{\n+  if (!__state<0>::_S_diag_state) { \n+    __state<0>::_S_diag_state = new __state<0>();\n+  }\n+  __state<0>::_S_diag_state->__turn_off();\n+}\n+\n+} // end namespace __cxxprof_impl\n+#endif /* PROFCXX_PROFILER_STATE_H__ */"}, {"sha": "37bcb6436e530afd2e0ed2ebdb667a1214d7ccd1", "filename": "libstdc++-v3/include/profile/impl/profiler_trace.h", "status": "added", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,564 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_trace.h\n+ *  @brief Data structures to represent profiling traces.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_TRACE_H__\n+#define PROFCXX_PROFILER_TRACE_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cerrno>\n+#include <cstdint>\n+#include <cstdio>\n+#include <cstdlib>\n+#define _GLIBCXX_IMPL_UNORDERED_MAP std::_GLIBCXX_STD_PR::unordered_map\n+#include <unordered_map>\n+#else\n+#include <errno.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <tr1/unordered_map>\n+#define _GLIBCXX_IMPL_UNORDERED_MAP std::tr1::unordered_map\n+#endif\n+\n+#include <algorithm>\n+#include <utility>\n+\n+#if defined _GLIBCXX_PROFILE_THREADS && defined HAVE_TLS\n+#include <pthread.h>\n+#endif\n+\n+#include \"profile/impl/profiler_state.h\"\n+#include \"profile/impl/profiler_node.h\"\n+\n+namespace __cxxprof_impl\n+{\n+\n+#if defined _GLIBCXX_PROFILE_THREADS && defined HAVE_TLS\n+#define _GLIBCXX_IMPL_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n+typedef pthread_mutex_t __mutex_t;\n+/** @brief Pthread mutex wrapper.  */\n+template <int _Unused=0>\n+class __mutex {\n+ public:\n+  static __mutex_t __global_lock;\n+  static void __lock(__mutex_t& __m) { pthread_mutex_lock(&__m); }\n+  static void __unlock(__mutex_t& __m) { pthread_mutex_unlock(&__m); }\n+};\n+#else\n+#define _GLIBCXX_IMPL_MUTEX_INITIALIZER 0\n+typedef int __mutex_t;\n+/** @brief Mock mutex interface.  */\n+template <int _Unused=0>\n+class __mutex {\n+ public:\n+  static __mutex_t __global_lock;\n+  static void __lock(__mutex_t& __m) {}\n+  static void __unlock(__mutex_t& __m) {}\n+};\n+#endif\n+\n+template <int _Unused>\n+__mutex_t __mutex<_Unused>::__global_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n+\n+/** @brief Representation of a warning.  */\n+struct __warning_data\n+{\n+  float __magnitude;\n+  __stack_t __context;\n+  const char* __warning_id;\n+  const char* __warning_message;\n+  __warning_data();\n+  __warning_data(float __m, __stack_t __c, const char* __id, \n+                 const char* __msg);\n+  bool operator>(const struct __warning_data& other) const;\n+};\n+\n+inline __warning_data::__warning_data()\n+    : __magnitude(0.0), __context(NULL), __warning_id(NULL),\n+      __warning_message(NULL)\n+{\n+}\n+\n+inline __warning_data::__warning_data(float __m, __stack_t __c, \n+                                      const char* __id, const char* __msg)\n+    : __magnitude(__m), __context(__c), __warning_id(__id),\n+      __warning_message(__msg)\n+{\n+}\n+\n+inline bool __warning_data::operator>(const struct __warning_data& other) const\n+{\n+  return __magnitude > other.__magnitude;\n+}\n+\n+typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n+\n+// Defined in profiler_<diagnostic name>.h.\n+class __trace_hash_func;\n+class __trace_hashtable_size;\n+class __trace_map2umap;\n+class __trace_vector_size;\n+class __trace_vector_to_list;\n+void __trace_vector_size_init();\n+void __trace_hashtable_size_init();\n+void __trace_hash_func_init();\n+void __trace_vector_to_list_init();\n+void __trace_map_to_unordered_map_init();\n+void __trace_vector_size_report(FILE*, __warning_vector_t&);\n+void __trace_hashtable_size_report(FILE*, __warning_vector_t&);\n+void __trace_hash_func_report(FILE*, __warning_vector_t&);\n+void __trace_vector_to_list_report(FILE*, __warning_vector_t&);\n+void __trace_map_to_unordered_map_report(FILE*, __warning_vector_t&);\n+\n+// Utility functions.\n+inline size_t __max(size_t __a, size_t __b)\n+{\n+  return __a >= __b ? __a : __b;\n+}\n+\n+inline size_t __min(size_t __a, size_t __b)\n+{\n+  return __a <= __b ? __a : __b;\n+}\n+\n+/** @brief Storage for diagnostic table entries.  Has only static fields.  */\n+template <int _Unused=0>\n+class __tables\n+{\n+ public:\n+  static __trace_hash_func* _S_hash_func;\n+  static __trace_hashtable_size* _S_hashtable_size;\n+  static __trace_map2umap* _S_map2umap;\n+  static __trace_vector_size* _S_vector_size;\n+  static __trace_vector_to_list* _S_vector_to_list;\n+};\n+\n+template <int _Unused>\n+__trace_hash_func* __tables<_Unused>::_S_hash_func = NULL;\n+template <int _Unused>\n+__trace_hashtable_size* __tables<_Unused>::_S_hashtable_size = NULL;\n+template <int _Unused>\n+__trace_map2umap* __tables<_Unused>::_S_map2umap = NULL;\n+template <int _Unused>\n+__trace_vector_size* __tables<_Unused>::_S_vector_size = NULL;\n+template <int _Unused>\n+__trace_vector_to_list* __tables<_Unused>::_S_vector_to_list = NULL;\n+\n+/** @brief Storage for user defined parameters.  Has only static fields.  */\n+template <int _Unused=0>\n+class __settings {\n+ public:\n+  static const char* _S_trace_file_name;\n+  static size_t _S_max_warn_count;\n+  static size_t _S_max_stack_depth;\n+  static size_t _S_max_mem;\n+};\n+\n+template <int _Unused>\n+const char* __settings<_Unused>::_S_trace_file_name = \n+    _GLIBCXX_PROFILE_TRACE_PATH_ROOT;\n+template <int _Unused>\n+size_t __settings<_Unused>::_S_max_warn_count =\n+    _GLIBCXX_PROFILE_MAX_WARN_COUNT;\n+template <int _Unused>\n+size_t __settings<_Unused>::_S_max_stack_depth =\n+    _GLIBCXX_PROFILE_MAX_STACK_DEPTH;\n+template <int _Unused>\n+size_t __settings<_Unused>::_S_max_mem =\n+    _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC;\n+\n+inline size_t __stack_max_depth()\n+{\n+  return __settings<0>::_S_max_stack_depth;\n+}\n+\n+inline size_t __max_mem()\n+{\n+  return __settings<0>::_S_max_mem;\n+}\n+\n+/** @brief Base class for all trace producers.  */\n+template <typename __object_info, typename __stack_info>\n+class __trace_base\n+{\n+ public:\n+  __trace_base();\n+  virtual ~__trace_base() {}\n+\n+  void __add_object(__object_t object, __object_info __info);\n+  __object_info* __get_object_info(__object_t __object);\n+  void __retire_object(__object_t __object);\n+  void __write(FILE* f);\n+  void __collect_warnings(__warning_vector_t& warnings);\n+\n+  void __lock_object_table();\n+  void __lock_stack_table();\n+  void __unlock_object_table();\n+  void __unlock_stack_table();\n+\n+ private:\n+  __mutex_t __object_table_lock;\n+  __mutex_t __stack_table_lock;\n+  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t, \n+                                      __object_info> __object_table_t;\n+  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info, __stack_hash, \n+                                      __stack_hash> __stack_table_t;\n+  __object_table_t __object_table;\n+  __stack_table_t __stack_table;\n+  size_t __stack_table_byte_size;\n+\n+ protected:\n+  const char* __id;\n+};\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__collect_warnings(\n+    __warning_vector_t& warnings)\n+{\n+  typename __stack_table_t::iterator __i = __stack_table.begin();\n+  for ( ; __i != __stack_table.end(); ++__i )\n+  {\n+    warnings.push_back(__warning_data((*__i).second.__magnitude(), \n+                                      (*__i).first, \n+                                      __id,\n+                                      (*__i).second.__advice()));\n+  }\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__lock_object_table()\n+{\n+  __mutex<0>::__lock(this->__object_table_lock);\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__lock_stack_table()\n+{\n+  __mutex<0>::__lock(this->__stack_table_lock);\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__unlock_object_table()\n+{\n+  __mutex<0>::__unlock(this->__object_table_lock);\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__unlock_stack_table()\n+{\n+  __mutex<0>::__unlock(this->__stack_table_lock);\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+__trace_base<__object_info, __stack_info>::__trace_base()\n+{\n+  // Do not pick the initial size too large, as we don't know which diagnostics\n+  // are more active.\n+  __object_table.rehash(10000);\n+  __stack_table.rehash(10000);\n+  __stack_table_byte_size = 0;\n+  __id = NULL;\n+  __object_table_lock = __stack_table_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__add_object(\n+    __object_t __object, __object_info __info)\n+{\n+  if (__max_mem() == 0 \n+      || __object_table.size() * sizeof(__object_info) <= __max_mem()) {\n+    __lock_object_table();\n+    __object_table.insert(\n+        typename __object_table_t::value_type(__object, __info));\n+    __unlock_object_table();\n+  }\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+__object_info* __trace_base<__object_info, __stack_info>::__get_object_info(\n+    __object_t __object)\n+{\n+  // XXX: Revisit this to see if we can decrease mutex spans.\n+  // Without this mutex, the object table could be rehashed during an\n+  // insertion on another thread, which could result in a segfault.\n+  __lock_object_table();\n+  typename __object_table_t::iterator __object_it = \n+      __object_table.find(__object);\n+  if (__object_it == __object_table.end()){\n+    __unlock_object_table();\n+    return NULL;\n+  } else {\n+    __unlock_object_table();\n+    return &__object_it->second;\n+  }\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__retire_object(\n+    __object_t __object)\n+{\n+  __lock_object_table();\n+  __lock_stack_table();\n+  typename __object_table_t::iterator __object_it =\n+      __object_table.find(__object);\n+  if (__object_it != __object_table.end()){\n+    const __object_info& __info = __object_it->second;\n+    const __stack_t& __stack = __info.__stack();\n+    typename __stack_table_t::iterator __stack_it = \n+        __stack_table.find(__stack);\n+    if (__stack_it == __stack_table.end()) {\n+      // First occurence of this call context.\n+      if (__max_mem() == 0 || __stack_table_byte_size < __max_mem()) {\n+        __stack_table_byte_size += \n+            (sizeof(__instruction_address_t) * __size(__stack)\n+             + sizeof(__stack) + sizeof(__stack_info));\n+        __stack_table.insert(make_pair(__stack, __stack_info(__info)));\n+      }\n+    } else {\n+      // Merge object info into info summary for this call context.\n+      __stack_it->second.__merge(__info);\n+      delete __stack;\n+    }\n+    __object_table.erase(__object);\n+  }\n+  __unlock_stack_table();\n+  __unlock_object_table();\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__write(FILE* __f)\n+{\n+  typename __stack_table_t::iterator __it;\n+\n+  for (__it = __stack_table.begin(); __it != __stack_table.end(); __it++) {\n+    if (__it->second.__is_valid()) {\n+      fprintf(__f, __id);\n+      fprintf(__f, \"|\");\n+      __cxxprof_impl::__write(__f, __it->first);\n+      fprintf(__f, \"|\");\n+      __it->second.__write(__f);\n+    }\n+  }\n+}\n+\n+inline size_t __env_to_size_t(const char* __env_var, size_t __default_value)\n+{\n+  char* __env_value = getenv(__env_var);\n+  if (__env_value) {\n+    long int __converted_value = strtol(__env_value, NULL, 10);\n+    if (errno || __converted_value < 0) {\n+      fprintf(stderr, \"Bad value for environment variable '%s'.\", __env_var);\n+      abort();\n+    } else {\n+      return static_cast<size_t>(__converted_value);\n+    }\n+  } else {\n+    return __default_value;\n+  }\n+}\n+\n+inline void __set_max_stack_trace_depth()\n+{\n+  __settings<0>::_S_max_stack_depth = __env_to_size_t(\n+      _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR,\n+      __settings<0>::_S_max_stack_depth);\n+}\n+\n+inline void __set_max_mem()\n+{\n+  __settings<0>::_S_max_mem = __env_to_size_t(\n+      _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR, __settings<0>::_S_max_mem);\n+}\n+\n+inline int __log_magnitude(float f)\n+{\n+  const float log_base = 10.0;\n+  int result = 0;\n+  int sign = 1;\n+  if (f < 0) {\n+    f = -f;\n+    sign = -1;\n+  }\n+  while (f > log_base) {\n+    ++result;\n+    f /= 10.0;\n+  }\n+  return sign * result;\n+}\n+\n+struct __warn\n+{\n+  FILE* __file;\n+  __warn(FILE* __f) { __file = __f; }\n+  void operator() (const __warning_data& __info)\n+  {\n+    fprintf(__file,  __info.__warning_id);\n+    fprintf(__file, \": improvement = %d\", __log_magnitude(__info.__magnitude));\n+    fprintf(__file, \": call stack = \");\n+    __cxxprof_impl::__write(__file, __info.__context);\n+    fprintf(__file, \": advice = %s\\n\", __info.__warning_message);\n+  }\n+};\n+\n+inline FILE* __open_output_file(const char* extension)\n+{\n+  // The path is made of _S_trace_file_name + \".\" + extension.\n+  size_t root_len = strlen(__settings<0>::_S_trace_file_name);\n+  size_t ext_len = strlen(extension);\n+  char* file_name = new char[root_len + 1 + ext_len + 1];\n+  char* p = file_name;\n+  memcpy(file_name, __settings<0>::_S_trace_file_name, root_len);\n+  *(file_name + root_len) = '.';\n+  memcpy(file_name + root_len + 1, extension, ext_len + 1);\n+  FILE* out_file = fopen(file_name, \"w\");\n+  if (out_file) {\n+    return out_file;\n+  } else {\n+    fprintf(stderr, \"Could not open trace file '%s'.\", file_name);\n+    abort();\n+  }\n+}\n+\n+/** @brief Final report method, registered with \"atexit\".\n+ *\n+ * This can also be called directly by user code, including signal handlers.\n+ * It is protected against deadlocks by the reentrance guard in profiler.h.\n+ * However, when called from a signal handler that triggers while within\n+ * __cxxprof_impl (under the guarded zone), no output will be produced.\n+ */\n+inline void __report(void)\n+{\n+  __mutex<0>::__lock(__mutex<0>::__global_lock);\n+\n+  __warning_vector_t __warnings;\n+\n+  FILE* __raw_file = __open_output_file(\"raw\");\n+  __trace_vector_size_report(__raw_file, __warnings);\n+  __trace_hashtable_size_report(__raw_file, __warnings);\n+  __trace_hash_func_report(__raw_file, __warnings);\n+  __trace_vector_to_list_report(__raw_file, __warnings);\n+  __trace_map_to_unordered_map_report(__raw_file, __warnings);\n+  fclose(__raw_file);\n+\n+  // Sort data by magnitude.\n+  // XXX: instead of sorting, should collect only top N for better performance.\n+  size_t __cutoff = __min(__settings<0>::_S_max_warn_count, \n+                          __warnings.size());\n+\n+  std::sort(__warnings.begin(), __warnings.end(),\n+            std::greater<__warning_vector_t::value_type>());\n+  __warnings.resize(__cutoff);\n+\n+  FILE* __warn_file = __open_output_file(\"txt\");\n+  std::for_each(__warnings.begin(), __warnings.end(), __warn(__warn_file));\n+  fclose(__warn_file);\n+\n+  __mutex<0>::__unlock(__mutex<0>::__global_lock);\n+}\n+\n+inline void __set_trace_path()\n+{\n+  char* __env_trace_file_name = getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);\n+\n+  if (__env_trace_file_name) { \n+    __settings<0>::_S_trace_file_name = __env_trace_file_name; \n+  }\n+\n+  // Make sure early that we can create the trace file.\n+  fclose(__open_output_file(\"txt\"));\n+}\n+\n+inline void __set_max_warn_count()\n+{\n+  char* __env_max_warn_count_str = getenv(\n+      _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);\n+\n+  if (__env_max_warn_count_str) {\n+    __settings<0>::_S_max_warn_count = static_cast<size_t>(\n+        atoi(__env_max_warn_count_str));\n+  }\n+}\n+\n+inline void __profcxx_init_unconditional()\n+{\n+  __mutex<0>::__lock(__mutex<0>::__global_lock);\n+\n+  __set_max_warn_count();\n+\n+  if (__is_invalid()) {\n+\n+    if (__settings<0>::_S_max_warn_count == 0) {\n+\n+      __turn_off();\n+\n+    } else {\n+\n+      __set_max_stack_trace_depth();\n+      __set_max_mem();\n+      __set_trace_path();\n+\n+      __trace_vector_size_init();\n+      __trace_hashtable_size_init();\n+      __trace_hash_func_init();\n+      __trace_vector_to_list_init();\n+      __trace_map_to_unordered_map_init();\n+\n+      atexit(__report);\n+\n+      __turn_on();\n+\n+    }\n+  }\n+\n+  __mutex<0>::__unlock(__mutex<0>::__global_lock);\n+}\n+\n+/** @brief This function must be called by each instrumentation point.\n+ *\n+ * The common path is inlined fully.\n+ */\n+inline bool __profcxx_init(void)\n+{\n+  if (__is_invalid()) {\n+    __profcxx_init_unconditional();\n+  }\n+\n+  return __is_on();\n+}\n+\n+} // namespace __cxxprof_impl\n+\n+#endif /* PROFCXX_PROFILER_TRACE_H__ */"}, {"sha": "dd42959825f2b4ed6f196f4f95cb7425a6df6cbf", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_size.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,112 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_vector_size.h\n+ *  @brief Collection of vector size traces.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_VECTOR_SIZE_H__\n+#define PROFCXX_PROFILER_VECTOR_SIZE_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstring>\n+#else\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#endif\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+#include \"profile/impl/profiler_state.h\"\n+#include \"profile/impl/profiler_container_size.h\"\n+\n+namespace __cxxprof_impl\n+{\n+\n+/** @brief Hashtable size instrumentation trace producer.  */\n+class __trace_vector_size : public __trace_container_size\n+{\n+ public:\n+  __trace_vector_size() : __trace_container_size() { __id = \"vector-size\"; }\n+};\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Initialization and report.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_vector_size_init()\n+{\n+  __tables<0>::_S_vector_size = new __trace_vector_size();\n+}\n+\n+inline void __trace_vector_size_report(FILE* __f, \n+                                       __warning_vector_t& __warnings)\n+{\n+  if (__tables<0>::_S_vector_size) {\n+    __tables<0>::_S_vector_size->__collect_warnings(__warnings);\n+    __tables<0>::_S_vector_size->__write(__f);\n+  }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Implementations of instrumentation hooks.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_vector_size_construct(const void* __obj, size_t __num)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_size->__insert(__obj, __get_stack(), __num);\n+}\n+\n+inline void __trace_vector_size_destruct(const void* __obj, size_t __num,\n+                                         size_t __inum)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_size->__destruct(__obj, __num, __inum);\n+}\n+\n+inline void __trace_vector_size_resize(const void* __obj, size_t __from,\n+                                       size_t __to)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_size->__resize(__obj, __from, __to);\n+}\n+\n+} // namespace __cxxprof_impl\n+\n+#endif /* PROFCXX_PROFILER_VECTOR_SIZE_H__ */"}, {"sha": "ec3dfbcfb8637bb52c0d92e4007fbdbbded7cd25", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_to_list.h", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,318 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_trace.h\n+ *  @brief Data structures to represent profiling traces.\n+ */\n+\n+// Written by Lixia Liu and Silvius Rus.\n+\n+#ifndef PROFCXX_PROFILER_VECTOR_TO_LIST_H__\n+#define PROFCXX_PROFILER_VECTOR_TO_LIST_H__ 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdio>\n+#include <cstdlib>\n+#include <cstring>\n+#else\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <string.h>\n+#endif\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+\n+namespace __cxxprof_impl\n+{\n+\n+/** @brief A vector-to-list instrumentation line in the object table.  */\n+class __vector2list_info: public __object_info_base\n+{\n+ public:\n+  __vector2list_info()\n+      :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n+       _M_vector_cost(0), _M_valid(true) {}\n+  __vector2list_info(__stack_t __stack)\n+      : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n+        _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true) {} \n+  virtual ~__vector2list_info() {}\n+  __vector2list_info(const __vector2list_info& __o);\n+  void __merge(const __vector2list_info& __o);\n+  void __write(FILE* __f) const;\n+  float __magnitude() const { return _M_vector_cost - _M_list_cost; }\n+  const char* __advice() const { return \"change std::vector to std::list\"; }\n+\n+  size_t __shift_count() { return _M_shift_count; }\n+  size_t __iterate()   { return _M_iterate; }\n+  float __list_cost() { return _M_list_cost; }\n+  size_t __resize() { return _M_resize; }\n+  void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n+  void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n+  bool __is_valid() { return _M_valid; }\n+  void __set_invalid() { _M_valid = false; }\n+\n+  void __opr_insert(size_t __pos, size_t __num);\n+  void __opr_iterate(size_t __num) { _M_iterate += __num; }\n+  void __resize(size_t __from, size_t __to);\n+\n+private:\n+  size_t _M_shift_count;\n+  size_t _M_iterate;\n+  size_t _M_resize;\n+  float _M_list_cost;\n+  float _M_vector_cost;\n+  bool  _M_valid;\n+};\n+\n+inline __vector2list_info::__vector2list_info(const __vector2list_info& __o)\n+    : __object_info_base(__o)\n+{\n+  _M_shift_count  = __o._M_shift_count;\n+  _M_iterate      = __o._M_iterate;\n+  _M_vector_cost  = __o._M_vector_cost;\n+  _M_list_cost    = __o._M_list_cost;\n+  _M_valid        = __o._M_valid;\n+  _M_resize       = __o._M_resize;\n+}\n+\n+inline void __vector2list_info::__merge(const __vector2list_info& __o)\n+{\n+  _M_shift_count  += __o._M_shift_count;\n+  _M_iterate      += __o._M_iterate;\n+  _M_vector_cost  += __o._M_vector_cost;\n+  _M_list_cost    += __o._M_list_cost;\n+  _M_valid        &= __o._M_valid;\n+  _M_resize       += __o._M_resize;\n+}\n+\n+inline void __vector2list_info::__opr_insert(size_t __pos, size_t __num)\n+{\n+  _M_shift_count += __num - __pos;\n+}\n+\n+inline void __vector2list_info::__resize(size_t __from, size_t __to)\n+{\n+  _M_resize += __from;\n+}\n+\n+/** @brief A vector-to-list instrumentation line in the stack table.  */\n+class __vector2list_stack_info: public __vector2list_info {\n+ public:\n+  __vector2list_stack_info(const __vector2list_info& __o) \n+      : __vector2list_info(__o) {}\n+};\n+\n+/** @brief Vector-to-list instrumentation producer.  */\n+class __trace_vector_to_list\n+    : public __trace_base<__vector2list_info, __vector2list_stack_info> \n+{\n+ public:\n+  __trace_vector_to_list();\n+  ~__trace_vector_to_list() {}\n+\n+  // Insert a new node at construct with object, callstack and initial size. \n+  void __insert(__object_t __obj, __stack_t __stack);\n+  // Call at destruction/clean to set container final size.\n+  void __destruct(const void* __obj);\n+\n+  // Find the node in the live map.\n+  __vector2list_info* __find(const void* __obj);\n+\n+  // Collect cost of operations.\n+  void __opr_insert(const void* __obj, size_t __pos, size_t __num);\n+  void __opr_iterate(const void* __obj, size_t __num);\n+  void __invalid_operator(const void* __obj);\n+  void __resize(const void* __obj, size_t __from, size_t __to);\n+  float __vector_cost(size_t __shift, size_t __iterate, size_t __resize);\n+  float __list_cost(size_t __shift, size_t __iterate, size_t __resize);\n+};\n+\n+inline __trace_vector_to_list::__trace_vector_to_list()\n+    : __trace_base<__vector2list_info, __vector2list_stack_info>()\n+{\n+  __id = \"vector-to-list\";\n+}\n+\n+inline void __trace_vector_to_list::__insert(__object_t __obj,\n+                                             __stack_t __stack)\n+{\n+  __add_object(__obj, __vector2list_info(__stack));\n+}\n+\n+inline void __vector2list_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\",\n+          _M_shift_count, _M_resize, _M_iterate, _M_vector_cost, _M_list_cost);\n+}\n+\n+// Cost model.  XXX: get this from the cost model database instead.\n+//  Vector operation cost:\n+//   - Cost per shift: 1\n+//   - Cost per access: 1\n+//   - Cost per resize: 1\n+//  List operation cost:\n+//   - Cost per shift: 0\n+//   - Cost per access: 10\n+//   - Cost per resize: 0\n+\n+inline float __trace_vector_to_list::__vector_cost(size_t __shift, \n+                                                   size_t __iterate,\n+                                                   size_t __resize)\n+{\n+  return __shift * 1 + __iterate * 1 + __resize * 1; \n+}\n+\n+inline float __trace_vector_to_list::__list_cost(size_t __shift, \n+                                                 size_t __iterate,\n+                                                 size_t __resize)\n+{\n+  return __shift * 0 + __iterate * 10 + __resize * 0; \n+}\n+\n+inline void __trace_vector_to_list::__destruct(const void* __obj)\n+{\n+  if (!__is_on())\n+    return;\n+\n+ __vector2list_info* __res = __get_object_info(__obj);\n+  if (!__res)\n+    return;\n+\n+  float __vc = __vector_cost(__res->__shift_count(), __res->__iterate(),\n+                             __res->__resize());\n+  float __lc = __list_cost(__res->__shift_count(), __res->__iterate(),\n+                           __res->__resize());\n+  __res->__set_vector_cost(__vc);\n+  __res->__set_list_cost(__lc);\n+\n+  __retire_object(__obj);\n+}\n+\n+inline void __trace_vector_to_list::__opr_insert(const void* __obj, \n+                                                 size_t __pos, size_t __num)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__opr_insert(__pos, __num);\n+}\n+\n+inline void __trace_vector_to_list::__opr_iterate(const void* __obj,\n+                                                  size_t __num)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__opr_iterate(__num);\n+}\n+\n+inline void __trace_vector_to_list::__invalid_operator(const void* __obj)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__set_invalid();\n+}\n+\n+inline void __trace_vector_to_list::__resize(const void* __obj, size_t __from, \n+                                             size_t __to)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__resize(__from, __to);\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Initialization and report.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_vector_to_list_init()\n+{\n+  __tables<0>::_S_vector_to_list = new __trace_vector_to_list();\n+}\n+\n+inline void __trace_vector_to_list_report(FILE* __f, \n+                                          __warning_vector_t& __warnings)\n+{\n+  if (__tables<0>::_S_vector_to_list) {\n+    __tables<0>::_S_vector_to_list->__collect_warnings(__warnings);\n+    __tables<0>::_S_vector_to_list->__write(__f);\n+  }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+// Implementations of instrumentation hooks.\n+//////////////////////////////////////////////////////////////////////////////\n+\n+inline void __trace_vector_to_list_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_to_list->__insert(__obj, __get_stack());\n+}\n+\n+inline void __trace_vector_to_list_destruct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_to_list->__destruct(__obj);\n+}\n+\n+inline void __trace_vector_to_list_insert(const void* __obj, \n+                                          size_t __pos, size_t __num)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_to_list->__opr_insert(__obj, __pos, __num);\n+}\n+\n+\n+inline void __trace_vector_to_list_iterate(const void* __obj, size_t __num)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_to_list->__opr_iterate(__obj, __num);\n+}\n+\n+inline void __trace_vector_to_list_invalid_operator(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_to_list->__invalid_operator(__obj);\n+}\n+\n+inline void __trace_vector_to_list_resize(const void* __obj, \n+                                          size_t __from, size_t __to)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  __tables<0>::_S_vector_to_list->__resize(__obj, __from, __to);\n+}\n+\n+} // namespace __cxxprof_impl\n+#endif /* PROFCXX_PROFILER_VECTOR_TO_LIST_H__ */"}, {"sha": "061c50658263cb4c875b5fcfe244bd34eca8737d", "filename": "libstdc++-v3/include/profile/list", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,520 @@\n+// Profiling list implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/list\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_LIST\n+#define _GLIBCXX_PROFILE_LIST 1\n+\n+#include <list>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief List wrapper with performance instrumentation.  */\n+  template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n+    class list\n+    : public _GLIBCXX_STD_D::list<_Tp, _Allocator>\n+    {\n+      typedef _GLIBCXX_STD_D::list<_Tp, _Allocator> _Base;\n+\n+    public:\n+      typedef typename _Base::reference             reference;\n+      typedef typename _Base::const_reference       const_reference;\n+\n+      typedef typename _Base::iterator              iterator;\n+      typedef typename _Base::const_iterator        const_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+\n+      typedef _Tp\t\t\t\t    value_type;\n+      typedef _Allocator\t\t\t    allocator_type;\n+      typedef typename _Base::pointer               pointer;\n+      typedef typename _Base::const_pointer         const_pointer;\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+\n+      // 23.2.2.1 construct/copy/destroy:\n+      explicit list(const _Allocator& __a = _Allocator())\n+      : _Base(__a) { }\n+\n+      explicit list(size_type __n, const _Tp& __value = _Tp(),\n+\t\t    const _Allocator& __a = _Allocator())\n+      : _Base(__n, __value, __a) { }\n+\n+      template<class _InputIterator>\n+      list(_InputIterator __first, _InputIterator __last,\n+\t   const _Allocator& __a = _Allocator())\n+      : _Base(__first, __last, __a)\n+      { }\n+\n+\n+      list(const list& __x)\n+      : _Base(__x) { }\n+\n+      list(const _Base& __x)\n+      : _Base(__x) { }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      list(list&& __x)\n+      : _Base(std::forward<list>(__x))\n+      { }\n+\n+      list(initializer_list<value_type> __l,\n+           const allocator_type& __a = allocator_type())\n+        : _Base(__l, __a) { }\n+#endif\n+\n+      ~list() { }\n+\n+      list&\n+      operator=(const list& __x)\n+      {\n+\tstatic_cast<_Base&>(*this) = __x;\n+\treturn *this;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      list&\n+      operator=(list&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      list&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tstatic_cast<_Base&>(*this) = __l;\n+\treturn *this;\n+      }\n+\n+      void\n+      assign(initializer_list<value_type> __l)\n+      {\n+\t_Base::assign(__l);\n+      }\n+#endif\n+\n+      template<class _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  _Base::assign(__first, __last);\n+\t}\n+\n+      void\n+      assign(size_type __n, const _Tp& __t)\n+      {\n+\t_Base::assign(__n, __t);\n+      }\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin()); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end()); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end()); }\n+\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end()); }\n+\n+      const_reverse_iterator\n+      crbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      crend() const\n+      { return const_reverse_iterator(begin()); }\n+#endif\n+\n+      // 23.2.2.2 capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      void\n+      resize(size_type __sz, _Tp __c = _Tp())\n+      {\n+        _Base::resize(__sz, __c);\n+      }\n+\n+      // element access:\n+      reference\n+      front()\n+      {\n+\treturn _Base::front();\n+      }\n+\n+      const_reference\n+      front() const\n+      {\n+\treturn _Base::front();\n+      }\n+\n+      reference\n+      back()\n+      {\n+\treturn _Base::back();\n+      }\n+\n+      const_reference\n+      back() const\n+      {\n+\treturn _Base::back();\n+      }\n+\n+      // 23.2.2.3 modifiers:\n+      using _Base::push_front;\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      using _Base::emplace_front;\n+#endif\n+\n+      void\n+      pop_front()\n+      {\n+\titerator __victim = begin();\n+\t_Base::pop_front();\n+      }\n+\n+      using _Base::push_back;\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      using _Base::emplace_back;\n+#endif\n+\n+      void\n+      pop_back()\n+      {\n+\titerator __victim = end();\n+\t--__victim;\n+\t_Base::pop_back();\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+        iterator\n+        emplace(iterator __position, _Args&&... __args)\n+\t{\n+\t  return iterator(_Base::emplace(__position,\n+\t\t\t\t\tstd::forward<_Args>(__args)...));\n+\t}\n+#endif\n+\n+      iterator\n+      insert(iterator __position, const _Tp& __x)\n+      {\n+\treturn iterator(_Base::insert(__position, __x));\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(iterator __position, _Tp&& __x)\n+      { return emplace(__position, std::move(__x)); }\n+\n+      void\n+      insert(iterator __p, initializer_list<value_type> __l)\n+      {\n+\t_Base::insert(__p, __l);\n+      }\n+#endif\n+\n+      void\n+      insert(iterator __position, size_type __n, const _Tp& __x)\n+      {\n+\t_Base::insert(__position, __n, __x);\n+      }\n+\n+      template<class _InputIterator>\n+        void\n+        insert(iterator __position, _InputIterator __first,\n+\t       _InputIterator __last)\n+        {\n+\t  _Base::insert(__position, __first, __last);\n+\t}\n+\n+      iterator\n+      erase(iterator __position)\n+      {\n+\treturn iterator(_Base::erase(__position));\n+      }\n+\n+      iterator\n+      erase(iterator __position, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\treturn iterator(_Base::erase(__position, __last));\n+      }\n+\n+      void\n+      swap(list& __x)\n+      {\n+\t_Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      {\n+\t_Base::clear();\n+      }\n+\n+      // 23.2.2.4 list operations:\n+      void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      splice(iterator __position, list&& __x)\n+#else\n+      splice(iterator __position, list& __x)\n+#endif\n+      {\n+\tthis->splice(__position, _GLIBCXX_MOVE(__x), __x.begin(), __x.end());\n+      }\n+\n+      void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      splice(iterator __position, list&& __x, iterator __i)\n+#else\n+      splice(iterator __position, list& __x, iterator __i)\n+#endif\n+      {\n+\t// We used to perform the splice_alloc check:  not anymore, redundant\n+\t// after implementing the relevant bits of N1599.\n+\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t_Base::splice(__position, _GLIBCXX_MOVE(__x._M_base()),\n+\t\t      __i);\n+      }\n+\n+      void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      splice(iterator __position, list&& __x, iterator __first,\n+\t     iterator __last)\n+#else\n+      splice(iterator __position, list& __x, iterator __first,\n+\t     iterator __last)\n+#endif\n+      {\n+\t// We used to perform the splice_alloc check:  not anymore, redundant\n+\t// after implementing the relevant bits of N1599.\n+\n+\t_Base::splice(__position, _GLIBCXX_MOVE(__x._M_base()),\n+\t\t      __first, __last);\n+      }\n+\n+      void\n+      remove(const _Tp& __value)\n+      {\n+\tfor (iterator __x = begin(); __x != _Base::end(); )\n+\t  {\n+\t    if (*__x == __value)\n+\t      __x = erase(__x);\n+\t    else\n+\t      ++__x;\n+\t  }\n+      }\n+\n+      template<class _Predicate>\n+        void\n+        remove_if(_Predicate __pred)\n+        {\n+\t  for (iterator __x = begin(); __x != _Base::end(); )\n+\t    {\n+\t      if (__pred(*__x))\n+\t\t__x = erase(__x);\n+\t      else\n+\t\t++__x;\n+\t    }\n+\t}\n+\n+      void\n+      unique()\n+      {\n+\titerator __first = begin();\n+\titerator __last = end();\n+\tif (__first == __last)\n+\t  return;\n+\titerator __next = __first;\n+\twhile (++__next != __last)\n+\t  {\n+\t    if (*__first == *__next)\n+\t      erase(__next);\n+\t    else\n+\t      __first = __next;\n+\t    __next = __first;\n+\t  }\n+      }\n+\n+      template<class _BinaryPredicate>\n+        void\n+        unique(_BinaryPredicate __binary_pred)\n+        {\n+\t  iterator __first = begin();\n+\t  iterator __last = end();\n+\t  if (__first == __last)\n+\t    return;\n+\t  iterator __next = __first;\n+\t  while (++__next != __last)\n+\t    {\n+\t      if (__binary_pred(*__first, *__next))\n+\t\terase(__next);\n+\t      else\n+\t\t__first = __next;\n+\t      __next = __first;\n+\t    }\n+\t}\n+\n+      void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      merge(list&& __x)\n+#else\n+      merge(list& __x)\n+#endif\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 300. list::merge() specification incomplete\n+\tif (this != &__x)\n+\t  {\n+\t    _Base::merge(_GLIBCXX_MOVE(__x._M_base()));\n+\t  }\n+      }\n+\n+      template<class _Compare>\n+        void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+        merge(list&& __x, _Compare __comp)\n+#else\n+        merge(list& __x, _Compare __comp)\n+#endif\n+        {\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 300. list::merge() specification incomplete\n+\t  if (this != &__x)\n+\t    {\n+\t      _Base::merge(_GLIBCXX_MOVE(__x._M_base()), __comp);\n+\t    }\n+\t}\n+\n+      void\n+      sort() { _Base::sort(); }\n+\n+      template<typename _StrictWeakOrdering>\n+        void\n+        sort(_StrictWeakOrdering __pred) { _Base::sort(__pred); }\n+\n+      using _Base::reverse;\n+\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const list<_Tp, _Alloc>& __lhs,\n+\t       const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const list<_Tp, _Alloc>& __lhs,\n+\t       const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const list<_Tp, _Alloc>& __lhs,\n+\t      const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const list<_Tp, _Alloc>& __lhs,\n+\t       const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const list<_Tp, _Alloc>& __lhs,\n+\t       const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const list<_Tp, _Alloc>& __lhs,\n+\t      const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(list<_Tp, _Alloc>& __lhs, list<_Tp, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "e396b852398d552c1be53d9df85183f93dbfc3f7", "filename": "libstdc++-v3/include/profile/map", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,41 @@\n+// Profiling map/multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file profile/map\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_MAP\n+#define _GLIBCXX_PROFILE_MAP 1\n+\n+#include <map>\n+#include <profile/map.h>\n+#include <profile/multimap.h>\n+\n+#endif"}, {"sha": "aa9e535a1e4fba3820c1cb989c8e81a05895a3b6", "filename": "libstdc++-v3/include/profile/map.h", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,489 @@\n+// Profiling map implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file profile/map.h\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_MAP_H\n+#define _GLIBCXX_PROFILE_MAP_H 1\n+\n+#include <utility>\n+#include <profile/base.h>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Map wrapper with performance instrumentation.  */\n+  template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n+    class map\n+    : public _GLIBCXX_STD_D::map<_Key, _Tp, _Compare, _Allocator>\n+    {\n+      typedef _GLIBCXX_STD_D::map<_Key, _Tp, _Compare, _Allocator> _Base;\n+\n+    public:\n+      // types:\n+      typedef _Key                                  key_type;\n+      typedef _Tp                                   mapped_type;\n+      typedef std::pair<const _Key, _Tp>            value_type;\n+      typedef _Compare                              key_compare;\n+      typedef _Allocator                            allocator_type;\n+      typedef typename _Base::reference             reference;\n+      typedef typename _Base::const_reference       const_reference;\n+\n+      typedef typename _Base::iterator       iterator;\n+      typedef typename _Base::const_iterator       const_iterator;\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Base::pointer               pointer;\n+      typedef typename _Base::const_pointer         const_pointer;\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+\n+      using _Base::value_compare;\n+\n+      // 23.3.1.1 construct/copy/destroy:\n+      explicit map(const _Compare& __comp = _Compare(),\n+\t\t   const _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) {\n+          __profcxx_map_to_unordered_map_construct(this);\n+      }\n+\n+      template<typename _InputIterator>\n+        map(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp = _Compare(),\n+\t    const _Allocator& __a = _Allocator())\n+\t: _Base(__first, __last, __comp, __a) {\n+          __profcxx_map_to_unordered_map_construct(this);\n+        }\n+\n+      map(const map& __x)\n+      : _Base(__x) {\n+          __profcxx_map_to_unordered_map_construct(this);\n+      }\n+\n+      map(const _Base& __x)\n+      : _Base(__x) {\n+          __profcxx_map_to_unordered_map_construct(this);\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      map(map&& __x)\n+      : _Base(std::forward<map>(__x))\n+      { }\n+\n+      map(initializer_list<value_type> __l,\n+\t  const _Compare& __c = _Compare(),\n+\t  const allocator_type& __a = allocator_type())\n+      : _Base(__l, __c, __a) { }\n+#endif\n+\n+      ~map() {\n+          __profcxx_map_to_unordered_map_destruct(this);\n+      }\n+\n+      map&\n+      operator=(const map& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      map&\n+      operator=(map&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      map&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+#endif\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 133. map missing get_allocator()\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator \n+      begin()\n+      { return _Base::begin(); }\n+\n+      const_iterator\n+      begin() const\n+      { return _Base::begin(); }\n+\n+      iterator\n+      end()\n+      { return _Base::end(); }\n+\n+      const_iterator\n+      end() const\n+      { return _Base::end(); }\n+\n+      reverse_iterator\n+      rbegin()\n+      { \n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return reverse_iterator(end()); \n+      }\n+\n+      const_reverse_iterator\n+      rbegin() const\n+      {\n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return const_reverse_iterator(end());\n+      }\n+\n+      reverse_iterator\n+      rend()\n+      {\n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return reverse_iterator(begin());\n+      }\n+\n+      const_reverse_iterator\n+      rend() const\n+      {\n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return const_reverse_iterator(begin());\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end()); }\n+\n+      const_reverse_iterator\n+      crbegin() const\n+      {\n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return const_reverse_iterator(end());\n+      }\n+\n+      const_reverse_iterator\n+      crend() const\n+      {\n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return const_reverse_iterator(begin());\n+      }\n+#endif\n+\n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      // 23.3.1.2 element access:\n+      mapped_type&\n+      operator[](const key_type& __k)\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+        return _Base::operator[](__k);\n+      }\n+\n+      mapped_type&\n+      at(const key_type& __k)\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+        return _Base::at(__k);\n+      }\n+\n+      const mapped_type&\n+      at(const key_type& __k) const\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+        return _Base::at(__k);\n+      }\n+\n+      // modifiers:\n+      std::pair<iterator, bool>\n+      insert(const value_type& __x)\n+      {\n+        __profcxx_map_to_unordered_map_insert(this, size(), 1);\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, bool> __res = _Base::insert(__x);\n+\treturn std::pair<iterator, bool>(iterator(__res.first),\n+\t\t\t\t\t __res.second);\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      insert(std::initializer_list<value_type> __list)\n+      { \n+        size_type size_before = size();\n+        _Base::insert(__list); \n+        __profcxx_map_to_unordered_map_insert(this, size_before, \n+                                                size() - size_before);\n+      }\n+#endif\n+\n+      iterator\n+      insert(iterator __position, const value_type& __x)\n+      {\n+        size_type size_before = size();\n+\treturn iterator(_Base::insert(__position, __x));\n+        __profcxx_map_to_unordered_map_insert(this, size_before, \n+                                                size() - size_before);\n+      }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+          size_type size_before = size();\n+\t  _Base::insert(__first, __last);\n+          __profcxx_map_to_unordered_map_insert(this, size_before, \n+                                                size() - size_before);\n+\t}\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      erase(iterator __position)\n+      {\n+\titerator __i = _Base::erase(__position);\n+        __profcxx_map_to_unordered_map_erase(this, size(), 1);\n+        return __i;\n+      }\n+#else\n+      void\n+      erase(iterator __position)\n+      {\n+\t_Base::erase(__position);\n+        __profcxx_map_to_unordered_map_erase(this, size(), 1);\n+      }\n+#endif\n+\n+      size_type\n+      erase(const key_type& __x)\n+      {\n+\titerator __victim = find(__x);\n+\tif (__victim == end())\n+\t  return 0;\n+\telse\n+\t{\n+\t  _Base::erase(__victim);\n+\t  return 1;\n+\t}\n+      }\n+\n+      void\n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\twhile (__first != __last)\n+\t  this->erase(__first++);\n+      }\n+\n+      void\n+\n+      swap(map& __x)\n+      {\n+\t_Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      { this->erase(begin(), end()); }\n+\n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+\n+      // 23.3.1.3 map operations:\n+      iterator\n+      find(const key_type& __x)\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+        return iterator(_Base::find(__x));\n+      }\n+\n+      const_iterator\n+      find(const key_type& __x) const\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+        return const_iterator(_Base::find(__x));\n+      }\n+\n+      size_type\n+      count(const key_type& __x) const\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+        return _Base::count(__x);\n+      }\n+\n+      iterator\n+      lower_bound(const key_type& __x)\n+      { \n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return iterator(_Base::lower_bound(__x)); \n+      }\n+\n+      const_iterator\n+      lower_bound(const key_type& __x) const\n+      { \n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return const_iterator(_Base::lower_bound(__x)); \n+      }\n+\n+      iterator\n+      upper_bound(const key_type& __x)\n+      { \n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return iterator(_Base::upper_bound(__x)); \n+      }\n+\n+      const_iterator\n+      upper_bound(const key_type& __x) const\n+      { \n+        __profcxx_map_to_unordered_map_invalidate(this);\n+        return const_iterator(_Base::upper_bound(__x)); \n+      }\n+\n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first),\n+\t\t\t      iterator(__res.second));\n+      }\n+\n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first),\n+\t\t\t      const_iterator(__res.second));\n+      }\n+\n+      _Base& \n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+    };\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator==(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { \n+      __profcxx_map_to_unordered_map_invalidate(&__lhs);\n+      __profcxx_map_to_unordered_map_invalidate(&__rhs);\n+      return __lhs._M_base() == __rhs._M_base(); \n+    }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { \n+      __profcxx_map_to_unordered_map_invalidate(&__lhs);\n+      __profcxx_map_to_unordered_map_invalidate(&__rhs);\n+      return __lhs._M_base() != __rhs._M_base(); \n+    }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t      const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    {\n+      __profcxx_map_to_unordered_map_invalidate(&__lhs);\n+      __profcxx_map_to_unordered_map_invalidate(&__rhs);\n+      return __lhs._M_base() < __rhs._M_base(); \n+    }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    {\n+      __profcxx_map_to_unordered_map_invalidate(&__lhs);\n+      __profcxx_map_to_unordered_map_invalidate(&__rhs);\n+      return __lhs._M_base() <= __rhs._M_base();\n+    }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    {\n+      __profcxx_map_to_unordered_map_invalidate(&__lhs);\n+      __profcxx_map_to_unordered_map_invalidate(&__rhs);\n+      return __lhs._M_base() >= __rhs._M_base();\n+    }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t      const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    {\n+      __profcxx_map_to_unordered_map_invalidate(&__lhs);\n+      __profcxx_map_to_unordered_map_invalidate(&__rhs);\n+      return __lhs._M_base() > __rhs._M_base();\n+    }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline void\n+    swap(map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "b1fc70b63b2fbcd12da7539f64f54a7b2dc47644", "filename": "libstdc++-v3/include/profile/multimap.h", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,363 @@\n+// Profiling multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/multimap.h\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_MULTIMAP_H\n+#define _GLIBCXX_PROFILE_MULTIMAP_H 1\n+\n+#include <utility>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Multimap wrapper with performance instrumentation.  */\n+  template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n+    class multimap\n+    : public _GLIBCXX_STD_D::multimap<_Key, _Tp, _Compare, _Allocator>\n+    {\n+      typedef _GLIBCXX_STD_D::multimap<_Key, _Tp, _Compare, _Allocator> _Base;\n+\n+    public:\n+      // types:\n+      typedef _Key\t\t\t\t     key_type;\n+      typedef _Tp\t\t\t\t     mapped_type;\n+      typedef std::pair<const _Key, _Tp>             value_type;\n+      typedef _Compare                               key_compare;\n+      typedef _Allocator                             allocator_type;\n+      typedef typename _Base::reference              reference;\n+      typedef typename _Base::const_reference        const_reference;\n+\n+      typedef typename _Base::iterator               iterator;\n+      typedef typename _Base::const_iterator         const_iterator;\n+      typedef typename _Base::reverse_iterator       reverse_iterator;\n+      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n+\n+      typedef typename _Base::size_type              size_type;\n+      typedef typename _Base::difference_type        difference_type;\n+      typedef typename _Base::pointer                pointer;\n+      typedef typename _Base::const_pointer          const_pointer;\n+\n+      using _Base::value_compare;\n+\n+      // 23.3.1.1 construct/copy/destroy:\n+      explicit multimap(const _Compare& __comp = _Compare(),\n+\t\t\tconst _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+      multimap(_InputIterator __first, _InputIterator __last,\n+\t       const _Compare& __comp = _Compare(),\n+\t       const _Allocator& __a = _Allocator())\n+      : _Base(__first, __last, __comp, __a) { }\n+\n+      multimap(const multimap& __x)\n+      : _Base(__x) { }\n+\n+      multimap(const _Base& __x)\n+      : _Base(__x) { }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      multimap(multimap&& __x)\n+      : _Base(std::forward<multimap>(__x))\n+      { }\n+\n+      multimap(initializer_list<value_type> __l,\n+\t       const _Compare& __c = _Compare(),\n+\t       const allocator_type& __a = allocator_type())\n+      : _Base(__l, __c, __a) { }\n+#endif\n+\n+      ~multimap() { }\n+\n+      multimap&\n+      operator=(const multimap& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      multimap&\n+      operator=(multimap&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      multimap&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+#endif\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin()); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end()); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end()); }\n+\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end()); }\n+\n+      const_reverse_iterator\n+      crbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      crend() const\n+      { return const_reverse_iterator(begin()); }\n+#endif\n+\n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      // modifiers:\n+      iterator\n+      insert(const value_type& __x)\n+      { return iterator(_Base::insert(__x)); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      insert(std::initializer_list<value_type> __list)\n+      { _Base::insert(__list); }\n+#endif\n+\n+      iterator\n+      insert(iterator __position, const value_type& __x)\n+      {\n+\treturn iterator(_Base::insert(__position, __x));\n+      }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  _Base::insert(__first, __last);\n+\t}\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      erase(iterator __position)\n+      {\n+        return _Base::erase(__position);\n+      }\n+#else\n+      void\n+      erase(iterator __position)\n+      {\n+\t_Base::erase(__position);\n+      }\n+#endif\n+\n+      size_type\n+      erase(const key_type& __x)\n+      {\n+\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n+\tsize_type __count = 0;\n+\twhile (__victims.first != __victims.second)\n+\t{\n+\t  iterator __victim = __victims.first++;\n+\t  _Base::erase(__victim);\n+\t  ++__count;\n+\t}\n+\treturn __count;\n+      }\n+\n+      void\n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\twhile (__first != __last)\n+\tthis->erase(__first++);\n+      }\n+\n+      void\n+      swap(multimap& __x)\n+      {\n+\t_Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      { this->erase(begin(), end()); }\n+\n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+\n+      // 23.3.1.3 multimap operations:\n+      iterator\n+      find(const key_type& __x)\n+      { return iterator(_Base::find(__x)); }\n+\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return const_iterator(_Base::find(__x)); }\n+\n+      using _Base::count;\n+\n+      iterator\n+      lower_bound(const key_type& __x)\n+      { return iterator(_Base::lower_bound(__x)); }\n+\n+      const_iterator\n+      lower_bound(const key_type& __x) const\n+      { return const_iterator(_Base::lower_bound(__x)); }\n+\n+      iterator\n+      upper_bound(const key_type& __x)\n+      { return iterator(_Base::upper_bound(__x)); }\n+\n+      const_iterator\n+      upper_bound(const key_type& __x) const\n+      { return const_iterator(_Base::upper_bound(__x)); }\n+\n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first),\n+\t\t\t      iterator(__res.second));\n+      }\n+\n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first),\n+\t\t\t      const_iterator(__res.second));\n+      }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+    };\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<(const multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t      const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t       const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>(const multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t      const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Compare, typename _Allocator>\n+    inline void\n+    swap(multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n+\t multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "759761bd52cc6102b2f63572392d63158ae43a17", "filename": "libstdc++-v3/include/profile/multiset.h", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,363 @@\n+// Profiling multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/multiset.h\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_MULTISET_H\n+#define _GLIBCXX_PROFILE_MULTISET_H 1\n+\n+#include <utility>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Multiset wrapper with performance instrumentation.  */\n+  template<typename _Key, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<_Key> >\n+    class multiset\n+    : public _GLIBCXX_STD_D::multiset<_Key, _Compare, _Allocator>\n+    {\n+      typedef _GLIBCXX_STD_D::multiset<_Key, _Compare, _Allocator> _Base;\n+\n+    public:\n+      // types:\n+      typedef _Key\t\t\t\t     key_type;\n+      typedef _Key\t\t\t\t     value_type;\n+      typedef _Compare\t\t\t\t     key_compare;\n+      typedef _Compare\t\t\t\t     value_compare;\n+      typedef _Allocator\t\t\t     allocator_type;\n+      typedef typename _Base::reference\t             reference;\n+      typedef typename _Base::const_reference        const_reference;\n+\n+      typedef typename _Base::iterator               iterator;\n+      typedef typename _Base::const_iterator         const_iterator;\n+      typedef typename _Base::reverse_iterator       reverse_iterator;\n+      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n+\n+      typedef typename _Base::size_type              size_type;\n+      typedef typename _Base::difference_type        difference_type;\n+      typedef typename _Base::pointer                pointer;\n+      typedef typename _Base::const_pointer          const_pointer;\n+\n+      // 23.3.3.1 construct/copy/destroy:\n+      explicit multiset(const _Compare& __comp = _Compare(),\n+\t\t\tconst _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+        multiset(_InputIterator __first, _InputIterator __last,\n+\t\t const _Compare& __comp = _Compare(),\n+\t\t const _Allocator& __a = _Allocator())\n+\t: _Base(__first, __last, __comp, __a) { }\n+\n+      multiset(const multiset& __x)\n+      : _Base(__x) { }\n+\n+      multiset(const _Base& __x)\n+      : _Base(__x) { }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      multiset(multiset&& __x)\n+      : _Base(std::forward<multiset>(__x))\n+      { }\n+\n+      multiset(initializer_list<value_type> __l,\n+\t       const _Compare& __comp = _Compare(),\n+\t       const allocator_type& __a = allocator_type())\n+      : _Base(__l, __comp, __a) { }\n+#endif\n+\n+      ~multiset() { }\n+\n+      multiset&\n+      operator=(const multiset& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      multiset&\n+      operator=(multiset&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      multiset&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+#endif\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin()); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end()); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end()); }\n+\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end()); }\n+\n+      const_reverse_iterator\n+      crbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      crend() const\n+      { return const_reverse_iterator(begin()); }\n+#endif\n+\n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      // modifiers:\n+      iterator\n+      insert(const value_type& __x)\n+      { return iterator(_Base::insert(__x)); }\n+\n+      iterator\n+      insert(iterator __position, const value_type& __x)\n+      {\n+\treturn iterator(_Base::insert(__position, __x));\n+      }\n+\n+      template<typename _InputIterator>\n+      void\n+      insert(_InputIterator __first, _InputIterator __last)\n+      {\n+\t_Base::insert(__first, __last);\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { _Base::insert(__l); }\n+#endif\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      erase(iterator __position)\n+      {\n+        return _Base::erase(__position);\n+      }\n+#else\n+      void\n+      erase(iterator __position)\n+      {\n+\t_Base::erase(__position);\n+      }\n+#endif\n+\n+      size_type\n+      erase(const key_type& __x)\n+      {\n+\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n+\tsize_type __count = 0;\n+\twhile (__victims.first != __victims.second)\n+\t{\n+\t  iterator __victim = __victims.first++;\n+\t  _Base::erase(__victim);\n+\t  ++__count;\n+\t}\n+\treturn __count;\n+      }\n+\n+      void\n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\twhile (__first != __last)\n+\tthis->erase(__first++);\n+      }\n+\n+      void\n+      swap(multiset& __x)\n+      {\n+\t_Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      { this->erase(begin(), end()); }\n+\n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+\n+      // multiset operations:\n+      iterator\n+      find(const key_type& __x)\n+      { return iterator(_Base::find(__x)); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return const_iterator(_Base::find(__x)); }\n+\n+      using _Base::count;\n+\n+      iterator\n+      lower_bound(const key_type& __x)\n+      { return iterator(_Base::lower_bound(__x)); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator\n+      lower_bound(const key_type& __x) const\n+      { return const_iterator(_Base::lower_bound(__x)); }\n+\n+      iterator\n+      upper_bound(const key_type& __x)\n+      { return iterator(_Base::upper_bound(__x)); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator\n+      upper_bound(const key_type& __x) const\n+      { return const_iterator(_Base::upper_bound(__x)); }\n+\n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first),\n+\t\t\t      iterator(__res.second));\n+      }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first),\n+\t\t\t      const_iterator(__res.second));\n+      }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+    };\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator==(const multiset<_Key, _Compare, _Allocator>& __lhs,\n+\t       const multiset<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator!=(const multiset<_Key, _Compare, _Allocator>& __lhs,\n+\t       const multiset<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<(const multiset<_Key, _Compare, _Allocator>& __lhs,\n+\t      const multiset<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<=(const multiset<_Key, _Compare, _Allocator>& __lhs,\n+\t       const multiset<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>=(const multiset<_Key, _Compare, _Allocator>& __lhs,\n+\t       const multiset<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>(const multiset<_Key, _Compare, _Allocator>& __lhs,\n+\t      const multiset<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    void\n+    swap(multiset<_Key, _Compare, _Allocator>& __x,\n+\t multiset<_Key, _Compare, _Allocator>& __y)\n+    { return __x.swap(__y); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "11603a848588f209c2c718966c3048dbbca8ae93", "filename": "libstdc++-v3/include/profile/set", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,41 @@\n+// Profiling set/multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file profile/set\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_SET\n+#define _GLIBCXX_PROFILE_SET 1\n+\n+#include <set>\n+#include <profile/set.h>\n+#include <profile/multiset.h>\n+\n+#endif"}, {"sha": "50fb16faf37e1d3eb176028748f7b9767d43e668", "filename": "libstdc++-v3/include/profile/set.h", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,367 @@\n+// Profiling set implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/set.h\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_SET_H\n+#define _GLIBCXX_PROFILE_SET_H 1\n+\n+#include <utility>\n+\n+namespace std \n+{\n+namespace __profile\n+{\n+  /** @brief Set wrapper with performance instrumentation.  */\n+  template<typename _Key, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<_Key> >\n+    class set\n+    : public _GLIBCXX_STD_D::set<_Key,_Compare,_Allocator>\n+    {\n+      typedef _GLIBCXX_STD_D::set<_Key, _Compare, _Allocator> _Base;\n+\n+    public:\n+      // types:\n+      typedef _Key\t\t\t\t    key_type;\n+      typedef _Key\t\t\t\t    value_type;\n+      typedef _Compare\t\t\t\t    key_compare;\n+      typedef _Compare\t\t\t\t    value_compare;\n+      typedef _Allocator\t\t\t    allocator_type;\n+      typedef typename _Base::reference             reference;\n+      typedef typename _Base::const_reference       const_reference;\n+\n+      typedef typename _Base::iterator               iterator;\n+      typedef typename _Base::const_iterator         const_iterator;\n+      typedef typename _Base::reverse_iterator       reverse_iterator;\n+      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Base::pointer               pointer;\n+      typedef typename _Base::const_pointer         const_pointer;\n+\n+      // 23.3.3.1 construct/copy/destroy:\n+      explicit set(const _Compare& __comp = _Compare(),\n+\t\t   const _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+        set(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp = _Compare(),\n+\t    const _Allocator& __a = _Allocator())\n+\t: _Base(__first, __last, __comp, __a) { }\n+\n+      set(const set& __x)\n+      : _Base(__x) { }\n+\n+      set(const _Base& __x)\n+      : _Base(__x) { }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      set(set&& __x)\n+      : _Base(std::forward<set>(__x))\n+      { }\n+\n+      set(initializer_list<value_type> __l,\n+\t  const _Compare& __comp = _Compare(),\n+\t  const allocator_type& __a = allocator_type())\n+      : _Base(__l, __comp, __a) { }\n+#endif\n+\n+      ~set() { }\n+\n+      set&\n+      operator=(const set& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      set&\n+      operator=(set&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      set&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+#endif\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin()); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end()); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end()); }\n+\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin()); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end()); }\n+\n+      const_reverse_iterator\n+      crbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      crend() const\n+      { return const_reverse_iterator(begin()); }\n+#endif\n+\n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      // modifiers:\n+      std::pair<iterator, bool>\n+      insert(const value_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, bool> __res = _Base::insert(__x);\n+\treturn std::pair<iterator, bool>(iterator(__res.first),\n+\t\t\t\t\t __res.second);\n+      }\n+\n+      iterator\n+      insert(iterator __position, const value_type& __x)\n+      {\n+\treturn iterator(_Base::insert(__position, __x));\n+      }\n+\n+      template <typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  _Base::insert(__first, __last);\n+\t}\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { _Base::insert(__l); }\n+#endif\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      erase(iterator __position)\n+      {\n+        return _Base::erase(__position);\n+      }\n+#else\n+      void\n+      erase(iterator __position)\n+      {\n+\t_Base::erase(__position);\n+      }\n+#endif\n+\n+      size_type\n+      erase(const key_type& __x)\n+      {\n+\titerator __victim = find(__x);\n+\tif (__victim == end())\n+          return 0;\n+\telse\n+        {\n+\t  _Base::erase(__victim);\n+\t  return 1;\n+        }\n+      }\n+\n+      void\n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\twhile (__first != __last)\n+        this->erase(__first++);\n+      }\n+\n+      void\n+      swap(set& __x)\n+      {\n+\t_Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      { this->erase(begin(), end()); }\n+\n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+\n+      // set operations:\n+      iterator\n+      find(const key_type& __x)\n+      { return iterator(_Base::find(__x)); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return const_iterator(_Base::find(__x)); }\n+\n+      using _Base::count;\n+\n+      iterator\n+      lower_bound(const key_type& __x)\n+      { return iterator(_Base::lower_bound(__x)); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator\n+      lower_bound(const key_type& __x) const\n+      { return const_iterator(_Base::lower_bound(__x)); }\n+\n+      iterator\n+      upper_bound(const key_type& __x)\n+      { return iterator(_Base::upper_bound(__x)); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator\n+      upper_bound(const key_type& __x) const\n+      { return const_iterator(_Base::upper_bound(__x)); }\n+\n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first),\n+\t\t\t      iterator(__res.second));\n+      }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first),\n+\t\t\t      const_iterator(__res.second));\n+      }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+    };\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator==(const set<_Key, _Compare, _Allocator>& __lhs,\n+\t       const set<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator!=(const set<_Key, _Compare, _Allocator>& __lhs,\n+\t       const set<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<(const set<_Key, _Compare, _Allocator>& __lhs,\n+\t      const set<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator<=(const set<_Key, _Compare, _Allocator>& __lhs,\n+\t       const set<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>=(const set<_Key, _Compare, _Allocator>& __lhs,\n+\t       const set<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool\n+    operator>(const set<_Key, _Compare, _Allocator>& __lhs,\n+\t      const set<_Key, _Compare, _Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    void\n+    swap(set<_Key, _Compare, _Allocator>& __x,\n+\t set<_Key, _Compare, _Allocator>& __y)\n+    { return __x.swap(__y); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "d1cb9217d23eacce9df30dc3b562e99e575ae2ef", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,498 @@\n+// Profiling unordered_map/unordered_multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file profile/unordered_map\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_UNORDERED_MAP\n+#define _GLIBCXX_PROFILE_UNORDERED_MAP 1\n+\n+#include <profile/base.h>\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+# include <unordered_map>\n+#else\n+# include <c++0x_warning.h>\n+#endif\n+\n+#include <initializer_list>\n+\n+#define _GLIBCXX_BASE unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_PR::_GLIBCXX_BASE\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Unordered_map wrapper with performance instrumentation.  */\n+  template<typename _Key, typename _Tp,\n+\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Pred = std::equal_to<_Key>,\n+\t   typename _Alloc =  std::allocator<_Key> >\n+    class unordered_map\n+    : public _GLIBCXX_STD_BASE\n+    {\n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::difference_type difference_type;\n+      typedef typename _Base::reference       reference;\n+      typedef typename _Base::const_reference const_reference;\n+      typedef typename _Base::mapped_type      mapped_type;\n+      typedef std::pair<typename _Base::iterator, bool> pair_type;\n+      typedef typename _Base::insert_return_type insert_return_type;\n+\n+      typedef typename _Base::iterator iterator;\n+      typedef typename _Base::const_iterator const_iterator;\n+\n+      explicit\n+      unordered_map(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      template<typename _InputIterator>\n+        unordered_map(_InputIterator __f, _InputIterator __l,\n+              size_type __n = 10,\n+              const hasher& __hf = hasher(),\n+              const key_equal& __eql = key_equal(),\n+              const allocator_type& __a = allocator_type())\n+      : _Base(__f, __l, __n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      unordered_map(const _Base& __x)\n+      : _Base(__x) \n+      { \n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      unordered_map(unordered_map&& __x)\n+      : _Base(std::forward<_Base>(__x)) \n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      unordered_map(initializer_list<value_type> __l,\n+\t\t    size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__l, __n, __hf, __eql, __a) { }\n+\n+      unordered_map&\n+      operator=(const unordered_map& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+      unordered_map&\n+      operator=(unordered_map&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      unordered_map&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+\n+      ~unordered_map()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), _Base::size());\n+        _M_profile_destruct();\n+      }\n+\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+\n+      void\n+      clear()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), _Base::size());\n+        _M_profile_destruct();\n+        _Base::clear();\n+      }\n+\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__l);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+      }\n+\n+       insert_return_type\n+      insert(const value_type& __obj)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        insert_return_type __res = _Base::insert(__obj);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return __res;\n+      }\n+      iterator\n+      insert(iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        iterator res = _Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      const_iterator\n+      insert(const_iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        const_iterator res =_Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      template<typename _InputIter>\n+      void\n+      insert(_InputIter __first, _InputIter __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first.base(), __last.base());\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+      }\n+\n+      void\n+      insert(const value_type* __first, const value_type* __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first, __last);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+      }\n+     \n+      // operator []\n+      mapped_type&\n+      operator[](const _Key& _k)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        mapped_type& __res = _M_base()[_k];\n+        size_type __new_size =  _Base::bucket_count();\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return __res;\n+      }   \n+\n+      void\n+      swap(unordered_map& __x)\n+      {\n+        _Base::swap(__x);\n+      }\n+      \n+      void rehash(size_type __n)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        _Base::rehash(__n);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+      }\n+    private:\n+      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      {\n+        if (__old_size != __new_size)\n+        {\n+          __profcxx_hashtable_resize(this, __old_size, __new_size);\n+        }\n+      }\n+      void _M_profile_destruct()\n+      {\n+        size_type __hops = 0, __lc = 0, __chain = 0;\n+        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n+        {\n+          while (it._M_cur_node->_M_next) {\n+             __chain++;\n+             it++;\n+          }\n+          if (__chain) {\n+            __chain++;\n+            __lc = __lc > __chain ? __lc : __chain;  \n+            __hops += __chain * (__chain - 1) / 2;\n+            __chain = 0;\n+          }\n+        }\n+        __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops); \n+      }\n+   };\n+  template<typename _Key, typename _Tp, typename _Hash,\n+       typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+#define _GLIBCXX_BASE unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_PR::_GLIBCXX_BASE\n+\n+  /** @brief Unordered_multimap wrapper with performance instrumentation.  */\n+  template<typename _Key, typename _Tp,\n+\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Pred = std::equal_to<_Key>,\n+\t   typename _Alloc =  std::allocator<_Key> >\n+    class unordered_multimap\n+    : public _GLIBCXX_STD_BASE\n+    {      \n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::difference_type difference_type;\n+      typedef typename _Base::reference       reference;\n+      typedef typename _Base::const_reference const_reference;\n+      typedef std::pair<typename _Base::iterator, bool> pair_type;\n+      typedef typename _Base::insert_return_type insert_return_type;\n+\n+      typedef typename _Base::iterator iterator;\n+      typedef typename _Base::const_iterator const_iterator;\n+\n+      explicit\n+      unordered_multimap(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+      template<typename _InputIterator>\n+        unordered_multimap(_InputIterator __f, _InputIterator __l,\n+              size_type __n = 10,\n+              const hasher& __hf = hasher(),\n+              const key_equal& __eql = key_equal(),\n+              const allocator_type& __a = allocator_type())\n+      : _Base(__f, __l, __n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+\n+      unordered_multimap(const _Base& __x)\n+      : _Base(__x)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+\n+      unordered_multimap(unordered_multimap&& __x)\n+      : _Base(std::forward<_Base>(__x))\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+\n+      unordered_multimap(initializer_list<value_type> __l,\n+\t\t\t size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__l, __n, __hf, __eql, __a) { }\n+\n+      unordered_multimap&\n+      operator=(const unordered_multimap& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+      unordered_multimap&\n+      operator=(unordered_multimap&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      unordered_multimap&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+\n+      ~unordered_multimap()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), _Base::size());\n+        _M_profile_destruct();\n+      }\n+\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+\n+      void\n+      clear()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), _Base::size());\n+        _M_profile_destruct();\n+        _Base::clear();\n+      }\n+\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { \n+        size_type __old_size =  _Base::bucket_count();\n+        _Base::insert(__l);\n+        _M_profile_resize(__old_size, _Base::bucket_count());\n+      }\n+\n+      insert_return_type\n+      insert(const value_type& __obj)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        insert_return_type __res = _Base::insert(__obj);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return __res;\n+      }\n+      iterator\n+      insert(iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        iterator res = _Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      const_iterator\n+      insert(const_iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        const_iterator res =_Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      template<typename _InputIter>\n+      void\n+      insert(_InputIter __first, _InputIter __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first.base(), __last.base());\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+      }\n+\n+      void\n+      insert(const value_type* __first, const value_type* __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first, __last);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+      }\n+\n+      void\n+      swap(unordered_multimap& __x)\n+      {\n+        _Base::swap(__x);\n+      }\n+\n+      void rehash(size_type __n)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        _Base::rehash(__n);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+      }\n+    private:\n+      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      {\n+        if (__old_size != __new_size)\n+        {\n+          __profcxx_hashtable_resize(this, __old_size, __new_size);\n+        }\n+      }\n+\n+      void _M_profile_destruct()\n+      {\n+        size_type __hops = 0, __lc = 0, __chain = 0;\n+        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n+        {\n+          while (it._M_cur_node->_M_next) {\n+             __chain++;\n+             it++;\n+          }\n+          if (__chain) {\n+            __chain++;\n+            __lc = __lc > __chain ? __lc : __chain;\n+            __hops += __chain * (__chain - 1) / 2;\n+            __chain = 0;\n+          }\n+        }\n+        __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops);\n+      }\n+\n+    };\n+  template<typename _Key, typename _Tp, typename _Hash,\n+       typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+\n+#endif"}, {"sha": "6c2dd77cb5fea1175c704690b7750b7cff1ae2e0", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,480 @@\n+// Profiling unordered_set/unordered_multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file profile/unordered_set\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_UNORDERED_SET\n+#define _GLIBCXX_PROFILE_UNORDERED_SET 1\n+\n+#include <profile/base.h>\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+# include <unordered_set>\n+#else\n+# include <c++0x_warning.h>\n+#endif\n+\n+#include <initializer_list>\n+\n+#define _GLIBCXX_BASE unordered_set<_Key, _Hash, _Pred, _Alloc>\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_PR::_GLIBCXX_BASE\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Unordered_set wrapper with performance instrumentation.  */\n+  template<typename _Key, \n+\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Pred = std::equal_to<_Key>,\n+\t   typename _Alloc =  std::allocator<_Key> >\n+    class unordered_set\n+    : public _GLIBCXX_STD_BASE\n+    {\n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::difference_type difference_type;\n+      typedef typename _Base::reference       reference;\n+      typedef typename _Base::const_reference const_reference;\n+      typedef typename _Base::insert_return_type insert_return_type;\n+\n+      typedef typename _Base::iterator iterator;\n+      typedef typename _Base::const_iterator const_iterator;\n+\n+      explicit\n+      unordered_set(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      template<typename _InputIterator>\n+        unordered_set(_InputIterator __f, _InputIterator __l,\n+              size_type __n = 10,\n+              const hasher& __hf = hasher(),\n+              const key_equal& __eql = key_equal(),\n+              const allocator_type& __a = allocator_type())\n+      : _Base(__f, __l, __n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      unordered_set(const _Base& __x)\n+      : _Base(__x) \n+      { \n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      unordered_set(unordered_set&& __x)\n+      : _Base(std::forward<_Base>(__x)) \n+      { \n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+        __profcxx_hashtable_construct2(this);\n+      }\n+\n+      unordered_set(initializer_list<value_type> __l,\n+\t\t    size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__l, __n, __hf, __eql, __a) { }\n+\n+      unordered_set&\n+      operator=(const unordered_set& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+      unordered_set&\n+      operator=(unordered_set&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      unordered_set&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+\n+      ~unordered_set()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n+                                     _Base::size());\n+        _M_profile_destruct();\n+      }\n+\n+      void\n+      swap(unordered_set& __x)\n+      {\n+        _Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n+                                     _Base::size());\n+        _M_profile_destruct();\n+        _Base::clear();\n+      }\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { \n+        size_type __old_size =  _Base::bucket_count();\n+        _Base::insert(__l); \n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+      insert_return_type insert(const value_type& __obj)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        insert_return_type __res = _Base::insert(__obj);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return __res;\n+      }\n+      iterator\n+      insert(iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        iterator res = _Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      const_iterator\n+      insert(const_iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        const_iterator res =_Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      template<typename _InputIter>\n+      void\n+      insert(_InputIter __first, _InputIter __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first, __last);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+\n+      void\n+      insert(const value_type* __first, const value_type* __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first, __last);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+     \n+      void rehash(size_type __n)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        _Base::rehash(__n);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+    private:\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      {\n+        if (__old_size != __new_size)\n+        {\n+          __profcxx_hashtable_resize(this, __old_size, __new_size);\n+        }\n+      }\n+      void _M_profile_destruct()\n+      {\n+        size_type __hops = 0, __lc = 0, __chain = 0;\n+        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n+        {\n+          while (it._M_cur_node->_M_next) {\n+             __chain++;\n+             it++;\n+          }\n+          if (__chain) {\n+            __chain++;\n+            __lc = __lc > __chain ? __lc : __chain;\n+            __hops += __chain * (__chain - 1) / 2;\n+            __chain = 0;\n+          }\n+        }\n+        __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops);\n+      }\n+\n+   };\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+     unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_PR::_GLIBCXX_BASE\n+#define _GLIBCXX_BASE unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n+\n+  /** @brief Unordered_multiset wrapper with performance instrumentation.  */\n+  template<typename _Value,\n+       typename _Hash  = std::hash<_Value>,\n+       typename _Pred = std::equal_to<_Value>,\n+       typename _Alloc =  std::allocator<_Value> >\n+    class unordered_multiset\n+    : public _GLIBCXX_STD_BASE\n+    {\n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::difference_type difference_type;\n+      typedef typename _Base::reference       reference;\n+      typedef typename _Base::const_reference const_reference;\n+      typedef typename _Base::insert_return_type insert_return_type;\n+\n+      typedef typename _Base::iterator iterator;\n+      typedef typename _Base::const_iterator const_iterator;\n+\n+      explicit\n+      unordered_multiset(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+\n+      template<typename _InputIterator>\n+        unordered_multiset(_InputIterator __f, _InputIterator __l,\n+              size_type __n = 10,\n+              const hasher& __hf = hasher(),\n+              const key_equal& __eql = key_equal(),\n+              const allocator_type& __a = allocator_type())\n+      : _Base(__f, __l, __n, __hf, __eql, __a)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+\n+      unordered_multiset(const _Base& __x)\n+      : _Base(__x)\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+\n+      unordered_multiset(unordered_multiset&& __x)\n+      : _Base(std::forward<_Base>(__x))\n+      {\n+        __profcxx_hashtable_construct(this, _Base::bucket_count());\n+      }\n+\n+      unordered_multiset(initializer_list<value_type> __l,\n+\t\t\t size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__l, __n, __hf, __eql, __a) { }\n+\n+      unordered_multiset&\n+      operator=(const unordered_multiset& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\treturn *this;\n+      }\n+\n+      unordered_multiset&\n+      operator=(unordered_multiset&& __x)\n+      {\n+        // NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\n+      }\n+\n+      unordered_multiset&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l);\n+\treturn *this;\n+      }\n+\n+      ~unordered_multiset()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n+                                     _Base::size());\n+        _M_profile_destruct();\n+      }\n+\n+      void\n+      swap(unordered_multiset& __x)\n+      {\n+        _Base::swap(__x);\n+      }\n+\n+      void\n+      clear()\n+      {\n+        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n+                                     _Base::size());\n+        _M_profile_destruct();\n+        _Base::clear();\n+      }\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { \n+        size_type __old_size =  _Base::bucket_count();\n+        _Base::insert(__l); \n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+      insert_return_type insert(const value_type& __obj)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        insert_return_type __res = _Base::insert(__obj);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return __res;\n+      }\n+      iterator\n+      insert(iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        iterator res = _Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      const_iterator\n+      insert(const_iterator __iter, const value_type& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count(); \n+        const_iterator res =_Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return res;\n+      }\n+\n+      template<typename _InputIter>\n+      void\n+      insert(_InputIter __first, _InputIter __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first, __last);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+\n+      void\n+      insert(const value_type* __first, const value_type* __last)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        _Base::insert(__first, __last);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+     \n+      void rehash(size_type __n)\n+      {\n+        size_type __old_size =  _Base::bucket_count();\n+        _Base::rehash(__n);\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+      }\n+    private:\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      {\n+        if (__old_size != __new_size)\n+        {\n+          __profcxx_hashtable_resize(this, __old_size, __new_size);\n+        }\n+      }\n+\n+      void _M_profile_destruct()\n+      {\n+        size_type __hops = 0, __lc = 0, __chain = 0;\n+        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n+        {\n+          while (it._M_cur_node->_M_next) {\n+             __chain++;\n+             it++;\n+          }\n+          if (__chain) {\n+            __chain++;\n+            __lc = __lc > __chain ? __lc : __chain;\n+            __hops += __chain * (__chain - 1) / 2;\n+            __chain = 0;\n+          }\n+        }\n+        __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops);\n+      }\n+\n+   };\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+     unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+\n+#endif"}, {"sha": "e6aeb686a7a155c62b7622c8a4228f39c0cde736", "filename": "libstdc++-v3/include/profile/vector", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,369 @@\n+// Profiling vector implementation -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file profile/vector\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_VECTOR\n+#define _GLIBCXX_PROFILE_VECTOR 1\n+\n+#include <vector>\n+#include <utility>\n+#include <profile/base.h>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+  /** @brief Vector wrapper with performance instrumentation.  */\n+  template<typename _Tp,\n+\t   typename _Allocator = std::allocator<_Tp> >\n+    class vector\n+    : public _GLIBCXX_STD_PR::vector<_Tp, _Allocator>\n+    {\n+      typedef _GLIBCXX_STD_PR::vector<_Tp, _Allocator> _Base;\n+\n+    public:\n+      typedef typename _Base::reference             reference;\n+      typedef typename _Base::const_reference       const_reference;\n+\n+      typedef typename _Base::iterator iterator;\n+      typedef typename _Base::const_iterator const_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+\n+      typedef _Tp\t\t\t\t                    value_type;\n+      typedef _Allocator\t\t\t                allocator_type;\n+      typedef typename _Base::pointer               pointer;\n+      typedef typename _Base::const_pointer         const_pointer;\n+\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+      // 23.2.4.1 construct/copy/destroy:\n+      explicit vector(const _Allocator& __a = _Allocator())\n+      : _Base(__a)\n+      { \n+        __profcxx_vector_construct(this, this->capacity());\n+        __profcxx_vector_construct2(this);\n+      }\n+\n+      explicit vector(size_type __n, const _Tp& __value = _Tp(),\n+\t\t      const _Allocator& __a = _Allocator())\n+      :  _Base(__n, __value, __a)\n+      { \n+        __profcxx_vector_construct(this, this->capacity());\n+        __profcxx_vector_construct2(this);\n+      }\n+\n+      template<class _InputIterator>\n+        vector(_InputIterator __first, _InputIterator __last,\n+\t       const _Allocator& __a = _Allocator())\n+\t: _Base(__first, __last, __a)\n+      { \n+        __profcxx_vector_construct(this, this->capacity());\n+        __profcxx_vector_construct2(this);\n+      }\n+\n+      vector(const vector& __x)\n+      : _Base(__x) \n+      { \n+        __profcxx_vector_construct(this, this->capacity());\n+        __profcxx_vector_construct2(this);\n+      }\n+\n+      /// Construction from a release-mode vector\n+      vector(const _Base& __x)\n+      : _Base(__x) \n+      { \n+        __profcxx_vector_construct(this, this->capacity());\n+        __profcxx_vector_construct2(this);\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      vector(vector&& __x)\n+      : _Base(std::forward<vector>(__x))\n+      {\n+        __profcxx_vector_construct(this, this->capacity());\n+        __profcxx_vector_construct2(this);\n+      }\n+\n+      vector(initializer_list<value_type> __l,\n+\t     const allocator_type& __a = allocator_type())\n+      : _Base(__l, __a) { }\n+#endif\n+\n+      ~vector() {\n+        __profcxx_vector_destruct(this, this->capacity(), this->size());\n+        __profcxx_vector_destruct2(this);\n+      }\n+\n+      vector&\n+      operator=(const vector& __x)\n+      {\n+        static_cast<_Base&>(*this) = __x;\n+        return *this;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      vector&\n+      operator=(vector&& __x)\n+      {\n+        // NB: DR 675.\n+        this->clear();\n+        this->swap(__x);\n+        return *this;\n+      }\n+\n+      vector&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tstatic_cast<_Base&>(*this) = __l;\n+\treturn *this;\n+      }\n+#endif\n+\n+      using _Base::assign;\n+      using _Base::get_allocator;\n+\n+      // 23.2.4.2 capacity:\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      void\n+      resize(size_type __sz, _Tp __c = _Tp())\n+      {\n+        __profcxx_vector_invalid_operator(this);\n+        _M_profile_resize(this, this->capacity(), __sz);\n+        _Base::resize(__sz, __c);\n+      }\n+\n+      using _Base::empty;\n+\n+      // element access:\n+      reference\n+      operator[](size_type __n)\n+      {\n+        __profcxx_vector_invalid_operator(this);\n+        return _M_base()[__n];\n+      }\n+      const_reference\n+      operator[](size_type __n) const\n+      {\n+        __profcxx_vector_invalid_operator(this);\n+        return _M_base()[__n];\n+      }\n+\n+      using _Base::at;\n+\n+      reference\n+      front()\n+      { \n+        return _Base::front();\n+      }\n+\n+      const_reference\n+      front() const\n+      {\n+\treturn _Base::front();\n+      }\n+\n+      reference\n+      back()\n+      {\n+\treturn _Base::back();\n+      }\n+\n+      const_reference\n+      back() const\n+      {\n+\treturn _Base::back();\n+      }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 464. Suggestion for new member functions in standard containers.\n+      using _Base::data;\n+\n+      // 23.2.4.3 modifiers:\n+      void\n+      push_back(const _Tp& __x)\n+      {\n+        size_type __old_size = this->capacity();\n+\t_Base::push_back(__x);\n+        _M_profile_resize(this, __old_size, this->capacity());\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      push_back(_Tp&& __x)\n+      {\n+        size_type __old_size = this->capacity();\n+        _Base::push_back(__x);\n+        _M_profile_resize(this, __old_size, this->capacity());\n+      }\n+\n+#endif\n+\n+      iterator\n+      insert(iterator __position, const _Tp& __x)\n+      {\n+        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        size_type __old_size = this->capacity();\n+\ttypename _Base::iterator __res = _Base::insert(__position,__x);\n+        _M_profile_resize(this, __old_size, this->capacity());\n+\treturn __res;\n+      }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(iterator __position, _Tp&& __x)\n+      {\n+        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        size_type __old_size = this->capacity();\n+\ttypename _Base::iterator __res = _Base::insert(__position,__x);\n+        _M_profile_resize(this, __old_size, this->capacity());\n+\treturn __res;\n+      }\n+\n+      void\n+      insert(iterator __position, initializer_list<value_type> __l)\n+      { this->insert(__position, __l.begin(), __l.end()); }\n+#endif\n+\n+      void\n+\n+      swap(vector& __x)\n+      {\n+        _Base::swap(__x);\n+      }\n+\n+\n+      void\n+      insert(iterator __position, size_type __n, const _Tp& __x)\n+      {\n+        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        size_type __old_size = this->capacity();\n+\t    _Base::insert(__position, __n, __x);\n+        _M_profile_resize(this, __old_size, this->capacity());\n+      }\n+\n+      template<class _InputIterator>\n+      void\n+      insert(iterator __position,\n+             _InputIterator __first, _InputIterator __last)\n+      {\n+        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        size_type __old_size = this->capacity();\n+        _Base::insert(__position, __first, __last);\n+        _M_profile_resize(this, __old_size, this->capacity());\n+      }\n+\n+      void\n+      clear()\n+      {\n+        __profcxx_vector_destruct(this, this->capacity(), this->size());\n+        __profcxx_vector_destruct2(this);\n+        _Base::clear();\n+      }\n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { \n+        return _Base::begin(); \n+      }\n+\n+      const_iterator\n+      begin() const\n+      { \n+        return _Base::begin(); \n+      }\n+\n+    private:\n+      void _M_profile_resize(void* obj, size_type __old_size, \n+                             size_type __new_size)\n+      {\n+        if (__old_size < __new_size) {\n+          __profcxx_vector_resize(this, this->size(), __new_size);\n+          __profcxx_vector_resize2(this, this->size(), __new_size);\n+        }\n+      }\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const vector<_Tp, _Alloc>& __lhs,\n+           const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const vector<_Tp, _Alloc>& __lhs,\n+           const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const vector<_Tp, _Alloc>& __lhs,\n+          const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const vector<_Tp, _Alloc>& __lhs,\n+           const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const vector<_Tp, _Alloc>& __lhs,\n+           const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const vector<_Tp, _Alloc>& __lhs,\n+          const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(vector<_Tp, _Alloc>& __lhs, vector<_Tp, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+} // namespace __profile\n+  using _GLIBCXX_STD_D::_S_word_bit;\n+} // namespace std\n+\n+#endif"}, {"sha": "131fe56de2da1629118c1f129d414c39f5a49622", "filename": "libstdc++-v3/include/std/bitset", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -1393,4 +1393,8 @@ _GLIBCXX_END_NESTED_NAMESPACE\n # include <debug/bitset>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/bitset>\n+#endif\n+\n #endif /* _GLIBCXX_BITSET */"}, {"sha": "f8a55f721652edb717b29eb387420dfabbbfd4b3", "filename": "libstdc++-v3/include/std/deque", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -72,4 +72,8 @@\n # include <debug/deque>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/deque>\n+#endif\n+\n #endif /* _GLIBCXX_DEQUE */"}, {"sha": "fcf164b4bd56eaace4bc2b53938148466d89b523", "filename": "libstdc++-v3/include/std/list", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -70,5 +70,9 @@\n # include <debug/list>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/list>\n+#endif\n+\n #endif /* _GLIBCXX_LIST */\n "}, {"sha": "25f86df6976728df0998b0846cd6e064d629ceca", "filename": "libstdc++-v3/include/std/map", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -65,4 +65,8 @@\n # include <debug/map>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/map>\n+#endif\n+\n #endif /* _GLIBCXX_MAP */"}, {"sha": "0b7805cabeceb4c4e4cbe955ae99530ff73577fa", "filename": "libstdc++-v3/include/std/set", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -65,4 +65,8 @@\n # include <debug/set>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/set>\n+#endif\n+\n #endif /* _GLIBCXX_SET */"}, {"sha": "f8cd5459787e58441ead5a930d98711d2dd339c1", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -53,7 +53,7 @@\n #  include <tr1_impl/unordered_map>\n #else\n #  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL)\n+#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL) || defined(_GLIBCXX_PROFILE)\n #  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace _GLIBCXX_STD_D {\n #  define _GLIBCXX_END_NAMESPACE_TR1 }\n #  define _GLIBCXX_TR1 _GLIBCXX_STD_D\n@@ -73,6 +73,10 @@\n # include <debug/unordered_map>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/unordered_map>\n+#endif\n+\n #endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif // _GLIBCXX_UNORDERED_MAP"}, {"sha": "b5b4f1089808933f76bdf07b7fab9dcb9d244f1a", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -53,7 +53,7 @@\n #  include <tr1_impl/unordered_set>\n #else\n #  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL)\n+#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL) || defined(_GLIBCXX_PROFILE) \n #  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace _GLIBCXX_STD_D {\n #  define _GLIBCXX_END_NAMESPACE_TR1 }\n #  define _GLIBCXX_TR1 _GLIBCXX_STD_D\n@@ -73,6 +73,9 @@\n # include <debug/unordered_set>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/unordered_set>\n+#endif\n #endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif // _GLIBCXX_UNORDERED_SET"}, {"sha": "41ecdde6c7bec13172390e17a8b32e482df885b4", "filename": "libstdc++-v3/include/std/vector", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -34,7 +34,7 @@\n  * that both that copyright notice and this permission notice appear\n  * in supporting documentation.  Hewlett-Packard Company makes no\n  * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n+ ded \"as is\" without express or implied warranty.\n  *\n  *\n  * Copyright (c) 1996\n@@ -73,5 +73,9 @@\n # include <debug/vector>\n #endif\n \n+#ifdef _GLIBCXX_PROFILE\n+# include <profile/vector>\n+#endif\n+\n #endif /* _GLIBCXX_VECTOR */\n "}, {"sha": "c47769823348e753ebe297a17efc0f5bbf399f12", "filename": "libstdc++-v3/include/tr1_impl/hashtable", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -409,6 +409,9 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       _M_erase_node(_Node*, _Node**);\n \n     public:\t\t\t\t\n+      // Expose insert_return_type for profiling mode.\n+      typedef _Insert_Return_Type insert_return_type;\n+\n       // Insert and erase\n       _Insert_Return_Type\n       insert(const value_type& __v) "}, {"sha": "089b10b83a61a01e6f3adb695755f7da26084545", "filename": "libstdc++-v3/testsuite/23_containers/deque/capacity/moveable.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcapacity%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcapacity%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcapacity%2Fmoveable.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -38,26 +38,26 @@ test01()\n   a.resize(98);\n   a.resize(99);\n   a.resize(100);\n-#ifndef _GLIBCXX_DEBUG\n+#if ! defined _GLIBCXX_DEBUG && ! defined _GLIBCXX_PROFILE\n   VERIFY( copycounter::copycount == 100 );\n #else\n   VERIFY( copycounter::copycount == 100 + 4 );\n #endif\n   a.resize(99);\n   a.resize(0);\n-#ifndef _GLIBCXX_DEBUG\n+#if ! defined _GLIBCXX_DEBUG && ! defined _GLIBCXX_PROFILE\n   VERIFY( copycounter::copycount == 100 );\n #else\n   VERIFY( copycounter::copycount == 100 + 6 );\n #endif\n   a.resize(100);\n-#ifndef _GLIBCXX_DEBUG\n+#if ! defined _GLIBCXX_DEBUG && ! defined _GLIBCXX_PROFILE\n   VERIFY( copycounter::copycount == 200 );\n #else\n   VERIFY( copycounter::copycount == 200 + 7 );\n #endif\n   a.clear();\n-#ifndef _GLIBCXX_DEBUG\n+#if ! defined _GLIBCXX_DEBUG && ! defined _GLIBCXX_PROFILE\n   VERIFY( copycounter::copycount == 200 );\n #else\n   VERIFY( copycounter::copycount == 200 + 7 );"}, {"sha": "d51fc3bb6628cebc8ac41b820beab8598f9b41af", "filename": "libstdc++-v3/testsuite/23_containers/list/capacity/29134.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcapacity%2F29134.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcapacity%2F29134.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcapacity%2F29134.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -28,7 +28,7 @@ void test01()\n   typedef std::list<int> list_type;\n   list_type l;\n \n-#ifndef _GLIBCXX_DEBUG\n+#if ! defined _GLIBCXX_DEBUG && ! defined _GLIBCXX_PROFILE\n   using std::_List_node;\n #else\n   using std::_GLIBCXX_STD_D::_List_node;"}, {"sha": "7939a35e3ef175905724a6ff9679f0138ae53e58", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/profile/hash_map.cc", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fprofile%2Fhash_map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fprofile%2Fhash_map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fprofile%2Fhash_map.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-Wno-deprecated\" }\n+/* testing the gcc instrumented */\n+\n+#include <ext/hash_map>\n+using namespace std;\n+using __gnu_cxx::hash_map;\n+\n+int main()\n+{\n+  hash_map <int, int> *tmp;\n+\n+  for (int j=1; j<=10; j++)\n+  {\n+    tmp = new hash_map<int, int>;\n+    // Insert more than default item\n+    for (int i=0; i<10000*j; i++) {\n+      (*tmp)[i]= i;\n+    }\n+    delete tmp;\n+  }\n+}\n+"}, {"sha": "93b506e9832ee9f045301535276e579fa66c7963", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/profile/unordered.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fprofile%2Funordered.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fprofile%2Funordered.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fprofile%2Funordered.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++0x\" }\n+/* testing the gcc instrumented */\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+using std::unordered_map;\n+using std::unordered_set;\n+\n+void test_unordered_set()\n+{\n+  // Test for unordered set\n+  unordered_set <int> *tmp2;\n+  tmp2 = new unordered_set<int>;\n+  tmp2->insert(1);\n+  delete tmp2;\n+}\n+void test_unordered_map()\n+{\n+  unordered_map <int, int> *tmp;\n+  for (int i=0; i<20; i++) \n+ {\n+  tmp = new unordered_map<int, int>(i+2);\n+  // Insert more than default item\n+  for (int j=0; j<10000; j++) {\n+      (*tmp)[j]= j;\n+  }\n+  \n+  delete tmp;\n+  }\n+\n+  tmp = new unordered_map<int, int>;\n+\n+  // Insert more than default item\n+  for (int i=0; i<150000; i++) {\n+//      (*tmp)[i] = i;\n+      (*tmp).insert(unordered_map<int, int>::value_type(i, i));\n+  }\n+\n+  (*tmp).erase(1);\n+  delete tmp;\n+}\n+int main()\n+{\n+  test_unordered_set();\n+  test_unordered_map();\n+}\n+"}, {"sha": "1e9d01afec59cf08d3a4e39459cf9e764268301b", "filename": "libstdc++-v3/testsuite/23_containers/vector/profile/vector.cc", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fprofile%2Fvector.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fprofile%2Fvector.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fprofile%2Fvector.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,18 @@\n+// Test vector: performance difference 25% (0.444s vs 0.539s)\n+// Advice: set tmp as 10000\n+\n+#include <vector>\n+\n+using std::vector;\n+\n+int main()\n+{\n+  vector <int> tmp;\n+\n+  for (int j=0; j<2000; j++)\n+    // Insert more than default item\n+    for (int i=0; i<10000; i++) {\n+      tmp.push_back(i);\n+    }\n+}\n+"}, {"sha": "47fdf8fcafa8ac24aae67391c617d60b6a94afb1", "filename": "libstdc++-v3/testsuite/23_containers/vector/resize/moveable.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fresize%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fresize%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fresize%2Fmoveable.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -41,26 +41,26 @@ test01()\n   a.resize(98);\n   a.resize(99);\n   a.resize(100);\n-#ifndef _GLIBCXX_DEBUG\n+#if !defined(_GLIBCXX_DEBUG) && !defined(_GLIBCXX_PROFILE)\n   VERIFY( copycounter::copycount == 100 + 1 );\n #else\n   VERIFY( copycounter::copycount == 100 + 1 + 4 );\n #endif\n   a.resize(99);\n   a.resize(0);\n-#ifndef _GLIBCXX_DEBUG\n+#if !defined(_GLIBCXX_DEBUG) && !defined(_GLIBCXX_PROFILE)\n   VERIFY( copycounter::copycount == 100 + 1 );\n #else\n   VERIFY( copycounter::copycount == 100 + 1 + 6 );\n #endif\n   a.resize(100);\n-#ifndef _GLIBCXX_DEBUG  \n+#if !defined(_GLIBCXX_DEBUG) && !defined(_GLIBCXX_PROFILE)\n   VERIFY( copycounter::copycount == 200 + 2 );\n #else\n   VERIFY( copycounter::copycount == 200 + 2 + 7 );\n #endif\n   a.clear();\n-#ifndef _GLIBCXX_DEBUG\n+#if !defined(_GLIBCXX_DEBUG) && !defined(_GLIBCXX_PROFILE)\n   VERIFY( copycounter::copycount == 200 + 2 );\n #else\n   VERIFY( copycounter::copycount == 200 + 2 + 7 );"}, {"sha": "c8176072326fc47b86af98250ad83f687a9031d0", "filename": "libstdc++-v3/testsuite/Makefile.am", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -196,6 +196,9 @@ libgomp_flags=-B${glibcxx_builddir}/../libgomp \\\n atomic_flags=$(ATOMIC_FLAGS)\n parallel_flags=\"unix/-D_GLIBCXX_PARALLEL/-fopenmp\"\n \n+# Runs the testsuite in profile mode.\n+profile_flags = \"unix/-D_GLIBCXX_PROFILE\"\n+\n check-parallel: site.exp\n \t-@(if test ! -d $${libgomp_dir}; then \\\n \t  echo \"Testing parallel mode failed as libgomp not present.\"; \\\n@@ -214,8 +217,17 @@ check-performance-parallel: testsuite_files_performance ${performance_script}\n \tCXXFLAGS=\"-D_GLIBCXX_PARALLEL -fopenmp $(atomic_flags) $(libgomp_flags)\"; export CXXFLAGS; \\\n \t${check_performance_script} ${glibcxx_srcdir} ${glibcxx_builddir})\n \n+check-profile: site.exp\n+\t-@(outputdir=profile; export outputdir; \\\n+\tif test ! -d $${outputdir}; then \\\n+\t  mkdir $${outputdir}; \\\n+\tfi; \\\n+\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n+\tEXPECT=$(EXPECT); export EXPECT; \\\n+\t$(MAKE) CXXFLAGS=\"$(atomic_flags) \" RUNTESTFLAGS=\"$(RUNTESTFLAGS) conformance.exp --outdir $${outputdir} --objdir $${outputdir} --target_board=$(profile_flags)\" check-DEJAGNU; )\n+\n .PHONY: baseline_symbols new-abi-baseline \\\n-\tcheck-abi check-compile check-performance check-parallel\n+\tcheck-abi check-compile check-performance check-parallel check-profile\n \n # By adding these files here, automake will remove them for 'make clean'\n CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \\\n@@ -224,4 +236,4 @@ CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \\\n \n # To remove directories.\n clean-local:\n-\trm -rf parallel\n+\trm -rf parallel profile"}, {"sha": "da2a59ad8bcadac2fd2c13f229b1086ba383ca4c", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -299,6 +299,9 @@ libgomp_flags = -B${glibcxx_builddir}/../libgomp \\\n atomic_flags = $(ATOMIC_FLAGS)\n parallel_flags = \"unix/-D_GLIBCXX_PARALLEL/-fopenmp\"\n \n+# Runs the testsuite in profile\n+profile_flags = \"unix/-D_GLIBCXX_PROFILE\"\n+\n # By adding these files here, automake will remove them for 'make clean'\n CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \\\n \t     testsuite_* site.exp abi_check baseline_symbols *TEST* *.dat \\\n@@ -642,12 +645,21 @@ check-performance-parallel: testsuite_files_performance ${performance_script}\n \tCXXFLAGS=\"-D_GLIBCXX_PARALLEL -fopenmp $(atomic_flags) $(libgomp_flags)\"; export CXXFLAGS; \\\n \t${check_performance_script} ${glibcxx_srcdir} ${glibcxx_builddir})\n \n+check-profile: site.exp\n+\t-@(outputdir=profile; export outputdir; \\\n+\tif test ! -d $${outputdir}; then \\\n+\t  mkdir $${outputdir}; \\\n+\tfi; \\\n+\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n+\tEXPECT=$(EXPECT); export EXPECT; \\\n+\t$(MAKE) CXXFLAGS=\"$(atomic_flags)\" RUNTESTFLAGS=\"$(RUNTESTFLAGS) conformance.exp --outdir $${outputdir} --objdir $${outputdir} --target_board=$(profile_flags)\" check-DEJAGNU; )\n+\n .PHONY: baseline_symbols new-abi-baseline \\\n-\tcheck-abi check-compile check-performance check-parallel\n+\tcheck-abi check-compile check-performance check-parallel check-profile\n \n # To remove directories.\n clean-local:\n-\trm -rf parallel\n+\trm -rf parallel profile\n \n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded."}, {"sha": "0a1f97962085a6f71ce40a4b2710225a54e42f17", "filename": "libstdc++-v3/testsuite/ext/profile/all.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fall.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x -O0 -D_GLIBCXX_PROFILE\" }\n+// { dg-do compile }\n+\n+// -*- C++ -*-\n+\n+// Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <map>\n+#include <vector>\n+#include <unordered_map>\n+\n+using std::map;\n+using std::vector;\n+using std::unordered_map;\n+\n+struct dumb_hash {\n+  size_t operator()(int x) const {return 0;}\n+  size_t operator()(int x, int y) const {return x == y;}\n+};\n+\n+int main() {\n+  map<int, int> m_to_umap;\n+  vector<int> v_to_list;\n+  unordered_map<int, int> um_too_small;\n+  unordered_map<int, int> um_too_large(1000000);\n+  unordered_map<int, int, dumb_hash, dumb_hash> um_dumb_hash;\n+\n+  for (int i = 0; i < 10000; ++i) {\n+    m_to_umap[i] = i;\n+    v_to_list.insert(v_to_list.begin(), i);\n+    um_too_small[i] = i;\n+    um_too_small[i] = i;\n+    um_dumb_hash[i] = i;\n+  }\n+}"}, {"sha": "dc91094986784f25b3ecc0f6ae8a4fa9afd36d49", "filename": "libstdc++-v3/testsuite/ext/profile/mh.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmh.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmh.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmh.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,65 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-D_GLIBCXX_PROFILE\" }\n+// { dg-do compile }\n+\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <vector>\n+\n+using std::vector;\n+\n+static void my_init_hook (void);\n+static void *my_malloc_hook (size_t, const void *);\n+typedef void* (*malloc_hook) (size_t, const void *);\n+\n+malloc_hook old_malloc_hook;\n+     \n+void (*__malloc_initialize_hook) (void) = my_init_hook;\n+\n+static void\n+my_init_hook (void)\n+{\n+  old_malloc_hook = __malloc_hook;\n+  __malloc_hook = my_malloc_hook;\n+}\n+\n+static void *\n+my_malloc_hook (size_t size, const void *caller)\n+{\n+  void *result;\n+  __malloc_hook = old_malloc_hook;\n+  result = malloc (size);\n+  old_malloc_hook = __malloc_hook;\n+\n+  // With _GLIBCXX_PROFILE, the instrumentation of the vector constructor\n+  // will call back into malloc.\n+  vector<int> v;\n+\n+  __malloc_hook = my_malloc_hook;\n+  return result;\n+}\n+     \n+\n+int main() {\n+  int* test = (int*) malloc(sizeof(int));\n+  *test = 1;\n+  return *test;\n+}"}, {"sha": "c8bcf720e1d664586e31475add93b5dc10735c60", "filename": "libstdc++-v3/testsuite/ext/profile/mutex_extensions.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1218d701f7de691254c06b4599abab6ca7361703/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions.cc?ref=1218d701f7de691254c06b4599abab6ca7361703", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-D_GLIBCXX_DEBUG -D_GLIBCXX_PROFILE\" }\n+// { dg-do compile }\n+\n+// -*- C++ -*-\n+\n+// Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <vector>\n+\n+// { dg-error \"Cannot use -D_GLIBCXX_PROFILE with \" \"\" { target *-*-* } 166 }\n+// { dg-excess-errors \"In file included from\" }"}]}