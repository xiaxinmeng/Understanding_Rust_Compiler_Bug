{"sha": "21f3a2369bb56501115221846f63f54a035233bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFmM2EyMzY5YmI1NjUwMTExNTIyMTg0NmY2M2Y1NGEwMzUyMzNiYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-04-12T07:05:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-04-12T07:05:29Z"}, "message": "omp-low.c (lower_omp_target): Use GOMP_MAP_FIRSTPRIVATE_INT regardless whether there are depend clauses or not.\n\n\t* omp-low.c (lower_omp_target): Use GOMP_MAP_FIRSTPRIVATE_INT\n\tregardless whether there are depend clauses or not.\n\n\t* libgomp.h (struct gomp_target_task): Remove firstprivate_copies\n\tfield.\n\t* target.c (gomp_target_fallback_firstprivate,\n\tgomp_target_unshare_firstprivate): Removed.\n\t(GOMP_target_ext): Copy firstprivate vars into gomp_allocaed memory\n\tbefore waiting for dependencies.\n\t(gomp_target_task_fn): Don't copy firstprivate vars here.\n\t* task.c (GOMP_PLUGIN_target_task_completion): Don't free\n\tfirstprivate_copies here.\n\t(gomp_create_target_task): Don't initialize firstprivate_copies field.\n\t* testsuite/libgomp.c/target-25.c (main): Use map (to:) instead of\n\texplicit/implicit firstprivate.\n\nFrom-SVN: r234894", "tree": {"sha": "7d2a75e2cbcd54347feb0c7ddb5e8f6d35f11e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d2a75e2cbcd54347feb0c7ddb5e8f6d35f11e2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21f3a2369bb56501115221846f63f54a035233bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f3a2369bb56501115221846f63f54a035233bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21f3a2369bb56501115221846f63f54a035233bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f3a2369bb56501115221846f63f54a035233bc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3f90b8c03e73c7a2a596f3f4112eca53ea19cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f90b8c03e73c7a2a596f3f4112eca53ea19cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f90b8c03e73c7a2a596f3f4112eca53ea19cdf"}], "stats": {"total": 188, "additions": 61, "deletions": 127}, "files": [{"sha": "edd33043879ab8d8c976f3d99decbef9d447970d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f3a2369bb56501115221846f63f54a035233bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f3a2369bb56501115221846f63f54a035233bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21f3a2369bb56501115221846f63f54a035233bc", "patch": "@@ -1,3 +1,8 @@\n+2016-04-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (lower_omp_target): Use GOMP_MAP_FIRSTPRIVATE_INT\n+\tregardless whether there are depend clauses or not.\n+\n 2016-04-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/70381"}, {"sha": "7335abc6396f4a6a91c29389143345f1560f5b18", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f3a2369bb56501115221846f63f54a035233bc/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f3a2369bb56501115221846f63f54a035233bc/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=21f3a2369bb56501115221846f63f54a035233bc", "patch": "@@ -15730,7 +15730,6 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   location_t loc = gimple_location (stmt);\n   bool offloaded, data_region;\n   unsigned int map_cnt = 0;\n-  bool has_depend = false;\n \n   offloaded = is_gimple_omp_offloaded (stmt);\n   switch (gimple_omp_target_kind (stmt))\n@@ -15765,7 +15764,6 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       dep_bind = gimple_build_bind (NULL, NULL, make_node (BLOCK));\n       lower_depend_clauses (gimple_omp_target_clauses_ptr (stmt),\n \t\t\t    &dep_ilist, &dep_olist);\n-      has_depend = true;\n     }\n \n   tgt_bind = NULL;\n@@ -16280,44 +16278,9 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    type = TREE_TYPE (ovar);\n \t    if (is_reference (ovar))\n \t      type = TREE_TYPE (type);\n-\t    bool use_firstprivate_int, force_addr;\n-\t    use_firstprivate_int = false;\n-\t    force_addr = false;\n \t    if ((INTEGRAL_TYPE_P (type)\n \t\t && TYPE_PRECISION (type) <= POINTER_SIZE)\n \t\t|| TREE_CODE (type) == POINTER_TYPE)\n-\t      use_firstprivate_int = true;\n-\t    if (has_depend)\n-\t      {\n-\t\tif (is_reference (var))\n-\t\t  use_firstprivate_int = false;\n-\t\telse if (is_gimple_reg (var))\n-\t\t  {\n-\t\t    if (DECL_HAS_VALUE_EXPR_P (var))\n-\t\t      {\n-\t\t\ttree v = get_base_address (var);\n-\t\t\tif (DECL_P (v) && TREE_ADDRESSABLE (v))\n-\t\t\t  {\n-\t\t\t    use_firstprivate_int = false;\n-\t\t\t    force_addr = true;\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  switch (TREE_CODE (v))\n-\t\t\t    {\n-\t\t\t    case INDIRECT_REF:\n-\t\t\t    case MEM_REF:\n-\t\t\t      use_firstprivate_int = false;\n-\t\t\t      force_addr = true;\n-\t\t\t      break;\n-\t\t\t    default:\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  use_firstprivate_int = false;\n-\t      }\n-\t    if (use_firstprivate_int)\n \t      {\n \t\ttkind = GOMP_MAP_FIRSTPRIVATE_INT;\n \t\ttree t = var;\n@@ -16332,7 +16295,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      }\n \t    else if (is_reference (var))\n \t      gimplify_assign (x, var, &ilist);\n-\t    else if (!force_addr && is_gimple_reg (var))\n+\t    else if (is_gimple_reg (var))\n \t      {\n \t\ttree avar = create_tmp_var (TREE_TYPE (var));\n \t\tmark_addressable (avar);\n@@ -16470,40 +16433,9 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\ttype = TREE_TYPE (var);\n \t\tif (is_reference (var))\n \t\t  type = TREE_TYPE (type);\n-\t\tbool use_firstprivate_int;\n-\t\tuse_firstprivate_int = false;\n \t\tif ((INTEGRAL_TYPE_P (type)\n \t\t     && TYPE_PRECISION (type) <= POINTER_SIZE)\n \t\t    || TREE_CODE (type) == POINTER_TYPE)\n-\t\t  use_firstprivate_int = true;\n-\t\tif (has_depend)\n-\t\t  {\n-\t\t    tree v = lookup_decl_in_outer_ctx (var, ctx);\n-\t\t    if (is_reference (v))\n-\t\t      use_firstprivate_int = false;\n-\t\t    else if (is_gimple_reg (v))\n-\t\t      {\n-\t\t\tif (DECL_HAS_VALUE_EXPR_P (v))\n-\t\t\t  {\n-\t\t\t    v = get_base_address (v);\n-\t\t\t    if (DECL_P (v) && TREE_ADDRESSABLE (v))\n-\t\t\t      use_firstprivate_int = false;\n-\t\t\t    else\n-\t\t\t      switch (TREE_CODE (v))\n-\t\t\t\t{\n-\t\t\t\tcase INDIRECT_REF:\n-\t\t\t\tcase MEM_REF:\n-\t\t\t\t  use_firstprivate_int = false;\n-\t\t\t\t  break;\n-\t\t\t\tdefault:\n-\t\t\t\t  break;\n-\t\t\t\t}\n-\t\t\t  }\n-\t\t      }\n-\t\t    else\n-\t\t      use_firstprivate_int = false;\n-\t\t  }\n-\t\tif (use_firstprivate_int)\n \t\t  {\n \t\t    x = build_receiver_ref (var, false, ctx);\n \t\t    if (TREE_CODE (type) != POINTER_TYPE)"}, {"sha": "b53dc6b7056c7eca5d51c0c9ed67da336a33d833", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=21f3a2369bb56501115221846f63f54a035233bc", "patch": "@@ -1,3 +1,18 @@\n+2016-04-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* libgomp.h (struct gomp_target_task): Remove firstprivate_copies\n+\tfield.\n+\t* target.c (gomp_target_fallback_firstprivate,\n+\tgomp_target_unshare_firstprivate): Removed.\n+\t(GOMP_target_ext): Copy firstprivate vars into gomp_allocaed memory\n+\tbefore waiting for dependencies.\n+\t(gomp_target_task_fn): Don't copy firstprivate vars here.\n+\t* task.c (GOMP_PLUGIN_target_task_completion): Don't free\n+\tfirstprivate_copies here.\n+\t(gomp_create_target_task): Don't initialize firstprivate_copies field.\n+\t* testsuite/libgomp.c/target-25.c (main): Use map (to:) instead of\n+\texplicit/implicit firstprivate.\n+\n 2016-04-08  Cesar Philippidis  <cesar@codesourcery.com>\n \n \tPR lto/70289"}, {"sha": "664e76b52d1f1b4731b8801f8e3f496ac270130b", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=21f3a2369bb56501115221846f63f54a035233bc", "patch": "@@ -496,8 +496,6 @@ struct gomp_target_task\n   struct target_mem_desc *tgt;\n   struct gomp_task *task;\n   struct gomp_team *team;\n-  /* Copies of firstprivate mapped data for shared memory accelerators.  */\n-  void *firstprivate_copies;\n   /* Device-specific target arguments.  */\n   void **args;\n   void *hostaddrs[];"}, {"sha": "e2dd0e089970ac615c9753310e5982b5f86e2c9e", "filename": "libgomp/target.c", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=21f3a2369bb56501115221846f63f54a035233bc", "patch": "@@ -1372,47 +1372,6 @@ copy_firstprivate_data (char *tgt, size_t mapnum, void **hostaddrs,\n       }\n }\n \n-/* Host fallback with firstprivate map-type handling.  */\n-\n-static void\n-gomp_target_fallback_firstprivate (void (*fn) (void *), size_t mapnum,\n-\t\t\t\t   void **hostaddrs, size_t *sizes,\n-\t\t\t\t   unsigned short *kinds)\n-{\n-  size_t tgt_align = 0, tgt_size = 0;\n-  calculate_firstprivate_requirements (mapnum, sizes, kinds, &tgt_align,\n-\t\t\t\t       &tgt_size);\n-  if (tgt_align)\n-    {\n-      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n-      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds, tgt_align,\n-\t\t\t      tgt_size);\n-    }\n-  gomp_target_fallback (fn, hostaddrs);\n-}\n-\n-/* Handle firstprivate map-type for shared memory devices and the host\n-   fallback.  Return the pointer of firstprivate copies which has to be freed\n-   after use.  */\n-\n-static void *\n-gomp_target_unshare_firstprivate (size_t mapnum, void **hostaddrs,\n-\t\t\t\t  size_t *sizes, unsigned short *kinds)\n-{\n-  size_t tgt_align = 0, tgt_size = 0;\n-  char *tgt = NULL;\n-\n-  calculate_firstprivate_requirements (mapnum, sizes, kinds, &tgt_align,\n-\t\t\t\t       &tgt_size);\n-  if (tgt_align)\n-    {\n-      tgt = gomp_malloc (tgt_size + tgt_align - 1);\n-      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds, tgt_align,\n-\t\t\t      tgt_size);\n-    }\n-  return tgt;\n-}\n-\n /* Helper function of GOMP_target{,_ext} routines.  */\n \n static void *\n@@ -1504,6 +1463,8 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t\t unsigned int flags, void **depend, void **args)\n {\n   struct gomp_device_descr *devicep = resolve_device (device);\n+  size_t tgt_align = 0, tgt_size = 0;\n+  bool fpc_done = false;\n \n   if (flags & GOMP_TARGET_FLAG_NOWAIT)\n     {\n@@ -1555,7 +1516,19 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n     {\n       struct gomp_thread *thr = gomp_thread ();\n       if (thr->task && thr->task->depend_hash)\n-\tgomp_task_maybe_wait_for_dependencies (depend);\n+\t{\n+\t  /* If we might need to wait, copy firstprivate now.  */\n+\t  calculate_firstprivate_requirements (mapnum, sizes, kinds,\n+\t\t\t\t\t       &tgt_align, &tgt_size);\n+\t  if (tgt_align)\n+\t    {\n+\t      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n+\t      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds,\n+\t\t\t\t      tgt_align, tgt_size);\n+\t    }\n+\t  fpc_done = true;\n+\t  gomp_task_maybe_wait_for_dependencies (depend);\n+\t}\n     }\n \n   void *fn_addr;\n@@ -1564,15 +1537,35 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n       || !(fn_addr = gomp_get_target_fn_addr (devicep, fn))\n       || (devicep->can_run_func && !devicep->can_run_func (fn_addr)))\n     {\n-      gomp_target_fallback_firstprivate (fn, mapnum, hostaddrs, sizes, kinds);\n+      if (!fpc_done)\n+\t{\n+\t  calculate_firstprivate_requirements (mapnum, sizes, kinds,\n+\t\t\t\t\t       &tgt_align, &tgt_size);\n+\t  if (tgt_align)\n+\t    {\n+\t      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n+\t      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds,\n+\t\t\t\t      tgt_align, tgt_size);\n+\t    }\n+\t}\n+      gomp_target_fallback (fn, hostaddrs);\n       return;\n     }\n \n   struct target_mem_desc *tgt_vars;\n-  void *fpc = NULL;\n   if (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     {\n-      fpc = gomp_target_unshare_firstprivate (mapnum, hostaddrs, sizes, kinds);\n+      if (!fpc_done)\n+\t{\n+\t  calculate_firstprivate_requirements (mapnum, sizes, kinds,\n+\t\t\t\t\t       &tgt_align, &tgt_size);\n+\t  if (tgt_align)\n+\t    {\n+\t      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n+\t      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds,\n+\t\t\t\t      tgt_align, tgt_size);\n+\t    }\n+\t}\n       tgt_vars = NULL;\n     }\n   else\n@@ -1583,8 +1576,6 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t\t     args);\n   if (tgt_vars)\n     gomp_unmap_vars (tgt_vars, true);\n-  else\n-    free (fpc);\n }\n \n /* Host fallback for GOMP_target_data{,_ext} routines.  */\n@@ -1891,9 +1882,7 @@ gomp_target_task_fn (void *data)\n \t  || (devicep->can_run_func && !devicep->can_run_func (fn_addr)))\n \t{\n \t  ttask->state = GOMP_TARGET_TASK_FALLBACK;\n-\t  gomp_target_fallback_firstprivate (ttask->fn, ttask->mapnum,\n-\t\t\t\t\t     ttask->hostaddrs, ttask->sizes,\n-\t\t\t\t\t     ttask->kinds);\n+\t  gomp_target_fallback (ttask->fn, ttask->hostaddrs);\n \t  return false;\n \t}\n \n@@ -1908,9 +1897,6 @@ gomp_target_task_fn (void *data)\n       if (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n \t{\n \t  ttask->tgt = NULL;\n-\t  ttask->firstprivate_copies\n-\t    = gomp_target_unshare_firstprivate (ttask->mapnum, ttask->hostaddrs,\n-\t\t\t\t\t\tttask->sizes, ttask->kinds);\n \t  actual_arguments = ttask->hostaddrs;\n \t}\n       else"}, {"sha": "023663f43d5dcc3038e2759731dfbf2851f524ae", "filename": "libgomp/task.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=21f3a2369bb56501115221846f63f54a035233bc", "patch": "@@ -582,7 +582,6 @@ GOMP_PLUGIN_target_task_completion (void *data)\n       return;\n     }\n   ttask->state = GOMP_TARGET_TASK_FINISHED;\n-  free (ttask->firstprivate_copies);\n   gomp_target_task_completion (team, task);\n   gomp_mutex_unlock (&team->task_lock);\n }\n@@ -683,7 +682,6 @@ gomp_create_target_task (struct gomp_device_descr *devicep,\n   ttask->state = state;\n   ttask->task = task;\n   ttask->team = team;\n-  ttask->firstprivate_copies = NULL;\n   task->fn = NULL;\n   task->fn_data = ttask;\n   task->final_task = 0;"}, {"sha": "09b8d52184aee8c222d1677656c47e8e27474a38", "filename": "libgomp/testsuite/libgomp.c/target-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f3a2369bb56501115221846f63f54a035233bc/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-25.c?ref=21f3a2369bb56501115221846f63f54a035233bc", "patch": "@@ -23,7 +23,7 @@ main ()\n       usleep (7000);\n       z = 3;\n     }\n-    #pragma omp target map(tofrom: x) map(from: err) firstprivate (y) depend(inout: x, z)\n+    #pragma omp target map(tofrom: x) map(from: err) map (to: y, z) depend(inout: x, z)\n     err = (x != 1 || y != 2 || z != 3);\n     if (err)\n       abort ();"}]}