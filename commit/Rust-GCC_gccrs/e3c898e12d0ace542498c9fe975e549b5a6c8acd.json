{"sha": "e3c898e12d0ace542498c9fe975e549b5a6c8acd", "node_id": "C_kwDOANBUbNoAKGUzYzg5OGUxMmQwYWNlNTQyNDk4YzlmZTk3NWU1NDliNWE2YzhhY2Q", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-11-03T02:53:41Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-11-03T02:53:41Z"}, "message": "c: C2x auto\n\nImplement C2x auto, a more restricted version of the C++ feature\n(closer to GNU C __auto_type in terms of what's supported).\n\nSince the feature is very close to GNU C __auto_type, much of the\nimplementation can be shared.  The main differences are:\n\n* Any prior declaration of the identifier in an outer scope is\n  shadowed during the initializer (whereas __auto_type leaves any such\n  declaration visible until the initializer ends and the scope of the\n  __auto_type declaration itself starts).  (A prior declaration in the\n  same scope is undefined behavior.)\n\n* The standard feature supports braced initializers (containing a\n  single expression, optionally followed by a comma).\n\n* The standard feature disallows the declaration from declaring\n  anything that's not an ordinary identifier (thus, the initializer\n  cannot declare a tag or the members of a structure or union), while\n  making it undefined behavior for it to declare more than one\n  ordinary identifier.  (For the latter, while I keep the existing\n  error from __auto_type in the case of more than one declarator, I\n  don't restrict other ordinary identifiers from being declared in\n  inner scopes such as GNU statement expressions.  I do however\n  disallow defining the members of an enumeration inside the\n  initializer (if the enum definition has no tag, that doesn't\n  actually violate a constraint), to avoid an enum type becoming\n  accessible beyond where it would have been without auto.\n  (Preventing new types from escaping the initializer - thus, ensuring\n  that anything written with auto corresponds to something that could\n  have been written without auto, modulo multiple evaluation of VLA\n  size expressions when not using auto - is a key motivation for some\n  restrictions on what can be declared in the initializer.)\n\nThe rule on shadowing and restrictions on other declarations in the\ninitializer are actually general rules for what C2x calls\nunderspecified declarations, a description that covers constexpr as\nwell as auto (in particular, this disallows a constexpr initializer\nfrom referencing the variable being initialized).  Thus, some of the\ncode added for those restrictions will also be of use in implementing\nC2x constexpr.\n\nauto with a type specifier remains a storage class specifier with the\nsame meaning as before (i.e. a redundant storage class specifier for\nuse at block scope).\n\nNote that the feature is only enabled in C2x mode (-std=c2x or\n-std=gnu2x); in older modes, a declaration with auto and no type is\ntreated as a case of implicit int (only accepted at block scope).\n\nSince many of the restrictions on C2x auto are specified as undefined\nbehavior rather than constraint violations, it would be possible to\nsupport more features from C++ auto without requiring diagnostics (but\nmaybe not a good idea, if it isn't clear exactly what semantics might\nbe given to such a feature in a future revision of C; and\n-Wc23-c2y-compat should arguably warn for any such future feature\nanyway).  For now the features are limited to something close to\nwhat's supported with __auto_type, with the differences as discussed\nabove between the two features.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/c/\n\t* c-decl.cc (in_underspecified_init, start_underspecified_init)\n\t(finish_underspecified_init): New.\n\t(shadow_tag_warned, parser_xref_tag, start_struct, start_enum):\n\tGive errors inside initializers of underspecified declarations.\n\t(grokdeclarator): Handle (erroneous) case of C2X auto on a\n\tparameter.\n\t(declspecs_add_type): Handle c2x_auto_p case.\n\t(declspecs_add_scspec): Handle auto possibly setting c2x_auto_p in\n\tC2X mode.\n\t(finish_declspecs): Handle c2x_auto_p.\n\t* c-parser.cc (c_parser_declaration_or_fndef): Handle C2X auto.\n\t* c-tree.h (C_DECL_UNDERSPECIFIED): New macro.\n\t(struct c_declspecs): Add c2x_auto_p.\n\t(start_underspecified_init, finish_underspecified_init): New\n\tprototypes.\n\t* c-typeck.cc (build_external_ref): Give error for underspecified\n\tdeclaration referenced in its initializer.\n\ngcc/testsuite/\n\t* gcc.dg/c2x-auto-1.c, gcc.dg/c2x-auto-2.c, gcc.dg/c2x-auto-3.c,\n\tgcc.dg/c2x-auto-4.c, gcc.dg/gnu2x-auto-1.c: New tests.", "tree": {"sha": "190e2caa19546fbe02ae5501d17390a218a4a148", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/190e2caa19546fbe02ae5501d17390a218a4a148"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3c898e12d0ace542498c9fe975e549b5a6c8acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c898e12d0ace542498c9fe975e549b5a6c8acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c898e12d0ace542498c9fe975e549b5a6c8acd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c898e12d0ace542498c9fe975e549b5a6c8acd/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58035eeece7894d1936db6bf0dd4f8eedd07a479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58035eeece7894d1936db6bf0dd4f8eedd07a479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58035eeece7894d1936db6bf0dd4f8eedd07a479"}], "stats": {"total": 437, "additions": 418, "deletions": 19}, "files": [{"sha": "a99b74560552ed48772a999bd11ca9c01843caac", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 140, "deletions": 3, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -1472,6 +1472,67 @@ pop_file_scope (void)\n   maybe_apply_pending_pragma_weaks ();\n }\n \f\n+/* Whether we are curently inside the initializer for an\n+   underspecified object definition (C2x auto or constexpr).  */\n+static bool in_underspecified_init;\n+\n+/* Start an underspecified object definition for NAME at LOC.  This\n+   means that NAME is shadowed inside its initializer, so neither the\n+   definition being initialized, nor any definition from an outer\n+   scope, may be referenced during that initializer.  Return state to\n+   be passed to finish_underspecified_init.  */\n+unsigned int\n+start_underspecified_init (location_t loc, tree name)\n+{\n+  bool prev = in_underspecified_init;\n+  bool ok;\n+  tree decl = build_decl (loc, VAR_DECL, name, error_mark_node);\n+  C_DECL_UNDERSPECIFIED (decl) = 1;\n+  struct c_scope *scope = current_scope;\n+  struct c_binding *b = I_SYMBOL_BINDING (name);\n+  if (b && B_IN_SCOPE (b, scope))\n+    {\n+      error_at (loc, \"underspecified declaration of %qE, which is already \"\n+\t\t\"declared in this scope\", name);\n+      ok = false;\n+    }\n+  else\n+    {\n+      bind (name, decl, scope, false, false, loc);\n+      ok = true;\n+    }\n+  in_underspecified_init = true;\n+  return ok | (prev << 1);\n+}\n+\n+/* Finish an underspecified object definition for NAME, before that\n+   name is bound to the real declaration instead of a placeholder.\n+   PREV_STATE is the value returned by the call to\n+   start_underspecified_init.  */\n+void\n+finish_underspecified_init (tree name, unsigned int prev_state)\n+{\n+  if (prev_state & 1)\n+    {\n+      /* A VAR_DECL was bound to the name to shadow any previous\n+\t declarations for the name; remove that binding now.  */\n+      struct c_scope *scope = current_scope;\n+      struct c_binding *b = I_SYMBOL_BINDING (name);\n+      gcc_assert (b);\n+      gcc_assert (B_IN_SCOPE (b, scope));\n+      gcc_assert (VAR_P (b->decl));\n+      gcc_assert (C_DECL_UNDERSPECIFIED (b->decl));\n+      I_SYMBOL_BINDING (name) = b->shadowed;\n+      /* In erroneous cases there may be other bindings added to this\n+\t scope during the initializer.  */\n+      struct c_binding **p = &scope->bindings;\n+      while (*p != b)\n+\tp = &((*p)->prev);\n+      *p = free_binding_and_advance (*p);\n+    }\n+  in_underspecified_init = (prev_state & (1u << 1)) >> 1;\n+}\n+\f\n /* Adjust the bindings for the start of a statement expression.  */\n \n void\n@@ -4764,6 +4825,17 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t      warned = 1;\n \t    }\n \n+\t  if (in_underspecified_init)\n+\t    {\n+\t      /* This can only occur with extensions such as statement\n+\t\t expressions, but is still appropriate as an error to\n+\t\t avoid types declared in such a context escaping to\n+\t\t the type of an auto variable.  */\n+\t      error (\"%qT declared in underspecified object initializer\",\n+\t\t     value);\n+\t      warned = 1;\n+\t    }\n+\n \t  if (name == NULL_TREE)\n \t    {\n \t      if (warned != 1 && code != ENUMERAL_TYPE)\n@@ -6458,6 +6530,15 @@ grokdeclarator (const struct c_declarator *declarator,\n   enum c_declarator_kind first_non_attr_kind;\n   unsigned int alignas_align = 0;\n \n+  if (type == NULL_TREE)\n+    {\n+      /* This can occur for auto on a parameter in C2X mode.  Set a\n+\t dummy type here so subsequent code can give diagnostics for\n+\t this case.  */\n+      gcc_assert (declspecs->c2x_auto_p);\n+      gcc_assert (decl_context == PARM);\n+      type = declspecs->type = integer_type_node;\n+    }\n   if (TREE_CODE (type) == ERROR_MARK)\n     return error_mark_node;\n   if (expr == NULL)\n@@ -6683,9 +6764,13 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  || storage_class == csc_typedef)\n \tstorage_class = csc_none;\n     }\n-  else if (decl_context != NORMAL && (storage_class != csc_none || threadp))\n+  else if (decl_context != NORMAL && (storage_class != csc_none\n+\t\t\t\t      || threadp\n+\t\t\t\t      || declspecs->c2x_auto_p))\n     {\n-      if (decl_context == PARM && storage_class == csc_register)\n+      if (decl_context == PARM\n+\t  && storage_class == csc_register\n+\t  && !declspecs->c2x_auto_p)\n \t;\n       else\n \t{\n@@ -8428,6 +8513,9 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name,\n \n   pushtag (loc, name, ref);\n   decl_attributes (&ref, attrs, (int) ATTR_FLAG_TYPE_IN_PLACE);\n+  if (in_underspecified_init)\n+    error_at (loc, \"%qT declared in underspecified object initializer\",\n+\t      ref);\n \n   ret.spec = ref;\n   return ret;\n@@ -8523,6 +8611,9 @@ start_struct (location_t loc, enum tree_code code, tree name,\n \t\t ? \"sizeof\"\n \t\t : (in_typeof ? \"typeof\" : \"alignof\")));\n \n+  if (in_underspecified_init)\n+    error_at (loc, \"%qT defined in underspecified object initializer\", ref);\n+\n   return ref;\n }\n \n@@ -9433,6 +9524,10 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name,\n \t\t ? \"sizeof\"\n \t\t : (in_typeof ? \"typeof\" : \"alignof\")));\n \n+  if (in_underspecified_init)\n+    error_at (loc, \"%qT defined in underspecified object initializer\",\n+\t      enumtype);\n+\n   return enumtype;\n }\n \n@@ -11261,6 +11356,20 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n   if (TREE_UNAVAILABLE (type))\n     specs->unavailable_p = true;\n \n+  /* As a type specifier is present, \"auto\" must be used as a storage\n+     class specifier, not for type deduction.  */\n+  if (specs->c2x_auto_p)\n+    {\n+      specs->c2x_auto_p = false;\n+      if (specs->storage_class != csc_none)\n+\terror (\"multiple storage classes in declaration specifiers\");\n+      else if (specs->thread_p)\n+\terror (\"%qs used with %<auto%>\",\n+\t       specs->thread_gnu_p ? \"__thread\" : \"_Thread_local\");\n+      else\n+\tspecs->storage_class = csc_auto;\n+    }\n+\n   /* Handle type specifier keywords.  */\n   if (TREE_CODE (type) == IDENTIFIER_NODE\n       && C_IS_RESERVED_WORD (type)\n@@ -12179,6 +12288,16 @@ declspecs_add_scspec (location_t loc,\n \t}\n       break;\n     case RID_AUTO:\n+      if (flag_isoc2x\n+\t  && specs->typespec_kind == ctsk_none\n+\t  && specs->storage_class != csc_typedef)\n+\t{\n+\t  /* \"auto\" potentially used for type deduction.  */\n+\t  if (specs->c2x_auto_p)\n+\t    error (\"duplicate %qE\", scspec);\n+\t  specs->c2x_auto_p = true;\n+\t  return specs;\n+\t}\n       n = csc_auto;\n       break;\n     case RID_EXTERN:\n@@ -12198,6 +12317,11 @@ declspecs_add_scspec (location_t loc,\n       break;\n     case RID_TYPEDEF:\n       n = csc_typedef;\n+      if (specs->c2x_auto_p)\n+\t{\n+\t  error (\"%<typedef%> used with %<auto%>\");\n+\t  specs->c2x_auto_p = false;\n+\t}\n       break;\n     default:\n       gcc_unreachable ();\n@@ -12284,7 +12408,7 @@ finish_declspecs (struct c_declspecs *specs)\n     {\n       gcc_assert (!specs->long_p && !specs->long_long_p && !specs->short_p\n \t\t  && !specs->signed_p && !specs->unsigned_p\n-\t\t  && !specs->complex_p);\n+\t\t  && !specs->complex_p && !specs->c2x_auto_p);\n \n       /* Set a dummy type.  */\n       if (TREE_CODE (specs->type) == ERROR_MARK)\n@@ -12320,6 +12444,18 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t   \"ISO C does not support plain %<complex%> meaning \"\n \t\t   \"%<double complex%>\");\n \t}\n+      else if (specs->c2x_auto_p)\n+\t{\n+\t  /* Type to be filled in later, including applying postfix\n+\t     attributes.  This warning only actually appears for\n+\t     -Wc11-c2x-compat in C2X mode; in older modes, there may\n+\t     be a warning or pedwarn for implicit \"int\" instead, or\n+\t     other errors for use of auto at file scope.  */\n+\t  pedwarn_c11 (input_location, OPT_Wpedantic,\n+\t\t       \"ISO C does not support %<auto%> type deduction \"\n+\t\t       \"before C2X\");\n+\t  return specs;\n+\t}\n       else\n \t{\n \t  specs->typespec_word = cts_int;\n@@ -12336,6 +12472,7 @@ finish_declspecs (struct c_declspecs *specs)\n   specs->explicit_signed_p = specs->signed_p;\n \n   /* Now compute the actual type.  */\n+  gcc_assert (!specs->c2x_auto_p);\n   switch (specs->typespec_word)\n     {\n     case cts_auto_type:"}, {"sha": "d70697b1d634f923ead8b75c8fdbfbfc930d0170", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -2103,7 +2103,11 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n     }\n \n   finish_declspecs (specs);\n-  bool auto_type_p = specs->typespec_word == cts_auto_type;\n+  bool gnu_auto_type_p = specs->typespec_word == cts_auto_type;\n+  bool std_auto_type_p = specs->c2x_auto_p;\n+  bool any_auto_type_p = gnu_auto_type_p || std_auto_type_p;\n+  gcc_assert (!(gnu_auto_type_p && std_auto_type_p));\n+  const char *auto_type_keyword = gnu_auto_type_p ? \"__auto_type\" : \"auto\";\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n       bool handled_assume = false;\n@@ -2114,8 +2118,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  specs->attrs\n \t    = handle_assume_attribute (here, specs->attrs, nested);\n \t}\n-      if (auto_type_p)\n-\terror_at (here, \"%<__auto_type%> in empty declaration\");\n+      if (any_auto_type_p)\n+\terror_at (here, \"%qs in empty declaration\", auto_type_keyword);\n       else if (specs->typespec_kind == ctsk_none\n \t       && attribute_fallthrough_p (specs->attrs))\n \t{\n@@ -2159,7 +2163,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       shadow_tag_warned (specs, 1);\n       return;\n     }\n-  else if (c_dialect_objc () && !auto_type_p)\n+  else if (c_dialect_objc () && !any_auto_type_p)\n     {\n       /* Prefix attributes are an error on method decls.  */\n       switch (c_parser_peek_token (parser)->type)\n@@ -2253,6 +2257,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       bool dummy = false;\n       timevar_id_t tv;\n       tree fnbody = NULL_TREE;\n+      tree std_auto_name = NULL_TREE;\n       /* Declaring either one or more declarators (in which case we\n \t should diagnose if there were no declaration specifiers) or a\n \t function definition (in which case the diagnostic for\n@@ -2270,14 +2275,29 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n \t}\n-      if (auto_type_p && declarator->kind != cdk_id)\n+      if (gnu_auto_type_p && declarator->kind != cdk_id)\n \t{\n \t  error_at (here,\n \t\t    \"%<__auto_type%> requires a plain identifier\"\n \t\t    \" as declarator\");\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n \t}\n+      if (std_auto_type_p)\n+\t{\n+\t  struct c_declarator *d = declarator;\n+\t  while (d->kind == cdk_attrs)\n+\t    d = d->declarator;\n+\t  if (d->kind != cdk_id)\n+\t    {\n+\t      error_at (here,\n+\t\t\t\"%<auto%> requires a plain identifier, possibly with\"\n+\t\t\t\" attributes, as declarator\");\n+\t      c_parser_skip_to_end_of_block_or_statement (parser);\n+\t      return;\n+\t    }\n+\t  std_auto_name = d->u.id.id;\n+\t}\n       if (c_parser_next_token_is (parser, CPP_EQ)\n \t  || c_parser_next_token_is (parser, CPP_COMMA)\n \t  || c_parser_next_token_is (parser, CPP_SEMICOLON)\n@@ -2317,19 +2337,37 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      struct c_expr init;\n \t      location_t init_loc;\n \t      c_parser_consume_token (parser);\n-\t      if (auto_type_p)\n+\t      if (any_auto_type_p)\n \t\t{\n \t\t  init_loc = c_parser_peek_token (parser)->location;\n \t\t  rich_location richloc (line_table, init_loc);\n+\t\t  unsigned int underspec_state = 0;\n+\t\t  if (std_auto_type_p)\n+\t\t    underspec_state = start_underspecified_init (init_loc,\n+\t\t\t\t\t\t\t\t std_auto_name);\n \t\t  start_init (NULL_TREE, asm_name, global_bindings_p (), &richloc);\n \t\t  /* A parameter is initialized, which is invalid.  Don't\n \t\t     attempt to instrument the initializer.  */\n \t\t  int flag_sanitize_save = flag_sanitize;\n \t\t  if (nested && !empty_ok)\n \t\t    flag_sanitize = 0;\n-\t\t  init = c_parser_expr_no_commas (parser, NULL);\n+\t\t  if (std_auto_type_p\n+\t\t      && c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n+\t\t    {\n+\t\t      matching_braces braces;\n+\t\t      braces.consume_open (parser);\n+\t\t      init = c_parser_expr_no_commas (parser, NULL);\n+\t\t      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t\tc_parser_consume_token (parser);\n+\t\t      braces.skip_until_found_close (parser);\n+\t\t    }\n+\t\t  else\n+\t\t    init = c_parser_expr_no_commas (parser, NULL);\n+\t\t  if (std_auto_type_p)\n+\t\t    finish_underspecified_init (std_auto_name, underspec_state);\n \t\t  flag_sanitize = flag_sanitize_save;\n-\t\t  if (TREE_CODE (init.value) == COMPONENT_REF\n+\t\t  if (gnu_auto_type_p\n+\t\t      && TREE_CODE (init.value) == COMPONENT_REF\n \t\t      && DECL_C_BIT_FIELD (TREE_OPERAND (init.value, 1)))\n \t\t    error_at (here,\n \t\t\t      \"%<__auto_type%> used with a bit-field\"\n@@ -2345,6 +2383,16 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  specs->locations[cdw_typedef] = init_loc;\n \t\t  specs->typedef_p = true;\n \t\t  specs->type = init_type;\n+\t\t  if (specs->postfix_attrs)\n+\t\t    {\n+\t\t      /* Postfix [[]] attributes are valid with C2X\n+\t\t\t auto, although not with __auto_type, and\n+\t\t\t modify the type given by the initializer.  */\n+\t\t      specs->postfix_attrs =\n+\t\t\tc_warn_type_attributes (specs->postfix_attrs);\n+\t\t      decl_attributes (&specs->type, specs->postfix_attrs, 0);\n+\t\t      specs->postfix_attrs = NULL_TREE;\n+\t\t    }\n \t\t  if (vm_type)\n \t\t    {\n \t\t      bool maybe_const = true;\n@@ -2400,11 +2448,11 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    }\n \t  else\n \t    {\n-\t      if (auto_type_p)\n+\t      if (any_auto_type_p)\n \t\t{\n \t\t  error_at (here,\n-\t\t\t    \"%<__auto_type%> requires an initialized \"\n-\t\t\t    \"data declaration\");\n+\t\t\t    \"%qs requires an initialized data declaration\",\n+\t\t\t    auto_type_keyword);\n \t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t\t  return;\n \t\t}\n@@ -2492,11 +2540,11 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n-\t      if (auto_type_p)\n+\t      if (any_auto_type_p)\n \t\t{\n \t\t  error_at (here,\n-\t\t\t    \"%<__auto_type%> may only be used with\"\n-\t\t\t    \" a single declarator\");\n+\t\t\t    \"%qs may only be used with a single declarator\",\n+\t\t\t    auto_type_keyword);\n \t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t\t  return;\n \t\t}\n@@ -2529,10 +2577,11 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      return;\n \t    }\n \t}\n-      else if (auto_type_p)\n+      else if (any_auto_type_p)\n \t{\n \t  error_at (here,\n-\t\t    \"%<__auto_type%> requires an initialized data declaration\");\n+\t\t    \"%qs requires an initialized data declaration\",\n+\t\t    auto_type_keyword);\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n \t}"}, {"sha": "8116e5cc984049df21ef0e830a093a824b43f32f", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -100,6 +100,10 @@ along with GCC; see the file COPYING3.  If not see\n #define C_DECL_COMPOUND_LITERAL_P(DECL) \\\n   DECL_LANG_FLAG_5 (VAR_DECL_CHECK (DECL))\n \n+/* Set on decls used as placeholders for a C2x underspecified object\n+   definition.  */\n+#define C_DECL_UNDERSPECIFIED(DECL) DECL_LANG_FLAG_7 (DECL)\n+\n /* Nonzero for a decl which either doesn't exist or isn't a prototype.\n    N.B. Could be simplified if all built-in decls had complete prototypes\n    (but this is presently difficult because some of them need FILE*).  */\n@@ -430,6 +434,11 @@ struct c_declspecs {\n      enum-type-specifier;\", but such an empty declaration is valid in\n      C2x when \"enum identifier;\" would not be).  */\n   BOOL_BITFIELD enum_type_specifier_ref_p : 1;\n+  /* Whether \"auto\" was specified in C2X (or later) mode and means the\n+     type is to be deduced from an initializer, or would mean that if\n+     no type specifier appears later in these declaration\n+     specifiers.  */\n+  BOOL_BITFIELD c2x_auto_p : 1;\n   /* The address space that the declaration belongs to.  */\n   addr_space_t address_space;\n };\n@@ -592,6 +601,8 @@ extern bool switch_statement_break_seen_p;\n \n extern bool global_bindings_p (void);\n extern tree pushdecl (tree);\n+extern unsigned int start_underspecified_init (location_t, tree);\n+extern void finish_underspecified_init (tree, unsigned int);\n extern void push_scope (void);\n extern tree pop_scope (void);\n extern void c_bindings_start_stmt_expr (struct c_spot_bindings *);"}, {"sha": "636098444b48fd0a45bd5cb75805c4050b7104b7", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -2861,6 +2861,9 @@ build_external_ref (location_t loc, tree id, bool fun, tree *type)\n     {\n       ref = decl;\n       *type = TREE_TYPE (ref);\n+      if (DECL_P (decl) && C_DECL_UNDERSPECIFIED (decl))\n+\terror_at (loc, \"underspecified %qD referenced in its initializer\",\n+\t\t  decl);\n     }\n   else if (fun)\n     /* Implicit function declaration.  */"}, {"sha": "f8460fb3bfb6c1d072a8e46c4fd10aba5f31d5ff", "filename": "gcc/testsuite/gcc.dg/c2x-auto-1.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-1.c?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -0,0 +1,81 @@\n+/* Test C2x auto.  Valid code, compilation tests.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+auto i = 1;\n+extern int i;\n+static auto l = { 0L };\n+extern long l;\n+extern auto const d = 0.0; /* { dg-warning \"initialized and declared 'extern'\" } */\n+extern const double d;\n+double dx;\n+auto ((i2)) = 3;\n+extern int i2;\n+const auto i3 [[]] = { 4, };\n+extern int i4;\n+thread_local auto f = 1.0f;\n+float ff;\n+extern typeof (f) ff;\n+auto h = (short) 0;\n+extern short h;\n+\n+struct s { int a; };\n+struct s sv;\n+struct s2;\n+enum e : int;\n+\n+extern const volatile long double cvld;\n+extern void (*tfp) (void);\n+\n+int a[10];\n+int *ap;\n+\n+typedef int ti;\n+\n+void\n+tf ()\n+{\n+  auto asv = (struct s) { 0 };\n+  extern typeof (asv) sv;\n+  auto s2p = (struct s2 *) 0;\n+  struct s3;\n+  auto s3p = (struct s3 *) 0;\n+  auto ev = (enum e) 0;\n+  static const auto volatile acvld = 0.5L;\n+  extern typeof (acvld) cvld;\n+  /* lvalue conversion occurs on the initializer, so losing qualifiers.  */\n+  auto ncd = d;\n+  extern typeof (ncd) dx;\n+  _Atomic double ad = 0.0;\n+  auto nad = ad;\n+  extern typeof (nad) dx;\n+  /* Function-to-pointer conversion occurs on the initializer.  */\n+  auto fp = tf;\n+  extern typeof (fp) tfp;\n+  /* Array-to-pointer conversion occurs on the initializer.  */\n+  auto aap = a;\n+  extern typeof (aap) ap;\n+  /* Shadowing a declaration from a containing scope is OK.  */\n+  auto i = 2L;\n+  extern typeof (i) l;\n+  /* auto can be used in for loops.  */\n+  for (auto ix = 2; ix < 10; ix++)\n+    {\n+      extern typeof (ix) i2;\n+    }\n+  /* auto is valid with bit-field initializers; the choice of type those have\n+     in expressions is unspecified but should match how _Generic handles such\n+     expressions.  */\n+  struct b { int a : 2; unsigned b : 3; } bv = { };\n+  auto bfa = bv.a;\n+  auto bfb = bv.b;\n+  static_assert (_Generic (bv.a, typeof (bfa) : 1, default : 2) == 1);\n+  static_assert (_Generic (bv.b, typeof (bfb) : 1, default : 2) == 1);\n+  /* The traditional meaning of auto with a type specifier is OK.  */\n+  auto short s;\n+  char auto c;\n+  auto struct t { int x; } t;\n+  /* That includes the case where the type comes from a typedef name.  */\n+  auto ti int_from_typedef = 3.0;\n+  extern typeof (int_from_typedef) i2;\n+}"}, {"sha": "a41f813018c79bf6d3c353dcb1a90131696ade30", "filename": "gcc/testsuite/gcc.dg/c2x-auto-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-2.c?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -0,0 +1,38 @@\n+/* Test C2x auto.  Valid code, execution tests.  Based on auto-type-1.c.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+/* { dg-require-effective-target alloca } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+auto i = 1;\n+extern int i;\n+auto c = (char) 1;\n+extern char c;\n+static auto u = 10U;\n+extern unsigned int u;\n+const auto ll = 1LL;\n+extern const long long ll;\n+\n+int\n+main (void)\n+{\n+  if (i != 1 || c != 1 || u != 10U)\n+    abort ();\n+  auto ai = i;\n+  int *aip = &ai;\n+  if (ai != 1)\n+    abort ();\n+  auto p = (int (*) [++i]) 0;\n+  if (i != 2)\n+    abort ();\n+  if (sizeof (*p) != 2 * sizeof (int))\n+    abort ();\n+  int vla[u][u];\n+  int (*vp)[u] = &vla[0];\n+  auto vpp = ++vp;\n+  if (vp != &vla[1])\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "a34ce31f6be75ef7e5a22eb1c3ef04b025aacb4a", "filename": "gcc/testsuite/gcc.dg/c2x-auto-3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-3.c?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -0,0 +1,64 @@\n+/* Test C2x auto.  Invalid code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+auto; /* { dg-error \"empty declaration\" } */\n+auto *p = (int *) 0; /* { dg-error \"plain identifier\" } */\n+auto i; /* { dg-error \"initialized data declaration\" } */\n+auto g { } /* { dg-error \"initialized data declaration\" } */\n+auto a = 1, b = 2; /* { dg-error \"single declarator\" } */\n+auto long e0 = 0; /* { dg-error \"file-scope declaration\" } */\n+long auto e1 = 0; /* { dg-error \"file-scope declaration\" } */\n+int auto e2 = 0; /* { dg-error \"file-scope declaration\" } */\n+\n+extern int e3;\n+auto e3 = 1; /* { dg-error \"underspecified declaration of 'e3', which is already declared in this scope\" } */\n+\n+void\n+f ()\n+{\n+  extern int fe1;\n+  auto fe1 = 1; /* { dg-error \"underspecified declaration of 'fe1', which is already declared in this scope\" } */\n+  /* { dg-error \"declaration of 'fe1' with no linkage follows extern declaration\" \"linkage error\" { target *-*-* } .-1 } */\n+  auto fe2 = (struct s *) 0; /* { dg-error \"declared in underspecified object initializer\" } */\n+  auto fe3 = (union u *) 0; /* { dg-error \"declared in underspecified object initializer\" } */\n+  auto fe4 = (struct s2 { int a; }) { }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  auto fe5 = (struct { int a; }) { }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  auto fe6 = (union u2 { int a; }) { }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  auto fe7 = (union { int a; }) { }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  auto fe8 = sizeof (enum e { A }); /* { dg-error \"defined in underspecified object initializer\" } */\n+  /* The following case is undefined behavior (so doesn't actually require a\n+     diagnostic).  */\n+  auto fe9 = sizeof (enum { B }); /* { dg-error \"defined in underspecified object initializer\" } */\n+  /* Examples with a forward declaration, then definition inside auto.  */\n+  struct s3;\n+  auto fe10 = (struct s3 { int a; }) { }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  union u3;\n+  auto fe11 = (union u3 { int a; }) { }; /* { dg-error \"defined in underspecified object initializer\" } */\n+}\n+\n+void f2 (auto x); /* { dg-error \"storage class specified for parameter\" } */\n+void f3 (auto y) { } /* { dg-error \"storage class specified for parameter\" } */\n+\n+auto e4 = sizeof (e4); /* { dg-error \"underspecified 'e4' referenced in its initializer\" } */\n+__SIZE_TYPE__ e5;\n+void\n+f4 ()\n+{\n+  auto e5 = sizeof (e5); /* { dg-error \"underspecified 'e5' referenced in its initializer\" } */\n+}\n+\n+auto typedef int T; /* { dg-error \"'typedef' used with 'auto'\" } */\n+auto auto e6 = 1; /* { dg-error \"duplicate 'auto'\" } */\n+static auto int e7 = 1; /* { dg-error \"multiple storage classes in declaration specifiers\" } */\n+_Thread_local auto int e8 = 2; /* { dg-error \"'_Thread_local' used with 'auto'\" } */\n+_Thread_local int auto e9 = 3; /* { dg-error \"'_Thread_local' used with 'auto'\" } */\n+/* { dg-error \"file-scope declaration of 'e9' specifies 'auto'\" \"file-scope error\" { target *-*-* } .-1 } */\n+\n+typedef auto int T2; /* { dg-error \"multiple storage classes in declaration specifiers\" } */\n+\n+void\n+f5 ()\n+{\n+  static int auto e10 = 3; /* { dg-error \"multiple storage classes in declaration specifiers\" } */\n+}"}, {"sha": "3c6cb34710ee74b280e89f5f612fb805b3a20a78", "filename": "gcc/testsuite/gcc.dg/c2x-auto-4.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-auto-4.c?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -0,0 +1,5 @@\n+/* Test C2x auto.  -Wc11-c2x-compat warning.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -Wc11-c2x-compat\" } */\n+\n+auto x = 2; /* { dg-warning \"ISO C does not support 'auto' type deduction before\" } */"}, {"sha": "e0b9e867d6ec5e97d52afd84ffb3ce45912a201e", "filename": "gcc/testsuite/gcc.dg/gnu2x-auto-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-auto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c898e12d0ace542498c9fe975e549b5a6c8acd/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-auto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-auto-1.c?ref=e3c898e12d0ace542498c9fe975e549b5a6c8acd", "patch": "@@ -0,0 +1,11 @@\n+/* Test C2x auto.  Invalid code with GNU extensions.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+void\n+f ()\n+{\n+  /* Do not allow a non-definition declaration of a tag in the auto\n+     initializer, to avoid it escaping an inner scope as shown here.  */\n+  auto x = ({ struct s; struct s *x = 0; x; }); /* { dg-error \"declared in underspecified object initializer\" } */\n+}"}]}