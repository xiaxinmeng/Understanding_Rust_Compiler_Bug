{"sha": "c95430028cde0571e4408ab54b8ce0e8dd469e26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1NDMwMDI4Y2RlMDU3MWU0NDA4YWI1NGI4Y2UwZThkZDQ2OWUyNg==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-06-29T18:01:04Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-29T18:01:04Z"}, "message": "Andrew Vaught <andyv@firstinter.net>\n\n2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\nAndrew Vaught  <andyv@firstinter.net>\n\n* gfortran.h (gfc_gsymbol): New typedef.\n(gfc_gsym_root): New variable.\n(gfc_get_gsymbol, gfc_find_gsym): New prototypes.\n* parse.c (global_used): New function.\n(parse_block_data): Check for double empty BLOCK DATA,\nuse global symbol table.\n(parse_module): Use global symbol table.\n(add_global_procedure, add_global_program): New functions.\n(gfc_parse_file): Use global symbol table.\n* symbol.c (gfc_gsym_root): New variable.\n(gfc_find_gsym, gsym_compare, gfc_get_gsymbol): New\nfunctions.\n\nCo-Authored-By: Andrew Vaught <andyv@firstinter.net>\n\nFrom-SVN: r83868", "tree": {"sha": "e33d1b38d11a8333dffcfecf71694f657a8f5d8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e33d1b38d11a8333dffcfecf71694f657a8f5d8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c95430028cde0571e4408ab54b8ce0e8dd469e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95430028cde0571e4408ab54b8ce0e8dd469e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c95430028cde0571e4408ab54b8ce0e8dd469e26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95430028cde0571e4408ab54b8ce0e8dd469e26/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c5fdae6338380b3dd9d98c9540fb69c242baae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c5fdae6338380b3dd9d98c9540fb69c242baae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c5fdae6338380b3dd9d98c9540fb69c242baae7"}], "stats": {"total": 219, "additions": 219, "deletions": 0}, "files": [{"sha": "b50d944a65a1f19750af3b7ab22ca733ab04897a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c95430028cde0571e4408ab54b8ce0e8dd469e26", "patch": "@@ -1,3 +1,19 @@\n+2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\tAndrew Vaught  <andyv@firstinter.net>\n+\n+\t* gfortran.h (gfc_gsymbol): New typedef.\n+\t(gfc_gsym_root): New variable.\n+\t(gfc_get_gsymbol, gfc_find_gsym): New prototypes.\n+\t* parse.c (global_used): New function.\n+\t(parse_block_data): Check for double empty BLOCK DATA,\n+\tuse global symbol table.\n+\t(parse_module): Use global symbol table.\n+\t(add_global_procedure, add_global_program): New functions.\n+\t(gfc_parse_file): Use global symbol table.\n+\t* symbol.c (gfc_gsym_root): New variable.\n+\t(gfc_find_gsym, gsym_compare, gfc_get_gsymbol): New\n+\tfunctions.\n+\n 2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* module.c (mio_gmp_real): Correct writing of negative numbers."}, {"sha": "bfd52e4b656c24b0fa923afde7d63681bcb583e1", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=c95430028cde0571e4408ab54b8ce0e8dd469e26", "patch": "@@ -720,6 +720,24 @@ gfc_namespace;\n \n extern gfc_namespace *gfc_current_ns;\n \n+/* Global symbols are symbols of global scope. Currently we only use\n+   this to detect collisions already when parsing.\n+   TODO: Extend to verify procedure calls.  */\n+\n+typedef struct gfc_gsymbol\n+{\n+  BBT_HEADER(gfc_gsymbol);\n+\n+  char name[GFC_MAX_SYMBOL_LEN+1];\n+  enum { GSYM_UNKNOWN=1, GSYM_PROGRAM, GSYM_FUNCTION, GSYM_SUBROUTINE,\n+        GSYM_MODULE, GSYM_COMMON, GSYM_BLOCK_DATA } type;\n+\n+  int defined, used;\n+  locus where;\n+}\n+gfc_gsymbol;\n+\n+extern gfc_gsymbol *gfc_gsym_root;\n \n /* Information on interfaces being built.  */\n typedef struct\n@@ -1490,6 +1508,9 @@ void gfc_save_all (gfc_namespace *);\n \n void gfc_symbol_state (void);\n \n+gfc_gsymbol *gfc_get_gsymbol (char *);\n+gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, char *);\n+\n /* intrinsic.c */\n extern int gfc_init_expr;\n "}, {"sha": "812df4d8401e302eeb032886006acb3c7cf5d1e8", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=c95430028cde0571e4408ab54b8ce0e8dd469e26", "patch": "@@ -2319,12 +2319,79 @@ parse_progunit (gfc_statement st)\n }\n \n \n+/* Come here to complain about a global symbol already in use as\n+   something else.  */\n+\n+static void\n+global_used (gfc_gsymbol *sym, locus *where)\n+{\n+  const char *name;\n+\n+  if (where == NULL)\n+    where = &gfc_current_locus;\n+\n+  switch(sym->type)\n+    {\n+    case GSYM_PROGRAM:\n+      name = \"PROGRAM\";\n+      break;\n+    case GSYM_FUNCTION:\n+      name = \"FUNCTION\";\n+      break;\n+    case GSYM_SUBROUTINE:\n+      name = \"SUBROUTINE\";\n+      break;\n+    case GSYM_COMMON:\n+      name = \"COMMON\";\n+      break;\n+    case GSYM_BLOCK_DATA:\n+      name = \"BLOCK DATA\";\n+      break;\n+    case GSYM_MODULE:\n+      name = \"MODULE\";\n+      break;\n+    default:\n+      gfc_internal_error (\"gfc_gsymbol_type(): Bad type\");\n+      name = NULL;\n+    }\n+\n+  gfc_error(\"Global name '%s' at %L is already being used as a %s at %L\",\n+           gfc_new_block->name, where, name, &sym->where);\n+}\n+\n+\n /* Parse a block data program unit.  */\n \n static void\n parse_block_data (void)\n {\n   gfc_statement st;\n+  static locus blank_locus;\n+  static int blank_block=0;\n+  gfc_gsymbol *s;\n+\n+  if (gfc_new_block == NULL)\n+    {\n+      if (blank_block)\n+       gfc_error (\"Blank BLOCK DATA at %C conflicts with \"\n+                  \"prior BLOCK DATA at %L\", &blank_locus);\n+      else\n+       {\n+         blank_block = 1;\n+         blank_locus = gfc_current_locus;\n+       }\n+    }\n+  else\n+    {\n+      s = gfc_get_gsymbol (gfc_new_block->name);\n+      if (s->type != GSYM_UNKNOWN)\n+       global_used(s, NULL);\n+      else\n+       {\n+         s->type = GSYM_BLOCK_DATA;\n+         s->where = gfc_current_locus;\n+       }\n+    }\n \n   st = parse_spec (ST_NONE);\n \n@@ -2344,6 +2411,16 @@ static void\n parse_module (void)\n {\n   gfc_statement st;\n+  gfc_gsymbol *s;\n+\n+  s = gfc_get_gsymbol (gfc_new_block->name);\n+  if (s->type != GSYM_UNKNOWN)\n+    global_used(s, NULL);\n+  else\n+    {\n+      s->type = GSYM_MODULE;\n+      s->where = gfc_current_locus;\n+    }\n \n   st = parse_spec (ST_NONE);\n \n@@ -2372,6 +2449,46 @@ parse_module (void)\n }\n \n \n+/* Add a procedure name to the global symbol table.  */\n+\n+static void\n+add_global_procedure (int sub)\n+{\n+  gfc_gsymbol *s;\n+\n+  s = gfc_get_gsymbol(gfc_new_block->name);\n+\n+  if (s->type != GSYM_UNKNOWN)\n+    global_used(s, NULL);\n+  else\n+    {\n+      s->type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;\n+      s->where = gfc_current_locus;\n+    }\n+}\n+\n+\n+/* Add a program to the global symbol table.  */\n+\n+static void\n+add_global_program (void)\n+{\n+  gfc_gsymbol *s;\n+\n+  if (gfc_new_block == NULL)\n+    return;\n+  s = gfc_get_gsymbol (gfc_new_block->name);\n+\n+  if (s->type != GSYM_UNKNOWN)\n+    global_used(s, NULL);\n+  else\n+    {\n+      s->type = GSYM_PROGRAM;\n+      s->where = gfc_current_locus;\n+    }\n+}\n+\n+\n /* Top level parser.  */\n \n try\n@@ -2415,16 +2532,19 @@ gfc_parse_file (void)\n \n       push_state (&s, COMP_PROGRAM, gfc_new_block);\n       accept_statement (st);\n+      add_global_program ();\n       parse_progunit (ST_NONE);\n       break;\n \n     case ST_SUBROUTINE:\n+      add_global_procedure (1);\n       push_state (&s, COMP_SUBROUTINE, gfc_new_block);\n       accept_statement (st);\n       parse_progunit (ST_NONE);\n       break;\n \n     case ST_FUNCTION:\n+      add_global_procedure (0);\n       push_state (&s, COMP_FUNCTION, gfc_new_block);\n       accept_statement (st);\n       parse_progunit (ST_NONE);"}, {"sha": "4b5f34e6d2d6d4424038690b09f6bbb66b8abe40", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95430028cde0571e4408ab54b8ce0e8dd469e26/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=c95430028cde0571e4408ab54b8ce0e8dd469e26", "patch": "@@ -88,6 +88,8 @@ static int next_dummy_order = 1;\n \n gfc_namespace *gfc_current_ns;\n \n+gfc_gsymbol *gfc_gsym_root = NULL;\n+\n static gfc_symbol *changed_syms = NULL;\n \n \n@@ -2419,3 +2421,63 @@ gfc_symbol_state(void) {\n }\n #endif\n \n+\n+/************** Global symbol handling ************/\n+\n+\n+/* Search a tree for the global symbol.  */\n+\n+gfc_gsymbol *\n+gfc_find_gsymbol (gfc_gsymbol *symbol, char *name)\n+{\n+  gfc_gsymbol *s;\n+\n+  if (symbol == NULL)\n+    return NULL;\n+  if (strcmp (symbol->name, name) == 0)\n+    return symbol;\n+\n+  s = gfc_find_gsymbol (symbol->left, name);\n+  if (s != NULL)\n+    return s;\n+\n+  s = gfc_find_gsymbol (symbol->right, name);\n+  if (s != NULL)\n+    return s;\n+\n+  return NULL;\n+}\n+\n+\n+/* Compare two global symbols. Used for managing the BB tree.  */\n+\n+static int\n+gsym_compare (void * _s1, void * _s2)\n+{\n+  gfc_gsymbol *s1, *s2;\n+\n+  s1 = (gfc_gsymbol *)_s1;\n+  s2 = (gfc_gsymbol *)_s2;\n+  return strcmp(s1->name, s2->name);\n+}\n+\n+\n+/* Get a global symbol, creating it if it doesn't exist.  */\n+\n+gfc_gsymbol *\n+gfc_get_gsymbol (char *name)\n+{\n+  gfc_gsymbol *s;\n+\n+  s = gfc_find_gsymbol (gfc_gsym_root, name);\n+  if (s != NULL)\n+    return s;\n+\n+  s = gfc_getmem (sizeof (gfc_gsymbol));\n+  s->type = GSYM_UNKNOWN;\n+  strcpy (s->name, name);\n+\n+  gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);\n+\n+  return s;\n+}"}]}