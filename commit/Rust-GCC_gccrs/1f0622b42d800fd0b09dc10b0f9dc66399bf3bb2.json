{"sha": "1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYwNjIyYjQyZDgwMGZkMGIwOWRjMTBiMGY5ZGM2NjM5OWJmM2JiMg==", "commit": {"author": {"name": "Silvius Rus", "email": "silvius.rus@gmail.com", "date": "2010-05-11T10:22:18Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-05-11T10:22:18Z"}, "message": "re PR libstdc++/43259 (ext/profile/all.cc fails on Solaris)\n\n2010-05-11  Silvius Rus  <silvius.rus@gmail.com>\n\n\tPR libstdc++/43259\n\t* include/profile/impl/profiler_algos.h: New.\n\t* include/Makefile.am: Add.\n\t* include/Makefile.in: Regenerate.\n\t* include/profile/impl/profiler.h\n\t(_GLIBCXX_PROFILE_DEFINE_UNINIT_DATA): Add.\n\t* include/profile/impl/profiler_trace.h\n\t(__mutex_t, __lock, __unlock): Remove.\n\t(__lock_object_table, __lock_stack_table): Remove. Replace uses with\n\tcalls to __gnu_cxx::__mutex::lock.\n\t(__unlock_object_table, __unlock_stack_table): Remove. Replace uses\n\twith calls to __gnu_cxx::__mutex::unlock.\n\t(__warn, __cost_factor_writer, __cost_factor_setter): Add.\n\t* testsuite/ext/profile/profiler_algos.cc: New.\n\nFrom-SVN: r159268", "tree": {"sha": "e2e1b39eddef02bf2a46b742c88e1282b9c70739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e1b39eddef02bf2a46b742c88e1282b9c70739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/comments", "author": {"login": "silviusrus", "id": 2181423, "node_id": "MDQ6VXNlcjIxODE0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/2181423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/silviusrus", "html_url": "https://github.com/silviusrus", "followers_url": "https://api.github.com/users/silviusrus/followers", "following_url": "https://api.github.com/users/silviusrus/following{/other_user}", "gists_url": "https://api.github.com/users/silviusrus/gists{/gist_id}", "starred_url": "https://api.github.com/users/silviusrus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/silviusrus/subscriptions", "organizations_url": "https://api.github.com/users/silviusrus/orgs", "repos_url": "https://api.github.com/users/silviusrus/repos", "events_url": "https://api.github.com/users/silviusrus/events{/privacy}", "received_events_url": "https://api.github.com/users/silviusrus/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dcda03f4be29b57f1e2527fe06d1e21394bc0785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcda03f4be29b57f1e2527fe06d1e21394bc0785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcda03f4be29b57f1e2527fe06d1e21394bc0785"}], "stats": {"total": 451, "additions": 278, "deletions": 173}, "files": [{"sha": "903f371fa626026d574ed5b246f1b44509d114ab", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "patch": "@@ -1,3 +1,20 @@\n+2010-05-11  Silvius Rus  <silvius.rus@gmail.com>\n+\n+\tPR libstdc++/43259\n+\t* include/profile/impl/profiler_algos.h: New.\n+\t* include/Makefile.am: Add.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/profile/impl/profiler.h\n+\t(_GLIBCXX_PROFILE_DEFINE_UNINIT_DATA): Add.\n+\t* include/profile/impl/profiler_trace.h\n+\t(__mutex_t, __lock, __unlock): Remove.\n+\t(__lock_object_table, __lock_stack_table): Remove. Replace uses with\n+\tcalls to __gnu_cxx::__mutex::lock.\n+\t(__unlock_object_table, __unlock_stack_table): Remove. Replace uses\n+\twith calls to __gnu_cxx::__mutex::unlock.\n+\t(__warn, __cost_factor_writer, __cost_factor_setter): Add.\n+\t* testsuite/ext/profile/profiler_algos.cc: New.\n+\n 2010-05-07  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* libsupc++/exception_ptr.h (make_exception_ptr): Add."}, {"sha": "1ced7813c1ce706917859c8ce12af65cd1f24f99", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "patch": "@@ -800,6 +800,7 @@ profile_impl_srcdir = ${glibcxx_srcdir}/include/profile/impl\n profile_impl_builddir = ./profile/impl\n profile_impl_headers = \\\n \t${profile_impl_srcdir}/profiler.h \\\n+\t${profile_impl_srcdir}/profiler_algos.h \\\n \t${profile_impl_srcdir}/profiler_container_size.h \\\n \t${profile_impl_srcdir}/profiler_hash_func.h \\\n \t${profile_impl_srcdir}/profiler_hashtable_size.h \\"}, {"sha": "fd45a43e9dad784d47173ee882417d0af4540505", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "patch": "@@ -1032,6 +1032,7 @@ profile_impl_srcdir = ${glibcxx_srcdir}/include/profile/impl\n profile_impl_builddir = ./profile/impl\n profile_impl_headers = \\\n \t${profile_impl_srcdir}/profiler.h \\\n+\t${profile_impl_srcdir}/profiler_algos.h \\\n \t${profile_impl_srcdir}/profiler_container_size.h \\\n \t${profile_impl_srcdir}/profiler_hash_func.h \\\n \t${profile_impl_srcdir}/profiler_hashtable_size.h \\"}, {"sha": "07ed50d8e4c76def15fa330df30a9d70da5f113d", "filename": "libstdc++-v3/include/profile/impl/profiler.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h?ref=1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "patch": "@@ -44,6 +44,13 @@\n #endif\n \n // Mechanism to define data with inline linkage.\n+#define _GLIBCXX_PROFILE_DEFINE_UNINIT_DATA(__type, __name)             \\\n+  inline __type&                                                        \\\n+  __get_##__name()                                                      \\\n+  {                                                                     \\\n+    static __type __name;                                               \\\n+    return __name;                                                      \\\n+  }\n #define _GLIBCXX_PROFILE_DEFINE_DATA(__type, __name, __initial_value...) \\\n   inline __type& __get_##__name() {                                      \\\n     static __type __name(__initial_value);                               \\\n@@ -362,11 +369,6 @@ namespace __gnu_profile\n #define __profcxx_map_to_unordered_map_find(__x...)\n #endif\n \n-// Run multithreaded unless instructed not to do so.\n-#ifndef _GLIBCXX_PROFILE_NO_THREADS\n-#define _GLIBCXX_PROFILE_THREADS\n-#endif\n-\n // Set default values for compile-time customizable variables.\n #ifndef _GLIBCXX_PROFILE_TRACE_PATH_ROOT\n #define _GLIBCXX_PROFILE_TRACE_PATH_ROOT \"libstdcxx-profile\"\n@@ -389,7 +391,7 @@ namespace __gnu_profile\n   \"_GLIBCXX_PROFILE_MAX_STACK_DEPTH\"\n #endif\n #ifndef _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC\n-#define _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC 2 << 27\n+#define _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC (1 << 28)\n #endif\n #ifndef _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR\n #define _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR \\"}, {"sha": "d4de43e9ee027750a455dfd213b88b941532a153", "filename": "libstdc++-v3/include/profile/impl/profiler_algos.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_algos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_algos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_algos.h?ref=1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "patch": "@@ -0,0 +1,118 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_algos.h\n+ *  @brief Algorithms used by the profile extension.\n+ *\n+ *  This file is needed to avoid including <algorithm> or <bits/stl_algo.h>.\n+ *  Including those files would result in recursive includes.\n+ *  These implementations are oversimplified.  In general, efficiency may be\n+ *  sacrificed to minimize maintenance overhead.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_PROFILER_ALGOS_H\n+#define _GLIBCXX_PROFILE_PROFILER_ALGOS_H 1\n+\n+namespace __gnu_profile\n+{\n+  /* Helper for __top_n.  Insert in sorted vector, but not beyond Nth elem.  */\n+  template<typename _Container>\n+    void\n+    __insert_top_n(_Container& __output,\n+\t\t   const typename _Container::value_type& __value,\n+\t\t   typename _Container::size_type __n)\n+    {\n+      typename _Container::iterator __it = __output.begin();\n+      typename _Container::size_type __count = 0;\n+\n+      // Skip up to N - 1 elements larger than VALUE.\n+      // XXX: Could do binary search for random iterators.\n+      while (true)\n+\t{\n+\t  if (__count >= __n)\n+\t    // VALUE is not in top N.\n+\t    return;\n+\n+\t  if (__it == __output.end())\n+\t    break;\n+\n+\t  if (*__it < __value)\n+\t    break;\n+\n+\t  ++__it;\n+\t  ++__count;\n+\t}\n+\n+      __output.insert(__it, __value);\n+    }\n+\n+  /* Copy the top N elements in INPUT, sorted in reverse order, to OUTPUT.  */\n+  template<typename _Container>\n+    void\n+    __top_n(const _Container& __input, _Container& __output,\n+\t    typename _Container::size_type __n)\n+    {\n+      __output.clear();\n+      typename _Container::const_iterator __it;\n+      for (__it = __input.begin(); __it != __input.end(); ++__it)\n+\t__insert_top_n(__output, *__it, __n);\n+    }\n+\n+  /* Simplified clone of std::for_each.  */\n+  template<typename _InputIterator, typename _Function>\n+    _Function \n+    __for_each(_InputIterator __first, _InputIterator __last, _Function __f)\n+    {\n+      for (; __first != __last; ++__first)\n+\t__f(*__first);\n+      return __f;\n+    }\n+\n+  /* Simplified clone of std::remove.  */\n+  template<typename _ForwardIterator, typename _Tp>\n+    _ForwardIterator\n+    __remove(_ForwardIterator __first, _ForwardIterator __last,\n+\t     const _Tp& __value)\n+    {\n+      if(__first == __last)\n+\treturn __first;\n+      _ForwardIterator __result = __first;\n+      ++__first;\n+      for(; __first != __last; ++__first)\n+\tif(!(*__first == __value))\n+\t  {\n+\t    *__result = *__first;\n+\t    ++__result;\n+\t  }\n+      return __result;\n+    }\n+} // namespace __gnu_profile\n+\n+#endif /* _GLIBCXX_PROFILE_PROFILER_ALGOS_H */"}, {"sha": "bfa8a6c3b21f0398352b4602ba0b72e63f9e8fac", "filename": "libstdc++-v3/include/profile/impl/profiler_trace.h", "status": "modified", "additions": 133, "deletions": 167, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h?ref=1f0622b42d800fd0b09dc10b0f9dc66399bf3bb2", "patch": "@@ -53,43 +53,31 @@\n #define _GLIBCXX_IMPL_UNORDERED_MAP std::tr1::unordered_map\n #endif\n \n+#include <ext/concurrence.h>\n #include <fstream>\n #include <string>\n #include <utility>\n-#include <bits/stl_heap.h> // for std::make_heap, std::sort_heap\n-\n-#if (defined _GLIBCXX_PROFILE_THREADS) && !(defined _GLIBCXX_HAVE_TLS)\n-#error You do not seem to have TLS support, which is required by the profile \\\n-  mode.  If your program is not multithreaded, recompile with \\\n-  -D_GLIBCXX_PROFILE_NO_THREADS\n-#endif\n-\n-#if defined _GLIBCXX_PROFILE_THREADS && defined _GLIBCXX_HAVE_TLS\n-#include <pthread.h>\n-#endif\n+#include <vector>\n \n+#include \"profile/impl/profiler_algos.h\"\n #include \"profile/impl/profiler_state.h\"\n #include \"profile/impl/profiler_node.h\"\n \n namespace __gnu_profile\n {\n-\n-#if defined _GLIBCXX_PROFILE_THREADS && defined _GLIBCXX_HAVE_TLS\n-#define _GLIBCXX_IMPL_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n-typedef pthread_mutex_t __mutex_t;\n-/** @brief Pthread mutex wrapper.  */\n-_GLIBCXX_PROFILE_DEFINE_DATA(__mutex_t, __global_lock, \n-                             PTHREAD_MUTEX_INITIALIZER);\n-inline void __lock(__mutex_t& __m) { pthread_mutex_lock(&__m); }\n-inline void __unlock(__mutex_t& __m) { pthread_mutex_unlock(&__m); }\n-#else\n-typedef int __mutex_t;\n-/** @brief Mock mutex interface.  */\n-#define _GLIBCXX_IMPL_MUTEX_INITIALIZER 0\n-_GLIBCXX_PROFILE_DEFINE_DATA(__mutex_t, __global_lock, 0);\n-inline void __lock(__mutex_t& __m) {}\n-inline void __unlock(__mutex_t& __m) {}\n-#endif\n+/** @brief Internal environment.  Values can be set one of two ways:\n+    1. In config file \"var = value\".  The default config file path is \n+       libstdcxx-profile.conf.\n+    2. By setting process environment variables.  For instance, in a Bash\n+       shell you can set the unit cost of iterating through a map like this:\n+       export __map_iterate_cost_factor=5.0.\n+    If a value is set both in the input file and through an environment\n+    variable, the environment value takes precedence.  */\n+typedef _GLIBCXX_IMPL_UNORDERED_MAP<std::string, std::string> __env_t;\n+_GLIBCXX_PROFILE_DEFINE_UNINIT_DATA(__env_t, __env);\n+\n+/** @brief Master lock.  */\n+_GLIBCXX_PROFILE_DEFINE_UNINIT_DATA(__gnu_cxx::__mutex, __global_lock);\n \n /** @brief Representation of a warning.  */\n struct __warning_data\n@@ -98,19 +86,15 @@ struct __warning_data\n   __stack_t __context;\n   const char* __warning_id;\n   const char* __warning_message;\n-\n   __warning_data()\n   : __magnitude(0.0), __context(NULL), __warning_id(NULL),\n     __warning_message(NULL) { }\n-\n   __warning_data(float __m, __stack_t __c, const char* __id, \n                  const char* __msg)\n-  : __magnitude(__m), __context(__c), __warning_id(__id),\n+  : __magnitude(__m), __context(__c), __warning_id(__id), \n     __warning_message(__msg) { }\n-\n-  bool\n-  operator>(const struct __warning_data& __other) const\n-  { return __magnitude > __other.__magnitude; }\n+  bool operator<(const struct __warning_data& __other) const\n+  { return __magnitude < __other.__magnitude; }\n };\n \n typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n@@ -228,14 +212,9 @@ class __trace_base\n   void __write(FILE* f);\n   void __collect_warnings(__warning_vector_t& __warnings);\n \n-  void __lock_object_table();\n-  void __lock_stack_table();\n-  void __unlock_object_table();\n-  void __unlock_stack_table();\n-\n  private:\n-  __mutex_t __object_table_lock;\n-  __mutex_t __stack_table_lock;\n+  __gnu_cxx::__mutex __object_table_lock;\n+  __gnu_cxx::__mutex __stack_table_lock;\n   typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t, \n                                       __object_info> __object_table_t;\n   typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info, __stack_hash, \n@@ -253,7 +232,7 @@ void __trace_base<__object_info, __stack_info>::__collect_warnings(\n     __warning_vector_t& __warnings)\n {\n   typename __stack_table_t::iterator __i = __stack_table.begin();\n-  for ( ; __i != __stack_table.end(); ++__i )\n+  for (; __i != __stack_table.end(); ++__i)\n   {\n     __warnings.push_back(__warning_data((*__i).second.__magnitude(), \n                                         (*__i).first, \n@@ -262,30 +241,6 @@ void __trace_base<__object_info, __stack_info>::__collect_warnings(\n   }\n }\n \n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__lock_object_table()\n-{\n-  __lock(this->__object_table_lock);\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__lock_stack_table()\n-{\n-  __lock(this->__stack_table_lock);\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__unlock_object_table()\n-{\n-  __unlock(this->__object_table_lock);\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__unlock_stack_table()\n-{\n-  __unlock(this->__stack_table_lock);\n-}\n-\n template <typename __object_info, typename __stack_info>\n __trace_base<__object_info, __stack_info>::__trace_base()\n {\n@@ -295,7 +250,6 @@ __trace_base<__object_info, __stack_info>::__trace_base()\n   __stack_table.rehash(10000);\n   __stack_table_byte_size = 0;\n   __id = NULL;\n-  __object_table_lock = __stack_table_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n }\n \n template <typename __object_info, typename __stack_info>\n@@ -304,10 +258,10 @@ void __trace_base<__object_info, __stack_info>::__add_object(\n {\n   if (__max_mem() == 0 \n       || __object_table.size() * sizeof(__object_info) <= __max_mem()) {\n-    __lock_object_table();\n+    this->__object_table_lock.lock();\n     __object_table.insert(\n         typename __object_table_t::value_type(__object, __info));\n-    __unlock_object_table();\n+    this->__object_table_lock.unlock();\n   }\n }\n \n@@ -318,14 +272,14 @@ __object_info* __trace_base<__object_info, __stack_info>::__get_object_info(\n   // XXX: Revisit this to see if we can decrease mutex spans.\n   // Without this mutex, the object table could be rehashed during an\n   // insertion on another thread, which could result in a segfault.\n-  __lock_object_table();\n+  this->__object_table_lock.lock();\n   typename __object_table_t::iterator __object_it = \n       __object_table.find(__object);\n   if (__object_it == __object_table.end()){\n-    __unlock_object_table();\n+    this->__object_table_lock.unlock();\n     return NULL;\n   } else {\n-    __unlock_object_table();\n+    this->__object_table_lock.unlock();\n     return &__object_it->second;\n   }\n }\n@@ -334,8 +288,8 @@ template <typename __object_info, typename __stack_info>\n void __trace_base<__object_info, __stack_info>::__retire_object(\n     __object_t __object)\n {\n-  __lock_object_table();\n-  __lock_stack_table();\n+  this->__object_table_lock.lock();\n+  this->__stack_table_lock.lock();\n   typename __object_table_t::iterator __object_it =\n       __object_table.find(__object);\n   if (__object_it != __object_table.end()){\n@@ -358,8 +312,8 @@ void __trace_base<__object_info, __stack_info>::__retire_object(\n     }\n     __object_table.erase(__object);\n   }\n-  __unlock_stack_table();\n-  __unlock_object_table();\n+  this->__object_table_lock.unlock();\n+  this->__stack_table_lock.unlock();\n }\n \n template <typename __object_info, typename __stack_info>\n@@ -408,40 +362,59 @@ inline void __set_max_mem()\n       _GLIBCXX_PROFILE_DATA(_S_max_mem));\n }\n \n-inline int __log_magnitude(float f)\n+inline int __log_magnitude(float __f)\n {\n-  const float log_base = 10.0;\n-  int result = 0;\n-  int sign = 1;\n-  if (f < 0) {\n-    f = -f;\n-    sign = -1;\n+  const float __log_base = 10.0;\n+  int __result = 0;\n+  int __sign = 1;\n+  if (__f < 0) {\n+    __f = -__f;\n+    __sign = -1;\n   }\n-  while (f > log_base) {\n-    ++result;\n-    f /= 10.0;\n+  while (__f > __log_base) {\n+    ++__result;\n+    __f /= 10.0;\n   }\n-  return sign * result;\n+  return __sign * __result;\n }\n \n-inline FILE* __open_output_file(const char* extension)\n+inline FILE* __open_output_file(const char* __extension)\n {\n   // The path is made of _S_trace_file_name + \".\" + extension.\n-  size_t root_len = strlen(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n-  size_t ext_len = strlen(extension);\n-  char* file_name = new char[root_len + 1 + ext_len + 1];\n-  memcpy(file_name, _GLIBCXX_PROFILE_DATA(_S_trace_file_name), root_len);\n-  *(file_name + root_len) = '.';\n-  memcpy(file_name + root_len + 1, extension, ext_len + 1);\n-  FILE* out_file = fopen(file_name, \"w\");\n-  if (out_file) {\n-    return out_file;\n+  size_t __root_len = strlen(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n+  size_t __ext_len = strlen(__extension);\n+  char* __file_name = new char[__root_len + 1 + __ext_len + 1];\n+  memcpy(__file_name, _GLIBCXX_PROFILE_DATA(_S_trace_file_name),\n+\t __root_len);\n+  *(__file_name + __root_len) = '.';\n+  memcpy(__file_name + __root_len + 1, __extension, __ext_len + 1);\n+  FILE* __out_file = fopen(__file_name, \"w\");\n+  if (__out_file) {\n+    return __out_file;\n   } else {\n-    fprintf(stderr, \"Could not open trace file '%s'.\\n\", file_name);\n+    fprintf(stderr, \"Could not open trace file '%s'.\\n\", __file_name);\n     abort();\n   }\n }\n \n+struct __warn\n+{\n+  FILE* __file;\n+  __warn(FILE* __f) { __file = __f; }\n+\n+  void operator() (const __warning_data& __info)\n+    {\n+      fprintf(__file,  __info.__warning_id);\n+      fprintf(__file, \": improvement = %d\",\n+\t      __log_magnitude(__info.__magnitude));\n+      fprintf(__file, \": call stack = \");\n+      __gnu_profile::__write(__file, __info.__context);\n+      fprintf(__file, \": advice = %s\\n\", __info.__warning_message);\n+      free(const_cast<void*>\n+\t   (reinterpret_cast<const void*>(__info.__warning_message)));\n+    }\n+};\n+\n /** @brief Final report method, registered with @b atexit.\n  *\n  * This can also be called directly by user code, including signal handlers.\n@@ -451,9 +424,9 @@ inline FILE* __open_output_file(const char* extension)\n  */\n inline void __report(void)\n {\n-  __lock(_GLIBCXX_PROFILE_DATA(__global_lock));\n+  _GLIBCXX_PROFILE_DATA(__global_lock).lock();\n \n-  __warning_vector_t __warnings;\n+  __warning_vector_t __warnings, __top_warnings;\n \n   FILE* __raw_file = __open_output_file(\"raw\");\n   __trace_vector_size_report(__raw_file, __warnings);\n@@ -465,35 +438,17 @@ inline void __report(void)\n   __trace_map_to_unordered_map_report(__raw_file, __warnings);\n   fclose(__raw_file);\n \n-  // Sort data by magnitude.\n-  // XXX: instead of sorting, should collect only top N for better performance.\n+  // Sort data by magnitude, keeping just top N.\n   size_t __cutoff = __min(_GLIBCXX_PROFILE_DATA(_S_max_warn_count),\n                           __warnings.size());\n-\n-  std::make_heap(__warnings.begin(), __warnings.end(),\n-\t\t std::greater<__warning_vector_t::value_type>());\n-  std::sort_heap(__warnings.begin(), __warnings.end(),\n-\t\t std::greater<__warning_vector_t::value_type>());\n-  __warnings.resize(__cutoff);\n+  __top_n(__warnings, __top_warnings, __cutoff);\n \n   FILE* __warn_file = __open_output_file(\"txt\");\n-\n-  for (__warning_vector_t::iterator __it = __warnings.begin();\n-       __it != __warnings.end(); ++__it)\n-    {\n-      fprintf(__warn_file,  __it->__warning_id);\n-      fprintf(__warn_file, \": improvement = %d\",\n-\t      __log_magnitude(__it->__magnitude));\n-      fprintf(__warn_file, \": call stack = \");\n-      __gnu_profile::__write(__warn_file, __it->__context);\n-      fprintf(__warn_file, \": advice = %s\\n\", __it->__warning_message);\n-      free(const_cast<void*>(reinterpret_cast<const void*>\n-\t\t\t     (__it->__warning_message)));\n-    }\n-\n+  __for_each(__top_warnings.begin(), __top_warnings.end(),\n+             __warn(__warn_file));\n   fclose(__warn_file);\n \n-  __unlock(_GLIBCXX_PROFILE_DATA(__global_lock));\n+  _GLIBCXX_PROFILE_DATA(__global_lock).unlock();\n }\n \n inline void __set_trace_path()\n@@ -519,7 +474,8 @@ inline void __set_max_warn_count()\n   }\n }\n \n-inline void __read_cost_factors()\n+inline void\n+__read_cost_factors()\n {\n   std::string __conf_file_name(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n   __conf_file_name += \".conf\";\n@@ -530,52 +486,66 @@ inline void __read_cost_factors()\n     {\n       std::string __line;\n \n-      while (getline(__conf_file, __line))\n+      while (std::getline(__conf_file, __line))\n \t{\n \t  std::string::size_type __i = __line.find_first_not_of(\" \\t\\n\\v\");\n \n-\t  if (__line.length() <= 0 || __line[__i] == '#') {\n+\t  if (__line.length() <= 0 || __line[__i] == '#')\n \t    // Skip empty lines or comments.\n \t    continue;\n-\t  }\n-\n-\t  // Trim.\n-\t  if (__line.begin() != __line.end())\n-\t    {\n-\t      // A simple remove operation.\n-\t      std::string::iterator __first = __line.begin();\n-\t      std::string::iterator __result = __first;\n-\t      ++__first;\n-\t      for(; __first != __line.end(); ++__first)\n-\t\tif(!(*__first == ' '))\n-\t\t  {\n-\t\t    *__result = *__first;\n-\t\t    ++__result;\n-\t\t  }\n-\t      __line.erase(__result, __line.end());\n-\t    }\n-\t  std::string::size_type __pos = __line.find(\"=\");\n-\t  std::string __factor_name = __line.substr(0, __pos);\n-\t  std::string::size_type __end = __line.find_first_of(\";\\n\");\n-\t  std::string __factor_value = __line.substr(__pos + 1, __end - __pos);\n-\n-\t  setenv(__factor_name.c_str(), __factor_value.c_str(), 0);\n-\t}\n+        }\n+\n+      // Trim.\n+      __line.erase(__remove(__line.begin(), __line.end(), ' '), __line.end());\n+      std::string::size_type __pos = __line.find(\"=\");\n+      std::string __factor_name = __line.substr(0, __pos);\n+      std::string::size_type __end = __line.find_first_of(\";\\n\");\n+      std::string __factor_value = __line.substr(__pos + 1, __end - __pos);\n+\n+      _GLIBCXX_PROFILE_DATA(__env)[__factor_name] = __factor_value;\n     }\n }\n \n-inline void __write_cost_factors()\n+struct __cost_factor_writer\n {\n-  FILE* __file = __open_output_file(\"conf.out\");\n-\n-  for (__decltype(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin()) __it\n-\t = _GLIBCXX_PROFILE_DATA(__cost_factors)->begin();\n-       __it != _GLIBCXX_PROFILE_DATA(__cost_factors)->end(); ++__it)\n-    fprintf(__file, \"%s = %f\\n\", (*__it)->__env_var, (*__it)->__value);\n+  FILE* __file;\n+  __cost_factor_writer(FILE* __f) : __file(__f) {}\n+  void\n+  operator() (const __cost_factor* __factor)\n+  { fprintf(__file, \"%s = %f\\n\", __factor->__env_var, __factor->__value); }\n+};\n \n+inline void\n+__write_cost_factors()\n+{\n+  FILE* __file = __open_output_file(\"conf.out\");\n+  __for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),\n+             _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),\n+             __cost_factor_writer(__file));\n   fclose(__file);\n }\n \n+struct __cost_factor_setter\n+{\n+  void operator() (__cost_factor* __factor)\n+    {\n+      // Look it up in the process environment first.\n+      const char* __env_value = getenv(__factor->__env_var);\n+\n+      if (!__env_value)\n+        {\n+          // Look it up in the config file.\n+          __env_t::iterator it = _GLIBCXX_PROFILE_DATA(__env).find(\n+              __factor->__env_var);\n+          if (it != _GLIBCXX_PROFILE_DATA(__env).end())\n+            __env_value = (*it).second.c_str();\n+        }\n+\n+      if (__env_value)\n+        __factor->__value = atof(__env_value);\n+    }\n+};\n+\n inline void __set_cost_factors()\n {\n   _GLIBCXX_PROFILE_DATA(__cost_factors) = new __cost_factor_vector;\n@@ -607,18 +577,14 @@ inline void __set_cost_factors()\n       &_GLIBCXX_PROFILE_DATA(__umap_find_cost_factor));\n   _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n       &_GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor));\n-\n-  \n-  for (__decltype(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin()) __it\n-\t = _GLIBCXX_PROFILE_DATA(__cost_factors)->begin();\n-       __it != _GLIBCXX_PROFILE_DATA(__cost_factors)->end(); ++__it)\n-    if (char* __env_cost_factor = getenv((*__it)->__env_var))\n-      (*__it)->__value = atof(__env_cost_factor);\n+  __for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),\n+             _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),\n+             __cost_factor_setter());\n }\n \n inline void __profcxx_init_unconditional()\n {\n-  __lock(_GLIBCXX_PROFILE_DATA(__global_lock));\n+  _GLIBCXX_PROFILE_DATA(__global_lock).lock();\n \n   if (__is_invalid()) {\n \n@@ -652,7 +618,7 @@ inline void __profcxx_init_unconditional()\n     }\n   }\n \n-  __unlock(_GLIBCXX_PROFILE_DATA(__global_lock));\n+  _GLIBCXX_PROFILE_DATA(__global_lock).unlock();\n }\n \n /** @brief This function must be called by each instrumentation point."}]}