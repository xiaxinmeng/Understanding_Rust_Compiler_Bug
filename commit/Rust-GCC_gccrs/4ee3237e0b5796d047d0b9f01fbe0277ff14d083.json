{"sha": "4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVlMzIzN2UwYjU3OTZkMDQ3ZDBiOWYwMWZiZTAyNzdmZjE0ZDA4Mw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael.morin@sfr.fr", "date": "2011-08-18T21:39:42Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-08-18T21:39:42Z"}, "message": "re PR fortran/50071 (gfortran does not distinguish labels in different type scoping units)\n\n2011-08-18  Mikael Morin  <mikael.morin@sfr.fr>\n\n\tPR fortran/50071\n\t* symbol.c (gfc_get_st_label): Use the derived type namespace when\n\twe are parsing a derived type definition.\n\n2011-08-18  Mikael Morin  <mikael.morin@sfr.fr>\n\n\tPR fortran/50071\n\t* gfortran.dg/duplicate_labels_2.f: New test.\n\nFrom-SVN: r177882", "tree": {"sha": "feabc159e1ce25b8141bef017a5b572e13771166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feabc159e1ce25b8141bef017a5b572e13771166"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/comments", "author": null, "committer": null, "parents": [{"sha": "bbceee64bef15b92b1f9b964b8d371bd07ea794a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbceee64bef15b92b1f9b964b8d371bd07ea794a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbceee64bef15b92b1f9b964b8d371bd07ea794a"}], "stats": {"total": 51, "additions": 46, "deletions": 5}, "files": [{"sha": "85538ee50f59396daaa1fdcb8b92461c0f5d3e4e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "patch": "@@ -1,3 +1,9 @@\n+2011-08-18  Mikael Morin  <mikael.morin@sfr.fr>\n+\n+\tPR fortran/50071\n+\t* symbol.c (gfc_get_st_label): Use the derived type namespace when\n+\twe are parsing a derived type definition.\n+\n 2011-08-18  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "446346029ca5a99a508679f854f35d847823c4b4", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "patch": "@@ -2127,11 +2127,16 @@ gfc_get_st_label (int labelno)\n   gfc_st_label *lp;\n   gfc_namespace *ns;\n \n-  /* Find the namespace of the scoping unit:\n-     If we're in a BLOCK construct, jump to the parent namespace.  */\n-  ns = gfc_current_ns;\n-  while (ns->proc_name && ns->proc_name->attr.flavor == FL_LABEL)\n-    ns = ns->parent;\n+  if (gfc_current_state () == COMP_DERIVED)\n+    ns = gfc_current_block ()->f2k_derived;\n+  else\n+    {\n+      /* Find the namespace of the scoping unit:\n+\t If we're in a BLOCK construct, jump to the parent namespace.  */\n+      ns = gfc_current_ns;\n+      while (ns->proc_name && ns->proc_name->attr.flavor == FL_LABEL)\n+\tns = ns->parent;\n+    }\n \n   /* First see if the label is already in this namespace.  */\n   lp = ns->st_labels;"}, {"sha": "150c1e55d86399d8e0b2bcf968af40adafd56072", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "patch": "@@ -1,3 +1,8 @@\n+2011-08-18  Mikael Morin  <mikael.morin@sfr.fr>\n+\n+\tPR fortran/50071\n+\t* gfortran.dg/duplicate_labels_2.f: New test.\n+\n 2011-08-18  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c1x-noreturn-1.c, gcc.dg/c1x-noreturn-2.c,"}, {"sha": "8a3692dd688c7929193bea1e244c015147077bfc", "filename": "gcc/testsuite/gfortran.dg/duplicate_labels_2.f", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ftestsuite%2Fgfortran.dg%2Fduplicate_labels_2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee3237e0b5796d047d0b9f01fbe0277ff14d083/gcc%2Ftestsuite%2Fgfortran.dg%2Fduplicate_labels_2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fduplicate_labels_2.f?ref=4ee3237e0b5796d047d0b9f01fbe0277ff14d083", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+!\n+! PR fortran/50071\n+! Duplicate statement labels should not be rejected if they appear in\n+! different scoping units\n+!\n+! Contributed by Vittorio Zecca <zeccav@gmail.com>\n+\n+c gfortran complains about duplicate statement labels\n+c this is a legal program because types have their own scoping units \n+c and you may have same labels in different scoping units,\n+c as you may have same identifiers inside, like G.\n+      type t1\n+1      integer G\n+      end type\n+      type t2\n+1      integer G\n+      end type\n+c this is legal\n+      goto 1\n+      print *,'bad'\n+1     continue\n+      print *,'good'\n+      end\n+"}]}