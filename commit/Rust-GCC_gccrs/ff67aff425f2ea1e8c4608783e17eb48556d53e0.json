{"sha": "ff67aff425f2ea1e8c4608783e17eb48556d53e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2N2FmZjQyNWYyZWExZThjNDYwODc4M2UxN2ViNDg1NTZkNTNlMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-02-13T15:48:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-02-13T15:48:38Z"}, "message": "re PR tree-optimization/84321 (ice in intersect_range_with_nonzero_bits, at tree-vrp.c:213)\n\n2018-02-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/84321\n\t* tree-vrp.c (intersect_range_with_nonzero_bits): Fix VR_ANTI_RANGE\n\thandling.  Also check whether the anti-range contains any values\n\tthat satisfy the mask; switch to a VR_RANGE if not.\n\ngcc/testsuite/\n\tPR tree-optimization/84321\n\t* gcc.dg/pr84321.c: New test.\n\nFrom-SVN: r257629", "tree": {"sha": "5f324b6586bb67d7c7022702e0076b23f29bc7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f324b6586bb67d7c7022702e0076b23f29bc7e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff67aff425f2ea1e8c4608783e17eb48556d53e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff67aff425f2ea1e8c4608783e17eb48556d53e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff67aff425f2ea1e8c4608783e17eb48556d53e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff67aff425f2ea1e8c4608783e17eb48556d53e0/comments", "author": null, "committer": null, "parents": [{"sha": "62e12268e613eff1b267f4c2538f2b7211067ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e12268e613eff1b267f4c2538f2b7211067ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e12268e613eff1b267f4c2538f2b7211067ecc"}], "stats": {"total": 92, "additions": 72, "deletions": 20}, "files": [{"sha": "c582ae17c1cc84a45591bcb8d0f679a11e63fb52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff67aff425f2ea1e8c4608783e17eb48556d53e0", "patch": "@@ -1,3 +1,10 @@\n+2018-02-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/84321\n+\t* tree-vrp.c (intersect_range_with_nonzero_bits): Fix VR_ANTI_RANGE\n+\thandling.  Also check whether the anti-range contains any values\n+\tthat satisfy the mask; switch to a VR_RANGE if not.\n+\n 2018-02-13  Paolo Bonzini <bonzini@gnu.org>\n \n \tPR sanitizer/84340"}, {"sha": "b11f10a6179e3c4facbcc8e35c690adc5c14a2d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff67aff425f2ea1e8c4608783e17eb48556d53e0", "patch": "@@ -1,3 +1,8 @@\n+2018-02-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/84321\n+\t* gcc.dg/pr84321.c: New test.\n+\n 2018-02-13  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/84359"}, {"sha": "8f8186b58f217de5b586895d0e925d9c20eb623d", "filename": "gcc/testsuite/gcc.dg/pr84321.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84321.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84321.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84321.c?ref=ff67aff425f2ea1e8c4608783e17eb48556d53e0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fwrapv\" } */\n+\n+int c;\n+\n+void\n+foo (int *a, int b)\n+{\n+  int e;\n+  if (b == 1)\n+    return;\n+  for (e = 0; e < (b & ~7); e += 8)\n+    ;\n+  for (++e; e < b;)\n+    c = a[e];\n+}"}, {"sha": "625e65b1184c86963f36f0c66a9e56311c99e101", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff67aff425f2ea1e8c4608783e17eb48556d53e0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=ff67aff425f2ea1e8c4608783e17eb48556d53e0", "patch": "@@ -184,37 +184,61 @@ intersect_range_with_nonzero_bits (enum value_range_type vr_type,\n \t\t\t\t   const wide_int &nonzero_bits,\n \t\t\t\t   signop sgn)\n {\n-  if (vr_type == VR_RANGE)\n-    {\n-      *max = wi::round_down_for_mask (*max, nonzero_bits);\n-\n-      /* Check that the range contains at least one valid value.  */\n-      if (wi::gt_p (*min, *max, sgn))\n-\treturn VR_UNDEFINED;\n-\n-      *min = wi::round_up_for_mask (*min, nonzero_bits);\n-      gcc_checking_assert (wi::le_p (*min, *max, sgn));\n-    }\n   if (vr_type == VR_ANTI_RANGE)\n     {\n-      *max = wi::round_up_for_mask (*max, nonzero_bits);\n+      /* The VR_ANTI_RANGE is equivalent to the union of the ranges\n+\t A: [-INF, *MIN) and B: (*MAX, +INF].  First use NONZERO_BITS\n+\t to create an inclusive upper bound for A and an inclusive lower\n+\t bound for B.  */\n+      wide_int a_max = wi::round_down_for_mask (*min - 1, nonzero_bits);\n+      wide_int b_min = wi::round_up_for_mask (*max + 1, nonzero_bits);\n+\n+      /* If the calculation of A_MAX wrapped, A is effectively empty\n+\t and A_MAX is the highest value that satisfies NONZERO_BITS.\n+\t Likewise if the calculation of B_MIN wrapped, B is effectively\n+\t empty and B_MIN is the lowest value that satisfies NONZERO_BITS.  */\n+      bool a_empty = wi::ge_p (a_max, *min, sgn);\n+      bool b_empty = wi::le_p (b_min, *max, sgn);\n+\n+      /* If both A and B are empty, there are no valid values.  */\n+      if (a_empty && b_empty)\n+\treturn VR_UNDEFINED;\n \n-      /* If the calculation wrapped, we now have a VR_RANGE whose\n-\t lower bound is *MAX and whose upper bound is *MIN.  */\n-      if (wi::gt_p (*min, *max, sgn))\n+      /* If exactly one of A or B is empty, return a VR_RANGE for the\n+\t other one.  */\n+      if (a_empty || b_empty)\n \t{\n-\t  std::swap (*min, *max);\n-\t  *max = wi::round_down_for_mask (*max, nonzero_bits);\n+\t  *min = b_min;\n+\t  *max = a_max;\n \t  gcc_checking_assert (wi::le_p (*min, *max, sgn));\n \t  return VR_RANGE;\n \t}\n \n-      *min = wi::round_down_for_mask (*min, nonzero_bits);\n+      /* Update the VR_ANTI_RANGE bounds.  */\n+      *min = a_max + 1;\n+      *max = b_min - 1;\n       gcc_checking_assert (wi::le_p (*min, *max, sgn));\n \n-      /* Check whether we now have an empty set of values.  */\n-      if (*min - 1 == *max)\n+      /* Now check whether the excluded range includes any values that\n+\t satisfy NONZERO_BITS.  If not, switch to a full VR_RANGE.  */\n+      if (wi::round_up_for_mask (*min, nonzero_bits) == b_min)\n+\t{\n+\t  unsigned int precision = min->get_precision ();\n+\t  *min = wi::min_value (precision, sgn);\n+\t  *max = wi::max_value (precision, sgn);\n+\t  vr_type = VR_RANGE;\n+\t}\n+    }\n+  if (vr_type == VR_RANGE)\n+    {\n+      *max = wi::round_down_for_mask (*max, nonzero_bits);\n+\n+      /* Check that the range contains at least one valid value.  */\n+      if (wi::gt_p (*min, *max, sgn))\n \treturn VR_UNDEFINED;\n+\n+      *min = wi::round_up_for_mask (*min, nonzero_bits);\n+      gcc_checking_assert (wi::le_p (*min, *max, sgn));\n     }\n   return vr_type;\n }"}]}