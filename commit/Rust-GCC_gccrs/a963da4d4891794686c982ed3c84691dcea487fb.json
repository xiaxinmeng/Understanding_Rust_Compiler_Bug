{"sha": "a963da4d4891794686c982ed3c84691dcea487fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk2M2RhNGQ0ODkxNzk0Njg2Yzk4MmVkM2M4NDY5MWRjZWE0ODdmYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-09-19T14:55:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-09-19T14:55:28Z"}, "message": "trans.c (gnat_pushdecl): Do not do anything special for PARM_DECLs.\n\n\t* gcc-interface/trans.c (gnat_pushdecl): Do not do anything special\n\tfor PARM_DECLs.\n\t(end_subprog_body): If the body is a BIND_EXPR, make its associated\n\tblock the top-level one.\n\t(build_function_stub): Build a statement group for the whole function.\n\t* gcc-interface/utils.c (Subprogram_Body_to_gnu): If copy-in/copy-out\n\tis used, create the enclosing block early and process first the OUT\n\tparameters.\n\nFrom-SVN: r164422", "tree": {"sha": "66ba2b935e91e290c60f125c94b6f3a1b96cecfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66ba2b935e91e290c60f125c94b6f3a1b96cecfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a963da4d4891794686c982ed3c84691dcea487fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a963da4d4891794686c982ed3c84691dcea487fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a963da4d4891794686c982ed3c84691dcea487fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a963da4d4891794686c982ed3c84691dcea487fb/comments", "author": null, "committer": null, "parents": [{"sha": "0b1821788cbe452cfa0cd50452e50754542aee3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b1821788cbe452cfa0cd50452e50754542aee3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b1821788cbe452cfa0cd50452e50754542aee3f"}], "stats": {"total": 183, "additions": 99, "deletions": 84}, "files": [{"sha": "4db1391b8a22be2e90d1f8e0411edc37e73685f2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a963da4d4891794686c982ed3c84691dcea487fb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a963da4d4891794686c982ed3c84691dcea487fb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a963da4d4891794686c982ed3c84691dcea487fb", "patch": "@@ -1,3 +1,14 @@\n+2010-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_pushdecl): Do not do anything special\n+\tfor PARM_DECLs.\n+\t(end_subprog_body): If the body is a BIND_EXPR, make its associated\n+\tblock the top-level one.\n+\t(build_function_stub): Build a statement group for the whole function.\n+\t* gcc-interface/utils.c (Subprogram_Body_to_gnu): If copy-in/copy-out\n+\tis used, create the enclosing block early and process first the OUT\n+\tparameters.\n+\n 2010-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Enumeration_Type>: Do"}, {"sha": "7031bfb447c5ae74df980df961ace04133745a95", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a963da4d4891794686c982ed3c84691dcea487fb/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a963da4d4891794686c982ed3c84691dcea487fb/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=a963da4d4891794686c982ed3c84691dcea487fb", "patch": "@@ -2455,40 +2455,48 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   begin_subprog_body (gnu_subprog_decl);\n \n-  /* If there are Out parameters, we need to ensure that the return statement\n-     properly copies them out.  We do this by making a new block and converting\n-     any inner return into a goto to a label at the end of the block.  */\n+  /* If there are In Out or Out parameters, we need to ensure that the return\n+     statement properly copies them out.  We do this by making a new block and\n+     converting any return into a goto to a label at the end of the block.  */\n   gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n-  VEC_safe_push (tree, gc, gnu_return_label_stack,\n-\t\t gnu_cico_list\n-\t\t ? create_artificial_label (input_location)\n-\t\t : NULL_TREE);\n+  if (gnu_cico_list)\n+    {\n+      VEC_safe_push (tree, gc, gnu_return_label_stack,\n+\t\t     create_artificial_label (input_location));\n+\n+      start_stmt_group ();\n+      gnat_pushlevel ();\n+\n+      /* See whether there are parameters for which we don't have a GCC tree\n+\t yet.  These must be Out parameters.  Make a VAR_DECL for them and\n+\t put it into TYPE_CI_CO_LIST, which must contain an empty entry too.\n+\t We can match up the entries because TYPE_CI_CO_LIST is in the order\n+\t of the parameters.  */\n+      for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n+\t   Present (gnat_param);\n+\t   gnat_param = Next_Formal_With_Extras (gnat_param))\n+\tif (!present_gnu_tree (gnat_param))\n+\t  {\n+\t    tree gnu_cico_entry = gnu_cico_list;\n+\n+\t    /* Skip any entries that have been already filled in; they must\n+\t       correspond to In Out parameters.  */\n+\t    while (gnu_cico_entry && TREE_VALUE (gnu_cico_entry))\n+\t      gnu_cico_entry = TREE_CHAIN (gnu_cico_entry);\n+\n+\t    /* Do any needed references for padded types.  */\n+\t    TREE_VALUE (gnu_cico_entry)\n+\t      = convert (TREE_TYPE (TREE_PURPOSE (gnu_cico_entry)),\n+\t\t\t gnat_to_gnu_entity (gnat_param, NULL_TREE, 1));\n+\t  }\n+    }\n+  else\n+    VEC_safe_push (tree, gc, gnu_return_label_stack, NULL_TREE);\n \n   /* Get a tree corresponding to the code for the subprogram.  */\n   start_stmt_group ();\n   gnat_pushlevel ();\n \n-  /* See if there are any parameters for which we don't yet have GCC entities.\n-     These must be for Out parameters for which we will be making VAR_DECL\n-     nodes here.  Fill them in to TYPE_CI_CO_LIST, which must contain the empty\n-     entry as well.  We can match up the entries because TYPE_CI_CO_LIST is in\n-     the order of the parameters.  */\n-  for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n-       Present (gnat_param);\n-       gnat_param = Next_Formal_With_Extras (gnat_param))\n-    if (!present_gnu_tree (gnat_param))\n-      {\n-\t/* Skip any entries that have been already filled in; they must\n-\t   correspond to In Out parameters.  */\n-\twhile (gnu_cico_list && TREE_VALUE (gnu_cico_list))\n-\t  gnu_cico_list = TREE_CHAIN (gnu_cico_list);\n-\n-\t/* Do any needed references for padded types.  */\n-\tTREE_VALUE (gnu_cico_list)\n-\t  = convert (TREE_TYPE (TREE_PURPOSE (gnu_cico_list)),\n-\t\t     gnat_to_gnu_entity (gnat_param, NULL_TREE, 1));\n-      }\n-\n   /* On VMS, establish our condition handler to possibly turn a condition into\n      the corresponding exception if the subprogram has a foreign convention or\n      is exported.\n@@ -2513,6 +2521,40 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   gnat_poplevel ();\n   gnu_result = end_stmt_group ();\n \n+  /* If we are dealing with a return from an Ada procedure with parameters\n+     passed by copy-in/copy-out, we need to return a record containing the\n+     final values of these parameters.  If the list contains only one entry,\n+     return just that entry though.\n+\n+     For a full description of the copy-in/copy-out parameter mechanism, see\n+     the part of the gnat_to_gnu_entity routine dealing with the translation\n+     of subprograms.\n+\n+     We need to make a block that contains the definition of that label and\n+     the copying of the return value.  It first contains the function, then\n+     the label and copy statement.  */\n+  if (gnu_cico_list)\n+    {\n+      tree gnu_retval;\n+\n+      add_stmt (gnu_result);\n+      add_stmt (build1 (LABEL_EXPR, void_type_node,\n+\t\t\tVEC_last (tree, gnu_return_label_stack)));\n+\n+      if (list_length (gnu_cico_list) == 1)\n+\tgnu_retval = TREE_VALUE (gnu_cico_list);\n+      else\n+\tgnu_retval = build_constructor_from_list (TREE_TYPE (gnu_subprog_type),\n+\t\t\t\t\t\t  gnu_cico_list);\n+\n+      add_stmt_with_node (build_return_expr (gnu_result_decl, gnu_retval),\n+\t\t\t  End_Label (Handled_Statement_Sequence (gnat_node)));\n+      gnat_poplevel ();\n+      gnu_result = end_stmt_group ();\n+    }\n+\n+  VEC_pop (tree, gnu_return_label_stack);\n+\n   /* If we populated the parameter attributes cache, we need to make sure\n      that the cached expressions are evaluated on all possible paths.  */\n   cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;\n@@ -2537,43 +2579,6 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       gnu_result = end_stmt_group ();\n     }\n \n-    /* If we are dealing with a return from an Ada procedure with parameters\n-       passed by copy-in/copy-out, we need to return a record containing the\n-       final values of these parameters.  If the list contains only one entry,\n-       return just that entry though.\n-\n-       For a full description of the copy-in/copy-out parameter mechanism, see\n-       the part of the gnat_to_gnu_entity routine dealing with the translation\n-       of subprograms.\n-\n-       We need to make a block that contains the definition of that label and\n-       the copying of the return value.  It first contains the function, then\n-       the label and copy statement.  */\n-  if (VEC_last (tree, gnu_return_label_stack))\n-    {\n-      tree gnu_retval;\n-\n-      start_stmt_group ();\n-      gnat_pushlevel ();\n-      add_stmt (gnu_result);\n-      add_stmt (build1 (LABEL_EXPR, void_type_node,\n-\t\t\tVEC_last (tree, gnu_return_label_stack)));\n-\n-      gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n-      if (list_length (gnu_cico_list) == 1)\n-\tgnu_retval = TREE_VALUE (gnu_cico_list);\n-      else\n-\tgnu_retval = build_constructor_from_list (TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t\t\t  gnu_cico_list);\n-\n-      add_stmt_with_node (build_return_expr (gnu_result_decl, gnu_retval),\n-\t\t\t  End_Label (Handled_Statement_Sequence (gnat_node)));\n-      gnat_poplevel ();\n-      gnu_result = end_stmt_group ();\n-    }\n-\n-  VEC_pop (tree, gnu_return_label_stack);\n-\n   /* Set the end location.  */\n   Sloc_to_locus\n     ((Present (End_Label (Handled_Statement_Sequence (gnat_node)))"}, {"sha": "e1f7aab68abc5f060037009b61b698a801a04f30", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a963da4d4891794686c982ed3c84691dcea487fb/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a963da4d4891794686c982ed3c84691dcea487fb/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a963da4d4891794686c982ed3c84691dcea487fb", "patch": "@@ -473,14 +473,8 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t}\n       else if (!DECL_EXTERNAL (decl))\n \t{\n-\t  tree block;\n-\t  /* Fake PARM_DECLs go into the topmost block of the function.  */\n-\t  if (TREE_CODE (decl) == PARM_DECL)\n-\t    block = BLOCK_SUPERCONTEXT (current_binding_level->block);\n-\t  else\n-\t    block = current_binding_level->block;\n-\t  DECL_CHAIN (decl) = BLOCK_VARS (block);\n-\t  BLOCK_VARS (block) = decl;\n+\t  DECL_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n+\t  BLOCK_VARS (current_binding_level->block) = decl;\n \t}\n     }\n \n@@ -1907,6 +1901,13 @@ end_subprog_body (tree body)\n   /* Mark the RESULT_DECL as being in this subprogram. */\n   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n \n+  /* The body should be a BIND_EXPR whose BLOCK is the top-level one.  */\n+  if (TREE_CODE (body) == BIND_EXPR)\n+    {\n+      BLOCK_SUPERCONTEXT (BIND_EXPR_BLOCK (body)) = fndecl;\n+      DECL_INITIAL (fndecl) = BIND_EXPR_BLOCK (body);\n+    }\n+\n   DECL_SAVED_TREE (fndecl) = body;\n \n   current_function_decl = DECL_CONTEXT (fndecl);\n@@ -3228,15 +3229,18 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n   tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n   tree gnu_stub_param, gnu_arg_types, gnu_param;\n   tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n-  tree gnu_body;\n   VEC(tree,gc) *gnu_param_vec = NULL;\n \n   gnu_subprog_type = TREE_TYPE (gnu_subprog);\n \n+  /* Initialize the information structure for the function.  */\n+  allocate_struct_function (gnu_stub_decl, false);\n+  set_cfun (NULL);\n+\n   begin_subprog_body (gnu_stub_decl);\n-  gnat_pushlevel ();\n \n   start_stmt_group ();\n+  gnat_pushlevel ();\n \n   /* Loop over the parameters of the stub and translate any of them\n      passed by descriptor into a by reference one.  */\n@@ -3258,8 +3262,6 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n       VEC_safe_push (tree, gc, gnu_param_vec, gnu_param);\n     }\n \n-  gnu_body = end_stmt_group ();\n-\n   /* Invoke the internal subprogram.  */\n   gnu_subprog_addr = build1 (ADDR_EXPR, build_pointer_type (gnu_subprog_type),\n \t\t\t     gnu_subprog);\n@@ -3268,16 +3270,13 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n \n   /* Propagate the return value, if any.  */\n   if (VOID_TYPE_P (TREE_TYPE (gnu_subprog_type)))\n-    append_to_statement_list (gnu_subprog_call, &gnu_body);\n+    add_stmt (gnu_subprog_call);\n   else\n-    append_to_statement_list (build_return_expr (DECL_RESULT (gnu_stub_decl),\n-\t\t\t\t\t\t gnu_subprog_call),\n-\t\t\t      &gnu_body);\n+    add_stmt (build_return_expr (DECL_RESULT (gnu_stub_decl),\n+\t\t\t\t gnu_subprog_call));\n \n   gnat_poplevel ();\n-\n-  allocate_struct_function (gnu_stub_decl, false);\n-  end_subprog_body (gnu_body);\n+  end_subprog_body (end_stmt_group ());\n }\n \f\n /* Build a type to be used to represent an aliased object whose nominal type"}]}