{"sha": "da4dbc25186cc8751c5bfc9427e2f624234f2449", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE0ZGJjMjUxODZjYzg3NTFjNWJmYzk0MjdlMmY2MjQyMzRmMjQ0OQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-08-10T15:40:59Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-08-10T15:40:59Z"}, "message": "gfortran.texi (Interoperability with C): Fix ordering in menu and add new subsection about pointers.\n\n2010-08-10  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.texi (Interoperability with C): Fix ordering in menu\n\tand add new subsection about pointers.\n\t(Interoperable Subroutines and Functions): Split off the pointer part.\n\t(working with Pointers): New subsection with extended discussion\n\tof pointers (especially procedure pointers).\n\nFrom-SVN: r163073", "tree": {"sha": "946f6153e79248832063d2f9040085590acafdd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/946f6153e79248832063d2f9040085590acafdd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da4dbc25186cc8751c5bfc9427e2f624234f2449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4dbc25186cc8751c5bfc9427e2f624234f2449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da4dbc25186cc8751c5bfc9427e2f624234f2449", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4dbc25186cc8751c5bfc9427e2f624234f2449/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6aa1e0fe385d599cec06f64b001079bf04044f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6aa1e0fe385d599cec06f64b001079bf04044f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6aa1e0fe385d599cec06f64b001079bf04044f2"}], "stats": {"total": 150, "additions": 141, "deletions": 9}, "files": [{"sha": "63884ebff00bdf558dee48932e83488abdcc56db", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4dbc25186cc8751c5bfc9427e2f624234f2449/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4dbc25186cc8751c5bfc9427e2f624234f2449/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=da4dbc25186cc8751c5bfc9427e2f624234f2449", "patch": "@@ -1,3 +1,11 @@\n+2010-08-10  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.texi (Interoperability with C): Fix ordering in menu\n+\tand add new subsection about pointers.\n+\t(Interoperable Subroutines and Functions): Split off the pointer part.\n+\t(working with Pointers): New subsection with extended discussion\n+\tof pointers (especially procedure pointers).\n+\n 2010-08-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/44235"}, {"sha": "93b742b710928eea8d8da7548d6dc41e5cdbf1a0", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 133, "deletions": 9, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4dbc25186cc8751c5bfc9427e2f624234f2449/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4dbc25186cc8751c5bfc9427e2f624234f2449/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=da4dbc25186cc8751c5bfc9427e2f624234f2449", "patch": "@@ -1933,10 +1933,11 @@ and their use is highly recommended.\n \n @menu\n * Intrinsic Types::\n-* Further Interoperability of Fortran with C::\n * Derived Types and struct::\n * Interoperable Global Variables::\n * Interoperable Subroutines and Functions::\n+* Working with Pointers::\n+* Further Interoperability of Fortran with C::\n @end menu\n \n Since Fortran 2003 (ISO/IEC 1539-1:2004(E)) there is a\n@@ -2059,7 +2060,8 @@ matches the Fortran declaration\n     integer(c_int) :: j\n @end smallexample\n \n-Note that pointer arguments also frequently need the @code{VALUE} attribute.\n+Note that pointer arguments also frequently need the @code{VALUE} attribute,\n+see @ref{Working with Pointers}.\n \n Strings are handled quite differently in C and Fortran. In C a string\n is a @code{NUL}-terminated array of characters while in Fortran each string\n@@ -2096,7 +2098,7 @@ literal has the right type; typically the default character\n kind and @code{c_char} are the same and thus @code{\"Hello World\"}\n is equivalent. However, the standard does not guarantee this.\n \n-The use of pointers is now illustrated using the C library\n+The use of strings is now further illustrated using the C library\n function @code{strncpy}, whose prototype is\n \n @smallexample\n@@ -2128,8 +2130,13 @@ example, we ignore the return value:\n   end\n @end smallexample\n \n-C pointers are represented in Fortran via the special derived type\n-@code{type(c_ptr)}, with private components. Thus one needs to\n+The intrinsic procedures are described in @ref{Intrinsic Procedures}.\n+\n+@node Working with Pointers\n+@subsection Working with Pointers\n+\n+C pointers are represented in Fortran via the special opaque derived type\n+@code{type(c_ptr)} (with private components). Thus one needs to\n use intrinsic conversion procedures to convert from or to C pointers.\n For example,\n \n@@ -2147,14 +2154,131 @@ For example,\n @end smallexample\n \n When converting C to Fortran arrays, the one-dimensional @code{SHAPE} argument\n-has to be passed. Note: A pointer argument @code{void *} matches\n-@code{TYPE(C_PTR), VALUE} while @code{TYPE(C_PTR)} matches @code{void **}.\n+has to be passed.\n+\n+If a pointer is a dummy-argument of an interoperable procedure, it usually\n+has to be declared using the @code{VALUE} attribute.  @code{void*}\n+matches @code{TYPE(C_PTR), VALUE}, while @code{TYPE(C_PTR)} alone\n+matches @code{void**}.\n \n Procedure pointers are handled analogously to pointers; the C type is\n @code{TYPE(C_FUNPTR)} and the intrinsic conversion procedures are\n-@code{C_F_PROC_POINTER} and @code{C_FUNLOC}.\n+@code{C_F_PROCPOINTER} and @code{C_FUNLOC}.\n \n-The intrinsic procedures are described in @ref{Intrinsic Procedures}.\n+Let's consider two examples of actually passing a procedure pointer from\n+C to Fortran and vice versa.  Note that these examples are also very\n+similar to passing ordinary pointers between both languages.\n+First, consider this code in C:\n+\n+@smallexample\n+/* Procedure implemented in Fortran.  */\n+void get_values (void (*)(double));\n+\n+/* Call-back routine we want called from Fortran.  */\n+void\n+print_it (double x)\n+@{\n+  printf (\"Number is %f.\\n\", x);\n+@}\n+\n+/* Call Fortran routine and pass call-back to it.  */\n+void\n+foobar ()\n+@{\n+  get_values (&print_it);\n+@}\n+@end smallexample\n+\n+A matching implementation for @code{get_values} in Fortran, that correctly\n+receives the procedure pointer from C and is able to call it, is given\n+in the following @code{MODULE}:\n+\n+@smallexample\n+MODULE m\n+  IMPLICIT NONE\n+\n+  ! Define interface of call-back routine.\n+  ABSTRACT INTERFACE\n+    SUBROUTINE callback (x)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      REAL(KIND=C_DOUBLE), INTENT(IN), VALUE :: x\n+    END SUBROUTINE callback\n+  END INTERFACE\n+\n+CONTAINS\n+\n+  ! Define C-bound procedure.\n+  SUBROUTINE get_values (cproc) BIND(C)\n+    USE, INTRINSIC :: ISO_C_BINDING\n+    TYPE(C_FUNPTR), INTENT(IN), VALUE :: cproc\n+\n+    PROCEDURE(callback), POINTER :: proc\n+\n+    ! Convert C to Fortran procedure pointer.\n+    CALL C_F_PROCPOINTER (cproc, proc)\n+\n+    ! Call it.\n+    CALL proc (1.0_C_DOUBLE)\n+    CALL proc (-42.0_C_DOUBLE)\n+    CALL proc (18.12_C_DOUBLE)\n+  END SUBROUTINE get_values\n+\n+END MODULE m\n+@end smallexample\n+\n+Next, we want to call a C routine that expects a procedure pointer argument\n+and pass it a Fortran procedure (which clearly must be interoperable!).\n+Again, the C function may be:\n+\n+@smallexample\n+int\n+call_it (int (*func)(int), int arg)\n+@{\n+  return func (arg);\n+@}\n+@end smallexample\n+\n+It can be used as in the following Fortran code:\n+\n+@smallexample\n+MODULE m\n+  USE, INTRINSIC :: ISO_C_BINDING\n+  IMPLICIT NONE\n+\n+  ! Define interface of C function.\n+  INTERFACE\n+    INTEGER(KIND=C_INT) FUNCTION call_it (func, arg) BIND(C)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      TYPE(C_FUNPTR), INTENT(IN), VALUE :: func\n+      INTEGER(KIND=C_INT), INTENT(IN), VALUE :: arg\n+    END FUNCTION call_it\n+  END INTERFACE\n+\n+CONTAINS\n+\n+  ! Define procedure passed to C function.\n+  ! It must be interoperable!\n+  INTEGER(KIND=C_INT) FUNCTION double_it (arg) BIND(C)\n+    INTEGER(KIND=C_INT), INTENT(IN), VALUE :: arg\n+    double_it = arg + arg\n+  END FUNCTION double_it\n+\n+  ! Call C function.\n+  SUBROUTINE foobar ()\n+    TYPE(C_FUNPTR) :: cproc\n+    INTEGER(KIND=C_INT) :: i\n+\n+    ! Get C procedure pointer.\n+    cproc = C_FUNLOC (double_it)\n+\n+    ! Use it.\n+    DO i = 1_C_INT, 10_C_INT\n+      PRINT *, call_it (cproc, i)\n+    END DO\n+  END SUBROUTINE foobar\n+\n+END MODULE m\n+@end smallexample\n \n @node Further Interoperability of Fortran with C\n @subsection Further Interoperability of Fortran with C"}]}