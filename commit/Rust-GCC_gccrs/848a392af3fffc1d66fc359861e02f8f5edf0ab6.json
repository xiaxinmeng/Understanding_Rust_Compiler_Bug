{"sha": "848a392af3fffc1d66fc359861e02f8f5edf0ab6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4YTM5MmFmM2ZmZmMxZDY2ZmMzNTk4NjFlMDJmOGY1ZWRmMGFiNg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2016-05-18T13:04:23Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2016-05-18T13:04:23Z"}, "message": "[PR 70646] Store size to inlining predicate conditions\n\n2016-05-18  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/70646\n\t* ipa-inline.h (condition): New field size.\n\t* ipa-inline-analysis.c (add_condition): New parameter SIZE, use it\n\tfor comaprison and store it into the new condition.\n\t(evaluate_conditions_for_known_args): Use condition size to check\n\taccess sizes for all but CHANGED conditions.\n\t(unmodified_parm_1): New parameter size_p, store access size into it.\n\t(unmodified_parm): Likewise.\n\t(unmodified_parm_or_parm_agg_item): Likewise.\n\t(eliminated_by_inlining_prob): Pass NULL to unmodified_parm as size_p.\n\t(set_cond_stmt_execution_predicate): Extract access sizes and store\n\tthem to conditions.\n\t(set_switch_stmt_execution_predicate): Likewise.\n\t(will_be_nonconstant_expr_predicate): Likewise.\n\t(will_be_nonconstant_predicate): Likewise.\n\t(inline_read_section): Stream condition size.\n\t(inline_write_summary): Likewise.\n\ntestsuite/\n\t* gcc.dg/ipa/pr70646.c: New test.\n\nFrom-SVN: r236389", "tree": {"sha": "15e7033e538678addcbb4347ed7dd8352c88b060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e7033e538678addcbb4347ed7dd8352c88b060"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848a392af3fffc1d66fc359861e02f8f5edf0ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848a392af3fffc1d66fc359861e02f8f5edf0ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848a392af3fffc1d66fc359861e02f8f5edf0ab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848a392af3fffc1d66fc359861e02f8f5edf0ab6/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f2ab7765b1dcc9a6f8426accc7ee038fe366f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2ab7765b1dcc9a6f8426accc7ee038fe366f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f2ab7765b1dcc9a6f8426accc7ee038fe366f95"}], "stats": {"total": 199, "additions": 148, "deletions": 51}, "files": [{"sha": "b39886853f6e6bd23c8f15ba35a088c8e0ab3bee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=848a392af3fffc1d66fc359861e02f8f5edf0ab6", "patch": "@@ -1,3 +1,23 @@\n+2016-05-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/70646\n+\t* ipa-inline.h (condition): New field size.\n+\t* ipa-inline-analysis.c (add_condition): New parameter SIZE, use it\n+\tfor comaprison and store it into the new condition.\n+\t(evaluate_conditions_for_known_args): Use condition size to check\n+\taccess sizes for all but CHANGED conditions.\n+\t(unmodified_parm_1): New parameter size_p, store access size into it.\n+\t(unmodified_parm): Likewise.\n+\t(unmodified_parm_or_parm_agg_item): Likewise.\n+\t(eliminated_by_inlining_prob): Pass NULL to unmodified_parm as size_p.\n+\t(set_cond_stmt_execution_predicate): Extract access sizes and store\n+\tthem to conditions.\n+\t(set_switch_stmt_execution_predicate): Likewise.\n+\t(will_be_nonconstant_expr_predicate): Likewise.\n+\t(will_be_nonconstant_predicate): Likewise.\n+\t(inline_read_section): Stream condition size.\n+\t(inline_write_summary): Likewise.\n+\n 2016-05-18  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-im.c (determine_max_movement): Properly add"}, {"sha": "4a547a2f18880d35a75eff44ea49b8f72748ce7a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 81, "deletions": 51, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=848a392af3fffc1d66fc359861e02f8f5edf0ab6", "patch": "@@ -216,13 +216,14 @@ struct agg_position_info\n   bool by_ref;\n };\n \n-/* Add condition to condition list CONDS.  AGGPOS describes whether the used\n-   oprand is loaded from an aggregate and where in the aggregate it is.  It can\n-   be NULL, which means this not a load from an aggregate.  */\n+/* Add condition to condition list SUMMARY. OPERAND_NUM, SIZE, CODE and VAL\n+   correspond to fields of condition structure.  AGGPOS describes whether the\n+   used operand is loaded from an aggregate and where in the aggregate it is.\n+   It can be NULL, which means this not a load from an aggregate.  */\n \n static struct predicate\n add_condition (struct inline_summary *summary, int operand_num,\n-\t       struct agg_position_info *aggpos,\n+\t       HOST_WIDE_INT size, struct agg_position_info *aggpos,\n \t       enum tree_code code, tree val)\n {\n   int i;\n@@ -248,6 +249,7 @@ add_condition (struct inline_summary *summary, int operand_num,\n   for (i = 0; vec_safe_iterate (summary->conds, i, &c); i++)\n     {\n       if (c->operand_num == operand_num\n+\t  && c->size == size\n \t  && c->code == code\n \t  && c->val == val\n \t  && c->agg_contents == agg_contents\n@@ -264,6 +266,7 @@ add_condition (struct inline_summary *summary, int operand_num,\n   new_cond.agg_contents = agg_contents;\n   new_cond.by_ref = by_ref;\n   new_cond.offset = offset;\n+  new_cond.size = size;\n   vec_safe_push (summary->conds, new_cond);\n   return single_cond_predicate (i + predicate_first_dynamic_condition);\n }\n@@ -867,21 +870,25 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  clause |= 1 << (i + predicate_first_dynamic_condition);\n \t  continue;\n \t}\n-      if (c->code == IS_NOT_CONSTANT || c->code == CHANGED)\n+      if (c->code == CHANGED)\n \tcontinue;\n \n-      if (operand_equal_p (TYPE_SIZE (TREE_TYPE (c->val)),\n-\t\t\t   TYPE_SIZE (TREE_TYPE (val)), 0))\n+      if (tree_to_shwi (TYPE_SIZE (TREE_TYPE (val))) != c->size)\n \t{\n-\t  val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);\n+\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  continue;\n+\t}\n+      if (c->code == IS_NOT_CONSTANT)\n+\tcontinue;\n \n-\t  res = val\n-\t    ? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)\n-\t    : NULL;\n+      val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);\n+      res = val\n+\t? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)\n+\t: NULL;\n+\n+      if (res && integer_zerop (res))\n+\tcontinue;\n \n-\t  if (res && integer_zerop (res))\n-\t    continue;\n-\t}\n       clause |= 1 << (i + predicate_first_dynamic_condition);\n     }\n   return clause;\n@@ -1522,16 +1529,21 @@ mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n }\n \n /* If OP refers to value of function parameter, return the corresponding\n-   parameter.  */\n+   parameter.  If non-NULL, the size of the memory load (or the SSA_NAME of the\n+   PARM_DECL) will be stored to *SIZE_P in that case too.  */\n \n static tree\n-unmodified_parm_1 (gimple *stmt, tree op)\n+unmodified_parm_1 (gimple *stmt, tree op, HOST_WIDE_INT *size_p)\n {\n   /* SSA_NAME referring to parm default def?  */\n   if (TREE_CODE (op) == SSA_NAME\n       && SSA_NAME_IS_DEFAULT_DEF (op)\n       && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n-    return SSA_NAME_VAR (op);\n+    {\n+      if (size_p)\n+\t*size_p = tree_to_shwi (TYPE_SIZE (TREE_TYPE (op)));\n+      return SSA_NAME_VAR (op);\n+    }\n   /* Non-SSA parm reference?  */\n   if (TREE_CODE (op) == PARM_DECL)\n     {\n@@ -1542,42 +1554,50 @@ unmodified_parm_1 (gimple *stmt, tree op)\n       walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,\n \t\t\t  NULL);\n       if (!modified)\n-\treturn op;\n+\t{\n+\t  if (size_p)\n+\t    *size_p = tree_to_shwi (TYPE_SIZE (TREE_TYPE (op)));\n+\t  return op;\n+\t}\n     }\n   return NULL_TREE;\n }\n \n /* If OP refers to value of function parameter, return the corresponding\n-   parameter.  Also traverse chains of SSA register assignments.  */\n+   parameter.  Also traverse chains of SSA register assignments.  If non-NULL,\n+   the size of the memory load (or the SSA_NAME of the PARM_DECL) will be\n+   stored to *SIZE_P in that case too.  */\n \n static tree\n-unmodified_parm (gimple *stmt, tree op)\n+unmodified_parm (gimple *stmt, tree op, HOST_WIDE_INT *size_p)\n {\n-  tree res = unmodified_parm_1 (stmt, op);\n+  tree res = unmodified_parm_1 (stmt, op, size_p);\n   if (res)\n     return res;\n \n   if (TREE_CODE (op) == SSA_NAME\n       && !SSA_NAME_IS_DEFAULT_DEF (op)\n       && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n     return unmodified_parm (SSA_NAME_DEF_STMT (op),\n-\t\t\t    gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op)));\n+\t\t\t    gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op)),\n+\t\t\t    size_p);\n   return NULL_TREE;\n }\n \n /* If OP refers to a value of a function parameter or value loaded from an\n    aggregate passed to a parameter (either by value or reference), return TRUE\n-   and store the number of the parameter to *INDEX_P and information whether\n-   and how it has been loaded from an aggregate into *AGGPOS.  INFO describes\n-   the function parameters, STMT is the statement in which OP is used or\n-   loaded.  */\n+   and store the number of the parameter to *INDEX_P, the access size into\n+   *SIZE_P, and information whether and how it has been loaded from an\n+   aggregate into *AGGPOS.  INFO describes the function parameters, STMT is the\n+   statement in which OP is used or loaded.  */\n \n static bool\n unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,\n \t\t\t\t  gimple *stmt, tree op, int *index_p,\n+\t\t\t\t  HOST_WIDE_INT *size_p,\n \t\t\t\t  struct agg_position_info *aggpos)\n {\n-  tree res = unmodified_parm_1 (stmt, op);\n+  tree res = unmodified_parm_1 (stmt, op, size_p);\n \n   gcc_checking_assert (aggpos);\n   if (res)\n@@ -1598,14 +1618,14 @@ unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,\n       stmt = SSA_NAME_DEF_STMT (op);\n       op = gimple_assign_rhs1 (stmt);\n       if (!REFERENCE_CLASS_P (op))\n-\treturn unmodified_parm_or_parm_agg_item (fbi, stmt, op, index_p,\n+\treturn unmodified_parm_or_parm_agg_item (fbi, stmt, op, index_p, size_p,\n \t\t\t\t\t\t aggpos);\n     }\n \n   aggpos->agg_contents = true;\n   return ipa_load_from_parm_agg (fbi, fbi->info->descriptors,\n \t\t\t\t stmt, op, index_p, &aggpos->offset,\n-\t\t\t\t NULL, &aggpos->by_ref);\n+\t\t\t\t size_p, &aggpos->by_ref);\n }\n \n /* See if statement might disappear after inlining.\n@@ -1656,7 +1676,7 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t    inner_lhs = lhs;\n \n \t  /* Reads of parameter are expected to be free.  */\n-\t  if (unmodified_parm (stmt, inner_rhs))\n+\t  if (unmodified_parm (stmt, inner_rhs, NULL))\n \t    rhs_free = true;\n \t  /* Match expressions of form &this->field. Those will most likely\n \t     combine with something upstream after inlining.  */\n@@ -1666,7 +1686,7 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t      if (TREE_CODE (op) == PARM_DECL)\n \t\trhs_free = true;\n \t      else if (TREE_CODE (op) == MEM_REF\n-\t\t       && unmodified_parm (stmt, TREE_OPERAND (op, 0)))\n+\t\t       && unmodified_parm (stmt, TREE_OPERAND (op, 0), NULL))\n \t\trhs_free = true;\n \t    }\n \n@@ -1679,7 +1699,7 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t  /* Reads of parameters passed by reference\n \t     expected to be free (i.e. optimized out after inlining).  */\n \t  if (TREE_CODE (inner_rhs) == MEM_REF\n-\t      && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0)))\n+\t      && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0), NULL))\n \t    rhs_free = true;\n \n \t  /* Copying parameter passed by reference into gimple register is\n@@ -1720,7 +1740,7 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t  if (TREE_CODE (inner_lhs) == PARM_DECL\n \t      || TREE_CODE (inner_lhs) == RESULT_DECL\n \t      || (TREE_CODE (inner_lhs) == MEM_REF\n-\t\t  && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0))\n+\t\t  && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0), NULL)\n \t\t      || (TREE_CODE (TREE_OPERAND (inner_lhs, 0)) == SSA_NAME\n \t\t\t  && SSA_NAME_VAR (TREE_OPERAND (inner_lhs, 0))\n \t\t\t  && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND\n@@ -1751,6 +1771,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   gimple *last;\n   tree op;\n   int index;\n+  HOST_WIDE_INT size;\n   struct agg_position_info aggpos;\n   enum tree_code code, inverted_code;\n   edge e;\n@@ -1767,7 +1788,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   /* TODO: handle conditionals like\n      var = op0 < 4;\n      if (var != 0).  */\n-  if (unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))\n+  if (unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &size, &aggpos))\n     {\n       code = gimple_cond_code (last);\n       inverted_code = invert_tree_comparison (code, HONOR_NANS (op));\n@@ -1781,9 +1802,10 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t     unordered one.  Be sure it is not confused with NON_CONSTANT.  */\n \t  if (this_code != ERROR_MARK)\n \t    {\n-\t      struct predicate p = add_condition\n-\t\t (summary, index, &aggpos, this_code,\n-\t\t  unshare_expr_without_location (gimple_cond_rhs (last)));\n+\t      struct predicate p\n+\t\t= add_condition (summary, index, size, &aggpos, this_code,\n+\t\t\t\t unshare_expr_without_location\n+\t\t\t\t (gimple_cond_rhs (last)));\n \t      e->aux = edge_predicate_pool.allocate ();\n \t      *(struct predicate *) e->aux = p;\n \t    }\n@@ -1810,11 +1832,12 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       || gimple_call_num_args (set_stmt) != 1)\n     return;\n   op2 = gimple_call_arg (set_stmt, 0);\n-  if (!unmodified_parm_or_parm_agg_item (fbi, set_stmt, op2, &index, &aggpos))\n+  if (!unmodified_parm_or_parm_agg_item (fbi, set_stmt, op2, &index, &size,\n+\t\t\t\t\t &aggpos))\n     return;\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n-      struct predicate p = add_condition (summary, index, &aggpos,\n+      struct predicate p = add_condition (summary, index, size, &aggpos,\n \t\t\t\t\t  IS_NOT_CONSTANT, NULL_TREE);\n       e->aux = edge_predicate_pool.allocate ();\n       *(struct predicate *) e->aux = p;\n@@ -1833,6 +1856,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   gimple *lastg;\n   tree op;\n   int index;\n+  HOST_WIDE_INT size;\n   struct agg_position_info aggpos;\n   edge e;\n   edge_iterator ei;\n@@ -1844,7 +1868,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n     return;\n   gswitch *last = as_a <gswitch *> (lastg);\n   op = gimple_switch_index (last);\n-  if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))\n+  if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &size, &aggpos))\n     return;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1869,14 +1893,14 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       if (!min && !max)\n \tp = true_predicate ();\n       else if (!max)\n-\tp = add_condition (summary, index, &aggpos, EQ_EXPR,\n+\tp = add_condition (summary, index, size, &aggpos, EQ_EXPR,\n \t\t\t   unshare_expr_without_location (min));\n       else\n \t{\n \t  struct predicate p1, p2;\n-\t  p1 = add_condition (summary, index, &aggpos, GE_EXPR,\n+\t  p1 = add_condition (summary, index, size, &aggpos, GE_EXPR,\n \t\t\t      unshare_expr_without_location (min));\n-\t  p2 = add_condition (summary, index, &aggpos, LE_EXPR,\n+\t  p2 = add_condition (summary, index, size, &aggpos, LE_EXPR,\n \t\t\t      unshare_expr_without_location (max));\n \t  p = and_predicates (summary->conds, &p1, &p2);\n \t}\n@@ -1977,13 +2001,14 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n {\n   tree parm;\n   int index;\n+  HOST_WIDE_INT size;\n \n   while (UNARY_CLASS_P (expr))\n     expr = TREE_OPERAND (expr, 0);\n \n-  parm = unmodified_parm (NULL, expr);\n+  parm = unmodified_parm (NULL, expr, &size);\n   if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n-    return add_condition (summary, index, NULL, CHANGED, NULL_TREE);\n+    return add_condition (summary, index, size, NULL, CHANGED, NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n     return false_predicate ();\n   if (TREE_CODE (expr) == SSA_NAME)\n@@ -2044,6 +2069,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n   struct predicate op_non_const;\n   bool is_load;\n   int base_index;\n+  HOST_WIDE_INT size;\n   struct agg_position_info aggpos;\n \n   /* What statments might be optimized away\n@@ -2067,7 +2093,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n       tree op;\n       gcc_assert (gimple_assign_single_p (stmt));\n       op = gimple_assign_rhs1 (stmt);\n-      if (!unmodified_parm_or_parm_agg_item (fbi, stmt, op, &base_index,\n+      if (!unmodified_parm_or_parm_agg_item (fbi, stmt, op, &base_index, &size,\n \t\t\t\t\t     &aggpos))\n \treturn p;\n     }\n@@ -2078,7 +2104,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n      adding conditionals.  */\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      tree parm = unmodified_parm (stmt, use);\n+      tree parm = unmodified_parm (stmt, use, NULL);\n       /* For arguments we can build a condition.  */\n       if (parm && ipa_get_param_decl_index (fbi->info, parm) >= 0)\n \tcontinue;\n@@ -2093,18 +2119,19 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \n   if (is_load)\n     op_non_const =\n-      add_condition (summary, base_index, &aggpos, CHANGED, NULL);\n+      add_condition (summary, base_index, size, &aggpos, CHANGED, NULL);\n   else\n     op_non_const = false_predicate ();\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      tree parm = unmodified_parm (stmt, use);\n+      HOST_WIDE_INT size;\n+      tree parm = unmodified_parm (stmt, use, &size);\n       int index;\n \n       if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n \t{\n \t  if (index != base_index)\n-\t    p = add_condition (summary, index, NULL, CHANGED, NULL_TREE);\n+\t    p = add_condition (summary, index, size, NULL, CHANGED, NULL_TREE);\n \t  else\n \t    continue;\n \t}\n@@ -3415,7 +3442,8 @@ remap_predicate (struct inline_summary *info,\n \t\t    ap.by_ref = c->by_ref;\n \t\t    cond_predicate = add_condition (info,\n \t\t\t\t\t\t    operand_map[c->operand_num],\n-\t\t\t\t\t\t    &ap, c->code, c->val);\n+\t\t\t\t\t\t    c->size, &ap, c->code,\n+\t\t\t\t\t\t    c->val);\n \t\t  }\n \t      }\n \t    /* Fixed conditions remains same, construct single\n@@ -4269,6 +4297,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t{\n \t  struct condition c;\n \t  c.operand_num = streamer_read_uhwi (&ib);\n+\t  c.size = streamer_read_uhwi (&ib);\n \t  c.code = (enum tree_code) streamer_read_uhwi (&ib);\n \t  c.val = stream_read_tree (&ib, data_in);\n \t  bp = streamer_read_bitpack (&ib);\n@@ -4434,6 +4463,7 @@ inline_write_summary (void)\n \t  for (i = 0; vec_safe_iterate (info->conds, i, &c); i++)\n \t    {\n \t      streamer_write_uhwi (ob, c->operand_num);\n+\t      streamer_write_uhwi (ob, c->size);\n \t      streamer_write_uhwi (ob, c->code);\n \t      stream_write_tree (ob, c->val, true);\n \t      bp = bitpack_create (ob->main_stream);"}, {"sha": "47f8832150a2830ccac1e8e65040e9497bc8b22d", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=848a392af3fffc1d66fc359861e02f8f5edf0ab6", "patch": "@@ -34,6 +34,8 @@ struct GTY(()) condition\n   /* If agg_contents is set, this is the offset from which the used data was\n      loaded.  */\n   HOST_WIDE_INT offset;\n+  /* Size of the access reading the data (or the PARM_DECL SSA_NAME).  */\n+  HOST_WIDE_INT size;\n   tree val;\n   int operand_num;\n   ENUM_BITFIELD(tree_code) code : 16;"}, {"sha": "ec993ce78318e6c3d876fe8974567d8effa0316c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=848a392af3fffc1d66fc359861e02f8f5edf0ab6", "patch": "@@ -1,3 +1,8 @@\n+2016-05-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/70646\n+\t* gcc.dg/ipa/pr70646.c: New test.\n+\n 2016-05-18  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vget_lane.c: Add fp16 tests."}, {"sha": "f85816e7303dfa637033a9b8dc565d4c49314ca1", "filename": "gcc/testsuite/gcc.dg/ipa/pr70646.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr70646.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a392af3fffc1d66fc359861e02f8f5edf0ab6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr70646.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr70646.c?ref=848a392af3fffc1d66fc359861e02f8f5edf0ab6", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#pragma GCC optimize(\"no-unit-at-a-time\")\n+\n+typedef unsigned char u8;\n+typedef unsigned long long u64;\n+\n+static inline __attribute__((always_inline)) u64 __swab64p(const u64 *p)\n+{\n+ return (__builtin_constant_p((u64)(*p)) ? ((u64)( (((u64)(*p) & (u64)0x00000000000000ffULL) << 56) | (((u64)(*p) & (u64)0x000000000000ff00ULL) << 40) | (((u64)(*p) & (u64)0x0000000000ff0000ULL) << 24) | (((u64)(*p) & (u64)0x00000000ff000000ULL) << 8) | (((u64)(*p) & (u64)0x000000ff00000000ULL) >> 8) | (((u64)(*p) & (u64)0x0000ff0000000000ULL) >> 24) | (((u64)(*p) & (u64)0x00ff000000000000ULL) >> 40) | (((u64)(*p) & (u64)0xff00000000000000ULL) >> 56))) : __builtin_bswap64(*p));\n+}\n+\n+static inline u64 wwn_to_u64(void *wwn)\n+{\n+ return __swab64p(wwn);\n+}\n+\n+void __attribute__((noinline,noclone)) broken(u64* shost)\n+{\n+ u8 node_name[8] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n+ *shost = wwn_to_u64(node_name);\n+}\n+\n+void __attribute__((noinline,noclone)) dummy(void)\n+{\n+ __builtin_abort();\n+}\n+\n+int main(int argc, char* argv[])\n+{\n+ u64 v;\n+\n+ broken(&v);\n+\n+ if(v != (u64)-1)\n+  __builtin_abort();\n+\n+ return 0;\n+}"}]}