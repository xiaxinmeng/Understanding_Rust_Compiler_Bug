{"sha": "bf0b0e5ee1c756b593f8e8d0456504575ac63218", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYwYjBlNWVlMWM3NTZiNTkzZjhlOGQwNDU2NTA0NTc1YWM2MzIxOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T13:47:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T13:47:34Z"}, "message": "[multiple changes]\n\n2014-08-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Preanalyze and resolve the\n\tprefix of attribute Loop_Entry.\n\t* sem_prag.adb (Analyze_Pragma): Verify the placement of pragma\n\tLoop_Variant with respect to an enclosing loop (if any).\n\t(Contains_Loop_Entry): Update the parameter profile and all\n\tcalls to this routine.\n\t* sem_res.adb (Resolve_Call): Code reformatting. Do not ask\n\tfor the corresponding body before determining the nature of the\n\tultimate alias's declarative node.\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat1drv.adb, sem_ch4.adb: Minor reformatting.\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_eval.adb (Rewrite_In_Raise_CE): Don't try to reuse inner\n\tconstraint error node since it is a list member.\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_warn.adb: Minor reformatting.\n\n2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* einfo.adb (Underlying_Type): Return the underlying full view\n\tof a private type if present.\n\t* freeze.adb (Freeze_Entity):\n\tBuild a single freeze node for partial, full and underlying full\n\tviews, if any.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Private_Type>: Add a\n\tmissing guard before the access to the Underlying_Full_View.\n\t* gcc-interface/trans.c (process_freeze_entity): Deal with underlying\n\tfull view if present.\n\t* gcc-interface/utils.c (make_dummy_type): Avoid superfluous work.\n\nFrom-SVN: r213463", "tree": {"sha": "e8a236c8e7a4c783a814ba81952ae78a2118a9b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8a236c8e7a4c783a814ba81952ae78a2118a9b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf0b0e5ee1c756b593f8e8d0456504575ac63218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf0b0e5ee1c756b593f8e8d0456504575ac63218", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf0b0e5ee1c756b593f8e8d0456504575ac63218", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf0b0e5ee1c756b593f8e8d0456504575ac63218/comments", "author": null, "committer": null, "parents": [{"sha": "1eb5852081801218c02c934db5aa9852fc284645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb5852081801218c02c934db5aa9852fc284645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb5852081801218c02c934db5aa9852fc284645"}], "stats": {"total": 254, "additions": 162, "deletions": 92}, "files": [{"sha": "6afc37ceb3a382d5ffe75dfc24a02a18c73f9ba9", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -8118,7 +8118,7 @@ package body Einfo is\n       elsif Ekind (Id) in Incomplete_Or_Private_Kind then\n \n          --  If we have an incomplete or private type with a full view,\n-         --  then we return the Underlying_Type of this full view\n+         --  then we return the Underlying_Type of this full view.\n \n          if Present (Full_View (Id)) then\n             if Id = Full_View (Id) then\n@@ -8131,6 +8131,14 @@ package body Einfo is\n                return Underlying_Type (Full_View (Id));\n             end if;\n \n+         --  If we have a private type with an underlying full view, then we\n+         --  return the Underlying_Type of this underlying full view.\n+\n+         elsif Ekind (Id) in Private_Kind\n+           and then Present (Underlying_Full_View (Id))\n+         then\n+            return Underlying_Type (Underlying_Full_View (Id));\n+\n          --  If we have an incomplete entity that comes from the limited\n          --  view then we return the Underlying_Type of its non-limited\n          --  view."}, {"sha": "9af48a8622e5d2e7a82302e6adc5e7034e8c85a6", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -4977,7 +4977,7 @@ package body Freeze is\n          --  view, we can retrieve the full view, but not the reverse).\n          --  However, in order to freeze correctly, we need to freeze the full\n          --  view. If we are freezing at the end of a scope (or within the\n-         --  scope of the private type), the partial and full views will have\n+         --  scope) of the private type, the partial and full views will have\n          --  been swapped, the full view appears first in the entity chain and\n          --  the swapping mechanism ensures that the pointers are properly set\n          --  (on scope exit).\n@@ -4987,6 +4987,11 @@ package body Freeze is\n          --  set the pointers appropriately since we cannot rely on swapping to\n          --  fix things up (subtypes in an outer scope might not get swapped).\n \n+         --  If the full view is itself private, the above requirements apply\n+         --  to the underlying full view instead of the full view. But there is\n+         --  no swapping mechanism for the underlying full view so we need to\n+         --  set the pointers appropriately in both cases.\n+\n          elsif Is_Incomplete_Or_Private_Type (E)\n            and then not Is_Generic_Type (E)\n          then\n@@ -5025,28 +5030,44 @@ package body Freeze is\n                if Is_Frozen (Full_View (E)) then\n                   Set_Has_Delayed_Freeze (E, False);\n                   Set_Freeze_Node (E, Empty);\n-                  Check_Debug_Info_Needed (E);\n \n                --  Otherwise freeze full view and patch the pointers so that\n-               --  the freeze node will elaborate both views in the back-end.\n+               --  the freeze node will elaborate both views in the back end.\n+               --  However, if full view is itself private, freeze underlying\n+               --  full view instead and patch the pointer so that the freeze\n+               --  node will elaborate the three views in the back end.\n \n                else\n                   declare\n-                     Full : constant Entity_Id := Full_View (E);\n+                     Full : Entity_Id := Full_View (E);\n \n                   begin\n                      if Is_Private_Type (Full)\n                        and then Present (Underlying_Full_View (Full))\n                      then\n-                        Freeze_And_Append\n-                          (Underlying_Full_View (Full), N, Result);\n+                        Full := Underlying_Full_View (Full);\n                      end if;\n \n                      Freeze_And_Append (Full, N, Result);\n \n-                     if Has_Delayed_Freeze (E) then\n+                     if Full /= Full_View (E)\n+                       and then Has_Delayed_Freeze (Full_View (E))\n+                     then\n                         F_Node := Freeze_Node (Full);\n \n+                        if Present (F_Node) then\n+                           Set_Freeze_Node (Full_View (E), F_Node);\n+                           Set_Entity (F_Node, Full_View (E));\n+\n+                        else\n+                           Set_Has_Delayed_Freeze (Full_View (E), False);\n+                           Set_Freeze_Node (Full_View (E), Empty);\n+                        end if;\n+                     end if;\n+\n+                     if Has_Delayed_Freeze (E) then\n+                        F_Node := Freeze_Node (Full_View (E));\n+\n                         if Present (F_Node) then\n                            Set_Freeze_Node (E, F_Node);\n                            Set_Entity (F_Node, E);\n@@ -5060,10 +5081,10 @@ package body Freeze is\n                         end if;\n                      end if;\n                   end;\n-\n-                  Check_Debug_Info_Needed (E);\n                end if;\n \n+               Check_Debug_Info_Needed (E);\n+\n                --  AI-117 requires that the convention of a partial view be the\n                --  same as the convention of the full view. Note that this is a\n                --  recognized breach of privacy, but it's essential for logical\n@@ -5090,6 +5111,35 @@ package body Freeze is\n \n                return Result;\n \n+            --  Case of underlying full view present\n+\n+            elsif Is_Private_Type (E)\n+              and then Present (Underlying_Full_View (E))\n+            then\n+               if not Is_Frozen (Underlying_Full_View (E)) then\n+                  Freeze_And_Append (Underlying_Full_View (E), N, Result);\n+               end if;\n+\n+               --  Patch the pointers so that the freeze node will elaborate\n+               --  both views in the back end.\n+\n+               if Has_Delayed_Freeze (E) then\n+                  F_Node := Freeze_Node (Underlying_Full_View (E));\n+\n+                  if Present (F_Node) then\n+                     Set_Freeze_Node (E, F_Node);\n+                     Set_Entity (F_Node, E);\n+\n+                  else\n+                     Set_Has_Delayed_Freeze (E, False);\n+                     Set_Freeze_Node (E, Empty);\n+                  end if;\n+               end if;\n+\n+               Check_Debug_Info_Needed (E);\n+\n+               return Result;\n+\n             --  Case of no full view present. If entity is derived or subtype,\n             --  it is safe to freeze, correctness depends on the frozen status\n             --  of parent. Otherwise it is either premature usage, or a Taft"}, {"sha": "bf70486a82353adef00c4719178a9f0ad4fdc59c", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -4654,7 +4654,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    ? Non_Limited_View (gnat_entity)\n \t    : Present (Full_View (gnat_entity))\n \t      ? Full_View (gnat_entity)\n-\t      : Underlying_Full_View (gnat_entity);\n+\t      : IN (kind, Private_Kind)\n+\t\t? Underlying_Full_View (gnat_entity)\n+\t\t: Empty;\n \n \t/* If this is an incomplete type with no full view, it must be a Taft\n \t   Amendment type, in which case we return a dummy type.  Otherwise,"}, {"sha": "64e428a5e332f2d4be5fd6fbd2236a2db80083e0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -7893,10 +7893,20 @@ process_freeze_entity (Node_Id gnat_node)\n   if (gnu_old)\n     {\n       save_gnu_tree (gnat_entity, NULL_TREE, false);\n+\n       if (IN (kind, Incomplete_Or_Private_Kind)\n-\t  && Present (Full_View (gnat_entity))\n-\t  && present_gnu_tree (Full_View (gnat_entity)))\n-\tsave_gnu_tree (Full_View (gnat_entity), NULL_TREE, false);\n+\t  && Present (Full_View (gnat_entity)))\n+\t{\n+\t  Entity_Id full_view = Full_View (gnat_entity);\n+\n+          if (IN (Ekind (full_view), Private_Kind)\n+\t      && Present (Underlying_Full_View (full_view)))\n+\t    full_view = Underlying_Full_View (full_view);\n+\n+\t  if (present_gnu_tree (full_view))\n+\t    save_gnu_tree (full_view, NULL_TREE, false);\n+\t}\n+\n       if (IN (kind, Type_Kind)\n \t  && Present (Class_Wide_Type (gnat_entity))\n \t  && Root_Type (Class_Wide_Type (gnat_entity)) == gnat_entity)\n@@ -7906,17 +7916,23 @@ process_freeze_entity (Node_Id gnat_node)\n   if (IN (kind, Incomplete_Or_Private_Kind)\n       && Present (Full_View (gnat_entity)))\n     {\n-      gnu_new = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE, 1);\n+      Entity_Id full_view = Full_View (gnat_entity);\n+\n+      if (IN (Ekind (full_view), Private_Kind)\n+\t  && Present (Underlying_Full_View (full_view)))\n+\tfull_view = Underlying_Full_View (full_view);\n+\n+      gnu_new = gnat_to_gnu_entity (full_view, NULL_TREE, 1);\n \n       /* Propagate back-annotations from full view to partial view.  */\n       if (Unknown_Alignment (gnat_entity))\n-\tSet_Alignment (gnat_entity, Alignment (Full_View (gnat_entity)));\n+\tSet_Alignment (gnat_entity, Alignment (full_view));\n \n       if (Unknown_Esize (gnat_entity))\n-\tSet_Esize (gnat_entity, Esize (Full_View (gnat_entity)));\n+\tSet_Esize (gnat_entity, Esize (full_view));\n \n       if (Unknown_RM_Size (gnat_entity))\n-\tSet_RM_Size (gnat_entity, RM_Size (Full_View (gnat_entity)));\n+\tSet_RM_Size (gnat_entity, RM_Size (full_view));\n \n       /* The above call may have defined this entity (the simplest example\n \t of this is when we have a private enumeral type since the bounds"}, {"sha": "f44bda335d28b245d3e52d4999b72a31f2c74dee", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -328,35 +328,31 @@ present_gnu_tree (Entity_Id gnat_entity)\n tree\n make_dummy_type (Entity_Id gnat_type)\n {\n-  Entity_Id gnat_underlying = Gigi_Equivalent_Type (gnat_type);\n+  Entity_Id gnat_equiv = Gigi_Equivalent_Type (Underlying_Type (gnat_type));\n   tree gnu_type;\n \n-  /* If there is an equivalent type, get its underlying type.  */\n-  if (Present (gnat_underlying))\n-    gnat_underlying = Gigi_Equivalent_Type (Underlying_Type (gnat_underlying));\n-\n   /* If there was no equivalent type (can only happen when just annotating\n      types) or underlying type, go back to the original type.  */\n-  if (No (gnat_underlying))\n-    gnat_underlying = gnat_type;\n+  if (No (gnat_equiv))\n+    gnat_equiv = gnat_type;\n \n   /* If it there already a dummy type, use that one.  Else make one.  */\n-  if (PRESENT_DUMMY_NODE (gnat_underlying))\n-    return GET_DUMMY_NODE (gnat_underlying);\n+  if (PRESENT_DUMMY_NODE (gnat_equiv))\n+    return GET_DUMMY_NODE (gnat_equiv);\n \n   /* If this is a record, make a RECORD_TYPE or UNION_TYPE; else make\n      an ENUMERAL_TYPE.  */\n-  gnu_type = make_node (Is_Record_Type (gnat_underlying)\n-\t\t\t? tree_code_for_record_type (gnat_underlying)\n+  gnu_type = make_node (Is_Record_Type (gnat_equiv)\n+\t\t\t? tree_code_for_record_type (gnat_equiv)\n \t\t\t: ENUMERAL_TYPE);\n   TYPE_NAME (gnu_type) = get_entity_name (gnat_type);\n   TYPE_DUMMY_P (gnu_type) = 1;\n   TYPE_STUB_DECL (gnu_type)\n     = create_type_stub_decl (TYPE_NAME (gnu_type), gnu_type);\n-  if (Is_By_Reference_Type (gnat_underlying))\n+  if (Is_By_Reference_Type (gnat_equiv))\n     TYPE_BY_REFERENCE_P (gnu_type) = 1;\n \n-  SET_DUMMY_NODE (gnat_underlying, gnu_type);\n+  SET_DUMMY_NODE (gnat_equiv, gnu_type);\n \n   return gnu_type;\n }"}, {"sha": "2ed775534183f21ce4fb5b485dfe6b37e854011c", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -872,7 +872,6 @@ begin\n       if Operating_Mode /= Check_Syntax then\n \n          --  Acquire target parameters from system.ads (package System source)\n-         --  System).\n \n          Targparm_Acquire : declare\n             use Sinput;"}, {"sha": "e3e9f5aaa49c419b87b89bfdbdee720b372cd6f8", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -4027,24 +4027,24 @@ package body Sem_Attr is\n            and then Entity (Identifier (Enclosing_Loop)) /= Loop_Id\n          then\n             Error_Attr_P\n-              (\"prefix of attribute % that applies to \"\n-               & \"outer loop must denote an entity\");\n+              (\"prefix of attribute % that applies to outer loop must denote \"\n+               & \"an entity\");\n \n          elsif Is_Potentially_Unevaluated (P) then\n             Uneval_Old_Msg;\n          end if;\n \n-         --  Finally, if the Loop_Entry attribute appears within a pragma\n-         --  that is ignored, we replace P'Loop_Entity by P to avoid useless\n-         --  generation of the loop entity variable. Note that in this case\n-         --  the expression won't be executed anyway, and this substitution\n-         --  keeps types happy!\n-\n-         --  We should really do this in the expander, but it's easier here\n+         --  Replace the Loop_Entry attribute reference by its prefix if the\n+         --  related pragma is ignored. This transformation is OK with respect\n+         --  to typing because Loop_Entry's type is that of its prefix. This\n+         --  early transformation also avoids the generation of a useless loop\n+         --  entry constant.\n \n          if Is_Ignored (Enclosing_Pragma) then\n             Rewrite (N, Relocate_Node (P));\n          end if;\n+\n+         Preanalyze_And_Resolve (P);\n       end Loop_Entry;\n \n       -------------"}, {"sha": "332bd28be3c8eb56e7f28c991f66dc861ec65ad9", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -1441,15 +1441,18 @@ package body Sem_Ch4 is\n       if Exp_Btype = Any_Discrete or else Exp_Btype = Any_Type then\n          return;\n \n+      --  Special casee message for character literal\n+\n       elsif Exp_Btype = Any_Character then\n          Error_Msg_N\n            (\"character literal as case expression is ambiguous\", Expr);\n          return;\n       end if;\n \n       if Etype (N) = Any_Type and then Present (Wrong_Alt) then\n-         Error_Msg_N (\"type incompatible with that of previous alternatives\",\n-           Expression (Wrong_Alt));\n+         Error_Msg_N\n+           (\"type incompatible with that of previous alternatives\",\n+            Expression (Wrong_Alt));\n          return;\n       end if;\n "}, {"sha": "3e5458f2982c588f9199a3db614e1e572efbdd8f", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -5465,13 +5465,6 @@ package body Sem_Eval is\n       then\n          Set_Condition (Parent (N), Empty);\n \n-      --  If the expression raising CE is a N_Raise_CE node, we can use that\n-      --  one. We just preserve the type of the context.\n-\n-      elsif Nkind (Exp) = N_Raise_Constraint_Error then\n-         Rewrite (N, Exp);\n-         Set_Etype (N, Typ);\n-\n       --  Else build an explicit N_Raise_CE\n \n       else"}, {"sha": "5a3a255a4411a25d98166f117c08aa6f5cbf8a5f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -10926,20 +10926,17 @@ package body Sem_Prag is\n               Pragma_Assume         |\n               Pragma_Loop_Invariant =>\n          Assert : declare\n-            Expr : Node_Id;\n-            Newa : List_Id;\n-\n-            Has_Loop_Entry : Boolean;\n-            --  Set True by\n-\n-            function Contains_Loop_Entry return Boolean;\n-            --  Tests if Expr contains a Loop_Entry attribute reference\n+            function Contains_Loop_Entry (Expr : Node_Id) return Boolean;\n+            --  Determine whether expression Expr contains a Loop_Entry\n+            --  attribute reference.\n \n             -------------------------\n             -- Contains_Loop_Entry --\n             -------------------------\n \n-            function Contains_Loop_Entry return Boolean is\n+            function Contains_Loop_Entry (Expr : Node_Id) return Boolean is\n+               Has_Loop_Entry : Boolean := False;\n+\n                function Process (N : Node_Id) return Traverse_Result;\n                --  Process function for traversal to look for Loop_Entry\n \n@@ -10964,11 +10961,15 @@ package body Sem_Prag is\n             --  Start of processing for Contains_Loop_Entry\n \n             begin\n-               Has_Loop_Entry := False;\n                Traverse (Expr);\n                return Has_Loop_Entry;\n             end Contains_Loop_Entry;\n \n+            --  Local variables\n+\n+            Expr : Node_Id;\n+            Newa : List_Id;\n+\n          --  Start of processing for Assert\n \n          begin\n@@ -10989,17 +10990,19 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Check);\n             Expr := Get_Pragma_Arg (Arg1);\n \n-            --  Special processing for Loop_Invariant or for other cases if\n-            --  a Loop_Entry attribute is present.\n+            --  Special processing for Loop_Invariant, Loop_Variant or for\n+            --  other cases where a Loop_Entry attribute is present. If the\n+            --  assertion pragma contains attribute Loop_Entry, ensure that\n+            --  the related pragma is within a loop.\n \n             if Prag_Id = Pragma_Loop_Invariant\n-              or else Contains_Loop_Entry\n+              or else Prag_Id = Pragma_Loop_Variant\n+              or else Contains_Loop_Entry (Expr)\n             then\n-               --  Check restricted placement, must be within a loop\n-\n                Check_Loop_Pragma_Placement;\n \n-               --  Do preanalyze to deal with embedded Loop_Entry attribute\n+               --  Perform preanalysis to deal with embedded Loop_Entry\n+               --  attributes.\n \n                Preanalyze_Assert_Expression (Expression (Arg1), Any_Boolean);\n             end if;"}, {"sha": "9509b230860c88fd619ab9cb1bbe180e1e4d89f9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -5371,15 +5371,6 @@ package body Sem_Res is\n    ------------------\n \n    procedure Resolve_Call (N : Node_Id; Typ : Entity_Id) is\n-      Loc     : constant Source_Ptr := Sloc (N);\n-      Subp    : constant Node_Id    := Name (N);\n-      Nam     : Entity_Id;\n-      I       : Interp_Index;\n-      It      : Interp;\n-      Norm_OK : Boolean;\n-      Scop    : Entity_Id;\n-      Rtype   : Entity_Id;\n-\n       function Same_Or_Aliased_Subprograms\n         (S : Entity_Id;\n          E : Entity_Id) return Boolean;\n@@ -5399,6 +5390,20 @@ package body Sem_Res is\n          return S = E or else (Present (Subp_Alias) and then Subp_Alias = E);\n       end Same_Or_Aliased_Subprograms;\n \n+      --  Local variables\n+\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Subp     : constant Node_Id    := Name (N);\n+      Body_Id  : Entity_Id;\n+      I        : Interp_Index;\n+      It       : Interp;\n+      Nam      : Entity_Id;\n+      Nam_Decl : Node_Id;\n+      Nam_UA   : Entity_Id;\n+      Norm_OK  : Boolean;\n+      Rtype    : Entity_Id;\n+      Scop     : Entity_Id;\n+\n    --  Start of processing for Resolve_Call\n \n    begin\n@@ -6218,21 +6223,16 @@ package body Sem_Res is\n         and then Is_Overloadable (Nam)\n         and then not Inside_A_Generic\n       then\n-         --  Retrieve the body to inline from the ultimate alias of Nam, if\n-         --  there is one, otherwise calls that should be inlined end up not\n-         --  being inlined.\n+         Nam_UA   := Ultimate_Alias (Nam);\n+         Nam_Decl := Unit_Declaration_Node (Nam_UA);\n \n-         declare\n-            Nam_UA  : constant Entity_Id := Ultimate_Alias (Nam);\n-            Decl    : constant Node_Id   := Unit_Declaration_Node (Nam_UA);\n-            Body_Id : constant Entity_Id := Corresponding_Body (Decl);\n+         if Nkind (Nam_Decl) = N_Subprogram_Declaration then\n+            Body_Id := Corresponding_Body (Nam_Decl);\n \n-         begin\n-            --  If the subprogram is not eligible for inlining in GNATprove\n-            --  mode, do nothing.\n+            --  Nothing to do if the subprogram is not eligible for inlining in\n+            --  GNATprove mode.\n \n-            if Nkind (Decl) /= N_Subprogram_Declaration\n-              or else not Is_Inlined_Always (Nam_UA)\n+            if not Is_Inlined_Always (Nam_UA)\n               or else not Can_Be_Inlined_In_GNATprove_Mode (Nam_UA, Body_Id)\n             then\n                null;\n@@ -6262,7 +6262,7 @@ package body Sem_Res is\n                --  the subprogram is not suitable for inlining in GNATprove\n                --  mode.\n \n-               elsif No (Body_To_Inline (Decl)) then\n+               elsif No (Body_To_Inline (Nam_Decl)) then\n                   null;\n \n                --  Calls cannot be inlined inside potentially unevaluated\n@@ -6281,7 +6281,7 @@ package body Sem_Res is\n                   Expand_Inlined_Call (N, Nam_UA, Nam);\n                end if;\n             end if;\n-         end;\n+         end if;\n       end if;\n \n       Warn_On_Overlapping_Actuals (Nam, N);"}, {"sha": "d52e2d7d85213a556e1d81b0f4c4c465ce60d503", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0b0e5ee1c756b593f8e8d0456504575ac63218/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=bf0b0e5ee1c756b593f8e8d0456504575ac63218", "patch": "@@ -820,9 +820,9 @@ package body Sem_Warn is\n          raise Program_Error;\n       end Body_Formal;\n \n-      -----------------------------------\n-      --   May_Need_Initialized_Actual --\n-      -----------------------------------\n+      ---------------------------------\n+      -- May_Need_Initialized_Actual --\n+      ---------------------------------\n \n       procedure May_Need_Initialized_Actual (Ent : Entity_Id) is\n          T   : constant Entity_Id := Etype (Ent);"}]}