{"sha": "187f4b9eb897a08c124742e018b323c1ad6c9189", "node_id": "C_kwDOANBUbNoAKDE4N2Y0YjllYjg5N2EwOGMxMjQ3NDJlMDE4YjMyM2MxYWQ2YzkxODk", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-04-20T16:10:15Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-04-28T10:16:43Z"}, "message": "gccrs: qualified path syntax is used to disambiguate predicates\n\nWhen resolving a qualified path we need to use the predicate to lookup the\nrelevant assoicated impl block where possible. The issue here is that\nit might not have one due to a valid error in the impl block or it might\nbe used within a trait this is a valid case. Generally we will be able to\nresolve to an impl block then it can grab that type and move on.\n\nFixes #2135\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-type-check-path.cc (TypeCheckExpr::visit): use the predicate\n\t(TypeCheckExpr::resolve_segments): cleanup\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-2135.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "d307e2a7e363275c220fbe14f69fb77e074a1432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d307e2a7e363275c220fbe14f69fb77e074a1432"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/187f4b9eb897a08c124742e018b323c1ad6c9189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187f4b9eb897a08c124742e018b323c1ad6c9189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187f4b9eb897a08c124742e018b323c1ad6c9189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187f4b9eb897a08c124742e018b323c1ad6c9189/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c13032e55c0bd39557c6366729e4afca3890c6c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13032e55c0bd39557c6366729e4afca3890c6c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13032e55c0bd39557c6366729e4afca3890c6c1"}], "stats": {"total": 101, "additions": 66, "deletions": 35}, "files": [{"sha": "67b8d24b5a9e5cb69377ca71456d05e24bc80430", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187f4b9eb897a08c124742e018b323c1ad6c9189/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187f4b9eb897a08c124742e018b323c1ad6c9189/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=187f4b9eb897a08c124742e018b323c1ad6c9189", "patch": "@@ -69,49 +69,63 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n   // inherit the bound\n   root->inherit_bounds ({specified_bound});\n \n-  // setup the associated types\n-  const TraitReference *specified_bound_ref = specified_bound.get ();\n-  auto candidates = TypeBoundsProbe::Probe (root);\n-  AssociatedImplTrait *associated_impl_trait = nullptr;\n-  for (auto &probed_bound : candidates)\n+  // lookup the associated item from the specified bound\n+  HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n+  HIR::PathIdentSegment item_seg_identifier = item_seg.get_segment ();\n+  TyTy::TypeBoundPredicateItem item\n+    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n+  if (item.is_error ())\n     {\n-      const TraitReference *bound_trait_ref = probed_bound.first;\n-      const HIR::ImplBlock *associated_impl = probed_bound.second;\n-\n-      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n-      AssociatedImplTrait *associated = nullptr;\n-      bool found_impl_trait\n-\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n-      if (found_impl_trait)\n+      rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n+      return;\n+    }\n+\n+  // we try to look for the real impl item if possible\n+  HIR::ImplItem *impl_item = nullptr;\n+\n+  // lookup the associated impl trait for this if we can (it might be generic)\n+  AssociatedImplTrait *associated_impl_trait\n+    = lookup_associated_impl_block (specified_bound, root);\n+  if (associated_impl_trait != nullptr)\n+    {\n+      for (auto &i :\n+\t   associated_impl_trait->get_impl_block ()->get_impl_items ())\n \t{\n-\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n-\t  bool found_self = associated->get_self ()->can_eq (root, false);\n-\t  if (found_trait && found_self)\n+\t  bool found = i->get_impl_item_name ().compare (\n+\t\t\t item_seg_identifier.as_string ())\n+\t\t       == 0;\n+\t  if (found)\n \t    {\n-\t      associated_impl_trait = associated;\n+\t      impl_item = i.get ();\n \t      break;\n \t    }\n \t}\n     }\n \n-  if (associated_impl_trait != nullptr)\n+  NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+  if (impl_item == nullptr)\n     {\n-      associated_impl_trait->setup_associated_types (root, specified_bound);\n+      // this may be valid as there could be a default trait implementation here\n+      // and we dont need to worry if the trait item is actually implemented or\n+      // not because this will have already been validated as part of the trait\n+      // impl block\n+      infered = item.get_tyty_for_receiver (root);\n+      root_resolved_node_id\n+\t= item.get_raw_item ()->get_mappings ().get_nodeid ();\n     }\n-\n-  // lookup the associated item from the specified bound\n-  HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n-  HIR::PathIdentSegment item_seg_identifier = item_seg.get_segment ();\n-  TyTy::TypeBoundPredicateItem item\n-    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n-  if (item.is_error ())\n+  else\n     {\n-      rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n-      return;\n-    }\n+      HirId impl_item_id = impl_item->get_impl_mappings ().get_hirid ();\n+      bool ok = query_type (impl_item_id, &infered);\n+      if (!ok)\n+\t{\n+\t  // FIXME\n+\t  // I think query_type should error if required here anyway\n+\t  return;\n+\t}\n \n-  // infer the root type\n-  infered = item.get_tyty_for_receiver (root);\n+      root_resolved_node_id = impl_item->get_impl_mappings ().get_nodeid ();\n+    }\n \n   // turbo-fish segment path::<ty>\n   if (item_seg.has_generic_args ())\n@@ -129,10 +143,7 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     }\n \n   // continue on as a path-in-expression\n-  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n-  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = expr.get_segments ().size () <= 1;\n-\n   if (fully_resolved)\n     {\n       resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n@@ -321,7 +332,8 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n       // candidate is found then we search extensions from traits\n       auto candidates\n \t= PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n-\t\t\t\tfalse, true /*ignore_mandatory_trait_items*/);\n+\t\t\t\tfalse /*probe_bounds*/,\n+\t\t\t\ttrue /*ignore_mandatory_trait_items*/);\n       if (candidates.size () == 0)\n \t{\n \t  candidates"}, {"sha": "563345efee36ded034edf2b94c242a2135c0f474", "filename": "gcc/testsuite/rust/compile/issue-2135.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187f4b9eb897a08c124742e018b323c1ad6c9189/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2135.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187f4b9eb897a08c124742e018b323c1ad6c9189/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2135.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2135.rs?ref=187f4b9eb897a08c124742e018b323c1ad6c9189", "patch": "@@ -0,0 +1,19 @@\n+pub trait Foo<A> {\n+    fn foo(self, _: A) -> u16;\n+}\n+\n+impl Foo<u16> for u16 {\n+    fn foo(self, _: u16) -> u16 {\n+        self\n+    }\n+}\n+\n+impl Foo<u8> for u16 {\n+    fn foo(self, _: u8) -> u16 {\n+        self\n+    }\n+}\n+\n+pub fn bar() -> u16 {\n+    <u16 as Foo<u16>>::foo(0u16, 0u16)\n+}"}]}