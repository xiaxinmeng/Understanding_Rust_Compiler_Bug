{"sha": "0e56e5906568a70ee8c2f8596437e9194dc88b81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1NmU1OTA2NTY4YTcwZWU4YzJmODU5NjQzN2U5MTk0ZGM4OGI4MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-09-28T14:48:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-28T14:48:30Z"}, "message": "libgo: Use libbacktrace rather than debug/elf registration.\n\nFrom-SVN: r191831", "tree": {"sha": "925434497da8b45f5bb1b591f8748e05c857d9a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/925434497da8b45f5bb1b591f8748e05c857d9a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e56e5906568a70ee8c2f8596437e9194dc88b81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e56e5906568a70ee8c2f8596437e9194dc88b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e56e5906568a70ee8c2f8596437e9194dc88b81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e56e5906568a70ee8c2f8596437e9194dc88b81/comments", "author": null, "committer": null, "parents": [{"sha": "d10402b413dfbc968d7edf21415c659db1646345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10402b413dfbc968d7edf21415c659db1646345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d10402b413dfbc968d7edf21415c659db1646345"}], "stats": {"total": 429, "additions": 173, "deletions": 256}, "files": [{"sha": "38217c4b897054009f9051c014c7cf73fcd0991b", "filename": "ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -1,3 +1,9 @@\n+2012-09-28  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Makefile.def: Make all-target-libgo depend on\n+\tall-target-libbacktrace.\n+\t* Makefile.in: Rebuild.\n+\n 2012-09-26  Ian Lance Taylor  <iant@google.com>\n \n \t* Makefile.def: Make all-gcc depend on all-libbacktrace."}, {"sha": "c22388a0702eaace91b422b55272652cb46e6512", "filename": "Makefile.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -491,6 +491,7 @@ dependencies = { module=configure-target-fastjar; on=configure-target-zlib; };\n dependencies = { module=all-target-fastjar; on=all-target-zlib; };\n dependencies = { module=configure-target-libgo; on=configure-target-libffi; };\n dependencies = { module=configure-target-libgo; on=all-target-libstdc++-v3; };\n+dependencies = { module=all-target-libgo; on=all-target-libbacktrace; };\n dependencies = { module=all-target-libgo; on=all-target-libffi; };\n dependencies = { module=configure-target-libjava; on=configure-target-zlib; };\n dependencies = { module=configure-target-libjava; on=configure-target-boehm-gc; };"}, {"sha": "9536afffbca2fe92b3da5497720282af841677f6", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -45348,6 +45348,7 @@ configure-target-fastjar: maybe-configure-target-zlib\n all-target-fastjar: maybe-all-target-zlib\n configure-target-libgo: maybe-configure-target-libffi\n configure-target-libgo: maybe-all-target-libstdc++-v3\n+all-target-libgo: maybe-all-target-libbacktrace\n all-target-libgo: maybe-all-target-libffi\n configure-target-libjava: maybe-configure-target-zlib\n configure-target-libjava: maybe-configure-target-boehm-gc"}, {"sha": "084399d41724d9a3f4d11e7615a2ea1c4eeb1055", "filename": "libgo/Makefile.am", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -39,7 +39,8 @@ ACLOCAL_AMFLAGS = -I ./config -I ../config\n \n AM_CFLAGS = -fexceptions -fplan9-extensions $(SPLIT_STACK) $(WARN_CFLAGS) \\\n \t$(STRINGOPS_FLAG) $(OSCFLAGS) \\\n-\t-I $(srcdir)/../libgcc -I $(MULTIBUILDTOP)../../gcc/include\n+\t-I $(srcdir)/../libgcc -I $(srcdir)/../libbacktrace \\\n+\t-I $(MULTIBUILDTOP)../../gcc/include\n \n if USING_SPLIT_STACK\n AM_LDFLAGS = -XCClinker $(SPLIT_STACK)\n@@ -1062,8 +1063,7 @@ go_debug_dwarf_files = \\\n \tgo/debug/dwarf/unit.go\n go_debug_elf_files = \\\n \tgo/debug/elf/elf.go \\\n-\tgo/debug/elf/file.go \\\n-\tgo/debug/elf/runtime.go\n+\tgo/debug/elf/file.go\n go_debug_gosym_files = \\\n \tgo/debug/gosym/pclntab.go \\\n \tgo/debug/gosym/symtab.go\n@@ -1782,7 +1782,8 @@ libgo_la_SOURCES = $(runtime_files)\n libgo_la_LDFLAGS = $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n \n libgo_la_LIBADD = \\\n-\t$(libgo_go_objs) $(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS)\n+\t$(libgo_go_objs) ../libbacktrace/libbacktrace.la \\\n+\t$(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS)\n \n libgobegin_a_SOURCES = \\\n \truntime/go-main.c"}, {"sha": "8fd098679d20ade7a665292796b5088155fac3ec", "filename": "libgo/Makefile.in", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -169,7 +169,8 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \ttext/tabwriter.lo text/template.lo text/template/parse.lo \\\n \ttesting/iotest.lo testing/quick.lo unicode/utf16.lo \\\n \tunicode/utf8.lo\n-libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n+libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \\\n+\t../libbacktrace/libbacktrace.la $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n @LIBGO_IS_LINUX_FALSE@am__objects_1 = lock_sema.lo thread-sema.lo\n@@ -435,7 +436,8 @@ AM_CPPFLAGS = -I $(srcdir)/runtime $(LIBFFIINCS) $(PTHREAD_CFLAGS)\n ACLOCAL_AMFLAGS = -I ./config -I ../config\n AM_CFLAGS = -fexceptions -fplan9-extensions $(SPLIT_STACK) $(WARN_CFLAGS) \\\n \t$(STRINGOPS_FLAG) $(OSCFLAGS) \\\n-\t-I $(srcdir)/../libgcc -I $(MULTIBUILDTOP)../../gcc/include\n+\t-I $(srcdir)/../libgcc -I $(srcdir)/../libbacktrace \\\n+\t-I $(MULTIBUILDTOP)../../gcc/include\n \n @USING_SPLIT_STACK_TRUE@AM_LDFLAGS = -XCClinker $(SPLIT_STACK)\n \n@@ -1287,8 +1289,7 @@ go_debug_dwarf_files = \\\n \n go_debug_elf_files = \\\n \tgo/debug/elf/elf.go \\\n-\tgo/debug/elf/file.go \\\n-\tgo/debug/elf/runtime.go\n+\tgo/debug/elf/file.go\n \n go_debug_gosym_files = \\\n \tgo/debug/gosym/pclntab.go \\\n@@ -1932,7 +1933,8 @@ libgo_go_objs = \\\n libgo_la_SOURCES = $(runtime_files)\n libgo_la_LDFLAGS = $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n libgo_la_LIBADD = \\\n-\t$(libgo_go_objs) $(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS)\n+\t$(libgo_go_objs) ../libbacktrace/libbacktrace.la \\\n+\t$(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS)\n \n libgobegin_a_SOURCES = \\\n \truntime/go-main.c"}, {"sha": "67b961b5c6c20acfaa134d5ae6247d4e14eeb7a7", "filename": "libgo/go/debug/elf/elf_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fdebug%2Felf%2Felf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fdebug%2Felf%2Felf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf_test.go?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -2,10 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package elf_test\n+package elf\n \n import (\n-\t. \"debug/elf\"\n \t\"fmt\"\n \t\"testing\"\n )"}, {"sha": "98f2723c86e6e1d3f3108254ed5e6bde2c7700c7", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -2,11 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package elf_test\n+package elf\n \n import (\n \t\"debug/dwarf\"\n-\t. \"debug/elf\"\n \t\"encoding/binary\"\n \t\"net\"\n \t\"os\""}, {"sha": "17cb6fbc99efd28ab8141f09cd974d843c8fd2cb", "filename": "libgo/go/debug/elf/runtime.go", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10402b413dfbc968d7edf21415c659db1646345/libgo%2Fgo%2Fdebug%2Felf%2Fruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10402b413dfbc968d7edf21415c659db1646345/libgo%2Fgo%2Fdebug%2Felf%2Fruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Fruntime.go?ref=d10402b413dfbc968d7edf21415c659db1646345", "patch": "@@ -1,161 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This is gccgo-specific code that uses DWARF information to fetch\n-// file/line information for PC values.  This package registers itself\n-// with the runtime package.\n-\n-package elf\n-\n-import (\n-\t\"debug/dwarf\"\n-\t\"debug/macho\"\n-\t\"os\"\n-\t\"runtime\"\n-\t\"sort\"\n-\t\"sync\"\n-)\n-\n-func init() {\n-\t// Register our lookup functions with the runtime package.\n-\truntime.RegisterDebugLookup(funcFileLine, symbolValue)\n-}\n-\n-// The file struct holds information for a specific file that is part\n-// of the execution.\n-type file struct {\n-\telf   *File       // If ELF\n-\tmacho *macho.File // If Mach-O\n-\tdwarf *dwarf.Data // DWARF information\n-\n-\tsymsByName []sym // Sorted by name\n-\tsymsByAddr []sym // Sorted by address\n-}\n-\n-// Sort symbols by name.\n-type symsByName []sym\n-\n-func (s symsByName) Len() int           { return len(s) }\n-func (s symsByName) Less(i, j int) bool { return s[i].name < s[j].name }\n-func (s symsByName) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n-\n-// Sort symbols by address.\n-type symsByAddr []sym\n-\n-func (s symsByAddr) Len() int           { return len(s) }\n-func (s symsByAddr) Less(i, j int) bool { return s[i].addr < s[j].addr }\n-func (s symsByAddr) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n-\n-// The sym structure holds the information we care about for a symbol,\n-// namely name and address.\n-type sym struct {\n-\tname string\n-\taddr uintptr\n-}\n-\n-// Open an input file.\n-func open(name string) (*file, error) {\n-\tefile, err := Open(name)\n-\tvar mfile *macho.File\n-\tif err != nil {\n-\t\tvar merr error\n-\t\tmfile, merr = macho.Open(name)\n-\t\tif merr != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\tr := &file{elf: efile, macho: mfile}\n-\n-\tif efile != nil {\n-\t\tr.dwarf, err = efile.DWARF()\n-\t} else {\n-\t\tr.dwarf, err = mfile.DWARF()\n-\t}\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar syms []sym\n-\tif efile != nil {\n-\t\tesyms, err := efile.Symbols()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tsyms = make([]sym, 0, len(esyms))\n-\t\tfor _, s := range esyms {\n-\t\t\tif ST_TYPE(s.Info) == STT_FUNC {\n-\t\t\t\tsyms = append(syms, sym{s.Name, uintptr(s.Value)})\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\tsyms = make([]sym, 0, len(mfile.Symtab.Syms))\n-\t\tfor _, s := range mfile.Symtab.Syms {\n-\t\t\tsyms = append(syms, sym{s.Name, uintptr(s.Value)})\n-\t\t}\n-\t}\n-\n-\tr.symsByName = make([]sym, len(syms))\n-\tcopy(r.symsByName, syms)\n-\tsort.Sort(symsByName(r.symsByName))\n-\n-\tr.symsByAddr = syms\n-\tsort.Sort(symsByAddr(r.symsByAddr))\n-\n-\treturn r, nil\n-}\n-\n-// The main executable\n-var executable *file\n-\n-// Only open the executable once.\n-var executableOnce sync.Once\n-\n-func openExecutable() {\n-\texecutableOnce.Do(func() {\n-\t\tf, err := open(\"/proc/self/exe\")\n-\t\tif err != nil {\n-\t\t\tf, err = open(os.Args[0])\n-\t\t\tif err != nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t\texecutable = f\n-\t})\n-}\n-\n-// The funcFileLine function looks up the function name, file name,\n-// and line number for a PC value.\n-func funcFileLine(pc uintptr, function *string, file *string, line *int) bool {\n-\topenExecutable()\n-\tif executable == nil || executable.dwarf == nil {\n-\t\treturn false\n-\t}\n-\tf, ln, err := executable.dwarf.FileLine(uint64(pc))\n-\tif err != nil {\n-\t\treturn false\n-\t}\n-\t*file = f\n-\t*line = ln\n-\n-\t*function = \"\"\n-\tif len(executable.symsByAddr) > 0 && pc >= executable.symsByAddr[0].addr {\n-\t\ti := sort.Search(len(executable.symsByAddr),\n-\t\t\tfunc(i int) bool { return executable.symsByAddr[i].addr > pc })\n-\t\t*function = executable.symsByAddr[i-1].name\n-\t}\n-\n-\treturn true\n-}\n-\n-// The symbolValue function fetches the value of a symbol.\n-func symbolValue(name string, val *uintptr) bool {\n-\ti := sort.Search(len(executable.symsByName),\n-\t\tfunc(i int) bool { return executable.symsByName[i].name >= name })\n-\tif i >= len(executable.symsByName) || executable.symsByName[i].name != name {\n-\t\treturn false\n-\t}\n-\t*val = executable.symsByName[i].addr\n-\treturn true\n-}"}, {"sha": "06fcde1447fb6148bfa6a4b8c8ab323d89bb668f", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -35,7 +35,6 @@ package pprof\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"html/template\"\n \t\"io\""}, {"sha": "df647ef73c0f8fda053474f95454209a1358c646", "filename": "libgo/go/net/ip_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fnet%2Fip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fnet%2Fip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip_test.go?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -6,7 +6,6 @@ package net\n \n import (\n \t\"bytes\"\n-\t_ \"debug/elf\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"testing\""}, {"sha": "a533a5c3bf48cf42632c9721d42b940c8e27d83a", "filename": "libgo/go/runtime/debug/stack.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -8,7 +8,6 @@ package debug\n \n import (\n \t\"bytes\"\n-\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\""}, {"sha": "f67e8a8f9aef882524c35f7517c7f1b6ec816934", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -11,7 +11,6 @@ package pprof\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"io\"\n \t\"runtime\""}, {"sha": "f59ce8ed6f7300d66ce21786dbf1225e8dc6360e", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -79,7 +79,6 @@\n package testing\n \n import (\n-\t_ \"debug/elf\"\n \t\"flag\"\n \t\"fmt\"\n \t\"os\""}, {"sha": "7d5df852886e1f500bf021b12d7dc5fb6b0969c2", "filename": "libgo/runtime/go-caller.c", "status": "modified", "additions": 115, "deletions": 35, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fruntime%2Fgo-caller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fruntime%2Fgo-caller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-caller.c?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -8,41 +8,99 @@\n \n #include <stdint.h>\n \n+#include \"backtrace.h\"\n+\n #include \"runtime.h\"\n #include \"go-string.h\"\n \n /* Get the function name, file name, and line number for a PC value.\n-   We use the DWARF debug information to get this.  Rather than write\n-   a whole new library in C, we use the existing Go library.\n-   Unfortunately, the Go library is only available if the debug/elf\n-   package is imported (we use debug/elf for both ELF and Mach-O, in\n-   this case).  We arrange for the debug/elf package to register\n-   itself, and tweak the various packages that need this information\n-   to import debug/elf where possible.  */\n+   We use the backtrace library to get this.  */\n+\n+/* Data structure to gather file/line information.  */\n+\n+struct caller\n+{\n+  struct __go_string fn;\n+  struct __go_string file;\n+  int line;\n+};\n+\n+/* Collect file/line information for a PC value.  If this is called\n+   more than once, due to inlined functions, we use the last call, as\n+   that is usually the most useful one.  */\n+\n+static int\n+callback (void *data, uintptr_t pc __attribute__ ((unused)),\n+\t  const char *filename, int lineno, const char *function)\n+{\n+  struct caller *c = (struct caller *) data;\n+\n+  if (function == NULL)\n+    {\n+      c->fn.__data = NULL;\n+      c->fn.__length = 0;\n+    }\n+  else\n+    {\n+      char *s;\n+\n+      c->fn.__length = __builtin_strlen (function);\n+      s = runtime_malloc (c->fn.__length);\n+      __builtin_memcpy (s, function, c->fn.__length);\n+      c->fn.__data = (unsigned char *) s;\n+    }\n+\n+  if (filename == NULL)\n+    {\n+      c->file.__data = NULL;\n+      c->file.__length = 0;\n+    }\n+  else\n+    {\n+      char *s;\n+\n+      c->file.__length = __builtin_strlen (filename);\n+      s = runtime_malloc (c->file.__length);\n+      __builtin_memcpy (s, filename, c->file.__length);\n+      c->file.__data = (unsigned char *) s;\n+    }\n+\n+  c->line = lineno;\n+\n+  return 0;\n+}\n \n-/* The function that returns function/file/line information.  */\n+/* The error callback for backtrace_pcinfo and backtrace_syminfo.  */\n \n-typedef _Bool (*infofn_type) (uintptr_t, struct __go_string *,\n-\t\t\t      struct __go_string *, int *);\n-static infofn_type infofn;\n+static void\n+error_callback (void *data __attribute__ ((unused)),\n+\t\tconst char *msg, int errnum)\n+{\n+  if (errnum == -1)\n+    return;\n+  if (errnum > 0)\n+    runtime_printf (\"%s errno %d\\n\", msg, errnum);\n+  runtime_throw (msg);\n+}\n+\n+/* The backtrace library state.  */\n \n-/* The function that returns the value of a symbol, used to get the\n-   entry address of a function.  */\n+static void *back_state;\n \n-typedef _Bool (*symvalfn_type) (struct __go_string, uintptr_t *);\n-static symvalfn_type symvalfn;\n+/* A lock to control creating back_state.  */\n \n-/* This is called by debug/elf to register the function that returns\n-   function/file/line information.  */\n+static Lock back_state_lock;\n \n-void RegisterDebugLookup (infofn_type, symvalfn_type)\n-  __asm__ (\"runtime.RegisterDebugLookup\");\n+/* Fetch back_state, creating it if necessary.  */\n \n-void\n-RegisterDebugLookup (infofn_type pi, symvalfn_type ps)\n+struct backtrace_state *\n+__go_get_backtrace_state ()\n {\n-  infofn = pi;\n-  symvalfn = ps;\n+  runtime_lock (&back_state_lock);\n+  if (back_state == NULL)\n+    back_state = backtrace_create_state (NULL, 1, error_callback, NULL);\n+  runtime_unlock (&back_state_lock);\n+  return back_state;\n }\n \n /* Return function/file/line information for PC.  */\n@@ -51,19 +109,38 @@ _Bool\n __go_file_line (uintptr pc, struct __go_string *fn, struct __go_string *file,\n \t\tint *line)\n {\n-  if (infofn == NULL)\n-    return 0;\n-  return infofn (pc, fn, file, line);\n+  struct caller c;\n+\n+  runtime_memclr (&c, sizeof c);\n+  backtrace_pcinfo (__go_get_backtrace_state (), pc, callback,\n+\t\t    error_callback, &c);\n+  *fn = c.fn;\n+  *file = c.file;\n+  *line = c.line;\n+  return c.file.__length > 0;\n }\n \n-/* Return the value of a symbol.  */\n+/* Collect symbol information.  */\n \n-_Bool\n-__go_symbol_value (struct __go_string sym, uintptr_t *val)\n+static void\n+syminfo_callback (void *data, uintptr_t pc __attribute__ ((unused)),\n+\t\t  const char *symname __attribute__ ((unused)),\n+\t\t  uintptr_t address)\n+{\n+  uintptr_t *pval = (uintptr_t *) data;\n+\n+  *pval = address;\n+}\n+\n+/* Set *VAL to the value of the symbol for PC.  */\n+\n+static _Bool\n+__go_symbol_value (uintptr_t pc, uintptr_t *val)\n {\n-  if (symvalfn == NULL)\n-    return 0;\n-  return symvalfn (sym, val);\n+  *val = 0;\n+  backtrace_syminfo (__go_get_backtrace_state (), pc, syminfo_callback,\n+\t\t     error_callback, &val);\n+  return *val != 0;\n }\n \n /* The values returned by runtime.Caller.  */\n@@ -112,12 +189,15 @@ FuncForPC (uintptr_t pc)\n \n   if (!__go_file_line (pc, &fn, &file, &line))\n     return NULL;\n-  if (!__go_symbol_value (fn, &val))\n-    return NULL;\n \n   ret = (Func *) runtime_malloc (sizeof (*ret));\n   ret->name = fn;\n-  ret->entry = val;\n+\n+  if (__go_symbol_value (pc, &val))\n+    ret->entry = val;\n+  else\n+    ret->entry = 0;\n+\n   return ret;\n }\n "}, {"sha": "71d69f6ad5d1434e8152fbe99fbf354d5940b362", "filename": "libgo/runtime/go-callers.c", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -6,64 +6,56 @@\n \n #include \"config.h\"\n \n-#include \"unwind.h\"\n+#include \"backtrace.h\"\n \n #include \"runtime.h\"\n \n-/* Argument passed to backtrace function.  */\n+/* Argument passed to callback function.  */\n \n struct callers_data\n {\n-  int skip;\n   uintptr *pcbuf;\n   int index;\n   int max;\n };\n \n-static _Unwind_Reason_Code\n-backtrace (struct _Unwind_Context *context, void *varg)\n+/* Callback function for backtrace_simple.  Just collect the PC\n+   values.  Return zero to continue, non-zero to stop.  */\n+\n+static int\n+callback (void *data, uintptr_t pc)\n+{\n+  struct callers_data *arg = (struct callers_data *) data;\n+\n+  arg->pcbuf[arg->index] = pc;\n+  ++arg->index;\n+  return arg->index >= arg->max;\n+}\n+\n+/* Error callback.  */\n+\n+static void\n+error_callback (void *data __attribute__ ((unused)),\n+\t\tconst char *msg, int errnum)\n {\n-  struct callers_data *arg = (struct callers_data *) varg;\n-  uintptr pc;\n-  int ip_before_insn = 0;\n-\n-#ifdef HAVE_GETIPINFO\n-  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n-#else\n-  pc = _Unwind_GetIP (context);\n-#endif\n-\n-  /* FIXME: If PC is in the __morestack routine, we should ignore\n-     it.  */\n-\n-  if (arg->skip > 0)\n-    --arg->skip;\n-  else if (arg->index >= arg->max)\n-    return _URC_END_OF_STACK;\n-  else\n-    {\n-      /* Here PC will be the return address.  We actually want the\n-\t address of the call instruction, so back up one byte and\n-\t count on the lookup routines handling that correctly.  */\n-      if (!ip_before_insn)\n-\t--pc;\n-      arg->pcbuf[arg->index] = pc;\n-      ++arg->index;\n-    }\n-  return _URC_NO_REASON;\n+  if (errnum != 0)\n+    runtime_printf (\"%s errno %d\\n\", msg, errnum);\n+  runtime_throw (msg);\n }\n \n+/* Gather caller PC's.  */\n+\n int32\n runtime_callers (int32 skip, uintptr *pcbuf, int32 m)\n {\n-  struct callers_data arg;\n-\n-  arg.skip = skip + 1;\n-  arg.pcbuf = pcbuf;\n-  arg.index = 0;\n-  arg.max = m;\n-  _Unwind_Backtrace (backtrace, &arg);\n-  return arg.index;\n+  struct callers_data data;\n+\n+  data.pcbuf = pcbuf;\n+  data.index = 0;\n+  data.max = m;\n+  backtrace_simple (__go_get_backtrace_state (), skip + 1, callback,\n+\t\t    error_callback, &data);\n+  return data.index;\n }\n \n int Callers (int, struct __go_open_array)"}, {"sha": "f96d740fb1cee69cf5f2ce7beefca8d979a156ed", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e56e5906568a70ee8c2f8596437e9194dc88b81/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=0e56e5906568a70ee8c2f8596437e9194dc88b81", "patch": "@@ -517,6 +517,8 @@ void\t__go_register_gc_roots(struct root_list*);\n // the stacks are allocated by the splitstack library.\n extern uintptr runtime_stacks_sys;\n \n-extern _Bool __go_file_line (uintptr, String*, String*, int *);\n+struct backtrace_state;\n+extern struct backtrace_state *__go_get_backtrace_state(void);\n+extern _Bool __go_file_line(uintptr, String*, String*, int *);\n \n int32 getproccount(void);"}]}