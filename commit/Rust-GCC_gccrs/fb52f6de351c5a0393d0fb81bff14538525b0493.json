{"sha": "fb52f6de351c5a0393d0fb81bff14538525b0493", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI1MmY2ZGUzNTFjNWEwMzkzZDBmYjgxYmZmMTQ1Mzg1MjViMDQ5Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-08-22T00:30:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-08-22T00:30:16Z"}, "message": "release notes\n\nFrom-SVN: r14883", "tree": {"sha": "5bde4ab48a6b252bb1ec87054a16df25fbb969c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bde4ab48a6b252bb1ec87054a16df25fbb969c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb52f6de351c5a0393d0fb81bff14538525b0493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb52f6de351c5a0393d0fb81bff14538525b0493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb52f6de351c5a0393d0fb81bff14538525b0493", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb52f6de351c5a0393d0fb81bff14538525b0493/comments", "author": null, "committer": null, "parents": [{"sha": "51e3ba163a15e7acf89aaa11c7a1afe9fcedeaff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e3ba163a15e7acf89aaa11c7a1afe9fcedeaff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e3ba163a15e7acf89aaa11c7a1afe9fcedeaff"}], "stats": {"total": 139, "additions": 139, "deletions": 0}, "files": [{"sha": "8f057ef5815986536539e8d74f1a9c38e106c27b", "filename": "gcc/cp/NEWS", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb52f6de351c5a0393d0fb81bff14538525b0493/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb52f6de351c5a0393d0fb81bff14538525b0493/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=fb52f6de351c5a0393d0fb81bff14538525b0493", "patch": "@@ -0,0 +1,139 @@\n+*** Changes since G++ version 2.7.2:\n+\n+* A public review copy of the December 1996 Draft of the ANSI C++\n+  proto-standard is now available. See\n+\n+\thttp://www.cygnus.com/misc/wp/\n+\n+  for more information.\n+\n+* Default function arguments in templates will not be evaluated (or\n+  checked for semantic validity) unless they are needed.\n+\n+* The -ftemplate-depth-NN flag can be used to increase the maximum\n+  recursive template instantiation depth, defaulting to 17. If you need\n+  to use this flag, the compiler will tell you.\n+\n+* The internal interface between RTTI-using code and the RTTI support\n+  library has changed, so code that uses dynamic_cast should be\n+  recompiled. The RTTI support library has moved from libstdc++ to\n+  libgcc, so you no longer need to link against libstdc++ for a program\n+  that doesn't use the \"hosted\" library.\n+\n+* bool is now always the same size as another built-in type. Previously,\n+  a 64-bit RISC target using a 32-bit ABI would have 32-bit pointers and a\n+  64-bit bool. This should only affect Irix 6, which was not supported in\n+  2.7.2.\n+\n+* new (nothrow) is now supported.\n+\n+* A flag -Weffc++ has been added for violations of some of the style \n+  guidelines in Scott Meyers' _Effective C++_ books.\n+\n+* On ELF systems, duplicate copies of symbols with 'initialized common'\n+  linkage (such as template instantiations, vtables, and extern inlines)\n+  will now be discarded by the GNU linker, so you don't need to use -frepo.\n+  This support requires GNU ld from binutils 2.8 or later.\n+\n+* Partial specialization of class templates is now supported.\n+\n+* The overload resolution code has been rewritten to conform to the latest\n+  C++ Working Paper.  Built-in operators are now considered as candidates\n+  in operator overload resolution.  Function template overloading chooses\n+  the more specialized template, and handles base classes in type deduction\n+  and guiding declarations properly.  In this release the old code can\n+  still be selected with -fno-ansi-overloading, although this is not\n+  supported and will be removed in a future release.\n+\n+* RTTI support has been rewritten to work properly and is now on by default.\n+  This means code that uses virtual functions will have a modest space\n+  overhead.  You can use the -fno-rtti flag to disable RTTI support.\n+\n+* Synthesized destructors are no longer made virtual just because the class\n+  already has virtual functions, only if they override a virtual destructor\n+  in a base class.  The compiler will warn if this affects your code.\n+\n+* The g++ driver no longer links with libg++ by default; it is now\n+  functionally identical to the c++ driver.\n+\n+* (void *)0 is no longer considered a null pointer constant; NULL in\n+  <stddef.h> is now defined as __null, a magic constant of type (void *)\n+  normally, or (size_t) with -ansi.\n+\n+* The new 'template <>' specialization syntax is now accepted and ignored.\n+\n+* The name of a class is now implicitly declared in its own scope; A::A\n+  refers to A.\n+\n+* g++ now uses a new implementation of templates. The basic idea is that\n+  now templates are minimally parsed when seen and then expanded later.\n+  This allows conformant early name binding and instantiation controls,\n+  since instantiations no longer have to go through the parser.\n+\n+  What you get:\n+\n+     + Inlining of template functions works without any extra effort or\n+       modifications.\n+     + Instantiations of class templates and methods defined in the class\n+       body are deferred until they are actually needed (unless\n+       -fexternal-templates is specified).\n+     + Nested types in class templates work.\n+     + Static data member templates work.\n+\n+  Possible problems:\n+\n+     + Types and class templates used in templates must be declared\n+       first, or the compiler will assume they are not types, and fail.\n+     + Similarly, nested types of template type parameters must be tagged\n+       with the 'typename' keyword.  In many cases, the compiler will tell\n+       you where you need to add 'typename'.\n+     + Syntax errors in templates that are never instantiated will now be\n+       diagnosed.\n+\n+* Synthesized methods are now emitted in any translation units that need\n+  an out-of-line copy. They are no longer affected by #pragma interface\n+  or #pragma implementation.\n+\n+* Local classes are now supported.\n+\n+* -Wall no longer implies -W.\n+  The new warning flag, -Wsign-compare, included in -Wall, warns about\n+  dangerous comparisons of signed and unsigned values. Only the flag is\n+  new; it was previously part of -W.\n+\n+* The new flag, -fno-weak, disables the use of weak symbols.\n+\n+* __attribute__ can now be attached to types as well as declarations.\n+\n+* -Woverloaded-virtual now warns if a virtual function in a base class is\n+  hidden in a derived class, rather than warning about virtual functions\n+  being overloaded (even if all of the inherited signatures are\n+  overridden) as it did before.\n+\n+* The compiler no longer emits a warning if an ellipsis is used as a\n+  function's argument list.\n+\n+* Exception handling support has been significantly improved and is on by\n+  default.  This can result in significant runtime overhead.  You can turn\n+  it off with -fno-exceptions.\n+\n+* Definition of nested types outside of their containing class is now\n+  supported. Use the following source code, as an example.\n+\n+       struct A {\n+              struct B;\n+              B* bp;\n+       };\n+\n+       struct A::B {\n+              int member;\n+       };\n+\n+* Explicit instantiation of template constructors and destructors is now\n+  supported. Use the following source code, as an example.\n+\n+       template A<int>::A(const A&);\n+\n+* On the HPPA, some classes that do not define a copy constructor\n+  will be passed and returned in memory again so that functions\n+  returning those types can be inlined."}]}