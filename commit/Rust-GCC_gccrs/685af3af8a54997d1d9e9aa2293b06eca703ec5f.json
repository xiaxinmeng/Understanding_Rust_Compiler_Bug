{"sha": "685af3af8a54997d1d9e9aa2293b06eca703ec5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1YWYzYWY4YTU0OTk3ZDFkOWU5YWEyMjkzYjA2ZWNhNzAzZWM1Zg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@redhat.com", "date": "2001-03-27T22:48:03Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2001-03-27T22:48:03Z"}, "message": "Fix ia64-linux ICE on bash.\n\n\t* flow.c (struct reg_cond_life_info): New fields orig_condition\n\tand stores.\n\t(init_propagate_block_info): Set new fields.\n\t(mark_regno_cond_dead): Set and use new fields.\n\t(flush_reg_cond_reg_1): Likewise.\n\t(and_reg_cond, case AND): Check for redundant AND conditions.\n\t(mark_used_reg): Delete unnecessary clears before freeing splay trees.\n\tSet new fields.\n\nFrom-SVN: r40881", "tree": {"sha": "28393dfbb1e83e28e13c0a657a5583983d22b562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28393dfbb1e83e28e13c0a657a5583983d22b562"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/685af3af8a54997d1d9e9aa2293b06eca703ec5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685af3af8a54997d1d9e9aa2293b06eca703ec5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685af3af8a54997d1d9e9aa2293b06eca703ec5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685af3af8a54997d1d9e9aa2293b06eca703ec5f/comments", "author": null, "committer": null, "parents": [{"sha": "b044e9d5e9f15c20a62ba92c601128e9630438f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b044e9d5e9f15c20a62ba92c601128e9630438f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b044e9d5e9f15c20a62ba92c601128e9630438f4"}], "stats": {"total": 65, "additions": 53, "deletions": 12}, "files": [{"sha": "07107a411ce967782b3611158b27f540568b3513", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685af3af8a54997d1d9e9aa2293b06eca703ec5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685af3af8a54997d1d9e9aa2293b06eca703ec5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=685af3af8a54997d1d9e9aa2293b06eca703ec5f", "patch": "@@ -1,3 +1,14 @@\n+2001-03-27  Jim Wilson  <wilson@redhat.com>\n+\n+\t* flow.c (struct reg_cond_life_info): New fields orig_condition\n+\tand stores.\n+\t(init_propagate_block_info): Set new fields.\n+\t(mark_regno_cond_dead): Set and use new fields.\n+\t(flush_reg_cond_reg_1): Likewise.\n+\t(and_reg_cond, case AND): Check for redundant AND conditions.\n+\t(mark_used_reg): Delete unnecessary clears before freeing splay trees.\n+\tSet new fields.\n+\n 2001-03-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cppmacro.c (stringify_arg): Null terminate strings."}, {"sha": "6625a6936f5b6914618d1c55e0fb3da0acffcd3a", "filename": "gcc/flow.c", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685af3af8a54997d1d9e9aa2293b06eca703ec5f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685af3af8a54997d1d9e9aa2293b06eca703ec5f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=685af3af8a54997d1d9e9aa2293b06eca703ec5f", "patch": "@@ -275,8 +275,14 @@ static rtx tail_recursion_label_list;\n /* Holds information for tracking conditional register life information.  */\n struct reg_cond_life_info\n {\n-  /* An EXPR_LIST of conditions under which a register is dead.  */\n+  /* A boolean expression of conditions under which a register is dead.  */\n   rtx condition;\n+  /* Conditions under which a register is dead at the basic block end.  */\n+  rtx orig_condition;\n+\n+  /* A boolean expression of conditions under which a register has been\n+     stored into.  */\n+  rtx stores;\n \n   /* ??? Could store mask of bytes that are dead, so that we could finally\n      track lifetimes of multi-word registers accessed via subregs.  */\n@@ -4202,6 +4208,8 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n \t       else\n \t\t cond = cond_true;\n \t       rcli->condition = cond;\n+\t       rcli->stores = const0_rtx;\n+\t       rcli->orig_condition = cond;\n \n \t       splay_tree_insert (pbi->reg_cond_dead, i,\n \t\t\t\t  (splay_tree_value) rcli);\n@@ -5146,6 +5154,8 @@ mark_regno_cond_dead (pbi, regno, cond)\n \t     which it is dead.  */\n \t  rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n \t  rcli->condition = cond;\n+\t  rcli->stores = cond;\n+\t  rcli->orig_condition = const0_rtx;\n \t  splay_tree_insert (pbi->reg_cond_dead, regno,\n \t\t\t     (splay_tree_value) rcli);\n \n@@ -5161,10 +5171,21 @@ mark_regno_cond_dead (pbi, regno, cond)\n \t  rcli = (struct reg_cond_life_info *) node->value;\n \t  ncond = rcli->condition;\n \t  ncond = ior_reg_cond (ncond, cond, 1);\n-\n-\t  /* If the register is now unconditionally dead,\n-\t     remove the entry in the splay_tree.  */\n-\t  if (ncond == const1_rtx)\n+\t  if (rcli->stores == const0_rtx)\n+\t    rcli->stores = cond;\n+\t  else if (rcli->stores != const1_rtx)\n+\t    rcli->stores = ior_reg_cond (rcli->stores, cond, 1);\n+\n+\t  /* If the register is now unconditionally dead, remove the entry\n+\t     in the splay_tree.  A register is unconditionally dead if the\n+\t     dead condition ncond is true.  A register is also unconditionally\n+\t     dead if the sum of all conditional stores is an unconditional\n+\t     store (stores is true), and the dead condition is identically the\n+\t     same as the original dead condition initialized at the end of\n+\t     the block.  This is a pointer compare, not an rtx_equal_p\n+\t     compare.  */\n+\t  if (ncond == const1_rtx\n+\t      || (ncond == rcli->orig_condition && rcli->stores == const1_rtx))\n \t    splay_tree_remove (pbi->reg_cond_dead, regno);\n \t  else\n \t    {\n@@ -5210,6 +5231,8 @@ flush_reg_cond_reg_1 (node, data)\n   /* Splice out portions of the expression that refer to regno.  */\n   rcli = (struct reg_cond_life_info *) node->value;\n   rcli->condition = elim_reg_cond (rcli->condition, regno);\n+  if (rcli->stores != const0_rtx && rcli->stores != const1_rtx)\n+    rcli->stores = elim_reg_cond (rcli->stores, regno);\n \n   /* If the entire condition is now false, signal the node to be removed.  */\n   if (rcli->condition == const0_rtx)\n@@ -5416,6 +5439,17 @@ and_reg_cond (old, x, add)\n \t}\n       if (! add)\n \treturn old;\n+\n+      /* If X is identical to one of the existing terms of the AND,\n+\t then just return what we already have.  */\n+      /* ??? There really should be some sort of recursive check here in\n+\t case there are nested ANDs.  */\n+      if ((GET_CODE (XEXP (old, 0)) == GET_CODE (x)\n+\t   && REGNO (XEXP (XEXP (old, 0), 0)) == REGNO (XEXP (x, 0)))\n+\t  || (GET_CODE (XEXP (old, 1)) == GET_CODE (x)\n+\t      && REGNO (XEXP (XEXP (old, 1), 0)) == REGNO (XEXP (x, 0))))\n+\treturn old;\n+\n       return gen_rtx_AND (0, old, x);\n \n     case NOT:\n@@ -5899,10 +5933,7 @@ mark_used_reg (pbi, reg, cond, insn)\n \t      /* If the register is now unconditionally live, remove the\n \t\t entry in the splay_tree.  */\n \t      if (ncond == const0_rtx)\n-\t\t{\n-\t\t  rcli->condition = NULL_RTX;\n-\t\t  splay_tree_remove (pbi->reg_cond_dead, regno);\n-\t\t}\n+\t\tsplay_tree_remove (pbi->reg_cond_dead, regno);\n \t      else\n \t\t{\n \t\t  rcli->condition = ncond;\n@@ -5916,6 +5947,8 @@ mark_used_reg (pbi, reg, cond, insn)\n \t     the condition under which it is still dead.  */\n \t  rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n \t  rcli->condition = not_reg_cond (cond);\n+\t  rcli->stores = const0_rtx;\n+\t  rcli->orig_condition = const0_rtx;\n \t  splay_tree_insert (pbi->reg_cond_dead, regno,\n \t\t\t     (splay_tree_value) rcli);\n \n@@ -5925,7 +5958,6 @@ mark_used_reg (pbi, reg, cond, insn)\n   else if (some_was_live)\n     {\n       splay_tree_node node;\n-      struct reg_cond_life_info *rcli;\n \n       node = splay_tree_lookup (pbi->reg_cond_dead, regno);\n       if (node != NULL)\n@@ -5934,8 +5966,6 @@ mark_used_reg (pbi, reg, cond, insn)\n \t     unconditionally so.  Remove it from the conditionally dead\n \t     list, so that a conditional set won't cause us to think\n \t     it dead.  */\n-\t  rcli = (struct reg_cond_life_info *) node->value;\n-\t  rcli->condition = NULL_RTX;\n \t  splay_tree_remove (pbi->reg_cond_dead, regno);\n \t}\n     }"}]}