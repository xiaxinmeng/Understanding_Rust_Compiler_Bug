{"sha": "2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkOGQyMjQxZTFlM2JhMDc3ZmM2ZGMzODEzZjIwMmY0NTQxNGZiZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-02-13T21:22:55Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-02-13T21:22:55Z"}, "message": "re PR fortran/26074 (Module array cannot be automatic or assumed shape)\n\n2006-02-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/26074\n\tPR fortran/25103\n\t* resolve.c (resolve_symbol): Extend the requirement that module\n\tarrays have constant bounds to those in the main program.  At the\n\tsame time simplify the array bounds, to avoiding trapping parameter\n\tarray references, and exclude automatic character length from main\n\tand modules. Rearrange resolve_symbol and resolve_derived to put as\n\teach flavor together, as much as is possible and move all specific\n\tcode for flavors FL_VARIABLE, FL_PROCEDURE and FL_PARAMETER into new\n\tfunctions.\n\t(resolve_fl_var_and_proc, resolve_fl_variable, resolve_fl_procedure):\n\tNew functions to do work of resolve_symbol.\n\t(resolve_index_expr): New function that is called from resolved_symbol\n\tand is extracted from resolve_charlen.\n\t(resolve_charlen): Call this new function.\n\t(resolve_fl_derived): Renamed resolve_derived to be consistent with\n\tthe naming of the new functions for the other flavours.  Change the\n\tcharlen checking so that the style is consistent with other similar\n\tchecks. Add the generation of the gfc_dt_list, removed from resolve_\n\tsymbol.\n\n\tPR fortran/20861\n\t* resolve.c (resolve_actual_arglist): Prevent internal procedures\n\tfrom being dummy arguments.\n\n\tPR fortran/20871\n\t* resolve.c (resolve_actual_arglist): Prevent pure but non-intrinsic\n\tprocedures from being dummy arguments.\n\n\tPR fortran/25083\n\t* resolve.c (check_data_variable): Add test that data variable is in\n\tCOMMON.\n\n\tPR fortran/25088\n\t* resolve.c (resolve_call): Add test that the subroutine does not\n\thave a type.\n\n\n2006-02-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/26074\n\tPR fortran/25103\n\t* gfortran.dg/module_parameter_array_refs_1.f90: New test.\n\t* gfortran.dg/bad_automatic_objects_1.f90: New test.\n\t* gfortran.dg/automatic_module_variable.f90: Change error message.\n\n\tPR fortran/20861\n\t* gfortran.dg/internal_dummy_1.f90: New test.\n\n\tPR fortran/20871\n\t* gfortran.dg/elemental_non_intrinsic_dummy_1.f90: New test.\n\n\n\tPR fortran/25083\n\t* gfortran.dg/uncommon_block_data_1.f90: New test.\n\t* gfortran.dg/equiv_constraint_7.f90: Correct non-compliance of test\n\twith standard.\n\n\tPR fortran/25088\n\t* gfortran.dg/typed_subroutine_1.f90: New test.\n\nFrom-SVN: r110926", "tree": {"sha": "ca9b226f8f8ef512a3cc36a94a5c973a3b92f259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca9b226f8f8ef512a3cc36a94a5c973a3b92f259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/comments", "author": null, "committer": null, "parents": [{"sha": "7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cdfcf600a86aa589584192c963a9cc5fa1a12b3"}], "stats": {"total": 903, "additions": 597, "deletions": 306}, "files": [{"sha": "619dd27fbd7fbbb98ce9e84d699cf2a8307861c9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -1,3 +1,42 @@\n+2006-02-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/26074\n+\tPR fortran/25103\n+\t* resolve.c (resolve_symbol): Extend the requirement that module\n+\tarrays have constant bounds to those in the main program.  At the\n+\tsame time simplify the array bounds, to avoiding trapping parameter\n+\tarray references, and exclude automatic character length from main\n+\tand modules. Rearrange resolve_symbol and resolve_derived to put as\n+\teach flavor together, as much as is possible and move all specific\n+\tcode for flavors FL_VARIABLE, FL_PROCEDURE and FL_PARAMETER into new\n+\tfunctions.\n+\t(resolve_fl_var_and_proc, resolve_fl_variable, resolve_fl_procedure):\n+\tNew functions to do work of resolve_symbol.\n+\t(resolve_index_expr): New function that is called from resolved_symbol\n+\tand is extracted from resolve_charlen.\n+\t(resolve_charlen): Call this new function.\n+\t(resolve_fl_derived): Renamed resolve_derived to be consistent with\n+\tthe naming of the new functions for the other flavours.  Change the\n+\tcharlen checking so that the style is consistent with other similar\n+\tchecks. Add the generation of the gfc_dt_list, removed from resolve_\n+\tsymbol.\n+\n+\tPR fortran/20861\n+\t* resolve.c (resolve_actual_arglist): Prevent internal procedures\n+\tfrom being dummy arguments.\n+\n+\tPR fortran/20871\n+\t* resolve.c (resolve_actual_arglist): Prevent pure but non-intrinsic\n+\tprocedures from being dummy arguments.\n+\n+\tPR fortran/25083\n+\t* resolve.c (check_data_variable): Add test that data variable is in\n+\tCOMMON.\n+\n+\tPR fortran/25088\n+\t* resolve.c (resolve_call): Add test that the subroutine does not\n+\thave a type.\n+\n 2006-02-12  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/25806"}, {"sha": "84d5c7b3eeff9f81f6b447ea2fd77c8be05b6446", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 435, "deletions": 303, "changes": 738, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -809,11 +809,25 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n \t  || sym->attr.external)\n \t{\n \n-          if (sym->attr.proc == PROC_ST_FUNCTION)\n-            {\n-              gfc_error (\"Statement function '%s' at %L is not allowed as an \"\n-                         \"actual argument\", sym->name, &e->where);\n-            }\n+\t  if (sym->attr.proc == PROC_ST_FUNCTION)\n+\t    {\n+\t      gfc_error (\"Statement function '%s' at %L is not allowed as an \"\n+\t\t\t \"actual argument\", sym->name, &e->where);\n+\t    }\n+\n+\t  if (sym->attr.contained && !sym->attr.use_assoc\n+\t      && sym->ns->proc_name->attr.flavor != FL_MODULE)\n+\t    {\n+\t      gfc_error (\"Internal procedure '%s' is not allowed as an \"\n+\t\t\t \"actual argument at %L\", sym->name, &e->where);\n+\t    }\n+\n+\t  if (sym->attr.elemental && !sym->attr.intrinsic)\n+\t    {\n+\t      gfc_error (\"ELEMENTAL non-INTRINSIC procedure '%s' is not \"\n+\t\t         \"allowed as an actual argument at %L\", sym->name,\n+\t\t\t &e->where);\n+\t    }\n \n \t  /* If the symbol is the function that names the current (or\n \t     parent) scope, then we really have a variable reference.  */\n@@ -1579,6 +1593,15 @@ resolve_call (gfc_code * c)\n {\n   try t;\n \n+  if (c->symtree && c->symtree->n.sym\n+\t&& c->symtree->n.sym->ts.type != BT_UNKNOWN)\n+    {\n+      gfc_error (\"'%s' at %L has a type, which is not consistent with \"\n+\t\t \"the CALL at %L\", c->symtree->n.sym->name,\n+\t\t &c->symtree->n.sym->declared_at, &c->loc);\n+      return FAILURE;\n+    }\n+\n   /* If the procedure is not internal or module, it must be external and\n      should be checked for usage.  */\n   if (c->symtree && c->symtree->n.sym\n@@ -4459,6 +4482,24 @@ resolve_values (gfc_symbol * sym)\n }\n \n \n+/* Resolve an index expression.  */\n+\n+static try\n+resolve_index_expr (gfc_expr * e)\n+{\n+\n+  if (gfc_resolve_expr (e) == FAILURE)\n+    return FAILURE;\n+\n+  if (gfc_simplify_expr (e, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (gfc_specification_expr (e) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n /* Resolve a charlen structure.  */\n \n static try\n@@ -4469,34 +4510,322 @@ resolve_charlen (gfc_charlen *cl)\n \n   cl->resolved = 1;\n \n-  if (gfc_resolve_expr (cl->length) == FAILURE)\n+  if (resolve_index_expr (cl->length) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_simplify_expr (cl->length, 0) == FAILURE)\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolution of common features of flavors variable and procedure. */\n+\n+static try\n+resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n+{\n+  /* Constraints on deferred shape variable.  */\n+  if (sym->as == NULL || sym->as->type != AS_DEFERRED)\n+    {\n+      if (sym->attr.allocatable)\n+\t{\n+\t  if (sym->attr.dimension)\n+\t    gfc_error (\"Allocatable array '%s' at %L must have \"\n+\t\t       \"a deferred shape\", sym->name, &sym->declared_at);\n+\t  else\n+\t    gfc_error (\"Scalar object '%s' at %L may not be ALLOCATABLE\",\n+\t\t       sym->name, &sym->declared_at);\n+\t    return FAILURE;\n+\t}\n+\n+      if (sym->attr.pointer && sym->attr.dimension)\n+\t{\n+\t  gfc_error (\"Array pointer '%s' at %L must have a deferred shape\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+\n+    }\n+  else\n+    {\n+      if (!mp_flag && !sym->attr.allocatable\n+\t     && !sym->attr.pointer && !sym->attr.dummy)\n+\t{\n+\t  gfc_error (\"Array '%s' at %L cannot have a deferred shape\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t }\n+    }\n+  return SUCCESS;\n+}\n+\n+/* Resolve symbols with flavor variable.  */\n+\n+static try\n+resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n+{\n+  int flag;\n+  int i;\n+  gfc_expr *e;\n+  gfc_expr *constructor_expr;\n+\n+  if (resolve_fl_var_and_proc (sym, mp_flag) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_specification_expr (cl->length) == FAILURE)\n+  /* The shape of a main program or module array needs to be constant.  */\n+  if (sym->as != NULL\n+\t&& sym->ns->proc_name\n+\t&& (sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t     || sym->ns->proc_name->attr.is_main_program)\n+\t&& !sym->attr.use_assoc\n+\t&& !sym->attr.allocatable\n+\t&& !sym->attr.pointer)\n+    {\n+      /* Unfortunately, !gfc_is_compile_time_shape hits a legal case that\n+\t has not been simplified; parameter array references.  Do the\n+\t simplification now.  */\n+      flag = 0;\n+      for (i = 0; i < sym->as->rank; i++)\n+\t{\n+\t  e = sym->as->lower[i];\n+\t  if (e && (resolve_index_expr (e) == FAILURE\n+\t\t|| !gfc_is_constant_expr (e)))\n+\t    {\n+\t      flag = 1;\n+\t      break;\n+\t    }\n+\n+\t  e = sym->as->upper[i];\n+\t  if (e && (resolve_index_expr (e) == FAILURE\n+\t\t|| !gfc_is_constant_expr (e)))\n+\t    {\n+\t      flag = 1;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (flag)\n+\t{\n+\t  gfc_error (\"The module or main program array '%s' at %L must \"\n+\t\t     \"have constant shape\", sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  if (sym->ts.type == BT_CHARACTER)\n+    {\n+      /* Make sure that character string variables with assumed length are\n+\t dummy arguments.  */\n+      e = sym->ts.cl->length;\n+      if (e == NULL && !sym->attr.dummy && !sym->attr.result)\n+\t{\n+\t  gfc_error (\"Entity with assumed character length at %L must be a \"\n+\t\t     \"dummy argument or a PARAMETER\", &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+\n+      if (!gfc_is_constant_expr (e)\n+\t    && !(e->expr_type == EXPR_VARIABLE\n+\t    && e->symtree->n.sym->attr.flavor == FL_PARAMETER)\n+\t    && sym->ns->proc_name\n+\t    && (sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t\t  || sym->ns->proc_name->attr.is_main_program)\n+\t    && !sym->attr.use_assoc)\n+\t{\n+\t  gfc_error (\"'%s' at %L must have constant character length \"\n+\t\t     \"in this context\", sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* Can the symbol have an initializer?  */\n+  flag = 0;\n+  if (sym->attr.allocatable || sym->attr.external || sym->attr.dummy\n+\t|| sym->attr.intrinsic || sym->attr.result)\n+    flag = 1;\n+  else if (sym->attr.dimension && !sym->attr.pointer)\n+    {\n+      /* Don't allow initialization of automatic arrays.  */\n+      for (i = 0; i < sym->as->rank; i++)\n+\t{\n+\t  if (sym->as->lower[i] == NULL\n+\t\t|| sym->as->lower[i]->expr_type != EXPR_CONSTANT\n+\t\t|| sym->as->upper[i] == NULL\n+\t\t|| sym->as->upper[i]->expr_type != EXPR_CONSTANT)\n+\t    {\n+\t      flag = 1;\n+\t      break;\n+\t    }\n+\t}\n+  }\n+\n+  /* Reject illegal initializers.  */\n+  if (sym->value && flag)\n+    {\n+      if (sym->attr.allocatable)\n+\tgfc_error (\"Allocatable '%s' at %L cannot have an initializer\",\n+\t\t   sym->name, &sym->declared_at);\n+      else if (sym->attr.external)\n+\tgfc_error (\"External '%s' at %L cannot have an initializer\",\n+\t\t   sym->name, &sym->declared_at);\n+      else if (sym->attr.dummy)\n+\tgfc_error (\"Dummy '%s' at %L cannot have an initializer\",\n+\t\t   sym->name, &sym->declared_at);\n+      else if (sym->attr.intrinsic)\n+\tgfc_error (\"Intrinsic '%s' at %L cannot have an initializer\",\n+\t\t   sym->name, &sym->declared_at);\n+      else if (sym->attr.result)\n+\tgfc_error (\"Function result '%s' at %L cannot have an initializer\",\n+\t\t   sym->name, &sym->declared_at);\n+      else\n+\tgfc_error (\"Automatic array '%s' at %L cannot have an initializer\",\n+\t\t   sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n+  /* 4th constraint in section 11.3:  \"If an object of a type for which\n+     component-initialization is specified (R429) appears in the\n+     specification-part of a module and does not have the ALLOCATABLE\n+     or POINTER attribute, the object shall have the SAVE attribute.\"  */\n+\n+  constructor_expr = NULL;\n+  if (sym->ts.type == BT_DERIVED && !(sym->value || flag))\n+\tconstructor_expr = gfc_default_initializer (&sym->ts);\n+\n+  if (sym->ns->proc_name\n+\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t&& constructor_expr\n+\t&& !sym->ns->save_all && !sym->attr.save\n+\t&& !sym->attr.pointer && !sym->attr.allocatable)\n+    {\n+      gfc_error(\"Object '%s' at %L must have the SAVE attribute %s\",\n+ \t \tsym->name, &sym->declared_at,\n+\t\t\"for default initialization of a component\");\n+      return FAILURE;\n+    }\n+\n+  /* Assign default initializer.  */\n+  if (sym->ts.type == BT_DERIVED && !(sym->value || flag)\n+\t&& !sym->attr.pointer)\n+    sym->value = gfc_default_initializer (&sym->ts);\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolve a procedure.  */\n+\n+static try\n+resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n+{\n+  gfc_formal_arglist *arg;\n+\n+  if (sym->attr.function\n+\t&& resolve_fl_var_and_proc (sym, mp_flag) == FAILURE)\n     return FAILURE;\n \n+  if (sym->attr.proc == PROC_ST_FUNCTION)\n+    {\n+      if (sym->ts.type == BT_CHARACTER)\n+        {\n+          gfc_charlen *cl = sym->ts.cl;\n+          if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT)\n+            {\n+              gfc_error (\"Character-valued statement function '%s' at %L must \"\n+                         \"have constant length\", sym->name, &sym->declared_at);\n+              return FAILURE;\n+            }\n+        }\n+    }\n+\n+  /* Ensure that derived type formal arguments of a public procedure\n+     are not of a private type.  */\n+  if (gfc_check_access(sym->attr.access, sym->ns->default_access))\n+    {\n+      for (arg = sym->formal; arg; arg = arg->next)\n+\t{\n+\t  if (arg->sym\n+\t\t&& arg->sym->ts.type == BT_DERIVED\n+\t\t&& !arg->sym->ts.derived->attr.use_assoc\n+\t\t&& !gfc_check_access(arg->sym->ts.derived->attr.access,\n+\t\t\targ->sym->ts.derived->ns->default_access))\n+\t    {\n+\t      gfc_error_now (\"'%s' is of a PRIVATE type and cannot be \"\n+\t\t\t     \"a dummy argument of '%s', which is \"\n+\t\t\t     \"PUBLIC at %L\", arg->sym->name, sym->name,\n+\t\t\t     &sym->declared_at);\n+\t      /* Stop this message from recurring.  */\n+\t      arg->sym->ts.derived->attr.access = ACCESS_PUBLIC;\n+\t      return FAILURE;\n+\t    }\n+\t}\n+    }\n+\n+  /* An external symbol may not have an intializer because it is taken to be\n+     a procedure.  */\n+  if (sym->attr.external && sym->value)\n+    {\n+      gfc_error (\"External object '%s' at %L may not have an initializer\",\n+\t\t sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n+  /* 5.1.1.5 of the Standard: A function name declared with an asterisk\n+     char-len-param shall not be array-valued, pointer-valued, recursive\n+     or pure.  ....snip... A character value of * may only be used in the\n+     following ways: (i) Dummy arg of procedure - dummy associates with\n+     actual length; (ii) To declare a named constant; or (iii) External\n+     function - but length must be declared in calling scoping unit.  */\n+  if (sym->attr.function\n+\t&& sym->ts.type == BT_CHARACTER\n+\t&& sym->ts.cl && sym->ts.cl->length == NULL)\n+    {\n+      if ((sym->as && sym->as->rank) || (sym->attr.pointer)\n+\t     || (sym->attr.recursive) || (sym->attr.pure))\n+\t{\n+\t  if (sym->as && sym->as->rank)\n+\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t       \"array-valued\", sym->name, &sym->declared_at);\n+\n+\t  if (sym->attr.pointer)\n+\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t       \"pointer-valued\", sym->name, &sym->declared_at);\n+\n+\t  if (sym->attr.pure)\n+\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t       \"pure\", sym->name, &sym->declared_at);\n+\n+\t  if (sym->attr.recursive)\n+\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t       \"recursive\", sym->name, &sym->declared_at);\n+\n+\t  return FAILURE;\n+\t}\n+\n+      /* Appendix B.2 of the standard.  Contained functions give an\n+\t error anyway.  Fixed-form is likely to be F77/legacy.  */\n+      if (!sym->attr.contained && gfc_current_form != FORM_FIXED)\n+\tgfc_notify_std (GFC_STD_F95_OBS, \"CHARACTER(*) function \"\n+\t\t\t\"'%s' at %L is obsolescent in fortran 95\",\n+\t\t\tsym->name, &sym->declared_at);\n+    }\n   return SUCCESS;\n }\n \n \n /* Resolve the components of a derived type.  */\n \n static try\n-resolve_derived (gfc_symbol *sym)\n+resolve_fl_derived (gfc_symbol *sym)\n {\n   gfc_component *c;\n+  gfc_dt_list * dt_list;\n+  int i;\n \n   for (c = sym->components; c != NULL; c = c->next)\n     {\n       if (c->ts.type == BT_CHARACTER)\n \t{\n-         if (resolve_charlen (c->ts.cl) == FAILURE)\n-\t   return FAILURE;\n-\t \n \t if (c->ts.cl->length == NULL\n+\t     || (resolve_charlen (c->ts.cl) == FAILURE)\n \t     || !gfc_is_constant_expr (c->ts.cl->length))\n \t   {\n \t     gfc_error (\"Character length of component '%s' needs to \"\n@@ -4507,12 +4836,86 @@ resolve_derived (gfc_symbol *sym)\n \t   }\n \t}\n \n-      /* TODO: Anything else that should be done here?  */\n+      if (c->ts.type == BT_DERIVED\n+\t    && sym->component_access != ACCESS_PRIVATE\n+\t    && gfc_check_access(sym->attr.access, sym->ns->default_access)\n+\t    && !c->ts.derived->attr.use_assoc\n+\t    && !gfc_check_access(c->ts.derived->attr.access,\n+\t\t\t\t c->ts.derived->ns->default_access))\n+\t{\n+\t  gfc_error (\"The component '%s' is a PRIVATE type and cannot be \"\n+\t\t     \"a component of '%s', which is PUBLIC at %L\",\n+\t\t      c->name, sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+\n+      if (c->pointer || c->as == NULL)\n+\tcontinue;\n+\n+      for (i = 0; i < c->as->rank; i++)\n+\t{\n+\t  if (c->as->lower[i] == NULL\n+\t\t|| !gfc_is_constant_expr (c->as->lower[i])\n+\t\t|| (resolve_index_expr (c->as->lower[i]) == FAILURE)\n+\t\t|| c->as->upper[i] == NULL\n+\t\t|| (resolve_index_expr (c->as->upper[i]) == FAILURE)\n+\t\t|| !gfc_is_constant_expr (c->as->upper[i]))\n+\t    {\n+\t      gfc_error (\"Component '%s' of '%s' at %L must have \"\n+\t\t\t \"constant array bounds.\",\n+\t\t\t c->name, sym->name, &c->loc);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+    }\n+    \n+  /* Add derived type to the derived type list.  */\n+  dt_list = gfc_get_dt_list ();\n+  dt_list->next = sym->ns->derived_types;\n+  dt_list->derived = sym;\n+  sym->ns->derived_types = dt_list;\n+\n+  return SUCCESS;\n+}\n+\n+\n+static try\n+resolve_fl_parameter (gfc_symbol *sym)\n+{\n+  /* A parameter array's shape needs to be constant.  */\n+  if (sym->as != NULL && !gfc_is_compile_time_shape (sym->as))\n+    {\n+      gfc_error (\"Parameter array '%s' at %L cannot be automatic \"\n+\t\t \"or assumed shape\", sym->name, &sym->declared_at);\n+      return FAILURE;\n     }\n \n+  /* Make sure a parameter that has been implicitly typed still\n+     matches the implicit type, since PARAMETER statements can precede\n+     IMPLICIT statements.  */\n+  if (sym->attr.implicit_type\n+\t&& !gfc_compare_types (&sym->ts,\n+\t\t\t       gfc_get_default_type (sym, sym->ns)))\n+    {\n+      gfc_error (\"Implicitly typed PARAMETER '%s' at %L doesn't match a \"\n+\t\t \"later IMPLICIT type\", sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n+  /* Make sure the types of derived parameters are consistent.  This\n+     type checking is deferred until resolution because the type may\n+     refer to a derived type from the host.  */\n+  if (sym->ts.type == BT_DERIVED\n+\t&& !gfc_compare_types (&sym->ts, &sym->value->ts))\n+    {\n+      gfc_error (\"Incompatible derived type in PARAMETER at %L\",\n+\t\t &sym->value->where);\n+      return FAILURE;\n+    }\n   return SUCCESS;\n }\n \n+\n /* Do anything necessary to resolve a symbol.  Right now, we just\n    assume that an otherwise unknown symbol is a variable.  This sort\n    of thing commonly happens for symbols in module.  */\n@@ -4523,14 +4926,11 @@ resolve_symbol (gfc_symbol * sym)\n   /* Zero if we are checking a formal namespace.  */\n   static int formal_ns_flag = 1;\n   int formal_ns_save, check_constant, mp_flag;\n-  int i, flag;\n   gfc_namelist *nl;\n   gfc_symtree *symtree;\n   gfc_symtree *this_symtree;\n   gfc_namespace *ns;\n   gfc_component *c;\n-  gfc_formal_arglist *arg;\n-  gfc_expr *constructor_expr;\n \n   if (sym->attr.flavor == FL_UNKNOWN)\n     {\n@@ -4566,7 +4966,7 @@ resolve_symbol (gfc_symbol * sym)\n \t}\n     }\n \n-  if (sym->attr.flavor == FL_DERIVED && resolve_derived (sym) == FAILURE)\n+  if (sym->attr.flavor == FL_DERIVED && resolve_fl_derived (sym) == FAILURE)\n     return;\n \n   /* Symbols that are module procedures with results (functions) have\n@@ -4618,90 +5018,18 @@ resolve_symbol (gfc_symbol * sym)\n       return;\n     }\n \n-  /* A parameter array's shape needs to be constant.  */\n-\n-  if (sym->attr.flavor == FL_PARAMETER && sym->as != NULL \n-      && !gfc_is_compile_time_shape (sym->as))\n-    {\n-      gfc_error (\"Parameter array '%s' at %L cannot be automatic \"\n-\t\t \"or assumed shape\", sym->name, &sym->declared_at);\n-\t  return;\n-    }\n-\n-  /* A module array's shape needs to be constant.  */\n-\n-  if (sym->ns->proc_name\n-      && sym->attr.flavor == FL_VARIABLE\n-      && sym->ns->proc_name->attr.flavor == FL_MODULE\n-      && !sym->attr.use_assoc\n-      && !sym->attr.allocatable\n-      && !sym->attr.pointer\n-      && sym->as != NULL\n-      && !gfc_is_compile_time_shape (sym->as))\n-    {\n-      gfc_error (\"Module array '%s' at %L cannot be automatic \"\n-         \"or assumed shape\", sym->name, &sym->declared_at);\n-      return;\n-    }\n-\n-  /* Make sure that character string variables with assumed length are\n-     dummy arguments.  */\n-\n-  if (sym->attr.flavor == FL_VARIABLE && !sym->attr.result\n-      && sym->ts.type == BT_CHARACTER\n-      && sym->ts.cl->length == NULL && sym->attr.dummy == 0)\n-    {\n-      gfc_error (\"Entity with assumed character length at %L must be a \"\n-\t\t \"dummy argument or a PARAMETER\", &sym->declared_at);\n-      return;\n-    }\n-\n-  /* Make sure a parameter that has been implicitly typed still\n-     matches the implicit type, since PARAMETER statements can precede\n-     IMPLICIT statements.  */\n-\n-  if (sym->attr.flavor == FL_PARAMETER\n-      && sym->attr.implicit_type\n-      && !gfc_compare_types (&sym->ts, gfc_get_default_type (sym, sym->ns)))\n-    gfc_error (\"Implicitly typed PARAMETER '%s' at %L doesn't match a \"\n-\t       \"later IMPLICIT type\", sym->name, &sym->declared_at);\n-\n-  /* Make sure the types of derived parameters are consistent.  This\n-     type checking is deferred until resolution because the type may\n-     refer to a derived type from the host.  */\n-\n-  if (sym->attr.flavor == FL_PARAMETER\n-      && sym->ts.type == BT_DERIVED\n-      && !gfc_compare_types (&sym->ts, &sym->value->ts))\n-    gfc_error (\"Incompatible derived type in PARAMETER at %L\",\n-\t       &sym->value->where);\n-\n   /* Make sure symbols with known intent or optional are really dummy\n      variable.  Because of ENTRY statement, this has to be deferred\n      until resolution time.  */\n \n-  if (! sym->attr.dummy\n+  if (!sym->attr.dummy\n       && (sym->attr.optional\n \t  || sym->attr.intent != INTENT_UNKNOWN))\n     {\n       gfc_error (\"Symbol at %L is not a DUMMY variable\", &sym->declared_at);\n       return;\n     }\n \n-  if (sym->attr.proc == PROC_ST_FUNCTION)\n-    {\n-      if (sym->ts.type == BT_CHARACTER)\n-        {\n-          gfc_charlen *cl = sym->ts.cl;\n-          if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT)\n-            {\n-              gfc_error (\"Character-valued statement function '%s' at %L must \"\n-                         \"have constant length\", sym->name, &sym->declared_at);\n-              return;\n-            }\n-        }\n-    }\n-\n   /* If a derived type symbol has reached this point, without its\n      type being declared, we have an error.  Notice that most\n      conditions that produce undefined derived types have already\n@@ -4720,28 +5048,6 @@ resolve_symbol (gfc_symbol * sym)\n       return;\n     }\n \n-  /* If a component of a derived type is of a type declared to be private,\n-     either the derived type definition must contain the PRIVATE statement,\n-     or the derived type must be private.  (4.4.1 just after R427) */\n-  if (sym->attr.flavor == FL_DERIVED\n-\t&& sym->component_access != ACCESS_PRIVATE\n-\t&& gfc_check_access(sym->attr.access, sym->ns->default_access))\n-    {\n-      for (c = sym->components; c; c = c->next)\n-\t{\n-\t  if (c->ts.type == BT_DERIVED\n-\t\t&& !c->ts.derived->attr.use_assoc\n-\t\t&& !gfc_check_access(c->ts.derived->attr.access,\n-\t\t\t\t     c->ts.derived->ns->default_access))\n-\t    {\n-\t      gfc_error (\"The component '%s' is a PRIVATE type and cannot be \"\n-\t\t\t \"a component of '%s', which is PUBLIC at %L\",\n-\t\t\t c->name, sym->name, &sym->declared_at);\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n   /* An assumed-size array with INTENT(OUT) shall not be of a type for which\n      default initialization is defined (5.1.2.4.4).  */\n   if (sym->ts.type == BT_DERIVED\n@@ -4762,141 +5068,16 @@ resolve_symbol (gfc_symbol * sym)\n \t}\n     }\n \n-\n-  /* Ensure that derived type formal arguments of a public procedure\n-     are not of a private type.  */\n-  if (sym->attr.flavor == FL_PROCEDURE\n-\t&& gfc_check_access(sym->attr.access, sym->ns->default_access))\n-    {\n-      for (arg = sym->formal; arg; arg = arg->next)\n-\t{\n-\t  if (arg->sym\n-\t\t&& arg->sym->ts.type == BT_DERIVED\n-\t\t&& !arg->sym->ts.derived->attr.use_assoc\n-\t\t&& !gfc_check_access(arg->sym->ts.derived->attr.access,\n-\t\t\t\t     arg->sym->ts.derived->ns->default_access))\n-\t    {\n-\t      gfc_error_now (\"'%s' is a PRIVATE type and cannot be \"\n-\t\t\t     \"a dummy argument of '%s', which is PUBLIC at %L\",\n-\t\t\t     arg->sym->name, sym->name, &sym->declared_at);\n-\t      /* Stop this message from recurring.  */\n-\t      arg->sym->ts.derived->attr.access = ACCESS_PUBLIC;\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  /* Constraints on deferred shape variable.  */\n-  if (sym->attr.flavor == FL_VARIABLE\n-      || (sym->attr.flavor == FL_PROCEDURE\n-\t  && sym->attr.function))\n-    {\n-      if (sym->as == NULL || sym->as->type != AS_DEFERRED)\n-\t{\n-\t  if (sym->attr.allocatable)\n-\t    {\n-\t      if (sym->attr.dimension)\n-\t\tgfc_error (\"Allocatable array '%s' at %L must have \"\n-\t\t\t   \"a deferred shape\", sym->name, &sym->declared_at);\n-\t      else\n-\t\tgfc_error (\"Scalar object '%s' at %L may not be ALLOCATABLE\",\n-\t\t\t   sym->name, &sym->declared_at);\n-\t      return;\n-\t    }\n-\n-\t  if (sym->attr.pointer && sym->attr.dimension)\n-\t    {\n-\t      gfc_error (\"Array pointer '%s' at %L must have a deferred shape\",\n-\t\t\t sym->name, &sym->declared_at);\n-\t      return;\n-\t    }\n-\n-\t}\n-      else\n-\t{\n-\t  if (!mp_flag && !sym->attr.allocatable\n-\t      && !sym->attr.pointer && !sym->attr.dummy)\n-\t    {\n-\t      gfc_error (\"Array '%s' at %L cannot have a deferred shape\",\n-\t\t\t sym->name, &sym->declared_at);\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n   switch (sym->attr.flavor)\n     {\n     case FL_VARIABLE:\n-      /* Can the symbol have an initializer?  */\n-      flag = 0;\n-      if (sym->attr.allocatable || sym->attr.external || sym->attr.dummy\n-\t  || sym->attr.intrinsic || sym->attr.result)\n-\tflag = 1;\n-      else if (sym->attr.dimension && !sym->attr.pointer)\n-\t{\n-\t  /* Don't allow initialization of automatic arrays.  */\n-\t  for (i = 0; i < sym->as->rank; i++)\n-\t    {\n-\t      if (sym->as->lower[i] == NULL\n-\t\t  || sym->as->lower[i]->expr_type != EXPR_CONSTANT\n-\t\t  || sym->as->upper[i] == NULL\n-\t\t  || sym->as->upper[i]->expr_type != EXPR_CONSTANT)\n-\t\t{\n-\t\t  flag = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Reject illegal initializers.  */\n-      if (sym->value && flag)\n-\t{\n-\t  if (sym->attr.allocatable)\n-\t    gfc_error (\"Allocatable '%s' at %L cannot have an initializer\",\n-\t\t       sym->name, &sym->declared_at);\n-\t  else if (sym->attr.external)\n-\t    gfc_error (\"External '%s' at %L cannot have an initializer\",\n-\t\t       sym->name, &sym->declared_at);\n-\t  else if (sym->attr.dummy)\n-\t    gfc_error (\"Dummy '%s' at %L cannot have an initializer\",\n-\t\t       sym->name, &sym->declared_at);\n-\t  else if (sym->attr.intrinsic)\n-\t    gfc_error (\"Intrinsic '%s' at %L cannot have an initializer\",\n-\t\t       sym->name, &sym->declared_at);\n-\t  else if (sym->attr.result)\n-\t    gfc_error (\"Function result '%s' at %L cannot have an initializer\",\n-\t\t       sym->name, &sym->declared_at);\n-\t  else\n-\t    gfc_error (\"Automatic array '%s' at %L cannot have an initializer\",\n-\t\t       sym->name, &sym->declared_at);\n-\t  return;\n-\t}\n-\n-     /* 4th constraint in section 11.3:  \"If an object of a type for which\n-\tcomponent-initialization is specified (R429) appears in the\n-\tspecification-part of a module and does not have the ALLOCATABLE\n-\tor POINTER attribute, the object shall have the SAVE attribute.\"  */\n-\n-      constructor_expr = NULL;\n-      if (sym->ts.type == BT_DERIVED && !(sym->value || flag))\n-        constructor_expr = gfc_default_initializer (&sym->ts);\n-\n-      if (sym->ns->proc_name\n-\t  && sym->ns->proc_name->attr.flavor == FL_MODULE\n-\t  && constructor_expr\n-\t  && !sym->ns->save_all && !sym->attr.save\n-\t  && !sym->attr.pointer && !sym->attr.allocatable)\n-\t{\n-\t  gfc_error(\"Object '%s' at %L must have the SAVE attribute %s\",\n- \t \t     sym->name, &sym->declared_at,\n-\t\t     \"for default initialization of a component\");\n-\t  return;\n-\t}\n+      if (resolve_fl_variable (sym, mp_flag) == FAILURE)\n+\treturn;\n+      break;\n \n-      /* Assign default initializer.  */\n-      if (sym->ts.type == BT_DERIVED && !(sym->value || flag)\n-          && !sym->attr.pointer)\n-\tsym->value = gfc_default_initializer (&sym->ts);\n+    case FL_PROCEDURE:\n+      if (resolve_fl_procedure (sym, mp_flag) == FAILURE)\n+\treturn;\n       break;\n \n     case FL_NAMELIST:\n@@ -4916,69 +5097,13 @@ resolve_symbol (gfc_symbol * sym)\n \t\t\t   &sym->declared_at);\n \t    }\n \t}\n-      break;\n-\n-    case FL_PROCEDURE:\n-      /* An external symbol may not have an intializer because it is taken to be\n-\t a procedure.  */\n-      if (sym->attr.external && sym->value)\n-\t{\n-\t  gfc_error (\"External object '%s' at %L may not have an initializer\",\n-\t\t     sym->name, &sym->declared_at);\n-\t  return;\n-\t}\n-\n-      /* 5.1.1.5 of the Standard: A function name declared with an asterisk\n-\t char-len-param shall not be array-valued, pointer-valued, recursive\n-\t or pure.  ....snip... A character value of * may only be used in the\n-\t following ways: (i) Dummy arg of procedure - dummy associates with\n-\t actual length; (ii) To declare a named constant; or (iii) External\n-\t function - but length must be declared in calling scoping unit.  */\n-      if (sym->attr.function\n-\t    && sym->ts.type == BT_CHARACTER\n-\t    && sym->ts.cl && sym->ts.cl->length == NULL)\n-\t{\n-\t  if ((sym->as && sym->as->rank) || (sym->attr.pointer)\n-\t\t || (sym->attr.recursive) || (sym->attr.pure))\n-\t    {\n-\t      if (sym->as && sym->as->rank)\n-\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n-\t\t\t   \"array-valued\", sym->name, &sym->declared_at);\n-\n-\t      if (sym->attr.pointer)\n-\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n-\t\t\t   \"pointer-valued\", sym->name, &sym->declared_at);\n-\n-\t      if (sym->attr.pure)\n-\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n-\t\t\t   \"pure\", sym->name, &sym->declared_at);\n-\n-\t      if (sym->attr.recursive)\n-\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n-\t\t\t   \"recursive\", sym->name, &sym->declared_at);\n-\n-\t      return;\n-\t    }\n-\n-\t  /* Appendix B.2 of the standard.  Contained functions give an\n-\t     error anyway.  Fixed-form is likely to be F77/legacy.  */\n-\t  if (!sym->attr.contained && gfc_current_form != FORM_FIXED)\n-\t    gfc_notify_std (GFC_STD_F95_OBS, \"CHARACTER(*) function \"\n-\t\t\t    \"'%s' at %L is obsolescent in fortran 95\",\n-\t\t\t    sym->name, &sym->declared_at);\n-\t}\n \n       break;\n \n-    case FL_DERIVED:\n-      /* Add derived type to the derived type list.  */\n-      {\n-\tgfc_dt_list * dt_list;\n-\tdt_list = gfc_get_dt_list ();\n-\tdt_list->next = sym->ns->derived_types;\n-\tdt_list->derived = sym;\n-\tsym->ns->derived_types = dt_list;\n-      }\n+    case FL_PARAMETER:\n+      if (resolve_fl_parameter (sym) == FAILURE)\n+\treturn;\n+\n       break;\n \n     default:\n@@ -5063,6 +5188,13 @@ check_data_variable (gfc_data_variable * var, locus * where)\n   if (e->expr_type != EXPR_VARIABLE)\n     gfc_internal_error (\"check_data_variable(): Bad expression\");\n \n+  if (e->symtree->n.sym->ns->is_block_data\n+\t&& !e->symtree->n.sym->attr.in_common)\n+    {\n+      gfc_error (\"BLOCK DATA element '%s' at %L must be in COMMON\",\n+\t         e->symtree->n.sym->name, &e->symtree->n.sym->declared_at);\n+    }\n+\n   if (e->rank == 0)\n     {\n       mpz_init_set_ui (size, 1);"}, {"sha": "113914077f7bf3cf8999105867155460cde73b3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -1,3 +1,26 @@\n+2006-02-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/26074\n+\tPR fortran/25103\n+\t* gfortran.dg/module_parameter_array_refs_1.f90: New test.\n+\t* gfortran.dg/bad_automatic_objects_1.f90: New test.\n+\t* gfortran.dg/automatic_module_variable.f90: Change error message.\n+\n+\tPR fortran/20861\n+\t* gfortran.dg/internal_dummy_1.f90: New test.\n+\n+\tPR fortran/20871\n+\t* gfortran.dg/elemental_non_intrinsic_dummy_1.f90: New test.\n+\n+\n+\tPR fortran/25083\n+\t* gfortran.dg/uncommon_block_data_1.f90: New test.\n+\t* gfortran.dg/equiv_constraint_7.f90: Correct non-compliance of test\n+\twith standard.\n+\n+\tPR fortran/25088\n+\t* gfortran.dg/typed_subroutine_1.f90: New test.\n+\n 2006-02-13  Geoffrey Keating  <geoffk@apple.com>\n \n \t* objc.dg/dwarf-1.m: New."}, {"sha": "201dcf4e1d3cb360d5864a205bcd3df7932283a8", "filename": "gcc/testsuite/gfortran.dg/automatic_module_variable.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fautomatic_module_variable.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fautomatic_module_variable.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fautomatic_module_variable.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -4,7 +4,7 @@\n module sd\n   integer, parameter :: n = 20\n   integer :: i(n)\n-  integer :: j(m) ! { dg-error \"cannot be automatic or assumed shape\" }\n+  integer :: j(m) ! { dg-error \"must have constant shape\" }\n   integer, pointer :: p(:)\n   integer, allocatable :: q(:)\n contains"}, {"sha": "2734418619478f0eb0e0b88a9dac4da5c6a3c956", "filename": "gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fbad_automatic_objects_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fbad_automatic_objects_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbad_automatic_objects_1.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! Tests the fix for 25103, in which the presence of automatic objects\n+! in the main program and the specification part of a module was not\n+! detected.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+module foo\n+  integer    ::  i\n+end module foo\n+module bar\n+  use foo\n+  integer, dimension (i) :: j ! { dg-error \"must have constant shape\" }\n+  character (len = i) :: c1   ! { dg-error \"must have constant character length\" }\n+end module bar\n+program foobar\n+  use foo\n+  integer, dimension (i) :: k ! { dg-error \"must have constant shape\" }\n+  character (len = i) :: c2   ! { dg-error \"must have constant character length\" }\n+end program foobar"}, {"sha": "c14a5d87fa5e9190ef5f4c6785eb519443b28393", "filename": "gcc/testsuite/gfortran.dg/elemental_non_intrinsic_dummy_1.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_non_intrinsic_dummy_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_non_intrinsic_dummy_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_non_intrinsic_dummy_1.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! Tests the fix for 20871, in which elemental non-intrinsic procedures were\n+! permitted to be dummy arguments.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+MODULE TT\n+CONTAINS\n+   ELEMENTAL INTEGER FUNCTION two(N)\n+     INTEGER, INTENT(IN) :: N\n+     two=2**N\n+   END FUNCTION\n+END MODULE\n+USE TT\n+ INTEGER, EXTERNAL  :: SUB\n+ write(6,*) SUB(two)    ! { dg-error \"not allowed as an actual argument \" }\n+END\n+INTEGER FUNCTION SUB(XX)\n+  INTEGER :: XX\n+  SUB=XX()\n+END"}, {"sha": "207b7d318a01306a2b44347739c219af43917188", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_7.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -2,8 +2,10 @@\n ! { dg-options \"-O0\" }\n ! PR20890 - Equivalence cannot contain more than one initialized variables.\n ! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n- BLOCK DATA\n+! Started out being in BLOCK DATA; however, blockdata variables must be in\n+! COMMON and therefore cannot have F95 style initializers....\n+ MODULE DATA\n   INTEGER :: I=1,J=2\n   EQUIVALENCE(I,J)  ! { dg-error \"cannot both be in the EQUIVALENCE\" }\n- END BLOCK DATA\n+ END MODULE DATA\n  END"}, {"sha": "cae187e808bafd9f33dd1ec4d71aab0c4b6cca28", "filename": "gcc/testsuite/gfortran.dg/internal_dummy_1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_dummy_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_dummy_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_dummy_1.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! Tests the fix for 20861, in which internal procedures were permitted to\n+! be dummy arguments.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+CALL DD(TT) ! { dg-error \"is not allowed as an actual argument\" }\n+CONTAINS\n+SUBROUTINE DD(F)\n+  INTERFACE\n+   SUBROUTINE F(X)\n+    REAL :: X\n+   END SUBROUTINE F\n+  END INTERFACE\n+END SUBROUTINE DD\n+SUBROUTINE TT(X)\n+  REAL :: X\n+END SUBROUTINE\n+END"}, {"sha": "a78b5253958b34e4213a4c39675bb5b2e53fb574", "filename": "gcc/testsuite/gfortran.dg/module_parameter_array_refs_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_parameter_array_refs_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_parameter_array_refs_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_parameter_array_refs_1.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Tests the fix for 26074, in which the array reference below would\n+! be determined not to be constant within modules.\n+!\n+! Contributed by Jonathan Dursi  <ljdursi@cita.utoronto.ca>\n+!\n+module foo\n+\n+   integer, parameter :: len = 5\n+   integer :: arr(max(len,1))\n+\n+end\n+"}, {"sha": "38619e7b8a67ec9d6835d7b5cb46d6507f9ee723", "filename": "gcc/testsuite/gfortran.dg/typed_subroutine_1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Ftyped_subroutine_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Ftyped_subroutine_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftyped_subroutine_1.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! Tests the fix for 25088, in which the compiler failed to detect that\n+! a called object had a type.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+ INTEGER :: S ! { dg-error \"has a type, which is not consistent with the CALL \" }\n+ CALL S()     ! { dg-error \"has a type, which is not consistent with the CALL \" }\n+ END\n+ SUBROUTINE S\n+ END SUBROUTINE"}, {"sha": "54547e89c15797e37664904bcf3fffffbec4754b", "filename": "gcc/testsuite/gfortran.dg/uncommon_block_data_1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Funcommon_block_data_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed8d2241e1e3ba077fc6dc3813f202f45414fbe/gcc%2Ftestsuite%2Fgfortran.dg%2Funcommon_block_data_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funcommon_block_data_1.f90?ref=2ed8d2241e1e3ba077fc6dc3813f202f45414fbe", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! Tests the fix for 25083, in which the compiler failed to detect that\n+! data variables in BLOCK DATA were not in COMMON.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+ BLOCK DATA D\n+  INTEGER I ! { dg-error \"must be in COMMON\" }\n+  DATA I /1/\n+ END BLOCK DATA\n+END"}]}