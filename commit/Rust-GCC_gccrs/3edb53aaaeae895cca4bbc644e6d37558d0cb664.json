{"sha": "3edb53aaaeae895cca4bbc644e6d37558d0cb664", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VkYjUzYWFhZWFlODk1Y2NhNGJiYzY0NGU2ZDM3NTU4ZDBjYjY2NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-09T20:26:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-09T20:26:43Z"}, "message": "dwarf2cfi: Unify add_fde_cfi and add_cie_cfi.\n\n        * dwarf2cfi.c (add_cfi_vec): New.\n        (add_cfi): Rename from add_fde_cfi.  Add the element to add_cfi_vec.\n        (def_cfa_1, reg_save): Remove for_cie argument.  Update all callers.\n        (execute_dwarf2_frame): Set add_cfi_vec.\n\nFrom-SVN: r176095", "tree": {"sha": "adab4c9d686df8016920bb1911b5b9147cef0d20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adab4c9d686df8016920bb1911b5b9147cef0d20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3edb53aaaeae895cca4bbc644e6d37558d0cb664", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edb53aaaeae895cca4bbc644e6d37558d0cb664", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3edb53aaaeae895cca4bbc644e6d37558d0cb664", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edb53aaaeae895cca4bbc644e6d37558d0cb664/comments", "author": null, "committer": null, "parents": [{"sha": "ded49a7f6c1027557819ec66d8d8d258f575add3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded49a7f6c1027557819ec66d8d8d258f575add3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ded49a7f6c1027557819ec66d8d8d258f575add3"}], "stats": {"total": 97, "additions": 47, "deletions": 50}, "files": [{"sha": "3b8fdf86a32ccb4a2a9b366f1c3aa32c165029b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edb53aaaeae895cca4bbc644e6d37558d0cb664/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edb53aaaeae895cca4bbc644e6d37558d0cb664/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3edb53aaaeae895cca4bbc644e6d37558d0cb664", "patch": "@@ -1,3 +1,10 @@\n+2011-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (add_cfi_vec): New.\n+\t(add_cfi): Rename from add_fde_cfi.  Add the element to add_cfi_vec.\n+\t(def_cfa_1, reg_save): Remove for_cie argument.  Update all callers.\n+\t(execute_dwarf2_frame): Set add_cfi_vec.\n+\n 2011-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* defaults.h (ASM_COMMENT_START): Move here..."}, {"sha": "ca9b50397ae04a932b51ac4a029ee8f70a0ded1b", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edb53aaaeae895cca4bbc644e6d37558d0cb664/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edb53aaaeae895cca4bbc644e6d37558d0cb664/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=3edb53aaaeae895cca4bbc644e6d37558d0cb664", "patch": "@@ -146,6 +146,9 @@ static GTY(()) unsigned long dwarf2out_cfi_label_num;\n /* The insn after which a new CFI note should be emitted.  */\n static rtx cfi_insn;\n \n+/* When non-null, add_cfi will add the CFI to this vector.  */\n+static cfi_vec *add_cfi_vec;\n+\n /* True if remember_state should be emitted before following CFI directive.  */\n static bool emit_cfa_remember;\n \n@@ -270,10 +273,10 @@ dwarf2out_cfi_label (void)\n   return xstrdup (label);\n }\n \n-/* Add CFI to the current fde.  */\n+/* Add CFI either to the current insn stream or to a vector, or both.  */\n \n static void\n-add_fde_cfi (dw_cfi_ref cfi)\n+add_cfi (dw_cfi_ref cfi)\n {\n   if (emit_cfa_remember)\n     {\n@@ -283,7 +286,7 @@ add_fde_cfi (dw_cfi_ref cfi)\n       emit_cfa_remember = false;\n       cfi_remember = new_cfi ();\n       cfi_remember->dw_cfi_opc = DW_CFA_remember_state;\n-      add_fde_cfi (cfi_remember);\n+      add_cfi (cfi_remember);\n     }\n \n   any_cfis_emitted = true;\n@@ -292,18 +295,8 @@ add_fde_cfi (dw_cfi_ref cfi)\n       cfi_insn = emit_note_after (NOTE_INSN_CFI, cfi_insn);\n       NOTE_CFI (cfi_insn) = cfi;\n     }\n-  else\n-    {\n-      dw_fde_ref fde = cfun->fde;\n-      VEC_safe_push (dw_cfi_ref, gc, fde->dw_fde_cfi, cfi);\n-      dwarf2out_emit_cfi (cfi);\n-    }\n-}\n-\n-static void\n-add_cie_cfi (dw_cfi_ref cfi)\n-{\n-  VEC_safe_push (dw_cfi_ref, gc, cie_cfi_vec, cfi);\n+  if (add_cfi_vec != NULL)\n+    VEC_safe_push (dw_cfi_ref, gc, *add_cfi_vec, cfi);\n }\n \n /* This function fills in aa dw_cfa_location structure from a dwarf location\n@@ -512,7 +505,7 @@ cfa_equal_p (const dw_cfa_location *loc1, const dw_cfa_location *loc2)\n    the dw_cfa_location structure.  */\n \n static void\n-def_cfa_1 (bool for_cie, dw_cfa_location *loc_p)\n+def_cfa_1 (dw_cfa_location *loc_p)\n {\n   dw_cfi_ref cfi;\n   dw_cfa_location loc;\n@@ -584,10 +577,7 @@ def_cfa_1 (bool for_cie, dw_cfa_location *loc_p)\n       cfi->dw_cfi_oprnd1.dw_cfi_loc = loc_list;\n     }\n \n-  if (for_cie)\n-    add_cie_cfi (cfi);\n-  else\n-    add_fde_cfi (cfi);\n+  add_cfi (cfi);\n   old_cfa = loc;\n }\n \n@@ -596,10 +586,9 @@ def_cfa_1 (bool for_cie, dw_cfa_location *loc_p)\n    otherwise it is saved in SREG.  */\n \n static void\n-reg_save (bool for_cie, unsigned int reg, unsigned int sreg,\n-          HOST_WIDE_INT offset)\n+reg_save (unsigned int reg, unsigned int sreg, HOST_WIDE_INT offset)\n {\n-  dw_fde_ref fde = for_cie ? NULL : cfun->fde;\n+  dw_fde_ref fde = cfun ? cfun->fde : NULL;\n   dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n@@ -632,10 +621,7 @@ reg_save (bool for_cie, unsigned int reg, unsigned int sreg,\n       cfi->dw_cfi_oprnd2.dw_cfi_reg_num = sreg;\n     }\n \n-  if (for_cie)\n-    add_cie_cfi (cfi);\n-  else\n-    add_fde_cfi (cfi);\n+  add_cfi (cfi);\n }\n \n /* Record the initial position of the return address.  RTL is\n@@ -693,7 +679,7 @@ initial_return_save (rtx rtl)\n     }\n \n   if (reg != DWARF_FRAME_RETURN_COLUMN)\n-    reg_save (true, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n+    reg_save (DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n }\n \n /* Given a SET, calculate the amount of stack adjustment it\n@@ -975,7 +961,7 @@ dwarf2out_args_size (HOST_WIDE_INT size)\n   cfi = new_cfi ();\n   cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n   cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n-  add_fde_cfi (cfi);\n+  add_cfi (cfi);\n }\n \n /* Record a stack adjustment of OFFSET bytes.  */\n@@ -1000,7 +986,7 @@ dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n   if (args_size < 0)\n     args_size = 0;\n \n-  def_cfa_1 (false, &cfa);\n+  def_cfa_1 (&cfa);\n   if (flag_asynchronous_unwind_tables)\n     dwarf2out_args_size (args_size);\n }\n@@ -1205,7 +1191,7 @@ dwarf2out_flush_queued_reg_saves (void)\n \tsreg = DWARF_FRAME_REGNUM (REGNO (q->saved_reg));\n       else\n \tsreg = INVALID_REGNUM;\n-      reg_save (false, reg, sreg, q->cfa_offset);\n+      reg_save (reg, sreg, q->cfa_offset);\n     }\n \n   queued_reg_saves = NULL;\n@@ -1299,7 +1285,7 @@ dwarf2out_frame_debug_def_cfa (rtx pat)\n       gcc_unreachable ();\n     }\n \n-  def_cfa_1 (false, &cfa);\n+  def_cfa_1 (&cfa);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_ADJUST_CFA note.  */\n@@ -1330,7 +1316,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n   cfa.reg = REGNO (dest);\n   gcc_assert (cfa.indirect == 0);\n \n-  def_cfa_1 (false, &cfa);\n+  def_cfa_1 (&cfa);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_OFFSET note.  */\n@@ -1376,7 +1362,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n      a different flushing heuristic for epilogues.  */\n   if (!span)\n-    reg_save (false, sregno, INVALID_REGNUM, offset);\n+    reg_save (sregno, INVALID_REGNUM, offset);\n   else\n     {\n       /* We have a PARALLEL describing where the contents of SRC live.\n@@ -1393,7 +1379,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n \t  rtx elem = XVECEXP (span, 0, par_index);\n \n \t  sregno = DWARF_FRAME_REGNUM (REGNO (src));\n-\t  reg_save (false, sregno, INVALID_REGNUM, span_offset);\n+\t  reg_save (sregno, INVALID_REGNUM, span_offset);\n \t  span_offset += GET_MODE_SIZE (GET_MODE (elem));\n \t}\n     }\n@@ -1422,7 +1408,7 @@ dwarf2out_frame_debug_cfa_register (rtx set)\n \n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n      a different flushing heuristic for epilogues.  */\n-  reg_save (false, sregno, dregno, 0);\n+  reg_save (sregno, dregno, 0);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_EXPRESSION note. */\n@@ -1450,7 +1436,7 @@ dwarf2out_frame_debug_cfa_expression (rtx set)\n \n   /* ??? We'd like to use queue_reg_save, were the interface different,\n      and, as above, we could manage flushing for epilogues.  */\n-  add_fde_cfi (cfi);\n+  add_cfi (cfi);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_RESTORE note.  */\n@@ -1464,7 +1450,7 @@ dwarf2out_frame_debug_cfa_restore (rtx reg)\n   cfi->dw_cfi_opc = (regno & ~0x3f ? DW_CFA_restore_extended : DW_CFA_restore);\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = regno;\n \n-  add_fde_cfi (cfi);\n+  add_cfi (cfi);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_WINDOW_SAVE.\n@@ -1477,7 +1463,7 @@ dwarf2out_frame_debug_cfa_window_save (void)\n   dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_opc = DW_CFA_GNU_window_save;\n-  add_fde_cfi (cfi);\n+  add_cfi (cfi);\n }\n \n /* Record call frame debugging information for an expression EXPR,\n@@ -1943,7 +1929,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  gcc_unreachable ();\n \t}\n \n-      def_cfa_1 (false, &cfa);\n+      def_cfa_1 (&cfa);\n       break;\n \n     case MEM:\n@@ -2103,14 +2089,14 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t\t  fde->drap_reg_saved = 1;\n \n-\t\t  def_cfa_1 (false, &cfa_exp);\n+\t\t  def_cfa_1 (&cfa_exp);\n \t\t  break;\n                 }\n \n \t      /* If the source register is exactly the CFA, assume\n \t\t we're saving SP like any other register; this happens\n \t\t on the ARM.  */\n-\t      def_cfa_1 (false, &cfa);\n+\t      def_cfa_1 (&cfa);\n \t      queue_reg_save (stack_pointer_rtx, NULL_RTX, offset);\n \t      break;\n \t    }\n@@ -2127,12 +2113,12 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      cfa.reg = REGNO (x);\n \t      cfa.base_offset = offset;\n \t      cfa.indirect = 1;\n-\t      def_cfa_1 (false, &cfa);\n+\t      def_cfa_1 (&cfa);\n \t      break;\n \t    }\n \t}\n \n-      def_cfa_1 (false, &cfa);\n+      def_cfa_1 (&cfa);\n       {\n \tspan = targetm.dwarf_register_span (src);\n \n@@ -2570,7 +2556,7 @@ dwarf2out_frame_debug_restore_state (void)\n   dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_opc = DW_CFA_restore_state;\n-  add_fde_cfi (cfi);\n+  add_cfi (cfi);\n \n   gcc_assert (cfa_remember.in_use);\n   cfa = cfa_remember;\n@@ -2591,18 +2577,22 @@ execute_dwarf2_frame (void)\n     {\n       dw_cfa_location loc;\n \n+      add_cfi_vec = &cie_cfi_vec;\n+\n       memset(&old_cfa, 0, sizeof (old_cfa));\n       old_cfa.reg = INVALID_REGNUM;\n \n       /* On entry, the Canonical Frame Address is at SP.  */\n       memset(&loc, 0, sizeof (loc));\n       loc.reg = STACK_POINTER_REGNUM;\n       loc.offset = INCOMING_FRAME_SP_OFFSET;\n-      def_cfa_1 (true, &loc);\n+      def_cfa_1 (&loc);\n \n       if (targetm.debug_unwind_info () == UI_DWARF2\n           || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n \tinitial_return_save (INCOMING_RETURN_ADDR_RTX);\n+\n+      add_cfi_vec = NULL;\n     }\n \n   /* Set up state for generating call frame debug info.  */"}, {"sha": "af7b58fa399d367c2e1cab1a0997d5471e2e63c0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edb53aaaeae895cca4bbc644e6d37558d0cb664/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edb53aaaeae895cca4bbc644e6d37558d0cb664/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3edb53aaaeae895cca4bbc644e6d37558d0cb664", "patch": "@@ -825,10 +825,10 @@ output_cfi_directive (FILE *f, dw_cfi_ref cfi)\n     case DW_CFA_advance_loc4:\n     case DW_CFA_MIPS_advance_loc8:\n     case DW_CFA_set_loc:\n-      /* Should only be created by add_fde_cfi in a code path not\n-\t followed when emitting via directives.  The assembler is\n-\t going to take care of this for us.  But this routines is\n-\t also used for debugging dumps, so print something.  */\n+      /* Should only be created in a code path not followed when emitting\n+\t via directives.  The assembler is going to take care of this for\n+\t us.  But this routines is also used for debugging dumps, so\n+\t print something.  */\n       gcc_assert (f != asm_out_file);\n       fprintf (f, \"\\t.cfi_advance_loc\\n\");\n       break;"}]}