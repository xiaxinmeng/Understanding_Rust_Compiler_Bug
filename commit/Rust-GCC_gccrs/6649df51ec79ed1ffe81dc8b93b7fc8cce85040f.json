{"sha": "6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY0OWRmNTFlYzc5ZWQxZmZlODFkYzhiOTNiN2ZjOGNjZTg1MDQwZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-05-17T16:37:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-17T16:37:33Z"}, "message": "lto-symtab.c (lto_symtab_resolve_symbols): Preffer decl with constructor over decl without.\n\n\n\t* lto-symtab.c (lto_symtab_resolve_symbols): Preffer decl with constructor\n\tover decl without.\n\t* cgraph.c (cgraph_remove_node): Clear also body of unanalyzed nodes.\n\t* cgraph.h (varpool_can_remove_if_no_refs): Handle external correctly.\n\t* cgraphunit.c (process_function_and_variable_attributes): Finalize \n\textrnal decls.\n\t(mark_functions_to_output): Also accept bodies for functions with clones.\n\t(output_in_order): Skip external vars.\n\t* lto-cgraph.c (lto_output_node): External functions are never in other\n\tpartition.\n\t(lto_output_varpool_node): Likewise.\n\t* lto-streamer-out.c (lto_write_tree): Always use error_mark_nodes for\n\tforgotten initializers.\n\t* ipa.c (process_references): Handle external vars.\n\t(symtab_remove_unreachable_nodes): Update to handle external vars.\n\t(varpool_externally_visible_p): External vars are externally visible.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Update.\n\t* varpool.c (varpool_remove_node): Remove constructor.\n\t(decide_is_variable_needed): Handle externals.\n\t(varpool_remove_unreferenced_decls): Likewise.\n\n\t* lto-partition.c (add_references_to_partition): Handle external vars.\n\t(partition_varpool_node_p): Likewise.\n\t(lto_promote_cross_file_statics): Do not promote externals.\n\nFrom-SVN: r187631", "tree": {"sha": "c091b61bf18ed877244605adef29bd8f35c140b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c091b61bf18ed877244605adef29bd8f35c140b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/comments", "author": null, "committer": null, "parents": [{"sha": "f9eead1f8953869fcfd8be7b0e58aff50fbe1fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9eead1f8953869fcfd8be7b0e58aff50fbe1fd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9eead1f8953869fcfd8be7b0e58aff50fbe1fd5"}], "stats": {"total": 158, "additions": 123, "deletions": 35}, "files": [{"sha": "d64c667ab3e964746a3250ca502fda5fb8214ce6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -1,3 +1,26 @@\n+2012-05-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_symtab_resolve_symbols): Preffer decl with constructor\n+\tover decl without.\n+\t* cgraph.c (cgraph_remove_node): Clear also body of unanalyzed nodes.\n+\t* cgraph.h (varpool_can_remove_if_no_refs): Handle external correctly.\n+\t* cgraphunit.c (process_function_and_variable_attributes): Finalize \n+\textrnal decls.\n+\t(mark_functions_to_output): Also accept bodies for functions with clones.\n+\t(output_in_order): Skip external vars.\n+\t* lto-cgraph.c (lto_output_node): External functions are never in other\n+\tpartition.\n+\t(lto_output_varpool_node): Likewise.\n+\t* lto-streamer-out.c (lto_write_tree): Always use error_mark_nodes for\n+\tforgotten initializers.\n+\t* ipa.c (process_references): Handle external vars.\n+\t(symtab_remove_unreachable_nodes): Update to handle external vars.\n+\t(varpool_externally_visible_p): External vars are externally visible.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Update.\n+\t* varpool.c (varpool_remove_node): Remove constructor.\n+\t(decide_is_variable_needed): Handle externals.\n+\t(varpool_remove_unreferenced_decls): Likewise.\n+\n 2012-05-17  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* opts.c (common_handle_option): -pedantic-errors enables -Wpedantic."}, {"sha": "86a94162236cbcd74f426a1baf101dc65ee31154", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -1242,6 +1242,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \t  && (cgraph_global_info_ready\n \t      && (TREE_ASM_WRITTEN (n->symbol.decl)\n \t\t  || DECL_EXTERNAL (n->symbol.decl)\n+\t\t  || !n->analyzed\n \t\t  || n->symbol.in_other_partition))))\n     cgraph_release_function_body (node);\n "}, {"sha": "de854f74b010b4145a594edd97004aa4567ed3b1", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -1123,11 +1123,12 @@ cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n static inline bool\n varpool_can_remove_if_no_refs (struct varpool_node *node)\n {\n+  if (DECL_EXTERNAL (node->symbol.decl))\n+    return true;\n   return (!node->symbol.force_output && !node->symbol.used_from_other_partition\n   \t  && (DECL_COMDAT (node->symbol.decl)\n-\t  || !node->symbol.externally_visible\n-\t  || DECL_HAS_VALUE_EXPR_P (node->symbol.decl)\n-\t  || DECL_EXTERNAL (node->symbol.decl)));\n+\t      || !node->symbol.externally_visible\n+\t      || DECL_HAS_VALUE_EXPR_P (node->symbol.decl)));\n }\n \n /* Return true when all references to VNODE must be visible in ipa_ref_list."}, {"sha": "97e810e5f2a3302f91449893704f8d7b55d5d964", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -782,6 +782,10 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n        vnode = varpool_next_variable (vnode))\n     {\n       tree decl = vnode->symbol.decl;\n+      if (DECL_EXTERNAL (decl)\n+\t  && DECL_INITIAL (decl)\n+\t  && const_value_known_p (decl))\n+\tvarpool_finalize_decl (decl);\n       if (DECL_PRESERVE_P (decl))\n \tvnode->symbol.force_output = true;\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n@@ -1161,6 +1165,8 @@ mark_functions_to_output (void)\n \t  gcc_assert (node->global.inlined_to\n \t\t      || !gimple_has_body_p (decl)\n \t\t      || node->symbol.in_other_partition\n+\t\t      || node->clones\n+\t\t      || DECL_ARTIFICIAL (decl)\n \t\t      || DECL_EXTERNAL (decl));\n \n \t}\n@@ -1760,12 +1766,13 @@ output_in_order (void)\n     }\n \n   FOR_EACH_DEFINED_VARIABLE (pv)\n-    {\n-      i = pv->symbol.order;\n-      gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n-      nodes[i].kind = ORDER_VAR;\n-      nodes[i].u.v = pv;\n-    }\n+    if (!DECL_EXTERNAL (pv->symbol.decl))\n+      {\n+\ti = pv->symbol.order;\n+\tgcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n+\tnodes[i].kind = ORDER_VAR;\n+\tnodes[i].u.v = pv;\n+      }\n \n   for (pa = asm_nodes; pa; pa = pa->next)\n     {"}, {"sha": "dbe1b838c5baf64423c9cfee2f3090ab41cde331", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -62,18 +62,11 @@ can_refer_decl_in_current_unit_p (tree decl)\n   if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n     return true;\n   /* External flag is set, so we deal with C++ reference\n-     to static object from other file.  */\n+     to static object from other file.\n+     We also may see weakref that is always safe.  */\n   if (DECL_EXTERNAL (decl) && TREE_STATIC (decl)\n       && TREE_CODE (decl) == VAR_DECL)\n-    {\n-      /* Just be sure it is not big in frontend setting\n-\t flags incorrectly.  Those variables should never\n-\t be finalized.  */\n-      gcc_checking_assert (!(vnode = varpool_get_node (decl))\n-\t\t\t   || vnode->alias\n-\t\t\t   || !vnode->finalized);\n-      return false;\n-    }\n+    return lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)) != NULL;\n   /* When function is public, we always can introduce new reference.\n      Exception are the COMDAT functions where introducing a direct\n      reference imply need to include function body in the curren tunit.  */"}, {"sha": "cafa7a11f2a96b60ccc40975b5a38664a11f1e6d", "filename": "gcc/ipa.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -100,7 +100,10 @@ process_references (struct ipa_ref_list *list,\n \t{\n \t  struct varpool_node *node = ipa_ref_varpool_node (ref);\n \n-\t  if (node->analyzed)\n+\t  if (node->analyzed\n+\t      && (!DECL_EXTERNAL (node->symbol.decl)\n+\t\t  || node->alias\n+\t\t  || before_inlining_p))\n \t    pointer_set_insert (reachable, node);\n \t  enqueue_node ((symtab_node) node, first, reachable);\n \t}\n@@ -187,6 +190,12 @@ has_addr_references_p (struct cgraph_node *node,\n      reshape callgraph and preserve body when offline copy of function or\n      inline clone is being removed.\n \n+   - C++ virtual tables keyed to other unit are represented as DECL_EXTERNAL\n+     variables with DECL_INITIAL set.  We finalize these and keep reachable\n+     ones around for constant folding purposes.  After inlining we however\n+     stop walking their references to let everything static referneced by them\n+     to be removed when it is otherwise unreachable.\n+\n    We maintain queue of both reachable symbols (i.e. defined symbols that needs\n    to stay) and symbols that are in boundary (i.e. external symbols referenced\n    by reachable symbols or origins of clones).  The queue is represented\n@@ -323,6 +332,19 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t}\n \t    }\n \t}\n+      /* When we see constructor of external variable, keep referred nodes in the\n+\t boundary.  This will also hold initializers of the external vars NODE\n+\t reffers to.  */\n+      if (symtab_variable_p (node)\n+\t  && DECL_EXTERNAL (node->symbol.decl)\n+\t  && !varpool (node)->alias\n+\t  && in_boundary_p)\n+        {\n+\t  int i;\n+\t  struct ipa_ref *ref;\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+\t    enqueue_node (ref->referred, &first, reachable);\n+        }\n     }\n \n   /* Remove unreachable functions.   */\n@@ -347,7 +369,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      changed = true;\n \t    }\n \t  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl)\n-\t      && !DECL_ARTIFICIAL (node->symbol.decl))\n+\t      && (node->local.finalized || !DECL_ARTIFICIAL (node->symbol.decl)))\n \t    cgraph_release_function_body (node);\n \t  node->analyzed = false;\n \t}\n@@ -627,6 +649,9 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n   if (vnode->alias && DECL_EXTERNAL (vnode->symbol.decl))\n     return true;\n \n+  if (DECL_EXTERNAL (vnode->symbol.decl))\n+    return true;\n+\n   if (!DECL_COMDAT (vnode->symbol.decl) && !TREE_PUBLIC (vnode->symbol.decl))\n     return false;\n "}, {"sha": "447948f75a93f14b971087986c38bf0bb8bd5517", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -440,7 +440,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      Cherry-picked nodes:  These are nodes we pulled from other\n      translation units into SET during IPA-inlining.  We make them as\n      local static nodes to prevent clashes with other local statics.  */\n-  if (boundary_p && node->analyzed)\n+  if (boundary_p && node->analyzed && !DECL_EXTERNAL (node->symbol.decl))\n     {\n       /* Inline clones can not be part of boundary.  \n          gcc_assert (!node->global.inlined_to);  \n@@ -575,6 +575,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n   if (DECL_IN_CONSTANT_POOL (node->symbol.decl)\n+      && !DECL_EXTERNAL (node->symbol.decl)\n       && !DECL_COMDAT (node->symbol.decl))\n     {\n       bp_pack_value (&bp, 0, 1);  /* used_from_other_parition.  */\n@@ -585,7 +586,8 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n       bp_pack_value (&bp, node->analyzed\n \t\t     && referenced_from_other_partition_p (&node->symbol.ref_list,\n \t\t\t\t\t\t\t   set, vset), 1);\n-      bp_pack_value (&bp, boundary_p, 1);  /* in_other_partition.  */\n+      bp_pack_value (&bp, boundary_p && !DECL_EXTERNAL (node->symbol.decl), 1);\n+\t  /* in_other_partition.  */\n     }\n   streamer_write_bitpack (&bp);\n   if (node->alias_of)"}, {"sha": "a4b28422664ab03ebd388ee722ee55adea76d0b6", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -353,11 +353,10 @@ lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n \n \t  varpool_encoder = ob->decl_state->varpool_node_encoder;\n \t  vnode = varpool_get_node (expr);\n-\t  if (!vnode)\n+\t  if (!vnode\n+\t      || !lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n+\t\t\t\t\t\t\t    vnode))\n \t    initial = error_mark_node;\n-\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n-\t\t\t\t\t\t\t      vnode))\n-\t    initial = NULL;\n \t}\n \n       stream_write_tree (ob, initial, ref_p);"}, {"sha": "c5efb7f0156ed430d9fbfa1089a96b59290e9832", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -489,7 +489,21 @@ lto_symtab_resolve_symbols (void **slot)\n       /* From variables that can prevail choose the largest one.  */\n       if (!prevailing\n \t  || tree_int_cst_lt (DECL_SIZE (prevailing->decl),\n-\t\t\t      DECL_SIZE (e->decl)))\n+\t\t\t      DECL_SIZE (e->decl))\n+\t  /* When variables are equivalent try to chose one that has useful\n+\t     DECL_INITIAL.  This makes sense for keyed vtables that are\n+\t     DECL_EXTERNAL but initialized.  In units that do not need them\n+\t     we replace the initializer by error_mark_node to conserve\n+\t     memory.\n+\n+\t     We know that the vtable is keyed outside the LTO unit - otherwise\n+\t     the keyed instance would prevail.  We still can preserve useful\n+\t     info in the initializer.  */\n+\t  || (DECL_SIZE (prevailing->decl) == DECL_SIZE (e->decl)\n+\t      && (DECL_INITIAL (e->decl)\n+\t\t  && DECL_INITIAL (e->decl) != error_mark_node)\n+\t      && (!DECL_INITIAL (prevailing->decl)\n+\t\t  || DECL_INITIAL (prevailing->decl) == error_mark_node)))\n \tprevailing = e;\n     }\n "}, {"sha": "04d4d03ee5b8b843b2b93b3a0008c6c7dbe5a52f", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -1,3 +1,9 @@\n+2012-05-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c (add_references_to_partition): Handle external vars.\n+\t(partition_varpool_node_p): Likewise.\n+\t(lto_promote_cross_file_statics): Do not promote externals.\n+\n 2012-05-14  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* lto-lang.c (handle_fnspec_attribute): New static function."}, {"sha": "602173dd94931f9bac3945c49fcb86224f22c35e", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -83,6 +83,7 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n       else\n         if (symtab_variable_p (ref->referred)\n \t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->symbol.decl)\n+\t\t|| DECL_EXTERNAL (ipa_ref_varpool_node (ref)->symbol.decl)\n \t        || (ref->use == IPA_REF_ALIAS\n \t\t    && lookup_attribute\n \t\t         (\"weakref\",\n@@ -287,6 +288,7 @@ partition_varpool_node_p (struct varpool_node *vnode)\n     return false;\n   /* Constant pool and comdat are always only in partitions they are needed.  */\n   if (DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n+      || DECL_EXTERNAL (vnode->symbol.decl)\n       || (DECL_COMDAT (vnode->symbol.decl)\n \t  && !vnode->symbol.force_output\n \t  && !symtab_used_from_object_file_p ((symtab_node) vnode)))\n@@ -843,6 +845,7 @@ lto_promote_cross_file_statics (void)\n \t     be made global.  It is sensible to keep those ltrans local to\n \t     allow better optimization.  */\n \t  if (!DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n+\t      && !DECL_EXTERNAL (vnode->symbol.decl)\n \t      && !DECL_COMDAT (vnode->symbol.decl)\n \t      && !vnode->symbol.externally_visible && vnode->analyzed\n \t      && referenced_from_other_partition_p (&vnode->symbol.ref_list,\n@@ -893,8 +896,11 @@ lto_promote_cross_file_statics (void)\n \n \t\t  /* Constant pool references use internal labels and thus\n \t\t     cannot be made global.  It is sensible to keep those\n-\t\t     ltrans local to allow better optimization.  */\n-\t\t  if (DECL_IN_CONSTANT_POOL (v->symbol.decl))\n+\t\t     ltrans local to allow better optimization.\n+\t\t     Similarly we ship external vars initializers into\n+\t\t     every ltrans unit possibly referring to it.  */\n+\t\t  if (DECL_IN_CONSTANT_POOL (v->symbol.decl)\n+\t\t      || DECL_EXTERNAL (v->symbol.decl))\n \t\t    {\n \t\t      if (!pointer_set_insert (inserted, vnode))\n \t\t\tVEC_safe_push (varpool_node_ptr, heap,"}, {"sha": "ceb16f9bbcac7871378e1a590a82b4fe5a39fc69", "filename": "gcc/varpool.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "patch": "@@ -59,6 +59,14 @@ void\n varpool_remove_node (struct varpool_node *node)\n {\n   symtab_unregister_node ((symtab_node)node);\n+  if (DECL_INITIAL (node->symbol.decl)\n+      && !DECL_IN_CONSTANT_POOL (node->symbol.decl)\n+      /* Keep vtables for BINFO folding.  */\n+      && !DECL_VIRTUAL_P (node->symbol.decl)\n+      /* dbxout output constant initializers for readonly vars.  */\n+      && (!host_integerp (DECL_INITIAL (node->symbol.decl), 0)\n+\t  || !TREE_READONLY (node->symbol.decl)))\n+    DECL_INITIAL (node->symbol.decl) = error_mark_node;\n   ggc_free (node);\n }\n \n@@ -118,17 +126,17 @@ varpool_node_for_asm (tree asmname)\n bool\n decide_is_variable_needed (struct varpool_node *node, tree decl)\n {\n+  if (DECL_EXTERNAL (decl))\n+    return false;\n+\n   /* If the user told us it is used, then it must be so.  */\n   if (node->symbol.force_output)\n     return true;\n \n-  gcc_assert (!DECL_EXTERNAL (decl));\n-\n   /* Externally visible variables must be output.  The exception is\n      COMDAT variables that must be output only when they are needed.  */\n   if (TREE_PUBLIC (decl)\n-      && !DECL_COMDAT (decl)\n-      && !DECL_EXTERNAL (decl))\n+      && !DECL_COMDAT (decl))\n     return true;\n \n   return false;\n@@ -348,7 +356,8 @@ varpool_remove_unreferenced_decls (void)\n \t  && (!varpool_can_remove_if_no_refs (node)\n \t      /* We just expanded all function bodies.  See if any of\n \t\t them needed the variable.  */\n-\t      || DECL_RTL_SET_P (node->symbol.decl)))\n+\t      || (!DECL_EXTERNAL (node->symbol.decl)\n+\t\t  && DECL_RTL_SET_P (node->symbol.decl))))\n \t{\n \t  enqueue_node (node, &first);\n           if (cgraph_dump_file)\n@@ -372,6 +381,8 @@ varpool_remove_unreferenced_decls (void)\n \t}\n       for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n \tif (symtab_variable_p (ref->referred)\n+\t    && (!DECL_EXTERNAL (ref->referred->symbol.decl)\n+\t\t|| varpool (ref->referred)->alias)\n \t    && varpool (ref->referred)->analyzed)\n \t  enqueue_node (varpool (ref->referred), &first);\n     }"}]}