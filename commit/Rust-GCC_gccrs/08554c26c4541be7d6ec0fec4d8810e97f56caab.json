{"sha": "08554c26c4541be7d6ec0fec4d8810e97f56caab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg1NTRjMjZjNDU0MWJlN2Q2ZWMwZmVjNGQ4ODEwZTk3ZjU2Y2FhYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-12-09T13:42:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-12-09T13:42:06Z"}, "message": "re PR tree-optimization/68786 (Aligned masked store is generated for unaligned pointer)\n\n\tPR tree-optimization/68786\n\t* tree-if-conv.c: Include builtins.h.\n\t(predicate_mem_writes): Put result of get_object_alignment (ref)\n\tinto second argument's value.\n\t* tree-vect-stmts.c (vectorizable_mask_load_store): Put minimum\n\tpointer alignment into second argument's value.\n\t* tree-data-ref.c (get_references_in_stmt): Use value of second\n\targument for build_aligned_type, and only the type to build\n\ta zero second argument for MEM_REF.\n\t* internal-fn.c (expand_mask_load_optab_fn,\n\texpand_mask_store_optab_fn): Likewise.\n\nFrom-SVN: r231454", "tree": {"sha": "502f1c7099772546308e02600f4ab82c0d8b35ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/502f1c7099772546308e02600f4ab82c0d8b35ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08554c26c4541be7d6ec0fec4d8810e97f56caab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08554c26c4541be7d6ec0fec4d8810e97f56caab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08554c26c4541be7d6ec0fec4d8810e97f56caab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08554c26c4541be7d6ec0fec4d8810e97f56caab/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e56c602ea3335648e81411442a66e52dd129dc3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56c602ea3335648e81411442a66e52dd129dc3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e56c602ea3335648e81411442a66e52dd129dc3b"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "8526be6e85b7af2b9f0f3d25005aee2d8e50690b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08554c26c4541be7d6ec0fec4d8810e97f56caab", "patch": "@@ -1,3 +1,17 @@\n+2015-12-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/68786\n+\t* tree-if-conv.c: Include builtins.h.\n+\t(predicate_mem_writes): Put result of get_object_alignment (ref)\n+\tinto second argument's value.\n+\t* tree-vect-stmts.c (vectorizable_mask_load_store): Put minimum\n+\tpointer alignment into second argument's value.\n+\t* tree-data-ref.c (get_references_in_stmt): Use value of second\n+\targument for build_aligned_type, and only the type to build\n+\ta zero second argument for MEM_REF.\n+\t* internal-fn.c (expand_mask_load_optab_fn,\n+\texpand_mask_store_optab_fn): Likewise.\n+\n 2015-12-09  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68583"}, {"sha": "3ceaffe67eaa694afe35de8f7a13a182c46f05ff", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=08554c26c4541be7d6ec0fec4d8810e97f56caab", "patch": "@@ -1911,16 +1911,20 @@ static void\n expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[3];\n-  tree type, lhs, rhs, maskt;\n+  tree type, lhs, rhs, maskt, ptr;\n   rtx mem, target, mask;\n+  unsigned align;\n \n   maskt = gimple_call_arg (stmt, 2);\n   lhs = gimple_call_lhs (stmt);\n   if (lhs == NULL_TREE)\n     return;\n   type = TREE_TYPE (lhs);\n-  rhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0),\n-\t\t     gimple_call_arg (stmt, 1));\n+  ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)), 0);\n+  align = tree_to_shwi (gimple_call_arg (stmt, 1));\n+  if (TYPE_ALIGN (type) != align)\n+    type = build_aligned_type (type, align);\n+  rhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0), ptr);\n \n   mem = expand_expr (rhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   gcc_assert (MEM_P (mem));\n@@ -1940,14 +1944,18 @@ static void\n expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n   struct expand_operand ops[3];\n-  tree type, lhs, rhs, maskt;\n+  tree type, lhs, rhs, maskt, ptr;\n   rtx mem, reg, mask;\n+  unsigned align;\n \n   maskt = gimple_call_arg (stmt, 2);\n   rhs = gimple_call_arg (stmt, 3);\n   type = TREE_TYPE (rhs);\n-  lhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0),\n-\t\t     gimple_call_arg (stmt, 1));\n+  ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)), 0);\n+  align = tree_to_shwi (gimple_call_arg (stmt, 1));\n+  if (TYPE_ALIGN (type) != align)\n+    type = build_aligned_type (type, align);\n+  lhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0), ptr);\n \n   mem = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   gcc_assert (MEM_P (mem));"}, {"sha": "ec800556b1b3071f5a773b7623efa2cecd3b4971", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=08554c26c4541be7d6ec0fec4d8810e97f56caab", "patch": "@@ -3872,6 +3872,8 @@ get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n   else if (stmt_code == GIMPLE_CALL)\n     {\n       unsigned i, n;\n+      tree ptr, type;\n+      unsigned int align;\n \n       ref.is_read = false;\n       if (gimple_call_internal_p (stmt))\n@@ -3882,12 +3884,16 @@ get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n \t      break;\n \t    ref.is_read = true;\n \t  case IFN_MASK_STORE:\n-\t    ref.ref = fold_build2 (MEM_REF,\n-\t\t\t\t   ref.is_read\n-\t\t\t\t   ? TREE_TYPE (gimple_call_lhs (stmt))\n-\t\t\t\t   : TREE_TYPE (gimple_call_arg (stmt, 3)),\n-\t\t\t\t   gimple_call_arg (stmt, 0),\n-\t\t\t\t   gimple_call_arg (stmt, 1));\n+\t    ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)), 0);\n+\t    align = tree_to_shwi (gimple_call_arg (stmt, 1));\n+\t    if (ref.is_read)\n+\t      type = TREE_TYPE (gimple_call_lhs (stmt));\n+\t    else\n+\t      type = TREE_TYPE (gimple_call_arg (stmt, 3));\n+\t    if (TYPE_ALIGN (type) != align)\n+\t      type = build_aligned_type (type, align);\n+\t    ref.ref = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0),\n+\t\t\t\t   ptr);\n \t    references->safe_push (ref);\n \t    return false;\n \t  default:"}, {"sha": "55b590b253de2a1ef8df3f932b379792b3748f94", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=08554c26c4541be7d6ec0fec4d8810e97f56caab", "patch": "@@ -111,6 +111,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"tree-hash-traits.h\"\n #include \"varasm.h\"\n+#include \"builtins.h\"\n \n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n@@ -2056,7 +2057,8 @@ predicate_mem_writes (loop_p loop)\n \t        vect_sizes.safe_push (bitsize);\n \t\tvect_masks.safe_push (mask);\n \t      }\n-\t    ptr = build_int_cst (reference_alias_ptr_type (ref), 0);\n+\t    ptr = build_int_cst (reference_alias_ptr_type (ref),\n+\t\t\t\t get_object_alignment (ref));\n \t    /* Copy points-to info if possible.  */\n \t    if (TREE_CODE (addr) == SSA_NAME && !SSA_NAME_PTR_INFO (addr))\n \t      copy_ref_info (build2 (MEM_REF, TREE_TYPE (ref), addr, ptr),"}, {"sha": "56aa2c8cce583c42120d90f3073bec068d098b2a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08554c26c4541be7d6ec0fec4d8810e97f56caab/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=08554c26c4541be7d6ec0fec4d8810e97f56caab", "patch": "@@ -2058,10 +2058,11 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    misalign = DR_MISALIGNMENT (dr);\n \t  set_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n \t\t\t\t  misalign);\n+\t  tree ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)),\n+\t\t\t\t    misalign ? misalign & -misalign : align);\n \t  new_stmt\n \t    = gimple_build_call_internal (IFN_MASK_STORE, 4, dataref_ptr,\n-\t\t\t\t\t  gimple_call_arg (stmt, 1),\n-\t\t\t\t\t  vec_mask, vec_rhs);\n+\t\t\t\t\t  ptr, vec_mask, vec_rhs);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  if (i == 0)\n \t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n@@ -2107,10 +2108,11 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    misalign = DR_MISALIGNMENT (dr);\n \t  set_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n \t\t\t\t  misalign);\n+\t  tree ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)),\n+\t\t\t\t    misalign ? misalign & -misalign : align);\n \t  new_stmt\n \t    = gimple_build_call_internal (IFN_MASK_LOAD, 3, dataref_ptr,\n-\t\t\t\t\t  gimple_call_arg (stmt, 1),\n-\t\t\t\t\t  vec_mask);\n+\t\t\t\t\t  ptr, vec_mask);\n \t  gimple_call_set_lhs (new_stmt, make_ssa_name (vec_dest));\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  if (i == 0)"}]}