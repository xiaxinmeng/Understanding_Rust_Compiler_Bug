{"sha": "89d7557202d25a393666ac4c0f7dbdab31e452a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkNzU1NzIwMmQyNWEzOTM2NjZhYzRjMGY3ZGJkYWIzMWU0NTJhMg==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@linaro.org", "date": "2018-11-22T14:46:17Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2018-11-22T14:46:17Z"}, "message": "PR85434: Prevent spilling of stack protector guard's address on ARM\n\nIn case of high register pressure in PIC mode, address of the stack\nprotector's guard can be spilled on ARM targets as shown in PR85434,\nthus allowing an attacker to control what the canary would be compared\nagainst. ARM does lack stack_protect_set and stack_protect_test insn\npatterns, defining them does not help as the address is expanded\nregularly and the patterns only deal with the copy and test of the\nguard with the canary.\n\nThis problem does not occur for x86 targets because the PIC access and\nthe test can be done in the same instruction. Aarch64 is exempt too\nbecause PIC access insn pattern are mov of UNSPEC which prevents it from\nthe second access in the epilogue being CSEd in cse_local pass with the\nfirst access in the prologue.\n\nThe approach followed here is to create new \"combined\" set and test\nstandard pattern names that take the unexpanded guard and do the set or\ntest. This allows the target to use an opaque pattern (eg. using UNSPEC)\nto hide the individual instructions being generated to the compiler and\nsplit the pattern into generic load, compare and branch instruction\nafter register allocator, therefore avoiding any spilling. This is here\nimplemented for the ARM targets. For targets not implementing these new\nstandard pattern names, the existing stack_protect_set and\nstack_protect_test pattern names are used.\n\nTo be able to split PIC access after register allocation, the functions\nhad to be augmented to force a new PIC register load and to control\nwhich register it loads into. This is because sharing the PIC register\nbetween prologue and epilogue could lead to spilling due to CSE again\nwhich an attacker could use to control what the canary gets compared\nagainst.\n\n2018-11-22  Thomas Preud'homme  <thomas.preudhomme@linaro.org>\n\n    gcc/\n    PR target/85434\n    * target-insns.def (stack_protect_combined_set): Define new standard\n    pattern name.\n    (stack_protect_combined_test): Likewise.\n    * cfgexpand.c (stack_protect_prologue): Try new\n    stack_protect_combined_set pattern first.\n    * function.c (stack_protect_epilogue): Try new\n    stack_protect_combined_test pattern first.\n    * config/arm/arm.c (require_pic_register): Add pic_reg and compute_now\n    parameters to control which register to use as PIC register and force\n    reloading PIC register respectively.  Insert in the stream of insns if\n    possible.\n    (legitimize_pic_address): Expose above new parameters in prototype and\n    adapt recursive calls accordingly.  Use pic_reg if non null instead of\n    cached one.\n    (arm_load_pic_register): Add pic_reg parameter and use it if non null.\n    (arm_legitimize_address): Adapt to new legitimize_pic_address\n    prototype.\n    (thumb_legitimize_address): Likewise.\n    (arm_emit_call_insn): Adapt to require_pic_register prototype change.\n    (arm_expand_prologue): Adapt to arm_load_pic_register prototype change.\n    (thumb1_expand_prologue): Likewise.\n    * config/arm/arm-protos.h (legitimize_pic_address): Adapt to prototype\n    change.\n    (arm_load_pic_register): Likewise.\n    * config/arm/predicated.md (guard_addr_operand): New predicate.\n    (guard_operand): New predicate.\n    * config/arm/arm.md (movsi expander): Adapt to legitimize_pic_address\n    prototype change.\n    (builtin_setjmp_receiver expander): Adapt to thumb1_expand_prologue\n    prototype change.\n    (stack_protect_combined_set): New expander..\n    (stack_protect_combined_set_insn): New insn_and_split pattern.\n    (stack_protect_set_insn): New insn pattern.\n    (stack_protect_combined_test): New expander.\n    (stack_protect_combined_test_insn): New insn_and_split pattern.\n    (arm_stack_protect_test_insn): New insn pattern.\n    * config/arm/thumb1.md (thumb1_stack_protect_test_insn): New insn pattern.\n    * config/arm/unspecs.md (UNSPEC_SP_SET): New unspec.\n    (UNSPEC_SP_TEST): Likewise.\n    * doc/md.texi (stack_protect_combined_set): Document new standard\n    pattern name.\n    (stack_protect_set): Clarify that the operand for guard's address is\n    legal.\n    (stack_protect_combined_test): Document new standard pattern name.\n    (stack_protect_test): Clarify that the operand for guard's address is\n    legal.\n\n    gcc/testsuite/\n    PR target/85434\n    * gcc.target/arm/pr85434.c: New test.\n\nFrom-SVN: r266379", "tree": {"sha": "8b2119c8e42ceb6779b4baa569523fdab6ec5a19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b2119c8e42ceb6779b4baa569523fdab6ec5a19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d7557202d25a393666ac4c0f7dbdab31e452a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d7557202d25a393666ac4c0f7dbdab31e452a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d7557202d25a393666ac4c0f7dbdab31e452a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d7557202d25a393666ac4c0f7dbdab31e452a2/comments", "author": {"login": "tpreudhomme-linaro", "id": 43454833, "node_id": "MDQ6VXNlcjQzNDU0ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/43454833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tpreudhomme-linaro", "html_url": "https://github.com/tpreudhomme-linaro", "followers_url": "https://api.github.com/users/tpreudhomme-linaro/followers", "following_url": "https://api.github.com/users/tpreudhomme-linaro/following{/other_user}", "gists_url": "https://api.github.com/users/tpreudhomme-linaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/tpreudhomme-linaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tpreudhomme-linaro/subscriptions", "organizations_url": "https://api.github.com/users/tpreudhomme-linaro/orgs", "repos_url": "https://api.github.com/users/tpreudhomme-linaro/repos", "events_url": "https://api.github.com/users/tpreudhomme-linaro/events{/privacy}", "received_events_url": "https://api.github.com/users/tpreudhomme-linaro/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5f0e0412b9aa61d960ffbb83327415da226f266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f0e0412b9aa61d960ffbb83327415da226f266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f0e0412b9aa61d960ffbb83327415da226f266"}], "stats": {"total": 646, "additions": 603, "deletions": 43}, "files": [{"sha": "fa41e7112e0f412d819a0fe72c339f59c95d1ac8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -1,3 +1,52 @@\n+2018-11-22  Thomas Preud'homme  <thomas.preudhomme@linaro.org>\n+\n+\t* target-insns.def (stack_protect_combined_set): Define new standard\n+\tpattern name.\n+\t(stack_protect_combined_test): Likewise.\n+\t* cfgexpand.c (stack_protect_prologue): Try new\n+\tstack_protect_combined_set pattern first.\n+\t* function.c (stack_protect_epilogue): Try new\n+\tstack_protect_combined_test pattern first.\n+\t* config/arm/arm.c (require_pic_register): Add pic_reg and compute_now\n+\tparameters to control which register to use as PIC register and force\n+\treloading PIC register respectively.  Insert in the stream of insns if\n+\tpossible.\n+\t(legitimize_pic_address): Expose above new parameters in prototype and\n+\tadapt recursive calls accordingly.  Use pic_reg if non null instead of\n+\tcached one.\n+\t(arm_load_pic_register): Add pic_reg parameter and use it if non null.\n+\t(arm_legitimize_address): Adapt to new legitimize_pic_address\n+\tprototype.\n+\t(thumb_legitimize_address): Likewise.\n+\t(arm_emit_call_insn): Adapt to require_pic_register prototype change.\n+\t(arm_expand_prologue): Adapt to arm_load_pic_register prototype change.\n+\t(thumb1_expand_prologue): Likewise.\n+\t* config/arm/arm-protos.h (legitimize_pic_address): Adapt to prototype\n+\tchange.\n+\t(arm_load_pic_register): Likewise.\n+\t* config/arm/predicated.md (guard_addr_operand): New predicate.\n+\t(guard_operand): New predicate.\n+\t* config/arm/arm.md (movsi expander): Adapt to legitimize_pic_address\n+\tprototype change.\n+\t(builtin_setjmp_receiver expander): Adapt to thumb1_expand_prologue\n+\tprototype change.\n+\t(stack_protect_combined_set): New expander..\n+\t(stack_protect_combined_set_insn): New insn_and_split pattern.\n+\t(stack_protect_set_insn): New insn pattern.\n+\t(stack_protect_combined_test): New expander.\n+\t(stack_protect_combined_test_insn): New insn_and_split pattern.\n+\t(arm_stack_protect_test_insn): New insn pattern.\n+\t* config/arm/thumb1.md (thumb1_stack_protect_test_insn): New insn pattern.\n+\t* config/arm/unspecs.md (UNSPEC_SP_SET): New unspec.\n+\t(UNSPEC_SP_TEST): Likewise.\n+\t* doc/md.texi (stack_protect_combined_set): Document new standard\n+\tpattern name.\n+\t(stack_protect_set): Clarify that the operand for guard's address is\n+\tlegal.\n+\t(stack_protect_combined_test): Document new standard pattern name.\n+\t(stack_protect_test): Clarify that the operand for guard's address is\n+\tlegal.\n+\n 2018-11-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/88148"}, {"sha": "21bdcdaeaa351972daf6a176da7ad9e5bdafc08c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -6185,6 +6185,23 @@ stack_protect_prologue (void)\n   rtx x, y;\n \n   x = expand_normal (crtl->stack_protect_guard);\n+\n+  if (targetm.have_stack_protect_combined_set () && guard_decl)\n+    {\n+      gcc_assert (DECL_P (guard_decl));\n+      y = DECL_RTL (guard_decl);\n+\n+      /* Allow the target to compute address of Y and copy it to X without\n+\t leaking Y into a register.  This combined address + copy pattern\n+\t allows the target to prevent spilling of any intermediate results by\n+\t splitting it after register allocator.  */\n+      if (rtx_insn *insn = targetm.gen_stack_protect_combined_set (x, y))\n+\t{\n+\t  emit_insn (insn);\n+\t  return;\n+\t}\n+    }\n+\n   if (guard_decl)\n     y = expand_normal (guard_decl);\n   else"}, {"sha": "00f5f16ed027ec40111c5d15dc8f1d8697eb5ca8", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -28,7 +28,7 @@ extern enum unwind_info_type arm_except_unwind_info (struct gcc_options *);\n extern int use_return_insn (int, rtx);\n extern bool use_simple_return_p (void);\n extern enum reg_class arm_regno_class (int);\n-extern void arm_load_pic_register (unsigned long);\n+extern void arm_load_pic_register (unsigned long, rtx);\n extern int arm_volatile_func (void);\n extern void arm_expand_prologue (void);\n extern void arm_expand_epilogue (bool);\n@@ -69,7 +69,7 @@ extern int const_ok_for_dimode_op (HOST_WIDE_INT, enum rtx_code);\n extern int arm_split_constant (RTX_CODE, machine_mode, rtx,\n \t\t\t       HOST_WIDE_INT, rtx, rtx, int);\n extern int legitimate_pic_operand_p (rtx);\n-extern rtx legitimize_pic_address (rtx, machine_mode, rtx);\n+extern rtx legitimize_pic_address (rtx, machine_mode, rtx, rtx, bool);\n extern rtx legitimize_tls_address (rtx, rtx);\n extern bool arm_legitimate_address_p (machine_mode, rtx, bool);\n extern int arm_legitimate_address_outer_p (machine_mode, rtx, RTX_CODE, int);"}, {"sha": "12417de5102faeba5055bb5d1c9d2aaa83ddedde", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -7379,21 +7379,34 @@ legitimate_pic_operand_p (rtx x)\n   return 1;\n }\n \n-/* Record that the current function needs a PIC register.  Initialize\n-   cfun->machine->pic_reg if we have not already done so.  */\n+/* Record that the current function needs a PIC register.  If PIC_REG is null,\n+   a new pseudo is allocated as PIC register, otherwise PIC_REG is used.  In\n+   both case cfun->machine->pic_reg is initialized if we have not already done\n+   so.  COMPUTE_NOW decide whether and where to set the PIC register.  If true,\n+   PIC register is reloaded in the current position of the instruction stream\n+   irregardless of whether it was loaded before.  Otherwise, it is only loaded\n+   if not already done so (crtl->uses_pic_offset_table is null).  Note that\n+   nonnull PIC_REG is only supported iff COMPUTE_NOW is true and null PIC_REG\n+   is only supported iff COMPUTE_NOW is false.  */\n \n static void\n-require_pic_register (void)\n+require_pic_register (rtx pic_reg, bool compute_now)\n {\n+  gcc_assert (compute_now == (pic_reg != NULL_RTX));\n+\n   /* A lot of the logic here is made obscure by the fact that this\n      routine gets called as part of the rtx cost estimation process.\n      We don't want those calls to affect any assumptions about the real\n      function; and further, we can't call entry_of_function() until we\n      start the real expansion process.  */\n-  if (!crtl->uses_pic_offset_table)\n+  if (!crtl->uses_pic_offset_table || compute_now)\n     {\n-      gcc_assert (can_create_pseudo_p ());\n+      gcc_assert (can_create_pseudo_p ()\n+\t\t  || (pic_reg != NULL_RTX\n+\t\t      && REG_P (pic_reg)\n+\t\t      && GET_MODE (pic_reg) == Pmode));\n       if (arm_pic_register != INVALID_REGNUM\n+\t  && !compute_now\n \t  && !(TARGET_THUMB1 && arm_pic_register > LAST_LO_REGNUM))\n \t{\n \t  if (!cfun->machine->pic_reg)\n@@ -7409,8 +7422,10 @@ require_pic_register (void)\n \t{\n \t  rtx_insn *seq, *insn;\n \n+\t  if (pic_reg == NULL_RTX)\n+\t    pic_reg = gen_reg_rtx (Pmode);\n \t  if (!cfun->machine->pic_reg)\n-\t    cfun->machine->pic_reg = gen_reg_rtx (Pmode);\n+\t    cfun->machine->pic_reg = pic_reg;\n \n \t  /* Play games to avoid marking the function as needing pic\n \t     if we are being called as part of the cost-estimation\n@@ -7421,11 +7436,12 @@ require_pic_register (void)\n \t      start_sequence ();\n \n \t      if (TARGET_THUMB1 && arm_pic_register != INVALID_REGNUM\n-\t\t  && arm_pic_register > LAST_LO_REGNUM)\n+\t\t  && arm_pic_register > LAST_LO_REGNUM\n+\t\t  && !compute_now)\n \t\temit_move_insn (cfun->machine->pic_reg,\n \t\t\t\tgen_rtx_REG (Pmode, arm_pic_register));\n \t      else\n-\t\tarm_load_pic_register (0UL);\n+\t\tarm_load_pic_register (0UL, pic_reg);\n \n \t      seq = get_insns ();\n \t      end_sequence ();\n@@ -7438,16 +7454,33 @@ require_pic_register (void)\n \t         we can't yet emit instructions directly in the final\n \t\t insn stream.  Queue the insns on the entry edge, they will\n \t\t be committed after everything else is expanded.  */\n-\t      insert_insn_on_edge (seq,\n-\t\t\t\t   single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t      if (currently_expanding_to_rtl)\n+\t\tinsert_insn_on_edge (seq,\n+\t\t\t\t     single_succ_edge\n+\t\t\t\t     (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t      else\n+\t\temit_insn (seq);\n \t    }\n \t}\n     }\n }\n \n+/* Legitimize PIC load to ORIG into REG.  If REG is NULL, a new pseudo is\n+   created to hold the result of the load.  If not NULL, PIC_REG indicates\n+   which register to use as PIC register, otherwise it is decided by register\n+   allocator.  COMPUTE_NOW forces the PIC register to be loaded at the current\n+   location in the instruction stream, irregardless of whether it was loaded\n+   previously.  Note that nonnull PIC_REG is only supported iff COMPUTE_NOW is\n+   true and null PIC_REG is only supported iff COMPUTE_NOW is false.\n+\n+   Returns the register REG into which the PIC load is performed.  */\n+\n rtx\n-legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n+legitimize_pic_address (rtx orig, machine_mode mode, rtx reg, rtx pic_reg,\n+\t\t\tbool compute_now)\n {\n+  gcc_assert (compute_now == (pic_reg != NULL_RTX));\n+\n   if (GET_CODE (orig) == SYMBOL_REF\n       || GET_CODE (orig) == LABEL_REF)\n     {\n@@ -7480,9 +7513,12 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n \t  rtx mem;\n \n \t  /* If this function doesn't have a pic register, create one now.  */\n-\t  require_pic_register ();\n+\t  require_pic_register (pic_reg, compute_now);\n+\n+\t  if (pic_reg == NULL_RTX)\n+\t    pic_reg = cfun->machine->pic_reg;\n \n-\t  pat = gen_calculate_pic_address (reg, cfun->machine->pic_reg, orig);\n+\t  pat = gen_calculate_pic_address (reg, pic_reg, orig);\n \n \t  /* Make the MEM as close to a constant as possible.  */\n \t  mem = SET_SRC (pat);\n@@ -7531,9 +7567,11 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n \n       gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n \n-      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg,\n+\t\t\t\t     pic_reg, compute_now);\n       offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t       base == reg ? 0 : reg);\n+\t\t\t\t       base == reg ? 0 : reg, pic_reg,\n+\t\t\t\t       compute_now);\n \n       if (CONST_INT_P (offset))\n \t{\n@@ -7633,16 +7671,17 @@ static GTY(()) int pic_labelno;\n    low register.  */\n \n void\n-arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n+arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED, rtx pic_reg)\n {\n-  rtx l1, labelno, pic_tmp, pic_rtx, pic_reg;\n+  rtx l1, labelno, pic_tmp, pic_rtx;\n \n   if (crtl->uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n     return;\n \n   gcc_assert (flag_pic);\n \n-  pic_reg = cfun->machine->pic_reg;\n+  if (pic_reg == NULL_RTX)\n+    pic_reg = cfun->machine->pic_reg;\n   if (TARGET_VXWORKS_RTP)\n     {\n       pic_rtx = gen_rtx_SYMBOL_REF (Pmode, VXWORKS_GOTT_BASE);\n@@ -8718,7 +8757,8 @@ arm_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n     {\n       /* We need to find and carefully transform any SYMBOL and LABEL\n \t references; so go back to the original address expression.  */\n-      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX);\n+      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t  false /*compute_now*/);\n \n       if (new_x != orig_x)\n \tx = new_x;\n@@ -8786,7 +8826,8 @@ thumb_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n     {\n       /* We need to find and carefully transform any SYMBOL and LABEL\n \t references; so go back to the original address expression.  */\n-      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX);\n+      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t  false /*compute_now*/);\n \n       if (new_x != orig_x)\n \tx = new_x;\n@@ -18074,7 +18115,7 @@ arm_emit_call_insn (rtx pat, rtx addr, bool sibcall)\n \t  ? !targetm.binds_local_p (SYMBOL_REF_DECL (addr))\n \t  : !SYMBOL_REF_LOCAL_P (addr)))\n     {\n-      require_pic_register ();\n+      require_pic_register (NULL_RTX, false /*compute_now*/);\n       use_reg (&CALL_INSN_FUNCTION_USAGE (insn), cfun->machine->pic_reg);\n     }\n \n@@ -22006,7 +22047,7 @@ arm_expand_prologue (void)\n       mask &= THUMB2_WORK_REGS;\n       if (!IS_NESTED (func_type))\n \tmask |= (1 << IP_REGNUM);\n-      arm_load_pic_register (mask);\n+      arm_load_pic_register (mask, NULL_RTX);\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -25237,7 +25278,7 @@ thumb1_expand_prologue (void)\n   /* Load the pic register before setting the frame pointer,\n      so we can use r7 as a temporary work register.  */\n   if (flag_pic && arm_pic_register != INVALID_REGNUM)\n-    arm_load_pic_register (live_regs_mask);\n+    arm_load_pic_register (live_regs_mask, NULL_RTX);\n \n   if (!frame_pointer_needed && CALLER_INTERWORKING_SLOT_SIZE > 0)\n     emit_move_insn (gen_rtx_REG (Pmode, ARM_HARD_FRAME_POINTER_REGNUM),"}, {"sha": "f6196e9316898e3258e08d8f2ece8fe9640676ca", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 161, "deletions": 2, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -6021,7 +6021,8 @@\n       operands[1] = legitimize_pic_address (operands[1], SImode,\n \t\t\t\t\t    (!can_create_pseudo_p ()\n \t\t\t\t\t     ? operands[0]\n-\t\t\t\t\t     : 0));\n+\t\t\t\t\t     : NULL_RTX), NULL_RTX,\n+\t\t\t\t\t    false /*compute_now*/);\n   }\n   \"\n )\n@@ -6309,7 +6310,7 @@\n   /* r3 is clobbered by set/longjmp, so we can use it as a scratch\n      register.  */\n   if (arm_pic_register != INVALID_REGNUM)\n-    arm_load_pic_register (1UL << 3);\n+    arm_load_pic_register (1UL << 3, NULL_RTX);\n   DONE;\n }\")\n \n@@ -8634,6 +8635,164 @@\n    (set_attr \"conds\" \"clob\")]\n )\n \n+;; Named patterns for stack smashing protection.\n+(define_expand \"stack_protect_combined_set\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"memory_operand\" \"\")\n+\t   (unspec:SI [(match_operand:SI 1 \"guard_operand\" \"\")]\n+\t\t      UNSPEC_SP_SET))\n+      (clobber (match_scratch:SI 2 \"\"))\n+      (clobber (match_scratch:SI 3 \"\"))])]\n+  \"\"\n+  \"\"\n+)\n+\n+;; Use a separate insn from the above expand to be able to have the mem outside\n+;; the operand #1 when register allocation comes. This is needed to avoid LRA\n+;; try to reload the guard since we need to control how PIC access is done in\n+;; the -fpic/-fPIC case (see COMPUTE_NOW parameter when calling\n+;; legitimize_pic_address ()).\n+(define_insn_and_split \"*stack_protect_combined_set_insn\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m,m\")\n+\t(unspec:SI [(mem:SI (match_operand:SI 1 \"guard_addr_operand\" \"X,X\"))]\n+\t\t   UNSPEC_SP_SET))\n+   (clobber (match_scratch:SI 2 \"=&l,&r\"))\n+   (clobber (match_scratch:SI 3 \"=&l,&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (unspec:SI [(mem:SI (match_dup 2))]\n+\t\t\t\t\t    UNSPEC_SP_SET))\n+\t      (clobber (match_dup 2))])]\n+  \"\n+{\n+  if (flag_pic)\n+    {\n+      /* Forces recomputing of GOT base now.  */\n+      legitimize_pic_address (operands[1], SImode, operands[2], operands[3],\n+\t\t\t      true /*compute_now*/);\n+    }\n+  else\n+    {\n+      if (address_operand (operands[1], SImode))\n+\toperands[2] = operands[1];\n+      else\n+\t{\n+\t  rtx mem = XEXP (force_const_mem (SImode, operands[1]), 0);\n+\t  emit_move_insn (operands[2], mem);\n+\t}\n+    }\n+}\"\n+  [(set_attr \"arch\" \"t1,32\")]\n+)\n+\n+(define_insn \"*stack_protect_set_insn\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m,m\")\n+\t(unspec:SI [(mem:SI (match_operand:SI 1 \"register_operand\" \"+&l,&r\"))]\n+\t UNSPEC_SP_SET))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"@\n+   ldr\\\\t%1, [%1]\\;str\\\\t%1, %0\\;movs\\t%1,#0\n+   ldr\\\\t%1, [%1]\\;str\\\\t%1, %0\\;mov\\t%1,#0\"\n+  [(set_attr \"length\" \"8,12\")\n+   (set_attr \"conds\" \"clob,nocond\")\n+   (set_attr \"type\" \"multiple\")\n+   (set_attr \"arch\" \"t1,32\")]\n+)\n+\n+(define_expand \"stack_protect_combined_test\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t\t(eq (match_operand:SI 0 \"memory_operand\" \"\")\n+\t\t    (unspec:SI [(match_operand:SI 1 \"guard_operand\" \"\")]\n+\t\t\t       UNSPEC_SP_TEST))\n+\t\t(label_ref (match_operand 2))\n+\t\t(pc)))\n+      (clobber (match_scratch:SI 3 \"\"))\n+      (clobber (match_scratch:SI 4 \"\"))\n+      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n+  \"\"\n+)\n+\n+;; Use a separate insn from the above expand to be able to have the mem outside\n+;; the operand #1 when register allocation comes. This is needed to avoid LRA\n+;; try to reload the guard since we need to control how PIC access is done in\n+;; the -fpic/-fPIC case (see COMPUTE_NOW parameter when calling\n+;; legitimize_pic_address ()).\n+(define_insn_and_split \"*stack_protect_combined_test_insn\"\n+  [(set (pc)\n+\t(if_then_else\n+\t\t(eq (match_operand:SI 0 \"memory_operand\" \"m,m\")\n+\t\t    (unspec:SI [(mem:SI (match_operand:SI 1 \"guard_addr_operand\" \"X,X\"))]\n+\t\t\t       UNSPEC_SP_TEST))\n+\t\t(label_ref (match_operand 2))\n+\t\t(pc)))\n+   (clobber (match_scratch:SI 3 \"=&l,&r\"))\n+   (clobber (match_scratch:SI 4 \"=&l,&r\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx eq;\n+\n+  if (flag_pic)\n+    {\n+      /* Forces recomputing of GOT base now.  */\n+      legitimize_pic_address (operands[1], SImode, operands[3], operands[4],\n+\t\t\t      true /*compute_now*/);\n+    }\n+  else\n+    {\n+      if (address_operand (operands[1], SImode))\n+\toperands[3] = operands[1];\n+      else\n+\t{\n+\t  rtx mem = XEXP (force_const_mem (SImode, operands[1]), 0);\n+\t  emit_move_insn (operands[3], mem);\n+\t}\n+    }\n+  if (TARGET_32BIT)\n+    {\n+      emit_insn (gen_arm_stack_protect_test_insn (operands[4], operands[0],\n+\t\t\t\t\t\t  operands[3]));\n+      rtx cc_reg = gen_rtx_REG (CC_Zmode, CC_REGNUM);\n+      eq = gen_rtx_EQ (CC_Zmode, cc_reg, const0_rtx);\n+      emit_jump_insn (gen_arm_cond_branch (operands[2], eq, cc_reg));\n+    }\n+  else\n+    {\n+      emit_insn (gen_thumb1_stack_protect_test_insn (operands[4], operands[0],\n+\t\t\t\t\t\t     operands[3]));\n+      eq = gen_rtx_EQ (VOIDmode, operands[4], const0_rtx);\n+      emit_jump_insn (gen_cbranchsi4 (eq, operands[4], const0_rtx,\n+\t\t\t\t      operands[2]));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"arch\" \"t1,32\")]\n+)\n+\n+(define_insn \"arm_stack_protect_test_insn\"\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z (unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m,m\")\n+\t\t\t\t  (mem:SI (match_operand:SI 2 \"register_operand\" \"+l,r\"))]\n+\t\t\t\t UNSPEC_SP_TEST)\n+\t\t      (const_int 0)))\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=&l,&r\"))\n+   (clobber (match_dup 2))]\n+  \"TARGET_32BIT\"\n+  \"ldr\\t%0, [%2]\\;ldr\\t%2, %1\\;eors\\t%0, %2, %0\"\n+  [(set_attr \"length\" \"8,12\")\n+   (set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"multiple\")\n+   (set_attr \"arch\" \"t,32\")]\n+)\n+\n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"s_register_operand\" \"\")\t; index to jump on\n    (match_operand:SI 1 \"const_int_operand\" \"\")\t; lower bound"}, {"sha": "69718ee9c7ac483532a43a54308e62e71984bfbc", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -31,6 +31,23 @@\n \t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n })\n \n+; Predicate for stack protector guard's address in\n+; stack_protect_combined_set_insn and stack_protect_combined_test_insn patterns\n+(define_predicate \"guard_addr_operand\"\n+  (match_test \"true\")\n+{\n+  return (CONSTANT_ADDRESS_P (op)\n+\t  || !targetm.cannot_force_const_mem (mode, op));\n+})\n+\n+; Predicate for stack protector guard in stack_protect_combined_set and\n+; stack_protect_combined_test patterns\n+(define_predicate \"guard_operand\"\n+  (match_code \"mem\")\n+{\n+  return guard_addr_operand (XEXP (op, 0), mode);\n+})\n+\n (define_predicate \"imm_for_neon_inv_logic_operand\"\n   (match_code \"const_vector\")\n {"}, {"sha": "cd199c9c52915ade6f56a9c795aac420010021aa", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -1962,4 +1962,17 @@\n   }\"\n   [(set_attr \"type\" \"mov_reg\")]\n )\n+\n+(define_insn \"thumb1_stack_protect_test_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&l\")\n+\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t    (mem:SI (match_operand:SI 2 \"register_operand\" \"+l\"))]\n+\t UNSPEC_SP_TEST))\n+   (clobber (match_dup 2))]\n+  \"TARGET_THUMB1\"\n+  \"ldr\\t%0, [%2]\\;ldr\\t%2, %1\\;eors\\t%0, %2, %0\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n \f"}, {"sha": "8f9dbcb08dc2547375e2d5195fe5dbb4098aa29a", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -86,6 +86,9 @@\n   UNSPEC_PROBE_STACK    ; Probe stack memory reference\n   UNSPEC_NONSECURE_MEM\t; Represent non-secure memory in ARMv8-M with\n \t\t\t; security extension\n+  UNSPEC_SP_SET\t\t; Represent the setting of stack protector's canary\n+  UNSPEC_SP_TEST\t; Represent the testing of stack protector's canary\n+\t\t\t; against the guard.\n ])\n \n (define_c_enum \"unspec\" ["}, {"sha": "895309b2f3c93a4f702f796787975dab9e2ef035", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -7450,22 +7450,61 @@ builtins.\n The get/set patterns have a single output/input operand respectively,\n with @var{mode} intended to be @code{Pmode}.\n \n+@cindex @code{stack_protect_combined_set} instruction pattern\n+@item @samp{stack_protect_combined_set}\n+This pattern, if defined, moves a @code{ptr_mode} value from an address\n+whose declaration RTX is given in operand 1 to the memory in operand 0\n+without leaving the value in a register afterward.  If several\n+instructions are needed by the target to perform the operation (eg. to\n+load the address from a GOT entry then load the @code{ptr_mode} value\n+and finally store it), it is the backend's responsibility to ensure no\n+intermediate result gets spilled.  This is to avoid leaking the value\n+some place that an attacker might use to rewrite the stack guard slot\n+after having clobbered it.\n+\n+If this pattern is not defined, then the address declaration is\n+expanded first in the standard way and a @code{stack_protect_set}\n+pattern is then generated to move the value from that address to the\n+address in operand 0.\n+\n @cindex @code{stack_protect_set} instruction pattern\n @item @samp{stack_protect_set}\n-This pattern, if defined, moves a @code{ptr_mode} value from the memory\n-in operand 1 to the memory in operand 0 without leaving the value in\n-a register afterward.  This is to avoid leaking the value some place\n-that an attacker might use to rewrite the stack guard slot after\n-having clobbered it.\n+This pattern, if defined, moves a @code{ptr_mode} value from the valid\n+memory location in operand 1 to the memory in operand 0 without leaving\n+the value in a register afterward.  This is to avoid leaking the value\n+some place that an attacker might use to rewrite the stack guard slot\n+after having clobbered it.\n+\n+Note: on targets where the addressing modes do not allow to load\n+directly from stack guard address, the address is expanded in a standard\n+way first which could cause some spills.\n \n If this pattern is not defined, then a plain move pattern is generated.\n \n+@cindex @code{stack_protect_combined_test} instruction pattern\n+@item @samp{stack_protect_combined_test}\n+This pattern, if defined, compares a @code{ptr_mode} value from an\n+address whose declaration RTX is given in operand 1 with the memory in\n+operand 0 without leaving the value in a register afterward and\n+branches to operand 2 if the values were equal.  If several\n+instructions are needed by the target to perform the operation (eg. to\n+load the address from a GOT entry then load the @code{ptr_mode} value\n+and finally store it), it is the backend's responsibility to ensure no\n+intermediate result gets spilled.  This is to avoid leaking the value\n+some place that an attacker might use to rewrite the stack guard slot\n+after having clobbered it.\n+\n+If this pattern is not defined, then the address declaration is\n+expanded first in the standard way and a @code{stack_protect_test}\n+pattern is then generated to compare the value from that address to the\n+value at the memory in operand 0.\n+\n @cindex @code{stack_protect_test} instruction pattern\n @item @samp{stack_protect_test}\n This pattern, if defined, compares a @code{ptr_mode} value from the\n-memory in operand 1 with the memory in operand 0 without leaving the\n-value in a register afterward and branches to operand 2 if the values\n-were equal.\n+valid memory location in operand 1 with the memory in operand 0 without\n+leaving the value in a register afterward and branches to operand 2 if\n+the values were equal.\n \n If this pattern is not defined, then a plain compare pattern and\n conditional branch pattern is used."}, {"sha": "69523c1d72309b7ba0e7a0e6ccfadcd3974dac75", "filename": "gcc/function.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -4937,18 +4937,34 @@ stack_protect_epilogue (void)\n   tree guard_decl = targetm.stack_protect_guard ();\n   rtx_code_label *label = gen_label_rtx ();\n   rtx x, y;\n-  rtx_insn *seq;\n+  rtx_insn *seq = NULL;\n \n   x = expand_normal (crtl->stack_protect_guard);\n-  if (guard_decl)\n-    y = expand_normal (guard_decl);\n+\n+  if (targetm.have_stack_protect_combined_test () && guard_decl)\n+    {\n+      gcc_assert (DECL_P (guard_decl));\n+      y = DECL_RTL (guard_decl);\n+      /* Allow the target to compute address of Y and compare it with X without\n+\t leaking Y into a register.  This combined address + compare pattern\n+\t allows the target to prevent spilling of any intermediate results by\n+\t splitting it after register allocator.  */\n+      seq = targetm.gen_stack_protect_combined_test (x, y, label);\n+    }\n   else\n-    y = const0_rtx;\n+    {\n+      if (guard_decl)\n+\ty = expand_normal (guard_decl);\n+      else\n+\ty = const0_rtx;\n+\n+      /* Allow the target to compare Y with X without leaking either into\n+\t a register.  */\n+      if (targetm.have_stack_protect_test ())\n+\tseq = targetm.gen_stack_protect_test (x, y, label);\n+    }\n \n-  /* Allow the target to compare Y with X without leaking either into\n-     a register.  */\n-  if (targetm.have_stack_protect_test ()\n-      && ((seq = targetm.gen_stack_protect_test (x, y, label)) != NULL_RTX))\n+  if (seq)\n     emit_insn (seq);\n   else\n     emit_cmp_and_jump_insns (x, y, EQ, NULL_RTX, ptr_mode, 1, label);"}, {"sha": "d39889b35229f6dba6bc2f6161abecba9c0448cb", "filename": "gcc/target-insns.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -96,7 +96,9 @@ DEF_TARGET_INSN (sibcall_value, (rtx x0, rtx x1, rtx opt2, rtx opt3,\n DEF_TARGET_INSN (simple_return, (void))\n DEF_TARGET_INSN (split_stack_prologue, (void))\n DEF_TARGET_INSN (split_stack_space_check, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (stack_protect_combined_set, (rtx x0, rtx x1))\n DEF_TARGET_INSN (stack_protect_set, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (stack_protect_combined_test, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (stack_protect_test, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (store_multiple, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (tablejump, (rtx x0, rtx x1))"}, {"sha": "c7eebe6c344a11f55b634fd0025055ca3c22228d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -1,3 +1,7 @@\n+2018-11-22  Thomas Preud'homme  <thomas.preudhomme@linaro.org>\n+\n+\t* gcc.target/arm/pr85434.c: New test.\n+\n 2018-11-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/88148"}, {"sha": "4143a861f7caffc2af5a57518674297dd4e9e1b6", "filename": "gcc/testsuite/gcc.target/arm/pr85434.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr85434.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7557202d25a393666ac4c0f7dbdab31e452a2/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr85434.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr85434.c?ref=89d7557202d25a393666ac4c0f7dbdab31e452a2", "patch": "@@ -0,0 +1,200 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target fstack_protector }*/\n+/* { dg-require-effective-target fpic }*/\n+/* { dg-additional-options \"-Os -fpic -fstack-protector-strong\" } */\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+\n+static const unsigned char base64_enc_map[64] =\n+{\n+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n+    'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n+    'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\n+    'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n+    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\n+    'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',\n+    '8', '9', '+', '/'\n+};\n+\n+#define BASE64_SIZE_T_MAX   ( (size_t) -1 ) /* SIZE_T_MAX is not standard */\n+\n+\n+void doSmth(void *x);\n+\n+#include <string.h>\n+\n+\n+void check(int n) {\n+  \n+    if (!(n % 2 && n % 3 && n % 5)) {\n+ __asm__  (   \"add    r8, r8, #1;\" );\n+    }\n+}\n+\n+uint32_t test(\n+  uint32_t a1,\n+  uint32_t a2,\n+  size_t a3,\n+  size_t a4,\n+  size_t a5,\n+  size_t a6)\n+{\n+  uint32_t nResult = 0;\n+  uint8_t* h = 0L;\n+  uint8_t X[128];\n+  uint8_t mac[64];\n+  size_t len;\n+\n+  doSmth(&a1);\n+  doSmth(&a2);\n+  doSmth(&a3);\n+  doSmth(&a4);\n+  doSmth(&a5);\n+  doSmth(&a6);\n+\n+  if (a1 && a2 && a3 && a4 && a5 && a6) {\n+    nResult = 1;\n+    h = (void*)X;\n+    len = sizeof(X);\n+    memset(X, a2, len);\n+    len -= 64;\n+    memcpy(mac ,X, len);\n+    *(h + len) = a6;\n+\n+    {\n+\n+\n+        unsigned char *dst = X;\n+        size_t dlen = a3;\n+        size_t *olen = &a6;\n+        const unsigned char *src = mac;\n+        size_t slen = a4;\n+    size_t i, n;\n+    int C1, C2, C3;\n+    unsigned char *p;\n+\n+    if( slen == 0 )\n+    {\n+        *olen = 0;\n+        return( 0 );\n+    }\n+\n+    n = slen / 3 + ( slen % 3 != 0 );\n+\n+    if( n > ( BASE64_SIZE_T_MAX - 1 ) / 4 )\n+    {\n+        *olen = BASE64_SIZE_T_MAX;\n+        return( 0 );\n+    }\n+\n+    n *= 4;\n+\n+    if( ( dlen < n + 1 ) || ( NULL == dst ) )\n+    {\n+        *olen = n + 1;\n+        return( 0 );\n+    }\n+\n+    n = ( slen / 3 ) * 3;\n+\n+    for( i = 0, p = dst; i < n; i += 3 )\n+    {\n+        C1 = *src++;\n+        C2 = *src++;\n+        C3 = *src++;\n+\n+        check(i);\n+\n+        *p++ = base64_enc_map[(C1 >> 2) & 0x3F];\n+        *p++ = base64_enc_map[(((C1 &  3) << 4) + (C2 >> 4)) & 0x3F];\n+        *p++ = base64_enc_map[(((C2 & 15) << 2) + (C3 >> 6)) & 0x3F];\n+        *p++ = base64_enc_map[C3 & 0x3F];\n+    }\n+\n+    if( i < slen )\n+    {\n+        C1 = *src++;\n+        C2 = ( ( i + 1 ) < slen ) ? *src++ : 0;\n+\n+        *p++ = base64_enc_map[(C1 >> 2) & 0x3F];\n+        *p++ = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];\n+\n+        if( ( i + 1 ) < slen )\n+             *p++ = base64_enc_map[((C2 & 15) << 2) & 0x3F];\n+        else *p++ = '=';\n+\n+        *p++ = '=';\n+    }\n+\n+    *olen = p - dst;\n+    *p = 0;\n+\n+}\n+\n+  __asm__ (\"mov r8, %0;\" : \"=r\" ( nResult ));\n+  }\n+  else\n+  {\n+    nResult = 2;\n+  }\n+\n+  doSmth(X);\n+  doSmth(mac);\n+\n+\n+  return nResult;\n+}\n+\n+/* The pattern below catches sequences of instructions that were generated\n+   for ARM and Thumb-2 before the fix for this PR. They are of the form:\n+\n+   ldr     rX, <offset from sp or fp>\n+   <optional non ldr instructions>\n+   ldr     rY, <offset from sp or fp>\n+   ldr     rZ, [rX]\n+   <optional non ldr instructions>\n+   cmp     rY, rZ\n+   <optional non cmp instructions>\n+   bl      __stack_chk_fail\n+\n+   Ideally the optional block would check for the various rX, rY and rZ\n+   registers not being set but this is not possible due to back references\n+   being illegal in lookahead expression in Tcl, thus preventing to use the\n+   only construct that allow to negate a regexp from using the backreferences\n+   to those registers.  Instead we go for the heuristic of allowing non ldr/cmp\n+   instructions with the assumptions that (i) those are not part of the stack\n+   protector sequences and (ii) they would only be scheduled here if they don't\n+   conflict with registers used by stack protector.\n+\n+   Note on the regexp logic:\n+   Allowing non X instructions (where X is ldr or cmp) is done by looking for\n+   some non newline spaces, followed by something which is not X, followed by\n+   an alphanumeric character followed by anything but a newline and ended by a\n+   newline the whole thing an undetermined number of times. The alphanumeric\n+   character is there to force the match of the negative lookahead for X to\n+   only happen after all the initial spaces and thus to check the mnemonic.\n+   This prevents it to match one of the initial space.  */\n+/* { dg-final { scan-assembler-not {ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\]\\n[ \\t]+ldr[ \\t]+([^,]+), \\[\\1\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+cmp[ \\t]+\\2, \\3(?:\\n[ \\t]+(?!cmp)\\w[^\\n]*)*\\n[ \\t]+bl[ \\t]+__stack_chk_fail} } } */\n+\n+/* Likewise for Thumb-1 sequences of instructions prior to the fix for this PR\n+   which had the form:\n+\n+   ldr     rS, <offset from sp or fp>\n+   <optional non ldr instructions>\n+   ldr     rT, <PC relative offset>\n+   <optional non ldr instructions>\n+   ldr     rX, [rS, rT]\n+   <optional non ldr instructions>\n+   ldr     rY, <offset from sp or fp>\n+   ldr     rZ, [rX]\n+   <optional non ldr instructions>\n+   cmp     rY, rZ\n+   <optional non cmp instructions>\n+   bl      __stack_chk_fail\n+\n+  Note on the regexp logic:\n+  PC relative offset is checked by looking for a source operand that does not\n+  contain [ or ].  */\n+/* { dg-final { scan-assembler-not {ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), [^][\\n]*(?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), \\[\\1, \\2\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\]\\n[ \\t]+ldr[ \\t]+([^,]+), \\[\\3\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+cmp[ \\t]+\\4, \\5(?:\\n[ \\t]+(?!cmp)\\w[^\\n]*)*\\n[ \\t]+bl[ \\t]+__stack_chk_fail} } } */"}]}