{"sha": "70f7276781bbc54ed541c6368e3e1e245a39d348", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBmNzI3Njc4MWJiYzU0ZWQ1NDFjNjM2OGUzZTFlMjQ1YTM5ZDM0OA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-06-30T20:04:37Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-06-30T20:04:37Z"}, "message": "Initial revision\n\nFrom-SVN: r27855", "tree": {"sha": "b53cc86b5ff2c8e092ad302d6f89dcdf6dcc1189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b53cc86b5ff2c8e092ad302d6f89dcdf6dcc1189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70f7276781bbc54ed541c6368e3e1e245a39d348", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f7276781bbc54ed541c6368e3e1e245a39d348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f7276781bbc54ed541c6368e3e1e245a39d348", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f7276781bbc54ed541c6368e3e1e245a39d348/comments", "author": null, "committer": null, "parents": [{"sha": "56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96"}], "stats": {"total": 2619, "additions": 2619, "deletions": 0}, "files": [{"sha": "b1a9dc3613a265de71ac1785d0745602156b708c", "filename": "boehm-gc/gcconfig.h", "status": "added", "additions": 1061, "deletions": 0, "changes": 1061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcconfig.h?ref=70f7276781bbc54ed541c6368e3e1e245a39d348", "patch": "@@ -0,0 +1,1061 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+ \n+#ifndef CONFIG_H\n+\n+# define CONFIG_H\n+\n+/* Machine dependent parameters.  Some tuning parameters can be found\t*/\n+/* near the top of gc_private.h.\t\t\t\t\t*/\n+\n+/* Machine specific parts contributed by various people.  See README file. */\n+\n+/* First a unified test for Linux: */\n+# if defined(linux) || defined(__linux__)\n+#    define LINUX\n+# endif\n+\n+/* Determine the machine type: */\n+# if defined(sun) && defined(mc68000)\n+#    define M68K\n+#    define SUNOS4\n+#    define mach_type_known\n+# endif\n+# if defined(hp9000s300)\n+#    define M68K\n+#    define HP\n+#    define mach_type_known\n+# endif\n+# if defined(__OpenBSD__) && defined(m68k)\n+#    define M68K\n+#    define OPENBSD\n+#    define mach_type_known\n+# endif\n+# if defined(__NetBSD__) && defined(m68k)\n+#    define M68K\n+#    define NETBSD\n+#    define mach_type_known\n+# endif\n+# if defined(vax)\n+#    define VAX\n+#    ifdef ultrix\n+#\tdefine ULTRIX\n+#    else\n+#\tdefine BSD\n+#    endif\n+#    define mach_type_known\n+# endif\n+# if defined(mips) || defined(__mips)\n+#    define MIPS\n+#    if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n+#\tdefine ULTRIX\n+#    else\n+#\tif defined(_SYSTYPE_SVR4) || defined(SYSTYPE_SVR4) || defined(__SYSTYPE_SVR4__)\n+#\t  define IRIX5   /* or IRIX 6.X */\n+#\telse\n+#\t  define RISCOS  /* or IRIX 4.X */\n+#\tendif\n+#    endif\n+#    define mach_type_known\n+# endif\n+# if defined(sequent) && defined(i386)\n+#    define I386\n+#    define SEQUENT\n+#    define mach_type_known\n+# endif\n+# if defined(sun) && defined(i386)\n+#    define I386\n+#    define SUNOS5\n+#    define mach_type_known\n+# endif\n+# if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)\n+#    define I386\n+#    define OS2\n+#    define mach_type_known\n+# endif\n+# if defined(ibm032)\n+#   define RT\n+#   define mach_type_known\n+# endif\n+# if defined(sun) && (defined(sparc) || defined(__sparc))\n+#   define SPARC\n+    /* Test for SunOS 5.x */\n+#     include <errno.h>\n+#     ifdef ECHRNG\n+#       define SUNOS5\n+#     else\n+#\tdefine SUNOS4\n+#     endif\n+#   define mach_type_known\n+# endif\n+# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux)\n+#   define SPARC\n+#   define DRSNX\n+#   define mach_type_known\n+# endif\n+# if defined(_IBMR2)\n+#   define RS6000\n+#   define mach_type_known\n+# endif\n+# if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)\n+\t/* The above test may need refinement\t*/\n+#   define I386\n+#   if defined(_SCO_ELF)\n+#     define SCO_ELF\n+#   else\n+#     define SCO\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(_AUX_SOURCE)\n+#   define M68K\n+#   define SYSV\n+#   define mach_type_known\n+# endif\n+# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) \\\n+     || defined(hppa) || defined(__hppa__)\n+#   define HP_PA\n+#   define mach_type_known\n+# endif\n+# if defined(LINUX) && defined(i386)\n+#    define I386\n+#    define mach_type_known\n+# endif\n+# if defined(LINUX) && defined(powerpc)\n+#    define POWERPC\n+#    define mach_type_known\n+# endif\n+# if defined(LINUX) && defined(__mc68000__)\n+#    define M68K\n+#    define mach_type_known\n+# endif\n+# if defined(linux) && defined(sparc)\n+#    define SPARC\n+#    define LINUX\n+#    define mach_type_known\n+# endif\n+# if defined(__alpha) || defined(__alpha__)\n+#   define ALPHA\n+#   if !defined(LINUX)\n+#     define OSF1\t/* a.k.a Digital Unix */\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(_AMIGA)\n+#   define M68K\n+#   define AMIGA\n+#   define mach_type_known\n+# endif\n+# if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)\n+#   define M68K\n+#   define MACOS\n+#   define mach_type_known\n+# endif\n+# if defined(__MWERKS__) && defined(__powerc)\n+#   define POWERPC\n+#   define MACOS\n+#   define mach_type_known\n+# endif\n+# if defined(NeXT) && defined(mc68000)\n+#   define M68K\n+#   define NEXT\n+#   define mach_type_known\n+# endif\n+# if defined(NeXT) && defined(i386)\n+#   define I386\n+#   define NEXT\n+#   define mach_type_known\n+# endif\n+# if defined(__OpenBSD__) && defined(i386)\n+#   define I386\n+#   define OPENBSD\n+#   define mach_type_known\n+# endif\n+# if defined(__FreeBSD__) && defined(i386)\n+#   define I386\n+#   define FREEBSD\n+#   define mach_type_known\n+# endif\n+# if defined(__NetBSD__) && defined(i386)\n+#   define I386\n+#   define NETBSD\n+#   define mach_type_known\n+# endif\n+# if defined(bsdi) && defined(i386)\n+#    define I386\n+#    define BSDI\n+#    define mach_type_known\n+# endif\n+# if !defined(mach_type_known) && defined(__386BSD__)\n+#   define I386\n+#   define THREE86BSD\n+#   define mach_type_known\n+# endif\n+# if defined(_CX_UX) && defined(_M88K)\n+#   define M88K\n+#   define CX_UX\n+#   define mach_type_known\n+# endif\n+# if defined(DGUX)\n+#   define M88K\n+    /* DGUX defined */\n+#   define mach_type_known\n+# endif\n+# if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n+     || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)\n+#   define I386\n+#   define MSWIN32\t/* or Win32s */\n+#   define mach_type_known\n+# endif\n+# if defined(__DJGPP__)\n+#   define I386\n+#   ifndef DJGPP\n+#     define DJGPP  /* MSDOS running the DJGPP port of GCC */\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(__CYGWIN32__) || defined(__CYGWIN__)\n+#   define I386\n+#   define CYGWIN32\n+#   define mach_type_known\n+# endif\n+# if defined(__BORLANDC__)\n+#   define I386\n+#   define MSWIN32\n+#   define mach_type_known\n+# endif\n+# if defined(_UTS) && !defined(mach_type_known)\n+#   define S370\n+#   define UTS4\n+#   define mach_type_known\n+# endif\n+/* Ivan Demakov */\n+# if defined(__WATCOMC__) && defined(__386__)\n+#   define I386\n+#   if !defined(OS2) && !defined(MSWIN32) && !defined(DOS4GW)\n+#     if defined(__OS2__)\n+#       define OS2\n+#     else\n+#       if defined(__WINDOWS_386__) || defined(__NT__)\n+#         define MSWIN32\n+#       else\n+#         define DOS4GW\n+#       endif\n+#     endif\n+#   endif\n+#   define mach_type_known\n+# endif\n+\n+/* Feel free to add more clauses here */\n+\n+/* Or manually define the machine type here.  A machine type is \t*/\n+/* characterized by the architecture.  Some\t\t\t\t*/\n+/* machine types are further subdivided by OS.\t\t\t\t*/\n+/* the macros ULTRIX, RISCOS, and BSD to distinguish.\t\t\t*/\n+/* Note that SGI IRIX is treated identically to RISCOS.\t\t\t*/\n+/* SYSV on an M68K actually means A/UX.\t\t\t\t\t*/\n+/* The distinction in these cases is usually the stack starting address */\n+# ifndef mach_type_known\n+\t--> unknown machine type\n+# endif\n+\t\t    /* Mapping is: M68K       ==> Motorola 680X0\t*/\n+\t\t    /*\t\t   (SUNOS4,HP,NEXT, and SYSV (A/UX),\t*/\n+\t\t    /*\t\t   MACOS and AMIGA variants)\t\t*/\n+\t\t    /*             I386       ==> Intel 386\t \t*/\n+\t\t    /*\t\t    (SEQUENT, OS2, SCO, LINUX, NETBSD,\t*/\n+\t\t    /*\t\t     FREEBSD, THREE86BSD, MSWIN32,\t*/\n+\t\t    /* \t\t     BSDI,SUNOS5, NEXT, other variants)\t*/\n+                    /*             NS32K      ==> Encore Multimax \t*/\n+                    /*             MIPS       ==> R2000 or R3000\t*/\n+                    /*\t\t\t(RISCOS, ULTRIX variants)\t*/\n+                    /*\t\t   VAX\t      ==> DEC VAX\t\t*/\n+                    /*\t\t\t(BSD, ULTRIX variants)\t\t*/\n+                    /*\t\t   RS6000     ==> IBM RS/6000 AIX3.X\t*/\n+                    /*\t\t   RT\t      ==> IBM PC/RT\t\t*/\n+                    /*\t\t   HP_PA      ==> HP9000/700 & /800\t*/\n+                    /*\t\t\t\t  HP/UX\t\t\t*/\n+\t\t    /*\t\t   SPARC      ==> SPARC under SunOS\t*/\n+\t\t    /*\t\t\t(SUNOS4, SUNOS5,\t\t*/\n+\t\t    /*\t\t\t DRSNX variants)\t\t*/\n+\t\t    /* \t\t   ALPHA      ==> DEC Alpha \t\t*/\n+\t\t    /*\t\t\t(OSF1 and LINUX variants)\t*/\n+\t\t    /* \t\t   M88K       ==> Motorola 88XX0        */\n+\t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n+\t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n+\t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n+\n+\n+/*\n+ * For each architecture and OS, the following need to be defined:\n+ *\n+ * CPP_WORD_SZ is a simple integer constant representing the word size.\n+ * in bits.  We assume byte addressibility, where a byte has 8 bits.\n+ * We also assume CPP_WORD_SZ is either 32 or 64.\n+ * (We care about the length of pointers, not hardware\n+ * bus widths.  Thus a 64 bit processor with a C compiler that uses\n+ * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)\n+ *\n+ * MACH_TYPE is a string representation of the machine type.\n+ * OS_TYPE is analogous for the OS.\n+ *\n+ * ALIGNMENT is the largest N, such that\n+ * all pointer are guaranteed to be aligned on N byte boundaries.\n+ * defining it to be 1 will always work, but perform poorly.\n+ *\n+ * DATASTART is the beginning of the data segment.\n+ * On UNIX systems, the collector will scan the area between DATASTART\n+ * and DATAEND for root pointers.\n+ *\n+ * DATAEND, if not &end.\n+ *\n+ * ALIGN_DOUBLE of GC_malloc should return blocks aligned to twice\n+ * the pointer size.\n+ *\n+ * STACKBOTTOM is the cool end of the stack, which is usually the\n+ * highest address in the stack.\n+ * Under PCR or OS/2, we have other ways of finding thread stacks.\n+ * For each machine, the following should:\n+ * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and\n+ * 2) define exactly one of\n+ *\tSTACKBOTTOM (should be defined to be an expression)\n+ *\tHEURISTIC1\n+ *\tHEURISTIC2\n+ * If either of the last two macros are defined, then STACKBOTTOM is computed\n+ * during collector startup using one of the following two heuristics:\n+ * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to\n+ *\t\tthe next multiple of STACK_GRAN.\n+ * HEURISTIC2:  Take an address inside GC_init's frame, increment it repeatedly\n+ *\t\tin small steps (decrement if STACK_GROWS_UP), and read the value\n+ *\t\tat each location.  Remember the value when the first\n+ *\t\tSegmentation violation or Bus error is signalled.  Round that\n+ *\t\tto the nearest plausible page boundary, and use that instead\n+ *\t\tof STACKBOTTOM.\n+ *\n+ * If no expression for STACKBOTTOM can be found, and neither of the above\n+ * heuristics are usable, the collector can still be used with all of the above\n+ * undefined, provided one of the following is done:\n+ * 1) GC_mark_roots can be changed to somehow mark from the correct stack(s)\n+ *    without reference to STACKBOTTOM.  This is appropriate for use in\n+ *    conjunction with thread packages, since there will be multiple stacks.\n+ *    (Allocating thread stacks in the heap, and treating them as ordinary\n+ *    heap data objects is also possible as a last resort.  However, this is\n+ *    likely to introduce significant amounts of excess storage retention\n+ *    unless the dead parts of the thread stacks are periodically cleared.)\n+ * 2) Client code may set GC_stackbottom before calling any GC_ routines.\n+ *    If the author of the client code controls the main program, this is\n+ *    easily accomplished by introducing a new main program, setting\n+ *    GC_stackbottom to the address of a local variable, and then calling\n+ *    the original main program.  The new main program would read something\n+ *    like:\n+ *\n+ *\t\t# include \"gc_private.h\"\n+ *\n+ *\t\tmain(argc, argv, envp)\n+ *\t\tint argc;\n+ *\t\tchar **argv, **envp;\n+ *\t\t{\n+ *\t\t    int dummy;\n+ *\n+ *\t\t    GC_stackbottom = (ptr_t)(&dummy);\n+ *\t\t    return(real_main(argc, argv, envp));\n+ *\t\t}\n+ *\n+ *\n+ * Each architecture may also define the style of virtual dirty bit\n+ * implementation to be used:\n+ *   MPROTECT_VDB: Write protect the heap and catch faults.\n+ *   PROC_VDB: Use the SVR4 /proc primitives to read dirty bits.\n+ *\n+ * An architecture may define DYNAMIC_LOADING if dynamic_load.c\n+ * defined GC_register_dynamic_libraries() for the architecture.\n+ */\n+\n+\n+# define STACK_GRAN 0x1000000\n+# ifdef M68K\n+#   define MACH_TYPE \"M68K\"\n+#   define ALIGNMENT 2\n+#   ifdef OPENBSD\n+#\tdefine OS_TYPE \"OPENBSD\"\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define STACKBOTTOM ((ptr_t)0xf0000000)\n+#       define MPROTECT_VDB\n+#       ifdef __ELF__\n+#            define DYNAMIC_LOADING\n+             extern char **__environ;\n+#            define DATASTART ((ptr_t)(&__environ))\n+                             /* hideous kludge: __environ is the first */\n+                             /* word in crt0.o, and delimits the start */\n+                             /* of the data segment, no matter which   */\n+                             /* ld options were passed through.        */\n+                             /* We could use _etext instead, but that  */\n+                             /* would include .rodata, which may       */\n+                             /* contain large read-only data tables    */\n+                             /* that we'd rather not scan.             */\n+             extern int _end;\n+#            define DATAEND (&_end)\n+#       else\n+             extern int etext;\n+#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       endif\n+#   endif\n+#   ifdef SUNOS4\n+#\tdefine OS_TYPE \"SUNOS4\"\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x1ffff) & ~0x1ffff))\n+#\tdefine HEURISTIC1\t/* differs\t*/\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef HP\n+#\tdefine OS_TYPE \"HP\"\n+\textern char etext;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       define STACKBOTTOM ((ptr_t) 0xffeffffc)\n+\t\t\t      /* empirically determined.  seems to work. */\n+#  \tinclude <unistd.h>\n+#\tdefine GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+#   endif\n+#   ifdef SYSV\n+#\tdefine OS_TYPE \"SYSV\"\n+\textern etext;\n+#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\t\t\t\t   & ~0x3fffff) \\\n+\t\t\t\t  +((word)&etext & 0x1fff))\n+\t/* This only works for shared-text binaries with magic number 0413.\n+\t   The other sorts of SysV binaries put the data at the end of the text,\n+\t   in which case the default of &etext would work.  Unfortunately,\n+\t   handling both would require having the magic-number available.\n+\t   \t   \t\t-- Parag\n+\t   */\n+#\tdefine STACKBOTTOM ((ptr_t)0xFFFFFFFE)\n+\t\t\t/* The stack starts at the top of memory, but   */\n+\t\t\t/* 0x0 cannot be used as setjump_test complains */\n+\t\t\t/* that the stack direction is incorrect.  Two  */\n+\t\t\t/* bytes down from 0x0 should be safe enough.   */\n+\t\t\t/* \t\t--Parag\t\t\t\t*/\n+#   \tinclude <sys/mmu.h>\n+#\tdefine GETPAGESIZE() PAGESIZE\t/* Is this still right? */\n+#   endif\n+#   ifdef AMIGA\n+#\tdefine OS_TYPE \"AMIGA\"\n+ \t    \t/* STACKBOTTOM and DATASTART handled specially\t*/\n+ \t    \t/* in os_dep.c\t\t\t\t\t*/\n+# \tdefine DATAEND\t/* not needed */\n+#\tdefine GETPAGESIZE() 4096\n+#   endif\n+#   ifdef MACOS\n+#     ifndef __LOWMEM__\n+#     include <LowMem.h>\n+#     endif\n+#     define OS_TYPE \"MACOS\"\n+\t\t\t/* see os_dep.c for details of global data segments. */\n+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n+#     define DATAEND\t/* not needed */\n+#     define GETPAGESIZE() 4096\n+#   endif\n+#   ifdef NEXT\n+#\tdefine OS_TYPE \"NEXT\"\n+#\tdefine DATASTART ((ptr_t) get_etext())\n+#\tdefine STACKBOTTOM ((ptr_t) 0x4000000)\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+# endif\n+\n+# ifdef POWERPC\n+#   define MACH_TYPE \"POWERPC\"\n+#   define ALIGNMENT 2\n+#   ifdef MACOS\n+#     ifndef __LOWMEM__\n+#     include <LowMem.h>\n+#     endif\n+#     define OS_TYPE \"MACOS\"\n+\t\t\t/* see os_dep.c for details of global data segments. */\n+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n+#     define DATAEND  /* not needed */\n+#   endif\n+#   ifdef LINUX\n+#     define OS_TYPE \"LINUX\"\n+#     define HEURISTIC1\n+#     undef STACK_GRAN\n+#     define STACK_GRAN 0x10000000\n+#     define DATASTART GC_data_start\n+      extern int _end;\n+#     define DATAEND (&_end)\n+#   endif\n+# endif\n+\n+# ifdef VAX\n+#   define MACH_TYPE \"VAX\"\n+#   define ALIGNMENT 4\t/* Pointers are longword aligned by 4.2 C compiler */\n+    extern char etext;\n+#   define DATASTART ((ptr_t)(&etext))\n+#   ifdef BSD\n+#\tdefine OS_TYPE \"BSD\"\n+#\tdefine HEURISTIC1\n+\t\t\t/* HEURISTIC2 may be OK, but it's hard to test. */\n+#   endif\n+#   ifdef ULTRIX\n+#\tdefine OS_TYPE \"ULTRIX\"\n+#\tdefine STACKBOTTOM ((ptr_t) 0x7fffc800)\n+#   endif\n+# endif\n+\n+# ifdef RT\n+#   define MACH_TYPE \"RT\"\n+#   define ALIGNMENT 4\n+#   define DATASTART ((ptr_t) 0x10000000)\n+#   define STACKBOTTOM ((ptr_t) 0x1fffd800)\n+# endif\n+\n+# ifdef SPARC\n+#   define MACH_TYPE \"SPARC\"\n+#   define ALIGNMENT 4\t/* Required by hardware\t*/\n+#   define ALIGN_DOUBLE\n+    extern int etext;\n+#   ifdef SUNOS5\n+#\tdefine OS_TYPE \"SUNOS5\"\n+\textern int _etext;\n+\textern int _end;\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#\tdefine DATAEND (&_end)\n+#\tifndef USE_MMAP\n+#\t    define USE_MMAP\n+#\tendif\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x40000000\n+#       else\n+#\t  define HEAP_START DATAEND\n+#       endif\n+#\tdefine PROC_VDB\n+/*\tHEURISTIC1 reportedly no longer works under 2.7.  Thus we\t*/\n+/* \tswitched to HEURISTIC2, eventhough it creates some debugging\t*/\n+/*\tissues.\t\t\t\t\t\t\t\t*/\n+#\tdefine HEURISTIC2\n+#\tinclude <unistd.h>\n+#       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n+\t\t/* getpagesize() appeared to be missing from at least one */\n+\t\t/* Solaris 5.4 installation.  Weird.\t\t\t  */\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef SUNOS4\n+#\tdefine OS_TYPE \"SUNOS4\"\n+\t/* [If you have a weak stomach, don't read this.]\t\t*/\n+\t/* We would like to use:\t\t\t\t\t*/\n+/* #       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1fff) & ~0x1fff)) */\n+\t/* This fails occasionally, due to an ancient, but very \t*/\n+\t/* persistent ld bug.  &etext is set 32 bytes too high.\t\t*/\n+\t/* We instead read the text segment size from the a.out\t\t*/\n+\t/* header, which happens to be mapped into our address space\t*/\n+\t/* at the start of the text segment.  The detective work here\t*/\n+\t/* was done by Robert Ehrlich, Manuel Serrano, and Bernard\t*/\n+\t/* Serpette of INRIA.\t\t\t\t\t\t*/\n+\t/* This assumes ZMAGIC, i.e. demand-loadable executables.\t*/\n+#\tdefine TEXTSTART 0x2000\n+#       define DATASTART ((ptr_t)(*(int *)(TEXTSTART+0x4)+TEXTSTART))\n+#\tdefine MPROTECT_VDB\n+#\tdefine HEURISTIC1\n+# \tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef DRSNX\n+#       define CPP_WORDSZ 32\n+#\tdefine OS_TYPE \"DRSNX\"\n+\textern char * GC_SysVGetDataStart();\n+\textern int etext;\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+#\tdefine MPROTECT_VDB\n+#       define STACKBOTTOM ((ptr_t) 0xdfff0000)\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef LINUX\n+#     define OS_TYPE \"LINUX\"\n+#     ifdef __ELF__\n+#         define DATASTART GC_data_start\n+#         define DYNAMIC_LOADING\n+#     else\n+          Linux Sparc non elf ?\n+#     endif\n+      extern int _end;\n+#     define DATAEND (&_end)\n+#     define SVR4\n+#     define STACKBOTTOM ((ptr_t) 0xf0000000)\n+#   endif\n+# endif\n+\n+# ifdef I386\n+#   define MACH_TYPE \"I386\"\n+#   define ALIGNMENT 4\t/* Appears to hold for all \"32 bit\" compilers\t*/\n+\t\t\t/* except Borland.  The -a4 option fixes \t*/\n+\t\t\t/* Borland.\t\t\t\t\t*/\n+                        /* Ivan Demakov: For Watcom the option is -zp4. */\n+#   ifndef SMALL_CONFIG\n+#     define ALIGN_DOUBLE /* Not strictly necessary, but may give speed   */\n+\t\t\t  /* improvement on Pentiums.\t\t\t  */\n+#   endif\n+#   ifdef SEQUENT\n+#\tdefine OS_TYPE \"SEQUENT\"\n+\textern int etext;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       define STACKBOTTOM ((ptr_t) 0x3ffff000) \n+#   endif\n+#   ifdef SUNOS5\n+#\tdefine OS_TYPE \"SUNOS5\"\n+  \textern int etext, _start;\n+  \textern char * GC_SysVGetDataStart();\n+#       define DATASTART GC_SysVGetDataStart(0x1000, &etext)\n+#\tdefine STACKBOTTOM ((ptr_t)(&_start))\n+/** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n+/*#\tdefine PROC_VDB*/\n+#\tdefine DYNAMIC_LOADING\n+#\tifndef USE_MMAP\n+#\t    define USE_MMAP\n+#\tendif\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x40000000\n+#       else\n+#\t  define HEAP_START DATAEND\n+#       endif\n+#   endif\n+#   ifdef SCO\n+#\tdefine OS_TYPE \"SCO\"\n+\textern int etext;\n+#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\t\t\t\t  & ~0x3fffff) \\\n+\t\t\t\t +((word)&etext & 0xfff))\n+#\tdefine STACKBOTTOM ((ptr_t) 0x7ffffffc)\n+#   endif\n+#   ifdef SCO_ELF\n+#       define OS_TYPE \"SCO_ELF\"\n+        extern int etext;\n+#       define DATASTART ((ptr_t)(&etext))\n+#       define STACKBOTTOM ((ptr_t) 0x08048000)\n+#       define DYNAMIC_LOADING\n+#\tdefine ELF_CLASS ELFCLASS32\n+#   endif\n+#   ifdef LINUX\n+#\tdefine OS_TYPE \"LINUX\"\n+#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n+\t/* Appears to be 0xe0000000 for at least one 2.1.91 kernel.\t*/\n+\t/* Probably needs to be more flexible, but I don't yet \t\t*/\n+\t/* fully understand how flexible.\t\t\t\t*/\n+#       if !defined(LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n+#\t    define MPROTECT_VDB\n+#\telse\n+\t    /* We seem to get random errors in incremental mode,\t*/\n+\t    /* possibly because Linux threads is itself a malloc client */\n+\t    /* and can't deal with the signals.\t\t\t\t*/\n+#\tendif\n+#       ifdef __ELF__\n+#            define DYNAMIC_LOADING\n+#\t     ifdef UNDEFINED\t/* includes ro data */\n+\t       extern int _etext;\n+#              define DATASTART ((ptr_t)((((word) (&_etext)) + 0xfff) & ~0xfff))\n+#\t     endif\n+#\t     include <features.h>\n+#\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n+\t\t extern int __data_start;\n+#\t\t define DATASTART ((ptr_t)(&__data_start))\n+#\t     else\n+     \t         extern char **__environ;\n+#                define DATASTART ((ptr_t)(&__environ))\n+\t\t\t      /* hideous kludge: __environ is the first */\n+\t\t\t      /* word in crt0.o, and delimits the start */\n+\t\t\t      /* of the data segment, no matter which   */\n+\t\t\t      /* ld options were passed through.        */\n+\t\t\t      /* We could use _etext instead, but that  */\n+\t\t\t      /* would include .rodata, which may       */\n+\t\t\t      /* contain large read-only data tables    */\n+\t\t\t      /* that we'd rather not scan.\t\t*/\n+#\t     endif\n+\t     extern int _end;\n+#\t     define DATAEND (&_end)\n+#\telse\n+\t     extern int etext;\n+#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       endif\n+#   endif\n+#   ifdef CYGWIN32\n+#       define OS_TYPE \"CYGWIN32\"\n+          extern int _data_start__;\n+          extern int _data_end__;\n+          extern int _bss_start__;\n+          extern int _bss_end__;\n+  \t/* For binutils 2.9.1, we have\t\t\t*/\n+  \t/*\tDATASTART   = _data_start__\t\t*/\n+  \t/*\tDATAEND\t    = _bss_end__\t\t*/\n+  \t/* whereas for some earlier versions it was\t*/\n+  \t/*\tDATASTART   = _bss_start__\t\t*/\n+  \t/*\tDATAEND\t    = _data_end__\t\t*/\n+  \t/* To get it right for both, we take the\t*/\n+  \t/* minumum/maximum of the two.\t\t\t*/\n+#   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n+#   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n+#       define DATASTART ((ptr_t) MIN(&_data_start__, &_bss_start__))\n+#       define DATAEND\t ((ptr_t) MAX(&_data_end__, &_bss_end__))\n+#\tundef STACK_GRAN\n+#       define STACK_GRAN 0x10000\n+#       define HEURISTIC1\n+#   endif\n+#   ifdef OS2\n+#\tdefine OS_TYPE \"OS2\"\n+ \t    \t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n+\t\t/* os_dep.c. OS2 actually has the right\t\t\t*/\n+\t\t/* system call!\t\t\t\t\t\t*/\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+#   ifdef MSWIN32\n+#\tdefine OS_TYPE \"MSWIN32\"\n+\t\t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n+\t\t/* os_dep.c.\t\t\t\t\t\t*/\n+#       ifndef __WATCOMC__\n+#\t  define MPROTECT_VDB\n+#\tendif\n+#       define DATAEND  /* not needed */\n+#   endif\n+#   ifdef DJGPP\n+#       define OS_TYPE \"DJGPP\"\n+#       include \"stubinfo.h\"\n+        extern int etext;\n+        extern int _stklen;\n+        extern int __djgpp_stack_limit;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1ff) & ~0x1ff))\n+/* #       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \\\n+                                                     + _stklen)) */\n+#       define STACKBOTTOM ((ptr_t)((word) __djgpp_stack_limit + _stklen))\n+\t\t/* This may not be right.  */\n+#   endif\n+#   ifdef OPENBSD\n+#\tdefine OS_TYPE \"OPENBSD\"\n+#   endif\n+#   ifdef FREEBSD\n+#\tdefine OS_TYPE \"FREEBSD\"\n+#\tdefine MPROTECT_VDB\n+#   endif\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#   endif\n+#   ifdef THREE86BSD\n+#\tdefine OS_TYPE \"THREE86BSD\"\n+#   endif\n+#   ifdef BSDI\n+#\tdefine OS_TYPE \"BSDI\"\n+#   endif\n+#   if defined(OPENBSD) || defined(FREEBSD) || defined(NETBSD) \\\n+        || defined(THREE86BSD) || defined(BSDI)\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef NEXT\n+#\tdefine OS_TYPE \"NEXT\"\n+#\tdefine DATASTART ((ptr_t) get_etext())\n+#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+#   ifdef DOS4GW\n+#     define OS_TYPE \"DOS4GW\"\n+      extern long __nullarea;\n+      extern char _end;\n+      extern char *_STACKTOP;\n+      /* Depending on calling conventions Watcom C either precedes\n+         or does not precedes with undescore names of C-variables.\n+         Make sure startup code variables always have the same names.  */\n+      #pragma aux __nullarea \"*\";\n+      #pragma aux _end \"*\";\n+#     define STACKBOTTOM ((ptr_t) _STACKTOP)\n+                         /* confused? me too. */\n+#     define DATASTART ((ptr_t) &__nullarea)\n+#     define DATAEND ((ptr_t) &_end)\n+#   endif\n+# endif\n+\n+# ifdef NS32K\n+#   define MACH_TYPE \"NS32K\"\n+#   define ALIGNMENT 4\n+    extern char **environ;\n+#   define DATASTART ((ptr_t)(&environ))\n+\t\t\t      /* hideous kludge: environ is the first   */\n+\t\t\t      /* word in crt0.o, and delimits the start */\n+\t\t\t      /* of the data segment, no matter which   */\n+\t\t\t      /* ld options were passed through.        */\n+#   define STACKBOTTOM ((ptr_t) 0xfffff000) /* for Encore */\n+# endif\n+\n+# ifdef MIPS\n+#   define MACH_TYPE \"MIPS\"\n+#   ifndef IRIX5\n+#     define DATASTART (ptr_t)0x10000000\n+\t\t\t      /* Could probably be slightly higher since */\n+\t\t\t      /* startup code allocates lots of stuff.   */\n+#   else\n+      extern int _fdata;\n+#     define DATASTART ((ptr_t)(&_fdata))\n+#     ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x30000000\n+#     else\n+#\t  define HEAP_START DATASTART\n+#     endif\n+\t\t\t      /* Lowest plausible heap address.\t\t*/\n+\t\t\t      /* In the MMAP case, we map there.\t*/\n+\t\t\t      /* In either case it is used to identify\t*/\n+\t\t\t      /* heap sections so they're not \t\t*/\n+\t\t\t      /* considered as roots.\t\t\t*/\n+#   endif /* IRIX5 */\n+#   define HEURISTIC2\n+/* #   define STACKBOTTOM ((ptr_t)0x7fff8000)  sometimes also works.  */\n+#   ifdef ULTRIX\n+#\tdefine OS_TYPE \"ULTRIX\"\n+#       define ALIGNMENT 4\n+#   endif\n+#   ifdef RISCOS\n+#\tdefine OS_TYPE \"RISCOS\"\n+#   \tdefine ALIGNMENT 4  /* Required by hardware */\n+#   endif\n+#   ifdef IRIX5\n+#\tdefine OS_TYPE \"IRIX5\"\n+#       define MPROTECT_VDB\n+#       ifdef _MIPS_SZPTR\n+#\t  define CPP_WORDSZ _MIPS_SZPTR\n+#\t  define ALIGNMENT (_MIPS_SZPTR/8)\n+#\t  if CPP_WORDSZ != 64\n+#\t    define ALIGN_DOUBLE\n+#\t  endif\n+#\telse\n+#         define ALIGNMENT 4\n+#\t  define ALIGN_DOUBLE\n+#\tendif\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+# endif\n+\n+# ifdef RS6000\n+#   define MACH_TYPE \"RS6000\"\n+#   define ALIGNMENT 4\n+#   define DATASTART ((ptr_t)0x20000000)\n+    extern int errno;\n+#   define STACKBOTTOM ((ptr_t)((ulong)&errno))\n+#   define DYNAMIC_LOADING\n+\t/* For really old versions of AIX, this may have to be removed. */\n+# endif\n+\n+# ifdef HP_PA\n+#   define MACH_TYPE \"HP_PA\"\n+#   define ALIGNMENT 4\n+#   define ALIGN_DOUBLE\n+    extern int __data_start;\n+#   define DATASTART ((ptr_t)(&__data_start))\n+#   if 0\n+\t/* The following appears to work for 7xx systems running HP/UX\t*/\n+\t/* 9.xx Furthermore, it might result in much faster\t\t*/\n+\t/* collections than HEURISTIC2, which may involve scanning\t*/\n+\t/* segments that directly precede the stack.  It is not the\t*/\n+\t/* default, since it may not work on older machine/OS\t\t*/\n+\t/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering\t*/\n+\t/* this.)\t\t\t\t\t\t\t*/\n+#       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */\n+#   else\n+#       define HEURISTIC2\n+#   endif\n+#   define STACK_GROWS_UP\n+#   define DYNAMIC_LOADING\n+#   include <unistd.h>\n+#   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+\t/* They misspelled the Posix macro?\t*/\n+# endif\n+\n+# ifdef ALPHA\n+#   define MACH_TYPE \"ALPHA\"\n+#   define ALIGNMENT 8\n+#   ifdef OSF1\n+#\tdefine OS_TYPE \"OSF1\"\n+#   \tdefine DATASTART ((ptr_t) 0x140000000)\n+\textern _end;\n+#   \tdefine DATAEND ((ptr_t) &_end)\n+#   \tdefine HEURISTIC2\n+\t/* Normally HEURISTIC2 is too conervative, since\t\t*/\n+\t/* the text segment immediately follows the stack.\t\t*/\n+\t/* Hence we give an upper pound.\t\t\t\t*/\n+    \textern int __start;\n+#   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(&__start) & ~(getpagesize()-1)))\n+#   \tdefine CPP_WORDSZ 64\n+#   \tdefine MPROTECT_VDB\n+#   \tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define CPP_WORDSZ 64\n+#       define STACKBOTTOM ((ptr_t) 0x120000000)\n+#       ifdef __ELF__\n+            extern int __data_start;\n+#           define DATASTART &__data_start\n+#           define DYNAMIC_LOADING\n+#       else\n+#           define DATASTART ((ptr_t) 0x140000000)\n+#       endif\n+\textern int _end;\n+#\tdefine DATAEND (&_end)\n+#\tdefine MPROTECT_VDB\n+\t\t/* Has only been superficially tested.  May not\t*/\n+\t\t/* work on all versions.\t\t\t*/\n+#   endif\n+# endif\n+\n+# ifdef M88K\n+#   define MACH_TYPE \"M88K\"\n+#   define ALIGNMENT 4\n+#   define ALIGN_DOUBLE\n+    extern int etext;\n+#   ifdef CX_UX\n+#\tdefine OS_TYPE \"CX_UX\"\n+#       define DATASTART ((((word)&etext + 0x3fffff) & ~0x3fffff) + 0x10000)\n+#   endif\n+#   ifdef  DGUX\n+#\tdefine OS_TYPE \"DGUX\"\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+#   endif\n+#   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */\n+# endif\n+\n+# ifdef S370\n+#   define MACH_TYPE \"S370\"\n+#   define OS_TYPE \"UTS4\"\n+#   define ALIGNMENT 4\t/* Required by hardware\t*/\n+    extern int etext;\n+\textern int _etext;\n+\textern int _end;\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#\tdefine DATAEND (&_end)\n+#\tdefine HEURISTIC2\n+# endif\n+\n+# ifndef STACK_GROWS_UP\n+#   define STACK_GROWS_DOWN\n+# endif\n+\n+# ifndef CPP_WORDSZ\n+#   define CPP_WORDSZ 32\n+# endif\n+\n+# ifndef OS_TYPE\n+#   define OS_TYPE \"\"\n+# endif\n+\n+# ifndef DATAEND\n+    extern int end;\n+#   define DATAEND (&end)\n+# endif\n+\n+# if defined(SVR4) && !defined(GETPAGESIZE)\n+#    include <unistd.h>\n+#    define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n+# endif\n+\n+# ifndef GETPAGESIZE\n+#   if defined(SUNOS5) || defined(IRIX5)\n+#\tinclude <unistd.h>\n+#   endif\n+#   define GETPAGESIZE() getpagesize()\n+# endif\n+\n+# if defined(SUNOS5) || defined(DRSNX) || defined(UTS4)\n+    /* OS has SVR4 generic features.  Probably others also qualify.\t*/\n+#   define SVR4\n+# endif\n+\n+# if defined(SUNOS5) || defined(DRSNX)\n+    /* OS has SUNOS5 style semi-undocumented interface to dynamic \t*/\n+    /* loader.\t\t\t\t\t\t\t\t*/\n+#   define SUNOS5DL\n+    /* OS has SUNOS5 style signal handlers.\t\t\t\t*/\n+#   define SUNOS5SIGS\n+# endif\n+\n+# if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n+   -> bad word size\n+# endif\n+\n+# ifdef PCR\n+#   undef DYNAMIC_LOADING\n+#   undef STACKBOTTOM\n+#   undef HEURISTIC1\n+#   undef HEURISTIC2\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+#   define PCR_VDB\n+# endif\n+\n+# ifdef SRC_M3\n+/* Postponed for now. */\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+# endif\n+\n+# ifdef SMALL_CONFIG\n+/* Presumably not worth the space it takes. */\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+# endif\n+\n+# if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n+#   define DEFAULT_VDB\n+# endif\n+\n+# if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n+#   define SOLARIS_THREADS\n+# endif\n+# if defined(IRIX_THREADS) && !defined(IRIX5)\n+--> inconsistent configuration\n+# endif\n+# if defined(IRIX_JDK_THREADS) && !defined(IRIX5)\n+--> inconsistent configuration\n+# endif\n+# if defined(LINUX_THREADS) && !defined(LINUX)\n+--> inconsistent configuration\n+# endif\n+# if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n+--> inconsistent configuration\n+# endif\n+# if defined(PCR) || defined(SRC_M3) || \\\n+\tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n+\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n+\tdefined(IRIX_JDK_THREADS)\n+#   define THREADS\n+# endif\n+\n+# if defined(HP_PA) || defined(M88K) || defined(POWERPC) \\\n+     || (defined(I386) && defined(OS2)) || defined(UTS4) || defined(LINT)\n+\t/* Use setjmp based hack to mark from callee-save registers. */\n+#\tdefine USE_GENERIC_PUSH_REGS\n+# endif\n+# if defined(SPARC) && !defined(LINUX)\n+#   define SAVE_CALL_CHAIN\n+#   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n+\t\t\t\t/* include assembly code to do it well.\t*/\n+# endif\n+\n+# endif"}, {"sha": "880020c53632d443b4e2c34246d26a9e2bbd03d6", "filename": "boehm-gc/include/javaxfc.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Finclude%2Fjavaxfc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Finclude%2Fjavaxfc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fjavaxfc.h?ref=70f7276781bbc54ed541c6368e3e1e245a39d348", "patch": "@@ -0,0 +1,41 @@\n+# ifndef GC_H\n+#   include \"gc.h\"\n+# endif\n+\n+/*\n+ * Invoke all remaining finalizers that haven't yet been run.\n+ * This is needed for strict compliance with the Java standard, \n+ * which can make the runtime guarantee that all finalizers are run.\n+ * This is problematic for several reasons:\n+ * 1) It means that finalizers, and all methods calle by them,\n+ *    must be prepared to deal with objects that have been finalized in\n+ *    spite of the fact that they are still referenced by statically\n+ *    allocated pointer variables.\n+ * 1) It may mean that we get stuck in an infinite loop running\n+ *    finalizers which create new finalizable objects, though that's\n+ *    probably unlikely.\n+ * Thus this is not recommended for general use.\n+ */\n+void GC_finalize_all();\n+\n+/*\n+ * A version of GC_register_finalizer that allows the object to be\n+ * finalized before the objects it references.  This is again error\n+ * prone, in that it makes it easy to accidentally reference finalized\n+ * objects.  Again, recommended only for JVM implementors.\n+ */\n+void GC_register_finalizer_no_order(GC_PTR obj,\n+\t\t\t       GC_finalization_proc fn, GC_PTR cd,\n+\t\t\t       GC_finalization_proc *ofn, GC_PTR * ocd);\n+\n+void GC_debug_register_finalizer_no_order(GC_PTR obj,\n+\t\t\t       GC_finalization_proc fn, GC_PTR cd,\n+\t\t\t       GC_finalization_proc *ofn, GC_PTR * ocd);\n+\n+#ifdef GC_DEBUG\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer_no_order(p, f, d, of, od)\n+#else\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_register_finalizer_no_order(p, f, d, of, od)\n+#endif"}, {"sha": "577138830c58c875d6eec423145abb1b8fca6b60", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=70f7276781bbc54ed541c6368e3e1e245a39d348", "patch": "@@ -0,0 +1,456 @@\n+/*\n+ * Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+//\n+// This is a revision of gc_alloc.h for SGI STL versions > 3.0\n+// Unlike earlier versions, it supplements the standard \"alloc.h\"\n+// instead of replacing it.\n+//\n+// This is sloppy about variable names used in header files.\n+// It also doesn't yet understand the new header file names or\n+// namespaces.\n+//\n+// This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE\n+// and -DALL_INTERIOR_POINTERS.  We also recommend\n+// -DREDIRECT_MALLOC=GC_uncollectable_malloc.\n+//\n+// Some of this could be faster in the explicit deallocation case.\n+// In particular, we spend too much time clearing objects on the\n+// free lists.  That could be avoided.\n+//\n+// This uses template classes with static members, and hence does not work\n+// with g++ 2.7.2 and earlier.\n+//\n+// Unlike its predecessor, this one simply defines\n+// \tgc_alloc\n+//\tsingle_client_gc_alloc\n+//\ttraceable_alloc\n+//\tsingle_client_traceable_alloc\n+//\n+// It does not redefine alloc.  Nor does it change the default allocator,\n+// though the user may wish to do so.  (The argument against changing\n+// the default allocator is that it may introduce subtle link compatibility\n+// problems.  The argument for changing it is that the usual default\n+// allocator is usually a very bad choice for a garbage collected environment.)\n+//\n+\n+#ifndef GC_ALLOC_H\n+\n+#include \"gc.h\"\n+#include <alloc.h>\n+\n+#define GC_ALLOC_H\n+\n+#include <stddef.h>\n+#include <string.h>\n+\n+// The following need to match collector data structures.\n+// We can't include gc_priv.h, since that pulls in way too much stuff.\n+// This should eventually be factored out into another include file.\n+\n+extern \"C\" {\n+    extern void ** const GC_objfreelist_ptr;\n+    extern void ** const GC_aobjfreelist_ptr;\n+    extern void ** const GC_uobjfreelist_ptr;\n+    extern void ** const GC_auobjfreelist_ptr;\n+\n+    extern void GC_incr_words_allocd(size_t words);\n+    extern void GC_incr_mem_freed(size_t words);\n+\n+    extern char * GC_generic_malloc_words_small(size_t word, int kind);\n+}\n+\n+// Object kinds; must match PTRFREE, NORMAL, UNCOLLECTABLE, and\n+// AUNCOLLECTABLE in gc_priv.h.\n+\n+enum { GC_PTRFREE = 0, GC_NORMAL = 1, GC_UNCOLLECTABLE = 2,\n+       GC_AUNCOLLECTABLE = 3 };\n+\n+enum { GC_max_fast_bytes = 255 };\n+\n+enum { GC_bytes_per_word = sizeof(char *) };\n+\n+enum { GC_byte_alignment = 8 };\n+\n+enum { GC_word_alignment = GC_byte_alignment/GC_bytes_per_word };\n+\n+inline void * &GC_obj_link(void * p)\n+{   return *(void **)p;  }\n+\n+// Compute a number of words >= n+1 bytes.\n+// The +1 allows for pointers one past the end.\n+inline size_t GC_round_up(size_t n)\n+{\n+    return ((n + GC_byte_alignment)/GC_byte_alignment)*GC_word_alignment;\n+}\n+\n+// The same but don't allow for extra byte.\n+inline size_t GC_round_up_uncollectable(size_t n)\n+{\n+    return ((n + GC_byte_alignment - 1)/GC_byte_alignment)*GC_word_alignment;\n+}\n+\n+template <int dummy>\n+class GC_aux_template {\n+public:\n+  // File local count of allocated words.  Occasionally this is\n+  // added into the global count.  A separate count is necessary since the\n+  // real one must be updated with a procedure call.\n+  static size_t GC_words_recently_allocd;\n+\n+  // Same for uncollectable mmory.  Not yet reflected in either\n+  // GC_words_recently_allocd or GC_non_gc_bytes.\n+  static size_t GC_uncollectable_words_recently_allocd;\n+\n+  // Similar counter for explicitly deallocated memory.\n+  static size_t GC_mem_recently_freed;\n+\n+  // Again for uncollectable memory.\n+  static size_t GC_uncollectable_mem_recently_freed;\n+\n+  static void * GC_out_of_line_malloc(size_t nwords, int kind);\n+};\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_words_recently_allocd = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_uncollectable_words_recently_allocd = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_mem_recently_freed = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_uncollectable_mem_recently_freed = 0;\n+\n+template <int dummy>\n+void * GC_aux_template<dummy>::GC_out_of_line_malloc(size_t nwords, int kind)\n+{\n+    GC_words_recently_allocd += GC_uncollectable_words_recently_allocd;\n+    GC_non_gc_bytes +=\n+                GC_bytes_per_word * GC_uncollectable_words_recently_allocd;\n+    GC_uncollectable_words_recently_allocd = 0;\n+\n+    GC_mem_recently_freed += GC_uncollectable_mem_recently_freed;\n+    GC_non_gc_bytes -= \n+                GC_bytes_per_word * GC_uncollectable_mem_recently_freed;\n+    GC_uncollectable_mem_recently_freed = 0;\n+\n+    GC_incr_words_allocd(GC_words_recently_allocd);\n+    GC_words_recently_allocd = 0;\n+\n+    GC_incr_mem_freed(GC_mem_recently_freed);\n+    GC_mem_recently_freed = 0;\n+\n+    return GC_generic_malloc_words_small(nwords, kind);\n+}\n+\n+typedef GC_aux_template<0> GC_aux;\n+\n+// A fast, single-threaded, garbage-collected allocator\n+// We assume the first word will be immediately overwritten.\n+// In this version, deallocation is not a noop, and explicit\n+// deallocation is likely to help performance.\n+template <int dummy>\n+class single_client_gc_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc(n);\n+\t    flh = GC_objfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_NORMAL);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic(n);\n+\t    flh = GC_aobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_PTRFREE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+\tstatic void deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes)  {\n+\t\tGC_free(p);\n+\t    } else {\n+\t        flh = GC_objfreelist_ptr + nwords;\n+\t        GC_obj_link(p) = *flh;\n+\t\tmemset((char *)p + GC_bytes_per_word, 0,\n+\t\t       GC_bytes_per_word * (nwords - 1));\n+\t        *flh = p;\n+\t        GC_aux::GC_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+\tstatic void ptr_free_deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes) {\n+\t\tGC_free(p);\n+\t    } else {\n+\t    \tflh = GC_aobjfreelist_ptr + nwords;\n+\t    \tGC_obj_link(p) = *flh;\n+\t    \t*flh = p;\n+\t    \tGC_aux::GC_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+};\n+\n+typedef single_client_gc_alloc_template<0> single_client_gc_alloc;\n+\n+// Once more, for uncollectable objects.\n+template <int dummy>\n+class single_client_traceable_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up_uncollectable(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_uncollectable(n);\n+\t    flh = GC_uobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_UNCOLLECTABLE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up_uncollectable(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic_uncollectable(n);\n+\t    flh = GC_auobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_AUNCOLLECTABLE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+\tstatic void deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up_uncollectable(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes)  {\n+\t\tGC_free(p);\n+\t    } else {\n+\t        flh = GC_uobjfreelist_ptr + nwords;\n+\t        GC_obj_link(p) = *flh;\n+\t        *flh = p;\n+\t        GC_aux::GC_uncollectable_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+\tstatic void ptr_free_deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up_uncollectable(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes) {\n+\t\tGC_free(p);\n+\t    } else {\n+\t    \tflh = GC_auobjfreelist_ptr + nwords;\n+\t    \tGC_obj_link(p) = *flh;\n+\t    \t*flh = p;\n+\t    \tGC_aux::GC_uncollectable_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+};\n+\n+typedef single_client_traceable_alloc_template<0> single_client_traceable_alloc;\n+\n+template < int dummy >\n+class gc_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n) { return GC_malloc(n); }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+\t\t{ return GC_malloc_atomic(n); }\n+\tstatic void deallocate(void *, size_t) { }\n+\tstatic void ptr_free_deallocate(void *, size_t) { }\n+};\n+\n+typedef gc_alloc_template < 0 > gc_alloc;\n+\n+template < int dummy >\n+class traceable_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n) { return GC_malloc_uncollectable(n); }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+\t\t{ return GC_malloc_atomic_uncollectable(n); }\n+\tstatic void deallocate(void *p, size_t) { GC_free(p); }\n+\tstatic void ptr_free_deallocate(void *p, size_t) { GC_free(p); }\n+};\n+\n+typedef traceable_alloc_template < 0 > traceable_alloc;\n+\n+#ifdef _SGI_SOURCE\n+\n+// We want to specialize simple_alloc so that it does the right thing\n+// for all pointerfree types.  At the moment there is no portable way to\n+// even approximate that.  The following approximation should work for\n+// SGI compilers, and perhaps some others.\n+\n+# define __GC_SPECIALIZE(T,alloc) \\\n+class simple_alloc<T, alloc> { \\\n+public: \\\n+    static T *allocate(size_t n) \\\n+\t{ return 0 == n? 0 : \\\n+\t\t\t (T*) alloc::ptr_free_allocate(n * sizeof (T)); } \\\n+    static T *allocate(void) \\\n+\t{ return (T*) alloc::ptr_free_allocate(sizeof (T)); } \\\n+    static void deallocate(T *p, size_t n) \\\n+\t{ if (0 != n) alloc::ptr_free_deallocate(p, n * sizeof (T)); } \\\n+    static void deallocate(T *p) \\\n+\t{ alloc::ptr_free_deallocate(p, sizeof (T)); } \\\n+};\n+\n+__GC_SPECIALIZE(char, gc_alloc)\n+__GC_SPECIALIZE(int, gc_alloc)\n+__GC_SPECIALIZE(unsigned, gc_alloc)\n+__GC_SPECIALIZE(float, gc_alloc)\n+__GC_SPECIALIZE(double, gc_alloc)\n+\n+__GC_SPECIALIZE(char, traceable_alloc)\n+__GC_SPECIALIZE(int, traceable_alloc)\n+__GC_SPECIALIZE(unsigned, traceable_alloc)\n+__GC_SPECIALIZE(float, traceable_alloc)\n+__GC_SPECIALIZE(double, traceable_alloc)\n+\n+__GC_SPECIALIZE(char, single_client_gc_alloc)\n+__GC_SPECIALIZE(int, single_client_gc_alloc)\n+__GC_SPECIALIZE(unsigned, single_client_gc_alloc)\n+__GC_SPECIALIZE(float, single_client_gc_alloc)\n+__GC_SPECIALIZE(double, single_client_gc_alloc)\n+\n+__GC_SPECIALIZE(char, single_client_traceable_alloc)\n+__GC_SPECIALIZE(int, single_client_traceable_alloc)\n+__GC_SPECIALIZE(unsigned, single_client_traceable_alloc)\n+__GC_SPECIALIZE(float, single_client_traceable_alloc)\n+__GC_SPECIALIZE(double, single_client_traceable_alloc)\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+__STL_BEGIN_NAMESPACE\n+\n+template <class _T>\n+struct _Alloc_traits<_T, gc_alloc >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_T, gc_alloc > _Alloc_type;\n+  typedef __allocator<_T, gc_alloc > allocator_type;\n+};\n+\n+inline bool operator==(const gc_alloc&,\n+                       const gc_alloc&)\n+{\n+  return true;\n+}\n+\n+inline bool operator!=(const gc_alloc&,\n+                       const gc_alloc&)\n+{\n+  return false;\n+}\n+\n+template <class _T>\n+struct _Alloc_traits<_T, single_client_gc_alloc >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_T, single_client_gc_alloc > _Alloc_type;\n+  typedef __allocator<_T, single_client_gc_alloc > allocator_type;\n+};\n+\n+inline bool operator==(const single_client_gc_alloc&,\n+                       const single_client_gc_alloc&)\n+{\n+  return true;\n+}\n+\n+inline bool operator!=(const single_client_gc_alloc&,\n+                       const single_client_gc_alloc&)\n+{\n+  return false;\n+}\n+\n+template <class _T>\n+struct _Alloc_traits<_T, traceable_alloc >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_T, traceable_alloc > _Alloc_type;\n+  typedef __allocator<_T, traceable_alloc > allocator_type;\n+};\n+\n+inline bool operator==(const traceable_alloc&,\n+                       const traceable_alloc&)\n+{\n+  return true;\n+}\n+\n+inline bool operator!=(const traceable_alloc&,\n+                       const traceable_alloc&)\n+{\n+  return false;\n+}\n+\n+template <class _T>\n+struct _Alloc_traits<_T, single_client_traceable_alloc >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_T, single_client_traceable_alloc > _Alloc_type;\n+  typedef __allocator<_T, single_client_traceable_alloc > allocator_type;\n+};\n+\n+inline bool operator==(const single_client_traceable_alloc&,\n+                       const single_client_traceable_alloc&)\n+{\n+  return true;\n+}\n+\n+inline bool operator!=(const single_client_traceable_alloc&,\n+                       const single_client_traceable_alloc&)\n+{\n+  return false;\n+}\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+#endif /* _SGI_SOURCE */\n+\n+#endif /* GC_ALLOC_H */"}, {"sha": "b1a9dc3613a265de71ac1785d0745602156b708c", "filename": "boehm-gc/include/private/gcconfig.h", "status": "added", "additions": 1061, "deletions": 0, "changes": 1061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f7276781bbc54ed541c6368e3e1e245a39d348/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=70f7276781bbc54ed541c6368e3e1e245a39d348", "patch": "@@ -0,0 +1,1061 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+ \n+#ifndef CONFIG_H\n+\n+# define CONFIG_H\n+\n+/* Machine dependent parameters.  Some tuning parameters can be found\t*/\n+/* near the top of gc_private.h.\t\t\t\t\t*/\n+\n+/* Machine specific parts contributed by various people.  See README file. */\n+\n+/* First a unified test for Linux: */\n+# if defined(linux) || defined(__linux__)\n+#    define LINUX\n+# endif\n+\n+/* Determine the machine type: */\n+# if defined(sun) && defined(mc68000)\n+#    define M68K\n+#    define SUNOS4\n+#    define mach_type_known\n+# endif\n+# if defined(hp9000s300)\n+#    define M68K\n+#    define HP\n+#    define mach_type_known\n+# endif\n+# if defined(__OpenBSD__) && defined(m68k)\n+#    define M68K\n+#    define OPENBSD\n+#    define mach_type_known\n+# endif\n+# if defined(__NetBSD__) && defined(m68k)\n+#    define M68K\n+#    define NETBSD\n+#    define mach_type_known\n+# endif\n+# if defined(vax)\n+#    define VAX\n+#    ifdef ultrix\n+#\tdefine ULTRIX\n+#    else\n+#\tdefine BSD\n+#    endif\n+#    define mach_type_known\n+# endif\n+# if defined(mips) || defined(__mips)\n+#    define MIPS\n+#    if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n+#\tdefine ULTRIX\n+#    else\n+#\tif defined(_SYSTYPE_SVR4) || defined(SYSTYPE_SVR4) || defined(__SYSTYPE_SVR4__)\n+#\t  define IRIX5   /* or IRIX 6.X */\n+#\telse\n+#\t  define RISCOS  /* or IRIX 4.X */\n+#\tendif\n+#    endif\n+#    define mach_type_known\n+# endif\n+# if defined(sequent) && defined(i386)\n+#    define I386\n+#    define SEQUENT\n+#    define mach_type_known\n+# endif\n+# if defined(sun) && defined(i386)\n+#    define I386\n+#    define SUNOS5\n+#    define mach_type_known\n+# endif\n+# if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)\n+#    define I386\n+#    define OS2\n+#    define mach_type_known\n+# endif\n+# if defined(ibm032)\n+#   define RT\n+#   define mach_type_known\n+# endif\n+# if defined(sun) && (defined(sparc) || defined(__sparc))\n+#   define SPARC\n+    /* Test for SunOS 5.x */\n+#     include <errno.h>\n+#     ifdef ECHRNG\n+#       define SUNOS5\n+#     else\n+#\tdefine SUNOS4\n+#     endif\n+#   define mach_type_known\n+# endif\n+# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux)\n+#   define SPARC\n+#   define DRSNX\n+#   define mach_type_known\n+# endif\n+# if defined(_IBMR2)\n+#   define RS6000\n+#   define mach_type_known\n+# endif\n+# if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)\n+\t/* The above test may need refinement\t*/\n+#   define I386\n+#   if defined(_SCO_ELF)\n+#     define SCO_ELF\n+#   else\n+#     define SCO\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(_AUX_SOURCE)\n+#   define M68K\n+#   define SYSV\n+#   define mach_type_known\n+# endif\n+# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) \\\n+     || defined(hppa) || defined(__hppa__)\n+#   define HP_PA\n+#   define mach_type_known\n+# endif\n+# if defined(LINUX) && defined(i386)\n+#    define I386\n+#    define mach_type_known\n+# endif\n+# if defined(LINUX) && defined(powerpc)\n+#    define POWERPC\n+#    define mach_type_known\n+# endif\n+# if defined(LINUX) && defined(__mc68000__)\n+#    define M68K\n+#    define mach_type_known\n+# endif\n+# if defined(linux) && defined(sparc)\n+#    define SPARC\n+#    define LINUX\n+#    define mach_type_known\n+# endif\n+# if defined(__alpha) || defined(__alpha__)\n+#   define ALPHA\n+#   if !defined(LINUX)\n+#     define OSF1\t/* a.k.a Digital Unix */\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(_AMIGA)\n+#   define M68K\n+#   define AMIGA\n+#   define mach_type_known\n+# endif\n+# if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)\n+#   define M68K\n+#   define MACOS\n+#   define mach_type_known\n+# endif\n+# if defined(__MWERKS__) && defined(__powerc)\n+#   define POWERPC\n+#   define MACOS\n+#   define mach_type_known\n+# endif\n+# if defined(NeXT) && defined(mc68000)\n+#   define M68K\n+#   define NEXT\n+#   define mach_type_known\n+# endif\n+# if defined(NeXT) && defined(i386)\n+#   define I386\n+#   define NEXT\n+#   define mach_type_known\n+# endif\n+# if defined(__OpenBSD__) && defined(i386)\n+#   define I386\n+#   define OPENBSD\n+#   define mach_type_known\n+# endif\n+# if defined(__FreeBSD__) && defined(i386)\n+#   define I386\n+#   define FREEBSD\n+#   define mach_type_known\n+# endif\n+# if defined(__NetBSD__) && defined(i386)\n+#   define I386\n+#   define NETBSD\n+#   define mach_type_known\n+# endif\n+# if defined(bsdi) && defined(i386)\n+#    define I386\n+#    define BSDI\n+#    define mach_type_known\n+# endif\n+# if !defined(mach_type_known) && defined(__386BSD__)\n+#   define I386\n+#   define THREE86BSD\n+#   define mach_type_known\n+# endif\n+# if defined(_CX_UX) && defined(_M88K)\n+#   define M88K\n+#   define CX_UX\n+#   define mach_type_known\n+# endif\n+# if defined(DGUX)\n+#   define M88K\n+    /* DGUX defined */\n+#   define mach_type_known\n+# endif\n+# if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n+     || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)\n+#   define I386\n+#   define MSWIN32\t/* or Win32s */\n+#   define mach_type_known\n+# endif\n+# if defined(__DJGPP__)\n+#   define I386\n+#   ifndef DJGPP\n+#     define DJGPP  /* MSDOS running the DJGPP port of GCC */\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(__CYGWIN32__) || defined(__CYGWIN__)\n+#   define I386\n+#   define CYGWIN32\n+#   define mach_type_known\n+# endif\n+# if defined(__BORLANDC__)\n+#   define I386\n+#   define MSWIN32\n+#   define mach_type_known\n+# endif\n+# if defined(_UTS) && !defined(mach_type_known)\n+#   define S370\n+#   define UTS4\n+#   define mach_type_known\n+# endif\n+/* Ivan Demakov */\n+# if defined(__WATCOMC__) && defined(__386__)\n+#   define I386\n+#   if !defined(OS2) && !defined(MSWIN32) && !defined(DOS4GW)\n+#     if defined(__OS2__)\n+#       define OS2\n+#     else\n+#       if defined(__WINDOWS_386__) || defined(__NT__)\n+#         define MSWIN32\n+#       else\n+#         define DOS4GW\n+#       endif\n+#     endif\n+#   endif\n+#   define mach_type_known\n+# endif\n+\n+/* Feel free to add more clauses here */\n+\n+/* Or manually define the machine type here.  A machine type is \t*/\n+/* characterized by the architecture.  Some\t\t\t\t*/\n+/* machine types are further subdivided by OS.\t\t\t\t*/\n+/* the macros ULTRIX, RISCOS, and BSD to distinguish.\t\t\t*/\n+/* Note that SGI IRIX is treated identically to RISCOS.\t\t\t*/\n+/* SYSV on an M68K actually means A/UX.\t\t\t\t\t*/\n+/* The distinction in these cases is usually the stack starting address */\n+# ifndef mach_type_known\n+\t--> unknown machine type\n+# endif\n+\t\t    /* Mapping is: M68K       ==> Motorola 680X0\t*/\n+\t\t    /*\t\t   (SUNOS4,HP,NEXT, and SYSV (A/UX),\t*/\n+\t\t    /*\t\t   MACOS and AMIGA variants)\t\t*/\n+\t\t    /*             I386       ==> Intel 386\t \t*/\n+\t\t    /*\t\t    (SEQUENT, OS2, SCO, LINUX, NETBSD,\t*/\n+\t\t    /*\t\t     FREEBSD, THREE86BSD, MSWIN32,\t*/\n+\t\t    /* \t\t     BSDI,SUNOS5, NEXT, other variants)\t*/\n+                    /*             NS32K      ==> Encore Multimax \t*/\n+                    /*             MIPS       ==> R2000 or R3000\t*/\n+                    /*\t\t\t(RISCOS, ULTRIX variants)\t*/\n+                    /*\t\t   VAX\t      ==> DEC VAX\t\t*/\n+                    /*\t\t\t(BSD, ULTRIX variants)\t\t*/\n+                    /*\t\t   RS6000     ==> IBM RS/6000 AIX3.X\t*/\n+                    /*\t\t   RT\t      ==> IBM PC/RT\t\t*/\n+                    /*\t\t   HP_PA      ==> HP9000/700 & /800\t*/\n+                    /*\t\t\t\t  HP/UX\t\t\t*/\n+\t\t    /*\t\t   SPARC      ==> SPARC under SunOS\t*/\n+\t\t    /*\t\t\t(SUNOS4, SUNOS5,\t\t*/\n+\t\t    /*\t\t\t DRSNX variants)\t\t*/\n+\t\t    /* \t\t   ALPHA      ==> DEC Alpha \t\t*/\n+\t\t    /*\t\t\t(OSF1 and LINUX variants)\t*/\n+\t\t    /* \t\t   M88K       ==> Motorola 88XX0        */\n+\t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n+\t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n+\t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n+\n+\n+/*\n+ * For each architecture and OS, the following need to be defined:\n+ *\n+ * CPP_WORD_SZ is a simple integer constant representing the word size.\n+ * in bits.  We assume byte addressibility, where a byte has 8 bits.\n+ * We also assume CPP_WORD_SZ is either 32 or 64.\n+ * (We care about the length of pointers, not hardware\n+ * bus widths.  Thus a 64 bit processor with a C compiler that uses\n+ * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)\n+ *\n+ * MACH_TYPE is a string representation of the machine type.\n+ * OS_TYPE is analogous for the OS.\n+ *\n+ * ALIGNMENT is the largest N, such that\n+ * all pointer are guaranteed to be aligned on N byte boundaries.\n+ * defining it to be 1 will always work, but perform poorly.\n+ *\n+ * DATASTART is the beginning of the data segment.\n+ * On UNIX systems, the collector will scan the area between DATASTART\n+ * and DATAEND for root pointers.\n+ *\n+ * DATAEND, if not &end.\n+ *\n+ * ALIGN_DOUBLE of GC_malloc should return blocks aligned to twice\n+ * the pointer size.\n+ *\n+ * STACKBOTTOM is the cool end of the stack, which is usually the\n+ * highest address in the stack.\n+ * Under PCR or OS/2, we have other ways of finding thread stacks.\n+ * For each machine, the following should:\n+ * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and\n+ * 2) define exactly one of\n+ *\tSTACKBOTTOM (should be defined to be an expression)\n+ *\tHEURISTIC1\n+ *\tHEURISTIC2\n+ * If either of the last two macros are defined, then STACKBOTTOM is computed\n+ * during collector startup using one of the following two heuristics:\n+ * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to\n+ *\t\tthe next multiple of STACK_GRAN.\n+ * HEURISTIC2:  Take an address inside GC_init's frame, increment it repeatedly\n+ *\t\tin small steps (decrement if STACK_GROWS_UP), and read the value\n+ *\t\tat each location.  Remember the value when the first\n+ *\t\tSegmentation violation or Bus error is signalled.  Round that\n+ *\t\tto the nearest plausible page boundary, and use that instead\n+ *\t\tof STACKBOTTOM.\n+ *\n+ * If no expression for STACKBOTTOM can be found, and neither of the above\n+ * heuristics are usable, the collector can still be used with all of the above\n+ * undefined, provided one of the following is done:\n+ * 1) GC_mark_roots can be changed to somehow mark from the correct stack(s)\n+ *    without reference to STACKBOTTOM.  This is appropriate for use in\n+ *    conjunction with thread packages, since there will be multiple stacks.\n+ *    (Allocating thread stacks in the heap, and treating them as ordinary\n+ *    heap data objects is also possible as a last resort.  However, this is\n+ *    likely to introduce significant amounts of excess storage retention\n+ *    unless the dead parts of the thread stacks are periodically cleared.)\n+ * 2) Client code may set GC_stackbottom before calling any GC_ routines.\n+ *    If the author of the client code controls the main program, this is\n+ *    easily accomplished by introducing a new main program, setting\n+ *    GC_stackbottom to the address of a local variable, and then calling\n+ *    the original main program.  The new main program would read something\n+ *    like:\n+ *\n+ *\t\t# include \"gc_private.h\"\n+ *\n+ *\t\tmain(argc, argv, envp)\n+ *\t\tint argc;\n+ *\t\tchar **argv, **envp;\n+ *\t\t{\n+ *\t\t    int dummy;\n+ *\n+ *\t\t    GC_stackbottom = (ptr_t)(&dummy);\n+ *\t\t    return(real_main(argc, argv, envp));\n+ *\t\t}\n+ *\n+ *\n+ * Each architecture may also define the style of virtual dirty bit\n+ * implementation to be used:\n+ *   MPROTECT_VDB: Write protect the heap and catch faults.\n+ *   PROC_VDB: Use the SVR4 /proc primitives to read dirty bits.\n+ *\n+ * An architecture may define DYNAMIC_LOADING if dynamic_load.c\n+ * defined GC_register_dynamic_libraries() for the architecture.\n+ */\n+\n+\n+# define STACK_GRAN 0x1000000\n+# ifdef M68K\n+#   define MACH_TYPE \"M68K\"\n+#   define ALIGNMENT 2\n+#   ifdef OPENBSD\n+#\tdefine OS_TYPE \"OPENBSD\"\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define STACKBOTTOM ((ptr_t)0xf0000000)\n+#       define MPROTECT_VDB\n+#       ifdef __ELF__\n+#            define DYNAMIC_LOADING\n+             extern char **__environ;\n+#            define DATASTART ((ptr_t)(&__environ))\n+                             /* hideous kludge: __environ is the first */\n+                             /* word in crt0.o, and delimits the start */\n+                             /* of the data segment, no matter which   */\n+                             /* ld options were passed through.        */\n+                             /* We could use _etext instead, but that  */\n+                             /* would include .rodata, which may       */\n+                             /* contain large read-only data tables    */\n+                             /* that we'd rather not scan.             */\n+             extern int _end;\n+#            define DATAEND (&_end)\n+#       else\n+             extern int etext;\n+#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       endif\n+#   endif\n+#   ifdef SUNOS4\n+#\tdefine OS_TYPE \"SUNOS4\"\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x1ffff) & ~0x1ffff))\n+#\tdefine HEURISTIC1\t/* differs\t*/\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef HP\n+#\tdefine OS_TYPE \"HP\"\n+\textern char etext;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       define STACKBOTTOM ((ptr_t) 0xffeffffc)\n+\t\t\t      /* empirically determined.  seems to work. */\n+#  \tinclude <unistd.h>\n+#\tdefine GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+#   endif\n+#   ifdef SYSV\n+#\tdefine OS_TYPE \"SYSV\"\n+\textern etext;\n+#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\t\t\t\t   & ~0x3fffff) \\\n+\t\t\t\t  +((word)&etext & 0x1fff))\n+\t/* This only works for shared-text binaries with magic number 0413.\n+\t   The other sorts of SysV binaries put the data at the end of the text,\n+\t   in which case the default of &etext would work.  Unfortunately,\n+\t   handling both would require having the magic-number available.\n+\t   \t   \t\t-- Parag\n+\t   */\n+#\tdefine STACKBOTTOM ((ptr_t)0xFFFFFFFE)\n+\t\t\t/* The stack starts at the top of memory, but   */\n+\t\t\t/* 0x0 cannot be used as setjump_test complains */\n+\t\t\t/* that the stack direction is incorrect.  Two  */\n+\t\t\t/* bytes down from 0x0 should be safe enough.   */\n+\t\t\t/* \t\t--Parag\t\t\t\t*/\n+#   \tinclude <sys/mmu.h>\n+#\tdefine GETPAGESIZE() PAGESIZE\t/* Is this still right? */\n+#   endif\n+#   ifdef AMIGA\n+#\tdefine OS_TYPE \"AMIGA\"\n+ \t    \t/* STACKBOTTOM and DATASTART handled specially\t*/\n+ \t    \t/* in os_dep.c\t\t\t\t\t*/\n+# \tdefine DATAEND\t/* not needed */\n+#\tdefine GETPAGESIZE() 4096\n+#   endif\n+#   ifdef MACOS\n+#     ifndef __LOWMEM__\n+#     include <LowMem.h>\n+#     endif\n+#     define OS_TYPE \"MACOS\"\n+\t\t\t/* see os_dep.c for details of global data segments. */\n+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n+#     define DATAEND\t/* not needed */\n+#     define GETPAGESIZE() 4096\n+#   endif\n+#   ifdef NEXT\n+#\tdefine OS_TYPE \"NEXT\"\n+#\tdefine DATASTART ((ptr_t) get_etext())\n+#\tdefine STACKBOTTOM ((ptr_t) 0x4000000)\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+# endif\n+\n+# ifdef POWERPC\n+#   define MACH_TYPE \"POWERPC\"\n+#   define ALIGNMENT 2\n+#   ifdef MACOS\n+#     ifndef __LOWMEM__\n+#     include <LowMem.h>\n+#     endif\n+#     define OS_TYPE \"MACOS\"\n+\t\t\t/* see os_dep.c for details of global data segments. */\n+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n+#     define DATAEND  /* not needed */\n+#   endif\n+#   ifdef LINUX\n+#     define OS_TYPE \"LINUX\"\n+#     define HEURISTIC1\n+#     undef STACK_GRAN\n+#     define STACK_GRAN 0x10000000\n+#     define DATASTART GC_data_start\n+      extern int _end;\n+#     define DATAEND (&_end)\n+#   endif\n+# endif\n+\n+# ifdef VAX\n+#   define MACH_TYPE \"VAX\"\n+#   define ALIGNMENT 4\t/* Pointers are longword aligned by 4.2 C compiler */\n+    extern char etext;\n+#   define DATASTART ((ptr_t)(&etext))\n+#   ifdef BSD\n+#\tdefine OS_TYPE \"BSD\"\n+#\tdefine HEURISTIC1\n+\t\t\t/* HEURISTIC2 may be OK, but it's hard to test. */\n+#   endif\n+#   ifdef ULTRIX\n+#\tdefine OS_TYPE \"ULTRIX\"\n+#\tdefine STACKBOTTOM ((ptr_t) 0x7fffc800)\n+#   endif\n+# endif\n+\n+# ifdef RT\n+#   define MACH_TYPE \"RT\"\n+#   define ALIGNMENT 4\n+#   define DATASTART ((ptr_t) 0x10000000)\n+#   define STACKBOTTOM ((ptr_t) 0x1fffd800)\n+# endif\n+\n+# ifdef SPARC\n+#   define MACH_TYPE \"SPARC\"\n+#   define ALIGNMENT 4\t/* Required by hardware\t*/\n+#   define ALIGN_DOUBLE\n+    extern int etext;\n+#   ifdef SUNOS5\n+#\tdefine OS_TYPE \"SUNOS5\"\n+\textern int _etext;\n+\textern int _end;\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#\tdefine DATAEND (&_end)\n+#\tifndef USE_MMAP\n+#\t    define USE_MMAP\n+#\tendif\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x40000000\n+#       else\n+#\t  define HEAP_START DATAEND\n+#       endif\n+#\tdefine PROC_VDB\n+/*\tHEURISTIC1 reportedly no longer works under 2.7.  Thus we\t*/\n+/* \tswitched to HEURISTIC2, eventhough it creates some debugging\t*/\n+/*\tissues.\t\t\t\t\t\t\t\t*/\n+#\tdefine HEURISTIC2\n+#\tinclude <unistd.h>\n+#       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n+\t\t/* getpagesize() appeared to be missing from at least one */\n+\t\t/* Solaris 5.4 installation.  Weird.\t\t\t  */\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef SUNOS4\n+#\tdefine OS_TYPE \"SUNOS4\"\n+\t/* [If you have a weak stomach, don't read this.]\t\t*/\n+\t/* We would like to use:\t\t\t\t\t*/\n+/* #       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1fff) & ~0x1fff)) */\n+\t/* This fails occasionally, due to an ancient, but very \t*/\n+\t/* persistent ld bug.  &etext is set 32 bytes too high.\t\t*/\n+\t/* We instead read the text segment size from the a.out\t\t*/\n+\t/* header, which happens to be mapped into our address space\t*/\n+\t/* at the start of the text segment.  The detective work here\t*/\n+\t/* was done by Robert Ehrlich, Manuel Serrano, and Bernard\t*/\n+\t/* Serpette of INRIA.\t\t\t\t\t\t*/\n+\t/* This assumes ZMAGIC, i.e. demand-loadable executables.\t*/\n+#\tdefine TEXTSTART 0x2000\n+#       define DATASTART ((ptr_t)(*(int *)(TEXTSTART+0x4)+TEXTSTART))\n+#\tdefine MPROTECT_VDB\n+#\tdefine HEURISTIC1\n+# \tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef DRSNX\n+#       define CPP_WORDSZ 32\n+#\tdefine OS_TYPE \"DRSNX\"\n+\textern char * GC_SysVGetDataStart();\n+\textern int etext;\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+#\tdefine MPROTECT_VDB\n+#       define STACKBOTTOM ((ptr_t) 0xdfff0000)\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef LINUX\n+#     define OS_TYPE \"LINUX\"\n+#     ifdef __ELF__\n+#         define DATASTART GC_data_start\n+#         define DYNAMIC_LOADING\n+#     else\n+          Linux Sparc non elf ?\n+#     endif\n+      extern int _end;\n+#     define DATAEND (&_end)\n+#     define SVR4\n+#     define STACKBOTTOM ((ptr_t) 0xf0000000)\n+#   endif\n+# endif\n+\n+# ifdef I386\n+#   define MACH_TYPE \"I386\"\n+#   define ALIGNMENT 4\t/* Appears to hold for all \"32 bit\" compilers\t*/\n+\t\t\t/* except Borland.  The -a4 option fixes \t*/\n+\t\t\t/* Borland.\t\t\t\t\t*/\n+                        /* Ivan Demakov: For Watcom the option is -zp4. */\n+#   ifndef SMALL_CONFIG\n+#     define ALIGN_DOUBLE /* Not strictly necessary, but may give speed   */\n+\t\t\t  /* improvement on Pentiums.\t\t\t  */\n+#   endif\n+#   ifdef SEQUENT\n+#\tdefine OS_TYPE \"SEQUENT\"\n+\textern int etext;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       define STACKBOTTOM ((ptr_t) 0x3ffff000) \n+#   endif\n+#   ifdef SUNOS5\n+#\tdefine OS_TYPE \"SUNOS5\"\n+  \textern int etext, _start;\n+  \textern char * GC_SysVGetDataStart();\n+#       define DATASTART GC_SysVGetDataStart(0x1000, &etext)\n+#\tdefine STACKBOTTOM ((ptr_t)(&_start))\n+/** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n+/*#\tdefine PROC_VDB*/\n+#\tdefine DYNAMIC_LOADING\n+#\tifndef USE_MMAP\n+#\t    define USE_MMAP\n+#\tendif\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x40000000\n+#       else\n+#\t  define HEAP_START DATAEND\n+#       endif\n+#   endif\n+#   ifdef SCO\n+#\tdefine OS_TYPE \"SCO\"\n+\textern int etext;\n+#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\t\t\t\t  & ~0x3fffff) \\\n+\t\t\t\t +((word)&etext & 0xfff))\n+#\tdefine STACKBOTTOM ((ptr_t) 0x7ffffffc)\n+#   endif\n+#   ifdef SCO_ELF\n+#       define OS_TYPE \"SCO_ELF\"\n+        extern int etext;\n+#       define DATASTART ((ptr_t)(&etext))\n+#       define STACKBOTTOM ((ptr_t) 0x08048000)\n+#       define DYNAMIC_LOADING\n+#\tdefine ELF_CLASS ELFCLASS32\n+#   endif\n+#   ifdef LINUX\n+#\tdefine OS_TYPE \"LINUX\"\n+#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n+\t/* Appears to be 0xe0000000 for at least one 2.1.91 kernel.\t*/\n+\t/* Probably needs to be more flexible, but I don't yet \t\t*/\n+\t/* fully understand how flexible.\t\t\t\t*/\n+#       if !defined(LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n+#\t    define MPROTECT_VDB\n+#\telse\n+\t    /* We seem to get random errors in incremental mode,\t*/\n+\t    /* possibly because Linux threads is itself a malloc client */\n+\t    /* and can't deal with the signals.\t\t\t\t*/\n+#\tendif\n+#       ifdef __ELF__\n+#            define DYNAMIC_LOADING\n+#\t     ifdef UNDEFINED\t/* includes ro data */\n+\t       extern int _etext;\n+#              define DATASTART ((ptr_t)((((word) (&_etext)) + 0xfff) & ~0xfff))\n+#\t     endif\n+#\t     include <features.h>\n+#\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n+\t\t extern int __data_start;\n+#\t\t define DATASTART ((ptr_t)(&__data_start))\n+#\t     else\n+     \t         extern char **__environ;\n+#                define DATASTART ((ptr_t)(&__environ))\n+\t\t\t      /* hideous kludge: __environ is the first */\n+\t\t\t      /* word in crt0.o, and delimits the start */\n+\t\t\t      /* of the data segment, no matter which   */\n+\t\t\t      /* ld options were passed through.        */\n+\t\t\t      /* We could use _etext instead, but that  */\n+\t\t\t      /* would include .rodata, which may       */\n+\t\t\t      /* contain large read-only data tables    */\n+\t\t\t      /* that we'd rather not scan.\t\t*/\n+#\t     endif\n+\t     extern int _end;\n+#\t     define DATAEND (&_end)\n+#\telse\n+\t     extern int etext;\n+#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       endif\n+#   endif\n+#   ifdef CYGWIN32\n+#       define OS_TYPE \"CYGWIN32\"\n+          extern int _data_start__;\n+          extern int _data_end__;\n+          extern int _bss_start__;\n+          extern int _bss_end__;\n+  \t/* For binutils 2.9.1, we have\t\t\t*/\n+  \t/*\tDATASTART   = _data_start__\t\t*/\n+  \t/*\tDATAEND\t    = _bss_end__\t\t*/\n+  \t/* whereas for some earlier versions it was\t*/\n+  \t/*\tDATASTART   = _bss_start__\t\t*/\n+  \t/*\tDATAEND\t    = _data_end__\t\t*/\n+  \t/* To get it right for both, we take the\t*/\n+  \t/* minumum/maximum of the two.\t\t\t*/\n+#   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n+#   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n+#       define DATASTART ((ptr_t) MIN(&_data_start__, &_bss_start__))\n+#       define DATAEND\t ((ptr_t) MAX(&_data_end__, &_bss_end__))\n+#\tundef STACK_GRAN\n+#       define STACK_GRAN 0x10000\n+#       define HEURISTIC1\n+#   endif\n+#   ifdef OS2\n+#\tdefine OS_TYPE \"OS2\"\n+ \t    \t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n+\t\t/* os_dep.c. OS2 actually has the right\t\t\t*/\n+\t\t/* system call!\t\t\t\t\t\t*/\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+#   ifdef MSWIN32\n+#\tdefine OS_TYPE \"MSWIN32\"\n+\t\t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n+\t\t/* os_dep.c.\t\t\t\t\t\t*/\n+#       ifndef __WATCOMC__\n+#\t  define MPROTECT_VDB\n+#\tendif\n+#       define DATAEND  /* not needed */\n+#   endif\n+#   ifdef DJGPP\n+#       define OS_TYPE \"DJGPP\"\n+#       include \"stubinfo.h\"\n+        extern int etext;\n+        extern int _stklen;\n+        extern int __djgpp_stack_limit;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1ff) & ~0x1ff))\n+/* #       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \\\n+                                                     + _stklen)) */\n+#       define STACKBOTTOM ((ptr_t)((word) __djgpp_stack_limit + _stklen))\n+\t\t/* This may not be right.  */\n+#   endif\n+#   ifdef OPENBSD\n+#\tdefine OS_TYPE \"OPENBSD\"\n+#   endif\n+#   ifdef FREEBSD\n+#\tdefine OS_TYPE \"FREEBSD\"\n+#\tdefine MPROTECT_VDB\n+#   endif\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#   endif\n+#   ifdef THREE86BSD\n+#\tdefine OS_TYPE \"THREE86BSD\"\n+#   endif\n+#   ifdef BSDI\n+#\tdefine OS_TYPE \"BSDI\"\n+#   endif\n+#   if defined(OPENBSD) || defined(FREEBSD) || defined(NETBSD) \\\n+        || defined(THREE86BSD) || defined(BSDI)\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef NEXT\n+#\tdefine OS_TYPE \"NEXT\"\n+#\tdefine DATASTART ((ptr_t) get_etext())\n+#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+#   ifdef DOS4GW\n+#     define OS_TYPE \"DOS4GW\"\n+      extern long __nullarea;\n+      extern char _end;\n+      extern char *_STACKTOP;\n+      /* Depending on calling conventions Watcom C either precedes\n+         or does not precedes with undescore names of C-variables.\n+         Make sure startup code variables always have the same names.  */\n+      #pragma aux __nullarea \"*\";\n+      #pragma aux _end \"*\";\n+#     define STACKBOTTOM ((ptr_t) _STACKTOP)\n+                         /* confused? me too. */\n+#     define DATASTART ((ptr_t) &__nullarea)\n+#     define DATAEND ((ptr_t) &_end)\n+#   endif\n+# endif\n+\n+# ifdef NS32K\n+#   define MACH_TYPE \"NS32K\"\n+#   define ALIGNMENT 4\n+    extern char **environ;\n+#   define DATASTART ((ptr_t)(&environ))\n+\t\t\t      /* hideous kludge: environ is the first   */\n+\t\t\t      /* word in crt0.o, and delimits the start */\n+\t\t\t      /* of the data segment, no matter which   */\n+\t\t\t      /* ld options were passed through.        */\n+#   define STACKBOTTOM ((ptr_t) 0xfffff000) /* for Encore */\n+# endif\n+\n+# ifdef MIPS\n+#   define MACH_TYPE \"MIPS\"\n+#   ifndef IRIX5\n+#     define DATASTART (ptr_t)0x10000000\n+\t\t\t      /* Could probably be slightly higher since */\n+\t\t\t      /* startup code allocates lots of stuff.   */\n+#   else\n+      extern int _fdata;\n+#     define DATASTART ((ptr_t)(&_fdata))\n+#     ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x30000000\n+#     else\n+#\t  define HEAP_START DATASTART\n+#     endif\n+\t\t\t      /* Lowest plausible heap address.\t\t*/\n+\t\t\t      /* In the MMAP case, we map there.\t*/\n+\t\t\t      /* In either case it is used to identify\t*/\n+\t\t\t      /* heap sections so they're not \t\t*/\n+\t\t\t      /* considered as roots.\t\t\t*/\n+#   endif /* IRIX5 */\n+#   define HEURISTIC2\n+/* #   define STACKBOTTOM ((ptr_t)0x7fff8000)  sometimes also works.  */\n+#   ifdef ULTRIX\n+#\tdefine OS_TYPE \"ULTRIX\"\n+#       define ALIGNMENT 4\n+#   endif\n+#   ifdef RISCOS\n+#\tdefine OS_TYPE \"RISCOS\"\n+#   \tdefine ALIGNMENT 4  /* Required by hardware */\n+#   endif\n+#   ifdef IRIX5\n+#\tdefine OS_TYPE \"IRIX5\"\n+#       define MPROTECT_VDB\n+#       ifdef _MIPS_SZPTR\n+#\t  define CPP_WORDSZ _MIPS_SZPTR\n+#\t  define ALIGNMENT (_MIPS_SZPTR/8)\n+#\t  if CPP_WORDSZ != 64\n+#\t    define ALIGN_DOUBLE\n+#\t  endif\n+#\telse\n+#         define ALIGNMENT 4\n+#\t  define ALIGN_DOUBLE\n+#\tendif\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+# endif\n+\n+# ifdef RS6000\n+#   define MACH_TYPE \"RS6000\"\n+#   define ALIGNMENT 4\n+#   define DATASTART ((ptr_t)0x20000000)\n+    extern int errno;\n+#   define STACKBOTTOM ((ptr_t)((ulong)&errno))\n+#   define DYNAMIC_LOADING\n+\t/* For really old versions of AIX, this may have to be removed. */\n+# endif\n+\n+# ifdef HP_PA\n+#   define MACH_TYPE \"HP_PA\"\n+#   define ALIGNMENT 4\n+#   define ALIGN_DOUBLE\n+    extern int __data_start;\n+#   define DATASTART ((ptr_t)(&__data_start))\n+#   if 0\n+\t/* The following appears to work for 7xx systems running HP/UX\t*/\n+\t/* 9.xx Furthermore, it might result in much faster\t\t*/\n+\t/* collections than HEURISTIC2, which may involve scanning\t*/\n+\t/* segments that directly precede the stack.  It is not the\t*/\n+\t/* default, since it may not work on older machine/OS\t\t*/\n+\t/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering\t*/\n+\t/* this.)\t\t\t\t\t\t\t*/\n+#       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */\n+#   else\n+#       define HEURISTIC2\n+#   endif\n+#   define STACK_GROWS_UP\n+#   define DYNAMIC_LOADING\n+#   include <unistd.h>\n+#   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+\t/* They misspelled the Posix macro?\t*/\n+# endif\n+\n+# ifdef ALPHA\n+#   define MACH_TYPE \"ALPHA\"\n+#   define ALIGNMENT 8\n+#   ifdef OSF1\n+#\tdefine OS_TYPE \"OSF1\"\n+#   \tdefine DATASTART ((ptr_t) 0x140000000)\n+\textern _end;\n+#   \tdefine DATAEND ((ptr_t) &_end)\n+#   \tdefine HEURISTIC2\n+\t/* Normally HEURISTIC2 is too conervative, since\t\t*/\n+\t/* the text segment immediately follows the stack.\t\t*/\n+\t/* Hence we give an upper pound.\t\t\t\t*/\n+    \textern int __start;\n+#   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(&__start) & ~(getpagesize()-1)))\n+#   \tdefine CPP_WORDSZ 64\n+#   \tdefine MPROTECT_VDB\n+#   \tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define CPP_WORDSZ 64\n+#       define STACKBOTTOM ((ptr_t) 0x120000000)\n+#       ifdef __ELF__\n+            extern int __data_start;\n+#           define DATASTART &__data_start\n+#           define DYNAMIC_LOADING\n+#       else\n+#           define DATASTART ((ptr_t) 0x140000000)\n+#       endif\n+\textern int _end;\n+#\tdefine DATAEND (&_end)\n+#\tdefine MPROTECT_VDB\n+\t\t/* Has only been superficially tested.  May not\t*/\n+\t\t/* work on all versions.\t\t\t*/\n+#   endif\n+# endif\n+\n+# ifdef M88K\n+#   define MACH_TYPE \"M88K\"\n+#   define ALIGNMENT 4\n+#   define ALIGN_DOUBLE\n+    extern int etext;\n+#   ifdef CX_UX\n+#\tdefine OS_TYPE \"CX_UX\"\n+#       define DATASTART ((((word)&etext + 0x3fffff) & ~0x3fffff) + 0x10000)\n+#   endif\n+#   ifdef  DGUX\n+#\tdefine OS_TYPE \"DGUX\"\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+#   endif\n+#   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */\n+# endif\n+\n+# ifdef S370\n+#   define MACH_TYPE \"S370\"\n+#   define OS_TYPE \"UTS4\"\n+#   define ALIGNMENT 4\t/* Required by hardware\t*/\n+    extern int etext;\n+\textern int _etext;\n+\textern int _end;\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#\tdefine DATAEND (&_end)\n+#\tdefine HEURISTIC2\n+# endif\n+\n+# ifndef STACK_GROWS_UP\n+#   define STACK_GROWS_DOWN\n+# endif\n+\n+# ifndef CPP_WORDSZ\n+#   define CPP_WORDSZ 32\n+# endif\n+\n+# ifndef OS_TYPE\n+#   define OS_TYPE \"\"\n+# endif\n+\n+# ifndef DATAEND\n+    extern int end;\n+#   define DATAEND (&end)\n+# endif\n+\n+# if defined(SVR4) && !defined(GETPAGESIZE)\n+#    include <unistd.h>\n+#    define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n+# endif\n+\n+# ifndef GETPAGESIZE\n+#   if defined(SUNOS5) || defined(IRIX5)\n+#\tinclude <unistd.h>\n+#   endif\n+#   define GETPAGESIZE() getpagesize()\n+# endif\n+\n+# if defined(SUNOS5) || defined(DRSNX) || defined(UTS4)\n+    /* OS has SVR4 generic features.  Probably others also qualify.\t*/\n+#   define SVR4\n+# endif\n+\n+# if defined(SUNOS5) || defined(DRSNX)\n+    /* OS has SUNOS5 style semi-undocumented interface to dynamic \t*/\n+    /* loader.\t\t\t\t\t\t\t\t*/\n+#   define SUNOS5DL\n+    /* OS has SUNOS5 style signal handlers.\t\t\t\t*/\n+#   define SUNOS5SIGS\n+# endif\n+\n+# if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n+   -> bad word size\n+# endif\n+\n+# ifdef PCR\n+#   undef DYNAMIC_LOADING\n+#   undef STACKBOTTOM\n+#   undef HEURISTIC1\n+#   undef HEURISTIC2\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+#   define PCR_VDB\n+# endif\n+\n+# ifdef SRC_M3\n+/* Postponed for now. */\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+# endif\n+\n+# ifdef SMALL_CONFIG\n+/* Presumably not worth the space it takes. */\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+# endif\n+\n+# if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n+#   define DEFAULT_VDB\n+# endif\n+\n+# if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n+#   define SOLARIS_THREADS\n+# endif\n+# if defined(IRIX_THREADS) && !defined(IRIX5)\n+--> inconsistent configuration\n+# endif\n+# if defined(IRIX_JDK_THREADS) && !defined(IRIX5)\n+--> inconsistent configuration\n+# endif\n+# if defined(LINUX_THREADS) && !defined(LINUX)\n+--> inconsistent configuration\n+# endif\n+# if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n+--> inconsistent configuration\n+# endif\n+# if defined(PCR) || defined(SRC_M3) || \\\n+\tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n+\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n+\tdefined(IRIX_JDK_THREADS)\n+#   define THREADS\n+# endif\n+\n+# if defined(HP_PA) || defined(M88K) || defined(POWERPC) \\\n+     || (defined(I386) && defined(OS2)) || defined(UTS4) || defined(LINT)\n+\t/* Use setjmp based hack to mark from callee-save registers. */\n+#\tdefine USE_GENERIC_PUSH_REGS\n+# endif\n+# if defined(SPARC) && !defined(LINUX)\n+#   define SAVE_CALL_CHAIN\n+#   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n+\t\t\t\t/* include assembly code to do it well.\t*/\n+# endif\n+\n+# endif"}]}