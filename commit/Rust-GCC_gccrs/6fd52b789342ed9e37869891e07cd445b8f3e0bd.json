{"sha": "6fd52b789342ed9e37869891e07cd445b8f3e0bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZkNTJiNzg5MzQyZWQ5ZTM3ODY5ODkxZTA3Y2Q0NDViOGYzZTBiZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-31T11:15:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-31T11:15:51Z"}, "message": "[multiple changes]\n\n2014-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* inline.adb (Has_Excluded_Declaration): With back-end inlining,\n\tonly return true for nested packages.\n\t(Cannot_Inline): Issue errors/warnings whatever the optimization level\n\tfor back-end inlining and remove assertion.\n\n2014-10-31  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* table.adb (Tree_Read, Tree_Write): Use parentheses to specify\n\tthe desired order of '*' and '/' operations to avoid overflow.\n\n2014-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch6.adb (Do_Inline): Remove unreachable code.\n\t(Do_Inline_Always): Likewise.\n\n2014-10-31  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Check_Stand_Alone_Library): Change error message\n\twhen library has no Ada interfaces and Library_Standalone is\n\tdeclared.\n\nFrom-SVN: r216961", "tree": {"sha": "41ad5c7a0b70cedc5ee2342d3332907ba6375fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41ad5c7a0b70cedc5ee2342d3332907ba6375fd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fd52b789342ed9e37869891e07cd445b8f3e0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd52b789342ed9e37869891e07cd445b8f3e0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd52b789342ed9e37869891e07cd445b8f3e0bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd52b789342ed9e37869891e07cd445b8f3e0bd/comments", "author": null, "committer": null, "parents": [{"sha": "d99565f84f00f7edfdfa42fdc490415806ad0e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d99565f84f00f7edfdfa42fdc490415806ad0e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d99565f84f00f7edfdfa42fdc490415806ad0e4b"}], "stats": {"total": 333, "additions": 52, "deletions": 281}, "files": [{"sha": "ec9daba8df53a5c1bbaa8583f222e3bedb394636", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6fd52b789342ed9e37869891e07cd445b8f3e0bd", "patch": "@@ -1,3 +1,26 @@\n+2014-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* inline.adb (Has_Excluded_Declaration): With back-end inlining,\n+\tonly return true for nested packages.\n+\t(Cannot_Inline): Issue errors/warnings whatever the optimization level\n+\tfor back-end inlining and remove assertion.\n+\n+2014-10-31  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* table.adb (Tree_Read, Tree_Write): Use parentheses to specify\n+\tthe desired order of '*' and '/' operations to avoid overflow.\n+\n+2014-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch6.adb (Do_Inline): Remove unreachable code.\n+\t(Do_Inline_Always): Likewise.\n+\n+2014-10-31  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_Stand_Alone_Library): Change error message\n+\twhen library has no Ada interfaces and Library_Standalone is\n+\tdeclared.\n+\n 2014-10-31  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_ch13.adb (Check_Constant_Address_Clause): Disable checks"}, {"sha": "b3f9ab6fc5e84db5d2bf7c471439361bfb924c61", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 4, "deletions": 249, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6fd52b789342ed9e37869891e07cd445b8f3e0bd", "patch": "@@ -1998,19 +1998,6 @@ package body Exp_Ch6 is\n       --  expression for the value of the actual, EF is the entity for the\n       --  extra formal.\n \n-      procedure Do_Inline (Subp : Entity_Id; Orig_Subp : Entity_Id);\n-      --  Check and inline the body of Subp. Invoked when compiling with\n-      --  optimizations enabled and Subp has pragma inline or inline always.\n-      --  If the subprogram is a renaming, or if it is inherited, then Subp\n-      --  references the renamed entity and Orig_Subp is the entity of the\n-      --  call node N.\n-\n-      procedure Do_Inline_Always (Subp : Entity_Id; Orig_Subp : Entity_Id);\n-      --  Check and inline the body of Subp. Invoked when compiling without\n-      --  optimizations and Subp has pragma inline always. If the subprogram is\n-      --  a renaming, or if it is inherited, then Subp references the renamed\n-      --  entity and Orig_Subp is the entity of the call node N.\n-\n       function Inherited_From_Formal (S : Entity_Id) return Entity_Id;\n       --  Within an instance, a type derived from an untagged formal derived\n       --  type inherits from the original parent, not from the actual. The\n@@ -2097,211 +2084,6 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Extra_Actual;\n \n-      ----------------\n-      --  Do_Inline --\n-      ----------------\n-\n-      procedure Do_Inline (Subp : Entity_Id; Orig_Subp : Entity_Id) is\n-         Spec : constant Node_Id := Unit_Declaration_Node (Subp);\n-\n-         procedure Do_Backend_Inline;\n-         --  Check that the call can be safely passed to the backend. If true\n-         --  then register the enclosing unit of Subp to Inlined_Bodies so that\n-         --  the body of Subp can be retrieved and analyzed by the backend.\n-\n-         -----------------------\n-         -- Do_Backend_Inline --\n-         -----------------------\n-\n-         procedure Do_Backend_Inline is\n-         begin\n-            --  No extra test needed for init subprograms since we know they\n-            --  are available to the backend.\n-\n-            if Is_Init_Proc (Subp) then\n-               Add_Inlined_Body (Subp);\n-               Register_Backend_Call (Call_Node);\n-\n-            --  Verify that if the body to inline is located in the current\n-            --  unit the inlining does not occur earlier. This avoids\n-            --  order-of-elaboration problems in the back end.\n-\n-            elsif In_Same_Extended_Unit (Call_Node, Subp)\n-              and then Nkind (Spec) = N_Subprogram_Declaration\n-              and then Earlier_In_Extended_Unit\n-                         (Loc, Sloc (Body_To_Inline (Spec)))\n-            then\n-               Error_Msg_NE\n-                 (\"cannot inline& (body not seen yet)??\", Call_Node, Subp);\n-\n-            else\n-               declare\n-                  Backend_Inline : Boolean := True;\n-\n-               begin\n-                  --  If we are compiling a package body that is not the\n-                  --  main unit, it must be for inlining/instantiation\n-                  --  purposes, in which case we inline the call to insure\n-                  --  that the same temporaries are generated when compiling\n-                  --  the body by itself. Otherwise link errors can occur.\n-\n-                  --  If the function being called is itself in the main\n-                  --  unit, we cannot inline, because there is a risk of\n-                  --  double elaboration and/or circularity: the inlining\n-                  --  can make visible a private entity in the body of the\n-                  --  main unit, that gigi will see before its sees its\n-                  --  proper definition.\n-\n-                  if not (In_Extended_Main_Code_Unit (Call_Node))\n-                    and then In_Package_Body\n-                  then\n-                     Backend_Inline :=\n-                       not In_Extended_Main_Source_Unit (Subp);\n-                  end if;\n-\n-                  if Backend_Inline then\n-                     Add_Inlined_Body (Subp);\n-                     Register_Backend_Call (Call_Node);\n-                  end if;\n-               end;\n-            end if;\n-         end Do_Backend_Inline;\n-\n-      --  Start of processing for Do_Inline\n-\n-      begin\n-         --  Verify that the body to inline has already been seen\n-\n-         if No (Spec)\n-           or else Nkind (Spec) /= N_Subprogram_Declaration\n-           or else No (Body_To_Inline (Spec))\n-         then\n-            if Comes_From_Source (Subp)\n-              and then Must_Inline (Subp)\n-            then\n-               Cannot_Inline\n-                 (\"cannot inline& (body not seen yet)?\", Call_Node, Subp);\n-\n-            --  Let the back end handle it\n-\n-            else\n-               Do_Backend_Inline;\n-               return;\n-            end if;\n-\n-         --  If this an inherited function that returns a private type, do not\n-         --  inline if the full view is an unconstrained array, because such\n-         --  calls cannot be inlined.\n-\n-         elsif Present (Orig_Subp)\n-           and then Is_Array_Type (Etype (Orig_Subp))\n-           and then not Is_Constrained (Etype (Orig_Subp))\n-         then\n-            Cannot_Inline\n-              (\"cannot inline& (unconstrained array)?\", Call_Node, Subp);\n-\n-         else\n-            Expand_Inlined_Call (Call_Node, Subp, Orig_Subp);\n-         end if;\n-      end Do_Inline;\n-\n-      ----------------------\n-      -- Do_Inline_Always --\n-      ----------------------\n-\n-      procedure Do_Inline_Always (Subp : Entity_Id; Orig_Subp : Entity_Id) is\n-         Spec    : constant Node_Id := Unit_Declaration_Node (Subp);\n-         Body_Id : Entity_Id;\n-\n-      begin\n-         if No (Spec)\n-           or else Nkind (Spec) /= N_Subprogram_Declaration\n-           or else No (Body_To_Inline (Spec))\n-           or else Serious_Errors_Detected /= 0\n-         then\n-            return;\n-         end if;\n-\n-         Body_Id := Corresponding_Body (Spec);\n-\n-         --  Verify that the body to inline has already been seen\n-\n-         if No (Body_Id)\n-           or else not Analyzed (Body_Id)\n-         then\n-            Set_Is_Inlined (Subp, False);\n-\n-            if Comes_From_Source (Subp) then\n-\n-               --  Report a warning only if the call is located in the unit of\n-               --  the called subprogram; otherwise it is an error.\n-\n-               if not In_Same_Extended_Unit (Call_Node, Subp) then\n-                  Cannot_Inline\n-                    (\"cannot inline& (body not seen yet)?\", Call_Node, Subp,\n-                     Is_Serious => True);\n-\n-               elsif In_Open_Scopes (Subp) then\n-\n-                  --  For backward compatibility we generate the same error\n-                  --  or warning of the previous implementation. This will\n-                  --  be changed when we definitely incorporate the new\n-                  --  support ???\n-\n-                  if Front_End_Inlining\n-                    and then Optimization_Level = 0\n-                  then\n-                     Error_Msg_N\n-                       (\"call to recursive subprogram cannot be inlined?p?\",\n-                        N);\n-\n-                  --  Do not emit error compiling runtime packages\n-\n-                  elsif Is_Predefined_File_Name\n-                    (Unit_File_Name (Get_Source_Unit (Subp)))\n-                  then\n-                     Error_Msg_N\n-                       (\"call to recursive subprogram cannot be inlined??\",\n-                        N);\n-\n-                  else\n-                     Error_Msg_N\n-                       (\"call to recursive subprogram cannot be inlined\",\n-                        N);\n-                  end if;\n-\n-               else\n-                  Cannot_Inline\n-                    (\"cannot inline& (body not seen yet)?\", Call_Node, Subp);\n-               end if;\n-            end if;\n-\n-            return;\n-\n-         --  If this an inherited function that returns a private type, do not\n-         --  inline if the full view is an unconstrained array, because such\n-         --  calls cannot be inlined.\n-\n-         elsif Present (Orig_Subp)\n-           and then Is_Array_Type (Etype (Orig_Subp))\n-           and then not Is_Constrained (Etype (Orig_Subp))\n-         then\n-            Cannot_Inline\n-              (\"cannot inline& (unconstrained array)?\", Call_Node, Subp);\n-\n-         --  If the called subprogram comes from an instance in the same\n-         --  unit, and the instance is not yet frozen, inlining might\n-         --  trigger order-of-elaboration problems.\n-\n-         elsif In_Unfrozen_Instance (Scope (Subp)) then\n-            Cannot_Inline\n-              (\"cannot inline& (unfrozen instance)?\", Call_Node, Subp);\n-\n-         else\n-            Expand_Inlined_Call (Call_Node, Subp, Orig_Subp);\n-         end if;\n-      end Do_Inline_Always;\n-\n       ---------------------------\n       -- Inherited_From_Formal --\n       ---------------------------\n@@ -3941,39 +3723,12 @@ package body Exp_Ch6 is\n                Set_Needs_Debug_Info (Subp, False);\n             end if;\n \n-         --  Frontend expansion of supported functions returning unconstrained\n-         --  types and simple renamings inlined by the frontend (see Freeze.\n-         --  Build_Renamed_Entity).\n+         --  Front end expansion of simple functions returning unconstrained\n+         --  types (see Check_And_Split_Unconstrained_Function) and simple\n+         --  renamings inlined by the front end (see Build_Renamed_Entity).\n \n          else\n-            declare\n-               Spec : constant Node_Id := Unit_Declaration_Node (Subp);\n-\n-            begin\n-               if Must_Inline (Subp) then\n-                  if In_Extended_Main_Code_Unit (Call_Node)\n-                    and then In_Same_Extended_Unit (Sloc (Spec), Loc)\n-                    and then not Has_Completion (Subp)\n-                  then\n-                     Cannot_Inline\n-                       (\"cannot inline& (body not seen yet)?\",\n-                        Call_Node, Subp);\n-\n-                  else\n-                     Do_Inline_Always (Subp, Orig_Subp);\n-                  end if;\n-\n-               elsif Optimization_Level > 0 then\n-                  Do_Inline (Subp, Orig_Subp);\n-               end if;\n-\n-               --  The call may have been inlined or may have been passed to\n-               --  the backend. No further action needed if it was inlined.\n-\n-               if Nkind (N) /= N_Function_Call then\n-                  return;\n-               end if;\n-            end;\n+            Expand_Inlined_Call (Call_Node, Subp, Orig_Subp);\n          end if;\n       end if;\n "}, {"sha": "dc26d21e13694704806d8a08dc929a848195b2c5", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=6fd52b789342ed9e37869891e07cd445b8f3e0bd", "patch": "@@ -1225,9 +1225,7 @@ package body Inline is\n             Error_Msg_NE (Msg & \"p?\", N, Subp);\n          end if;\n \n-         return;\n-\n-      --  New semantics\n+      --  New semantics relying on back end inlining\n \n       elsif Is_Serious then\n \n@@ -1242,9 +1240,7 @@ package body Inline is\n          Set_Is_Inlined_Always (Subp, False);\n          Error_Msg_NE (Msg & \"p?\", N, Subp);\n \n-      --  Do not issue errors/warnings when compiling with optimizations\n-\n-      elsif Optimization_Level = 0 then\n+      else\n \n          --  Do not emit warning if this is a predefined unit which is not\n          --  the main unit. This behavior is currently provided for backward\n@@ -1281,24 +1277,13 @@ package body Inline is\n \n             Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n \n-         else pragma Assert (Front_End_Inlining);\n+         else\n             Set_Is_Inlined (Subp, False);\n \n-            --  When inlining cannot take place we must issue an error.\n-            --  For backward compatibility we still report a warning.\n-\n             if Ineffective_Inline_Warnings then\n                Error_Msg_NE (Msg & \"p?\", N, Subp);\n             end if;\n          end if;\n-\n-      --  Compiling with optimizations enabled it is too early to report\n-      --  problems since the backend may still perform inlining. In order\n-      --  to report unhandled inlinings the program must be compiled with\n-      --  -Winline and the error is reported by the backend.\n-\n-      else\n-         null;\n       end if;\n    end Cannot_Inline;\n \n@@ -3327,11 +3312,25 @@ package body Inline is\n \n       D := First (Decls);\n       while Present (D) loop\n-         if Nkind (D) = N_Subprogram_Body then\n+         --  First declarations universally excluded\n+\n+         if Nkind (D) = N_Package_Declaration then\n             Cannot_Inline\n-              (\"cannot inline & (nested subprogram)?\",\n+              (\"cannot inline & (nested package declaration)?\",\n+               D, Subp);\n+            return True;\n+\n+         elsif Nkind (D) = N_Package_Instantiation then\n+            Cannot_Inline\n+              (\"cannot inline & (nested package instantiation)?\",\n                D, Subp);\n             return True;\n+         end if;\n+\n+         --  Then declarations excluded only for front end inlining\n+\n+         if Back_End_Inlining then\n+            null;\n \n          elsif Nkind (D) = N_Task_Type_Declaration\n            or else Nkind (D) = N_Single_Task_Declaration\n@@ -3349,9 +3348,9 @@ package body Inline is\n                D, Subp);\n             return True;\n \n-         elsif Nkind (D) = N_Package_Declaration then\n+         elsif Nkind (D) = N_Subprogram_Body then\n             Cannot_Inline\n-              (\"cannot inline & (nested package declaration)?\",\n+              (\"cannot inline & (nested subprogram)?\",\n                D, Subp);\n             return True;\n \n@@ -3368,12 +3367,6 @@ package body Inline is\n               (\"cannot inline & (nested procedure instantiation)?\",\n                D, Subp);\n             return True;\n-\n-         elsif Nkind (D) = N_Package_Instantiation then\n-            Cannot_Inline\n-              (\"cannot inline & (nested package instantiation)?\",\n-               D, Subp);\n-            return True;\n          end if;\n \n          Next (D);"}, {"sha": "b808112e8c92593ce08502dd4d47526360a3b6e0", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=6fd52b789342ed9e37869891e07cd445b8f3e0bd", "patch": "@@ -4711,7 +4711,7 @@ package body Prj.Nmsc is\n          then\n             Error_Msg\n               (Data.Flags,\n-               \"Library_Standalone valid only if Library_Interface is set\",\n+               \"Library_Standalone valid only if library has Ada interfaces\",\n                Lib_Standalone.Location, Project);\n          end if;\n "}, {"sha": "97d0410e6dd449d7c3d787c2c25966019f05c06f", "filename": "gcc/ada/table.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Ftable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd52b789342ed9e37869891e07cd445b8f3e0bd/gcc%2Fada%2Ftable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.adb?ref=6fd52b789342ed9e37869891e07cd445b8f3e0bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -399,7 +399,7 @@ package body Table is\n          Tree_Read_Data\n            (Tree_Get_Table_Address,\n              (Last_Val - Int (First) + 1) *\n-               Table_Type'Component_Size / Storage_Unit);\n+               (Table_Type'Component_Size / Storage_Unit));\n       end Tree_Read;\n \n       ----------------\n@@ -415,7 +415,7 @@ package body Table is\n          Tree_Write_Data\n            (Tree_Get_Table_Address,\n             (Last_Val - Int (First) + 1) *\n-              Table_Type'Component_Size / Storage_Unit);\n+              (Table_Type'Component_Size / Storage_Unit));\n       end Tree_Write;\n \n    begin"}]}