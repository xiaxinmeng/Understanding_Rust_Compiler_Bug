{"sha": "1cb36a981d95f29f37fef511b88a04c48cfa90cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiMzZhOTgxZDk1ZjI5ZjM3ZmVmNTExYjg4YTA0YzQ4Y2ZhOTBjYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-02T22:58:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-02T22:58:04Z"}, "message": "Jakub Jelinek  <jj@ultra.linux.cz>\n\n        * config/sparc/sparc.h (ASM_DECLARE_REGISTER_GLOBAL): New macro.\n        (RTX_OK_FOR_OLO10): Likewise.\n        (GO_IF_LEGITIMATE_ADDRESS): If assembler supports offsetable\n        %lo(), allow it in addresses...\n        (PRINT_OPERAND_ADDRESS): ... and print it appropriately.\n        * config/sparc/sparc.md (sethi_di_medlow_embmedany_pic): sethi %lo()\n        does not make sense.\n        * config/sparc/sparc.c (sparc_hard_reg_printed): New array.\n        (sparc_output_scratch_registers): New function.\n        (output_function_prologue, sparc_flat_output_function_prologue): Use\n        it.\n        * varasm.c (make_decl_rtl): Use ASM_DECLARE_REGISTER_GLOBAL if\n        defined.\n        * tm.texi (ASM_DECLARE_REGISTER_GLOBAL): Document it.\n        * configure.in: Add check for .register pseudo-op support in as and\n        check for offsetable %lo().\n        * acconfig.h: Add templates for the above checks.\n        * configure: Regenerate.\n\nRichard Henderson  <rth@cygnus.com>\n\n        * sparc/linux64.h (TARGET_DEFAULT): Remove MASK_APP_REGS.\n        * sparc/sol2-sld-64.h (TARGET_DEFAULT): Likewise.\n        * sparc/sol2.h (TARGET_DEFAULT): Likewise.\n\nFrom-SVN: r28414", "tree": {"sha": "a4298750822ac9991259b44746e7970194b4f6a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4298750822ac9991259b44746e7970194b4f6a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cb36a981d95f29f37fef511b88a04c48cfa90cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb36a981d95f29f37fef511b88a04c48cfa90cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb36a981d95f29f37fef511b88a04c48cfa90cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb36a981d95f29f37fef511b88a04c48cfa90cc/comments", "author": null, "committer": null, "parents": [{"sha": "e76d23764b387e9636b5d568b62531019f7f2273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e76d23764b387e9636b5d568b62531019f7f2273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e76d23764b387e9636b5d568b62531019f7f2273"}], "stats": {"total": 301, "additions": 277, "deletions": 24}, "files": [{"sha": "315a061272eff205c1e340c0384abfeaf51db849", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -1,3 +1,30 @@\n+1999-08-02  Jakub Jelinek  <jj@ultra.linux.cz>\n+\n+\t* config/sparc/sparc.h (ASM_DECLARE_REGISTER_GLOBAL): New macro.\n+\t(RTX_OK_FOR_OLO10): Likewise.\n+\t(GO_IF_LEGITIMATE_ADDRESS): If assembler supports offsetable\n+\t%lo(), allow it in addresses...\n+\t(PRINT_OPERAND_ADDRESS): ... and print it appropriately.\n+\t* config/sparc/sparc.md (sethi_di_medlow_embmedany_pic): sethi %lo()\n+\tdoes not make sense.\n+\t* config/sparc/sparc.c (sparc_hard_reg_printed): New array.\n+\t(sparc_output_scratch_registers): New function.\n+\t(output_function_prologue, sparc_flat_output_function_prologue): Use\n+\tit.\n+\t* varasm.c (make_decl_rtl): Use ASM_DECLARE_REGISTER_GLOBAL if\n+\tdefined.\n+\t* tm.texi (ASM_DECLARE_REGISTER_GLOBAL): Document it.\n+\t* configure.in: Add check for .register pseudo-op support in as and\n+\tcheck for offsetable %lo().\n+\t* acconfig.h: Add templates for the above checks.\n+\t* configure: Regenerate.\n+\n+1999-08-02  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sparc/linux64.h (TARGET_DEFAULT): Remove MASK_APP_REGS.\n+\t* sparc/sol2-sld-64.h (TARGET_DEFAULT): Likewise.\n+\t* sparc/sol2.h (TARGET_DEFAULT): Likewise.\n+\n Mon Aug  2 23:46:45 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* loop.c (strength_reduce): When doing biv->giv conversion, fix up"}, {"sha": "18fe21155717e0900ba94f4d4c90f79a83047d00", "filename": "gcc/acconfig.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Facconfig.h?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -29,6 +29,12 @@\n /* Define if your assembler supports .balign and .p2align.  */\n #undef HAVE_GAS_BALIGN_AND_P2ALIGN\n \n+/* Define if your assembler supports offsetable %lo().  */\n+#undef HAVE_AS_OFFSETABLE_LO10\n+\n+/* Define if your assembler supports .register.  */\n+#undef HAVE_AS_REGISTER_PSEUDO_OP\n+\n /* Define if your assembler supports .subsection and .subsection -1 starts\n    emitting at the beginning of your section */\n #undef HAVE_GAS_SUBSECTION_ORDERING"}, {"sha": "36216761e30c476f148f3b4d55436de0cea37484", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -41,7 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n   (MASK_V9 + MASK_PTR64 + MASK_64BIT /* + MASK_HARD_QUAD */ \\\n-   + MASK_STACK_BIAS + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n+   + MASK_STACK_BIAS + MASK_EPILOGUE + MASK_FPU)\n #endif\n \n /* Output at beginning of assembler file.  */"}, {"sha": "ac4f53b247b40c9a1cf9d083d146f9935bdf4d10", "filename": "gcc/config/sparc/sol2-sld-64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsol2-sld-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsol2-sld-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2-sld-64.h?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -18,7 +18,7 @@\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n   (MASK_V9 + MASK_PTR64 + MASK_64BIT /* + MASK_HARD_QUAD */ + \\\n-   MASK_STACK_BIAS + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n+   MASK_STACK_BIAS + MASK_EPILOGUE + MASK_FPU)\n #endif\n \n /* The default code model.  */"}, {"sha": "c6091b20747b4108a668a19654f5d3b5c3698761", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -213,7 +213,7 @@ Boston, MA 02111-1307, USA.  */\n /* Solaris allows 64 bit out and global registers in 32 bit mode.\n    sparc_override_options will disable V8+ if not generating V9 code.  */\n #undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU + MASK_V8PLUS)\n+#define TARGET_DEFAULT (MASK_EPILOGUE + MASK_FPU + MASK_V8PLUS)\n \f\n /* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n    traps available which can get and set the condition codes"}, {"sha": "1d3bbc722f91ecce9b2416009b680857aad2ddb1", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -141,6 +141,8 @@ int sparc_align_loops;\n int sparc_align_jumps;\n int sparc_align_funcs;\n \n+char sparc_hard_reg_printed[8];\n+\n struct sparc_cpu_select sparc_select[] =\n {\n   /* switch\tname,\t\ttune\tarch */\n@@ -3108,6 +3110,32 @@ build_big_number (file, num, reg)\n     }\n }\n \n+/* Output any necessary .register pseudo-ops.  */\n+void\n+sparc_output_scratch_registers (file)\n+     FILE *file;\n+{\n+#ifdef HAVE_AS_REGISTER_PSEUDO_OP\n+  int i;\n+\n+  if (TARGET_ARCH32)\n+    return;\n+\n+  /* Check if %g[2367] were used without\n+     .register being printed for them already.  */\n+  for (i = 2; i < 8; i++)\n+    {\n+      if (regs_ever_live [i]\n+\t  && ! sparc_hard_reg_printed [i])\n+\t{\n+\t  sparc_hard_reg_printed [i] = 1;\n+\t  fprintf (file, \"\\t.register\\t%%g%d, #scratch\\n\", i);\n+\t}\n+      if (i == 3) i = 5;\n+    }\n+#endif\n+}\n+\n /* Output code for the function prologue.  */\n \n void\n@@ -3116,6 +3144,8 @@ output_function_prologue (file, size, leaf_function)\n      int size;\n      int leaf_function;\n {\n+  sparc_output_scratch_registers (file);\n+\n   /* Need to use actual_fsize, since we are also allocating\n      space for our callee (and our own register save area).  */\n   actual_fsize = compute_frame_size (size, leaf_function);\n@@ -5849,6 +5879,8 @@ sparc_flat_output_function_prologue (file, size)\n   char *sp_str = reg_names[STACK_POINTER_REGNUM];\n   unsigned long gmask = current_frame_info.gmask;\n \n+  sparc_output_scratch_registers (file);\n+\n   /* This is only for the human reader.  */\n   fprintf (file, \"\\t%s#PROLOGUE# 0\\n\", ASM_COMMENT_START);\n   fprintf (file, \"\\t%s# vars= %ld, regs= %d/%d, args= %d, extra= %ld\\n\","}, {"sha": "e42554dddda931d1db91b4e9f767d95c978d643f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 83, "deletions": 9, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -1822,6 +1822,31 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n } while (0)\n \n+/* Output the special assembly code needed to tell the assembler some\n+   register is used as global register variable.  */\n+\n+#ifdef HAVE_AS_REGISTER_PSEUDO_OP\n+#define ASM_DECLARE_REGISTER_GLOBAL(FILE, DECL, REGNO, NAME)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ARCH64)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int __end = HARD_REGNO_NREGS ((REGNO), DECL_MODE (decl)) + (REGNO); \\\n+      int __reg;\t\t\t\t\t\t\t\\\n+      extern char sparc_hard_reg_printed[8];\t\t\t\t\\\n+      for (__reg = (REGNO); __reg < 8 && __reg < __end; __reg++)\t\\\n+\tif ((__reg & ~1) == 2 || (__reg & ~1) == 6)\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (__reg == (REGNO))\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\t.register\\t%%g%d, %s\\n\", __reg, (NAME)); \\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\t.register\\t%%g%d, .gnu.part%d.%s\\n\",\t\\\n+\t\t       __reg, __reg - (REGNO), (NAME));\t\t\t\\\n+\t    sparc_hard_reg_printed[__reg] = 1;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+#endif\n+\n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to allocate.\n@@ -2233,6 +2258,14 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n        : 0))\n #endif\n \f\n+/* Should gcc use [%reg+%lo(xx)+offset] addresses?  */\n+\n+#ifdef HAVE_AS_OFFSETABLE_LO10\n+#define USE_AS_OFFSETABLE_LO10 1\n+#else\n+#define USE_AS_OFFSETABLE_LO10 0\n+#endif\n+\f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n@@ -2257,6 +2290,9 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n \n #define RTX_OK_FOR_OFFSET_P(X)\t\t\t\t\t\t\\\n   (GET_CODE (X) == CONST_INT && INTVAL (X) >= -0x1000 && INTVAL (X) < 0x1000)\n+  \n+#define RTX_OK_FOR_OLO10_P(X)\t\t\t\t\t\t\\\n+  (GET_CODE (X) == CONST_INT && INTVAL (X) >= -0x1000 && INTVAL (X) < 0xc00 - 8)\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n { if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n@@ -2308,6 +2344,30 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n \t      || RTX_OK_FOR_OFFSET_P (op0))\t\t\\\n \t    goto ADDR;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n+      else if (USE_AS_OFFSETABLE_LO10\t\t\t\\\n+\t       && GET_CODE (op0) == LO_SUM\t\t\\\n+\t       && TARGET_ARCH64\t\t\t\t\\\n+\t       && ! TARGET_CM_MEDMID\t\t\t\\\n+\t       && RTX_OK_FOR_OLO10_P (op1))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  register rtx op00 = XEXP (op0, 0);\t\t\\\n+\t  register rtx op01 = XEXP (op0, 1);\t\t\\\n+\t  if (RTX_OK_FOR_BASE_P (op00)\t\t\t\\\n+\t      && CONSTANT_P (op01))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else if (USE_AS_OFFSETABLE_LO10\t\t\t\\\n+\t       && GET_CODE (op1) == LO_SUM\t\t\\\n+\t       && TARGET_ARCH64\t\t\t\t\\\n+\t       && ! TARGET_CM_MEDMID\t\t\t\\\n+\t       && RTX_OK_FOR_OLO10_P (op0))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  register rtx op10 = XEXP (op1, 0);\t\t\\\n+\t  register rtx op11 = XEXP (op1, 1);\t\t\\\n+\t  if (RTX_OK_FOR_BASE_P (op10)\t\t\t\\\n+\t      && CONSTANT_P (op11))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == LO_SUM)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n@@ -3115,15 +3175,29 @@ do {\t\t\t\t\t\t\t\t\t\\\n \toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\\\n       else\t\t\t\t\t\t\t\\\n \tbase = XEXP (addr, 0), index = XEXP (addr, 1);\t\t\\\n-      fputs (reg_names[REGNO (base)], FILE);\t\t\t\\\n-      if (index == 0)\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"%+d\", offset);\t\t\t\t\\\n-      else if (GET_CODE (index) == REG)\t\t\t\t\\\n-\tfprintf (FILE, \"+%s\", reg_names[REGNO (index)]);\t\\\n-      else if (GET_CODE (index) == SYMBOL_REF\t\t\t\\\n-\t       || GET_CODE (index) == CONST)\t\t\t\\\n-\tfputc ('+', FILE), output_addr_const (FILE, index);\t\\\n-      else abort ();\t\t\t\t\t\t\\\n+      if (GET_CODE (base) == LO_SUM)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (! USE_AS_OFFSETABLE_LO10\t\t\t\t\\\n+\t      || TARGET_ARCH32\t\t\t\t\t\\\n+\t      || TARGET_CM_MEDMID)\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\\\n+\t  output_operand (XEXP (base, 0), 0);\t\t\t\\\n+\t  fputs (\"+%lo(\", FILE);\t\t\t\t\\\n+\t  output_address (XEXP (base, 1));\t\t\t\\\n+\t  fprintf (FILE, \")+%d\", offset);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fputs (reg_names[REGNO (base)], FILE);\t\t\\\n+\t  if (index == 0)\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%+d\", offset);\t\t\t\\\n+\t  else if (GET_CODE (index) == REG)\t\t\t\\\n+\t    fprintf (FILE, \"+%s\", reg_names[REGNO (index)]);\t\\\n+\t  else if (GET_CODE (index) == SYMBOL_REF\t\t\\\n+\t\t   || GET_CODE (index) == CONST)\t\t\\\n+\t    fputc ('+', FILE), output_addr_const (FILE, index);\t\\\n+\t  else abort ();\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (addr) == MINUS\t\t\t\t\\\n \t   && GET_CODE (XEXP (addr, 1)) == LABEL_REF)\t\t\\"}, {"sha": "e8390961dcab407d91617de69c2c12abc9702f0f", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -2495,7 +2495,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (match_operand:DI 1 \"sp64_medium_pic_operand\" \"\")))]\n   \"(TARGET_CM_MEDLOW || TARGET_CM_EMBMEDANY) && check_pic (1)\"\n-  \"sethi\\\\t%%lo(%a1), %0\"\n+  \"sethi\\\\t%%hi(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n "}, {"sha": "634da9aae5985473ba758386180f322783ccd344", "filename": "gcc/configure", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -8325,10 +8325,62 @@ EOF\n fi\n echo \"$ac_t\"\"$gcc_cv_as_subsections\" 1>&6\n \n-echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:8330: checking assembler instructions\" >&5\n-gcc_cv_as_instructions=\n-if test x$gcc_cv_as != x; then\n+case \"$target\" in \n+  sparc*-*-*)\n+    echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n+echo \"configure:8332: checking assembler .register pseudo-op support\" >&5\n+    gcc_cv_as_register_pseudo_op=\n+    if test x$gcc_cv_as != x; then\n+\t# Check if we have .register\n+\techo \".register %g2, #scratch\" > conftest.s\n+\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_register_pseudo_op=yes\n+\t\tcat >> confdefs.h <<\\EOF\n+#define HAVE_AS_REGISTER_PSEUDO_OP 1\n+EOF\n+\n+\tfi\n+\trm -f conftest.s conftest.o\n+    fi\n+    echo \"$ac_t\"\"$gcc_cv_as_register_pseudo_op\" 1>&6\n+\n+    echo $ac_n \"checking assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n+echo \"configure:8349: checking assembler offsetable %lo() support\" >&5\n+    gcc_cv_as_offsetable_lo10=\n+    if test x$gcc_cv_as != x; then\n+\t# Check if assembler has offsetable %lo()\n+\techo \"or %g1, %lo(ab) + 12, %g1\" > conftest.s\n+\techo \"or %g1, %lo(ab + 12), %g1\" > conftest1.s\n+\tgcc_cv_as_flags64=\"-xarch=v9\"\n+\tif ! $gcc_cv_as $gcc_cv_as_flags64 -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_flags64=\"-64\"\n+\t\tif ! $gcc_cv_as $gcc_cv_as_flags64 -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\t\tgcc_cv_as_flags64=\"\"\n+\t\tfi\n+\tfi\n+\tif test -n \"$gcc_cv_as_flags64\" ; then\n+\t\tif $gcc_cv_as $gcc_cv_as_flags64 -o conftest1.o conftest1.s > /dev/null 2>&1; then\n+\t\t\tif cmp conftest.o conftest1.o > /dev/null 2>&1; then\n+\t\t\t\t:\n+\t\t\telse\n+\t\t\t\tgcc_cv_as_offsetable_lo10=yes\n+\t\t\t\tcat >> confdefs.h <<\\EOF\n+#define HAVE_AS_OFFSETABLE_LO10 1\n+EOF\n+\n+\t\t\tfi\n+\t\tfi\n+\tfi\n+\trm -f conftest.s conftest.o conftest1.s conftest1.o\n+    fi\n+    echo \"$ac_t\"\"$gcc_cv_as_offsetable_lo10\" 1>&6\n+    ;;\n+\n+  i[34567]86-*-*)\n+    echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n+echo \"configure:8382: checking assembler instructions\" >&5\n+    gcc_cv_as_instructions=\n+    if test x$gcc_cv_as != x; then\n \tset \"filds fists\" \"filds mem; fists mem\"\n \twhile test $# -gt 0\n   \tdo\n@@ -8343,8 +8395,10 @@ EOF\n \t\tshift 2\n \tdone\n \trm -f conftest.s conftest.o\n-fi\n-echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n+    fi\n+    echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n+    ;;\n+esac\n \n # Figure out what language subdirectories are present.\n # Look if the user specified --enable-languages=\"...\"; if not, use"}, {"sha": "860274827989ed69e54d0ea166b44d10f3a5f5b1", "filename": "gcc/configure.in", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -4153,9 +4153,55 @@ EOF\n fi\n AC_MSG_RESULT($gcc_cv_as_subsections)\n \n-AC_MSG_CHECKING(assembler instructions)\n-gcc_cv_as_instructions=\n-if test x$gcc_cv_as != x; then\n+case \"$target\" in \n+  sparc*-*-*)\n+    AC_MSG_CHECKING(assembler .register pseudo-op support)\n+    gcc_cv_as_register_pseudo_op=\n+    if test x$gcc_cv_as != x; then\n+\t# Check if we have .register\n+\techo \".register %g2, #scratch\" > conftest.s\n+\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_register_pseudo_op=yes\n+\t\tAC_DEFINE(HAVE_AS_REGISTER_PSEUDO_OP)\n+\tfi\n+\trm -f conftest.s conftest.o\n+    fi\n+    AC_MSG_RESULT($gcc_cv_as_register_pseudo_op)\n+\n+    AC_MSG_CHECKING([assembler offsetable %lo() support])\n+    gcc_cv_as_offsetable_lo10=\n+    if test x$gcc_cv_as != x; then\n+\t# Check if assembler has offsetable %lo()\n+\techo \"or %g1, %lo(ab) + 12, %g1\" > conftest.s\n+\techo \"or %g1, %lo(ab + 12), %g1\" > conftest1.s\n+\tgcc_cv_as_flags64=\"-xarch=v9\"\n+\tif ! $gcc_cv_as $gcc_cv_as_flags64 -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_flags64=\"-64\"\n+\t\tif ! $gcc_cv_as $gcc_cv_as_flags64 -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\t\tgcc_cv_as_flags64=\"\"\n+\t\tfi\n+\tfi\n+\tif test -n \"$gcc_cv_as_flags64\" ; then\n+\t\tif $gcc_cv_as $gcc_cv_as_flags64 -o conftest1.o conftest1.s > /dev/null 2>&1; then\n+\t\t\tif cmp conftest.o conftest1.o > /dev/null 2>&1; then\n+\t\t\t\t:\n+\t\t\telse\n+\t\t\t\tgcc_cv_as_offsetable_lo10=yes\n+\t\t\t\tAC_DEFINE(HAVE_AS_OFFSETABLE_LO10)\n+\t\t\tfi\n+\t\tfi\n+\tfi\n+\trm -f conftest.s conftest.o conftest1.s conftest1.o\n+    fi\n+    AC_MSG_RESULT($gcc_cv_as_offsetable_lo10)\n+    ;;\n+\n+changequote(,)dnl\n+  i[34567]86-*-*)\n+changequote([,])dnl\n+    AC_MSG_CHECKING(assembler instructions)\n+    gcc_cv_as_instructions=\n+    if test x$gcc_cv_as != x; then\n \tset \"filds fists\" \"filds mem; fists mem\"\n \twhile test $# -gt 0\n   \tdo\n@@ -4167,8 +4213,10 @@ if test x$gcc_cv_as != x; then\n \t\tshift 2\n \tdone\n \trm -f conftest.s conftest.o\n-fi\n-AC_MSG_RESULT($gcc_cv_as_instructions)\n+    fi\n+    AC_MSG_RESULT($gcc_cv_as_instructions)\n+    ;;\n+esac\n \n # Figure out what language subdirectories are present.\n # Look if the user specified --enable-languages=\"...\"; if not, use"}, {"sha": "32593d9c7a5767df87d6877e875989acf531b966", "filename": "gcc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -5591,6 +5591,15 @@ label definition (perhaps using @code{ASM_OUTPUT_LABEL}).  The argument\n If this macro is not defined, then the variable name is defined in the\n usual manner as a label (by means of @code{ASM_OUTPUT_LABEL}).\n \n+@findex ASM_DECLARE_REGISTER_GLOBAL\n+@item ASM_DECLARE_REGISTER_GLOBAL (@var{stream}, @var{decl}, @var{regno}, @var{name})\n+A C statement (sans semicolon) to output to the stdio stream\n+@var{stream} any text necessary for claiming a register @var{regno}\n+for a global variable @var{decl} with name @var{name}.\n+\n+If you don't define this macro, that is equivalent to defining it to do\n+nothing.\n+\n @findex  ASM_FINISH_DECLARE_OBJECT\n @item ASM_FINISH_DECLARE_OBJECT (@var{stream}, @var{decl}, @var{toplevel}, @var{atend})\n A C statement (sans semicolon) to finish up declaring a variable name"}, {"sha": "e429cd285fc41fd323507939bb435dec9e2aa028", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb36a981d95f29f37fef511b88a04c48cfa90cc/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=1cb36a981d95f29f37fef511b88a04c48cfa90cc", "patch": "@@ -704,6 +704,9 @@ make_decl_rtl (decl, asmspec, top_level)\n \t    {\n \t      /* Make this register global, so not usable for anything\n \t\t else.  */\n+#ifdef ASM_DECLARE_REGISTER_GLOBAL\n+\t      ASM_DECLARE_REGISTER_GLOBAL (asm_out_file, decl, reg_number, name);\n+#endif\n \t      nregs = HARD_REGNO_NREGS (reg_number, DECL_MODE (decl));\n \t      while (nregs > 0)\n \t\tglobalize_reg (reg_number + --nregs);"}]}