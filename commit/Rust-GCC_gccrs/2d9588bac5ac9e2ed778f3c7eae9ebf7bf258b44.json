{"sha": "2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ5NTg4YmFjNWFjOWUyZWQ3NzhmM2M3ZWFlOWViZjdiZjI1OGI0NA==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-07-21T05:22:05Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-07-21T05:22:56Z"}, "message": "predcom: Refactor more using auto_vec\n\nThis patch follows Martin's suggestion at the link[1] to do more\nrefactorings by:\n  - Adding m_ prefix for class pcom_worker member variables.\n  - Using auto_vec instead of vec among class pcom_worker,\n    chain, component and comp_ptrs.\n\nThe changes in tree-data-ref.[ch] is required, without it the\ndestruction of auto_vec instance could try to double free the\nmemory pointed by m_vec.\n\nBootstrapped and regtested on powerpc64le-linux-gnu P9,\nx86_64-redhat-linux and aarch64-linux-gnu, also\nbootstrapped on ppc64le P9 with bootstrap-O3 config.\n\n[1] https://gcc.gnu.org/pipermail/gcc-patches/2021-June/573424.html\n\ngcc/ChangeLog:\n\n\t* tree-data-ref.c (free_dependence_relations): Adjust to pass vec\n\tby reference.\n\t(free_data_refs): Likewise.\n\t* tree-data-ref.h (free_dependence_relations): Likewise.\n\t(free_data_refs): Likewise.\n\t* tree-predcom.c (struct chain): Use auto_vec instead of vec for\n\tmembers.\n\t(struct component): Likewise.\n\t(pcom_worker::pcom_worker): Adjust for auto_vec and renaming changes.\n\t(pcom_worker::~pcom_worker): Likewise.\n\t(pcom_worker::release_chain): Adjust as auto_vec changes.\n\t(pcom_worker::loop): Rename to ...\n\t(pcom_worker::m_loop): ... this.\n\t(pcom_worker::datarefs): Rename to ...\n\t(pcom_worker::m_datarefs): ... this.  Use auto_vec instead of vec.\n\t(pcom_worker::dependences): Rename to ...\n\t(pcom_worker::m_dependences): ... this.  Use auto_vec instead of vec.\n\t(pcom_worker::chains): Rename to ...\n\t(pcom_worker::m_chains): ... this.  Use auto_vec instead of vec.\n\t(pcom_worker::looparound_phis): Rename to ...\n\t(pcom_worker::m_looparound_phis): ... this.  Use auto_vec instead of\n\tvec.\n\t(pcom_worker::cache): Rename to ...\n\t(pcom_worker::m_cache): ... this.  Use auto_vec instead of vec.\n\t(pcom_worker::release_chain): Adjust for auto_vec changes.\n\t(pcom_worker::release_chains): Adjust for auto_vec and renaming\n\tchanges.\n\t(release_component): Remove.\n\t(release_components): Adjust for release_component removal.\n\t(component_of): Adjust to use vec.\n\t(merge_comps): Likewise.\n\t(pcom_worker::aff_combination_dr_offset): Adjust for renaming changes.\n\t(pcom_worker::determine_offset): Likewise.\n\t(class comp_ptrs): Remove.\n\t(pcom_worker::split_data_refs_to_components): Adjust for renaming\n\tchanges, for comp_ptrs removal with auto_vec.\n\t(pcom_worker::suitable_component_p): Adjust for renaming changes.\n\t(pcom_worker::filter_suitable_components): Adjust for release_component\n\tremoval.\n\t(pcom_worker::valid_initializer_p): Adjust for renaming changes.\n\t(pcom_worker::find_looparound_phi): Likewise.\n\t(pcom_worker::add_looparound_copies): Likewise.\n\t(pcom_worker::determine_roots_comp): Likewise.\n\t(pcom_worker::single_nonlooparound_use): Likewise.\n\t(pcom_worker::execute_pred_commoning_chain): Likewise.\n\t(pcom_worker::execute_pred_commoning): Likewise.\n\t(pcom_worker::try_combine_chains): Likewise.\n\t(pcom_worker::prepare_initializers_chain): Likewise.\n\t(pcom_worker::prepare_initializers): Likewise.\n\t(pcom_worker::prepare_finalizers_chain): Likewise.\n\t(pcom_worker::prepare_finalizers): Likewise.\n\t(pcom_worker::tree_predictive_commoning_loop): Likewise.", "tree": {"sha": "1bbb2c7f349c75faf5a72541a4dec8ecde804732", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bbb2c7f349c75faf5a72541a4dec8ecde804732"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92d4550991de7e0970a38939422b31e9dc07dd11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d4550991de7e0970a38939422b31e9dc07dd11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d4550991de7e0970a38939422b31e9dc07dd11"}], "stats": {"total": 256, "additions": 108, "deletions": 148}, "files": [{"sha": "b6f782848854669d1f5ad9ce6fa5721e16e17e3e", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "patch": "@@ -6208,7 +6208,7 @@ free_dependence_relation (struct data_dependence_relation *ddr)\n    DEPENDENCE_RELATIONS.  */\n \n void\n-free_dependence_relations (vec<ddr_p> dependence_relations)\n+free_dependence_relations (vec<ddr_p>& dependence_relations)\n {\n   for (data_dependence_relation *ddr : dependence_relations)\n     if (ddr)\n@@ -6220,7 +6220,7 @@ free_dependence_relations (vec<ddr_p> dependence_relations)\n /* Free the memory used by the data references from DATAREFS.  */\n \n void\n-free_data_refs (vec<data_reference_p> datarefs)\n+free_data_refs (vec<data_reference_p>& datarefs)\n {\n   for (data_reference *dr : datarefs)\n     free_data_ref (dr);"}, {"sha": "de45f25611c9f1969002398c985f7af5793e44b3", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "patch": "@@ -534,9 +534,9 @@ extern void debug (vec<ddr_p> &ref);\n extern void debug (vec<ddr_p> *ptr);\n extern void debug_data_dependence_relations (vec<ddr_p> );\n extern void free_dependence_relation (struct data_dependence_relation *);\n-extern void free_dependence_relations (vec<ddr_p> );\n+extern void free_dependence_relations (vec<ddr_p>& );\n extern void free_data_ref (data_reference_p);\n-extern void free_data_refs (vec<data_reference_p> );\n+extern void free_data_refs (vec<data_reference_p>& );\n extern opt_result find_data_references_in_stmt (class loop *, gimple *,\n \t\t\t\t\t\tvec<data_reference_p> *);\n extern bool graphite_find_data_references_in_stmt (edge, loop_p, gimple *,"}, {"sha": "cf85517e1c7717b44dd20dac1ebaebb7a210769b", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 104, "deletions": 144, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "patch": "@@ -306,19 +306,19 @@ typedef struct chain\n   struct chain *ch1, *ch2;\n \n   /* The references in the chain.  */\n-  vec<dref> refs;\n+  auto_vec<dref> refs;\n \n   /* The maximum distance of the reference in the chain from the root.  */\n   unsigned length;\n \n   /* The variables used to copy the value throughout iterations.  */\n-  vec<tree> vars;\n+  auto_vec<tree> vars;\n \n   /* Initializers for the variables.  */\n-  vec<tree> inits;\n+  auto_vec<tree> inits;\n \n   /* Finalizers for the eliminated stores.  */\n-  vec<tree> finis;\n+  auto_vec<tree> finis;\n \n   /* gimple stmts intializing the initial variables of the chain.  */\n   gimple_seq init_seq;\n@@ -362,7 +362,7 @@ enum ref_step_type\n struct component\n {\n   /* The references in the component.  */\n-  vec<dref> refs;\n+  auto_vec<dref> refs;\n \n   /* What we know about the step of the references in the component.  */\n   enum ref_step_type comp_step;\n@@ -381,17 +381,13 @@ struct component\n class pcom_worker\n {\n public:\n-  pcom_worker (loop_p l) : loop (l), chains (vNULL), cache (NULL)\n-  {\n-    dependences.create (10);\n-    datarefs.create (10);\n-  }\n+  pcom_worker (loop_p l) : m_loop (l), m_cache (NULL) {}\n \n   ~pcom_worker ()\n   {\n-    free_data_refs (datarefs);\n-    free_dependence_relations (dependences);\n-    free_affine_expand_cache (&cache);\n+    free_data_refs (m_datarefs);\n+    free_dependence_relations (m_dependences);\n+    free_affine_expand_cache (&m_cache);\n     release_chains ();\n   }\n \n@@ -407,23 +403,24 @@ class pcom_worker\n \n private:\n   /* The pointer to the given loop.  */\n-  loop_p loop;\n+  loop_p m_loop;\n \n   /* All data references.  */\n-  vec<data_reference_p> datarefs;\n+  auto_vec<data_reference_p, 10> m_datarefs;\n \n   /* All data dependences.  */\n-  vec<ddr_p> dependences;\n+  auto_vec<ddr_p, 10> m_dependences;\n \n   /* All chains.  */\n-  vec<chain_p> chains;\n+  auto_vec<chain_p> m_chains;\n \n   /* Bitmap of ssa names defined by looparound phi nodes covered by chains.  */\n-  auto_bitmap looparound_phis;\n+  auto_bitmap m_looparound_phis;\n \n   typedef hash_map<tree, name_expansion *> tree_expand_map_t;\n   /* Cache used by tree_to_aff_combination_expand.  */\n-  tree_expand_map_t *cache;\n+  tree_expand_map_t *m_cache;\n+\n   /* Splits dependence graph to components.  */\n   struct component *split_data_refs_to_components ();\n \n@@ -695,13 +692,9 @@ pcom_worker::release_chain (chain_p chain)\n   FOR_EACH_VEC_ELT (chain->refs, i, ref)\n     free (ref);\n \n-  chain->refs.release ();\n-  chain->vars.release ();\n-  chain->inits.release ();\n   if (chain->init_seq)\n     gimple_seq_discard (chain->init_seq);\n \n-  chain->finis.release ();\n   if (chain->fini_seq)\n     gimple_seq_discard (chain->fini_seq);\n \n@@ -716,18 +709,8 @@ pcom_worker::release_chains ()\n   unsigned i;\n   chain_p chain;\n \n-  FOR_EACH_VEC_ELT (chains, i, chain)\n+  FOR_EACH_VEC_ELT (m_chains, i, chain)\n     release_chain (chain);\n-  chains.release ();\n-}\n-\n-/* Frees a component COMP.  */\n-\n-static void\n-release_component (struct component *comp)\n-{\n-  comp->refs.release ();\n-  free (comp);\n }\n \n /* Frees list of components COMPS.  */\n@@ -740,15 +723,15 @@ release_components (struct component *comps)\n   for (act = comps; act; act = next)\n     {\n       next = act->next;\n-      release_component (act);\n+      XDELETE (act);\n     }\n }\n \n /* Finds a root of tree given by FATHERS containing A, and performs path\n    shortening.  */\n \n static unsigned\n-component_of (unsigned fathers[], unsigned a)\n+component_of (vec<unsigned> &fathers, unsigned a)\n {\n   unsigned root, n;\n \n@@ -768,7 +751,8 @@ component_of (unsigned fathers[], unsigned a)\n    components, A and B are components to merge.  */\n \n static void\n-merge_comps (unsigned fathers[], unsigned sizes[], unsigned a, unsigned b)\n+merge_comps (vec<unsigned> &fathers, vec<unsigned> &sizes,\n+\t     unsigned a, unsigned b)\n {\n   unsigned ca = component_of (fathers, a);\n   unsigned cb = component_of (fathers, b);\n@@ -822,7 +806,7 @@ pcom_worker::aff_combination_dr_offset (struct data_reference *dr,\n   tree type = TREE_TYPE (DR_OFFSET (dr));\n   aff_tree delta;\n \n-  tree_to_aff_combination_expand (DR_OFFSET (dr), type, offset, &cache);\n+  tree_to_aff_combination_expand (DR_OFFSET (dr), type, offset, &m_cache);\n   aff_combination_const (&delta, type, wi::to_poly_widest (DR_INIT (dr)));\n   aff_combination_add (offset, &delta);\n }\n@@ -869,7 +853,7 @@ pcom_worker::determine_offset (struct data_reference *a,\n   aff_combination_add (&diff, &baseb);\n \n   tree_to_aff_combination_expand (DR_STEP (a), TREE_TYPE (DR_STEP (a)),\n-\t\t\t\t  &step, &cache);\n+\t\t\t\t  &step, &m_cache);\n   return aff_combination_constant_multiple_p (&diff, &step, off);\n }\n \n@@ -890,50 +874,28 @@ last_always_executed_block (class loop *loop)\n   return last;\n }\n \n-/* RAII class for comp_father and comp_size usage.  */\n-\n-class comp_ptrs\n-{\n-public:\n-  unsigned *comp_father;\n-  unsigned *comp_size;\n-\n-  comp_ptrs (unsigned n)\n-  {\n-    comp_father = XNEWVEC (unsigned, n + 1);\n-    comp_size = XNEWVEC (unsigned, n + 1);\n-  }\n-\n-  ~comp_ptrs ()\n-  {\n-    free (comp_father);\n-    free (comp_size);\n-  }\n-\n-  comp_ptrs (const comp_ptrs &) = delete;\n-  comp_ptrs &operator= (const comp_ptrs &) = delete;\n-};\n-\n /* Splits dependence graph on DATAREFS described by DEPENDENCES to\n    components.  */\n \n struct component *\n pcom_worker::split_data_refs_to_components ()\n {\n-  unsigned i, n = datarefs.length ();\n+  unsigned i, n = m_datarefs.length ();\n   unsigned ca, ia, ib, bad;\n-  comp_ptrs ptrs (n);\n-  struct component **comps;\n   struct data_reference *dr, *dra, *drb;\n   struct data_dependence_relation *ddr;\n   struct component *comp_list = NULL, *comp;\n   dref dataref;\n   /* Don't do store elimination if loop has multiple exit edges.  */\n-  bool eliminate_store_p = single_exit (loop) != NULL;\n-  basic_block last_always_executed = last_always_executed_block (loop);\n+  bool eliminate_store_p = single_exit (m_loop) != NULL;\n+  basic_block last_always_executed = last_always_executed_block (m_loop);\n   auto_bitmap no_store_store_comps;\n+  auto_vec<unsigned> comp_father (n + 1);\n+  auto_vec<unsigned> comp_size (n + 1);\n+  comp_father.quick_grow (n + 1);\n+  comp_size.quick_grow (n + 1);\n \n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+  FOR_EACH_VEC_ELT (m_datarefs, i, dr)\n     {\n       if (!DR_REF (dr))\n \t  /* A fake reference for call or asm_expr that may clobber memory;\n@@ -943,26 +905,26 @@ pcom_worker::split_data_refs_to_components ()\n       if (is_gimple_call (DR_STMT (dr)))\n \treturn NULL;\n       dr->aux = (void *) (size_t) i;\n-      ptrs.comp_father[i] = i;\n-      ptrs.comp_size[i] = 1;\n+      comp_father[i] = i;\n+      comp_size[i] = 1;\n     }\n \n   /* A component reserved for the \"bad\" data references.  */\n-  ptrs.comp_father[n] = n;\n-  ptrs.comp_size[n] = 1;\n+  comp_father[n] = n;\n+  comp_size[n] = 1;\n \n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+  FOR_EACH_VEC_ELT (m_datarefs, i, dr)\n     {\n       enum ref_step_type dummy;\n \n       if (!suitable_reference_p (dr, &dummy))\n \t{\n \t  ia = (unsigned) (size_t) dr->aux;\n-\t  merge_comps (ptrs.comp_father, ptrs.comp_size, n, ia);\n+\t  merge_comps (comp_father, comp_size, n, ia);\n \t}\n     }\n \n-  FOR_EACH_VEC_ELT (dependences, i, ddr)\n+  FOR_EACH_VEC_ELT (m_dependences, i, ddr)\n     {\n       poly_widest_int dummy_off;\n \n@@ -979,12 +941,12 @@ pcom_worker::split_data_refs_to_components ()\n \t      || DDR_NUM_DIST_VECTS (ddr) == 0))\n \teliminate_store_p = false;\n \n-      ia = component_of (ptrs.comp_father, (unsigned) (size_t) dra->aux);\n-      ib = component_of (ptrs.comp_father, (unsigned) (size_t) drb->aux);\n+      ia = component_of (comp_father, (unsigned) (size_t) dra->aux);\n+      ib = component_of (comp_father, (unsigned) (size_t) drb->aux);\n       if (ia == ib)\n \tcontinue;\n \n-      bad = component_of (ptrs.comp_father, n);\n+      bad = component_of (comp_father, n);\n \n       /* If both A and B are reads, we may ignore unsuitable dependences.  */\n       if (DR_IS_READ (dra) && DR_IS_READ (drb))\n@@ -1008,7 +970,7 @@ pcom_worker::split_data_refs_to_components ()\n \t  else if (!determine_offset (dra, drb, &dummy_off))\n \t    {\n \t      bitmap_set_bit (no_store_store_comps, ib);\n-\t      merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ia);\n+\t      merge_comps (comp_father, comp_size, bad, ia);\n \t      continue;\n \t    }\n \t}\n@@ -1022,46 +984,47 @@ pcom_worker::split_data_refs_to_components ()\n \t  else if (!determine_offset (dra, drb, &dummy_off))\n \t    {\n \t      bitmap_set_bit (no_store_store_comps, ia);\n-\t      merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ib);\n+\t      merge_comps (comp_father, comp_size, bad, ib);\n \t      continue;\n \t    }\n \t}\n       else if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb)\n \t       && ia != bad && ib != bad\n \t       && !determine_offset (dra, drb, &dummy_off))\n \t{\n-\t  merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ia);\n-\t  merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ib);\n+\t  merge_comps (comp_father, comp_size, bad, ia);\n+\t  merge_comps (comp_father, comp_size, bad, ib);\n \t  continue;\n \t}\n \n-      merge_comps (ptrs.comp_father, ptrs.comp_size, ia, ib);\n+      merge_comps (comp_father, comp_size, ia, ib);\n     }\n \n   if (eliminate_store_p)\n     {\n-      tree niters = number_of_latch_executions (loop);\n+      tree niters = number_of_latch_executions (m_loop);\n \n       /* Don't do store elimination if niters info is unknown because stores\n \t in the last iteration can't be eliminated and we need to recover it\n \t after loop.  */\n       eliminate_store_p = (niters != NULL_TREE && niters != chrec_dont_know);\n     }\n \n-  comps = XCNEWVEC (struct component *, n);\n-  bad = component_of (ptrs.comp_father, n);\n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+  auto_vec<struct component *> comps;\n+  comps.safe_grow_cleared (n, true);\n+  bad = component_of (comp_father, n);\n+  FOR_EACH_VEC_ELT (m_datarefs, i, dr)\n     {\n       ia = (unsigned) (size_t) dr->aux;\n-      ca = component_of (ptrs.comp_father, ia);\n+      ca = component_of (comp_father, ia);\n       if (ca == bad)\n \tcontinue;\n \n       comp = comps[ca];\n       if (!comp)\n \t{\n \t  comp = XCNEW (struct component);\n-\t  comp->refs.create (ptrs.comp_size[ca]);\n+\t  comp->refs.create (comp_size[ca]);\n \t  comp->eliminate_store_p = eliminate_store_p;\n \t  comps[ca] = comp;\n \t}\n@@ -1084,7 +1047,7 @@ pcom_worker::split_data_refs_to_components ()\n       bitmap_iterator bi;\n       EXECUTE_IF_SET_IN_BITMAP (no_store_store_comps, 0, ia, bi)\n \t{\n-\t  ca = component_of (ptrs.comp_father, ia);\n+\t  ca = component_of (comp_father, ia);\n \t  if (ca != bad)\n \t    comps[ca]->eliminate_store_p = false;\n \t}\n@@ -1099,7 +1062,6 @@ pcom_worker::split_data_refs_to_components ()\n \t  comp_list = comp;\n \t}\n     }\n-  free (comps);\n   return comp_list;\n }\n \n@@ -1111,14 +1073,14 @@ pcom_worker::suitable_component_p (struct component *comp)\n {\n   unsigned i;\n   dref a, first;\n-  basic_block ba, bp = loop->header;\n+  basic_block ba, bp = m_loop->header;\n   bool ok, has_write = false;\n \n   FOR_EACH_VEC_ELT (comp->refs, i, a)\n     {\n       ba = gimple_bb (a->stmt);\n \n-      if (!just_once_each_iteration_p (loop, ba))\n+      if (!just_once_each_iteration_p (m_loop, ba))\n \treturn false;\n \n       gcc_assert (dominated_by_p (CDI_DOMINATORS, ba, bp));\n@@ -1180,7 +1142,7 @@ pcom_worker::filter_suitable_components (struct component *comps)\n \t  *comp = act->next;\n \t  FOR_EACH_VEC_ELT (act->refs, i, ref)\n \t    free (ref);\n-\t  release_component (act);\n+\t  XDELETE (act);\n \t}\n     }\n \n@@ -1392,7 +1354,7 @@ pcom_worker::valid_initializer_p (struct data_reference *ref, unsigned distance,\n   aff_combination_add (&diff, &base);\n \n   tree_to_aff_combination_expand (DR_STEP (root), TREE_TYPE (DR_STEP (root)),\n-\t\t\t\t  &step, &cache);\n+\t\t\t\t  &step, &m_cache);\n   if (!aff_combination_constant_multiple_p (&diff, &step, &off))\n     return false;\n \n@@ -1413,7 +1375,7 @@ pcom_worker::find_looparound_phi (dref ref, dref root)\n   tree name, init, init_ref;\n   gphi *phi = NULL;\n   gimple *init_stmt;\n-  edge latch = loop_latch_edge (loop);\n+  edge latch = loop_latch_edge (m_loop);\n   struct data_reference init_dr;\n   gphi_iterator psi;\n \n@@ -1429,7 +1391,7 @@ pcom_worker::find_looparound_phi (dref ref, dref root)\n   if (!name)\n     return NULL;\n \n-  for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n+  for (psi = gsi_start_phis (m_loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n       phi = psi.phi ();\n       if (PHI_ARG_DEF_FROM_EDGE (phi, latch) == name)\n@@ -1439,7 +1401,7 @@ pcom_worker::find_looparound_phi (dref ref, dref root)\n   if (gsi_end_p (psi))\n     return NULL;\n \n-  init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n+  init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (m_loop));\n   if (TREE_CODE (init) != SSA_NAME)\n     return NULL;\n   init_stmt = SSA_NAME_DEF_STMT (init);\n@@ -1457,7 +1419,7 @@ pcom_worker::find_looparound_phi (dref ref, dref root)\n   memset (&init_dr, 0, sizeof (struct data_reference));\n   DR_REF (&init_dr) = init_ref;\n   DR_STMT (&init_dr) = phi;\n-  if (!dr_analyze_innermost (&DR_INNERMOST (&init_dr), init_ref, loop,\n+  if (!dr_analyze_innermost (&DR_INNERMOST (&init_dr), init_ref, m_loop,\n \t\t\t     init_stmt))\n     return NULL;\n \n@@ -1512,7 +1474,7 @@ pcom_worker::add_looparound_copies (chain_p chain)\n       if (!phi)\n \tcontinue;\n \n-      bitmap_set_bit (looparound_phis, SSA_NAME_VERSION (PHI_RESULT (phi)));\n+      bitmap_set_bit (m_looparound_phis, SSA_NAME_VERSION (PHI_RESULT (phi)));\n       insert_looparound_copy (chain, ref, phi);\n     }\n }\n@@ -1533,7 +1495,7 @@ pcom_worker::determine_roots_comp (struct component *comp)\n   if (comp->comp_step == RS_INVARIANT)\n     {\n       chain = make_invariant_chain (comp);\n-      chains.safe_push (chain);\n+      m_chains.safe_push (chain);\n       return;\n     }\n \n@@ -1578,7 +1540,7 @@ pcom_worker::determine_roots_comp (struct component *comp)\n \t  if (nontrivial_chain_p (chain))\n \t    {\n \t      add_looparound_copies (chain);\n-\t      chains.safe_push (chain);\n+\t      m_chains.safe_push (chain);\n \t    }\n \t  else\n \t    release_chain (chain);\n@@ -1599,7 +1561,7 @@ pcom_worker::determine_roots_comp (struct component *comp)\n   if (nontrivial_chain_p (chain))\n     {\n       add_looparound_copies (chain);\n-      chains.safe_push (chain);\n+      m_chains.safe_push (chain);\n     }\n   else\n     release_chain (chain);\n@@ -2196,7 +2158,7 @@ pcom_worker::single_nonlooparound_use (tree name)\n \t{\n \t  /* Ignore uses in looparound phi nodes.  Uses in other phi nodes\n \t     could not be processed anyway, so just fail for them.  */\n-\t  if (bitmap_bit_p (looparound_phis,\n+\t  if (bitmap_bit_p (m_looparound_phis,\n \t\t\t    SSA_NAME_VERSION (PHI_RESULT (stmt))))\n \t    continue;\n \n@@ -2305,14 +2267,14 @@ pcom_worker::execute_pred_commoning_chain (chain_p chain,\n \t      /* If dead stores in this chain store loop variant values,\n \t\t we need to set up the variables by loading from memory\n \t\t before loop and propagating it with PHI nodes.  */\n-\t      initialize_root_vars_store_elim_2 (loop, chain, tmp_vars);\n+\t      initialize_root_vars_store_elim_2 (m_loop, chain, tmp_vars);\n \t    }\n \n \t  /* For inter-iteration store elimination chain, stores at each\n \t     distance in loop's last (chain->length - 1) iterations can't\n \t     be eliminated, because there is no following killing store.\n \t     We need to generate these stores after loop.  */\n-\t  finalize_eliminated_stores (loop, chain);\n+\t  finalize_eliminated_stores (m_loop, chain);\n \t}\n \n       bool last_store_p = true;\n@@ -2342,7 +2304,7 @@ pcom_worker::execute_pred_commoning_chain (chain_p chain,\n   else\n     {\n       /* For non-combined chains, set up the variables that hold its value.  */\n-      initialize_root_vars (loop, chain, tmp_vars);\n+      initialize_root_vars (m_loop, chain, tmp_vars);\n       a = get_chain_root (chain);\n       in_lhs = (chain->type == CT_STORE_LOAD\n \t\t|| chain->type == CT_COMBINATION);\n@@ -2411,15 +2373,15 @@ pcom_worker::execute_pred_commoning (bitmap tmp_vars)\n   chain_p chain;\n   unsigned i;\n \n-  FOR_EACH_VEC_ELT (chains, i, chain)\n+  FOR_EACH_VEC_ELT (m_chains, i, chain)\n     {\n       if (chain->type == CT_INVARIANT)\n-\texecute_load_motion (loop, chain, tmp_vars);\n+\texecute_load_motion (m_loop, chain, tmp_vars);\n       else\n \texecute_pred_commoning_chain (chain, tmp_vars);\n     }\n \n-  FOR_EACH_VEC_ELT (chains, i, chain)\n+  FOR_EACH_VEC_ELT (m_chains, i, chain)\n     {\n       if (chain->type == CT_INVARIANT)\n \t;\n@@ -2979,7 +2941,7 @@ pcom_worker::try_combine_chains ()\n   auto_vec<chain_p> worklist;\n   bool combined_p = false;\n \n-  FOR_EACH_VEC_ELT (chains, i, ch1)\n+  FOR_EACH_VEC_ELT (m_chains, i, ch1)\n     if (chain_can_be_combined_p (ch1))\n       worklist.safe_push (ch1);\n \n@@ -2989,7 +2951,7 @@ pcom_worker::try_combine_chains ()\n       if (!chain_can_be_combined_p (ch1))\n \tcontinue;\n \n-      FOR_EACH_VEC_ELT (chains, j, ch2)\n+      FOR_EACH_VEC_ELT (m_chains, j, ch2)\n \t{\n \t  if (!chain_can_be_combined_p (ch2))\n \t    continue;\n@@ -2998,7 +2960,7 @@ pcom_worker::try_combine_chains ()\n \t  if (cch)\n \t    {\n \t      worklist.safe_push (cch);\n-\t      chains.safe_push (cch);\n+\t      m_chains.safe_push (cch);\n \t      combined_p = true;\n \t      break;\n \t    }\n@@ -3008,8 +2970,8 @@ pcom_worker::try_combine_chains ()\n     return;\n \n   /* Setup UID for all statements in dominance order.  */\n-  basic_block *bbs = get_loop_body_in_dom_order (loop);\n-  renumber_gimple_stmt_uids_in_blocks (bbs, loop->num_nodes);\n+  basic_block *bbs = get_loop_body_in_dom_order (m_loop);\n+  renumber_gimple_stmt_uids_in_blocks (bbs, m_loop->num_nodes);\n   free (bbs);\n \n   /* Re-association in combined chains may generate statements different to\n@@ -3022,7 +2984,7 @@ pcom_worker::try_combine_chains ()\n \n      We first update position information for all combined chains.  */\n   dref ref;\n-  for (i = 0; chains.iterate (i, &ch1); ++i)\n+  for (i = 0; m_chains.iterate (i, &ch1); ++i)\n     {\n       if (ch1->type != CT_COMBINATION || ch1->combined)\n \tcontinue;\n@@ -3033,7 +2995,7 @@ pcom_worker::try_combine_chains ()\n       update_pos_for_combined_chains (ch1);\n     }\n   /* Then sort references according to newly updated position information.  */\n-  for (i = 0; chains.iterate (i, &ch1); ++i)\n+  for (i = 0; m_chains.iterate (i, &ch1); ++i)\n     {\n       if (ch1->type != CT_COMBINATION && !ch1->combined)\n \tcontinue;\n@@ -3155,10 +3117,10 @@ pcom_worker::prepare_initializers_chain (chain_p chain)\n   struct data_reference *dr = get_chain_root (chain)->ref;\n   tree init;\n   dref laref;\n-  edge entry = loop_preheader_edge (loop);\n+  edge entry = loop_preheader_edge (m_loop);\n \n   if (chain->type == CT_STORE_STORE)\n-    return prepare_initializers_chain_store_elim (loop, chain);\n+    return prepare_initializers_chain_store_elim (m_loop, chain);\n \n   /* Find the initializers for the variables, and check that they cannot\n      trap.  */\n@@ -3210,15 +3172,15 @@ pcom_worker::prepare_initializers ()\n   chain_p chain;\n   unsigned i;\n \n-  for (i = 0; i < chains.length (); )\n+  for (i = 0; i < m_chains.length (); )\n     {\n-      chain = chains[i];\n+      chain = m_chains[i];\n       if (prepare_initializers_chain (chain))\n \ti++;\n       else\n \t{\n \t  release_chain (chain);\n-\t  chains.unordered_remove (i);\n+\t  m_chains.unordered_remove (i);\n \t}\n     }\n }\n@@ -3231,7 +3193,7 @@ pcom_worker::prepare_finalizers_chain (chain_p chain)\n {\n   unsigned i, n = chain->length;\n   struct data_reference *dr = get_chain_root (chain)->ref;\n-  tree fini, niters = number_of_latch_executions (loop);\n+  tree fini, niters = number_of_latch_executions (m_loop);\n \n   /* For now we can't eliminate stores if some of them are conditional\n      executed.  */\n@@ -3281,9 +3243,9 @@ pcom_worker::prepare_finalizers ()\n   unsigned i;\n   bool loop_closed_ssa = false;\n \n-  for (i = 0; i < chains.length ();)\n+  for (i = 0; i < m_chains.length ();)\n     {\n-      chain = chains[i];\n+      chain = m_chains[i];\n \n       /* Finalizer is only necessary for inter-iteration store elimination\n \t chains.  */\n@@ -3305,7 +3267,7 @@ pcom_worker::prepare_finalizers ()\n       else\n \t{\n \t  release_chain (chain);\n-\t  chains.unordered_remove (i);\n+\t  m_chains.unordered_remove (i);\n \t}\n     }\n   return loop_closed_ssa;\n@@ -3341,10 +3303,10 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n   bool unroll = false, loop_closed_ssa = false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Processing loop %d\\n\", loop->num);\n+    fprintf (dump_file, \"Processing loop %d\\n\", m_loop->num);\n \n   /* Nothing for predicitive commoning if loop only iterates 1 time.  */\n-  if (get_max_loop_iterations_int (loop) == 0)\n+  if (get_max_loop_iterations_int (m_loop) == 0)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Loop iterates only 1 time, nothing to do.\\n\");\n@@ -3355,16 +3317,16 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n   /* Find the data references and split them into components according to their\n      dependence relations.  */\n   auto_vec<loop_p, 3> loop_nest;\n-  if (!compute_data_dependences_for_loop (loop, true, &loop_nest, &datarefs,\n-\t\t\t\t\t  &dependences))\n+  if (!compute_data_dependences_for_loop (m_loop, true, &loop_nest, &m_datarefs,\n+\t\t\t\t\t  &m_dependences))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Cannot analyze data dependencies\\n\");\n       return 0;\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_data_dependence_relations (dump_file, dependences);\n+    dump_data_dependence_relations (dump_file, m_dependences);\n \n   components = split_data_refs_to_components ();\n \n@@ -3385,7 +3347,7 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n   determine_roots (components);\n   release_components (components);\n \n-  if (!chains.exists ())\n+  if (!m_chains.exists ())\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -3399,21 +3361,21 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n   /* Try to combine the chains that are always worked with together.  */\n   try_combine_chains ();\n \n-  insert_init_seqs (loop, chains);\n+  insert_init_seqs (m_loop, m_chains);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Before commoning:\\n\\n\");\n-      dump_chains (dump_file, chains);\n+      dump_chains (dump_file, m_chains);\n     }\n \n   if (allow_unroll_p)\n     /* Determine the unroll factor, and if the loop should be unrolled, ensure\n        that its number of iterations is divisible by the factor.  */\n-    unroll_factor = determine_unroll_factor (chains);\n+    unroll_factor = determine_unroll_factor (m_chains);\n \n   if (unroll_factor > 1)\n-    unroll = can_unroll_loop_p (loop, unroll_factor, &desc);\n+    unroll = can_unroll_loop_p (m_loop, unroll_factor, &desc);\n \n   /* Execute the predictive commoning transformations, and possibly unroll the\n      loop.  */\n@@ -3425,7 +3387,7 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n \tfprintf (dump_file, \"Unrolling %u times.\\n\", unroll_factor);\n \n       dta.tmp_vars = tmp_vars;\n-      dta.chains = chains;\n+      dta.chains = m_chains;\n       dta.worker = this;\n \n       /* Cfg manipulations performed in tree_transform_and_unroll_loop before\n@@ -3434,12 +3396,12 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n \t statements.  To fix this, we store the ssa names defined by the\n \t phi nodes here instead of the phi nodes themselves, and restore\n \t the phi nodes in execute_pred_commoning_cbck.  A bit hacky.  */\n-      replace_phis_by_defined_names (chains);\n+      replace_phis_by_defined_names (m_chains);\n \n-      edge exit = single_dom_exit (loop);\n-      tree_transform_and_unroll_loop (loop, unroll_factor, exit, &desc,\n+      edge exit = single_dom_exit (m_loop);\n+      tree_transform_and_unroll_loop (m_loop, unroll_factor, exit, &desc,\n \t\t\t\t      execute_pred_commoning_cbck, &dta);\n-      eliminate_temp_copies (loop, tmp_vars);\n+      eliminate_temp_copies (m_loop, tmp_vars);\n     }\n   else\n     {\n@@ -3554,5 +3516,3 @@ make_pass_predcom (gcc::context *ctxt)\n {\n   return new pass_predcom (ctxt);\n }\n-\n-"}]}