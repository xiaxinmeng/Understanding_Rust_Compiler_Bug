{"sha": "9795b20366362d63be058f1e4f3009d6bad79310", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc5NWIyMDM2NjM2MmQ2M2JlMDU4ZjFlNGYzMDA5ZDZiYWQ3OTMxMA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-05T07:02:08Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-05T07:02:08Z"}, "message": "[Ada] Diagnostics in Elaboration order v4.0\n\nThis patch introduces several changes to the new elaboration order\nmechanism:\n\n  * The library graph can now discover, store, and organize the various\n    cycles it contains.\n\n  * The elaboration order mechanism can now diagnose one or all cycles\n    within the library graph. Diagnostics consist of describing the\n    reason for the cycle, listing all units comprising the circuit, and\n    offering suggestions on how to break the cycle.\n\nThe patch also modifies unit ALI to hide all invocation-related data\nstructures and several implementation-specific types by relocating them\nin the body of the unit.\n\nThe patch cleans up most children of Bindo by using better names of\nroutines and formal parameters.\n\n------------\n-- Source --\n------------\n\n--  a.ads\n\nwith B; pragma Elaborate_All (B);\nwith C; pragma Elaborate_All (C);\n\npackage A is\nend A;\n\n--  b.ads\n\npackage B is\n   procedure Force_Body;\nend B;\n\n--  b.adb\n\nwith D;\n\npackage body B is\n   procedure Force_Body is null;\n\n   Elab : constant Integer := D.Func;\nend B;\n\n--  c.ads\n\npackage C is\n   procedure Force_Body;\nend C;\n\n--  c.adb\n\nwith E;\n\npackage body C is\n   procedure Force_Body is null;\nend C;\n\n--  d.ads\n\npackage D is\n   function Func return Integer;\nend D;\n\n--  d.adb\n\nwith A;\n\npackage body D is\n   Local : Integer := 123;\n\n   function Func return Integer is\n   begin\n      return Local;\n   end Func;\nend D;\n\n--  e.ads\n\nwith A;\n\npackage E is\nend E;\n\n--  main.adb\n\nwith B;\n\n--             Elaborate_All             Elaborate_All               with\n--    C spec <--------------- A spec ---------------------> B spec <------ Main\n--      ^                      ^  ^                           ^\n--      |                      |  |                           |\n--  sbb |                      |  |                           | sbb\n--      |                      |  |                           |\n--    C body -----------> E spec  |       D spec <--------- B body\n--               with             |         ^       with      |\n--                                |         |                 |\n--                                |     sbb |                 |\n--                                |         |                 |\n--                                +------ D body <------------+\n--                                  with           Invocation\n--\n--  The cycles are\n--\n--    A spec --> C spec --> E spec --> A spec\n--               C body\n--\n--    A spec --> B spec --> D body --> A spec\n--               B body\n\nprocedure Main is begin null; end Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q main.adb -bargs -d_C -d_N\nerror: Elaboration circularity detected\ninfo:\ninfo:    Reason:\ninfo:\ninfo:      unit \"a (spec)\" depends on its own elaboration\ninfo:\ninfo:    Circularity:\ninfo:\ninfo:      unit \"a (spec)\" has with clause and pragma Elaborate_All for unit\n             \"b (spec)\"\ninfo:      unit \"b (body)\" is in the closure of pragma Elaborate_All\ninfo:      unit \"b (body)\" has with clause for unit \"d (spec)\"\ninfo:      unit \"d (body)\" is in the closure of pragma Elaborate_All\ninfo:      unit \"d (body)\" has with clause for unit \"a (spec)\"\ninfo:\ninfo:    Suggestions:\ninfo:\ninfo:      change pragma Elaborate_All for unit \"b (spec)\" to Elaborate in unit\n             \"a (spec)\"\ninfo:      remove pragma Elaborate_All for unit \"b (spec)\" in unit \"a (spec)\"\ninfo:\nerror: Elaboration circularity detected\ninfo:\ninfo:    Reason:\ninfo:\ninfo:      unit \"a (spec)\" depends on its own elaboration\ninfo:\ninfo:    Circularity:\ninfo:\ninfo:      unit \"a (spec)\" has with clause and pragma Elaborate_All for unit\n             \"c (spec)\"\ninfo:      unit \"c (body)\" is in the closure of pragma Elaborate_All\ninfo:      unit \"c (body)\" has with clause for unit \"e (spec)\"\ninfo:      unit \"e (spec)\" has with clause for unit \"a (spec)\"\ninfo:\ninfo:    Suggestions:\ninfo:\ninfo:      change pragma Elaborate_All for unit \"c (spec)\" to Elaborate in unit\n             \"a (spec)\"\ninfo:      remove pragma Elaborate_All for unit \"c (spec)\" in unit \"a (spec)\"\ninfo:\ngnatmake: *** bind failed.\n\n2019-07-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* ali.adb: Relocate types Invocation_Construct_Record,\n\tInvocation_Relation_Record, and Invocation_Signature_Record to\n\tthe body of ALI.  Relocate tables Invocation_Constructs,\n\tInvocation_Relations, and Invocation_Signatures to the body of\n\tALI.  Remove type Body_Placement_Codes.  Add new types\n\tDeclaration_Placement_Codes, and\n\tInvocation_Graph_Encoding_Codes.  Update the literals of type\n\tInvocation_Graph_Line_Codes.\n\t(Add_Invocation_Construct): Update the parameter profile. Add an\n\tinvocation construct built from all attributes provided.\n\t(Add_Invocation_Relation): Update the parameter profile. Add an\n\tinvocation relation built from all attributes provided.\n\t(Body_Placement): New routine.\n\t(Body_Placement_Kind_To_Code, Code_To_Body_Placement_Kind):\n\tRemoved.\n\t(Code_To_Declaration_Placement_Kind,\n\tCode_To_Invocation_Graph_Encoding_Kind, Column,\n\tDeclaration_Placement_Kind_To_Code, Extra,\n\tFor_Each_Invocation_Construct, For_Each_Invocation_Relation,\n\tInvocation_Graph_Encoding,\n\tInvocation_Graph_Encoding_Kind_To_Code, Invoker, Kind, Line,\n\tLocations, Name): New routine.\n\t(Scan_Invocation_Construct_Line): Reimplement the scanning\n\tmechanism.\n\t(Scan_Invocation_Graph_Attributes_Line): New routine.\n\t(Scan_Invocation_Graph_Line): Use a case statement to dispatch.\n\t(Scan_Invocation_Relation_Line): Reimplement the scanning\n\tmechanism.\n\t(Scope): New routine.\n\t(Set_Invocation_Graph_Encoding, Signature, Spec_Placement,\n\tTarget): New routine.\n\t* ali.ads: Add new type Invocation_Graph_Encoding_Kind.  Add\n\tcomponent Invocation_Graph_Encoding to type Unit_Record.\n\tRelocate various types and data structures to the body of ALI.\n\t(Add_Invocation_Construct, Add_Invocation_Relation): Update the\n\tparameter profile.\n\t(Body_Placement): New routine.\n\t(Body_Placement_Kind_To_Code, Code_To_Body_Placement_Kind):\n\tRemoved.\n\t(Code_To_Declaration_Placement_Kind,\n\tCode_To_Invocation_Graph_Encoding_Kind, Column,\n\tDeclaration_Placement_Kind_To_Code, Extra,\n\tFor_Each_Invocation_Construct, For_Each_Invocation_Relation,\n\tInvocation_Graph_Encoding,\n\tInvocation_Graph_Encoding_Kind_To_Code, Invoker, Kind, Line,\n\tLocations, Name, Scope, Set_Invocation_Graph_Encoding,\n\tSignature, Spec_Placement, Target): New routine.\n\t* bindo.adb: Add with clause for Binde.  Add with and use\n\tclauses for Debug.  Update the documentation.  Add new switches.\n\t(Find_Elaboration_Order): Dispatch to the proper elaboration\n\tmechanism.\n\t* bindo-augmentors.adb:\n\tRemove with and use clauses for GNAT and GNAT.Sets.  Remove\n\tmembership set VS.  Update the parameter profiles of most\n\troutines to use better parameter names.  Update the\n\timplementation of most routine to use the new parameter names.\n\tRemove various redundant assertions.\n\t* bindo-builders.adb: Use better names for instantiated data\n\tstructures. Update all references to these names.  Update the\n\tparameter profiles of most routines to use better parameter\n\tnames.  Update the implementation of most routine to use the new\n\tparameter names.\n\t(Build_Library_Graph): Update the parameter profile. Update the\n\tcall to Create.\n\t(Create_Vertex): Reimplemented.\n\t(Declaration_Placement_Vertex): New routine.\n\t* bindo-builders.ads (Build_Library_Graph): Update the parameter\n\tprofile and comment on usage.\n\t* bindo-diagnostics.adb: Almost a new unit.\n\t* bindo-diagnostics.ads: Add a use clause for\n\tBindo.Graphs.Invocation_Graphs.  Remove package\n\tCycle_Diagnostics.\n\t(Diagnose_Circularities): New routine.\n\t* bindo-elaborators.adb: Remove the with and use clauses for\n\tBinderr and GNAT.Sets.  Remove the use clause for\n\tBindo.Diagnostics.Cycle_Diagnostics.  Remove membership set VS.\n\tUpdate the parameter profiles of most routines to use better\n\tparameter names.  Update the implementation of most routine to\n\tuse the new parameter names.  (Elaborate_Units_Common): Update\n\tthe parameter profile. Pass an infication to the library graph\n\tbuilder whether the dynamic model is in effect.\n\t(Elaborate_Units_Dynamic, Elaborate_Units_Static): Use\n\tDiagnose_Circularities to provide diagnostics.\n\t(Update_Successor): Use routine In_Same_Component to determine\n\twhether the predecessor and successor reside in different\n\tcomponents.\n\t* bindo-graphs.adb: Add with and use clauses for Butil, Debug,\n\tOutput, and Bindo.Writers.  Remove with and use clauses for\n\tGNAT.Lists.  Update the parameter profiles of most routines to\n\tuse better parameter names.  Update the implementation of most\n\troutine to use the new parameter names.  Remove various\n\tredundant assertions.  Remove doubly linked list EL.  Add new\n\ttype Precedence_Kind.\n\t(Add_Cycle): New routine.\n\t(Add_Vertex): Update the parameter profile. Update the creation\n\tof vertex attributes.\n\t(Add_Vertex_And_Complement, Body_Vertex, Column,\n\tComplementary_Vertex, Copy_Cycle_Path, Cycle_Kind_Of): New\n\troutines.\n\t(Destroy_Invocation_Graph_Edge, Destroy_Library_Graph_Cycle,\n\tDestroy_Library_Graph_Edge, Extra, File_Name,\n\tFind_All_Cycles_Through_Vertex, Find_All_Cycles_With_Edge,\n\tFind_Cycles, Find_First_Lower_Precedence_Cycle,\n\tGet_LGC_Attributes, Has_Next, Hash_Library_Graph_Cycle,\n\tHash_Library_Graph_Cycle_Attributes, Highest_Precedence_Cycle,\n\tHighest_Precedence_Edge, In_Same_Component, Insert_And_Sort,\n\tInvocation_Edge_Count, Invocation_Graph_Encoding,\n\tIs_Cycle_Initiating_Edge, Is_Cyclic_Edge,\n\tIs_Cyclic_Elaborate_All_Edge, Is_Cyclic_Elaborate_Body_Edge,\n\tIs_Cyclic_Elaborate_Edge, Is_Cyclic_Forced_Edge,\n\tIs_Cyclic_Invocation_Edge, Is_Cyclic_With_Edge,\n\tIs_Dynamically_Elaborated, Is_Elaborate_All_Edge,\n\tIs_Elaborate_Body_Edge, Is_Elaborate_Edge: New routines.\n\t(Is_Existing_Predecessor_Successor_Relation): Removed.\n\t(Is_Forced_Edge, Is_Invocation_Edge, Is_Recorded_Cycle,\n\tIs_Recorded_Edge, Is_With_Edge, Iterate_Edges_Of_Cycle, Kind,\n\tLength): New routine.\n\t(Lib_Vertex): Removed.\n\t(Line, Links_Vertices_In_Same_Component,\n\tMaximum_Invocation_Edge_Count, Next, Normalize_And_Add_Cycle,\n\tNormalize_Cycle_Path, Number_Of_Cycles, Path, Precedence,\n\tRemove_Vertex_And_Complement, Sequence_Next_Cycle): New routines.\n\t(Sequence_Next_IGE_Id): Renamed to Sequence_Next_Edge.\n\t(Sequence_Next_IGV_Id): Renamed to Sequence_Next_Vertex.\n\t(Sequence_Next_LGE_Id): Renamed to Sequence_Next_Edge.\n\t(Sequence_Next_LGV_Id): Renamed to Sequence_Next_Vertex.\n\t(Set_Is_Existing_Predecessor_Successor_Relation): Removed.\n\t(Set_Is_Recorded_Cycle, Set_Is_Recorded_Edge,\n\tSet_LGC_Attributes, Spec_Vertex, Trace_Cycle, Trace_Edge,\n\tTrace_Eol, Trace_Vertex): New routines.\n\t* bindo-graphs.ads: Add with and use clauses for Types and\n\tGNAT.Lists.  Update the parameter profiles of most routines to\n\tuse better parameter names.  Update the implementation of most\n\troutine to use the new parameter names.  Add the new\n\tinstantiated data structures IGE_Lists, IGV_Sets, LGC_Lists,\n\tLGE_Lists, LGE_Sets, LGV_Sets, and RC_Sets.  Add new type\n\tLibrary_Graph_Cycle_Id along with an empty and initial value.\n\tRemove component Lib_Vertex and add new components Body_Vertex\n\tand Spec_Vertex to type Invocation_Graph_Vertex_Attributes.  Add\n\tnew type Library_Graph_Cycle_Kind.  Add new iterators\n\tAll_Cycle_Iterator and Edges_Of_Cycle_Iterator.  Add new type\n\tLibrary_Graph_Cycle_Attributes.  Add new components\n\tCycle_Attributes, Cycles, and Dynamically_Elaborated to type\n\tLibrary_Graph_Attributes.\n\t(Body_Vertex, Column, Destroy_Invocation_Graph_Edge,\n\tDestroy_Library_Graph_Cycle_Attributes,\n\tDestroy_Library_Graph_Edge, Extra, File_Name, Find_Cycles,\n\tHas_Elaborate_All_Cycle, Has_Next, Hash_Library_Graph_Cycle,\n\tHash_Library_Graph_Cycle_Attributes, Highest_Precedence_Cycle,\n\tIn_Same_Component, Invocation_Edge_Count,\n\tInvocation_Graph_Encoding, Is_Dynamically_Elaborated,\n\tIs_Elaborate_All_Edge, Is_Elaborate_Body_Edge,\n\tIs_Elaborate_Edge, Is_Forced_Edge, Is_Invocation_Edge,\n\tIs_With_Edge, Iterate_All_Cycles, Iterate_Edges_Of_Cycle, Kind):\n\tNew routines.\n\t(Length, Lib_Vertex, (Line, Next, Number_Of_Cycles, Present,\n\tSame_Library_Graph_Cycle_Attributes, Spec_Vertex): New routines.\n\t* bindo-units.adb (File_Name, Invocation_Graph_Encoding): New\n\troutines.\n\t* bindo-units.ads: Add new instantiated data structure\n\tUnit_Sets.\n\t(File_Name, Invocation_Graph_Encoding): New routine.\n\t* bindo-validators.adb: Remove with and use clauses for GNAT and\n\tGNAT.Sets.  Remove membership set US.  Update the parameter\n\tprofiles of most routines to use better parameter names.  Update\n\tthe implementation of most routine to use the new parameter\n\tnames.\n\t(Validate_Cycle, Validate_Cycle_Path, Validate_Cycles,\n\tValidate_Invocation_Graph_Vertex): Remove the validation of\n\tcomponent Lib_Vertex. Add the validation of components\n\tBody_Vertex and Spec_Vertex.\n\t(Write_Error): New routine.\n\t* bindo-validators.ads (Validate_Cycles): New routine.\n\t* bindo-writers.adb: Update the parameter profiles of most\n\troutines to use better parameter names.  Update the\n\timplementation of most routine to use the new parameter names.\n\t(Write_Cycle, Write_Cyclic_Edge, Write_Cycles): New routines.\n\t(Write_Invocation_Graph_Vertex): Remove the output of component\n\tLib_Vertex. Add the output of components Body_Vertex and\n\tSpec_Vertex.\n\t* bindo-writers.ads (Write_Cycles): New routine.\n\t* debug.adb: Use binder switches -d_C and -d_P, add\n\tdocumentation on their usage.\n\t* gnatbind.adb: Remove with and use clauses for Binde.  Delegate\n\tthe choice of elaboration mechanism to Bindo.\n\t* lib-writ.adb (Column, Extra, Invoker, Kind, Line, Locations,\n\tName, Placement, Scope, Signature, Target): Removed.\n\t(Write_Invocation_Graph): Moved at the top level.\n\t(Write_Invocation_Graph_Attributes): New routine.\n\t(Write_Invocation_Relation, Write_Invocation_Signature): Moved\n\tat the top level.\n\t* lib-writ.ads: Add a documentation section on invocation graph\n\tattributes.\n\t* sem_elab.adb (Body_Placement_Of): New routine.\n\t(Declare_Invocation_Construct): Update the call to\n\tAdd_Invocation_Construct.\n\t(Declaration_Placement_Of_Node): New routine.\n\t(Get_Invocation_Attributes): Correct the retrieval of the\n\tenclosing subprogram where the postcondition procedure lives.\n\t(Placement_Of, Placement_Of_Node): Removed.\n\t(Record_Invocation_Graph): Record the encoding format used.\n\t(Record_Invocation_Graph_Encoding): New routine.\n\t(Record_Invocation_Relation): Update the call to\n\tAdd_Invocation_Relation.\n\t(Spec_Placement_Of): Removed.\n\t* libgnat/g-lists.ads, libgnat/g-lists.adb (Equal): New routine.\n\nFrom-SVN: r273107", "tree": {"sha": "aba3763d81a519c490994b1fce8918c7e31e31c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aba3763d81a519c490994b1fce8918c7e31e31c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9795b20366362d63be058f1e4f3009d6bad79310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9795b20366362d63be058f1e4f3009d6bad79310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9795b20366362d63be058f1e4f3009d6bad79310", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9795b20366362d63be058f1e4f3009d6bad79310/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "db6261488e4e53e4ac09ec9db50ea2e4a1859377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db6261488e4e53e4ac09ec9db50ea2e4a1859377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db6261488e4e53e4ac09ec9db50ea2e4a1859377"}], "stats": {"total": 9168, "additions": 6939, "deletions": 2229}, "files": [{"sha": "279eac546d594e652ed51e69f20b0f4ca6d5b48e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -1,3 +1,212 @@\n+2019-07-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* ali.adb: Relocate types Invocation_Construct_Record,\n+\tInvocation_Relation_Record, and Invocation_Signature_Record to\n+\tthe body of ALI.  Relocate tables Invocation_Constructs,\n+\tInvocation_Relations, and Invocation_Signatures to the body of\n+\tALI.  Remove type Body_Placement_Codes.  Add new types\n+\tDeclaration_Placement_Codes, and\n+\tInvocation_Graph_Encoding_Codes.  Update the literals of type\n+\tInvocation_Graph_Line_Codes.\n+\t(Add_Invocation_Construct): Update the parameter profile. Add an\n+\tinvocation construct built from all attributes provided.\n+\t(Add_Invocation_Relation): Update the parameter profile. Add an\n+\tinvocation relation built from all attributes provided.\n+\t(Body_Placement): New routine.\n+\t(Body_Placement_Kind_To_Code, Code_To_Body_Placement_Kind):\n+\tRemoved.\n+\t(Code_To_Declaration_Placement_Kind,\n+\tCode_To_Invocation_Graph_Encoding_Kind, Column,\n+\tDeclaration_Placement_Kind_To_Code, Extra,\n+\tFor_Each_Invocation_Construct, For_Each_Invocation_Relation,\n+\tInvocation_Graph_Encoding,\n+\tInvocation_Graph_Encoding_Kind_To_Code, Invoker, Kind, Line,\n+\tLocations, Name): New routine.\n+\t(Scan_Invocation_Construct_Line): Reimplement the scanning\n+\tmechanism.\n+\t(Scan_Invocation_Graph_Attributes_Line): New routine.\n+\t(Scan_Invocation_Graph_Line): Use a case statement to dispatch.\n+\t(Scan_Invocation_Relation_Line): Reimplement the scanning\n+\tmechanism.\n+\t(Scope): New routine.\n+\t(Set_Invocation_Graph_Encoding, Signature, Spec_Placement,\n+\tTarget): New routine.\n+\t* ali.ads: Add new type Invocation_Graph_Encoding_Kind.  Add\n+\tcomponent Invocation_Graph_Encoding to type Unit_Record.\n+\tRelocate various types and data structures to the body of ALI.\n+\t(Add_Invocation_Construct, Add_Invocation_Relation): Update the\n+\tparameter profile.\n+\t(Body_Placement): New routine.\n+\t(Body_Placement_Kind_To_Code, Code_To_Body_Placement_Kind):\n+\tRemoved.\n+\t(Code_To_Declaration_Placement_Kind,\n+\tCode_To_Invocation_Graph_Encoding_Kind, Column,\n+\tDeclaration_Placement_Kind_To_Code, Extra,\n+\tFor_Each_Invocation_Construct, For_Each_Invocation_Relation,\n+\tInvocation_Graph_Encoding,\n+\tInvocation_Graph_Encoding_Kind_To_Code, Invoker, Kind, Line,\n+\tLocations, Name, Scope, Set_Invocation_Graph_Encoding,\n+\tSignature, Spec_Placement, Target): New routine.\n+\t* bindo.adb: Add with clause for Binde.  Add with and use\n+\tclauses for Debug.  Update the documentation.  Add new switches.\n+\t(Find_Elaboration_Order): Dispatch to the proper elaboration\n+\tmechanism.\n+\t* bindo-augmentors.adb:\n+\tRemove with and use clauses for GNAT and GNAT.Sets.  Remove\n+\tmembership set VS.  Update the parameter profiles of most\n+\troutines to use better parameter names.  Update the\n+\timplementation of most routine to use the new parameter names.\n+\tRemove various redundant assertions.\n+\t* bindo-builders.adb: Use better names for instantiated data\n+\tstructures. Update all references to these names.  Update the\n+\tparameter profiles of most routines to use better parameter\n+\tnames.  Update the implementation of most routine to use the new\n+\tparameter names.\n+\t(Build_Library_Graph): Update the parameter profile. Update the\n+\tcall to Create.\n+\t(Create_Vertex): Reimplemented.\n+\t(Declaration_Placement_Vertex): New routine.\n+\t* bindo-builders.ads (Build_Library_Graph): Update the parameter\n+\tprofile and comment on usage.\n+\t* bindo-diagnostics.adb: Almost a new unit.\n+\t* bindo-diagnostics.ads: Add a use clause for\n+\tBindo.Graphs.Invocation_Graphs.  Remove package\n+\tCycle_Diagnostics.\n+\t(Diagnose_Circularities): New routine.\n+\t* bindo-elaborators.adb: Remove the with and use clauses for\n+\tBinderr and GNAT.Sets.  Remove the use clause for\n+\tBindo.Diagnostics.Cycle_Diagnostics.  Remove membership set VS.\n+\tUpdate the parameter profiles of most routines to use better\n+\tparameter names.  Update the implementation of most routine to\n+\tuse the new parameter names.  (Elaborate_Units_Common): Update\n+\tthe parameter profile. Pass an infication to the library graph\n+\tbuilder whether the dynamic model is in effect.\n+\t(Elaborate_Units_Dynamic, Elaborate_Units_Static): Use\n+\tDiagnose_Circularities to provide diagnostics.\n+\t(Update_Successor): Use routine In_Same_Component to determine\n+\twhether the predecessor and successor reside in different\n+\tcomponents.\n+\t* bindo-graphs.adb: Add with and use clauses for Butil, Debug,\n+\tOutput, and Bindo.Writers.  Remove with and use clauses for\n+\tGNAT.Lists.  Update the parameter profiles of most routines to\n+\tuse better parameter names.  Update the implementation of most\n+\troutine to use the new parameter names.  Remove various\n+\tredundant assertions.  Remove doubly linked list EL.  Add new\n+\ttype Precedence_Kind.\n+\t(Add_Cycle): New routine.\n+\t(Add_Vertex): Update the parameter profile. Update the creation\n+\tof vertex attributes.\n+\t(Add_Vertex_And_Complement, Body_Vertex, Column,\n+\tComplementary_Vertex, Copy_Cycle_Path, Cycle_Kind_Of): New\n+\troutines.\n+\t(Destroy_Invocation_Graph_Edge, Destroy_Library_Graph_Cycle,\n+\tDestroy_Library_Graph_Edge, Extra, File_Name,\n+\tFind_All_Cycles_Through_Vertex, Find_All_Cycles_With_Edge,\n+\tFind_Cycles, Find_First_Lower_Precedence_Cycle,\n+\tGet_LGC_Attributes, Has_Next, Hash_Library_Graph_Cycle,\n+\tHash_Library_Graph_Cycle_Attributes, Highest_Precedence_Cycle,\n+\tHighest_Precedence_Edge, In_Same_Component, Insert_And_Sort,\n+\tInvocation_Edge_Count, Invocation_Graph_Encoding,\n+\tIs_Cycle_Initiating_Edge, Is_Cyclic_Edge,\n+\tIs_Cyclic_Elaborate_All_Edge, Is_Cyclic_Elaborate_Body_Edge,\n+\tIs_Cyclic_Elaborate_Edge, Is_Cyclic_Forced_Edge,\n+\tIs_Cyclic_Invocation_Edge, Is_Cyclic_With_Edge,\n+\tIs_Dynamically_Elaborated, Is_Elaborate_All_Edge,\n+\tIs_Elaborate_Body_Edge, Is_Elaborate_Edge: New routines.\n+\t(Is_Existing_Predecessor_Successor_Relation): Removed.\n+\t(Is_Forced_Edge, Is_Invocation_Edge, Is_Recorded_Cycle,\n+\tIs_Recorded_Edge, Is_With_Edge, Iterate_Edges_Of_Cycle, Kind,\n+\tLength): New routine.\n+\t(Lib_Vertex): Removed.\n+\t(Line, Links_Vertices_In_Same_Component,\n+\tMaximum_Invocation_Edge_Count, Next, Normalize_And_Add_Cycle,\n+\tNormalize_Cycle_Path, Number_Of_Cycles, Path, Precedence,\n+\tRemove_Vertex_And_Complement, Sequence_Next_Cycle): New routines.\n+\t(Sequence_Next_IGE_Id): Renamed to Sequence_Next_Edge.\n+\t(Sequence_Next_IGV_Id): Renamed to Sequence_Next_Vertex.\n+\t(Sequence_Next_LGE_Id): Renamed to Sequence_Next_Edge.\n+\t(Sequence_Next_LGV_Id): Renamed to Sequence_Next_Vertex.\n+\t(Set_Is_Existing_Predecessor_Successor_Relation): Removed.\n+\t(Set_Is_Recorded_Cycle, Set_Is_Recorded_Edge,\n+\tSet_LGC_Attributes, Spec_Vertex, Trace_Cycle, Trace_Edge,\n+\tTrace_Eol, Trace_Vertex): New routines.\n+\t* bindo-graphs.ads: Add with and use clauses for Types and\n+\tGNAT.Lists.  Update the parameter profiles of most routines to\n+\tuse better parameter names.  Update the implementation of most\n+\troutine to use the new parameter names.  Add the new\n+\tinstantiated data structures IGE_Lists, IGV_Sets, LGC_Lists,\n+\tLGE_Lists, LGE_Sets, LGV_Sets, and RC_Sets.  Add new type\n+\tLibrary_Graph_Cycle_Id along with an empty and initial value.\n+\tRemove component Lib_Vertex and add new components Body_Vertex\n+\tand Spec_Vertex to type Invocation_Graph_Vertex_Attributes.  Add\n+\tnew type Library_Graph_Cycle_Kind.  Add new iterators\n+\tAll_Cycle_Iterator and Edges_Of_Cycle_Iterator.  Add new type\n+\tLibrary_Graph_Cycle_Attributes.  Add new components\n+\tCycle_Attributes, Cycles, and Dynamically_Elaborated to type\n+\tLibrary_Graph_Attributes.\n+\t(Body_Vertex, Column, Destroy_Invocation_Graph_Edge,\n+\tDestroy_Library_Graph_Cycle_Attributes,\n+\tDestroy_Library_Graph_Edge, Extra, File_Name, Find_Cycles,\n+\tHas_Elaborate_All_Cycle, Has_Next, Hash_Library_Graph_Cycle,\n+\tHash_Library_Graph_Cycle_Attributes, Highest_Precedence_Cycle,\n+\tIn_Same_Component, Invocation_Edge_Count,\n+\tInvocation_Graph_Encoding, Is_Dynamically_Elaborated,\n+\tIs_Elaborate_All_Edge, Is_Elaborate_Body_Edge,\n+\tIs_Elaborate_Edge, Is_Forced_Edge, Is_Invocation_Edge,\n+\tIs_With_Edge, Iterate_All_Cycles, Iterate_Edges_Of_Cycle, Kind):\n+\tNew routines.\n+\t(Length, Lib_Vertex, (Line, Next, Number_Of_Cycles, Present,\n+\tSame_Library_Graph_Cycle_Attributes, Spec_Vertex): New routines.\n+\t* bindo-units.adb (File_Name, Invocation_Graph_Encoding): New\n+\troutines.\n+\t* bindo-units.ads: Add new instantiated data structure\n+\tUnit_Sets.\n+\t(File_Name, Invocation_Graph_Encoding): New routine.\n+\t* bindo-validators.adb: Remove with and use clauses for GNAT and\n+\tGNAT.Sets.  Remove membership set US.  Update the parameter\n+\tprofiles of most routines to use better parameter names.  Update\n+\tthe implementation of most routine to use the new parameter\n+\tnames.\n+\t(Validate_Cycle, Validate_Cycle_Path, Validate_Cycles,\n+\tValidate_Invocation_Graph_Vertex): Remove the validation of\n+\tcomponent Lib_Vertex. Add the validation of components\n+\tBody_Vertex and Spec_Vertex.\n+\t(Write_Error): New routine.\n+\t* bindo-validators.ads (Validate_Cycles): New routine.\n+\t* bindo-writers.adb: Update the parameter profiles of most\n+\troutines to use better parameter names.  Update the\n+\timplementation of most routine to use the new parameter names.\n+\t(Write_Cycle, Write_Cyclic_Edge, Write_Cycles): New routines.\n+\t(Write_Invocation_Graph_Vertex): Remove the output of component\n+\tLib_Vertex. Add the output of components Body_Vertex and\n+\tSpec_Vertex.\n+\t* bindo-writers.ads (Write_Cycles): New routine.\n+\t* debug.adb: Use binder switches -d_C and -d_P, add\n+\tdocumentation on their usage.\n+\t* gnatbind.adb: Remove with and use clauses for Binde.  Delegate\n+\tthe choice of elaboration mechanism to Bindo.\n+\t* lib-writ.adb (Column, Extra, Invoker, Kind, Line, Locations,\n+\tName, Placement, Scope, Signature, Target): Removed.\n+\t(Write_Invocation_Graph): Moved at the top level.\n+\t(Write_Invocation_Graph_Attributes): New routine.\n+\t(Write_Invocation_Relation, Write_Invocation_Signature): Moved\n+\tat the top level.\n+\t* lib-writ.ads: Add a documentation section on invocation graph\n+\tattributes.\n+\t* sem_elab.adb (Body_Placement_Of): New routine.\n+\t(Declare_Invocation_Construct): Update the call to\n+\tAdd_Invocation_Construct.\n+\t(Declaration_Placement_Of_Node): New routine.\n+\t(Get_Invocation_Attributes): Correct the retrieval of the\n+\tenclosing subprogram where the postcondition procedure lives.\n+\t(Placement_Of, Placement_Of_Node): Removed.\n+\t(Record_Invocation_Graph): Record the encoding format used.\n+\t(Record_Invocation_Graph_Encoding): New routine.\n+\t(Record_Invocation_Relation): Update the call to\n+\tAdd_Invocation_Relation.\n+\t(Spec_Placement_Of): Removed.\n+\t* libgnat/g-lists.ads, libgnat/g-lists.adb (Equal): New routine.\n+\n 2019-07-05  Ed Schonberg  <schonberg@adacore.com>\n \n \t* checks.adb (Apply_Predicate_Check): Except within the"}, {"sha": "aa8b2424696d01eacfa283a3f314bae11c6a6f0d", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 478, "deletions": 73, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -39,10 +39,115 @@ package body ALI is\n    use ASCII;\n    --  Make control characters visible\n \n+   -----------\n+   -- Types --\n+   -----------\n+\n+   --  The following type represents an invocation construct\n+\n+   type Invocation_Construct_Record is record\n+      Body_Placement : Declaration_Placement_Kind := No_Declaration_Placement;\n+      --  The location of the invocation construct's body with respect to the\n+      --  unit where it is declared.\n+\n+      Kind : Invocation_Construct_Kind := Regular_Construct;\n+      --  The nature of the invocation construct\n+\n+      Signature : Invocation_Signature_Id := No_Invocation_Signature;\n+      --  The invocation signature that uniquely identifies the invocation\n+      --  construct in the ALI space.\n+\n+      Spec_Placement : Declaration_Placement_Kind := No_Declaration_Placement;\n+      --  The location of the invocation construct's spec with respect to the\n+      --  unit where it is declared.\n+   end record;\n+\n+   --  The following type represents an invocation relation. It associates an\n+   --  invoker that activates/calls/instantiates with a target.\n+\n+   type Invocation_Relation_Record is record\n+      Extra : Name_Id := No_Name;\n+      --  The name of an additional entity used in error diagnostics\n+\n+      Invoker : Invocation_Signature_Id := No_Invocation_Signature;\n+      --  The invocation signature that uniquely identifies the invoker within\n+      --  the ALI space.\n+\n+      Kind : Invocation_Kind := No_Invocation;\n+      --  The nature of the invocation\n+\n+      Target : Invocation_Signature_Id := No_Invocation_Signature;\n+      --  The invocation signature that uniquely identifies the target within\n+      --  the ALI space.\n+   end record;\n+\n+   --  The following type represents an invocation signature. Its purpose is\n+   --  to uniquely identify an invocation construct within the ALI space. The\n+   --  signature comprises several pieces, some of which are used in error\n+   --  diagnostics by the binder. Identification issues are resolved as\n+   --  follows:\n+   --\n+   --    * The Column, Line, and Locations attributes together differentiate\n+   --      between homonyms. In most cases, the Column and Line are sufficient\n+   --      except when generic instantiations are involved. Together, the three\n+   --      attributes offer a sequence of column-line pairs that eventually\n+   --      reflect the location within the generic template.\n+   --\n+   --    * The Name attribute differentiates between invocation constructs at\n+   --      the scope level. Since it is illegal for two entities with the same\n+   --      name to coexist in the same scope, the Name attribute is sufficient\n+   --      to distinguish them. Overloaded entities are already handled by the\n+   --      Column, Line, and Locations attributes.\n+   --\n+   --    * The Scope attribute differentiates between invocation constructs at\n+   --      various levels of nesting.\n+\n+   type Invocation_Signature_Record is record\n+      Column : Nat := 0;\n+      --  The column number where the invocation construct is declared\n+\n+      Line : Nat := 0;\n+      --  The line number where the invocation construct is declared\n+\n+      Locations : Name_Id := No_Name;\n+      --  Sequence of column and line numbers within nested instantiations\n+\n+      Name : Name_Id := No_Name;\n+      --  The name of the invocation construct\n+\n+      Scope : Name_Id := No_Name;\n+      --  The qualified name of the scope where the invocation construct is\n+      --  declared.\n+   end record;\n+\n    ---------------------\n    -- Data structures --\n    ---------------------\n \n+   package Invocation_Constructs is new Table.Table\n+     (Table_Index_Type     => Invocation_Construct_Id,\n+      Table_Component_Type => Invocation_Construct_Record,\n+      Table_Low_Bound      => First_Invocation_Construct,\n+      Table_Initial        => 2500,\n+      Table_Increment      => 200,\n+      Table_Name           => \"Invocation_Constructs\");\n+\n+   package Invocation_Relations is new Table.Table\n+     (Table_Index_Type     => Invocation_Relation_Id,\n+      Table_Component_Type => Invocation_Relation_Record,\n+      Table_Low_Bound      => First_Invocation_Relation,\n+      Table_Initial        => 2500,\n+      Table_Increment      => 200,\n+      Table_Name           => \"Invocation_Relation\");\n+\n+   package Invocation_Signatures is new Table.Table\n+     (Table_Index_Type     => Invocation_Signature_Id,\n+      Table_Component_Type => Invocation_Signature_Record,\n+      Table_Low_Bound      => First_Invocation_Signature,\n+      Table_Initial        => 2500,\n+      Table_Increment      => 200,\n+      Table_Name           => \"Invocation_Signatures\");\n+\n    procedure Destroy (IS_Id : in out Invocation_Signature_Id);\n    --  Destroy an invocation signature with id IS_Id\n \n@@ -68,14 +173,19 @@ package body ALI is\n    Sig_To_Sig_Map : constant Sig_Map.Dynamic_Hash_Table :=\n                       Sig_Map.Create (500);\n \n-   --  The folowing table maps body placement kinds to character codes for\n-   --  invocation construct encoding in ALI files.\n+   --  The folowing table maps declaration placement kinds to character codes\n+   --  for invocation construct encoding in ALI files.\n \n-   Body_Placement_Codes :\n-     constant array (Body_Placement_Kind) of Character :=\n-       (In_Body           => 'b',\n-        In_Spec           => 's',\n-        No_Body_Placement => 'Z');\n+   Declaration_Placement_Codes :\n+     constant array (Declaration_Placement_Kind) of Character :=\n+       (In_Body                  => 'b',\n+        In_Spec                  => 's',\n+        No_Declaration_Placement => 'Z');\n+\n+   Compile_Time_Invocation_Graph_Encoding : Invocation_Graph_Encoding_Kind :=\n+                                              No_Encoding;\n+   --  The invocation-graph encoding format as specified at compile time. Do\n+   --  not manipulate this value directly.\n \n    --  The following table maps invocation kinds to character codes for\n    --  invocation relation encoding in ALI files.\n@@ -112,13 +222,23 @@ package body ALI is\n         Elaborate_Spec_Procedure => 's',\n         Regular_Construct        => 'Z');\n \n-   --  The following table maps invocation graph line kinds to character codes\n+   --  The following table maps invocation-graph encoding kinds to character\n+   --  codes for invocation-graph encoding in ALI files.\n+\n+   Invocation_Graph_Encoding_Codes :\n+     constant array (Invocation_Graph_Encoding_Kind) of Character :=\n+       (Full_Path_Encoding => 'f',\n+        Endpoints_Encoding => 'e',\n+        No_Encoding        => 'Z');\n+\n+   --  The following table maps invocation-graph line kinds to character codes\n    --  used in ALI files.\n \n    Invocation_Graph_Line_Codes :\n      constant array (Invocation_Graph_Line_Kind) of Character :=\n-       (Invocation_Construct_Line => 'c',\n-        Invocation_Relation_Line  => 'r');\n+       (Invocation_Construct_Line        => 'c',\n+        Invocation_Graph_Attributes_Line => 'a',\n+        Invocation_Relation_Line         => 'r');\n \n    --  The following variable records which characters currently are used as\n    --  line type markers in the ALI file. This is used in Scan_ALI to detect\n@@ -153,18 +273,22 @@ package body ALI is\n    ------------------------------\n \n    procedure Add_Invocation_Construct\n-     (IC_Rec       : Invocation_Construct_Record;\n-      Update_Units : Boolean := True)\n+     (Body_Placement : Declaration_Placement_Kind;\n+      Kind           : Invocation_Construct_Kind;\n+      Signature      : Invocation_Signature_Id;\n+      Spec_Placement : Declaration_Placement_Kind;\n+      Update_Units   : Boolean := True)\n    is\n-      IC_Id : Invocation_Construct_Id;\n-\n    begin\n-      pragma Assert (Present (IC_Rec.Signature));\n+      pragma Assert (Present (Signature));\n \n       --  Create a invocation construct from the scanned attributes\n \n-      Invocation_Constructs.Append (IC_Rec);\n-      IC_Id := Invocation_Constructs.Last;\n+      Invocation_Constructs.Append\n+        ((Body_Placement => Body_Placement,\n+          Kind           => Kind,\n+          Signature      => Signature,\n+          Spec_Placement => Spec_Placement));\n \n       --  Update the invocation construct counter of the current unit only when\n       --  requested by the caller.\n@@ -174,7 +298,7 @@ package body ALI is\n             Curr_Unit : Unit_Record renames Units.Table (Units.Last);\n \n          begin\n-            Curr_Unit.Last_Invocation_Construct := IC_Id;\n+            Curr_Unit.Last_Invocation_Construct := Invocation_Constructs.Last;\n          end;\n       end if;\n    end Add_Invocation_Construct;\n@@ -184,20 +308,24 @@ package body ALI is\n    -----------------------------\n \n    procedure Add_Invocation_Relation\n-     (IR_Rec       : Invocation_Relation_Record;\n+     (Extra        : Name_Id;\n+      Invoker      : Invocation_Signature_Id;\n+      Kind         : Invocation_Kind;\n+      Target       : Invocation_Signature_Id;\n       Update_Units : Boolean := True)\n    is\n-      IR_Id : Invocation_Relation_Id;\n-\n    begin\n-      pragma Assert (Present (IR_Rec.Invoker));\n-      pragma Assert (Present (IR_Rec.Target));\n-      pragma Assert (IR_Rec.Kind /= No_Invocation);\n+      pragma Assert (Present (Invoker));\n+      pragma Assert (Kind /= No_Invocation);\n+      pragma Assert (Present (Target));\n \n       --  Create an invocation relation from the scanned attributes\n \n-      Invocation_Relations.Append (IR_Rec);\n-      IR_Id := Invocation_Relations.Last;\n+      Invocation_Relations.Append\n+        ((Extra   => Extra,\n+          Invoker => Invoker,\n+          Kind    => Kind,\n+          Target  => Target));\n \n       --  Update the invocation relation counter of the current unit only when\n       --  requested by the caller.\n@@ -207,41 +335,42 @@ package body ALI is\n             Curr_Unit : Unit_Record renames Units.Table (Units.Last);\n \n          begin\n-            Curr_Unit.Last_Invocation_Relation := IR_Id;\n+            Curr_Unit.Last_Invocation_Relation := Invocation_Relations.Last;\n          end;\n       end if;\n    end Add_Invocation_Relation;\n \n-   ---------------------------------\n-   -- Body_Placement_Kind_To_Code --\n-   ---------------------------------\n+   --------------------\n+   -- Body_Placement --\n+   --------------------\n \n-   function Body_Placement_Kind_To_Code\n-     (Kind : Body_Placement_Kind) return Character\n+   function Body_Placement\n+     (IC_Id : Invocation_Construct_Id) return Declaration_Placement_Kind\n    is\n    begin\n-      return Body_Placement_Codes (Kind);\n-   end Body_Placement_Kind_To_Code;\n+      pragma Assert (Present (IC_Id));\n+      return Invocation_Constructs.Table (IC_Id).Body_Placement;\n+   end Body_Placement;\n \n-   ---------------------------------\n-   -- Code_To_Body_Placement_Kind --\n-   ---------------------------------\n+   ----------------------------------------\n+   -- Code_To_Declaration_Placement_Kind --\n+   ----------------------------------------\n \n-   function Code_To_Body_Placement_Kind\n-     (Code : Character) return Body_Placement_Kind\n+   function Code_To_Declaration_Placement_Kind\n+     (Code : Character) return Declaration_Placement_Kind\n    is\n    begin\n-      --  Determine which body placement kind corresponds to the character code\n-      --  by traversing the contents of the mapping table.\n+      --  Determine which placement kind corresponds to the character code by\n+      --  traversing the contents of the mapping table.\n \n-      for Kind in Body_Placement_Kind loop\n-         if Body_Placement_Codes (Kind) = Code then\n+      for Kind in Declaration_Placement_Kind loop\n+         if Declaration_Placement_Codes (Kind) = Code then\n             return Kind;\n          end if;\n       end loop;\n \n       raise Program_Error;\n-   end Code_To_Body_Placement_Kind;\n+   end Code_To_Declaration_Placement_Kind;\n \n    ---------------------------------------\n    -- Code_To_Invocation_Construct_Kind --\n@@ -263,6 +392,26 @@ package body ALI is\n       raise Program_Error;\n    end Code_To_Invocation_Construct_Kind;\n \n+   --------------------------------------------\n+   -- Code_To_Invocation_Graph_Encoding_Kind --\n+   --------------------------------------------\n+\n+   function Code_To_Invocation_Graph_Encoding_Kind\n+     (Code : Character) return Invocation_Graph_Encoding_Kind\n+   is\n+   begin\n+      --  Determine which invocation-graph encoding kind matches the character\n+      --  code by traversing the contents of the mapping table.\n+\n+      for Kind in Invocation_Graph_Encoding_Kind loop\n+         if Invocation_Graph_Encoding_Codes (Kind) = Code then\n+            return Kind;\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+   end Code_To_Invocation_Graph_Encoding_Kind;\n+\n    -----------------------------\n    -- Code_To_Invocation_Kind --\n    -----------------------------\n@@ -291,7 +440,7 @@ package body ALI is\n      (Code : Character) return Invocation_Graph_Line_Kind\n    is\n    begin\n-      --  Determine which invocation graph line kind matches the character\n+      --  Determine which invocation-graph line kind matches the character\n       --  code by traversing the contents of the mapping table.\n \n       for Kind in Invocation_Graph_Line_Kind loop\n@@ -303,6 +452,27 @@ package body ALI is\n       raise Program_Error;\n    end Code_To_Invocation_Graph_Line_Kind;\n \n+   ------------\n+   -- Column --\n+   ------------\n+\n+   function Column (IS_Id : Invocation_Signature_Id) return Nat is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Column;\n+   end Column;\n+\n+   ----------------------------------------\n+   -- Declaration_Placement_Kind_To_Code --\n+   ----------------------------------------\n+\n+   function Declaration_Placement_Kind_To_Code\n+     (Kind : Declaration_Placement_Kind) return Character\n+   is\n+   begin\n+      return Declaration_Placement_Codes (Kind);\n+   end Declaration_Placement_Kind_To_Code;\n+\n    -------------\n    -- Destroy --\n    -------------\n@@ -313,6 +483,50 @@ package body ALI is\n       null;\n    end Destroy;\n \n+   -----------\n+   -- Extra --\n+   -----------\n+\n+   function Extra (IR_Id : Invocation_Relation_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Extra;\n+   end Extra;\n+\n+   -----------------------------------\n+   -- For_Each_Invocation_Construct --\n+   -----------------------------------\n+\n+   procedure For_Each_Invocation_Construct\n+     (Processor : Invocation_Construct_Processor_Ptr)\n+   is\n+   begin\n+      pragma Assert (Processor /= null);\n+\n+      for IC_Id in Invocation_Constructs.First ..\n+                   Invocation_Constructs.Last\n+      loop\n+         Processor.all (IC_Id);\n+      end loop;\n+   end For_Each_Invocation_Construct;\n+\n+   ----------------------------------\n+   -- For_Each_Invocation_Relation --\n+   ----------------------------------\n+\n+   procedure For_Each_Invocation_Relation\n+     (Processor : Invocation_Relation_Processor_Ptr)\n+   is\n+   begin\n+      pragma Assert (Processor /= null);\n+\n+      for IR_Id in Invocation_Relations.First ..\n+                   Invocation_Relations.Last\n+      loop\n+         Processor.all (IR_Id);\n+      end loop;\n+   end For_Each_Invocation_Relation;\n+\n    ----------\n    -- Hash --\n    ----------\n@@ -428,6 +642,26 @@ package body ALI is\n       return Invocation_Construct_Codes (Kind);\n    end Invocation_Construct_Kind_To_Code;\n \n+   -------------------------------\n+   -- Invocation_Graph_Encoding --\n+   -------------------------------\n+\n+   function Invocation_Graph_Encoding return Invocation_Graph_Encoding_Kind is\n+   begin\n+      return Compile_Time_Invocation_Graph_Encoding;\n+   end Invocation_Graph_Encoding;\n+\n+   --------------------------------------------\n+   -- Invocation_Graph_Encoding_Kind_To_Code --\n+   --------------------------------------------\n+\n+   function Invocation_Graph_Encoding_Kind_To_Code\n+     (Kind : Invocation_Graph_Encoding_Kind) return Character\n+   is\n+   begin\n+      return Invocation_Graph_Encoding_Codes (Kind);\n+   end Invocation_Graph_Encoding_Kind_To_Code;\n+\n    ----------------------------------------\n    -- Invocation_Graph_Line_Kind_To_Code --\n    ----------------------------------------\n@@ -488,6 +722,70 @@ package body ALI is\n       return IS_Id;\n    end Invocation_Signature_Of;\n \n+   -------------\n+   -- Invoker --\n+   -------------\n+\n+   function Invoker\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id\n+   is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Invoker;\n+   end Invoker;\n+\n+   ----------\n+   -- Kind --\n+   ----------\n+\n+   function Kind\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Construct_Kind\n+   is\n+   begin\n+      pragma Assert (Present (IC_Id));\n+      return Invocation_Constructs.Table (IC_Id).Kind;\n+   end Kind;\n+\n+   ----------\n+   -- Kind --\n+   ----------\n+\n+   function Kind (IR_Id : Invocation_Relation_Id) return Invocation_Kind is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Kind;\n+   end Kind;\n+\n+   ----------\n+   -- Line --\n+   ----------\n+\n+   function Line (IS_Id : Invocation_Signature_Id) return Nat is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Line;\n+   end Line;\n+\n+   ---------------\n+   -- Locations --\n+   ---------------\n+\n+   function Locations (IS_Id : Invocation_Signature_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Locations;\n+   end Locations;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (IS_Id : Invocation_Signature_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Name;\n+   end Name;\n+\n    -------------\n    -- Present --\n    -------------\n@@ -638,7 +936,7 @@ package body ALI is\n       --\n       --    If Ignore_Special is False (normal case), the scan is terminated by\n       --    a typeref bracket or an equal sign except for the special case of\n-      --    an operator name starting with a double quote which is terminated\n+      --    an operator name starting with a double quote that is terminated\n       --    by another double quote.\n       --\n       --    If May_Be_Quoted is True and the first non blank character is '\"'\n@@ -674,7 +972,7 @@ package body ALI is\n       --  Parse the definition of a typeref (<...>, {...} or (...))\n \n       procedure Scan_Invocation_Graph_Line;\n-      --  Parse a single line which encodes a piece of the invocation graph\n+      --  Parse a single line that encodes a piece of the invocation graph\n \n       procedure Skip_Eol;\n       --  Skip past spaces, then skip past end of line (fatal error if not\n@@ -1204,6 +1502,13 @@ package body ALI is\n          --    * Invocation_Constructs\n          --    * Units\n \n+         procedure Scan_Invocation_Graph_Attributes_Line;\n+         pragma Inline (Scan_Invocation_Graph_Attributes_Line);\n+         --  Parse an invocation-graph attributes line. The following data\n+         --  structures are updated:\n+         --\n+         --    * Units\n+\n          procedure Scan_Invocation_Relation_Line;\n          pragma Inline (Scan_Invocation_Relation_Line);\n          --  Parse an invocation relation line and construct the corresponding\n@@ -1225,72 +1530,99 @@ package body ALI is\n          ------------------------------------\n \n          procedure Scan_Invocation_Construct_Line is\n-            IC_Rec : Invocation_Construct_Record;\n+            Body_Placement : Declaration_Placement_Kind;\n+            Kind           : Invocation_Construct_Kind;\n+            Signature      : Invocation_Signature_Id;\n+            Spec_Placement : Declaration_Placement_Kind;\n \n          begin\n             --  construct-kind\n \n-            IC_Rec.Kind := Code_To_Invocation_Construct_Kind (Getc);\n+            Kind := Code_To_Invocation_Construct_Kind (Getc);\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  construct-spec-placement\n+\n+            Spec_Placement := Code_To_Declaration_Placement_Kind (Getc);\n             Checkc (' ');\n             Skip_Space;\n \n             --  construct-body-placement\n \n-            IC_Rec.Placement := Code_To_Body_Placement_Kind (Getc);\n+            Body_Placement := Code_To_Declaration_Placement_Kind (Getc);\n             Checkc (' ');\n             Skip_Space;\n \n             --  construct-signature\n \n-            IC_Rec.Signature := Scan_Invocation_Signature;\n-            pragma Assert (Present (IC_Rec.Signature));\n-\n+            Signature := Scan_Invocation_Signature;\n             Skip_Eol;\n \n-            Add_Invocation_Construct (IC_Rec);\n+            Add_Invocation_Construct\n+              (Body_Placement => Body_Placement,\n+               Kind           => Kind,\n+               Signature      => Signature,\n+               Spec_Placement => Spec_Placement);\n          end Scan_Invocation_Construct_Line;\n \n+         -------------------------------------------\n+         -- Scan_Invocation_Graph_Attributes_Line --\n+         -------------------------------------------\n+\n+         procedure Scan_Invocation_Graph_Attributes_Line is\n+         begin\n+            --  encoding-kind\n+\n+            Set_Invocation_Graph_Encoding\n+              (Code_To_Invocation_Graph_Encoding_Kind (Getc));\n+            Skip_Eol;\n+         end Scan_Invocation_Graph_Attributes_Line;\n+\n          -----------------------------------\n          -- Scan_Invocation_Relation_Line --\n          -----------------------------------\n \n          procedure Scan_Invocation_Relation_Line is\n-            IR_Rec : Invocation_Relation_Record;\n+            Extra   : Name_Id;\n+            Invoker : Invocation_Signature_Id;\n+            Kind    : Invocation_Kind;\n+            Target  : Invocation_Signature_Id;\n \n          begin\n             --  relation-kind\n \n-            IR_Rec.Kind := Code_To_Invocation_Kind (Getc);\n+            Kind := Code_To_Invocation_Kind (Getc);\n             Checkc (' ');\n             Skip_Space;\n \n             --  (extra-name | \"none\")\n \n-            IR_Rec.Extra := Get_Name;\n+            Extra := Get_Name;\n \n-            if IR_Rec.Extra = Name_None then\n-               IR_Rec.Extra := No_Name;\n+            if Extra = Name_None then\n+               Extra := No_Name;\n             end if;\n \n             Checkc (' ');\n             Skip_Space;\n \n             --  invoker-signature\n \n-            IR_Rec.Invoker := Scan_Invocation_Signature;\n-            pragma Assert (Present (IR_Rec.Invoker));\n-\n+            Invoker := Scan_Invocation_Signature;\n             Checkc (' ');\n             Skip_Space;\n \n             --  target-signature\n \n-            IR_Rec.Target := Scan_Invocation_Signature;\n-            pragma Assert (Present (IR_Rec.Target));\n-\n+            Target := Scan_Invocation_Signature;\n             Skip_Eol;\n \n-            Add_Invocation_Relation (IR_Rec);\n+            Add_Invocation_Relation\n+              (Extra   => Extra,\n+               Invoker => Invoker,\n+               Kind    => Kind,\n+               Target  => Target);\n          end Scan_Invocation_Relation_Line;\n \n          -------------------------------\n@@ -1378,13 +1710,16 @@ package body ALI is\n \n          --  line-attributes\n \n-         if Line = Invocation_Construct_Line then\n-            Scan_Invocation_Construct_Line;\n+         case Line is\n+            when Invocation_Construct_Line =>\n+               Scan_Invocation_Construct_Line;\n \n-         else\n-            pragma Assert (Line = Invocation_Relation_Line);\n-            Scan_Invocation_Relation_Line;\n-         end if;\n+            when Invocation_Graph_Attributes_Line =>\n+               Scan_Invocation_Graph_Attributes_Line;\n+\n+            when Invocation_Relation_Line =>\n+               Scan_Invocation_Relation_Line;\n+         end case;\n       end Scan_Invocation_Graph_Line;\n \n       --------------\n@@ -3064,7 +3399,7 @@ package body ALI is\n \n       ALIs.Table (Id).Last_Sdep := Sdep.Last;\n \n-      --  Loop through invocation graph lines\n+      --  Loop through invocation-graph lines\n \n       G_Loop : loop\n          Check_Unknown_Line;\n@@ -3436,6 +3771,16 @@ package body ALI is\n          return No_ALI_Id;\n    end Scan_ALI;\n \n+   -----------\n+   -- Scope --\n+   -----------\n+\n+   function Scope (IS_Id : Invocation_Signature_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Scope;\n+   end Scope;\n+\n    ---------\n    -- SEq --\n    ---------\n@@ -3445,6 +3790,30 @@ package body ALI is\n       return F1.all = F2.all;\n    end SEq;\n \n+   -----------------------------------\n+   -- Set_Invocation_Graph_Encoding --\n+   -----------------------------------\n+\n+   procedure Set_Invocation_Graph_Encoding\n+     (Kind         : Invocation_Graph_Encoding_Kind;\n+      Update_Units : Boolean := True)\n+   is\n+   begin\n+      Compile_Time_Invocation_Graph_Encoding := Kind;\n+\n+      --  Update the invocation-graph encoding of the current unit only when\n+      --  requested by the caller.\n+\n+      if Update_Units then\n+         declare\n+            Curr_Unit : Unit_Record renames Units.Table (Units.Last);\n+\n+         begin\n+            Curr_Unit.Invocation_Graph_Encoding := Kind;\n+         end;\n+      end if;\n+   end Set_Invocation_Graph_Encoding;\n+\n    -----------\n    -- SHash --\n    -----------\n@@ -3461,4 +3830,40 @@ package body ALI is\n       return Vindex (Vindex'First + Vindex (H mod Vindex'Range_Length));\n    end SHash;\n \n+   ---------------\n+   -- Signature --\n+   ---------------\n+\n+   function Signature\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Signature_Id\n+   is\n+   begin\n+      pragma Assert (Present (IC_Id));\n+      return Invocation_Constructs.Table (IC_Id).Signature;\n+   end Signature;\n+\n+   --------------------\n+   -- Spec_Placement --\n+   --------------------\n+\n+   function Spec_Placement\n+     (IC_Id : Invocation_Construct_Id) return Declaration_Placement_Kind\n+   is\n+   begin\n+      pragma Assert (Present (IC_Id));\n+      return Invocation_Constructs.Table (IC_Id).Spec_Placement;\n+   end Spec_Placement;\n+\n+   ------------\n+   -- Target --\n+   ------------\n+\n+   function Target\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id\n+   is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Target;\n+   end Target;\n+\n end ALI;"}, {"sha": "6db9e49a36fc53eb6981f829627f2a19c008c087", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 172, "deletions": 143, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -112,6 +112,20 @@ package ALI is\n    First_ALI_Entry : constant ALI_Id := No_ALI_Id + 1;\n    --  Id of first actual entry in table\n \n+   --  The following type enumerates all possible invocation-graph encoding\n+   --  kinds.\n+\n+   type Invocation_Graph_Encoding_Kind is\n+     (Endpoints_Encoding,\n+      --  The invocation construct and relation lines contain information for\n+      --  the start construct and end target found on an invocation-graph path.\n+\n+      Full_Path_Encoding,\n+      --  The invocation construct and relation lines contain information for\n+      --  all constructs and targets found on a invocation-graph path.\n+\n+      No_Encoding);\n+\n    type Main_Program_Type is (None, Proc, Func);\n    --  Indicator of whether unit can be used as main program\n \n@@ -368,6 +382,11 @@ package ALI is\n       Last_Arg : Arg_Id;\n       --  Id of last args table entry for this file\n \n+      Invocation_Graph_Encoding : Invocation_Graph_Encoding_Kind;\n+      --  The encoding format used to capture information about the invocation\n+      --  constructs and relations within the corresponding ALI file of this\n+      --  unit.\n+\n       First_Invocation_Construct : Invocation_Construct_Id;\n       --  Id of the first invocation construct for this unit\n \n@@ -1087,66 +1106,41 @@ package ALI is\n    -- Invocation Graph Types --\n    ----------------------------\n \n+   --  The following type identifies an invocation construct\n+\n+   No_Invocation_Construct    : constant Invocation_Construct_Id :=\n+                                  Invocation_Construct_Id'First;\n+   First_Invocation_Construct : constant Invocation_Construct_Id :=\n+                                  No_Invocation_Construct + 1;\n+\n+   --  The following type identifies an invocation relation\n+\n+   No_Invocation_Relation    : constant Invocation_Relation_Id :=\n+                                 Invocation_Relation_Id'First;\n+   First_Invocation_Relation : constant Invocation_Relation_Id :=\n+                                 No_Invocation_Relation + 1;\n+\n    --  The following type identifies an invocation signature\n \n    No_Invocation_Signature    : constant Invocation_Signature_Id :=\n                                   Invocation_Signature_Id'First;\n    First_Invocation_Signature : constant Invocation_Signature_Id :=\n                                   No_Invocation_Signature + 1;\n \n-   --  The following type represents an invocation signature. Its purpose is\n-   --  to uniquely identify an invocation construct within the ALI space. The\n-   --  signature is comprised out of several pieces, some of which are used in\n-   --  error diagnostics by the binder. Identification issues are resolved as\n-   --  follows:\n-   --\n-   --    * The Column, Line, and Locations attributes together differentiate\n-   --      between homonyms. In most cases, the Column and Line are sufficient\n-   --      except when generic instantiations are involved. Together, the three\n-   --      attributes offer a sequence of column-line pairs which eventually\n-   --      reflect the location within the generic template.\n-   --\n-   --    * The Name attribute differentiates between invocation constructs at\n-   --      the scope level. Since it is illegal for two entities with the same\n-   --      name to coexist in the same scope, the Name attribute is sufficient\n-   --      to distinguish them. Overloaded entities are already handled by the\n-   --      Column, Line, and Locations attributes.\n-   --\n-   --    * The Scope attribute differentiates between invocation constructs at\n-   --      various levels of nesting.\n-\n-   type Invocation_Signature_Record is record\n-      Column : Nat := 0;\n-      --  The column number where the invocation construct is declared\n-\n-      Line : Nat := 0;\n-      --  The line number where the invocation construct is declared\n-\n-      Locations : Name_Id := No_Name;\n-      --  Sequence of column and line numbers within nested instantiations\n-\n-      Name : Name_Id := No_Name;\n-      --  The name of the invocation construct\n-\n-      Scope : Name_Id := No_Name;\n-      --  The qualified name of the scope where the invocation construct is\n-      --  declared.\n-   end record;\n-\n    --  The following type enumerates all possible placements of an invocation\n-   --  construct's body body with respect to the unit it is declared in.\n+   --  construct's spec and body with respect to the unit it is declared in.\n \n-   type Body_Placement_Kind is\n+   type Declaration_Placement_Kind is\n      (In_Body,\n-      --  The body of the invocation construct is within the body of the unit\n-      --  it is declared in.\n+      --  The declaration of the invocation construct is within the body of the\n+      --  unit it is declared in.\n \n       In_Spec,\n-      --  The body of the invocation construct is within the spec of the unit\n-      --  it is declared in.\n+      --  The declaration of the invocation construct is within the spec of the\n+      --  unit it is declared in.\n \n-      No_Body_Placement);\n-      --  The invocation construct does not have a body\n+      No_Declaration_Placement);\n+      --  The invocation construct does not have a declaration\n \n    --  The following type enumerates all possible invocation construct kinds\n \n@@ -1162,35 +1156,6 @@ package ALI is\n       Regular_Construct);\n       --  The invocation construct is a normal invocation construct\n \n-   --  The following type identifies an invocation construct\n-\n-   No_Invocation_Construct    : constant Invocation_Construct_Id :=\n-                                  Invocation_Construct_Id'First;\n-   First_Invocation_Construct : constant Invocation_Construct_Id :=\n-                                  No_Invocation_Construct + 1;\n-\n-   --  The following type represents an invocation construct\n-\n-   type Invocation_Construct_Record is record\n-      Kind : Invocation_Construct_Kind := Regular_Construct;\n-      --  The nature of the invocation construct\n-\n-      Placement : Body_Placement_Kind := No_Body_Placement;\n-      --  The location of the invocation construct's body with respect to the\n-      --  body of the unit it is declared in.\n-\n-      Signature : Invocation_Signature_Id := No_Invocation_Signature;\n-      --  The invocation signature which uniquely identifies the invocation\n-      --  construct in the ALI space.\n-   end record;\n-\n-   --  The following type identifies an invocation relation\n-\n-   No_Invocation_Relation    : constant Invocation_Relation_Id :=\n-                                 Invocation_Relation_Id'First;\n-   First_Invocation_Relation : constant Invocation_Relation_Id :=\n-                                 No_Invocation_Relation + 1;\n-\n    --  The following type enumerates all possible invocation kinds\n \n    type Invocation_Kind is\n@@ -1220,94 +1185,60 @@ package ALI is\n    --  Internal_Controlled_Finalization\n        Internal_Controlled_Initialization;\n \n-   --  The following type represents an invocation relation. It associates an\n-   --  invoker which activates/calls/instantiates with a target.\n-\n-   type Invocation_Relation_Record is record\n-      Extra : Name_Id := No_Name;\n-      --  The name of an additional entity used in error diagnostics\n-\n-      Invoker : Invocation_Signature_Id := No_Invocation_Signature;\n-      --  The invocation signature which uniquely identifies the invoker within\n-      --  the ALI space.\n-\n-      Kind : Invocation_Kind := No_Invocation;\n-      --  The nature of the invocation\n-\n-      Target : Invocation_Signature_Id := No_Invocation_Signature;\n-      --  The invocation signature which uniquely identifies the target within\n-      --  the ALI space.\n-   end record;\n-\n-   --  The following type enumerates all possible invocation graph ALI lines\n+   --  The following type enumerates all possible invocation-graph ALI lines\n \n    type Invocation_Graph_Line_Kind is\n      (Invocation_Construct_Line,\n+      Invocation_Graph_Attributes_Line,\n       Invocation_Relation_Line);\n \n-   --------------------------------------\n-   -- Invocation Graph Data Structures --\n-   --------------------------------------\n-\n-   package Invocation_Constructs is new Table.Table\n-     (Table_Index_Type     => Invocation_Construct_Id,\n-      Table_Component_Type => Invocation_Construct_Record,\n-      Table_Low_Bound      => First_Invocation_Construct,\n-      Table_Initial        => 2500,\n-      Table_Increment      => 200,\n-      Table_Name           => \"Invocation_Constructs\");\n-\n-   package Invocation_Relations is new Table.Table\n-     (Table_Index_Type     => Invocation_Relation_Id,\n-      Table_Component_Type => Invocation_Relation_Record,\n-      Table_Low_Bound      => First_Invocation_Relation,\n-      Table_Initial        => 2500,\n-      Table_Increment      => 200,\n-      Table_Name           => \"Invocation_Relation\");\n-\n-   package Invocation_Signatures is new Table.Table\n-     (Table_Index_Type     => Invocation_Signature_Id,\n-      Table_Component_Type => Invocation_Signature_Record,\n-      Table_Low_Bound      => First_Invocation_Signature,\n-      Table_Initial        => 2500,\n-      Table_Increment      => 200,\n-      Table_Name           => \"Invocation_Signatures\");\n-\n    ----------------------------------\n    -- Invocation Graph Subprograms --\n    ----------------------------------\n \n    procedure Add_Invocation_Construct\n-     (IC_Rec       : Invocation_Construct_Record;\n-      Update_Units : Boolean := True);\n+     (Body_Placement : Declaration_Placement_Kind;\n+      Kind           : Invocation_Construct_Kind;\n+      Signature      : Invocation_Signature_Id;\n+      Spec_Placement : Declaration_Placement_Kind;\n+      Update_Units   : Boolean := True);\n    pragma Inline (Add_Invocation_Construct);\n-   --  Add invocation construct attributes IC_Rec to internal data structures.\n-   --  Flag Undate_Units should be set when this addition must be reflected in\n-   --  the attributes of the current unit.\n+   --  Add a new invocation construct described by its attributes. Update_Units\n+   --  should be set when this addition must be reflected in the attributes of\n+   --  the current unit.\n \n    procedure Add_Invocation_Relation\n-     (IR_Rec       : Invocation_Relation_Record;\n+     (Extra        : Name_Id;\n+      Invoker      : Invocation_Signature_Id;\n+      Kind         : Invocation_Kind;\n+      Target       : Invocation_Signature_Id;\n       Update_Units : Boolean := True);\n    pragma Inline (Add_Invocation_Relation);\n-   --  Add invocation relation attributes IR_Rec to internal data structures.\n-   --  Flag Undate_Units should be set when this addition must be reflected in\n-   --  the attributes of the current unit.\n+   --  Add a new invocation relation described by its attributes. Update_Units\n+   --  should be set when this addition must be reflected in the attributes of\n+   --  the current unit.\n \n-   function Body_Placement_Kind_To_Code\n-     (Kind : Body_Placement_Kind) return Character;\n-   pragma Inline (Body_Placement_Kind_To_Code);\n-   --  Obtain the character encoding of body placement kind Kind\n+   function Body_Placement\n+     (IC_Id : Invocation_Construct_Id) return Declaration_Placement_Kind;\n+   pragma Inline (Body_Placement);\n+   --  Obtain the location of invocation construct IC_Id's body with respect to\n+   --  the unit where it is declared.\n \n-   function Code_To_Body_Placement_Kind\n-     (Code : Character) return Body_Placement_Kind;\n-   pragma Inline (Code_To_Body_Placement_Kind);\n-   --  Obtain the body placement kind of character encoding Code\n+   function Code_To_Declaration_Placement_Kind\n+     (Code : Character) return Declaration_Placement_Kind;\n+   pragma Inline (Code_To_Declaration_Placement_Kind);\n+   --  Obtain the declaration placement kind of character encoding Code\n \n    function Code_To_Invocation_Construct_Kind\n      (Code : Character) return Invocation_Construct_Kind;\n    pragma Inline (Code_To_Invocation_Construct_Kind);\n    --  Obtain the invocation construct kind of character encoding Code\n \n+   function Code_To_Invocation_Graph_Encoding_Kind\n+     (Code : Character) return Invocation_Graph_Encoding_Kind;\n+   pragma Inline (Code_To_Invocation_Graph_Encoding_Kind);\n+   --  Obtain the invocation-graph encoding kind of character encoding Code\n+\n    function Code_To_Invocation_Kind\n      (Code : Character) return Invocation_Kind;\n    pragma Inline (Code_To_Invocation_Kind);\n@@ -1316,17 +1247,58 @@ package ALI is\n    function Code_To_Invocation_Graph_Line_Kind\n      (Code : Character) return Invocation_Graph_Line_Kind;\n    pragma Inline (Code_To_Invocation_Graph_Line_Kind);\n-   --  Obtain the invocation graph line kind of character encoding Code\n+   --  Obtain the invocation-graph line kind of character encoding Code\n+\n+   function Column (IS_Id : Invocation_Signature_Id) return Nat;\n+   pragma Inline (Column);\n+   --  Obtain the column number of invocation signature IS_Id\n+\n+   function Declaration_Placement_Kind_To_Code\n+     (Kind : Declaration_Placement_Kind) return Character;\n+   pragma Inline (Declaration_Placement_Kind_To_Code);\n+   --  Obtain the character encoding of declaration placement kind Kind\n+\n+   function Extra (IR_Id : Invocation_Relation_Id) return Name_Id;\n+   pragma Inline (Extra);\n+   --  Obtain the name of the additional entity used in error diagnostics for\n+   --  invocation relation IR_Id.\n+\n+   type Invocation_Construct_Processor_Ptr is\n+     access procedure (IC_Id : Invocation_Construct_Id);\n+\n+   procedure For_Each_Invocation_Construct\n+     (Processor : Invocation_Construct_Processor_Ptr);\n+   pragma Inline (For_Each_Invocation_Construct);\n+   --  Invoke Processor on each invocation construct\n+\n+   type Invocation_Relation_Processor_Ptr is\n+     access procedure (IR_Id : Invocation_Relation_Id);\n+\n+   procedure For_Each_Invocation_Relation\n+     (Processor : Invocation_Relation_Processor_Ptr);\n+   pragma Inline (For_Each_Invocation_Relation);\n+   --  Invoker Processor on each invocation relation\n \n    function Invocation_Construct_Kind_To_Code\n      (Kind : Invocation_Construct_Kind) return Character;\n    pragma Inline (Invocation_Construct_Kind_To_Code);\n    --  Obtain the character encoding of invocation kind Kind\n \n+   function Invocation_Graph_Encoding return Invocation_Graph_Encoding_Kind;\n+   pragma Inline (Invocation_Graph_Encoding);\n+   --  Obtain the encoding format used to capture information about the\n+   --  invocation constructs and relations within the ALI file of the main\n+   --  unit.\n+\n+   function Invocation_Graph_Encoding_Kind_To_Code\n+     (Kind : Invocation_Graph_Encoding_Kind) return Character;\n+   pragma Inline (Invocation_Graph_Encoding_Kind_To_Code);\n+   --  Obtain the character encoding for invocation-graph encoding kind Kind\n+\n    function Invocation_Graph_Line_Kind_To_Code\n      (Kind : Invocation_Graph_Line_Kind) return Character;\n    pragma Inline (Invocation_Graph_Line_Kind_To_Code);\n-   --  Obtain the character encoding for invocation like kind Kind\n+   --  Obtain the character encoding for invocation line kind Kind\n \n    function Invocation_Kind_To_Code\n      (Kind : Invocation_Kind) return Character;\n@@ -1342,6 +1314,63 @@ package ALI is\n    pragma Inline (Invocation_Signature_Of);\n    --  Obtain the invocation signature that corresponds to the input attributes\n \n+   function Invoker\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id;\n+   pragma Inline (Invoker);\n+   --  Obtain the signature of the invocation relation IR_Id's invoker\n+\n+   function Kind\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Construct_Kind;\n+   pragma Inline (Kind);\n+   --  Obtain the nature of invocation construct IC_Id\n+\n+   function Kind\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Kind;\n+   pragma Inline (Kind);\n+   --  Obtain the nature of invocation relation IR_Id\n+\n+   function Line (IS_Id : Invocation_Signature_Id) return Nat;\n+   pragma Inline (Line);\n+   --  Obtain the line number of invocation signature IS_Id\n+\n+   function Locations (IS_Id : Invocation_Signature_Id) return Name_Id;\n+   pragma Inline (Locations);\n+   --  Obtain the sequence of column and line numbers within nested instances\n+   --  of invocation signature IS_Id\n+\n+   function Name (IS_Id : Invocation_Signature_Id) return Name_Id;\n+   pragma Inline (Name);\n+   --  Obtain the name of invocation signature IS_Id\n+\n+   function Scope (IS_Id : Invocation_Signature_Id) return Name_Id;\n+   pragma Inline (Scope);\n+   --  Obtain the scope of invocation signature IS_Id\n+\n+   procedure Set_Invocation_Graph_Encoding\n+     (Kind         : Invocation_Graph_Encoding_Kind;\n+      Update_Units : Boolean := True);\n+   pragma Inline (Set_Invocation_Graph_Encoding);\n+   --  Set the encoding format used to capture information about the invocation\n+   --  constructs and relations within the ALI file of the main unit to Kind.\n+   --  Update_Units should be set when this action must be reflected in the\n+   --  attributes of the current unit.\n+\n+   function Signature\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Signature_Id;\n+   pragma Inline (Signature);\n+   --  Obtain the signature of invocation construct IC_Id\n+\n+   function Spec_Placement\n+     (IC_Id : Invocation_Construct_Id) return Declaration_Placement_Kind;\n+   pragma Inline (Spec_Placement);\n+   --  Obtain the location of invocation construct IC_Id's spec with respect to\n+   --  the unit where it is declared.\n+\n+   function Target\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id;\n+   pragma Inline (Target);\n+   --  Obtain the signature of the invocation relation IR_Id's target\n+\n    --------------------------------------\n    -- Subprograms for Reading ALI File --\n    --------------------------------------"}, {"sha": "af39464328771f0b952b445a077a05d1169d338f", "filename": "gcc/ada/bindo-augmentors.adb", "status": "modified", "additions": 68, "deletions": 85, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-augmentors.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-augmentors.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-augmentors.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -29,9 +29,6 @@ with Types;  use Types;\n \n with Bindo.Writers; use Bindo.Writers;\n \n-with GNAT;      use GNAT;\n-with GNAT.Sets; use GNAT.Sets;\n-\n package body Bindo.Augmentors is\n \n    ------------------------------\n@@ -40,23 +37,13 @@ package body Bindo.Augmentors is\n \n    package body Library_Graph_Augmentors is\n \n-      -----------------\n-      -- Visited set --\n-      -----------------\n-\n-      package VS is new Membership_Sets\n-        (Element_Type => Invocation_Graph_Vertex_Id,\n-         \"=\"          => \"=\",\n-         Hash         => Hash_Invocation_Graph_Vertex);\n-      use VS;\n-\n       -----------------\n       -- Global data --\n       -----------------\n \n-      Inv_Graph : Invocation_Graph := Invocation_Graphs.Nil;\n-      Lib_Graph : Library_Graph    := Library_Graphs.Nil;\n-      Visited   : Membership_Set   := VS.Nil;\n+      Inv_Graph : Invocation_Graph        := Invocation_Graphs.Nil;\n+      Lib_Graph : Library_Graph           := Library_Graphs.Nil;\n+      Visited   : IGV_Sets.Membership_Set := IGV_Sets.Nil;\n \n       ----------------\n       -- Statistics --\n@@ -75,16 +62,16 @@ package body Bindo.Augmentors is\n       -----------------------\n \n       function Is_Visited\n-        (IGV_Id : Invocation_Graph_Vertex_Id) return Boolean;\n+        (Vertex : Invocation_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Visited);\n-      --  Determine whether invocation graph vertex IGV_Id has been visited\n+      --  Determine whether invocation graph vertex Vertex has been visited\n       --  during the traversal.\n \n       procedure Set_Is_Visited\n-        (IGV_Id : Invocation_Graph_Vertex_Id;\n+        (Vertex : Invocation_Graph_Vertex_Id;\n          Val    : Boolean := True);\n       pragma Inline (Set_Is_Visited);\n-      --  Mark invocation graph vertex IGV_Id as visited during the traversal\n+      --  Mark invocation graph vertex Vertex as visited during the traversal\n       --  depending on value Val.\n \n       procedure Visit_Elaboration_Root (Root : Invocation_Graph_Vertex_Id);\n@@ -106,26 +93,26 @@ package body Bindo.Augmentors is\n       --      successor is the current root.\n \n       procedure Visit_Vertex\n-        (Curr_IGV_Id   : Invocation_Graph_Vertex_Id;\n-         Last_LGV_Id   : Library_Graph_Vertex_Id;\n-         Root_LGV_Id   : Library_Graph_Vertex_Id;\n-         Internal_Ctrl : Boolean;\n-         Path          : Natural);\n+        (Invoker                    : Invocation_Graph_Vertex_Id;\n+         Last_Vertex                : Library_Graph_Vertex_Id;\n+         Root_Vertex                : Library_Graph_Vertex_Id;\n+         Internal_Controlled_Action : Boolean;\n+         Path                       : Natural);\n       pragma Inline (Visit_Vertex);\n-      --  Visit invocation graph vertex Curr_IGV_Id to:\n+      --  Visit invocation graph vertex Invoker to:\n       --\n       --    * Detect a transition from the last library graph vertex denoted by\n-      --      Last_LGV_Id to the library graph vertex of Curr_IGV_Id.\n+      --      Last_Vertex to the library graph vertex of Invoker.\n       --\n       --    * Create an invocation edge in library graph Lib_Graph to reflect\n       --      the transition, where the predecessor is the library graph vertex\n-      --      or Curr_IGV_Id, and the successor is Root_LGV_Id.\n+      --      or Invoker, and the successor is Root_Vertex.\n       --\n-      --    * Visit the neighbours of Curr_IGV_Id.\n+      --    * Visit the neighbours of Invoker.\n       --\n-      --  Flag Internal_Ctrl should be set when the DFS traversal visited an\n-      --  internal controlled invocation edge. Path denotes the length of the\n-      --  path.\n+      --  Flag Internal_Controlled_Action should be set when the DFS traversal\n+      --  visited an internal controlled invocation edge. Path is the length of\n+      --  the path.\n \n       procedure Write_Statistics;\n       pragma Inline (Write_Statistics);\n@@ -166,31 +153,31 @@ package body Bindo.Augmentors is\n       ----------------\n \n       function Is_Visited\n-        (IGV_Id : Invocation_Graph_Vertex_Id) return Boolean\n+        (Vertex : Invocation_Graph_Vertex_Id) return Boolean\n       is\n       begin\n-         pragma Assert (Present (Visited));\n-         pragma Assert (Present (IGV_Id));\n+         pragma Assert (IGV_Sets.Present (Visited));\n+         pragma Assert (Present (Vertex));\n \n-         return Contains (Visited, IGV_Id);\n+         return IGV_Sets.Contains (Visited, Vertex);\n       end Is_Visited;\n \n       --------------------\n       -- Set_Is_Visited --\n       --------------------\n \n       procedure Set_Is_Visited\n-        (IGV_Id : Invocation_Graph_Vertex_Id;\n+        (Vertex : Invocation_Graph_Vertex_Id;\n          Val    : Boolean := True)\n       is\n       begin\n-         pragma Assert (Present (Visited));\n-         pragma Assert (Present (IGV_Id));\n+         pragma Assert (IGV_Sets.Present (Visited));\n+         pragma Assert (Present (Vertex));\n \n          if Val then\n-            Insert (Visited, IGV_Id);\n+            IGV_Sets.Insert (Visited, Vertex);\n          else\n-            Delete (Visited, IGV_Id);\n+            IGV_Sets.Delete (Visited, Vertex);\n          end if;\n       end Set_Is_Visited;\n \n@@ -203,24 +190,24 @@ package body Bindo.Augmentors is\n          pragma Assert (Present (Root));\n          pragma Assert (Present (Lib_Graph));\n \n-         Root_LGV_Id : constant Library_Graph_Vertex_Id :=\n-                         Lib_Vertex (Inv_Graph, Root);\n+         Root_Vertex : constant Library_Graph_Vertex_Id :=\n+                         Body_Vertex (Inv_Graph, Root);\n \n-         pragma Assert (Present (Root_LGV_Id));\n+         pragma Assert (Present (Root_Vertex));\n \n       begin\n          --  Prepare the global data\n \n-         Visited := Create (Number_Of_Vertices (Inv_Graph));\n+         Visited := IGV_Sets.Create (Number_Of_Vertices (Inv_Graph));\n \n          Visit_Vertex\n-           (Curr_IGV_Id   => Root,\n-            Last_LGV_Id   => Root_LGV_Id,\n-            Root_LGV_Id   => Root_LGV_Id,\n-            Internal_Ctrl => False,\n-            Path          => 0);\n+           (Invoker                    => Root,\n+            Last_Vertex                => Root_Vertex,\n+            Root_Vertex                => Root_Vertex,\n+            Internal_Controlled_Action => False,\n+            Path                       => 0);\n \n-         Destroy (Visited);\n+         IGV_Sets.Destroy (Visited);\n       end Visit_Elaboration_Root;\n \n       -----------------------------\n@@ -237,7 +224,6 @@ package body Bindo.Augmentors is\n          Iter := Iterate_Elaboration_Roots (Inv_Graph);\n          while Has_Next (Iter) loop\n             Next (Iter, Root);\n-            pragma Assert (Present (Root));\n \n             Visit_Elaboration_Root (Root);\n          end loop;\n@@ -248,34 +234,33 @@ package body Bindo.Augmentors is\n       ------------------\n \n       procedure Visit_Vertex\n-        (Curr_IGV_Id   : Invocation_Graph_Vertex_Id;\n-         Last_LGV_Id   : Library_Graph_Vertex_Id;\n-         Root_LGV_Id   : Library_Graph_Vertex_Id;\n-         Internal_Ctrl : Boolean;\n-         Path          : Natural)\n+        (Invoker                    : Invocation_Graph_Vertex_Id;\n+         Last_Vertex                : Library_Graph_Vertex_Id;\n+         Root_Vertex                : Library_Graph_Vertex_Id;\n+         Internal_Controlled_Action : Boolean;\n+         Path                       : Natural)\n       is\n          New_Path : constant Natural := Path + 1;\n \n-         Curr_LGV_Id : Library_Graph_Vertex_Id;\n-         IGE_Id      : Invocation_Graph_Edge_Id;\n-         Iter        : Edges_To_Targets_Iterator;\n-         Targ        : Invocation_Graph_Vertex_Id;\n+         Edge           : Invocation_Graph_Edge_Id;\n+         Invoker_Vertex : Library_Graph_Vertex_Id;\n+         Iter           : Edges_To_Targets_Iterator;\n \n       begin\n          pragma Assert (Present (Inv_Graph));\n-         pragma Assert (Present (Curr_IGV_Id));\n          pragma Assert (Present (Lib_Graph));\n-         pragma Assert (Present (Last_LGV_Id));\n-         pragma Assert (Present (Root_LGV_Id));\n+         pragma Assert (Present (Invoker));\n+         pragma Assert (Present (Last_Vertex));\n+         pragma Assert (Present (Root_Vertex));\n \n          --  Nothing to do when the current invocation graph vertex has already\n          --  been visited.\n \n-         if Is_Visited (Curr_IGV_Id) then\n+         if Is_Visited (Invoker) then\n             return;\n          end if;\n \n-         Set_Is_Visited (Curr_IGV_Id);\n+         Set_Is_Visited (Invoker);\n \n          --  Update the statistics\n \n@@ -287,10 +272,10 @@ package body Bindo.Augmentors is\n          --  indicates that elaboration is transitioning from one unit to\n          --  another. Add a library graph edge to capture this dependency.\n \n-         Curr_LGV_Id := Lib_Vertex (Inv_Graph, Curr_IGV_Id);\n-         pragma Assert (Present (Curr_LGV_Id));\n+         Invoker_Vertex := Body_Vertex (Inv_Graph, Invoker);\n+         pragma Assert (Present (Invoker_Vertex));\n \n-         if Curr_LGV_Id /= Last_LGV_Id then\n+         if Invoker_Vertex /= Last_Vertex then\n \n             --  The path ultimately reaches back into the unit where the root\n             --  resides, resulting in a self dependency. In most cases this is\n@@ -299,7 +284,9 @@ package body Bindo.Augmentors is\n             --  library graph edge because the circularity is the result of\n             --  expansion and thus spurious.\n \n-            if Curr_LGV_Id = Root_LGV_Id and then Internal_Ctrl then\n+            if Invoker_Vertex = Root_Vertex\n+              and then Internal_Controlled_Action\n+            then\n                null;\n \n             --  Otherwise create the library graph edge, even if this results\n@@ -308,32 +295,28 @@ package body Bindo.Augmentors is\n             else\n                Add_Edge\n                  (G    => Lib_Graph,\n-                  Pred => Curr_LGV_Id,\n-                  Succ => Root_LGV_Id,\n+                  Pred => Invoker_Vertex,\n+                  Succ => Root_Vertex,\n                   Kind => Invocation_Edge);\n             end if;\n          end if;\n \n          --  Extend the DFS traversal to all targets of the invocation graph\n          --  vertex.\n \n-         Iter := Iterate_Edges_To_Targets (Inv_Graph, Curr_IGV_Id);\n+         Iter := Iterate_Edges_To_Targets (Inv_Graph, Invoker);\n          while Has_Next (Iter) loop\n-            Next (Iter, IGE_Id);\n-            pragma Assert (Present (IGE_Id));\n-\n-            Targ := Target (Inv_Graph, IGE_Id);\n-            pragma Assert (Present (Targ));\n+            Next (Iter, Edge);\n \n             Visit_Vertex\n-              (Curr_IGV_Id   => Targ,\n-               Last_LGV_Id   => Curr_LGV_Id,\n-               Root_LGV_Id   => Root_LGV_Id,\n-               Internal_Ctrl =>\n-                 Internal_Ctrl\n-                   or else Kind (Inv_Graph, IGE_Id) in\n+              (Invoker                    => Target (Inv_Graph, Edge),\n+               Last_Vertex                => Invoker_Vertex,\n+               Root_Vertex                => Root_Vertex,\n+               Internal_Controlled_Action =>\n+                 Internal_Controlled_Action\n+                   or else Kind (Inv_Graph, Edge) in\n                              Internal_Controlled_Invocation_Kind,\n-               Path          => New_Path);\n+               Path                       => New_Path);\n          end loop;\n       end Visit_Vertex;\n "}, {"sha": "f4b8e42fe08753cd990b12c8e86bae04a2baae47", "filename": "gcc/ada/bindo-builders.adb", "status": "modified", "additions": 111, "deletions": 118, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-builders.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-builders.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-builders.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -64,17 +64,25 @@ package body Bindo.Builders is\n \n       procedure Create_Vertex\n         (IC_Id  : Invocation_Construct_Id;\n-         LGV_Id : Library_Graph_Vertex_Id);\n+         Vertex : Library_Graph_Vertex_Id);\n       pragma Inline (Create_Vertex);\n       --  Create a new vertex for invocation construct IC_Id in invocation\n-      --  graph Inv_Graph. The vertex is linked to vertex LGV_Id of library\n+      --  graph Inv_Graph. The vertex is linked to vertex Vertex of library\n       --  graph Lib_Graph.\n \n       procedure Create_Vertices (U_Id : Unit_Id);\n       pragma Inline (Create_Vertices);\n       --  Create new vertices for all invocation constructs of unit U_Id in\n       --  invocation graph Inv_Graph.\n \n+      function Declaration_Placement_Vertex\n+        (Vertex    : Library_Graph_Vertex_Id;\n+         Placement : Declaration_Placement_Kind)\n+         return Library_Graph_Vertex_Id;\n+      pragma Inline (Declaration_Placement_Vertex);\n+      --  Obtain the spec or body of vertex Vertex depending on the requested\n+      --  placement in Placement.\n+\n       ----------------------------\n       -- Build_Invocation_Graph --\n       ----------------------------\n@@ -88,8 +96,9 @@ package body Bindo.Builders is\n          --  Prepare the global data\n \n          Inv_Graph :=\n-           Create (Initial_Vertices => Number_Of_Elaborable_Units,\n-                   Initial_Edges    => Number_Of_Elaborable_Units);\n+           Create\n+             (Initial_Vertices => Number_Of_Elaborable_Units,\n+              Initial_Edges    => Number_Of_Elaborable_Units);\n          Lib_Graph := Lib_G;\n \n          For_Each_Elaborable_Unit (Create_Vertices'Access);\n@@ -107,33 +116,24 @@ package body Bindo.Builders is\n          pragma Assert (Present (Lib_Graph));\n          pragma Assert (Present (IR_Id));\n \n-         IR_Rec : Invocation_Relation_Record renames\n-                    Invocation_Relations.Table (IR_Id);\n-\n-         pragma Assert (Present (IR_Rec.Invoker));\n-         pragma Assert (Present (IR_Rec.Target));\n+         Invoker_Sig : constant Invocation_Signature_Id := Invoker (IR_Id);\n+         Target_Sig  : constant Invocation_Signature_Id := Target  (IR_Id);\n \n-         Invoker : Invocation_Graph_Vertex_Id;\n-         Target  : Invocation_Graph_Vertex_Id;\n+         pragma Assert (Present (Invoker_Sig));\n+         pragma Assert (Present (Target_Sig));\n \n       begin\n          --  Nothing to do when the target denotes an invocation construct that\n          --  resides in a unit which will never be elaborated.\n \n-         if not Needs_Elaboration (IR_Rec.Target) then\n+         if not Needs_Elaboration (Target_Sig) then\n             return;\n          end if;\n \n-         Invoker := Corresponding_Vertex (Inv_Graph, IR_Rec.Invoker);\n-         Target  := Corresponding_Vertex (Inv_Graph, IR_Rec.Target);\n-\n-         pragma Assert (Present (Invoker));\n-         pragma Assert (Present (Target));\n-\n          Add_Edge\n            (G      => Inv_Graph,\n-            Source => Invoker,\n-            Target => Target,\n+            Source => Corresponding_Vertex (Inv_Graph, Invoker_Sig),\n+            Target => Corresponding_Vertex (Inv_Graph, Target_Sig),\n             IR_Id  => IR_Id);\n       end Create_Edge;\n \n@@ -162,35 +162,25 @@ package body Bindo.Builders is\n \n       procedure Create_Vertex\n         (IC_Id  : Invocation_Construct_Id;\n-         LGV_Id : Library_Graph_Vertex_Id)\n+         Vertex : Library_Graph_Vertex_Id)\n       is\n+      begin\n          pragma Assert (Present (Inv_Graph));\n          pragma Assert (Present (Lib_Graph));\n          pragma Assert (Present (IC_Id));\n-         pragma Assert (Present (LGV_Id));\n-\n-         IC_Rec : Invocation_Construct_Record renames\n-                    Invocation_Constructs.Table (IC_Id);\n-\n-         Body_LGV_Id : Library_Graph_Vertex_Id;\n-\n-      begin\n-         --  Determine the proper library graph vertex which holds the body of\n-         --  the invocation construct.\n-\n-         if IC_Rec.Placement = In_Body then\n-            Body_LGV_Id := Proper_Body (Lib_Graph, LGV_Id);\n-         else\n-            pragma Assert (IC_Rec.Placement = In_Spec);\n-            Body_LGV_Id := Proper_Spec (Lib_Graph, LGV_Id);\n-         end if;\n-\n-         pragma Assert (Present (Body_LGV_Id));\n+         pragma Assert (Present (Vertex));\n \n          Add_Vertex\n-           (G      => Inv_Graph,\n-            IC_Id  => IC_Id,\n-            LGV_Id => Body_LGV_Id);\n+           (G           => Inv_Graph,\n+            IC_Id       => IC_Id,\n+            Body_Vertex =>\n+              Declaration_Placement_Vertex\n+                (Vertex    => Vertex,\n+                 Placement => Body_Placement (IC_Id)),\n+            Spec_Vertex =>\n+              Declaration_Placement_Vertex\n+                (Vertex    => Vertex,\n+                 Placement => Spec_Placement (IC_Id)));\n       end Create_Vertex;\n \n       ---------------------\n@@ -203,18 +193,37 @@ package body Bindo.Builders is\n          pragma Assert (Present (U_Id));\n \n          U_Rec  : Unit_Record renames ALI.Units.Table (U_Id);\n-         LGV_Id : constant Library_Graph_Vertex_Id :=\n+         Vertex : constant Library_Graph_Vertex_Id :=\n                     Corresponding_Vertex (Lib_Graph, U_Id);\n \n-         pragma Assert (Present (LGV_Id));\n-\n       begin\n          for IC_Id in U_Rec.First_Invocation_Construct ..\n                       U_Rec.Last_Invocation_Construct\n          loop\n-            Create_Vertex (IC_Id, LGV_Id);\n+            Create_Vertex (IC_Id, Vertex);\n          end loop;\n       end Create_Vertices;\n+\n+      ----------------------------------\n+      -- Declaration_Placement_Vertex --\n+      ----------------------------------\n+\n+      function Declaration_Placement_Vertex\n+        (Vertex    : Library_Graph_Vertex_Id;\n+         Placement : Declaration_Placement_Kind)\n+         return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (Vertex));\n+\n+         if Placement = In_Body then\n+            return Proper_Body (Lib_Graph, Vertex);\n+         else\n+            pragma Assert (Placement = In_Spec);\n+            return Proper_Spec (Lib_Graph, Vertex);\n+         end if;\n+      end Declaration_Placement_Vertex;\n    end Invocation_Graph_Builders;\n \n    ----------------------------\n@@ -235,7 +244,7 @@ package body Bindo.Builders is\n       pragma Inline (Hash_Unit);\n       --  Obtain the hash value of key U_Id\n \n-      package UL is new Dynamic_Hash_Tables\n+      package Unit_Line_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Unit_Id,\n          Value_Type            => Logical_Line_Number,\n          No_Value              => No_Line_Number,\n@@ -253,9 +262,10 @@ package body Bindo.Builders is\n \n       Lib_Graph : Library_Graph := Library_Graphs.Nil;\n \n-      Unit_To_Line : UL.Dynamic_Hash_Table := UL.Nil;\n+      Unit_To_Line : Unit_Line_Tables.Dynamic_Hash_Table :=\n+                       Unit_Line_Tables.Nil;\n       --  The map of unit name -> line number, used to detect duplicate unit\n-      --  names and report errors.\n+      --  names in the forced-elaboration-order file and report errors.\n \n       -----------------------\n       -- Local subprograms --\n@@ -348,20 +358,24 @@ package body Bindo.Builders is\n       begin\n          pragma Assert (Present (U_Id));\n \n-         UL.Put (Unit_To_Line, U_Id, Line);\n+         Unit_Line_Tables.Put (Unit_To_Line, U_Id, Line);\n       end Add_Unit;\n \n       -------------------------\n       -- Build_Library_Graph --\n       -------------------------\n \n-      function Build_Library_Graph return Library_Graph is\n+      function Build_Library_Graph\n+        (Dynamically_Elaborated : Boolean) return Library_Graph\n+      is\n       begin\n          --  Prepare the global data\n \n          Lib_Graph :=\n-           Create (Initial_Vertices => Number_Of_Elaborable_Units,\n-                   Initial_Edges    => Number_Of_Elaborable_Units);\n+           Create\n+             (Initial_Vertices       => Number_Of_Elaborable_Units,\n+              Initial_Edges          => Number_Of_Elaborable_Units,\n+              Dynamically_Elaborated => Dynamically_Elaborated);\n \n          For_Each_Elaborable_Unit (Create_Vertex'Access);\n          For_Each_Elaborable_Unit (Create_Spec_And_Body_Edge'Access);\n@@ -383,14 +397,11 @@ package body Bindo.Builders is\n          pragma Assert (Present (Pred));\n          pragma Assert (Present (Succ));\n \n-         Pred_LGV_Id : constant Library_Graph_Vertex_Id :=\n+         Pred_Vertex : constant Library_Graph_Vertex_Id :=\n                          Corresponding_Vertex (Lib_Graph, Pred);\n-         Succ_LGV_Id : constant Library_Graph_Vertex_Id :=\n+         Succ_Vertex : constant Library_Graph_Vertex_Id :=\n                          Corresponding_Vertex (Lib_Graph, Succ);\n \n-         pragma Assert (Present (Pred_LGV_Id));\n-         pragma Assert (Present (Succ_LGV_Id));\n-\n       begin\n          Write_Unit_Name (Name (Pred));\n          Write_Str (\" <-- \");\n@@ -399,8 +410,8 @@ package body Bindo.Builders is\n \n          Add_Edge\n            (G    => Lib_Graph,\n-            Pred => Pred_LGV_Id,\n-            Succ => Succ_LGV_Id,\n+            Pred => Pred_Vertex,\n+            Succ => Succ_Vertex,\n             Kind => Forced_Edge);\n       end Create_Forced_Edge;\n \n@@ -409,95 +420,89 @@ package body Bindo.Builders is\n       -------------------------\n \n       procedure Create_Forced_Edges is\n-         Curr_Unit : Unit_Id;\n-         Iter      : Forced_Units_Iterator;\n-         Prev_Unit : Unit_Id;\n-         Unit_Line : Logical_Line_Number;\n-         Unit_Name : Unit_Name_Type;\n+         Current_Unit  : Unit_Id;\n+         Iter          : Forced_Units_Iterator;\n+         Previous_Unit : Unit_Id;\n+         Unit_Line     : Logical_Line_Number;\n+         Unit_Name     : Unit_Name_Type;\n \n       begin\n-         Prev_Unit    := No_Unit_Id;\n-         Unit_To_Line := UL.Create (20);\n+         Previous_Unit := No_Unit_Id;\n+         Unit_To_Line  := Unit_Line_Tables.Create (20);\n \n          --  Inspect the contents of the forced-elaboration-order file supplied\n          --  to the binder using switch -f, and diagnose each unit accordingly.\n \n          Iter := Iterate_Forced_Units;\n          while Has_Next (Iter) loop\n             Next (Iter, Unit_Name, Unit_Line);\n-            pragma Assert (Present (Unit_Name));\n \n-            Curr_Unit := Corresponding_Unit (Unit_Name);\n+            Current_Unit := Corresponding_Unit (Unit_Name);\n \n-            if not Present (Curr_Unit) then\n+            if not Present (Current_Unit) then\n                Missing_Unit_Info (Unit_Name);\n \n-            elsif Is_Internal_Unit (Curr_Unit) then\n+            elsif Is_Internal_Unit (Current_Unit) then\n                Internal_Unit_Info (Unit_Name);\n \n-            elsif Is_Duplicate_Unit (Curr_Unit) then\n-               Duplicate_Unit_Error (Curr_Unit, Unit_Name, Unit_Line);\n+            elsif Is_Duplicate_Unit (Current_Unit) then\n+               Duplicate_Unit_Error (Current_Unit, Unit_Name, Unit_Line);\n \n             --  Otherwise the unit is a valid candidate for a vertex. Create a\n             --  forced edge between each pair of units.\n \n             else\n-               Add_Unit (Curr_Unit, Unit_Line);\n+               Add_Unit (Current_Unit, Unit_Line);\n \n-               if Present (Prev_Unit) then\n+               if Present (Previous_Unit) then\n                   Create_Forced_Edge\n-                    (Pred => Prev_Unit,\n-                     Succ => Curr_Unit);\n+                    (Pred => Previous_Unit,\n+                     Succ => Current_Unit);\n                end if;\n \n-               Prev_Unit := Curr_Unit;\n+               Previous_Unit := Current_Unit;\n             end if;\n          end loop;\n \n-         UL.Destroy (Unit_To_Line);\n+         Unit_Line_Tables.Destroy (Unit_To_Line);\n       end Create_Forced_Edges;\n \n       -------------------------------\n       -- Create_Spec_And_Body_Edge --\n       -------------------------------\n \n       procedure Create_Spec_And_Body_Edge (U_Id : Unit_Id) is\n-         Aux_LGV_Id : Library_Graph_Vertex_Id;\n-         LGV_Id     : Library_Graph_Vertex_Id;\n+         Extra_Vertex : Library_Graph_Vertex_Id;\n+         Vertex       : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (Lib_Graph));\n          pragma Assert (Present (U_Id));\n \n-         LGV_Id := Corresponding_Vertex (Lib_Graph, U_Id);\n-         pragma Assert (Present (LGV_Id));\n+         Vertex := Corresponding_Vertex (Lib_Graph, U_Id);\n \n          --  The unit denotes a body that completes a previous spec. Link the\n          --  spec and body. Add an edge between the predecessor spec and the\n          --  successor body.\n \n-         if Is_Body_With_Spec (Lib_Graph, LGV_Id) then\n-            Aux_LGV_Id :=\n+         if Is_Body_With_Spec (Lib_Graph, Vertex) then\n+            Extra_Vertex :=\n               Corresponding_Vertex (Lib_Graph, Corresponding_Spec (U_Id));\n-            pragma Assert (Present (Aux_LGV_Id));\n-\n-            Set_Corresponding_Item (Lib_Graph, LGV_Id, Aux_LGV_Id);\n+            Set_Corresponding_Item (Lib_Graph, Vertex, Extra_Vertex);\n \n             Add_Edge\n               (G    => Lib_Graph,\n-               Pred => Aux_LGV_Id,\n-               Succ => LGV_Id,\n+               Pred => Extra_Vertex,\n+               Succ => Vertex,\n                Kind => Spec_Before_Body_Edge);\n \n          --  The unit denotes a spec with a completing body. Link the spec and\n          --  body.\n \n-         elsif Is_Spec_With_Body (Lib_Graph, LGV_Id) then\n-            Aux_LGV_Id :=\n+         elsif Is_Spec_With_Body (Lib_Graph, Vertex) then\n+            Extra_Vertex :=\n               Corresponding_Vertex (Lib_Graph, Corresponding_Body (U_Id));\n-            pragma Assert (Present (Aux_LGV_Id));\n-\n-            Set_Corresponding_Item (Lib_Graph, LGV_Id, Aux_LGV_Id);\n+            Set_Corresponding_Item (Lib_Graph, Vertex, Extra_Vertex);\n          end if;\n       end Create_Spec_And_Body_Edge;\n \n@@ -531,11 +536,8 @@ package body Bindo.Builders is\n          Withed_U_Id : constant Unit_Id :=\n                          Corresponding_Unit (Withed_Rec.Uname);\n \n-         pragma Assert (Present (Withed_U_Id));\n-\n-         Aux_LGV_Id    : Library_Graph_Vertex_Id;\n          Kind          : Library_Graph_Edge_Kind;\n-         Withed_LGV_Id : Library_Graph_Vertex_Id;\n+         Withed_Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          --  Nothing to do when the withed unit does not need to be elaborated.\n@@ -545,8 +547,7 @@ package body Bindo.Builders is\n             return;\n          end if;\n \n-         Withed_LGV_Id := Corresponding_Vertex (Lib_Graph, Withed_U_Id);\n-         pragma Assert (Present (Withed_LGV_Id));\n+         Withed_Vertex := Corresponding_Vertex (Lib_Graph, Withed_U_Id);\n \n          --  The with comes with pragma Elaborate\n \n@@ -557,15 +558,12 @@ package body Bindo.Builders is\n             --  between the body of the withed predecessor and the withing\n             --  successor.\n \n-            if Is_Spec_With_Body (Lib_Graph, Withed_LGV_Id) then\n-               Aux_LGV_Id :=\n-                 Corresponding_Vertex\n-                   (Lib_Graph, Corresponding_Body (Withed_U_Id));\n-               pragma Assert (Present (Aux_LGV_Id));\n-\n+            if Is_Spec_With_Body (Lib_Graph, Withed_Vertex) then\n                Add_Edge\n                  (G    => Lib_Graph,\n-                  Pred => Aux_LGV_Id,\n+                  Pred =>\n+                    Corresponding_Vertex\n+                      (Lib_Graph, Corresponding_Body (Withed_U_Id)),\n                   Succ => Succ,\n                   Kind => Kind);\n             end if;\n@@ -586,7 +584,7 @@ package body Bindo.Builders is\n \n          Add_Edge\n            (G    => Lib_Graph,\n-            Pred => Withed_LGV_Id,\n+            Pred => Withed_Vertex,\n             Succ => Succ,\n             Kind => Kind);\n       end Create_With_Edge;\n@@ -596,18 +594,13 @@ package body Bindo.Builders is\n       -----------------------\n \n       procedure Create_With_Edges (U_Id : Unit_Id) is\n-         LGV_Id : Library_Graph_Vertex_Id;\n-\n       begin\n          pragma Assert (Present (Lib_Graph));\n          pragma Assert (Present (U_Id));\n \n-         LGV_Id := Corresponding_Vertex (Lib_Graph, U_Id);\n-         pragma Assert (Present (LGV_Id));\n-\n          Create_With_Edges\n            (U_Id => U_Id,\n-            Succ => LGV_Id);\n+            Succ => Corresponding_Vertex (Lib_Graph, U_Id));\n       end Create_With_Edges;\n \n       -----------------------\n@@ -655,7 +648,7 @@ package body Bindo.Builders is\n          pragma Assert (Present (Nam));\n \n          Prev_Line : constant Logical_Line_Number :=\n-                       UL.Get (Unit_To_Line, U_Id);\n+                       Unit_Line_Tables.Get (Unit_To_Line, U_Id);\n \n       begin\n          Error_Msg_Nat_1  := Nat (Line);\n@@ -698,7 +691,7 @@ package body Bindo.Builders is\n       begin\n          pragma Assert (Present (U_Id));\n \n-         return UL.Contains (Unit_To_Line, U_Id);\n+         return Unit_Line_Tables.Contains (Unit_To_Line, U_Id);\n       end Is_Duplicate_Unit;\n \n       -------------------------"}, {"sha": "0e8519fd1eb3fd10655ab3c5a258448770690195", "filename": "gcc/ada/bindo-builders.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-builders.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-builders.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-builders.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -56,9 +56,11 @@ package Bindo.Builders is\n    ----------------------------\n \n    package Library_Graph_Builders is\n-      function Build_Library_Graph return Library_Graph;\n+      function Build_Library_Graph\n+        (Dynamically_Elaborated : Boolean) return Library_Graph;\n       --  Return a new library graph that reflects the dependencies between\n-      --  all units of the bind.\n+      --  all units of the bind. Flag Dynamically_Elaborated must be set when\n+      --  the main library unit was compiled using the dynamic model.\n \n    end Library_Graph_Builders;\n "}, {"sha": "a4b031d0006b02b7d6387695445b4fd5b3a9b59e", "filename": "gcc/ada/bindo-diagnostics.adb", "status": "modified", "additions": 1438, "deletions": 31, "changes": 1469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-diagnostics.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-diagnostics.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-diagnostics.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -23,50 +23,1457 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Binderr; use Binderr;\n+with Debug;   use Debug;\n+with Types;   use Types;\n+\n+with Bindo.Validators;\n+use  Bindo.Validators;\n+use  Bindo.Validators.Cycle_Validators;\n+\n+with Bindo.Writers;\n+use  Bindo.Writers;\n+use  Bindo.Writers.Cycle_Writers;\n+\n package body Bindo.Diagnostics is\n \n    -----------------------\n-   -- Cycle_Diagnostics --\n+   -- Local subprograms --\n+   -----------------------\n+\n+   procedure Diagnose_All_Cycles\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph);\n+   pragma Inline (Diagnose_All_Cycles);\n+   --  Emit diagnostics for all cycles of library graph G\n+\n+   procedure Diagnose_Cycle\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph;\n+      Cycle     : Library_Graph_Cycle_Id);\n+   pragma Inline (Diagnose_Cycle);\n+   --  Emit diagnostics for cycle Cycle of library graph G\n+\n+   procedure Find_And_Output_Invocation_Paths\n+     (Inv_Graph   : Invocation_Graph;\n+      Lib_Graph   : Library_Graph;\n+      Source      : Library_Graph_Vertex_Id;\n+      Destination : Library_Graph_Vertex_Id);\n+   pragma Inline (Find_And_Output_Invocation_Paths);\n+   --  Find all paths in invocation graph Inv_Graph that originate from vertex\n+   --  Source and reach vertex Destination of library graph Lib_Graph. Output\n+   --  the transitions of each such path.\n+\n+   function Find_Elaboration_Root\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph;\n+      Vertex : Library_Graph_Vertex_Id) return Invocation_Graph_Vertex_Id;\n+   pragma Inline (Find_Elaboration_Root);\n+   --  Find the elaboration root in invocation graph Inv_Graph that corresponds\n+   --  to vertex Vertex of library graph Lib_Graph.\n+\n+   procedure Output_All_Cycles_Suggestions (G : Library_Graph);\n+   pragma Inline (Output_All_Cycles_Suggestions);\n+   --  Suggest the diagnostic of all cycles in library graph G if circumstances\n+   --  allow it.\n+\n+   procedure Output_Dynamic_Model_Suggestions\n+     (G     : Library_Graph;\n+      Cycle : Library_Graph_Cycle_Id);\n+   pragma Inline (Output_Dynamic_Model_Suggestions);\n+   --  Suggest the use of the dynamic elaboration model to break cycle Cycle of\n+   --  library graph G if circumstances allow it.\n+\n+   procedure Output_Elaborate_All_Suggestions\n+     (G    : Library_Graph;\n+      Pred : Library_Graph_Vertex_Id;\n+      Succ : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Elaborate_All_Suggestions);\n+   --  Suggest ways to break a cycle that involves an Elaborate_All edge that\n+   --  links predecessor Pred and successor Succ of library graph G.\n+\n+   procedure Output_Elaborate_All_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Elaborate_All_Transition);\n+   --  Output a transition through an Elaborate_All edge of library graph G\n+   --  with successor Source and predecessor Actual_Destination. Parameter\n+   --  Expected_Destination denotes the predecessor as specified by the next\n+   --  edge in a cycle.\n+\n+   procedure Output_Elaborate_Body_Suggestions\n+     (G    : Library_Graph;\n+      Succ : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Elaborate_Body_Suggestions);\n+   --  Suggest ways to break a cycle that involves an edge where successor Succ\n+   --  is either a spec subject to pragma Elaborate_Body or the body of such a\n+   --  spec.\n+\n+   procedure Output_Elaborate_Body_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Elaborate_Body_Transition);\n+   --  Output a transition through an edge of library graph G with successor\n+   --  Source and predecessor Actual_Destination. Vertex Source is either a\n+   --  spec subject to pragma Elaborate_Body or denotes the body of such a\n+   --  spec. Expected_Destination denotes the predecessor as specified by the\n+   --  next edge in a cycle.\n+\n+   procedure Output_Elaborate_Suggestions\n+     (G    : Library_Graph;\n+      Pred : Library_Graph_Vertex_Id;\n+      Succ : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Elaborate_Suggestions);\n+   --  Suggest ways to break a cycle that involves an Elaborate edge that links\n+   --  predecessor Pred and successor Succ of library graph G.\n+\n+   procedure Output_Elaborate_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Elaborate_Transition);\n+   --  Output a transition through an Elaborate edge of library graph G\n+   --  with successor Source and predecessor Actual_Destination. Parameter\n+   --  Expected_Destination denotes the predecessor as specified by the next\n+   --  edge in a cycle.\n+\n+   procedure Output_Forced_Suggestions\n+     (G    : Library_Graph;\n+      Pred : Library_Graph_Vertex_Id;\n+      Succ : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Forced_Suggestions);\n+   --  Suggest ways to break a cycle that involves a Forced edge that links\n+   --  predecessor Pred with successor Succ of library graph G.\n+\n+   procedure Output_Forced_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id;\n+      Elaborate_All_Active : Boolean);\n+   pragma Inline (Output_Forced_Transition);\n+   --  Output a transition through a Forced edge of library graph G with\n+   --  successor Source and predecessor Actual_Destination. Parameter\n+   --  Expected_Destination denotes the predecessor as specified by the\n+   --  next edge in a cycle.\n+\n+   procedure Output_Full_Encoding_Suggestions\n+     (G          : Library_Graph;\n+      Cycle      : Library_Graph_Cycle_Id;\n+      First_Edge : Library_Graph_Edge_Id);\n+   pragma Inline (Output_Full_Encoding_Suggestions);\n+   --  Suggest the use of the full path invocation graph encoding to break\n+   --  cycle Cycle with initial edge First_Edge of library graph G.\n+\n+   procedure Output_Invocation_Path\n+     (Inv_Graph         : Invocation_Graph;\n+      Lib_Graph         : Library_Graph;\n+      Elaborated_Vertex : Library_Graph_Vertex_Id;\n+      Path              : IGE_Lists.Doubly_Linked_List;\n+      Path_Id           : in out Nat);\n+   pragma Inline (Output_Invocation_Path);\n+   --  Output path Path, which consists of invocation graph Inv_Graph edges.\n+   --  Elaborated_Vertex is the vertex of library graph Lib_Graph whose\n+   --  elaboration initiated the path. Path_Id is the unique id of the path.\n+\n+   procedure Output_Invocation_Path_Transition\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph;\n+      Edge      : Invocation_Graph_Edge_Id);\n+   pragma Inline (Output_Invocation_Path_Transition);\n+   --  Output a transition through edge Edge of invocation graph G, which is\n+   --  part of an invocation path. Lib_Graph is the related library graph.\n+\n+   procedure Output_Invocation_Transition\n+     (Inv_Graph   : Invocation_Graph;\n+      Lib_Graph   : Library_Graph;\n+      Source      : Library_Graph_Vertex_Id;\n+      Destination : Library_Graph_Vertex_Id);\n+   pragma Inline (Output_Invocation_Transition);\n+   --  Output a transition through an invocation edge of library graph G with\n+   --  successor Source and predecessor Destination. Inv_Graph is the related\n+   --  invocation graph.\n+\n+   procedure Output_Reason_And_Circularity_Header\n+     (G          : Library_Graph;\n+      First_Edge : Library_Graph_Edge_Id);\n+   pragma Inline (Output_Reason_And_Circularity_Header);\n+   --  Output the reason and circularity header for a circularity of library\n+   --  graph G with initial edge First_Edge.\n+\n+   procedure Output_Suggestions\n+     (G          : Library_Graph;\n+      Cycle      : Library_Graph_Cycle_Id;\n+      First_Edge : Library_Graph_Edge_Id);\n+   pragma Inline (Output_Suggestions);\n+   --  Suggest various ways to break cycle Cycle with initial edge First_Edge\n+   --  of library graph G.\n+\n+   procedure Output_Transition\n+     (Inv_Graph            : Invocation_Graph;\n+      Lib_Graph            : Library_Graph;\n+      Current_Edge         : Library_Graph_Edge_Id;\n+      Next_Edge            : Library_Graph_Edge_Id;\n+      Elaborate_All_Active : Boolean);\n+   pragma Inline (Output_Transition);\n+   --  Output a transition described by edge Current_Edge, which is followed by\n+   --  edge Next_Edge of library graph Lib_Graph. Inv_Graph denotes the related\n+   --  invocation graph. Elaborate_All_Active should be set when the transition\n+   --  occurs within a cycle that involves an Elaborate_All edge.\n+\n+   procedure Output_With_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id;\n+      Elaborate_All_Active : Boolean);\n+   pragma Inline (Output_With_Transition);\n+   --  Output a transition through a regular with edge of library graph G\n+   --  with successor Source and predecessor Actual_Destination. Parameter\n+   --  Expected_Destination denotes the predecessor as specified by the next\n+   --  edge in a cycle. Elaborate_All_Active should be set when the transition\n+   --  occurs within a cycle that involves an Elaborate_All edge.\n+\n+   procedure Visit_Vertex\n+     (Inv_Graph         : Invocation_Graph;\n+      Lib_Graph         : Library_Graph;\n+      Invoker           : Invocation_Graph_Vertex_Id;\n+      Invoker_Vertex    : Library_Graph_Vertex_Id;\n+      Last_Vertex       : Library_Graph_Vertex_Id;\n+      Elaborated_Vertex : Library_Graph_Vertex_Id;\n+      End_Vertex        : Library_Graph_Vertex_Id;\n+      Path              : IGE_Lists.Doubly_Linked_List;\n+      Path_Id           : in out Nat);\n+   pragma Inline (Visit_Vertex);\n+   --  Visit invocation graph vertex Invoker that resides in library graph\n+   --  vertex Invoker_Vertex as part of a DFS traversal. Last_Vertex denotes\n+   --  the previous vertex in the traversal. Elaborated_Vertex is the vertex\n+   --  whose elaboration started the traversal. End_Vertex is the vertex that\n+   --  terminates the traversal. All edges along the path are recorded in Path.\n+   --  Path_Id is the id of the path.\n+\n+   -------------------------\n+   -- Diagnose_All_Cycles --\n+   -------------------------\n+\n+   procedure Diagnose_All_Cycles\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph)\n+   is\n+      Cycle : Library_Graph_Cycle_Id;\n+      Iter  : All_Cycle_Iterator;\n+\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+\n+      Iter := Iterate_All_Cycles (Lib_Graph);\n+      while Has_Next (Iter) loop\n+         Next (Iter, Cycle);\n+\n+         Diagnose_Cycle\n+           (Inv_Graph => Inv_Graph,\n+            Lib_Graph => Lib_Graph,\n+            Cycle     => Cycle);\n+      end loop;\n+   end Diagnose_All_Cycles;\n+\n+   --------------------------\n+   -- Diagnose_Circularities --\n+   --------------------------\n+\n+   procedure Diagnose_Circularities\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph)\n+   is\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+\n+      --  Find, validate, and output all cycles of the library graph\n+\n+      Find_Cycles     (Lib_Graph);\n+      Validate_Cycles (Lib_Graph);\n+      Write_Cycles    (Lib_Graph);\n+\n+      --  Diagnose all cycles in the graph regardless of their importance when\n+      --  switch -d_C (diagnose all cycles) is in effect.\n+\n+      if Debug_Flag_Underscore_CC then\n+         Diagnose_All_Cycles (Inv_Graph, Lib_Graph);\n+\n+      --  Otherwise diagnose the most important cycle in the graph\n+\n+      else\n+         Diagnose_Cycle\n+           (Inv_Graph => Inv_Graph,\n+            Lib_Graph => Lib_Graph,\n+            Cycle     => Highest_Precedence_Cycle (Lib_Graph));\n+      end if;\n+   end Diagnose_Circularities;\n+\n+   --------------------\n+   -- Diagnose_Cycle --\n+   --------------------\n+\n+   procedure Diagnose_Cycle\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph;\n+      Cycle     : Library_Graph_Cycle_Id)\n+   is\n+      Current_Edge         : Library_Graph_Edge_Id;\n+      Elaborate_All_Active : Boolean;\n+      First_Edge           : Library_Graph_Edge_Id;\n+      Iter                 : Edges_Of_Cycle_Iterator;\n+      Next_Edge            : Library_Graph_Edge_Id;\n+\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Cycle));\n+\n+      Elaborate_All_Active := False;\n+      First_Edge := No_Library_Graph_Edge;\n+\n+      --  Inspect the edges of the cycle in pairs, emitting diagnostics based\n+      --  on their successors and predecessors.\n+\n+      Iter := Iterate_Edges_Of_Cycle (Lib_Graph, Cycle);\n+      while Has_Next (Iter) loop\n+\n+         --  Emit the reason for the cycle using the initial edge, which is the\n+         --  most important edge in the cycle.\n+\n+         if not Present (First_Edge) then\n+            Next (Iter, Current_Edge);\n+\n+            First_Edge := Current_Edge;\n+            Elaborate_All_Active :=\n+              Is_Elaborate_All_Edge\n+                (G    => Lib_Graph,\n+                 Edge => First_Edge);\n+\n+            Output_Reason_And_Circularity_Header\n+              (G          => Lib_Graph,\n+               First_Edge => First_Edge);\n+         end if;\n+\n+         --  Obtain the other edge of the pair\n+\n+         exit when not Has_Next (Iter);\n+         Next (Iter, Next_Edge);\n+\n+         --  Describe the transition from the current edge to the next edge by\n+         --  taking into account the predecessors and successors involved, as\n+         --  well as the nature of the edge.\n+\n+         Output_Transition\n+           (Inv_Graph            => Inv_Graph,\n+            Lib_Graph            => Lib_Graph,\n+            Current_Edge         => Current_Edge,\n+            Next_Edge            => Next_Edge,\n+            Elaborate_All_Active => Elaborate_All_Active);\n+\n+         Current_Edge := Next_Edge;\n+      end loop;\n+\n+      --  Describe the transition from the last edge to the first edge\n+\n+      Output_Transition\n+        (Inv_Graph            => Inv_Graph,\n+         Lib_Graph            => Lib_Graph,\n+         Current_Edge         => Current_Edge,\n+         Next_Edge            => First_Edge,\n+         Elaborate_All_Active => Elaborate_All_Active);\n+\n+      --  Suggest various alternatives for breaking the cycle\n+\n+      Output_Suggestions\n+        (G          => Lib_Graph,\n+         Cycle      => Cycle,\n+         First_Edge => First_Edge);\n+   end Diagnose_Cycle;\n+\n+   --------------------------------------\n+   -- Find_And_Output_Invocation_Paths --\n+   --------------------------------------\n+\n+   procedure Find_And_Output_Invocation_Paths\n+     (Inv_Graph   : Invocation_Graph;\n+      Lib_Graph   : Library_Graph;\n+      Source      : Library_Graph_Vertex_Id;\n+      Destination : Library_Graph_Vertex_Id)\n+   is\n+      Path    : IGE_Lists.Doubly_Linked_List;\n+      Path_Id : Nat;\n+\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Source));\n+      pragma Assert (Present (Destination));\n+\n+      --  Nothing to do when the invocation graph encoding format of the source\n+      --  vertex does not contain detailed information about invocation paths.\n+\n+      if Invocation_Graph_Encoding (Lib_Graph, Source) /=\n+           Full_Path_Encoding\n+      then\n+         return;\n+      end if;\n+\n+      Path    := IGE_Lists.Create;\n+      Path_Id := 1;\n+\n+      --  Start a DFS traversal over the invocation graph, in an attempt to\n+      --  reach Destination from Source. The actual start of the path is the\n+      --  elaboration root invocation vertex that corresponds to the Source.\n+      --  Each unique path is emitted as part of the current cycle diagnostic.\n+\n+      Visit_Vertex\n+        (Inv_Graph         => Inv_Graph,\n+         Lib_Graph         => Lib_Graph,\n+         Invoker           =>\n+           Find_Elaboration_Root\n+             (Inv_Graph => Inv_Graph,\n+              Lib_Graph => Lib_Graph,\n+              Vertex    => Source),\n+         Invoker_Vertex    => Source,\n+         Last_Vertex       => Source,\n+         Elaborated_Vertex => Source,\n+         End_Vertex        => Destination,\n+         Path              => Path,\n+         Path_Id           => Path_Id);\n+\n+      IGE_Lists.Destroy (Path);\n+   end Find_And_Output_Invocation_Paths;\n+\n+   ---------------------------\n+   -- Find_Elaboration_Root --\n+   ---------------------------\n+\n+   function Find_Elaboration_Root\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph;\n+      Vertex    : Library_Graph_Vertex_Id) return Invocation_Graph_Vertex_Id\n+   is\n+      Current_Vertex : Invocation_Graph_Vertex_Id;\n+      Iter           : Elaboration_Root_Iterator;\n+      Root_Vertex    : Invocation_Graph_Vertex_Id;\n+\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Vertex));\n+\n+      --  Assume that the vertex does not have a corresponding elaboration root\n+\n+      Root_Vertex := No_Invocation_Graph_Vertex;\n+\n+      --  Inspect all elaboration roots trying to find the one that resides in\n+      --  the input vertex.\n+      --\n+      --  IMPORTANT:\n+      --\n+      --    * The iterator must run to completion in order to unlock the\n+      --      invocation graph.\n+\n+      Iter := Iterate_Elaboration_Roots (Inv_Graph);\n+      while Has_Next (Iter) loop\n+         Next (Iter, Current_Vertex);\n+\n+         if not Present (Root_Vertex)\n+           and then Body_Vertex (Inv_Graph, Current_Vertex) = Vertex\n+         then\n+            Root_Vertex := Current_Vertex;\n+         end if;\n+      end loop;\n+\n+      return Root_Vertex;\n+   end Find_Elaboration_Root;\n+\n+   -----------------------------------\n+   -- Output_All_Cycles_Suggestions --\n+   -----------------------------------\n+\n+   procedure Output_All_Cycles_Suggestions (G : Library_Graph) is\n+   begin\n+      pragma Assert (Present (G));\n+\n+      --  The library graph contains at least one cycle and only the highest\n+      --  priority cycle was diagnosed. Diagnosing all cycles may yield extra\n+      --  information for decision making.\n+\n+      if Number_Of_Cycles (G) > 1 and then not Debug_Flag_Underscore_CC then\n+         Error_Msg_Info\n+           (\"    diagnose all circularities (-d_C)\");\n+      end if;\n+   end Output_All_Cycles_Suggestions;\n+\n+   --------------------------------------\n+   -- Output_Dynamic_Model_Suggestions --\n+   --------------------------------------\n+\n+   procedure Output_Dynamic_Model_Suggestions\n+     (G     : Library_Graph;\n+      Cycle : Library_Graph_Cycle_Id)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Cycle));\n+\n+      --  The cycle contains at least one invocation edge and the main library\n+      --  unit was compiled with the static model. Using the dynamic model may\n+      --  eliminate the invocation edge, and thus the cycle.\n+\n+      if Invocation_Edge_Count (G, Cycle) > 0\n+        and then not Is_Dynamically_Elaborated (G)\n+      then\n+         Error_Msg_Info\n+           (\"    use the dynamic elaboration model (-gnatE)\");\n+      end if;\n+   end Output_Dynamic_Model_Suggestions;\n+\n+   --------------------------------------\n+   -- Output_Elaborate_All_Suggestions --\n+   --------------------------------------\n+\n+   procedure Output_Elaborate_All_Suggestions\n+     (G    : Library_Graph;\n+      Pred : Library_Graph_Vertex_Id;\n+      Succ : Library_Graph_Vertex_Id)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Pred));\n+      pragma Assert (Present (Succ));\n+\n+      Error_Msg_Unit_1 := Name (G, Pred);\n+      Error_Msg_Unit_2 := Name (G, Succ);\n+      Error_Msg_Info\n+        (\"    change pragma Elaborate_All for unit $ to Elaborate in unit $\");\n+      Error_Msg_Info\n+        (\"    remove pragma Elaborate_All for unit $ in unit $\");\n+   end Output_Elaborate_All_Suggestions;\n+\n+   -------------------------------------\n+   -- Output_Elaborate_All_Transition --\n+   -------------------------------------\n+\n+   procedure Output_Elaborate_All_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Source));\n+      pragma Assert (Present (Actual_Destination));\n+      pragma Assert (Present (Expected_Destination));\n+\n+      --  The actual and expected destination vertices match, and denote the\n+      --  spec of a unit.\n+      --\n+      --            Elaborate_All   Actual_Destination\n+      --    Source ---------------> spec -->\n+      --                            Expected_Destination\n+      --\n+      --            Elaborate_All   Actual_Destination\n+      --    Source ---------------> stand-alone body -->\n+      --                            Expected_Destination\n+\n+      if Actual_Destination = Expected_Destination then\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause and pragma Elaborate_All for unit $\");\n+\n+      --  Otherwise the actual destination vertex denotes the spec of a unit,\n+      --  while the expected destination is the corresponding body.\n+      --\n+      --            Elaborate_All   Actual_Destination\n+      --    Source ---------------> spec\n+      --\n+      --                            body -->\n+      --                            Expected_Destination\n+\n+      else\n+         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n+         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n+         pragma Assert\n+           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause and pragma Elaborate_All for unit $\");\n+\n+         Error_Msg_Unit_1 := Name (G, Expected_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is in the closure of pragma Elaborate_All\");\n+      end if;\n+   end Output_Elaborate_All_Transition;\n+\n+   ---------------------------------------\n+   -- Output_Elaborate_Body_Suggestions --\n+   ---------------------------------------\n+\n+   procedure Output_Elaborate_Body_Suggestions\n+     (G    : Library_Graph;\n+      Succ : Library_Graph_Vertex_Id)\n+   is\n+      Spec : Library_Graph_Vertex_Id;\n+\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Succ));\n+\n+      --  Find the initial declaration of the unit because it is the one\n+      --  subject to pragma Elaborate_Body.\n+\n+      if Is_Body_With_Spec (G, Succ) then\n+         Spec := Proper_Spec (G, Succ);\n+      else\n+         Spec := Succ;\n+      end if;\n+\n+      Error_Msg_Unit_1 := Name (G, Spec);\n+      Error_Msg_Info\n+        (\"    remove pragma Elaborate_Body in unit $\");\n+   end Output_Elaborate_Body_Suggestions;\n+\n+   --------------------------------------\n+   -- Output_Elaborate_Body_Transition --\n+   --------------------------------------\n+\n+   procedure Output_Elaborate_Body_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Source));\n+      pragma Assert (Present (Actual_Destination));\n+      pragma Assert (Present (Expected_Destination));\n+\n+      --  The actual and expected destination vertices match, and denote the\n+      --  spec of a unit subject to pragma Elaborate_Body. There is no need to\n+      --  mention the pragma because it does not affect the path of the cycle.\n+      --  Treat the edge as a regular with edge.\n+      --\n+      --               Actual_Destination\n+      --    Source --> spec Elaborate_Body -->\n+      --               Expected_Destination\n+\n+      if Actual_Destination = Expected_Destination then\n+         pragma Assert (Is_Spec (G, Actual_Destination));\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause for unit $\");\n+\n+      --  Otherwise the actual destination vertex is the spec of a unit subject\n+      --  to pragma Elaborate_Body and the expected destination vertex is the\n+      --  completion body. The pragma must be mentioned because it directs the\n+      --  path of the cycle from the spec to the body.\n+      --\n+      --               Actual_Destination\n+      --    Source --> spec Elaborate_Body\n+      --\n+      --               body -->\n+      --               Expected_Destination\n+\n+      else\n+         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n+         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n+         pragma Assert\n+           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+\n+         Error_Msg_Unit_1 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is subject to pragma Elaborate_Body\");\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Expected_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause for unit $\");\n+      end if;\n+   end Output_Elaborate_Body_Transition;\n+\n+   ----------------------------------\n+   -- Output_Elaborate_Suggestions --\n+   ----------------------------------\n+\n+   procedure Output_Elaborate_Suggestions\n+     (G    : Library_Graph;\n+      Pred : Library_Graph_Vertex_Id;\n+      Succ : Library_Graph_Vertex_Id)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Pred));\n+      pragma Assert (Present (Succ));\n+\n+      Error_Msg_Unit_1 := Name (G, Pred);\n+      Error_Msg_Unit_2 := Name (G, Succ);\n+      Error_Msg_Info\n+        (\"    remove pragma Elaborate for unit $ in unit $\");\n+   end Output_Elaborate_Suggestions;\n+\n+   ---------------------------------\n+   -- Output_Elaborate_Transition --\n+   ---------------------------------\n+\n+   procedure Output_Elaborate_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id)\n+   is\n+      Spec : Library_Graph_Vertex_Id;\n+\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Source));\n+      pragma Assert (Present (Actual_Destination));\n+      pragma Assert (Present (Expected_Destination));\n+\n+      --  The actual and expected destination vertices match, and denote the\n+      --  spec of a unit.\n+      --\n+      --            Elaborate   Actual_Destination\n+      --    Source -----------> spec -->\n+      --                        Expected_Destination\n+      --\n+      --            Elaborate   Actual_Destination\n+      --    Source -----------> stand-alone body -->\n+      --                        Expected_Destination\n+      --\n+      --  The processing of pragma Elaborate body generates an edge between a\n+      --  successor and predecessor body.\n+      --\n+      --                        spec\n+      --\n+      --            Elaborate   Actual_Destination\n+      --    Source -----------> body -->\n+      --                        Expected_Destination\n+\n+      if Actual_Destination = Expected_Destination then\n+\n+         --  Find the initial declaration of the unit because it is the one\n+         --  subject to pragma Elaborate.\n+\n+         if Is_Body_With_Spec (G, Actual_Destination) then\n+            Spec := Proper_Spec (G, Actual_Destination);\n+         else\n+            Spec := Actual_Destination;\n+         end if;\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Spec);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause and pragma Elaborate for unit $\");\n+\n+         if Actual_Destination /= Spec then\n+            Error_Msg_Unit_1 := Name (G, Actual_Destination);\n+            Error_Msg_Info\n+              (\"    unit $ is in the closure of pragma Elaborate\");\n+         end if;\n+\n+      --  Otherwise the actual destination vertex denotes the spec of a unit\n+      --  while the expected destination vertex is the corresponding body.\n+      --\n+      --            Elaborate   Actual_Destination\n+      --    Source -----------> spec\n+      --\n+      --                        body -->\n+      --                        Expected_Destination\n+\n+      else\n+         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n+         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n+         pragma Assert\n+           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause and pragma Elaborate for unit $\");\n+\n+         Error_Msg_Unit_1 := Name (G, Expected_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is in the closure of pragma Elaborate\");\n+      end if;\n+   end Output_Elaborate_Transition;\n+\n+   -------------------------------\n+   -- Output_Forced_Suggestions --\n+   -------------------------------\n+\n+   procedure Output_Forced_Suggestions\n+     (G    : Library_Graph;\n+      Pred : Library_Graph_Vertex_Id;\n+      Succ : Library_Graph_Vertex_Id)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Pred));\n+      pragma Assert (Present (Succ));\n+\n+      Error_Msg_Unit_1 := Name (G, Succ);\n+      Error_Msg_Unit_2 := Name (G, Pred);\n+      Error_Msg_Info\n+        (\"    remove the dependency of unit $ on unit $ from argument of -f \"\n+         & \"switch\");\n+   end Output_Forced_Suggestions;\n+\n+   ------------------------------\n+   -- Output_Forced_Transition --\n+   ------------------------------\n+\n+   procedure Output_Forced_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id;\n+      Elaborate_All_Active : Boolean)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Source));\n+      pragma Assert (Present (Actual_Destination));\n+      pragma Assert (Present (Expected_Destination));\n+\n+      --  The actual and expected destination vertices match, and denote the\n+      --  spec of a unit.\n+      --\n+      --            Forced   Actual_Destination\n+      --    Source --------> spec -->\n+      --                     Expected_Destination\n+      --\n+      --            Forced   Actual_Destination\n+      --    Source --------> body -->\n+      --                     Expected_Destination\n+\n+      if Actual_Destination = Expected_Destination then\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has a dependency on unit $ forced by -f switch\");\n+\n+      --  The actual destination vertex denotes the spec of a unit while the\n+      --  expected destination is the corresponding body, and the unit is in\n+      --  the closure of an earlier Elaborate_All pragma.\n+      --\n+      --            Forced   Actual_Destination\n+      --    Source --------> spec\n+      --\n+      --                     body -->\n+      --                     Expected_Destination\n+\n+      elsif Elaborate_All_Active then\n+         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n+         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n+         pragma Assert\n+           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has a dependency on unit $ forced by -f switch\");\n+\n+         Error_Msg_Unit_1 := Name (G, Expected_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is in the closure of pragma Elaborate_All\");\n+\n+      --  Otherwise the actual destination vertex denotes a spec subject to\n+      --  pragma Elaborate_Body while the expected destination denotes the\n+      --  corresponding body.\n+      --\n+      --            Forced   Actual_Destination\n+      --    Source --------> spec Elaborate_Body\n+      --\n+      --                     body -->\n+      --                     Expected_Destination\n+\n+      else\n+         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n+         pragma Assert (Is_Spec_With_Elaborate_Body (G, Actual_Destination));\n+         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n+         pragma Assert\n+           (Is_Body_Of_Spec_With_Elaborate_Body (G, Expected_Destination));\n+         pragma Assert\n+           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has a dependency on unit $ forced by -f switch\");\n+\n+         Error_Msg_Unit_1 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is subject to pragma Elaborate_Body\");\n+\n+         Error_Msg_Unit_1 := Name (G, Expected_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is in the closure of pragma Elaborate_Body\");\n+      end if;\n+   end Output_Forced_Transition;\n+\n+   --------------------------------------\n+   -- Output_Full_Encoding_Suggestions --\n+   --------------------------------------\n+\n+   procedure Output_Full_Encoding_Suggestions\n+     (G          : Library_Graph;\n+      Cycle      : Library_Graph_Cycle_Id;\n+      First_Edge : Library_Graph_Edge_Id)\n+   is\n+      Succ : Library_Graph_Vertex_Id;\n+\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Cycle));\n+      pragma Assert (Present (First_Edge));\n+\n+      if Is_Invocation_Edge (G, First_Edge) then\n+         Succ := Successor (G, First_Edge);\n+\n+         if Invocation_Graph_Encoding (G, Succ) /= Full_Path_Encoding then\n+            Error_Msg_Info\n+              (\"    use detailed invocation information (-gnatd_F)\");\n+         end if;\n+      end if;\n+   end Output_Full_Encoding_Suggestions;\n+\n+   ----------------------------\n+   -- Output_Invocation_Path --\n+   -----------------------------\n+\n+   procedure Output_Invocation_Path\n+     (Inv_Graph         : Invocation_Graph;\n+      Lib_Graph         : Library_Graph;\n+      Elaborated_Vertex : Library_Graph_Vertex_Id;\n+      Path              : IGE_Lists.Doubly_Linked_List;\n+      Path_Id           : in out Nat)\n+   is\n+      Edge : Invocation_Graph_Edge_Id;\n+      Iter : IGE_Lists.Iterator;\n+\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Elaborated_Vertex));\n+      pragma Assert (IGE_Lists.Present (Path));\n+\n+      Error_Msg_Nat_1 := Path_Id;\n+      Error_Msg_Info (\"      path #:\");\n+\n+      Error_Msg_Unit_1 := Name (Lib_Graph, Elaborated_Vertex);\n+      Error_Msg_Info (\"        elaboration of unit $\");\n+\n+      Iter := IGE_Lists.Iterate (Path);\n+      while IGE_Lists.Has_Next (Iter) loop\n+         IGE_Lists.Next (Iter, Edge);\n+\n+         Output_Invocation_Path_Transition\n+           (Inv_Graph => Inv_Graph,\n+            Lib_Graph => Lib_Graph,\n+            Edge      => Edge);\n+      end loop;\n+\n+      Path_Id := Path_Id + 1;\n+   end Output_Invocation_Path;\n+\n+   ---------------------------------------\n+   -- Output_Invocation_Path_Transition --\n+   ---------------------------------------\n+\n+   procedure Output_Invocation_Path_Transition\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph;\n+      Edge      : Invocation_Graph_Edge_Id)\n+   is\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Edge));\n+\n+      Declared : constant String := \"declared at {:#:#\";\n+\n+      Targ        : constant Invocation_Graph_Vertex_Id :=\n+                      Target (Inv_Graph, Edge);\n+      Targ_Extra  : constant Name_Id                    :=\n+                      Extra (Inv_Graph, Edge);\n+      Targ_Vertex : constant Library_Graph_Vertex_Id    :=\n+                      Spec_Vertex (Inv_Graph, Targ);\n+\n+   begin\n+      Error_Msg_Name_1 := Name   (Inv_Graph, Targ);\n+      Error_Msg_Nat_1  := Line   (Inv_Graph, Targ);\n+      Error_Msg_Nat_2  := Column (Inv_Graph, Targ);\n+      Error_Msg_File_1 := File_Name (Lib_Graph, Targ_Vertex);\n+\n+      case Kind (Inv_Graph, Edge) is\n+         when Accept_Alternative =>\n+            Error_Msg_Info\n+              (\"        selection of entry % \"\n+               & Declared);\n+\n+         when Access_Taken =>\n+            Error_Msg_Info\n+              (\"        aliasing of subprogram % \"\n+               & Declared);\n+\n+         when Call =>\n+            Error_Msg_Info\n+              (\"        call to subprogram % \"\n+               & Declared);\n+\n+         when Controlled_Adjustment\n+            | Internal_Controlled_Adjustment\n+         =>\n+            Error_Msg_Name_1 := Targ_Extra;\n+            Error_Msg_Info\n+              (\"        adjustment actions for type % \"\n+               & Declared);\n+\n+         when Controlled_Finalization\n+            | Internal_Controlled_Finalization\n+         =>\n+            Error_Msg_Name_1 := Targ_Extra;\n+            Error_Msg_Info\n+              (\"        finalization actions for type % \"\n+               & Declared);\n+\n+         when Controlled_Initialization\n+            | Internal_Controlled_Initialization\n+            | Type_Initialization\n+         =>\n+            Error_Msg_Name_1 := Targ_Extra;\n+            Error_Msg_Info\n+              (\"        initialization actions for type % \"\n+               & Declared);\n+\n+         when Default_Initial_Condition_Verification =>\n+            Error_Msg_Name_1 := Targ_Extra;\n+            Error_Msg_Info\n+              (\"        verification of Default_Initial_Condition for type % \"\n+               & Declared);\n+\n+         when Initial_Condition_Verification =>\n+            Error_Msg_Info\n+              (\"        verification of Initial_Condition \"\n+               & Declared);\n+\n+         when Instantiation =>\n+            Error_Msg_Info\n+              (\"        instantiation % \"\n+               & Declared);\n+\n+         when Invariant_Verification =>\n+            Error_Msg_Name_1 := Targ_Extra;\n+            Error_Msg_Info\n+              (\"        verification of invariant for type % \"\n+               & Declared);\n+\n+         when Postcondition_Verification =>\n+            Error_Msg_Name_1 := Targ_Extra;\n+            Error_Msg_Info\n+              (\"        verification of postcondition for subprogram % \"\n+               & Declared);\n+\n+         when Protected_Entry_Call =>\n+            Error_Msg_Info\n+              (\"        call to protected entry % \"\n+               & Declared);\n+\n+         when Protected_Subprogram_Call =>\n+            Error_Msg_Info\n+              (\"        call to protected subprogram % \"\n+               & Declared);\n+\n+         when Task_Activation =>\n+            Error_Msg_Info\n+              (\"        activation of local task \"\n+               & Declared);\n+\n+         when Task_Entry_Call =>\n+            Error_Msg_Info\n+              (\"        call to task entry % \"\n+               & Declared);\n+\n+         when others =>\n+            pragma Assert (False);\n+            null;\n+      end case;\n+   end Output_Invocation_Path_Transition;\n+\n+   ----------------------------------\n+   -- Output_Invocation_Transition --\n+   ----------------------------------\n+\n+   procedure Output_Invocation_Transition\n+     (Inv_Graph   : Invocation_Graph;\n+      Lib_Graph   : Library_Graph;\n+      Source      : Library_Graph_Vertex_Id;\n+      Destination : Library_Graph_Vertex_Id)\n+   is\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Source));\n+      pragma Assert (Present (Destination));\n+\n+      Error_Msg_Unit_1 := Name (Lib_Graph, Source);\n+      Error_Msg_Unit_2 := Name (Lib_Graph, Destination);\n+      Error_Msg_Info\n+        (\"    unit $ invokes a construct of unit $ at elaboration time\");\n+\n+      Find_And_Output_Invocation_Paths\n+        (Inv_Graph   => Inv_Graph,\n+         Lib_Graph   => Lib_Graph,\n+         Source      => Source,\n+         Destination => Destination);\n+   end Output_Invocation_Transition;\n+\n+   ------------------------------------------\n+   -- Output_Reason_And_Circularity_Header --\n+   ------------------------------------------\n+\n+   procedure Output_Reason_And_Circularity_Header\n+     (G          : Library_Graph;\n+      First_Edge : Library_Graph_Edge_Id)\n+   is\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (First_Edge));\n+\n+      Succ : constant Library_Graph_Vertex_Id := Successor (G, First_Edge);\n+\n+   begin\n+      Error_Msg_Unit_1 := Name (G, Succ);\n+      Error_Msg      (\"Elaboration circularity detected\");\n+      Error_Msg_Info (\"\");\n+      Error_Msg_Info (\"  Reason:\");\n+      Error_Msg_Info (\"\");\n+      Error_Msg_Info (\"    unit $ depends on its own elaboration\");\n+      Error_Msg_Info (\"\");\n+      Error_Msg_Info (\"  Circularity:\");\n+      Error_Msg_Info (\"\");\n+   end Output_Reason_And_Circularity_Header;\n+\n+   ------------------------\n+   -- Output_Suggestions --\n+   ------------------------\n+\n+   procedure Output_Suggestions\n+     (G          : Library_Graph;\n+      Cycle      : Library_Graph_Cycle_Id;\n+      First_Edge : Library_Graph_Edge_Id)\n+   is\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Cycle));\n+      pragma Assert (Present (First_Edge));\n+\n+      Pred : constant Library_Graph_Vertex_Id := Predecessor (G, First_Edge);\n+      Succ : constant Library_Graph_Vertex_Id := Successor   (G, First_Edge);\n+\n+   begin\n+      Error_Msg_Info (\"\");\n+      Error_Msg_Info (\"  Suggestions:\");\n+      Error_Msg_Info (\"\");\n+\n+      --  Output edge-specific suggestions\n+\n+      if Is_Elaborate_All_Edge (G, First_Edge) then\n+         Output_Elaborate_All_Suggestions\n+           (G    => G,\n+            Pred => Pred,\n+            Succ => Succ);\n+\n+      elsif Is_Elaborate_Body_Edge (G, First_Edge) then\n+         Output_Elaborate_Body_Suggestions\n+           (G    => G,\n+            Succ => Succ);\n+\n+      elsif Is_Elaborate_Edge (G, First_Edge) then\n+         Output_Elaborate_Suggestions\n+           (G    => G,\n+            Pred => Pred,\n+            Succ => Succ);\n+\n+      elsif Is_Forced_Edge (G, First_Edge) then\n+         Output_Forced_Suggestions\n+           (G    => G,\n+            Pred => Pred,\n+            Succ => Succ);\n+      end if;\n+\n+      --  Output general purpose suggestions\n+\n+      Output_Dynamic_Model_Suggestions\n+        (G     => G,\n+         Cycle => Cycle);\n+\n+      Output_Full_Encoding_Suggestions\n+        (G          => G,\n+         Cycle      => Cycle,\n+         First_Edge => First_Edge);\n+\n+      Output_All_Cycles_Suggestions (G);\n+\n+      Error_Msg_Info (\"\");\n+   end Output_Suggestions;\n+\n+   -----------------------\n+   -- Output_Transition --\n    -----------------------\n \n-   package body Cycle_Diagnostics is\n+   procedure Output_Transition\n+     (Inv_Graph            : Invocation_Graph;\n+      Lib_Graph            : Library_Graph;\n+      Current_Edge         : Library_Graph_Edge_Id;\n+      Next_Edge            : Library_Graph_Edge_Id;\n+      Elaborate_All_Active : Boolean)\n+   is\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Current_Edge));\n+      pragma Assert (Present (Next_Edge));\n+\n+      Actual_Destination   : constant Library_Graph_Vertex_Id :=\n+                               Predecessor (Lib_Graph, Current_Edge);\n+      Expected_Destination : constant Library_Graph_Vertex_Id :=\n+                               Successor   (Lib_Graph, Next_Edge);\n+      Source               : constant Library_Graph_Vertex_Id :=\n+                               Successor   (Lib_Graph, Current_Edge);\n \n-      -----------------------------\n-      -- Has_Elaborate_All_Cycle --\n-      -----------------------------\n+   begin\n+      if Is_Elaborate_All_Edge (Lib_Graph, Current_Edge) then\n+         Output_Elaborate_All_Transition\n+           (G                    => Lib_Graph,\n+            Source               => Source,\n+            Actual_Destination   => Actual_Destination,\n+            Expected_Destination => Expected_Destination);\n \n-      function Has_Elaborate_All_Cycle (G : Library_Graph) return Boolean is\n-         Has_Cycle : Boolean;\n-         Iter      : All_Edge_Iterator;\n-         LGE_Id    : Library_Graph_Edge_Id;\n+      elsif Is_Elaborate_Body_Edge (Lib_Graph, Current_Edge) then\n+         Output_Elaborate_Body_Transition\n+           (G                    => Lib_Graph,\n+            Source               => Source,\n+            Actual_Destination   => Actual_Destination,\n+            Expected_Destination => Expected_Destination);\n \n-      begin\n-         pragma Assert (Present (G));\n+      elsif Is_Elaborate_Edge (Lib_Graph, Current_Edge) then\n+         Output_Elaborate_Transition\n+           (G                    => Lib_Graph,\n+            Source               => Source,\n+            Actual_Destination   => Actual_Destination,\n+            Expected_Destination => Expected_Destination);\n \n-         --  Assume that the graph lacks a cycle\n+      elsif Is_Forced_Edge (Lib_Graph, Current_Edge) then\n+         Output_Forced_Transition\n+           (G                    => Lib_Graph,\n+            Source               => Source,\n+            Actual_Destination   => Actual_Destination,\n+            Expected_Destination => Expected_Destination,\n+            Elaborate_All_Active => Elaborate_All_Active);\n \n-         Has_Cycle := False;\n+      elsif Is_Invocation_Edge (Lib_Graph, Current_Edge) then\n+         Output_Invocation_Transition\n+           (Inv_Graph   => Inv_Graph,\n+            Lib_Graph   => Lib_Graph,\n+            Source      => Source,\n+            Destination => Expected_Destination);\n \n-         --  The library graph has an Elaborate_All cycle when one of its edges\n-         --  represents a with clause for a unit with pragma Elaborate_All, and\n-         --  both the predecessor and successor reside in the same component.\n-         --  Note that the iteration must run to completion in order to unlock\n-         --  the graph.\n+      else\n+         pragma Assert (Is_With_Edge (Lib_Graph, Current_Edge));\n \n-         Iter := Iterate_All_Edges (G);\n+         Output_With_Transition\n+           (G                    => Lib_Graph,\n+            Source               => Source,\n+            Actual_Destination   => Actual_Destination,\n+            Expected_Destination => Expected_Destination,\n+            Elaborate_All_Active => Elaborate_All_Active);\n+      end if;\n+   end Output_Transition;\n+\n+   ----------------------------\n+   -- Output_With_Transition --\n+   ----------------------------\n+\n+   procedure Output_With_Transition\n+     (G                    : Library_Graph;\n+      Source               : Library_Graph_Vertex_Id;\n+      Actual_Destination   : Library_Graph_Vertex_Id;\n+      Expected_Destination : Library_Graph_Vertex_Id;\n+      Elaborate_All_Active : Boolean)\n+   is\n+   begin\n+      pragma Assert (Present (G));\n+      pragma Assert (Present (Source));\n+      pragma Assert (Present (Actual_Destination));\n+      pragma Assert (Present (Expected_Destination));\n+\n+      --  The actual and expected destination vertices match, and denote the\n+      --  spec of a unit.\n+      --\n+      --            with   Actual_Destination\n+      --    Source ------> spec -->\n+      --                   Expected_Destination\n+      --\n+      --            with   Actual_Destination\n+      --    Source ------> stand-alone body -->\n+      --                   Expected_Destination\n+\n+      if Actual_Destination = Expected_Destination then\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause for unit $\");\n+\n+      --  The actual destination vertex denotes the spec of a unit while the\n+      --  expected destination is the corresponding body, and the unit is in\n+      --  the closure of an earlier Elaborate_All pragma.\n+      --\n+      --            with   Actual_Destination\n+      --    Source ------> spec\n+      --\n+      --                   body -->\n+      --                   Expected_Destination\n+\n+      elsif Elaborate_All_Active then\n+         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n+         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n+         pragma Assert\n+           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause for unit $\");\n+\n+         Error_Msg_Unit_1 := Name (G, Expected_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is in the closure of pragma Elaborate_All\");\n+\n+      --  Otherwise the actual destination vertex denotes a spec subject to\n+      --  pragma Elaborate_Body while the expected destination denotes the\n+      --  corresponding body.\n+      --\n+      --            with   Actual_Destination\n+      --    Source ------> spec Elaborate_Body\n+      --\n+      --                   body -->\n+      --                   Expected_Destination\n+\n+      else\n+         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n+         pragma Assert (Is_Spec_With_Elaborate_Body (G, Actual_Destination));\n+         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n+         pragma Assert\n+           (Is_Body_Of_Spec_With_Elaborate_Body (G, Expected_Destination));\n+         pragma Assert\n+           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+\n+         Error_Msg_Unit_1 := Name (G, Source);\n+         Error_Msg_Unit_2 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ has with clause for unit $\");\n+\n+         Error_Msg_Unit_1 := Name (G, Actual_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is subject to pragma Elaborate_Body\");\n+\n+         Error_Msg_Unit_1 := Name (G, Expected_Destination);\n+         Error_Msg_Info\n+           (\"    unit $ is in the closure of pragma Elaborate_Body\");\n+      end if;\n+   end Output_With_Transition;\n+\n+   ------------------\n+   -- Visit_Vertex --\n+   ------------------\n+\n+   procedure Visit_Vertex\n+     (Inv_Graph         : Invocation_Graph;\n+      Lib_Graph         : Library_Graph;\n+      Invoker           : Invocation_Graph_Vertex_Id;\n+      Invoker_Vertex    : Library_Graph_Vertex_Id;\n+      Last_Vertex       : Library_Graph_Vertex_Id;\n+      Elaborated_Vertex : Library_Graph_Vertex_Id;\n+      End_Vertex        : Library_Graph_Vertex_Id;\n+      Path              : IGE_Lists.Doubly_Linked_List;\n+      Path_Id           : in out Nat)\n+   is\n+      Edge : Invocation_Graph_Edge_Id;\n+      Iter : Edges_To_Targets_Iterator;\n+      Targ : Invocation_Graph_Vertex_Id;\n+\n+   begin\n+      pragma Assert (Present (Inv_Graph));\n+      pragma Assert (Present (Lib_Graph));\n+      pragma Assert (Present (Invoker));\n+      pragma Assert (Present (Invoker_Vertex));\n+      pragma Assert (Present (Last_Vertex));\n+      pragma Assert (Present (Elaborated_Vertex));\n+      pragma Assert (Present (End_Vertex));\n+      pragma Assert (IGE_Lists.Present (Path));\n+\n+      --  The current invocation vertex resides within the end library vertex.\n+      --  Emit the path that started from some elaboration root and ultimately\n+      --  reached the desired library vertex.\n+\n+      if Body_Vertex (Inv_Graph, Invoker) = End_Vertex\n+        and then Invoker_Vertex /= Last_Vertex\n+      then\n+         Output_Invocation_Path\n+           (Inv_Graph         => Inv_Graph,\n+            Lib_Graph         => Lib_Graph,\n+            Elaborated_Vertex => Elaborated_Vertex,\n+            Path              => Path,\n+            Path_Id           => Path_Id);\n+\n+      --  Otherwise extend the search for the end library vertex via all edges\n+      --  to targets.\n+\n+      else\n+         Iter := Iterate_Edges_To_Targets (Inv_Graph, Invoker);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGE_Id);\n-            pragma Assert (Present (LGE_Id));\n-\n-            if Kind (G, LGE_Id) = Elaborate_All_Edge\n-              and then Links_Vertices_In_Same_Component (G, LGE_Id)\n-            then\n-               Has_Cycle := True;\n-            end if;\n-         end loop;\n+            Next (Iter, Edge);\n \n-         return Has_Cycle;\n-      end Has_Elaborate_All_Cycle;\n-   end Cycle_Diagnostics;\n+            --  Prepare for edge backtracking\n+\n+            IGE_Lists.Append (Path, Edge);\n+\n+            --  The traversal proceeds through the library vertex that houses\n+            --  the body of the target.\n+\n+            Targ := Target (Inv_Graph, Edge);\n+\n+            Visit_Vertex\n+              (Inv_Graph         => Inv_Graph,\n+               Lib_Graph         => Lib_Graph,\n+               Invoker           => Targ,\n+               Invoker_Vertex    => Body_Vertex (Inv_Graph, Targ),\n+               Last_Vertex       => Invoker_Vertex,\n+               Elaborated_Vertex => Elaborated_Vertex,\n+               End_Vertex        => End_Vertex,\n+               Path              => Path,\n+               Path_Id           => Path_Id);\n+\n+            --  Backtrack the edge\n+\n+            IGE_Lists.Delete_Last (Path);\n+         end loop;\n+      end if;\n+   end Visit_Vertex;\n \n end Bindo.Diagnostics;"}, {"sha": "3835a68d8d78da841af295b80e62dba3d0ba8735", "filename": "gcc/ada/bindo-diagnostics.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-diagnostics.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-diagnostics.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-diagnostics.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -30,6 +30,7 @@\n \n with Bindo.Graphs;\n use  Bindo.Graphs;\n+use  Bindo.Graphs.Invocation_Graphs;\n use  Bindo.Graphs.Library_Graphs;\n \n package Bindo.Diagnostics is\n@@ -46,16 +47,15 @@ package Bindo.Diagnostics is\n       Order_Has_Elaborate_All_Circularity,\n       Order_OK);\n \n-   -----------------------\n-   -- Cycle_Diagnostics --\n-   -----------------------\n+   ---------\n+   -- API --\n+   ---------\n \n-   package Cycle_Diagnostics is\n-      function Has_Elaborate_All_Cycle (G : Library_Graph) return Boolean;\n-      pragma Inline (Has_Elaborate_All_Cycle);\n-      --  Determine whether library graph G contains a cycle where pragma\n-      --  Elaborate_All appears within a component.\n-\n-   end Cycle_Diagnostics;\n+   procedure Diagnose_Circularities\n+     (Inv_Graph : Invocation_Graph;\n+      Lib_Graph : Library_Graph);\n+   pragma Inline (Diagnose_Circularities);\n+   --  Diagnose all cycles of library graph Lib_Graph with matching invocation\n+   --  graph Inv_Graph.\n \n end Bindo.Diagnostics;"}, {"sha": "d26101a4f9b273e52358bde29677131e997f1af1", "filename": "gcc/ada/bindo-elaborators.adb", "status": "modified", "additions": 209, "deletions": 238, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-elaborators.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-elaborators.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-elaborators.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -23,11 +23,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Binderr; use Binderr;\n-with Butil;   use Butil;\n-with Debug;   use Debug;\n-with Output;  use Output;\n-with Types;   use Types;\n+with Butil;  use Butil;\n+with Debug;  use Debug;\n+with Output; use Output;\n+with Types;  use Types;\n \n with Bindo.Augmentors;\n use  Bindo.Augmentors;\n@@ -40,7 +39,6 @@ use  Bindo.Builders.Library_Graph_Builders;\n \n with Bindo.Diagnostics;\n use  Bindo.Diagnostics;\n-use  Bindo.Diagnostics.Cycle_Diagnostics;\n \n with Bindo.Units;\n use  Bindo.Units;\n@@ -61,7 +59,6 @@ use  Bindo.Writers.Unit_Closure_Writers;\n \n with GNAT;        use GNAT;\n with GNAT.Graphs; use GNAT.Graphs;\n-with GNAT.Sets;   use GNAT.Sets;\n \n package body Bindo.Elaborators is\n \n@@ -89,57 +86,47 @@ package body Bindo.Elaborators is\n \n       type String_Ptr is access all String;\n \n-      -----------------\n-      -- Visited set --\n-      -----------------\n-\n-      package VS is new Membership_Sets\n-        (Element_Type => Library_Graph_Vertex_Id,\n-         \"=\"          => \"=\",\n-         Hash         => Hash_Library_Graph_Vertex);\n-      use VS;\n-\n       -----------------------\n       -- Local subprograms --\n       -----------------------\n \n       procedure Add_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n-         Set    : Membership_Set;\n+         Vertex : Library_Graph_Vertex_Id;\n+         Set    : LGV_Sets.Membership_Set;\n          Msg    : String;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level);\n       pragma Inline (Add_Vertex);\n-      --  Add vertex LGV_Id of library graph G to membership set Set. Msg is\n+      --  Add vertex Vertex of library graph G to membership set Set. Msg is\n       --  a message emitted for tracing purposes. Step is the current step in\n       --  the elaboration order. Indent is the desired indentation level for\n       --  tracing.\n \n       procedure Add_Vertex_If_Elaborable\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n-         Set    : Membership_Set;\n+         Vertex : Library_Graph_Vertex_Id;\n+         Set    : LGV_Sets.Membership_Set;\n          Msg    : String;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level);\n       pragma Inline (Add_Vertex_If_Elaborable);\n-      --  Add vertex LGV_Id of library graph G to membership set Set if it can\n+      --  Add vertex Vertex of library graph G to membership set Set if it can\n       --  be elaborated. Msg is a message emitted for tracing purposes. Step is\n       --  the current step in the elaboration order. Indent is the desired\n       --  indentation level for tracing.\n \n       function Create_All_Candidates_Set\n         (G    : Library_Graph;\n-         Step : Elaboration_Order_Step) return Membership_Set;\n+         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set;\n       pragma Inline (Create_All_Candidates_Set);\n       --  Collect all elaborable candidate vertices of library graph G in a\n       --  set. Step is the current step in the elaboration order.\n \n       function Create_Component_Candidates_Set\n         (G    : Library_Graph;\n          Comp : Component_Id;\n-         Step : Elaboration_Order_Step) return Membership_Set;\n+         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set;\n       pragma Inline (Create_Component_Candidates_Set);\n       --  Collect all elaborable candidate vertices that appear in component\n       --  Comp of library graph G in a set. Step is the current step in the\n@@ -148,7 +135,7 @@ package body Bindo.Elaborators is\n       procedure Elaborate_Component\n         (G                  : Library_Graph;\n          Comp               : Component_Id;\n-         All_Candidates     : Membership_Set;\n+         All_Candidates     : LGV_Sets.Membership_Set;\n          Remaining_Vertices : in out Natural;\n          Order              : in out Unit_Id_Table;\n          Step               : Elaboration_Order_Step);\n@@ -170,15 +157,18 @@ package body Bindo.Elaborators is\n \n       procedure Elaborate_Units_Common\n         (Use_Inv_Graph : Boolean;\n+         Is_Dyn_Elab   : Boolean;\n          Inv_Graph     : out Invocation_Graph;\n          Lib_Graph     : out Library_Graph;\n          Order         : out Unit_Id_Table;\n          Status        : out Elaboration_Order_Status);\n       pragma Inline (Elaborate_Units_Common);\n       --  Find the elaboration order of all units in the bind. Use_Inv_Graph\n       --  should be set when library graph Lib_Graph is to be augmented with\n-      --  information from invocation graph Inv_Graph. Order is the elaboration\n-      --  order. Status is the condition of the elaboration order.\n+      --  information from invocation graph Inv_Graph. Is_Dyn_Elab should be\n+      --  set when the main library unit was compiled using the dynamic model.\n+      --  Order is the elaboration order. Status is the condition of the\n+      --  elaboration order.\n \n       procedure Elaborate_Units_Dynamic (Order : out Unit_Id_Table);\n       pragma Inline (Elaborate_Units_Dynamic);\n@@ -196,26 +186,26 @@ package body Bindo.Elaborators is\n \n       procedure Elaborate_Vertex\n         (G                  : Library_Graph;\n-         LGV_Id             : Library_Graph_Vertex_Id;\n-         All_Candidates     : Membership_Set;\n-         Comp_Candidates    : Membership_Set;\n+         Vertex             : Library_Graph_Vertex_Id;\n+         All_Candidates     : LGV_Sets.Membership_Set;\n+         Comp_Candidates    : LGV_Sets.Membership_Set;\n          Remaining_Vertices : in out Natural;\n          Order              : in out Unit_Id_Table;\n          Step               : Elaboration_Order_Step;\n          Indent             : Indentation_Level);\n       pragma Inline (Elaborate_Vertex);\n-      --  Elaborate vertex LGV_Id of library graph G by adding its unit to\n+      --  Elaborate vertex Vertex of library graph G by adding its unit to\n       --  elaboration order Order. The routine updates awaiting successors\n       --  where applicable. All_Candidates denotes the set of all elaborable\n       --  vertices across the whole library graph. Comp_Candidates is the set\n-      --  of all elaborable vertices in the component of LGV_Id. Parameter\n+      --  of all elaborable vertices in the component of Vertex. Parameter\n       --  Remaining_Vertices denotes the number of vertices that remain to\n       --  be elaborated. Step is the current step in the elaboration order.\n       --  Indent is the desired indentation level for tracing.\n \n       function Find_Best_Candidate\n         (G      : Library_Graph;\n-         Set    : Membership_Set;\n+         Set    : LGV_Sets.Membership_Set;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level) return Library_Graph_Vertex_Id;\n       pragma Inline (Find_Best_Candidate);\n@@ -224,17 +214,17 @@ package body Bindo.Elaborators is\n       --  order. Indent is the desired indentation level for tracing.\n \n       function Is_Better_Candidate\n-        (G           : Library_Graph;\n-         Best_Candid : Library_Graph_Vertex_Id;\n-         New_Candid  : Library_Graph_Vertex_Id) return Boolean;\n+        (G              : Library_Graph;\n+         Best_Candidate : Library_Graph_Vertex_Id;\n+         New_Candidate  : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Better_Candidate);\n-      --  Determine whether new candidate vertex New_Candid of library graph\n+      --  Determine whether new candidate vertex New_Candidate of library graph\n       --  G is a more suitable choice for elaboration compared to the current\n-      --  best candidate Best_Candid.\n+      --  best candidate Best_Candidate.\n \n       procedure Trace_Candidate_Vertices\n         (G    : Library_Graph;\n-         Set  : Membership_Set;\n+         Set  : LGV_Sets.Membership_Set;\n          Step : Elaboration_Order_Step);\n       pragma Inline (Trace_Candidate_Vertices);\n       --  Write the candidate vertices of library graph G present in membership\n@@ -266,12 +256,12 @@ package body Bindo.Elaborators is\n \n       procedure Trace_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n          Msg    : String;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level);\n       pragma Inline (Trace_Vertex);\n-      --  Write elaboration-related information for vertex LGV_Id of library\n+      --  Write elaboration-related information for vertex Vertex of library\n       --  graph G to standard output, starting with message Msg. Step is the\n       --  current step in the elaboration order. Indent denotes the desired\n       --  indentation level for tracing.\n@@ -280,8 +270,8 @@ package body Bindo.Elaborators is\n         (G               : Library_Graph;\n          Pred            : Library_Graph_Vertex_Id;\n          Succ            : Library_Graph_Vertex_Id;\n-         All_Candidates  : Membership_Set;\n-         Comp_Candidates : Membership_Set;\n+         All_Candidates  : LGV_Sets.Membership_Set;\n+         Comp_Candidates : LGV_Sets.Membership_Set;\n          Step            : Elaboration_Order_Step;\n          Indent          : Indentation_Level);\n       pragma Inline (Update_Successor);\n@@ -297,8 +287,8 @@ package body Bindo.Elaborators is\n       procedure Update_Successors\n         (G               : Library_Graph;\n          Pred            : Library_Graph_Vertex_Id;\n-         All_Candidates  : Membership_Set;\n-         Comp_Candidates : Membership_Set;\n+         All_Candidates  : LGV_Sets.Membership_Set;\n+         Comp_Candidates : LGV_Sets.Membership_Set;\n          Step            : Elaboration_Order_Step;\n          Indent          : Indentation_Level);\n       pragma Inline (Update_Successors);\n@@ -317,30 +307,30 @@ package body Bindo.Elaborators is\n \n       procedure Add_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n-         Set    : Membership_Set;\n+         Vertex : Library_Graph_Vertex_Id;\n+         Set    : LGV_Sets.Membership_Set;\n          Msg    : String;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level)\n       is\n       begin\n-         pragma Assert (Present (LGV_Id));\n-         pragma Assert (Needs_Elaboration (G, LGV_Id));\n-         pragma Assert (Present (Set));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Needs_Elaboration (G, Vertex));\n+         pragma Assert (LGV_Sets.Present (Set));\n \n          --  Add vertex only when it is not present in the set. This is not\n          --  strictly necessary because the set implementation handles this\n          --  case, however the check eliminates spurious traces.\n \n-         if not Contains (Set, LGV_Id) then\n+         if not LGV_Sets.Contains (Set, Vertex) then\n             Trace_Vertex\n               (G      => G,\n-               LGV_Id => LGV_Id,\n+               Vertex => Vertex,\n                Msg    => Msg,\n                Step   => Step,\n                Indent => Indent);\n \n-            Insert (Set, LGV_Id);\n+            LGV_Sets.Insert (Set, Vertex);\n          end if;\n       end Add_Vertex;\n \n@@ -350,53 +340,53 @@ package body Bindo.Elaborators is\n \n       procedure Add_Vertex_If_Elaborable\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n-         Set    : Membership_Set;\n+         Vertex : Library_Graph_Vertex_Id;\n+         Set    : LGV_Sets.Membership_Set;\n          Msg    : String;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level)\n       is\n-         Aux_LGV_Id : Library_Graph_Vertex_Id;\n+         Extra_Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (LGV_Id));\n-         pragma Assert (Needs_Elaboration (G, LGV_Id));\n-         pragma Assert (Present (Set));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Needs_Elaboration (G, Vertex));\n+         pragma Assert (LGV_Sets.Present (Set));\n \n-         if Is_Elaborable_Vertex (G, LGV_Id) then\n+         if Is_Elaborable_Vertex (G, Vertex) then\n             Add_Vertex\n               (G      => G,\n-               LGV_Id => LGV_Id,\n+               Vertex => Vertex,\n                Set    => Set,\n                Msg    => Msg,\n                Step   => Step,\n                Indent => Indent);\n \n             --  Assume that there is no extra vertex that needs to be added\n \n-            Aux_LGV_Id := No_Library_Graph_Vertex;\n+            Extra_Vertex := No_Library_Graph_Vertex;\n \n             --  A spec-body pair where the spec carries pragma Elaborate_Body\n             --  must be treated as one vertex for elaboration purposes. If one\n             --  of them is elaborable, then the other is also elaborable. This\n             --  property is guaranteed by predicate Is_Elaborable_Vertex.\n \n-            if Is_Body_Of_Spec_With_Elaborate_Body (G, LGV_Id) then\n-               Aux_LGV_Id := Proper_Spec (G, LGV_Id);\n-               pragma Assert (Present (Aux_LGV_Id));\n+            if Is_Body_Of_Spec_With_Elaborate_Body (G, Vertex) then\n+               Extra_Vertex := Proper_Spec (G, Vertex);\n+               pragma Assert (Present (Extra_Vertex));\n \n-            elsif Is_Spec_With_Elaborate_Body (G, LGV_Id) then\n-               Aux_LGV_Id := Proper_Body (G, LGV_Id);\n-               pragma Assert (Present (Aux_LGV_Id));\n+            elsif Is_Spec_With_Elaborate_Body (G, Vertex) then\n+               Extra_Vertex := Proper_Body (G, Vertex);\n+               pragma Assert (Present (Extra_Vertex));\n             end if;\n \n-            if Present (Aux_LGV_Id) then\n-               pragma Assert (Needs_Elaboration (G, Aux_LGV_Id));\n+            if Present (Extra_Vertex) then\n+               pragma Assert (Needs_Elaboration (G, Extra_Vertex));\n \n                Add_Vertex\n                  (G      => G,\n-                  LGV_Id => Aux_LGV_Id,\n+                  Vertex => Extra_Vertex,\n                   Set    => Set,\n                   Msg    => Msg,\n                   Step   => Step,\n@@ -411,24 +401,23 @@ package body Bindo.Elaborators is\n \n       function Create_All_Candidates_Set\n         (G    : Library_Graph;\n-         Step : Elaboration_Order_Step) return Membership_Set\n+         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set\n       is\n          Iter   : Library_Graphs.All_Vertex_Iterator;\n-         LGV_Id : Library_Graph_Vertex_Id;\n-         Set    : Membership_Set;\n+         Set    : LGV_Sets.Membership_Set;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n \n-         Set  := Create (Number_Of_Vertices (G));\n+         Set  := LGV_Sets.Create (Number_Of_Vertices (G));\n          Iter := Iterate_All_Vertices (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGV_Id);\n-            pragma Assert (Present (LGV_Id));\n+            Next (Iter, Vertex);\n \n             Add_Vertex_If_Elaborable\n               (G      => G,\n-               LGV_Id => LGV_Id,\n+               Vertex => Vertex,\n                Set    => Set,\n                Msg    => Add_To_All_Candidates_Msg,\n                Step   => Step,\n@@ -445,25 +434,24 @@ package body Bindo.Elaborators is\n       function Create_Component_Candidates_Set\n         (G    : Library_Graph;\n          Comp : Component_Id;\n-         Step : Elaboration_Order_Step) return Membership_Set\n+         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set\n       is\n          Iter   : Component_Vertex_Iterator;\n-         LGV_Id : Library_Graph_Vertex_Id;\n-         Set    : Membership_Set;\n+         Set    : LGV_Sets.Membership_Set;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Comp));\n \n-         Set  := Create (Number_Of_Component_Vertices (G, Comp));\n+         Set  := LGV_Sets.Create (Number_Of_Component_Vertices (G, Comp));\n          Iter := Iterate_Component_Vertices (G, Comp);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGV_Id);\n-            pragma Assert (Present (LGV_Id));\n+            Next (Iter, Vertex);\n \n             Add_Vertex_If_Elaborable\n               (G      => G,\n-               LGV_Id => LGV_Id,\n+               Vertex => Vertex,\n                Set    => Set,\n                Msg    => Add_To_Comp_Candidates_Msg,\n                Step   => Step,\n@@ -480,18 +468,18 @@ package body Bindo.Elaborators is\n       procedure Elaborate_Component\n         (G                  : Library_Graph;\n          Comp               : Component_Id;\n-         All_Candidates     : Membership_Set;\n+         All_Candidates     : LGV_Sets.Membership_Set;\n          Remaining_Vertices : in out Natural;\n          Order              : in out Unit_Id_Table;\n          Step               : Elaboration_Order_Step)\n       is\n          Candidate       : Library_Graph_Vertex_Id;\n-         Comp_Candidates : Membership_Set;\n+         Comp_Candidates : LGV_Sets.Membership_Set;\n \n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Comp));\n-         pragma Assert (Present (All_Candidates));\n+         pragma Assert (LGV_Sets.Present (All_Candidates));\n \n          Trace_Component\n            (G    => G,\n@@ -518,7 +506,7 @@ package body Bindo.Elaborators is\n \n             Elaborate_Vertex\n               (G                  => G,\n-               LGV_Id             => Candidate,\n+               Vertex             => Candidate,\n                All_Candidates     => All_Candidates,\n                Comp_Candidates    => Comp_Candidates,\n                Remaining_Vertices => Remaining_Vertices,\n@@ -527,7 +515,7 @@ package body Bindo.Elaborators is\n                Indent             => Nested_Indentation);\n          end loop;\n \n-         Destroy (Comp_Candidates);\n+         LGV_Sets.Destroy (Comp_Candidates);\n       end Elaborate_Component;\n \n       -----------------------------\n@@ -539,9 +527,8 @@ package body Bindo.Elaborators is\n          Order  : out Unit_Id_Table;\n          Status : out Elaboration_Order_Status)\n       is\n-         All_Candidates     : Membership_Set;\n+         All_Candidates     : LGV_Sets.Membership_Set;\n          Candidate          : Library_Graph_Vertex_Id;\n-         Comp               : Component_Id;\n          Remaining_Vertices : Natural;\n          Step               : Elaboration_Order_Step;\n \n@@ -585,19 +572,16 @@ package body Bindo.Elaborators is\n             --  and their components that they have one less predecessor to\n             --  wait on. This may add new candidates to set All_Candidates.\n \n-            Comp := Component (G, Candidate);\n-            pragma Assert (Present (Comp));\n-\n             Elaborate_Component\n               (G                  => G,\n-               Comp               => Comp,\n+               Comp               => Component (G, Candidate),\n                All_Candidates     => All_Candidates,\n                Remaining_Vertices => Remaining_Vertices,\n                Order              => Order,\n                Step               => Step);\n          end loop;\n \n-         Destroy (All_Candidates);\n+         LGV_Sets.Destroy (All_Candidates);\n \n          --  The library graph contains an Elaborate_All circularity when\n          --  at least one edge subject to the related pragma appears in a\n@@ -642,7 +626,7 @@ package body Bindo.Elaborators is\n          Write_ALI_Tables;\n \n          --  Choose the proper elaboration strategy based on whether the main\n-         --  library unit was compiled with dynamic elaboration checks.\n+         --  library unit was compiled using the dynamic model.\n \n          if Is_Dynamically_Elaborated (Main_Lib_Unit) then\n             Elaborate_Units_Dynamic (Order);\n@@ -673,6 +657,7 @@ package body Bindo.Elaborators is\n \n       procedure Elaborate_Units_Common\n         (Use_Inv_Graph : Boolean;\n+         Is_Dyn_Elab   : Boolean;\n          Inv_Graph     : out Invocation_Graph;\n          Lib_Graph     : out Library_Graph;\n          Order         : out Unit_Id_Table;\n@@ -682,7 +667,7 @@ package body Bindo.Elaborators is\n          --  Create, validate, and output the library graph that captures the\n          --  dependencies between library items.\n \n-         Lib_Graph := Build_Library_Graph;\n+         Lib_Graph := Build_Library_Graph (Is_Dyn_Elab);\n          Validate_Library_Graph (Lib_Graph);\n          Write_Library_Graph    (Lib_Graph);\n \n@@ -746,6 +731,7 @@ package body Bindo.Elaborators is\n \n          Elaborate_Units_Common\n            (Use_Inv_Graph => True,\n+            Is_Dyn_Elab   => True,\n             Inv_Graph     => Mix_Inv_Graph,\n             Lib_Graph     => Mix_Lib_Graph,\n             Order         => Mix_Order,\n@@ -761,9 +747,9 @@ package body Bindo.Elaborators is\n          --  the invocation graph because the circularity will persist.\n \n          elsif Status = Order_Has_Elaborate_All_Circularity then\n-            Error_Msg (\"elaboration circularity detected\");\n-\n-            --  Report error here\n+            Diagnose_Circularities\n+              (Inv_Graph => Mix_Inv_Graph,\n+               Lib_Graph => Mix_Lib_Graph);\n \n          --  Otherwise the library graph contains a circularity, or the extra\n          --  information provided by the invocation graph caused a circularity.\n@@ -776,6 +762,7 @@ package body Bindo.Elaborators is\n \n             Elaborate_Units_Common\n               (Use_Inv_Graph => False,\n+               Is_Dyn_Elab   => True,\n                Inv_Graph     => Dyn_Inv_Graph,\n                Lib_Graph     => Dyn_Lib_Graph,\n                Order         => Dyn_Order,\n@@ -792,9 +779,9 @@ package body Bindo.Elaborators is\n             --  the circularity.\n \n             else\n-               Error_Msg (\"elaboration circularity detected\");\n-\n-               --  Report error here\n+               Diagnose_Circularities\n+                 (Inv_Graph => Dyn_Inv_Graph,\n+                  Lib_Graph => Dyn_Lib_Graph);\n             end if;\n \n             Destroy (Dyn_Inv_Graph);\n@@ -827,6 +814,7 @@ package body Bindo.Elaborators is\n \n          Elaborate_Units_Common\n            (Use_Inv_Graph => True,\n+            Is_Dyn_Elab   => False,\n             Inv_Graph     => Inv_Graph,\n             Lib_Graph     => Lib_Graph,\n             Order         => Order,\n@@ -835,9 +823,9 @@ package body Bindo.Elaborators is\n          --  The augmented library graph contains a circularity\n \n          if Status /= Order_OK then\n-            Error_Msg (\"elaboration circularity detected\");\n-\n-            --  Report error here\n+            Diagnose_Circularities\n+              (Inv_Graph => Inv_Graph,\n+               Lib_Graph => Lib_Graph);\n          end if;\n \n          Destroy (Inv_Graph);\n@@ -856,27 +844,24 @@ package body Bindo.Elaborators is\n \n       procedure Elaborate_Vertex\n         (G                  : Library_Graph;\n-         LGV_Id             : Library_Graph_Vertex_Id;\n-         All_Candidates     : Membership_Set;\n-         Comp_Candidates    : Membership_Set;\n+         Vertex             : Library_Graph_Vertex_Id;\n+         All_Candidates     : LGV_Sets.Membership_Set;\n+         Comp_Candidates    : LGV_Sets.Membership_Set;\n          Remaining_Vertices : in out Natural;\n          Order              : in out Unit_Id_Table;\n          Step               : Elaboration_Order_Step;\n          Indent             : Indentation_Level)\n       is\n-         Body_LGV_Id : Library_Graph_Vertex_Id;\n-         U_Id        : Unit_Id;\n-\n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (LGV_Id));\n-         pragma Assert (Needs_Elaboration (G, LGV_Id));\n-         pragma Assert (Present (All_Candidates));\n-         pragma Assert (Present (Comp_Candidates));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Needs_Elaboration (G, Vertex));\n+         pragma Assert (LGV_Sets.Present (All_Candidates));\n+         pragma Assert (LGV_Sets.Present (Comp_Candidates));\n \n          Trace_Vertex\n            (G      => G,\n-            LGV_Id => LGV_Id,\n+            Vertex => Vertex,\n             Msg    => \"elaborating vertex\",\n             Step   => Step,\n             Indent => Indent);\n@@ -887,20 +872,17 @@ package body Bindo.Elaborators is\n          --  check that the vertex is present in either set because the set\n          --  implementation handles this case.\n \n-         Delete (All_Candidates,  LGV_Id);\n-         Delete (Comp_Candidates, LGV_Id);\n+         LGV_Sets.Delete (All_Candidates,  Vertex);\n+         LGV_Sets.Delete (Comp_Candidates, Vertex);\n \n          --  Mark the vertex as elaborated in order to prevent further attempts\n          --  to re-elaborate it.\n \n-         Set_In_Elaboration_Order (G, LGV_Id);\n+         Set_In_Elaboration_Order (G, Vertex);\n \n          --  Add the unit represented by the vertex to the elaboration order\n \n-         U_Id := Unit (G, LGV_Id);\n-         pragma Assert (Present (U_Id));\n-\n-         Unit_Id_Tables.Append (Order, U_Id);\n+         Unit_Id_Tables.Append (Order, Unit (G, Vertex));\n \n          --  There is now one fewer vertex to elaborate\n \n@@ -912,7 +894,7 @@ package body Bindo.Elaborators is\n \n          Update_Successors\n            (G               => G,\n-            Pred            => LGV_Id,\n+            Pred            => Vertex,\n             All_Candidates  => All_Candidates,\n             Comp_Candidates => Comp_Candidates,\n             Step            => Step,\n@@ -922,13 +904,10 @@ package body Bindo.Elaborators is\n          --  to pragma Elaborate_Body. Elaborate the body in order to satisfy\n          --  the semantics of the pragma.\n \n-         if Is_Spec_With_Elaborate_Body (G, LGV_Id) then\n-            Body_LGV_Id := Proper_Body (G, LGV_Id);\n-            pragma Assert (Present (Body_LGV_Id));\n-\n+         if Is_Spec_With_Elaborate_Body (G, Vertex) then\n             Elaborate_Vertex\n               (G                  => G,\n-               LGV_Id             => Body_LGV_Id,\n+               Vertex             => Proper_Body (G, Vertex),\n                All_Candidates     => All_Candidates,\n                Comp_Candidates    => Comp_Candidates,\n                Remaining_Vertices => Remaining_Vertices,\n@@ -944,17 +923,17 @@ package body Bindo.Elaborators is\n \n       function Find_Best_Candidate\n         (G      : Library_Graph;\n-         Set    : Membership_Set;\n+         Set    : LGV_Sets.Membership_Set;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level) return Library_Graph_Vertex_Id\n       is\n-         Best : Library_Graph_Vertex_Id;\n-         Curr : Library_Graph_Vertex_Id;\n-         Iter : Iterator;\n+         Best    : Library_Graph_Vertex_Id;\n+         Current : Library_Graph_Vertex_Id;\n+         Iter    : LGV_Sets.Iterator;\n \n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Set));\n+         pragma Assert (LGV_Sets.Present (Set));\n \n          --  Assume that there is no candidate\n \n@@ -963,21 +942,19 @@ package body Bindo.Elaborators is\n          --  Inspect all vertices in the set, looking for the best candidate to\n          --  elaborate.\n \n-         Iter := Iterate (Set);\n-         while Has_Next (Iter) loop\n-            Next (Iter, Curr);\n-\n-            pragma Assert (Present (Curr));\n-            pragma Assert (Needs_Elaboration (G, Curr));\n+         Iter := LGV_Sets.Iterate (Set);\n+         while LGV_Sets.Has_Next (Iter) loop\n+            LGV_Sets.Next (Iter, Current);\n+            pragma Assert (Needs_Elaboration (G, Current));\n \n             --  Update the best candidate when there is no such candidate\n \n             if not Present (Best) then\n-               Best := Curr;\n+               Best := Current;\n \n                Trace_Vertex\n                  (G      => G,\n-                  LGV_Id => Best,\n+                  Vertex => Best,\n                   Msg    => \"initial best candidate vertex\",\n                   Step   => Step,\n                   Indent => Indent);\n@@ -987,14 +964,14 @@ package body Bindo.Elaborators is\n \n             elsif Is_Better_Candidate\n                     (G           => G,\n-                     Best_Candid => Best,\n-                     New_Candid  => Curr)\n+                     Best_Candidate => Best,\n+                     New_Candidate  => Current)\n             then\n-               Best := Curr;\n+               Best := Current;\n \n                Trace_Vertex\n                  (G      => G,\n-                  LGV_Id => Best,\n+                  Vertex => Best,\n                   Msg    => \"best candidate vertex\",\n                   Step   => Step,\n                   Indent => Indent);\n@@ -1009,56 +986,57 @@ package body Bindo.Elaborators is\n       -------------------------\n \n       function Is_Better_Candidate\n-        (G           : Library_Graph;\n-         Best_Candid : Library_Graph_Vertex_Id;\n-         New_Candid  : Library_Graph_Vertex_Id) return Boolean\n+        (G              : Library_Graph;\n+         Best_Candidate : Library_Graph_Vertex_Id;\n+         New_Candidate  : Library_Graph_Vertex_Id) return Boolean\n       is\n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Best_Candid));\n-         pragma Assert (Present (New_Candid));\n+         pragma Assert (Present (Best_Candidate));\n+         pragma Assert (Present (New_Candidate));\n \n          --  Prefer a predefined unit over a non-predefined unit\n \n-         if Is_Predefined_Unit (G, Best_Candid)\n-           and then not Is_Predefined_Unit (G, New_Candid)\n+         if Is_Predefined_Unit (G, Best_Candidate)\n+           and then not Is_Predefined_Unit (G, New_Candidate)\n          then\n             return False;\n \n-         elsif not Is_Predefined_Unit (G, Best_Candid)\n-           and then Is_Predefined_Unit (G, New_Candid)\n+         elsif not Is_Predefined_Unit (G, Best_Candidate)\n+           and then Is_Predefined_Unit (G, New_Candidate)\n          then\n             return True;\n \n          --  Prefer an internal unit over a non-iternal unit\n \n-         elsif Is_Internal_Unit (G, Best_Candid)\n-           and then not Is_Internal_Unit (G, New_Candid)\n+         elsif Is_Internal_Unit (G, Best_Candidate)\n+           and then not Is_Internal_Unit (G, New_Candidate)\n          then\n             return False;\n \n-         elsif not Is_Internal_Unit (G, Best_Candid)\n-           and then Is_Internal_Unit (G, New_Candid)\n+         elsif not Is_Internal_Unit (G, Best_Candidate)\n+           and then Is_Internal_Unit (G, New_Candidate)\n          then\n             return True;\n \n          --  Prefer a preelaborated unit over a non-preelaborated unit\n \n-         elsif Is_Preelaborated_Unit (G, Best_Candid)\n-           and then not Is_Preelaborated_Unit (G, New_Candid)\n+         elsif Is_Preelaborated_Unit (G, Best_Candidate)\n+           and then not Is_Preelaborated_Unit (G, New_Candidate)\n          then\n             return False;\n \n-         elsif not Is_Preelaborated_Unit (G, Best_Candid)\n-           and then Is_Preelaborated_Unit (G, New_Candid)\n+         elsif not Is_Preelaborated_Unit (G, Best_Candidate)\n+           and then Is_Preelaborated_Unit (G, New_Candidate)\n          then\n             return True;\n \n          --  Otherwise default to lexicographical order to ensure deterministic\n          --  behavior.\n \n          else\n-            return Uname_Less (Name (G, Best_Candid), Name (G, New_Candid));\n+            return\n+              Uname_Less (Name (G, Best_Candidate), Name (G, New_Candidate));\n          end if;\n       end Is_Better_Candidate;\n \n@@ -1068,36 +1046,35 @@ package body Bindo.Elaborators is\n \n       procedure Trace_Candidate_Vertices\n         (G    : Library_Graph;\n-         Set  : Membership_Set;\n+         Set  : LGV_Sets.Membership_Set;\n          Step : Elaboration_Order_Step)\n       is\n-         Iter   : Iterator;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Iter   : LGV_Sets.Iterator;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Set));\n+         pragma Assert (LGV_Sets.Present (Set));\n \n-         --  Nothing to do when switch -d_T (output elaboration order trace\n-         --  information) is not in effect.\n+         --  Nothing to do when switch -d_T (output elaboration order and cycle\n+         --  detection trace information) is not in effect.\n \n          if not Debug_Flag_Underscore_TT then\n             return;\n          end if;\n \n          Trace_Step (Step);\n          Write_Str  (\"candidate vertices: \");\n-         Write_Int  (Int (Size (Set)));\n+         Write_Int  (Int (LGV_Sets.Size (Set)));\n          Write_Eol;\n \n-         Iter := Iterate (Set);\n-         while Has_Next (Iter) loop\n-            Next (Iter, LGV_Id);\n-            pragma Assert (Present (LGV_Id));\n+         Iter := LGV_Sets.Iterate (Set);\n+         while LGV_Sets.Has_Next (Iter) loop\n+            LGV_Sets.Next (Iter, Vertex);\n \n             Trace_Vertex\n               (G      => G,\n-               LGV_Id => LGV_Id,\n+               Vertex => Vertex,\n                Msg    => \"candidate vertex\",\n                Step   => Step,\n                Indent => Nested_Indentation);\n@@ -1118,8 +1095,8 @@ package body Bindo.Elaborators is\n          pragma Assert (Present (G));\n          pragma Assert (Present (Comp));\n \n-         --  Nothing to do when switch -d_T (output elaboration order trace\n-         --  information) is not in effect.\n+         --  Nothing to do when switch -d_T (output elaboration order and cycle\n+         --  detection trace information) is not in effect.\n \n          if not Debug_Flag_Underscore_TT then\n             return;\n@@ -1145,8 +1122,8 @@ package body Bindo.Elaborators is\n \n       procedure Trace_Step (Step : Elaboration_Order_Step) is\n       begin\n-         --  Nothing to do when switch -d_T (output elaboration order trace\n-         --  information) is not in effect.\n+         --  Nothing to do when switch -d_T (output elaboration order and cycle\n+         --  detection trace information) is not in effect.\n \n          if not Debug_Flag_Underscore_TT then\n             return;\n@@ -1168,13 +1145,13 @@ package body Bindo.Elaborators is\n          Step  : Elaboration_Order_Step)\n       is\n          Iter   : Library_Graphs.All_Vertex_Iterator;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n \n-         --  Nothing to do when switch -d_T (output elaboration order trace\n-         --  information) is not in effect.\n+         --  Nothing to do when switch -d_T (output elaboration order and cycle\n+         --  detection trace information) is not in effect.\n \n          if not Debug_Flag_Underscore_TT then\n             return;\n@@ -1187,15 +1164,14 @@ package body Bindo.Elaborators is\n \n          Iter := Iterate_All_Vertices (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGV_Id);\n-            pragma Assert (Present (LGV_Id));\n+            Next (Iter, Vertex);\n \n-            if Needs_Elaboration (G, LGV_Id)\n-              and then not In_Elaboration_Order (G, LGV_Id)\n+            if Needs_Elaboration (G, Vertex)\n+              and then not In_Elaboration_Order (G, Vertex)\n             then\n                Trace_Vertex\n                  (G      => G,\n-                  LGV_Id => LGV_Id,\n+                  Vertex => Vertex,\n                   Msg    => \"remaining vertex\",\n                   Step   => Step,\n                   Indent => Nested_Indentation);\n@@ -1209,21 +1185,21 @@ package body Bindo.Elaborators is\n \n       procedure Trace_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n          Msg    : String;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level)\n       is\n          pragma Assert (Present (G));\n-         pragma Assert (Present (LGV_Id));\n+         pragma Assert (Present (Vertex));\n \n-         Comp : constant Component_Id := Component (G, LGV_Id);\n-\n-         pragma Assert (Present (Comp));\n+         Attr_Indent : constant Indentation_Level :=\n+                         Indent + Nested_Indentation;\n+         Comp        : constant Component_Id := Component (G, Vertex);\n \n       begin\n-         --  Nothing to do when switch -d_T (output elaboration order trace\n-         --  information) is not in effect.\n+         --  Nothing to do when switch -d_T (output elaboration order and cycle\n+         --  detection trace information) is not in effect.\n \n          if not Debug_Flag_Underscore_TT then\n             return;\n@@ -1233,31 +1209,31 @@ package body Bindo.Elaborators is\n          Indent_By  (Indent);\n          Write_Str  (Msg);\n          Write_Str  (\" (LGV_Id_\");\n-         Write_Int  (Int (LGV_Id));\n+         Write_Int  (Int (Vertex));\n          Write_Str  (\")\");\n          Write_Eol;\n \n          Trace_Step (Step);\n-         Indent_By  (Indent + Nested_Indentation);\n+         Indent_By  (Attr_Indent);\n          Write_Str  (\"name = \");\n-         Write_Name (Name (G, LGV_Id));\n+         Write_Name (Name (G, Vertex));\n          Write_Eol;\n \n          Trace_Step (Step);\n-         Indent_By  (Indent + Nested_Indentation);\n+         Indent_By  (Attr_Indent);\n          Write_Str  (\"Component (Comp_Id_\");\n          Write_Int  (Int (Comp));\n          Write_Str  (\")\");\n          Write_Eol;\n \n          Trace_Step (Step);\n-         Indent_By  (Indent + Nested_Indentation);\n+         Indent_By  (Attr_Indent);\n          Write_Str  (\"pending predecessors: \");\n-         Write_Num  (Int (Pending_Predecessors (G, LGV_Id)));\n+         Write_Num  (Int (Pending_Predecessors (G, Vertex)));\n          Write_Eol;\n \n          Trace_Step (Step);\n-         Indent_By  (Indent + Nested_Indentation);\n+         Indent_By  (Attr_Indent);\n          Write_Str  (\"pending components  : \");\n          Write_Num  (Int (Pending_Predecessors (G, Comp)));\n          Write_Eol;\n@@ -1271,8 +1247,8 @@ package body Bindo.Elaborators is\n         (G               : Library_Graph;\n          Pred            : Library_Graph_Vertex_Id;\n          Succ            : Library_Graph_Vertex_Id;\n-         All_Candidates  : Membership_Set;\n-         Comp_Candidates : Membership_Set;\n+         All_Candidates  : LGV_Sets.Membership_Set;\n+         Comp_Candidates : LGV_Sets.Membership_Set;\n          Step            : Elaboration_Order_Step;\n          Indent          : Indentation_Level)\n       is\n@@ -1281,26 +1257,28 @@ package body Bindo.Elaborators is\n          pragma Assert (Needs_Elaboration (G, Pred));\n          pragma Assert (Present (Succ));\n          pragma Assert (Needs_Elaboration (G, Succ));\n-         pragma Assert (Present (All_Candidates));\n-         pragma Assert (Present (Comp_Candidates));\n-\n-         Pred_Comp : constant Component_Id := Component (G, Pred);\n-         Succ_Comp : constant Component_Id := Component (G, Succ);\n+         pragma Assert (LGV_Sets.Present (All_Candidates));\n+         pragma Assert (LGV_Sets.Present (Comp_Candidates));\n \n-         pragma Assert (Present (Pred_Comp));\n-         pragma Assert (Present (Succ_Comp));\n+         In_Different_Components : constant Boolean :=\n+                                     not In_Same_Component\n+                                           (G     => G,\n+                                            Left  => Pred,\n+                                            Right => Succ);\n \n-         In_Different_Components : constant Boolean := Pred_Comp /= Succ_Comp;\n+         Succ_Comp     : constant Component_Id      := Component (G, Succ);\n+         Vertex_Indent : constant Indentation_Level :=\n+                           Indent + Nested_Indentation;\n \n          Candidate : Library_Graph_Vertex_Id;\n          Iter      : Component_Vertex_Iterator;\n          Msg       : String_Ptr;\n-         Set       : Membership_Set;\n+         Set       : LGV_Sets.Membership_Set;\n \n       begin\n          Trace_Vertex\n            (G      => G,\n-            LGV_Id => Succ,\n+            Vertex => Succ,\n             Msg    => \"updating successor\",\n             Step   => Step,\n             Indent => Indent);\n@@ -1341,11 +1319,11 @@ package body Bindo.Elaborators is\n \n          Add_Vertex_If_Elaborable\n            (G      => G,\n-            LGV_Id => Succ,\n+            Vertex => Succ,\n             Set    => Set,\n             Msg    => Msg.all,\n             Step   => Step,\n-            Indent => Indent + Nested_Indentation);\n+            Indent => Vertex_Indent);\n \n          --  At this point the successor component may become elaborable when\n          --  its final predecessor component is elaborated. This in turn may\n@@ -1357,15 +1335,14 @@ package body Bindo.Elaborators is\n             Iter := Iterate_Component_Vertices (G, Succ_Comp);\n             while Has_Next (Iter) loop\n                Next (Iter, Candidate);\n-               pragma Assert (Present (Candidate));\n \n                Add_Vertex_If_Elaborable\n                  (G      => G,\n-                  LGV_Id => Candidate,\n+                  Vertex => Candidate,\n                   Set    => All_Candidates,\n                   Msg    => Add_To_All_Candidates_Msg,\n                   Step   => Step,\n-                  Indent => Indent + Nested_Indentation);\n+                  Indent => Vertex_Indent);\n             end loop;\n          end if;\n       end Update_Successor;\n@@ -1377,36 +1354,30 @@ package body Bindo.Elaborators is\n       procedure Update_Successors\n         (G               : Library_Graph;\n          Pred            : Library_Graph_Vertex_Id;\n-         All_Candidates  : Membership_Set;\n-         Comp_Candidates : Membership_Set;\n+         All_Candidates  : LGV_Sets.Membership_Set;\n+         Comp_Candidates : LGV_Sets.Membership_Set;\n          Step            : Elaboration_Order_Step;\n          Indent          : Indentation_Level)\n       is\n-         Iter   : Edges_To_Successors_Iterator;\n-         LGE_Id : Library_Graph_Edge_Id;\n-         Succ   : Library_Graph_Vertex_Id;\n+         Edge : Library_Graph_Edge_Id;\n+         Iter : Edges_To_Successors_Iterator;\n \n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Pred));\n          pragma Assert (Needs_Elaboration (G, Pred));\n-         pragma Assert (Present (All_Candidates));\n-         pragma Assert (Present (Comp_Candidates));\n+         pragma Assert (LGV_Sets.Present (All_Candidates));\n+         pragma Assert (LGV_Sets.Present (Comp_Candidates));\n \n          Iter := Iterate_Edges_To_Successors (G, Pred);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGE_Id);\n-\n-            pragma Assert (Present (LGE_Id));\n-            pragma Assert (Predecessor (G, LGE_Id) = Pred);\n-\n-            Succ := Successor (G, LGE_Id);\n-            pragma Assert (Present (Succ));\n+            Next (Iter, Edge);\n+            pragma Assert (Predecessor (G, Edge) = Pred);\n \n             Update_Successor\n               (G               => G,\n                Pred            => Pred,\n-               Succ            => Succ,\n+               Succ            => Successor (G, Edge),\n                All_Candidates  => All_Candidates,\n                Comp_Candidates => Comp_Candidates,\n                Step            => Step,"}, {"sha": "c68e367d56799ddd9a4fdaf7d5556919966077cc", "filename": "gcc/ada/bindo-graphs.adb", "status": "modified", "additions": 2583, "deletions": 588, "changes": 3171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310"}, {"sha": "02f8e52fd64db6288b5207efa31b9b1dd5bd7e1a", "filename": "gcc/ada/bindo-graphs.ads", "status": "modified", "additions": 519, "deletions": 161, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -28,11 +28,14 @@\n --  The following unit defines the various graphs used in determining the\n --  elaboration order of units.\n \n+with Types; use Types;\n+\n with Bindo.Units; use Bindo.Units;\n \n with GNAT;                 use GNAT;\n with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n with GNAT.Graphs;          use GNAT.Graphs;\n+with GNAT.Lists;           use GNAT.Lists;\n with GNAT.Sets;            use GNAT.Sets;\n \n package Bindo.Graphs is\n@@ -49,14 +52,24 @@ package Bindo.Graphs is\n    First_Invocation_Graph_Edge : constant Invocation_Graph_Edge_Id :=\n                                    No_Invocation_Graph_Edge + 1;\n \n+   procedure Destroy_Invocation_Graph_Edge\n+     (Edge : in out Invocation_Graph_Edge_Id);\n+   pragma Inline (Destroy_Invocation_Graph_Edge);\n+   --  Destroy invocation graph edge Edge\n+\n    function Hash_Invocation_Graph_Edge\n-     (IGE_Id : Invocation_Graph_Edge_Id) return Bucket_Range_Type;\n+     (Edge : Invocation_Graph_Edge_Id) return Bucket_Range_Type;\n    pragma Inline (Hash_Invocation_Graph_Edge);\n-   --  Obtain the hash value of key IGE_Id\n+   --  Obtain the hash value of key Edge\n \n-   function Present (IGE_Id : Invocation_Graph_Edge_Id) return Boolean;\n+   function Present (Edge : Invocation_Graph_Edge_Id) return Boolean;\n    pragma Inline (Present);\n-   --  Determine whether invocation graph edge IGE_Id exists\n+   --  Determine whether invocation graph edge Edge exists\n+\n+   package IGE_Lists is new Doubly_Linked_Lists\n+     (Element_Type    => Invocation_Graph_Edge_Id,\n+      \"=\"             => \"=\",\n+      Destroy_Element => Destroy_Invocation_Graph_Edge);\n \n    ------------------------------\n    --  Invocation graph vertex --\n@@ -71,13 +84,47 @@ package Bindo.Graphs is\n                                      No_Invocation_Graph_Vertex + 1;\n \n    function Hash_Invocation_Graph_Vertex\n-     (IGV_Id : Invocation_Graph_Vertex_Id) return Bucket_Range_Type;\n+     (Vertex : Invocation_Graph_Vertex_Id) return Bucket_Range_Type;\n    pragma Inline (Hash_Invocation_Graph_Vertex);\n-   --  Obtain the hash value of key IGV_Id\n+   --  Obtain the hash value of key Vertex\n \n-   function Present (IGV_Id : Invocation_Graph_Vertex_Id) return Boolean;\n+   function Present (Vertex : Invocation_Graph_Vertex_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether invocation graph vertex Vertex exists\n+\n+   package IGV_Sets is new Membership_Sets\n+     (Element_Type => Invocation_Graph_Vertex_Id,\n+      \"=\"          => \"=\",\n+      Hash         => Hash_Invocation_Graph_Vertex);\n+\n+   -------------------------\n+   -- Library graph cycle --\n+   -------------------------\n+\n+   type Library_Graph_Cycle_Id is new Natural;\n+   No_Library_Graph_Cycle    : constant Library_Graph_Cycle_Id :=\n+                                 Library_Graph_Cycle_Id'First;\n+   First_Library_Graph_Cycle : constant Library_Graph_Cycle_Id :=\n+                                 No_Library_Graph_Cycle + 1;\n+\n+   procedure Destroy_Library_Graph_Cycle\n+     (Cycle : in out Library_Graph_Cycle_Id);\n+   pragma Inline (Destroy_Library_Graph_Cycle);\n+   --  Destroy library graph cycle Cycle\n+\n+   function Hash_Library_Graph_Cycle\n+     (Cycle : Library_Graph_Cycle_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Library_Graph_Cycle);\n+   --  Obtain the hash value of key Cycle\n+\n+   function Present (Cycle : Library_Graph_Cycle_Id) return Boolean;\n    pragma Inline (Present);\n-   --  Determine whether invocation graph vertex IGV_Id exists\n+   --  Determine whether library graph cycle Cycle exists\n+\n+   package LGC_Lists is new Doubly_Linked_Lists\n+     (Element_Type    => Library_Graph_Cycle_Id,\n+      \"=\"             => \"=\",\n+      Destroy_Element => Destroy_Library_Graph_Cycle);\n \n    ------------------------\n    -- Library graph edge --\n@@ -91,14 +138,29 @@ package Bindo.Graphs is\n    First_Library_Graph_Edge : constant Library_Graph_Edge_Id :=\n                                 No_Library_Graph_Edge + 1;\n \n+   procedure Destroy_Library_Graph_Edge\n+     (Edge : in out Library_Graph_Edge_Id);\n+   pragma Inline (Destroy_Library_Graph_Edge);\n+   --  Destroy library graph edge Edge\n+\n    function Hash_Library_Graph_Edge\n-     (LGE_Id : Library_Graph_Edge_Id) return Bucket_Range_Type;\n+     (Edge : Library_Graph_Edge_Id) return Bucket_Range_Type;\n    pragma Inline (Hash_Library_Graph_Edge);\n-   --  Obtain the hash value of key LGE_Id\n+   --  Obtain the hash value of key Edge\n \n-   function Present (LGE_Id : Library_Graph_Edge_Id) return Boolean;\n+   function Present (Edge : Library_Graph_Edge_Id) return Boolean;\n    pragma Inline (Present);\n-   --  Determine whether library graph edge LGE_Id exists\n+   --  Determine whether library graph edge Edge exists\n+\n+   package LGE_Lists is new Doubly_Linked_Lists\n+     (Element_Type    => Library_Graph_Edge_Id,\n+      \"=\"             => \"=\",\n+      Destroy_Element => Destroy_Library_Graph_Edge);\n+\n+   package LGE_Sets is new Membership_Sets\n+     (Element_Type => Library_Graph_Edge_Id,\n+      \"=\"          => \"=\",\n+      Hash         => Hash_Library_Graph_Edge);\n \n    --------------------------\n    -- Library graph vertex --\n@@ -113,13 +175,18 @@ package Bindo.Graphs is\n                                   No_Library_Graph_Vertex + 1;\n \n    function Hash_Library_Graph_Vertex\n-     (LGV_Id : Library_Graph_Vertex_Id) return Bucket_Range_Type;\n+     (Vertex : Library_Graph_Vertex_Id) return Bucket_Range_Type;\n    pragma Inline (Hash_Library_Graph_Vertex);\n-   --  Obtain the hash value of key LGV_Id\n+   --  Obtain the hash value of key Vertex\n \n-   function Present (LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+   function Present (Vertex : Library_Graph_Vertex_Id) return Boolean;\n    pragma Inline (Present);\n-   --  Determine whether library graph vertex LGV_Id exists\n+   --  Determine whether library graph vertex Vertex exists\n+\n+   package LGV_Sets is new Membership_Sets\n+     (Element_Type => Library_Graph_Vertex_Id,\n+      \"=\"          => \"=\",\n+      Hash         => Hash_Library_Graph_Vertex);\n \n    -----------------------\n    -- Invocation_Graphs --\n@@ -152,13 +219,16 @@ package Bindo.Graphs is\n       --  describes.\n \n       procedure Add_Vertex\n-        (G      : Invocation_Graph;\n-         IC_Id  : Invocation_Construct_Id;\n-         LGV_Id : Library_Graph_Vertex_Id);\n+        (G           : Invocation_Graph;\n+         IC_Id       : Invocation_Construct_Id;\n+         Body_Vertex : Library_Graph_Vertex_Id;\n+         Spec_Vertex : Library_Graph_Vertex_Id);\n       pragma Inline (Add_Vertex);\n       --  Create a new vertex in invocation graph G. IC_Id is the invocation\n-      --  construct the vertex describes. LGV_Id is the library graph vertex\n-      --  where the invocation construct appears.\n+      --  construct the vertex describes. Body_Vertex denotes the library graph\n+      --  vertex where the invocation construct's body is declared. Spec_Vertex\n+      --  is the library graph vertex where the invocation construct's spec is\n+      --  declared.\n \n       function Create\n         (Initial_Vertices : Positive;\n@@ -179,11 +249,26 @@ package Bindo.Graphs is\n       -- Vertex attributes --\n       -----------------------\n \n+      function Body_Vertex\n+        (G      : Invocation_Graph;\n+         Vertex : Invocation_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Body_Vertex);\n+      --  Obtain the library graph vertex where the body of the invocation\n+      --  construct represented by vertex Vertex of invocation graph G is\n+      --  declared.\n+\n+      function Column\n+        (G      : Invocation_Graph;\n+         Vertex : Invocation_Graph_Vertex_Id) return Nat;\n+      pragma Inline (Column);\n+      --  Obtain the column number where the invocation construct vertex Vertex\n+      --  of invocation graph G describes.\n+\n       function Construct\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id) return Invocation_Construct_Id;\n+         Vertex : Invocation_Graph_Vertex_Id) return Invocation_Construct_Id;\n       pragma Inline (Construct);\n-      --  Obtain the invocation construct vertex IGV_Id of invocation graph G\n+      --  Obtain the invocation construct vertex Vertex of invocation graph G\n       --  describes.\n \n       function Corresponding_Vertex\n@@ -193,41 +278,56 @@ package Bindo.Graphs is\n       --  Obtain the vertex of invocation graph G that corresponds to signature\n       --  IS_Id.\n \n-      function Lib_Vertex\n+      function Line\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n-      pragma Inline (Lib_Vertex);\n-      --  Obtain the library graph vertex where vertex IGV_Id of invocation\n-      --  graph appears.\n+         Vertex : Invocation_Graph_Vertex_Id) return Nat;\n+      pragma Inline (Line);\n+      --  Obtain the line number where the invocation construct vertex Vertex\n+      --  of invocation graph G describes.\n \n       function Name\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id) return Name_Id;\n+         Vertex : Invocation_Graph_Vertex_Id) return Name_Id;\n       pragma Inline (Name);\n-      --  Obtain the name of the construct vertex IGV_Id of invocation graph G\n+      --  Obtain the name of the construct vertex Vertex of invocation graph G\n       --  describes.\n \n+      function Spec_Vertex\n+        (G      : Invocation_Graph;\n+         Vertex : Invocation_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Spec_Vertex);\n+      --  Obtain the library graph vertex where the spec of the invocation\n+      --  construct represented by vertex Vertex of invocation graph G is\n+      --  declared.\n+\n       ---------------------\n       -- Edge attributes --\n       ---------------------\n \n+      function Extra\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id) return Name_Id;\n+      pragma Inline (Extra);\n+      --  Obtain the extra name used in error diagnostics of edge Edge of\n+      --  invocation graph G.\n+\n       function Kind\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Kind;\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id) return Invocation_Kind;\n       pragma Inline (Kind);\n-      --  Obtain the nature of edge IGE_Id of invocation graph G\n+      --  Obtain the nature of edge Edge of invocation graph G\n \n       function Relation\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Relation_Id;\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id) return Invocation_Relation_Id;\n       pragma Inline (Relation);\n-      --  Obtain the relation edge IGE_Id of invocation graph G describes\n+      --  Obtain the relation edge Edge of invocation graph G describes\n \n       function Target\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Graph_Vertex_Id;\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id) return Invocation_Graph_Vertex_Id;\n       pragma Inline (Target);\n-      --  Obtain the target vertex edge IGE_Id of invocation graph G designates\n+      --  Obtain the target vertex edge Edge of invocation graph G designates\n \n       ----------------\n       -- Statistics --\n@@ -245,9 +345,9 @@ package Bindo.Graphs is\n \n       function Number_Of_Edges_To_Targets\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id) return Natural;\n+         Vertex : Invocation_Graph_Vertex_Id) return Natural;\n       pragma Inline (Number_Of_Edges_To_Targets);\n-      --  Obtain the total number of edges to targets vertex IGV_Id of\n+      --  Obtain the total number of edges to targets vertex Vertex of\n       --  invocation graph G has.\n \n       function Number_Of_Elaboration_Roots\n@@ -278,8 +378,8 @@ package Bindo.Graphs is\n       --  Obtain an iterator over all edges of invocation graph G\n \n       procedure Next\n-        (Iter   : in out All_Edge_Iterator;\n-         IGE_Id : out Invocation_Graph_Edge_Id);\n+        (Iter : in out All_Edge_Iterator;\n+         Edge : out Invocation_Graph_Edge_Id);\n       pragma Inline (Next);\n       --  Return the current edge referenced by iterator Iter and advance to\n       --  the next available edge.\n@@ -300,7 +400,7 @@ package Bindo.Graphs is\n \n       procedure Next\n         (Iter   : in out All_Vertex_Iterator;\n-         IGV_Id : out Invocation_Graph_Vertex_Id);\n+         Vertex : out Invocation_Graph_Vertex_Id);\n       pragma Inline (Next);\n       --  Return the current vertex referenced by iterator Iter and advance\n       --  to the next available vertex.\n@@ -316,14 +416,14 @@ package Bindo.Graphs is\n \n       function Iterate_Edges_To_Targets\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id) return Edges_To_Targets_Iterator;\n+         Vertex : Invocation_Graph_Vertex_Id) return Edges_To_Targets_Iterator;\n       pragma Inline (Iterate_Edges_To_Targets);\n       --  Obtain an iterator over all edges to targets with source vertex\n-      --  IGV_Id of invocation graph G.\n+      --  Vertex of invocation graph G.\n \n       procedure Next\n-        (Iter   : in out Edges_To_Targets_Iterator;\n-         IGE_Id : out Invocation_Graph_Edge_Id);\n+        (Iter : in out Edges_To_Targets_Iterator;\n+         Edge : out Invocation_Graph_Edge_Id);\n       pragma Inline (Next);\n       --  Return the current edge referenced by iterator Iter and advance to\n       --  the next available edge.\n@@ -357,32 +457,38 @@ package Bindo.Graphs is\n       --------------\n \n       procedure Destroy_Invocation_Graph_Vertex\n-        (IGV_Id : in out Invocation_Graph_Vertex_Id);\n+        (Vertex : in out Invocation_Graph_Vertex_Id);\n       pragma Inline (Destroy_Invocation_Graph_Vertex);\n-      --  Destroy invocation graph vertex IGV_Id\n+      --  Destroy invocation graph vertex Vertex\n \n       --  The following type represents the attributes of an invocation graph\n       --  vertex.\n \n       type Invocation_Graph_Vertex_Attributes is record\n+         Body_Vertex : Library_Graph_Vertex_Id := No_Library_Graph_Vertex;\n+         --  Reference to the library graph vertex where the body of this\n+         --  vertex resides.\n+\n          Construct : Invocation_Construct_Id := No_Invocation_Construct;\n          --  Reference to the invocation construct this vertex represents\n \n-         Lib_Vertex : Library_Graph_Vertex_Id := No_Library_Graph_Vertex;\n-         --  Reference to the library graph vertex where this vertex resides\n+         Spec_Vertex : Library_Graph_Vertex_Id := No_Library_Graph_Vertex;\n+         --  Reference to the library graph vertex where the spec of this\n+         --  vertex resides.\n       end record;\n \n       No_Invocation_Graph_Vertex_Attributes :\n         constant Invocation_Graph_Vertex_Attributes :=\n-          (Construct  => No_Invocation_Construct,\n-           Lib_Vertex => No_Library_Graph_Vertex);\n+          (Body_Vertex => No_Library_Graph_Vertex,\n+           Construct   => No_Invocation_Construct,\n+           Spec_Vertex => No_Library_Graph_Vertex);\n \n       procedure Destroy_Invocation_Graph_Vertex_Attributes\n         (Attrs : in out Invocation_Graph_Vertex_Attributes);\n       pragma Inline (Destroy_Invocation_Graph_Vertex_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package VA is new Dynamic_Hash_Tables\n+      package IGV_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Invocation_Graph_Vertex_Id,\n          Value_Type            => Invocation_Graph_Vertex_Attributes,\n          No_Value              => No_Invocation_Graph_Vertex_Attributes,\n@@ -399,9 +505,9 @@ package Bindo.Graphs is\n       -----------\n \n       procedure Destroy_Invocation_Graph_Edge\n-        (IGE_Id : in out Invocation_Graph_Edge_Id);\n+        (Edge : in out Invocation_Graph_Edge_Id);\n       pragma Inline (Destroy_Invocation_Graph_Edge);\n-      --  Destroy invocation graph edge IGE_Id\n+      --  Destroy invocation graph edge Edge\n \n       --  The following type represents the attributes of an invocation graph\n       --  edge.\n@@ -420,7 +526,7 @@ package Bindo.Graphs is\n       pragma Inline (Destroy_Invocation_Graph_Edge_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package EA is new Dynamic_Hash_Tables\n+      package IGE_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Invocation_Graph_Edge_Id,\n          Value_Type            => Invocation_Graph_Edge_Attributes,\n          No_Value              => No_Invocation_Graph_Edge_Attributes,\n@@ -457,7 +563,7 @@ package Bindo.Graphs is\n       pragma Inline (Hash_Source_Target_Relation);\n       --  Obtain the hash value of key Rel\n \n-      package ST is new Membership_Sets\n+      package Relation_Sets is new Membership_Sets\n         (Element_Type => Source_Target_Relation,\n          \"=\"          => \"=\",\n          Hash         => Hash_Source_Target_Relation);\n@@ -477,7 +583,7 @@ package Bindo.Graphs is\n       pragma Inline (Hash_Invocation_Signature);\n       --  Obtain the hash value of key IS_Id\n \n-      package SV is new Dynamic_Hash_Tables\n+      package Signature_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Invocation_Signature_Id,\n          Value_Type            => Invocation_Graph_Vertex_Id,\n          No_Value              => No_Invocation_Graph_Vertex,\n@@ -493,7 +599,7 @@ package Bindo.Graphs is\n       -- Elaboration roots --\n       -----------------------\n \n-      package ER is new Membership_Sets\n+      package IGV_Sets is new Membership_Sets\n         (Element_Type => Invocation_Graph_Vertex_Id,\n          \"=\"          => \"=\",\n          Hash         => Hash_Invocation_Graph_Vertex);\n@@ -518,24 +624,25 @@ package Bindo.Graphs is\n          Counts : Invocation_Graph_Edge_Counts := (others => 0);\n          --  Edge statistics\n \n-         Edge_Attributes : EA.Dynamic_Hash_Table := EA.Nil;\n+         Edge_Attributes : IGE_Tables.Dynamic_Hash_Table := IGE_Tables.Nil;\n          --  The map of edge -> edge attributes for all edges in the graph\n \n          Graph : DG.Directed_Graph := DG.Nil;\n          --  The underlying graph describing the relations between edges and\n          --  vertices.\n \n-         Relations : ST.Membership_Set := ST.Nil;\n+         Relations : Relation_Sets.Membership_Set := Relation_Sets.Nil;\n          --  The set of relations between source and targets, used to prevent\n          --  duplicate edges in the graph.\n \n-         Roots : ER.Membership_Set := ER.Nil;\n+         Roots : IGV_Sets.Membership_Set := IGV_Sets.Nil;\n          --  The set of elaboration root vertices\n \n-         Signature_To_Vertex : SV.Dynamic_Hash_Table := SV.Nil;\n+         Signature_To_Vertex : Signature_Tables.Dynamic_Hash_Table :=\n+                                 Signature_Tables.Nil;\n          --  The map of signature -> vertex\n \n-         Vertex_Attributes : VA.Dynamic_Hash_Table := VA.Nil;\n+         Vertex_Attributes : IGV_Tables.Dynamic_Hash_Table := IGV_Tables.Nil;\n          --  The map of vertex -> vertex attributes for all vertices in the\n          --  graph.\n       end record;\n@@ -550,7 +657,7 @@ package Bindo.Graphs is\n       type All_Edge_Iterator         is new DG.All_Edge_Iterator;\n       type All_Vertex_Iterator       is new DG.All_Vertex_Iterator;\n       type Edges_To_Targets_Iterator is new DG.Outgoing_Edge_Iterator;\n-      type Elaboration_Root_Iterator is new ER.Iterator;\n+      type Elaboration_Root_Iterator is new IGV_Sets.Iterator;\n    end Invocation_Graphs;\n \n    --------------------\n@@ -559,6 +666,32 @@ package Bindo.Graphs is\n \n    package Library_Graphs is\n \n+      --  The following type represents the various kinds of library graph\n+      --  cycles. The ordering of kinds is significant, where a literal with\n+      --  lower ordinal has a higner precedence than one with higher ordinal.\n+\n+      type Library_Graph_Cycle_Kind is\n+        (Elaborate_Body_Cycle,\n+         --  A cycle that involves at least one spec-body pair, where the\n+         --  spec is subject to pragma Elaborate_Body. This is the highest\n+         --  precedence cycle.\n+\n+         Elaborate_Cycle,\n+         --  A cycle that involves at least one Elaborate edge\n+\n+         Elaborate_All_Cycle,\n+         --  A cycle that involves at least one Elaborate_All edge\n+\n+         Forced_Cycle,\n+         --  A cycle that involves at least one edge which is a byproduct of\n+         --  the forced-elaboration-order file.\n+\n+         Invocation_Cycle,\n+         --  A cycle that involves at least one invocation edge. This is the\n+         --  lowest precedence cycle.\n+\n+         No_Cycle_Kind);\n+\n       --  The following type represents the various kinds of library edges\n \n       type Library_Graph_Edge_Kind is\n@@ -620,11 +753,13 @@ package Bindo.Graphs is\n       --  describes.\n \n       function Create\n-        (Initial_Vertices : Positive;\n-         Initial_Edges    : Positive) return Library_Graph;\n+        (Initial_Vertices       : Positive;\n+         Initial_Edges          : Positive;\n+         Dynamically_Elaborated : Boolean) return Library_Graph;\n       pragma Inline (Create);\n       --  Create a new empty graph with vertex capacity Initial_Vertices and\n-      --  edge capacity Initial_Edges.\n+      --  edge capacity Initial_Edges. Flag Dynamically_Elaborated must be set\n+      --  when the main library unit was compiled using the dynamic model.\n \n       procedure Destroy (G : in out Library_Graph);\n       pragma Inline (Destroy);\n@@ -634,6 +769,16 @@ package Bindo.Graphs is\n       pragma Inline (Find_Components);\n       --  Find all components in library graph G\n \n+      procedure Find_Cycles (G : Library_Graph);\n+      pragma Inline (Find_Cycles);\n+      --  Find all cycles in library graph G\n+\n+      function Highest_Precedence_Cycle\n+        (G : Library_Graph) return Library_Graph_Cycle_Id;\n+      pragma Inline (Highest_Precedence_Cycle);\n+      --  Obtain the cycle with highest precedence among all other cycles of\n+      --  library graph G.\n+\n       function Present (G : Library_Graph) return Boolean;\n       pragma Inline (Present);\n       --  Determine whether library graph G exists\n@@ -644,16 +789,16 @@ package Bindo.Graphs is\n \n       function Component\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Component_Id;\n+         Vertex : Library_Graph_Vertex_Id) return Component_Id;\n       pragma Inline (Component);\n-      --  Obtain the component where vertex LGV_Id of library graph G resides\n+      --  Obtain the component where vertex Vertex of library graph G resides\n \n       function Corresponding_Item\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n       pragma Inline (Corresponding_Item);\n       --  Obtain the complementary vertex which represents the corresponding\n-      --  spec or body of vertex LGV_Id of library graph G.\n+      --  spec or body of vertex Vertex of library graph G.\n \n       function Corresponding_Vertex\n         (G    : Library_Graph;\n@@ -664,75 +809,91 @@ package Bindo.Graphs is\n \n       procedure Decrement_Pending_Predecessors\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id);\n+         Vertex : Library_Graph_Vertex_Id);\n       pragma Inline (Decrement_Pending_Predecessors);\n-      --  Decrease the number of pending predecessors vertex LGV_Id of library\n+      --  Decrease the number of pending predecessors vertex Vertex of library\n       --  graph G must wait on until it can be elaborated.\n \n+      function File_Name\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return File_Name_Type;\n+      pragma Inline (File_Name);\n+      --  Obtain the name of the file where vertex Vertex of library graph G\n+      --  resides.\n+\n       function In_Elaboration_Order\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (In_Elaboration_Order);\n-      --  Determine whether vertex LGV_Id of library graph G is already in some\n+      --  Determine whether vertex Vertex of library graph G is already in some\n       --  elaboration order.\n \n+      function Invocation_Graph_Encoding\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id)\n+         return Invocation_Graph_Encoding_Kind;\n+      pragma Inline (Invocation_Graph_Encoding);\n+      --  Obtain the encoding format used to capture information related to\n+      --  invocation vertices and edges that reside within vertex Vertex of\n+      --  library graph G.\n+\n       function Name\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Unit_Name_Type;\n+         Vertex : Library_Graph_Vertex_Id) return Unit_Name_Type;\n       pragma Inline (Name);\n-      --  Obtain the name of the unit which vertex LGV_Id of library graph G\n+      --  Obtain the name of the unit which vertex Vertex of library graph G\n       --  represents.\n \n       function Pending_Predecessors\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Natural;\n+         Vertex : Library_Graph_Vertex_Id) return Natural;\n       pragma Inline (Pending_Predecessors);\n-      --  Obtain the number of pending predecessors vertex LGV_Id of library\n+      --  Obtain the number of pending predecessors vertex Vertex of library\n       --  graph G must wait on until it can be elaborated.\n \n       procedure Set_Corresponding_Item\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n          Val    : Library_Graph_Vertex_Id);\n       pragma Inline (Set_Corresponding_Item);\n       --  Set the complementary vertex which represents the corresponding\n-      --  spec or body of vertex LGV_Id of library graph G to value Val.\n+      --  spec or body of vertex Vertex of library graph G to value Val.\n \n       procedure Set_In_Elaboration_Order\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n          Val    : Boolean := True);\n       pragma Inline (Set_In_Elaboration_Order);\n-      --  Mark vertex LGV_Id of library graph G as included in some elaboration\n+      --  Mark vertex Vertex of library graph G as included in some elaboration\n       --  order depending on value Val.\n \n       function Unit\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Unit_Id;\n+         Vertex : Library_Graph_Vertex_Id) return Unit_Id;\n       pragma Inline (Unit);\n-      --  Obtain the unit vertex LGV_Id of library graph G represents\n+      --  Obtain the unit vertex Vertex of library graph G represents\n \n       ---------------------\n       -- Edge attributes --\n       ---------------------\n \n       function Kind\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Edge_Kind;\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Library_Graph_Edge_Kind;\n       pragma Inline (Kind);\n-      --  Obtain the nature of edge LGE_Id of library graph G\n+      --  Obtain the nature of edge Edge of library graph G\n \n       function Predecessor\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id;\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id;\n       pragma Inline (Predecessor);\n-      --  Obtain the predecessor vertex of edge LGE_Id of library graph G\n+      --  Obtain the predecessor vertex of edge Edge of library graph G\n \n       function Successor\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id;\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id;\n       pragma Inline (Successor);\n-      --  Obtain the successor vertex of edge LGE_Id of library graph G\n+      --  Obtain the successor vertex of edge Edge of library graph G\n \n       --------------------------\n       -- Component attributes --\n@@ -752,30 +913,71 @@ package Bindo.Graphs is\n       --  Obtain the number of pending predecessors component Comp of library\n       --  graph G must wait on until it can be elaborated.\n \n+      ----------------------\n+      -- Cycle attributes --\n+      ----------------------\n+\n+      function Invocation_Edge_Count\n+        (G      : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id) return Natural;\n+      pragma Inline (Invocation_Edge_Count);\n+      --  Obtain the number of invocation edges in cycle Cycle of library\n+      --  graph G.\n+\n+      function Kind\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id) return Library_Graph_Cycle_Kind;\n+      pragma Inline (Kind);\n+      --  Obtain the nature of cycle Cycle of library graph G\n+\n+      function Length\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id) return Natural;\n+      pragma Inline (Length);\n+      --  Obtain the length of cycle Cycle of library graph G\n+\n       ---------------\n       -- Semantics --\n       ---------------\n \n+      function Has_Elaborate_All_Cycle (G : Library_Graph) return Boolean;\n+      pragma Inline (Has_Elaborate_All_Cycle);\n+      --  Determine whether library graph G contains a cycle involving pragma\n+      --  Elaborate_All.\n+\n+      function In_Same_Component\n+        (G     : Library_Graph;\n+         Left  : Library_Graph_Vertex_Id;\n+         Right : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (In_Same_Component);\n+      --  Determine whether vertices Left and Right of library graph G reside\n+      --  in the same component.\n+\n       function Is_Body\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Body);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a body\n+      --  Determine whether vertex Vertex of library graph G denotes a body\n \n       function Is_Body_Of_Spec_With_Elaborate_Body\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Body_Of_Spec_With_Elaborate_Body);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a body\n+      --  Determine whether vertex Vertex of library graph G denotes a body\n       --  with a corresponding spec, and the spec has pragma Elaborate_Body.\n \n       function Is_Body_With_Spec\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Body_With_Spec);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a body\n+      --  Determine whether vertex Vertex of library graph G denotes a body\n       --  with a corresponding spec.\n \n+      function Is_Dynamically_Elaborated (G : Library_Graph) return Boolean;\n+      pragma Inline (Is_Dynamically_Elaborated);\n+      --  Determine whether library graph G was created from a set of units\n+      --  where the main library unit was compiled using the dynamic model.\n+\n       function Is_Elaborable_Component\n         (G    : Library_Graph;\n          Comp : Component_Id) return Boolean;\n@@ -784,76 +986,112 @@ package Bindo.Graphs is\n \n       function Is_Elaborable_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Elaborable_Vertex);\n-      --  Determine whether vertex LGV_Id of library graph G can be elaborated\n+      --  Determine whether vertex Vertex of library graph G can be elaborated\n+\n+      function Is_Elaborate_All_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Boolean;\n+      pragma Inline (Is_Elaborate_All_Edge);\n+      --  Determine whether edge Edge of library graph G is an edge whose\n+      --  predecessor is subject to pragma Elaborate_All.\n+\n+      function Is_Elaborate_Body_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Boolean;\n+      pragma Inline (Is_Elaborate_Body_Edge);\n+      --  Determine whether edge Edge of library graph G has a successor\n+      --  that is either a spec subject to pragma Elaborate_Body, or a body\n+      --  that completes such a spec.\n+\n+      function Is_Elaborate_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Boolean;\n+      pragma Inline (Is_Elaborate_Edge);\n+      --  Determine whether edge Edge of library graph G is an edge whose\n+      --  predecessor is subject to pragma Elaborate.\n+\n+      function Is_Forced_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Boolean;\n+      pragma Inline (Is_Forced_Edge);\n+      --  Determine whether edge Edge of library graph G is a byproduct of the\n+      --  forced-elaboration-order file.\n \n       function Is_Internal_Unit\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Internal_Unit);\n-      --  Determine whether vertex LGV_Id of library graph G denotes an\n+      --  Determine whether vertex Vertex of library graph G denotes an\n       --  internal unit.\n \n+      function Is_Invocation_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Boolean;\n+      pragma Inline (Is_Invocation_Edge);\n+      --  Determine whether edge Edge of library graph G came from the\n+      --  traversal of the invocation graph.\n+\n       function Is_Predefined_Unit\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Predefined_Unit);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a\n+      --  Determine whether vertex Vertex of library graph G denotes a\n       --  predefined unit.\n \n       function Is_Preelaborated_Unit\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Preelaborated_Unit);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a unit\n+      --  Determine whether vertex Vertex of library graph G denotes a unit\n       --  subjec to pragma Pure or Preelaborable.\n \n       function Is_Spec\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Spec);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a spec\n+      --  Determine whether vertex Vertex of library graph G denotes a spec\n \n       function Is_Spec_With_Body\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Spec_With_Body);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a spec\n+      --  Determine whether vertex Vertex of library graph G denotes a spec\n       --  with a corresponding body.\n \n       function Is_Spec_With_Elaborate_Body\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Spec_With_Elaborate_Body);\n-      --  Determine whether vertex LGV_Id of library graph G denotes a spec\n+      --  Determine whether vertex Vertex of library graph G denotes a spec\n       --  with a corresponding body, and is subject to pragma Elaborate_Body.\n \n-      function Links_Vertices_In_Same_Component\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id) return Boolean;\n-      pragma Inline (Links_Vertices_In_Same_Component);\n-      --  Determine whether edge LGE_Id of library graph G links a predecessor\n-      --  and a successor that reside within the same component.\n+      function Is_With_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) return Boolean;\n+      pragma Inline (Is_With_Edge);\n+      --  Determine whether edge Edge of library graph G is the result of a\n+      --  with dependency between its successor and predecessor.\n \n       function Needs_Elaboration\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Needs_Elaboration);\n-      --  Determine whether vertex LGV_Id of library graph G represents a unit\n+      --  Determine whether vertex Vertex of library graph G represents a unit\n       --  that needs to be elaborated.\n \n       function Proper_Body\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n       pragma Inline (Proper_Body);\n-      --  Obtain the body of vertex LGV_Id of library graph G\n+      --  Obtain the body of vertex Vertex of library graph G\n \n       function Proper_Spec\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n       pragma Inline (Proper_Spec);\n-      --  Obtain the spec of vertex LGV_Id of library graph G\n+      --  Obtain the spec of vertex Vertex of library graph G\n \n       ----------------\n       -- Statistics --\n@@ -876,15 +1114,19 @@ package Bindo.Graphs is\n       pragma Inline (Number_Of_Components);\n       --  Obtain the total number of components in library graph G\n \n+      function Number_Of_Cycles (G : Library_Graph) return Natural;\n+      pragma Inline (Number_Of_Cycles);\n+      --  Obtain the total number of cycles in library graph G\n+\n       function Number_Of_Edges (G : Library_Graph) return Natural;\n       pragma Inline (Number_Of_Edges);\n       --  Obtain the total number of edges in library graph G\n \n       function Number_Of_Edges_To_Successors\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Natural;\n+         Vertex : Library_Graph_Vertex_Id) return Natural;\n       pragma Inline (Number_Of_Edges_To_Successors);\n-      --  Obtain the total number of edges to successors vertex LGV_Id of\n+      --  Obtain the total number of edges to successors vertex Vertex of\n       --  library graph G has.\n \n       function Number_Of_Vertices (G : Library_Graph) return Natural;\n@@ -895,6 +1137,27 @@ package Bindo.Graphs is\n       -- Iterators --\n       ---------------\n \n+      --  The following type represents an iterator over all cycles of a\n+      --  library graph.\n+\n+      type All_Cycle_Iterator is private;\n+\n+      function Has_Next (Iter : All_Cycle_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more cycles to examine\n+\n+      function Iterate_All_Cycles\n+        (G : Library_Graph) return All_Cycle_Iterator;\n+      pragma Inline (Iterate_All_Cycles);\n+      --  Obtain an iterator over all cycles of library graph G\n+\n+      procedure Next\n+        (Iter  : in out All_Cycle_Iterator;\n+         Cycle : out Library_Graph_Cycle_Id);\n+      pragma Inline (Next);\n+      --  Return the current cycle referenced by iterator Iter and advance to\n+      --  the next available cycle.\n+\n       --  The following type represents an iterator over all edges of a library\n       --  graph.\n \n@@ -909,8 +1172,8 @@ package Bindo.Graphs is\n       --  Obtain an iterator over all edges of library graph G\n \n       procedure Next\n-        (Iter   : in out All_Edge_Iterator;\n-         LGE_Id : out Library_Graph_Edge_Id);\n+        (Iter : in out All_Edge_Iterator;\n+         Edge : out Library_Graph_Edge_Id);\n       pragma Inline (Next);\n       --  Return the current edge referenced by iterator Iter and advance to\n       --  the next available edge.\n@@ -931,7 +1194,7 @@ package Bindo.Graphs is\n \n       procedure Next\n         (Iter   : in out All_Vertex_Iterator;\n-         LGV_Id : out Library_Graph_Vertex_Id);\n+         Vertex : out Library_Graph_Vertex_Id);\n       pragma Inline (Next);\n       --  Return the current vertex referenced by iterator Iter and advance\n       --  to the next available vertex.\n@@ -975,11 +1238,34 @@ package Bindo.Graphs is\n \n       procedure Next\n         (Iter   : in out Component_Vertex_Iterator;\n-         LGV_Id : out Library_Graph_Vertex_Id);\n+         Vertex : out Library_Graph_Vertex_Id);\n       pragma Inline (Next);\n       --  Return the current vertex referenced by iterator Iter and advance\n       --  to the next available vertex.\n \n+      --  The following type represents an iterator over all edges that form a\n+      --  cycle.\n+\n+      type Edges_Of_Cycle_Iterator is private;\n+\n+      function Has_Next (Iter : Edges_Of_Cycle_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more edges to examine\n+\n+      function Iterate_Edges_Of_Cycle\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id) return Edges_Of_Cycle_Iterator;\n+      pragma Inline (Iterate_Edges_Of_Cycle);\n+      --  Obtain an iterator over all edges that form cycle Cycle of library\n+      --  graph G.\n+\n+      procedure Next\n+        (Iter : in out Edges_Of_Cycle_Iterator;\n+         Edge : out Library_Graph_Edge_Id);\n+      pragma Inline (Next);\n+      --  Return the current edge referenced by iterator Iter and advance to\n+      --  the next available edge.\n+\n       --  The following type represents an iterator over all edges that reach\n       --  successors starting from a particular predecessor vertex.\n \n@@ -991,14 +1277,14 @@ package Bindo.Graphs is\n \n       function Iterate_Edges_To_Successors\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) return Edges_To_Successors_Iterator;\n+         Vertex : Library_Graph_Vertex_Id) return Edges_To_Successors_Iterator;\n       pragma Inline (Iterate_Components);\n       --  Obtain an iterator over all edges to successors with predecessor\n-      --  vertex LGV_Id of library graph G.\n+      --  vertex Vertex of library graph G.\n \n       procedure Next\n-        (Iter   : in out Edges_To_Successors_Iterator;\n-         LGE_Id : out Library_Graph_Edge_Id);\n+        (Iter : in out Edges_To_Successors_Iterator;\n+         Edge : out Library_Graph_Edge_Id);\n       pragma Inline (Next);\n       --  Return the current edge referenced by iterator Iter and advance to\n       --  the next available edge.\n@@ -1010,9 +1296,9 @@ package Bindo.Graphs is\n       --------------\n \n       procedure Destroy_Library_Graph_Vertex\n-        (LGV_Id : in out Library_Graph_Vertex_Id);\n+        (Vertex : in out Library_Graph_Vertex_Id);\n       pragma Inline (Destroy_Library_Graph_Vertex);\n-      --  Destroy library graph vertex LGV_Id\n+      --  Destroy library graph vertex Vertex\n \n       --  The following type represents the attributes of a library graph\n       --  vertex.\n@@ -1054,7 +1340,7 @@ package Bindo.Graphs is\n       pragma Inline (Destroy_Library_Graph_Vertex_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package VA is new Dynamic_Hash_Tables\n+      package LGV_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Library_Graph_Vertex_Id,\n          Value_Type            => Library_Graph_Vertex_Attributes,\n          No_Value              => No_Library_Graph_Vertex_Attributes,\n@@ -1070,11 +1356,6 @@ package Bindo.Graphs is\n       -- Edges --\n       -----------\n \n-      procedure Destroy_Library_Graph_Edge\n-        (LGE_Id : in out Library_Graph_Edge_Id);\n-      pragma Inline (Destroy_Library_Graph_Edge);\n-      --  Destroy library graph edge LGE_Id\n-\n       --  The following type represents the attributes of a library graph edge\n \n       type Library_Graph_Edge_Attributes is record\n@@ -1091,7 +1372,7 @@ package Bindo.Graphs is\n       pragma Inline (Destroy_Library_Graph_Edge_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package EA is new Dynamic_Hash_Tables\n+      package LGE_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Library_Graph_Edge_Id,\n          Value_Type            => Library_Graph_Edge_Attributes,\n          No_Value              => No_Library_Graph_Edge_Attributes,\n@@ -1123,7 +1404,7 @@ package Bindo.Graphs is\n       pragma Inline (Destroy_Component_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package CA is new Dynamic_Hash_Tables\n+      package Component_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Component_Id,\n          Value_Type            => Component_Attributes,\n          No_Value              => No_Component_Attributes,\n@@ -1135,9 +1416,69 @@ package Bindo.Graphs is\n          Destroy_Value         => Destroy_Component_Attributes,\n          Hash                  => Hash_Component);\n \n-      ---------------\n-      -- Relations --\n-      ---------------\n+      ------------\n+      -- Cycles --\n+      ------------\n+\n+      --  The following type represents the attributes of a cycle\n+\n+      type Library_Graph_Cycle_Attributes is record\n+         Invocation_Edge_Count : Natural := 0;\n+         --  The number of invocation edges within the cycle\n+\n+         Kind : Library_Graph_Cycle_Kind := No_Cycle_Kind;\n+         --  The nature of the cycle\n+\n+         Path : LGE_Lists.Doubly_Linked_List := LGE_Lists.Nil;\n+         --  The path of edges that form the cycle\n+      end record;\n+\n+      No_Library_Graph_Cycle_Attributes :\n+        constant Library_Graph_Cycle_Attributes :=\n+          (Invocation_Edge_Count => 0,\n+           Kind                  => No_Cycle_Kind,\n+           Path                  => LGE_Lists.Nil);\n+\n+      procedure Destroy_Library_Graph_Cycle_Attributes\n+        (Attrs : in out Library_Graph_Cycle_Attributes);\n+      pragma Inline (Destroy_Library_Graph_Cycle_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      function Hash_Library_Graph_Cycle_Attributes\n+        (Attrs : Library_Graph_Cycle_Attributes) return Bucket_Range_Type;\n+      pragma Inline (Hash_Library_Graph_Cycle_Attributes);\n+      --  Obtain the hash of key Attrs\n+\n+      function Same_Library_Graph_Cycle_Attributes\n+        (Left  : Library_Graph_Cycle_Attributes;\n+         Right : Library_Graph_Cycle_Attributes) return Boolean;\n+      pragma Inline (Same_Library_Graph_Cycle_Attributes);\n+      --  Determine whether cycle attributes Left and Right are the same\n+\n+      package LGC_Tables is new Dynamic_Hash_Tables\n+        (Key_Type              => Library_Graph_Cycle_Id,\n+         Value_Type            => Library_Graph_Cycle_Attributes,\n+         No_Value              => No_Library_Graph_Cycle_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Library_Graph_Cycle_Attributes,\n+         Hash                  => Hash_Library_Graph_Cycle);\n+\n+      ---------------------\n+      -- Recorded cycles --\n+      ---------------------\n+\n+      package RC_Sets is new Membership_Sets\n+        (Element_Type => Library_Graph_Cycle_Attributes,\n+         \"=\"          => Same_Library_Graph_Cycle_Attributes,\n+         Hash         => Hash_Library_Graph_Cycle_Attributes);\n+\n+      --------------------\n+      -- Recorded edges --\n+      --------------------\n \n       --  The following type represents a relation between a predecessor and\n       --  successor vertices.\n@@ -1160,7 +1501,7 @@ package Bindo.Graphs is\n       pragma Inline (Hash_Predecessor_Successor_Relation);\n       --  Obtain the hash value of key Rel\n \n-      package PS is new Membership_Sets\n+      package RE_Sets is new Membership_Sets\n         (Element_Type => Predecessor_Successor_Relation,\n          \"=\"          => \"=\",\n          Hash         => Hash_Predecessor_Successor_Relation);\n@@ -1176,7 +1517,7 @@ package Bindo.Graphs is\n       -- Units --\n       -----------\n \n-      package UV is new Dynamic_Hash_Tables\n+      package Unit_Tables is new Dynamic_Hash_Tables\n         (Key_Type              => Unit_Id,\n          Value_Type            => Library_Graph_Vertex_Id,\n          No_Value              => No_Library_Graph_Vertex,\n@@ -1205,28 +1546,43 @@ package Bindo.Graphs is\n       --  The following type represents the attributes of a library graph\n \n       type Library_Graph_Attributes is record\n-         Component_Attributes : CA.Dynamic_Hash_Table := CA.Nil;\n+         Component_Attributes : Component_Tables.Dynamic_Hash_Table :=\n+                                  Component_Tables.Nil;\n          --  The map of component -> component attributes for all components in\n          --  the graph.\n \n          Counts : Library_Graph_Edge_Counts := (others => 0);\n          --  Edge statistics\n \n-         Edge_Attributes : EA.Dynamic_Hash_Table := EA.Nil;\n+         Cycle_Attributes : LGC_Tables.Dynamic_Hash_Table := LGC_Tables.Nil;\n+         --  The map of cycle -> cycle attributes for all cycles in the graph\n+\n+         Cycles : LGC_Lists.Doubly_Linked_List := LGC_Lists.Nil;\n+         --  The list of all cycles in the graph, sorted based on precedence\n+\n+         Dynamically_Elaborated : Boolean := False;\n+         --  Set when the main library unit was compiled using the dynamic\n+         --  model.\n+\n+         Edge_Attributes : LGE_Tables.Dynamic_Hash_Table := LGE_Tables.Nil;\n          --  The map of edge -> edge attributes for all edges in the graph\n \n          Graph : DG.Directed_Graph := DG.Nil;\n          --  The underlying graph describing the relations between edges and\n          --  vertices.\n \n-         Relations : PS.Membership_Set := PS.Nil;\n-         --  The set of relations between successors and predecessors, used to\n-         --  prevent duplicate edges in the graph.\n+         Recorded_Cycles : RC_Sets.Membership_Set := RC_Sets.Nil;\n+         --  The set of recorded cycles, used to prevent duplicate cycles in\n+         --  the graph.\n+\n+         Recorded_Edges : RE_Sets.Membership_Set := RE_Sets.Nil;\n+         --  The set of recorded edges, used to prevent duplicate edges in the\n+         --  graph.\n \n-         Unit_To_Vertex : UV.Dynamic_Hash_Table := UV.Nil;\n+         Unit_To_Vertex : Unit_Tables.Dynamic_Hash_Table := Unit_Tables.Nil;\n          --  The map of unit -> vertex\n \n-         Vertex_Attributes : VA.Dynamic_Hash_Table := VA.Nil;\n+         Vertex_Attributes : LGV_Tables.Dynamic_Hash_Table := LGV_Tables.Nil;\n          --  The map of vertex -> vertex attributes for all vertices in the\n          --  graph.\n       end record;\n@@ -1238,10 +1594,12 @@ package Bindo.Graphs is\n       -- Iterators --\n       ---------------\n \n+      type All_Cycle_Iterator           is new LGC_Lists.Iterator;\n       type All_Edge_Iterator            is new DG.All_Edge_Iterator;\n       type All_Vertex_Iterator          is new DG.All_Vertex_Iterator;\n       type Component_Iterator           is new DG.Component_Iterator;\n       type Component_Vertex_Iterator    is new DG.Component_Vertex_Iterator;\n+      type Edges_Of_Cycle_Iterator      is new LGE_Lists.Iterator;\n       type Edges_To_Successors_Iterator is new DG.Outgoing_Edge_Iterator;\n    end Library_Graphs;\n "}, {"sha": "d2501e062fe1319d6f06cd342d8baee920684623", "filename": "gcc/ada/bindo-units.adb", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-units.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-units.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-units.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -29,7 +29,7 @@ package body Bindo.Units is\n    -- Signature set --\n    -------------------\n \n-   package SS is new Membership_Sets\n+   package Signature_Sets is new Membership_Sets\n      (Element_Type => Invocation_Signature_Id,\n       \"=\"          => \"=\",\n       Hash         => Hash_Invocation_Signature);\n@@ -41,11 +41,13 @@ package body Bindo.Units is\n    --  The following set stores all invocation signatures that appear in\n    --  elaborable units.\n \n-   Elaborable_Constructs : SS.Membership_Set := SS.Nil;\n+   Elaborable_Constructs : Signature_Sets.Membership_Set := Signature_Sets.Nil;\n \n    --  The following set stores all units the need to be elaborated\n \n-   Elaborable_Units : US.Membership_Set := US.Nil;\n+   --  Kirchev\n+\n+   Elaborable_Units : Unit_Sets.Membership_Set := Unit_Sets.Nil;\n \n    -----------------------\n    -- Local subprograms --\n@@ -139,14 +141,27 @@ package body Bindo.Units is\n       return Corresponding_Unit (Name_Id (UNam));\n    end Corresponding_Unit;\n \n+   ---------------\n+   -- File_Name --\n+   ---------------\n+\n+   function File_Name (U_Id : Unit_Id) return File_Name_Type is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      return U_Rec.Sfile;\n+   end File_Name;\n+\n    --------------------\n    -- Finalize_Units --\n    --------------------\n \n    procedure Finalize_Units is\n    begin\n-      SS.Destroy (Elaborable_Constructs);\n-      US.Destroy (Elaborable_Units);\n+      Signature_Sets.Destroy (Elaborable_Constructs);\n+      Unit_Sets.Destroy      (Elaborable_Units);\n    end Finalize_Units;\n \n    ------------------------------\n@@ -183,7 +198,7 @@ package body Bindo.Units is\n \n    function Has_Next (Iter : Elaborable_Units_Iterator) return Boolean is\n    begin\n-      return US.Has_Next (US.Iterator (Iter));\n+      return Unit_Sets.Has_Next (Unit_Sets.Iterator (Iter));\n    end Has_Next;\n \n    -------------------------------\n@@ -216,10 +231,25 @@ package body Bindo.Units is\n \n    procedure Initialize_Units is\n    begin\n-      Elaborable_Constructs := SS.Create (Number_Of_Units);\n-      Elaborable_Units      := US.Create (Number_Of_Units);\n+      Elaborable_Constructs := Signature_Sets.Create (Number_Of_Units);\n+      Elaborable_Units      := Unit_Sets.Create      (Number_Of_Units);\n    end Initialize_Units;\n \n+   -------------------------------\n+   -- Invocation_Graph_Encoding --\n+   -------------------------------\n+\n+   function Invocation_Graph_Encoding\n+     (U_Id : Unit_Id) return Invocation_Graph_Encoding_Kind\n+   is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      return U_Rec.Invocation_Graph_Encoding;\n+   end Invocation_Graph_Encoding;\n+\n    -------------------------------\n    -- Is_Dynamically_Elaborated --\n    -------------------------------\n@@ -278,7 +308,7 @@ package body Bindo.Units is\n \n    function Iterate_Elaborable_Units return Elaborable_Units_Iterator is\n    begin\n-      return Elaborable_Units_Iterator (US.Iterate (Elaborable_Units));\n+      return Elaborable_Units_Iterator (Unit_Sets.Iterate (Elaborable_Units));\n    end Iterate_Elaborable_Units;\n \n    ----------\n@@ -304,7 +334,7 @@ package body Bindo.Units is\n    begin\n       pragma Assert (Present (IS_Id));\n \n-      return SS.Contains (Elaborable_Constructs, IS_Id);\n+      return Signature_Sets.Contains (Elaborable_Constructs, IS_Id);\n    end Needs_Elaboration;\n \n    -----------------------\n@@ -315,7 +345,7 @@ package body Bindo.Units is\n    begin\n       pragma Assert (Present (U_Id));\n \n-      return US.Contains (Elaborable_Units, U_Id);\n+      return Unit_Sets.Contains (Elaborable_Units, U_Id);\n    end Needs_Elaboration;\n \n    ----------\n@@ -327,7 +357,7 @@ package body Bindo.Units is\n       U_Id : out Unit_Id)\n    is\n    begin\n-      US.Next (US.Iterator (Iter), U_Id);\n+      Unit_Sets.Next (Unit_Sets.Iterator (Iter), U_Id);\n    end Next;\n \n    --------------------------------\n@@ -336,7 +366,7 @@ package body Bindo.Units is\n \n    function Number_Of_Elaborable_Units return Natural is\n    begin\n-      return US.Size (Elaborable_Units);\n+      return Unit_Sets.Size (Elaborable_Units);\n    end Number_Of_Elaborable_Units;\n \n    ---------------------\n@@ -355,14 +385,12 @@ package body Bindo.Units is\n    procedure Process_Invocation_Construct (IC_Id : Invocation_Construct_Id) is\n       pragma Assert (Present (IC_Id));\n \n-      IC_Rec : Invocation_Construct_Record renames\n-                 Invocation_Constructs.Table (IC_Id);\n-      IC_Sig : constant Invocation_Signature_Id := IC_Rec.Signature;\n+      IS_Id : constant Invocation_Signature_Id := Signature (IC_Id);\n \n-      pragma Assert (Present (IC_Sig));\n+      pragma Assert (Present (IS_Id));\n \n    begin\n-      SS.Insert (Elaborable_Constructs, IC_Sig);\n+      Signature_Sets.Insert (Elaborable_Constructs, IS_Id);\n    end Process_Invocation_Construct;\n \n    -----------------------------------\n@@ -402,7 +430,7 @@ package body Bindo.Units is\n       --  signatures of constructs it declares.\n \n       else\n-         US.Insert (Elaborable_Units, U_Id);\n+         Unit_Sets.Insert (Elaborable_Units, U_Id);\n          Process_Invocation_Constructs (U_Id);\n       end if;\n    end Process_Unit;"}, {"sha": "37493935f0aed01565a147b58e271e25ba65708b", "filename": "gcc/ada/bindo-units.ads", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-units.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-units.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-units.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -33,6 +33,19 @@ with GNAT.Sets; use GNAT.Sets;\n \n package Bindo.Units is\n \n+   ---------------\n+   -- Unit sets --\n+   ---------------\n+\n+   function Hash_Unit (U_Id : Unit_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Unit);\n+   --  Obtain the hash value of key U_Id\n+\n+   package Unit_Sets is new Membership_Sets\n+     (Element_Type => Unit_Id,\n+      \"=\"          => \"=\",\n+      Hash         => Hash_Unit);\n+\n    procedure Collect_Elaborable_Units;\n    pragma Inline (Collect_Elaborable_Units);\n    --  Gather all units in the bind that require elaboration. The units are\n@@ -54,6 +67,10 @@ package Bindo.Units is\n    pragma Inline (Corresponding_Unit);\n    --  Obtain the unit which corresponds to name FNam\n \n+   function File_Name (U_Id : Unit_Id) return File_Name_Type;\n+   pragma Inline (File_Name);\n+   --  Obtain the file name of unit U_Id\n+\n    type Unit_Processor_Ptr is access procedure (U_Id : Unit_Id);\n \n    procedure For_Each_Elaborable_Unit (Processor : Unit_Processor_Ptr);\n@@ -69,9 +86,11 @@ package Bindo.Units is\n    pragma Inline (Hash_Invocation_Signature);\n    --  Obtain the hash value of key IS_Id\n \n-   function Hash_Unit (U_Id : Unit_Id) return Bucket_Range_Type;\n-   pragma Inline (Hash_Unit);\n-   --  Obtain the hash value of key U_Id\n+   function Invocation_Graph_Encoding\n+     (U_Id : Unit_Id) return Invocation_Graph_Encoding_Kind;\n+   pragma Inline (Invocation_Graph_Encoding);\n+   --  Obtain the encoding format used to capture invocation constructs and\n+   --  relations in the ALI file of unit U_Id.\n \n    function Is_Dynamically_Elaborated (U_Id : Unit_Id) return Boolean;\n    pragma Inline (Is_Dynamically_Elaborated);\n@@ -144,11 +163,6 @@ package Bindo.Units is\n    --  Initialize the internal structures of this unit\n \n private\n-   package US is new Membership_Sets\n-     (Element_Type => Unit_Id,\n-      \"=\"          => \"=\",\n-      Hash         => Hash_Unit);\n-\n-   type Elaborable_Units_Iterator is new US.Iterator;\n+   type Elaborable_Units_Iterator is new Unit_Sets.Iterator;\n \n end Bindo.Units;"}, {"sha": "aed496003699d88d5c05782358a3dd64e4404990", "filename": "gcc/ada/bindo-validators.adb", "status": "modified", "additions": 297, "deletions": 163, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-validators.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-validators.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-validators.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -29,30 +29,191 @@ with Types;  use Types;\n \n with Bindo.Units; use Bindo.Units;\n \n-with GNAT;      use GNAT;\n-with GNAT.Sets; use GNAT.Sets;\n-\n package body Bindo.Validators is\n \n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   procedure Write_Error\n+     (Msg  : String;\n+      Flag : out Boolean);\n+   pragma Inline (Write_Error);\n+   --  Write error message Msg to standard output and set flag Flag to True\n+\n+   ----------------------\n+   -- Cycle_Validators --\n+   ----------------------\n+\n+   package body Cycle_Validators is\n+      Has_Invalid_Cycle : Boolean := False;\n+      --  Flag set when the library graph contains an invalid cycle\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Validate_Cycle\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id);\n+      pragma Inline (Validate_Cycle);\n+      --  Ensure that a cycle meets the following requirements:\n+      --\n+      --    * Is of proper kind\n+      --    * Has enough edges to form a circuit\n+      --    * No edge is repeated\n+\n+      procedure Validate_Cycle_Path\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id);\n+      pragma Inline (Validate_Cycle_Path);\n+      --  Ensure that the path of a cycle meets the following requirements:\n+      --\n+      --    * No edge is repeated\n+\n+      --------------------\n+      -- Validate_Cycle --\n+      --------------------\n+\n+      procedure Validate_Cycle\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id)\n+      is\n+         Msg : constant String := \"Validate_Cycle\";\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         if not Present (Cycle) then\n+            Write_Error (Msg, Has_Invalid_Cycle);\n+\n+            Write_Str (\"  empty cycle\");\n+            Write_Eol;\n+            Write_Eol;\n+            return;\n+         end if;\n+\n+         if Kind (G, Cycle) = No_Cycle_Kind then\n+            Write_Error (Msg, Has_Invalid_Cycle);\n+\n+            Write_Str (\"  cycle (LGC_Id_\");\n+            Write_Int (Int (Cycle));\n+            Write_Str (\") is a No_Cycle\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         --  A cycle requires at least one edge (self cycle) to form a circuit\n+\n+         if Length (G, Cycle) < 1 then\n+            Write_Error (Msg, Has_Invalid_Cycle);\n+\n+            Write_Str (\"  cycle (LGC_Id_\");\n+            Write_Int (Int (Cycle));\n+            Write_Str (\") does not contain enough edges\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         Validate_Cycle_Path (G, Cycle);\n+      end Validate_Cycle;\n+\n+      -------------------------\n+      -- Validate_Cycle_Path --\n+      -------------------------\n+\n+      procedure Validate_Cycle_Path\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id)\n+      is\n+         Msg : constant String := \"Validate_Cycle_Path\";\n+\n+         Edge  : Library_Graph_Edge_Id;\n+         Edges : LGE_Sets.Membership_Set;\n+         Iter  : Edges_Of_Cycle_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Cycle));\n+\n+         --  Use a set to detect duplicate edges while traversing the cycle\n+\n+         Edges := LGE_Sets.Create (Length (G, Cycle));\n+\n+         --  Inspect the edges of the cucle, trying to catch duplicates\n+\n+         Iter := Iterate_Edges_Of_Cycle (G, Cycle);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Edge);\n+\n+            --  The current edge has already been encountered while traversing\n+            --  the cycle. This indicates that the cycle is malformed as edges\n+            --  are not repeated in the circuit.\n+\n+            if LGE_Sets.Contains (Edges, Edge) then\n+               Write_Error (Msg, Has_Invalid_Cycle);\n+\n+               Write_Str (\"  library graph edge (LGE_Id_\");\n+               Write_Int (Int (Edge));\n+               Write_Str (\") is repeaded in cycle (LGC_Id_\");\n+               Write_Int (Int (Cycle));\n+               Write_Str (\")\");\n+               Write_Eol;\n+\n+            --  Otherwise add the current edge to the set of encountered edges\n+\n+            else\n+               LGE_Sets.Insert (Edges, Edge);\n+            end if;\n+         end loop;\n+\n+         LGE_Sets.Destroy (Edges);\n+      end Validate_Cycle_Path;\n+\n+      ---------------------\n+      -- Validate_Cycles --\n+      ---------------------\n+\n+      procedure Validate_Cycles (G : Library_Graph) is\n+         Cycle : Library_Graph_Cycle_Id;\n+         Iter  : All_Cycle_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Nothing to do when switch -d_V (validate bindo cycles, graphs, and\n+         --  order) is not in effect.\n+\n+         if not Debug_Flag_Underscore_VV then\n+            return;\n+         end if;\n+\n+         Iter := Iterate_All_Cycles (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Cycle);\n+\n+            Validate_Cycle (G, Cycle);\n+         end loop;\n+\n+         if Has_Invalid_Cycle then\n+            raise Invalid_Cycle;\n+         end if;\n+      end Validate_Cycles;\n+   end Cycle_Validators;\n+\n    ----------------------------------\n    -- Elaboration_Order_Validators --\n    ----------------------------------\n \n    package body Elaboration_Order_Validators is\n-      package US is new Membership_Sets\n-        (Element_Type => Unit_Id,\n-         \"=\"          => \"=\",\n-         Hash         => Hash_Unit);\n-      use US;\n-\n       Has_Invalid_Data : Boolean := False;\n       --  Flag set when the elaboration order contains invalid data\n \n       -----------------------\n       -- Local subprograms --\n       -----------------------\n \n-      function Build_Elaborable_Unit_Set return Membership_Set;\n+      function Build_Elaborable_Unit_Set return Unit_Sets.Membership_Set;\n       pragma Inline (Build_Elaborable_Unit_Set);\n       --  Create a set from all units that need to be elaborated\n \n@@ -61,7 +222,7 @@ package body Bindo.Validators is\n       --  Emit an error concerning unit U_Id that must be elaborated, but was\n       --  not.\n \n-      procedure Report_Missing_Elaborations (Set : Membership_Set);\n+      procedure Report_Missing_Elaborations (Set : Unit_Sets.Membership_Set);\n       pragma Inline (Report_Missing_Elaborations);\n       --  Emit errors on all units in set Set that must be elaborated, but were\n       --  not.\n@@ -70,7 +231,9 @@ package body Bindo.Validators is\n       pragma Inline (Report_Spurious_Elaboration);\n       --  Emit an error concerning unit U_Id that is incorrectly elaborated\n \n-      procedure Validate_Unit (U_Id : Unit_Id; Elab_Set : Membership_Set);\n+      procedure Validate_Unit\n+        (U_Id     : Unit_Id;\n+         Elab_Set : Unit_Sets.Membership_Set);\n       pragma Inline (Validate_Unit);\n       --  Validate the elaboration status of unit U_Id. Elab_Set is the set of\n       --  all units that need to be elaborated.\n@@ -79,28 +242,22 @@ package body Bindo.Validators is\n       pragma Inline (Validate_Units);\n       --  Validate all units in elaboration order Order\n \n-      procedure Write_Error (Msg : String);\n-      pragma Inline (Write_Error);\n-      --  Write error message Msg to standard output and signal that the\n-      --  elaboration order is incorrect.\n-\n       -------------------------------\n       -- Build_Elaborable_Unit_Set --\n       -------------------------------\n \n-      function Build_Elaborable_Unit_Set return Membership_Set is\n+      function Build_Elaborable_Unit_Set return Unit_Sets.Membership_Set is\n          Iter : Elaborable_Units_Iterator;\n-         Set  : Membership_Set;\n+         Set  : Unit_Sets.Membership_Set;\n          U_Id : Unit_Id;\n \n       begin\n-         Set  := Create (Number_Of_Elaborable_Units);\n+         Set  := Unit_Sets.Create (Number_Of_Elaborable_Units);\n          Iter := Iterate_Elaborable_Units;\n          while Has_Next (Iter) loop\n             Next (Iter, U_Id);\n-            pragma Assert (Present (U_Id));\n \n-            Insert (Set, U_Id);\n+            Unit_Sets.Insert (Set, U_Id);\n          end loop;\n \n          return Set;\n@@ -115,7 +272,7 @@ package body Bindo.Validators is\n \n       begin\n          pragma Assert (Present (U_Id));\n-         Write_Error (Msg);\n+         Write_Error (Msg, Has_Invalid_Data);\n \n          Write_Str  (\"unit (U_Id_\");\n          Write_Int  (Int (U_Id));\n@@ -129,15 +286,14 @@ package body Bindo.Validators is\n       -- Report_Missing_Elaborations --\n       ---------------------------------\n \n-      procedure Report_Missing_Elaborations (Set : Membership_Set) is\n-         Iter : Iterator;\n+      procedure Report_Missing_Elaborations (Set : Unit_Sets.Membership_Set) is\n+         Iter : Unit_Sets.Iterator;\n          U_Id : Unit_Id;\n \n       begin\n-         Iter := Iterate (Set);\n-         while Has_Next (Iter) loop\n-            Next (Iter, U_Id);\n-            pragma Assert (Present (U_Id));\n+         Iter := Unit_Sets.Iterate (Set);\n+         while Unit_Sets.Has_Next (Iter) loop\n+            Unit_Sets.Next (Iter, U_Id);\n \n             Report_Missing_Elaboration (U_Id);\n          end loop;\n@@ -152,7 +308,7 @@ package body Bindo.Validators is\n \n       begin\n          pragma Assert (Present (U_Id));\n-         Write_Error (Msg);\n+         Write_Error (Msg, Has_Invalid_Data);\n \n          Write_Str  (\"unit (U_Id_\");\n          Write_Int  (Int (U_Id));\n@@ -167,8 +323,8 @@ package body Bindo.Validators is\n \n       procedure Validate_Elaboration_Order (Order : Unit_Id_Table) is\n       begin\n-         --  Nothing to do when switch -d_V (validate bindo graphs and order)\n-         --  is not in effect.\n+         --  Nothing to do when switch -d_V (validate bindo cycles, graphs, and\n+         --  order) is not in effect.\n \n          if not Debug_Flag_Underscore_VV then\n             return;\n@@ -185,15 +341,18 @@ package body Bindo.Validators is\n       -- Validate_Unit --\n       -------------------\n \n-      procedure Validate_Unit (U_Id : Unit_Id; Elab_Set : Membership_Set) is\n+      procedure Validate_Unit\n+        (U_Id     : Unit_Id;\n+         Elab_Set : Unit_Sets.Membership_Set)\n+      is\n       begin\n          pragma Assert (Present (U_Id));\n \n          --  The current unit in the elaboration order appears within the set\n          --  of units that require elaboration. Remove it from the set.\n \n-         if Contains (Elab_Set, U_Id) then\n-            Delete (Elab_Set, U_Id);\n+         if Unit_Sets.Contains (Elab_Set, U_Id) then\n+            Unit_Sets.Delete (Elab_Set, U_Id);\n \n          --  Otherwise the current unit in the elaboration order must not be\n          --  elaborated.\n@@ -208,7 +367,7 @@ package body Bindo.Validators is\n       --------------------\n \n       procedure Validate_Units (Order : Unit_Id_Table) is\n-         Elab_Set : Membership_Set;\n+         Elab_Set : Unit_Sets.Membership_Set;\n \n       begin\n          --  Collect all units in the compilation that need to be elaborated\n@@ -230,21 +389,8 @@ package body Bindo.Validators is\n          --  their elaboration.\n \n          Report_Missing_Elaborations (Elab_Set);\n-         Destroy (Elab_Set);\n+         Unit_Sets.Destroy (Elab_Set);\n       end Validate_Units;\n-\n-      -----------------\n-      -- Write_Error --\n-      -----------------\n-\n-      procedure Write_Error (Msg : String) is\n-      begin\n-         Has_Invalid_Data := True;\n-\n-         Write_Str (\"ERROR: \");\n-         Write_Str (Msg);\n-         Write_Eol;\n-      end Write_Error;\n    end Elaboration_Order_Validators;\n \n    ---------------------------------\n@@ -260,10 +406,10 @@ package body Bindo.Validators is\n       -----------------------\n \n       procedure Validate_Invocation_Graph_Edge\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id);\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id);\n       pragma Inline (Validate_Invocation_Graph_Edge);\n-      --  Verify that the attributes of edge IGE_Id of invocation graph G are\n+      --  Verify that the attributes of edge Edge of invocation graph G are\n       --  properly set.\n \n       procedure Validate_Invocation_Graph_Edges (G : Invocation_Graph);\n@@ -273,21 +419,16 @@ package body Bindo.Validators is\n \n       procedure Validate_Invocation_Graph_Vertex\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id);\n+         Vertex : Invocation_Graph_Vertex_Id);\n       pragma Inline (Validate_Invocation_Graph_Vertex);\n-      --  Verify that the attributes of vertex IGV_Id of inbocation graph G are\n+      --  Verify that the attributes of vertex Vertex of inbocation graph G are\n       --  properly set.\n \n       procedure Validate_Invocation_Graph_Vertices (G : Invocation_Graph);\n       pragma Inline (Validate_Invocation_Graph_Vertices);\n       --  Verify that the attributes of all vertices of invocation graph G are\n       --  properly set.\n \n-      procedure Write_Error (Msg : String);\n-      pragma Inline (Write_Error);\n-      --  Write error message Msg to standard output and signal that the\n-      --  invocation graph is incorrect.\n-\n       -------------------------------\n       -- Validate_Invocation_Graph --\n       -------------------------------\n@@ -296,8 +437,8 @@ package body Bindo.Validators is\n       begin\n          pragma Assert (Present (G));\n \n-         --  Nothing to do when switch -d_V (validate bindo graphs and order)\n-         --  is not in effect.\n+         --  Nothing to do when switch -d_V (validate bindo cycles, graphs, and\n+         --  order) is not in effect.\n \n          if not Debug_Flag_Underscore_VV then\n             return;\n@@ -316,38 +457,38 @@ package body Bindo.Validators is\n       ------------------------------------\n \n       procedure Validate_Invocation_Graph_Edge\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id)\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id)\n       is\n          Msg : constant String := \"Validate_Invocation_Graph_Edge\";\n \n       begin\n          pragma Assert (Present (G));\n \n-         if not Present (IGE_Id) then\n-            Write_Error (Msg);\n+         if not Present (Edge) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  emply invocation graph edge\");\n             Write_Eol;\n             Write_Eol;\n             return;\n          end if;\n \n-         if not Present (Relation (G, IGE_Id)) then\n-            Write_Error (Msg);\n+         if not Present (Relation (G, Edge)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  invocation graph edge (IGE_Id_\");\n-            Write_Int (Int (IGE_Id));\n+            Write_Int (Int (Edge));\n             Write_Str (\") lacks Relation\");\n             Write_Eol;\n             Write_Eol;\n          end if;\n \n-         if not Present (Target (G, IGE_Id)) then\n-            Write_Error (Msg);\n+         if not Present (Target (G, Edge)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  invocation graph edge (IGE_Id_\");\n-            Write_Int (Int (IGE_Id));\n+            Write_Int (Int (Edge));\n             Write_Str (\") lacks Target\");\n             Write_Eol;\n             Write_Eol;\n@@ -359,17 +500,17 @@ package body Bindo.Validators is\n       -------------------------------------\n \n       procedure Validate_Invocation_Graph_Edges (G : Invocation_Graph) is\n-         IGE_Id : Invocation_Graph_Edge_Id;\n-         Iter   : Invocation_Graphs.All_Edge_Iterator;\n+         Edge : Invocation_Graph_Edge_Id;\n+         Iter : Invocation_Graphs.All_Edge_Iterator;\n \n       begin\n          pragma Assert (Present (G));\n \n          Iter := Iterate_All_Edges (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, IGE_Id);\n+            Next (Iter, Edge);\n \n-            Validate_Invocation_Graph_Edge (G, IGE_Id);\n+            Validate_Invocation_Graph_Edge (G, Edge);\n          end loop;\n       end Validate_Invocation_Graph_Edges;\n \n@@ -379,38 +520,48 @@ package body Bindo.Validators is\n \n       procedure Validate_Invocation_Graph_Vertex\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id)\n+         Vertex : Invocation_Graph_Vertex_Id)\n       is\n          Msg : constant String := \"Validate_Invocation_Graph_Vertex\";\n \n       begin\n          pragma Assert (Present (G));\n \n-         if not Present (IGV_Id) then\n-            Write_Error (Msg);\n+         if not Present (Vertex) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  emply invocation graph vertex\");\n             Write_Eol;\n             Write_Eol;\n             return;\n          end if;\n \n-         if not Present (Construct (G, IGV_Id)) then\n-            Write_Error (Msg);\n+         if not Present (Body_Vertex (G, Vertex)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  invocation graph vertex (IGV_Id_\");\n-            Write_Int (Int (IGV_Id));\n+            Write_Int (Int (Vertex));\n+            Write_Str (\") lacks Body_Vertex\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         if not Present (Construct (G, Vertex)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n+\n+            Write_Str (\"  invocation graph vertex (IGV_Id_\");\n+            Write_Int (Int (Vertex));\n             Write_Str (\") lacks Construct\");\n             Write_Eol;\n             Write_Eol;\n          end if;\n \n-         if not Present (Lib_Vertex (G, IGV_Id)) then\n-            Write_Error (Msg);\n+         if not Present (Spec_Vertex (G, Vertex)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  invocation graph vertex (IGV_Id_\");\n-            Write_Int (Int (IGV_Id));\n-            Write_Str (\") lacks Lib_Vertex\");\n+            Write_Int (Int (Vertex));\n+            Write_Str (\") lacks Spec_Vertex\");\n             Write_Eol;\n             Write_Eol;\n          end if;\n@@ -421,32 +572,19 @@ package body Bindo.Validators is\n       ----------------------------------------\n \n       procedure Validate_Invocation_Graph_Vertices (G : Invocation_Graph) is\n-         IGV_Id : Invocation_Graph_Vertex_Id;\n          Iter   : Invocation_Graphs.All_Vertex_Iterator;\n+         Vertex : Invocation_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n \n          Iter := Iterate_All_Vertices (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, IGV_Id);\n+            Next (Iter, Vertex);\n \n-            Validate_Invocation_Graph_Vertex (G, IGV_Id);\n+            Validate_Invocation_Graph_Vertex (G, Vertex);\n          end loop;\n       end Validate_Invocation_Graph_Vertices;\n-\n-      -----------------\n-      -- Write_Error --\n-      -----------------\n-\n-      procedure Write_Error (Msg : String) is\n-      begin\n-         Has_Invalid_Data := True;\n-\n-         Write_Str (\"ERROR: \");\n-         Write_Str (Msg);\n-         Write_Eol;\n-      end Write_Error;\n    end Invocation_Graph_Validators;\n \n    ------------------------------\n@@ -462,10 +600,10 @@ package body Bindo.Validators is\n       -----------------------\n \n       procedure Validate_Library_Graph_Edge\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id);\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id);\n       pragma Inline (Validate_Library_Graph_Edge);\n-      --  Verify that the attributes of edge LGE_Id of library graph G are\n+      --  Verify that the attributes of edge Edge of library graph G are\n       --  properly set.\n \n       procedure Validate_Library_Graph_Edges (G : Library_Graph);\n@@ -475,21 +613,16 @@ package body Bindo.Validators is\n \n       procedure Validate_Library_Graph_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id);\n+         Vertex : Library_Graph_Vertex_Id);\n       pragma Inline (Validate_Library_Graph_Vertex);\n-      --  Verify that the attributes of vertex LGV_Id of library graph G are\n+      --  Verify that the attributes of vertex Vertex of library graph G are\n       --  properly set.\n \n       procedure Validate_Library_Graph_Vertices (G : Library_Graph);\n       pragma Inline (Validate_Library_Graph_Vertices);\n       --  Verify that the attributes of all vertices of library graph G are\n       --  properly set.\n \n-      procedure Write_Error (Msg : String);\n-      pragma Inline (Write_Error);\n-      --  Write error message Msg to standard output and signal that the\n-      --  library graph is incorrect.\n-\n       ----------------------------\n       -- Validate_Library_Graph --\n       ----------------------------\n@@ -498,8 +631,8 @@ package body Bindo.Validators is\n       begin\n          pragma Assert (Present (G));\n \n-         --  Nothing to do when switch -d_V (validate bindo graphs and order)\n-         --  is not in effect.\n+         --  Nothing to do when switch -d_V (validate bindo cycles, graphs, and\n+         --  order) is not in effect.\n \n          if not Debug_Flag_Underscore_VV then\n             return;\n@@ -518,57 +651,57 @@ package body Bindo.Validators is\n       ---------------------------------\n \n       procedure Validate_Library_Graph_Edge\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id)\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id)\n       is\n          Msg : constant String := \"Validate_Library_Graph_Edge\";\n \n       begin\n          pragma Assert (Present (G));\n \n-         if not Present (LGE_Id) then\n-            Write_Error (Msg);\n+         if not Present (Edge) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  emply library graph edge\");\n             Write_Eol;\n             Write_Eol;\n             return;\n          end if;\n \n-         if Kind (G, LGE_Id) = No_Edge then\n-            Write_Error (Msg);\n+         if Kind (G, Edge) = No_Edge then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  library graph edge (LGE_Id_\");\n-            Write_Int (Int (LGE_Id));\n+            Write_Int (Int (Edge));\n             Write_Str (\") is not a valid edge\");\n             Write_Eol;\n             Write_Eol;\n \n-         elsif Kind (G, LGE_Id) = Body_Before_Spec_Edge then\n-            Write_Error (Msg);\n+         elsif Kind (G, Edge) = Body_Before_Spec_Edge then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  library graph edge (LGE_Id_\");\n-            Write_Int (Int (LGE_Id));\n+            Write_Int (Int (Edge));\n             Write_Str (\") is a Body_Before_Spec edge\");\n             Write_Eol;\n             Write_Eol;\n          end if;\n \n-         if not Present (Predecessor (G, LGE_Id)) then\n-            Write_Error (Msg);\n+         if not Present (Predecessor (G, Edge)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  library graph edge (LGE_Id_\");\n-            Write_Int (Int (LGE_Id));\n+            Write_Int (Int (Edge));\n             Write_Str (\") lacks Predecessor\");\n             Write_Eol;\n             Write_Eol;\n          end if;\n \n-         if not Present (Successor (G, LGE_Id)) then\n-            Write_Error (Msg);\n+         if not Present (Successor (G, Edge)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  library graph edge (LGE_Id_\");\n-            Write_Int (Int (LGE_Id));\n+            Write_Int (Int (Edge));\n             Write_Str (\") lacks Successor\");\n             Write_Eol;\n             Write_Eol;\n@@ -580,18 +713,17 @@ package body Bindo.Validators is\n       ----------------------------------\n \n       procedure Validate_Library_Graph_Edges (G : Library_Graph) is\n-         Iter   : Library_Graphs.All_Edge_Iterator;\n-         LGE_Id : Library_Graph_Edge_Id;\n+         Edge : Library_Graph_Edge_Id;\n+         Iter : Library_Graphs.All_Edge_Iterator;\n \n       begin\n          pragma Assert (Present (G));\n \n          Iter := Iterate_All_Edges (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGE_Id);\n-            pragma Assert (Present (LGE_Id));\n+            Next (Iter, Edge);\n \n-            Validate_Library_Graph_Edge (G, LGE_Id);\n+            Validate_Library_Graph_Edge (G, Edge);\n          end loop;\n       end Validate_Library_Graph_Edges;\n \n@@ -601,41 +733,41 @@ package body Bindo.Validators is\n \n       procedure Validate_Library_Graph_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id)\n+         Vertex : Library_Graph_Vertex_Id)\n       is\n          Msg : constant String := \"Validate_Library_Graph_Vertex\";\n \n       begin\n          pragma Assert (Present (G));\n \n-         if not Present (LGV_Id) then\n-            Write_Error (Msg);\n+         if not Present (Vertex) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  empty library graph vertex\");\n             Write_Eol;\n             Write_Eol;\n             return;\n          end if;\n \n-         if (Is_Body_With_Spec (G, LGV_Id)\n+         if (Is_Body_With_Spec (G, Vertex)\n                or else\n-             Is_Spec_With_Body (G, LGV_Id))\n-           and then not Present (Corresponding_Item (G, LGV_Id))\n+             Is_Spec_With_Body (G, Vertex))\n+           and then not Present (Corresponding_Item (G, Vertex))\n          then\n-            Write_Error (Msg);\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  library graph vertex (LGV_Id_\");\n-            Write_Int (Int (LGV_Id));\n+            Write_Int (Int (Vertex));\n             Write_Str (\") lacks Corresponding_Item\");\n             Write_Eol;\n             Write_Eol;\n          end if;\n \n-         if not Present (Unit (G, LGV_Id)) then\n-            Write_Error (Msg);\n+         if not Present (Unit (G, Vertex)) then\n+            Write_Error (Msg, Has_Invalid_Data);\n \n             Write_Str (\"  library graph vertex (LGV_Id_\");\n-            Write_Int (Int (LGV_Id));\n+            Write_Int (Int (Vertex));\n             Write_Str (\") lacks Unit\");\n             Write_Eol;\n             Write_Eol;\n@@ -648,32 +780,34 @@ package body Bindo.Validators is\n \n       procedure Validate_Library_Graph_Vertices (G : Library_Graph) is\n          Iter   : Library_Graphs.All_Vertex_Iterator;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n \n          Iter := Iterate_All_Vertices (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGV_Id);\n-            pragma Assert (Present (LGV_Id));\n+            Next (Iter, Vertex);\n \n-            Validate_Library_Graph_Vertex (G, LGV_Id);\n+            Validate_Library_Graph_Vertex (G, Vertex);\n          end loop;\n       end Validate_Library_Graph_Vertices;\n-\n-      -----------------\n-      -- Write_Error --\n-      -----------------\n-\n-      procedure Write_Error (Msg : String) is\n-      begin\n-         Has_Invalid_Data := True;\n-\n-         Write_Str (\"ERROR: \");\n-         Write_Str (Msg);\n-         Write_Eol;\n-      end Write_Error;\n    end Library_Graph_Validators;\n \n+   -----------------\n+   -- Write_Error --\n+   -----------------\n+\n+   procedure Write_Error\n+     (Msg  : String;\n+      Flag : out Boolean)\n+   is\n+   begin\n+      Write_Str (\"ERROR: \");\n+      Write_Str (Msg);\n+      Write_Eol;\n+\n+      Flag := True;\n+   end Write_Error;\n+\n end Bindo.Validators;"}, {"sha": "d70447b887a14dd639e735a29ab5592dec52a417", "filename": "gcc/ada/bindo-validators.ads", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-validators.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-validators.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-validators.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -35,6 +35,26 @@ use  Bindo.Graphs.Library_Graphs;\n \n package Bindo.Validators is\n \n+   ----------------------\n+   -- Cycle_Validators --\n+   ----------------------\n+\n+   package Cycle_Validators is\n+      Invalid_Cycle : exception;\n+      --  Exception raised when the library graph contains an invalid cycle\n+\n+      procedure Validate_Cycles (G : Library_Graph);\n+      --  Ensure that all cycles of library graph G meet the following\n+      --  requirements:\n+      --\n+      --    * Are of proper kind\n+      --    * Have enough edges to form a circuit\n+      --    * No edge is repeated\n+      --\n+      --  Diagnose issues and raise Invalid_Cycle if this is not the case.\n+\n+   end Cycle_Validators;\n+\n    ----------------------------------\n    -- Elaboration_Order_Validators --\n    ----------------------------------"}, {"sha": "067ba1ffad516e28a81809a6b668851b24e5babd", "filename": "gcc/ada/bindo-writers.adb", "status": "modified", "additions": 236, "deletions": 133, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-writers.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-writers.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -28,7 +28,8 @@ with Fname;  use Fname;\n with Opt;    use Opt;\n with Output; use Output;\n \n-with Bindo.Units; use Bindo.Units;\n+with Bindo.Units;\n+use  Bindo.Units;\n \n with GNAT;        use GNAT;\n with GNAT.Graphs; use GNAT.Graphs;\n@@ -124,26 +125,27 @@ package body Bindo.Writers is\n       --------------------------------\n \n       procedure Write_Invocation_Construct (IC_Id : Invocation_Construct_Id) is\n+      begin\n          pragma Assert (Present (IC_Id));\n \n-         IC_Rec : Invocation_Construct_Record renames\n-                    Invocation_Constructs.Table (IC_Id);\n-\n-      begin\n          Write_Str (\"  invocation construct (IC_Id_\");\n          Write_Int (Int (IC_Id));\n          Write_Str (\")\");\n          Write_Eol;\n \n+         Write_Str (\"    Body_Placement = \");\n+         Write_Str (Body_Placement (IC_Id)'Img);\n+         Write_Eol;\n+\n          Write_Str (\"    Kind = \");\n-         Write_Str (IC_Rec.Kind'Img);\n+         Write_Str (Kind (IC_Id)'Img);\n          Write_Eol;\n \n-         Write_Str (\"    Placement = \");\n-         Write_Str (IC_Rec.Placement'Img);\n+         Write_Str (\"    Spec_Placement = \");\n+         Write_Str (Spec_Placement (IC_Id)'Img);\n          Write_Eol;\n \n-         Write_Invocation_Signature (IC_Rec.Signature);\n+         Write_Invocation_Signature (Signature (IC_Id));\n          Write_Eol;\n       end Write_Invocation_Construct;\n \n@@ -152,20 +154,17 @@ package body Bindo.Writers is\n       -------------------------------\n \n       procedure Write_Invocation_Relation (IR_Id : Invocation_Relation_Id) is\n+      begin\n          pragma Assert (Present (IR_Id));\n \n-         IR_Rec : Invocation_Relation_Record renames\n-                    Invocation_Relations.Table (IR_Id);\n-\n-      begin\n          Write_Str (\"  invocation relation (IR_Id_\");\n          Write_Int (Int (IR_Id));\n          Write_Str (\")\");\n          Write_Eol;\n \n-         if Present (IR_Rec.Extra) then\n+         if Present (Extra (IR_Id)) then\n             Write_Str  (\"    Extra = \");\n-            Write_Name (IR_Rec.Extra);\n+            Write_Name (Extra (IR_Id));\n          else\n             Write_Str (\"    Extra = none\");\n          end if;\n@@ -174,16 +173,16 @@ package body Bindo.Writers is\n          Write_Str (\"    Invoker\");\n          Write_Eol;\n \n-         Write_Invocation_Signature (IR_Rec.Invoker);\n+         Write_Invocation_Signature (Invoker (IR_Id));\n \n          Write_Str (\"    Kind = \");\n-         Write_Str (IR_Rec.Kind'Img);\n+         Write_Str (Kind (IR_Id)'Img);\n          Write_Eol;\n \n          Write_Str (\"    Target\");\n          Write_Eol;\n \n-         Write_Invocation_Signature (IR_Rec.Target);\n+         Write_Invocation_Signature (Target (IR_Id));\n          Write_Eol;\n       end Write_Invocation_Relation;\n \n@@ -192,39 +191,36 @@ package body Bindo.Writers is\n       --------------------------------\n \n       procedure Write_Invocation_Signature (IS_Id : Invocation_Signature_Id) is\n+      begin\n          pragma Assert (Present (IS_Id));\n \n-         IS_Rec : Invocation_Signature_Record renames\n-                    Invocation_Signatures.Table (IS_Id);\n-\n-      begin\n          Write_Str (\"    Signature (IS_Id_\");\n          Write_Int (Int (IS_Id));\n          Write_Str (\")\");\n          Write_Eol;\n \n          Write_Str (\"      Column = \");\n-         Write_Int (Int (IS_Rec.Column));\n+         Write_Int (Int (Column (IS_Id)));\n          Write_Eol;\n \n          Write_Str (\"      Line = \");\n-         Write_Int (Int (IS_Rec.Line));\n+         Write_Int (Int (Line (IS_Id)));\n          Write_Eol;\n \n-         if Present (IS_Rec.Locations) then\n+         if Present (Locations (IS_Id)) then\n             Write_Str  (\"      Locations = \");\n-            Write_Name (IS_Rec.Locations);\n+            Write_Name (Locations (IS_Id));\n          else\n             Write_Str (\"      Locations = none\");\n          end if;\n \n          Write_Eol;\n          Write_Str  (\"      Name = \");\n-         Write_Name (IS_Rec.Name);\n+         Write_Name (Name (IS_Id));\n          Write_Eol;\n \n          Write_Str  (\"      Scope = \");\n-         Write_Name (IS_Rec.Scope);\n+         Write_Name (Scope (IS_Id));\n          Write_Eol;\n       end Write_Invocation_Signature;\n \n@@ -277,17 +273,8 @@ package body Bindo.Writers is\n          Write_Eol;\n          Write_Eol;\n \n-         for IC_Id in U_Rec.First_Invocation_Construct ..\n-                      U_Rec.Last_Invocation_Construct\n-         loop\n-            Write_Invocation_Construct (IC_Id);\n-         end loop;\n-\n-         for IR_Id in U_Rec.First_Invocation_Relation ..\n-                      U_Rec.Last_Invocation_Relation\n-         loop\n-            Write_Invocation_Relation (IR_Id);\n-         end loop;\n+         For_Each_Invocation_Construct (Write_Invocation_Construct'Access);\n+         For_Each_Invocation_Relation  (Write_Invocation_Relation'Access);\n       end Write_Unit;\n \n       -----------------------\n@@ -313,6 +300,131 @@ package body Bindo.Writers is\n       end Write_Unit_Common;\n    end ALI_Writers;\n \n+   -------------------\n+   -- Cycle_Writers --\n+   -------------------\n+\n+   package body Cycle_Writers is\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Write_Cycle\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id);\n+      pragma Inline (Write_Cycle);\n+      --  Write the path of cycle Cycle found in library graph G to standard\n+      --  output.\n+\n+      procedure Write_Cyclic_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id);\n+      pragma Inline (Write_Cyclic_Edge);\n+      --  Write cyclic edge Edge of library graph G to standard\n+\n+      -----------------\n+      -- Write_Cycle --\n+      -----------------\n+\n+      procedure Write_Cycle\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id)\n+      is\n+         Edge : Library_Graph_Edge_Id;\n+         Iter : Edges_Of_Cycle_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Cycle));\n+\n+         --  Nothing to do when switch -d_P (output cycle paths) is not in\n+         --  effect.\n+\n+         if not Debug_Flag_Underscore_PP then\n+            return;\n+         end if;\n+\n+         Write_Str (\"cycle (LGC_Id_\");\n+         Write_Int (Int (Cycle));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Iter := Iterate_Edges_Of_Cycle (G, Cycle);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Edge);\n+\n+            Write_Cyclic_Edge (G, Edge);\n+         end loop;\n+\n+         Write_Eol;\n+      end Write_Cycle;\n+\n+      ------------------\n+      -- Write_Cycles --\n+      ------------------\n+\n+      procedure Write_Cycles (G : Library_Graph) is\n+         Cycle : Library_Graph_Cycle_Id;\n+         Iter  : All_Cycle_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Cycles (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Cycle);\n+\n+            Write_Cycle (G, Cycle);\n+         end loop;\n+      end Write_Cycles;\n+\n+      -----------------------\n+      -- Write_Cyclic_Edge --\n+      -----------------------\n+\n+      procedure Write_Cyclic_Edge\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Edge));\n+\n+         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, Edge);\n+         Succ : constant Library_Graph_Vertex_Id := Successor   (G, Edge);\n+\n+      begin\n+         Indent_By (Nested_Indentation);\n+         Write_Name (Name (G, Succ));\n+         Write_Str  (\" --> \");\n+         Write_Name (Name (G, Pred));\n+         Write_Str  (\"   \");\n+\n+         if Is_Elaborate_All_Edge (G, Edge) then\n+            Write_Str (\"Elaborate_All edge\");\n+\n+         elsif Is_Elaborate_Body_Edge (G, Edge) then\n+            Write_Str (\"Elaborate_Body edge\");\n+\n+         elsif Is_Elaborate_Edge (G, Edge) then\n+            Write_Str (\"Elaborate edge\");\n+\n+         elsif Is_Forced_Edge (G, Edge) then\n+            Write_Str (\"forced edge\");\n+\n+         elsif Is_Invocation_Edge (G, Edge) then\n+            Write_Str (\"invocation edge\");\n+\n+         else\n+            pragma Assert (Is_With_Edge (G, Edge));\n+\n+            Write_Str (\"with edge\");\n+         end if;\n+\n+         Write_Eol;\n+      end Write_Cyclic_Edge;\n+   end Cycle_Writers;\n+\n    -------------------------------\n    -- Elaboration_Order_Writers --\n    -------------------------------\n@@ -416,22 +528,23 @@ package body Bindo.Writers is\n       --  Write all elaboration roots of invocation graph G to standard output\n \n       procedure Write_Invocation_Graph_Edge\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id);\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id);\n       pragma Inline (Write_Invocation_Graph_Edge);\n-      --  Write edge IGE_Id of invocation graph G to standard output\n+      --  Write edge Edge of invocation graph G to standard output\n \n       procedure Write_Invocation_Graph_Edges\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id);\n+         Vertex : Invocation_Graph_Vertex_Id);\n       pragma Inline (Write_Invocation_Graph_Edges);\n-      --  Write all edges of invocation graph G to standard output\n+      --  Write all edges to targets of vertex Vertex of invocation graph G to\n+      --  standard output.\n \n       procedure Write_Invocation_Graph_Vertex\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id);\n+         Vertex : Invocation_Graph_Vertex_Id);\n       pragma Inline (Write_Invocation_Graph_Vertex);\n-      --  Write vertex IGV_Id of invocation graph G to standard output\n+      --  Write vertex Vertex of invocation graph G to standard output\n \n       procedure Write_Invocation_Graph_Vertices (G : Invocation_Graph);\n       pragma Inline (Write_Invocation_Graph_Vertices);\n@@ -447,14 +560,13 @@ package body Bindo.Writers is\n       -----------\n \n       procedure pige\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id)\n-         renames Write_Invocation_Graph_Edge;\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id) renames Write_Invocation_Graph_Edge;\n       pragma Unreferenced (pige);\n \n       procedure pigv\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id)\n+         Vertex : Invocation_Graph_Vertex_Id)\n          renames Write_Invocation_Graph_Vertex;\n       pragma Unreferenced (pigv);\n \n@@ -498,7 +610,6 @@ package body Bindo.Writers is\n             Iter := Iterate_Elaboration_Roots (G);\n             while Has_Next (Iter) loop\n                Next (Iter, Root);\n-               pragma Assert (Present (Root));\n \n                Write_Elaboration_Root (G, Root);\n             end loop;\n@@ -541,24 +652,22 @@ package body Bindo.Writers is\n       ---------------------------------\n \n       procedure Write_Invocation_Graph_Edge\n-        (G      : Invocation_Graph;\n-         IGE_Id : Invocation_Graph_Edge_Id)\n+        (G    : Invocation_Graph;\n+         Edge : Invocation_Graph_Edge_Id)\n       is\n          pragma Assert (Present (G));\n-         pragma Assert (Present (IGE_Id));\n-\n-         Targ : constant Invocation_Graph_Vertex_Id := Target (G, IGE_Id);\n+         pragma Assert (Present (Edge));\n \n-         pragma Assert (Present (Targ));\n+         Targ : constant Invocation_Graph_Vertex_Id := Target (G, Edge);\n \n       begin\n          Write_Str (\"    invocation graph edge (IGE_Id_\");\n-         Write_Int (Int (IGE_Id));\n+         Write_Int (Int (Edge));\n          Write_Str (\")\");\n          Write_Eol;\n \n          Write_Str (\"      Relation (IR_Id_\");\n-         Write_Int (Int (Relation (G, IGE_Id)));\n+         Write_Int (Int (Relation (G, Edge)));\n          Write_Str (\")\");\n          Write_Eol;\n \n@@ -577,29 +686,28 @@ package body Bindo.Writers is\n \n       procedure Write_Invocation_Graph_Edges\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id)\n+         Vertex : Invocation_Graph_Vertex_Id)\n       is\n          pragma Assert (Present (G));\n-         pragma Assert (Present (IGV_Id));\n+         pragma Assert (Present (Vertex));\n \n          Num_Of_Edges : constant Natural :=\n-                          Number_Of_Edges_To_Targets (G, IGV_Id);\n+                          Number_Of_Edges_To_Targets (G, Vertex);\n \n-         IGE_Id : Invocation_Graph_Edge_Id;\n-         Iter   : Invocation_Graphs.Edges_To_Targets_Iterator;\n+         Edge : Invocation_Graph_Edge_Id;\n+         Iter : Invocation_Graphs.Edges_To_Targets_Iterator;\n \n       begin\n          Write_Str (\"  Edges to targets: \");\n          Write_Int (Int (Num_Of_Edges));\n          Write_Eol;\n \n          if Num_Of_Edges > 0 then\n-            Iter := Iterate_Edges_To_Targets (G, IGV_Id);\n+            Iter := Iterate_Edges_To_Targets (G, Vertex);\n             while Has_Next (Iter) loop\n-               Next (Iter, IGE_Id);\n-               pragma Assert (Present (IGE_Id));\n+               Next (Iter, Edge);\n \n-               Write_Invocation_Graph_Edge (G, IGE_Id);\n+               Write_Invocation_Graph_Edge (G, Edge);\n             end loop;\n          else\n             Write_Eol;\n@@ -612,48 +720,52 @@ package body Bindo.Writers is\n \n       procedure Write_Invocation_Graph_Vertex\n         (G      : Invocation_Graph;\n-         IGV_Id : Invocation_Graph_Vertex_Id)\n+         Vertex : Invocation_Graph_Vertex_Id)\n       is\n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (IGV_Id));\n+         pragma Assert (Present (Vertex));\n \n          Write_Str  (\"invocation graph vertex (IGV_Id_\");\n-         Write_Int  (Int (IGV_Id));\n+         Write_Int  (Int (Vertex));\n          Write_Str  (\") name = \");\n-         Write_Name (Name (G, IGV_Id));\n+         Write_Name (Name (G, Vertex));\n+         Write_Eol;\n+\n+         Write_Str (\"  Body_Vertex (LGV_Id_\");\n+         Write_Int (Int (Body_Vertex (G, Vertex)));\n+         Write_Str (\")\");\n          Write_Eol;\n \n          Write_Str (\"  Construct (IC_Id_\");\n-         Write_Int (Int (Construct (G, IGV_Id)));\n+         Write_Int (Int (Construct (G, Vertex)));\n          Write_Str (\")\");\n          Write_Eol;\n \n-         Write_Str (\"  Lib_Vertex (LGV_Id_\");\n-         Write_Int (Int (Lib_Vertex (G, IGV_Id)));\n+         Write_Str (\"  Spec_Vertex (LGV_Id_\");\n+         Write_Int (Int (Spec_Vertex (G, Vertex)));\n          Write_Str (\")\");\n          Write_Eol;\n \n-         Write_Invocation_Graph_Edges (G, IGV_Id);\n+         Write_Invocation_Graph_Edges (G, Vertex);\n       end Write_Invocation_Graph_Vertex;\n \n       -------------------------------------\n       -- Write_Invocation_Graph_Vertices --\n       -------------------------------------\n \n       procedure Write_Invocation_Graph_Vertices (G : Invocation_Graph) is\n-         IGV_Id : Invocation_Graph_Vertex_Id;\n          Iter   : Invocation_Graphs.All_Vertex_Iterator;\n+         Vertex : Invocation_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n \n          Iter := Iterate_All_Vertices (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, IGV_Id);\n-            pragma Assert (Present (IGV_Id));\n+            Next (Iter, Vertex);\n \n-            Write_Invocation_Graph_Vertex (G, IGV_Id);\n+            Write_Invocation_Graph_Vertex (G, Vertex);\n          end loop;\n       end Write_Invocation_Graph_Vertices;\n \n@@ -719,22 +831,22 @@ package body Bindo.Writers is\n \n       procedure Write_Edges_To_Successors\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id);\n+         Vertex : Library_Graph_Vertex_Id);\n       pragma Inline (Write_Edges_To_Successors);\n-      --  Write all edges to successors of predecessor LGV_Id of library graph\n+      --  Write all edges to successors of predecessor Vertex of library graph\n       --  G to standard output.\n \n       procedure Write_Library_Graph_Edge\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id);\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id);\n       pragma Inline (Write_Library_Graph_Edge);\n-      --  Write edge LGE_Id of library graph G to standard output\n+      --  Write edge Edge of library graph G to standard output\n \n       procedure Write_Library_Graph_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id);\n+         Vertex : Library_Graph_Vertex_Id);\n       pragma Inline (Write_Library_Graph_Vertex);\n-      --  Write vertex LGV_Id of library graph G to standard output\n+      --  Write vertex Vertex of library graph G to standard output\n \n       procedure Write_Library_Graph_Vertices (G : Library_Graph);\n       pragma Inline (Write_Library_Graph_Vertices);\n@@ -755,13 +867,13 @@ package body Bindo.Writers is\n       pragma Unreferenced (pc);\n \n       procedure plge\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id) renames Write_Library_Graph_Edge;\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id) renames Write_Library_Graph_Edge;\n       pragma Unreferenced (plge);\n \n       procedure plgv\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id) renames Write_Library_Graph_Vertex;\n+         Vertex : Library_Graph_Vertex_Id) renames Write_Library_Graph_Vertex;\n       pragma Unreferenced (plgv);\n \n       ---------------------\n@@ -797,21 +909,20 @@ package body Bindo.Writers is\n          Comp : Component_Id)\n       is\n          Iter   : Component_Vertex_Iterator;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Comp));\n \n          Iter := Iterate_Component_Vertices (G, Comp);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGV_Id);\n-            pragma Assert (Present (LGV_Id));\n+            Next (Iter, Vertex);\n \n             Write_Str  (\"    library graph vertex (LGV_Id_\");\n-            Write_Int  (Int (LGV_Id));\n+            Write_Int  (Int (Vertex));\n             Write_Str  (\") name = \");\n-            Write_Name (Name (G, LGV_Id));\n+            Write_Name (Name (G, Vertex));\n             Write_Eol;\n          end loop;\n \n@@ -835,7 +946,6 @@ package body Bindo.Writers is\n             Iter := Iterate_Components (G);\n             while Has_Next (Iter) loop\n                Next (Iter, Comp);\n-               pragma Assert (Present (Comp));\n \n                Write_Component (G, Comp);\n             end loop;\n@@ -850,29 +960,28 @@ package body Bindo.Writers is\n \n       procedure Write_Edges_To_Successors\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id)\n+         Vertex : Library_Graph_Vertex_Id)\n       is\n          pragma Assert (Present (G));\n-         pragma Assert (Present (LGV_Id));\n+         pragma Assert (Present (Vertex));\n \n          Num_Of_Edges : constant Natural :=\n-                          Number_Of_Edges_To_Successors (G, LGV_Id);\n+                          Number_Of_Edges_To_Successors (G, Vertex);\n \n-         Iter   : Edges_To_Successors_Iterator;\n-         LGE_Id : Library_Graph_Edge_Id;\n+         Edge : Library_Graph_Edge_Id;\n+         Iter : Edges_To_Successors_Iterator;\n \n       begin\n          Write_Str (\"  Edges to successors: \");\n          Write_Int (Int (Num_Of_Edges));\n          Write_Eol;\n \n          if Num_Of_Edges > 0 then\n-            Iter := Iterate_Edges_To_Successors (G, LGV_Id);\n+            Iter := Iterate_Edges_To_Successors (G, Vertex);\n             while Has_Next (Iter) loop\n-               Next (Iter, LGE_Id);\n-               pragma Assert (Present (LGE_Id));\n+               Next (Iter, Edge);\n \n-               Write_Library_Graph_Edge (G, LGE_Id);\n+               Write_Library_Graph_Edge (G, Edge);\n             end loop;\n          else\n             Write_Eol;\n@@ -913,26 +1022,23 @@ package body Bindo.Writers is\n       ------------------------------\n \n       procedure Write_Library_Graph_Edge\n-        (G      : Library_Graph;\n-         LGE_Id : Library_Graph_Edge_Id)\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id)\n       is\n          pragma Assert (Present (G));\n-         pragma Assert (Present (LGE_Id));\n+         pragma Assert (Present (Edge));\n \n-         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, LGE_Id);\n-         Succ : constant Library_Graph_Vertex_Id := Successor   (G, LGE_Id);\n-\n-         pragma Assert (Present (Pred));\n-         pragma Assert (Present (Succ));\n+         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, Edge);\n+         Succ : constant Library_Graph_Vertex_Id := Successor   (G, Edge);\n \n       begin\n          Write_Str (\"    library graph edge (LGE_Id_\");\n-         Write_Int (Int (LGE_Id));\n+         Write_Int (Int (Edge));\n          Write_Str (\")\");\n          Write_Eol;\n \n          Write_Str (\"      Kind = \");\n-         Write_Str (Kind (G, LGE_Id)'Img);\n+         Write_Str (Kind (G, Edge)'Img);\n          Write_Eol;\n \n          Write_Str  (\"      Predecessor (LGV_Id_\");\n@@ -956,22 +1062,20 @@ package body Bindo.Writers is\n \n       procedure Write_Library_Graph_Vertex\n         (G      : Library_Graph;\n-         LGV_Id : Library_Graph_Vertex_Id)\n+         Vertex : Library_Graph_Vertex_Id)\n       is\n          pragma Assert (Present (G));\n-         pragma Assert (Present (LGV_Id));\n+         pragma Assert (Present (Vertex));\n \n          Item : constant Library_Graph_Vertex_Id :=\n-                  Corresponding_Item (G, LGV_Id);\n-         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n-\n-         pragma Assert (Present (U_Id));\n+                  Corresponding_Item (G, Vertex);\n+         U_Id : constant Unit_Id := Unit (G, Vertex);\n \n       begin\n          Write_Str  (\"library graph vertex (LGV_Id_\");\n-         Write_Int  (Int (LGV_Id));\n+         Write_Int  (Int (Vertex));\n          Write_Str  (\") name = \");\n-         Write_Name (Name (G, LGV_Id));\n+         Write_Name (Name (G, Vertex));\n          Write_Eol;\n \n          if Present (Item) then\n@@ -986,19 +1090,19 @@ package body Bindo.Writers is\n          Write_Eol;\n          Write_Str (\"  In_Elaboration_Order = \");\n \n-         if In_Elaboration_Order (G, LGV_Id) then\n+         if In_Elaboration_Order (G, Vertex) then\n             Write_Str (\"True\");\n          else\n             Write_Str (\"False\");\n          end if;\n \n          Write_Eol;\n          Write_Str (\"  Pending_Predecessors = \");\n-         Write_Int (Int (Pending_Predecessors (G, LGV_Id)));\n+         Write_Int (Int (Pending_Predecessors (G, Vertex)));\n          Write_Eol;\n \n          Write_Str (\"  Component (Comp_Id_\");\n-         Write_Int (Int (Component (G, LGV_Id)));\n+         Write_Int (Int (Component (G, Vertex)));\n          Write_Str (\")\");\n          Write_Eol;\n \n@@ -1008,7 +1112,7 @@ package body Bindo.Writers is\n          Write_Name (Name (U_Id));\n          Write_Eol;\n \n-         Write_Edges_To_Successors (G, LGV_Id);\n+         Write_Edges_To_Successors (G, Vertex);\n       end Write_Library_Graph_Vertex;\n \n       ----------------------------------\n@@ -1017,17 +1121,16 @@ package body Bindo.Writers is\n \n       procedure Write_Library_Graph_Vertices (G : Library_Graph) is\n          Iter   : Library_Graphs.All_Vertex_Iterator;\n-         LGV_Id : Library_Graph_Vertex_Id;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n \n          Iter := Iterate_All_Vertices (G);\n          while Has_Next (Iter) loop\n-            Next (Iter, LGV_Id);\n-            pragma Assert (Present (LGV_Id));\n+            Next (Iter, Vertex);\n \n-            Write_Library_Graph_Vertex (G, LGV_Id);\n+            Write_Library_Graph_Vertex (G, Vertex);\n          end loop;\n       end Write_Library_Graph_Vertices;\n \n@@ -1071,11 +1174,11 @@ package body Bindo.Writers is\n       pragma Inline (Hash_File_Name);\n       --  Obtain the hash value of key Nam\n \n-      package FS is new Membership_Sets\n+      package File_Name_Tables is new Membership_Sets\n         (Element_Type => File_Name_Type,\n          \"=\"          => \"=\",\n          Hash         => Hash_File_Name);\n-      use FS;\n+      use File_Name_Tables;\n \n       -----------------------\n       -- Local subprograms --"}, {"sha": "b7916387c514ab2594f5a3e5b3150d34c7f1afe3", "filename": "gcc/ada/bindo-writers.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-writers.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo-writers.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -81,6 +81,16 @@ package Bindo.Writers is\n \n    end ALI_Writers;\n \n+   -------------------\n+   -- Cycle_Writers --\n+   -------------------\n+\n+   package Cycle_Writers is\n+      procedure Write_Cycles (G : Library_Graph);\n+      --  Write all cycles of library graph G to standard output\n+\n+   end Cycle_Writers;\n+\n    -------------------------------\n    -- Elaboration_Order_Writers --\n    -------------------------------"}, {"sha": "039fd0d3ccd1d5bb0d4a3729aff9f3c06bf406b3", "filename": "gcc/ada/bindo.adb", "status": "modified", "additions": 100, "deletions": 25, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fbindo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -23,8 +23,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Binde;\n+with Debug; use Debug;\n+\n with Bindo.Elaborators;\n-use  Bindo.Elaborators.Invocation_And_Library_Graph_Elaborators;\n+use  Bindo.Elaborators;\n \n package body Bindo is\n \n@@ -47,37 +50,53 @@ package body Bindo is\n    --        - The flow of execution at elaboration time.\n    --\n    --        - Additional dependencies between units supplied to the binder by\n-   --          means of a file.\n+   --          means of a forced-elaboration-order file.\n+   --\n+   --      The high-level idea empoyed by the EO mechanism is to construct two\n+   --      graphs and use the information they represent to find an ordering of\n+   --      all units.\n    --\n-   --      The high-level idea is to construct two graphs:\n+   --      The invocation graph represents the flow of execution at elaboration\n+   --      time.\n    --\n-   --        - Invocation graph - Models the flow of execution at elaboration\n-   --          time.\n+   --      The library graph captures the dependencies between units expressed\n+   --      by with clause and elaboration-related pragmas. The library graph is\n+   --      further augmented with additional information from the invocation\n+   --      graph by exploring the execution paths from a unit with elaboration\n+   --      code to other external units.\n    --\n-   --        - Library graph - Represents with clause and pragma dependencies\n-   --          between units.\n+   --      The strongly connected components of the library graph are computed.\n    --\n-   --      The library graph is further augmented with additional information\n-   --      from the invocation graph by exploring the execution paths from a\n-   --      unit with elaboration code to other external units. All strongly\n-   --      connected components of the library graph are discovered. Finally,\n-   --      the order is obtained via a topological sort-like algorithm which\n-   --      attempts to order available units while enabling other units to be\n+   --      The order is obtained using a topological sort-like algorithm which\n+   --      traverses the library graph and its strongly connected components in\n+   --      an attempt to order available units while enabling other units to be\n    --      ordered.\n    --\n    --    * Diagnose elaboration circularities between units\n    --\n-   --      The library graph may contain at least one cycle, in which case no\n-   --      ordering is possible.\n+   --      An elaboration circularity arrises when either\n+   --\n+   --        - At least one unit cannot be ordered, or\n+   --\n+   --        - All units can be ordered, but an edge with an Elaborate_All\n+   --          pragma links two vertices within the same component of the\n+   --          library graph.\n    --\n-   --      ??? more on this later\n+   --      The library graph is traversed to discover, collect, and sort all\n+   --      cycles that hinder the elaboration order.\n+   --\n+   --      The most important cycle is diagnosed by describing its effects on\n+   --      the elaboration order and listing all units comprising the circuit.\n+   --      Various suggestions on how to break the cycle are offered.\n \n    -----------------\n    -- Terminology --\n    -----------------\n \n    --  * Component - A strongly connected component of a graph.\n    --\n+   --  * Elaboration circularity - A cycle involving units from the bind.\n+   --\n    --  * Elaboration root - A special invocation construct which denotes the\n    --    elaboration procedure of a unit.\n    --\n@@ -162,7 +181,11 @@ package body Bindo is\n    --          |\n    --  +------ | -------------- Diagnostics phase -------------------------+\n    --  |       |                                                           |\n-   --  |       +--> ??? more on this later                                 |\n+   --  |       +--> Find_Cycles                                            |\n+   --  |       +--> Validate_Cycles                                        |\n+   --  |       +--> Write_Cycles                                           |\n+   --  |       |                                                           |\n+   --  |       +--> Diagnose_Cycle / Diagnose_All_Cycles                   |\n    --  |                                                                   |\n    --  +-------------------------------------------------------------------+\n \n@@ -225,7 +248,37 @@ package body Bindo is\n    -- Diagnostics phase --\n    -----------------------\n \n-   --  ??? more on this later\n+   --  The Diagnostics phase has the following objectives:\n+   --\n+   --    * Discover, save, and sort all cycles in the library graph. The cycles\n+   --      are sorted based on the following heiristics:\n+   --\n+   --        - A cycle with higher precedence is preferred.\n+   --\n+   --        - A cycle with fewer invocation edges is preferred.\n+   --\n+   --        - A cycle with a shorter length is preferred.\n+   --\n+   --    * Validate the consistency of cycles, only when switch -d_V is in\n+   --      effect.\n+   --\n+   --    * Write the contents of all cycles in human-readable form to standard\n+   --      output when switch -d_O is in effect.\n+   --\n+   --    * Diagnose the most important cycle, or all cycles when switch -d_C is\n+   --      in effect. The diagnostic consists of:\n+   --\n+   --        - The reason for the existance of the cycle, along with the unit\n+   --          whose elaboration cannot be guaranteed.\n+   --\n+   --        - A detailed traceback of the cycle, showcasing the transition\n+   --          between units, along with any other elaboration order-related\n+   --          information.\n+   --\n+   --        - A set of suggestions on how to break the cycle considering the\n+   --          the edges coprising the circuit, the elaboration model used to\n+   --          compile the units, the availability of invocation information,\n+   --          and the state of various relevant switches.\n \n    --------------\n    -- Switches --\n@@ -236,6 +289,11 @@ package body Bindo is\n    --        GNATbind outputs the contents of ALI table Invocation_Constructs\n    --        and Invocation_Edges in textual format to standard output.\n    --\n+   --  -d_C  Diagnose all cycles\n+   --\n+   --        GNATbind outputs diagnostics for all unique cycles in the bind,\n+   --        rather than just the most important one.\n+   --\n    --  -d_I  Output invocation graph\n    --\n    --        GNATbind outputs the invocation graph in text format to standard\n@@ -255,16 +313,20 @@ package body Bindo is\n    --        GNATbind outputs the elaboration order in text format to standard\n    --        output.\n    --\n+   --  -d_P  Output cycle paths\n+   --\n+   --        GNATbind output the cycle paths in text format to standard output\n+   --\n    --  -d_T  Output elaboration order trace information\n    --\n-   --        GNATbind outputs trace information on elaboration order activities\n-   --        to standard output.\n+   --        GNATbind outputs trace information on elaboration order and cycle\n+   --        detection activities to standard output.\n    --\n-   --  -d_V  Validate bindo graphs and order\n+   --  -d_V  Validate bindo cycles, graphs, and order\n    --\n-   --        GNATbind validates the invocation graph, library graph, SCC graph\n-   --        and elaboration order by detecting inconsistencies and producing\n-   --        error reports.\n+   --        GNATbind validates the invocation graph, library graph along with\n+   --        its cycles, and elaboration order by detecting inconsistencies and\n+   --        producing error reports.\n \n    ----------------------------------------\n    -- Debugging elaboration order issues --\n@@ -281,7 +343,20 @@ package body Bindo is\n       Main_Lib_File : File_Name_Type)\n    is\n    begin\n-      Elaborate_Units (Order, Main_Lib_File);\n+      --  Use the invocation and library graph-based elaboration order when\n+      --  switch -d_N (new bindo order) is in effect.\n+\n+      if Debug_Flag_Underscore_NN then\n+         Invocation_And_Library_Graph_Elaborators.Elaborate_Units\n+           (Order         => Order,\n+            Main_Lib_File => Main_Lib_File);\n+\n+      --  Otherwise use the library graph and heuristic-based elaboration\n+      --  order.\n+\n+      else\n+         Binde.Find_Elab_Order (Order, Main_Lib_File);\n+      end if;\n    end Find_Elaboration_Order;\n \n end Bindo;"}, {"sha": "fb9ebba4ea277f8095e8c7b2243f4afbd59bb918", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -378,7 +378,7 @@ package body Debug is\n \n    --  d_A  Output ALI invocation tables\n    --  d_B\n-   --  d_C\n+   --  d_C  Diagnose all cycles\n    --  d_D\n    --  d_F\n    --  d_G\n@@ -390,13 +390,13 @@ package body Debug is\n    --  d_M\n    --  d_N  New bindo order\n    --  d_O  Output elaboration order\n-   --  d_P\n+   --  d_P  Output cycle paths\n    --  d_Q\n    --  d_R\n    --  d_S\n-   --  d_T  Output elaboration order trace information\n+   --  d_T  Output elaboration order and cycle detection trace information\n    --  d_U\n-   --  d_V  Validate bindo graphs and order\n+   --  d_V  Validate bindo cycles, graphs, and order\n    --  d_W\n    --  d_X\n    --  d_Y\n@@ -1150,22 +1150,27 @@ package body Debug is\n \n    --  d_A  GNATBIND output the contents of all ALI invocation-related tables\n    --       in textual format to standard output.\n-   --\n+\n+   --  d_C  GNATBIND diagnoses all unique cycles within the bind, rather than\n+   --       just the most important one.\n+\n    --  d_I  GNATBIND outputs the contents of the invocation graph in textual\n    --       format to standard output.\n-   --\n+\n    --  d_L  GNATBIND outputs the contents of the library graph in textual\n    --       format to standard output.\n-   --\n+\n    --  d_N  GNATBIND utilizes the elaboration order provided by bindo\n-   --\n+\n    --  d_O  GNATBIND outputs the elaboration order of units to standard output\n-   --\n-   --  d_T  GNATBIND outputs trace information of elaboration order activities\n-   --       to standard output.\n-   --\n-   --  d_V  GNATBIND validates the invocation graph, library graph, SCC graph\n-   --       and elaboration order.\n+\n+   --  d_P  GNATBIND outputs the cycle paths to standard output\n+\n+   --  d_T  GNATBIND outputs trace information of elaboration order and cycle\n+   --       detection activities to standard output.\n+\n+   --  d_V  GNATBIND validates the invocation graph, library graph along with\n+   --       its cycles, and the elaboration order.\n \n    --------------------------------------------\n    -- Documentation for gnatmake Debug Flags --"}, {"sha": "40c85b95ac0bdbffb2dafab3b876a14d6e9e7b9b", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -26,7 +26,6 @@\n with ALI;      use ALI;\n with ALI.Util; use ALI.Util;\n with Bcheck;   use Bcheck;\n-with Binde;    use Binde;\n with Binderr;  use Binderr;\n with Bindgen;  use Bindgen;\n with Bindo;    use Bindo;\n@@ -883,14 +882,7 @@ begin\n             Elab_Order : Unit_Id_Table;\n \n          begin\n-            --  Use the invocation and library graph-based elaboration order\n-            --  when switch -d_N (new bindo order) is in effect.\n-\n-            if Debug_Flag_Underscore_NN then\n-               Find_Elaboration_Order (Elab_Order, First_Main_Lib_File);\n-            else\n-               Find_Elab_Order (Elab_Order, First_Main_Lib_File);\n-            end if;\n+            Find_Elaboration_Order (Elab_Order, First_Main_Lib_File);\n \n             if Errors_Detected = 0 and then not Check_Only then\n                Gen_Output_File"}, {"sha": "861d58eaf96fdc58ee338441c9773b0f5aa1150c", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 191, "deletions": 353, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -59,65 +59,32 @@ with System.WCh_Con;   use System.WCh_Con;\n package body Lib.Writ is\n \n    -----------------------\n-   -- Local Subprograms --\n+   -- Local subprograms --\n    -----------------------\n \n-   function Column (IS_Id : Invocation_Signature_Id) return Nat;\n-   pragma Inline (Column);\n-   --  Obtain attribute Column of an invocation signature with id IS_Id\n-\n-   function Extra (IR_Id : Invocation_Relation_Id) return Name_Id;\n-   pragma Inline (Extra);\n-   --  Obtain attribute Extra of an invocation relation with id IR_Id\n-\n-   function Invoker\n-     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id;\n-   pragma Inline (Invoker);\n-   --  Obtain attribute Invoker of an invocation relation with id IR_Id\n-\n-   function Kind\n-     (IC_Id : Invocation_Construct_Id) return Invocation_Construct_Kind;\n-   pragma Inline (Kind);\n-   --  Obtain attribute Kind of an invocation construct with id IC_Id\n-\n-   function Kind (IR_Id : Invocation_Relation_Id) return Invocation_Kind;\n-   pragma Inline (Kind);\n-   --  Obtain attribute Kind of an invocation relation with id IR_Id\n-\n-   function Line (IS_Id : Invocation_Signature_Id) return Nat;\n-   pragma Inline (Line);\n-   --  Obtain attribute Line of an invocation signature with id IS_Id\n-\n-   function Locations (IS_Id : Invocation_Signature_Id) return Name_Id;\n-   pragma Inline (Locations);\n-   --  Obtain attribute Locations of an invocation signature with id IS_Id\n-\n-   function Name (IS_Id : Invocation_Signature_Id) return Name_Id;\n-   pragma Inline (Name);\n-   --  Obtain attribute Name of an invocation signature with id IS_Id\n-\n-   function Placement\n-     (IC_Id : Invocation_Construct_Id) return Body_Placement_Kind;\n-   pragma Inline (Placement);\n-   --  Obtain attribute Placement of an invocation construct with id IC_Id\n-\n    function Present (N_Id : Name_Id) return Boolean;\n    pragma Inline (Present);\n    --  Determine whether a name with id N_Id exists\n \n-   function Scope (IS_Id : Invocation_Signature_Id) return Name_Id;\n-   pragma Inline (Scope);\n-   --  Obtain attribute Scope of an invocation signature with id IS_Id\n+   procedure Write_Invocation_Construct (IC_Id : Invocation_Construct_Id);\n+   pragma Inline (Write_Invocation_Construct);\n+   --  Write invocation construct IC_Id to the ALI file\n+\n+   procedure Write_Invocation_Graph;\n+   pragma Inline (Write_Invocation_Graph);\n+   --  Write out the invocation graph\n \n-   function Signature\n-     (IC_Id : Invocation_Construct_Id) return Invocation_Signature_Id;\n-   pragma Inline (Signature);\n-   --  Obtain attribute Signature of an invocation construct with id IC_Id\n+   procedure Write_Invocation_Graph_Attributes;\n+   pragma Inline (Write_Invocation_Graph_Attributes);\n+   --  Write out the attributes of the invocation graph\n \n-   function Target\n-     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id;\n-   pragma Inline (Target);\n-   --  Obtain attribute Target of an invocation relation with id IR_Id\n+   procedure Write_Invocation_Relation (IR_Id : Invocation_Relation_Id);\n+   pragma Inline (Write_Invocation_Relation);\n+   --  Write invocation relation IR_Id to the ALI file\n+\n+   procedure Write_Invocation_Signature (IS_Id : Invocation_Signature_Id);\n+   pragma Inline (Write_Invocation_Signature);\n+   --  Write invocation signature IS_Id to the ALI file\n \n    procedure Write_Unit_Name (N : Node_Id);\n    --  Used to write out the unit name for R (pragma Restriction) lines\n@@ -161,16 +128,6 @@ package body Lib.Writ is\n          OA_Setting             => 'O');\n    end Add_Preprocessing_Dependency;\n \n-   ------------\n-   -- Column --\n-   ------------\n-\n-   function Column (IS_Id : Invocation_Signature_Id) return Nat is\n-   begin\n-      pragma Assert (Present (IS_Id));\n-      return Invocation_Signatures.Table (IS_Id).Column;\n-   end Column;\n-\n    ------------------------------\n    -- Ensure_System_Dependency --\n    ------------------------------\n@@ -252,92 +209,6 @@ package body Lib.Writ is\n       end;\n    end Ensure_System_Dependency;\n \n-   -----------\n-   -- Extra --\n-   -----------\n-\n-   function Extra (IR_Id : Invocation_Relation_Id) return Name_Id is\n-   begin\n-      pragma Assert (Present (IR_Id));\n-      return Invocation_Relations.Table (IR_Id).Extra;\n-   end Extra;\n-\n-   -------------\n-   -- Invoker --\n-   -------------\n-\n-   function Invoker\n-     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id\n-   is\n-   begin\n-      pragma Assert (Present (IR_Id));\n-      return Invocation_Relations.Table (IR_Id).Invoker;\n-   end Invoker;\n-\n-   ----------\n-   -- Kind --\n-   ----------\n-\n-   function Kind\n-     (IC_Id : Invocation_Construct_Id) return Invocation_Construct_Kind\n-   is\n-   begin\n-      pragma Assert (Present (IC_Id));\n-      return Invocation_Constructs.Table (IC_Id).Kind;\n-   end Kind;\n-\n-   ----------\n-   -- Kind --\n-   ----------\n-\n-   function Kind (IR_Id : Invocation_Relation_Id) return Invocation_Kind is\n-   begin\n-      pragma Assert (Present (IR_Id));\n-      return Invocation_Relations.Table (IR_Id).Kind;\n-   end Kind;\n-\n-   ----------\n-   -- Line --\n-   ----------\n-\n-   function Line (IS_Id : Invocation_Signature_Id) return Nat is\n-   begin\n-      pragma Assert (Present (IS_Id));\n-      return Invocation_Signatures.Table (IS_Id).Line;\n-   end Line;\n-\n-   ---------------\n-   -- Locations --\n-   ---------------\n-\n-   function Locations (IS_Id : Invocation_Signature_Id) return Name_Id is\n-   begin\n-      pragma Assert (Present (IS_Id));\n-      return Invocation_Signatures.Table (IS_Id).Locations;\n-   end Locations;\n-\n-   ----------\n-   -- Name --\n-   ----------\n-\n-   function Name (IS_Id : Invocation_Signature_Id) return Name_Id is\n-   begin\n-      pragma Assert (Present (IS_Id));\n-      return Invocation_Signatures.Table (IS_Id).Name;\n-   end Name;\n-\n-   ---------------\n-   -- Placement --\n-   ---------------\n-\n-   function Placement\n-     (IC_Id : Invocation_Construct_Id) return Body_Placement_Kind\n-   is\n-   begin\n-      pragma Assert (Present (IC_Id));\n-      return Invocation_Constructs.Table (IC_Id).Placement;\n-   end Placement;\n-\n    -------------\n    -- Present --\n    -------------\n@@ -347,40 +218,6 @@ package body Lib.Writ is\n       return N_Id /= No_Name;\n    end Present;\n \n-   -----------\n-   -- Scope --\n-   -----------\n-\n-   function Scope (IS_Id : Invocation_Signature_Id) return Name_Id is\n-   begin\n-      pragma Assert (Present (IS_Id));\n-      return Invocation_Signatures.Table (IS_Id).Scope;\n-   end Scope;\n-\n-   ---------------\n-   -- Signature --\n-   ---------------\n-\n-   function Signature\n-     (IC_Id : Invocation_Construct_Id) return Invocation_Signature_Id\n-   is\n-   begin\n-      pragma Assert (Present (IC_Id));\n-      return Invocation_Constructs.Table (IC_Id).Signature;\n-   end Signature;\n-\n-   ------------\n-   -- Target --\n-   ------------\n-\n-   function Target\n-     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id\n-   is\n-   begin\n-      pragma Assert (Present (IR_Id));\n-      return Invocation_Relations.Table (IR_Id).Target;\n-   end Target;\n-\n    ---------------\n    -- Write_ALI --\n    ---------------\n@@ -441,9 +278,6 @@ package body Lib.Writ is\n       --  this file (using Scan_ALI) and returns True. If no file exists,\n       --  or the file is not up to date, then False is returned.\n \n-      procedure Write_Invocation_Graph;\n-      --  Write out the invocation graph\n-\n       procedure Write_Unit_Information (Unit_Num : Unit_Number_Type);\n       --  Write out the library information for one unit for which code is\n       --  generated (includes unit line and with lines).\n@@ -632,175 +466,6 @@ package body Lib.Writ is\n          end loop;\n       end Update_Tables_From_ALI_File;\n \n-      ----------------------------\n-      -- Write_Invocation_Graph --\n-      ----------------------------\n-\n-      procedure Write_Invocation_Graph is\n-         procedure Write_Invocation_Construct\n-           (IC_Id : Invocation_Construct_Id);\n-         pragma Inline (Write_Invocation_Construct);\n-         --  Write invocation construct IC_Id to the ALI file\n-\n-         procedure Write_Invocation_Relation (IR_Id : Invocation_Relation_Id);\n-         pragma Inline (Write_Invocation_Relation);\n-         --  Write invocation relation IR_Id to the ALI file\n-\n-         procedure Write_Invocation_Signature\n-           (IS_Id : Invocation_Signature_Id);\n-         pragma Inline (Write_Invocation_Signature);\n-         --  Write invocation signature IS_Id to the ALI file\n-\n-         --------------------------------\n-         -- Write_Invocation_Construct --\n-         --------------------------------\n-\n-         procedure Write_Invocation_Construct\n-           (IC_Id : Invocation_Construct_Id)\n-         is\n-         begin\n-            --  G header\n-\n-            Write_Info_Initiate ('G');\n-            Write_Info_Char     (' ');\n-\n-            --  line-kind\n-\n-            Write_Info_Char\n-              (Invocation_Graph_Line_Kind_To_Code (Invocation_Construct_Line));\n-            Write_Info_Char (' ');\n-\n-            --  construct-kind\n-\n-            Write_Info_Char (Invocation_Construct_Kind_To_Code (Kind (IC_Id)));\n-            Write_Info_Char (' ');\n-\n-            --  construct-body-placement\n-\n-            Write_Info_Char (Body_Placement_Kind_To_Code (Placement (IC_Id)));\n-            Write_Info_Char (' ');\n-\n-            --  construct-signature\n-\n-            Write_Invocation_Signature (Signature (IC_Id));\n-            Write_Info_EOL;\n-         end Write_Invocation_Construct;\n-\n-         -------------------------------\n-         -- Write_Invocation_Relation --\n-         -------------------------------\n-\n-         procedure Write_Invocation_Relation\n-           (IR_Id : Invocation_Relation_Id)\n-         is\n-         begin\n-            --  G header\n-\n-            Write_Info_Initiate ('G');\n-            Write_Info_Char     (' ');\n-\n-            --  line-kind\n-\n-            Write_Info_Char\n-              (Invocation_Graph_Line_Kind_To_Code (Invocation_Relation_Line));\n-            Write_Info_Char (' ');\n-\n-            --  relation-kind\n-\n-            Write_Info_Char (Invocation_Kind_To_Code (Kind (IR_Id)));\n-            Write_Info_Char (' ');\n-\n-            --  (extra-name | \"none\")\n-\n-            if Present (Extra (IR_Id)) then\n-               Write_Info_Name (Extra (IR_Id));\n-            else\n-               Write_Info_Str (\"none\");\n-            end if;\n-\n-            Write_Info_Char (' ');\n-\n-            --  invoker-signature\n-\n-            Write_Invocation_Signature (Invoker (IR_Id));\n-            Write_Info_Char (' ');\n-\n-            --  target-signature\n-\n-            Write_Invocation_Signature (Target (IR_Id));\n-\n-            Write_Info_EOL;\n-         end Write_Invocation_Relation;\n-\n-         --------------------------------\n-         -- Write_Invocation_Signature --\n-         --------------------------------\n-\n-         procedure Write_Invocation_Signature\n-           (IS_Id : Invocation_Signature_Id)\n-         is\n-         begin\n-            --  [\n-\n-            Write_Info_Char ('[');\n-\n-            --  name\n-\n-            Write_Info_Name (Name (IS_Id));\n-            Write_Info_Char (' ');\n-\n-            --  scope\n-\n-            Write_Info_Name (Scope (IS_Id));\n-            Write_Info_Char (' ');\n-\n-            --  line\n-\n-            Write_Info_Nat  (Line (IS_Id));\n-            Write_Info_Char (' ');\n-\n-            --  column\n-\n-            Write_Info_Nat  (Column (IS_Id));\n-            Write_Info_Char (' ');\n-\n-            --  (locations | \"none\")\n-\n-            if Present (Locations (IS_Id)) then\n-               Write_Info_Name (Locations (IS_Id));\n-            else\n-               Write_Info_Str (\"none\");\n-            end if;\n-\n-            --  ]\n-\n-            Write_Info_Char (']');\n-         end Write_Invocation_Signature;\n-\n-      --  Start of processing for Write_Invocation_Graph\n-\n-      begin\n-         --  First write out all invocation constructs declared within the\n-         --  current unit. This ensures that when this invocation is read,\n-         --  the invocation constructs are materialized before they are\n-         --  referenced by invocation relations.\n-\n-         for IC_Id in Invocation_Constructs.First ..\n-                      Invocation_Constructs.Last\n-         loop\n-            Write_Invocation_Construct (IC_Id);\n-         end loop;\n-\n-         --  Write out all invocation relations that originate from invocation\n-         --  constructs delared in the current unit.\n-\n-         for IR_Id in Invocation_Relations.First ..\n-                      Invocation_Relations.Last\n-         loop\n-            Write_Invocation_Relation (IR_Id);\n-         end loop;\n-      end Write_Invocation_Graph;\n-\n       ----------------------------\n       -- Write_Unit_Information --\n       ----------------------------\n@@ -2010,6 +1675,179 @@ package body Lib.Writ is\n       Close_Output_Library_Info;\n    end Write_ALI;\n \n+   --------------------------------\n+   -- Write_Invocation_Construct --\n+   --------------------------------\n+\n+   procedure Write_Invocation_Construct (IC_Id : Invocation_Construct_Id) is\n+   begin\n+      --  G header\n+\n+      Write_Info_Initiate ('G');\n+      Write_Info_Char     (' ');\n+\n+      --  line-kind\n+\n+      Write_Info_Char\n+        (Invocation_Graph_Line_Kind_To_Code (Invocation_Construct_Line));\n+      Write_Info_Char (' ');\n+\n+      --  construct-kind\n+\n+      Write_Info_Char (Invocation_Construct_Kind_To_Code (Kind (IC_Id)));\n+      Write_Info_Char (' ');\n+\n+      --  construct-spec-placement\n+\n+      Write_Info_Char\n+        (Declaration_Placement_Kind_To_Code (Spec_Placement (IC_Id)));\n+      Write_Info_Char (' ');\n+\n+      --  construct-body-placement\n+\n+      Write_Info_Char\n+        (Declaration_Placement_Kind_To_Code (Body_Placement (IC_Id)));\n+      Write_Info_Char (' ');\n+\n+      --  construct-signature\n+\n+      Write_Invocation_Signature (Signature (IC_Id));\n+      Write_Info_EOL;\n+   end Write_Invocation_Construct;\n+\n+   ---------------------------------------\n+   -- Write_Invocation_Graph_Attributes --\n+   ---------------------------------------\n+\n+   procedure Write_Invocation_Graph_Attributes is\n+   begin\n+      --  G header\n+\n+      Write_Info_Initiate ('G');\n+      Write_Info_Char     (' ');\n+\n+      --  line-kind\n+\n+      Write_Info_Char\n+        (Invocation_Graph_Line_Kind_To_Code\n+          (Invocation_Graph_Attributes_Line));\n+      Write_Info_Char (' ');\n+\n+      --  encoding-kind\n+\n+      Write_Info_Char\n+        (Invocation_Graph_Encoding_Kind_To_Code (Invocation_Graph_Encoding));\n+      Write_Info_EOL;\n+   end Write_Invocation_Graph_Attributes;\n+\n+   ----------------------------\n+   -- Write_Invocation_Graph --\n+   ----------------------------\n+\n+   procedure Write_Invocation_Graph is\n+   begin\n+      Write_Invocation_Graph_Attributes;\n+\n+      --  First write out all invocation constructs declared within the current\n+      --  unit. This ensures that when this invocation is read, the invocation\n+      --  constructs are materialized before they are referenced by invocation\n+      --  relations.\n+\n+      For_Each_Invocation_Construct (Write_Invocation_Construct'Access);\n+\n+      --  Write out all invocation relations that originate from invocation\n+      --  constructs delared in the current unit.\n+\n+      For_Each_Invocation_Relation (Write_Invocation_Relation'Access);\n+   end Write_Invocation_Graph;\n+\n+   -------------------------------\n+   -- Write_Invocation_Relation --\n+   -------------------------------\n+\n+   procedure Write_Invocation_Relation (IR_Id : Invocation_Relation_Id) is\n+   begin\n+      --  G header\n+\n+      Write_Info_Initiate ('G');\n+      Write_Info_Char     (' ');\n+\n+      --  line-kind\n+\n+      Write_Info_Char\n+        (Invocation_Graph_Line_Kind_To_Code (Invocation_Relation_Line));\n+      Write_Info_Char (' ');\n+\n+      --  relation-kind\n+\n+      Write_Info_Char (Invocation_Kind_To_Code (Kind (IR_Id)));\n+      Write_Info_Char (' ');\n+\n+      --  (extra-name | \"none\")\n+\n+      if Present (Extra (IR_Id)) then\n+         Write_Info_Name (Extra (IR_Id));\n+      else\n+         Write_Info_Str (\"none\");\n+      end if;\n+\n+      Write_Info_Char (' ');\n+\n+      --  invoker-signature\n+\n+      Write_Invocation_Signature (Invoker (IR_Id));\n+      Write_Info_Char (' ');\n+\n+      --  target-signature\n+\n+      Write_Invocation_Signature (Target (IR_Id));\n+\n+      Write_Info_EOL;\n+   end Write_Invocation_Relation;\n+\n+   --------------------------------\n+   -- Write_Invocation_Signature --\n+   --------------------------------\n+\n+   procedure Write_Invocation_Signature (IS_Id : Invocation_Signature_Id) is\n+   begin\n+      --  [\n+\n+      Write_Info_Char ('[');\n+\n+      --  name\n+\n+      Write_Info_Name (Name (IS_Id));\n+      Write_Info_Char (' ');\n+\n+      --  scope\n+\n+      Write_Info_Name (Scope (IS_Id));\n+      Write_Info_Char (' ');\n+\n+      --  line\n+\n+      Write_Info_Nat  (Line (IS_Id));\n+      Write_Info_Char (' ');\n+\n+      --  column\n+\n+      Write_Info_Nat  (Column (IS_Id));\n+      Write_Info_Char (' ');\n+\n+      --  (locations | \"none\")\n+\n+      if Present (Locations (IS_Id)) then\n+         Write_Info_Name (Locations (IS_Id));\n+      else\n+         Write_Info_Str (\"none\");\n+      end if;\n+\n+      --  ]\n+\n+      Write_Info_Char (']');\n+   end Write_Invocation_Signature;\n+\n    ---------------------\n    -- Write_Unit_Name --\n    ---------------------"}, {"sha": "7248a61e86f51e42b881dfb93d06c8fcd7b2847f", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -880,18 +880,32 @@ package Lib.Writ is\n    --      locations of all instances where the initial declaration of the\n    --      construct appears.\n    --\n+   --  When the line-kind denotes invocation graph attributes, line-attributes\n+   --  are set as follows:\n+   --\n+   --      encoding-kind\n+   --\n+   --      Attribute encoding-kind is a Character which specifies the encoding\n+   --      kind used when collecting invocation constructs and relations. Table\n+   --      ALI.Invocation_Graph_Encoding_Codes lists all legal values.\n+   --\n    --  When the line-kind denotes an invocation construct, line-attributes are\n    --  set as follows:\n    --\n-   --      construct-kind construct-body-placement construct-signature\n+   --      construct-kind construct-spec-placement construct-body-placement\n+   --        construct-signature\n    --\n    --      Attribute construct-kind is a Character which denotes the nature of\n    --      the construct. Table ALI.Invocation_Construct_Codes lists all legal\n    --      values.\n    --\n+   --      Attribute construct-spec-placement is a Character which denotes the\n+   --      placement of the construct's spec within the unit. All legal values\n+   --      are listed in table ALI.Spec_And_Body_Placement_Codes.\n+   --\n    --      Attribute construct-body-placement is a Character which denotes the\n    --      placement of the construct's body within the unit. All legal values\n-   --      are listed in table ALI.Body_Placement_Codes.\n+   --      are listed in table ALI.Spec_And_Body_Placement_Codes.\n    --\n    --      Attribute construct-signature is the invocation signature of the\n    --      construct.\n@@ -925,7 +939,7 @@ package Lib.Writ is\n    --        Postcondition_Verification             - related routine\n    --        Protected_Entry_Call                   - not present\n    --        Protected_Subprogram_Call              - not present\n-   --        Task_Activation                        - related task object\n+   --        Task_Activation                        - not present\n    --        Task_Entry_Call                        - not present\n    --        Type_Initialization                    - related type\n    --"}, {"sha": "817274a66f0cee493364af9cb0b54e4d029c1fc9", "filename": "gcc/ada/libgnat/g-lists.adb", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -337,6 +337,57 @@ package body GNAT.Lists is\n          end if;\n       end Ensure_Unlocked;\n \n+      -----------\n+      -- Equal --\n+      -----------\n+\n+      function Equal\n+        (Left  : Doubly_Linked_List;\n+         Right : Doubly_Linked_List) return Boolean\n+      is\n+         Left_Head  : Node_Ptr;\n+         Left_Nod   : Node_Ptr;\n+         Right_Head : Node_Ptr;\n+         Right_Nod  : Node_Ptr;\n+\n+      begin\n+         --  Two non-existent lists are considered equal\n+\n+         if Left = Nil and then Right = Nil then\n+            return True;\n+\n+         --  A non-existent list is never equal to an already created list\n+\n+         elsif Left = Nil or else Right = Nil then\n+            return False;\n+\n+         --  The two lists must contain the same number of elements to be equal\n+\n+         elsif Size (Left) /= Size (Right) then\n+            return False;\n+         end if;\n+\n+         --  Compare the two lists element by element\n+\n+         Left_Head  := Left.Nodes'Access;\n+         Left_Nod   := Left_Head.Next;\n+         Right_Head := Right.Nodes'Access;\n+         Right_Nod  := Right_Head.Next;\n+         while Is_Valid (Left_Nod,  Left_Head)\n+                 and then\n+               Is_Valid (Right_Nod, Right_Head)\n+         loop\n+            if Left_Nod.Elem /= Right_Nod.Elem then\n+               return False;\n+            end if;\n+\n+            Left_Nod  := Left_Nod.Next;\n+            Right_Nod := Right_Nod.Next;\n+         end loop;\n+\n+         return True;\n+      end Equal;\n+\n       ---------------\n       -- Find_Node --\n       ---------------"}, {"sha": "fdcaed6af8a9352f9595e93366adca7b1c316edb", "filename": "gcc/ada/libgnat/g-lists.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.ads?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -117,6 +117,12 @@ package GNAT.Lists is\n       --  end of a list's lifetime. This action will raise Iterated if the\n       --  list has outstanding iterators.\n \n+      function Equal\n+        (Left  : Doubly_Linked_List;\n+         Right : Doubly_Linked_List) return Boolean;\n+      --  Determine whether lists Left and Right have the same characteristics\n+      --  and contain the same elements.\n+\n       function First (L : Doubly_Linked_List) return Element_Type;\n       --  Obtain an element from the start of list L. This action will raise\n       --  List_Empty if the list is empty."}, {"sha": "2bd38c83780ce2a5d478585a59af9ae5cf508d47", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 120, "deletions": 52, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9795b20366362d63be058f1e4f3009d6bad79310/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=9795b20366362d63be058f1e4f3009d6bad79310", "patch": "@@ -11689,6 +11689,11 @@ package body Sem_Elab is\n       --  active scenarios. In_State is the current state of the Processing\n       --  phase.\n \n+      procedure Record_Invocation_Graph_Encoding;\n+      pragma Inline (Record_Invocation_Graph_Encoding);\n+      --  Record the encoding format used to capture information related to\n+      --  invocation constructs and relations.\n+\n       procedure Record_Invocation_Path (In_State : Processing_In_State);\n       pragma Inline (Record_Invocation_Path);\n       --  Record the invocation relations found within the path represented in\n@@ -11938,40 +11943,32 @@ package body Sem_Elab is\n         (Constr_Id : Entity_Id;\n          In_State  : Processing_In_State)\n       is\n+         function Body_Placement_Of\n+           (Id : Entity_Id) return Declaration_Placement_Kind;\n+         pragma Inline (Body_Placement_Of);\n+         --  Obtain the placement of arbitrary entity Id's body\n+\n+         function Declaration_Placement_Of_Node\n+           (N : Node_Id) return Declaration_Placement_Kind;\n+         pragma Inline (Declaration_Placement_Of_Node);\n+         --  Obtain the placement of arbitrary node N\n+\n          function Kind_Of (Id : Entity_Id) return Invocation_Construct_Kind;\n          pragma Inline (Kind_Of);\n          --  Obtain the invocation construct kind of arbitrary entity Id\n \n-         function Placement_Of (Id : Entity_Id) return Body_Placement_Kind;\n-         pragma Inline (Placement_Of);\n-         --  Obtain the body placement of arbitrary entity Id\n-\n-         function Placement_Of_Node (N : Node_Id) return Body_Placement_Kind;\n-         pragma Inline (Placement_Of_Node);\n-         --  Obtain the body placement of arbitrary node N\n-\n-         -------------\n-         -- Kind_Of --\n-         -------------\n-\n-         function Kind_Of (Id : Entity_Id) return Invocation_Construct_Kind is\n-         begin\n-            if Id = Elab_Body_Id then\n-               return Elaborate_Body_Procedure;\n-\n-            elsif Id = Elab_Spec_Id then\n-               return Elaborate_Spec_Procedure;\n-\n-            else\n-               return Regular_Construct;\n-            end if;\n-         end Kind_Of;\n+         function Spec_Placement_Of\n+           (Id : Entity_Id) return Declaration_Placement_Kind;\n+         pragma Inline (Spec_Placement_Of);\n+         --  Obtain the placement of arbitrary entity Id's spec\n \n-         ------------------\n-         -- Placement_Of --\n-         ------------------\n+         -----------------------\n+         -- Body_Placement_Of --\n+         -----------------------\n \n-         function Placement_Of (Id : Entity_Id) return Body_Placement_Kind is\n+         function Body_Placement_Of\n+           (Id : Entity_Id) return Declaration_Placement_Kind\n+         is\n             Id_Rep    : constant Target_Rep_Id :=\n                           Target_Representation_Of (Id, In_State);\n             Body_Decl : constant Node_Id := Body_Declaration (Id_Rep);\n@@ -11981,21 +11978,23 @@ package body Sem_Elab is\n             --  The entity has a body\n \n             if Present (Body_Decl) then\n-               return Placement_Of_Node (Body_Decl);\n+               return Declaration_Placement_Of_Node (Body_Decl);\n \n             --  Otherwise the entity must have a spec\n \n             else\n                pragma Assert (Present (Spec_Decl));\n-               return Placement_Of_Node (Spec_Decl);\n+               return Declaration_Placement_Of_Node (Spec_Decl);\n             end if;\n-         end Placement_Of;\n+         end Body_Placement_Of;\n \n-         -----------------------\n-         -- Placement_Of_Node --\n-         -----------------------\n+         -----------------------------------\n+         -- Declaration_Placement_Of_Node --\n+         -----------------------------------\n \n-         function Placement_Of_Node (N : Node_Id) return Body_Placement_Kind is\n+         function Declaration_Placement_Of_Node\n+           (N : Node_Id) return Declaration_Placement_Kind\n+         is\n             Main_Unit_Id : constant Entity_Id := Cunit_Entity (Main_Unit);\n             N_Unit_Id    : constant Entity_Id := Find_Top_Unit (N);\n \n@@ -12039,11 +12038,50 @@ package body Sem_Elab is\n             else\n                return In_Body;\n             end if;\n-         end Placement_Of_Node;\n+         end Declaration_Placement_Of_Node;\n \n-         --  Local variables\n+         -------------\n+         -- Kind_Of --\n+         -------------\n+\n+         function Kind_Of (Id : Entity_Id) return Invocation_Construct_Kind is\n+         begin\n+            if Id = Elab_Body_Id then\n+               return Elaborate_Body_Procedure;\n+\n+            elsif Id = Elab_Spec_Id then\n+               return Elaborate_Spec_Procedure;\n+\n+            else\n+               return Regular_Construct;\n+            end if;\n+         end Kind_Of;\n \n-         IC_Rec : Invocation_Construct_Record;\n+         -----------------------\n+         -- Spec_Placement_Of --\n+         -----------------------\n+\n+         function Spec_Placement_Of\n+           (Id : Entity_Id) return Declaration_Placement_Kind\n+         is\n+            Id_Rep    : constant Target_Rep_Id :=\n+                          Target_Representation_Of (Id, In_State);\n+            Body_Decl : constant Node_Id := Body_Declaration (Id_Rep);\n+            Spec_Decl : constant Node_Id := Spec_Declaration (Id_Rep);\n+\n+         begin\n+            --  The entity has a spec\n+\n+            if Present (Spec_Decl) then\n+               return Declaration_Placement_Of_Node (Spec_Decl);\n+\n+            --  Otherwise the entity must have a body\n+\n+            else\n+               pragma Assert (Present (Body_Decl));\n+               return Declaration_Placement_Of_Node (Body_Decl);\n+            end if;\n+         end Spec_Placement_Of;\n \n       --  Start of processing for Declare_Invocation_Construct\n \n@@ -12059,15 +12097,14 @@ package body Sem_Elab is\n \n          Set_Is_Saved_Construct (Constr_Id);\n \n-         IC_Rec.Kind      := Kind_Of      (Constr_Id);\n-         IC_Rec.Placement := Placement_Of (Constr_Id);\n-         IC_Rec.Signature := Signature_Of (Constr_Id);\n-\n          --  Add the construct in the ALI file\n \n          Add_Invocation_Construct\n-           (IC_Rec       => IC_Rec,\n-            Update_Units => False);\n+           (Body_Placement => Body_Placement_Of (Constr_Id),\n+            Kind           => Kind_Of           (Constr_Id),\n+            Signature      => Signature_Of      (Constr_Id),\n+            Spec_Placement => Spec_Placement_Of (Constr_Id),\n+            Update_Units   => False);\n       end Declare_Invocation_Construct;\n \n       -------------------------------\n@@ -12809,6 +12846,12 @@ package body Sem_Elab is\n             return;\n          end if;\n \n+         --  Save the encoding format used to capture information about the\n+         --  invocation constructs and relations in the ALI file of the main\n+         --  unit.\n+\n+         Record_Invocation_Graph_Encoding;\n+\n          --  Examine all library level invocation scenarios and perform DFS\n          --  traversals from each one. Encode a path in the ALI file of the\n          --  main unit if it reaches into an external unit.\n@@ -12824,6 +12867,30 @@ package body Sem_Elab is\n          Process_Main_Unit;\n       end Record_Invocation_Graph;\n \n+      --------------------------------------\n+      -- Record_Invocation_Graph_Encoding --\n+      --------------------------------------\n+\n+      procedure Record_Invocation_Graph_Encoding is\n+         Kind : Invocation_Graph_Encoding_Kind := No_Encoding;\n+\n+      begin\n+         --  Switch -gnatd_F (encode full invocation paths in ALI files) is in\n+         --  effect.\n+\n+         if Debug_Flag_Underscore_FF then\n+            Kind := Full_Path_Encoding;\n+         else\n+            Kind := Endpoints_Encoding;\n+         end if;\n+\n+         --  Save the encoding format in the ALI file of the main unit\n+\n+         Set_Invocation_Graph_Encoding\n+           (Kind         => Kind,\n+            Update_Units => False);\n+      end Record_Invocation_Graph_Encoding;\n+\n       ----------------------------\n       -- Record_Invocation_Path --\n       ----------------------------\n@@ -12882,6 +12949,10 @@ package body Sem_Elab is\n            (Extra : out Entity_Id;\n             Kind  : out Invocation_Kind)\n          is\n+            Targ_Rep  : constant Target_Rep_Id :=\n+                          Target_Representation_Of (Targ_Id, In_State);\n+            Spec_Decl : constant Node_Id := Spec_Declaration (Targ_Rep);\n+\n          begin\n             --  Accept within a task body\n \n@@ -12970,7 +13041,7 @@ package body Sem_Elab is\n             --  Postcondition verification\n \n             elsif Is_Postconditions_Proc (Targ_Id) then\n-               Extra := Find_Enclosing_Scope (Targ_Id);\n+               Extra := Find_Enclosing_Scope (Spec_Decl);\n                Kind  := Postcondition_Verification;\n \n             --  Protected entry call\n@@ -13013,7 +13084,6 @@ package body Sem_Elab is\n \n          Extra     : Entity_Id;\n          Extra_Nam : Name_Id;\n-         IR_Rec    : Invocation_Relation_Record;\n          Kind      : Invocation_Kind;\n          Rel       : Invoker_Target_Relation;\n \n@@ -13052,15 +13122,13 @@ package body Sem_Elab is\n             Extra_Nam := No_Name;\n          end if;\n \n-         IR_Rec.Extra   := Extra_Nam;\n-         IR_Rec.Invoker := Signature_Of (Invk_Id);\n-         IR_Rec.Kind    := Kind;\n-         IR_Rec.Target  := Signature_Of (Targ_Id);\n-\n          --  Add the relation in the ALI file\n \n          Add_Invocation_Relation\n-           (IR_Rec       => IR_Rec,\n+           (Extra        => Extra_Nam,\n+            Invoker      => Signature_Of (Invk_Id),\n+            Kind         => Kind,\n+            Target       => Signature_Of (Targ_Id),\n             Update_Units => False);\n       end Record_Invocation_Relation;\n "}]}