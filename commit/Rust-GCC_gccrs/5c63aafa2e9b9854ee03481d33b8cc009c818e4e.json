{"sha": "5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM2M2FhZmEyZTliOTg1NGVlMDM0ODFkMzNiOGNjMDA5YzgxOGU0ZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2016-04-20T10:19:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-20T10:19:57Z"}, "message": "sem_ch12.adb (Qualify_Universal_Operands): New routine.\n\n2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch12.adb (Qualify_Universal_Operands): New routine.\n\t(Save_References_In_Operator): Add explicit qualifications in\n\tthe generic template for all operands of universal type.\n\t* sem_type.adb (Disambiguate): Update the call to Matches.\n\t(Matches): Reimplemented.\n\t* sem_util.ads, sem_util.adb (Yields_Universal_Type): New routine.\n\nFrom-SVN: r235254", "tree": {"sha": "fbc908f1eaee497bacf39f846a2908c0f26aa8eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbc908f1eaee497bacf39f846a2908c0f26aa8eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e22a38c2f5f173ac220cd9ec70b55ce08243797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e22a38c2f5f173ac220cd9ec70b55ce08243797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e22a38c2f5f173ac220cd9ec70b55ce08243797"}], "stats": {"total": 298, "additions": 280, "deletions": 18}, "files": [{"sha": "275823173e2eef7b9f8155dbfeab4d2f534765d7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "patch": "@@ -1,3 +1,12 @@\n+2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch12.adb (Qualify_Universal_Operands): New routine.\n+\t(Save_References_In_Operator): Add explicit qualifications in\n+\tthe generic template for all operands of universal type.\n+\t* sem_type.adb (Disambiguate): Update the call to Matches.\n+\t(Matches): Reimplemented.\n+\t* sem_util.ads, sem_util.adb (Yields_Universal_Type): New routine.\n+\n 2016-04-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Rep_Item_Too_Late): Better error message for"}, {"sha": "bd7a6a412ae75b96daf7c11fd942bedfc2810501", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 127, "deletions": 2, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "patch": "@@ -13848,6 +13848,19 @@ package body Sem_Ch12 is\n       --  global because it is used to denote a specific compilation unit at\n       --  the time the instantiations will be analyzed.\n \n+      procedure Qualify_Universal_Operands\n+        (Op        : Node_Id;\n+         Func_Call : Node_Id);\n+      --  Op denotes a binary or unary operator in generic template Templ. Node\n+      --  Func_Call is the function call alternative of the operator within the\n+      --  the analyzed copy of the template. Change each operand which yields a\n+      --  universal type by wrapping it into a qualified expression\n+      --\n+      --    Actual_Typ'(Operand)\n+      --\n+      --  where Actual_Typ is the type of corresponding actual parameter of\n+      --  Operand in Func_Call.\n+\n       procedure Reset_Entity (N : Node_Id);\n       --  Save semantic information on global entity so that it is not resolved\n       --  again at instantiation time.\n@@ -13938,6 +13951,109 @@ package body Sem_Ch12 is\n          end if;\n       end Is_Global;\n \n+      --------------------------------\n+      -- Qualify_Universal_Operands --\n+      --------------------------------\n+\n+      procedure Qualify_Universal_Operands\n+        (Op        : Node_Id;\n+         Func_Call : Node_Id)\n+      is\n+         procedure Qualify_Operand (Opnd : Node_Id; Actual : Node_Id);\n+         --  Rewrite operand Opnd as a qualified expression of the form\n+         --\n+         --    Actual_Typ'(Opnd)\n+         --\n+         --  where Actual is the corresponding actual parameter of Opnd in\n+         --  function call Func_Call.\n+\n+         function Qualify_Type\n+           (Loc : Source_Ptr;\n+            Typ : Entity_Id) return Node_Id;\n+         --  Qualify type Typ by creating a selected component of the form\n+         --\n+         --    Scope_Of_Typ.Typ\n+\n+         ---------------------\n+         -- Qualify_Operand --\n+         ---------------------\n+\n+         procedure Qualify_Operand (Opnd : Node_Id; Actual : Node_Id) is\n+            Loc  : constant Source_Ptr := Sloc (Opnd);\n+            Typ  : constant Entity_Id  := Etype (Actual);\n+            Mark : Node_Id;\n+\n+         begin\n+            --  Qualify the operand when it is of a universal type. Note that\n+            --  the template is unanalyzed and it is not possible to directly\n+            --  query the type. This transformation is not done when the type\n+            --  of the actual is internally generated because the type will be\n+            --  regenerated in the instance.\n+\n+            if Yields_Universal_Type (Opnd)\n+              and then Comes_From_Source (Typ)\n+              and then not Is_Hidden (Typ)\n+            then\n+               --  The type of the actual may be a global reference. Save this\n+               --  information by creating a reference to it.\n+\n+               if Is_Global (Typ) then\n+                  Mark := New_Occurrence_Of (Typ, Loc);\n+\n+               --  Otherwise rely on resolution to find the proper type within\n+               --  the instance.\n+\n+               else\n+                  Mark := Qualify_Type (Loc, Typ);\n+               end if;\n+\n+               Rewrite (Opnd,\n+                 Make_Qualified_Expression (Loc,\n+                   Subtype_Mark => Mark,\n+                   Expression   => Relocate_Node (Opnd)));\n+            end if;\n+         end Qualify_Operand;\n+\n+         ------------------\n+         -- Qualify_Type --\n+         ------------------\n+\n+         function Qualify_Type\n+           (Loc : Source_Ptr;\n+            Typ : Entity_Id) return Node_Id\n+         is\n+            Scop   : constant Entity_Id := Scope (Typ);\n+            Result : Node_Id;\n+\n+         begin\n+            Result := Make_Identifier (Loc, Chars (Typ));\n+\n+            if Present (Scop) and then Scop /= Standard_Standard then\n+               Result :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix        => Make_Identifier (Loc, Chars (Scop)),\n+                   Selector_Name => Result);\n+            end if;\n+\n+            return Result;\n+         end Qualify_Type;\n+\n+         --  Local variables\n+\n+         Actuals : constant List_Id := Parameter_Associations (Func_Call);\n+\n+      --  Start of processing for Qualify_Universal_Operands\n+\n+      begin\n+         if Nkind (Op) in N_Binary_Op then\n+            Qualify_Operand (Left_Opnd  (Op), First (Actuals));\n+            Qualify_Operand (Right_Opnd (Op), Next (First (Actuals)));\n+\n+         elsif Nkind (Op) in N_Unary_Op then\n+            Qualify_Operand (Right_Opnd (Op), First (Actuals));\n+         end if;\n+      end Qualify_Universal_Operands;\n+\n       ------------------\n       -- Reset_Entity --\n       ------------------\n@@ -14716,21 +14832,30 @@ package body Sem_Ch12 is\n                Reset_Entity (N);\n \n             --  The analysis of the generic copy transformed the operator into\n-            --  some other construct. Propagate the changes to the template.\n+            --  some other construct. Propagate the changes to the template if\n+            --  applicable.\n \n             else\n                N2 := Get_Associated_Node (N);\n \n                --  The operator resoved to a function call\n \n                if Nkind (N2) = N_Function_Call then\n+\n+                  --  Add explicit qualifications in the generic template for\n+                  --  all operands of universal type. This aids resolution by\n+                  --  preserving the actual type of a literal or an attribute\n+                  --  that yields a universal result.\n+\n+                  Qualify_Universal_Operands (N, N2);\n+\n                   E := Entity (Name (N2));\n \n                   if Present (E) and then Is_Global (E) then\n                      Set_Etype (N, Etype (N2));\n                   else\n                      Set_Associated_Node (N, Empty);\n-                     Set_Etype (N, Empty);\n+                     Set_Etype           (N, Empty);\n                   end if;\n \n                --  The operator was folded into a literal"}, {"sha": "00405ab238b8354903bcc579d35e82fb421d9454", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 82, "deletions": 16, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "patch": "@@ -1316,13 +1316,13 @@ package body Sem_Type is\n       --  the generic. Within the instance the actual is represented by a\n       --  constructed subprogram renaming.\n \n-      function Matches (Actual, Formal : Node_Id) return Boolean;\n-      --  Look for exact type match in an instance, to remove spurious\n-      --  ambiguities when two formal types have the same actual.\n+      function Matches (Op : Node_Id; Func_Id : Entity_Id) return Boolean;\n+      --  Determine whether function Func_Id is an exact match for binary or\n+      --  unary operator Op.\n \n       function Operand_Type return Entity_Id;\n-      --  Determine type of operand for an equality operation, to apply\n-      --  Ada 2005 rules to equality on anonymous access types.\n+      --  Determine type of operand for an equality operation, to apply Ada\n+      --  2005 rules to equality on anonymous access types.\n \n       function Standard_Operator return Boolean;\n       --  Check whether subprogram is predefined operator declared in Standard.\n@@ -1412,14 +1412,82 @@ package body Sem_Type is\n       -- Matches --\n       -------------\n \n-      function Matches (Actual, Formal : Node_Id) return Boolean is\n-         T1 : constant Entity_Id := Etype (Actual);\n-         T2 : constant Entity_Id := Etype (Formal);\n+      function Matches (Op : Node_Id; Func_Id : Entity_Id) return Boolean is\n+         function Matching_Types\n+           (Opnd_Typ   : Entity_Id;\n+            Formal_Typ : Entity_Id) return Boolean;\n+         --  Determine whether operand type Opnd_Typ and formal parameter type\n+         --  Formal_Typ are either the same or compatible.\n+\n+         --------------------\n+         -- Matching_Types --\n+         --------------------\n+\n+         function Matching_Types\n+           (Opnd_Typ   : Entity_Id;\n+            Formal_Typ : Entity_Id) return Boolean\n+         is\n+         begin\n+            --  A direct match\n+\n+            if Opnd_Typ = Formal_Typ then\n+               return True;\n+\n+            --  Any integer type matches universal integer\n+\n+            elsif Opnd_Typ = Universal_Integer\n+              and then Is_Integer_Type (Formal_Typ)\n+            then\n+               return True;\n+\n+            --  Any floating point type matches universal real\n+\n+            elsif Opnd_Typ = Universal_Real\n+              and then Is_Floating_Point_Type (Formal_Typ)\n+            then\n+               return True;\n+\n+            --  The type of the formal parameter maps a generic actual type to\n+            --  a generic formal type. If the operand type is the type being\n+            --  mapped in an instance, then this is a match.\n+\n+            elsif Is_Generic_Actual_Type (Formal_Typ)\n+              and then Etype (Formal_Typ) = Opnd_Typ\n+            then\n+               return True;\n+\n+            --  ??? There are possibly other cases to consider\n+\n+            else\n+               return False;\n+            end if;\n+         end Matching_Types;\n+\n+         --  Local variables\n+\n+         F1      : constant Entity_Id := First_Formal (Func_Id);\n+         F1_Typ  : constant Entity_Id := Etype (F1);\n+         F2      : constant Entity_Id := Next_Formal (F1);\n+         F2_Typ  : constant Entity_Id := Etype (F2);\n+         Lop_Typ : constant Entity_Id := Etype (Left_Opnd  (Op));\n+         Rop_Typ : constant Entity_Id := Etype (Right_Opnd (Op));\n+\n+      --  Start of processing for Matches\n+\n       begin\n-         return T1 = T2\n-           or else\n-             (Is_Numeric_Type (T2)\n-               and then (T1 = Universal_Real or else T1 = Universal_Integer));\n+         if Lop_Typ = F1_Typ then\n+            return Matching_Types (Rop_Typ, F2_Typ);\n+\n+         elsif Rop_Typ = F2_Typ then\n+            return Matching_Types (Lop_Typ, F1_Typ);\n+\n+         --  Otherwise this is not a good match bechause each operand-formal\n+         --  pair is compatible only on base type basis which is not specific\n+         --  enough.\n+\n+         else\n+            return False;\n+         end if;\n       end Matches;\n \n       ------------------\n@@ -1697,6 +1765,7 @@ package body Sem_Type is\n \n       It1  := It;\n       Nam1 := It.Nam;\n+\n       while I /= I2 loop\n          Get_Next_Interp (I, It);\n       end loop;\n@@ -1967,10 +2036,7 @@ package body Sem_Type is\n                end;\n \n             elsif Nkind (N) in N_Binary_Op then\n-               if Matches (Left_Opnd (N), First_Formal (Nam1))\n-                 and then\n-                   Matches (Right_Opnd (N), Next_Formal (First_Formal (Nam1)))\n-               then\n+               if Matches (N, Nam1) then\n                   return It1;\n                else\n                   return It2;"}, {"sha": "4989409d67e670f24cce34e534be730e62b7271d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "patch": "@@ -20957,4 +20957,63 @@ package body Sem_Util is\n       end if;\n    end Yields_Synchronized_Object;\n \n+   ---------------------------\n+   -- Yields_Universal_Type --\n+   ---------------------------\n+\n+   function Yields_Universal_Type (N : Node_Id) return Boolean is\n+      Nam : Name_Id;\n+\n+   begin\n+      --  Integer and real literals are of a universal type\n+\n+      if Nkind_In (N, N_Integer_Literal, N_Real_Literal) then\n+         return True;\n+\n+      --  The values of certain attributes are of a universal type\n+\n+      elsif Nkind (N) = N_Attribute_Reference then\n+         Nam := Attribute_Name (N);\n+\n+         return\n+           Nam = Name_Aft\n+             or else Nam = Name_Alignment\n+             or else Nam = Name_Component_Size\n+             or else Nam = Name_Count\n+             or else Nam = Name_Delta\n+             or else Nam = Name_Digits\n+             or else Nam = Name_Exponent\n+             or else Nam = Name_First_Bit\n+             or else Nam = Name_Fore\n+             or else Nam = Name_Last_Bit\n+             or else Nam = Name_Length\n+             or else Nam = Name_Machine_Emax\n+             or else Nam = Name_Machine_Emin\n+             or else Nam = Name_Machine_Mantissa\n+             or else Nam = Name_Machine_Radix\n+             or else Nam = Name_Max_Alignment_For_Allocation\n+             or else Nam = Name_Max_Size_In_Storage_Elements\n+             or else Nam = Name_Model_Emin\n+             or else Nam = Name_Model_Epsilon\n+             or else Nam = Name_Model_Mantissa\n+             or else Nam = Name_Model_Small\n+             or else Nam = Name_Modulus\n+             or else Nam = Name_Pos\n+             or else Nam = Name_Position\n+             or else Nam = Name_Safe_First\n+             or else Nam = Name_Safe_Last\n+             or else Nam = Name_Scale\n+             or else Nam = Name_Size\n+             or else Nam = Name_Small\n+             or else Nam = Name_Wide_Wide_Width\n+             or else Nam = Name_Wide_Width\n+             or else Nam = Name_Width;\n+\n+      --  ??? There are possibly other cases to consider\n+\n+      else\n+         return False;\n+      end if;\n+   end Yields_Universal_Type;\n+\n end Sem_Util;"}, {"sha": "36cae436f04fe00e0b89e3ac957ffe31a14a8f3f", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c63aafa2e9b9854ee03481d33b8cc009c818e4e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=5c63aafa2e9b9854ee03481d33b8cc009c818e4e", "patch": "@@ -2295,4 +2295,7 @@ package Sem_Util is\n    --    * A synchronized interface type\n    --    * A task type\n \n+   function Yields_Universal_Type (N : Node_Id) return Boolean;\n+   --  Determine whether unanalyzed node N yields a universal type\n+\n end Sem_Util;"}]}