{"sha": "f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRmNGQwZjhmYjdjMWJmY2Q1Yzk3YmVlYTA1ZDE1ZWRlMDJlNWEyNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-10T00:56:56Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-10T00:56:56Z"}, "message": "read-rtl.c: Fix formatting.\n\n\t* read-rtl.c: Fix formatting.\n\t* real.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regrename.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* reload1.c: Likewise.\n\t* reload.c: Likewise.\n\t* rtl.c: Likewise.\n\nFrom-SVN: r48704", "tree": {"sha": "128e1e60a316c7721be28b666b9ba4f7130e4a88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/128e1e60a316c7721be28b666b9ba4f7130e4a88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/comments", "author": null, "committer": null, "parents": [{"sha": "54a8a50f804adc0ee5c30ed6e96150ec0c4c4375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54a8a50f804adc0ee5c30ed6e96150ec0c4c4375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54a8a50f804adc0ee5c30ed6e96150ec0c4c4375"}], "stats": {"total": 93, "additions": 52, "deletions": 41}, "files": [{"sha": "1989ac9569ffc13da690ca1c310ee1aaf64e14d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,3 +1,14 @@\n+2002-01-09  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* read-rtl.c: Fix formatting.\n+\t* real.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regrename.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* rtl.c: Likewise.\n+\n 2002-01-09  Kazu Hirata  <kazu@hxi.com>\n \n \t* rtlanal.c (find_reg_fusage): Use XEXP instead of SET_DEST"}, {"sha": "3c9b9f536d2ad20c2223b5614ca9eed78ad97085", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,5 +1,5 @@\n /* RTL reader for GNU C Compiler.\n-   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -396,7 +396,7 @@ atoll(p)\n       if (new_wide < tmp_wide)\n \t{\n \t  /* Return INT_MAX equiv on overflow.  */\n-\t  tmp_wide = (~(unsigned HOST_WIDE_INT)0) >> 1;\n+\t  tmp_wide = (~(unsigned HOST_WIDE_INT) 0) >> 1;\n \t  break;\n \t}\n       tmp_wide = new_wide;"}, {"sha": "3a125947546c2ba029e42341151534eacb2f40e6", "filename": "gcc/real.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,7 +1,7 @@\n /* real.c - implementation of REAL_ARITHMETIC, REAL_VALUE_ATOF,\n    and support for XFmode IEEE extended real floating point arithmetic.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2002 Free Software Foundation, Inc.\n    Contributed by Stephen L. Moshier (moshier@world.std.com).\n \n This file is part of GCC.\n@@ -272,7 +272,7 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n \tdo {\t\t\t\t\t\t\t\\\n \t  memcpy ((r), (e), 2*NE);\t\t\t\t\\\n \t  if (2*NE < sizeof(*r))\t\t\t\t\\\n-\t    memset ((char *)(r) + 2*NE, 0, sizeof(*r) - 2*NE);\t\\\n+\t    memset ((char *) (r) + 2*NE, 0, sizeof(*r) - 2*NE);\t\\\n \t} while (0)\n # else /* no XFmode */\n #  if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n@@ -284,7 +284,7 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n \tdo {\t\t\t\t\t\t\t\\\n \t  memcpy ((r), (e), 2*NE);\t\t\t\t\\\n \t  if (2*NE < sizeof(*r))\t\t\t\t\\\n-\t    memset ((char *)(r) + 2*NE, 0, sizeof(*r) - 2*NE);\t\\\n+\t    memset ((char *) (r) + 2*NE, 0, sizeof(*r) - 2*NE);\t\\\n \t} while (0)\n #else\n #define NE 6\n@@ -2423,7 +2423,7 @@ edivm (den, num)\n       tnum = (((unsigned EMULONG) num[M]) << 16) + num[M+1];\n \n       /* Do not execute the divide instruction if it will overflow.  */\n-      if ((tdenm * (unsigned long)0xffff) < tnum)\n+      if ((tdenm * (unsigned long) 0xffff) < tnum)\n \ttquot = 0xffff;\n       else\n \ttquot = tnum / tdenm;"}, {"sha": "a1c4187f6fcc6df0251bf57f592175f237fb1a04", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,6 +1,6 @@\n /* Register to Stack convert for GNU compiler.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -226,7 +226,7 @@ static rtx\n   FP_mode_reg[LAST_STACK_REG+1-FIRST_STACK_REG][(int) MAX_MACHINE_MODE];\n \n #define FP_MODE_REG(regno,mode)\t\\\n-  (FP_mode_reg[(regno)-FIRST_STACK_REG][(int)(mode)])\n+  (FP_mode_reg[(regno)-FIRST_STACK_REG][(int) (mode)])\n \n /* Used to initialize uninitialized registers.  */\n static rtx nan;\n@@ -1438,7 +1438,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n         }\n       /* ??? Uninitialized USE should not happen.  */\n       else if (get_hard_regnum (regstack, *src) == -1)\n-\tabort();\n+\tabort ();\n       break;\n \n     case CLOBBER:"}, {"sha": "95776382c94f21800da9f8032b00f30f50d6d782", "filename": "gcc/regclass.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,6 +1,6 @@\n /* Compute register class preferences for pseudo-registers.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996\n-   1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2305,9 +2305,9 @@ free_reg_info ()\n \t}\n \n       free (reg_pref_buffer);\n-      reg_pref_buffer = (struct reg_pref *)0;\n-      reg_info_head = (struct reg_info_data *)0;\n-      renumber = (short *)0;\n+      reg_pref_buffer = (struct reg_pref *) 0;\n+      reg_info_head = (struct reg_info_data *) 0;\n+      renumber = (short *) 0;\n     }\n   regno_allocated = 0;\n   reg_n_max = 0;"}, {"sha": "149fb247681941d09f6e19a8cb000cb5482ecbff", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,5 +1,5 @@\n /* Register renaming for the GNU compiler.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n "}, {"sha": "39960509af931328189841a932247e8f97d50954", "filename": "gcc/reload.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,6 +1,6 @@\n /* Search an insn for pseudo regs that must be in hard regs and are not.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -642,7 +642,7 @@ get_secondary_mem (x, mode, opnum, type)\n \t       : type == RELOAD_FOR_OUTPUT ? RELOAD_FOR_OUTPUT_ADDRESS\n \t       : RELOAD_OTHER);\n \n-      find_reloads_address (mode, (rtx*)0, XEXP (loc, 0), &XEXP (loc, 0),\n+      find_reloads_address (mode, (rtx*) 0, XEXP (loc, 0), &XEXP (loc, 0),\n \t\t\t    opnum, type, 0, 0);\n     }\n \n@@ -913,7 +913,7 @@ push_reload (in, out, inloc, outloc, class,\n \n       default:\n \tbreak;\n-    }\n+      }\n \n   /* If we are reloading a (SUBREG constant ...), really reload just the\n      inside expression in its own mode.  Similarly for (SUBREG (PLUS ...)).\n@@ -1047,7 +1047,7 @@ push_reload (in, out, inloc, outloc, class,\n \t order as the reloads.  Thus if the outer reload is also of type\n \t RELOAD_OTHER, we are guaranteed that this inner reload will be\n \t output before the outer reload.  */\n-      push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), (rtx *)0,\n+      push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), (rtx *) 0,\n \t\t   in_class, VOIDmode, VOIDmode, 0, 0, opnum, type);\n       dont_remove_subreg = 1;\n     }\n@@ -1925,7 +1925,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n       unsigned int regno = REGNO (in) + in_offset;\n       unsigned int nwords = HARD_REGNO_NREGS (regno, inmode);\n \n-      if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, (rtx*)0)\n+      if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, (rtx*) 0)\n \t  && ! hard_reg_set_here_p (regno, regno + nwords,\n \t\t\t\t    PATTERN (this_insn))\n \t  && (! earlyclobber\n@@ -2344,7 +2344,7 @@ immune_p (x, y, ydata)\n   struct decomposition xdata;\n \n   if (ydata.reg_flag)\n-    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, (rtx*)0);\n+    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, (rtx*) 0);\n   if (ydata.safe)\n     return 1;\n \n@@ -2623,7 +2623,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t;\n       else if (constraints[i][0] == 'p')\n \t{\n-\t  find_reloads_address (VOIDmode, (rtx*)0,\n+\t  find_reloads_address (VOIDmode, (rtx*) 0,\n \t\t\t\trecog_data.operand[i],\n \t\t\t\trecog_data.operand_loc[i],\n \t\t\t\ti, operand_type[i], ind_levels, insn);\n@@ -3685,7 +3685,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  {\n \t    operand_reloadnum[i]\n \t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n-\t\t\t     &XEXP (recog_data.operand[i], 0), (rtx*)0,\n+\t\t\t     &XEXP (recog_data.operand[i], 0), (rtx*) 0,\n \t\t\t     MODE_BASE_REG_CLASS (VOIDmode),\n \t\t\t     GET_MODE (XEXP (recog_data.operand[i], 0)),\n \t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n@@ -4568,7 +4568,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t      tem = make_memloc (ad, regno);\n \t      if (! strict_memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n \t\t{\n-\t\t  find_reloads_address (GET_MODE (tem), (rtx*)0, XEXP (tem, 0),\n+\t\t  find_reloads_address (GET_MODE (tem), (rtx*) 0, XEXP (tem, 0),\n \t\t\t\t\t&XEXP (tem, 0), opnum, ADDR_TYPE (type),\n \t\t\t\t\tind_levels, insn);\n \t\t}\n@@ -4617,7 +4617,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n-      push_reload (ad, NULL_RTX, loc, (rtx*)0, MODE_BASE_REG_CLASS (mode),\n+      push_reload (ad, NULL_RTX, loc, (rtx*) 0, MODE_BASE_REG_CLASS (mode),\n \t\t   GET_MODE (ad), VOIDmode, 0, 0, opnum, type);\n       return 1;\n     }\n@@ -4717,7 +4717,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t{\n \t  /* Must use TEM here, not AD, since it is the one that will\n \t     have any subexpressions reloaded, if needed.  */\n-\t  push_reload (tem, NULL_RTX, loc, (rtx*)0,\n+\t  push_reload (tem, NULL_RTX, loc, (rtx*) 0,\n \t\t       MODE_BASE_REG_CLASS (mode), GET_MODE (tem),\n \t\t       VOIDmode, 0,\n \t\t       0, opnum, type);\n@@ -5432,7 +5432,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t      else\n \t\t{\n \t\t  reloadnum\n-\t\t    = push_reload (x, NULL_RTX, loc, (rtx*)0,\n+\t\t    = push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t\t\t   (context ? INDEX_REG_CLASS :\n \t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n@@ -5473,7 +5473,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\tXEXP (XEXP (x, 0), 0), &XEXP (XEXP (x, 0), 0),\n \t\t\t\topnum, type, ind_levels, insn);\n \n-\t  reloadnum = push_reload (x, NULL_RTX, loc, (rtx*)0,\n+\t  reloadnum = push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t\t\t   (context ? INDEX_REG_CLASS :\n \t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n \t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n@@ -5503,7 +5503,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t    opnum, ADDR_TYPE (type), ind_levels, insn);\n-      push_reload (*loc, NULL_RTX, loc, (rtx*)0,\n+      push_reload (*loc, NULL_RTX, loc, (rtx*) 0,\n \t\t   (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n \t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n       return 1;\n@@ -5525,7 +5525,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t that feeds this insn.  */\n \tif (reg_equiv_mem[regno] != 0)\n \t  {\n-\t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, (rtx*)0,\n+\t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, (rtx*) 0,\n \t\t\t (context ? INDEX_REG_CLASS :\n \t\t\t  MODE_BASE_REG_CLASS (mode)),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n@@ -5554,7 +5554,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t     || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n \t\t  : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n \t  {\n-\t    push_reload (x, NULL_RTX, loc, (rtx*)0,\n+\t    push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n@@ -5566,7 +5566,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t   from before this insn to after it.  */\n \tif (regno_clobbered_p (regno, this_insn, GET_MODE (x), 0))\n \t  {\n-\t    push_reload (x, NULL_RTX, loc, (rtx*)0,\n+\t    push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n@@ -5587,7 +5587,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t      if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n \t\t     : REGNO_MODE_OK_FOR_BASE_P (regno, mode)))\n \t\t{\n-\t\t  push_reload (x, NULL_RTX, loc, (rtx*)0,\n+\t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t\t       (context ? INDEX_REG_CLASS :\n \t\t\t\tMODE_BASE_REG_CLASS (mode)),\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n@@ -5605,7 +5605,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t{\n \t\t  x = find_reloads_subreg_address (x, 0, opnum, type,\n \t\t\t\t\t\t   ind_levels, insn);\n-\t\t  push_reload (x, NULL_RTX, loc, (rtx*)0, class,\n+\t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0, class,\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n \t\t}\n@@ -5681,7 +5681,7 @@ find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n \t\t\t    opnum, type, ind_levels, 0);\n     }\n \n-  push_reload (x, NULL_RTX, loc, (rtx*)0, class,\n+  push_reload (x, NULL_RTX, loc, (rtx*) 0, class,\n \t       mode, VOIDmode, 0, 0, opnum, type);\n }\n \f\n@@ -6045,7 +6045,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n \t  if (reg_equiv_memory_loc[r])\n \t    return refers_to_regno_for_reload_p (regno, endregno,\n \t\t\t\t\t\t reg_equiv_memory_loc[r],\n-\t\t\t\t\t\t (rtx*)0);\n+\t\t\t\t\t\t (rtx*) 0);\n \n \t  if (reg_equiv_constant[r])\n \t    return 0;\n@@ -6191,7 +6191,7 @@ reg_overlap_mentioned_for_reload_p (x, in)\n   endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n \n-  return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*)0);\n+  return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*) 0);\n }\n \n /* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n@@ -6446,7 +6446,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n       && refers_to_regno_for_reload_p (valueno,\n \t\t\t\t       (valueno\n \t\t\t\t\t+ HARD_REGNO_NREGS (valueno, mode)),\n-\t\t\t\t       goal, (rtx*)0))\n+\t\t\t\t       goal, (rtx*) 0))\n     return 0;\n \n   /* Reject registers that overlap GOAL.  */"}, {"sha": "58449c0f3ff2e4e903c77632d46d0d882e5a0ebf", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,6 +1,6 @@\n /* Reload pseudo regs into hard regs for insns that require hard regs.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -4835,7 +4835,7 @@ reload_reg_free_for_value_p (start_regno, regno, opnum, type, value, out,\n       rtx reg = rld[i].reg_rtx;\n       if (reg && GET_CODE (reg) == REG\n \t  && ((unsigned) regno - true_regnum (reg)\n-\t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - (unsigned)1)\n+\t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - (unsigned) 1)\n \t  && i != reloadnum)\n \t{\n \t  rtx other_input = rld[i].in;"}, {"sha": "39b7ddb5c867807fa5f919053240e5506e7494e3", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=f4f4d0f8fb7c1bfcd5c97beea05d15ede02e5a26", "patch": "@@ -1,5 +1,5 @@\n /* RTL utility routines.\n-   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -180,7 +180,7 @@ const unsigned char mode_wider_mode[NUM_MACHINE_MODES] = {\n #undef DEF_MACHMODE\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  \\\n-  ((BITSIZE) >= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT)0 : ((unsigned HOST_WIDE_INT) 1 << (BITSIZE)) - 1,\n+  ((BITSIZE) >= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT) 0 : ((unsigned HOST_WIDE_INT) 1 << (BITSIZE)) - 1,\n \n /* Indexed by machine mode, gives mask of significant bits in mode.  */\n "}]}