{"sha": "f0517163a9b573e1e5858490d95787a48c8a4a10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA1MTcxNjNhOWI1NzNlMWU1ODU4NDkwZDk1Nzg3YTQ4YzhhNGExMA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-07T20:19:43Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-07T20:19:43Z"}, "message": "rs6000.c (struct processor_costs): Add new fields for simple floating point operations \"fp\"...\n\n\n\t* config/rs6000/rs6000.c (struct processor_costs): Add new fields\n\tfor simple floating point operations \"fp\", double precision\n\tmultiplication \"dmul\", and single and double precision division\n\t\"sdiv\" and \"ddiv\".  Update all CPU variant tables as appropriate.\n\t(ppc630_cost): New table split from ppc620_cost, to distinguish\n\tdifferences in floating point latencies.\n\t(rs6000_override_options): Use ppc630_cost for PROCESSOR_PPC630.\n\t(rs6000_rtx_costs): Add support for single and double precision\n\tfloating point addition, subtraction, multiplication, division,\n\tfused-multiply-add, fused-multiply-sub, negation, absolute value\n\tand negative absolute value.  Tweak MEM case to use prefered idiom.\n\nFrom-SVN: r84226", "tree": {"sha": "695c690ccd4077b3e039f00d90c5f77e390acb45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/695c690ccd4077b3e039f00d90c5f77e390acb45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0517163a9b573e1e5858490d95787a48c8a4a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0517163a9b573e1e5858490d95787a48c8a4a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0517163a9b573e1e5858490d95787a48c8a4a10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0517163a9b573e1e5858490d95787a48c8a4a10/comments", "author": null, "committer": null, "parents": [{"sha": "63b8825280dc6eac8ff82c577c15831a150c1c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b8825280dc6eac8ff82c577c15831a150c1c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b8825280dc6eac8ff82c577c15831a150c1c40"}], "stats": {"total": 164, "additions": 153, "deletions": 11}, "files": [{"sha": "f16f998e8485fbf4fa730c94591608b8ae14efcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0517163a9b573e1e5858490d95787a48c8a4a10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0517163a9b573e1e5858490d95787a48c8a4a10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0517163a9b573e1e5858490d95787a48c8a4a10", "patch": "@@ -1,3 +1,17 @@\n+2004-07-07  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* config/rs6000/rs6000.c (struct processor_costs): Add new fields\n+\tfor simple floating point operations \"fp\", double precision\n+\tmultiplication \"dmul\", and single and double precision division\n+\t\"sdiv\" and \"ddiv\".  Update all CPU variant tables as appropriate.\n+\t(ppc630_cost): New table split from ppc620_cost, to distinguish\n+\tdifferences in floating point latencies.\n+\t(rs6000_override_options): Use ppc630_cost for PROCESSOR_PPC630.\n+\t(rs6000_rtx_costs): Add support for single and double precision\n+\tfloating point addition, subtraction, multiplication, division,\n+\tfused-multiply-add, fused-multiply-sub, negation, absolute value\n+\tand negative absolute value.  Tweak MEM case to use prefered idiom.\n+\n 2004-07-07  Richard Henderson  <rth@redhat.com>\n \n \t* tree-flow-inline.h (may_propagate_copy): Move..."}, {"sha": "a0c7d10e9b786e929896b17842d36d0d6498915d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 139, "deletions": 11, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0517163a9b573e1e5858490d95787a48c8a4a10/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0517163a9b573e1e5858490d95787a48c8a4a10/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f0517163a9b573e1e5858490d95787a48c8a4a10", "patch": "@@ -292,6 +292,10 @@ struct processor_costs {\n   const int muldi;        /* cost of DImode multiplication.  */\n   const int divsi;        /* cost of SImode division.  */\n   const int divdi;        /* cost of DImode division.  */\n+  const int fp;           /* cost of simple SFmode and DFmode insns.  */\n+  const int dmul;         /* cost of DFmode multiplication (and fmadd).  */\n+  const int sdiv;         /* cost of SFmode division (fdivs).  */\n+  const int ddiv;         /* cost of DFmode division (fdiv).  */\n };\n \n const struct processor_costs *rs6000_cost;\n@@ -307,6 +311,10 @@ struct processor_costs size32_cost = {\n   1,    /* muldi */\n   1,    /* divsi */\n   1,    /* divdi */\n+  1,    /* fp */\n+  1,    /* dmul */\n+  1,    /* sdiv */\n+  1,    /* ddiv */\n };\n \n /* Instruction size costs on 64bit processors.  */\n@@ -318,6 +326,10 @@ struct processor_costs size64_cost = {\n   1,    /* muldi */\n   1,    /* divsi */\n   1,    /* divdi */\n+  1,    /* fp */\n+  1,    /* dmul */\n+  1,    /* sdiv */\n+  1,    /* ddiv */\n };\n \n /* Instruction costs on RIOS1 processors.  */\n@@ -329,6 +341,10 @@ struct processor_costs rios1_cost = {\n   5,    /* muldi */\n   19,   /* divsi */\n   19,   /* divdi */\n+  2,    /* fp */\n+  2,    /* dmul */\n+  19,   /* sdiv */\n+  19,   /* ddiv */\n };\n \n /* Instruction costs on RIOS2 processors.  */\n@@ -340,6 +356,10 @@ struct processor_costs rios2_cost = {\n   2,    /* muldi */\n   13,   /* divsi */\n   13,   /* divdi */\n+  2,    /* fp */\n+  2,    /* dmul */\n+  17,   /* sdiv */\n+  17,   /* ddiv */\n };\n \n /* Instruction costs on RS64A processors.  */\n@@ -351,6 +371,10 @@ struct processor_costs rs64a_cost = {\n   34,   /* muldi */\n   65,   /* divsi */\n   67,   /* divdi */\n+  4,    /* fp */\n+  4,    /* dmul */\n+  31,   /* sdiv */\n+  31,   /* ddiv */\n };\n \n /* Instruction costs on MPCCORE processors.  */\n@@ -362,6 +386,10 @@ struct processor_costs mpccore_cost = {\n   2,    /* muldi */\n   6,    /* divsi */\n   6,    /* divdi */\n+  4,    /* fp */\n+  5,    /* dmul */\n+  10,   /* sdiv */\n+  17,   /* ddiv */\n };\n \n /* Instruction costs on PPC403 processors.  */\n@@ -373,6 +401,10 @@ struct processor_costs ppc403_cost = {\n   4,    /* muldi */\n   33,   /* divsi */\n   33,   /* divdi */\n+  11,   /* fp */\n+  11,   /* dmul */\n+  11,   /* sdiv */\n+  11,   /* ddiv */\n };\n \n /* Instruction costs on PPC405 processors.  */\n@@ -384,6 +416,10 @@ struct processor_costs ppc405_cost = {\n   5,    /* muldi */\n   35,   /* divsi */\n   35,   /* divdi */\n+  11,   /* fp */\n+  11,   /* dmul */\n+  11,   /* sdiv */\n+  11,   /* ddiv */\n };\n \n /* Instruction costs on PPC440 processors.  */\n@@ -395,6 +431,10 @@ struct processor_costs ppc440_cost = {\n   3,    /* muldi */\n   34,   /* divsi */\n   34,   /* divdi */\n+  5,    /* fp */\n+  5,    /* dmul */\n+  19,   /* sdiv */\n+  33,   /* ddiv */\n };\n \n /* Instruction costs on PPC601 processors.  */\n@@ -406,6 +446,10 @@ struct processor_costs ppc601_cost = {\n   5,    /* muldi */\n   36,   /* divsi */\n   36,   /* divdi */\n+  4,    /* fp */\n+  5,    /* dmul */\n+  17,   /* sdiv */\n+  31,   /* ddiv */\n };\n \n /* Instruction costs on PPC603 processors.  */\n@@ -417,6 +461,10 @@ struct processor_costs ppc603_cost = {\n   5,    /* muldi */\n   37,   /* divsi */\n   37,   /* divdi */\n+  3,    /* fp */\n+  4,    /* dmul */\n+  18,   /* sdiv */\n+  33,   /* ddiv */\n };\n \n /* Instruction costs on PPC604 processors.  */\n@@ -428,6 +476,10 @@ struct processor_costs ppc604_cost = {\n   4,    /* muldi */\n   20,   /* divsi */\n   20,   /* divdi */\n+  3,    /* fp */\n+  3,    /* dmul */\n+  18,   /* sdiv */\n+  32,   /* ddiv */\n };\n \n /* Instruction costs on PPC604e processors.  */\n@@ -439,9 +491,13 @@ struct processor_costs ppc604e_cost = {\n   2,    /* muldi */\n   20,   /* divsi */\n   20,   /* divdi */\n+  3,    /* fp */\n+  3,    /* dmul */\n+  18,   /* sdiv */\n+  32,   /* ddiv */\n };\n \n-/* Instruction costs on PPC620 and PPC630 processors.  */\n+/* Instruction costs on PPC620 processors.  */\n static const\n struct processor_costs ppc620_cost = {\n   5,    /* mulsi */\n@@ -450,6 +506,25 @@ struct processor_costs ppc620_cost = {\n   7,    /* muldi */\n   21,   /* divsi */\n   37,   /* divdi */\n+  3,    /* fp */\n+  3,    /* dmul */\n+  18,   /* sdiv */\n+  32,   /* ddiv */\n+};\n+\n+/* Instruction costs on PPC630 processors.  */\n+static const\n+struct processor_costs ppc630_cost = {\n+  5,    /* mulsi */\n+  4,    /* mulsi_const */\n+  3,    /* mulsi_const9 */\n+  7,    /* muldi */\n+  21,   /* divsi */\n+  37,   /* divdi */\n+  3,    /* fp */\n+  3,    /* dmul */\n+  17,   /* sdiv */\n+  21,   /* ddiv */\n };\n \n /* Instruction costs on PPC750 and PPC7400 processors.  */\n@@ -461,6 +536,10 @@ struct processor_costs ppc750_cost = {\n   5,    /* muldi */\n   17,   /* divsi */\n   17,   /* divdi */\n+  3,    /* fp */\n+  3,    /* dmul */\n+  17,   /* sdiv */\n+  31,   /* ddiv */\n };\n \n /* Instruction costs on PPC7450 processors.  */\n@@ -472,6 +551,10 @@ struct processor_costs ppc7450_cost = {\n   4,    /* muldi */\n   23,   /* divsi */\n   23,   /* divdi */\n+  5,    /* fp */\n+  5,    /* dmul */\n+  21,   /* sdiv */\n+  35,   /* ddiv */\n };\n \n /* Instruction costs on PPC8540 processors.  */\n@@ -483,6 +566,10 @@ struct processor_costs ppc8540_cost = {\n   4,    /* muldi */\n   19,   /* divsi */\n   19,   /* divdi */\n+  4,    /* fp */\n+  4,    /* dmul */\n+  29,   /* sdiv */\n+  29,   /* ddiv */\n };\n \n /* Instruction costs on POWER4 and POWER5 processors.  */\n@@ -494,6 +581,10 @@ struct processor_costs power4_cost = {\n   4,    /* muldi */\n   18,   /* divsi */\n   34,   /* divdi */\n+  3,    /* fp */\n+  3,    /* dmul */\n+  17,   /* sdiv */\n+  17,   /* ddiv */\n };\n \n \f\n@@ -1370,10 +1461,13 @@ rs6000_override_options (const char *default_cpu)\n \tbreak;\n \n       case PROCESSOR_PPC620:\n-      case PROCESSOR_PPC630:\n \trs6000_cost = &ppc620_cost;\n \tbreak;\n \n+      case PROCESSOR_PPC630:\n+\trs6000_cost = &ppc630_cost;\n+\tbreak;\n+\n       case PROCESSOR_PPC750:\n       case PROCESSOR_PPC7400:\n \trs6000_cost = &ppc750_cost;\n@@ -16419,6 +16513,8 @@ static bool\n rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, \n \t\t  int *total)\n {\n+  enum machine_mode mode = GET_MODE (x);\n+\n   switch (code)\n     {\n       /* On the RS/6000, if it is valid in the insn, it is free.\n@@ -16433,16 +16529,30 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n       return true;\n \n     case PLUS:\n-      *total = ((GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t\t && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1))\n-\t\t\t\t\t       + 0x8000) >= 0x10000)\n-\t\t && ((INTVAL (XEXP (x, 1)) & 0xffff) != 0))\n-\t\t? COSTS_N_INSNS (2)\n-\t\t: COSTS_N_INSNS (1));\n+      if (mode == DFmode)\n+\t*total = GET_CODE (XEXP (x, 0)) == MULT\n+\t\t ? COSTS_N_INSNS (rs6000_cost->dmul)\n+\t\t : COSTS_N_INSNS (rs6000_cost->fp);\n+      else if (mode == SFmode)\n+\t*total = COSTS_N_INSNS (rs6000_cost->fp);\n+      else\n+\t*total = ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t  && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1))\n+\t\t\t\t\t\t+ 0x8000) >= 0x10000)\n+\t\t  && ((INTVAL (XEXP (x, 1)) & 0xffff) != 0))\n+\t\t ? COSTS_N_INSNS (2)\n+\t\t : COSTS_N_INSNS (1));\n       return true;\n \n     case MINUS:\n-      *total = COSTS_N_INSNS (1);\n+      if (mode == DFmode)\n+\t*total = GET_CODE (XEXP (x, 0)) == MULT\n+\t\t ? COSTS_N_INSNS (rs6000_cost->dmul)\n+\t\t : COSTS_N_INSNS (rs6000_cost->fp);\n+      else if (mode == SFmode)\n+\t*total = COSTS_N_INSNS (rs6000_cost->fp);\n+      else\n+        *total = COSTS_N_INSNS (1);\n       return true;\n \n     case AND:\n@@ -16464,14 +16574,24 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t  else\n \t    *total = COSTS_N_INSNS (rs6000_cost->mulsi_const);\n \t}\n-      else if (GET_MODE (XEXP (x, 1)) == DImode)\n+      else if (mode == DFmode)\n+\t*total = COSTS_N_INSNS (rs6000_cost->dmul);\n+      else if (mode == SFmode)\n+\t*total = COSTS_N_INSNS (rs6000_cost->fp);\n+      else if (mode == DImode)\n \t*total = COSTS_N_INSNS (rs6000_cost->muldi);\n       else\n \t*total = COSTS_N_INSNS (rs6000_cost->mulsi);\n       return true;\n \n     case DIV:\n     case MOD:\n+      if (FLOAT_MODE_P (mode))\n+\t{\n+\t  *total = mode == DFmode ? COSTS_N_INSNS (rs6000_cost->ddiv)\n+\t\t\t\t  : COSTS_N_INSNS (rs6000_cost->sdiv);\n+\t  return true;\n+\t}\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n \t{\n@@ -16492,9 +16612,17 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n       *total = COSTS_N_INSNS (4);\n       return true;\n \n+    case NEG:\n+    case ABS:\n+      if (FLOAT_MODE_P (mode))\n+\t*total = COSTS_N_INSNS (rs6000_cost->fp);\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n     case MEM:\n       /* MEM should be slightly more expensive than (plus (reg) (const)).  */\n-      *total = 5;\n+      *total = COSTS_N_INSNS (1) + 1;\n       return true;\n \n     default:"}]}