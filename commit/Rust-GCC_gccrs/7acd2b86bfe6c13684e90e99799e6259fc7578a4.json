{"sha": "7acd2b86bfe6c13684e90e99799e6259fc7578a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjZDJiODZiZmU2YzEzNjg0ZTkwZTk5Nzk5ZTYyNTlmYzc1NzhhNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-07-23T20:26:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-07-23T20:26:09Z"}, "message": "runtime: Support cgo callbacks from threads started by C.\n\nThis adjusts the extram support to work with gccgo.  There are\nsome corresponding changes to cgo in\nhttps://codereview.appspot.com/11406047/ .\n\nFrom-SVN: r201179", "tree": {"sha": "9fd65c56b9fe79df84a03e848ee2e499acd32e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fd65c56b9fe79df84a03e848ee2e499acd32e15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7acd2b86bfe6c13684e90e99799e6259fc7578a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7acd2b86bfe6c13684e90e99799e6259fc7578a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7acd2b86bfe6c13684e90e99799e6259fc7578a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7acd2b86bfe6c13684e90e99799e6259fc7578a4/comments", "author": null, "committer": null, "parents": [{"sha": "fb48aadc7876cd39a7503265aa822706a674e4ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb48aadc7876cd39a7503265aa822706a674e4ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb48aadc7876cd39a7503265aa822706a674e4ed"}], "stats": {"total": 151, "additions": 131, "deletions": 20}, "files": [{"sha": "9ba1ea7d042e11ec3303dd6b3c82d1432b248736", "filename": "libgo/runtime/go-cgo.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fgo-cgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fgo-cgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cgo.c?ref=7acd2b86bfe6c13684e90e99799e6259fc7578a4", "patch": "@@ -35,6 +35,9 @@ syscall_cgocall ()\n   M* m;\n   G* g;\n \n+  if (runtime_needextram && runtime_cas (&runtime_needextram, 1, 0))\n+    runtime_newextram ();\n+\n   m = runtime_m ();\n   ++m->ncgocall;\n   g = runtime_g ();\n@@ -71,15 +74,40 @@ syscall_cgocalldone ()\n void\n syscall_cgocallback ()\n {\n+  M *mp;\n+\n+  mp = runtime_m ();\n+  if (mp == NULL)\n+    {\n+      runtime_needm ();\n+      mp = runtime_m ();\n+      mp->dropextram = true;\n+    }\n+\n   runtime_exitsyscall ();\n+\n+  mp = runtime_m ();\n+  if (mp->needextram)\n+    {\n+      mp->needextram = 0;\n+      runtime_newextram ();\n+    }\n }\n \n /* Prepare to return to C/C++ code from a callback to Go code.  */\n \n void\n syscall_cgocallbackdone ()\n {\n+  M *mp;\n+\n   runtime_entersyscall ();\n+  mp = runtime_m ();\n+  if (mp->dropextram && runtime_g ()->ncgo == 0)\n+    {\n+      mp->dropextram = false;\n+      runtime_dropm ();\n+    }\n }\n \n /* Allocate memory and save it in a list visible to the Go garbage"}, {"sha": "3955e0f5cee6a8a9129ff0c141f9ca153fa0d17a", "filename": "libgo/runtime/go-defer.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fgo-defer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fgo-defer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-defer.c?ref=7acd2b86bfe6c13684e90e99799e6259fc7578a4", "patch": "@@ -42,6 +42,7 @@ __go_undefer (_Bool *frame)\n     {\n       struct __go_defer_stack *d;\n       void (*pfn) (void *);\n+      M *m;\n \n       d = g->defer;\n       pfn = d->__pfn;\n@@ -51,7 +52,14 @@ __go_undefer (_Bool *frame)\n \t(*pfn) (d->__arg);\n \n       g->defer = d->__next;\n-      __go_free (d);\n+\n+      /* This may be called by a cgo callback routine to defer the\n+\t call to syscall.CgocallBackDone, in which case we will not\n+\t have a memory context.  Don't try to free anything in that\n+\t case--the GC will release it later.  */\n+      m = runtime_m ();\n+      if (m != NULL && m->mcache != NULL)\n+\t__go_free (d);\n \n       /* Since we are executing a defer function here, we know we are\n \t returning from the calling function.  If the calling"}, {"sha": "7e284eeaa3d01eedd6ecb2f1cc46d284ed971e02", "filename": "libgo/runtime/go-panic.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fgo-panic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fgo-panic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.c?ref=7acd2b86bfe6c13684e90e99799e6259fc7578a4", "patch": "@@ -54,6 +54,7 @@ __go_panic (struct __go_empty_interface arg)\n     {\n       struct __go_defer_stack *d;\n       void (*pfn) (void *);\n+      M *m;\n \n       d = g->defer;\n       if (d == NULL)\n@@ -95,7 +96,14 @@ __go_panic (struct __go_empty_interface arg)\n \t}\n \n       g->defer = d->__next;\n-      __go_free (d);\n+\n+      /* This may be called by a cgo callback routine to defer the\n+\t call to syscall.CgocallBackDone, in which case we will not\n+\t have a memory context.  Don't try to free anything in that\n+\t case--the GC will release it later.  */\n+      m = runtime_m ();\n+      if (m != NULL && m->mcache != NULL)\n+\t__go_free (d);\n     }\n \n   /* The panic was not recovered.  */"}, {"sha": "d42ff3362ee8acf0e9b11f25af924c2387ba8b00", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 81, "deletions": 18, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=7acd2b86bfe6c13684e90e99799e6259fc7578a4", "patch": "@@ -397,7 +397,8 @@ enum { MaxGomaxprocs = 1<<8 };\n Sched\truntime_sched;\n int32\truntime_gomaxprocs;\n bool\truntime_singleproc;\n-bool\truntime_iscgo;\n+bool\truntime_iscgo = true;\n+uint32\truntime_needextram = 1;\n uint32\truntime_gcwaiting;\n M\truntime_m0;\n G\truntime_g0;\t // idle goroutine for m0\n@@ -901,8 +902,8 @@ runtime_mstart(void* mp)\n \n #ifdef USING_SPLIT_STACK\n \t{\n-\t  int dont_block_signals = 0;\n-\t  __splitstack_block_signals(&dont_block_signals, nil);\n+\t\tint dont_block_signals = 0;\n+\t\t__splitstack_block_signals(&dont_block_signals, nil);\n \t}\n #endif\n \n@@ -944,7 +945,7 @@ struct CgoThreadStart\n // Allocate a new m unassociated with any thread.\n // Can use p for allocation context if needed.\n M*\n-runtime_allocm(P *p)\n+runtime_allocm(P *p, int32 stacksize, byte** ret_g0_stack, size_t* ret_g0_stacksize)\n {\n \tM *mp;\n \n@@ -961,7 +962,7 @@ runtime_allocm(P *p)\n \n \tmp = runtime_mal(sizeof *mp);\n \tmcommoninit(mp);\n-\tmp->g0 = runtime_malg(-1, nil, nil);\n+\tmp->g0 = runtime_malg(stacksize, ret_g0_stack, ret_g0_stacksize);\n \n \tif(p == m->p)\n \t\treleasep();\n@@ -1006,6 +1007,9 @@ static void unlockextra(M*);\n //\n // When the callback is done with the m, it calls dropm to\n // put the m back on the list.\n+//\n+// Unlike the gc toolchain, we start running on curg, since we are\n+// just going to return and let the caller continue.\n void\n runtime_needm(void)\n {\n@@ -1027,18 +1031,40 @@ runtime_needm(void)\n \tmp->needextram = mp->schedlink == nil;\n \tunlockextra(mp->schedlink);\n \n-\t// Install m and g (= m->g0) and set the stack bounds\n-\t// to match the current stack. We don't actually know\n-\t// how big the stack is, like we don't know how big any\n-\t// scheduling stack is, but we assume there's at least 32 kB,\n-\t// which is more than enough for us.\n-\truntime_setmg(mp, mp->g0);\n+\t// Install m and g (= m->curg).\n+\truntime_setmg(mp, mp->curg);\n \n-\t// We assume that the split stack support has been initialized\n-\t// for this new thread.\n+\t// Initialize g's context as in mstart.\n+\tinitcontext();\n+\tg->status = Gsyscall;\n+\tg->entry = nil;\n+\tg->param = nil;\n+#ifdef USING_SPLIT_STACK\n+\t__splitstack_getcontext(&g->stack_context[0]);\n+#else\n+\tg->gcinitial_sp = &mp;\n+\tg->gcstack_size = 0;\n+\tg->gcnext_sp = &mp;\n+#endif\n+\tgetcontext(&g->context);\n+\n+\tif(g->entry != nil) {\n+\t\t// Got here from mcall.\n+\t\tvoid (*pfn)(G*) = (void (*)(G*))g->entry;\n+\t\tG* gp = (G*)g->param;\n+\t\tpfn(gp);\n+\t\t*(int*)0x22 = 0x22;\n+\t}\n \n \t// Initialize this thread to use the m.\n \truntime_minit();\n+\n+#ifdef USING_SPLIT_STACK\n+\t{\n+\t\tint dont_block_signals = 0;\n+\t\t__splitstack_block_signals(&dont_block_signals, nil);\n+\t}\n+#endif\n }\n \n // newextram allocates an m and puts it on the extra list.\n@@ -1049,15 +1075,17 @@ runtime_newextram(void)\n {\n \tM *mp, *mnext;\n \tG *gp;\n+\tbyte *g0_sp, *sp;\n+\tsize_t g0_spsize, spsize;\n \n \t// Create extra goroutine locked to extra m.\n \t// The goroutine is the context in which the cgo callback will run.\n \t// The sched.pc will never be returned to, but setting it to\n \t// runtime.goexit makes clear to the traceback routines where\n \t// the goroutine stack ends.\n-\tmp = runtime_allocm(nil);\n-\tgp = runtime_malg(StackMin, nil, nil);\n-\tgp->status = Gsyscall;\n+\tmp = runtime_allocm(nil, StackMin, &g0_sp, &g0_spsize);\n+\tgp = runtime_malg(StackMin, &sp, &spsize);\n+\tgp->status = Gdead;\n \tmp->curg = gp;\n \tmp->locked = LockInternal;\n \tmp->lockedg = gp;\n@@ -1072,6 +1100,16 @@ runtime_newextram(void)\n \truntime_unlock(&runtime_sched);\n \tgp->goid = runtime_xadd64(&runtime_sched.goidgen, 1);\n \n+\t// The context for gp will be set up in runtime_needm.  But\n+\t// here we need to set up the context for g0.\n+\tgetcontext(&mp->g0->context);\n+\tmp->g0->context.uc_stack.ss_sp = g0_sp;\n+#ifdef MAKECONTEXT_STACK_TOP\n+\tmp->g0->context.uc_stack.ss_sp += g0_spsize;\n+#endif\n+\tmp->g0->context.uc_stack.ss_size = g0_spsize;\n+\tmakecontext(&mp->g0->context, kickoff, 0);\n+\n \t// Add m to the extra list.\n \tmnext = lockextra(true);\n \tmp->schedlink = mnext;\n@@ -1114,6 +1152,8 @@ runtime_dropm(void)\n \tmp = m;\n \truntime_setmg(nil, nil);\n \n+\tmp->curg->status = Gdead;\n+\n \tmnext = lockextra(true);\n \tmp->schedlink = mnext;\n \tunlockextra(mp);\n@@ -1159,14 +1199,37 @@ unlockextra(M *mp)\n \truntime_atomicstorep(&runtime_extram, mp);\n }\n \n+static int32\n+countextra()\n+{\n+\tM *mp, *mc;\n+\tint32 c;\n+\n+\tfor(;;) {\n+\t\tmp = runtime_atomicloadp(&runtime_extram);\n+\t\tif(mp == MLOCKED) {\n+\t\t\truntime_osyield();\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif(!runtime_casp(&runtime_extram, mp, MLOCKED)) {\n+\t\t\truntime_osyield();\n+\t\t\tcontinue;\n+\t\t}\n+\t\tc = 0;\n+\t\tfor(mc = mp; mc != nil; mc = mc->schedlink)\n+\t\t\tc++;\n+\t\truntime_atomicstorep(&runtime_extram, mp);\n+\t\treturn c;\n+\t}\n+}\n \n // Create a new m.  It will start off with a call to fn, or else the scheduler.\n static void\n newm(void(*fn)(void), P *p)\n {\n \tM *mp;\n \n-\tmp = runtime_allocm(p);\n+\tmp = runtime_allocm(p, -1, nil, nil);\n \tmp->nextp = p;\n \tmp->mstartfn = fn;\n \n@@ -2348,7 +2411,7 @@ checkdead(void)\n \tint32 run, grunning, s;\n \n \t// -1 for sysmon\n-\trun = runtime_sched.mcount - runtime_sched.nmidle - runtime_sched.mlocked - 1;\n+\trun = runtime_sched.mcount - runtime_sched.nmidle - runtime_sched.mlocked - 1 - countextra();\n \tif(run > 0)\n \t\treturn;\n \tif(run < 0) {"}, {"sha": "78fd388186a147b121a5c376e1aaa1d6fa31a40e", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acd2b86bfe6c13684e90e99799e6259fc7578a4/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=7acd2b86bfe6c13684e90e99799e6259fc7578a4", "patch": "@@ -273,6 +273,7 @@ struct\tM\n \tGCStats\tgcstats;\n \tbool\tracecall;\n \tbool\tneedextram;\n+\tbool\tdropextram;\t// for gccgo: drop after call is done.\n \tvoid*\tracepc;\n \tvoid\t(*waitunlockf)(Lock*);\n \tvoid*\twaitlock;\n@@ -450,6 +451,7 @@ extern\tG*\truntime_lastg;\n extern\tM*\truntime_allm;\n extern\tP**\truntime_allp;\n extern\tint32\truntime_gomaxprocs;\n+extern\tuint32\truntime_needextram;\n extern\tbool\truntime_singleproc;\n extern\tuint32\truntime_panicking;\n extern\tuint32\truntime_gcwaiting;\t\t// gc is waiting to run\n@@ -518,6 +520,8 @@ G*\truntime_malg(int32, byte**, size_t*);\n void\truntime_mpreinit(M*);\n void\truntime_minit(void);\n void\truntime_unminit(void);\n+void\truntime_needm(void);\n+void\truntime_dropm(void);\n void\truntime_signalstack(byte*, int32);\n MCache*\truntime_allocmcache(void);\n void\truntime_freemcache(MCache*);"}]}