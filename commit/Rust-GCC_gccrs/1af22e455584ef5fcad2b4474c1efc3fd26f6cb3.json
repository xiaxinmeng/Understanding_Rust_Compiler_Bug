{"sha": "1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFmMjJlNDU1NTg0ZWY1ZmNhZDJiNDQ3NGMxZWZjM2ZkMjZmNmNiMw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-06-14T11:01:24Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-06-14T11:01:24Z"}, "message": "When avoiding double deallocation, look at namespace, expression and component.\n\nOur finalization handling is a mess.  Really, we should get to try and get\nthis fixed for gcc 11.\n\nIn the meantime, here is a patch which fixes a regression I introduced\nwhen fixing a regression with a memory leak.  The important thing\nhere is to realize that we do not need to finalize (and deallocate)\nmultiple times for the same expression and the same component\nin the same namespace.  It might cause code size regressions, but\nbetter big code than wrong code...\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/94109\n\t* class.c (finalize_component): Return early if finalization has\n\talready happened for expression and component within namespace.\n\t* gfortran.h (gfc_was_finalized): New type.\n\t(gfc_namespace): Add member was_finalzed.\n\t(gfc_expr): Remove finalized.\n\t* symbol.c (gfc_free_namespace): Free was_finalized.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/94109\n\t* gfortran.dg/finalize_34.f90: Adjust free counts.\n\t* gfortran.dg/finalize_36.f90: New test.", "tree": {"sha": "769ed6b4561d0635ea175b5a1b496690efc39c75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/769ed6b4561d0635ea175b5a1b496690efc39c75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/comments", "author": null, "committer": null, "parents": [{"sha": "275bef5fbae9d1e22885c581cfbe6fc5248ca8ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/275bef5fbae9d1e22885c581cfbe6fc5248ca8ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/275bef5fbae9d1e22885c581cfbe6fc5248ca8ad"}], "stats": {"total": 89, "additions": 82, "deletions": 7}, "files": [{"sha": "cfc450283fae942a3365fda64cda78aa40836ec9", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "patch": "@@ -920,12 +920,18 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n {\n   gfc_expr *e;\n   gfc_ref *ref;\n+  gfc_was_finalized *f;\n \n   if (!comp_is_finalizable (comp))\n     return;\n \n-  if (expr->finalized)\n-    return;\n+  /* If this expression with this component has been finalized\n+     already in this namespace, there is nothing to do.  */\n+  for (f = sub_ns->was_finalized; f; f = f->next)\n+    {\n+      if (f->e == expr && f->c == comp)\n+\treturn;\n+    }\n \n   e = gfc_copy_expr (expr);\n   if (!e->ref)\n@@ -1055,7 +1061,13 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n \t\t\t    sub_ns);\n       gfc_free_expr (e);\n     }\n-  expr->finalized = 1;\n+\n+  /* Record that this was finalized already in this namespace.  */\n+  f = sub_ns->was_finalized;\n+  sub_ns->was_finalized = XCNEW (gfc_was_finalized);\n+  sub_ns->was_finalized->e = expr;\n+  sub_ns->was_finalized->c = comp;\n+  sub_ns->was_finalized->next = f;\n }\n \n "}, {"sha": "c12a8bef27720df0dd84a83b5aa1ee08296bf6ec", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "patch": "@@ -1774,6 +1774,16 @@ gfc_oacc_routine_name;\n \n #define gfc_get_oacc_routine_name() XCNEW (gfc_oacc_routine_name)\n \n+/* Node in linked list to see what has already been finalized\n+   earlier.  */\n+\n+typedef struct gfc_was_finalized {\n+  gfc_expr *e;\n+  gfc_component *c;\n+  struct gfc_was_finalized *next;\n+}\n+gfc_was_finalized;\n+\n /* A namespace describes the contents of procedure, module, interface block\n    or BLOCK construct.  */\n /* ??? Anything else use these?  */\n@@ -1866,6 +1876,11 @@ typedef struct gfc_namespace\n   /* Linked list of !$omp declare simd constructs.  */\n   struct gfc_omp_declare_simd *omp_declare_simd;\n \n+  /* A hash set for the the gfc expressions that have already\n+     been finalized in this namespace.  */\n+\n+  gfc_was_finalized *was_finalized;\n+\n   /* Set to 1 if namespace is a BLOCK DATA program unit.  */\n   unsigned is_block_data:1;\n \n@@ -2218,9 +2233,6 @@ typedef struct gfc_expr\n   /* Set this if the expression came from expanding an array constructor.  */\n   unsigned int from_constructor : 1;\n \n-  /* Set this if the expression has already been finalized.  */\n-  unsigned int finalized : 1;\n-\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from"}, {"sha": "ba388ff598d3eb2acdb1e8926b9a9c7d8c82064b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "patch": "@@ -4017,6 +4017,7 @@ gfc_free_namespace (gfc_namespace *ns)\n {\n   gfc_namespace *p, *q;\n   int i;\n+  gfc_was_finalized *f;\n \n   if (ns == NULL)\n     return;\n@@ -4049,6 +4050,17 @@ gfc_free_namespace (gfc_namespace *ns)\n     gfc_free_interface (ns->op[i]);\n \n   gfc_free_data (ns->data);\n+\n+  /* Free all the expr + component combinations that have been\n+     finalized.  */\n+  f = ns->was_finalized;\n+  while (f)\n+    {\n+      gfc_was_finalized* current = f;\n+      f = f->next;\n+      free (current);\n+    }\n+\n   p = ns->contained;\n   free (ns);\n "}, {"sha": "8fb801d42357a2f117fd96260c804df43ed76221", "filename": "gcc/testsuite/gfortran.dg/finalize_34.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_34.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_34.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_34.f90?ref=1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "patch": "@@ -22,4 +22,4 @@ program main\n   use testmodule\n   type(evtlist_type), dimension(10) :: a\n end program main\n-! { dg-final  { scan-tree-dump-times \"__builtin_free\" 12 \"original\" } }\n+! { dg-final  { scan-tree-dump-times \"__builtin_free\" 24 \"original\" } }"}, {"sha": "432f5472aebc2256323b1010832c290de71795d3", "filename": "gcc/testsuite/gfortran.dg/finalize_36.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_36.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af22e455584ef5fcad2b4474c1efc3fd26f6cb3/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_36.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_36.f90?ref=1af22e455584ef5fcad2b4474c1efc3fd26f6cb3", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! PR 94109\n+! This used to leak memory.  Test case by Antony Lewis.\n+    module debug\n+    implicit none\n+\n+    Type Tester\n+        real, dimension(:), allocatable :: Dat, Dat2\n+    end Type\n+\n+    Type TestType2\n+        Type(Tester) :: T\n+    end type TestType2\n+\n+    contains\n+\n+    subroutine Leaker\n+    class(TestType2), pointer :: ActiveState\n+    Type(Tester) :: Temp\n+\n+    allocate(Temp%Dat2(10000))\n+\n+    allocate(TestType2::ActiveState)\n+    ActiveState%T = Temp\n+    deallocate(ActiveState)\n+\n+    end subroutine\n+\n+    end module\n+\n+\n+    program run\n+    use debug\n+\n+    call Leaker()\n+\n+    end program\n+! { dg-final { scan-tree-dump-times \"__builtin_free\\\\ \\\\(ptr2\" 4 \"original\" } }"}]}