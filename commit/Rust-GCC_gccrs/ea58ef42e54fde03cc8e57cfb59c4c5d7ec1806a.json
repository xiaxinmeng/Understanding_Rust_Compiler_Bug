{"sha": "ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE1OGVmNDJlNTRmZGUwM2NjOGU1N2NmYjU5YzRjNWQ3ZWMxODA2YQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2014-05-09T17:50:25Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2014-05-09T17:50:25Z"}, "message": "re PR c/61096 (error_init lacks a location)\n\n\tPR c/61096\n\t* c-parser.c (c_parser_braced_init): Pass brace_loc to push_init_level.\n\t(c_parser_initelt): Pass location to set_init_label.  Pass array index\n\tlocation to set_init_index.\n\t* c-tree.h (push_init_level): Update declaration.\n\t(pop_init_level): Likewise.\n\t(set_init_index): Likewise.\n\t(set_init_label): Likewise.\n\t* c-typeck.c (error_init): Add location parameter.  Call error_at\n\tinstead of error.\n\t(digest_init): Pass init_loc to error_init.\n\t(really_start_incremental_init):\n\t(push_init_level): Add location parameter.  Pass loc to pop_init_level\n\tand error_init.\n\t(pop_init_level): Likewise.\n\t(set_designator): Add location parameter.  Pass loc to pop_init_level,\n\tpush_init_level, and error_init.\n\t(set_init_index): Add location parameter.  Pass loc to error_init and\n\tset_designator.\n\t(set_init_label): Likewise.\n\t(output_init_element): Pass loc to error_init.\n\t(process_init_element): Pass loc to error_init, pop_init_level,\n\tpedwarn_init, and push_init_level.\n\n\t* gcc.dg/pr61096-1.c: New test.\n\t* gcc.dg/pr61096-2.c: New test.\n\nFrom-SVN: r210280", "tree": {"sha": "cd6331ec639c692e7b4cbb94402526fdfa70a6b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd6331ec639c692e7b4cbb94402526fdfa70a6b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f61140c2a7c3ade3c0ccd0514c3136efc2c0b18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f61140c2a7c3ade3c0ccd0514c3136efc2c0b18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f61140c2a7c3ade3c0ccd0514c3136efc2c0b18"}], "stats": {"total": 259, "additions": 189, "deletions": 70}, "files": [{"sha": "8c71d372bd697309b8e90902b00f8c61f8ba4962", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "patch": "@@ -1,3 +1,29 @@\n+2014-05-09  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/61096\n+\t* c-parser.c (c_parser_braced_init): Pass brace_loc to push_init_level.\n+\t(c_parser_initelt): Pass location to set_init_label.  Pass array index\n+\tlocation to set_init_index.\n+\t* c-tree.h (push_init_level): Update declaration.\n+\t(pop_init_level): Likewise.\n+\t(set_init_index): Likewise.\n+\t(set_init_label): Likewise.\n+\t* c-typeck.c (error_init): Add location parameter.  Call error_at\n+\tinstead of error.\n+\t(digest_init): Pass init_loc to error_init.\n+\t(really_start_incremental_init):\n+\t(push_init_level): Add location parameter.  Pass loc to pop_init_level\n+\tand error_init.\n+\t(pop_init_level): Likewise.\n+\t(set_designator): Add location parameter.  Pass loc to pop_init_level,\n+\tpush_init_level, and error_init.\n+\t(set_init_index): Add location parameter.  Pass loc to error_init and\n+\tset_designator.\n+\t(set_init_label): Likewise.\n+\t(output_init_element): Pass loc to error_init.\n+\t(process_init_element): Pass loc to error_init, pop_init_level,\n+\tpedwarn_init, and push_init_level.\n+\n 2014-05-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/50459"}, {"sha": "432bf96522828e41ca6f679d18c7d5be509e9ee7", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "patch": "@@ -4143,7 +4143,7 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));\n   c_parser_consume_token (parser);\n   if (nested_p)\n-    push_init_level (0, &braced_init_obstack);\n+    push_init_level (brace_loc, 0, &braced_init_obstack);\n   else\n     really_start_incremental_init (type);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -4173,12 +4173,12 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, \"expected %<}%>\");\n-      pop_init_level (0, &braced_init_obstack);\n+      pop_init_level (brace_loc, 0, &braced_init_obstack);\n       obstack_free (&braced_init_obstack, NULL);\n       return ret;\n     }\n   c_parser_consume_token (parser);\n-  ret = pop_init_level (0, &braced_init_obstack);\n+  ret = pop_init_level (brace_loc, 0, &braced_init_obstack);\n   obstack_free (&braced_init_obstack, NULL);\n   return ret;\n }\n@@ -4195,7 +4195,8 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n       && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n     {\n       /* Old-style structure member designator.  */\n-      set_init_label (c_parser_peek_token (parser)->value,\n+      set_init_label (c_parser_peek_token (parser)->location,\n+\t\t      c_parser_peek_token (parser)->value,\n \t\t      braced_init_obstack);\n       /* Use the colon as the error location.  */\n       pedwarn (c_parser_peek_2nd_token (parser)->location, OPT_Wpedantic,\n@@ -4224,7 +4225,7 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t      c_parser_consume_token (parser);\n \t      if (c_parser_next_token_is (parser, CPP_NAME))\n \t\t{\n-\t\t  set_init_label (c_parser_peek_token (parser)->value,\n+\t\t  set_init_label (des_loc, c_parser_peek_token (parser)->value,\n \t\t\t\t  braced_init_obstack);\n \t\t  c_parser_consume_token (parser);\n \t\t}\n@@ -4245,6 +4246,7 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t    {\n \t      tree first, second;\n \t      location_t ellipsis_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n+\t      location_t array_index_loc = UNKNOWN_LOCATION;\n \t      /* ??? Following the old parser, [ objc-receiver\n \t\t objc-message-args ] is accepted as an initializer,\n \t\t being distinguished from a designator by what follows\n@@ -4322,6 +4324,7 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t\t  return;\n \t\t}\n \t      c_parser_consume_token (parser);\n+\t      array_index_loc = c_parser_peek_token (parser)->location;\n \t      first = c_parser_expr_no_commas (parser, NULL).value;\n \t      mark_exp_read (first);\n \t    array_desig_after_first:\n@@ -4337,7 +4340,8 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \t\t{\n \t\t  c_parser_consume_token (parser);\n-\t\t  set_init_index (first, second, braced_init_obstack);\n+\t\t  set_init_index (array_index_loc, first, second,\n+\t\t\t\t  braced_init_obstack);\n \t\t  if (second)\n \t\t    pedwarn (ellipsis_loc, OPT_Wpedantic,\n \t\t\t     \"ISO C forbids specifying range of elements to initialize\");"}, {"sha": "ae932faf8086a1ed188ebe3e71b72600b60a1628", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "patch": "@@ -606,10 +606,10 @@ extern void maybe_warn_string_init (tree, struct c_expr);\n extern void start_init (tree, tree, int);\n extern void finish_init (void);\n extern void really_start_incremental_init (tree);\n-extern void push_init_level (int, struct obstack *);\n-extern struct c_expr pop_init_level (int, struct obstack *);\n-extern void set_init_index (tree, tree, struct obstack *);\n-extern void set_init_label (tree, struct obstack *);\n+extern void push_init_level (location_t, int, struct obstack *);\n+extern struct c_expr pop_init_level (location_t, int, struct obstack *);\n+extern void set_init_index (location_t, tree, tree, struct obstack *);\n+extern void set_init_label (location_t, tree, struct obstack *);\n extern void process_init_element (location_t, struct c_expr, bool,\n \t\t\t\t  struct obstack *);\n extern tree build_compound_literal (location_t, tree, tree, bool);"}, {"sha": "67988012372097b28b485e8b389944000d2542ae", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "patch": "@@ -106,7 +106,7 @@ static tree digest_init (location_t, tree, tree, tree, bool, bool, int);\n static void output_init_element (location_t, tree, tree, bool, tree, tree, int,\n \t\t\t\t bool, struct obstack *);\n static void output_pending_init_elements (int, struct obstack *);\n-static int set_designator (int, struct obstack *);\n+static int set_designator (location_t, int, struct obstack *);\n static void push_range_stack (tree, struct obstack *);\n static void add_pending_init (location_t, tree, tree, tree, bool,\n \t\t\t      struct obstack *);\n@@ -5545,15 +5545,15 @@ convert_to_anonymous_field (location_t location, tree type, tree rhs)\n    The component name is taken from the spelling stack.  */\n \n static void\n-error_init (const char *gmsgid)\n+error_init (location_t loc, const char *gmsgid)\n {\n   char *ofwhat;\n \n   /* The gmsgid may be a format string with %< and %>. */\n-  error (gmsgid);\n+  error_at (loc, gmsgid);\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    error (\"(near initialization for %qs)\", ofwhat);\n+    error_at (loc, \"(near initialization for %qs)\", ofwhat);\n }\n \n /* Issue a pedantic warning for a bad initializer component.  OPT is\n@@ -6555,22 +6555,23 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t    {\n \t      if (typ2 != char_type_node)\n \t\t{\n-\t\t  error_init (\"char-array initialized from wide string\");\n+\t\t  error_init (init_loc, \"char-array initialized from wide \"\n+\t\t\t      \"string\");\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (typ2 == char_type_node)\n \t\t{\n-\t\t  error_init (\"wide character array initialized from non-wide \"\n-\t\t\t      \"string\");\n+\t\t  error_init (init_loc, \"wide character array initialized \"\n+\t\t\t      \"from non-wide string\");\n \t\t  return error_mark_node;\n \t\t}\n \t      else if (!comptypes(typ1, typ2))\n \t\t{\n-\t\t  error_init (\"wide character array initialized from \"\n-\t\t\t      \"incompatible wide string\");\n+\t\t  error_init (init_loc, \"wide character array initialized \"\n+\t\t\t      \"from incompatible wide string\");\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n@@ -6603,7 +6604,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t}\n       else if (INTEGRAL_TYPE_P (typ1))\n \t{\n-\t  error_init (\"array of inappropriate type initialized \"\n+\t  error_init (init_loc, \"array of inappropriate type initialized \"\n \t\t      \"from string constant\");\n \t  return error_mark_node;\n \t}\n@@ -6671,7 +6672,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t\t  (init_loc, inside_init);\n \t      else\n \t\t{\n-\t\t  error_init (\"invalid use of non-lvalue array\");\n+\t\t  error_init (init_loc, \"invalid use of non-lvalue array\");\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n@@ -6697,7 +6698,8 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n       if (code == ARRAY_TYPE && TREE_CODE (inside_init) != STRING_CST\n \t  && TREE_CODE (inside_init) != CONSTRUCTOR)\n \t{\n-\t  error_init (\"array initialized from non-constant array expression\");\n+\t  error_init (init_loc, \"array initialized from non-constant array \"\n+\t\t      \"expression\");\n \t  return error_mark_node;\n \t}\n \n@@ -6711,7 +6713,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t    = valid_compound_expr_initializer (inside_init,\n \t\t\t\t\t       TREE_TYPE (inside_init));\n \t  if (inside_init == error_mark_node)\n-\t    error_init (\"initializer element is not constant\");\n+\t    error_init (init_loc, \"initializer element is not constant\");\n \t  else\n \t    pedwarn_init (init_loc, OPT_Wpedantic,\n \t\t\t  \"initializer element is not constant\");\n@@ -6722,7 +6724,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t       && !initializer_constant_valid_p (inside_init,\n \t\t\t\t\t\t TREE_TYPE (inside_init)))\n \t{\n-\t  error_init (\"initializer element is not constant\");\n+\t  error_init (init_loc, \"initializer element is not constant\");\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant && !maybe_const)\n@@ -6762,14 +6764,15 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t;\n       else if (require_constant && !TREE_CONSTANT (inside_init))\n \t{\n-\t  error_init (\"initializer element is not constant\");\n+\t  error_init (init_loc, \"initializer element is not constant\");\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant\n \t       && !initializer_constant_valid_p (inside_init,\n \t\t\t\t\t\t TREE_TYPE (inside_init)))\n \t{\n-\t  error_init (\"initializer element is not computable at load time\");\n+\t  error_init (init_loc, \"initializer element is not computable at \"\n+\t\t      \"load time\");\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant && !maybe_const)\n@@ -6783,11 +6786,11 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \n   if (COMPLETE_TYPE_P (type) && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n-      error_init (\"variable-sized object may not be initialized\");\n+      error_init (init_loc, \"variable-sized object may not be initialized\");\n       return error_mark_node;\n     }\n \n-  error_init (\"invalid initializer\");\n+  error_init (init_loc, \"invalid initializer\");\n   return error_mark_node;\n }\n \f\n@@ -7165,7 +7168,8 @@ really_start_incremental_init (tree type)\n    IMPLICIT is 1 (or 2 if the push is because of designator list).  */\n \n void\n-push_init_level (int implicit, struct obstack * braced_init_obstack)\n+push_init_level (location_t loc, int implicit,\n+\t\t struct obstack *braced_init_obstack)\n {\n   struct constructor_stack *p;\n   tree value = NULL_TREE;\n@@ -7184,14 +7188,14 @@ push_init_level (int implicit, struct obstack * braced_init_obstack)\n \t       || TREE_CODE (constructor_type) == UNION_TYPE)\n \t      && constructor_fields == 0)\n \t    process_init_element (input_location,\n-\t\t\t\t  pop_init_level (1, braced_init_obstack),\n+\t\t\t\t  pop_init_level (loc, 1, braced_init_obstack),\n \t\t\t\t  true, braced_init_obstack);\n \t  else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n \t\t   && constructor_max_index\n \t\t   && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t       constructor_index))\n \t    process_init_element (input_location,\n-\t\t\t\t  pop_init_level (1, braced_init_obstack),\n+\t\t\t\t  pop_init_level (loc, 1, braced_init_obstack),\n \t\t\t\t  true, braced_init_obstack);\n \t  else\n \t    break;\n@@ -7281,7 +7285,7 @@ push_init_level (int implicit, struct obstack * braced_init_obstack)\n \n   if (constructor_type == 0)\n     {\n-      error_init (\"extra brace group at end of initializer\");\n+      error_init (loc, \"extra brace group at end of initializer\");\n       constructor_fields = 0;\n       constructor_unfilled_fields = 0;\n       return;\n@@ -7382,7 +7386,8 @@ push_init_level (int implicit, struct obstack * braced_init_obstack)\n    Otherwise, return a CONSTRUCTOR expression as the value.  */\n \n struct c_expr\n-pop_init_level (int implicit, struct obstack * braced_init_obstack)\n+pop_init_level (location_t loc, int implicit,\n+\t\tstruct obstack *braced_init_obstack)\n {\n   struct constructor_stack *p;\n   struct c_expr ret;\n@@ -7396,7 +7401,7 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n \t pop any inner levels that didn't have explicit braces.  */\n       while (constructor_stack->implicit)\n \tprocess_init_element (input_location,\n-\t\t\t      pop_init_level (1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n \t\t\t      true, braced_init_obstack);\n       gcc_assert (!constructor_range_stack);\n     }\n@@ -7423,7 +7428,7 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n \t  gcc_assert (!TYPE_SIZE (constructor_type));\n \n \t  if (constructor_depth > 2)\n-\t    error_init (\"initialization of flexible array member in a nested context\");\n+\t    error_init (loc, \"initialization of flexible array member in a nested context\");\n \t  else\n \t    pedwarn_init (input_location, OPT_Wpedantic,\n \t\t\t  \"initialization of a flexible array member\");\n@@ -7485,12 +7490,12 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n       if (vec_safe_is_empty (constructor_elements))\n \t{\n \t  if (!constructor_erroneous)\n-\t    error_init (\"empty scalar initializer\");\n+\t    error_init (loc, \"empty scalar initializer\");\n \t  ret.value = error_mark_node;\n \t}\n       else if (vec_safe_length (constructor_elements) != 1)\n \t{\n-\t  error_init (\"extra elements in scalar initializer\");\n+\t  error_init (loc, \"extra elements in scalar initializer\");\n \t  ret.value = (*constructor_elements)[0].value;\n \t}\n       else\n@@ -7553,7 +7558,8 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n    ARRAY argument is nonzero for array ranges.  Returns zero for success.  */\n \n static int\n-set_designator (int array, struct obstack * braced_init_obstack)\n+set_designator (location_t loc, int array,\n+\t\tstruct obstack *braced_init_obstack)\n {\n   tree subtype;\n   enum tree_code subcode;\n@@ -7576,7 +7582,7 @@ set_designator (int array, struct obstack * braced_init_obstack)\n \t braces.  */\n       while (constructor_stack->implicit)\n \tprocess_init_element (input_location,\n-\t\t\t      pop_init_level (1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n \t\t\t      true, braced_init_obstack);\n       constructor_designated = 1;\n       return 0;\n@@ -7600,17 +7606,17 @@ set_designator (int array, struct obstack * braced_init_obstack)\n   subcode = TREE_CODE (subtype);\n   if (array && subcode != ARRAY_TYPE)\n     {\n-      error_init (\"array index in non-array initializer\");\n+      error_init (loc, \"array index in non-array initializer\");\n       return 1;\n     }\n   else if (!array && subcode != RECORD_TYPE && subcode != UNION_TYPE)\n     {\n-      error_init (\"field name not in record or union initializer\");\n+      error_init (loc, \"field name not in record or union initializer\");\n       return 1;\n     }\n \n   constructor_designated = 1;\n-  push_init_level (2, braced_init_obstack);\n+  push_init_level (loc, 2, braced_init_obstack);\n   return 0;\n }\n \n@@ -7643,18 +7649,18 @@ push_range_stack (tree range_end, struct obstack * braced_init_obstack)\n    of indices, running from FIRST through LAST.  */\n \n void\n-set_init_index (tree first, tree last,\n+set_init_index (location_t loc, tree first, tree last,\n \t\tstruct obstack * braced_init_obstack)\n {\n-  if (set_designator (1, braced_init_obstack))\n+  if (set_designator (loc, 1, braced_init_obstack))\n     return;\n \n   designator_erroneous = 1;\n \n   if (!INTEGRAL_TYPE_P (TREE_TYPE (first))\n       || (last && !INTEGRAL_TYPE_P (TREE_TYPE (last))))\n     {\n-      error_init (\"array index in initializer not of integer type\");\n+      error_init (loc, \"array index in initializer not of integer type\");\n       return;\n     }\n \n@@ -7677,16 +7683,16 @@ set_init_index (tree first, tree last,\n     }\n \n   if (TREE_CODE (first) != INTEGER_CST)\n-    error_init (\"nonconstant array index in initializer\");\n+    error_init (loc, \"nonconstant array index in initializer\");\n   else if (last != 0 && TREE_CODE (last) != INTEGER_CST)\n-    error_init (\"nonconstant array index in initializer\");\n+    error_init (loc, \"nonconstant array index in initializer\");\n   else if (TREE_CODE (constructor_type) != ARRAY_TYPE)\n-    error_init (\"array index in non-array initializer\");\n+    error_init (loc, \"array index in non-array initializer\");\n   else if (tree_int_cst_sgn (first) == -1)\n-    error_init (\"array index in initializer exceeds array bounds\");\n+    error_init (loc, \"array index in initializer exceeds array bounds\");\n   else if (constructor_max_index\n \t   && tree_int_cst_lt (constructor_max_index, first))\n-    error_init (\"array index in initializer exceeds array bounds\");\n+    error_init (loc, \"array index in initializer exceeds array bounds\");\n   else\n     {\n       constant_expression_warning (first);\n@@ -7705,7 +7711,7 @@ set_init_index (tree first, tree last,\n \t    last = 0;\n \t  else if (tree_int_cst_lt (last, first))\n \t    {\n-\t      error_init (\"empty index range in initializer\");\n+\t      error_init (loc, \"empty index range in initializer\");\n \t      last = 0;\n \t    }\n \t  else\n@@ -7714,7 +7720,8 @@ set_init_index (tree first, tree last,\n \t      if (constructor_max_index != 0\n \t\t  && tree_int_cst_lt (constructor_max_index, last))\n \t\t{\n-\t\t  error_init (\"array index range in initializer exceeds array bounds\");\n+\t\t  error_init (loc, \"array index range in initializer exceeds \"\n+\t\t\t      \"array bounds\");\n \t\t  last = 0;\n \t\t}\n \t    }\n@@ -7730,19 +7737,20 @@ set_init_index (tree first, tree last,\n /* Within a struct initializer, specify the next field to be initialized.  */\n \n void\n-set_init_label (tree fieldname, struct obstack * braced_init_obstack)\n+set_init_label (location_t loc, tree fieldname,\n+\t\tstruct obstack *braced_init_obstack)\n {\n   tree field;\n \n-  if (set_designator (0, braced_init_obstack))\n+  if (set_designator (loc, 0, braced_init_obstack))\n     return;\n \n   designator_erroneous = 1;\n \n   if (TREE_CODE (constructor_type) != RECORD_TYPE\n       && TREE_CODE (constructor_type) != UNION_TYPE)\n     {\n-      error_init (\"field name not in record or union initializer\");\n+      error_init (loc, \"field name not in record or union initializer\");\n       return;\n     }\n \n@@ -7761,7 +7769,7 @@ set_init_label (tree fieldname, struct obstack * braced_init_obstack)\n \tfield = TREE_CHAIN (field);\n \tif (field)\n \t  {\n-\t    if (set_designator (0, braced_init_obstack))\n+\t    if (set_designator (loc, 0, braced_init_obstack))\n \t      return;\n \t  }\n       }\n@@ -8261,7 +8269,7 @@ output_init_element (location_t loc, tree value, tree origtype,\n     {\n       if (require_constant_value)\n \t{\n-\t  error_init (\"initializer element is not constant\");\n+\t  error_init (loc, \"initializer element is not constant\");\n \t  value = error_mark_node;\n \t}\n       else if (require_constant_elements)\n@@ -8582,14 +8590,14 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n       && integer_zerop (constructor_unfilled_index))\n     {\n       if (constructor_stack->replacement_value.value)\n-\terror_init (\"excess elements in char array initializer\");\n+\terror_init (loc, \"excess elements in char array initializer\");\n       constructor_stack->replacement_value = value;\n       return;\n     }\n \n   if (constructor_stack->replacement_value.value != 0)\n     {\n-      error_init (\"excess elements in struct initializer\");\n+      error_init (loc, \"excess elements in struct initializer\");\n       return;\n     }\n \n@@ -8605,14 +8613,16 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n       if ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t   || TREE_CODE (constructor_type) == UNION_TYPE)\n \t  && constructor_fields == 0)\n-\tprocess_init_element (loc, pop_init_level (1, braced_init_obstack),\n+\tprocess_init_element (loc,\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n \t\t\t      true, braced_init_obstack);\n       else if ((TREE_CODE (constructor_type) == ARRAY_TYPE\n \t        || TREE_CODE (constructor_type) == VECTOR_TYPE)\n \t       && constructor_max_index\n \t       && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t   constructor_index))\n-\tprocess_init_element (loc, pop_init_level (1, braced_init_obstack),\n+\tprocess_init_element (loc,\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n \t\t\t      true, braced_init_obstack);\n       else\n \tbreak;\n@@ -8649,8 +8659,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \n \t  if (constructor_fields == 0)\n \t    {\n-\t      pedwarn_init (input_location, 0,\n-\t\t\t    \"excess elements in struct initializer\");\n+\t      pedwarn_init (loc, 0, \"excess elements in struct initializer\");\n \t      break;\n \t    }\n \n@@ -8665,7 +8674,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t      && TYPE_SIZE (fieldtype) == NULL_TREE\n \t      && DECL_CHAIN (constructor_fields) == NULL_TREE)\n \t    {\n-\t      error_init (\"non-static initialization of a flexible array member\");\n+\t      error_init (loc, \"non-static initialization of a flexible \"\n+\t\t\t  \"array member\");\n \t      break;\n \t    }\n \n@@ -8683,7 +8693,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n \t\t       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))\n \t    {\n-\t      push_init_level (1, braced_init_obstack);\n+\t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n \t    }\n \n@@ -8775,7 +8785,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n \t\t       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))\n \t    {\n-\t      push_init_level (1, braced_init_obstack);\n+\t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n \t    }\n \n@@ -8817,7 +8827,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n \t\t       || eltcode == UNION_TYPE || eltcode == VECTOR_TYPE))\n \t    {\n-\t      push_init_level (1, braced_init_obstack);\n+\t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n \t    }\n \n@@ -8918,7 +8928,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t    {\n \t      gcc_assert (constructor_stack->implicit);\n \t      process_init_element (loc,\n-\t\t\t\t    pop_init_level (1, braced_init_obstack),\n+\t\t\t\t    pop_init_level (loc, 1,\n+\t\t\t\t\t\t    braced_init_obstack),\n \t\t\t\t    true, braced_init_obstack);\n \t    }\n \t  for (p = range_stack;\n@@ -8927,7 +8938,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t    {\n \t      gcc_assert (constructor_stack->implicit);\n \t      process_init_element (loc,\n-\t\t\t\t    pop_init_level (1, braced_init_obstack),\n+\t\t\t\t    pop_init_level (loc, 1,\n+\t\t\t\t\t\t    braced_init_obstack),\n \t\t\t\t    true, braced_init_obstack);\n \t    }\n \n@@ -8948,7 +8960,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t      p = p->next;\n \t      if (!p)\n \t\tbreak;\n-\t      push_init_level (2, braced_init_obstack);\n+\t      push_init_level (loc, 2, braced_init_obstack);\n \t      p->stack = constructor_stack;\n \t      if (p->range_end && tree_int_cst_equal (p->index, p->range_end))\n \t\tp->index = p->range_start;"}, {"sha": "88f207a9f33560a8c5a8a073a6834436ed590858", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "patch": "@@ -1,3 +1,9 @@\n+2014-05-09  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/61096\n+\t* gcc.dg/pr61096-1.c: New test.\n+\t* gcc.dg/pr61096-2.c: New test.\n+\n 2014-05-09  Florian Weimer  <fweimer@redhat.com>\n \n \t* gcc.dg/fstack-protector-strong.c: Add coverage for return slots."}, {"sha": "3f7d60c0e5dd98beb872c55655dbc8f4a3ace76d", "filename": "gcc/testsuite/gcc.dg/pr61096-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-1.c?ref=ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "patch": "@@ -0,0 +1,61 @@\n+/* PR c/61077 */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -fshort-enums -fshort-wchar -Wpedantic\" } */\n+/* { dg-prune-output \".*near initialization for.*\" } */\n+\n+typedef enum { A } schar;\n+extern int e;\n+struct S\n+{\n+  int a[3];\n+};\n+struct f\n+{\n+  int w;\n+  int x[];\n+};\n+struct g\n+{\n+  struct f f; /* { dg-warning \"invalid use of structure with flexible array member\" } */\n+};\n+\n+char w1[] = L\"foo\"; /* { dg-error \"13:char-array initialized from wide string\" } */\n+__WCHAR_TYPE__ w2[] = \"foo\"; /* { dg-error \"23:wide character array initialized from non-wide string\" } */\n+__WCHAR_TYPE__ w3[] = U\"foo\"; /* { dg-error \"23:wide character array initialized from incompatible wide string\" } */\n+schar a1[] = \"foo\"; /* { dg-error \"14:array of inappropriate type initialized from string constant\" } */\n+int a2[] = (int[]) { 1 }; /* { dg-error \"12:array initialized from non-constant array expression\" } */\n+\n+int a3 = e; /* { dg-error \"10:initializer element is not constant\" } */\n+int a4 = (e, 1); /* { dg-error \"10:initializer element is not constant\" } */\n+int a5 = a1[0]; /* { dg-error \"10:initializer element is not constant\" } */\n+int a6 = &a3 - &a4; /* { dg-error \"10:initializer element is not\" } */\n+int a7[] = a7; /* { dg-error \"12:invalid initializer\" } */\n+\n+struct S s = { { 1 }, { 3 } }; /* { dg-error \"23:extra brace group at end of initializer\" } */\n+/* { dg-warning \"23:excess elements in struct initializer\" \"\" { target *-*-* } 34 } */\n+struct g g1 = { {0, { 1 } } }; /* { dg-error \"21:initialization of flexible array member in a nested context\" } */\n+struct g g2 = { .f[0] = 1 }; /* { dg-error \"20:array index in non-array initializer\" } */\n+\n+__extension__ int a8 = { }; /* { dg-error \"24:empty scalar initializer\" } */\n+int a9[10] = {[1.2] = 2 }; /* { dg-error \"16:array index in initializer not of integer type\" } */\n+int a10[10] = {[e] = 2 }; /* { dg-error \"17:nonconstant array index in initializer\" } */\n+__extension__ int a11[10] = {[1 ... e] = 1 }; /* { dg-error \"31:nonconstant array index in initializer\" } */\n+int a12 = {[1] = 2 }; /* { dg-error \"13:array index in non-array initializer\" } */\n+int a13[2] = {[-1] = 4 }; /* { dg-error \"16:array index in initializer exceeds array bounds\" } */\n+int a14[2] = {[64] = 4 }; /* { dg-error \"16:array index in initializer exceeds array bounds\" } */\n+__extension__ int a15[10] = {[2 ... 1] = 4 }; /* { dg-error \"31:empty index range in initializer\" } */\n+__extension__ int a16[10] = {[2 ... 100] = 4 }; /* { dg-error \"31:array index range in initializer exceeds array bounds\" } */\n+int a17[] = { .B = 1 }; /* { dg-error \"15:field name not in record or union initializer\" } */\n+int a18[] = { e }; /* { dg-error \"15:initializer element is not constant\" } */\n+char a19[1] = { \"x\", \"x\" }; /* { dg-error \"22:excess elements in char array initializer\" } */\n+\n+void\n+bar (void)\n+{\n+  struct f f = { 2, \"c\" }; /* { dg-error \"21:non-static initialization of a flexible array member\" } */\n+}\n+\n+struct\n+{\n+  char *v;\n+} sx[] = { .v = 0 }; /* { dg-error \"12:field name not in record or union initializer\" } */"}, {"sha": "fbea4d9db6bcc062e60643abb0b3f10580c42d3f", "filename": "gcc/testsuite/gcc.dg/pr61096-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-2.c?ref=ea58ef42e54fde03cc8e57cfb59c4c5d7ec1806a", "patch": "@@ -0,0 +1,10 @@\n+/* PR c/61077 */\n+/* { dg-do compile } */\n+\n+struct s { char c[1]; };\n+extern struct s foo (void);\n+void\n+bar (void)\n+{\n+  char *t = (foo ()).c; /* { dg-error \"13:invalid use of non-lvalue array\" } */\n+}"}]}