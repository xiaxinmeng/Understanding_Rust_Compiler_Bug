{"sha": "83584eab1b561ac4be25da110c20d2d92371b9df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM1ODRlYWIxYjU2MWFjNGJlMjVkYTExMGMyMGQyZDkyMzcxYjlkZg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-04-15T12:43:15Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-04-15T12:43:15Z"}, "message": "PR 56919 Improve SYSTEM_CLOCK intrinsic on Windows.\n\nfrontend ChangeLog:\n\n2013-04-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/56919\n\t* intrinsics.texi (SYSTEM_CLOCK): Update documentation.\n\n\nlibgfortran ChangeLog:\n\n2013-04-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/56919\n\t* intrinsics/time_1.h: Check __CYGWIN__ in addition to\n\t__MINGW32__.\n\t* intrinsics/system_clock.c (GF_CLOCK_MONOTONIC): Check\n\t_POSIX_MONOTONIC_CLOCK as well.\n\t(system_clock_4): Use GetTickCount on Windows.\n\t(system_clock_8): Use QueryPerformanceCounter and\n\tQueryPerformanceCounterFrequency on Windows.\n\nFrom-SVN: r197968", "tree": {"sha": "de4249db60be7d49eb149f5d7ed57db6d0670016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de4249db60be7d49eb149f5d7ed57db6d0670016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83584eab1b561ac4be25da110c20d2d92371b9df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83584eab1b561ac4be25da110c20d2d92371b9df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83584eab1b561ac4be25da110c20d2d92371b9df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83584eab1b561ac4be25da110c20d2d92371b9df/comments", "author": null, "committer": null, "parents": [{"sha": "1c50eadaae42490efff780b9b68123a952d34f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c50eadaae42490efff780b9b68123a952d34f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c50eadaae42490efff780b9b68123a952d34f57"}], "stats": {"total": 129, "additions": 103, "deletions": 26}, "files": [{"sha": "012d531bdeb6c42d6cc2146d7a45160477f6680d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83584eab1b561ac4be25da110c20d2d92371b9df/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83584eab1b561ac4be25da110c20d2d92371b9df/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=83584eab1b561ac4be25da110c20d2d92371b9df", "patch": "@@ -1,3 +1,8 @@\n+2013-04-15  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/56919\n+\t* intrinsics.texi (SYSTEM_CLOCK): Update documentation.\n+\n 2013-04-15  Tobias Burnus  <burnus@net-b.de>\n \n \t* class.c (gfc_find_intrinsic_vtab): Removed unused var."}, {"sha": "d5ff9a048dcd0014e4df1db50297b4348c8951b1", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83584eab1b561ac4be25da110c20d2d92371b9df/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83584eab1b561ac4be25da110c20d2d92371b9df/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=83584eab1b561ac4be25da110c20d2d92371b9df", "patch": "@@ -12038,27 +12038,38 @@ and should considered in new code for future portability.\n @item @emph{Description}:\n Determines the @var{COUNT} of a processor clock since an unspecified\n time in the past modulo @var{COUNT_MAX}, @var{COUNT_RATE} determines\n-the number of clock ticks per second.  If the platform supports a high\n-resolution monotonic clock, that clock is used and can provide up to\n-nanosecond resolution.  If a high resolution monotonic clock is not\n-available, the implementation falls back to a potentially lower\n-resolution realtime clock.\n-\n-@var{COUNT_RATE} is system dependent and can vary depending on the kind of the\n-arguments. For @var{kind=4} arguments, @var{COUNT} usually represents\n-milliseconds, while for @var{kind=8} arguments, @var{COUNT} typically\n-represents micro- or nanoseconds. @var{COUNT_MAX} usually equals\n-@code{HUGE(COUNT_MAX)}.\n-\n-If there is no clock, @var{COUNT} is set to @code{-HUGE(COUNT)}, and\n-@var{COUNT_RATE} and @var{COUNT_MAX} are set to zero.\n-\n-When running on a platform using the GNU C library (glibc), or a\n-derivative thereof, the high resolution monotonic clock is available\n-only when linking with the @var{rt} library.  This can be done\n-explicitly by adding the @code{-lrt} flag when linking the\n+the number of clock ticks per second.  If the platform supports a\n+monotonic clock, that clock is used and can, depending on the platform\n+clock implementation, provide up to nanosecond resolution.  If a\n+monotonic clock is not available, the implementation falls back to a\n+realtime clock.\n+\n+@var{COUNT_RATE} is system dependent and can vary depending on the\n+kind of the arguments. For @var{kind=4} arguments, @var{COUNT}\n+represents milliseconds, while for @var{kind=8} arguments, @var{COUNT}\n+typically represents micro- or nanoseconds depending on resolution of\n+the underlying platform clock. @var{COUNT_MAX} usually equals\n+@code{HUGE(COUNT_MAX)}. Note that the millisecond resolution of the\n+@var{kind=4} version implies that the @var{COUNT} will wrap around in\n+roughly 25 days. In order to avoid issues with the wrap around and for\n+more precise timing, please use the @var{kind=4} version.\n+\n+If there is no clock, or querying the clock fails, @var{COUNT} is set\n+to @code{-HUGE(COUNT)}, and @var{COUNT_RATE} and @var{COUNT_MAX} are\n+set to zero.\n+\n+When running on a platform using the GNU C library (glibc) version\n+2.16 or older, or a derivative thereof, the high resolution monotonic\n+clock is available only when linking with the @var{rt} library.  This\n+can be done explicitly by adding the @code{-lrt} flag when linking the\n application, but is also done implicitly when using OpenMP.\n \n+On the Windows platform, the version with @var{kind=4} arguments uses\n+the @code{GetTickCount} function, whereas the @var{kind=8} version\n+uses @code{QueryPerformanceCounter} and\n+@code{QueryPerformanceCounterFrequency}. For more information, and\n+potential caveats, please see the platform documentation.\n+\n @item @emph{Standard}:\n Fortran 95 and later\n "}, {"sha": "55f6dd7a5336136976de8ff2967f32b50fc78072", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83584eab1b561ac4be25da110c20d2d92371b9df/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83584eab1b561ac4be25da110c20d2d92371b9df/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=83584eab1b561ac4be25da110c20d2d92371b9df", "patch": "@@ -1,3 +1,14 @@\n+2013-04-15  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/56919\n+\t* intrinsics/time_1.h: Check __CYGWIN__ in addition to\n+\t__MINGW32__.\n+\t* intrinsics/system_clock.c (GF_CLOCK_MONOTONIC): Check\n+\t_POSIX_MONOTONIC_CLOCK as well.\n+\t(system_clock_4): Use GetTickCount on Windows.\n+\t(system_clock_8): Use QueryPerformanceCounter and\n+\tQueryPerformanceCounterFrequency on Windows.\n+\n 2013-04-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/56810"}, {"sha": "74a294db810f3b7199f2e55c50b64b1772ab184d", "filename": "libgfortran/intrinsics/system_clock.c", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83584eab1b561ac4be25da110c20d2d92371b9df/libgfortran%2Fintrinsics%2Fsystem_clock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83584eab1b561ac4be25da110c20d2d92371b9df/libgfortran%2Fintrinsics%2Fsystem_clock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsystem_clock.c?ref=83584eab1b561ac4be25da110c20d2d92371b9df", "patch": "@@ -29,20 +29,23 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"time_1.h\"\n \n \n+#if !defined(__MINGW32__) && !defined(__CYGWIN__)\n+\n /* POSIX states that CLOCK_REALTIME must be present if clock_gettime\n    is available, others are optional.  */\n #if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_CLOCK_GETTIME_LIBRT)\n-#ifdef CLOCK_MONOTONIC\n+#if defined(CLOCK_MONOTONIC) && defined(_POSIX_MONOTONIC_CLOCK) \\\n+  && _POSIX_MONOTONIC_CLOCK >= 0\n #define GF_CLOCK_MONOTONIC CLOCK_MONOTONIC\n #else\n #define GF_CLOCK_MONOTONIC CLOCK_REALTIME\n #endif\n #endif\n \n-/* Weakref trickery for clock_gettime().  On Glibc, clock_gettime()\n-   requires us to link in librt, which also pulls in libpthread.  In\n-   order to avoid this by default, only call clock_gettime() through a\n-   weak reference. \n+/* Weakref trickery for clock_gettime().  On Glibc <= 2.16,\n+   clock_gettime() requires us to link in librt, which also pulls in\n+   libpthread.  In order to avoid this by default, only call\n+   clock_gettime() through a weak reference.\n \n    Some targets don't support weak undefined references; on these\n    GTHREAD_USE_WEAK is 0. So we need to define it to 1 on other\n@@ -105,6 +108,8 @@ gf_gettime_mono (time_t * secs, long * nanosecs, long * tck)\n #endif\n }\n \n+#endif /* !__MINGW32 && !__CYGWIN__  */\n+\n extern void system_clock_4 (GFC_INTEGER_4 *, GFC_INTEGER_4 *, GFC_INTEGER_4 *);\n export_proto(system_clock_4);\n \n@@ -115,12 +120,28 @@ export_proto(system_clock_8);\n /* prefix(system_clock_4) is the INTEGER(4) version of the SYSTEM_CLOCK\n    intrinsic subroutine.  It returns the number of clock ticks for the current\n    system time, the number of ticks per second, and the maximum possible value\n-   for COUNT.  On the first call to SYSTEM_CLOCK, COUNT is set to zero. */\n+   for COUNT.  */\n \n void\n system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n \t       GFC_INTEGER_4 *count_max)\n {\n+#if defined(__MINGW32__) || defined(__CYGWIN__) \n+  if (count)\n+    {\n+      /* Use GetTickCount here as the resolution and range is\n+\t sufficient for the INTEGER(kind=4) version, and\n+\t QueryPerformanceCounter has potential issues.  */\n+      uint32_t cnt = GetTickCount ();\n+      if (cnt > GFC_INTEGER_4_HUGE)\n+\tcnt -= GFC_INTEGER_4_HUGE - 1;\n+      *count = cnt;\n+    }\n+  if (count_rate)\n+    *count_rate = 1000;\n+  if (count_max)\n+    *count_max = GFC_INTEGER_4_HUGE;\n+#else\n   GFC_INTEGER_4 cnt;\n   GFC_INTEGER_4 mx;\n \n@@ -158,6 +179,7 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n     *count_rate = tck;\n   if (count_max != NULL)\n     *count_max = mx;\n+#endif\n }\n \n \n@@ -167,6 +189,33 @@ void\n system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n \t\tGFC_INTEGER_8 *count_max)\n {\n+#if defined(__MINGW32__) || defined(__CYGWIN__) \n+  LARGE_INTEGER cnt;\n+  LARGE_INTEGER freq;\n+  bool fail = false;\n+  if (count && !QueryPerformanceCounter (&cnt))\n+    fail = true;\n+  if (count_rate && !QueryPerformanceFrequency (&freq))\n+    fail = true;\n+  if (fail)\n+    {\n+      if (count)\n+\t*count = - GFC_INTEGER_8_HUGE;\n+      if (count_rate)\n+\t*count_rate = 0;\n+      if (count_max)\n+\t*count_max = 0;\n+    }\n+  else\n+    {\n+      if (count)\n+\t*count = cnt.QuadPart;\n+      if (count_rate)\n+\t*count_rate = freq.QuadPart;\n+      if (count_max)\n+\t*count_max = GFC_INTEGER_8_HUGE;\n+    }\n+#else\n   GFC_INTEGER_8 cnt;\n   GFC_INTEGER_8 mx;\n \n@@ -204,4 +253,5 @@ system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n     *count_rate = tck;\n   if (count_max != NULL)\n     *count_max = mx;\n+#endif\n }"}, {"sha": "de6472c62623a7a40f3a94ce3d2e84a6e51b9bf9", "filename": "libgfortran/intrinsics/time_1.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83584eab1b561ac4be25da110c20d2d92371b9df/libgfortran%2Fintrinsics%2Ftime_1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83584eab1b561ac4be25da110c20d2d92371b9df/libgfortran%2Fintrinsics%2Ftime_1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ftime_1.h?ref=83584eab1b561ac4be25da110c20d2d92371b9df", "patch": "@@ -101,7 +101,7 @@ localtime_r (const time_t * timep, struct tm * result)\n    CPU_TIME intrinsics.  Returns 0 for success or -1 if no\n    CPU time could be computed.  */\n \n-#ifdef __MINGW32__\n+#if defined(__MINGW32__) || defined(__CYGWIN__)\n \n #define WIN32_LEAN_AND_MEAN\n #include <windows.h>"}]}