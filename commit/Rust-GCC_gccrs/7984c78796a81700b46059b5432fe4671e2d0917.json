{"sha": "7984c78796a81700b46059b5432fe4671e2d0917", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk4NGM3ODc5NmE4MTcwMGI0NjA1OWI1NDMyZmU0NjcxZTJkMDkxNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-10T23:33:40Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-10T23:33:40Z"}, "message": "lower-subreg.c: Include except.h.\n\n\t* lower-subreg.c: Include except.h.\n\t(decompose_multiword_subregs): Verify that the only control flow\n\tinsns we can split are loads to multi-words pseudos.\n\tHandle breaking such blocks after splitting, instead of calling\n\tfind_many_sub_basic_blocks.\n\n\t* loop-unroll.c (split_edge_and_insert): Don't set BB_SUPERBLOCK\n\ton the new basic block.  Add a lengthy comment explaining why we\n\tthought this was necessary.\n\t* cfglayout.c (cfg_layout_finalize): Don't break superblocks.\n\nFrom-SVN: r122807", "tree": {"sha": "bcc7bb1636a815612ac3bc51f2f41069c2317a4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcc7bb1636a815612ac3bc51f2f41069c2317a4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7984c78796a81700b46059b5432fe4671e2d0917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7984c78796a81700b46059b5432fe4671e2d0917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7984c78796a81700b46059b5432fe4671e2d0917", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7984c78796a81700b46059b5432fe4671e2d0917/comments", "author": null, "committer": null, "parents": [{"sha": "b2c50382fbaa050248b5d3952e2682f91fed4ede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c50382fbaa050248b5d3952e2682f91fed4ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c50382fbaa050248b5d3952e2682f91fed4ede"}], "stats": {"total": 96, "additions": 91, "deletions": 5}, "files": [{"sha": "d6e748d205e9b87a1e3b68af055627d7a4631073", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7984c78796a81700b46059b5432fe4671e2d0917", "patch": "@@ -1,3 +1,16 @@\n+2007-03-11  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* lower-subreg.c: Include except.h.\n+\t(decompose_multiword_subregs): Verify that the only control flow\n+\tinsns we can split are loads to multi-words pseudos.\n+\tHandle breaking such blocks after splitting, instead of calling\n+\tfind_many_sub_basic_blocks.\n+\n+\t* loop-unroll.c (split_edge_and_insert): Don't set BB_SUPERBLOCK\n+\ton the new basic block.  Add a lengthy comment explaining why we\n+\tthought this was necessary.\n+\t* cfglayout.c (cfg_layout_finalize): Don't break superblocks.\n+\n 2007-03-10  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/30924"}, {"sha": "bbdd7a25b414c176bb8a0afd7976b1e74f76afda", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=7984c78796a81700b46059b5432fe4671e2d0917", "patch": "@@ -1149,8 +1149,6 @@ cfg_layout_finalize (void)\n     bb->il.rtl->visited = 0;\n   }\n \n-  break_superblocks ();\n-\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif"}, {"sha": "0ef434ce8bfe2f82dcde9e853449d088a9a7ae90", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=7984c78796a81700b46059b5432fe4671e2d0917", "patch": "@@ -879,7 +879,37 @@ split_edge_and_insert (edge e, rtx insns)\n     return NULL;\n   bb = split_edge (e); \n   emit_insn_after (insns, BB_END (bb));\n-  bb->flags |= BB_SUPERBLOCK;\n+\n+  /* ??? We used to assume that INSNS can contain control flow insns, and\n+     that we had to try to find sub basic blocks in BB to maintain a valid\n+     CFG.  For this purpose we used to set the BB_SUPERBLOCK flag on BB\n+     and call break_superblocks when going out of cfglayout mode.  But it\n+     turns out that this never happens; and that if it does ever happen,\n+     the verify_flow_info call in loop_optimizer_finalize would fail.\n+\n+     There are two reasons why we expected we could have control flow insns\n+     in INSNS.  The first is when a comparison has to be done in parts, and\n+     the second is when the number of iterations is computed for loops with\n+     the number of iterations known at runtime.  In both cases, test cases\n+     to get control flow in INSNS appear to be impossible to construct:\n+\n+      * If do_compare_rtx_and_jump needs several branches to do comparison\n+\tin a mode that needs comparison by parts, we cannot analyze the\n+\tnumber of iterations of the loop, and we never get to unrolling it.\n+\n+      * The code in expand_divmod that was suspected to cause creation of\n+\tbranching code seems to be only accessed for signed division.  The\n+\tdivisions used by # of iterations analysis are always unsigned.\n+\tProblems might arise on architectures that emits branching code\n+\tfor some operations that may appear in the unroller (especially\n+\tfor division), but we have no such architectures.\n+\n+     Considering all this, it was decided that we should for now assume\n+     that INSNS can in theory contain control flow insns, but in practice\n+     it never does.  So we don't handle the theoretical case, and should\n+     a real failure ever show up, we have a pretty good clue for how to\n+     fix it.  */\n+\n   return bb;\n }\n "}, {"sha": "e911205f460f4675a529805cd30f7aa0ee47b400", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984c78796a81700b46059b5432fe4671e2d0917/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=7984c78796a81700b46059b5432fe4671e2d0917", "patch": "@@ -35,6 +35,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"recog.h\"\n #include \"bitmap.h\"\n #include \"expr.h\"\n+#include \"except.h\"\n #include \"regs.h\"\n #include \"tree-pass.h\"\n \n@@ -1051,6 +1052,8 @@ decompose_multiword_subregs (bool update_life)\n       int max_regno = max_reg_num ();\n       sbitmap life_blocks;\n       sbitmap sub_blocks;\n+      unsigned int i;\n+      sbitmap_iterator sbi;\n       bitmap_iterator iter;\n       unsigned int regno;\n \n@@ -1105,6 +1108,21 @@ decompose_multiword_subregs (bool update_life)\n \t\t      rtx orig_insn = insn;\n \t\t      bool cfi = control_flow_insn_p (insn);\n \n+\t\t      /* We can end up splitting loads to multi-word pseudos\n+\t\t\t into separate loads to machine word size pseudos.\n+\t\t\t When this happens, we first had one load that can\n+\t\t\t throw, and after resolve_simple_move we'll have a\n+\t\t\t bunch of loads (at least two).  All those loads may\n+\t\t\t trap if we can have non-call exceptions, so they\n+\t\t\t all will end the current basic block.  We split the\n+\t\t\t block after the outer loop over all insns, but we\n+\t\t\t make sure here that we will be able to split the\n+\t\t\t basic block and still produce the correct control\n+\t\t\t flow graph for it.  */\n+\t\t      gcc_assert (!cfi\n+\t\t\t\t  || (flag_non_call_exceptions\n+\t\t\t\t      && can_throw_internal (insn)));\n+\n \t\t      insn = resolve_simple_move (set, insn);\n \t\t      if (insn != orig_insn)\n \t\t\t{\n@@ -1157,8 +1175,35 @@ decompose_multiword_subregs (bool update_life)\n \tupdate_life_info (life_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t\t  PROP_DEATH_NOTES);\n \n-      if (sbitmap_first_set_bit (sub_blocks) >= 0)\n-\tfind_many_sub_basic_blocks (sub_blocks);\n+      /* If we had insns to split that caused control flow insns in the middle\n+\t of a basic block, split those blocks now.  Note that we only handle\n+\t the case where splitting a load has caused multiple possibly trapping\n+\t loads to appear.  */\n+      EXECUTE_IF_SET_IN_SBITMAP (sub_blocks, 0, i, sbi)\n+\t{\n+\t  rtx insn, end;\n+\t  edge fallthru;\n+\n+\t  bb = BASIC_BLOCK (i);\n+\t  insn = BB_HEAD (bb);\n+\t  end = BB_END (bb);\n+\n+\t  while (insn != end)\n+\t    {\n+\t      if (control_flow_insn_p (insn))\n+\t\t{\n+\t\t  /* Split the block after insn.  There will be a fallthru\n+\t\t     edge, which is OK so we keep it.  We have to create the\n+\t\t     exception edges ourselves.  */\n+\t\t  fallthru = split_block (bb, insn);\n+\t\t  rtl_make_eh_edge (NULL, bb, BB_END (bb));\n+\t\t  bb = fallthru->dest;\n+\t\t  insn = BB_HEAD (bb);\n+\t\t}\n+\t      else\n+\t        insn = NEXT_INSN (insn);\n+\t    }\n+\t}\n \n       sbitmap_free (life_blocks);\n       sbitmap_free (sub_blocks);"}]}