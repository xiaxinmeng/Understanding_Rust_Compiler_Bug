{"sha": "e64e93877bfe065068b7111b7aa74d8f7d78df8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0ZTkzODc3YmZlMDY1MDY4YjcxMTFiN2FhNzRkOGY3ZDc4ZGY4Zg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-04-26T20:37:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-04-26T20:37:58Z"}, "message": "compiler: Add Enclosed_var_expression.\n\n    \n    Introduces an abstraction for a variable referenced in a closure.\n    This maintains the underlying expression which accesses a field within\n    a closure variable and gives easy access to the underlying\n    Named_object.\n    \n    Reviewed-on: https://go-review.googlesource.com/22374\n\nFrom-SVN: r235452", "tree": {"sha": "9037b628a43dc83bd08039aa7677c78fda77f011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9037b628a43dc83bd08039aa7677c78fda77f011"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e64e93877bfe065068b7111b7aa74d8f7d78df8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e64e93877bfe065068b7111b7aa74d8f7d78df8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e64e93877bfe065068b7111b7aa74d8f7d78df8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e64e93877bfe065068b7111b7aa74d8f7d78df8f/comments", "author": null, "committer": null, "parents": [{"sha": "5e851c020abe8d78f73ace4ff8a3a2e047662865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e851c020abe8d78f73ace4ff8a3a2e047662865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e851c020abe8d78f73ace4ff8a3a2e047662865"}], "stats": {"total": 229, "additions": 164, "deletions": 65}, "files": [{"sha": "5f24f22aeae32b104320a9e7c53f1c15e2e4c699", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e64e93877bfe065068b7111b7aa74d8f7d78df8f", "patch": "@@ -1,4 +1,4 @@\n-944c3ca6ac7c204585fd73936894fe05de535b94\n+ba520fdcbea95531ebb9ef3d5be2de405ca90df3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "05425bcbc8a64363d788fd7c60aec5bee900f341", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 73, "deletions": 45, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=e64e93877bfe065068b7111b7aa74d8f7d78df8f", "patch": "@@ -782,6 +782,74 @@ Expression::make_var_reference(Named_object* var, Location location)\n   return new Var_expression(var, location);\n }\n \n+// Class Enclosed_var_expression.\n+\n+int\n+Enclosed_var_expression::do_traverse(Traverse*)\n+{\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Lower the reference to the enclosed variable.\n+\n+Expression*\n+Enclosed_var_expression::do_lower(Gogo* gogo, Named_object* function,\n+\t\t\t\t  Statement_inserter* inserter, int)\n+{\n+  gogo->lower_expression(function, inserter, &this->reference_);\n+  return this;\n+}\n+\n+// Flatten the reference to the enclosed variable.\n+\n+Expression*\n+Enclosed_var_expression::do_flatten(Gogo* gogo, Named_object* function,\n+\t\t\t\t    Statement_inserter* inserter)\n+{\n+  gogo->flatten_expression(function, inserter, &this->reference_);\n+  return this;\n+}\n+\n+void\n+Enclosed_var_expression::do_address_taken(bool escapes)\n+{\n+  if (!escapes)\n+    {\n+      if (this->variable_->is_variable())\n+\tthis->variable_->var_value()->set_non_escaping_address_taken();\n+      else if (this->variable_->is_result_variable())\n+\tthis->variable_->result_var_value()->set_non_escaping_address_taken();\n+      else\n+\tgo_unreachable();\n+    }\n+  else\n+    {\n+      if (this->variable_->is_variable())\n+\tthis->variable_->var_value()->set_address_taken();\n+      else if (this->variable_->is_result_variable())\n+\tthis->variable_->result_var_value()->set_address_taken();\n+      else\n+\tgo_unreachable();\n+    }\n+}\n+\n+// Ast dump for enclosed variable expression.\n+\n+void\n+Enclosed_var_expression::do_dump_expression(Ast_dump_context* adc) const\n+{\n+  adc->ostream() << this->variable_->name();\n+}\n+\n+// Make a reference to a variable within an enclosing function.\n+\n+Expression*\n+Expression::make_enclosing_var_reference(Expression* reference,\n+\t\t\t\t\t Named_object* var, Location location)\n+{\n+  return new Enclosed_var_expression(reference, var, location);\n+}\n+\n // Class Temporary_reference_expression.\n \n // The type.\n@@ -12814,53 +12882,12 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \t  no = name_expr->var_expression()->named_object();\n \t  break;\n \n-\tcase EXPRESSION_FUNC_REFERENCE:\n-\t  no = name_expr->func_expression()->named_object();\n+\tcase EXPRESSION_ENCLOSED_VAR_REFERENCE:\n+\t  no = name_expr->enclosed_var_expression()->variable();\n \t  break;\n \n-\tcase EXPRESSION_UNARY:\n-\t  // If there is a local variable around with the same name as\n-\t  // the field, and this occurs in the closure, then the\n-\t  // parser may turn the field reference into an indirection\n-\t  // through the closure.  FIXME: This is a mess.\n-\t  {\n-\t    bad_key = true;\n-\t    Unary_expression* ue = static_cast<Unary_expression*>(name_expr);\n-\t    if (ue->op() == OPERATOR_MULT)\n-\t      {\n-\t\tField_reference_expression* fre =\n-\t\t  ue->operand()->field_reference_expression();\n-\t\tif (fre != NULL)\n-\t\t  {\n-\t\t    Struct_type* st =\n-\t\t      fre->expr()->type()->deref()->struct_type();\n-\t\t    if (st != NULL)\n-\t\t      {\n-\t\t\tconst Struct_field* sf = st->field(fre->field_index());\n-\t\t\tname = sf->field_name();\n-\n-\t\t\t// See below.  FIXME.\n-\t\t\tif (!Gogo::is_hidden_name(name)\n-\t\t\t    && name[0] >= 'a'\n-\t\t\t    && name[0] <= 'z')\n-\t\t\t  {\n-\t\t\t    if (gogo->lookup_global(name.c_str()) != NULL)\n-\t\t\t      name = gogo->pack_hidden_name(name, false);\n-\t\t\t  }\n-\n-\t\t\tchar buf[20];\n-\t\t\tsnprintf(buf, sizeof buf, \"%u\", fre->field_index());\n-\t\t\tsize_t buflen = strlen(buf);\n-\t\t\tif (name.compare(name.length() - buflen, buflen, buf)\n-\t\t\t    == 0)\n-\t\t\t  {\n-\t\t\t    name = name.substr(0, name.length() - buflen);\n-\t\t\t    bad_key = false;\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n+\tcase EXPRESSION_FUNC_REFERENCE:\n+\t  no = name_expr->func_expression()->named_object();\n \t  break;\n \n \tdefault:\n@@ -13301,6 +13328,7 @@ Expression::is_variable() const\n     case EXPRESSION_VAR_REFERENCE:\n     case EXPRESSION_TEMPORARY_REFERENCE:\n     case EXPRESSION_SET_AND_USE_TEMPORARY:\n+    case EXPRESSION_ENCLOSED_VAR_REFERENCE:\n       return true;\n     default:\n       return false;"}, {"sha": "c1e8191f6bd30cb9b64c1a987a0c6fe4dd750726", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=e64e93877bfe065068b7111b7aa74d8f7d78df8f", "patch": "@@ -29,6 +29,7 @@ class Struct_type;\n class Struct_field;\n class Expression_list;\n class Var_expression;\n+class Enclosed_var_expression;\n class Temporary_reference_expression;\n class Set_and_use_temporary_expression;\n class String_expression;\n@@ -85,6 +86,7 @@ class Expression\n     EXPRESSION_BINARY,\n     EXPRESSION_CONST_REFERENCE,\n     EXPRESSION_VAR_REFERENCE,\n+    EXPRESSION_ENCLOSED_VAR_REFERENCE,\n     EXPRESSION_TEMPORARY_REFERENCE,\n     EXPRESSION_SET_AND_USE_TEMPORARY,\n     EXPRESSION_SINK,\n@@ -166,6 +168,10 @@ class Expression\n   static Expression*\n   make_var_reference(Named_object*, Location);\n \n+  // Make a reference to a variable within an enclosing function.\n+  static Expression*\n+  make_enclosing_var_reference(Expression*, Named_object*, Location);\n+\n   // Make a reference to a temporary variable.  Temporary variables\n   // are always created by a single statement, which is what we use to\n   // refer to them.\n@@ -539,6 +545,20 @@ class Expression\n   var_expression() const\n   { return this->convert<const Var_expression, EXPRESSION_VAR_REFERENCE>(); }\n \n+  // If this is a enclosed_variable reference, return the\n+  // Enclosed_var_expression structure.  Otherwise, return NULL.\n+  // This is a controlled dynamic cast.\n+  Enclosed_var_expression*\n+  enclosed_var_expression()\n+  { return this->convert<Enclosed_var_expression,\n+\t\t\t EXPRESSION_ENCLOSED_VAR_REFERENCE>(); }\n+\n+  const Enclosed_var_expression*\n+  enclosed_var_expression() const\n+  { return this->convert<const Enclosed_var_expression,\n+\t\t\t EXPRESSION_ENCLOSED_VAR_REFERENCE>(); }\n+\n+\n   // If this is a reference to a temporary variable, return the\n   // Temporary_reference_expression.  Otherwise, return NULL.\n   Temporary_reference_expression*\n@@ -1258,6 +1278,71 @@ class Var_expression : public Expression\n   Named_object* variable_;\n };\n \n+// A reference to a variable within an enclosing function.\n+\n+class Enclosed_var_expression : public Expression\n+{\n+ public:\n+  Enclosed_var_expression(Expression* reference, Named_object* variable,\n+\t\t\t  Location location)\n+    : Expression(EXPRESSION_ENCLOSED_VAR_REFERENCE, location),\n+      reference_(reference), variable_(variable)\n+  { }\n+\n+  // The reference to the enclosed variable.  This will be an indirection of the\n+  // the field stored within closure variable.\n+  Expression*\n+  reference() const\n+  { return this->reference_; }\n+\n+  // The variable being enclosed and referenced.\n+  Named_object*\n+  variable() const\n+  { return this->variable_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  Type*\n+  do_type()\n+  { return this->reference_->type(); }\n+\n+  void\n+  do_determine_type(const Type_context* context)\n+  { return this->reference_->determine_type(context); }\n+\n+  Expression*\n+  do_copy()\n+  { return this; }\n+\n+  bool\n+  do_is_addressable() const\n+  { return this->reference_->is_addressable(); }\n+\n+  void\n+  do_address_taken(bool escapes);\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n+  { return this->reference_->get_backend(context); }\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The reference to the enclosed variable.\n+  Expression* reference_;\n+  // The variable being enclosed.\n+  Named_object* variable_;\n+};\n+\n // A reference to a temporary variable.\n \n class Temporary_reference_expression : public Expression"}, {"sha": "c96ae1dacec903888b738aa96985dcaf41f868f8", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e64e93877bfe065068b7111b7aa74d8f7d78df8f/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=e64e93877bfe065068b7111b7aa74d8f7d78df8f", "patch": "@@ -2658,7 +2658,7 @@ Parse::enclosing_var_reference(Named_object* in_function, Named_object* var,\n \t\t\t\t\t\t   ins.first->index(),\n \t\t\t\t\t\t   location);\n   e = Expression::make_unary(OPERATOR_MULT, e, location);\n-  return e;\n+  return Expression::make_enclosing_var_reference(e, var, location);\n }\n \n // CompositeLit  = LiteralType LiteralValue .\n@@ -5791,24 +5791,10 @@ Parse::verify_not_sink(Expression* expr)\n \n   // If this can not be a sink, and it is a variable, then we are\n   // using the variable, not just assigning to it.\n-  Var_expression* ve = expr->var_expression();\n-  if (ve != NULL)\n-    this->mark_var_used(ve->named_object());\n-  else if (expr->deref()->field_reference_expression() != NULL\n-\t   && this->gogo_->current_function() != NULL)\n-    {\n-      // We could be looking at a variable referenced from a closure.\n-      // If so, we need to get the enclosed variable and mark it as used.\n-      Function* this_function = this->gogo_->current_function()->func_value();\n-      Named_object* closure = this_function->closure_var();\n-      if (closure != NULL)\n-\t{\n-\t  unsigned int var_index =\n-\t    expr->deref()->field_reference_expression()->field_index();\n-\t  this->mark_var_used(this_function->enclosing_var(var_index - 1));\n-\t}\n-    }\n-\n+  if (expr->var_expression() != NULL)\n+    this->mark_var_used(expr->var_expression()->named_object());\n+  else if (expr->enclosed_var_expression() != NULL)\n+    this->mark_var_used(expr->enclosed_var_expression()->variable());\n   return expr;\n }\n "}]}