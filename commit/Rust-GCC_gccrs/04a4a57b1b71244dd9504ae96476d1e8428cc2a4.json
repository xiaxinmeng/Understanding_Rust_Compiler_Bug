{"sha": "04a4a57b1b71244dd9504ae96476d1e8428cc2a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRhNGE1N2IxYjcxMjQ0ZGQ5NTA0YWU5NjQ3NmQxZTg0MjhjYzJhNA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-05-29T08:59:44Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-05-29T08:59:44Z"}, "message": "PR 19155 Check for strtod failure via endptr\n\nFrom-SVN: r174393", "tree": {"sha": "15bd48ac37b10fadbe3bdad3b1fa55db9c44f988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15bd48ac37b10fadbe3bdad3b1fa55db9c44f988"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04a4a57b1b71244dd9504ae96476d1e8428cc2a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04a4a57b1b71244dd9504ae96476d1e8428cc2a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04a4a57b1b71244dd9504ae96476d1e8428cc2a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04a4a57b1b71244dd9504ae96476d1e8428cc2a4/comments", "author": null, "committer": null, "parents": [{"sha": "be7a83950d24551571e6d032a54b0a1bdb8a697b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7a83950d24551571e6d032a54b0a1bdb8a697b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be7a83950d24551571e6d032a54b0a1bdb8a697b"}], "stats": {"total": 45, "additions": 30, "deletions": 15}, "files": [{"sha": "1d08da8c3b9d88ff1cfe460423ef53d70a028f1c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a4a57b1b71244dd9504ae96476d1e8428cc2a4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a4a57b1b71244dd9504ae96476d1e8428cc2a4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=04a4a57b1b71244dd9504ae96476d1e8428cc2a4", "patch": "@@ -1,3 +1,10 @@\n+2011-05-29  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/19155\n+\t* io/read.c (convert_real): Check for invalid input by comparing\n+\tendptr instead of EINVAL.\n+\t(read_f): Fixup floating point input without significand.\n+\n 2011-05-22  Tobias Burnus  <burnus@net-b.de>\n \n \t* runtime/stop.c (stop_string,error_stop_string): Minor cleanup."}, {"sha": "aa41bc7b9d288d4884acc14a69f0f0492e28b4d0", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a4a57b1b71244dd9504ae96476d1e8428cc2a4/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a4a57b1b71244dd9504ae96476d1e8428cc2a4/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=04a4a57b1b71244dd9504ae96476d1e8428cc2a4", "patch": "@@ -1,9 +1,9 @@\n-/* Copyright (C) 2002, 2003, 2005, 2007, 2008, 2009, 2010\n+/* Copyright (C) 2002, 2003, 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    F2003 I/O support contributed by Jerry DeLisle\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -131,45 +131,45 @@ max_value (int length, int signed_flag)\n \n \n /* convert_real()-- Convert a character representation of a floating\n-   point number to the machine number.  Returns nonzero if there is a\n-   range problem during conversion.  Note: many architectures\n-   (e.g. IA-64, HP-PA) require that the storage pointed to by the dest\n-   argument is properly aligned for the type in question.  */\n+   point number to the machine number.  Returns nonzero if there is an\n+   invalid input.  Note: many architectures (e.g. IA-64, HP-PA)\n+   require that the storage pointed to by the dest argument is\n+   properly aligned for the type in question.  */\n \n int\n convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)\n {\n-  errno = 0;\n+  char *endptr = NULL;\n \n   switch (length)\n     {\n     case 4:\n       *((GFC_REAL_4*) dest) =\n #if defined(HAVE_STRTOF)\n-\tgfc_strtof (buffer, NULL);\n+\tgfc_strtof (buffer, &endptr);\n #else\n-\t(GFC_REAL_4) gfc_strtod (buffer, NULL);\n+\t(GFC_REAL_4) gfc_strtod (buffer, &endptr);\n #endif\n       break;\n \n     case 8:\n-      *((GFC_REAL_8*) dest) = gfc_strtod (buffer, NULL);\n+      *((GFC_REAL_8*) dest) = gfc_strtod (buffer, &endptr);\n       break;\n \n #if defined(HAVE_GFC_REAL_10) && defined (HAVE_STRTOLD)\n     case 10:\n-      *((GFC_REAL_10*) dest) = gfc_strtold (buffer, NULL);\n+      *((GFC_REAL_10*) dest) = gfc_strtold (buffer, &endptr);\n       break;\n #endif\n \n #if defined(HAVE_GFC_REAL_16)\n # if defined(GFC_REAL_16_IS_FLOAT128)\n     case 16:\n-      *((GFC_REAL_16*) dest) = __qmath_(strtoflt128) (buffer, NULL);\n+      *((GFC_REAL_16*) dest) = __qmath_(strtoflt128) (buffer, &endptr);\n       break;\n # elif defined(HAVE_STRTOLD)\n     case 16:\n-      *((GFC_REAL_16*) dest) = gfc_strtold (buffer, NULL);\n+      *((GFC_REAL_16*) dest) = gfc_strtold (buffer, &endptr);\n       break;\n # endif\n #endif\n@@ -178,10 +178,10 @@ convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)\n       internal_error (&dtp->common, \"Unsupported real kind during IO\");\n     }\n \n-  if (errno == EINVAL)\n+  if (buffer == endptr)\n     {\n       generate_error (&dtp->common, LIBERROR_READ_VALUE,\n-\t\t      \"Error during floating point read\");\n+  \t\t      \"Error during floating point read\");\n       next_record (dtp, 1);\n       return 1;\n     }\n@@ -1114,6 +1114,14 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   /* Output a trailing '0' after decimal point if not yet found.  */\n   if (seen_dp && !seen_dec_digit)\n     *(out++) = '0';\n+  /* Handle input of style \"E+NN\" by inserting a 0 for the\n+     significand.  */\n+  else if (!seen_int_digit && !seen_dec_digit)\n+    {\n+      notify_std (&dtp->common, GFC_STD_LEGACY, \n+\t\t  \"REAL input of style 'E+NN'\");\n+      *(out++) = '0';\n+    }\n \n   /* Print out the exponent to finish the reformatted number.  Maximum 4\n      digits for the exponent.  */"}]}