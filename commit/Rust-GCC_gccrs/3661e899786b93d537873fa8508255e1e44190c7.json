{"sha": "3661e899786b93d537873fa8508255e1e44190c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY2MWU4OTk3ODZiOTNkNTM3ODczZmE4NTA4MjU1ZTFlNDQxOTBjNw==", "commit": {"author": {"name": "Tomas Bily", "email": "tbily@suse.cz", "date": "2008-12-03T13:35:13Z"}, "committer": {"name": "Tomas Bily", "email": "tomby@gcc.gnu.org", "date": "2008-12-03T13:35:13Z"}, "message": "re PR middle-end/38250 (ICE with -O2 -ftree-loop-distribution)\n\n        PR middle-end/38250\n        * tree-loop-distribution.c (build_size_arg): New function.\n        (generate_memset_zero): Checks if DR_STEP(de) is NULL.\n        Reorganized generating of stmts.\n        * testsuite/gcc.dg/tree-ssa/pr38250.c: New file.\n        * tree-data-ref.c (dr_analyze_innermost): Returns bool.\n        Indicate if analysis succeed.\n        * tree-data-ref.h (dr_analyze_innermost): Returns bool.\n        * tree-predcom.c (valid_initializer_p, find_looparound_phi):\n        Uses new definition of dr_analyze_innermost.\n\nFrom-SVN: r142394", "tree": {"sha": "ce8e0b8567348f3139f7c4c74dd94700b18f970f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce8e0b8567348f3139f7c4c74dd94700b18f970f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3661e899786b93d537873fa8508255e1e44190c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3661e899786b93d537873fa8508255e1e44190c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3661e899786b93d537873fa8508255e1e44190c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3661e899786b93d537873fa8508255e1e44190c7/comments", "author": null, "committer": null, "parents": [{"sha": "f11d2f1e7e33588448f7b60ce752d5d355377cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f11d2f1e7e33588448f7b60ce752d5d355377cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f11d2f1e7e33588448f7b60ce752d5d355377cb1"}], "stats": {"total": 63, "additions": 46, "deletions": 17}, "files": [{"sha": "03da741d592374bb349abe540ccfc39bb50e02c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3661e899786b93d537873fa8508255e1e44190c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3661e899786b93d537873fa8508255e1e44190c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3661e899786b93d537873fa8508255e1e44190c7", "patch": "@@ -1,3 +1,16 @@\n+2008-12-03  Tomas Bily  <tbily@suse.cz>\n+\n+        PR middle-end/38250\n+        * tree-loop-distribution.c (build_size_arg): New function.\n+        (generate_memset_zero): Checks if dr_analyze_innermost succeed.\n+        Reorganized generating of stmts.\n+        * testsuite/gcc.dg/tree-ssa/pr38250.c: New file.\n+        * tree-data-ref.c (dr_analyze_innermost): Returns bool.\n+        Indicate if analysis succeed.\n+        * tree-data-ref.h (dr_analyze_innermost): Returns bool.\n+        * tree-predcom.c (valid_initializer_p, find_looparound_phi):\n+        Uses new definition of dr_analyze_innermost.\n+\n 2008-12-03  Ben Elliston  <bje@au.ibm.com>\n \n \t* tree-ssa-pre.c (do_regular_insertion): Initialise edoubleprime."}, {"sha": "2715339219e2b0443a850a8db82dd5348cd1e6a5", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3661e899786b93d537873fa8508255e1e44190c7", "patch": "@@ -667,9 +667,9 @@ canonicalize_base_object_address (tree addr)\n }\n \n /* Analyzes the behavior of the memory reference DR in the innermost loop that\n-   contains it.  */\n+   contains it. Returns true if analysis succeed or false otherwise.  */\n \n-void\n+bool\n dr_analyze_innermost (struct data_reference *dr)\n {\n   gimple stmt = DR_STMT (dr);\n@@ -693,15 +693,15 @@ dr_analyze_innermost (struct data_reference *dr)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"failed: bit offset alignment.\\n\");\n-      return;\n+      return false;\n     }\n \n   base = build_fold_addr_expr (base);\n   if (!simple_iv (loop, stmt, base, &base_iv, false))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n-      return;\n+      return false;\n     }\n   if (!poffset)\n     {\n@@ -712,7 +712,7 @@ dr_analyze_innermost (struct data_reference *dr)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"failed: evolution of offset is not affine.\\n\");\n-      return;\n+      return false;\n     }\n \n   init = ssize_int (pbitpos / BITS_PER_UNIT);\n@@ -735,6 +735,8 @@ dr_analyze_innermost (struct data_reference *dr)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"success.\\n\");\n+\n+  return true;\n }\n \n /* Determines the base object and the list of indices of memory reference"}, {"sha": "3c2f1b288362881c25988235871b5ef6082c0ace", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=3661e899786b93d537873fa8508255e1e44190c7", "patch": "@@ -381,7 +381,7 @@ DEF_VEC_O (data_ref_loc);\n DEF_VEC_ALLOC_O (data_ref_loc, heap);\n \n bool get_references_in_stmt (gimple, VEC (data_ref_loc, heap) **);\n-void dr_analyze_innermost (struct data_reference *);\n+bool dr_analyze_innermost (struct data_reference *);\n extern bool compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       VEC (data_reference_p, heap) **,\n \t\t\t\t\t       VEC (ddr_p, heap) **);"}, {"sha": "062ab48ee7ea1556be4eeeaef4d3cb9360d58ff2", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=3661e899786b93d537873fa8508255e1e44190c7", "patch": "@@ -216,13 +216,30 @@ generate_loops_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n   return true;\n }\n \n+/* Build size argument.  */\n+\n+static inline tree\n+build_size_arg (tree nb_iter, tree op, gimple_seq* stmt_list)\n+{\n+    tree nb_bytes;\n+    gimple_seq stmts = NULL;\n+\n+    nb_bytes = fold_build2 (MULT_EXPR, TREE_TYPE (nb_iter),\n+\t\t\t    nb_iter, TYPE_SIZE_UNIT (TREE_TYPE (op)));\n+    nb_bytes = force_gimple_operand (nb_bytes, &stmts, true, NULL);\n+    gimple_seq_add_seq (stmt_list, stmts);\n+\n+    return nb_bytes;\n+}\n+\n /* Generate a call to memset.  Return true when the operation succeeded.  */\n \n static bool\n generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n \t\t      gimple_stmt_iterator bsi)\n {\n-  tree t, nb_bytes, addr_base;\n+  tree t, addr_base;\n+  tree nb_bytes = NULL;\n   bool res = false;\n   gimple_seq stmts = NULL, stmt_list = NULL;\n   gimple fn_call;\n@@ -231,14 +248,10 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   ssa_op_iter iter;\n   struct data_reference *dr = XCNEW (struct data_reference);\n \n-  nb_bytes = fold_build2 (MULT_EXPR, TREE_TYPE (nb_iter),\n-\t\t\t  nb_iter, TYPE_SIZE_UNIT (TREE_TYPE (op0)));\n-  nb_bytes = force_gimple_operand (nb_bytes, &stmts, true, NULL);\n-  gimple_seq_add_seq (&stmt_list, stmts);\n-\n   DR_STMT (dr) = stmt;\n   DR_REF (dr) = op0;\n-  dr_analyze_innermost (dr);\n+  if (!dr_analyze_innermost (dr))\n+    goto end;\n \n   /* Test for a positive stride, iterating over every element.  */\n   if (integer_zerop (fold_build2 (MINUS_EXPR, integer_type_node, DR_STEP (dr),\n@@ -253,6 +266,7 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n \t\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (op0)),\n \t\t\t\t       DR_STEP (dr))))\n     {\n+      nb_bytes = build_size_arg (nb_iter, op0, &stmt_list);\n       addr_base = size_binop (PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n       addr_base = fold_build2 (MINUS_EXPR, sizetype, addr_base, nb_bytes);\n       addr_base = force_gimple_operand (addr_base, &stmts, true, NULL);\n@@ -272,6 +286,8 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   fntype = TREE_TYPE (fndecl);\n   fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n \n+  if (!nb_bytes)\n+      nb_bytes = build_size_arg (nb_iter, op0, &stmt_list);\n   fn_call = gimple_build_call (fn, 3, mem, integer_zero_node, nb_bytes);\n   gimple_seq_add_stmt (&stmt_list, fn_call);\n "}, {"sha": "54e0b7fe1607f74ed0ea21dd9ec02dacb831c6a2", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3661e899786b93d537873fa8508255e1e44190c7/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=3661e899786b93d537873fa8508255e1e44190c7", "patch": "@@ -1026,9 +1026,6 @@ valid_initializer_p (struct data_reference *ref,\n   aff_tree diff, base, step;\n   double_int off;\n \n-  if (!DR_BASE_ADDRESS (ref))\n-    return false;\n-\n   /* Both REF and ROOT must be accessing the same object.  */\n   if (!operand_equal_p (DR_BASE_ADDRESS (ref), DR_BASE_ADDRESS (root), 0))\n     return false;\n@@ -1115,7 +1112,8 @@ find_looparound_phi (struct loop *loop, dref ref, dref root)\n   memset (&init_dr, 0, sizeof (struct data_reference));\n   DR_REF (&init_dr) = init_ref;\n   DR_STMT (&init_dr) = phi;\n-  dr_analyze_innermost (&init_dr);\n+  if (!dr_analyze_innermost (&init_dr))\n+    return NULL;\n \n   if (!valid_initializer_p (&init_dr, ref->distance + 1, root->ref))\n     return NULL;"}]}