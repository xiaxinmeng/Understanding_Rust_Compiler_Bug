{"sha": "015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE1YjFhZDFkZmE4ZmJkNzMyMzY5MTUxNWE1YzFjMzhjNGMxNTQxZA==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-09-04T18:09:32Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-09-04T18:09:32Z"}, "message": "expr.c (emit_group_load): Revise to allow splitting TCmode source into DImode pieces.\n\n\t* expr.c (emit_group_load): Revise to allow splitting TCmode source\n\tinto DImode pieces.\n\t* pa-64.h (LONG_DOUBLE_TYPE_SIZE): Define to 128.\n\t* pa64-regs.h (CLASS_CANNOT_CHANGE_MODE_P): Inhibit changes from SImode\n\tfor floating-point register class.\n\t* pa.c (function_arg): Fix handling of modes wider than one word for\n\tTARGET_64BIT.\n\nFrom-SVN: r56805", "tree": {"sha": "a78c678a10eb1a59228782c1360a8910ed4f8e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a78c678a10eb1a59228782c1360a8910ed4f8e9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/comments", "author": null, "committer": null, "parents": [{"sha": "b10f218708c0cc0f878ff4a474e46196bc30e3b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b10f218708c0cc0f878ff4a474e46196bc30e3b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b10f218708c0cc0f878ff4a474e46196bc30e3b5"}], "stats": {"total": 155, "additions": 73, "deletions": 82}, "files": [{"sha": "e7d7646dc4947ce6a4b448a470cae44262d0690f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "patch": "@@ -1,3 +1,14 @@\n+2002-09-04  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* expr.c (emit_group_load): Revise to allow splitting TCmode source\n+\tinto DImode pieces.\n+\n+\t* pa-64.h (LONG_DOUBLE_TYPE_SIZE): Define to 128.\n+\t* pa64-regs.h (CLASS_CANNOT_CHANGE_MODE_P): Inhibit changes from SImode\n+\tfor floating-point register class.\n+\t* pa.c (function_arg): Fix handling of modes wider than one word for\n+\tTARGET_64BIT.\n+\n Wed Sep  4 18:48:10 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* combine.c (make_compound_operation): Don't generate zero / sign"}, {"sha": "82ce3ef45f276f60c4e84da45be2a0317863a97a", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "patch": "@@ -65,10 +65,8 @@ Boston, MA 02111-1307, USA.  */\n #define FLOAT_TYPE_SIZE 32\n #undef DOUBLE_TYPE_SIZE\n #define DOUBLE_TYPE_SIZE 64\n-/* This should be 128, but until we work out the ABI for the 128bit\n-   FP codes supplied by HP we'll keep it at 64 bits.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 128\n \n /* Temporary until we figure out what to do with those *(&@$ 32bit\n    relocs which appear in stabs.  */"}, {"sha": "2d655394a0daac0a5fc9719cc984a0f8c6056ab6", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 36, "deletions": 64, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "patch": "@@ -7446,6 +7446,8 @@ function_arg (cum, mode, type, named, incoming)\n      int incoming;\n {\n   int max_arg_words = (TARGET_64BIT ? 8 : 4);\n+  int arg_size = FUNCTION_ARG_SIZE (mode, type);\n+  int alignment = 0;\n   int fpr_reg_base;\n   int gpr_reg_base;\n   rtx retval;\n@@ -7456,16 +7458,15 @@ function_arg (cum, mode, type, named, incoming)\n          this routine should return zero.  FUNCTION_ARG_PARTIAL_NREGS will\n          handle arguments which are split between regs and stack slots if\n          the ABI mandates split arguments.  */\n-      if (cum->words + FUNCTION_ARG_SIZE (mode, type) > max_arg_words\n+      if (cum->words + arg_size > max_arg_words\n           || mode == VOIDmode)\n \treturn NULL_RTX;\n     }\n   else\n     {\n-      int offset = 0;\n-      if (FUNCTION_ARG_SIZE (mode, type) > 1 && (cum->words & 1))\n-\toffset = 1;\n-      if (cum->words + offset >= max_arg_words\n+      if (arg_size > 1)\n+\talignment = cum->words & 1;\n+      if (cum->words + alignment >= max_arg_words\n \t  || mode == VOIDmode)\n \treturn NULL_RTX;\n     }\n@@ -7474,70 +7475,54 @@ function_arg (cum, mode, type, named, incoming)\n      particularly in their handling of FP registers.  We might\n      be able to cleverly share code between them, but I'm not\n      going to bother in the hope that splitting them up results\n-     in code that is more easily understood.\n+     in code that is more easily understood.  */\n \n-     The 64bit code probably is very wrong for structure passing.  */\n   if (TARGET_64BIT)\n     {\n       /* Advance the base registers to their current locations.\n \n          Remember, gprs grow towards smaller register numbers while\n-\t fprs grow to higher register numbers.  Also remember FP regs\n-\t are always 4 bytes wide, while the size of an integer register\n-\t varies based on the size of the target word.  */\n+\t fprs grow to higher register numbers.  Also remember that\n+\t although FP regs are 32-bit addressable, we pretend that\n+\t the registers are 64-bits wide.  */\n       gpr_reg_base = 26 - cum->words;\n       fpr_reg_base = 32 + cum->words;\n \n-      /* If the argument is more than a word long, then we need to align\n-\t the base registers.  Same caveats as above.  */\n-      if (FUNCTION_ARG_SIZE (mode, type) > 1)\n+      /* Arguments wider than one word need special treatment.  */\n+      if (arg_size > 1)\n \t{\n-\t  if (mode != BLKmode)\n+\t  /* Double-extended precision (80-bit), quad-precision (128-bit)\n+\t     and aggregates including complex numbers are aligned on\n+\t     128-bit boundaries.  The first eight 64-bit argument slots\n+\t     are associated one-to-one, with general registers r26\n+\t     through r19, and also with floating-point registers fr4\n+\t     through fr11.  Arguments larger than one word are always\n+\t     passed in general registers.  */\n+\n+\t  rtx loc[8];\n+\t  int i, offset = 0, ub = arg_size;\n+\n+\t  /* Align the base register.  */\n+\t  gpr_reg_base -= alignment;\n+\n+\t  ub = MIN (ub, max_arg_words - cum->words - alignment);\n+\t  for (i = 0; i < ub; i++)\n \t    {\n-\t      /* First deal with alignment of the doubleword.  */\n-\t      gpr_reg_base -= (cum->words & 1);\n-\n-\t      /* This seems backwards, but it is what HP specifies.  We need\n-\t         gpr_reg_base to point to the smaller numbered register of\n-\t         the integer register pair.  So if we have an even register\n-\t          number, then decrement the gpr base.  */\n-\t      gpr_reg_base -= ((gpr_reg_base % 2) == 0);\n-\n-\t      /* FP values behave sanely, except that each FP reg is only\n-\t         half of word.  */\n-\t      fpr_reg_base += ((fpr_reg_base % 2) == 0);\n-            }\n-\t  else\n-\t    {\n-\t      rtx loc[8];\n-\t      int i, offset = 0, ub;\n-              ub = FUNCTION_ARG_SIZE (mode, type);\n-\t      ub = MIN (ub,\n-\t\t\tMAX (0, max_arg_words - cum->words - (cum->words & 1)));\n-\t      gpr_reg_base -= (cum->words & 1);\n-\t      for (i = 0; i < ub; i++)\n-\t\t{\n-\t\t  loc[i] = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t      gen_rtx_REG (DImode,\n-\t\t\t\t\t\t\t   gpr_reg_base),\n-\t\t\t\t\t      GEN_INT (offset));\n-\t\t  gpr_reg_base -= 1;\n-\t\t  offset += 8;\n-\t\t}\n-\t      if (ub == 0)\n-\t\treturn NULL_RTX;\n-\t      else if (ub == 1)\n-\t\treturn XEXP (loc[0], 0);\n-\t      else\n-\t\treturn gen_rtx_PARALLEL (mode, gen_rtvec_v (ub, loc));\n+\t      loc[i] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (DImode, gpr_reg_base),\n+\t\t\t\t\t  GEN_INT (offset));\n+\t      gpr_reg_base -= 1;\n+\t      offset += 8;\n \t    }\n+\n+\t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (ub, loc));\n \t}\n     }\n   else\n     {\n       /* If the argument is larger than a word, then we know precisely\n \t which registers we must use.  */\n-      if (FUNCTION_ARG_SIZE (mode, type) > 1)\n+      if (arg_size > 1)\n \t{\n \t  if (cum->words)\n \t    {\n@@ -7559,19 +7544,6 @@ function_arg (cum, mode, type, named, incoming)\n \t}\n     }\n \n-  if (TARGET_64BIT && mode == TFmode)\n-    {\n-      return\n-\tgen_rtx_PARALLEL\n-\t  (mode,\n-\t   gen_rtvec (2,\n-\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t gen_rtx_REG (DImode, gpr_reg_base + 1),\n-\t\t\t\t\t const0_rtx),\n-\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t gen_rtx_REG (DImode, gpr_reg_base),\n-\t\t\t\t\t GEN_INT (8))));\n-    }\n   /* Determine if the argument needs to be passed in both general and\n      floating point registers.  */\n   if (((TARGET_PORTABLE_RUNTIME || TARGET_64BIT || TARGET_ELF32)"}, {"sha": "0af4c5fb2706cd9d104f4c330dfaf7a7293e3d93", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "patch": "@@ -234,16 +234,21 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the mode of the object illegally.  */\n-/* ??? This may not actually be necessary anymore.  But until I can prove\n-   otherwise it will stay.  */\n+\n #define CLASS_CANNOT_CHANGE_MODE\t(FP_REGS)\n \n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n+/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.\n+\n+   SImode loads to floating-point registers are not zero-extended.\n+   The definition for LOAD_EXTEND_OP specifies that integer loads\n+   narrower than BITS_PER_WORD will be zero-extended.  As a result,\n+   we inhibit changes from SImode unless they are to a mode that is\n+   identical in size.  */\n+\n+#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO)\t\t\t\t\\\n+  ((FROM) == SImode && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n \n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n+/* Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n "}, {"sha": "5872ab055fb948a42d8c1bd69d66c566f67fadad", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015b1ad1dfa8fbd7323691515a5c1c38c4c1541d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=015b1ad1dfa8fbd7323691515a5c1c38c4c1541d", "patch": "@@ -2265,21 +2265,26 @@ emit_group_load (dst, orig_src, ssize)\n \t}\n       else if (GET_CODE (src) == CONCAT)\n \t{\n-\t  if ((bytepos == 0\n-\t       && bytelen == GET_MODE_SIZE (GET_MODE (XEXP (src, 0))))\n-\t      || (bytepos == (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (XEXP (src, 0)))\n-\t\t  && bytelen == GET_MODE_SIZE (GET_MODE (XEXP (src, 1)))))\n+\t  unsigned int slen = GET_MODE_SIZE (GET_MODE (src));\n+\t  unsigned int slen0 = GET_MODE_SIZE (GET_MODE (XEXP (src, 0)));\n+\n+\t  if ((bytepos == 0 && bytelen == slen0)\n+\t      || (bytepos != 0 && bytepos + bytelen <= slen))\n \t    {\n-\t      tmps[i] = XEXP (src, bytepos != 0);\n+\t      /* The following assumes that the concatenated objects all\n+\t\t have the same size.  In this case, a simple calculation\n+\t\t can be used to determine the object and the bit field\n+\t\t to be extracted.  */\n+\t      tmps[i] = XEXP (src, bytepos / slen0);\n \t      if (! CONSTANT_P (tmps[i])\n \t\t  && (GET_CODE (tmps[i]) != REG || GET_MODE (tmps[i]) != mode))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n-\t\t\t\t\t     0, 1, NULL_RTX, mode, mode, ssize);\n+\t\t\t\t\t     (bytepos % slen0) * BITS_PER_UNIT,\n+\t\t\t\t\t     1, NULL_RTX, mode, mode, ssize);\n \t    }\n \t  else if (bytepos == 0)\n \t    {\n-\t      rtx mem = assign_stack_temp (GET_MODE (src),\n-\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (src)), 0);\n+\t      rtx mem = assign_stack_temp (GET_MODE (src), slen, 0);\n \t      emit_move_insn (mem, src);\n \t      tmps[i] = adjust_address (mem, mode, 0);\n \t    }"}]}