{"sha": "7178e3af78b543cef6eaa8f3de26708f536b3ce7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE3OGUzYWY3OGI1NDNjZWY2ZWFhOGYzZGUyNjcwOGY1MzZiM2NlNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-26T23:02:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-26T23:02:43Z"}, "message": "Use INTEGRAL_TYPE_P and FLOAT_TYPE_P.\n\nFrom-SVN: r4241", "tree": {"sha": "01fef45fa5bc6f524750737f32e98a27a380bc52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01fef45fa5bc6f524750737f32e98a27a380bc52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7178e3af78b543cef6eaa8f3de26708f536b3ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7178e3af78b543cef6eaa8f3de26708f536b3ce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7178e3af78b543cef6eaa8f3de26708f536b3ce7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7178e3af78b543cef6eaa8f3de26708f536b3ce7/comments", "author": null, "committer": null, "parents": [{"sha": "8729113865444cd9afe48970e6f813a982583eb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8729113865444cd9afe48970e6f813a982583eb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8729113865444cd9afe48970e6f813a982583eb0"}], "stats": {"total": 55, "additions": 25, "deletions": 30}, "files": [{"sha": "43995c60a0b88b67421581f983225ec509c5c16f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7178e3af78b543cef6eaa8f3de26708f536b3ce7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7178e3af78b543cef6eaa8f3de26708f536b3ce7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7178e3af78b543cef6eaa8f3de26708f536b3ce7", "patch": "@@ -987,14 +987,13 @@ split_tree (in, code, varp, conp, varsignp)\n     in = TREE_OPERAND (in, 0);\n \n   if (TREE_CODE (in) == code\n-      || (TREE_CODE (TREE_TYPE (in)) != REAL_TYPE\n+      || (! FLOAT_TYPE_P (TREE_TYPE (in))\n \t  /* We can associate addition and subtraction together\n \t     (even though the C standard doesn't say so)\n \t     for integers because the value is not affected.\n \t     For reals, the value might be affected, so we can't.  */\n-\t  &&\n-\t  ((code == PLUS_EXPR && TREE_CODE (in) == MINUS_EXPR)\n-\t   || (code == MINUS_EXPR && TREE_CODE (in) == PLUS_EXPR))))\n+\t  && ((code == PLUS_EXPR && TREE_CODE (in) == MINUS_EXPR)\n+\t      || (code == MINUS_EXPR && TREE_CODE (in) == PLUS_EXPR))))\n     {\n       enum tree_code code = TREE_CODE (TREE_OPERAND (in, 0));\n       if (code == INTEGER_CST)\n@@ -1503,9 +1502,7 @@ fold_convert (t, arg1)\n {\n   register tree type = TREE_TYPE (t);\n \n-  if (TREE_CODE (type) == POINTER_TYPE\n-      || TREE_CODE (type) == INTEGER_TYPE\n-      || TREE_CODE (type) == ENUMERAL_TYPE)\n+  if (TREE_CODE (type) == POINTER_TYPE || INTEGRAL_TYPE_P (type))\n     {\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \t{\n@@ -1820,7 +1817,7 @@ operand_equal_for_comparison_p (arg0, arg1, other)\n   if (operand_equal_p (arg0, arg1, 0))\n     return 1;\n \n-  if (TREE_CODE (TREE_TYPE (arg0)) != INTEGER_TYPE)\n+  if (! INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n     return 0;\n \n   /* Duplicate what shorten_compare does to ARG1 and see if that gives the\n@@ -2052,7 +2049,7 @@ invert_truthvalue (arg)\n \n   if (TREE_CODE_CLASS (code) == '<')\n     {\n-      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REAL_TYPE\n+      if (FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n \t  && code != NE_EXPR && code != EQ_EXPR)\n \treturn build1 (TRUTH_NOT_EXPR, type, arg);\n       else\n@@ -2614,8 +2611,7 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \n   /* Fail if VAR isn't an integer.  */\n   utype = TREE_TYPE (var);\n-  if (TREE_CODE (utype) != INTEGER_TYPE\n-      && TREE_CODE (utype) != ENUMERAL_TYPE)\n+  if (! INTEGRAL_TYPE_P (utype))\n     return 0;\n \n   /* The range test is invalid if subtracting the two constants results\n@@ -2754,7 +2750,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n      are with zero (tmw).  */\n \n   if (BRANCH_COST >= 2\n-      && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE\n+      && INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n       && simple_operand_p (rl_arg)\n       && simple_operand_p (rr_arg))\n     return build (code, truth_type, lhs, rhs);\n@@ -3329,7 +3325,7 @@ fold (expr)\n \treturn TREE_OPERAND (arg0, 0);\n \n       /* Convert - (a - b) to (b - a) for non-floating-point.  */\n-      else if (TREE_CODE (arg0) == MINUS_EXPR && TREE_CODE (type) != REAL_TYPE)\n+      else if (TREE_CODE (arg0) == MINUS_EXPR && ! FLOAT_TYPE_P (type))\n \treturn build (MINUS_EXPR, type, TREE_OPERAND (arg0, 1),\n \t\t      TREE_OPERAND (arg0, 0));\n \n@@ -3384,7 +3380,7 @@ fold (expr)\n       /* A + (-B) -> A - B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n \treturn fold (build (MINUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n-      else if (TREE_CODE (type) != REAL_TYPE)\n+      else if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n \t    return non_lvalue (convert (type, arg0));\n@@ -3413,7 +3409,7 @@ fold (expr)\n       /* In most languages, can't associate operations on floats\n \t through parentheses.  Rather than remember where the parentheses\n \t were, we don't associate floats at all.  It shouldn't matter much.  */\n-      if (TREE_CODE (type) == REAL_TYPE)\n+      if (FLOAT_TYPE_P (type))\n \tgoto binary;\n       /* The varsign == -1 cases happen only for addition and subtraction.\n \t It says that the arg that was split was really CON minus VAR.\n@@ -3524,7 +3520,7 @@ fold (expr)\n       return t;\n \n     case MINUS_EXPR:\n-      if (TREE_CODE (type) != REAL_TYPE)\n+      if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (! wins && integer_zerop (arg0))\n \t    return build1 (NEGATE_EXPR, type, arg1);\n@@ -3549,14 +3545,13 @@ fold (expr)\n \t     Also note that operand_equal_p is always false if an operand\n \t     is volatile.  */\n \n-\t  if (operand_equal_p (arg0, arg1,\n-\t\t\t       TREE_CODE (type) == REAL_TYPE))\n+\t  if (operand_equal_p (arg0, arg1, FLOAT_TYPE_P (type)))\n \t    return convert (type, integer_zero_node);\n \t}\n       goto associate;\n \n     case MULT_EXPR:\n-      if (TREE_CODE (type) != REAL_TYPE)\n+      if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n \t    return omit_one_operand (type, arg1, arg0);\n@@ -3764,15 +3759,15 @@ fold (expr)\n     case MIN_EXPR:\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn arg0;\n-      if (TREE_CODE (type) == INTEGER_TYPE\n+      if (INTEGRAL_TYPE_P (type)\n \t  && operand_equal_p (arg1, TYPE_MIN_VALUE (type), 1))\n \treturn omit_one_operand (type, arg1, arg0);\n       goto associate;\n \n     case MAX_EXPR:\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn arg0;\n-      if (TREE_CODE (type) == INTEGER_TYPE\n+      if (INTEGRAL_TYPE_P (type)\n \t  && operand_equal_p (arg1, TYPE_MAX_VALUE (type), 1))\n \treturn omit_one_operand (type, arg1, arg0);\n       goto associate;\n@@ -3891,7 +3886,7 @@ fold (expr)\n \t       This optimization is invalid for floating point due to rounding.\n \t       For pointer types we assume overflow doesn't happen.  */\n \t    if (TREE_CODE (TREE_TYPE (varop)) == POINTER_TYPE\n-\t\t|| (TREE_CODE (TREE_TYPE (varop)) != REAL_TYPE\n+\t\t|| (! FLOAT_TYPE_P (TREE_TYPE (varop))\n \t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n \t      {\n \t\ttree newconst\n@@ -3905,7 +3900,7 @@ fold (expr)\n \telse if (constop && TREE_CODE (varop) == POSTDECREMENT_EXPR)\n \t  {\n \t    if (TREE_CODE (TREE_TYPE (varop)) == POINTER_TYPE\n-\t\t|| (TREE_CODE (TREE_TYPE (varop)) != REAL_TYPE\n+\t\t|| (! FLOAT_TYPE_P (TREE_TYPE (varop))\n \t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n \t      {\n \t\ttree newconst\n@@ -3999,7 +3994,7 @@ fold (expr)\n \t    case EQ_EXPR:\n \t    case GE_EXPR:\n \t    case LE_EXPR:\n-\t      if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE)\n+\t      if (INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n \t\t{\n \t\t  t = build_int_2 (1, 0);\n \t\t  TREE_TYPE (t) = type;\n@@ -4011,7 +4006,7 @@ fold (expr)\n \n \t    case NE_EXPR:\n \t      /* For NE, we can only do this simplification if integer.  */\n-\t      if (TREE_CODE (TREE_TYPE (arg0)) != INTEGER_TYPE)\n+\t      if (! INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n \t\tbreak;\n \t      /* ... fall through ... */\n \t    case GT_EXPR:\n@@ -4024,7 +4019,7 @@ fold (expr)\n \n       /* An unsigned comparison against 0 can be simplified.  */\n       if (integer_zerop (arg1)\n-\t  && (TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n \t      || TREE_CODE (TREE_TYPE (arg1)) == POINTER_TYPE)\n \t  && TREE_UNSIGNED (TREE_TYPE (arg1)))\n \t{\n@@ -4070,7 +4065,7 @@ fold (expr)\n \t      && cval1 != 0 && cval2 != 0\n \t      && ! (TREE_CONSTANT (cval1) && TREE_CONSTANT (cval2))\n \t      && TREE_TYPE (cval1) == TREE_TYPE (cval2)\n-\t      && TREE_CODE (TREE_TYPE (cval1)) == INTEGER_TYPE\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (cval1))\n \t      && ! operand_equal_p (TYPE_MIN_VALUE (TREE_TYPE (cval1)),\n \t\t\t\t    TYPE_MAX_VALUE (TREE_TYPE (cval2)), 0))\n \t    {\n@@ -4279,7 +4274,7 @@ fold (expr)\n \n       if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n \t  && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t      || TREE_CODE (TREE_TYPE (TREE_OPERAND (arg0, 0))) != REAL_TYPE)\n+\t      || ! FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1)))\n \t{\n@@ -4340,9 +4335,9 @@ fold (expr)\n \t     we might still be able to simplify this.  For example,\n \t     if C1 is one less or one more than C2, this might have started\n \t     out as a MIN or MAX and been transformed by this function.\n-\t     Only good for INTEGER_TYPE, because we need TYPE_MAX_VALUE.  */\n+\t     Only good for INTEGER_TYPEs, because we need TYPE_MAX_VALUE.  */\n \n-\t  if (TREE_CODE (type) == INTEGER_TYPE\n+\t  if (INTEGRAL_TYPE_P (type)\n \t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n \t      && TREE_CODE (arg2) == INTEGER_CST)\n \t    switch (comp_code)"}]}