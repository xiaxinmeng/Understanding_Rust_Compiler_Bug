{"sha": "54866f7a81a2af4a6097146a1c78bd09bb437883", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ4NjZmN2E4MWEyYWY0YTYwOTcxNDZhMWM3OGJkMDliYjQzNzg4Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-09-16T23:09:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-09-16T23:48:19Z"}, "message": "libgo: update to go1.17.1 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/350414", "tree": {"sha": "4de6eb05a5d33a651cc25dc13296f8e4b9876cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4de6eb05a5d33a651cc25dc13296f8e4b9876cba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54866f7a81a2af4a6097146a1c78bd09bb437883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54866f7a81a2af4a6097146a1c78bd09bb437883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54866f7a81a2af4a6097146a1c78bd09bb437883", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54866f7a81a2af4a6097146a1c78bd09bb437883/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "745781d24cd7562202687cfbe05597ee673d4537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/745781d24cd7562202687cfbe05597ee673d4537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/745781d24cd7562202687cfbe05597ee673d4537"}], "stats": {"total": 175, "additions": 154, "deletions": 21}, "files": [{"sha": "e2abd5fc4b78f56f760ac3ee9caa3061ab91b2a7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -1,4 +1,4 @@\n-c11d9f8275f2bbe9b05cdd815c79ac331f78e15c\n+850235e4b974b9c5c2d7a1f9860583bd07f2a45c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4473f479d5f8681a6ea4e5908f00f09dc261cd00", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -1,4 +1,4 @@\n-ec5170397c724a8ae440b2bc529f857c86f0e6b1\n+21a4e67ad58e3c4a7c5254f60cda5be5c3c450ff\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "844393b24b0958afae43bbd8344d8acff17fb91a", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -1 +1 @@\n-go1.17\n+go1.17.1"}, {"sha": "c91a8d00e6c1d488a4386296bb8a20ddaf14e3bb", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -102,7 +102,7 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \t// indicate it contains up to 1 << 128 - 1 files. Since each file has a\n \t// header which will be _at least_ 30 bytes we can safely preallocate\n \t// if (data size / 30) >= end.directoryRecords.\n-\tif (uint64(size)-end.directorySize)/30 >= end.directoryRecords {\n+\tif end.directorySize < uint64(size) && (uint64(size)-end.directorySize)/30 >= end.directoryRecords {\n \t\tz.File = make([]*File, 0, end.directoryRecords)\n \t}\n \tz.Comment = end.comment"}, {"sha": "afb03ace24d286dee2208d46ee3ce274a55e47f4", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -1384,3 +1384,21 @@ func TestCVE202133196(t *testing.T) {\n \t\tt.Errorf(\"Archive has unexpected number of files, got %d, want 5\", len(r.File))\n \t}\n }\n+\n+func TestCVE202139293(t *testing.T) {\n+\t// directory size is so large, that the check in Reader.init\n+\t// overflows when subtracting from the archive size, causing\n+\t// the pre-allocation check to be bypassed.\n+\tdata := []byte{\n+\t\t0x50, 0x4b, 0x06, 0x06, 0x05, 0x06, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b,\n+\t\t0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+\t\t0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b,\n+\t\t0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+\t\t0x00, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,\n+\t\t0xff, 0x50, 0xfe, 0x00, 0xff, 0x00, 0x3a, 0x00, 0x00, 0x00, 0xff,\n+\t}\n+\t_, err := NewReader(bytes.NewReader(data), int64(len(data)))\n+\tif err != ErrFormat {\n+\t\tt.Fatalf(\"unexpected error, got: %v, want: %v\", err, ErrFormat)\n+\t}\n+}"}, {"sha": "47f236ce1682772d5b9d6366ff14ba206f8b8565", "filename": "libgo/go/cmd/go/internal/modload/edit.go", "status": "modified", "additions": 75, "deletions": 11, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -190,8 +190,8 @@ func limiterForEdit(ctx context.Context, rs *Requirements, tryUpgrade, mustSelec\n \n // raiseLimitsForUpgrades increases the module versions in maxVersions to the\n // versions that would be needed to allow each of the modules in tryUpgrade\n-// (individually) and all of the modules in mustSelect (simultaneously) to be\n-// added as roots.\n+// (individually or in any combination) and all of the modules in mustSelect\n+// (simultaneously) to be added as roots.\n //\n // Versions not present in maxVersion are unrestricted, and it is assumed that\n // they will not be promoted to root requirements (and thus will not contribute\n@@ -213,18 +213,42 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t\t}\n \t}\n \n-\tvar eagerUpgrades []module.Version\n+\tvar (\n+\t\teagerUpgrades  []module.Version\n+\t\tisLazyRootPath map[string]bool\n+\t)\n \tif depth == eager {\n \t\teagerUpgrades = tryUpgrade\n \t} else {\n+\t\tisLazyRootPath = make(map[string]bool, len(maxVersion))\n+\t\tfor p := range maxVersion {\n+\t\t\tisLazyRootPath[p] = true\n+\t\t}\n \t\tfor _, m := range tryUpgrade {\n+\t\t\tisLazyRootPath[m.Path] = true\n+\t\t}\n+\t\tfor _, m := range mustSelect {\n+\t\t\tisLazyRootPath[m.Path] = true\n+\t\t}\n+\n+\t\tallowedRoot := map[module.Version]bool{}\n+\n+\t\tvar allowRoot func(m module.Version) error\n+\t\tallowRoot = func(m module.Version) error {\n+\t\t\tif allowedRoot[m] {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tallowedRoot[m] = true\n+\n \t\t\tif m.Path == Target.Path {\n \t\t\t\t// Target is already considered to be higher than any possible m, so we\n \t\t\t\t// won't be upgrading to it anyway and there is no point scanning its\n \t\t\t\t// dependencies.\n-\t\t\t\tcontinue\n+\t\t\t\treturn nil\n \t\t\t}\n \n+\t\t\tallow(m)\n+\n \t\t\tsummary, err := goModSummary(m)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n@@ -234,12 +258,27 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t\t\t\t// graph, rather than loading the (potentially-overlapping) subgraph for\n \t\t\t\t// each upgrade individually.\n \t\t\t\teagerUpgrades = append(eagerUpgrades, m)\n-\t\t\t\tcontinue\n+\t\t\t\treturn nil\n \t\t\t}\n-\n \t\t\tfor _, r := range summary.require {\n-\t\t\t\tallow(r)\n+\t\t\t\tif isLazyRootPath[r.Path] {\n+\t\t\t\t\t// r could become a root as the result of an upgrade or downgrade,\n+\t\t\t\t\t// in which case its dependencies will not be pruned out.\n+\t\t\t\t\t// We need to allow those dependencies to be upgraded too.\n+\t\t\t\t\tif err := allowRoot(r); err != nil {\n+\t\t\t\t\t\treturn err\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// r will not become a root, so its dependencies don't matter.\n+\t\t\t\t\t// Allow only r itself.\n+\t\t\t\t\tallow(r)\n+\t\t\t\t}\n \t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tfor _, m := range tryUpgrade {\n+\t\t\tallowRoot(m)\n \t\t}\n \t}\n \n@@ -268,16 +307,41 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t\t}\n \t}\n \n-\tif len(mustSelect) > 0 {\n-\t\tmustGraph, err := readModGraph(ctx, depth, mustSelect)\n+\t// Explicitly allow any (transitive) upgrades implied by mustSelect.\n+\tnextRoots := append([]module.Version(nil), mustSelect...)\n+\tfor nextRoots != nil {\n+\t\tmodule.Sort(nextRoots)\n+\t\trs := newRequirements(depth, nextRoots, nil)\n+\t\tnextRoots = nil\n+\n+\t\trs, mustGraph, err := expandGraph(ctx, rs)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \n \t\tfor _, r := range mustGraph.BuildList() {\n-\t\t\t// Some module in mustSelect requires r, so we must allow at least r.Version\n-\t\t\t// unless it conflicts with an entry in mustSelect.\n+\t\t\t// Some module in mustSelect requires r, so we must allow at least\n+\t\t\t// r.Version (unless it conflicts with another entry in mustSelect, in\n+\t\t\t// which case we will error out either way).\n \t\t\tallow(r)\n+\n+\t\t\tif isLazyRootPath[r.Path] {\n+\t\t\t\tif v, ok := rs.rootSelected(r.Path); ok && r.Version == v {\n+\t\t\t\t\t// r is already a root, so its requirements are already included in\n+\t\t\t\t\t// the build list.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\t// The dependencies in mustSelect may upgrade (or downgrade) an existing\n+\t\t\t\t// root to match r, which will remain as a root. However, since r is not\n+\t\t\t\t// a root of rs, its dependencies have been pruned out of this build\n+\t\t\t\t// list. We need to add it back explicitly so that we allow any\n+\t\t\t\t// transitive upgrades that r will pull in.\n+\t\t\t\tif nextRoots == nil {\n+\t\t\t\t\tnextRoots = rs.rootModules // already capped\n+\t\t\t\t}\n+\t\t\t\tnextRoots = append(nextRoots, r)\n+\t\t\t}\n \t\t}\n \t}\n "}, {"sha": "dd725372ad918a85d533b3dc30e213d49616bcd7", "filename": "libgo/go/crypto/rand/rand_getentropy.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fcrypto%2Frand%2Frand_getentropy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fcrypto%2Frand%2Frand_getentropy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_getentropy.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//go:build darwin || openbsd\n-// +build darwin openbsd\n+//go:build (darwin && !ios) || openbsd\n+// +build darwin,!ios openbsd\n \n package rand\n "}, {"sha": "b41359f4c2822552fad425240bdb747e521bf935", "filename": "libgo/go/embed/internal/embedtest/embed_test.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembed_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembed_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembed_test.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -129,3 +129,43 @@ func TestUninitialized(t *testing.T) {\n \t\tt.Errorf(\"in uninitialized embed.FS, . is not a directory\")\n \t}\n }\n+\n+var (\n+\t//go:embed \"testdata/hello.txt\"\n+\thelloT []T\n+\t//go:embed \"testdata/hello.txt\"\n+\thelloUint8 []uint8\n+\t//go:embed \"testdata/hello.txt\"\n+\thelloEUint8 []EmbedUint8\n+\t//go:embed \"testdata/hello.txt\"\n+\thelloBytes EmbedBytes\n+\t//go:embed \"testdata/hello.txt\"\n+\thelloString EmbedString\n+)\n+\n+type T byte\n+type EmbedUint8 uint8\n+type EmbedBytes []byte\n+type EmbedString string\n+\n+// golang.org/issue/47735\n+func TestAliases(t *testing.T) {\n+\tall := testDirAll\n+\twant, e := all.ReadFile(\"testdata/hello.txt\")\n+\tif e != nil {\n+\t\tt.Fatal(\"ReadFile:\", e)\n+\t}\n+\tcheck := func(g interface{}) {\n+\t\tgot := reflect.ValueOf(g)\n+\t\tfor i := 0; i < got.Len(); i++ {\n+\t\t\tif byte(got.Index(i).Uint()) != want[i] {\n+\t\t\t\tt.Fatalf(\"got %v want %v\", got.Bytes(), want)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tcheck(helloT)\n+\tcheck(helloUint8)\n+\tcheck(helloEUint8)\n+\tcheck(helloBytes)\n+\tcheck(helloString)\n+}"}, {"sha": "a89afcc101bc81d040d37f635cbf144ae751bbb1", "filename": "libgo/go/go.mod", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo.mod?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -4,7 +4,7 @@ go 1.17\n \n require (\n \tgolang.org/x/crypto v0.0.0-20210503195802-e9a32991a82e\n-\tgolang.org/x/net v0.0.0-20210510120150-4163338589ed\n+\tgolang.org/x/net v0.0.0-20210901185426-6d2eada6345e\n \tgolang.org/x/sys v0.0.0-20210511113859-b0526f3d8744 // indirect\n \tgolang.org/x/text v0.3.7-0.20210503195748-5c7c50ebbd4f // indirect\n )"}, {"sha": "336b526a2843d3b977986a07ba3b9bfeef6a4e8d", "filename": "libgo/go/go/types/call.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -224,7 +224,6 @@ func (check *Checker) exprList(elist []ast.Expr, allowCommaOk bool) (xlist []*op\n \t\t// exactly one (possibly invalid or comma-ok) value\n \t\txlist = []*operand{&x}\n \t\tif allowCommaOk && (x.mode == mapindex || x.mode == commaok || x.mode == commaerr) {\n-\t\t\tx.mode = value\n \t\t\tx2 := &operand{mode: value, expr: e, typ: Typ[UntypedBool]}\n \t\t\tif x.mode == commaerr {\n \t\t\t\tx2.typ = universeError"}, {"sha": "4892218b75453cd8cc2f539a74e0269df4bc785c", "filename": "libgo/go/go/types/resolver.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -276,7 +276,7 @@ func (check *Checker) collectObjects() {\n \t\t\t\t}\n \n \t\t\t\tif name == \"init\" {\n-\t\t\t\t\tcheck.errorf(d.spec.Name, _InvalidInitDecl, \"cannot import package as init - init must be a func\")\n+\t\t\t\t\tcheck.errorf(d.spec, _InvalidInitDecl, \"cannot import package as init - init must be a func\")\n \t\t\t\t\treturn\n \t\t\t\t}\n "}, {"sha": "c75006bf8b686742463b1d601d2ec51eff20cf46", "filename": "libgo/go/internal/syscall/unix/getentropy_darwin.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fgetentropy_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fgetentropy_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fgetentropy_darwin.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -2,6 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build darwin && !ios\n+// +build darwin,!ios\n+\n package unix\n \n import ("}, {"sha": "8958a9e5b9b4119bda6c3ff0859c2ee26064715f", "filename": "libgo/go/net/http/h2_bundle.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -4519,6 +4519,15 @@ func (sc *http2serverConn) serve() {\n \t\tcase res := <-sc.wroteFrameCh:\n \t\t\tsc.wroteFrame(res)\n \t\tcase res := <-sc.readFrameCh:\n+\t\t\t// Process any written frames before reading new frames from the client since a\n+\t\t\t// written frame could have triggered a new stream to be started.\n+\t\t\tif sc.writingFrameAsync {\n+\t\t\t\tselect {\n+\t\t\t\tcase wroteRes := <-sc.wroteFrameCh:\n+\t\t\t\t\tsc.wroteFrame(wroteRes)\n+\t\t\t\tdefault:\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif !sc.processFrameFromReader(res) {\n \t\t\t\treturn\n \t\t\t}"}, {"sha": "70d42ed32c6baa1f21cd7103b4453269a9173ebf", "filename": "libgo/go/vendor/modules.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fvendor%2Fmodules.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54866f7a81a2af4a6097146a1c78bd09bb437883/libgo%2Fgo%2Fvendor%2Fmodules.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fvendor%2Fmodules.txt?ref=54866f7a81a2af4a6097146a1c78bd09bb437883", "patch": "@@ -8,7 +8,7 @@ golang.org/x/crypto/curve25519\n golang.org/x/crypto/hkdf\n golang.org/x/crypto/internal/subtle\n golang.org/x/crypto/poly1305\n-# golang.org/x/net v0.0.0-20210510120150-4163338589ed\n+# golang.org/x/net v0.0.0-20210901185426-6d2eada6345e\n ## explicit; go 1.17\n golang.org/x/net/dns/dnsmessage\n golang.org/x/net/http/httpguts"}]}