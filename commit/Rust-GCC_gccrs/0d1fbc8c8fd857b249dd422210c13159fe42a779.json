{"sha": "0d1fbc8c8fd857b249dd422210c13159fe42a779", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQxZmJjOGM4ZmQ4NTdiMjQ5ZGQ0MjIyMTBjMTMxNTlmZTQyYTc3OQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2004-05-08T17:08:51Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2004-05-08T17:08:51Z"}, "message": "rs6000-protos.h (rs6000_hard_regno_mode_ok_p): Declare.\n\n\t* config/rs6000/rs6000-protos.h (rs6000_hard_regno_mode_ok_p):\n\tDeclare.\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok_p): New.\n\t(rs6000_hard_regno_mode_ok): New.\n\t(rs6000_init_hard_regno_mode_ok): New.\n\t(rs6000_override_options): Call rs6000_init_hard_regno_mode_ok.\n\n\t* config/rs6000/rs6000.h (HARD_REGNO_NREGS): Use precomputed\n\tresult.\n\nFrom-SVN: r81642", "tree": {"sha": "7eef947fb0ad3e8f51b9f760e58ee8c82bb1300d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eef947fb0ad3e8f51b9f760e58ee8c82bb1300d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d1fbc8c8fd857b249dd422210c13159fe42a779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1fbc8c8fd857b249dd422210c13159fe42a779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d1fbc8c8fd857b249dd422210c13159fe42a779", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1fbc8c8fd857b249dd422210c13159fe42a779/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f95d92720298e65753dc72b4e6ee38f567dd3028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95d92720298e65753dc72b4e6ee38f567dd3028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95d92720298e65753dc72b4e6ee38f567dd3028"}], "stats": {"total": 96, "additions": 76, "deletions": 20}, "files": [{"sha": "c08dc3bb5ddfce0b996d0eca612a830ad5f24968", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d1fbc8c8fd857b249dd422210c13159fe42a779", "patch": "@@ -1,3 +1,16 @@\n+2004-05-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_hard_regno_mode_ok_p):\n+\tDeclare.\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok_p): New.\n+\t(rs6000_hard_regno_mode_ok): New.\n+\t(rs6000_init_hard_regno_mode_ok): New.\n+\t(rs6000_override_options): Call rs6000_init_hard_regno_mode_ok.\n+\n+\t* config/rs6000/rs6000.h (HARD_REGNO_NREGS): Use precomputed\n+\tresult.\n+\n 2004-05-07  Ziemowit Laski  <zlaski@apple.com>\n \n \t* config/rs6000/altivec.h (vector, pixel, bool): Do not"}, {"sha": "fa8a3829e726349a5763d637aec5f38ee1c265df", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0d1fbc8c8fd857b249dd422210c13159fe42a779", "patch": "@@ -212,4 +212,5 @@ extern void rs6000_cpu_cpp_builtins (struct cpp_reader *);\n char *output_call (rtx, rtx *, int, int);\n #endif\n \n+extern bool rs6000_hard_regno_mode_ok_p[][FIRST_PSEUDO_REGISTER];\n #endif  /* rs6000-protos.h */"}, {"sha": "bf831eabdbd7a32822e5938d478437f188771e54", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0d1fbc8c8fd857b249dd422210c13159fe42a779", "patch": "@@ -215,6 +215,9 @@ const char *rs6000_debug_name;\n int rs6000_debug_stack;\t\t/* debug stack applications */\n int rs6000_debug_arg;\t\t/* debug argument handling */\n \n+/* Value is TRUE if register/mode pair is accepatable.  */\n+bool rs6000_hard_regno_mode_ok_p[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n+\n /* Opaque types.  */\n static GTY(()) tree opaque_V2SI_type_node;\n static GTY(()) tree opaque_V2SF_type_node;\n@@ -645,6 +648,58 @@ static const char alt_reg_names[][8] =\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode\n+   MODE.  */\n+static int\n+rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+{\n+  /* The GPRs can hold any mode, but values bigger than one register\n+     cannot go past R31.  */\n+  if (INT_REGNO_P (regno))\n+    return INT_REGNO_P (regno + HARD_REGNO_NREGS (regno, mode) - 1);\n+\n+  /* The float registers can only hold floating modes and DImode.  */\n+  if (FP_REGNO_P (regno))\n+    return\n+      (GET_MODE_CLASS (mode) == MODE_FLOAT\n+       && FP_REGNO_P (regno + HARD_REGNO_NREGS (regno, mode) - 1))\n+      || (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_SIZE (mode) == UNITS_PER_FP_WORD);\n+\n+  /* The CR register can only hold CC modes.  */\n+  if (CR_REGNO_P (regno))\n+    return GET_MODE_CLASS (mode) == MODE_CC;\n+\n+  if (XER_REGNO_P (regno))\n+    return mode == PSImode;\n+\n+  /* AltiVec only in AldyVec registers.  */\n+  if (ALTIVEC_REGNO_P (regno))\n+    return ALTIVEC_VECTOR_MODE (mode);\n+\n+  /* ...but GPRs can hold SIMD data on the SPE in one register.  */\n+  if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n+    return 1;\n+\n+  /* We cannot put TImode anywhere except general register and it must be\n+     able to fit within the register set.  */\n+\n+  return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n+}\n+\n+/* Initialize rs6000_hard_regno_mode_ok_p table.  */\n+static void\n+rs6000_init_hard_regno_mode_ok (void)\n+{\n+  int r, m;\n+\n+  for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n+    for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+      if (rs6000_hard_regno_mode_ok (r, m))\n+\trs6000_hard_regno_mode_ok_p[m][r] = true;\n+}\n+\n /* Override command line options.  Mostly we process the processor\n    type and sometimes adjust other TARGET_ options.  */\n \n@@ -747,6 +802,9 @@ rs6000_override_options (const char *default_cpu)\n \t\t     | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_ALTIVEC\n \t\t     | MASK_MFCRF)\n   };\n+\n+  rs6000_init_hard_regno_mode_ok ();\n+\n  set_masks = POWER_MASKS | POWERPC_MASKS | MASK_SOFT_FLOAT;\n #ifdef OS_MISSING_POWERPC64\n   if (OS_MISSING_POWERPC64)"}, {"sha": "8bd516d3f2b3c927125a75215c6c900a13d08d30", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1fbc8c8fd857b249dd422210c13159fe42a779/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0d1fbc8c8fd857b249dd422210c13159fe42a779", "patch": "@@ -1027,26 +1027,10 @@ extern const char *rs6000_warn_altivec_long_switch;\n         ((TARGET_SPE && SPE_VECTOR_MODE (MODE))\t\t\\\n \t || (TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (MODE)))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   For POWER and PowerPC, the GPRs can hold any mode, but values bigger\n-   than one register cannot go past R31.  The float\n-   registers only can hold floating modes and DImode, and CR register only\n-   can hold CC modes.  We cannot put TImode anywhere except general\n-   register and it must be able to fit within the register set.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  (INT_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n-     INT_REGNO_P (REGNO + HARD_REGNO_NREGS (REGNO, MODE) - 1)\t        \\\n-   : FP_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n-     ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-       && FP_REGNO_P (REGNO + HARD_REGNO_NREGS (REGNO, MODE) - 1))\t\\\n-      || (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\\\n-\t  && GET_MODE_SIZE (MODE) == UNITS_PER_FP_WORD))\t\t\\\n-   : ALTIVEC_REGNO_P (REGNO) ? ALTIVEC_VECTOR_MODE (MODE)\t\t\\\n-   : SPE_SIMD_REGNO_P (REGNO) && TARGET_SPE && SPE_VECTOR_MODE (MODE) ? 1 \\\n-   : CR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC\t\t\\\n-   : XER_REGNO_P (REGNO) ? (MODE) == PSImode\t\t\t\t\\\n-   : GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\n+/* Value is TRUE if hard register REGNO can hold a value of\n+   machine-mode MODE.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  rs6000_hard_regno_mode_ok_p[(int)(MODE)][REGNO]\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2."}]}