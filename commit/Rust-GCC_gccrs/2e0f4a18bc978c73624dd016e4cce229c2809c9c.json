{"sha": "2e0f4a18bc978c73624dd016e4cce229c2809c9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUwZjRhMThiYzk3OGM3MzYyNGRkMDE2ZTRjY2UyMjljMjgwOWM5Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-18T10:11:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-18T10:12:43Z"}, "message": "phiopt: Improve minmax optimization [PR95699]\n\nAs discussed in the PR, the\nx < 0x80000000U to (int) x >= 0\noptimization stands in the way of minmax_replacement optimization,\nso for comparisons with most of the constants it works well, but when the\nabove mentioned optimization triggers, it is unable to do it.\nThe match.pd (cond (cmp (convert? x) c1) (op x c2) c3) -> (op (minmax x c1) c2)\noptimization is able to look through that and this patch\nteaches minmax_replacement about it too.\n\n2020-06-18  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/95699\n\t* tree-ssa-phiopt.c (minmax_replacement): Treat (signed int)x < 0\n\tas x > INT_MAX and (signed int)x >= 0 as x <= INT_MAX.  Move variable\n\tdeclarations to the statements that set them where possible.\n\n\t* gcc.dg/tree-ssa/pr95699.c: New test.", "tree": {"sha": "b707531c7df555f60f6fb700333cf9852ca54f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b707531c7df555f60f6fb700333cf9852ca54f77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e0f4a18bc978c73624dd016e4cce229c2809c9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0f4a18bc978c73624dd016e4cce229c2809c9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e0f4a18bc978c73624dd016e4cce229c2809c9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0f4a18bc978c73624dd016e4cce229c2809c9c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a875db43cd4210843c480c8df26a1d6624d057d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a875db43cd4210843c480c8df26a1d6624d057d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a875db43cd4210843c480c8df26a1d6624d057d"}], "stats": {"total": 102, "additions": 92, "deletions": 10}, "files": [{"sha": "43a2307aae6f30da54cac0f70ee4341ddd2e592a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr95699.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0f4a18bc978c73624dd016e4cce229c2809c9c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr95699.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0f4a18bc978c73624dd016e4cce229c2809c9c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr95699.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr95699.c?ref=2e0f4a18bc978c73624dd016e4cce229c2809c9c", "patch": "@@ -0,0 +1,39 @@\n+/* PR tree-optimization/95699 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump \"MAX_EXPR <\\[^>\\n\\r]*9223372036854775807\\[^>\\n\\r]*>\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"MAX_EXPR <\\[^>\\n\\r]*9223372036854775808\\[^>\\n\\r]*>\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"MIN_EXPR <\\[^>\\n\\r]*9223372036854775807\\[^>\\n\\r]*>\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"MIN_EXPR <\\[^>\\n\\r]*9223372036854775808\\[^>\\n\\r]*>\" \"optimized\" } } */\n+\n+unsigned long long\n+f1 (unsigned long long x)\n+{\n+  if (x < 0x7fffffffffffffffULL)\n+    x = 0x7fffffffffffffffULL;\n+  return x;\n+}\n+\n+unsigned long long\n+f2 (unsigned long long x)\n+{\n+  if (x < 0x8000000000000000ULL)\n+    x = 0x8000000000000000ULL;\n+  return x;\n+}\n+\n+unsigned long long\n+f3 (unsigned long long x)\n+{\n+  if (x >= 0x7fffffffffffffffULL)\n+    x = 0x7fffffffffffffffULL;\n+  return x;\n+}\n+\n+unsigned long long\n+f4 (unsigned long long x)\n+{\n+  if (x >= 0x8000000000000000ULL)\n+    x = 0x8000000000000000ULL;\n+  return x;\n+}"}, {"sha": "b97f863aaf350b9e2a1ccbac9334f327380a2079", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0f4a18bc978c73624dd016e4cce229c2809c9c/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0f4a18bc978c73624dd016e4cce229c2809c9c/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=2e0f4a18bc978c73624dd016e4cce229c2809c9c", "patch": "@@ -1363,22 +1363,21 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t    edge e0, edge e1, gimple *phi,\n \t\t    tree arg0, tree arg1)\n {\n-  tree result, type, rhs;\n-  gcond *cond;\n+  tree result;\n   edge true_edge, false_edge;\n-  enum tree_code cmp, minmax, ass_code;\n-  tree smaller, alt_smaller, larger, alt_larger, arg_true, arg_false;\n+  enum tree_code minmax, ass_code;\n+  tree smaller, larger, arg_true, arg_false;\n   gimple_stmt_iterator gsi, gsi_from;\n \n-  type = TREE_TYPE (PHI_RESULT (phi));\n+  tree type = TREE_TYPE (PHI_RESULT (phi));\n \n   /* The optimization may be unsafe due to NaNs.  */\n   if (HONOR_NANS (type) || HONOR_SIGNED_ZEROS (type))\n     return false;\n \n-  cond = as_a <gcond *> (last_stmt (cond_bb));\n-  cmp = gimple_cond_code (cond);\n-  rhs = gimple_cond_rhs (cond);\n+  gcond *cond = as_a <gcond *> (last_stmt (cond_bb));\n+  enum tree_code cmp = gimple_cond_code (cond);\n+  tree rhs = gimple_cond_rhs (cond);\n \n   /* Turn EQ/NE of extreme values to order comparisons.  */\n   if ((cmp == NE_EXPR || cmp == EQ_EXPR)\n@@ -1401,8 +1400,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* This transformation is only valid for order comparisons.  Record which\n      operand is smaller/larger if the result of the comparison is true.  */\n-  alt_smaller = NULL_TREE;\n-  alt_larger = NULL_TREE;\n+  tree alt_smaller = NULL_TREE;\n+  tree alt_larger = NULL_TREE;\n   if (cmp == LT_EXPR || cmp == LE_EXPR)\n     {\n       smaller = gimple_cond_lhs (cond);\n@@ -1463,6 +1462,50 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n   else\n     return false;\n \n+  /* Handle the special case of (signed_type)x < 0 being equivalent\n+     to x > MAX_VAL(signed_type) and (signed_type)x >= 0 equivalent\n+     to x <= MAX_VAL(signed_type).  */\n+  if ((cmp == GE_EXPR || cmp == LT_EXPR)\n+      && INTEGRAL_TYPE_P (type)\n+      && TYPE_UNSIGNED (type)\n+      && integer_zerop (rhs))\n+    {\n+      tree op = gimple_cond_lhs (cond);\n+      if (TREE_CODE (op) == SSA_NAME\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (op))\n+\t  && !TYPE_UNSIGNED (TREE_TYPE (op)))\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (op);\n+\t  if (gimple_assign_cast_p (def_stmt))\n+\t    {\n+\t      tree op1 = gimple_assign_rhs1 (def_stmt);\n+\t      if (INTEGRAL_TYPE_P (TREE_TYPE (op1))\n+\t\t  && TYPE_UNSIGNED (TREE_TYPE (op1))\n+\t\t  && (TYPE_PRECISION (TREE_TYPE (op))\n+\t\t      == TYPE_PRECISION (TREE_TYPE (op1)))\n+\t\t  && useless_type_conversion_p (type, TREE_TYPE (op1)))\n+\t\t{\n+\t\t  wide_int w1 = wi::max_value (TREE_TYPE (op));\n+\t\t  wide_int w2 = wi::add (w1, 1);\n+\t\t  if (cmp == LT_EXPR)\n+\t\t    {\n+\t\t      larger = op1;\n+\t\t      smaller = wide_int_to_tree (TREE_TYPE (op1), w1);\n+\t\t      alt_smaller = wide_int_to_tree (TREE_TYPE (op1), w2);\n+\t\t      alt_larger = NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      smaller = op1;\n+\t\t      larger = wide_int_to_tree (TREE_TYPE (op1), w1);\n+\t\t      alt_larger = wide_int_to_tree (TREE_TYPE (op1), w2);\n+\t\t      alt_smaller = NULL_TREE;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   /* We need to know which is the true edge and which is the false\n       edge so that we know if have abs or negative abs.  */\n   extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);"}]}