{"sha": "24cd9afe617a39801d190418cf3fbab3bc3742a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRjZDlhZmU2MTdhMzk4MDFkMTkwNDE4Y2YzZmJhYjNiYzM3NDJhNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-04T13:36:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-04T13:36:06Z"}, "message": "loop-niter: Recognize popcount idioms even with char, short and __int128 [PR95771]\n\nAs the testcase shows, we punt unnecessarily on popcount loop idioms if\nthe type is smaller than int or larger than long long.\nSmaller type than int can be handled by zero-extending the argument to\nunsigned int, and types twice as long as long long by doing\n__builtin_popcountll on both halves of the __int128.\n\n2020-01-04  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/95771\n\t* tree-ssa-loop-niter.c (number_of_iterations_popcount): Handle types\n\twith precision smaller than int's precision and types with precision\n\ttwice as large as long long.  Formatting fixes.\n\n\t* gcc.target/i386/pr95771.c: New test.", "tree": {"sha": "bf580b45d997d0ebbe977b7a323cb5e64c945cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf580b45d997d0ebbe977b7a323cb5e64c945cb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24cd9afe617a39801d190418cf3fbab3bc3742a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24cd9afe617a39801d190418cf3fbab3bc3742a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24cd9afe617a39801d190418cf3fbab3bc3742a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24cd9afe617a39801d190418cf3fbab3bc3742a7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39bd65faee3bafe2dc067e5fedb5079896551a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39bd65faee3bafe2dc067e5fedb5079896551a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39bd65faee3bafe2dc067e5fedb5079896551a8a"}], "stats": {"total": 112, "additions": 98, "deletions": 14}, "files": [{"sha": "d7b67017800b705b9854f561916c20901ea76803", "filename": "gcc/testsuite/gcc.target/i386/pr95771.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24cd9afe617a39801d190418cf3fbab3bc3742a7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95771.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24cd9afe617a39801d190418cf3fbab3bc3742a7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95771.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95771.c?ref=24cd9afe617a39801d190418cf3fbab3bc3742a7", "patch": "@@ -0,0 +1,67 @@\n+/* PR tree-optimization/95771 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mpopcnt -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \" = __builtin_popcount\" 6 \"optimized\" { target int128 } } } */\n+/* { dg-final { scan-tree-dump-times \" = __builtin_popcount\" 4 \"optimized\" { target { ! int128 } } } } */\n+\n+int\n+foo (unsigned char x)\n+{\n+  int i = 0;\n+  while (x)\n+    {\n+      x &= x - 1;\n+      ++i;\n+    }\n+  return i;\n+}\n+\n+int\n+bar (unsigned short x)\n+{\n+  int i = 0;\n+  while (x)\n+    {\n+      x &= x - 1;\n+      ++i;\n+    }\n+  return i;\n+}\n+\n+int\n+baz (unsigned int x)\n+{\n+  int i = 0;\n+  while (x)\n+    {\n+      x &= x - 1;\n+      ++i;\n+    }\n+  return i;\n+}\n+\n+int\n+qux (unsigned long long x)\n+{\n+  int i = 0;\n+  while (x)\n+    {\n+      x &= x - 1;\n+      ++i;\n+    }\n+  return i;\n+}\n+\n+#ifdef __SIZEOF_INT128__\n+int\n+corge (unsigned __int128 x)\n+{\n+  int i = 0;\n+  while (x)\n+    {\n+      x &= x - 1;\n+      ++i;\n+    }\n+  return i;\n+}\n+#endif"}, {"sha": "98978bcaa85387a1f6f37e96c607d2f186a87929", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24cd9afe617a39801d190418cf3fbab3bc3742a7/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24cd9afe617a39801d190418cf3fbab3bc3742a7/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=24cd9afe617a39801d190418cf3fbab3bc3742a7", "patch": "@@ -2666,27 +2666,45 @@ number_of_iterations_popcount (loop_p loop, edge exit,\n \n   /* We found a match. Get the corresponding popcount builtin.  */\n   tree src = gimple_phi_arg_def (phi, loop_preheader_edge (loop)->dest_idx);\n-  if (TYPE_PRECISION (TREE_TYPE (src)) == TYPE_PRECISION (integer_type_node))\n+  if (TYPE_PRECISION (TREE_TYPE (src)) <= TYPE_PRECISION (integer_type_node))\n     fn = builtin_decl_implicit (BUILT_IN_POPCOUNT);\n-  else if (TYPE_PRECISION (TREE_TYPE (src)) == TYPE_PRECISION\n-\t   (long_integer_type_node))\n+  else if (TYPE_PRECISION (TREE_TYPE (src))\n+\t   == TYPE_PRECISION (long_integer_type_node))\n     fn = builtin_decl_implicit (BUILT_IN_POPCOUNTL);\n-  else if (TYPE_PRECISION (TREE_TYPE (src)) == TYPE_PRECISION\n-\t   (long_long_integer_type_node))\n+  else if (TYPE_PRECISION (TREE_TYPE (src))\n+\t   == TYPE_PRECISION (long_long_integer_type_node)\n+\t   || (TYPE_PRECISION (TREE_TYPE (src))\n+\t       == 2 * TYPE_PRECISION (long_long_integer_type_node)))\n     fn = builtin_decl_implicit (BUILT_IN_POPCOUNTLL);\n \n-  /* ??? Support promoting char/short to int.  */\n   if (!fn)\n     return false;\n \n   /* Update NITER params accordingly  */\n   tree utype = unsigned_type_for (TREE_TYPE (src));\n   src = fold_convert (utype, src);\n-  tree call = fold_convert (utype, build_call_expr (fn, 1, src));\n+  if (TYPE_PRECISION (TREE_TYPE (src)) < TYPE_PRECISION (integer_type_node))\n+    src = fold_convert (unsigned_type_node, src);\n+  tree call;\n+  if (TYPE_PRECISION (TREE_TYPE (src))\n+      == 2 * TYPE_PRECISION (long_long_integer_type_node))\n+    {\n+      int prec = TYPE_PRECISION (long_long_integer_type_node);\n+      tree src1 = fold_convert (long_long_unsigned_type_node,\n+\t\t\t\tfold_build2 (RSHIFT_EXPR, TREE_TYPE (src),\n+\t\t\t\t\t     unshare_expr (src),\n+\t\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t    prec)));\n+      tree src2 = fold_convert (long_long_unsigned_type_node, src);\n+      call = build_call_expr (fn, 1, src1);\n+      call = fold_build2 (PLUS_EXPR, TREE_TYPE (call), call,\n+\t\t\t  build_call_expr (fn, 1, src2));\n+      call = fold_convert (utype, call);\n+    }\n+  else\n+    call = fold_convert (utype, build_call_expr (fn, 1, src));\n   if (adjust)\n-    iter = fold_build2 (MINUS_EXPR, utype,\n-\t\t\tcall,\n-\t\t\tbuild_int_cst (utype, 1));\n+    iter = fold_build2 (MINUS_EXPR, utype, call, build_int_cst (utype, 1));\n   else\n     iter = call;\n \n@@ -2703,10 +2721,9 @@ number_of_iterations_popcount (loop_p loop, edge exit,\n   if (adjust)\n     {\n       tree may_be_zero = fold_build2 (EQ_EXPR, boolean_type_node, src,\n-\t\t\t\t      build_zero_cst\n-\t\t\t\t      (TREE_TYPE (src)));\n-      niter->may_be_zero =\n-\tsimplify_using_initial_conditions (loop, may_be_zero);\n+\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n+      niter->may_be_zero\n+\t= simplify_using_initial_conditions (loop, may_be_zero);\n     }\n   else\n     niter->may_be_zero = boolean_false_node;"}]}