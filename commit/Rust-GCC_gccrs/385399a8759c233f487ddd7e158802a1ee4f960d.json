{"sha": "385399a8759c233f487ddd7e158802a1ee4f960d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg1Mzk5YTg3NTljMjMzZjQ4N2RkZDdlMTU4ODAyYTFlZTRmOTYwZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-09-17T14:28:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-09-17T14:28:59Z"}, "message": "Split up optabs.[hc]\n\noptabs.[hc] is a bit of a behemoth.  It includes basic functions for querying\nwhat a target can do, related tree- and gimple-level query functions,\nrelated rtl-level query functions, and the functions that actually\ngenerate code.  Some gimple optimisations therefore need:\n\n#include \"insn-config.h\"\n#include \"expmed.h\"\n#include \"dojump.h\"\n#include \"explow.h\"\n#include \"emit-rtl.h\"\n#include \"varasm.h\"\n#include \"stmt.h\"\n#include \"expr.h\"\n\npurely to query whether the target has support for a particular operation.\n\nThis patch splits optabs up as follows:\n\n      - optabs-query.[hc]: IL-independent functions for querying what a target\n          can do natively.\n      - optabs-tree.[hc]: tree and gimple query functions (an extension of\n          optabs-query.[hc]).\n      - optabs-libfuncs.[hc]: optabs-specific libfuncs (an extension of\n          libfuncs.h)\n      - optabs.h: For now includes optabs-query.h and optabs-libfuncs.h.\n\nOnly two files outside optabs need to include both optabs.h and\noptabs-tree.h: expr.c and function.c.  I think that's expected given\nthat both are related to expand.\n\nIt might be good to split optabs.h further, but this is already quite\na big patch.\n\nI changed can_conditionally_move_p from returning an int to returning\na bool and fixed a few formatting glitches.  There should be no other\nchanges to the functions themselves.\n\ngcc/\n\t* Makefile.in (OBJS): Add optabs-libfuncs.o, optabs-query.o\n\tand optabs-tree.o.\n\t(GTFILES): Replace optabs.c with optabs-libfunc.c.\n\t* genopinit.c (main): Add an include guard to insn-opinit.h.\n\tProtect the rtx_code parts with NUM_RTX_CODE.\n\t* optabs.h: Split parts out to...\n\t* optabs-libfuncs.h, optabs-query.h, optabs-tree.h: ...these\n\tnew files.\n\t* optabs.c: Split parts out to...\n\t* optabs-libfuncs.c, optabs-query.c, optabs-tree.c: ...these\n\tnew files.\n\t* cilk-common.c: Include optabs-query.h rather than optabs.h.\n\t* fold-const.c: Likewise.\n\t* target-globals.c: Likewise.\n\t* tree-if-conv.c: Likewise.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* tree-ssa-loop-prefetch.c: Likewise.\n\t* tree-ssa-math-opts.c: Include optabs-tree.h rather than\n\toptabs.h.  Remove unncessary include files.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* tree-switch-conversion.c: Likewise.\n\t* tree-vect-data-refs.c: Likewise.\n\t* tree-vect-generic.c: Likewise.\n\t* tree-vect-loop.c: Likewise.\n\t* tree-vect-patterns.c: Likewise.\n\t* tree-vect-slp.c: Likewise.\n\t* tree-vect-stmts.c: Likewise.\n\t* tree-vrp.c: Likewise.\n\t* toplev.c: Include optabs-query.h and optabs-libfuncs.h\n\trather than optabs.h.\n\t* expr.c: Include optabs-tree.h.\n\t* function.c: Likewise.\n\nFrom-SVN: r227865", "tree": {"sha": "b4c04d6027cb1108af25cc0d42827303e661abb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4c04d6027cb1108af25cc0d42827303e661abb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/385399a8759c233f487ddd7e158802a1ee4f960d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385399a8759c233f487ddd7e158802a1ee4f960d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385399a8759c233f487ddd7e158802a1ee4f960d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385399a8759c233f487ddd7e158802a1ee4f960d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a78eb72ac066743c8c11dbc1032a1909963719a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78eb72ac066743c8c11dbc1032a1909963719a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a78eb72ac066743c8c11dbc1032a1909963719a3"}], "stats": {"total": 4582, "additions": 2321, "deletions": 2261}, "files": [{"sha": "fa26892fc459dc129b1e6d459b6c596ace7be2d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -1,3 +1,39 @@\n+2015-09-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* Makefile.in (OBJS): Add optabs-libfuncs.o, optabs-query.o\n+\tand optabs-tree.o.\n+\t(GTFILES): Replace optabs.c with optabs-libfunc.c.\n+\t* genopinit.c (main): Add an include guard to insn-opinit.h.\n+\tProtect the rtx_code parts with NUM_RTX_CODE.\n+\t* optabs.h: Split parts out to...\n+\t* optabs-libfuncs.h, optabs-query.h, optabs-tree.h: ...these\n+\tnew files.\n+\t* optabs.c: Split parts out to...\n+\t* optabs-libfuncs.c, optabs-query.c, optabs-tree.c: ...these\n+\tnew files.\n+\t* cilk-common.c: Include optabs-query.h rather than optabs.h.\n+\t* fold-const.c: Likewise.\n+\t* target-globals.c: Likewise.\n+\t* tree-if-conv.c: Likewise.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* tree-ssa-loop-prefetch.c: Likewise.\n+\t* tree-ssa-math-opts.c: Include optabs-tree.h rather than\n+\toptabs.h.  Remove unncessary include files.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* tree-switch-conversion.c: Likewise.\n+\t* tree-vect-data-refs.c: Likewise.\n+\t* tree-vect-generic.c: Likewise.\n+\t* tree-vect-loop.c: Likewise.\n+\t* tree-vect-patterns.c: Likewise.\n+\t* tree-vect-slp.c: Likewise.\n+\t* tree-vect-stmts.c: Likewise.\n+\t* tree-vrp.c: Likewise.\n+\t* toplev.c: Include optabs-query.h and optabs-libfuncs.h\n+\trather than optabs.h.\n+\t* expr.c: Include optabs-tree.h.\n+\t* function.c: Likewise.\n+\n 2015-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/65958"}, {"sha": "c2df21db7b3e74f7671f451a6386c68edda6950e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -1350,6 +1350,9 @@ OBJS = \\\n \tmodulo-sched.o \\\n \tomp-low.o \\\n \toptabs.o \\\n+\toptabs-libfuncs.o \\\n+\toptabs-query.o \\\n+\toptabs-tree.o \\\n \toptions-save.o \\\n \topts-global.o \\\n \tpasses.o \\\n@@ -2330,7 +2333,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/expr.h \\\n   $(srcdir)/function.c $(srcdir)/except.c \\\n   $(srcdir)/gcse.c $(srcdir)/godump.c \\\n-  $(srcdir)/lists.c $(srcdir)/optabs.c \\\n+  $(srcdir)/lists.c $(srcdir)/optabs-libfuncs.c \\\n   $(srcdir)/profile.c $(srcdir)/mcf.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfgrtl.c \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\"}, {"sha": "62acc186d31803a3bd73d6565f593b4dc9db96ea", "filename": "gcc/cilk-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Fcilk-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Fcilk-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-common.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stmt.h\"\n #include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-query.h\"\n #include \"recog.h\"\n #include \"tree-iterator.h\"\n #include \"gimplify.h\""}, {"sha": "165b016cf3df4d816091bd20d8b018c58508c19f", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */\n #include \"expr.h\"\n #include \"insn-codes.h\"\n+#include \"optabs-tree.h\"\n #include \"optabs.h\"\n #include \"libfuncs.h\"\n #include \"recog.h\""}, {"sha": "a27ef2256abd62e529d3591d50c7b8b72fb10d18", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -76,7 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"cgraph.h\"\n #include \"generic-match.h\"\n-#include \"optabs.h\"\n+#include \"optabs-query.h\"\n \n #ifndef LOAD_EXTEND_OP\n #define LOAD_EXTEND_OP(M) UNKNOWN"}, {"sha": "9b4c2b99bc2e77797b73172cbff49fd8df938d5b", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stmt.h\"\n #include \"expr.h\"\n #include \"insn-codes.h\"\n+#include \"optabs-tree.h\"\n #include \"optabs.h\"\n #include \"libfuncs.h\"\n #include \"regs.h\""}, {"sha": "167815d561d50247226f6e014f937617d7304e86", "filename": "gcc/genopinit.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -377,6 +377,9 @@ main (int argc, char **argv)\n      purging of the X patterns above.  */\n   qsort (optabs, n, sizeof (optab_def), optab_kind_cmp);\n \n+  fprintf (h_file, \"#ifndef GCC_INSN_OPINIT_H\\n\");\n+  fprintf (h_file, \"#define GCC_INSN_OPINIT_H 1\\n\");\n+\n   /* Emit the optab enumeration for the header file.  */\n   fprintf (h_file, \"enum optab_tag {\\n\");\n   for (i = j = 0; i < n; ++i)\n@@ -426,6 +429,7 @@ main (int argc, char **argv)\n \t   \"   the body of that kind of insn.  */\\n\"\n \t   \"#define GEN_FCN(CODE) (insn_data[CODE].genfun)\\n\"\n \t   \"\\n\"\n+\t   \"#ifdef NUM_RTX_CODE\\n\"\n \t   \"/* Contains the optab used for each rtx code, and vice-versa.  */\\n\"\n \t   \"extern const optab code_to_optab_[NUM_RTX_CODE];\\n\"\n \t   \"extern const enum rtx_code optab_to_code_[NUM_OPTABS];\\n\"\n@@ -441,6 +445,7 @@ main (int argc, char **argv)\n \t   \"{\\n\"\n \t   \"  return optab_to_code_[op];\\n\"\n \t   \"}\\n\"\n+\t   \"#endif\\n\"\n \t   \"\\n\"\n \t   \"extern const struct convert_optab_libcall_d convlib_def[NUM_CONVLIB_OPTABS];\\n\"\n \t   \"extern const struct optab_libcall_d normlib_def[NUM_NORMLIB_OPTABS];\\n\"\n@@ -594,6 +599,7 @@ main (int argc, char **argv)\n     }\n   fprintf (s_file, \"};\\n\\n\");\n \n+  fprintf (h_file, \"#endif\\n\");\n   return (fclose (h_file) == 0 && fclose (s_file) == 0\n \t  ? SUCCESS_EXIT_CODE : FATAL_EXIT_CODE);\n }"}, {"sha": "bace520a79e3b5d4ebf02c6c88eada02d8a1fa77", "filename": "gcc/optabs-libfuncs.c", "status": "added", "additions": 974, "deletions": 0, "changes": 974, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-libfuncs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-libfuncs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-libfuncs.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -0,0 +1,974 @@\n+/* Mapping from optabs to underlying library functions\n+   Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"insn-codes.h\"\n+#include \"optabs-libfuncs.h\"\n+#include \"libfuncs.h\"\n+#include \"optabs-query.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"varasm.h\"\n+#include \"stor-layout.h\"\n+#include \"rtl.h\"\n+\n+struct target_libfuncs default_target_libfuncs;\n+#if SWITCHABLE_TARGET\n+struct target_libfuncs *this_target_libfuncs = &default_target_libfuncs;\n+#endif\n+\n+#define libfunc_hash \\\n+  (this_target_libfuncs->x_libfunc_hash)\n+\n+/* Prefixes for the current version of decimal floating point (BID vs. DPD) */\n+#if ENABLE_DECIMAL_BID_FORMAT\n+#define DECIMAL_PREFIX \"bid_\"\n+#else\n+#define DECIMAL_PREFIX \"dpd_\"\n+#endif\n+\n+/* Used for libfunc_hash.  */\n+\n+hashval_t\n+libfunc_hasher::hash (libfunc_entry *e)\n+{\n+  return ((e->mode1 + e->mode2 * NUM_MACHINE_MODES) ^ e->op);\n+}\n+\n+/* Used for libfunc_hash.  */\n+\n+bool\n+libfunc_hasher::equal (libfunc_entry *e1, libfunc_entry *e2)\n+{\n+  return e1->op == e2->op && e1->mode1 == e2->mode1 && e1->mode2 == e2->mode2;\n+}\n+\n+/* Return libfunc corresponding operation defined by OPTAB converting\n+   from MODE2 to MODE1.  Trigger lazy initialization if needed, return NULL\n+   if no libfunc is available.  */\n+rtx\n+convert_optab_libfunc (convert_optab optab, machine_mode mode1,\n+\t\t       machine_mode mode2)\n+{\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+\n+  /* ??? This ought to be an assert, but not all of the places\n+     that we expand optabs know about the optabs that got moved\n+     to being direct.  */\n+  if (!(optab >= FIRST_CONV_OPTAB && optab <= LAST_CONVLIB_OPTAB))\n+    return NULL_RTX;\n+\n+  e.op = optab;\n+  e.mode1 = mode1;\n+  e.mode2 = mode2;\n+  slot = libfunc_hash->find_slot (&e, NO_INSERT);\n+  if (!slot)\n+    {\n+      const struct convert_optab_libcall_d *d\n+\t= &convlib_def[optab - FIRST_CONV_OPTAB];\n+\n+      if (d->libcall_gen == NULL)\n+\treturn NULL;\n+\n+      d->libcall_gen (optab, d->libcall_basename, mode1, mode2);\n+      slot = libfunc_hash->find_slot (&e, NO_INSERT);\n+      if (!slot)\n+\treturn NULL;\n+    }\n+  return (*slot)->libfunc;\n+}\n+\n+/* Return libfunc corresponding operation defined by OPTAB in MODE.\n+   Trigger lazy initialization if needed, return NULL if no libfunc is\n+   available.  */\n+rtx\n+optab_libfunc (optab optab, machine_mode mode)\n+{\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+\n+  /* ??? This ought to be an assert, but not all of the places\n+     that we expand optabs know about the optabs that got moved\n+     to being direct.  */\n+  if (!(optab >= FIRST_NORM_OPTAB && optab <= LAST_NORMLIB_OPTAB))\n+    return NULL_RTX;\n+\n+  e.op = optab;\n+  e.mode1 = mode;\n+  e.mode2 = VOIDmode;\n+  slot = libfunc_hash->find_slot (&e, NO_INSERT);\n+  if (!slot)\n+    {\n+      const struct optab_libcall_d *d\n+\t= &normlib_def[optab - FIRST_NORM_OPTAB];\n+\n+      if (d->libcall_gen == NULL)\n+\treturn NULL;\n+\n+      d->libcall_gen (optab, d->libcall_basename, d->libcall_suffix, mode);\n+      slot = libfunc_hash->find_slot (&e, NO_INSERT);\n+      if (!slot)\n+\treturn NULL;\n+    }\n+  return (*slot)->libfunc;\n+}\n+\n+/* Initialize the libfunc fields of an entire group of entries in some\n+   optab.  Each entry is set equal to a string consisting of a leading\n+   pair of underscores followed by a generic operation name followed by\n+   a mode name (downshifted to lowercase) followed by a single character\n+   representing the number of operands for the given operation (which is\n+   usually one of the characters '2', '3', or '4').\n+\n+   OPTABLE is the table in which libfunc fields are to be initialized.\n+   OPNAME is the generic (string) name of the operation.\n+   SUFFIX is the character which specifies the number of operands for\n+     the given generic operation.\n+   MODE is the mode to generate for.  */\n+\n+static void\n+gen_libfunc (optab optable, const char *opname, int suffix,\n+\t     machine_mode mode)\n+{\n+  unsigned opname_len = strlen (opname);\n+  const char *mname = GET_MODE_NAME (mode);\n+  unsigned mname_len = strlen (mname);\n+  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;\n+  int len = prefix_len + opname_len + mname_len + 1 + 1;\n+  char *libfunc_name = XALLOCAVEC (char, len);\n+  char *p;\n+  const char *q;\n+\n+  p = libfunc_name;\n+  *p++ = '_';\n+  *p++ = '_';\n+  if (targetm.libfunc_gnu_prefix)\n+    {\n+      *p++ = 'g';\n+      *p++ = 'n';\n+      *p++ = 'u';\n+      *p++ = '_';\n+    }\n+  for (q = opname; *q;)\n+    *p++ = *q++;\n+  for (q = mname; *q; q++)\n+    *p++ = TOLOWER (*q);\n+  *p++ = suffix;\n+  *p = '\\0';\n+\n+  set_optab_libfunc (optable, mode,\n+\t\t     ggc_alloc_string (libfunc_name, p - libfunc_name));\n+}\n+\n+/* Like gen_libfunc, but verify that integer operation is involved.  */\n+\n+void\n+gen_int_libfunc (optab optable, const char *opname, char suffix,\n+\t\t machine_mode mode)\n+{\n+  int maxsize = 2 * BITS_PER_WORD;\n+  int minsize = BITS_PER_WORD;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return;\n+  if (maxsize < LONG_LONG_TYPE_SIZE)\n+    maxsize = LONG_LONG_TYPE_SIZE;\n+  if (minsize > INT_TYPE_SIZE\n+      && (trapv_binoptab_p (optable)\n+\t  || trapv_unoptab_p (optable)))\n+    minsize = INT_TYPE_SIZE;\n+  if (GET_MODE_BITSIZE (mode) < minsize\n+      || GET_MODE_BITSIZE (mode) > maxsize)\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that FP and set decimal prefix if needed.  */\n+\n+void\n+gen_fp_libfunc (optab optable, const char *opname, char suffix,\n+\t\tmachine_mode mode)\n+{\n+  char *dec_opname;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_libfunc (optable, opname, suffix, mode);\n+  if (DECIMAL_FLOAT_MODE_P (mode))\n+    {\n+      dec_opname = XALLOCAVEC (char, sizeof (DECIMAL_PREFIX) + strlen (opname));\n+      /* For BID support, change the name to have either a bid_ or dpd_ prefix\n+\t depending on the low level floating format used.  */\n+      memcpy (dec_opname, DECIMAL_PREFIX, sizeof (DECIMAL_PREFIX) - 1);\n+      strcpy (dec_opname + sizeof (DECIMAL_PREFIX) - 1, opname);\n+      gen_libfunc (optable, dec_opname, suffix, mode);\n+    }\n+}\n+\n+/* Like gen_libfunc, but verify that fixed-point operation is involved.  */\n+\n+void\n+gen_fixed_libfunc (optab optable, const char *opname, char suffix,\n+\t\t   machine_mode mode)\n+{\n+  if (!ALL_FIXED_POINT_MODE_P (mode))\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that signed fixed-point operation is\n+   involved.  */\n+\n+void\n+gen_signed_fixed_libfunc (optab optable, const char *opname, char suffix,\n+\t\t\t  machine_mode mode)\n+{\n+  if (!SIGNED_FIXED_POINT_MODE_P (mode))\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that unsigned fixed-point operation is\n+   involved.  */\n+\n+void\n+gen_unsigned_fixed_libfunc (optab optable, const char *opname, char suffix,\n+\t\t\t    machine_mode mode)\n+{\n+  if (!UNSIGNED_FIXED_POINT_MODE_P (mode))\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that FP or INT operation is involved.  */\n+\n+void\n+gen_int_fp_libfunc (optab optable, const char *name, char suffix,\n+\t\t    machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that FP or INT operation is involved\n+   and add 'v' suffix for integer operation.  */\n+\n+void\n+gen_intv_fp_libfunc (optab optable, const char *name, char suffix,\n+\t\t     machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      int len = strlen (name);\n+      char *v_name = XALLOCAVEC (char, len + 2);\n+      strcpy (v_name, name);\n+      v_name[len] = 'v';\n+      v_name[len + 1] = 0;\n+      gen_int_libfunc (optable, v_name, suffix, mode);\n+    }\n+}\n+\n+/* Like gen_libfunc, but verify that FP or INT or FIXED operation is\n+   involved.  */\n+\n+void\n+gen_int_fp_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t  machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (ALL_FIXED_POINT_MODE_P (mode))\n+    gen_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that FP or INT or signed FIXED operation is\n+   involved.  */\n+\n+void\n+gen_int_fp_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t\t machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (SIGNED_FIXED_POINT_MODE_P (mode))\n+    gen_signed_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that INT or FIXED operation is\n+   involved.  */\n+\n+void\n+gen_int_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t       machine_mode mode)\n+{\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (ALL_FIXED_POINT_MODE_P (mode))\n+    gen_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that INT or signed FIXED operation is\n+   involved.  */\n+\n+void\n+gen_int_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t      machine_mode mode)\n+{\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (SIGNED_FIXED_POINT_MODE_P (mode))\n+    gen_signed_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that INT or unsigned FIXED operation is\n+   involved.  */\n+\n+void\n+gen_int_unsigned_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t\tmachine_mode mode)\n+{\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (UNSIGNED_FIXED_POINT_MODE_P (mode))\n+    gen_unsigned_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Initialize the libfunc fields of an entire group of entries of an\n+   inter-mode-class conversion optab.  The string formation rules are\n+   similar to the ones for init_libfuncs, above, but instead of having\n+   a mode name and an operand count these functions have two mode names\n+   and no operand count.  */\n+\n+void\n+gen_interclass_conv_libfunc (convert_optab tab,\n+\t\t\t     const char *opname,\n+\t\t\t     machine_mode tmode,\n+\t\t\t     machine_mode fmode)\n+{\n+  size_t opname_len = strlen (opname);\n+  size_t mname_len = 0;\n+\n+  const char *fname, *tname;\n+  const char *q;\n+  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;\n+  char *libfunc_name, *suffix;\n+  char *nondec_name, *dec_name, *nondec_suffix, *dec_suffix;\n+  char *p;\n+\n+  /* If this is a decimal conversion, add the current BID vs. DPD prefix that\n+     depends on which underlying decimal floating point format is used.  */\n+  const size_t dec_len = sizeof (DECIMAL_PREFIX) - 1;\n+\n+  mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n+\n+  nondec_name = XALLOCAVEC (char, prefix_len + opname_len + mname_len + 1 + 1);\n+  nondec_name[0] = '_';\n+  nondec_name[1] = '_';\n+  if (targetm.libfunc_gnu_prefix)\n+    {\n+      nondec_name[2] = 'g';\n+      nondec_name[3] = 'n';\n+      nondec_name[4] = 'u';\n+      nondec_name[5] = '_';\n+    }\n+\n+  memcpy (&nondec_name[prefix_len], opname, opname_len);\n+  nondec_suffix = nondec_name + opname_len + prefix_len;\n+\n+  dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);\n+  dec_name[0] = '_';\n+  dec_name[1] = '_';\n+  memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n+  memcpy (&dec_name[2+dec_len], opname, opname_len);\n+  dec_suffix = dec_name + dec_len + opname_len + 2;\n+\n+  fname = GET_MODE_NAME (fmode);\n+  tname = GET_MODE_NAME (tmode);\n+\n+  if (DECIMAL_FLOAT_MODE_P (fmode) || DECIMAL_FLOAT_MODE_P (tmode))\n+    {\n+      libfunc_name = dec_name;\n+      suffix = dec_suffix;\n+    }\n+  else\n+    {\n+      libfunc_name = nondec_name;\n+      suffix = nondec_suffix;\n+    }\n+\n+  p = suffix;\n+  for (q = fname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n+  for (q = tname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n+\n+  *p = '\\0';\n+\n+  set_conv_libfunc (tab, tmode, fmode,\n+\t\t    ggc_alloc_string (libfunc_name, p - libfunc_name));\n+}\n+\n+/* Same as gen_interclass_conv_libfunc but verify that we are producing\n+   int->fp conversion.  */\n+\n+void\n+gen_int_to_fp_conv_libfunc (convert_optab tab,\n+\t\t\t    const char *opname,\n+\t\t\t    machine_mode tmode,\n+\t\t\t    machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (fmode) != MODE_INT)\n+    return;\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n+    return;\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* ufloat_optab is special by using floatun for FP and floatuns decimal fp\n+   naming scheme.  */\n+\n+void\n+gen_ufloat_conv_libfunc (convert_optab tab,\n+\t\t\t const char *opname ATTRIBUTE_UNUSED,\n+\t\t\t machine_mode tmode,\n+\t\t\t machine_mode fmode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (tmode))\n+    gen_int_to_fp_conv_libfunc (tab, \"floatuns\", tmode, fmode);\n+  else\n+    gen_int_to_fp_conv_libfunc (tab, \"floatun\", tmode, fmode);\n+}\n+\n+/* Same as gen_interclass_conv_libfunc but verify that we are producing\n+   fp->int conversion.  */\n+\n+void\n+gen_int_to_fp_nondecimal_conv_libfunc (convert_optab tab,\n+\t\t\t\t       const char *opname,\n+\t\t\t\t       machine_mode tmode,\n+\t\t\t\t       machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (fmode) != MODE_INT)\n+    return;\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT)\n+    return;\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Same as gen_interclass_conv_libfunc but verify that we are producing\n+   fp->int conversion with no decimal floating point involved.  */\n+\n+void\n+gen_fp_to_int_conv_libfunc (convert_optab tab,\n+\t\t\t    const char *opname,\n+\t\t\t    machine_mode tmode,\n+\t\t\t    machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n+    return;\n+  if (GET_MODE_CLASS (tmode) != MODE_INT)\n+    return;\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Initialize the libfunc fields of an of an intra-mode-class conversion optab.\n+   The string formation rules are\n+   similar to the ones for init_libfunc, above.  */\n+\n+void\n+gen_intraclass_conv_libfunc (convert_optab tab, const char *opname,\n+\t\t\t     machine_mode tmode, machine_mode fmode)\n+{\n+  size_t opname_len = strlen (opname);\n+  size_t mname_len = 0;\n+\n+  const char *fname, *tname;\n+  const char *q;\n+  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;\n+  char *nondec_name, *dec_name, *nondec_suffix, *dec_suffix;\n+  char *libfunc_name, *suffix;\n+  char *p;\n+\n+  /* If this is a decimal conversion, add the current BID vs. DPD prefix that\n+     depends on which underlying decimal floating point format is used.  */\n+  const size_t dec_len = sizeof (DECIMAL_PREFIX) - 1;\n+\n+  mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n+\n+  nondec_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);\n+  nondec_name[0] = '_';\n+  nondec_name[1] = '_';\n+  if (targetm.libfunc_gnu_prefix)\n+    {\n+      nondec_name[2] = 'g';\n+      nondec_name[3] = 'n';\n+      nondec_name[4] = 'u';\n+      nondec_name[5] = '_';\n+    }\n+  memcpy (&nondec_name[prefix_len], opname, opname_len);\n+  nondec_suffix = nondec_name + opname_len + prefix_len;\n+\n+  dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);\n+  dec_name[0] = '_';\n+  dec_name[1] = '_';\n+  memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n+  memcpy (&dec_name[2 + dec_len], opname, opname_len);\n+  dec_suffix = dec_name + dec_len + opname_len + 2;\n+\n+  fname = GET_MODE_NAME (fmode);\n+  tname = GET_MODE_NAME (tmode);\n+\n+  if (DECIMAL_FLOAT_MODE_P (fmode) || DECIMAL_FLOAT_MODE_P (tmode))\n+    {\n+      libfunc_name = dec_name;\n+      suffix = dec_suffix;\n+    }\n+  else\n+    {\n+      libfunc_name = nondec_name;\n+      suffix = nondec_suffix;\n+    }\n+\n+  p = suffix;\n+  for (q = fname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n+  for (q = tname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n+\n+  *p++ = '2';\n+  *p = '\\0';\n+\n+  set_conv_libfunc (tab, tmode, fmode,\n+\t\t    ggc_alloc_string (libfunc_name, p - libfunc_name));\n+}\n+\n+/* Pick proper libcall for trunc_optab.  We need to chose if we do\n+   truncation or extension and interclass or intraclass.  */\n+\n+void\n+gen_trunc_conv_libfunc (convert_optab tab,\n+\t\t\tconst char *opname,\n+\t\t\tmachine_mode tmode,\n+\t\t\tmachine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n+    return;\n+  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n+    return;\n+  if (tmode == fmode)\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (fmode))\n+      || (GET_MODE_CLASS (fmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (tmode)))\n+     gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+\n+  if (GET_MODE_PRECISION (fmode) <= GET_MODE_PRECISION (tmode))\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT\n+       && GET_MODE_CLASS (fmode) == MODE_FLOAT)\n+      || (DECIMAL_FLOAT_MODE_P (fmode) && DECIMAL_FLOAT_MODE_P (tmode)))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for extend_optab.  We need to chose if we do\n+   truncation or extension and interclass or intraclass.  */\n+\n+void\n+gen_extend_conv_libfunc (convert_optab tab,\n+\t\t\t const char *opname ATTRIBUTE_UNUSED,\n+\t\t\t machine_mode tmode,\n+\t\t\t machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n+    return;\n+  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n+    return;\n+  if (tmode == fmode)\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (fmode))\n+      || (GET_MODE_CLASS (fmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (tmode)))\n+     gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+\n+  if (GET_MODE_PRECISION (fmode) > GET_MODE_PRECISION (tmode))\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT\n+       && GET_MODE_CLASS (fmode) == MODE_FLOAT)\n+      || (DECIMAL_FLOAT_MODE_P (fmode) && DECIMAL_FLOAT_MODE_P (tmode)))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for fract_optab.  We need to chose if we do\n+   interclass or intraclass.  */\n+\n+void\n+gen_fract_conv_libfunc (convert_optab tab,\n+\t\t\tconst char *opname,\n+\t\t\tmachine_mode tmode,\n+\t\t\tmachine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  if (!(ALL_FIXED_POINT_MODE_P (tmode) || ALL_FIXED_POINT_MODE_P (fmode)))\n+    return;\n+\n+  if (GET_MODE_CLASS (tmode) == GET_MODE_CLASS (fmode))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+  else\n+    gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for fractuns_optab.  */\n+\n+void\n+gen_fractuns_conv_libfunc (convert_optab tab,\n+\t\t\t   const char *opname,\n+\t\t\t   machine_mode tmode,\n+\t\t\t   machine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  /* One mode must be a fixed-point mode, and the other must be an integer\n+     mode.  */\n+  if (!((ALL_FIXED_POINT_MODE_P (tmode) && GET_MODE_CLASS (fmode) == MODE_INT)\n+\t|| (ALL_FIXED_POINT_MODE_P (fmode)\n+\t    && GET_MODE_CLASS (tmode) == MODE_INT)))\n+    return;\n+\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for satfract_optab.  We need to chose if we do\n+   interclass or intraclass.  */\n+\n+void\n+gen_satfract_conv_libfunc (convert_optab tab,\n+\t\t\t   const char *opname,\n+\t\t\t   machine_mode tmode,\n+\t\t\t   machine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  /* TMODE must be a fixed-point mode.  */\n+  if (!ALL_FIXED_POINT_MODE_P (tmode))\n+    return;\n+\n+  if (GET_MODE_CLASS (tmode) == GET_MODE_CLASS (fmode))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+  else\n+    gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for satfractuns_optab.  */\n+\n+void\n+gen_satfractuns_conv_libfunc (convert_optab tab,\n+\t\t\t      const char *opname,\n+\t\t\t      machine_mode tmode,\n+\t\t\t      machine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  /* TMODE must be a fixed-point mode, and FMODE must be an integer mode.  */\n+  if (!(ALL_FIXED_POINT_MODE_P (tmode) && GET_MODE_CLASS (fmode) == MODE_INT))\n+    return;\n+\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Hashtable callbacks for libfunc_decls.  */\n+\n+struct libfunc_decl_hasher : ggc_ptr_hash<tree_node>\n+{\n+  static hashval_t\n+  hash (tree entry)\n+  {\n+    return IDENTIFIER_HASH_VALUE (DECL_NAME (entry));\n+  }\n+\n+  static bool\n+  equal (tree decl, tree name)\n+  {\n+    return DECL_NAME (decl) == name;\n+  }\n+};\n+\n+/* A table of previously-created libfuncs, hashed by name.  */\n+static GTY (()) hash_table<libfunc_decl_hasher> *libfunc_decls;\n+\n+/* Build a decl for a libfunc named NAME.  */\n+\n+tree\n+build_libfunc_function (const char *name)\n+{\n+  tree decl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL,\n+\t\t\t  get_identifier (name),\n+\t\t\t  build_function_type (integer_type_node, NULL_TREE));\n+  /* ??? We don't have any type information except for this is\n+     a function.  Pretend this is \"int foo ()\".  */\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_EXTERNAL (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+  gcc_assert (DECL_ASSEMBLER_NAME (decl));\n+\n+  /* Zap the nonsensical SYMBOL_REF_DECL for this.  What we're left with\n+     are the flags assigned by targetm.encode_section_info.  */\n+  SET_SYMBOL_REF_DECL (XEXP (DECL_RTL (decl), 0), NULL);\n+\n+  return decl;\n+}\n+\n+/* Return a libfunc for NAME, creating one if we don't already have one.\n+   The returned rtx is a SYMBOL_REF.  */\n+\n+rtx\n+init_one_libfunc (const char *name)\n+{\n+  tree id, decl;\n+  hashval_t hash;\n+\n+  if (libfunc_decls == NULL)\n+    libfunc_decls = hash_table<libfunc_decl_hasher>::create_ggc (37);\n+\n+  /* See if we have already created a libfunc decl for this function.  */\n+  id = get_identifier (name);\n+  hash = IDENTIFIER_HASH_VALUE (id);\n+  tree *slot = libfunc_decls->find_slot_with_hash (id, hash, INSERT);\n+  decl = *slot;\n+  if (decl == NULL)\n+    {\n+      /* Create a new decl, so that it can be passed to\n+\t targetm.encode_section_info.  */\n+      decl = build_libfunc_function (name);\n+      *slot = decl;\n+    }\n+  return XEXP (DECL_RTL (decl), 0);\n+}\n+\n+/* Adjust the assembler name of libfunc NAME to ASMSPEC.  */\n+\n+rtx\n+set_user_assembler_libfunc (const char *name, const char *asmspec)\n+{\n+  tree id, decl;\n+  hashval_t hash;\n+\n+  id = get_identifier (name);\n+  hash = IDENTIFIER_HASH_VALUE (id);\n+  tree *slot = libfunc_decls->find_slot_with_hash (id, hash, NO_INSERT);\n+  gcc_assert (slot);\n+  decl = (tree) *slot;\n+  set_user_assembler_name (decl, asmspec);\n+  return XEXP (DECL_RTL (decl), 0);\n+}\n+\n+/* Call this to reset the function entry for one optab (OPTABLE) in mode\n+   MODE to NAME, which should be either 0 or a string constant.  */\n+\n+void\n+set_optab_libfunc (optab op, machine_mode mode, const char *name)\n+{\n+  rtx val;\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+\n+  e.op = op;\n+  e.mode1 = mode;\n+  e.mode2 = VOIDmode;\n+\n+  if (name)\n+    val = init_one_libfunc (name);\n+  else\n+    val = 0;\n+  slot = libfunc_hash->find_slot (&e, INSERT);\n+  if (*slot == NULL)\n+    *slot = ggc_alloc<libfunc_entry> ();\n+  (*slot)->op = op;\n+  (*slot)->mode1 = mode;\n+  (*slot)->mode2 = VOIDmode;\n+  (*slot)->libfunc = val;\n+}\n+\n+/* Call this to reset the function entry for one conversion optab\n+   (OPTABLE) from mode FMODE to mode TMODE to NAME, which should be\n+   either 0 or a string constant.  */\n+\n+void\n+set_conv_libfunc (convert_optab optab, machine_mode tmode,\n+\t\t  machine_mode fmode, const char *name)\n+{\n+  rtx val;\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+\n+  e.op = optab;\n+  e.mode1 = tmode;\n+  e.mode2 = fmode;\n+\n+  if (name)\n+    val = init_one_libfunc (name);\n+  else\n+    val = 0;\n+  slot = libfunc_hash->find_slot (&e, INSERT);\n+  if (*slot == NULL)\n+    *slot = ggc_alloc<libfunc_entry> ();\n+  (*slot)->op = optab;\n+  (*slot)->mode1 = tmode;\n+  (*slot)->mode2 = fmode;\n+  (*slot)->libfunc = val;\n+}\n+\n+/* Call this to initialize the contents of the optabs\n+   appropriately for the current target machine.  */\n+\n+void\n+init_optabs (void)\n+{\n+  if (libfunc_hash)\n+    libfunc_hash->empty ();\n+  else\n+    libfunc_hash = hash_table<libfunc_hasher>::create_ggc (10);\n+\n+  /* Fill in the optabs with the insns we support.  */\n+  init_all_optabs (this_fn_optabs);\n+\n+  /* The ffs function operates on `int'.  Fall back on it if we do not\n+     have a libgcc2 function for that width.  */\n+  if (INT_TYPE_SIZE < BITS_PER_WORD)\n+    set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n+\t\t       \"ffs\");\n+\n+  /* Explicitly initialize the bswap libfuncs since we need them to be\n+     valid for things other than word_mode.  */\n+  if (targetm.libfunc_gnu_prefix)\n+    {\n+      set_optab_libfunc (bswap_optab, SImode, \"__gnu_bswapsi2\");\n+      set_optab_libfunc (bswap_optab, DImode, \"__gnu_bswapdi2\");\n+    }\n+  else\n+    {\n+      set_optab_libfunc (bswap_optab, SImode, \"__bswapsi2\");\n+      set_optab_libfunc (bswap_optab, DImode, \"__bswapdi2\");\n+    }\n+\n+  /* Use cabs for double complex abs, since systems generally have cabs.\n+     Don't define any libcall for float complex, so that cabs will be used.  */\n+  if (complex_double_type_node)\n+    set_optab_libfunc (abs_optab, TYPE_MODE (complex_double_type_node),\n+\t\t       \"cabs\");\n+\n+  abort_libfunc = init_one_libfunc (\"abort\");\n+  memcpy_libfunc = init_one_libfunc (\"memcpy\");\n+  memmove_libfunc = init_one_libfunc (\"memmove\");\n+  memcmp_libfunc = init_one_libfunc (\"memcmp\");\n+  memset_libfunc = init_one_libfunc (\"memset\");\n+  setbits_libfunc = init_one_libfunc (\"__setbits\");\n+\n+#ifndef DONT_USE_BUILTIN_SETJMP\n+  setjmp_libfunc = init_one_libfunc (\"__builtin_setjmp\");\n+  longjmp_libfunc = init_one_libfunc (\"__builtin_longjmp\");\n+#else\n+  setjmp_libfunc = init_one_libfunc (\"setjmp\");\n+  longjmp_libfunc = init_one_libfunc (\"longjmp\");\n+#endif\n+  unwind_sjlj_register_libfunc = init_one_libfunc (\"_Unwind_SjLj_Register\");\n+  unwind_sjlj_unregister_libfunc\n+    = init_one_libfunc (\"_Unwind_SjLj_Unregister\");\n+\n+  /* For function entry/exit instrumentation.  */\n+  profile_function_entry_libfunc\n+    = init_one_libfunc (\"__cyg_profile_func_enter\");\n+  profile_function_exit_libfunc\n+    = init_one_libfunc (\"__cyg_profile_func_exit\");\n+\n+  gcov_flush_libfunc = init_one_libfunc (\"__gcov_flush\");\n+\n+  /* Allow the target to add more libcalls or rename some, etc.  */\n+  targetm.init_libfuncs ();\n+}\n+\n+/* A helper function for init_sync_libfuncs.  Using the basename BASE,\n+   install libfuncs into TAB for BASE_N for 1 <= N <= MAX.  */\n+\n+static void\n+init_sync_libfuncs_1 (optab tab, const char *base, int max)\n+{\n+  machine_mode mode;\n+  char buf[64];\n+  size_t len = strlen (base);\n+  int i;\n+\n+  gcc_assert (max <= 8);\n+  gcc_assert (len + 3 < sizeof (buf));\n+\n+  memcpy (buf, base, len);\n+  buf[len] = '_';\n+  buf[len + 1] = '0';\n+  buf[len + 2] = '\\0';\n+\n+  mode = QImode;\n+  for (i = 1; i <= max; i *= 2)\n+    {\n+      buf[len + 1] = '0' + i;\n+      set_optab_libfunc (tab, mode, buf);\n+      mode = GET_MODE_2XWIDER_MODE (mode);\n+    }\n+}\n+\n+void\n+init_sync_libfuncs (int max)\n+{\n+  if (!flag_sync_libcalls)\n+    return;\n+\n+  init_sync_libfuncs_1 (sync_compare_and_swap_optab,\n+\t\t\t\"__sync_val_compare_and_swap\", max);\n+  init_sync_libfuncs_1 (sync_lock_test_and_set_optab,\n+\t\t\t\"__sync_lock_test_and_set\", max);\n+\n+  init_sync_libfuncs_1 (sync_old_add_optab, \"__sync_fetch_and_add\", max);\n+  init_sync_libfuncs_1 (sync_old_sub_optab, \"__sync_fetch_and_sub\", max);\n+  init_sync_libfuncs_1 (sync_old_ior_optab, \"__sync_fetch_and_or\", max);\n+  init_sync_libfuncs_1 (sync_old_and_optab, \"__sync_fetch_and_and\", max);\n+  init_sync_libfuncs_1 (sync_old_xor_optab, \"__sync_fetch_and_xor\", max);\n+  init_sync_libfuncs_1 (sync_old_nand_optab, \"__sync_fetch_and_nand\", max);\n+\n+  init_sync_libfuncs_1 (sync_new_add_optab, \"__sync_add_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_sub_optab, \"__sync_sub_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_ior_optab, \"__sync_or_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_and_optab, \"__sync_and_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_xor_optab, \"__sync_xor_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_nand_optab, \"__sync_nand_and_fetch\", max);\n+}\n+\n+#include \"gt-optabs-libfuncs.h\""}, {"sha": "4e43c8078ed635b701ff07b21ef6f56dc7493615", "filename": "gcc/optabs-libfuncs.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-libfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-libfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-libfuncs.h?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -0,0 +1,77 @@\n+/* Mapping from optabs to underlying library functions\n+   Copyright (C) 2001-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OPTABS_LIBFUNCS_H\n+#define GCC_OPTABS_LIBFUNCS_H\n+\n+#include \"insn-opinit.h\"\n+\n+rtx convert_optab_libfunc (convert_optab, machine_mode, machine_mode);\n+rtx optab_libfunc (optab, machine_mode);\n+\n+void gen_int_libfunc (optab, const char *, char, machine_mode);\n+void gen_fp_libfunc (optab, const char *, char, machine_mode);\n+void gen_fixed_libfunc (optab, const char *, char, machine_mode);\n+void gen_signed_fixed_libfunc (optab, const char *, char, machine_mode);\n+void gen_unsigned_fixed_libfunc (optab, const char *, char, machine_mode);\n+void gen_int_fp_libfunc (optab, const char *, char, machine_mode);\n+void gen_intv_fp_libfunc (optab, const char *, char, machine_mode);\n+void gen_int_fp_fixed_libfunc (optab, const char *, char, machine_mode);\n+void gen_int_fp_signed_fixed_libfunc (optab, const char *, char, machine_mode);\n+void gen_int_fixed_libfunc (optab, const char *, char, machine_mode);\n+void gen_int_signed_fixed_libfunc (optab, const char *, char, machine_mode);\n+void gen_int_unsigned_fixed_libfunc (optab, const char *, char, machine_mode);\n+\n+void gen_interclass_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t  machine_mode, machine_mode);\n+void gen_int_to_fp_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t machine_mode, machine_mode);\n+void gen_ufloat_conv_libfunc (convert_optab, const char *,\n+\t\t\t      machine_mode, machine_mode);\n+void gen_int_to_fp_nondecimal_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t\t    machine_mode, machine_mode);\n+void gen_fp_to_int_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t machine_mode, machine_mode);\n+void gen_intraclass_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t  machine_mode, machine_mode);\n+void gen_trunc_conv_libfunc (convert_optab, const char *,\n+\t\t\t     machine_mode, machine_mode);\n+void gen_extend_conv_libfunc (convert_optab, const char *,\n+\t\t\t      machine_mode, machine_mode);\n+void gen_fract_conv_libfunc (convert_optab, const char *,\n+\t\t\t     machine_mode, machine_mode);\n+void gen_fractuns_conv_libfunc (convert_optab, const char *,\n+\t\t\t\tmachine_mode, machine_mode);\n+void gen_satfract_conv_libfunc (convert_optab, const char *,\n+\t\t\t\tmachine_mode, machine_mode);\n+void gen_satfractuns_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t   machine_mode, machine_mode);\n+\n+tree build_libfunc_function (const char *);\n+rtx init_one_libfunc (const char *);\n+rtx set_user_assembler_libfunc (const char *, const char *);\n+\n+void set_optab_libfunc (optab, machine_mode, const char *);\n+void set_conv_libfunc (convert_optab, machine_mode,\n+\t\t       machine_mode, const char *);\n+\n+void init_optabs (void);\n+void init_sync_libfuncs (int max);\n+\n+#endif"}, {"sha": "254089fec7e6d1d2e1f22ca285676880fff41b6c", "filename": "gcc/optabs-query.c", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -0,0 +1,573 @@\n+/* IR-agnostic target query functions relating to optabs\n+   Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"insn-codes.h\"\n+#include \"optabs-query.h\"\n+#include \"optabs-libfuncs.h\"\n+#include \"insn-config.h\"\n+#include \"rtl.h\"\n+#include \"recog.h\"\n+\n+struct target_optabs default_target_optabs;\n+struct target_optabs *this_fn_optabs = &default_target_optabs;\n+#if SWITCHABLE_TARGET\n+struct target_optabs *this_target_optabs = &default_target_optabs;\n+#endif\n+\n+/* Enumerates the possible types of structure operand to an\n+   extraction_insn.  */\n+enum extraction_type { ET_unaligned_mem, ET_reg };\n+\n+/* Check whether insv, extv or extzv pattern ICODE can be used for an\n+   insertion or extraction of type TYPE on a structure of mode MODE.\n+   Return true if so and fill in *INSN accordingly.  STRUCT_OP is the\n+   operand number of the structure (the first sign_extract or zero_extract\n+   operand) and FIELD_OP is the operand number of the field (the other\n+   side of the set from the sign_extract or zero_extract).  */\n+\n+static bool\n+get_traditional_extraction_insn (extraction_insn *insn,\n+\t\t\t\t enum extraction_type type,\n+\t\t\t\t machine_mode mode,\n+\t\t\t\t enum insn_code icode,\n+\t\t\t\t int struct_op, int field_op)\n+{\n+  const struct insn_data_d *data = &insn_data[icode];\n+\n+  machine_mode struct_mode = data->operand[struct_op].mode;\n+  if (struct_mode == VOIDmode)\n+    struct_mode = word_mode;\n+  if (mode != struct_mode)\n+    return false;\n+\n+  machine_mode field_mode = data->operand[field_op].mode;\n+  if (field_mode == VOIDmode)\n+    field_mode = word_mode;\n+\n+  machine_mode pos_mode = data->operand[struct_op + 2].mode;\n+  if (pos_mode == VOIDmode)\n+    pos_mode = word_mode;\n+\n+  insn->icode = icode;\n+  insn->field_mode = field_mode;\n+  insn->struct_mode = (type == ET_unaligned_mem ? byte_mode : struct_mode);\n+  insn->pos_mode = pos_mode;\n+  return true;\n+}\n+\n+/* Return true if an optab exists to perform an insertion or extraction\n+   of type TYPE in mode MODE.  Describe the instruction in *INSN if so.\n+\n+   REG_OPTAB is the optab to use for register structures and\n+   MISALIGN_OPTAB is the optab to use for misaligned memory structures.\n+   POS_OP is the operand number of the bit position.  */\n+\n+static bool\n+get_optab_extraction_insn (struct extraction_insn *insn,\n+\t\t\t   enum extraction_type type,\n+\t\t\t   machine_mode mode, direct_optab reg_optab,\n+\t\t\t   direct_optab misalign_optab, int pos_op)\n+{\n+  direct_optab optab = (type == ET_unaligned_mem ? misalign_optab : reg_optab);\n+  enum insn_code icode = direct_optab_handler (optab, mode);\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n+\n+  const struct insn_data_d *data = &insn_data[icode];\n+\n+  insn->icode = icode;\n+  insn->field_mode = mode;\n+  insn->struct_mode = (type == ET_unaligned_mem ? BLKmode : mode);\n+  insn->pos_mode = data->operand[pos_op].mode;\n+  if (insn->pos_mode == VOIDmode)\n+    insn->pos_mode = word_mode;\n+  return true;\n+}\n+\n+/* Return true if an instruction exists to perform an insertion or\n+   extraction (PATTERN says which) of type TYPE in mode MODE.\n+   Describe the instruction in *INSN if so.  */\n+\n+static bool\n+get_extraction_insn (extraction_insn *insn,\n+\t\t     enum extraction_pattern pattern,\n+\t\t     enum extraction_type type,\n+\t\t     machine_mode mode)\n+{\n+  switch (pattern)\n+    {\n+    case EP_insv:\n+      if (targetm.have_insv ()\n+\t  && get_traditional_extraction_insn (insn, type, mode,\n+\t\t\t\t\t      targetm.code_for_insv, 0, 3))\n+\treturn true;\n+      return get_optab_extraction_insn (insn, type, mode, insv_optab,\n+\t\t\t\t\tinsvmisalign_optab, 2);\n+\n+    case EP_extv:\n+      if (targetm.have_extv ()\n+\t  && get_traditional_extraction_insn (insn, type, mode,\n+\t\t\t\t\t      targetm.code_for_extv, 1, 0))\n+\treturn true;\n+      return get_optab_extraction_insn (insn, type, mode, extv_optab,\n+\t\t\t\t\textvmisalign_optab, 3);\n+\n+    case EP_extzv:\n+      if (targetm.have_extzv ()\n+\t  && get_traditional_extraction_insn (insn, type, mode,\n+\t\t\t\t\t      targetm.code_for_extzv, 1, 0))\n+\treturn true;\n+      return get_optab_extraction_insn (insn, type, mode, extzv_optab,\n+\t\t\t\t\textzvmisalign_optab, 3);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return true if an instruction exists to access a field of mode\n+   FIELDMODE in a structure that has STRUCT_BITS significant bits.\n+   Describe the \"best\" such instruction in *INSN if so.  PATTERN and\n+   TYPE describe the type of insertion or extraction we want to perform.\n+\n+   For an insertion, the number of significant structure bits includes\n+   all bits of the target.  For an extraction, it need only include the\n+   most significant bit of the field.  Larger widths are acceptable\n+   in both cases.  */\n+\n+static bool\n+get_best_extraction_insn (extraction_insn *insn,\n+\t\t\t  enum extraction_pattern pattern,\n+\t\t\t  enum extraction_type type,\n+\t\t\t  unsigned HOST_WIDE_INT struct_bits,\n+\t\t\t  machine_mode field_mode)\n+{\n+  machine_mode mode = smallest_mode_for_size (struct_bits, MODE_INT);\n+  while (mode != VOIDmode)\n+    {\n+      if (get_extraction_insn (insn, pattern, type, mode))\n+\t{\n+\t  while (mode != VOIDmode\n+\t\t && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (field_mode)\n+\t\t && !TRULY_NOOP_TRUNCATION_MODES_P (insn->field_mode,\n+\t\t\t\t\t\t    field_mode))\n+\t    {\n+\t      get_extraction_insn (insn, pattern, type, mode);\n+\t      mode = GET_MODE_WIDER_MODE (mode);\n+\t    }\n+\t  return true;\n+\t}\n+      mode = GET_MODE_WIDER_MODE (mode);\n+    }\n+  return false;\n+}\n+\n+/* Return true if an instruction exists to access a field of mode\n+   FIELDMODE in a register structure that has STRUCT_BITS significant bits.\n+   Describe the \"best\" such instruction in *INSN if so.  PATTERN describes\n+   the type of insertion or extraction we want to perform.\n+\n+   For an insertion, the number of significant structure bits includes\n+   all bits of the target.  For an extraction, it need only include the\n+   most significant bit of the field.  Larger widths are acceptable\n+   in both cases.  */\n+\n+bool\n+get_best_reg_extraction_insn (extraction_insn *insn,\n+\t\t\t      enum extraction_pattern pattern,\n+\t\t\t      unsigned HOST_WIDE_INT struct_bits,\n+\t\t\t      machine_mode field_mode)\n+{\n+  return get_best_extraction_insn (insn, pattern, ET_reg, struct_bits,\n+\t\t\t\t   field_mode);\n+}\n+\n+/* Return true if an instruction exists to access a field of BITSIZE\n+   bits starting BITNUM bits into a memory structure.  Describe the\n+   \"best\" such instruction in *INSN if so.  PATTERN describes the type\n+   of insertion or extraction we want to perform and FIELDMODE is the\n+   natural mode of the extracted field.\n+\n+   The instructions considered here only access bytes that overlap\n+   the bitfield; they do not touch any surrounding bytes.  */\n+\n+bool\n+get_best_mem_extraction_insn (extraction_insn *insn,\n+\t\t\t      enum extraction_pattern pattern,\n+\t\t\t      HOST_WIDE_INT bitsize, HOST_WIDE_INT bitnum,\n+\t\t\t      machine_mode field_mode)\n+{\n+  unsigned HOST_WIDE_INT struct_bits = (bitnum % BITS_PER_UNIT\n+\t\t\t\t\t+ bitsize\n+\t\t\t\t\t+ BITS_PER_UNIT - 1);\n+  struct_bits -= struct_bits % BITS_PER_UNIT;\n+  return get_best_extraction_insn (insn, pattern, ET_unaligned_mem,\n+\t\t\t\t   struct_bits, field_mode);\n+}\n+\n+/* Return the insn code used to extend FROM_MODE to TO_MODE.\n+   UNSIGNEDP specifies zero-extension instead of sign-extension.  If\n+   no such operation exists, CODE_FOR_nothing will be returned.  */\n+\n+enum insn_code\n+can_extend_p (machine_mode to_mode, machine_mode from_mode,\n+\t      int unsignedp)\n+{\n+  if (unsignedp < 0 && targetm.have_ptr_extend ())\n+    return targetm.code_for_ptr_extend;\n+\n+  convert_optab tab = unsignedp ? zext_optab : sext_optab;\n+  return convert_optab_handler (tab, to_mode, from_mode);\n+}\n+\n+/* Return the insn code to convert fixed-point mode FIXMODE to floating-point\n+   mode FLTMODE, or CODE_FOR_nothing if no such instruction exists.\n+   UNSIGNEDP specifies whether FIXMODE is unsigned.  */\n+\n+enum insn_code\n+can_float_p (machine_mode fltmode, machine_mode fixmode,\n+\t     int unsignedp)\n+{\n+  convert_optab tab = unsignedp ? ufloat_optab : sfloat_optab;\n+  return convert_optab_handler (tab, fltmode, fixmode);\n+}\n+\n+/* Return the insn code to convert floating-point mode FLTMODE to fixed-point\n+   mode FIXMODE, or CODE_FOR_nothing if no such instruction exists.\n+   UNSIGNEDP specifies whether FIXMODE is unsigned.\n+\n+   On a successful return, set *TRUNCP_PTR to true if it is necessary to\n+   output an explicit FTRUNC before the instruction.  */\n+\n+enum insn_code\n+can_fix_p (machine_mode fixmode, machine_mode fltmode,\n+\t   int unsignedp, bool *truncp_ptr)\n+{\n+  convert_optab tab;\n+  enum insn_code icode;\n+\n+  tab = unsignedp ? ufixtrunc_optab : sfixtrunc_optab;\n+  icode = convert_optab_handler (tab, fixmode, fltmode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      *truncp_ptr = false;\n+      return icode;\n+    }\n+\n+  /* FIXME: This requires a port to define both FIX and FTRUNC pattern\n+     for this to work.  We need to rework the fix* and ftrunc* patterns\n+     and documentation.  */\n+  tab = unsignedp ? ufix_optab : sfix_optab;\n+  icode = convert_optab_handler (tab, fixmode, fltmode);\n+  if (icode != CODE_FOR_nothing\n+      && optab_handler (ftrunc_optab, fltmode) != CODE_FOR_nothing)\n+    {\n+      *truncp_ptr = true;\n+      return icode;\n+    }\n+\n+  return CODE_FOR_nothing;\n+}\n+\n+/* Return nonzero if a conditional move of mode MODE is supported.\n+\n+   This function is for combine so it can tell whether an insn that looks\n+   like a conditional move is actually supported by the hardware.  If we\n+   guess wrong we lose a bit on optimization, but that's it.  */\n+/* ??? sparc64 supports conditionally moving integers values based on fp\n+   comparisons, and vice versa.  How do we handle them?  */\n+\n+bool\n+can_conditionally_move_p (machine_mode mode)\n+{\n+  return direct_optab_handler (movcc_optab, mode) != CODE_FOR_nothing;\n+}\n+\n+/* Return true if VEC_PERM_EXPR of arbitrary input vectors can be\n+   expanded using SIMD extensions of the CPU.  SEL may be NULL, which\n+   stands for an unknown constant.  Note that additional permutations\n+   representing whole-vector shifts may also be handled via the vec_shr\n+   optab, but only where the second input vector is entirely constant\n+   zeroes; this case is not dealt with here.  */\n+\n+bool\n+can_vec_perm_p (machine_mode mode, bool variable,\n+\t\tconst unsigned char *sel)\n+{\n+  machine_mode qimode;\n+\n+  /* If the target doesn't implement a vector mode for the vector type,\n+     then no operations are supported.  */\n+  if (!VECTOR_MODE_P (mode))\n+    return false;\n+\n+  if (!variable)\n+    {\n+      if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n+\t  && (sel == NULL\n+\t      || targetm.vectorize.vec_perm_const_ok == NULL\n+\t      || targetm.vectorize.vec_perm_const_ok (mode, sel)))\n+\treturn true;\n+    }\n+\n+  if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n+    return true;\n+\n+  /* We allow fallback to a QI vector mode, and adjust the mask.  */\n+  if (GET_MODE_INNER (mode) == QImode)\n+    return false;\n+  qimode = mode_for_vector (QImode, GET_MODE_SIZE (mode));\n+  if (!VECTOR_MODE_P (qimode))\n+    return false;\n+\n+  /* ??? For completeness, we ought to check the QImode version of\n+      vec_perm_const_optab.  But all users of this implicit lowering\n+      feature implement the variable vec_perm_optab.  */\n+  if (direct_optab_handler (vec_perm_optab, qimode) == CODE_FOR_nothing)\n+    return false;\n+\n+  /* In order to support the lowering of variable permutations,\n+     we need to support shifts and adds.  */\n+  if (variable)\n+    {\n+      if (GET_MODE_UNIT_SIZE (mode) > 2\n+\t  && optab_handler (ashl_optab, mode) == CODE_FOR_nothing\n+\t  && optab_handler (vashl_optab, mode) == CODE_FOR_nothing)\n+\treturn false;\n+      if (optab_handler (add_optab, qimode) == CODE_FOR_nothing)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Like optab_handler, but for widening_operations that have a\n+   TO_MODE and a FROM_MODE.  */\n+\n+enum insn_code\n+widening_optab_handler (optab op, machine_mode to_mode,\n+\t\t\tmachine_mode from_mode)\n+{\n+  unsigned scode = (op << 16) | to_mode;\n+  if (to_mode != from_mode && from_mode != VOIDmode)\n+    {\n+      /* ??? Why does find_widening_optab_handler_and_mode attempt to\n+\t widen things that can't be widened?  E.g. add_optab... */\n+      if (op > LAST_CONV_OPTAB)\n+\treturn CODE_FOR_nothing;\n+      scode |= from_mode << 8;\n+    }\n+  return raw_optab_handler (scode);\n+}\n+\n+/* Find a widening optab even if it doesn't widen as much as we want.\n+   E.g. if from_mode is HImode, and to_mode is DImode, and there is no\n+   direct HI->SI insn, then return SI->DI, if that exists.\n+   If PERMIT_NON_WIDENING is non-zero then this can be used with\n+   non-widening optabs also.  */\n+\n+enum insn_code\n+find_widening_optab_handler_and_mode (optab op, machine_mode to_mode,\n+\t\t\t\t      machine_mode from_mode,\n+\t\t\t\t      int permit_non_widening,\n+\t\t\t\t      machine_mode *found_mode)\n+{\n+  for (; (permit_non_widening || from_mode != to_mode)\n+\t && GET_MODE_SIZE (from_mode) <= GET_MODE_SIZE (to_mode)\n+\t && from_mode != VOIDmode;\n+       from_mode = GET_MODE_WIDER_MODE (from_mode))\n+    {\n+      enum insn_code handler = widening_optab_handler (op, to_mode,\n+\t\t\t\t\t\t       from_mode);\n+\n+      if (handler != CODE_FOR_nothing)\n+\t{\n+\t  if (found_mode)\n+\t    *found_mode = from_mode;\n+\t  return handler;\n+\t}\n+    }\n+\n+  return CODE_FOR_nothing;\n+}\n+\n+/* Return non-zero if a highpart multiply is supported of can be synthisized.\n+   For the benefit of expand_mult_highpart, the return value is 1 for direct,\n+   2 for even/odd widening, and 3 for hi/lo widening.  */\n+\n+int\n+can_mult_highpart_p (machine_mode mode, bool uns_p)\n+{\n+  optab op;\n+  unsigned char *sel;\n+  unsigned i, nunits;\n+\n+  op = uns_p ? umul_highpart_optab : smul_highpart_optab;\n+  if (optab_handler (op, mode) != CODE_FOR_nothing)\n+    return 1;\n+\n+  /* If the mode is an integral vector, synth from widening operations.  */\n+  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+    return 0;\n+\n+  nunits = GET_MODE_NUNITS (mode);\n+  sel = XALLOCAVEC (unsigned char, nunits);\n+\n+  op = uns_p ? vec_widen_umult_even_optab : vec_widen_smult_even_optab;\n+  if (optab_handler (op, mode) != CODE_FOR_nothing)\n+    {\n+      op = uns_p ? vec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n+      if (optab_handler (op, mode) != CODE_FOR_nothing)\n+\t{\n+\t  for (i = 0; i < nunits; ++i)\n+\t    sel[i] = !BYTES_BIG_ENDIAN + (i & ~1) + ((i & 1) ? nunits : 0);\n+\t  if (can_vec_perm_p (mode, false, sel))\n+\t    return 2;\n+\t}\n+    }\n+\n+  op = uns_p ? vec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n+  if (optab_handler (op, mode) != CODE_FOR_nothing)\n+    {\n+      op = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n+      if (optab_handler (op, mode) != CODE_FOR_nothing)\n+\t{\n+\t  for (i = 0; i < nunits; ++i)\n+\t    sel[i] = 2 * i + (BYTES_BIG_ENDIAN ? 0 : 1);\n+\t  if (can_vec_perm_p (mode, false, sel))\n+\t    return 3;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return true if target supports vector masked load/store for mode.  */\n+\n+bool\n+can_vec_mask_load_store_p (machine_mode mode, bool is_load)\n+{\n+  optab op = is_load ? maskload_optab : maskstore_optab;\n+  machine_mode vmode;\n+  unsigned int vector_sizes;\n+\n+  /* If mode is vector mode, check it directly.  */\n+  if (VECTOR_MODE_P (mode))\n+    return optab_handler (op, mode) != CODE_FOR_nothing;\n+\n+  /* Otherwise, return true if there is some vector mode with\n+     the mask load/store supported.  */\n+\n+  /* See if there is any chance the mask load or store might be\n+     vectorized.  If not, punt.  */\n+  vmode = targetm.vectorize.preferred_simd_mode (mode);\n+  if (!VECTOR_MODE_P (vmode))\n+    return false;\n+\n+  if (optab_handler (op, vmode) != CODE_FOR_nothing)\n+    return true;\n+\n+  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n+  while (vector_sizes != 0)\n+    {\n+      unsigned int cur = 1 << floor_log2 (vector_sizes);\n+      vector_sizes &= ~cur;\n+      if (cur <= GET_MODE_SIZE (mode))\n+\tcontinue;\n+      vmode = mode_for_vector (mode, cur / GET_MODE_SIZE (mode));\n+      if (VECTOR_MODE_P (vmode)\n+\t  && optab_handler (op, vmode) != CODE_FOR_nothing)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if there is a compare_and_swap pattern.  */\n+\n+bool\n+can_compare_and_swap_p (machine_mode mode, bool allow_libcall)\n+{\n+  enum insn_code icode;\n+\n+  /* Check for __atomic_compare_and_swap.  */\n+  icode = direct_optab_handler (atomic_compare_and_swap_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    return true;\n+\n+  /* Check for __sync_compare_and_swap.  */\n+  icode = optab_handler (sync_compare_and_swap_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    return true;\n+  if (allow_libcall && optab_libfunc (sync_compare_and_swap_optab, mode))\n+    return true;\n+\n+  /* No inline compare and swap.  */\n+  return false;\n+}\n+\n+/* Return true if an atomic exchange can be performed.  */\n+\n+bool\n+can_atomic_exchange_p (machine_mode mode, bool allow_libcall)\n+{\n+  enum insn_code icode;\n+\n+  /* Check for __atomic_exchange.  */\n+  icode = direct_optab_handler (atomic_exchange_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    return true;\n+\n+  /* Don't check __sync_test_and_set, as on some platforms that\n+     has reduced functionality.  Targets that really do support\n+     a proper exchange should simply be updated to the __atomics.  */\n+\n+  return can_compare_and_swap_p (mode, allow_libcall);\n+}\n+\n+/* Determine whether \"1 << x\" is relatively cheap in word_mode.  */\n+\n+bool\n+lshift_cheap_p (bool speed_p)\n+{\n+  /* FIXME: This should be made target dependent via this \"this_target\"\n+     mechanism, similar to e.g. can_copy_init_p in gcse.c.  */\n+  static bool init[2] = { false, false };\n+  static bool cheap[2] = { true, true };\n+\n+  /* If the targer has no lshift in word_mode, the operation will most\n+     probably not be cheap.  ??? Does GCC even work for such targets?  */\n+  if (optab_handler (ashl_optab, word_mode) == CODE_FOR_nothing)\n+    return false;\n+\n+  if (!init[speed_p])\n+    {\n+      rtx reg = gen_raw_REG (word_mode, 10000);\n+      int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n+\t\t\t       word_mode, speed_p);\n+      cheap[speed_p] = cost < COSTS_N_INSNS (3);\n+      init[speed_p] = true;\n+    }\n+\n+  return cheap[speed_p];\n+}"}, {"sha": "73f272946a75b1c818348216944385ecc8806e6b", "filename": "gcc/optabs-query.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -0,0 +1,138 @@\n+/* IR-agnostic target query functions relating to optabs\n+   Copyright (C) 2001-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OPTABS_QUERY_H\n+#define GCC_OPTABS_QUERY_H\n+\n+#include \"insn-opinit.h\"\n+\n+/* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n+   if the target does not have such an insn.  */\n+\n+inline enum insn_code\n+optab_handler (optab op, machine_mode mode)\n+{\n+  unsigned scode = (op << 16) | mode;\n+  gcc_assert (op > LAST_CONV_OPTAB);\n+  return raw_optab_handler (scode);\n+}\n+\n+/* Return the insn used to perform conversion OP from mode FROM_MODE\n+   to mode TO_MODE; return CODE_FOR_nothing if the target does not have\n+   such an insn.  */\n+\n+inline enum insn_code\n+convert_optab_handler (convert_optab op, machine_mode to_mode,\n+\t\t       machine_mode from_mode)\n+{\n+  unsigned scode = (op << 16) | (from_mode << 8) | to_mode;\n+  gcc_assert (op > unknown_optab && op <= LAST_CONV_OPTAB);\n+  return raw_optab_handler (scode);\n+}\n+\n+/* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n+   if the target does not have such an insn.  */\n+\n+inline enum insn_code\n+direct_optab_handler (direct_optab op, machine_mode mode)\n+{\n+  return optab_handler (op, mode);\n+}\n+\n+/* Return true if UNOPTAB is for a trapping-on-overflow operation.  */\n+\n+inline bool\n+trapv_unoptab_p (optab unoptab)\n+{\n+  return (unoptab == negv_optab\n+\t  || unoptab == absv_optab);\n+}\n+\n+/* Return true if BINOPTAB is for a trapping-on-overflow operation.  */\n+\n+inline bool\n+trapv_binoptab_p (optab binoptab)\n+{\n+  return (binoptab == addv_optab\n+\t  || binoptab == subv_optab\n+\t  || binoptab == smulv_optab);\n+}\n+\n+/* Return insn code for a conditional operator with a comparison in\n+   mode CMODE, unsigned if UNS is true, resulting in a value of mode VMODE.  */\n+\n+inline enum insn_code\n+get_vcond_icode (machine_mode vmode, machine_mode cmode, bool uns)\n+{\n+  enum insn_code icode = CODE_FOR_nothing;\n+  if (uns)\n+    icode = convert_optab_handler (vcondu_optab, vmode, cmode);\n+  else\n+    icode = convert_optab_handler (vcond_optab, vmode, cmode);\n+  return icode;\n+}\n+\n+/* Enumerates the possible extraction_insn operations.  */\n+enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n+\n+/* Describes an instruction that inserts or extracts a bitfield.  */\n+struct extraction_insn\n+{\n+  /* The code of the instruction.  */\n+  enum insn_code icode;\n+\n+  /* The mode that the structure operand should have.  This is byte_mode\n+     when using the legacy insv, extv and extzv patterns to access memory.  */\n+  machine_mode struct_mode;\n+\n+  /* The mode of the field to be inserted or extracted, and by extension\n+     the mode of the insertion or extraction itself.  */\n+  machine_mode field_mode;\n+\n+  /* The mode of the field's bit position.  This is only important\n+     when the position is variable rather than constant.  */\n+  machine_mode pos_mode;\n+};\n+\n+bool get_best_reg_extraction_insn (extraction_insn *,\n+\t\t\t\t   enum extraction_pattern,\n+\t\t\t\t   unsigned HOST_WIDE_INT, machine_mode);\n+bool get_best_mem_extraction_insn (extraction_insn *,\n+\t\t\t\t   enum extraction_pattern,\n+\t\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT, machine_mode);\n+\n+enum insn_code can_extend_p (machine_mode, machine_mode, int);\n+enum insn_code can_float_p (machine_mode, machine_mode, int);\n+enum insn_code can_fix_p (machine_mode, machine_mode, int, bool *);\n+bool can_conditionally_move_p (machine_mode mode);\n+bool can_vec_perm_p (machine_mode, bool, const unsigned char *);\n+enum insn_code widening_optab_handler (optab, machine_mode, machine_mode);\n+/* Find a widening optab even if it doesn't widen as much as we want.  */\n+#define find_widening_optab_handler(A,B,C,D) \\\n+  find_widening_optab_handler_and_mode (A, B, C, D, NULL)\n+enum insn_code find_widening_optab_handler_and_mode (optab, machine_mode,\n+\t\t\t\t\t\t     machine_mode, int,\n+\t\t\t\t\t\t     machine_mode *);\n+int can_mult_highpart_p (machine_mode, bool);\n+bool can_vec_mask_load_store_p (machine_mode, bool);\n+bool can_compare_and_swap_p (machine_mode, bool);\n+bool can_atomic_exchange_p (machine_mode, bool);\n+bool lshift_cheap_p (bool);\n+\n+#endif"}, {"sha": "3b033382c18f1264cd13ec7a7e37a75fc97a154f", "filename": "gcc/optabs-tree.c", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -0,0 +1,370 @@\n+/* Tree-based target query functions relating to optabs\n+   Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"insn-codes.h\"\n+#include \"tree.h\"\n+#include \"optabs-tree.h\"\n+#include \"stor-layout.h\"\n+\n+/* Return the optab used for computing the operation given by the tree code,\n+   CODE and the tree EXP.  This function is not always usable (for example, it\n+   cannot give complete results for multiplication or division) but probably\n+   ought to be relied on more widely throughout the expander.  */\n+optab\n+optab_for_tree_code (enum tree_code code, const_tree type,\n+\t\t     enum optab_subtype subtype)\n+{\n+  bool trapv;\n+  switch (code)\n+    {\n+    case BIT_AND_EXPR:\n+      return and_optab;\n+\n+    case BIT_IOR_EXPR:\n+      return ior_optab;\n+\n+    case BIT_NOT_EXPR:\n+      return one_cmpl_optab;\n+\n+    case BIT_XOR_EXPR:\n+      return xor_optab;\n+\n+    case MULT_HIGHPART_EXPR:\n+      return TYPE_UNSIGNED (type) ? umul_highpart_optab : smul_highpart_optab;\n+\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+      return TYPE_UNSIGNED (type) ? umod_optab : smod_optab;\n+\n+    case RDIV_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usdiv_optab : ssdiv_optab;\n+      return TYPE_UNSIGNED (type) ? udiv_optab : sdiv_optab;\n+\n+    case LSHIFT_EXPR:\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n+\t{\n+\t  if (subtype == optab_vector)\n+\t    return TYPE_SATURATING (type) ? unknown_optab : vashl_optab;\n+\n+\t  gcc_assert (subtype == optab_scalar);\n+\t}\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usashl_optab : ssashl_optab;\n+      return ashl_optab;\n+\n+    case RSHIFT_EXPR:\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n+\t{\n+\t  if (subtype == optab_vector)\n+\t    return TYPE_UNSIGNED (type) ? vlshr_optab : vashr_optab;\n+\n+\t  gcc_assert (subtype == optab_scalar);\n+\t}\n+      return TYPE_UNSIGNED (type) ? lshr_optab : ashr_optab;\n+\n+    case LROTATE_EXPR:\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n+\t{\n+\t  if (subtype == optab_vector)\n+\t    return vrotl_optab;\n+\n+\t  gcc_assert (subtype == optab_scalar);\n+\t}\n+      return rotl_optab;\n+\n+    case RROTATE_EXPR:\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n+\t{\n+\t  if (subtype == optab_vector)\n+\t    return vrotr_optab;\n+\n+\t  gcc_assert (subtype == optab_scalar);\n+\t}\n+      return rotr_optab;\n+\n+    case MAX_EXPR:\n+      return TYPE_UNSIGNED (type) ? umax_optab : smax_optab;\n+\n+    case MIN_EXPR:\n+      return TYPE_UNSIGNED (type) ? umin_optab : smin_optab;\n+\n+    case REALIGN_LOAD_EXPR:\n+      return vec_realign_load_optab;\n+\n+    case WIDEN_SUM_EXPR:\n+      return TYPE_UNSIGNED (type) ? usum_widen_optab : ssum_widen_optab;\n+\n+    case DOT_PROD_EXPR:\n+      return TYPE_UNSIGNED (type) ? udot_prod_optab : sdot_prod_optab;\n+\n+    case SAD_EXPR:\n+      return TYPE_UNSIGNED (type) ? usad_optab : ssad_optab;\n+\n+    case WIDEN_MULT_PLUS_EXPR:\n+      return (TYPE_UNSIGNED (type)\n+\t      ? (TYPE_SATURATING (type)\n+\t\t ? usmadd_widen_optab : umadd_widen_optab)\n+\t      : (TYPE_SATURATING (type)\n+\t\t ? ssmadd_widen_optab : smadd_widen_optab));\n+\n+    case WIDEN_MULT_MINUS_EXPR:\n+      return (TYPE_UNSIGNED (type)\n+\t      ? (TYPE_SATURATING (type)\n+\t\t ? usmsub_widen_optab : umsub_widen_optab)\n+\t      : (TYPE_SATURATING (type)\n+\t\t ? ssmsub_widen_optab : smsub_widen_optab));\n+\n+    case FMA_EXPR:\n+      return fma_optab;\n+\n+    case REDUC_MAX_EXPR:\n+      return TYPE_UNSIGNED (type)\n+\t     ? reduc_umax_scal_optab : reduc_smax_scal_optab;\n+\n+    case REDUC_MIN_EXPR:\n+      return TYPE_UNSIGNED (type)\n+\t     ? reduc_umin_scal_optab : reduc_smin_scal_optab;\n+\n+    case REDUC_PLUS_EXPR:\n+      return reduc_plus_scal_optab;\n+\n+    case VEC_WIDEN_MULT_HI_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n+\n+    case VEC_WIDEN_MULT_LO_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n+\n+    case VEC_WIDEN_MULT_EVEN_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_widen_umult_even_optab : vec_widen_smult_even_optab;\n+\n+    case VEC_WIDEN_MULT_ODD_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n+\n+    case VEC_WIDEN_LSHIFT_HI_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_widen_ushiftl_hi_optab : vec_widen_sshiftl_hi_optab;\n+\n+    case VEC_WIDEN_LSHIFT_LO_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_widen_ushiftl_lo_optab : vec_widen_sshiftl_lo_optab;\n+\n+    case VEC_UNPACK_HI_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_unpacku_hi_optab : vec_unpacks_hi_optab;\n+\n+    case VEC_UNPACK_LO_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_unpacku_lo_optab : vec_unpacks_lo_optab;\n+\n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+      /* The signedness is determined from input operand.  */\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_unpacku_float_hi_optab : vec_unpacks_float_hi_optab;\n+\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n+      /* The signedness is determined from input operand.  */\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_unpacku_float_lo_optab : vec_unpacks_float_lo_optab;\n+\n+    case VEC_PACK_TRUNC_EXPR:\n+      return vec_pack_trunc_optab;\n+\n+    case VEC_PACK_SAT_EXPR:\n+      return TYPE_UNSIGNED (type) ? vec_pack_usat_optab : vec_pack_ssat_optab;\n+\n+    case VEC_PACK_FIX_TRUNC_EXPR:\n+      /* The signedness is determined from output operand.  */\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_pack_ufix_trunc_optab : vec_pack_sfix_trunc_optab;\n+\n+    default:\n+      break;\n+    }\n+\n+  trapv = INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type);\n+  switch (code)\n+    {\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usadd_optab : ssadd_optab;\n+      return trapv ? addv_optab : add_optab;\n+\n+    case MINUS_EXPR:\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? ussub_optab : sssub_optab;\n+      return trapv ? subv_optab : sub_optab;\n+\n+    case MULT_EXPR:\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usmul_optab : ssmul_optab;\n+      return trapv ? smulv_optab : smul_optab;\n+\n+    case NEGATE_EXPR:\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usneg_optab : ssneg_optab;\n+      return trapv ? negv_optab : neg_optab;\n+\n+    case ABS_EXPR:\n+      return trapv ? absv_optab : abs_optab;\n+\n+    default:\n+      return unknown_optab;\n+    }\n+}\n+\n+/* Given optab UNOPTAB that reduces a vector to a scalar, find instead the old\n+   optab that produces a vector with the reduction result in one element,\n+   for a tree with type TYPE.  */\n+\n+optab\n+scalar_reduc_to_vector (optab unoptab, const_tree type)\n+{\n+  switch (unoptab)\n+    {\n+    case reduc_plus_scal_optab:\n+      return TYPE_UNSIGNED (type) ? reduc_uplus_optab : reduc_splus_optab;\n+\n+    case reduc_smin_scal_optab: return reduc_smin_optab;\n+    case reduc_umin_scal_optab: return reduc_umin_optab;\n+    case reduc_smax_scal_optab: return reduc_smax_optab;\n+    case reduc_umax_scal_optab: return reduc_umax_optab;\n+    default: return unknown_optab;\n+    }\n+}\n+\n+/* Function supportable_convert_operation\n+\n+   Check whether an operation represented by the code CODE is a\n+   convert operation that is supported by the target platform in\n+   vector form (i.e., when operating on arguments of type VECTYPE_IN\n+   producing a result of type VECTYPE_OUT).\n+\n+   Convert operations we currently support directly are FIX_TRUNC and FLOAT.\n+   This function checks if these operations are supported\n+   by the target platform either directly (via vector tree-codes), or via\n+   target builtins.\n+\n+   Output:\n+   - CODE1 is code of vector operation to be used when\n+   vectorizing the operation, if available.\n+   - DECL is decl of target builtin functions to be used\n+   when vectorizing the operation, if available.  In this case,\n+   CODE1 is CALL_EXPR.  */\n+\n+bool\n+supportable_convert_operation (enum tree_code code,\n+\t\t\t       tree vectype_out, tree vectype_in,\n+\t\t\t       tree *decl, enum tree_code *code1)\n+{\n+  machine_mode m1,m2;\n+  bool truncp;\n+\n+  m1 = TYPE_MODE (vectype_out);\n+  m2 = TYPE_MODE (vectype_in);\n+\n+  /* First check if we can done conversion directly.  */\n+  if ((code == FIX_TRUNC_EXPR\n+       && can_fix_p (m1,m2,TYPE_UNSIGNED (vectype_out), &truncp)\n+\t  != CODE_FOR_nothing)\n+      || (code == FLOAT_EXPR\n+\t  && can_float_p (m1,m2,TYPE_UNSIGNED (vectype_in))\n+\t     != CODE_FOR_nothing))\n+    {\n+      *code1 = code;\n+      return true;\n+    }\n+\n+  /* Now check for builtin.  */\n+  if (targetm.vectorize.builtin_conversion\n+      && targetm.vectorize.builtin_conversion (code, vectype_out, vectype_in))\n+    {\n+      *code1 = CALL_EXPR;\n+      *decl = targetm.vectorize.builtin_conversion (code, vectype_out,\n+\t\t\t\t\t\t    vectype_in);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return TRUE iff, appropriate vector insns are available\n+   for vector cond expr with vector type VALUE_TYPE and a comparison\n+   with operand vector types in CMP_OP_TYPE.  */\n+\n+bool\n+expand_vec_cond_expr_p (tree value_type, tree cmp_op_type)\n+{\n+  machine_mode value_mode = TYPE_MODE (value_type);\n+  machine_mode cmp_op_mode = TYPE_MODE (cmp_op_type);\n+  if (GET_MODE_SIZE (value_mode) != GET_MODE_SIZE (cmp_op_mode)\n+      || GET_MODE_NUNITS (value_mode) != GET_MODE_NUNITS (cmp_op_mode)\n+      || get_vcond_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type),\n+\t\t\t  TYPE_UNSIGNED (cmp_op_type)) == CODE_FOR_nothing)\n+    return false;\n+  return true;\n+}\n+\n+/* Use the current target and options to initialize\n+   TREE_OPTIMIZATION_OPTABS (OPTNODE).  */\n+\n+void\n+init_tree_optimization_optabs (tree optnode)\n+{\n+  /* Quick exit if we have already computed optabs for this target.  */\n+  if (TREE_OPTIMIZATION_BASE_OPTABS (optnode) == this_target_optabs)\n+    return;\n+\n+  /* Forget any previous information and set up for the current target.  */\n+  TREE_OPTIMIZATION_BASE_OPTABS (optnode) = this_target_optabs;\n+  struct target_optabs *tmp_optabs = (struct target_optabs *)\n+    TREE_OPTIMIZATION_OPTABS (optnode);\n+  if (tmp_optabs)\n+    memset (tmp_optabs, 0, sizeof (struct target_optabs));\n+  else\n+    tmp_optabs = ggc_alloc<target_optabs> ();\n+\n+  /* Generate a new set of optabs into tmp_optabs.  */\n+  init_all_optabs (tmp_optabs);\n+\n+  /* If the optabs changed, record it.  */\n+  if (memcmp (tmp_optabs, this_target_optabs, sizeof (struct target_optabs)))\n+    TREE_OPTIMIZATION_OPTABS (optnode) = tmp_optabs;\n+  else\n+    {\n+      TREE_OPTIMIZATION_OPTABS (optnode) = NULL;\n+      ggc_free (tmp_optabs);\n+    }\n+}"}, {"sha": "bf6c9e3149531ec31e96d3f50c6bde9dbe65ecd3", "filename": "gcc/optabs-tree.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.h?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -0,0 +1,45 @@\n+/* Tree-based target query functions relating to optabs\n+   Copyright (C) 2001-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OPTABS_TREE_H\n+#define GCC_OPTABS_TREE_H\n+\n+#include \"optabs-query.h\"\n+\n+/* An extra flag to control optab_for_tree_code's behavior.  This is needed to\n+   distinguish between machines with a vector shift that takes a scalar for the\n+   shift amount vs. machines that take a vector for the shift amount.  */\n+enum optab_subtype\n+{\n+  optab_default,\n+  optab_scalar,\n+  optab_vector\n+};\n+\n+/* Return the optab used for computing the given operation on the type given by\n+   the second argument.  The third argument distinguishes between the types of\n+   vector shifts and rotates.  */\n+optab optab_for_tree_code (enum tree_code, const_tree, enum optab_subtype);\n+optab scalar_reduc_to_vector (optab, const_tree);\n+bool supportable_convert_operation (enum tree_code, tree, tree, tree *,\n+\t\t\t\t    enum tree_code *);\n+bool expand_vec_cond_expr_p (tree, tree);\n+void init_tree_optimization_optabs (tree);\n+\n+#endif"}, {"sha": "c49d66b5a0e92a75a4c8048527dd6ae1bf8d9d98", "filename": "gcc/optabs.c", "status": "modified", "additions": 75, "deletions": 1917, "changes": 1992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -33,8 +33,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"tree-hasher.h\"\n #include \"stor-layout.h\"\n-#include \"stringpool.h\"\n-#include \"varasm.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n #include \"except.h\"\n@@ -47,124 +45,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"insn-codes.h\"\n #include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"libfuncs.h\"\n #include \"recog.h\"\n #include \"reload.h\"\n #include \"target.h\"\n \n-struct target_optabs default_target_optabs;\n-struct target_libfuncs default_target_libfuncs;\n-struct target_optabs *this_fn_optabs = &default_target_optabs;\n-#if SWITCHABLE_TARGET\n-struct target_optabs *this_target_optabs = &default_target_optabs;\n-struct target_libfuncs *this_target_libfuncs = &default_target_libfuncs;\n-#endif\n-\n-#define libfunc_hash \\\n-  (this_target_libfuncs->x_libfunc_hash)\n-\n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   machine_mode *);\n static rtx expand_unop_direct (machine_mode, optab, rtx, rtx, int);\n static void emit_libcall_block_1 (rtx_insn *, rtx, rtx, rtx, bool);\n \n /* Debug facility for use in GDB.  */\n void debug_optab_libfuncs (void);\n-\n-/* Prefixes for the current version of decimal floating point (BID vs. DPD) */\n-#if ENABLE_DECIMAL_BID_FORMAT\n-#define DECIMAL_PREFIX \"bid_\"\n-#else\n-#define DECIMAL_PREFIX \"dpd_\"\n-#endif\n-\f\n-/* Used for libfunc_hash.  */\n-\n-hashval_t\n-libfunc_hasher::hash (libfunc_entry *e)\n-{\n-  return ((e->mode1 + e->mode2 * NUM_MACHINE_MODES) ^ e->op);\n-}\n-\n-/* Used for libfunc_hash.  */\n-\n-bool\n-libfunc_hasher::equal (libfunc_entry *e1, libfunc_entry *e2)\n-{\n-  return e1->op == e2->op && e1->mode1 == e2->mode1 && e1->mode2 == e2->mode2;\n-}\n-\n-/* Return libfunc corresponding operation defined by OPTAB converting\n-   from MODE2 to MODE1.  Trigger lazy initialization if needed, return NULL\n-   if no libfunc is available.  */\n-rtx\n-convert_optab_libfunc (convert_optab optab, machine_mode mode1,\n-\t\t       machine_mode mode2)\n-{\n-  struct libfunc_entry e;\n-  struct libfunc_entry **slot;\n-\n-  /* ??? This ought to be an assert, but not all of the places\n-     that we expand optabs know about the optabs that got moved\n-     to being direct.  */\n-  if (!(optab >= FIRST_CONV_OPTAB && optab <= LAST_CONVLIB_OPTAB))\n-    return NULL_RTX;\n-\n-  e.op = optab;\n-  e.mode1 = mode1;\n-  e.mode2 = mode2;\n-  slot = libfunc_hash->find_slot (&e, NO_INSERT);\n-  if (!slot)\n-    {\n-      const struct convert_optab_libcall_d *d\n-\t= &convlib_def[optab - FIRST_CONV_OPTAB];\n-\n-      if (d->libcall_gen == NULL)\n-\treturn NULL;\n-\n-      d->libcall_gen (optab, d->libcall_basename, mode1, mode2);\n-      slot = libfunc_hash->find_slot (&e, NO_INSERT);\n-      if (!slot)\n-\treturn NULL;\n-    }\n-  return (*slot)->libfunc;\n-}\n-\n-/* Return libfunc corresponding operation defined by OPTAB in MODE.\n-   Trigger lazy initialization if needed, return NULL if no libfunc is\n-   available.  */\n-rtx\n-optab_libfunc (optab optab, machine_mode mode)\n-{\n-  struct libfunc_entry e;\n-  struct libfunc_entry **slot;\n-\n-  /* ??? This ought to be an assert, but not all of the places\n-     that we expand optabs know about the optabs that got moved\n-     to being direct.  */\n-  if (!(optab >= FIRST_NORM_OPTAB && optab <= LAST_NORMLIB_OPTAB))\n-    return NULL_RTX;\n-\n-  e.op = optab;\n-  e.mode1 = mode;\n-  e.mode2 = VOIDmode;\n-  slot = libfunc_hash->find_slot (&e, NO_INSERT);\n-  if (!slot)\n-    {\n-      const struct optab_libcall_d *d\n-\t= &normlib_def[optab - FIRST_NORM_OPTAB];\n-\n-      if (d->libcall_gen == NULL)\n-\treturn NULL;\n-\n-      d->libcall_gen (optab, d->libcall_basename, d->libcall_suffix, mode);\n-      slot = libfunc_hash->find_slot (&e, NO_INSERT);\n-      if (!slot)\n-\treturn NULL;\n-    }\n-  return (*slot)->libfunc;\n-}\n-\n \f\n /* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to\n    the result of operation CODE applied to OP0 (and OP1 if it is a binary\n@@ -298,56 +191,6 @@ widened_mode (machine_mode to_mode, rtx op0, rtx op1)\n   return result;\n }\n \f\n-/* Like optab_handler, but for widening_operations that have a\n-   TO_MODE and a FROM_MODE.  */\n-\n-enum insn_code\n-widening_optab_handler (optab op, machine_mode to_mode,\n-\t\t\tmachine_mode from_mode)\n-{\n-  unsigned scode = (op << 16) | to_mode;\n-  if (to_mode != from_mode && from_mode != VOIDmode)\n-    {\n-      /* ??? Why does find_widening_optab_handler_and_mode attempt to\n-\t widen things that can't be widened?  E.g. add_optab... */\n-      if (op > LAST_CONV_OPTAB)\n-\treturn CODE_FOR_nothing;\n-      scode |= from_mode << 8;\n-    }\n-  return raw_optab_handler (scode);\n-}\n-\n-/* Find a widening optab even if it doesn't widen as much as we want.\n-   E.g. if from_mode is HImode, and to_mode is DImode, and there is no\n-   direct HI->SI insn, then return SI->DI, if that exists.\n-   If PERMIT_NON_WIDENING is non-zero then this can be used with\n-   non-widening optabs also.  */\n-\n-enum insn_code\n-find_widening_optab_handler_and_mode (optab op, machine_mode to_mode,\n-\t\t\t\t      machine_mode from_mode,\n-\t\t\t\t      int permit_non_widening,\n-\t\t\t\t      machine_mode *found_mode)\n-{\n-  for (; (permit_non_widening || from_mode != to_mode)\n-\t && GET_MODE_SIZE (from_mode) <= GET_MODE_SIZE (to_mode)\n-\t && from_mode != VOIDmode;\n-       from_mode = GET_MODE_WIDER_MODE (from_mode))\n-    {\n-      enum insn_code handler = widening_optab_handler (op, to_mode,\n-\t\t\t\t\t\t       from_mode);\n-\n-      if (handler != CODE_FOR_nothing)\n-\t{\n-\t  if (found_mode)\n-\t    *found_mode = from_mode;\n-\t  return handler;\n-\t}\n-    }\n-\n-  return CODE_FOR_nothing;\n-}\n-\f\n /* Widen OP to MODE and return the rtx for the widened operand.  UNSIGNEDP\n    says whether OP is signed or unsigned.  NO_EXTEND is nonzero if we need\n    not actually do a sign-extend or zero-extend, but can leave the\n@@ -386,245 +229,6 @@ widen_operand (rtx op, machine_mode mode, machine_mode oldmode,\n   return result;\n }\n \f\n-/* Return the optab used for computing the operation given by the tree code,\n-   CODE and the tree EXP.  This function is not always usable (for example, it\n-   cannot give complete results for multiplication or division) but probably\n-   ought to be relied on more widely throughout the expander.  */\n-optab\n-optab_for_tree_code (enum tree_code code, const_tree type,\n-\t\t     enum optab_subtype subtype)\n-{\n-  bool trapv;\n-  switch (code)\n-    {\n-    case BIT_AND_EXPR:\n-      return and_optab;\n-\n-    case BIT_IOR_EXPR:\n-      return ior_optab;\n-\n-    case BIT_NOT_EXPR:\n-      return one_cmpl_optab;\n-\n-    case BIT_XOR_EXPR:\n-      return xor_optab;\n-\n-    case MULT_HIGHPART_EXPR:\n-      return TYPE_UNSIGNED (type) ? umul_highpart_optab : smul_highpart_optab;\n-\n-    case TRUNC_MOD_EXPR:\n-    case CEIL_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-      return TYPE_UNSIGNED (type) ? umod_optab : smod_optab;\n-\n-    case RDIV_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-      if (TYPE_SATURATING (type))\n-\treturn TYPE_UNSIGNED (type) ? usdiv_optab : ssdiv_optab;\n-      return TYPE_UNSIGNED (type) ? udiv_optab : sdiv_optab;\n-\n-    case LSHIFT_EXPR:\n-      if (TREE_CODE (type) == VECTOR_TYPE)\n-\t{\n-\t  if (subtype == optab_vector)\n-\t    return TYPE_SATURATING (type) ? unknown_optab : vashl_optab;\n-\n-\t  gcc_assert (subtype == optab_scalar);\n-\t}\n-      if (TYPE_SATURATING (type))\n-\treturn TYPE_UNSIGNED (type) ? usashl_optab : ssashl_optab;\n-      return ashl_optab;\n-\n-    case RSHIFT_EXPR:\n-      if (TREE_CODE (type) == VECTOR_TYPE)\n-\t{\n-\t  if (subtype == optab_vector)\n-\t    return TYPE_UNSIGNED (type) ? vlshr_optab : vashr_optab;\n-\n-\t  gcc_assert (subtype == optab_scalar);\n-\t}\n-      return TYPE_UNSIGNED (type) ? lshr_optab : ashr_optab;\n-\n-    case LROTATE_EXPR:\n-      if (TREE_CODE (type) == VECTOR_TYPE)\n-\t{\n-\t  if (subtype == optab_vector)\n-\t    return vrotl_optab;\n-\n-\t  gcc_assert (subtype == optab_scalar);\n-\t}\n-      return rotl_optab;\n-\n-    case RROTATE_EXPR:\n-      if (TREE_CODE (type) == VECTOR_TYPE)\n-\t{\n-\t  if (subtype == optab_vector)\n-\t    return vrotr_optab;\n-\n-\t  gcc_assert (subtype == optab_scalar);\n-\t}\n-      return rotr_optab;\n-\n-    case MAX_EXPR:\n-      return TYPE_UNSIGNED (type) ? umax_optab : smax_optab;\n-\n-    case MIN_EXPR:\n-      return TYPE_UNSIGNED (type) ? umin_optab : smin_optab;\n-\n-    case REALIGN_LOAD_EXPR:\n-      return vec_realign_load_optab;\n-\n-    case WIDEN_SUM_EXPR:\n-      return TYPE_UNSIGNED (type) ? usum_widen_optab : ssum_widen_optab;\n-\n-    case DOT_PROD_EXPR:\n-      return TYPE_UNSIGNED (type) ? udot_prod_optab : sdot_prod_optab;\n-\n-    case SAD_EXPR:\n-      return TYPE_UNSIGNED (type) ? usad_optab : ssad_optab;\n-\n-    case WIDEN_MULT_PLUS_EXPR:\n-      return (TYPE_UNSIGNED (type)\n-\t      ? (TYPE_SATURATING (type)\n-\t\t ? usmadd_widen_optab : umadd_widen_optab)\n-\t      : (TYPE_SATURATING (type)\n-\t\t ? ssmadd_widen_optab : smadd_widen_optab));\n-\n-    case WIDEN_MULT_MINUS_EXPR:\n-      return (TYPE_UNSIGNED (type)\n-\t      ? (TYPE_SATURATING (type)\n-\t\t ? usmsub_widen_optab : umsub_widen_optab)\n-\t      : (TYPE_SATURATING (type)\n-\t\t ? ssmsub_widen_optab : smsub_widen_optab));\n-\n-    case FMA_EXPR:\n-      return fma_optab;\n-\n-    case REDUC_MAX_EXPR:\n-      return TYPE_UNSIGNED (type)\n-\t     ? reduc_umax_scal_optab : reduc_smax_scal_optab;\n-\n-    case REDUC_MIN_EXPR:\n-      return TYPE_UNSIGNED (type)\n-\t     ? reduc_umin_scal_optab : reduc_smin_scal_optab;\n-\n-    case REDUC_PLUS_EXPR:\n-      return reduc_plus_scal_optab;\n-\n-    case VEC_WIDEN_MULT_HI_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n-\n-    case VEC_WIDEN_MULT_LO_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n-\n-    case VEC_WIDEN_MULT_EVEN_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_widen_umult_even_optab : vec_widen_smult_even_optab;\n-\n-    case VEC_WIDEN_MULT_ODD_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n-\n-    case VEC_WIDEN_LSHIFT_HI_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-        vec_widen_ushiftl_hi_optab : vec_widen_sshiftl_hi_optab;\n-\n-    case VEC_WIDEN_LSHIFT_LO_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-        vec_widen_ushiftl_lo_optab : vec_widen_sshiftl_lo_optab;\n-\n-    case VEC_UNPACK_HI_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_unpacku_hi_optab : vec_unpacks_hi_optab;\n-\n-    case VEC_UNPACK_LO_EXPR:\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_unpacku_lo_optab : vec_unpacks_lo_optab;\n-\n-    case VEC_UNPACK_FLOAT_HI_EXPR:\n-      /* The signedness is determined from input operand.  */\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_unpacku_float_hi_optab : vec_unpacks_float_hi_optab;\n-\n-    case VEC_UNPACK_FLOAT_LO_EXPR:\n-      /* The signedness is determined from input operand.  */\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_unpacku_float_lo_optab : vec_unpacks_float_lo_optab;\n-\n-    case VEC_PACK_TRUNC_EXPR:\n-      return vec_pack_trunc_optab;\n-\n-    case VEC_PACK_SAT_EXPR:\n-      return TYPE_UNSIGNED (type) ? vec_pack_usat_optab : vec_pack_ssat_optab;\n-\n-    case VEC_PACK_FIX_TRUNC_EXPR:\n-      /* The signedness is determined from output operand.  */\n-      return TYPE_UNSIGNED (type) ?\n-\tvec_pack_ufix_trunc_optab : vec_pack_sfix_trunc_optab;\n-\n-    default:\n-      break;\n-    }\n-\n-  trapv = INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type);\n-  switch (code)\n-    {\n-    case POINTER_PLUS_EXPR:\n-    case PLUS_EXPR:\n-      if (TYPE_SATURATING (type))\n-\treturn TYPE_UNSIGNED (type) ? usadd_optab : ssadd_optab;\n-      return trapv ? addv_optab : add_optab;\n-\n-    case MINUS_EXPR:\n-      if (TYPE_SATURATING (type))\n-\treturn TYPE_UNSIGNED (type) ? ussub_optab : sssub_optab;\n-      return trapv ? subv_optab : sub_optab;\n-\n-    case MULT_EXPR:\n-      if (TYPE_SATURATING (type))\n-\treturn TYPE_UNSIGNED (type) ? usmul_optab : ssmul_optab;\n-      return trapv ? smulv_optab : smul_optab;\n-\n-    case NEGATE_EXPR:\n-      if (TYPE_SATURATING (type))\n-\treturn TYPE_UNSIGNED (type) ? usneg_optab : ssneg_optab;\n-      return trapv ? negv_optab : neg_optab;\n-\n-    case ABS_EXPR:\n-      return trapv ? absv_optab : abs_optab;\n-\n-    default:\n-      return unknown_optab;\n-    }\n-}\n-\n-/* Given optab UNOPTAB that reduces a vector to a scalar, find instead the old\n-   optab that produces a vector with the reduction result in one element,\n-   for a tree with type TYPE.  */\n-\n-optab\n-scalar_reduc_to_vector (optab unoptab, const_tree type)\n-{\n-  switch (unoptab)\n-    {\n-    case reduc_plus_scal_optab:\n-      return TYPE_UNSIGNED (type) ? reduc_uplus_optab : reduc_splus_optab;\n-\n-    case reduc_smin_scal_optab: return reduc_smin_optab;\n-    case reduc_umin_scal_optab: return reduc_umin_optab;\n-    case reduc_smax_scal_optab: return reduc_smax_optab;\n-    case reduc_umax_scal_optab: return reduc_umax_optab;\n-    default: return unknown_optab;\n-    }\n-}\n-\n /* Expand vector widening operations.\n \n    There are two different classes of operations handled here:\n@@ -4606,23 +4210,6 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   return NULL_RTX;\n }\n \n-/* Return nonzero if a conditional move of mode MODE is supported.\n-\n-   This function is for combine so it can tell whether an insn that looks\n-   like a conditional move is actually supported by the hardware.  If we\n-   guess wrong we lose a bit on optimization, but that's it.  */\n-/* ??? sparc64 supports conditionally moving integers values based on fp\n-   comparisons, and vice versa.  How do we handle them?  */\n-\n-int\n-can_conditionally_move_p (machine_mode mode)\n-{\n-  if (direct_optab_handler (movcc_optab, mode) != CODE_FOR_nothing)\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* Emit a conditional addition instruction if the machine supports one for that\n    condition and machine mode.\n \n@@ -4853,22 +4440,6 @@ have_sub2_insn (rtx x, rtx y)\n   return 1;\n }\n \f\n-/* Return the insn code used to extend FROM_MODE to TO_MODE.\n-   UNSIGNEDP specifies zero-extension instead of sign-extension.  If\n-   no such operation exists, CODE_FOR_nothing will be returned.  */\n-\n-enum insn_code\n-can_extend_p (machine_mode to_mode, machine_mode from_mode,\n-\t      int unsignedp)\n-{\n-  convert_optab tab;\n-  if (unsignedp < 0 && targetm.have_ptr_extend ())\n-    return targetm.code_for_ptr_extend;\n-\n-  tab = unsignedp ? zext_optab : sext_optab;\n-  return convert_optab_handler (tab, to_mode, from_mode);\n-}\n-\n /* Generate the body of an insn to extend Y (with mode MFROM)\n    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n \n@@ -4879,110 +4450,6 @@ gen_extend_insn (rtx x, rtx y, machine_mode mto,\n   enum insn_code icode = can_extend_p (mto, mfrom, unsignedp);\n   return GEN_FCN (icode) (x, y);\n }\n-\f\n-/* can_fix_p and can_float_p say whether the target machine\n-   can directly convert a given fixed point type to\n-   a given floating point type, or vice versa.\n-   The returned value is the CODE_FOR_... value to use,\n-   or CODE_FOR_nothing if these modes cannot be directly converted.\n-\n-   *TRUNCP_PTR is set to 1 if it is necessary to output\n-   an explicit FTRUNC insn before the fix insn; otherwise 0.  */\n-\n-static enum insn_code\n-can_fix_p (machine_mode fixmode, machine_mode fltmode,\n-\t   int unsignedp, int *truncp_ptr)\n-{\n-  convert_optab tab;\n-  enum insn_code icode;\n-\n-  tab = unsignedp ? ufixtrunc_optab : sfixtrunc_optab;\n-  icode = convert_optab_handler (tab, fixmode, fltmode);\n-  if (icode != CODE_FOR_nothing)\n-    {\n-      *truncp_ptr = 0;\n-      return icode;\n-    }\n-\n-  /* FIXME: This requires a port to define both FIX and FTRUNC pattern\n-     for this to work. We need to rework the fix* and ftrunc* patterns\n-     and documentation.  */\n-  tab = unsignedp ? ufix_optab : sfix_optab;\n-  icode = convert_optab_handler (tab, fixmode, fltmode);\n-  if (icode != CODE_FOR_nothing\n-      && optab_handler (ftrunc_optab, fltmode) != CODE_FOR_nothing)\n-    {\n-      *truncp_ptr = 1;\n-      return icode;\n-    }\n-\n-  *truncp_ptr = 0;\n-  return CODE_FOR_nothing;\n-}\n-\n-enum insn_code\n-can_float_p (machine_mode fltmode, machine_mode fixmode,\n-\t     int unsignedp)\n-{\n-  convert_optab tab;\n-\n-  tab = unsignedp ? ufloat_optab : sfloat_optab;\n-  return convert_optab_handler (tab, fltmode, fixmode);\n-}\n-\n-/* Function supportable_convert_operation\n-\n-   Check whether an operation represented by the code CODE is a\n-   convert operation that is supported by the target platform in\n-   vector form (i.e., when operating on arguments of type VECTYPE_IN\n-   producing a result of type VECTYPE_OUT).\n-   \n-   Convert operations we currently support directly are FIX_TRUNC and FLOAT.\n-   This function checks if these operations are supported\n-   by the target platform either directly (via vector tree-codes), or via\n-   target builtins.\n-   \n-   Output:\n-   - CODE1 is code of vector operation to be used when\n-   vectorizing the operation, if available.\n-   - DECL is decl of target builtin functions to be used\n-   when vectorizing the operation, if available.  In this case,\n-   CODE1 is CALL_EXPR.  */\n-\n-bool\n-supportable_convert_operation (enum tree_code code,\n-                                    tree vectype_out, tree vectype_in,\n-                                    tree *decl, enum tree_code *code1)\n-{\n-  machine_mode m1,m2;\n-  int truncp;\n-\n-  m1 = TYPE_MODE (vectype_out);\n-  m2 = TYPE_MODE (vectype_in);\n-\n-  /* First check if we can done conversion directly.  */\n-  if ((code == FIX_TRUNC_EXPR \n-       && can_fix_p (m1,m2,TYPE_UNSIGNED (vectype_out), &truncp) \n-          != CODE_FOR_nothing)\n-      || (code == FLOAT_EXPR\n-          && can_float_p (m1,m2,TYPE_UNSIGNED (vectype_in))\n-\t     != CODE_FOR_nothing))\n-    {\n-      *code1 = code;\n-      return true;\n-    }\n-\n-  /* Now check for builtin.  */\n-  if (targetm.vectorize.builtin_conversion\n-      && targetm.vectorize.builtin_conversion (code, vectype_out, vectype_in))\n-    {\n-      *code1 = CALL_EXPR;\n-      *decl = targetm.vectorize.builtin_conversion (code, vectype_out, vectype_in);\n-      return true;\n-    }\n-  return false;\n-}\n-\n \f\n /* Generate code to convert FROM to floating point\n    and store in TO.  FROM must be fixed point and not VOIDmode.\n@@ -5197,7 +4664,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n   enum insn_code icode;\n   rtx target = to;\n   machine_mode fmode, imode;\n-  int must_trunc = 0;\n+  bool must_trunc = false;\n \n   /* We first try to find a pair of modes, one real and one integer, at\n      least as wide as FROM and TO, respectively, in which we can open-code\n@@ -5478,957 +4945,91 @@ have_insn_for (enum rtx_code code, machine_mode mode)\n \t      != CODE_FOR_nothing));\n }\n \n-/* Initialize the libfunc fields of an entire group of entries in some\n-   optab.  Each entry is set equal to a string consisting of a leading\n-   pair of underscores followed by a generic operation name followed by\n-   a mode name (downshifted to lowercase) followed by a single character\n-   representing the number of operands for the given operation (which is\n-   usually one of the characters '2', '3', or '4').\n-\n-   OPTABLE is the table in which libfunc fields are to be initialized.\n-   OPNAME is the generic (string) name of the operation.\n-   SUFFIX is the character which specifies the number of operands for\n-     the given generic operation.\n-   MODE is the mode to generate for.\n-*/\n+/* Print information about the current contents of the optabs on\n+   STDERR.  */\n \n-static void\n-gen_libfunc (optab optable, const char *opname, int suffix,\n-\t     machine_mode mode)\n+DEBUG_FUNCTION void\n+debug_optab_libfuncs (void)\n {\n-  unsigned opname_len = strlen (opname);\n-  const char *mname = GET_MODE_NAME (mode);\n-  unsigned mname_len = strlen (mname);\n-  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;\n-  int len = prefix_len + opname_len + mname_len + 1 + 1;\n-  char *libfunc_name = XALLOCAVEC (char, len);\n-  char *p;\n-  const char *q;\n-\n-  p = libfunc_name;\n-  *p++ = '_';\n-  *p++ = '_';\n-  if (targetm.libfunc_gnu_prefix)\n-    {\n-      *p++ = 'g';\n-      *p++ = 'n';\n-      *p++ = 'u';\n-      *p++ = '_';\n-    }\n-  for (q = opname; *q; )\n-    *p++ = *q++;\n-  for (q = mname; *q; q++)\n-    *p++ = TOLOWER (*q);\n-  *p++ = suffix;\n-  *p = '\\0';\n-\n-  set_optab_libfunc (optable, mode,\n-\t\t     ggc_alloc_string (libfunc_name, p - libfunc_name));\n+  int i, j, k;\n+\n+  /* Dump the arithmetic optabs.  */\n+  for (i = FIRST_NORM_OPTAB; i <= LAST_NORMLIB_OPTAB; ++i)\n+    for (j = 0; j < NUM_MACHINE_MODES; ++j)\n+      {\n+\trtx l = optab_libfunc ((optab) i, (machine_mode) j);\n+\tif (l)\n+\t  {\n+\t    gcc_assert (GET_CODE (l) == SYMBOL_REF);\n+\t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n+\t\t     GET_RTX_NAME (optab_to_code ((optab) i)),\n+\t\t     GET_MODE_NAME (j),\n+\t\t     XSTR (l, 0));\n+\t  }\n+      }\n+\n+  /* Dump the conversion optabs.  */\n+  for (i = FIRST_CONV_OPTAB; i <= LAST_CONVLIB_OPTAB; ++i)\n+    for (j = 0; j < NUM_MACHINE_MODES; ++j)\n+      for (k = 0; k < NUM_MACHINE_MODES; ++k)\n+\t{\n+\t  rtx l = convert_optab_libfunc ((optab) i, (machine_mode) j,\n+\t\t\t\t\t (machine_mode) k);\n+\t  if (l)\n+\t    {\n+\t      gcc_assert (GET_CODE (l) == SYMBOL_REF);\n+\t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n+\t\t       GET_RTX_NAME (optab_to_code ((optab) i)),\n+\t\t       GET_MODE_NAME (j),\n+\t\t       GET_MODE_NAME (k),\n+\t\t       XSTR (l, 0));\n+\t    }\n+\t}\n }\n \n-/* Like gen_libfunc, but verify that integer operation is involved.  */\n+/* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition\n+   CODE.  Return 0 on failure.  */\n \n-void\n-gen_int_libfunc (optab optable, const char *opname, char suffix,\n-\t\t machine_mode mode)\n+rtx_insn *\n+gen_cond_trap (enum rtx_code code, rtx op1, rtx op2, rtx tcode)\n {\n-  int maxsize = 2 * BITS_PER_WORD;\n-  int minsize = BITS_PER_WORD;\n+  machine_mode mode = GET_MODE (op1);\n+  enum insn_code icode;\n+  rtx_insn *insn;\n+  rtx trap_rtx;\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT)\n-    return;\n-  if (maxsize < LONG_LONG_TYPE_SIZE)\n-    maxsize = LONG_LONG_TYPE_SIZE;\n-  if (minsize > INT_TYPE_SIZE\n-      && (trapv_binoptab_p (optable)\n-\t  || trapv_unoptab_p (optable)))\n-    minsize = INT_TYPE_SIZE;\n-  if (GET_MODE_BITSIZE (mode) < minsize\n-      || GET_MODE_BITSIZE (mode) > maxsize)\n-    return;\n-  gen_libfunc (optable, opname, suffix, mode);\n-}\n+  if (mode == VOIDmode)\n+    return 0;\n+\n+  icode = optab_handler (ctrap_optab, mode);\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n \n-/* Like gen_libfunc, but verify that FP and set decimal prefix if needed.  */\n+  /* Some targets only accept a zero trap code.  */\n+  if (!insn_operand_matches (icode, 3, tcode))\n+    return 0;\n \n-void\n-gen_fp_libfunc (optab optable, const char *opname, char suffix,\n-\t\tmachine_mode mode)\n-{\n-  char *dec_opname;\n+  do_pending_stack_adjust ();\n+  start_sequence ();\n+  prepare_cmp_insn (op1, op2, code, NULL_RTX, false, OPTAB_DIRECT,\n+\t\t    &trap_rtx, &mode);\n+  if (!trap_rtx)\n+    insn = NULL;\n+  else\n+    insn = GEN_FCN (icode) (trap_rtx, XEXP (trap_rtx, 0), XEXP (trap_rtx, 1),\n+\t\t\t    tcode);\n \n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    gen_libfunc (optable, opname, suffix, mode);\n-  if (DECIMAL_FLOAT_MODE_P (mode))\n+  /* If that failed, then give up.  */\n+  if (insn == 0)\n     {\n-      dec_opname = XALLOCAVEC (char, sizeof (DECIMAL_PREFIX) + strlen (opname));\n-      /* For BID support, change the name to have either a bid_ or dpd_ prefix\n-\t depending on the low level floating format used.  */\n-      memcpy (dec_opname, DECIMAL_PREFIX, sizeof (DECIMAL_PREFIX) - 1);\n-      strcpy (dec_opname + sizeof (DECIMAL_PREFIX) - 1, opname);\n-      gen_libfunc (optable, dec_opname, suffix, mode);\n+      end_sequence ();\n+      return 0;\n     }\n-}\n-\n-/* Like gen_libfunc, but verify that fixed-point operation is involved.  */\n-\n-void\n-gen_fixed_libfunc (optab optable, const char *opname, char suffix,\n-\t\t   machine_mode mode)\n-{\n-  if (!ALL_FIXED_POINT_MODE_P (mode))\n-    return;\n-  gen_libfunc (optable, opname, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that signed fixed-point operation is\n-   involved.  */\n-\n-void\n-gen_signed_fixed_libfunc (optab optable, const char *opname, char suffix,\n-\t\t\t  machine_mode mode)\n-{\n-  if (!SIGNED_FIXED_POINT_MODE_P (mode))\n-    return;\n-  gen_libfunc (optable, opname, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that unsigned fixed-point operation is\n-   involved.  */\n-\n-void\n-gen_unsigned_fixed_libfunc (optab optable, const char *opname, char suffix,\n-\t\t\t    machine_mode mode)\n-{\n-  if (!UNSIGNED_FIXED_POINT_MODE_P (mode))\n-    return;\n-  gen_libfunc (optable, opname, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that FP or INT operation is involved.  */\n-\n-void\n-gen_int_fp_libfunc (optab optable, const char *name, char suffix,\n-\t\t    machine_mode mode)\n-{\n-  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    gen_fp_libfunc (optable, name, suffix, mode);\n-  if (INTEGRAL_MODE_P (mode))\n-    gen_int_libfunc (optable, name, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that FP or INT operation is involved\n-   and add 'v' suffix for integer operation.  */\n-\n-void\n-gen_intv_fp_libfunc (optab optable, const char *name, char suffix,\n-\t\t     machine_mode mode)\n-{\n-  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    gen_fp_libfunc (optable, name, suffix, mode);\n-  if (GET_MODE_CLASS (mode) == MODE_INT)\n-    {\n-      int len = strlen (name);\n-      char *v_name = XALLOCAVEC (char, len + 2);\n-      strcpy (v_name, name);\n-      v_name[len] = 'v';\n-      v_name[len + 1] = 0;\n-      gen_int_libfunc (optable, v_name, suffix, mode);\n-    }\n-}\n-\n-/* Like gen_libfunc, but verify that FP or INT or FIXED operation is\n-   involved.  */\n-\n-void\n-gen_int_fp_fixed_libfunc (optab optable, const char *name, char suffix,\n-\t\t\t  machine_mode mode)\n-{\n-  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    gen_fp_libfunc (optable, name, suffix, mode);\n-  if (INTEGRAL_MODE_P (mode))\n-    gen_int_libfunc (optable, name, suffix, mode);\n-  if (ALL_FIXED_POINT_MODE_P (mode))\n-    gen_fixed_libfunc (optable, name, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that FP or INT or signed FIXED operation is\n-   involved.  */\n-\n-void\n-gen_int_fp_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n-\t\t\t\t machine_mode mode)\n-{\n-  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    gen_fp_libfunc (optable, name, suffix, mode);\n-  if (INTEGRAL_MODE_P (mode))\n-    gen_int_libfunc (optable, name, suffix, mode);\n-  if (SIGNED_FIXED_POINT_MODE_P (mode))\n-    gen_signed_fixed_libfunc (optable, name, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that INT or FIXED operation is\n-   involved.  */\n-\n-void\n-gen_int_fixed_libfunc (optab optable, const char *name, char suffix,\n-\t\t       machine_mode mode)\n-{\n-  if (INTEGRAL_MODE_P (mode))\n-    gen_int_libfunc (optable, name, suffix, mode);\n-  if (ALL_FIXED_POINT_MODE_P (mode))\n-    gen_fixed_libfunc (optable, name, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that INT or signed FIXED operation is\n-   involved.  */\n-\n-void\n-gen_int_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n-\t\t\t      machine_mode mode)\n-{\n-  if (INTEGRAL_MODE_P (mode))\n-    gen_int_libfunc (optable, name, suffix, mode);\n-  if (SIGNED_FIXED_POINT_MODE_P (mode))\n-    gen_signed_fixed_libfunc (optable, name, suffix, mode);\n-}\n-\n-/* Like gen_libfunc, but verify that INT or unsigned FIXED operation is\n-   involved.  */\n-\n-void\n-gen_int_unsigned_fixed_libfunc (optab optable, const char *name, char suffix,\n-\t\t\t\tmachine_mode mode)\n-{\n-  if (INTEGRAL_MODE_P (mode))\n-    gen_int_libfunc (optable, name, suffix, mode);\n-  if (UNSIGNED_FIXED_POINT_MODE_P (mode))\n-    gen_unsigned_fixed_libfunc (optable, name, suffix, mode);\n-}\n-\n-/* Initialize the libfunc fields of an entire group of entries of an\n-   inter-mode-class conversion optab.  The string formation rules are\n-   similar to the ones for init_libfuncs, above, but instead of having\n-   a mode name and an operand count these functions have two mode names\n-   and no operand count.  */\n-\n-void\n-gen_interclass_conv_libfunc (convert_optab tab,\n-\t\t\t     const char *opname,\n-\t\t\t     machine_mode tmode,\n-\t\t\t     machine_mode fmode)\n-{\n-  size_t opname_len = strlen (opname);\n-  size_t mname_len = 0;\n-\n-  const char *fname, *tname;\n-  const char *q;\n-  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;\n-  char *libfunc_name, *suffix;\n-  char *nondec_name, *dec_name, *nondec_suffix, *dec_suffix;\n-  char *p;\n-\n-  /* If this is a decimal conversion, add the current BID vs. DPD prefix that\n-     depends on which underlying decimal floating point format is used.  */\n-  const size_t dec_len = sizeof (DECIMAL_PREFIX) - 1;\n-\n-  mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n-\n-  nondec_name = XALLOCAVEC (char, prefix_len + opname_len + mname_len + 1 + 1);\n-  nondec_name[0] = '_';\n-  nondec_name[1] = '_';\n-  if (targetm.libfunc_gnu_prefix)\n-    {\n-      nondec_name[2] = 'g';\n-      nondec_name[3] = 'n';\n-      nondec_name[4] = 'u';\n-      nondec_name[5] = '_';\n-    }\n-\n-  memcpy (&nondec_name[prefix_len], opname, opname_len);\n-  nondec_suffix = nondec_name + opname_len + prefix_len;\n-\n-  dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);\n-  dec_name[0] = '_';\n-  dec_name[1] = '_';\n-  memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n-  memcpy (&dec_name[2+dec_len], opname, opname_len);\n-  dec_suffix = dec_name + dec_len + opname_len + 2;\n-\n-  fname = GET_MODE_NAME (fmode);\n-  tname = GET_MODE_NAME (tmode);\n-\n-  if (DECIMAL_FLOAT_MODE_P (fmode) || DECIMAL_FLOAT_MODE_P (tmode))\n-    {\n-      libfunc_name = dec_name;\n-      suffix = dec_suffix;\n-    }\n-  else\n-    {\n-      libfunc_name = nondec_name;\n-      suffix = nondec_suffix;\n-    }\n-\n-  p = suffix;\n-  for (q = fname; *q; p++, q++)\n-    *p = TOLOWER (*q);\n-  for (q = tname; *q; p++, q++)\n-    *p = TOLOWER (*q);\n-\n-  *p = '\\0';\n-\n-  set_conv_libfunc (tab, tmode, fmode,\n-\t\t    ggc_alloc_string (libfunc_name, p - libfunc_name));\n-}\n-\n-/* Same as gen_interclass_conv_libfunc but verify that we are producing\n-   int->fp conversion.  */\n-\n-void\n-gen_int_to_fp_conv_libfunc (convert_optab tab,\n-\t\t\t    const char *opname,\n-\t\t\t    machine_mode tmode,\n-\t\t\t    machine_mode fmode)\n-{\n-  if (GET_MODE_CLASS (fmode) != MODE_INT)\n-    return;\n-  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n-    return;\n-  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* ufloat_optab is special by using floatun for FP and floatuns decimal fp\n-   naming scheme.  */\n-\n-void\n-gen_ufloat_conv_libfunc (convert_optab tab,\n-\t\t\t const char *opname ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode tmode,\n-\t\t\t machine_mode fmode)\n-{\n-  if (DECIMAL_FLOAT_MODE_P (tmode))\n-    gen_int_to_fp_conv_libfunc (tab, \"floatuns\", tmode, fmode);\n-  else\n-    gen_int_to_fp_conv_libfunc (tab, \"floatun\", tmode, fmode);\n-}\n-\n-/* Same as gen_interclass_conv_libfunc but verify that we are producing\n-   fp->int conversion.  */\n-\n-void\n-gen_int_to_fp_nondecimal_conv_libfunc (convert_optab tab,\n-\t\t\t               const char *opname,\n-\t\t\t               machine_mode tmode,\n-\t\t\t               machine_mode fmode)\n-{\n-  if (GET_MODE_CLASS (fmode) != MODE_INT)\n-    return;\n-  if (GET_MODE_CLASS (tmode) != MODE_FLOAT)\n-    return;\n-  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Same as gen_interclass_conv_libfunc but verify that we are producing\n-   fp->int conversion with no decimal floating point involved.  */\n-\n-void\n-gen_fp_to_int_conv_libfunc (convert_optab tab,\n-\t\t\t    const char *opname,\n-\t\t\t    machine_mode tmode,\n-\t\t\t    machine_mode fmode)\n-{\n-  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n-    return;\n-  if (GET_MODE_CLASS (tmode) != MODE_INT)\n-    return;\n-  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Initialize the libfunc fields of an of an intra-mode-class conversion optab.\n-   The string formation rules are\n-   similar to the ones for init_libfunc, above.  */\n-\n-void\n-gen_intraclass_conv_libfunc (convert_optab tab, const char *opname,\n-\t\t\t     machine_mode tmode, machine_mode fmode)\n-{\n-  size_t opname_len = strlen (opname);\n-  size_t mname_len = 0;\n-\n-  const char *fname, *tname;\n-  const char *q;\n-  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;\n-  char *nondec_name, *dec_name, *nondec_suffix, *dec_suffix;\n-  char *libfunc_name, *suffix;\n-  char *p;\n-\n-  /* If this is a decimal conversion, add the current BID vs. DPD prefix that\n-     depends on which underlying decimal floating point format is used.  */\n-  const size_t dec_len = sizeof (DECIMAL_PREFIX) - 1;\n-\n-  mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n-\n-  nondec_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);\n-  nondec_name[0] = '_';\n-  nondec_name[1] = '_';\n-  if (targetm.libfunc_gnu_prefix)\n-    {\n-      nondec_name[2] = 'g';\n-      nondec_name[3] = 'n';\n-      nondec_name[4] = 'u';\n-      nondec_name[5] = '_';\n-    }\n-  memcpy (&nondec_name[prefix_len], opname, opname_len);\n-  nondec_suffix = nondec_name + opname_len + prefix_len;\n-\n-  dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);\n-  dec_name[0] = '_';\n-  dec_name[1] = '_';\n-  memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n-  memcpy (&dec_name[2 + dec_len], opname, opname_len);\n-  dec_suffix = dec_name + dec_len + opname_len + 2;\n-\n-  fname = GET_MODE_NAME (fmode);\n-  tname = GET_MODE_NAME (tmode);\n-\n-  if (DECIMAL_FLOAT_MODE_P (fmode) || DECIMAL_FLOAT_MODE_P (tmode))\n-    {\n-      libfunc_name = dec_name;\n-      suffix = dec_suffix;\n-    }\n-  else\n-    {\n-      libfunc_name = nondec_name;\n-      suffix = nondec_suffix;\n-    }\n-\n-  p = suffix;\n-  for (q = fname; *q; p++, q++)\n-    *p = TOLOWER (*q);\n-  for (q = tname; *q; p++, q++)\n-    *p = TOLOWER (*q);\n-\n-  *p++ = '2';\n-  *p = '\\0';\n-\n-  set_conv_libfunc (tab, tmode, fmode,\n-\t\t    ggc_alloc_string (libfunc_name, p - libfunc_name));\n-}\n-\n-/* Pick proper libcall for trunc_optab.  We need to chose if we do\n-   truncation or extension and interclass or intraclass.  */\n-\n-void\n-gen_trunc_conv_libfunc (convert_optab tab,\n-\t\t\t const char *opname,\n-\t\t\t machine_mode tmode,\n-\t\t\t machine_mode fmode)\n-{\n-  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n-    return;\n-  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n-    return;\n-  if (tmode == fmode)\n-    return;\n-\n-  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (fmode))\n-      || (GET_MODE_CLASS (fmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (tmode)))\n-     gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-\n-  if (GET_MODE_PRECISION (fmode) <= GET_MODE_PRECISION (tmode))\n-    return;\n-\n-  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT\n-       && GET_MODE_CLASS (fmode) == MODE_FLOAT)\n-      || (DECIMAL_FLOAT_MODE_P (fmode) && DECIMAL_FLOAT_MODE_P (tmode)))\n-    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Pick proper libcall for extend_optab.  We need to chose if we do\n-   truncation or extension and interclass or intraclass.  */\n-\n-void\n-gen_extend_conv_libfunc (convert_optab tab,\n-\t\t\t const char *opname ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode tmode,\n-\t\t\t machine_mode fmode)\n-{\n-  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n-    return;\n-  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n-    return;\n-  if (tmode == fmode)\n-    return;\n-\n-  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (fmode))\n-      || (GET_MODE_CLASS (fmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (tmode)))\n-     gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-\n-  if (GET_MODE_PRECISION (fmode) > GET_MODE_PRECISION (tmode))\n-    return;\n-\n-  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT\n-       && GET_MODE_CLASS (fmode) == MODE_FLOAT)\n-      || (DECIMAL_FLOAT_MODE_P (fmode) && DECIMAL_FLOAT_MODE_P (tmode)))\n-    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Pick proper libcall for fract_optab.  We need to chose if we do\n-   interclass or intraclass.  */\n-\n-void\n-gen_fract_conv_libfunc (convert_optab tab,\n-\t\t\tconst char *opname,\n-\t\t\tmachine_mode tmode,\n-\t\t\tmachine_mode fmode)\n-{\n-  if (tmode == fmode)\n-    return;\n-  if (!(ALL_FIXED_POINT_MODE_P (tmode) || ALL_FIXED_POINT_MODE_P (fmode)))\n-    return;\n-\n-  if (GET_MODE_CLASS (tmode) == GET_MODE_CLASS (fmode))\n-    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n-  else\n-    gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Pick proper libcall for fractuns_optab.  */\n-\n-void\n-gen_fractuns_conv_libfunc (convert_optab tab,\n-\t\t\t   const char *opname,\n-\t\t\t   machine_mode tmode,\n-\t\t\t   machine_mode fmode)\n-{\n-  if (tmode == fmode)\n-    return;\n-  /* One mode must be a fixed-point mode, and the other must be an integer\n-     mode. */\n-  if (!((ALL_FIXED_POINT_MODE_P (tmode) && GET_MODE_CLASS (fmode) == MODE_INT)\n-\t|| (ALL_FIXED_POINT_MODE_P (fmode)\n-\t    && GET_MODE_CLASS (tmode) == MODE_INT)))\n-    return;\n-\n-  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Pick proper libcall for satfract_optab.  We need to chose if we do\n-   interclass or intraclass.  */\n-\n-void\n-gen_satfract_conv_libfunc (convert_optab tab,\n-\t\t\t   const char *opname,\n-\t\t\t   machine_mode tmode,\n-\t\t\t   machine_mode fmode)\n-{\n-  if (tmode == fmode)\n-    return;\n-  /* TMODE must be a fixed-point mode.  */\n-  if (!ALL_FIXED_POINT_MODE_P (tmode))\n-    return;\n-\n-  if (GET_MODE_CLASS (tmode) == GET_MODE_CLASS (fmode))\n-    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n-  else\n-    gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Pick proper libcall for satfractuns_optab.  */\n-\n-void\n-gen_satfractuns_conv_libfunc (convert_optab tab,\n-\t\t\t      const char *opname,\n-\t\t\t      machine_mode tmode,\n-\t\t\t      machine_mode fmode)\n-{\n-  if (tmode == fmode)\n-    return;\n-  /* TMODE must be a fixed-point mode, and FMODE must be an integer mode. */\n-  if (!(ALL_FIXED_POINT_MODE_P (tmode) && GET_MODE_CLASS (fmode) == MODE_INT))\n-    return;\n-\n-  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n-}\n-\n-/* Hashtable callbacks for libfunc_decls.  */\n-\n-struct libfunc_decl_hasher : ggc_ptr_hash<tree_node>\n-{\n-  static hashval_t\n-  hash (tree entry)\n-  {\n-    return IDENTIFIER_HASH_VALUE (DECL_NAME (entry));\n-  }\n-\n-  static bool\n-  equal (tree decl, tree name)\n-  {\n-    return DECL_NAME (decl) == name;\n-  }\n-};\n-\n-/* A table of previously-created libfuncs, hashed by name.  */\n-static GTY (()) hash_table<libfunc_decl_hasher> *libfunc_decls;\n-\n-/* Build a decl for a libfunc named NAME. */\n-\n-tree\n-build_libfunc_function (const char *name)\n-{\n-  tree decl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL,\n-\t\t\t  get_identifier (name),\n-                          build_function_type (integer_type_node, NULL_TREE));\n-  /* ??? We don't have any type information except for this is\n-     a function.  Pretend this is \"int foo()\".  */\n-  DECL_ARTIFICIAL (decl) = 1;\n-  DECL_EXTERNAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  gcc_assert (DECL_ASSEMBLER_NAME (decl));\n-\n-  /* Zap the nonsensical SYMBOL_REF_DECL for this.  What we're left with\n-     are the flags assigned by targetm.encode_section_info.  */\n-  SET_SYMBOL_REF_DECL (XEXP (DECL_RTL (decl), 0), NULL);\n-\n-  return decl;\n-}\n-\n-rtx\n-init_one_libfunc (const char *name)\n-{\n-  tree id, decl;\n-  hashval_t hash;\n-\n-  if (libfunc_decls == NULL)\n-    libfunc_decls = hash_table<libfunc_decl_hasher>::create_ggc (37);\n-\n-  /* See if we have already created a libfunc decl for this function.  */\n-  id = get_identifier (name);\n-  hash = IDENTIFIER_HASH_VALUE (id);\n-  tree *slot = libfunc_decls->find_slot_with_hash (id, hash, INSERT);\n-  decl = *slot;\n-  if (decl == NULL)\n-    {\n-      /* Create a new decl, so that it can be passed to\n-\t targetm.encode_section_info.  */\n-      decl = build_libfunc_function (name);\n-      *slot = decl;\n-    }\n-  return XEXP (DECL_RTL (decl), 0);\n-}\n-\n-/* Adjust the assembler name of libfunc NAME to ASMSPEC.  */\n-\n-rtx\n-set_user_assembler_libfunc (const char *name, const char *asmspec)\n-{\n-  tree id, decl;\n-  hashval_t hash;\n-\n-  id = get_identifier (name);\n-  hash = IDENTIFIER_HASH_VALUE (id);\n-  tree *slot = libfunc_decls->find_slot_with_hash (id, hash, NO_INSERT);\n-  gcc_assert (slot);\n-  decl = (tree) *slot;\n-  set_user_assembler_name (decl, asmspec);\n-  return XEXP (DECL_RTL (decl), 0);\n-}\n-\n-/* Call this to reset the function entry for one optab (OPTABLE) in mode\n-   MODE to NAME, which should be either 0 or a string constant.  */\n-void\n-set_optab_libfunc (optab op, machine_mode mode, const char *name)\n-{\n-  rtx val;\n-  struct libfunc_entry e;\n-  struct libfunc_entry **slot;\n-\n-  e.op = op;\n-  e.mode1 = mode;\n-  e.mode2 = VOIDmode;\n-\n-  if (name)\n-    val = init_one_libfunc (name);\n-  else\n-    val = 0;\n-  slot = libfunc_hash->find_slot (&e, INSERT);\n-  if (*slot == NULL)\n-    *slot = ggc_alloc<libfunc_entry> ();\n-  (*slot)->op = op;\n-  (*slot)->mode1 = mode;\n-  (*slot)->mode2 = VOIDmode;\n-  (*slot)->libfunc = val;\n-}\n-\n-/* Call this to reset the function entry for one conversion optab\n-   (OPTABLE) from mode FMODE to mode TMODE to NAME, which should be\n-   either 0 or a string constant.  */\n-void\n-set_conv_libfunc (convert_optab optab, machine_mode tmode,\n-\t\t  machine_mode fmode, const char *name)\n-{\n-  rtx val;\n-  struct libfunc_entry e;\n-  struct libfunc_entry **slot;\n-\n-  e.op = optab;\n-  e.mode1 = tmode;\n-  e.mode2 = fmode;\n-\n-  if (name)\n-    val = init_one_libfunc (name);\n-  else\n-    val = 0;\n-  slot = libfunc_hash->find_slot (&e, INSERT);\n-  if (*slot == NULL)\n-    *slot = ggc_alloc<libfunc_entry> ();\n-  (*slot)->op = optab;\n-  (*slot)->mode1 = tmode;\n-  (*slot)->mode2 = fmode;\n-  (*slot)->libfunc = val;\n-}\n-\n-/* Call this to initialize the contents of the optabs\n-   appropriately for the current target machine.  */\n-\n-void\n-init_optabs (void)\n-{\n-  if (libfunc_hash)\n-    libfunc_hash->empty ();\n-  else\n-    libfunc_hash = hash_table<libfunc_hasher>::create_ggc (10);\n-\n-  /* Fill in the optabs with the insns we support.  */\n-  init_all_optabs (this_fn_optabs);\n-\n-  /* The ffs function operates on `int'.  Fall back on it if we do not\n-     have a libgcc2 function for that width.  */\n-  if (INT_TYPE_SIZE < BITS_PER_WORD)\n-    set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n-\t\t       \"ffs\");\n-\n-  /* Explicitly initialize the bswap libfuncs since we need them to be\n-     valid for things other than word_mode.  */\n-  if (targetm.libfunc_gnu_prefix)\n-    {\n-      set_optab_libfunc (bswap_optab, SImode, \"__gnu_bswapsi2\");\n-      set_optab_libfunc (bswap_optab, DImode, \"__gnu_bswapdi2\");\n-    }\n-  else\n-    {\n-      set_optab_libfunc (bswap_optab, SImode, \"__bswapsi2\");\n-      set_optab_libfunc (bswap_optab, DImode, \"__bswapdi2\");\n-    }\n-\n-  /* Use cabs for double complex abs, since systems generally have cabs.\n-     Don't define any libcall for float complex, so that cabs will be used.  */\n-  if (complex_double_type_node)\n-    set_optab_libfunc (abs_optab, TYPE_MODE (complex_double_type_node),\n-\t\t       \"cabs\");\n-\n-  abort_libfunc = init_one_libfunc (\"abort\");\n-  memcpy_libfunc = init_one_libfunc (\"memcpy\");\n-  memmove_libfunc = init_one_libfunc (\"memmove\");\n-  memcmp_libfunc = init_one_libfunc (\"memcmp\");\n-  memset_libfunc = init_one_libfunc (\"memset\");\n-  setbits_libfunc = init_one_libfunc (\"__setbits\");\n-\n-#ifndef DONT_USE_BUILTIN_SETJMP\n-  setjmp_libfunc = init_one_libfunc (\"__builtin_setjmp\");\n-  longjmp_libfunc = init_one_libfunc (\"__builtin_longjmp\");\n-#else\n-  setjmp_libfunc = init_one_libfunc (\"setjmp\");\n-  longjmp_libfunc = init_one_libfunc (\"longjmp\");\n-#endif\n-  unwind_sjlj_register_libfunc = init_one_libfunc (\"_Unwind_SjLj_Register\");\n-  unwind_sjlj_unregister_libfunc\n-    = init_one_libfunc (\"_Unwind_SjLj_Unregister\");\n-\n-  /* For function entry/exit instrumentation.  */\n-  profile_function_entry_libfunc\n-    = init_one_libfunc (\"__cyg_profile_func_enter\");\n-  profile_function_exit_libfunc\n-    = init_one_libfunc (\"__cyg_profile_func_exit\");\n-\n-  gcov_flush_libfunc = init_one_libfunc (\"__gcov_flush\");\n-\n-  /* Allow the target to add more libcalls or rename some, etc.  */\n-  targetm.init_libfuncs ();\n-}\n-\n-/* Use the current target and options to initialize\n-   TREE_OPTIMIZATION_OPTABS (OPTNODE).  */\n-\n-void\n-init_tree_optimization_optabs (tree optnode)\n-{\n-  /* Quick exit if we have already computed optabs for this target.  */\n-  if (TREE_OPTIMIZATION_BASE_OPTABS (optnode) == this_target_optabs)\n-    return;\n-\n-  /* Forget any previous information and set up for the current target.  */\n-  TREE_OPTIMIZATION_BASE_OPTABS (optnode) = this_target_optabs;\n-  struct target_optabs *tmp_optabs = (struct target_optabs *)\n-    TREE_OPTIMIZATION_OPTABS (optnode);\n-  if (tmp_optabs)\n-    memset (tmp_optabs, 0, sizeof (struct target_optabs));\n-  else\n-    tmp_optabs = ggc_alloc<target_optabs> ();\n-\n-  /* Generate a new set of optabs into tmp_optabs.  */\n-  init_all_optabs (tmp_optabs);\n-\n-  /* If the optabs changed, record it.  */\n-  if (memcmp (tmp_optabs, this_target_optabs, sizeof (struct target_optabs)))\n-    TREE_OPTIMIZATION_OPTABS (optnode) = tmp_optabs;\n-  else\n-    {\n-      TREE_OPTIMIZATION_OPTABS (optnode) = NULL;\n-      ggc_free (tmp_optabs);\n-    }\n-}\n-\n-/* A helper function for init_sync_libfuncs.  Using the basename BASE,\n-   install libfuncs into TAB for BASE_N for 1 <= N <= MAX.  */\n-\n-static void\n-init_sync_libfuncs_1 (optab tab, const char *base, int max)\n-{\n-  machine_mode mode;\n-  char buf[64];\n-  size_t len = strlen (base);\n-  int i;\n-\n-  gcc_assert (max <= 8);\n-  gcc_assert (len + 3 < sizeof (buf));\n-\n-  memcpy (buf, base, len);\n-  buf[len] = '_';\n-  buf[len + 1] = '0';\n-  buf[len + 2] = '\\0';\n-\n-  mode = QImode;\n-  for (i = 1; i <= max; i *= 2)\n-    {\n-      buf[len + 1] = '0' + i;\n-      set_optab_libfunc (tab, mode, buf);\n-      mode = GET_MODE_2XWIDER_MODE (mode);\n-    }\n-}\n-\n-void\n-init_sync_libfuncs (int max)\n-{\n-  if (!flag_sync_libcalls)\n-    return;\n-\n-  init_sync_libfuncs_1 (sync_compare_and_swap_optab,\n-\t\t\t\"__sync_val_compare_and_swap\", max);\n-  init_sync_libfuncs_1 (sync_lock_test_and_set_optab,\n-\t\t\t\"__sync_lock_test_and_set\", max);\n-\n-  init_sync_libfuncs_1 (sync_old_add_optab, \"__sync_fetch_and_add\", max);\n-  init_sync_libfuncs_1 (sync_old_sub_optab, \"__sync_fetch_and_sub\", max);\n-  init_sync_libfuncs_1 (sync_old_ior_optab, \"__sync_fetch_and_or\", max);\n-  init_sync_libfuncs_1 (sync_old_and_optab, \"__sync_fetch_and_and\", max);\n-  init_sync_libfuncs_1 (sync_old_xor_optab, \"__sync_fetch_and_xor\", max);\n-  init_sync_libfuncs_1 (sync_old_nand_optab, \"__sync_fetch_and_nand\", max);\n-\n-  init_sync_libfuncs_1 (sync_new_add_optab, \"__sync_add_and_fetch\", max);\n-  init_sync_libfuncs_1 (sync_new_sub_optab, \"__sync_sub_and_fetch\", max);\n-  init_sync_libfuncs_1 (sync_new_ior_optab, \"__sync_or_and_fetch\", max);\n-  init_sync_libfuncs_1 (sync_new_and_optab, \"__sync_and_and_fetch\", max);\n-  init_sync_libfuncs_1 (sync_new_xor_optab, \"__sync_xor_and_fetch\", max);\n-  init_sync_libfuncs_1 (sync_new_nand_optab, \"__sync_nand_and_fetch\", max);\n-}\n-\n-/* Print information about the current contents of the optabs on\n-   STDERR.  */\n-\n-DEBUG_FUNCTION void\n-debug_optab_libfuncs (void)\n-{\n-  int i, j, k;\n-\n-  /* Dump the arithmetic optabs.  */\n-  for (i = FIRST_NORM_OPTAB; i <= LAST_NORMLIB_OPTAB; ++i)\n-    for (j = 0; j < NUM_MACHINE_MODES; ++j)\n-      {\n-\trtx l = optab_libfunc ((optab) i, (machine_mode) j);\n-\tif (l)\n-\t  {\n-\t    gcc_assert (GET_CODE (l) == SYMBOL_REF);\n-\t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n-\t\t     GET_RTX_NAME (optab_to_code ((optab) i)),\n-\t\t     GET_MODE_NAME (j),\n-\t\t     XSTR (l, 0));\n-\t  }\n-      }\n-\n-  /* Dump the conversion optabs.  */\n-  for (i = FIRST_CONV_OPTAB; i <= LAST_CONVLIB_OPTAB; ++i)\n-    for (j = 0; j < NUM_MACHINE_MODES; ++j)\n-      for (k = 0; k < NUM_MACHINE_MODES; ++k)\n-\t{\n-\t  rtx l = convert_optab_libfunc ((optab) i, (machine_mode) j,\n-\t\t\t\t\t (machine_mode) k);\n-\t  if (l)\n-\t    {\n-\t      gcc_assert (GET_CODE (l) == SYMBOL_REF);\n-\t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n-\t\t       GET_RTX_NAME (optab_to_code ((optab) i)),\n-\t\t       GET_MODE_NAME (j),\n-\t\t       GET_MODE_NAME (k),\n-\t\t       XSTR (l, 0));\n-\t    }\n-\t}\n-}\n-\n-\f\n-/* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition\n-   CODE.  Return 0 on failure.  */\n-\n-rtx_insn *\n-gen_cond_trap (enum rtx_code code, rtx op1, rtx op2, rtx tcode)\n-{\n-  machine_mode mode = GET_MODE (op1);\n-  enum insn_code icode;\n-  rtx_insn *insn;\n-  rtx trap_rtx;\n-\n-  if (mode == VOIDmode)\n-    return 0;\n-\n-  icode = optab_handler (ctrap_optab, mode);\n-  if (icode == CODE_FOR_nothing)\n-    return 0;\n-\n-  /* Some targets only accept a zero trap code.  */\n-  if (!insn_operand_matches (icode, 3, tcode))\n-    return 0;\n-\n-  do_pending_stack_adjust ();\n-  start_sequence ();\n-  prepare_cmp_insn (op1, op2, code, NULL_RTX, false, OPTAB_DIRECT,\n-\t\t    &trap_rtx, &mode);\n-  if (!trap_rtx)\n-    insn = NULL;\n-  else\n-    insn = GEN_FCN (icode) (trap_rtx, XEXP (trap_rtx, 0), XEXP (trap_rtx, 1),\n-\t\t\t    tcode);\n-\n-  /* If that failed, then give up.  */\n-  if (insn == 0)\n-    {\n-      end_sequence ();\n-      return 0;\n-    }\n-\n-  emit_insn (insn);\n-  insn = get_insns ();\n-  end_sequence ();\n-  return insn;\n+\n+  emit_insn (insn);\n+  insn = get_insns ();\n+  end_sequence ();\n+  return insn;\n }\n \n /* Return rtx code for TCODE. Use UNSIGNEDP to select signed\n@@ -6534,63 +5135,6 @@ vector_compare_rtx (enum tree_code tcode, tree t_op0, tree t_op1,\n   return gen_rtx_fmt_ee (rcode, VOIDmode, ops[0].value, ops[1].value);\n }\n \n-/* Return true if VEC_PERM_EXPR of arbitrary input vectors can be expanded using\n-   SIMD extensions of the CPU.  SEL may be NULL, which stands for an unknown\n-   constant.  Note that additional permutations representing whole-vector shifts\n-   may also be handled via the vec_shr optab, but only where the second input\n-   vector is entirely constant zeroes; this case is not dealt with here.  */\n-\n-bool\n-can_vec_perm_p (machine_mode mode, bool variable,\n-\t\tconst unsigned char *sel)\n-{\n-  machine_mode qimode;\n-\n-  /* If the target doesn't implement a vector mode for the vector type,\n-     then no operations are supported.  */\n-  if (!VECTOR_MODE_P (mode))\n-    return false;\n-\n-  if (!variable)\n-    {\n-      if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n-\t  && (sel == NULL\n-\t      || targetm.vectorize.vec_perm_const_ok == NULL\n-\t      || targetm.vectorize.vec_perm_const_ok (mode, sel)))\n-\treturn true;\n-    }\n-\n-  if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n-    return true;\n-\n-  /* We allow fallback to a QI vector mode, and adjust the mask.  */\n-  if (GET_MODE_INNER (mode) == QImode)\n-    return false;\n-  qimode = mode_for_vector (QImode, GET_MODE_SIZE (mode));\n-  if (!VECTOR_MODE_P (qimode))\n-    return false;\n-\n-  /* ??? For completeness, we ought to check the QImode version of\n-      vec_perm_const_optab.  But all users of this implicit lowering\n-      feature implement the variable vec_perm_optab.  */\n-  if (direct_optab_handler (vec_perm_optab, qimode) == CODE_FOR_nothing)\n-    return false;\n-\n-  /* In order to support the lowering of variable permutations,\n-     we need to support shifts and adds.  */\n-  if (variable)\n-    {\n-      if (GET_MODE_UNIT_SIZE (mode) > 2\n-\t  && optab_handler (ashl_optab, mode) == CODE_FOR_nothing\n-\t  && optab_handler (vashl_optab, mode) == CODE_FOR_nothing)\n-\treturn false;\n-      if (optab_handler (add_optab, qimode) == CODE_FOR_nothing)\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n /* Checks if vec_perm mask SEL is a constant equivalent to a shift of the first\n    vec_perm operand, assuming the second operand is a constant vector of zeroes.\n    Return the shift distance in bits if so, or NULL_RTX if the vec_perm is not a\n@@ -6800,37 +5344,6 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   return tmp;\n }\n \n-/* Return insn code for a conditional operator with a comparison in\n-   mode CMODE, unsigned if UNS is true, resulting in a value of mode VMODE.  */\n-\n-static inline enum insn_code\n-get_vcond_icode (machine_mode vmode, machine_mode cmode, bool uns)\n-{\n-  enum insn_code icode = CODE_FOR_nothing;\n-  if (uns)\n-    icode = convert_optab_handler (vcondu_optab, vmode, cmode);\n-  else\n-    icode = convert_optab_handler (vcond_optab, vmode, cmode);\n-  return icode;\n-}\n-\n-/* Return TRUE iff, appropriate vector insns are available\n-   for vector cond expr with vector type VALUE_TYPE and a comparison\n-   with operand vector types in CMP_OP_TYPE.  */\n-\n-bool\n-expand_vec_cond_expr_p (tree value_type, tree cmp_op_type)\n-{\n-  machine_mode value_mode = TYPE_MODE (value_type);\n-  machine_mode cmp_op_mode = TYPE_MODE (cmp_op_type);\n-  if (GET_MODE_SIZE (value_mode) != GET_MODE_SIZE (cmp_op_mode)\n-      || GET_MODE_NUNITS (value_mode) != GET_MODE_NUNITS (cmp_op_mode)\n-      || get_vcond_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type),\n-\t\t\t  TYPE_UNSIGNED (cmp_op_type)) == CODE_FOR_nothing)\n-    return false;\n-  return true;\n-}\n-\n /* Generate insns for a VEC_COND_EXPR, given its TYPE and its\n    three operands.  */\n \n@@ -6886,57 +5399,6 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n   return ops[0].value;\n }\n \n-/* Return non-zero if a highpart multiply is supported of can be synthisized.\n-   For the benefit of expand_mult_highpart, the return value is 1 for direct,\n-   2 for even/odd widening, and 3 for hi/lo widening.  */\n-\n-int\n-can_mult_highpart_p (machine_mode mode, bool uns_p)\n-{\n-  optab op;\n-  unsigned char *sel;\n-  unsigned i, nunits;\n-\n-  op = uns_p ? umul_highpart_optab : smul_highpart_optab;\n-  if (optab_handler (op, mode) != CODE_FOR_nothing)\n-    return 1;\n-\n-  /* If the mode is an integral vector, synth from widening operations.  */\n-  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n-    return 0;\n-\n-  nunits = GET_MODE_NUNITS (mode);\n-  sel = XALLOCAVEC (unsigned char, nunits);\n-\n-  op = uns_p ? vec_widen_umult_even_optab : vec_widen_smult_even_optab;\n-  if (optab_handler (op, mode) != CODE_FOR_nothing)\n-    {\n-      op = uns_p ? vec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n-      if (optab_handler (op, mode) != CODE_FOR_nothing)\n-\t{\n-\t  for (i = 0; i < nunits; ++i)\n-\t    sel[i] = !BYTES_BIG_ENDIAN + (i & ~1) + ((i & 1) ? nunits : 0);\n-\t  if (can_vec_perm_p (mode, false, sel))\n-\t    return 2;\n-\t}\n-    }\n-\n-  op = uns_p ? vec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n-  if (optab_handler (op, mode) != CODE_FOR_nothing)\n-    {\n-      op = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n-      if (optab_handler (op, mode) != CODE_FOR_nothing)\n-\t{\n-\t  for (i = 0; i < nunits; ++i)\n-\t    sel[i] = 2 * i + (BYTES_BIG_ENDIAN ? 0 : 1);\n-\t  if (can_vec_perm_p (mode, false, sel))\n-\t    return 3;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n /* Expand a highpart multiply.  */\n \n rtx\n@@ -7008,89 +5470,7 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n \n   return expand_vec_perm (mode, m1, m2, perm, target);\n }\n-\n-/* Return true if target supports vector masked load/store for mode.  */\n-bool\n-can_vec_mask_load_store_p (machine_mode mode, bool is_load)\n-{\n-  optab op = is_load ? maskload_optab : maskstore_optab;\n-  machine_mode vmode;\n-  unsigned int vector_sizes;\n-\n-  /* If mode is vector mode, check it directly.  */\n-  if (VECTOR_MODE_P (mode))\n-    return optab_handler (op, mode) != CODE_FOR_nothing;\n-\n-  /* Otherwise, return true if there is some vector mode with\n-     the mask load/store supported.  */\n-\n-  /* See if there is any chance the mask load or store might be\n-     vectorized.  If not, punt.  */\n-  vmode = targetm.vectorize.preferred_simd_mode (mode);\n-  if (!VECTOR_MODE_P (vmode))\n-    return false;\n-\n-  if (optab_handler (op, vmode) != CODE_FOR_nothing)\n-    return true;\n-\n-  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n-  while (vector_sizes != 0)\n-    {\n-      unsigned int cur = 1 << floor_log2 (vector_sizes);\n-      vector_sizes &= ~cur;\n-      if (cur <= GET_MODE_SIZE (mode))\n-\tcontinue;\n-      vmode = mode_for_vector (mode, cur / GET_MODE_SIZE (mode));\n-      if (VECTOR_MODE_P (vmode)\n-\t  && optab_handler (op, vmode) != CODE_FOR_nothing)\n-\treturn true;\n-    }\n-  return false;\n-}\n \f\n-/* Return true if there is a compare_and_swap pattern.  */\n-\n-bool\n-can_compare_and_swap_p (machine_mode mode, bool allow_libcall)\n-{\n-  enum insn_code icode;\n-\n-  /* Check for __atomic_compare_and_swap.  */\n-  icode = direct_optab_handler (atomic_compare_and_swap_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n-    return true;\n-\n-  /* Check for __sync_compare_and_swap.  */\n-  icode = optab_handler (sync_compare_and_swap_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n-    return true;\n-  if (allow_libcall && optab_libfunc (sync_compare_and_swap_optab, mode))\n-    return true;\n-\n-  /* No inline compare and swap.  */\n-  return false;\n-}\n-\n-/* Return true if an atomic exchange can be performed.  */\n-\n-bool\n-can_atomic_exchange_p (machine_mode mode, bool allow_libcall)\n-{\n-  enum insn_code icode;\n-\n-  /* Check for __atomic_exchange.  */\n-  icode = direct_optab_handler (atomic_exchange_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n-    return true;\n-\n-  /* Don't check __sync_test_and_set, as on some platforms that\n-     has reduced functionality.  Targets that really do support\n-     a proper exchange should simply be updated to the __atomics.  */\n-\n-  return can_compare_and_swap_p (mode, allow_libcall);\n-}\n-\n-\n /* Helper function to find the MODE_CC set in a sync_compare_and_swap\n    pattern.  */\n \n@@ -8412,225 +6792,3 @@ expand_jump_insn (enum insn_code icode, unsigned int nops,\n   if (!maybe_expand_jump_insn (icode, nops, ops))\n     gcc_unreachable ();\n }\n-\n-/* Reduce conditional compilation elsewhere.  */\n-\n-/* Enumerates the possible types of structure operand to an\n-   extraction_insn.  */\n-enum extraction_type { ET_unaligned_mem, ET_reg };\n-\n-/* Check whether insv, extv or extzv pattern ICODE can be used for an\n-   insertion or extraction of type TYPE on a structure of mode MODE.\n-   Return true if so and fill in *INSN accordingly.  STRUCT_OP is the\n-   operand number of the structure (the first sign_extract or zero_extract\n-   operand) and FIELD_OP is the operand number of the field (the other\n-   side of the set from the sign_extract or zero_extract).  */\n-\n-static bool\n-get_traditional_extraction_insn (extraction_insn *insn,\n-\t\t\t\t enum extraction_type type,\n-\t\t\t\t machine_mode mode,\n-\t\t\t\t enum insn_code icode,\n-\t\t\t\t int struct_op, int field_op)\n-{\n-  const struct insn_data_d *data = &insn_data[icode];\n-\n-  machine_mode struct_mode = data->operand[struct_op].mode;\n-  if (struct_mode == VOIDmode)\n-    struct_mode = word_mode;\n-  if (mode != struct_mode)\n-    return false;\n-\n-  machine_mode field_mode = data->operand[field_op].mode;\n-  if (field_mode == VOIDmode)\n-    field_mode = word_mode;\n-\n-  machine_mode pos_mode = data->operand[struct_op + 2].mode;\n-  if (pos_mode == VOIDmode)\n-    pos_mode = word_mode;\n-\n-  insn->icode = icode;\n-  insn->field_mode = field_mode;\n-  insn->struct_mode = (type == ET_unaligned_mem ? byte_mode : struct_mode);\n-  insn->pos_mode = pos_mode;\n-  return true;\n-}\n-\n-/* Return true if an optab exists to perform an insertion or extraction\n-   of type TYPE in mode MODE.  Describe the instruction in *INSN if so.\n-\n-   REG_OPTAB is the optab to use for register structures and\n-   MISALIGN_OPTAB is the optab to use for misaligned memory structures.\n-   POS_OP is the operand number of the bit position.  */\n-\n-static bool\n-get_optab_extraction_insn (struct extraction_insn *insn,\n-\t\t\t   enum extraction_type type,\n-\t\t\t   machine_mode mode, direct_optab reg_optab,\n-\t\t\t   direct_optab misalign_optab, int pos_op)\n-{\n-  direct_optab optab = (type == ET_unaligned_mem ? misalign_optab : reg_optab);\n-  enum insn_code icode = direct_optab_handler (optab, mode);\n-  if (icode == CODE_FOR_nothing)\n-    return false;\n-\n-  const struct insn_data_d *data = &insn_data[icode];\n-\n-  insn->icode = icode;\n-  insn->field_mode = mode;\n-  insn->struct_mode = (type == ET_unaligned_mem ? BLKmode : mode);\n-  insn->pos_mode = data->operand[pos_op].mode;\n-  if (insn->pos_mode == VOIDmode)\n-    insn->pos_mode = word_mode;\n-  return true;\n-}\n-\n-/* Return true if an instruction exists to perform an insertion or\n-   extraction (PATTERN says which) of type TYPE in mode MODE.\n-   Describe the instruction in *INSN if so.  */\n-\n-static bool\n-get_extraction_insn (extraction_insn *insn,\n-\t\t     enum extraction_pattern pattern,\n-\t\t     enum extraction_type type,\n-\t\t     machine_mode mode)\n-{\n-  switch (pattern)\n-    {\n-    case EP_insv:\n-      if (targetm.have_insv ()\n-\t  && get_traditional_extraction_insn (insn, type, mode,\n-\t\t\t\t\t      targetm.code_for_insv, 0, 3))\n-\treturn true;\n-      return get_optab_extraction_insn (insn, type, mode, insv_optab,\n-\t\t\t\t\tinsvmisalign_optab, 2);\n-\n-    case EP_extv:\n-      if (targetm.have_extv ()\n-\t  && get_traditional_extraction_insn (insn, type, mode,\n-\t\t\t\t\t      targetm.code_for_extv, 1, 0))\n-\treturn true;\n-      return get_optab_extraction_insn (insn, type, mode, extv_optab,\n-\t\t\t\t\textvmisalign_optab, 3);\n-\n-    case EP_extzv:\n-      if (targetm.have_extzv ()\n-\t  && get_traditional_extraction_insn (insn, type, mode,\n-\t\t\t\t\t      targetm.code_for_extzv, 1, 0))\n-\treturn true;\n-      return get_optab_extraction_insn (insn, type, mode, extzv_optab,\n-\t\t\t\t\textzvmisalign_optab, 3);\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return true if an instruction exists to access a field of mode\n-   FIELDMODE in a structure that has STRUCT_BITS significant bits.\n-   Describe the \"best\" such instruction in *INSN if so.  PATTERN and\n-   TYPE describe the type of insertion or extraction we want to perform.\n-\n-   For an insertion, the number of significant structure bits includes\n-   all bits of the target.  For an extraction, it need only include the\n-   most significant bit of the field.  Larger widths are acceptable\n-   in both cases.  */\n-\n-static bool\n-get_best_extraction_insn (extraction_insn *insn,\n-\t\t\t  enum extraction_pattern pattern,\n-\t\t\t  enum extraction_type type,\n-\t\t\t  unsigned HOST_WIDE_INT struct_bits,\n-\t\t\t  machine_mode field_mode)\n-{\n-  machine_mode mode = smallest_mode_for_size (struct_bits, MODE_INT);\n-  while (mode != VOIDmode)\n-    {\n-      if (get_extraction_insn (insn, pattern, type, mode))\n-\t{\n-\t  while (mode != VOIDmode\n-\t\t && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (field_mode)\n-\t\t && !TRULY_NOOP_TRUNCATION_MODES_P (insn->field_mode,\n-\t\t\t\t\t\t    field_mode))\n-\t    {\n-\t      get_extraction_insn (insn, pattern, type, mode);\n-\t      mode = GET_MODE_WIDER_MODE (mode);\n-\t    }\n-\t  return true;\n-\t}\n-      mode = GET_MODE_WIDER_MODE (mode);\n-    }\n-  return false;\n-}\n-\n-/* Return true if an instruction exists to access a field of mode\n-   FIELDMODE in a register structure that has STRUCT_BITS significant bits.\n-   Describe the \"best\" such instruction in *INSN if so.  PATTERN describes\n-   the type of insertion or extraction we want to perform.\n-\n-   For an insertion, the number of significant structure bits includes\n-   all bits of the target.  For an extraction, it need only include the\n-   most significant bit of the field.  Larger widths are acceptable\n-   in both cases.  */\n-\n-bool\n-get_best_reg_extraction_insn (extraction_insn *insn,\n-\t\t\t      enum extraction_pattern pattern,\n-\t\t\t      unsigned HOST_WIDE_INT struct_bits,\n-\t\t\t      machine_mode field_mode)\n-{\n-  return get_best_extraction_insn (insn, pattern, ET_reg, struct_bits,\n-\t\t\t\t   field_mode);\n-}\n-\n-/* Return true if an instruction exists to access a field of BITSIZE\n-   bits starting BITNUM bits into a memory structure.  Describe the\n-   \"best\" such instruction in *INSN if so.  PATTERN describes the type\n-   of insertion or extraction we want to perform and FIELDMODE is the\n-   natural mode of the extracted field.\n-\n-   The instructions considered here only access bytes that overlap\n-   the bitfield; they do not touch any surrounding bytes.  */\n-\n-bool\n-get_best_mem_extraction_insn (extraction_insn *insn,\n-\t\t\t      enum extraction_pattern pattern,\n-\t\t\t      HOST_WIDE_INT bitsize, HOST_WIDE_INT bitnum,\n-\t\t\t      machine_mode field_mode)\n-{\n-  unsigned HOST_WIDE_INT struct_bits = (bitnum % BITS_PER_UNIT\n-\t\t\t\t\t+ bitsize\n-\t\t\t\t\t+ BITS_PER_UNIT - 1);\n-  struct_bits -= struct_bits % BITS_PER_UNIT;\n-  return get_best_extraction_insn (insn, pattern, ET_unaligned_mem,\n-\t\t\t\t   struct_bits, field_mode);\n-}\n-\n-/* Determine whether \"1 << x\" is relatively cheap in word_mode.  */\n-\n-bool\n-lshift_cheap_p (bool speed_p)\n-{\n-  /* FIXME: This should be made target dependent via this \"this_target\"\n-     mechanism, similar to e.g. can_copy_init_p in gcse.c.  */\n-  static bool init[2] = { false, false };\n-  static bool cheap[2] = { true, true };\n-\n-  /* If the targer has no lshift in word_mode, the operation will most\n-     probably not be cheap.  ??? Does GCC even work for such targets?  */\n-  if (optab_handler (ashl_optab, word_mode) == CODE_FOR_nothing)\n-    return false;\n-\n-  if (!init[speed_p])\n-    {\n-      rtx reg = gen_raw_REG (word_mode, 10000);\n-      int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n-\t\t\t       word_mode, speed_p);\n-      cheap[speed_p] = cost < COSTS_N_INSNS (3);\n-      init[speed_p] = true;\n-    }\n-\n-  return cheap[speed_p];\n-}\n-\n-#include \"gt-optabs.h\""}, {"sha": "3f29d1b6f79055074b0bc3098bebeea5c92f8741", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 226, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -20,87 +20,12 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_OPTABS_H\n #define GCC_OPTABS_H\n \n-#include \"insn-opinit.h\"\n+#include \"optabs-query.h\"\n+#include \"optabs-libfuncs.h\"\n \n /* Generate code for a widening multiply.  */\n extern rtx expand_widening_mult (machine_mode, rtx, rtx, rtx, int, optab);\n \n-/* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n-   if the target does not have such an insn.  */\n-\n-static inline enum insn_code\n-optab_handler (optab op, machine_mode mode)\n-{\n-  unsigned scode = (op << 16) | mode;\n-  gcc_assert (op > LAST_CONV_OPTAB);\n-  return raw_optab_handler (scode);\n-}\n-\n-/* Return the insn used to perform conversion OP from mode FROM_MODE\n-   to mode TO_MODE; return CODE_FOR_nothing if the target does not have\n-   such an insn.  */\n-\n-static inline enum insn_code\n-convert_optab_handler (convert_optab op, machine_mode to_mode,\n-\t\t       machine_mode from_mode)\n-{\n-  unsigned scode = (op << 16) | (from_mode << 8) | to_mode;\n-  gcc_assert (op > unknown_optab && op <= LAST_CONV_OPTAB);\n-  return raw_optab_handler (scode);\n-}\n-\n-/* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n-   if the target does not have such an insn.  */\n-\n-static inline enum insn_code\n-direct_optab_handler (direct_optab op, machine_mode mode)\n-{\n-  return optab_handler (op, mode);\n-}\n-\n-/* Return true if UNOPTAB is for a trapping-on-overflow operation.  */\n-\n-static inline bool\n-trapv_unoptab_p (optab unoptab)\n-{\n-  return (unoptab == negv_optab\n-\t  || unoptab == absv_optab); \n-}\n-\n-/* Return true if BINOPTAB is for a trapping-on-overflow operation.  */\n-\n-static inline bool\n-trapv_binoptab_p (optab binoptab)\n-{\n-  return (binoptab == addv_optab\n-\t  || binoptab == subv_optab\n-\t  || binoptab == smulv_optab);\n-}\n-\n-\n-\n-/* Describes an instruction that inserts or extracts a bitfield.  */\n-struct extraction_insn\n-{\n-  /* The code of the instruction.  */\n-  enum insn_code icode;\n-\n-  /* The mode that the structure operand should have.  This is byte_mode\n-     when using the legacy insv, extv and extzv patterns to access memory.  */\n-  machine_mode struct_mode;\n-\n-  /* The mode of the field to be inserted or extracted, and by extension\n-     the mode of the insertion or extraction itself.  */\n-  machine_mode field_mode;\n-\n-  /* The mode of the field's bit position.  This is only important\n-     when the position is variable rather than constant.  */\n-  machine_mode pos_mode;\n-};\n-\n-\n-\n-\n /* Describes the type of an expand_operand.  Each value is associated\n    with a create_*_operand function; see the comments above those\n    functions for details.  */\n@@ -227,30 +152,6 @@ create_integer_operand (struct expand_operand *op, HOST_WIDE_INT intval)\n }\n \n \n-extern rtx convert_optab_libfunc (convert_optab optab, machine_mode mode1,\n-\t\t\t          machine_mode mode2);\n-extern rtx optab_libfunc (optab optab, machine_mode mode);\n-extern enum insn_code widening_optab_handler (optab, machine_mode,\n-\t\t\t\t\t      machine_mode);\n-/* Find a widening optab even if it doesn't widen as much as we want.  */\n-#define find_widening_optab_handler(A,B,C,D) \\\n-  find_widening_optab_handler_and_mode (A, B, C, D, NULL)\n-extern enum insn_code find_widening_optab_handler_and_mode (optab,\n-\t\t\t\t\t\t\t    machine_mode,\n-\t\t\t\t\t\t\t    machine_mode,\n-\t\t\t\t\t\t\t    int,\n-\t\t\t\t\t\t\t    machine_mode *);\n-\n-/* An extra flag to control optab_for_tree_code's behavior.  This is needed to\n-   distinguish between machines with a vector shift that takes a scalar for the\n-   shift amount vs. machines that take a vector for the shift amount.  */\n-enum optab_subtype\n-{\n-  optab_default,\n-  optab_scalar,\n-  optab_vector\n-};\n-\n /* Passed to expand_simple_binop and expand_binop to say which options\n    to try to use if the requested operation can't be open-coded on the\n    requisite mode.  Either OPTAB_LIB or OPTAB_LIB_WIDEN says try using\n@@ -267,16 +168,6 @@ enum optab_methods\n   OPTAB_MUST_WIDEN\n };\n \n-/* Return the optab used for computing the given operation on the type given by\n-   the second argument.  The third argument distinguishes between the types of\n-   vector shifts and rotates */\n-extern optab optab_for_tree_code (enum tree_code, const_tree, enum optab_subtype);\n-\n-/* Given an optab that reduces a vector to a scalar, find instead the old\n-   optab that produces a vector with the reduction result in one element,\n-   for a tree with the specified type.  */\n-extern optab scalar_reduc_to_vector (optab, const_tree type);\n-\n extern rtx expand_widen_pattern_expr (struct separate_ops *, rtx , rtx , rtx,\n                                       rtx, int);\n extern rtx expand_ternary_op (machine_mode mode, optab ternary_optab,\n@@ -368,9 +259,6 @@ extern void emit_indirect_jump (rtx);\n rtx emit_conditional_move (rtx, enum rtx_code, rtx, rtx, machine_mode,\n \t\t\t   rtx, rtx, machine_mode, int);\n \n-/* Return nonzero if the conditional move is supported.  */\n-int can_conditionally_move_p (machine_mode mode);\n-\n rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, machine_mode,\n \t\t\t  rtx, rtx, machine_mode, int);\n \n@@ -386,22 +274,10 @@ extern rtx_insn *gen_sub2_insn (rtx, rtx);\n extern rtx_insn *gen_sub3_insn (rtx, rtx, rtx);\n extern int have_sub2_insn (rtx, rtx);\n \n-/* Return the INSN_CODE to use for an extend operation.  */\n-extern enum insn_code can_extend_p (machine_mode, machine_mode, int);\n-\n /* Generate the body of an insn to extend Y (with mode MFROM)\n    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n extern rtx_insn *gen_extend_insn (rtx, rtx, machine_mode, machine_mode, int);\n \n-/* Return the insn_code for a FLOAT_EXPR.  */\n-enum insn_code can_float_p (machine_mode, machine_mode, int);\n-\n-/* Check whether an operation represented by the code CODE is a\n-   convert operation that is supported by the target platform in\n-   vector form */\n-bool supportable_convert_operation (enum tree_code, tree, tree, tree *, \n-                                    enum tree_code *);\n-\n /* Generate code for a FLOAT_EXPR.  */\n extern void expand_float (rtx, rtx, int);\n \n@@ -418,104 +294,18 @@ extern bool expand_sfix_optab (rtx, rtx, convert_optab);\n    perform the operation described by CODE and MODE.  */\n extern int have_insn_for (enum rtx_code, machine_mode);\n \n-extern void gen_int_libfunc (optab, const char *, char, machine_mode);\n-extern void gen_fp_libfunc (optab, const char *, char, machine_mode);\n-extern void gen_fixed_libfunc (optab, const char *, char, machine_mode);\n-extern void gen_signed_fixed_libfunc (optab, const char *, char,\n-\t\t\t\t      machine_mode);\n-extern void gen_unsigned_fixed_libfunc (optab, const char *, char,\n-\t\t\t\t\tmachine_mode);\n-extern void gen_int_fp_libfunc (optab, const char *, char, machine_mode);\n-extern void gen_intv_fp_libfunc (optab, const char *, char, machine_mode);\n-extern void gen_int_fp_fixed_libfunc (optab, const char *, char,\n-\t\t\t\t      machine_mode);\n-extern void gen_int_fp_signed_fixed_libfunc (optab, const char *, char,\n-\t\t\t\t\t     machine_mode);\n-extern void gen_int_fixed_libfunc (optab, const char *, char,\n-\t\t\t\t   machine_mode);\n-extern void gen_int_signed_fixed_libfunc (optab, const char *, char,\n-\t\t\t\t\t  machine_mode);\n-extern void gen_int_unsigned_fixed_libfunc (optab, const char *, char,\n-\t\t\t\t\t    machine_mode);\n-\n-extern void gen_interclass_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t\t machine_mode, machine_mode);\n-extern void gen_int_to_fp_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t\tmachine_mode, machine_mode);\n-extern void gen_ufloat_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t     machine_mode, machine_mode);\n-extern void gen_int_to_fp_nondecimal_conv_libfunc  (convert_optab,\n-\t\t\t\t\t\t    const char *,\n-\t\t\t\t\t\t    machine_mode,\n-\t\t\t\t\t\t    machine_mode);\n-extern void gen_fp_to_int_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t\tmachine_mode, machine_mode);\n-extern void gen_intraclass_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t\t machine_mode, machine_mode);\n-extern void gen_trunc_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t    machine_mode, machine_mode);\n-extern void gen_extend_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t     machine_mode, machine_mode);\n-extern void gen_fract_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t    machine_mode, machine_mode);\n-extern void gen_fractuns_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t       machine_mode, machine_mode);\n-extern void gen_satfract_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t       machine_mode, machine_mode);\n-extern void gen_satfractuns_conv_libfunc (convert_optab, const char *,\n-\t\t\t\t\t  machine_mode,\n-\t\t\t\t\t  machine_mode);\n-\n-/* Build a decl for a libfunc named NAME. */\n-extern tree build_libfunc_function (const char *);\n-\n-/* Call this to initialize an optab function entry.  */\n-extern rtx init_one_libfunc (const char *);\n-extern rtx set_user_assembler_libfunc (const char *, const char *);\n-\n-/* Call this to reset the function entry for one optab.  */\n-extern void set_optab_libfunc (optab, machine_mode, const char *);\n-extern void set_conv_libfunc (convert_optab, machine_mode,\n-\t\t\t      machine_mode, const char *);\n-\n-/* Call this once to initialize the contents of the optabs\n-   appropriately for the current target machine.  */\n-extern void init_optabs (void);\n-extern void init_tree_optimization_optabs (tree);\n-\n-/* Call this to install all of the __sync libcalls up to size MAX.  */\n-extern void init_sync_libfuncs (int max);\n-\n /* Generate a conditional trap instruction.  */\n extern rtx_insn *gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n \n-/* Return true if target supports vector operations for VEC_PERM_EXPR.  */\n-extern bool can_vec_perm_p (machine_mode, bool, const unsigned char *);\n-\n /* Generate code for VEC_PERM_EXPR.  */\n extern rtx expand_vec_perm (machine_mode, rtx, rtx, rtx, rtx);\n \n-/* Return tree if target supports vector operations for COND_EXPR.  */\n-bool expand_vec_cond_expr_p (tree, tree);\n-\n /* Generate code for VEC_COND_EXPR.  */\n extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n \n-/* Return non-zero if target supports a given highpart multiplication.  */\n-extern int can_mult_highpart_p (machine_mode, bool);\n-\n /* Generate code for MULT_HIGHPART_EXPR.  */\n extern rtx expand_mult_highpart (machine_mode, rtx, rtx, rtx, bool);\n \n-/* Return true if target supports vector masked load/store for mode.  */\n-extern bool can_vec_mask_load_store_p (machine_mode, bool);\n-\n-/* Return true if there is an inline compare and swap pattern.  */\n-extern bool can_compare_and_swap_p (machine_mode, bool);\n-\n-/* Return true if there is an inline atomic exchange pattern.  */\n-extern bool can_atomic_exchange_p (machine_mode, bool);\n-\n extern rtx expand_sync_lock_test_and_set (rtx, rtx, rtx);\n extern rtx expand_atomic_test_and_set (rtx, rtx, enum memmodel);\n extern rtx expand_atomic_exchange (rtx, rtx, rtx, enum memmodel);\n@@ -549,20 +339,6 @@ extern void expand_insn (enum insn_code icode, unsigned int nops,\n extern void expand_jump_insn (enum insn_code icode, unsigned int nops,\n \t\t\t      struct expand_operand *ops);\n \n-/* Enumerates the possible extraction_insn operations.  */\n-enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n-\n-extern bool get_best_reg_extraction_insn (extraction_insn *,\n-\t\t\t\t\t  enum extraction_pattern,\n-\t\t\t\t\t  unsigned HOST_WIDE_INT,\n-\t\t\t\t\t  machine_mode);\n-extern bool get_best_mem_extraction_insn (extraction_insn *,\n-\t\t\t\t\t  enum extraction_pattern,\n-\t\t\t\t\t  HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t  machine_mode);\n-\n-extern bool lshift_cheap_p (bool);\n-\n extern enum rtx_code get_rtx_code (enum tree_code tcode, bool unsignedp);\n \n #endif /* GCC_OPTABS_H */"}, {"sha": "54b8517d3696c512d8acdd7ed460e045c0710092", "filename": "gcc/target-globals.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stmt.h\"\n #include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-query.h\"\n #include \"libfuncs.h\"\n #include \"cfgloop.h\"\n #include \"ira.h\""}, {"sha": "6d740d4233373479817fc0e21a38547215f5d56d", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -87,7 +87,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"gcse.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-query.h\"\n+#include \"optabs-libfuncs.h\"\n #include \"tree-chkp.h\"\n #include \"omp-low.h\"\n "}, {"sha": "0987884e4cc3f71cbc1f3cb83ec7b9feba73c8d5", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -120,7 +120,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stmt.h\"\n #include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-query.h\"\n #include \"tree-hash-traits.h\"\n \n /* List of basic blocks in if-conversion-suitable order.  */"}, {"sha": "5978c59a738685cee193e7785961a30bfde41d8a", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -54,7 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"cfgloop.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-query.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"tree-ssa-dom.h\"\n #include \"builtins.h\""}, {"sha": "0260b260060d1df518327069bf368c01d1d7a49f", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -65,7 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stmt.h\"\n #include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-query.h\"\n #include \"recog.h\"\n \n /* This pass inserts prefetch instructions to optimize cache usage during"}, {"sha": "b90e9291ba0896ae6cd762f0613619d9b4a04c1b", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -103,15 +103,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify-me.h\"\n #include \"stor-layout.h\"\n #include \"tree-cfg.h\"\n-#include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n #include \"tree-pass.h\"\n@@ -120,11 +111,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"builtins.h\"\n #include \"params.h\"\n-\n-/* FIXME: RTL headers have to be included here for optabs.  */\n-#include \"expr.h\"\t\t/* Because optabs.h wants sepops.  */\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n \n /* This structure represents one basic block that either computes a\n    division, or is a common dominator for basic block that compute a"}, {"sha": "0c0a39305b6ec8c3bb44f3f8cac6e11c2de30512", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -38,14 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify-me.h\"\n #include \"tree-cfg.h\"\n #include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"tree-dfa.h\"\n #include \"tree-pass.h\"\n #include \"langhooks.h\"\n@@ -54,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-data-ref.h\"\n #include \"gimple-pretty-print.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-inline.h\"\n #include \"params.h\""}, {"sha": "4aa2aabadc0d1a0193ddb44e5ceaa9fb43929cd9", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -43,15 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop-niter.h\"\n #include \"tree-ssa-loop.h\"\n #include \"flags.h\"\n-#include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n #include \"tree-iterator.h\"\n@@ -65,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"gimplify.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n \n /*  This is a simple global reassociation pass.  It is, in part, based\n     on the LLVM pass of the same name (They do some things more/less"}, {"sha": "4208140d73f037f0a4ca8cb7da99123a3226a9c9", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -52,17 +52,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    type in the GIMPLE type system that is language-independent?  */\n #include \"langhooks.h\"\n \n-/* Need to include expr.h and optabs.h for lshift_cheap_p.  */\n-#include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n \f\n /* Maximum number of case bit tests.\n    FIXME: This should be derived from PARAM_CASE_VALUES_THRESHOLD and"}, {"sha": "671e613a434e7dc4de0082ff488b769b510f676c", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -49,19 +49,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"diagnostic-core.h\"\n #include \"cgraph.h\"\n-/* Need to include rtl.h, expr.h, etc. for optabs.  */\n-#include \"flags.h\"\n-#include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n #include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"builtins.h\"\n #include \"params.h\"\n "}, {"sha": "68a7b7479f38b60b7193be3b9db9e78c277405b5", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -40,19 +40,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"target.h\"\n-\n-/* Need to include rtl.h, expr.h, etc. for optabs.  */\n-#include \"insn-config.h\"\n #include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n \n \n static void expand_vector_operations_1 (gimple_stmt_iterator *);"}, {"sha": "c09531787a785b39a9d2d098195eb89a71824c02", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -44,18 +44,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"cfgloop.h\"\n #include \"flags.h\"\n-#include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n-#include \"recog.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"params.h\"\n #include \"diagnostic-core.h\"\n #include \"tree-chrec.h\""}, {"sha": "b0aae4fd41d18382b6e89a306405473a62540a9f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -40,15 +40,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"params.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-vectorizer.h\""}, {"sha": "1dd816783f2a8f402b50cc9236fffc4a6617a29e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -40,17 +40,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"flags.h\"\n #include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"recog.h\"\t\t/* FIXME: for insn_data */\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"tree-vectorizer.h\"\n #include \"langhooks.h\"\n #include \"gimple-walk.h\""}, {"sha": "d4a436d38b0cd33994a0183babb812cae4bb96e1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -45,17 +45,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"flags.h\"\n #include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"recog.h\"\t\t/* FIXME: for insn_data */\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"diagnostic-core.h\"\n #include \"tree-vectorizer.h\"\n #include \"cgraph.h\""}, {"sha": "5e813906ac7dc5cae8a0d77eb16de585aa38016c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385399a8759c233f487ddd7e158802a1ee4f960d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=385399a8759c233f487ddd7e158802a1ee4f960d", "patch": "@@ -54,16 +54,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"tree-chrec.h\"\n #include \"tree-ssa-threadupdate.h\"\n-#include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n #include \"insn-codes.h\"\n-#include \"optabs.h\"\n+#include \"optabs-tree.h\"\n #include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n "}]}