{"sha": "8376a32eb13b751abe718b098877a58d4c6c76ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM3NmEzMmViMTNiNzUxYWJlNzE4YjA5ODg3N2E1OGQ0YzZjNzZlZg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:52Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:52Z"}, "message": "\ufffd\nMerge from Cygnus internal source tree.\n\nFrom-SVN: r23024", "tree": {"sha": "8066b09879ba6438fa1b2224673353959ba6ee29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8066b09879ba6438fa1b2224673353959ba6ee29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8376a32eb13b751abe718b098877a58d4c6c76ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8376a32eb13b751abe718b098877a58d4c6c76ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8376a32eb13b751abe718b098877a58d4c6c76ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8376a32eb13b751abe718b098877a58d4c6c76ef/comments", "author": null, "committer": null, "parents": [{"sha": "b67d701b4ff899f1e677f00fa9b579fee7be5557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67d701b4ff899f1e677f00fa9b579fee7be5557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67d701b4ff899f1e677f00fa9b579fee7be5557"}], "stats": {"total": 261, "additions": 162, "deletions": 99}, "files": [{"sha": "2ded69cf00287b4e305adf34ebc98739af5d3c6c", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=8376a32eb13b751abe718b098877a58d4c6c76ef", "patch": "@@ -1,12 +1,57 @@\n /* Shift right, logical. */\n \n-DEFTREECODE (URSHIFT_EXPR, \"urshift_expr\", \"2\", 2)\n+DEFTREECODE (URSHIFT_EXPR, \"urshift_expr\", '2', 2)\n \n /* Return -1, 0, 1 depending on whether the first argument is\n    less, equal, or greater to the second argument. */\n-DEFTREECODE (COMPARE_EXPR, \"compare_expr\", \"2\", 2)\n+DEFTREECODE (COMPARE_EXPR, \"compare_expr\", '2', 2)\n \n /* Same as COMPARE_EXPR, but if either value is NaN, the result is -1. */\n-DEFTREECODE (COMPARE_L_EXPR, \"compare_l_expr\", \"2\", 2)\n+DEFTREECODE (COMPARE_L_EXPR, \"compare_l_expr\", '2', 2)\n /* Same as COMPARE_EXPR, but if either value is NaN, the result is 1. */\n-DEFTREECODE (COMPARE_G_EXPR, \"compare_g_expr\", \"2\", 2)\n+DEFTREECODE (COMPARE_G_EXPR, \"compare_g_expr\", '2', 2)\n+\n+/* Unary plus. Operand 0 is the expression the unary plus is applied\n+   to */\n+DEFTREECODE (UNARY_PLUS_EXPR, \"unary_plus_expr\", '1', 1)\n+\n+/* New array creation expression.\n+   Operand 0 is the array base type.\n+   Operand 1 is the list of dimension expressions. \n+   Operand 2 is the number of other dimensions of unspecified range.\n+   Once patched, the node will bear the type of the created array.  */\n+DEFTREECODE (NEW_ARRAY_EXPR, \"new_array_expr\", 'e', 3)\n+\n+/* New class creation expression.\n+   Operand 0 is the name of the class to be created\n+   Operand 1 is the argument list used to select a constructor.\n+   There is no operand 2.  That slot is used for the\n+   CALL_EXPR_RTL macro (see preexpand_calls).\n+   The type should be the one of the created class.  */\n+DEFTREECODE (NEW_CLASS_EXPR, \"new_class_expr\", 'e', 3)\n+\n+/* Defines `this' as an expression.  */\n+DEFTREECODE (THIS_EXPR, \"this\", '1', 0)\n+\n+/* Case statement expression.\n+   Operand 1 is the case value.  */\n+DEFTREECODE (CASE_EXPR, \"case\", '1', 1)\n+\n+/* Default statement expression. */\n+DEFTREECODE (DEFAULT_EXPR, \"default\", '1', 0)\n+\n+/* Try expression\n+   Operand 0 is the tried block,\n+   Operand 1 contains chained catch nodes\n+   Operand 2 contains the finally clause.  */\n+DEFTREECODE (TRY_EXPR, \"try-catch-finally\", 'e', 3)\n+\n+/* Catch clause.\n+   Operand 0 is the catch clause block, which contains the declaration of\n+   the catch clause parameter.  */\n+DEFTREECODE (CATCH_EXPR, \"catch\", '1', 1)\n+\n+/* Finally clause.\n+   Operand 0 is the finally label.\n+   Operand 1 is the finally block.  */\n+DEFTREECODE (FINALLY_EXPR, \"finally\", 'e', 2) \n\\ No newline at end of file"}, {"sha": "9e36b457bc38569c433add0ff70894052cbbad20", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=8376a32eb13b751abe718b098877a58d4c6c76ef", "patch": "@@ -239,6 +239,9 @@ DEFUN(utf8_equal_string, (jcf, index, value),\n     MAX_STACK, MAX_LOCALS, CODE_LENGTH); \\\n   disassemble_method (jcf, jcf->read_ptr, CODE_LENGTH); }\n \n+#define HANDLE_EXCEPTION_TABLE(ENTRIES, COUNT) \\\n+  print_exception_table (jcf, ENTRIES, COUNT)\n+\n #define HANDLE_EXCEPTIONS_ATTRIBUTE(COUNT) \\\n { int n = (COUNT); int i; \\\n   COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length); \\\n@@ -286,7 +289,6 @@ DEFUN(utf8_equal_string, (jcf, index, value),\n     fprintf (out, \"\\nAttributes (count: %d):\\n\", attributes_count);\n \n #include \"javaop.h\"\n-#include \"jcf-reader.c\"\n \n static void\n DEFUN(print_constant_ref, (stream, jcf, index),\n@@ -336,7 +338,9 @@ void\n DEFUN(print_constant_terse, (out, jcf, index, expected),\n       FILE *out AND JCF *jcf AND int index AND int expected)\n {\n-  if (JPOOL_TAG (jcf, index) != expected)\n+  if (! CPOOL_INDEX_IN_RANGE (&jcf->cpool, index))\n+    fprintf (out, \"<constant pool index %d not in range>\", index);\n+  else if (JPOOL_TAG (jcf, index) != expected)\n     {\n       fprintf (out, \"<Unexpected constant type \");\n       print_constant (out, jcf, index, 1);\n@@ -610,6 +614,39 @@ DEFUN(print_signature, (stream, jcf, signature_index, int options),\n     }\n }\n \n+\n+static void\n+DEFUN(print_exception_table, (jcf, entries, count),\n+      JCF *jcf AND unsigned char *entries AND int count)\n+{\n+  /* Print exception table. */\n+  int i = count;\n+  if (i > 0)\n+    {\n+      unsigned char *ptr = entries;\n+      fprintf (out, \"Exceptions (count: %d):\\n\", i);\n+      for (; --i >= 0;  ptr+= 8)\n+\t{\n+\t  int start_pc = GET_u2 (ptr);\n+\t  int end_pc = GET_u2 (ptr+2);\n+\t  int handler_pc = GET_u2 (ptr+4);\n+\t  int catch_type = GET_u2 (ptr+6);\n+\t  fprintf (out, \"  start: %d, end: %d, handler: %d, type: %d\",\n+\t\t   start_pc, end_pc, handler_pc, catch_type);\n+\t  if (catch_type == 0)\n+\t    fputs (\" /* finally */\", out);\n+\t  else\n+\t    {\n+\t      fputc('=', out);\n+\t      print_constant_terse (out, jcf, catch_type, CONSTANT_Class);\n+\t    }\n+\t  fputc ('\\n', out);\n+\t}\n+    }\n+}\n+\n+#include \"jcf-reader.c\"\n+\n int\n DEFUN (usage, (), )\n {\n@@ -876,6 +913,7 @@ DEFUN(disassemble_method, (jcf, byte_ops, len),\n #undef PTR\n   int PC;\n   int i;\n+  int saw_wide = 0;\n   if (flag_disassemble_methods == 0)\n     return;\n #define BCODE byte_ops\n@@ -923,9 +961,7 @@ DEFUN(disassemble_method, (jcf, byte_ops, len),\n /* Print out operand (a local variable index) for LOAD opcodes.\n    These all push local variable onto the opcode stack. */\n #define LOAD(OPERAND_TYPE, OPERAND_VALUE) \\\n-  INT_temp = (OPERAND_VALUE); \\\n-  if (oldpc+1 == PC) /* nothing - local index implied by opcode */; \\\n-  else fprintf (out, \" %d\", INT_temp);\n+  INT_temp = saw_wide ? IMMEDIATE_u2 : (OPERAND_VALUE); goto load_store;\n \n /* Handle STORE opcodes same as LOAD opcodes.\n    These all store a value from the opcode stack in a local variable. */\n@@ -994,7 +1030,8 @@ DEFUN(disassemble_method, (jcf, byte_ops, len),\n   fprintf (out, \" %d\", saw_index ? INT_temp : oldpc + INT_temp)\n \n #define RET(OPERAND_TYPE, OPERAND_VALUE) \\\n-  INT_temp = (OPERAND_VALUE); \\\n+  INT_temp = saw_wide ? IMMEDIATE_u2 : (OPERAND_VALUE); \\\n+  saw_wide = 0; \\\n   fprintf (out, \" %d\", INT_temp);\n \n #define SWITCH(OPERAND_TYPE, TABLE_OR_LOOKUP) \\\n@@ -1022,11 +1059,14 @@ DEFUN(disassemble_method, (jcf, byte_ops, len),\n   SPECIAL_##OPERAND_VALUE(OPERAND_TYPE)\n \n #define SPECIAL_IINC(OPERAND_TYPE) \\\n-  INT_temp = IMMEDIATE_u1; \\\n-  fprintf (out, \"%d %d\", INT_temp, IMMEDIATE_s1)\n+  INT_temp = saw_wide ? IMMEDIATE_u2 : IMMEDIATE_u1; \\\n+  fprintf (out, \" %d\", INT_temp); \\\n+  INT_temp = saw_wide ? IMMEDIATE_s2 : IMMEDIATE_s1; \\\n+  saw_wide = 0; \\\n+  fprintf (out, \" %d\", INT_temp)\n \n #define SPECIAL_WIDE(OPERAND_TYPE) \\\n-  INT_temp = IMMEDIATE_u1; fprintf (out, \"%d\", INT_temp)\n+  saw_wide = 1;\n \n #define SPECIAL_EXIT(OPERAND_TYPE) /* nothing */\n #define SPECIAL_ENTER(OPERAND_TYPE) /* nothing */\n@@ -1040,33 +1080,19 @@ DEFUN(disassemble_method, (jcf, byte_ops, len),\n    TEST(OPERAND_TYPE, OPERAND_VALUE)\n \n #include \"javaop.def\"\n-\tdefault:\n-\t  fprintf (out, \"%3d: unknown(%3d)\\n\", oldpc, byte_ops[PC]);\n-\t}\n-    }\n \n-  /* Print exception table. */\n-  i = GET_u2(byte_ops+len);\n-  if (i > 0)\n-    {\n-      unsigned char *ptr = byte_ops+len+2;\n-      fprintf (out, \"Exceptions (count: %d):\\n\", i);\n-      for (; --i >= 0;  ptr+= 8)\n-\t{\n-\t  int start_pc = GET_u2 (ptr);\n-\t  int end_pc = GET_u2 (ptr+2);\n-\t  int handler_pc = GET_u2 (ptr+4);\n-\t  int catch_type = GET_u2 (ptr+6);\n-\t  fprintf (out, \"  start: %d, end: %d, handler: %d, type: %d\",\n-\t\t   start_pc, end_pc, handler_pc, catch_type);\n-\t  if (catch_type == 0)\n-\t    fputs (\" /* finally */\", out);\n+\tload_store:\n+\t  if (oldpc+1 == PC) /* nothing - local index implied by opcode */;\n \t  else\n \t    {\n-\t      fputc('=', out);\n-\t      print_constant_terse (out, jcf, catch_type, CONSTANT_Class);\n+\t      saw_wide = 0;\n+\t      fprintf (out, \" %d\", INT_temp);\n \t    }\n \t  fputc ('\\n', out);\n+\t  break;\n+\n+\tdefault:\n+\t  fprintf (out, \"%3d: unknown(%3d)\\n\", oldpc, byte_ops[PC]);\n \t}\n     }\n }"}, {"sha": "9816ce329c8338ec6f14d4a6b878cf11079b4b03", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=8376a32eb13b751abe718b098877a58d4c6c76ef", "patch": "@@ -83,6 +83,9 @@ DEFUN(get_attribute, (jcf),\n       exception_table_length = JCF_readu2 (jcf);\n       if (code_length + 8 * exception_table_length + 12 > attribute_length)\n \treturn -1;\n+#ifdef HANDLE_EXCEPTION_TABLE\n+      HANDLE_EXCEPTION_TABLE (jcf->read_ptr, exception_table_length);\n+#endif\n       JCF_SKIP (jcf, 2 * 4 * exception_table_length);\n       attributes_count = JCF_readu2 (jcf);\n       for (j = 0; j < attributes_count; j++)"}, {"sha": "7b86b1356647aeb5b5288d10c026fe712b5c87c7", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=8376a32eb13b751abe718b098877a58d4c6c76ef", "patch": "@@ -60,15 +60,15 @@ char *main_class_name = NULL;\n int lang_specific_extra_outfiles = 0;\n \n char jvgenmain_spec[] =\n-  \"jvgenmain %i %{!pipe:%g.i} |\\n\\\n-   cc1 %{!pipe:%g.i} %1 \\\n+  \"jvgenmain %i %{!pipe:%u.i} |\\n\\\n+   cc1 %{!pipe:%U.i} %1 \\\n \t\t   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*} %{a*}\\\n \t\t   %{g*} %{O*} \\\n \t\t   %{v:-version} %{pg:-p} %{p} %{f*}\\\n \t\t   %{aux-info*}\\\n \t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n-\t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n-              %{!S:as %a %Y -o %w%b%O %{!pipe:%g.s} %A\\n }\";\n+\t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%U.s}} |\\n\\\n+              %{!S:as %a %Y -o %d%w%u%O %{!pipe:%U.s} %A\\n }\";\n \n void\n lang_specific_driver (fn, in_argc, in_argv, in_added_libraries)\n@@ -141,6 +141,9 @@ lang_specific_driver (fn, in_argc, in_argv, in_added_libraries)\n   /* The total number of arguments with the new stuff.  */\n   int num_args = 1;\n \n+  /* Non-zero if linking is supposed to happen.  */\n+  int will_link = 1;\n+\n   argc = *in_argc;\n   argv = *in_argv;\n   added_libraries = *in_added_libraries;\n@@ -210,14 +213,18 @@ lang_specific_driver (fn, in_argc, in_argv, in_added_libraries)\n \t\t     && (char *)strchr (\"bBVDUoeTuIYmLiA\", argv[i][1]) != NULL)\n \t\t    || strcmp (argv[i], \"-Tdata\") == 0))\n \t    quote = argv[i];\n-\t  else if (library != 0 && ((argv[i][2] == '\\0'\n-\t\t     && (char *) strchr (\"cSEM\", argv[i][1]) != NULL)\n-\t\t    || strcmp (argv[i], \"-MM\") == 0))\n+\t  else if (library != 0 \n+\t\t   && ((argv[i][2] == '\\0'\n+\t\t\t&& (char *) strchr (\"cSEM\", argv[i][1]) != NULL)\n+\t\t       || strcmp (argv[i], \"-MM\") == 0))\n \t    {\n \t      /* Don't specify libraries if we won't link, since that would\n \t\t cause a warning.  */\n \t      library = 0;\n \t      added -= 2;\n+\n+\t      /* Remember this so we can confirm -fmain option.  */\n+\t      will_link = 0;\n \t    }\n \t  else\n \t    /* Pass other options through.  */\n@@ -270,6 +277,8 @@ lang_specific_driver (fn, in_argc, in_argv, in_added_libraries)\n \n       if (strncmp (argv[i], \"-fmain=\", 7) == 0)\n \t{\n+\t  if (! will_link)\n+\t    (*fn) (\"cannot specify `main' class when not linking\");\n \t  --j;\n \t  continue;\n \t}"}, {"sha": "c08510577dd8f72641010284b0a28cc6e17f5d46", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=8376a32eb13b751abe718b098877a58d4c6c76ef", "patch": "@@ -25,6 +25,9 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n /* This is the contribution to the `lang_options' array in gcc.c for\n    java.  */\n \n+/* CYGNUS LOCAL - the format of this file has been changed to\n+   allow cc1 to implement --help.  nickc/--help */\n+\n DEFINE_LANG_NAME (\"Java\")\n      \n   { \"-fbounds-check\", \"\" },"}, {"sha": "a54688b7f4428c50e11e4a2a85c0ed97866d2630", "filename": "gcc/java/lex.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=8376a32eb13b751abe718b098877a58d4c6c76ef", "patch": "@@ -51,6 +51,10 @@ Addison Wesley 1996\" (http://java.sun.com/docs/books/jls/html/3.doc.html)  */\n #include <unistd.h>\n #endif\n \n+#ifndef JC1_LITE\n+extern struct obstack *expression_obstack;\n+#endif\n+\n void\n java_init_lex ()\n {\n@@ -71,6 +75,13 @@ java_init_lex ()\n     wfl_operator = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);\n   if (!label_id)\n     label_id = get_identifier (\"$L\");\n+  if (!wfl_append) \n+    wfl_append = build_expr_wfl (get_identifier (\"append\"), NULL, 0, 0);\n+  if (!wfl_string_buffer)\n+    wfl_string_buffer = \n+      build_expr_wfl (get_identifier (\"java.lang.StringBuffer\"), NULL, 0, 0);\n+  if (!wfl_to_string)\n+    wfl_to_string = build_expr_wfl (get_identifier (\"toString\"), NULL, 0, 0);\n \n   ctxp->static_initialized = ctxp->non_static_initialized = \n     ctxp->incomplete_class = NULL_TREE;\n@@ -885,27 +896,20 @@ java_lex (java_lval)\n \n       obstack_1grow (&temporary_obstack, '\\0');\n       string = obstack_finish (&temporary_obstack);\n-      if (!no_error || (c != '\"'))\n-\t*string = '\\0';\t\t/* Silently turns the string to an empty one */\n-      \n-      JAVA_LEX_STR_LIT (string)\n-      \n #ifndef JC1_LITE\n-      if (*string)\n+      if (!no_error || (c != '\"'))\n+\tjava_lval->node = error_mark_node; /* Requires futher testing FIXME */\n+      else\n \t{\n-\t  extern struct obstack *expression_obstack;\n \t  tree s = make_node (STRING_CST);\n \t  TREE_STRING_LENGTH (s) = strlen (string);\n \t  TREE_STRING_POINTER (s) = \n-\t    obstack_alloc (expression_obstack, strlen (string));\n+\t    obstack_alloc (expression_obstack, TREE_STRING_LENGTH (s)+1);\n \t  strcpy (TREE_STRING_POINTER (s), string);\n \t  java_lval->node = s;\n \t}\n-      else\n-\tjava_lval->node = error_mark_node;\n #endif\n       return STRING_LIT_TK;\n-      \n     }\n \n   /* Separator */\n@@ -1194,12 +1198,17 @@ java_lex (java_lval)\n \t      SET_LVAL_NODE (null_pointer_node);\n \t      return NULL_TK;\n \n-\t      /* We build an operator for SUPER, so we can keep its position */\n+\t      /* Some keyword we want to retain information on the location\n+\t\t they where found */\n+\t    case CASE_TK:\n+\t    case DEFAULT_TK:\n \t    case SUPER_TK:\n \t    case THIS_TK:\n \t    case RETURN_TK:\n \t    case BREAK_TK:\n \t    case CONTINUE_TK:\n+\t    case TRY_TK:\n+\t    case CATCH_TK:\n \t      BUILD_OPERATOR (kw->token);\n \n \t    default:"}, {"sha": "08acf126497fbcb0cefa0fed6aa0d58d283a6e66", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 13, "deletions": 45, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8376a32eb13b751abe718b098877a58d4c6c76ef/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=8376a32eb13b751abe718b098877a58d4c6c76ef", "patch": "@@ -135,14 +135,6 @@ type_for_mode (mode, unsignedp)\n   if (mode == TYPE_MODE (double_type_node))\n     return double_type_node;\n \n-#if 0\n-  if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n-    return build_pointer_type (char_type_node);\n-\n-  if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n-    return build_pointer_type (integer_type_node);\n-#endif\n-\n   return 0;\n }\n \n@@ -331,9 +323,9 @@ build_java_array_type (element_type, length)\n \t\t     buf, 0, 0, \"\");\n   t = IDENTIFIER_SIGNATURE_TYPE (sig);\n   if (t != NULL_TREE)\n-    return t;\n+    return TREE_TYPE (t);\n   t = make_class ();\n-  IDENTIFIER_SIGNATURE_TYPE (sig) = t;\n+  IDENTIFIER_SIGNATURE_TYPE (sig) = build_pointer_type (t);\n   TYPE_ARRAY_P (t) = 1;\n \n   if (TREE_CODE (el_name) == POINTER_TYPE)\n@@ -345,6 +337,8 @@ build_java_array_type (element_type, length)\n \n   set_java_signature (t, sig);\n   set_super_info (0, t, object_type_node, 0);\n+  if (TREE_CODE (element_type) == RECORD_TYPE)\n+    element_type = promote_type (element_type);\n   TYPE_ARRAY_ELEMENT (t) = element_type;\n \n   /* Add length pseudo-field. */\n@@ -411,6 +405,7 @@ static tree\n parse_signature_type (ptr, limit)\n      const unsigned char **ptr, *limit;\n {\n+  tree type;\n   if ((*ptr) >= limit)\n     fatal (\"bad signature string\");\n   switch (*(*ptr))\n@@ -426,12 +421,9 @@ parse_signature_type (ptr, limit)\n     case 'V':  (*ptr)++;  return void_type_node;\n     case '[':\n       for ((*ptr)++; (*ptr) < limit && isdigit (**ptr); ) (*ptr)++;\n-      {\n-\ttree element_type = parse_signature_type (ptr, limit);\n-\tif (TREE_CODE (element_type) == RECORD_TYPE)\n-\t  element_type = promote_type (element_type);\n-\treturn build_java_array_type (element_type, -1);\n-      }\n+      type = parse_signature_type (ptr, limit);\n+      type = build_java_array_type (type, -1); \n+      break;\n     case 'L':\n       {\n \tconst unsigned char *start = ++(*ptr);\n@@ -444,11 +436,13 @@ parse_signature_type (ptr, limit)\n \t      break;\n \t  }\n \t*ptr = str+1;\n-\treturn lookup_class (unmangle_classname (start, str - start));\n+\ttype = lookup_class (unmangle_classname (start, str - start));\n+\tbreak;\n       }\n     default:\n       fatal (\"unrecognized signature string\");\n     }\n+  return promote_type (type);\n }\n \n /* Parse a Java \"mangled\" signature string, starting at SIG_STRING,\n@@ -471,12 +465,12 @@ parse_signature_string (sig_string, sig_length)\n       str++;\n       while (str < limit && str[0] != ')')\n \t{\n-\t  tree argtype = promote_type (parse_signature_type (&str, limit));\n+\t  tree argtype = parse_signature_type (&str, limit);\n \t  argtype_list = tree_cons (NULL_TREE, argtype, argtype_list);\n \t}\n       if (str++, str >= limit)\n \tfatal (\"bad signature string\");\n-      result_type = promote_type (parse_signature_type (&str, limit));\n+      result_type = parse_signature_type (&str, limit);\n       result_type = build_function_type (result_type,\n \t\t\t\t\t nreverse (argtype_list));\n     }\n@@ -700,32 +694,6 @@ lookup_java_method (clas, method_name, method_signature)\n   return NULL_TREE;\n }\n \n-/* Search in class CLAS (and its superclasses) for methods matching\n-   METHOD_NAME and METHOD_SIGNATURE. Return a list of FUNCTION_DECLs.\n-   When called from here, build_java_signature doesn't take the\n-   returned type into account. */\n-\n-tree\n-match_java_method (clas, method_name, method_signature)\n-     tree clas, method_name, method_signature;\n-{\n-  tree method;\n-  tree list = NULL_TREE;\n-  while (clas != NULL_TREE)\n-    {\n-      for (method = TYPE_METHODS (clas);\n-\t   method != NULL_TREE;  method = TREE_CHAIN (method))\n-\t{\n-\t  tree method_sig = build_java_argument_signature (TREE_TYPE (method));\n-\t  if (DECL_NAME (method) == method_name \n-\t      && method_sig == method_signature)\n-\t    list = tree_cons (NULL_TREE, method, list);\n-\t}\n-      clas = CLASSTYPE_SUPER (clas);\n-    }\n-  return list;\n-}\n-\n /* Search in class CLAS for a constructor matching METHOD_SIGNATURE.\n    Return a FUNCTION_DECL on success, or NULL_TREE if none found. */\n "}]}