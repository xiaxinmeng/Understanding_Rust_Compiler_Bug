{"sha": "673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjczYmY1YTZiNjVlNTFkMTc3ZDJjZjlmYzQwMDIxNzFiMWY0NjdhYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:16Z"}, "message": "[23/77] Replace != VOIDmode checks with is_a <scalar_int_mode>\n\nThis patch replaces some checks against VOIDmode with checks\nof is_a <scalar_int_mode>, in cases where scalar integer modes\nwere the only useful alternatives left.\n\ngcc/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* cfgexpand.c (expand_debug_expr): Use is_a <scalar_int_mode>\n\tinstead of != VOIDmode.\n\t* combine.c (if_then_else_cond): Likewise.\n\t(change_zero_ext): Likewise.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t(loc_descriptor): Likewise.\n\t* rtlanal.c (canonicalize_condition): Likewise.\n\t* simplify-rtx.c (simplify_relational_operation_1): Likewise.\n\nFrom-SVN: r251475", "tree": {"sha": "6c897f8eed13c0d78998341ce2a350c204fa4667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c897f8eed13c0d78998341ce2a350c204fa4667"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/comments", "author": null, "committer": null, "parents": [{"sha": "45e8e706e295e7770d02c6d9c9798f4bab7ab524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e8e706e295e7770d02c6d9c9798f4bab7ab524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e8e706e295e7770d02c6d9c9798f4bab7ab524"}], "stats": {"total": 86, "additions": 42, "deletions": 44}, "files": [{"sha": "ad6f05606ab2777ff8332039eea36e8e8a7649cf", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "patch": "@@ -4139,7 +4139,7 @@ expand_debug_expr (tree exp)\n   machine_mode inner_mode = VOIDmode;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n   addr_space_t as;\n-  scalar_int_mode op1_mode;\n+  scalar_int_mode op0_mode, op1_mode;\n \n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n@@ -4581,23 +4581,23 @@ expand_debug_expr (tree exp)\n \t size_t, we need to check for mis-matched modes and correct\n \t the addend.  */\n       if (op0 && op1\n-\t  && GET_MODE (op0) != VOIDmode && GET_MODE (op1) != VOIDmode\n-\t  && GET_MODE (op0) != GET_MODE (op1))\n+\t  && is_a <scalar_int_mode> (GET_MODE (op0), &op0_mode)\n+\t  && is_a <scalar_int_mode> (GET_MODE (op1), &op1_mode)\n+\t  && op0_mode != op1_mode)\n \t{\n-\t  if (GET_MODE_BITSIZE (GET_MODE (op0)) < GET_MODE_BITSIZE (GET_MODE (op1))\n-\t      /* If OP0 is a partial mode, then we must truncate, even if it has\n-\t\t the same bitsize as OP1 as GCC's representation of partial modes\n-\t\t is opaque.  */\n-\t      || (GET_MODE_CLASS (GET_MODE (op0)) == MODE_PARTIAL_INT\n-\t\t  && GET_MODE_BITSIZE (GET_MODE (op0)) == GET_MODE_BITSIZE (GET_MODE (op1))))\n-\t    op1 = simplify_gen_unary (TRUNCATE, GET_MODE (op0), op1,\n-\t\t\t\t      GET_MODE (op1));\n+\t  if (GET_MODE_BITSIZE (op0_mode) < GET_MODE_BITSIZE (op1_mode)\n+\t      /* If OP0 is a partial mode, then we must truncate, even\n+\t\t if it has the same bitsize as OP1 as GCC's\n+\t\t representation of partial modes is opaque.  */\n+\t      || (GET_MODE_CLASS (op0_mode) == MODE_PARTIAL_INT\n+\t\t  && (GET_MODE_BITSIZE (op0_mode)\n+\t\t      == GET_MODE_BITSIZE (op1_mode))))\n+\t    op1 = simplify_gen_unary (TRUNCATE, op0_mode, op1, op1_mode);\n \t  else\n \t    /* We always sign-extend, regardless of the signedness of\n \t       the operand, because the operand is always unsigned\n \t       here even if the original C expression is signed.  */\n-\t    op1 = simplify_gen_unary (SIGN_EXTEND, GET_MODE (op0), op1,\n-\t\t\t\t      GET_MODE (op1));\n+\t    op1 = simplify_gen_unary (SIGN_EXTEND, op0_mode, op1, op1_mode);\n \t}\n       /* Fall through.  */\n     case PLUS_EXPR:"}, {"sha": "7239ae3e74cfddeccdbdf899b43d179899647d33", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "patch": "@@ -9019,6 +9019,7 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n   enum rtx_code code = GET_CODE (x);\n   rtx cond0, cond1, true0, true1, false0, false1;\n   unsigned HOST_WIDE_INT nz;\n+  scalar_int_mode int_mode;\n \n   /* If we are comparing a value against zero, we are done.  */\n   if ((code == NE || code == EQ)\n@@ -9215,8 +9216,9 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n   /* If X is known to be either 0 or -1, those are the true and\n      false values when testing X.  */\n   else if (x == constm1_rtx || x == const0_rtx\n-\t   || (mode != VOIDmode && mode != BLKmode\n-\t       && num_sign_bit_copies (x, mode) == GET_MODE_PRECISION (mode)))\n+\t   || (is_a <scalar_int_mode> (mode, &int_mode)\n+\t       && (num_sign_bit_copies (x, int_mode)\n+\t\t   == GET_MODE_PRECISION (int_mode))))\n     {\n       *ptrue = constm1_rtx, *pfalse = const0_rtx;\n       return x;\n@@ -11271,20 +11273,17 @@ change_zero_ext (rtx pat)\n   FOR_EACH_SUBRTX_PTR (iter, array, src, NONCONST)\n     {\n       rtx x = **iter;\n-      scalar_int_mode mode;\n+      scalar_int_mode mode, inner_mode;\n       if (!is_a <scalar_int_mode> (GET_MODE (x), &mode))\n \tcontinue;\n       int size;\n \n       if (GET_CODE (x) == ZERO_EXTRACT\n \t  && CONST_INT_P (XEXP (x, 1))\n \t  && CONST_INT_P (XEXP (x, 2))\n-\t  && GET_MODE (XEXP (x, 0)) != VOIDmode\n-\t  && GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)))\n-\t      <= GET_MODE_PRECISION (mode))\n+\t  && is_a <scalar_int_mode> (GET_MODE (XEXP (x, 0)), &inner_mode)\n+\t  && GET_MODE_PRECISION (inner_mode) <= GET_MODE_PRECISION (mode))\n \t{\n-\t  machine_mode inner_mode = GET_MODE (XEXP (x, 0));\n-\n \t  size = INTVAL (XEXP (x, 1));\n \n \t  int start = INTVAL (XEXP (x, 2));"}, {"sha": "7dd9f26be534a41f635de2401fe1f9e6fcfd444a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "patch": "@@ -14689,7 +14689,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n   if (mode != GET_MODE (rtl) && GET_MODE (rtl) != VOIDmode)\n     return NULL;\n \n-  scalar_int_mode int_mode, inner_mode;\n+  scalar_int_mode int_mode, inner_mode, op1_mode;\n   switch (GET_CODE (rtl))\n     {\n     case POST_INC:\n@@ -15127,9 +15127,8 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n       {\n \trtx rtlop1 = XEXP (rtl, 1);\n-\tif (GET_MODE (rtlop1) != VOIDmode\n-\t    && GET_MODE_BITSIZE (GET_MODE (rtlop1))\n-\t       < GET_MODE_BITSIZE (int_mode))\n+\tif (is_a <scalar_int_mode> (GET_MODE (rtlop1), &op1_mode)\n+\t    && GET_MODE_BITSIZE (op1_mode) < GET_MODE_BITSIZE (int_mode))\n \t  rtlop1 = gen_rtx_ZERO_EXTEND (int_mode, rtlop1);\n \top1 = mem_loc_descriptor (rtlop1, int_mode, mem_mode,\n \t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n@@ -15960,7 +15959,8 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \tbreak;\n       /* FALLTHROUGH */\n     case LABEL_REF:\n-      if (mode != VOIDmode && GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE\n+      if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && GET_MODE_SIZE (int_mode) == DWARF2_ADDR_SIZE\n \t  && (dwarf_version >= 4 || !dwarf_strict))\n \t{\n          loc_result = new_addr_loc_descr (rtl, dtprel_false);"}, {"sha": "08c43a9322ceccabb1a2b791464306fe56267fe0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "patch": "@@ -5559,40 +5559,39 @@ canonicalize_condition (rtx_insn *insn, rtx cond, int reverse,\n      if we can do computations in the relevant mode and we do not\n      overflow.  */\n \n-  if (GET_MODE_CLASS (GET_MODE (op0)) != MODE_CC\n-      && CONST_INT_P (op1)\n-      && GET_MODE (op0) != VOIDmode\n-      && GET_MODE_PRECISION (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n+  scalar_int_mode op0_mode;\n+  if (CONST_INT_P (op1)\n+      && is_a <scalar_int_mode> (GET_MODE (op0), &op0_mode)\n+      && GET_MODE_PRECISION (op0_mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n       HOST_WIDE_INT const_val = INTVAL (op1);\n       unsigned HOST_WIDE_INT uconst_val = const_val;\n       unsigned HOST_WIDE_INT max_val\n-\t= (unsigned HOST_WIDE_INT) GET_MODE_MASK (GET_MODE (op0));\n+\t= (unsigned HOST_WIDE_INT) GET_MODE_MASK (op0_mode);\n \n       switch (code)\n \t{\n \tcase LE:\n \t  if ((unsigned HOST_WIDE_INT) const_val != max_val >> 1)\n-\t    code = LT, op1 = gen_int_mode (const_val + 1, GET_MODE (op0));\n+\t    code = LT, op1 = gen_int_mode (const_val + 1, op0_mode);\n \t  break;\n \n \t/* When cross-compiling, const_val might be sign-extended from\n \t   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */\n \tcase GE:\n \t  if ((const_val & max_val)\n-\t      != (HOST_WIDE_INT_1U\n-\t\t  << (GET_MODE_PRECISION (GET_MODE (op0)) - 1)))\n-\t    code = GT, op1 = gen_int_mode (const_val - 1, GET_MODE (op0));\n+\t      != (HOST_WIDE_INT_1U << (GET_MODE_PRECISION (op0_mode) - 1)))\n+\t    code = GT, op1 = gen_int_mode (const_val - 1, op0_mode);\n \t  break;\n \n \tcase LEU:\n \t  if (uconst_val < max_val)\n-\t    code = LTU, op1 = gen_int_mode (uconst_val + 1, GET_MODE (op0));\n+\t    code = LTU, op1 = gen_int_mode (uconst_val + 1, op0_mode);\n \t  break;\n \n \tcase GEU:\n \t  if (uconst_val != 0)\n-\t    code = GTU, op1 = gen_int_mode (uconst_val - 1, GET_MODE (op0));\n+\t    code = GTU, op1 = gen_int_mode (uconst_val - 1, op0_mode);\n \t  break;\n \n \tdefault:"}, {"sha": "0c91dbb830c24234c2c296a1864aae372d232124", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673bf5a6b65e51d177d2cf9fc4002171b1f467ab/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "patch": "@@ -4829,19 +4829,19 @@ simplify_relational_operation_1 (enum rtx_code code, machine_mode mode,\n \n   /* (ne:SI (zero_extract:SI FOO (const_int 1) BAR) (const_int 0))) is\n      the same as (zero_extract:SI FOO (const_int 1) BAR).  */\n-  scalar_int_mode int_mode;\n+  scalar_int_mode int_mode, int_cmp_mode;\n   if (code == NE\n       && op1 == const0_rtx\n       && is_int_mode (mode, &int_mode)\n-      && cmp_mode != VOIDmode\n+      && is_a <scalar_int_mode> (cmp_mode, &int_cmp_mode)\n       /* ??? Work-around BImode bugs in the ia64 backend.  */\n       && int_mode != BImode\n-      && cmp_mode != BImode\n-      && nonzero_bits (op0, cmp_mode) == 1\n+      && int_cmp_mode != BImode\n+      && nonzero_bits (op0, int_cmp_mode) == 1\n       && STORE_FLAG_VALUE == 1)\n-    return GET_MODE_SIZE (int_mode) > GET_MODE_SIZE (cmp_mode)\n-\t   ? simplify_gen_unary (ZERO_EXTEND, int_mode, op0, cmp_mode)\n-\t   : lowpart_subreg (int_mode, op0, cmp_mode);\n+    return GET_MODE_SIZE (int_mode) > GET_MODE_SIZE (int_cmp_mode)\n+\t   ? simplify_gen_unary (ZERO_EXTEND, int_mode, op0, int_cmp_mode)\n+\t   : lowpart_subreg (int_mode, op0, int_cmp_mode);\n \n   /* (eq/ne (xor x y) 0) simplifies to (eq/ne x y).  */\n   if ((code == EQ || code == NE)"}]}