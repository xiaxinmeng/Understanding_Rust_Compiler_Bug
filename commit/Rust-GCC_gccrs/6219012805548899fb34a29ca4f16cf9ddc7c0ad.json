{"sha": "6219012805548899fb34a29ca4f16cf9ddc7c0ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIxOTAxMjgwNTU0ODg5OWZiMzRhMjljYTRmMTZjZjlkZGM3YzBhZA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "1999-12-10T12:08:51Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-10T12:08:51Z"}, "message": "sparc.c (fp_sethi_p, [...]): New functions.\n\n\t* config/sparc/sparc.c (fp_sethi_p, fp_mov_p, fp_high_losum_p):\n\tNew functions.\n\t* config/sparc/sparc-protos.h: Add them.\n\t* config/sparc/sparc.h: Add them to PREDICATE_CODES.\n\t(EXTRA_CONSTRAINT_BASE): New macro, handling Q, R, and S\n\tconstraints which use those helpers.\n\t(EXTRA_CONSTRAINT): Use this new macro.\n\t* md.texi: Update sparc target constraints documentation.\n\t* config/sparc/sparc.md (clear_sf, clear_sfp, movsf_const_intreg,\n\tmovsf_const_high, movsf_const_lo, movsf_insn): Delete.\n\t(movsf_insn_novis_liveg0, movsf_insn_novis_noliveg0,\n\tmovsf_insn_vis, movsf_lo_sum, movsf_high): New patterns.\n\t(movsf high/lo_sum split): Rework for new patterns.\n\t(movsf expander): Allow storing fp_zero to memory if ! live_g0.\n\nFrom-SVN: r30857", "tree": {"sha": "548f0ef07f06b8bc5f34425bda9329658c86a499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/548f0ef07f06b8bc5f34425bda9329658c86a499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6219012805548899fb34a29ca4f16cf9ddc7c0ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6219012805548899fb34a29ca4f16cf9ddc7c0ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6219012805548899fb34a29ca4f16cf9ddc7c0ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6219012805548899fb34a29ca4f16cf9ddc7c0ad/comments", "author": null, "committer": null, "parents": [{"sha": "acce0437338a6aece7ae98387c98f2a0e31da6a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acce0437338a6aece7ae98387c98f2a0e31da6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acce0437338a6aece7ae98387c98f2a0e31da6a4"}], "stats": {"total": 440, "additions": 326, "deletions": 114}, "files": [{"sha": "42204f484180a2a625b28fc8120d0bf7bcbb14c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6219012805548899fb34a29ca4f16cf9ddc7c0ad", "patch": "@@ -1,3 +1,20 @@\n+1999-12-10  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.c (fp_sethi_p, fp_mov_p, fp_high_losum_p):\n+\tNew functions.\n+\t* config/sparc/sparc-protos.h: Add them.\n+\t* config/sparc/sparc.h: Add them to PREDICATE_CODES.\n+\t(EXTRA_CONSTRAINT_BASE): New macro, handling Q, R, and S\n+\tconstraints which use those helpers.\n+\t(EXTRA_CONSTRAINT): Use this new macro.\n+\t* md.texi: Update sparc target constraints documentation.\n+\t* config/sparc/sparc.md (clear_sf, clear_sfp, movsf_const_intreg,\n+\tmovsf_const_high, movsf_const_lo, movsf_insn): Delete.\n+\t(movsf_insn_novis_liveg0, movsf_insn_novis_noliveg0,\n+\tmovsf_insn_vis, movsf_lo_sum, movsf_high): New patterns.\n+\t(movsf high/lo_sum split): Rework for new patterns.\n+\t(movsf expander): Allow storing fp_zero to memory if ! live_g0.\n+\n 1999-12-09  Gavin Romig-Koch  <gavin@cetus.cygnus.com>\n \n \t* c-common.c (c_common_nodes_and_builtins): "}, {"sha": "8c5b1b1a82bbb27a079e20dd93ecdd6c7f8a193d", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=6219012805548899fb34a29ca4f16cf9ddc7c0ad", "patch": "@@ -124,6 +124,9 @@ extern int emit_move_sequence PARAMS ((rtx, enum machine_mode));\n extern int extend_op PARAMS ((rtx, enum machine_mode));\n extern int fcc_reg_operand PARAMS ((rtx, enum machine_mode));\n extern int fp_zero_operand PARAMS ((rtx));\n+extern int fp_sethi_p PARAMS ((rtx));\n+extern int fp_mov_p PARAMS ((rtx));\n+extern int fp_high_losum_p PARAMS ((rtx));\n extern int icc_or_fcc_reg_operand PARAMS ((rtx, enum machine_mode));\n extern int label_ref_operand PARAMS ((rtx, enum machine_mode));\n extern int mem_min_alignment PARAMS ((rtx, int));"}, {"sha": "9c5380d574ad3164bf88f836f4cbe9d435e90366", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=6219012805548899fb34a29ca4f16cf9ddc7c0ad", "patch": "@@ -406,6 +406,85 @@ fp_zero_operand (op)\n   return (REAL_VALUES_EQUAL (r, dconst0) && ! REAL_VALUE_MINUS_ZERO (r));\n }\n \n+/* Nonzero if OP is a floating point constant which can\n+   be loaded into an integer register using a single\n+   sethi instruction.  */\n+\n+int\n+fp_sethi_p (op)\n+     rtx op;\n+{\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      if (REAL_VALUES_EQUAL (r, dconst0) &&\n+\t  ! REAL_VALUE_MINUS_ZERO (r))\n+\treturn 0;\n+      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+      if (SPARC_SETHI_P (i))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Nonzero if OP is a floating point constant which can\n+   be loaded into an integer register using a single\n+   mov instruction.  */\n+\n+int\n+fp_mov_p (op)\n+     rtx op;\n+{\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      if (REAL_VALUES_EQUAL (r, dconst0) &&\n+\t  ! REAL_VALUE_MINUS_ZERO (r))\n+\treturn 0;\n+      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+      if (SPARC_SIMM13_P (i))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Nonzero if OP is a floating point constant which can\n+   be loaded into an integer register using a high/losum\n+   instruction sequence.  */\n+\n+int\n+fp_high_losum_p (op)\n+     rtx op;\n+{\n+  /* The constraints calling this should only be in\n+     SFmode move insns, so any constant which cannot\n+     be moved using a single insn will do.  */\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      if (REAL_VALUES_EQUAL (r, dconst0) &&\n+\t  ! REAL_VALUE_MINUS_ZERO (r))\n+\treturn 0;\n+      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+      if (! SPARC_SETHI_P (i)\n+          && ! SPARC_SIMM13_P (i))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Nonzero if OP is an integer register.  */\n \n int\n@@ -1112,6 +1191,10 @@ input_operand (op, mode)\n   if (register_operand (op, mode))\n     return 1;\n \n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_CODE (op) == CONST_DOUBLE)\n+    return 1;\n+\n   /* If this is a SUBREG, look inside so that we handle\n      paradoxical ones.  */\n   if (GET_CODE (op) == SUBREG)"}, {"sha": "c949c3eea2d2e4747411dca51006d917f131eebe", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=6219012805548899fb34a29ca4f16cf9ddc7c0ad", "patch": "@@ -2283,12 +2283,27 @@ LFLGRET\"ID\":\\n\\\n \n /* Optional extra constraints for this machine.\n \n+   'Q' handles floating point constants which can be moved into\n+       an integer register with a single sethi instruction.\n+\n+   'R' handles floating point constants which can be moved into\n+       an integer register with a single mov instruction.\n+\n+   'S' handles floating point constants which can be moved into\n+       an integer register using a high/lo_sum sequence.\n+\n    'T' handles memory addresses where the alignment is known to\n        be at least 8 bytes.\n \n    `U' handles all pseudo registers or a hard even numbered\n        integer register, needed for ldd/std instructions.  */\n \n+#define EXTRA_CONSTRAINT_BASE(OP, C)   \\\n+   ((C) == 'Q' ? fp_sethi_p(OP)        \\\n+    : (C) == 'R' ? fp_mov_p(OP)        \\\n+    : (C) == 'S' ? fp_high_losum_p(OP) \\\n+    : 0)\n+\n #ifndef REG_OK_STRICT\n \n /* Nonzero if X is a hard reg that can be used as an index\n@@ -2303,12 +2318,13 @@ LFLGRET\"ID\":\\n\\\n /* 'T', 'U' are for aligned memory loads which aren't needed for v9.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-   ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n-    ? (mem_min_alignment (OP, 8))\t\t\t\\\n-    : ((! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n-       ? (register_ok_for_ldd (OP))\t\t\t\\\n-       : 0))\n- \n+   (EXTRA_CONSTRAINT_BASE(OP, C)                        \\\n+    || ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n+        ? (mem_min_alignment (OP, 8))\t\t\t\\\n+        : ((! TARGET_ARCH64 && (C) == 'U')\t\t\\\n+            ? (register_ok_for_ldd (OP))\t\t\\\n+            : 0)))\n+\n #else\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n@@ -2317,14 +2333,16 @@ LFLGRET\"ID\":\\n\\\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-   ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n-    ? mem_min_alignment (OP, 8) && strict_memory_address_p (Pmode, XEXP (OP, 0)) \\\n-    : ((! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n-       ? (GET_CODE (OP) == REG\t\t\t\t\\\n-          && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\\\n-\t      || reg_renumber[REGNO (OP)] >= 0)\t\t\\\n-          && register_ok_for_ldd (OP))\t\t\t\\\n-       : 0))\n+   (EXTRA_CONSTRAINT_BASE(OP, C)                        \\\n+    || ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n+        ? mem_min_alignment (OP, 8) && strict_memory_address_p (Pmode, XEXP (OP, 0)) \\\n+        : ((! TARGET_ARCH64 && (C) == 'U')\t\t\\\n+           ? (GET_CODE (OP) == REG\t\t\t\\\n+              && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\\\n+\t          || reg_renumber[REGNO (OP)] >= 0)\t\\\n+              && register_ok_for_ldd (OP))\t\t\\\n+           : 0)))\n+\n #endif\n \f\n /* Should gcc use [%reg+%lo(xx)+offset] addresses?  */\n@@ -3309,6 +3327,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\\\n {\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\t\\\n+{\"fp_sethi_p\", {CONST_DOUBLE}},\t\t\t\t\t\t\\\n+{\"fp_mov_p\", {CONST_DOUBLE}},\t\t\t\t\t\t\\\n+{\"fp_high_losum_p\", {CONST_DOUBLE}},\t\t\t\t\t\\\n {\"intreg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n {\"fcc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n {\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\\"}, {"sha": "b7025a860ce293fa6a6efc60c1187978c5622c9d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 177, "deletions": 97, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=6219012805548899fb34a29ca4f16cf9ddc7c0ad", "patch": "@@ -37,12 +37,10 @@\n ;;\t\t\t9\tsethh\n ;;\t\t\t10\tsetlm\n ;;\t\t\t11\tembmedany_sethi, embmedany_brsum\n-;;                      12\tmovsf_const_high\n ;;\t\t\t13\tembmedany_textuhi\n ;;\t\t\t14\tembmedany_texthi\n ;;\t\t\t15\tembmedany_textulo\n ;;\t\t\t16\tembmedany_textlo\n-;;                      17\tmovsf_const_lo\n ;;\t\t\t18\tsethm\n ;;\t\t\t19\tsetlo\n ;;\n@@ -2820,91 +2818,203 @@\n \f\n ;; Floating point move insns\n \n-(define_insn \"*clear_sf\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-        (match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_VIS\n-   && fp_zero_operand (operands[1])\"\n-  \"fzeros\\\\t%0\"\n-  [(set_attr \"type\" \"fpmove\")\n-   (set_attr \"length\" \"1\")])\n+(define_insn \"*movsf_insn_novis_liveg0\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,*r,*r,*r,*r,*r,f,m,m\")\n+\t(match_operand:SF 1 \"input_operand\"         \"f,G,Q,*rR,S,m,m,f,*r\"))]\n+  \"(TARGET_FPU && ! TARGET_VIS && TARGET_LIVE_G0)\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && (which_alternative == 2\n+          || which_alternative == 3\n+          || which_alternative == 4))\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i;\n \n-(define_insn \"*clear_sfp\"\n-  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n-        (match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"! TARGET_LIVE_G0\n-   && fp_zero_operand (operands[1])\"\n-  \"st\\\\t%%g0, %0\"\n-  [(set_attr \"type\" \"store\")\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+      operands[1] = GEN_INT (i);\n+    }\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"fmovs\\\\t%1, %0\\\";\n+    case 1:\n+      return \\\"and\\\\t%0, 0, %0\\\";\n+    case 2:\n+      return \\\"sethi\\\\t%%hi(%a1), %0\\\";\n+    case 3:\n+      return \\\"mov\\\\t%1, %0\\\";\n+    case 4:\n+      return \\\"#\\\";\n+    case 5:\n+    case 6:\n+      return \\\"ld\\\\t%1, %0\\\";\n+    case 7:\n+    case 8:\n+      return \\\"st\\\\t%1, %0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"fpmove,move,move,move,*,load,fpload,fpstore,store\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movsf_const_intreg\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,r\")\n-        (match_operand:SF 1 \"const_double_operand\" \"m#F,F\"))]\n-  \"TARGET_FPU\"\n+(define_insn \"*movsf_insn_novis_noliveg0\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,*r,*r,*r,*r,*r,f,m,m\")\n+\t(match_operand:SF 1 \"input_operand\"         \"f,G,Q,*rR,S,m,m,f,*rG\"))]\n+  \"(TARGET_FPU && ! TARGET_VIS && ! TARGET_LIVE_G0)\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode)\n+       || fp_zero_operand (operands[1]))\"\n   \"*\n {\n-  REAL_VALUE_TYPE r;\n-  long i;\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && (which_alternative == 2\n+          || which_alternative == 3\n+          || which_alternative == 4))\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i;\n \n-  if (which_alternative == 0)\n-    return \\\"ld\\\\t%1, %0\\\";\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+      operands[1] = GEN_INT (i);\n+    }\n \n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-  if (SPARC_SIMM13_P (i) || SPARC_SETHI_P (i))\n+  switch (which_alternative)\n     {\n+    case 0:\n+      return \\\"fmovs\\\\t%1, %0\\\";\n+    case 1:\n+      return \\\"clr\\\\t%0\\\";\n+    case 2:\n+      return \\\"sethi\\\\t%%hi(%a1), %0\\\";\n+    case 3:\n+      return \\\"mov\\\\t%1, %0\\\";\n+    case 4:\n+      return \\\"#\\\";\n+    case 5:\n+    case 6:\n+      return \\\"ld\\\\t%1, %0\\\";\n+    case 7:\n+    case 8:\n+      return \\\"st\\\\t%r1, %0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"fpmove,move,move,move,*,load,fpload,fpstore,store\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*movsf_insn_vis\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,*r,*r,*r,f,m,m\")\n+\t(match_operand:SF 1 \"input_operand\"         \"f,G,G,Q,*rR,S,m,m,f,*rG\"))]\n+  \"(TARGET_FPU && TARGET_VIS)\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode)\n+       || fp_zero_operand (operands[1]))\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && (which_alternative == 3\n+          || which_alternative == 4\n+          || which_alternative == 5))\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n       operands[1] = GEN_INT (i);\n-      if (SPARC_SIMM13_P (INTVAL (operands[1])))\n-        return \\\"mov\\\\t%1, %0\\\";\n-      else if (SPARC_SETHI_P (INTVAL (operands[1])))\n-        return \\\"sethi\\\\t%%hi(%a1), %0\\\";\n-      else\n-        abort ();\n     }\n-  else\n-    return \\\"#\\\";\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"fmovs\\\\t%1, %0\\\";\n+    case 1:\n+      return \\\"fzeros\\\\t%0\\\";\n+    case 2:\n+      return \\\"clr\\\\t%0\\\";\n+    case 3:\n+      return \\\"sethi\\\\t%%hi(%a1), %0\\\";\n+    case 4:\n+      return \\\"mov\\\\t%1, %0\\\";\n+    case 5:\n+      return \\\"#\\\";\n+    case 6:\n+    case 7:\n+      return \\\"ld\\\\t%1, %0\\\";\n+    case 8:\n+    case 9:\n+      return \\\"st\\\\t%r1, %0\\\";\n+    }\n }\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1,2\")])\n+  [(set_attr \"type\" \"fpmove,fpmove,move,move,move,*,load,fpload,fpstore,store\")\n+   (set_attr \"length\" \"1\")])\n \n-;; There isn't much I can do about this, if I change the\n-;; mode then flow info gets really confused because the\n-;; destination no longer looks the same.  Ho hum...\n-(define_insn \"*movsf_const_high\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-        (unspec:SF [(match_operand 1 \"const_int_operand\" \"\")] 12))]\n-  \"\"\n-  \"sethi\\\\t%%hi(%a1), %0\"\n-  [(set_attr \"type\" \"move\")\n+(define_insn \"*movsf_lo_sum\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (lo_sum:SF (match_operand:SF 1 \"register_operand\" \"\")\n+                   (match_operand:SF 2 \"const_double_operand\" \"\")))]\n+  \"TARGET_FPU && fp_high_losum_p (operands[2])\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[2]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  operands[2] = GEN_INT (i);\n+  return \\\"or\\\\t%1, %%lo(%a2), %0\\\";\n+}\"\n+  [(set_attr \"type\" \"ialu\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movsf_const_lo\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-        (unspec:SF [(match_operand:SF 1 \"register_operand\" \"r\")\n-                    (match_operand 2 \"const_int_operand\" \"\")] 17))]\n-  \"\"\n-  \"or\\\\t%1, %%lo(%a2), %0\"\n+(define_insn \"*movsf_high\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (high:SF (match_operand:SF 1 \"const_double_operand\" \"\")))]\n+  \"TARGET_FPU && fp_high_losum_p (operands[1])\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  operands[1] = GEN_INT (i);\n+  return \\\"sethi\\\\t%%hi(%1), %0\\\";\n+}\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n         (match_operand:SF 1 \"const_double_operand\" \"\"))]\n   \"TARGET_FPU\n+   && fp_high_losum_p (operands[1])\n    && (GET_CODE (operands[0]) == REG\n        && REGNO (operands[0]) < 32)\"\n-  [(set (match_dup 0) (unspec:SF [(match_dup 1)] 12))\n-   (set (match_dup 0) (unspec:SF [(match_dup 0) (match_dup 1)] 17))]\n-  \"\n-{\n-  REAL_VALUE_TYPE r;\n-  long i;\n+  [(set (match_dup 0) (high:SF (match_dup 1)))\n+   (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n \n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-  operands[1] = GEN_INT (i);\n-}\")\n+;; Exactly the same as above, except that all `f' cases are deleted.\n+;; This is necessary to prevent reload from ever trying to use a `f' reg\n+;; when -mno-fpu.\n+\n+(define_insn \"*movsf_no_f_insn\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:SF 1 \"input_operand\"    \"r,m,r\"))]\n+  \"! TARGET_FPU\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"@\n+   mov\\\\t%1, %0\n+   ld\\\\t%1, %0\n+   st\\\\t%1, %0\"\n+  [(set_attr \"type\" \"move,load,store\")\n+   (set_attr \"length\" \"1\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n@@ -2933,7 +3043,10 @@\n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], SFmode))\n+      if (register_operand (operands[1], SFmode)\n+\t  || (! TARGET_LIVE_G0\n+\t      && GET_CODE (operands[1]) == CONST_DOUBLE\n+              && fp_zero_operand (operands[1])))\n \tgoto movsf_is_ok;\n \n       if (! reload_in_progress)\n@@ -2964,39 +3077,6 @@\n   ;\n }\")\n \n-(define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,m,r,r,m\")\n-\t(match_operand:SF 1 \"input_operand\"    \"f,m,f,r,m,r\"))]\n-  \"TARGET_FPU\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-  \"@\n-   fmovs\\\\t%1, %0\n-   ld\\\\t%1, %0\n-   st\\\\t%1, %0\n-   mov\\\\t%1, %0\n-   ld\\\\t%1, %0\n-   st\\\\t%1, %0\"\n-  [(set_attr \"type\" \"fpmove,fpload,fpstore,move,load,store\")\n-   (set_attr \"length\" \"1\")])\n-\n-;; Exactly the same as above, except that all `f' cases are deleted.\n-;; This is necessary to prevent reload from ever trying to use a `f' reg\n-;; when -mno-fpu.\n-\n-(define_insn \"*movsf_no_f_insn\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:SF 1 \"input_operand\"    \"r,m,r\"))]\n-  \"! TARGET_FPU\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-  \"@\n-   mov\\\\t%1, %0\n-   ld\\\\t%1, %0\n-   st\\\\t%1, %0\"\n-  [(set_attr \"type\" \"move,load,store\")\n-   (set_attr \"length\" \"1\")])\n-\n (define_insn \"*clear_df\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n         (match_operand:DF 1 \"const_double_operand\" \"\"))]"}, {"sha": "067d464d46c1c9bafe05c3e54d101d7757137a21", "filename": "gcc/md.texi", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6219012805548899fb34a29ca4f16cf9ddc7c0ad/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=6219012805548899fb34a29ca4f16cf9ddc7c0ad", "patch": "@@ -1621,11 +1621,19 @@ Floating-point zero\n Signed 13 bit constant, sign-extended to 32 or 64 bits\n \n @item Q\n-Memory reference that can be loaded with one instruction  (@samp{m} is\n-more appropriate for @code{asm} statements)\n+Floating-point constant whose integral representation can\n+be moved into an integer register using a single sethi\n+instruction\n+\n+@item R\n+Floating-point constant whose integral representation can\n+be moved into an integer register using a single mov\n+instruction\n \n @item S\n-Constant, or memory address\n+Floating-point constant whose integral representation can\n+be moved into an integer register using a high/lo_sum\n+instruction sequence\n \n @item T\n Memory address aligned to an 8-byte boundary"}]}