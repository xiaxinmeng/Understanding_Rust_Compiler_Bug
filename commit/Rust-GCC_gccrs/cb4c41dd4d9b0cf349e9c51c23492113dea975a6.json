{"sha": "cb4c41dd4d9b0cf349e9c51c23492113dea975a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I0YzQxZGQ0ZDliMGNmMzQ5ZTljNTFjMjM0OTIxMTNkZWE5NzVhNg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2015-05-19T17:41:21Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2015-05-19T17:41:21Z"}, "message": "S/390 Invalid vector binary ops\n\nThis is a first try to implement at least some of the requirements\nregarding the vector bool type documented for IBM XLC.\n\nWith this patch error messages will be issued for invalid uses of\nvector bool types in binary operators.\n\nvector bool types are being marked opaque in order to prevent the\nfront-end from complaining about \"vector bool long\" vs \"vector bool\nlong long\" combinations on 64 bit.  The opaque flag basically\nsuppresses any type checking. However, we still want vector bool to be\naccepted only in contexts specified in the documentation (to be\npublished soon).  Implementing the invalid binary op hook does this\nfor binary operators at least.  But this is far from being complete :(\n\ngcc/\n\t* config/s390/s390.c (s390_vector_bool_type_p): New function.\n\t(s390_invalid_binary_op): New function.\n\t(TARGET_INVALID_BINARY_OP): Define macro.\n\nFrom-SVN: r223404", "tree": {"sha": "452095ebe18ef24556b523eeac0cf483a5c18e3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/452095ebe18ef24556b523eeac0cf483a5c18e3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb4c41dd4d9b0cf349e9c51c23492113dea975a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4c41dd4d9b0cf349e9c51c23492113dea975a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4c41dd4d9b0cf349e9c51c23492113dea975a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4c41dd4d9b0cf349e9c51c23492113dea975a6/comments", "author": null, "committer": null, "parents": [{"sha": "17521813e152860e7cfa5a5d0255cf2ca5e704be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17521813e152860e7cfa5a5d0255cf2ca5e704be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17521813e152860e7cfa5a5d0255cf2ca5e704be"}], "stats": {"total": 67, "additions": 67, "deletions": 0}, "files": [{"sha": "9676e38c765f5be88626d598f0248356d785056c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4c41dd4d9b0cf349e9c51c23492113dea975a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4c41dd4d9b0cf349e9c51c23492113dea975a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb4c41dd4d9b0cf349e9c51c23492113dea975a6", "patch": "@@ -1,3 +1,9 @@\n+2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_vector_bool_type_p): New function.\n+\t(s390_invalid_binary_op): New function.\n+\t(TARGET_INVALID_BINARY_OP): Define macro.\n+\n 2015-05-19  David Sherwood  <david.sherwood@arm.com>\n \n \t* loop-invariant.c (create_new_invariant): Don't calculate address cost"}, {"sha": "6648597fe442e55b63f1c4ca703e61084dd30afe", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4c41dd4d9b0cf349e9c51c23492113dea975a6/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4c41dd4d9b0cf349e9c51c23492113dea975a6/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=cb4c41dd4d9b0cf349e9c51c23492113dea975a6", "patch": "@@ -13649,6 +13649,64 @@ s390_vector_alignment (const_tree type)\n }\n \n \n+/* Return true if TYPE is a vector bool type.  */\n+static inline bool\n+s390_vector_bool_type_p (const_tree type)\n+{\n+  return TYPE_VECTOR_OPAQUE (type);\n+}\n+\n+/* Return the diagnostic message string if the binary operation OP is\n+   not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n+static const char*\n+s390_invalid_binary_op (int op ATTRIBUTE_UNUSED, const_tree type1, const_tree type2)\n+{\n+  bool bool1_p, bool2_p;\n+  bool plusminus_p;\n+  bool muldiv_p;\n+  bool compare_p;\n+  machine_mode mode1, mode2;\n+\n+  if (!TARGET_ZVECTOR)\n+    return NULL;\n+\n+  if (!VECTOR_TYPE_P (type1) || !VECTOR_TYPE_P (type2))\n+    return NULL;\n+\n+  bool1_p = s390_vector_bool_type_p (type1);\n+  bool2_p = s390_vector_bool_type_p (type2);\n+\n+  /* Mixing signed and unsigned types is forbidden for all\n+     operators.  */\n+  if (!bool1_p && !bool2_p\n+      && TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n+    return N_(\"types differ in signess\");\n+\n+  plusminus_p = (op == PLUS_EXPR || op == MINUS_EXPR);\n+  muldiv_p = (op == MULT_EXPR || op == RDIV_EXPR || op == TRUNC_DIV_EXPR\n+\t      || op == CEIL_DIV_EXPR || op == FLOOR_DIV_EXPR\n+\t      || op == ROUND_DIV_EXPR);\n+  compare_p = (op == LT_EXPR || op == LE_EXPR || op == GT_EXPR || op == GE_EXPR\n+\t       || op == EQ_EXPR || op == NE_EXPR);\n+\n+  if (bool1_p && bool2_p && (plusminus_p || muldiv_p))\n+    return N_(\"binary operator does not support two vector bool operands\");\n+\n+  if (bool1_p != bool2_p && (muldiv_p || compare_p))\n+    return N_(\"binary operator does not support vector bool operand\");\n+\n+  mode1 = TYPE_MODE (type1);\n+  mode2 = TYPE_MODE (type2);\n+\n+  if (bool1_p != bool2_p && plusminus_p\n+      && (GET_MODE_CLASS (mode1) == MODE_VECTOR_FLOAT\n+\t  || GET_MODE_CLASS (mode2) == MODE_VECTOR_FLOAT))\n+    return N_(\"binary operator does not support mixing vector \"\n+\t      \"bool with floating point vector operands\");\n+\n+  return NULL;\n+}\n+\n /* Initialize GCC target structure.  */\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n@@ -13863,6 +13921,9 @@ s390_vector_alignment (const_tree type)\n #undef TARGET_VECTOR_ALIGNMENT\n #define TARGET_VECTOR_ALIGNMENT s390_vector_alignment\n \n+#undef TARGET_INVALID_BINARY_OP\n+#define TARGET_INVALID_BINARY_OP s390_invalid_binary_op\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}]}