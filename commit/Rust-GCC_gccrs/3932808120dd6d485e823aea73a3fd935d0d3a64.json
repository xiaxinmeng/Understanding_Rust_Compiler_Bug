{"sha": "3932808120dd6d485e823aea73a3fd935d0d3a64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkzMjgwODEyMGRkNmQ0ODVlODIzYWVhNzNhM2ZkOTM1ZDBkM2E2NA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2005-06-11T19:39:13Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-06-11T19:39:13Z"}, "message": "[multiple changes]\n\n2005-06-11  Thomas Koenig  <Thomas.Koenig@onlinde.de>\n\n\tPR libfortran/21333\n\t* Makefile.am: Add in_pack_c4.c, in_pack_c8.c, in_unpack_c4.c\n\tand in_unpack_c8.c.\n\t* Makefile.in: Regenerate.\n\t* libgfortran.h:  Declare internal_pack_c4, internal_pack_c8,\n\tinternal_unpack_c4 and internal_unpack_c8.\n\t* m4/in_pack.m4: Use rtype_ccode insteald of rtype_kind\n\tin function name.\n\tUse sizeof (rtype_name) as size for memory allocation.\n\t* m4/in_unpack.m4: Use rtype_ccode insteald of rtype_kind\n\tin function name.\n\tUse sizeof (rtype_name) for calculation of sizes for memcpy.\n\t* runtime/in_pack_generic.c:  For real, integer and logical\n\tcall internal_pack_4 if size==4 and internal_pack_8 if\n\tsize==8.\n\tFor complex, call internal_pack_c4 if size==8 and\n\tinternal_pack_c8 if size==16.\n\t* runtime/in_unpack_generic.c: For real, integer and logical\n        call internal_unpack_4 if size==4 and internal_unpack_8 if\n        size==8.\n        For complex, call internal_unpack_c4 if size==8 and\n        internal_unpack_c8 if size==16.\n\t* generated/in_pack_i4.c:  Regenerated.\n\t* generated/in_pack_i8.c:  Regenerated.\n\t* generated/in_unpack_i4.c:  Regenerated.\n\t* generated/in_unpack_i8.c:  Regenerated.\n\t* generated/in_pack_c4.c:  New file.\n\t* generated/in_pack_c8.c:  New file.\n\t* generated/in_unpack_c4.c:  New file.\n\t* generated/in_unpack_c8.c:  New file.\n\n2005-05-11  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\t* gfortran.fortran-torture/execute/in-pack.f90:  New test.\n\nFrom-SVN: r100842", "tree": {"sha": "aad494096555f7a4cc32786401cfade71ce1dc21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aad494096555f7a4cc32786401cfade71ce1dc21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3932808120dd6d485e823aea73a3fd935d0d3a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3932808120dd6d485e823aea73a3fd935d0d3a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3932808120dd6d485e823aea73a3fd935d0d3a64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3932808120dd6d485e823aea73a3fd935d0d3a64/comments", "author": null, "committer": null, "parents": [{"sha": "1fa5c70974c297a42a550aa776c6a47f645459e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa5c70974c297a42a550aa776c6a47f645459e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fa5c70974c297a42a550aa776c6a47f645459e5"}], "stats": {"total": 708, "additions": 677, "deletions": 31}, "files": [{"sha": "1dced9a33898152d65698ae2f211bbce45d4f777", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -1,3 +1,7 @@\n+2005-05-11  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\t* gfortran.fortran-torture/execute/in-pack.f90:  New test.\n+\n 2005-06-10  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* gfortran.dg/vect/vect-4.f90: Update comments. Only one unaligned"}, {"sha": "b9ea268324020aa578cdc69d70877d90102846c5", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/in-pack.f90", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fin-pack.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fin-pack.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fin-pack.f90?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -0,0 +1,92 @@\n+!  Check in_pack and in_unpack for integer and comlex types, with\n+!  alignment issues thrown in for good measure.\n+\n+program main\n+  implicit none\n+\n+  complex(kind=4) :: a4(5),b4(5),aa4(5),bb4(5)\n+  real(kind=4) :: r4(100)\n+  equivalence(a4(1),r4(1)),(b4(1),r4(12))\n+\n+  complex(kind=8) :: a8(5),b8(5),aa8(5),bb8(5)\n+  real(kind=8) :: r8(100)\n+  equivalence(a8(1),r8(1)),(b8(1),r8(12))\n+\n+  integer(kind=4) :: i4(5),ii4(5)\n+  integer(kind=8) :: i8(5),ii8(5)\n+\n+  integer :: i\n+\n+  a4 = (/(cmplx(i,-i,kind=4),i=1,5)/)\n+  b4 = (/(2*cmplx(i,-i,kind=4),i=1,5)/)\n+  call csub4(a4(5:1:-1),b4(5:1:-1),5)\n+  aa4 = (/(cmplx(5-i+1,i-5-1,kind=4),i=1,5)/)\n+  if (any(aa4 /= a4)) call abort\n+  bb4 = (/(2*cmplx(5-i+1,i-5-1,kind=4),i=1,5)/)\n+  if (any(bb4 /= b4)) call abort\n+\n+  a8 = (/(cmplx(i,-i,kind=8),i=1,5)/)\n+  b8 = (/(2*cmplx(i,-i,kind=8),i=1,5)/)\n+  call csub8(a8(5:1:-1),b8(5:1:-1),5)\n+  aa8 = (/(cmplx(5-i+1,i-5-1,kind=8),i=1,5)/)\n+  if (any(aa8 /= a8)) call abort\n+  bb8 = (/(2*cmplx(5-i+1,i-5-1,kind=8),i=1,5)/)\n+  if (any(bb8 /= b8)) call abort\n+\n+  i4 = (/(i, i=1,5)/)\n+  call isub4(i4(5:1:-1),5)\n+  ii4 = (/(5-i+1,i=1,5)/)\n+  if (any(ii4 /= i4)) call abort\n+\n+  i8 = (/(i,i=1,5)/)\n+  call isub8(i8(5:1:-1),5)\n+  ii8 = (/(5-i+1,i=1,5)/)\n+  if (any(ii8 /= i8)) call abort\n+\n+end program main\n+\n+subroutine csub4(a,b,n)\n+  implicit none\n+  complex(kind=4), dimension(n) :: a,b\n+  complex(kind=4), dimension(n) :: aa, bb\n+  integer :: n, i\n+  aa = (/(cmplx(n-i+1,i-n-1,kind=4),i=1,n)/)\n+  if (any(aa /= a)) call abort\n+  bb = (/(2*cmplx(n-i+1,i-n-1,kind=4),i=1,5)/)\n+  if (any(bb /= b)) call abort\n+  a = (/(cmplx(i,-i,kind=4),i=1,5)/)\n+  b = (/(2*cmplx(i,-i,kind=4),i=1,5)/)\n+end subroutine csub4\n+\n+subroutine csub8(a,b,n)\n+  implicit none\n+  complex(kind=8), dimension(n) :: a,b\n+  complex(kind=8), dimension(n) :: aa, bb\n+  integer :: n, i\n+  aa = (/(cmplx(n-i+1,i-n-1,kind=8),i=1,n)/)\n+  if (any(aa /= a)) call abort\n+  bb = (/(2*cmplx(n-i+1,i-n-1,kind=8),i=1,5)/)\n+  if (any(bb /= b)) call abort\n+  a = (/(cmplx(i,-i,kind=8),i=1,5)/)\n+  b = (/(2*cmplx(i,-i,kind=8),i=1,5)/)\n+end subroutine csub8\n+\n+subroutine isub4(a,n)\n+  implicit none\n+  integer(kind=4), dimension(n) :: a\n+  integer(kind=4), dimension(n) :: aa\n+  integer :: n, i\n+  aa = (/(n-i+1,i=1,n)/)\n+  if (any(aa /= a)) call abort\n+  a = (/(i,i=1,5)/)\n+end subroutine isub4\n+\n+subroutine isub8(a,n)\n+  implicit none\n+  integer(kind=8), dimension(n) :: a\n+  integer(kind=8), dimension(n) :: aa\n+  integer :: n, i\n+  aa = (/(n-i+1,i=1,n)/)\n+  if (any(aa /= a)) call abort\n+  a = (/(i,i=1,5)/)\n+end subroutine isub8"}, {"sha": "43fc98830014c7340c74c65c8eb4b0630d9bedcd", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -243,11 +243,15 @@ generated/cshift1_8.c\n \n in_pack_c = \\\n generated/in_pack_i4.c \\\n-generated/in_pack_i8.c\n+generated/in_pack_i8.c \\\n+generated/in_pack_c4.c \\\n+generated/in_pack_c8.c\n \n in_unpack_c = \\\n generated/in_unpack_i4.c \\\n-generated/in_unpack_i8.c\n+generated/in_unpack_i8.c \\\n+generated/in_unpack_c4.c \\\n+generated/in_unpack_c8.c\n \n i_exponent_c = \\\n generated/exponent_r4.c \\"}, {"sha": "4fc4357cf25a9a40b8a2e48ee1503ddfcb5fe188", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -104,8 +104,10 @@ am__objects_21 = eoshift3_4.lo eoshift3_8.lo\n am__objects_22 = cshift1_4.lo cshift1_8.lo\n am__objects_23 = reshape_i4.lo reshape_i8.lo reshape_c4.lo \\\n \treshape_c8.lo\n-am__objects_24 = in_pack_i4.lo in_pack_i8.lo\n-am__objects_25 = in_unpack_i4.lo in_unpack_i8.lo\n+am__objects_24 = in_pack_i4.lo in_pack_i8.lo in_pack_c4.lo \\\n+\tin_pack_c8.lo\n+am__objects_25 = in_unpack_i4.lo in_unpack_i8.lo in_unpack_c4.lo \\\n+\tin_unpack_c8.lo\n am__objects_26 = exponent_r4.lo exponent_r8.lo\n am__objects_27 = fraction_r4.lo fraction_r8.lo\n am__objects_28 = nearest_r4.lo nearest_r8.lo\n@@ -533,11 +535,15 @@ generated/cshift1_8.c\n \n in_pack_c = \\\n generated/in_pack_i4.c \\\n-generated/in_pack_i8.c\n+generated/in_pack_i8.c \\\n+generated/in_pack_c4.c \\\n+generated/in_pack_c8.c\n \n in_unpack_c = \\\n generated/in_unpack_i4.c \\\n-generated/in_unpack_i8.c\n+generated/in_unpack_i8.c \\\n+generated/in_unpack_c4.c \\\n+generated/in_unpack_c8.c\n \n i_exponent_c = \\\n generated/exponent_r4.c \\\n@@ -1129,12 +1135,24 @@ in_pack_i4.lo: generated/in_pack_i4.c\n in_pack_i8.lo: generated/in_pack_i8.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_i8.lo `test -f 'generated/in_pack_i8.c' || echo '$(srcdir)/'`generated/in_pack_i8.c\n \n+in_pack_c4.lo: generated/in_pack_c4.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_c4.lo `test -f 'generated/in_pack_c4.c' || echo '$(srcdir)/'`generated/in_pack_c4.c\n+\n+in_pack_c8.lo: generated/in_pack_c8.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_c8.lo `test -f 'generated/in_pack_c8.c' || echo '$(srcdir)/'`generated/in_pack_c8.c\n+\n in_unpack_i4.lo: generated/in_unpack_i4.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_i4.lo `test -f 'generated/in_unpack_i4.c' || echo '$(srcdir)/'`generated/in_unpack_i4.c\n \n in_unpack_i8.lo: generated/in_unpack_i8.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_i8.lo `test -f 'generated/in_unpack_i8.c' || echo '$(srcdir)/'`generated/in_unpack_i8.c\n \n+in_unpack_c4.lo: generated/in_unpack_c4.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_c4.lo `test -f 'generated/in_unpack_c4.c' || echo '$(srcdir)/'`generated/in_unpack_c4.c\n+\n+in_unpack_c8.lo: generated/in_unpack_c8.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_c8.lo `test -f 'generated/in_unpack_c8.c' || echo '$(srcdir)/'`generated/in_unpack_c8.c\n+\n exponent_r4.lo: generated/exponent_r4.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o exponent_r4.lo `test -f 'generated/exponent_r4.c' || echo '$(srcdir)/'`generated/exponent_r4.c\n "}, {"sha": "ed3b8ec6ef6b390459b8f822da216de6e24e0f37", "filename": "libgfortran/generated/in_pack_c4.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c4.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -0,0 +1,123 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_COMPLEX_4 *\n+internal_pack_c4 (gfc_array_c4 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_COMPLEX_4 *src;\n+  GFC_COMPLEX_4 *dest;\n+  GFC_COMPLEX_4 *destptr;\n+  int n;\n+  int packed;\n+\n+  if (source->dim[0].stride == 0)\n+    {\n+      source->dim[0].stride = 1;\n+      return source->data;\n+    }\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_COMPLEX_4 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_4));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+"}, {"sha": "e313540f7bf43679e2bbe05bd9fd1c072f74a929", "filename": "libgfortran/generated/in_pack_c8.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c8.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -0,0 +1,123 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_COMPLEX_8 *\n+internal_pack_c8 (gfc_array_c8 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_COMPLEX_8 *src;\n+  GFC_COMPLEX_8 *dest;\n+  GFC_COMPLEX_8 *destptr;\n+  int n;\n+  int packed;\n+\n+  if (source->dim[0].stride == 0)\n+    {\n+      source->dim[0].stride = 1;\n+      return source->data;\n+    }\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_COMPLEX_8 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_8));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+"}, {"sha": "75ea83bda9d2cce3c546946a354bc00a26f232ed", "filename": "libgfortran/generated/in_pack_i4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i4.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -82,7 +82,7 @@ internal_pack_4 (gfc_array_i4 * source)\n     return source->data;\n \n   /* Allocate storage for the destination.  */\n-  destptr = (GFC_INTEGER_4 *)internal_malloc_size (ssize * 4);\n+  destptr = (GFC_INTEGER_4 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_4));\n   dest = destptr;\n   src = source->data;\n   stride0 = stride[0];"}, {"sha": "69cc861d404df3bf84b7bd0fcb3b417f64bb5374", "filename": "libgfortran/generated/in_pack_i8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_pack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i8.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -82,7 +82,7 @@ internal_pack_8 (gfc_array_i8 * source)\n     return source->data;\n \n   /* Allocate storage for the destination.  */\n-  destptr = (GFC_INTEGER_8 *)internal_malloc_size (ssize * 8);\n+  destptr = (GFC_INTEGER_8 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_8));\n   dest = destptr;\n   src = source->data;\n   stride0 = stride[0];"}, {"sha": "e24939e5e529e0d2d2e00ae7874608eba3c50fa3", "filename": "libgfortran/generated/in_unpack_c4.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c4.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -0,0 +1,111 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+void\n+internal_unpack_c4 (gfc_array_c4 * d, const GFC_COMPLEX_4 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_COMPLEX_4 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  if (d->dim[0].stride == 0)\n+    d->dim[0].stride = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_COMPLEX_4));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "66865075c0213bcb55e00224dac63dc7b3b59494", "filename": "libgfortran/generated/in_unpack_c8.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c8.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -0,0 +1,111 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+void\n+internal_unpack_c8 (gfc_array_c8 * d, const GFC_COMPLEX_8 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_COMPLEX_8 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  if (d->dim[0].stride == 0)\n+    d->dim[0].stride = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_COMPLEX_8));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "4759568d73a655fbd2b76e1b508afc7fd5d3eee0", "filename": "libgfortran/generated/in_unpack_i4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i4.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -71,7 +71,7 @@ internal_unpack_4 (gfc_array_i4 * d, const GFC_INTEGER_4 * src)\n \n   if (dsize != 0)\n     {\n-      memcpy (dest, src, dsize * 4);\n+      memcpy (dest, src, dsize * sizeof (GFC_INTEGER_4));\n       return;\n     }\n "}, {"sha": "28c3a90f6afe6c9b2a5a64f609dcfe74e51680b9", "filename": "libgfortran/generated/in_unpack_i8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i8.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -71,7 +71,7 @@ internal_unpack_8 (gfc_array_i8 * d, const GFC_INTEGER_8 * src)\n \n   if (dsize != 0)\n     {\n-      memcpy (dest, src, dsize * 8);\n+      memcpy (dest, src, dsize * sizeof (GFC_INTEGER_8));\n       return;\n     }\n "}, {"sha": "e5485d1ba8b20542823bb83386f177e4fbdf0e08", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -482,20 +482,32 @@ internal_proto(reshape_packed);\n \n /* Repacking functions.  */\n \n-/* ??? These four aren't currently used by the compiler, though we\n+/* ??? These eight aren't currently used by the compiler, though we\n    certainly could do so.  */\n GFC_INTEGER_4 *internal_pack_4 (gfc_array_i4 *);\n internal_proto(internal_pack_4);\n \n GFC_INTEGER_8 *internal_pack_8 (gfc_array_i8 *);\n internal_proto(internal_pack_8);\n \n+GFC_COMPLEX_4 *internal_pack_c4 (gfc_array_c4 *);\n+internal_proto(internal_pack_c4);\n+\n+GFC_COMPLEX_8 *internal_pack_c8 (gfc_array_c8 *);\n+internal_proto(internal_pack_c8);\n+\n extern void internal_unpack_4 (gfc_array_i4 *, const GFC_INTEGER_4 *);\n internal_proto(internal_unpack_4);\n \n extern void internal_unpack_8 (gfc_array_i8 *, const GFC_INTEGER_8 *);\n internal_proto(internal_unpack_8);\n \n+extern void internal_unpack_c4 (gfc_array_c4 *, const GFC_COMPLEX_4 *);\n+internal_proto(internal_unpack_c4);\n+\n+extern void internal_unpack_c8 (gfc_array_c8 *, const GFC_COMPLEX_8 *);\n+internal_proto(internal_unpack_c8);\n+\n /* string_intrinsics.c */\n \n extern GFC_INTEGER_4 compare_string (GFC_INTEGER_4, const char *,"}, {"sha": "819cb3e2c331ad9fe578e27fae333fb6e987d1b2", "filename": "libgfortran/m4/in_pack.m4", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fm4%2Fin_pack.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fm4%2Fin_pack.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fin_pack.m4?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -37,9 +37,10 @@ include(iparm.m4)dnl\n /* Allocates a block of memory with internal_malloc if the array needs\n    repacking.  */\n \n-dnl Only the kind (ie size) is used to name the function.\n+dnl The kind (ie size) is used to name the function for logicals, integers\n+dnl and reals.  For complex, it's c4 or c8.\n rtype_name *\n-`internal_pack_'rtype_kind (rtype * source)\n+`internal_pack_'rtype_ccode (rtype * source)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -84,7 +85,7 @@ rtype_name *\n     return source->data;\n \n   /* Allocate storage for the destination.  */\n-  destptr = (rtype_name *)internal_malloc_size (ssize * rtype_kind);\n+  destptr = (rtype_name *)internal_malloc_size (ssize * sizeof (rtype_name));\n   dest = destptr;\n   src = source->data;\n   stride0 = stride[0];"}, {"sha": "47ae51d9ac05f0f44dc1adcd427004f9f74197e0", "filename": "libgfortran/m4/in_unpack.m4", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fm4%2Fin_unpack.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fm4%2Fin_unpack.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fin_unpack.m4?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -35,9 +35,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"libgfortran.h\"'\n include(iparm.m4)dnl\n \n-dnl Only the kind (ie size) is used to name the function.\n+dnl Only the kind (ie size) is used to name the function for integers,\n+dnl reals and logicals.  For complex, it's c4 and c8.\n void\n-`internal_unpack_'rtype_kind (rtype * d, const rtype_name * src)\n+`internal_unpack_'rtype_ccode (rtype * d, const rtype_name * src)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -73,7 +74,7 @@ void\n \n   if (dsize != 0)\n     {\n-      memcpy (dest, src, dsize * rtype_kind);\n+      memcpy (dest, src, dsize * sizeof (rtype_name));\n       return;\n     }\n "}, {"sha": "23810cf83206afaa143d60aabb7391dfdab1bc88", "filename": "libgfortran/runtime/in_pack_generic.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fruntime%2Fin_pack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fruntime%2Fin_pack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fin_pack_generic.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -52,21 +52,44 @@ internal_pack (gfc_array_char * source)\n   int n;\n   int packed;\n   index_type size;\n+  int type;\n \n   if (source->dim[0].stride == 0)\n     {\n       source->dim[0].stride = 1;\n       return source->data;\n     }\n \n+  type = GFC_DESCRIPTOR_TYPE (source);\n   size = GFC_DESCRIPTOR_SIZE (source);\n-  switch (size)\n+  switch (type)\n     {\n-    case 4:\n-      return internal_pack_4 ((gfc_array_i4 *)source);\n-\n-    case 8:\n-      return internal_pack_8 ((gfc_array_i8 *)source);\n+    case GFC_DTYPE_INTEGER:\n+    case GFC_DTYPE_LOGICAL:\n+    case GFC_DTYPE_REAL:\n+      switch (size)\n+\t{\n+\tcase 4:\n+\t  return internal_pack_4 ((gfc_array_i4 *)source);\n+\t  \n+\tcase 8:\n+\t  return internal_pack_8 ((gfc_array_i8 *)source);\n+\t}\n+      break;\n+\n+    case GFC_DTYPE_COMPLEX:\n+      switch (size)\n+\t{\n+\tcase 8:\n+\t  return internal_pack_c4 ((gfc_array_c4 *)source);\n+\t  \n+\tcase 16:\n+\t  return internal_pack_c8 ((gfc_array_c8 *)source);\n+\t}\n+      break;\n+\n+    default:\n+      break;\n     }\n \n   dim = GFC_DESCRIPTOR_RANK (source);"}, {"sha": "1e8ac6b7a470d37281ce9c941eb8f9b03a6c83dc", "filename": "libgfortran/runtime/in_unpack_generic.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fruntime%2Fin_unpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932808120dd6d485e823aea73a3fd935d0d3a64/libgfortran%2Fruntime%2Fin_unpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fin_unpack_generic.c?ref=3932808120dd6d485e823aea73a3fd935d0d3a64", "patch": "@@ -50,22 +50,45 @@ internal_unpack (gfc_array_char * d, const void * s)\n   const char *src;\n   int n;\n   int size;\n+  int type;\n \n   dest = d->data;\n   /* This check may be redundant, but do it anyway.  */\n   if (s == dest || !s)\n     return;\n \n+  type = GFC_DESCRIPTOR_TYPE (d);\n   size = GFC_DESCRIPTOR_SIZE (d);\n-  switch (size)\n+  switch (type)\n     {\n-    case 4:\n-      internal_unpack_4 ((gfc_array_i4 *)d, (const GFC_INTEGER_4 *)s);\n-      return;\n-\n-    case 8:\n-      internal_unpack_8 ((gfc_array_i8 *)d, (const GFC_INTEGER_8 *)s);\n-      return;\n+    case GFC_DTYPE_INTEGER:\n+    case GFC_DTYPE_LOGICAL:\n+    case GFC_DTYPE_REAL:\n+      switch (size)\n+\t{\n+\tcase 4:\n+\t  internal_unpack_4 ((gfc_array_i4 *)d, (const GFC_INTEGER_4 *)s);\n+\t  return;\n+\n+\tcase 8:\n+\t  internal_unpack_8 ((gfc_array_i8 *)d, (const GFC_INTEGER_8 *)s);\n+\t  return;\n+\t}\n+      break;\n+\n+    case GFC_DTYPE_COMPLEX:\n+      switch (size) \n+\t{\n+\tcase 8:\n+\t  internal_unpack_c4 ((gfc_array_c4 *)d, (const GFC_COMPLEX_4 *)s);\n+\t  return;\n+\n+\tcase 16:\n+\t  internal_unpack_c8 ((gfc_array_c8 *)d, (const GFC_COMPLEX_8 *)s);\n+\t  return;\n+\t}\n+    default:\n+      break;\n     }\n \n   if (d->dim[0].stride == 0)"}]}