{"sha": "542d73aeffbdb33c2cf23d1a232da9d7fe747e92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQyZDczYWVmZmJkYjMzYzJjZjIzZDFhMjMyZGE5ZDdmZTc0N2U5Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-07T18:36:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-07T18:36:23Z"}, "message": "emit-rtl.c (remove_unnecessary_notes): Verify proper nesting of block notes and exception handling notes.\n\n        * emit-rtl.c (remove_unnecessary_notes): Verify proper nesting\n        of block notes and exception handling notes.\n\nFrom-SVN: r40295", "tree": {"sha": "60a2ea46f8d164b6809059d0e148fc6603c01794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60a2ea46f8d164b6809059d0e148fc6603c01794"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/542d73aeffbdb33c2cf23d1a232da9d7fe747e92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/542d73aeffbdb33c2cf23d1a232da9d7fe747e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/542d73aeffbdb33c2cf23d1a232da9d7fe747e92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/542d73aeffbdb33c2cf23d1a232da9d7fe747e92/comments", "author": null, "committer": null, "parents": [{"sha": "dd1f09c21cbd573bd4fe5ba15b85e49cb77db515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd1f09c21cbd573bd4fe5ba15b85e49cb77db515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd1f09c21cbd573bd4fe5ba15b85e49cb77db515"}], "stats": {"total": 85, "additions": 60, "deletions": 25}, "files": [{"sha": "3da7b2ef53ed6fc86a9c302c69993f0954f8ce8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542d73aeffbdb33c2cf23d1a232da9d7fe747e92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542d73aeffbdb33c2cf23d1a232da9d7fe747e92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=542d73aeffbdb33c2cf23d1a232da9d7fe747e92", "patch": "@@ -1,3 +1,8 @@\n+2001-03-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* emit-rtl.c (remove_unnecessary_notes): Verify proper nesting\n+\tof block notes and exception handling notes.\n+\n 2001-03-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* fixinc/Makefile.in (FIXINC_DEFS): Add -DHAVE_CONFIG_H."}, {"sha": "6ac8ac155bc3a0a172ad956157d698e82fa34046", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542d73aeffbdb33c2cf23d1a232da9d7fe747e92/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542d73aeffbdb33c2cf23d1a232da9d7fe747e92/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=542d73aeffbdb33c2cf23d1a232da9d7fe747e92", "patch": "@@ -2825,8 +2825,11 @@ reorder_insns_with_line_notes (from, to, after)\n void\n remove_unnecessary_notes ()\n {\n+  rtx block_stack = NULL_RTX;\n+  rtx eh_stack = NULL_RTX;\n   rtx insn;\n   rtx next;\n+  rtx tmp;\n \n   /* We must not remove the first instruction in the function because\n      the compiler depends on the first instruction being a note.  */\n@@ -2839,55 +2842,78 @@ remove_unnecessary_notes ()\n       if (GET_CODE (insn) != NOTE)\n \tcontinue;\n \n-      /* By now, all notes indicating lexical blocks should have\n-\t NOTE_BLOCK filled in.  */\n-      if ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n-\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n-\t  && NOTE_BLOCK (insn) == NULL_TREE)\n-\tabort ();\n-\n-      /* Remove NOTE_INSN_DELETED notes.  */\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n-\tremove_insn (insn);\n-      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+      switch (NOTE_LINE_NUMBER (insn))\n \t{\n+\tcase NOTE_INSN_DELETED:\n+\t  remove_insn (insn);\n+\t  break;\n+\n+\tcase NOTE_INSN_EH_REGION_BEG:\n+\t  eh_stack = alloc_INSN_LIST (insn, eh_stack);\n+\t  break;\n+\n+\tcase NOTE_INSN_EH_REGION_END:\n+\t  /* Too many end notes.  */\n+\t  if (eh_stack == NULL_RTX)\n+\t    abort ();\n+\t  /* Mismatched nesting.  */\n+\t  if (NOTE_EH_HANDLER (XEXP (eh_stack, 0)) != NOTE_EH_HANDLER (insn))\n+\t    abort ();\n+\t  tmp = eh_stack;\n+\t  eh_stack = XEXP (eh_stack, 1);\n+\t  free_INSN_LIST_node (tmp);\n+\t  break;\n+\n+\tcase NOTE_INSN_BLOCK_BEG:\n+\t  /* By now, all notes indicating lexical blocks should have\n+\t     NOTE_BLOCK filled in.  */\n+\t  if (NOTE_BLOCK (insn) == NULL_TREE)\n+\t    abort ();\n+\t  block_stack = alloc_INSN_LIST (insn, block_stack);\n+\t  break;\n+\n+\tcase NOTE_INSN_BLOCK_END:\n+\t  /* Too many end notes.  */\n+\t  if (block_stack == NULL_RTX)\n+\t    abort ();\n+\t  /* Mismatched nesting.  */\n+\t  if (NOTE_BLOCK (XEXP (block_stack, 0)) != NOTE_BLOCK (insn))\n+\t    abort ();\n+\t  tmp = block_stack;\n+\t  block_stack = XEXP (block_stack, 1);\n+\t  free_INSN_LIST_node (tmp);\n+\n \t  /* Scan back to see if there are any non-note instructions\n \t     between INSN and the beginning of this block.  If not,\n \t     then there is no PC range in the generated code that will\n \t     actually be in this block, so there's no point in\n \t     remembering the existence of the block.  */\n-\t  rtx prev;\n-\n-\t  for (prev = PREV_INSN (insn); prev; prev = PREV_INSN (prev))\n+\t  for (tmp = PREV_INSN (insn); tmp ; tmp = PREV_INSN (tmp))\n \t    {\n \t      /* This block contains a real instruction.  Note that we\n \t\t don't include labels; if the only thing in the block\n \t\t is a label, then there are still no PC values that\n \t\t lie within the block.  */\n-\t      if (INSN_P (prev))\n+\t      if (INSN_P (tmp))\n \t\tbreak;\n \n \t      /* We're only interested in NOTEs.  */\n-\t      if (GET_CODE (prev) != NOTE)\n+\t      if (GET_CODE (tmp) != NOTE)\n \t\tcontinue;\n \n-\t      if (NOTE_LINE_NUMBER (prev) == NOTE_INSN_BLOCK_BEG)\n+\t      if (NOTE_LINE_NUMBER (tmp) == NOTE_INSN_BLOCK_BEG)\n \t\t{\n-\t\t  /* If the BLOCKs referred to by these notes don't\n-\t\t     match, then something is wrong with our BLOCK\n-\t\t     nesting structure.  */\n-\t\t  if (NOTE_BLOCK (prev) != NOTE_BLOCK (insn))\n-\t\t    abort ();\n-\n+\t\t  /* We just verified that this BLOCK matches us\n+\t\t     with the block_stack check above.  */\n \t\t  if (debug_ignore_block (NOTE_BLOCK (insn)))\n \t\t    {\n \t\t      BLOCK_DEAD (NOTE_BLOCK (insn)) = 1;\n-\t\t      remove_insn (prev);\n+\t\t      remove_insn (tmp);\n \t\t      remove_insn (insn);\n \t\t    }\n \t\t  break;\n \t\t}\n-\t      else if (NOTE_LINE_NUMBER (prev) == NOTE_INSN_BLOCK_END)\n+\t      else if (NOTE_LINE_NUMBER (tmp) == NOTE_INSN_BLOCK_END)\n \t\t/* There's a nested block.  We need to leave the\n \t\t   current block in place since otherwise the debugger\n \t\t   wouldn't be able to show symbols from our block in\n@@ -2896,6 +2922,10 @@ remove_unnecessary_notes ()\n \t    }\n \t}\n     }\n+\n+  /* Too many begin notes.  */\n+  if (block_stack || eh_stack)\n+    abort ();\n }\n \n \f"}]}