{"sha": "08b7516191a62e53819e24d08f2a413c84cf4925", "node_id": "C_kwDOANBUbNoAKDA4Yjc1MTYxOTFhNjJlNTM4MTllMjRkMDhmMmE0MTNjODRjZjQ5MjU", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-07T11:27:30Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-08T10:08:26Z"}, "message": "macros: Parse macro patterns properly in repetition\n\nCo-authored-by: philberty <philip.herron@embecosm.com>", "tree": {"sha": "12d649747e87c8266a84ea3e819876469145e905", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12d649747e87c8266a84ea3e819876469145e905"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08b7516191a62e53819e24d08f2a413c84cf4925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b7516191a62e53819e24d08f2a413c84cf4925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b7516191a62e53819e24d08f2a413c84cf4925", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b7516191a62e53819e24d08f2a413c84cf4925/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "865b6090a8f8981cdfc050ea2ee44abbe92de141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865b6090a8f8981cdfc050ea2ee44abbe92de141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/865b6090a8f8981cdfc050ea2ee44abbe92de141"}], "stats": {"total": 68, "additions": 47, "deletions": 21}, "files": [{"sha": "61ab626f101e7fea7b2a9646eb97d93cf2f364ae", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.cc", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b7516191a62e53819e24d08f2a413c84cf4925/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b7516191a62e53819e24d08f2a413c84cf4925/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc?ref=08b7516191a62e53819e24d08f2a413c84cf4925", "patch": "@@ -39,9 +39,6 @@ SubstituteCtx::substitute_repetition (\n {\n   rust_assert (pattern_end < macro.size ());\n \n-  rust_debug (\"pattern start: %lu\", pattern_start);\n-  rust_debug (\"pattern end: %lu\", pattern_end);\n-\n   std::vector<std::unique_ptr<AST::Token>> expanded;\n \n   // Find the first fragment and get the amount of repetitions that we should\n@@ -154,19 +151,57 @@ SubstituteCtx::substitute_token (size_t token_idx)\n \t// We need to parse up until the closing delimiter and expand this\n \t// fragment->n times.\n \trust_debug (\"expanding repetition\");\n-\tstd::vector<std::unique_ptr<AST::Token>> repetition_pattern;\n+\n+\t// We're in a context where macro repetitions have already been\n+\t// parsed and validated: This means that\n+\t// 1/ There will be no delimiters as that is an error\n+\t// 2/ There are no fragment specifiers anymore, which prevents us\n+\t// from reusing parser functions.\n+\t//\n+\t// Repetition patterns are also special in that they cannot contain\n+\t// \"rogue\" delimiters: For example, this is invalid, as they are\n+\t// parsed as MacroMatches and must contain a correct amount of\n+\t// delimiters.\n+\t// `$($e:expr ) )`\n+\t//            ^ rogue closing parenthesis\n+\t//\n+\t// With all of that in mind, we can simply skip ahead from one\n+\t// parenthesis to the other to find the pattern to expand. Of course,\n+\t// pairs of delimiters, including parentheses, are allowed.\n+\t// `$($e:expr ( ) )`\n+\t// Parentheses are the sole delimiter for which we need a special\n+\t// behavior since they delimit the repetition pattern\n+\n \tsize_t pattern_start = token_idx + 1;\n \tsize_t pattern_end = pattern_start;\n-\tfor (; pattern_end < macro.size ()\n-\t       && macro.at (pattern_end)->get_id () != RIGHT_PAREN;\n-\t     pattern_end++)\n-\t  ;\n+\tauto parentheses_stack = 0;\n+\tfor (size_t idx = pattern_start; idx < macro.size (); idx++)\n+\t  {\n+\t    if (macro.at (idx)->get_id () == LEFT_PAREN)\n+\t      {\n+\t\tparentheses_stack++;\n+\t      }\n+\t    else if (macro.at (idx)->get_id () == RIGHT_PAREN)\n+\t      {\n+\t\tif (parentheses_stack == 0)\n+\t\t  {\n+\t\t    pattern_end = idx;\n+\t\t    break;\n+\t\t  }\n+\t\tparentheses_stack--;\n+\t      }\n+\t  }\n+\n+\t// Unreachable case, but let's make sure we don't ever run into it\n+\trust_assert (pattern_end != pattern_start);\n \n \tstd::unique_ptr<AST::Token> separator_token = nullptr;\n-\t// FIXME: Can this go out of bounds?\n-\tauto &post_pattern_token = macro.at (pattern_end + 1);\n-\tif (!is_rep_op (post_pattern_token))\n-\t  separator_token = post_pattern_token->clone_token ();\n+\tif (pattern_end + 1 <= macro.size ())\n+\t  {\n+\t    auto &post_pattern_token = macro.at (pattern_end + 1);\n+\t    if (!is_rep_op (post_pattern_token))\n+\t      separator_token = post_pattern_token->clone_token ();\n+\t  }\n \n \t// Amount of tokens to skip\n \tauto to_skip = 0;\n@@ -178,15 +213,6 @@ SubstituteCtx::substitute_token (size_t token_idx)\n \tif (separator_token)\n \t  to_skip += 1;\n \n-\t// FIXME: This skips whitespaces... Is that okay??\n-\t// FIXME: Is there any existing parsing function that allows us to\n-\t// parse a macro pattern?\n-\n-\t// FIXME: Add error handling in the case we haven't found a matching\n-\t// closing delimiter\n-\n-\t// FIXME: We need to parse the repetition token now\n-\n \treturn {substitute_repetition (pattern_start, pattern_end,\n \t\t\t\t       std::move (separator_token)),\n \t\tpattern_end - pattern_start + to_skip};"}]}