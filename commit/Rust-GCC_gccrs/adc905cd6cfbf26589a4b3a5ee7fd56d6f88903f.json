{"sha": "adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRjOTA1Y2Q2Y2ZiZjI2NTg5YTRiM2E1ZWU3ZmQ1NmQ2Zjg4OTAzZg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2016-12-19T16:03:53Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2016-12-19T16:03:53Z"}, "message": "Makefile.am: Remove ISO_C_BINDING runtime functions.\n\n\t* Makefile.am: Remove ISO_C_BINDING runtime functions.\n\t* Makefile.in: Regenerate.\n\t* gfortran.map: Remove all __iso_c_binding_c_f_pointer_* symbols.\n\t* intrinsics/iso_c_binding.h: Remove.\n\t* intrinsics/iso_c_binding.c: Remove.\n\t* intrinsics/iso_c_generated_procs.c: Remove.\n\nFrom-SVN: r243801", "tree": {"sha": "ec51d68b0b0b4c68b8b234400fe96c7e66c43351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec51d68b0b0b4c68b8b234400fe96c7e66c43351"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bed192f40a5e2ff8edc9375c443473c0a966c5b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed192f40a5e2ff8edc9375c443473c0a966c5b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed192f40a5e2ff8edc9375c443473c0a966c5b5"}], "stats": {"total": 742, "additions": 9, "deletions": 733}, "files": [{"sha": "114b006b4099f5ba66b7ea34feaf863658035aa5", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f", "patch": "@@ -1,3 +1,12 @@\n+2016-12-19  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* Makefile.am: Remove ISO_C_BINDING runtime functions.\n+\t* Makefile.in: Regenerate.\n+\t* gfortran.map: Remove all __iso_c_binding_c_f_pointer_* symbols.\n+\t* intrinsics/iso_c_binding.h: Remove.\n+\t* intrinsics/iso_c_binding.c: Remove.\n+\t* intrinsics/iso_c_generated_procs.c: Remove.\n+\n 2016-12-19  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* Makefile.am: Remove intrinsics/bit_intrinsics.c."}, {"sha": "fed875e1493e62afa5c48e44d6bb0f17c9e29b5d", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f", "patch": "@@ -122,8 +122,6 @@ intrinsics/extends_type_of.c \\\n intrinsics/fnum.c \\\n intrinsics/ierrno.c \\\n intrinsics/ishftc.c \\\n-intrinsics/iso_c_generated_procs.c \\\n-intrinsics/iso_c_binding.c \\\n intrinsics/mvbits.c \\\n intrinsics/move_alloc.c \\\n intrinsics/pack_generic.c \\"}, {"sha": "80cf29ad8431519555af209fb654fc4aeac77978", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=adc905cd6cfbf26589a4b3a5ee7fd56d6f88903f", "patch": "@@ -966,27 +966,6 @@ GFORTRAN_1.0 {\n     _gfortran_unpack0_char;\n     _gfortran_unpack1;\n     _gfortran_unpack1_char;\n-    __iso_c_binding_c_f_pointer;\n-    __iso_c_binding_c_f_pointer_d0;\n-    __iso_c_binding_c_f_pointer_i1;\n-    __iso_c_binding_c_f_pointer_i2;\n-    __iso_c_binding_c_f_pointer_i4;\n-    __iso_c_binding_c_f_pointer_i8;\n-    __iso_c_binding_c_f_pointer_i16;\n-    __iso_c_binding_c_f_pointer_r4;\n-    __iso_c_binding_c_f_pointer_r8;\n-    __iso_c_binding_c_f_pointer_r10;\n-    __iso_c_binding_c_f_pointer_r16;\n-    __iso_c_binding_c_f_pointer_c4;\n-    __iso_c_binding_c_f_pointer_c8;\n-    __iso_c_binding_c_f_pointer_c10;\n-    __iso_c_binding_c_f_pointer_c16;\n-    __iso_c_binding_c_f_pointer_s0;\n-    __iso_c_binding_c_f_pointer_l1;\n-    __iso_c_binding_c_f_pointer_l2;\n-    __iso_c_binding_c_f_pointer_l4;\n-    __iso_c_binding_c_f_pointer_l8;\n-    __iso_c_binding_c_f_pointer_u0;\n   local:\n     *;\n };"}, {"sha": "bd80f3ddc542094fb18db109479628888e965cc7", "filename": "libgfortran/intrinsics/iso_c_binding.c", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed192f40a5e2ff8edc9375c443473c0a966c5b5/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed192f40a5e2ff8edc9375c443473c0a966c5b5/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.c?ref=bed192f40a5e2ff8edc9375c443473c0a966c5b5", "patch": "@@ -1,189 +0,0 @@\n-/* Implementation of the ISO_C_BINDING library helper functions.\n-   Copyright (C) 2007-2016 Free Software Foundation, Inc.\n-   Contributed by Christopher Rickett.\n-\n-This file is part of the GNU Fortran runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or\n-modify it under the terms of the GNU General Public\n-License as published by the Free Software Foundation; either\n-version 3 of the License, or (at your option) any later version.\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* Implement the functions and subroutines provided by the intrinsic\n-   iso_c_binding module.  */\n-\n-#include \"libgfortran.h\"\n-#include \"iso_c_binding.h\"\n-\n-#include <stdlib.h>\n-\n-\n-/* Set the fields of a Fortran pointer descriptor to point to the\n-   given C address.  It uses c_f_pointer_u0 for the common\n-   fields, and will set up the information necessary if this C address\n-   is to an array (i.e., offset, type, element size).  The parameter\n-   c_ptr_in represents the C address to have Fortran point to.  The\n-   parameter f_ptr_out is the Fortran pointer to associate with the C\n-   address.  The parameter shape is a one-dimensional array of integers\n-   specifying the upper bound(s) of the array pointed to by the given C\n-   address, if applicable.  The shape parameter is optional in Fortran,\n-   which will cause it to come in here as NULL.  The parameter type is\n-   the type of the data being pointed to (i.e.,libgfortran.h). The\n-   elem_size parameter is the size, in bytes, of the data element being\n-   pointed to.  If the address is for an array, then the size needs to\n-   be the size of a single element (i.e., for an array of doubles, it\n-   needs to be the number of bytes for the size of one double).  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer) (void *c_ptr_in,\n-                                    gfc_array_void *f_ptr_out,\n-                                    const array_t *shape,\n-                                    int type, int elemSize)\n-{\n-  if (shape != NULL)\n-    {\n-      f_ptr_out->offset = 0;\n-\n-      /* Set the necessary dtype field for all pointers.  */\n-      f_ptr_out->dtype = 0;\n-\n-      /* Put in the element size.  */\n-      f_ptr_out->dtype = f_ptr_out->dtype | (elemSize << GFC_DTYPE_SIZE_SHIFT);\n-\n-      /* Set the data type (e.g., BT_INTEGER).  */\n-      f_ptr_out->dtype = f_ptr_out->dtype | (type << GFC_DTYPE_TYPE_SHIFT);\n-    }\n-  \n-  /* Use the generic version of c_f_pointer to set common fields.  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer_u0) (c_ptr_in, f_ptr_out, shape);\n-}\n-\n-\n-/* A generic function to set the common fields of all descriptors, no\n-   matter whether it's to a scalar or an array.  Access is via the array\n-   descrptor macros. Parameter shape is a rank 1 array of integers\n-   containing the upper bound of each dimension of what f_ptr_out\n-   points to.  The length of this array must be EXACTLY the rank of\n-   what f_ptr_out points to, as required by the draft (J3/04-007).  If\n-   f_ptr_out points to a scalar, then this parameter will be NULL.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_u0) (void *c_ptr_in,\n-                                       gfc_array_void *f_ptr_out,\n-                                       const array_t *shape)\n-{\n-  int i = 0;\n-  int shapeSize = 0;\n-\n-  GFC_DESCRIPTOR_DATA (f_ptr_out) = c_ptr_in;\n-\n-  if (shape != NULL)\n-    {\n-      index_type source_stride, size;\n-      index_type str = 1;\n-      char *p;\n-\n-      f_ptr_out->offset = str;\n-      shapeSize = 0;\n-      p = shape->base_addr;\n-      size = GFC_DESCRIPTOR_SIZE(shape);\n-\n-      source_stride = GFC_DESCRIPTOR_STRIDE_BYTES(shape,0);\n-\n-      /* shape's length (rank of the output array) */\n-      shapeSize = GFC_DESCRIPTOR_EXTENT(shape,0);\n-      for (i = 0; i < shapeSize; i++)\n-        {\n-\t  index_type ub;\n-\n-          /* Have to allow for the SHAPE array to be any valid kind for\n-             an INTEGER type.  */\n-\t  switch (size)\n-\t    {\n-#ifdef HAVE_GFC_INTEGER_1\n-\t      case 1:\n-\t\tub = *((GFC_INTEGER_1 *) p);\n-\t\tbreak;\n-#endif\n-#ifdef HAVE_GFC_INTEGER_2\n-\t      case 2:\n-\t\tub = *((GFC_INTEGER_2 *) p);\n-\t\tbreak;\n-#endif\n-#ifdef HAVE_GFC_INTEGER_4\n-\t      case 4:\n-\t\tub = *((GFC_INTEGER_4 *) p);\n-\t\tbreak;\n-#endif\n-#ifdef HAVE_GFC_INTEGER_8\n-\t      case 8:\n-\t\tub = *((GFC_INTEGER_8 *) p);\n-\t\tbreak;\n-#endif\n-#ifdef HAVE_GFC_INTEGER_16\n-\t      case 16:\n-\t\tub = *((GFC_INTEGER_16 *) p);\n-\t\tbreak;\n-#endif\n-\t      default:\n-\t\tinternal_error (NULL, \"c_f_pointer_u0: Invalid size\");\n-\t    }\n-\t  p += source_stride;\n-\n-\t  if (i != 0)\n-\t    {\n-\t      str = str * GFC_DESCRIPTOR_EXTENT(f_ptr_out,i-1);\n-\t      f_ptr_out->offset += str;\n-\t    }\n-\n-          /* Lower bound is 1, as specified by the draft.  */\n-\t  GFC_DIMENSION_SET(f_ptr_out->dim[i], 1, ub, str);\n-        }\n-\n-      f_ptr_out->offset *= -1;\n-\n-      /* All we know is the rank, so set it, leaving the rest alone.\n-         Make NO assumptions about the state of dtype coming in!  If we\n-         shift right by TYPE_SHIFT bits we'll throw away the existing\n-         rank.  Then, shift left by the same number to shift in zeros\n-         and or with the new rank.  */\n-      f_ptr_out->dtype = ((f_ptr_out->dtype >> GFC_DTYPE_TYPE_SHIFT)\n-                           << GFC_DTYPE_TYPE_SHIFT) | shapeSize;\n-    }\n-}\n-\n-\n-/* Sets the descriptor fields for a Fortran pointer to a derived type,\n-   using c_f_pointer_u0 for the majority of the work.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_d0) (void *c_ptr_in,\n-                                       gfc_array_void *f_ptr_out,\n-                                       const array_t *shape)\n-{\n-  /* Set the common fields.  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer_u0) (c_ptr_in, f_ptr_out, shape);\n-\n-  /* Preserve the size and rank bits, but reset the type.  */\n-  if (shape != NULL)\n-    {\n-      f_ptr_out->dtype = f_ptr_out->dtype & (~GFC_DTYPE_TYPE_MASK);\n-      f_ptr_out->dtype = f_ptr_out->dtype\n-\t\t\t | (BT_DERIVED << GFC_DTYPE_TYPE_SHIFT);\n-    }\n-}"}, {"sha": "a5e1767be4f5e146c18fd53594dbc6cef291e104", "filename": "libgfortran/intrinsics/iso_c_binding.h", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed192f40a5e2ff8edc9375c443473c0a966c5b5/libgfortran%2Fintrinsics%2Fiso_c_binding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed192f40a5e2ff8edc9375c443473c0a966c5b5/libgfortran%2Fintrinsics%2Fiso_c_binding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.h?ref=bed192f40a5e2ff8edc9375c443473c0a966c5b5", "patch": "@@ -1,55 +0,0 @@\n-/* Copyright (C) 2007-2016 Free Software Foundation, Inc.\n-   Contributed by Christopher Rickett.\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* Declarations for ISO_C_BINDING library helper functions.  */\n-\n-#ifndef GFOR_ISO_C_BINDING_H\n-#define GFOR_ISO_C_BINDING_H\n-\n-#include \"libgfortran.h\"\n-\n-typedef struct c_ptr\n-{\n-  void *c_address;\n-}\n-c_ptr_t;\n-\n-typedef struct c_funptr\n-{\n-  void *c_address;\n-}\n-c_funptr_t;\n-\n-#define ISO_C_BINDING_PREFIX(a) __iso_c_binding_##a\n-\n-void ISO_C_BINDING_PREFIX(c_f_pointer)(void *, gfc_array_void *,\n-\t\t\t\t       const array_t *, int, int);\n-\n-void ISO_C_BINDING_PREFIX(c_f_pointer_u0) (void *, gfc_array_void *,\n-\t\t\t\t\t   const array_t *);\n-void ISO_C_BINDING_PREFIX(c_f_pointer_d0) (void *, gfc_array_void *,\n-\t\t\t\t\t   const array_t *);\n-\n-#endif"}, {"sha": "9c2ea63642cd01b5f40a827764adf269847717c1", "filename": "libgfortran/intrinsics/iso_c_generated_procs.c", "status": "removed", "additions": 0, "deletions": 466, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed192f40a5e2ff8edc9375c443473c0a966c5b5/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed192f40a5e2ff8edc9375c443473c0a966c5b5/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c?ref=bed192f40a5e2ff8edc9375c443473c0a966c5b5", "patch": "@@ -1,466 +0,0 @@\n-/* Implementation of the ISO_C_BINDING library helper generated functions.\n-   Copyright (C) 2007-2016 Free Software Foundation, Inc.\n-   Contributed by Christopher Rickett.\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or\n-modify it under the terms of the GNU General Public\n-License as published by the Free Software Foundation; either\n-version 3 of the License, or (at your option) any later version.\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"libgfortran.h\"\n-#include \"iso_c_binding.h\"\n-\n-\n-/* TODO: This file needs to be finished so that a function is provided\n-   for all possible type/kind combinations!  */\n-\n-#ifdef HAVE_GFC_INTEGER_1\n-void ISO_C_BINDING_PREFIX (c_f_pointer_i1) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_INTEGER_2\n-void ISO_C_BINDING_PREFIX (c_f_pointer_i2) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_INTEGER_4\n-void ISO_C_BINDING_PREFIX (c_f_pointer_i4) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_INTEGER_8\n-void ISO_C_BINDING_PREFIX (c_f_pointer_i8) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_INTEGER_16\n-void ISO_C_BINDING_PREFIX (c_f_pointer_i16) (void *, gfc_array_void *,\n-\t\t\t\t\t     const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_REAL_4\n-void ISO_C_BINDING_PREFIX (c_f_pointer_r4) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_REAL_8\n-void ISO_C_BINDING_PREFIX (c_f_pointer_r8) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_REAL_10\n-void ISO_C_BINDING_PREFIX (c_f_pointer_r10) (void *, gfc_array_void *,\n-\t\t\t\t\t     const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_REAL_16\n-void ISO_C_BINDING_PREFIX (c_f_pointer_r16) (void *, gfc_array_void *,\n-\t\t\t\t\t     const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_COMPLEX_4\n-void ISO_C_BINDING_PREFIX (c_f_pointer_c4) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_COMPLEX_8\n-void ISO_C_BINDING_PREFIX (c_f_pointer_c8) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_COMPLEX_10\n-void ISO_C_BINDING_PREFIX (c_f_pointer_c10) (void *, gfc_array_void *,\n-\t\t\t\t\t     const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_COMPLEX_16\n-void ISO_C_BINDING_PREFIX (c_f_pointer_c16) (void *, gfc_array_void *,\n-\t\t\t\t\t     const array_t *);\n-#endif\n-\n-#ifdef GFC_DEFAULT_CHAR\n-void ISO_C_BINDING_PREFIX (c_f_pointer_s0) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_LOGICAL_1\n-void ISO_C_BINDING_PREFIX (c_f_pointer_l1) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_LOGICAL_2\n-void ISO_C_BINDING_PREFIX (c_f_pointer_l2) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_LOGICAL_4\n-void ISO_C_BINDING_PREFIX (c_f_pointer_l4) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-#ifdef HAVE_GFC_LOGICAL_8\n-void ISO_C_BINDING_PREFIX (c_f_pointer_l8) (void *, gfc_array_void *,\n-\t\t\t\t\t    const array_t *);\n-#endif\n-\n-\n-#ifdef HAVE_GFC_INTEGER_1\n-/* Set the given Fortran pointer, 'f_ptr_out', to point to the given C\n-   address, 'c_ptr_in'.  The Fortran pointer is of type integer and\n-   kind=1.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  shape is a one-dimensional array of integers\n-   specifying the upper bounds of the array pointed to by the given C\n-   address, if applicable.  'shape' is an optional parameter in\n-   Fortran, so if the user does not provide it, it will come in here\n-   as NULL.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_i1) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an integer(kind=1).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_INTEGER,\n-\t\t\t\t      (int) sizeof (GFC_INTEGER_1));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_INTEGER_2\n-/* Set the given Fortran pointer, 'f_ptr_out', to point to the given C\n-   address, 'c_ptr_in'.  The Fortran pointer is of type integer and\n-   kind=2.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  shape is a one-dimensional array of integers\n-   specifying the upper bounds of the array pointed to by the given C\n-   address, if applicable.  'shape' is an optional parameter in\n-   Fortran, so if the user does not provide it, it will come in here\n-   as NULL.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_i2) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an integer(kind=2).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_INTEGER,\n-\t\t\t\t      (int) sizeof (GFC_INTEGER_2));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_INTEGER_4\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type integer and\n-   kind=4.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_i4) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an integer(kind=4).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_INTEGER,\n-\t\t\t\t      (int) sizeof (GFC_INTEGER_4));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_INTEGER_8\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type integer and\n-   kind=8.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_i8) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an integer(kind=8).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_INTEGER,\n-\t\t\t\t      (int) sizeof (GFC_INTEGER_8));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_INTEGER_16\n-/* Set the given Fortran pointer, 'f_ptr_out', to point to the given C\n-   address, 'c_ptr_in'.  The Fortran pointer is of type integer and\n-   kind=16.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  shape is a one-dimensional array of integers\n-   specifying the upper bounds of the array pointed to by the given C\n-   address, if applicable.  'shape' is an optional parameter in\n-   Fortran, so if the user does not provide it, it will come in here\n-   as NULL.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_i16) (void *c_ptr_in,\n-\t\t\t\t\tgfc_array_void *f_ptr_out,\n-\t\t\t\t\tconst array_t *shape)\n-{\n-  /* Here we have an integer(kind=16).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_INTEGER,\n-\t\t\t\t      (int) sizeof (GFC_INTEGER_16));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_REAL_4\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type real and\n-   kind=4.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_r4) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an real(kind=4).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_REAL,\n-\t\t\t\t      (int) sizeof (GFC_REAL_4));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_REAL_8\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type real and\n-   kind=8.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_r8) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an real(kind=8).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_REAL,\n-\t\t\t\t      (int) sizeof (GFC_REAL_8));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_REAL_10\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type real and\n-   kind=10.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_r10) (void *c_ptr_in,\n-\t\t\t\t\tgfc_array_void *f_ptr_out,\n-\t\t\t\t\tconst array_t *shape)\n-{\n-  /* Here we have an real(kind=10).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_REAL,\n-\t\t\t\t      (int) sizeof (GFC_REAL_10));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_REAL_16\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type real and\n-   kind=16.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_r16) (void *c_ptr_in,\n-\t\t\t\t\tgfc_array_void *f_ptr_out,\n-\t\t\t\t\tconst array_t *shape)\n-{\n-  /* Here we have an real(kind=16).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_REAL,\n-\t\t\t\t      (int) sizeof (GFC_REAL_16));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_COMPLEX_4\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type complex and\n-   kind=4.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_c4) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an complex(kind=4).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_COMPLEX,\n-\t\t\t\t      (int) sizeof (GFC_COMPLEX_4));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_COMPLEX_8\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type complex and\n-   kind=8.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_c8) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have an complex(kind=8).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_COMPLEX,\n-\t\t\t\t      (int) sizeof (GFC_COMPLEX_8));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_COMPLEX_10\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type complex and\n-   kind=10.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_c10) (void *c_ptr_in,\n-\t\t\t\t\tgfc_array_void *f_ptr_out,\n-\t\t\t\t\tconst array_t *shape)\n-{\n-  /* Here we have an complex(kind=10).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_COMPLEX,\n-\t\t\t\t      (int) sizeof (GFC_COMPLEX_10));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_COMPLEX_16\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type complex and\n-   kind=16.  The function c_f_pointer is used to set up the pointer\n-   descriptor.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_c16) (void *c_ptr_in,\n-\t\t\t\t\tgfc_array_void *f_ptr_out,\n-\t\t\t\t\tconst array_t *shape)\n-{\n-  /* Here we have an complex(kind=16).  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_COMPLEX,\n-\t\t\t\t      (int) sizeof (GFC_COMPLEX_16));\n-}\n-#endif\n-\n-\n-#ifdef GFC_DEFAULT_CHAR\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type character.  */\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_s0) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have a character string of len=1.  */\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_CHARACTER,\n-\t\t\t\t      (int) sizeof (char));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_LOGICAL_1\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type logical, kind=1.\t*/\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_l1) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have a logical of kind=1.\t*/\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_LOGICAL,\n-\t\t\t\t      (int) sizeof (GFC_LOGICAL_1));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_LOGICAL_2\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type logical, kind=2.\t*/\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_l2) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have a logical of kind=2.\t*/\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_LOGICAL,\n-\t\t\t\t      (int) sizeof (GFC_LOGICAL_2));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_LOGICAL_4\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type logical, kind=4.\t*/\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_l4) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have a logical of kind=4.\t*/\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_LOGICAL,\n-\t\t\t\t      (int) sizeof (GFC_LOGICAL_4));\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GFC_LOGICAL_8\n-/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n-   address, c_ptr_in.  The Fortran pointer is of type logical, kind=8.\t*/\n-\n-void\n-ISO_C_BINDING_PREFIX (c_f_pointer_l8) (void *c_ptr_in,\n-\t\t\t\t       gfc_array_void *f_ptr_out,\n-\t\t\t\t       const array_t *shape)\n-{\n-  /* Here we have a logical of kind=8.\t*/\n-  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n-\t\t\t\t      (int) BT_LOGICAL,\n-\t\t\t\t      (int) sizeof (GFC_LOGICAL_8));\n-}\n-#endif"}]}