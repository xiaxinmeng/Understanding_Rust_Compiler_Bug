{"sha": "79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzliNGE4ZGNmYjNlNzJiYmUwNThlOWMxY2IwMmIzOTQxZTkwZTQ2OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-11T11:20:44Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-11T11:20:44Z"}, "message": "expmed.c (init_expmed): Use stack-local structures for temporary rtl.\n\n        * expmed.c (init_expmed): Use stack-local structures for\n        temporary rtl.  Don't recognize shifts.\n\nFrom-SVN: r84502", "tree": {"sha": "1c15a7b39aa5494cdf3df51907ab040afa5bf582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c15a7b39aa5494cdf3df51907ab040afa5bf582"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468/comments", "author": null, "committer": null, "parents": [{"sha": "7e7d1b4b3f489aa357f5ba5979712bd2420ffd50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7d1b4b3f489aa357f5ba5979712bd2420ffd50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e7d1b4b3f489aa357f5ba5979712bd2420ffd50"}], "stats": {"total": 201, "additions": 119, "deletions": 82}, "files": [{"sha": "03d7804a6df1a31f92bcf4ccc21835d2a3b91e61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468", "patch": "@@ -1,3 +1,8 @@\n+2004-07-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* expmed.c (init_expmed): Use stack-local structures for \n+\ttemporary rtl.  Don't recognize shifts.\n+\n 2004-07-11  Richard Henderson  <rth@redhat.com>\n \n \t* expr.c (store_expr): Don't fiddle subreg promotion for types"}, {"sha": "c1f9873e978148d5eebdc1e7394baf75d0ad1292", "filename": "gcc/expmed.c", "status": "modified", "additions": 114, "deletions": 82, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=79b4a8dcfb3e72bbe058e9c1cb02b3941e90e468", "patch": "@@ -106,112 +106,144 @@ static int mul_highpart_cost[NUM_MACHINE_MODES];\n void\n init_expmed (void)\n {\n-  rtx reg, shift_insn, shiftadd_insn, shiftsub_insn;\n-  rtx shift_pat, shiftadd_pat, shiftsub_pat;\n+  struct\n+  {\n+    struct rtx_def reg;\n+    struct rtx_def plus;\trtunion plus_fld1;\n+    struct rtx_def neg;\n+    struct rtx_def udiv;\trtunion udiv_fld1;\n+    struct rtx_def mult;\trtunion mult_fld1;\n+    struct rtx_def div;\t\trtunion div_fld1;\n+    struct rtx_def mod;\t\trtunion mod_fld1;\n+    struct rtx_def zext;\n+    struct rtx_def wide_mult;\trtunion wide_mult_fld1;\n+    struct rtx_def wide_lshr;\trtunion wide_lshr_fld1;\n+    struct rtx_def wide_trunc;\n+    struct rtx_def shift;\trtunion shift_fld1;\n+    struct rtx_def shift_mult;\trtunion shift_mult_fld1;\n+    struct rtx_def shift_add;\trtunion shift_add_fld1;\n+    struct rtx_def shift_sub;\trtunion shift_sub_fld1;\n+  } all;\n+\n   rtx pow2[MAX_BITS_PER_WORD];\n   rtx cint[MAX_BITS_PER_WORD];\n-  int dummy;\n   int m, n;\n   enum machine_mode mode, wider_mode;\n \n-  start_sequence ();\n-\n   zero_cost = rtx_cost (const0_rtx, 0);\n \n-  init_recog ();\n-\n   for (m = 1; m < MAX_BITS_PER_WORD; m++)\n     {\n       pow2[m] = GEN_INT ((HOST_WIDE_INT) 1 << m);\n       cint[m] = GEN_INT (m);\n     }\n \n+  memset (&all, 0, sizeof all);\n+\n+  PUT_CODE (&all.reg, REG);\n+  REGNO (&all.reg) = 10000;\n+\n+  PUT_CODE (&all.plus, PLUS);\n+  XEXP (&all.plus, 0) = &all.reg;\n+  XEXP (&all.plus, 1) = &all.reg;\n+\n+  PUT_CODE (&all.neg, NEG);\n+  XEXP (&all.neg, 0) = &all.reg;\n+\n+  PUT_CODE (&all.udiv, UDIV);\n+  XEXP (&all.udiv, 0) = &all.reg;\n+  XEXP (&all.udiv, 1) = &all.reg;\n+\n+  PUT_CODE (&all.mult, MULT);\n+  XEXP (&all.mult, 0) = &all.reg;\n+  XEXP (&all.mult, 1) = &all.reg;\n+\n+  PUT_CODE (&all.div, DIV);\n+  XEXP (&all.div, 0) = &all.reg;\n+  XEXP (&all.div, 1) = 32 < MAX_BITS_PER_WORD ? cint[32] : GEN_INT (32);\n+\n+  PUT_CODE (&all.mod, MOD);\n+  XEXP (&all.mod, 0) = &all.reg;\n+  XEXP (&all.mod, 1) = XEXP (&all.div, 1);\n+\n+  PUT_CODE (&all.zext, ZERO_EXTEND);\n+  XEXP (&all.zext, 0) = &all.reg;\n+\n+  PUT_CODE (&all.wide_mult, MULT);\n+  XEXP (&all.wide_mult, 0) = &all.zext;\n+  XEXP (&all.wide_mult, 1) = &all.zext;\n+\n+  PUT_CODE (&all.wide_lshr, LSHIFTRT);\n+  XEXP (&all.wide_lshr, 0) = &all.wide_mult;\n+\n+  PUT_CODE (&all.wide_trunc, TRUNCATE);\n+  XEXP (&all.wide_trunc, 0) = &all.wide_lshr;\n+\n+  PUT_CODE (&all.shift, ASHIFT);\n+  XEXP (&all.shift, 0) = &all.reg;\n+\n+  PUT_CODE (&all.shift_mult, MULT);\n+  XEXP (&all.shift_mult, 0) = &all.reg;\n+\n+  PUT_CODE (&all.shift_add, PLUS);\n+  XEXP (&all.shift_add, 0) = &all.shift_mult;\n+  XEXP (&all.shift_add, 1) = &all.reg;\n+\n+  PUT_CODE (&all.shift_sub, MINUS);\n+  XEXP (&all.shift_sub, 0) = &all.shift_mult;\n+  XEXP (&all.shift_sub, 1) = &all.reg;\n+\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      reg = gen_rtx_REG (mode, 10000);\n-      add_cost[mode] = rtx_cost (gen_rtx_PLUS (mode, reg, reg), SET);\n-      neg_cost[mode] = rtx_cost (gen_rtx_NEG (mode, reg), SET);\n-      div_cost[mode] = rtx_cost (gen_rtx_UDIV (mode, reg, reg), SET);\n-      mul_cost[mode] = rtx_cost (gen_rtx_MULT (mode, reg, reg), SET);\n-\n-      sdiv_pow2_cheap[mode]\n-\t= (rtx_cost (gen_rtx_DIV (mode, reg, GEN_INT (32)), SET)\n-\t   <= 2 * add_cost[mode]);\n-      smod_pow2_cheap[mode]\n-\t= (rtx_cost (gen_rtx_MOD (mode, reg, GEN_INT (32)), SET)\n-\t   <= 2 * add_cost[mode]);\n+      PUT_MODE (&all.reg, mode);\n+      PUT_MODE (&all.plus, mode);\n+      PUT_MODE (&all.neg, mode);\n+      PUT_MODE (&all.udiv, mode);\n+      PUT_MODE (&all.mult, mode);\n+      PUT_MODE (&all.div, mode);\n+      PUT_MODE (&all.mod, mode);\n+      PUT_MODE (&all.wide_trunc, mode);\n+      PUT_MODE (&all.shift, mode);\n+      PUT_MODE (&all.shift_mult, mode);\n+      PUT_MODE (&all.shift_add, mode);\n+      PUT_MODE (&all.shift_sub, mode);\n+\n+      add_cost[mode] = rtx_cost (&all.plus, SET);\n+      neg_cost[mode] = rtx_cost (&all.neg, SET);\n+      div_cost[mode] = rtx_cost (&all.udiv, SET);\n+      mul_cost[mode] = rtx_cost (&all.mult, SET);\n+\n+      sdiv_pow2_cheap[mode] = (rtx_cost (&all.div, SET) <= 2 * add_cost[mode]);\n+      smod_pow2_cheap[mode] = (rtx_cost (&all.mod, SET) <= 2 * add_cost[mode]);\n \n       wider_mode = GET_MODE_WIDER_MODE (mode);\n       if (wider_mode != VOIDmode)\n \t{\n-\t  mul_widen_cost[wider_mode]\n-\t    = rtx_cost (gen_rtx_MULT (wider_mode,\n-\t\t\t\t      gen_rtx_ZERO_EXTEND (wider_mode, reg),\n-\t\t\t\t      gen_rtx_ZERO_EXTEND (wider_mode, reg)),\n-\t\t\tSET);\n-\t  mul_highpart_cost[mode]\n-\t    = rtx_cost (gen_rtx_TRUNCATE\n-\t\t\t(mode,\n-\t\t\t gen_rtx_LSHIFTRT (wider_mode,\n-\t\t\t\t\t   gen_rtx_MULT (wider_mode,\n-\t\t\t\t\t\t\t gen_rtx_ZERO_EXTEND\n-\t\t\t\t\t\t\t (wider_mode, reg),\n-\t\t\t\t\t\t\t gen_rtx_ZERO_EXTEND\n-\t\t\t\t\t\t\t (wider_mode, reg)),\n-\t\t\t\t\t   GEN_INT (GET_MODE_BITSIZE (mode)))),\n-\t\t\tSET);\n+\t  PUT_MODE (&all.zext, wider_mode);\n+\t  PUT_MODE (&all.wide_mult, wider_mode);\n+\t  PUT_MODE (&all.wide_lshr, wider_mode);\n+\t  XEXP (&all.wide_lshr, 1) = GEN_INT (GET_MODE_BITSIZE (mode));\n+\n+\t  mul_widen_cost[wider_mode] = rtx_cost (&all.wide_mult, SET);\n+\t  mul_highpart_cost[mode] = rtx_cost (&all.wide_trunc, SET);\n \t}\n \n-\tshift_insn = emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t\t\t     gen_rtx_ASHIFT (mode, reg,\n-\t\t\t\t\t\t\t     const0_rtx)));\n-\n-\tshiftadd_insn\n-\t  = emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t\t    gen_rtx_PLUS (mode,\n-\t\t\t\t\t\t  gen_rtx_MULT (mode,\n-\t\t\t\t\t\t\t\treg,\n-\t\t\t\t\t\t\t\tconst0_rtx),\n-\t\t\t\t\t\t  reg)));\n-\n-\tshiftsub_insn\n-\t  = emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t\t    gen_rtx_MINUS (mode,\n-\t\t\t\t\t\t   gen_rtx_MULT (mode,\n-\t\t\t\t\t\t\t\t reg,\n-\t\t\t\t\t\t\t\t const0_rtx),\n-\t\t\t\t\t\t   reg)));\n-\n-\tshift_pat = PATTERN (shift_insn);\n-\tshiftadd_pat = PATTERN (shiftadd_insn);\n-\tshiftsub_pat = PATTERN (shiftsub_insn);\n-\n-\tshift_cost[mode][0] = 0;\n-\tshiftadd_cost[mode][0] = shiftsub_cost[mode][0] = add_cost[mode];\n-\n-\tn = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n-\tfor (m = 1; m < n; m++)\n-\t  {\n-\t    shift_cost[mode][m] = 32000;\n-\t    XEXP (SET_SRC (shift_pat), 1) = cint[m];\n-\t    if (recog (shift_pat, shift_insn, &dummy) >= 0)\n-\t      shift_cost[mode][m] = rtx_cost (SET_SRC (shift_pat), SET);\n-\n-\t    shiftadd_cost[mode][m] = 32000;\n-\t    XEXP (XEXP (SET_SRC (shiftadd_pat), 0), 1) = pow2[m];\n-\t    if (recog (shiftadd_pat, shiftadd_insn, &dummy) >= 0)\n-\t      shiftadd_cost[mode][m] = rtx_cost (SET_SRC (shiftadd_pat), SET);\n-\n-\t    shiftsub_cost[mode][m] = 32000;\n-\t    XEXP (XEXP (SET_SRC (shiftsub_pat), 0), 1) = pow2[m];\n-\t    if (recog (shiftsub_pat, shiftsub_insn, &dummy) >= 0)\n-\t      shiftsub_cost[mode][m] = rtx_cost (SET_SRC (shiftsub_pat), SET);\n-\t  }\n-    }\n+      shift_cost[mode][0] = 0;\n+      shiftadd_cost[mode][0] = shiftsub_cost[mode][0] = add_cost[mode];\n \n-  end_sequence ();\n+      n = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n+      for (m = 1; m < n; m++)\n+\t{\n+\t  XEXP (&all.shift, 1) = cint[m];\n+\t  XEXP (&all.shift_mult, 1) = pow2[m];\n+\n+\t  shift_cost[mode][m] = rtx_cost (&all.shift, SET);\n+\t  shiftadd_cost[mode][m] = rtx_cost (&all.shift_add, SET);\n+\t  shiftsub_cost[mode][m] = rtx_cost (&all.shift_sub, SET);\n+\t}\n+    }\n }\n \n /* Return an rtx representing minus the value of X."}]}