{"sha": "530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMwZjNhMWJmNjI5NjRjMGM1MmQ2ZmNmNGNhMGQzMjFjZTlkNTE1Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-10-26T16:40:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-10-26T16:40:16Z"}, "message": "re PR lto/45736 (ICE: in cgraph_remove_unreachable_nodes, at ipa.c:245 with -flto and attribute((constructor)))\n\n\n\tPR middle-end/45736\n\t* cgraph.c (cgraph_set_readonly_flag): Rename to...\n\t(cgraph_set_const_flags) ... this one; get also looping argument;\n\tclear constructor/destructor flags.\n\t(cgraph_set_pure_flag): Likewise.\n\t(cgraph_set_looping_const_or_pure_flag): Remove.\n\t(cgraph_can_remove_if_no_direct_calls_and_refs): Do not try\n\tto optimize away static ctors/dtors; it does not work on inline clones;\n\texternal functions can always be rmeoved.\n\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Assert on inline\n\tclones; in LTO external functions always can go.\n\t(cgraph_used_from_object_file_p): Handle EXTERNAL functions correctly.\n\t(cgraph_mark_address_taken_node): Assert that we are not taking address of\n\tinline clone.\n\t(cgraph_can_remove_if_no_direct_calls_p): We always eventually remove\n\texternal functions.\n\t* ipa-cp.c (ipcp_cloning_candidate_p): Do not clone functions with address taken.\n\t(ipcp_initialize_node_lattices): Only local functions can be handled without cloning.\n\t* cgraph.h (cgraph_set_readonly_flag,\n\tcgraph_set_looping_const_or_pure_flag): Remove.\n\t(cgraph_set_const_flag): Declare.\n\t(cgraph_set_pure_flag): Update.\n\t* ipa-pure-const (propagate_pure_const, local_pure_const): Update\n\tflags setting code.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Fix formating; do not look at inline\n\tclones; fix handling of external definitions.\n\t(cgraph_postorder): Do not look at inline clones in the first pass.\n\t(function_and_variable_visibility): Drop constructors/destructor\n\tflags at pure and const functions.\n\t* tree-profile.c (tree_profiling): Update.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Always clone functions with\n\taddress taken; external functions do not account to whole program size.\n\t(cgraph_decide_inlining): Likewise; do not try to inline functions already\n\tinlined.\n\t* testsuite/gcc.dg/lto/pr45736_0.c: New function.\n\nFrom-SVN: r165972", "tree": {"sha": "f4fc3981e343130fc38f5d142b14b9d00708d62f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4fc3981e343130fc38f5d142b14b9d00708d62f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/comments", "author": null, "committer": null, "parents": [{"sha": "0d600fce5ba0aae8073f84b9c5f9296233f6f269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d600fce5ba0aae8073f84b9c5f9296233f6f269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d600fce5ba0aae8073f84b9c5f9296233f6f269"}], "stats": {"total": 212, "additions": 151, "deletions": 61}, "files": [{"sha": "48d6bdd9522315b214a120e286c9e67aee07855b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -1,3 +1,40 @@\n+2010-10-26  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/45736\n+\t* cgraph.c (cgraph_set_readonly_flag): Rename to...\n+\t(cgraph_set_const_flags) ... this one; get also looping argument;\n+\tclear constructor/destructor flags.\n+\t(cgraph_set_pure_flag): Likewise.\n+\t(cgraph_set_looping_const_or_pure_flag): Remove.\n+\t(cgraph_can_remove_if_no_direct_calls_and_refs): Do not try\n+\tto optimize away static ctors/dtors; it does not work on inline clones;\n+\texternal functions can always be rmeoved.\n+\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Assert on inline\n+\tclones; in LTO external functions always can go.\n+\t(cgraph_used_from_object_file_p): Handle EXTERNAL functions correctly.\n+\t(cgraph_mark_address_taken_node): Assert that we are not taking address of\n+\tinline clone.\n+\t(cgraph_can_remove_if_no_direct_calls_p): We always eventually remove\n+\texternal functions.\n+\t* ipa-cp.c (ipcp_cloning_candidate_p): Do not clone functions with address taken.\n+\t(ipcp_initialize_node_lattices): Only local functions can be handled without cloning.\n+\t* cgraph.h (cgraph_set_readonly_flag,\n+\tcgraph_set_looping_const_or_pure_flag): Remove.\n+\t(cgraph_set_const_flag): Declare.\n+\t(cgraph_set_pure_flag): Update.\n+\t* ipa-pure-const (propagate_pure_const, local_pure_const): Update\n+\tflags setting code.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Fix formating; do not look at inline\n+\tclones; fix handling of external definitions.\n+\t(cgraph_postorder): Do not look at inline clones in the first pass.\n+\t(function_and_variable_visibility): Drop constructors/destructor\n+\tflags at pure and const functions.\n+\t* tree-profile.c (tree_profiling): Update.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Always clone functions with\n+\taddress taken; external functions do not account to whole program size.\n+\t(cgraph_decide_inlining): Likewise; do not try to inline functions already\n+\tinlined.\n+\n 2010-10-26  Jie Zhang  <jie@codesourcery.com>\n \n \t* doc/invoke.texi: Improve documentation of"}, {"sha": "1451d2bdd4c4b075b37194921f9ac6fe222aac8a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -1723,6 +1723,7 @@ cgraph_mark_needed_node (struct cgraph_node *node)\n void\n cgraph_mark_address_taken_node (struct cgraph_node *node)\n {\n+  gcc_assert (!node->global.inlined_to);\n   cgraph_mark_reachable_node (node);\n   node->address_taken = 1;\n }\n@@ -2591,37 +2592,50 @@ cgraph_set_nothrow_flag (struct cgraph_node *node, bool nothrow)\n    if any to READONLY.  */\n \n void\n-cgraph_set_readonly_flag (struct cgraph_node *node, bool readonly)\n+cgraph_set_const_flag (struct cgraph_node *node, bool readonly, bool looping)\n {\n   struct cgraph_node *alias;\n+  /* Static constructors and destructors without a side effect can be\n+     optimized out.  */\n+  if (!looping && readonly)\n+    {\n+      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n+\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+      if (DECL_STATIC_DESTRUCTOR (node->decl))\n+\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+    }\n   TREE_READONLY (node->decl) = readonly;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n   for (alias = node->same_body; alias; alias = alias->next)\n-    TREE_READONLY (alias->decl) = readonly;\n+    {\n+      TREE_READONLY (alias->decl) = readonly;\n+      DECL_LOOPING_CONST_OR_PURE_P (alias->decl) = looping;\n+    }\n }\n \n /* Set DECL_PURE_P on NODE's decl and on same_body aliases of NODE\n    if any to PURE.  */\n \n void\n-cgraph_set_pure_flag (struct cgraph_node *node, bool pure)\n+cgraph_set_pure_flag (struct cgraph_node *node, bool pure, bool looping)\n {\n   struct cgraph_node *alias;\n+  /* Static constructors and destructors without a side effect can be\n+     optimized out.  */\n+  if (!looping && pure)\n+    {\n+      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n+\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+      if (DECL_STATIC_DESTRUCTOR (node->decl))\n+\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+    }\n   DECL_PURE_P (node->decl) = pure;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n   for (alias = node->same_body; alias; alias = alias->next)\n-    DECL_PURE_P (alias->decl) = pure;\n-}\n-\n-/* Set DECL_LOOPING_CONST_OR_PURE_P on NODE's decl and on\n-   same_body aliases of NODE if any to LOOPING_CONST_OR_PURE.  */\n-\n-void\n-cgraph_set_looping_const_or_pure_flag (struct cgraph_node *node,\n-\t\t\t\t       bool looping_const_or_pure)\n-{\n-  struct cgraph_node *alias;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping_const_or_pure;\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    DECL_LOOPING_CONST_OR_PURE_P (alias->decl) = looping_const_or_pure;\n+    {\n+      DECL_PURE_P (alias->decl) = pure;\n+      DECL_LOOPING_CONST_OR_PURE_P (alias->decl) = looping;\n+    }\n }\n \n /* See if the frequency of NODE can be updated based on frequencies of its\n@@ -2768,25 +2782,21 @@ cgraph_edge_cannot_lead_to_return (struct cgraph_edge *e)\n bool\n cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n {\n+  gcc_assert (!node->global.inlined_to);\n+  /* Extern inlines can always go, we will use the external definition.  */\n+  if (DECL_EXTERNAL (node->decl))\n+    return true;\n   /* When function is needed, we can not remove it.  */\n   if (node->needed || node->reachable_from_other_partition)\n     return false;\n+  if (DECL_STATIC_CONSTRUCTOR (node->decl)\n+      || DECL_STATIC_DESTRUCTOR (node->decl))\n+    return false;\n   /* Only COMDAT functions can be removed if externally visible.  */\n   if (node->local.externally_visible\n       && (!DECL_COMDAT (node->decl)\n \t  || cgraph_used_from_object_file_p (node)))\n     return false;\n-  /* Constructors and destructors are executed by the runtime, however\n-     we can get rid of all pure constructors and destructors.  */\n-  if (DECL_STATIC_CONSTRUCTOR (node->decl)\n-      || DECL_STATIC_DESTRUCTOR (node->decl))\n-    {\n-      int flags = flags_from_decl_or_type (node->decl);\n-      if (!optimize\n-\t  || !(flags & (ECF_CONST | ECF_PURE))\n-\t  || (flags & ECF_LOOPING_CONST_OR_PURE))\n-\treturn false;\n-    }\n   return true;\n }\n \n@@ -2807,12 +2817,17 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n bool\n cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node)\n {\n+  gcc_assert (!node->global.inlined_to);\n   if (cgraph_used_from_object_file_p (node))\n     return false;\n   if (!in_lto_p && !flag_whole_program)\n     return cgraph_only_called_directly_p (node);\n   else\n-    return cgraph_can_remove_if_no_direct_calls_p (node);\n+    {\n+       if (DECL_EXTERNAL (node->decl))\n+         return true;\n+      return cgraph_can_remove_if_no_direct_calls_p (node);\n+    }\n }\n \n /* Return true when RESOLUTION indicate that linker will use\n@@ -2835,7 +2850,8 @@ cgraph_used_from_object_file_p (struct cgraph_node *node)\n {\n   struct cgraph_node *alias;\n \n-  if (!TREE_PUBLIC (node->decl))\n+  gcc_assert (!node->global.inlined_to);\n+  if (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n     return false;\n   if (resolution_used_from_other_file_p (node->resolution))\n     return true;"}, {"sha": "2b7ed4b8985dc757e1658622b78fb3e92365f693", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -602,9 +602,8 @@ struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \t\t\t\t\t\t  const char *clone_name);\n \n void cgraph_set_nothrow_flag (struct cgraph_node *, bool);\n-void cgraph_set_readonly_flag (struct cgraph_node *, bool);\n-void cgraph_set_pure_flag (struct cgraph_node *, bool);\n-void cgraph_set_looping_const_or_pure_flag (struct cgraph_node *, bool);\n+void cgraph_set_const_flag (struct cgraph_node *, bool, bool);\n+void cgraph_set_pure_flag (struct cgraph_node *, bool, bool);\n tree clone_function_name (tree decl, const char *);\n bool cgraph_node_cannot_return (struct cgraph_node *);\n bool cgraph_edge_cannot_lead_to_return (struct cgraph_edge *);\n@@ -909,6 +908,7 @@ varpool_node_set_nonempty_p (varpool_node_set set)\n static inline bool\n cgraph_only_called_directly_p (struct cgraph_node *node)\n {\n+  gcc_assert (!node->global.inlined_to);\n   return (!node->needed && !node->address_taken\n \t  && !node->reachable_from_other_partition\n \t  && !DECL_STATIC_CONSTRUCTOR (node->decl)\n@@ -922,6 +922,9 @@ cgraph_only_called_directly_p (struct cgraph_node *node)\n static inline bool\n cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n {\n+  /* Extern inlines can always go, we will use the external definition.  */\n+  if (DECL_EXTERNAL (node->decl))\n+    return true;\n   return !node->address_taken && cgraph_can_remove_if_no_direct_calls_and_refs_p (node);\n }\n "}, {"sha": "33ed496a2f015e7195a1ffd3bc787fde8448aa53", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -457,6 +457,15 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   if (cgraph_only_called_directly_p (node) || !node->analyzed)\n     return false;\n \n+  /* When function address is taken, we are pretty sure it will be called in hidden way.  */\n+  if (node->address_taken)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not considering %s for cloning; address is taken.\\n\",\n+ \t         cgraph_node_name (node));\n+      return false;\n+    }\n+\n   if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     {\n       if (dump_file)\n@@ -561,7 +570,7 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n \n   if (ipa_is_called_with_var_arguments (info))\n     type = IPA_BOTTOM;\n-  else if (cgraph_only_called_directly_p (node))\n+  else if (node->local.local)\n     type = IPA_TOP;\n   /* When cloning is allowed, we can assume that externally visible functions\n      are not called.  We will compensate this by cloning later.  */"}, {"sha": "7241dcb0d48a5fcd300cbaa3c3bc5c2e5821a9ce", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -250,6 +250,10 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n       /* We may eliminate the need for out-of-line copy to be output.\n \t In that case just go ahead and re-use it.  */\n       if (!e->callee->callers->next_caller\n+\t  /* FIXME: When address is taken of DECL_EXTERNAL function we still can remove its\n+\t     offline copy, but we would need to keep unanalyzed node in the callgraph so\n+\t     references can point to it.  */\n+\t  && !e->callee->address_taken\n \t  && cgraph_can_remove_if_no_direct_calls_p (e->callee)\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed.\n@@ -264,7 +268,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  && !cgraph_new_nodes)\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n-\t  if (e->callee->analyzed)\n+\t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->decl))\n \t    {\n \t      overall_size -= e->callee->global.size;\n \t      nfunctions_inlined++;\n@@ -1449,7 +1453,8 @@ cgraph_decide_inlining (void)\n \tstruct cgraph_edge *e;\n \n \tgcc_assert (inline_summary (node)->self_size == node->global.size);\n-\tinitial_size += node->global.size;\n+\tif (!DECL_EXTERNAL (node->decl))\n+\t  initial_size += node->global.size;\n \tfor (e = node->callees; e; e = e->next_callee)\n \t  if (max_count < e->count)\n \t    max_count = e->count;\n@@ -1512,6 +1517,7 @@ cgraph_decide_inlining (void)\n \n \t  if (node->callers\n \t      && !node->callers->next_caller\n+\t      && !node->global.inlined_to\n \t      && cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n \t      && node->local.inlinable\n \t      && cgraph_function_body_availability (node) >= AVAIL_AVAILABLE"}, {"sha": "d671643116ec8b972883658709a0a5f77d8f57c8", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -1322,8 +1322,7 @@ propagate_pure_const (void)\n \t\t\t     this_looping ? \"looping \" : \"\",\n \t\t\t     cgraph_node_name (w));\n \t\t}\n-\t      cgraph_set_readonly_flag (w, true);\n-\t      cgraph_set_looping_const_or_pure_flag (w, this_looping);\n+\t      cgraph_set_const_flag (w, true, this_looping);\n \t      break;\n \n \t    case IPA_PURE:\n@@ -1335,8 +1334,7 @@ propagate_pure_const (void)\n \t\t\t     this_looping ? \"looping \" : \"\",\n \t\t\t     cgraph_node_name (w));\n \t\t}\n-\t      cgraph_set_pure_flag (w, true);\n-\t      cgraph_set_looping_const_or_pure_flag (w, this_looping);\n+\t      cgraph_set_pure_flag (w, true, this_looping);\n \t      break;\n \n \t    default:\n@@ -1599,8 +1597,7 @@ local_pure_const (void)\n \t  warn_function_const (current_function_decl, !l->looping);\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_readonly_flag (node, true);\n-\t      cgraph_set_looping_const_or_pure_flag (node, l->looping);\n+\t      cgraph_set_const_flag (node, true, l->looping);\n \t      changed = true;\n \t    }\n \t  if (dump_file)\n@@ -1614,7 +1611,7 @@ local_pure_const (void)\n \t{\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_looping_const_or_pure_flag (node, false);\n+\t      cgraph_set_const_flag (node, true, false);\n \t      changed = true;\n \t    }\n \t  if (dump_file)\n@@ -1629,8 +1626,7 @@ local_pure_const (void)\n \t{\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_pure_flag (node, true);\n-\t      cgraph_set_looping_const_or_pure_flag (node, l->looping);\n+\t      cgraph_set_pure_flag (node, true, l->looping);\n \t      changed = true;\n \t    }\n \t  warn_function_pure (current_function_decl, !l->looping);\n@@ -1645,7 +1641,7 @@ local_pure_const (void)\n \t{\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_looping_const_or_pure_flag (node, false);\n+\t      cgraph_set_pure_flag (node, true, false);\n \t      changed = true;\n \t    }\n \t  if (dump_file)"}, {"sha": "2eb43b85596466a76def07187b312eb0e6c50a02", "filename": "gcc/ipa.c", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -57,8 +57,9 @@ cgraph_postorder (struct cgraph_node **order)\n     for (node = cgraph_nodes; node; node = node->next)\n       if (!node->aux\n \t  && (pass\n-\t      || (!cgraph_only_called_directly_p (node)\n-\t  \t  && !node->address_taken)))\n+\t      || (!node->address_taken\n+\t\t  && !node->global.inlined_to\n+\t\t  && !cgraph_only_called_directly_p (node))))\n \t{\n \t  node2 = node;\n \t  if (!node->callers)\n@@ -237,15 +238,22 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     gcc_assert (!vnode->aux);\n #endif\n   varpool_reset_queue ();\n+  /* Mark functions whose bodies are obviously needed.\n+     This is mostly when they can be referenced externally.  Inline clones\n+     are special since their declarations are shared with master clone and thus\n+     cgraph_can_remove_if_no_direct_calls_and_refs_p should not be called on them.  */\n   for (node = cgraph_nodes; node; node = node->next)\n-    if ((!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n-\t /* Keep around virtual functions for possible devirtualization.  */\n-\t || (!before_inlining_p\n-\t     && !node->global.inlined_to\n-\t     && DECL_VIRTUAL_P (node->decl)\n-\t     && (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))))\n-\t&& ((!DECL_EXTERNAL (node->decl))\n-            || before_inlining_p))\n+    if (node->analyzed && !node->global.inlined_to\n+\t&& (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n+\t    /* Keep around virtual functions for possible devirtualization.  */\n+\t    || (before_inlining_p\n+\t\t&& DECL_VIRTUAL_P (node->decl)\n+\t\t&& (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl)))\n+\t    /* Also external functions with address taken are better to stay\n+\t       for indirect inlining.  */\n+\t    || (before_inlining_p\n+\t\t&& DECL_EXTERNAL (node->decl)\n+\t\t&& node->address_taken)))\n       {\n         gcc_assert (!node->global.inlined_to);\n \tenqueue_cgraph_node (node, &first);\n@@ -256,6 +264,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n         gcc_assert (!node->aux);\n \tnode->reachable = false;\n       }\n+\n+  /* Mark variables that are obviously needed.  */\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {\n       vnode->next_needed = NULL;\n@@ -428,10 +438,10 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t\tnode->clone_of->clones = node->next_sibling_clone;\n \t\t      if (node->next_sibling_clone)\n \t\t\tnode->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n-    #ifdef ENABLE_CHECKING\n+#ifdef ENABLE_CHECKING\n \t\t      if (node->clone_of)\n \t\t\tnode->former_clone_of = node->clone_of->decl;\n-    #endif\n+#endif\n \t\t      node->clone_of = NULL;\n \t\t      node->next_sibling_clone = NULL;\n \t\t      node->prev_sibling_clone = NULL;\n@@ -771,6 +781,15 @@ function_and_variable_visibility (bool whole_program)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n+      int flags = flags_from_decl_or_type (node->decl);\n+      if (optimize\n+\t  && (flags & (ECF_CONST | ECF_PURE))\n+\t  && !(flags & ECF_LOOPING_CONST_OR_PURE))\n+\t{\n+\t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+\t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+\t}\n+\n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n \t (that ought to be shared but can not due to object format\n \t limitations).  It is neccesary to keep the flag to make rest of C++ FE"}, {"sha": "fcb3d8789830df42eb16f5622b8596bc1b6c84a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -1,3 +1,8 @@\n+2010-10-26  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/45736\n+\t* testsuite/gcc.dg/lto/pr45736_0.c: New function.\n+\n 2010-10-26  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/46167"}, {"sha": "ba38504f3ef96086af50fb2ca04307f99c0ee382", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=530f3a1bf62964c0c52d6fcf4ca0d321ce9d5156", "patch": "@@ -510,9 +510,8 @@ tree_profiling (void)\n \t  || DECL_STRUCT_FUNCTION (node->decl)->after_tree_profile)\n \tcontinue;\n \n-      cgraph_set_readonly_flag (node, false);\n-      cgraph_set_pure_flag (node, false);\n-      cgraph_set_looping_const_or_pure_flag (node, false);\n+      cgraph_set_const_flag (node, false, false);\n+      cgraph_set_pure_flag (node, false, false);\n     }\n \n   /* Update call statements and rebuild the cgraph.  */"}]}