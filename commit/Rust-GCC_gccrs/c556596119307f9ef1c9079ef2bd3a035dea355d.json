{"sha": "c556596119307f9ef1c9079ef2bd3a035dea355d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU1NjU5NjExOTMwN2Y5ZWYxYzkwNzllZjJiZDNhMDM1ZGVhMzU1ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-22T12:35:19Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-22T20:17:25Z"}, "message": "libstdc++: Simplify std::try_lock and std::lock further\n\nThe std::try_lock and std::lock algorithms can use iteration instead of\nrecursion when all lockables have the same type and can be held by an\narray of unique_lock<L> objects.\n\nBy making this change to __detail::__try_lock_impl it also benefits\n__detail::__lock_impl, which uses it. For std::lock we can just put the\niterative version directly in std::lock, to avoid making any call to\n__detail::__lock_impl.\n\nSigned-off-by: Matthias Kretz <m.kretz@gsi.de>\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nCo-authored-by: Matthias Kretz <m.kretz@gsi.de>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/mutex (lock): Replace recursion with iteration\n\twhen lockables all have the same type.\n\t(__detail::__try_lock_impl): Likewise. Pass lockables as\n\tparameters, instead of a tuple. Always lock the first one, and\n\trecurse for the rest.\n\t(__detail::__lock_impl): Adjust call to __try_lock_impl.\n\t(__detail::__try_to_lock): Remove.\n\t* testsuite/30_threads/lock/3.cc: Check that mutexes are locked.\n\t* testsuite/30_threads/lock/4.cc: Also test non-heterogeneous\n\targuments.\n\t* testsuite/30_threads/unique_lock/cons/60497.cc: Also check\n\tstd::try_lock.\n\t* testsuite/30_threads/try_lock/5.cc: New test.", "tree": {"sha": "0292d6d165df8828a851fe18b32cf4f2698dc3c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0292d6d165df8828a851fe18b32cf4f2698dc3c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c556596119307f9ef1c9079ef2bd3a035dea355d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c556596119307f9ef1c9079ef2bd3a035dea355d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c556596119307f9ef1c9079ef2bd3a035dea355d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c556596119307f9ef1c9079ef2bd3a035dea355d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a29741db11007e37d8d4ff977b89a8314abfda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a29741db11007e37d8d4ff977b89a8314abfda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5a29741db11007e37d8d4ff977b89a8314abfda"}], "stats": {"total": 283, "additions": 253, "deletions": 30}, "files": [{"sha": "c18ca1a195533058a5a3d70f418a6080a147dc6d", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 79, "deletions": 29, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=c556596119307f9ef1c9079ef2bd3a035dea355d", "patch": "@@ -514,39 +514,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// @cond undocumented\n   namespace __detail\n   {\n+    // Lock the last lockable, after all previous ones are locked.\n     template<typename _Lockable>\n-      inline unique_lock<_Lockable>\n-      __try_to_lock(_Lockable& __l)\n-      { return unique_lock<_Lockable>{__l, try_to_lock}; }\n-\n-    // Lock the last element of the tuple, after all previous ones are locked.\n-    template<int _Idx, typename... _Lockables>\n-      inline __enable_if_t<_Idx + 1 == sizeof...(_Lockables), int>\n-      __try_lock_impl(tuple<_Lockables&...>& __lockables)\n+      inline int\n+      __try_lock_impl(_Lockable& __lockable)\n       {\n-\tif (auto __lock = __detail::__try_to_lock(std::get<_Idx>(__lockables)))\n+\tif (unique_lock<_Lockable> __lock{__lockable, try_to_lock})\n \t  {\n \t    __lock.release();\n \t    return -1;\n \t  }\n \telse\n-\t  return _Idx;\n+\t  return 0;\n       }\n \n-    // Lock tuple elements starting from _Idx.\n-    template<int _Idx, typename... _Lockables>\n-      inline __enable_if_t<_Idx + 1 != sizeof...(_Lockables), int>\n-      __try_lock_impl(tuple<_Lockables&...>& __lockables)\n+    // Lock each lockable in turn.\n+    // Use iteration if all lockables are the same type, recursion otherwise.\n+    template<typename _L0, typename... _Lockables>\n+      inline int\n+      __try_lock_impl(_L0& __l0, _Lockables&... __lockables)\n       {\n-\tif (auto __lock = __detail::__try_to_lock(std::get<_Idx>(__lockables)))\n+#if __cplusplus >= 201703L\n+\tif constexpr ((is_same_v<_L0, _Lockables> && ...))\n \t  {\n-\t    int __idx = __detail::__try_lock_impl<_Idx + 1>(__lockables);\n+\t    constexpr int _Np = 1 + sizeof...(_Lockables);\n+\t    unique_lock<_L0> __locks[_Np] = {\n+\t\t{__l0, defer_lock}, {__lockables, defer_lock}...\n+\t    };\n+\t    for (int __i = 0; __i < _Np; ++__i)\n+\t      {\n+\t\tif (!__locks[__i].try_lock())\n+\t\t  {\n+\t\t    const int __failed = __i;\n+\t\t    while (__i--)\n+\t\t      __locks[__i].unlock();\n+\t\t    return __failed;\n+\t\t  }\n+\t      }\n+\t    for (auto& __l : __locks)\n+\t      __l.release();\n+\t    return -1;\n+\t  }\n+\telse\n+#endif\n+\tif (unique_lock<_L0> __lock{__l0, try_to_lock})\n+\t  {\n+\t    int __idx = __detail::__try_lock_impl(__lockables...);\n \t    if (__idx == -1)\n-\t      __lock.release();\n-\t    return __idx;\n+\t      {\n+\t\t__lock.release();\n+\t\treturn -1;\n+\t      }\n+\t    return __idx + 1;\n \t  }\n \telse\n-\t  return _Idx;\n+\t  return 0;\n       }\n \n   } // namespace __detail\n@@ -562,12 +584,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *\n    *  Sequentially calls try_lock() on each argument.\n    */\n-  template<typename _Lock1, typename _Lock2, typename... _Lock3>\n+  template<typename _L1, typename _L2, typename... _L3>\n     int\n-    try_lock(_Lock1& __l1, _Lock2& __l2, _Lock3&... __l3)\n+    try_lock(_L1& __l1, _L2& __l2, _L3&... __l3)\n     {\n-      auto __lockables = std::tie(__l1, __l2, __l3...);\n-      return __detail::__try_lock_impl<0>(__lockables);\n+      return __detail::__try_lock_impl(__l1, __l2, __l3...);\n     }\n \n   /// @cond undocumented\n@@ -589,8 +610,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tint __failed = 1; // index that couldn't be locked\n \t\t{\n \t\t  unique_lock<_L0> __first(__l0);\n-\t\t  auto __rest = std::tie(__l1...);\n-\t\t  __failed += __detail::__try_lock_impl<0>(__rest);\n+\t\t  __failed += __detail::__try_lock_impl(__l1...);\n \t\t  if (!__failed)\n \t\t    {\n \t\t      __i = -1; // finished\n@@ -620,15 +640,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @post All arguments are locked.\n    *\n    *  All arguments are locked via a sequence of calls to lock(), try_lock()\n-   *  and unlock().  If the call exits via an exception any locks that were\n-   *  obtained will be released.\n+   *  and unlock().  If this function exits via an exception any locks that\n+   *  were obtained will be released.\n    */\n   template<typename _L1, typename _L2, typename... _L3>\n     void\n     lock(_L1& __l1, _L2& __l2, _L3&... __l3)\n     {\n-      int __i = 0;\n-      __detail::__lock_impl(__i, 0, __l1, __l2, __l3...);\n+#if __cplusplus >= 201703L\n+      if constexpr (is_same_v<_L1, _L2> && (is_same_v<_L1, _L3> && ...))\n+\t{\n+\t  constexpr int _Np = 2 + sizeof...(_L3);\n+\t  unique_lock<_L1> __locks[] = {\n+\t      {__l1, defer_lock}, {__l2, defer_lock}, {__l3, defer_lock}...\n+\t  };\n+\t  int __first = 0;\n+\t  do {\n+\t    __locks[__first].lock();\n+\t    for (int __j = 1; __j < _Np; ++__j)\n+\t      {\n+\t\tconst int __idx = (__first + __j) % _Np;\n+\t\tif (!__locks[__idx].try_lock())\n+\t\t  {\n+\t\t    for (int __k = __j; __k != 0; --__k)\n+\t\t      __locks[(__first + __k - 1) % _Np].unlock();\n+\t\t    __first = __idx;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  } while (!__locks[__first].owns_lock());\n+\n+\t  for (auto& __l : __locks)\n+\t    __l.release();\n+\t}\n+      else\n+#endif\n+\t{\n+\t  int __i = 0;\n+\t  __detail::__lock_impl(__i, 0, __l1, __l2, __l3...);\n+\t}\n     }\n \n #if __cplusplus >= 201703L"}, {"sha": "5fa118768bdf2a5d4ea83d55d94eaab2e49aa791", "filename": "libstdc++-v3/testsuite/30_threads/lock/3.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F3.cc?ref=c556596119307f9ef1c9079ef2bd3a035dea355d", "patch": "@@ -37,7 +37,7 @@ struct user_lock\n     is_locked = true;\n   }\n \n-  bool try_lock() \n+  bool try_lock()\n   { return is_locked ? false : (is_locked = true); }\n \n   void unlock()\n@@ -62,6 +62,8 @@ int main()\n \t{\n \t  //heterogeneous types\n \t  std::lock(m1, m2, m3);\n+\t  VERIFY( !m1.try_lock() );\n+\t  VERIFY( !m3.try_lock() );\n \t  m1.unlock();\n \t  m2.unlock();\n \t  m3.unlock();"}, {"sha": "130c1f62d7326f3864bce390559847b4c5030ea9", "filename": "libstdc++-v3/testsuite/30_threads/lock/4.cc", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F4.cc?ref=c556596119307f9ef1c9079ef2bd3a035dea355d", "patch": "@@ -73,6 +73,7 @@ int unreliable_lock::lock_on = -1;\n void test01()\n {\n   unreliable_lock l1, l2, l3;\n+  std::mutex m1, m2, m3;\n \n   try\n     {\n@@ -87,6 +88,60 @@ void test01()\n     {\n       VERIFY( false );\n     }\n+\n+  // Repeat with non-heterogeneous arguments\n+\n+  try\n+    {\n+      unreliable_lock::count = 0;\n+      std::lock(l1, l2, l3, m1);\n+      VERIFY( unreliable_lock::count == 3 );\n+      l1.unlock();\n+      l2.unlock();\n+      l3.unlock();\n+      VERIFY( !m1.try_lock() ); // already locked\n+      m1.unlock();\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  try\n+    {\n+      unreliable_lock::count = 0;\n+      std::lock(m1, l1, l2, l3);\n+      VERIFY( unreliable_lock::count == 3 );\n+      VERIFY( !m1.try_lock() ); // already locked\n+      m1.unlock();\n+      l1.unlock();\n+      l2.unlock();\n+      l3.unlock();\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  try\n+    {\n+      unreliable_lock::count = 0;\n+      std::lock(l1, m1, l2, m2, l3, m3);\n+      VERIFY( unreliable_lock::count == 3 );\n+      l1.unlock();\n+      l2.unlock();\n+      l3.unlock();\n+      VERIFY( !m1.try_lock() ); // already locked\n+      VERIFY( !m2.try_lock() ); // already locked\n+      VERIFY( !m3.try_lock() ); // already locked\n+      m1.unlock();\n+      m2.unlock();\n+      m3.unlock();\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n }\n \n void test02()\n@@ -111,6 +166,31 @@ void test02()\n     {\n       VERIFY( false );\n     }\n+\n+  // Repeat with non-heterogeneous arguments\n+\n+  try\n+    {\n+      unreliable_lock::lock_on = 1;\n+      while (unreliable_lock::lock_on < 3)\n+      {\n+        unreliable_lock::count = 0;\n+        unreliable_lock l1, l2, l3;\n+\tstd::mutex m1;\n+        std::lock(l1, l2, l3, m1);\n+        VERIFY( unreliable_lock::count > 3 );\n+        l1.unlock();\n+        l2.unlock();\n+        l3.unlock();\n+\tVERIFY( !m1.try_lock() ); // already locked\n+        m1.unlock();\n+        ++unreliable_lock::lock_on;\n+      }\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n }\n \n void test03()\n@@ -133,6 +213,50 @@ void test03()\n     VERIFY( test );\n     ++unreliable_lock::throw_on;\n   }\n+\n+  // Repeat with non-heterogeneous arguments\n+\n+  unreliable_lock::throw_on = 0;\n+  while (unreliable_lock::throw_on < 3)\n+  {\n+    unreliable_lock::count = 0;\n+    unreliable_lock l1, l2, l3;\n+    std::mutex m1;\n+    bool test = false;\n+    try\n+      {\n+        std::lock(l1, l2, l3, m1);\n+      }\n+    catch (...)\n+      {\n+        test = true;\n+      }\n+    VERIFY( test );\n+    VERIFY( m1.try_lock() ); // m1 was not left locked by failed std::lock\n+    m1.unlock();\n+    ++unreliable_lock::throw_on;\n+  }\n+\n+  unreliable_lock::throw_on = 0;\n+  while (unreliable_lock::throw_on < 3)\n+  {\n+    unreliable_lock::count = 0;\n+    unreliable_lock l1, l2, l3;\n+    std::mutex m1;\n+    bool test = false;\n+    try\n+      {\n+        std::lock(m1, l1, l2, l3);\n+      }\n+    catch (...)\n+      {\n+        test = true;\n+      }\n+    VERIFY( test );\n+    VERIFY( m1.try_lock() ); // m1 was not left locked by failed std::lock\n+    m1.unlock();\n+    ++unreliable_lock::throw_on;\n+  }\n }\n \n int main()"}, {"sha": "a5574ff01fbb4aaf3d6aeee9e154f53370449e82", "filename": "libstdc++-v3/testsuite/30_threads/try_lock/5.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F5.cc?ref=c556596119307f9ef1c9079ef2bd3a035dea355d", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do run { target c++11 } }\n+\n+#include <mutex>\n+#include <testsuite_hooks.h>\n+\n+struct Lockable\n+{\n+  static int tries;\n+\n+  void lock() { }\n+  void unlock() { }\n+  bool try_lock() { return ++tries != 2; }\n+};\n+\n+int Lockable::tries = 0;\n+\n+void test01()\n+{\n+  Lockable l1, l2, l3;\n+  std::mutex m1, m2;\n+\n+  VERIFY( std::try_lock(l1, l2, l3) == 1 );\n+  VERIFY( Lockable::tries == 2 );\n+\n+  Lockable::tries = 0;\n+  VERIFY( std::try_lock(m1, l1, l2, l3) == 2 );\n+  VERIFY( Lockable::tries == 2 );\n+\n+  Lockable::tries = 0;\n+  VERIFY( std::try_lock(l1, l2, l3, m1) == 1 );\n+  VERIFY( Lockable::tries == 2 );\n+\n+  Lockable::tries = 0;\n+  VERIFY( std::try_lock(m1, l1, l2, l3, m2) == 2 );\n+  VERIFY( Lockable::tries == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "08698cea783eb674c2d26cd5ae20753bf578507d", "filename": "libstdc++-v3/testsuite/30_threads/unique_lock/cons/60497.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_lock%2Fcons%2F60497.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c556596119307f9ef1c9079ef2bd3a035dea355d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_lock%2Fcons%2F60497.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_lock%2Fcons%2F60497.cc?ref=c556596119307f9ef1c9079ef2bd3a035dea355d", "patch": "@@ -46,3 +46,9 @@ void test02()\n   test_type l1, l2, l3;\n   std::lock(l1, l2, l3);\n }\n+\n+void test03()\n+{\n+  test_type l1, l2, l3;\n+  std::try_lock(l1, l2, l3);\n+}"}]}