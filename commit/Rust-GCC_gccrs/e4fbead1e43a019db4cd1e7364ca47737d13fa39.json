{"sha": "e4fbead1e43a019db4cd1e7364ca47737d13fa39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRmYmVhZDFlNDNhMDE5ZGI0Y2QxZTczNjRjYTQ3NzM3ZDEzZmEzOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-03-10T21:39:01Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-03-10T21:39:01Z"}, "message": "builtins.c (expand_builtin_signbit): Extend to handle floating point modes wider than the largest integer type...\n\n\n\t* builtins.c (expand_builtin_signbit): Extend to handle floating\n\tpoint modes wider than the largest integer type, using the\n\toperand_subword_force function to obtain the signbit's word.\n\n\t* gcc.dg/builtins-32.c: Add new run-time tests for long double.\n\nFrom-SVN: r96263", "tree": {"sha": "9fee6ed62b160ba480074e89b8d8be41b4e3194f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fee6ed62b160ba480074e89b8d8be41b4e3194f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4fbead1e43a019db4cd1e7364ca47737d13fa39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fbead1e43a019db4cd1e7364ca47737d13fa39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4fbead1e43a019db4cd1e7364ca47737d13fa39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fbead1e43a019db4cd1e7364ca47737d13fa39/comments", "author": null, "committer": null, "parents": [{"sha": "985f2d8fa38d5c97b7f28208f0a571a568622039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985f2d8fa38d5c97b7f28208f0a571a568622039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/985f2d8fa38d5c97b7f28208f0a571a568622039"}], "stats": {"total": 101, "additions": 67, "deletions": 34}, "files": [{"sha": "18efe597a39509fa01c0deaf97fa3e234c34a4b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4fbead1e43a019db4cd1e7364ca47737d13fa39", "patch": "@@ -1,3 +1,9 @@\n+2005-03-10  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_builtin_signbit): Extend to handle floating\n+\tpoint modes wider than the largest integer type, using the\n+\toperand_subword_force function to obtain the signbit's word.\n+\n 2005-03-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/20322"}, {"sha": "4f464746b9a829c5059f89be013222b03dab8040", "filename": "gcc/builtins.c", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e4fbead1e43a019db4cd1e7364ca47737d13fa39", "patch": "@@ -4957,7 +4957,7 @@ expand_builtin_signbit (tree exp, rtx target)\n   enum machine_mode fmode, imode, rmode;\n   HOST_WIDE_INT hi, lo;\n   tree arg, arglist;\n-  int bitpos;\n+  int word, bitpos;\n   rtx temp;\n \n   arglist = TREE_OPERAND (exp, 1);\n@@ -4971,7 +4971,8 @@ expand_builtin_signbit (tree exp, rtx target)\n \n   /* For floating point formats without a sign bit, implement signbit\n      as \"ARG < 0.0\".  */\n-  if (fmt->signbit < 0)\n+  bitpos = fmt->signbit;\n+  if (bitpos < 0)\n   {\n     /* But we can't do this if the format supports signed zero.  */\n     if (fmt->has_signed_zero && HONOR_SIGNED_ZEROS (fmode))\n@@ -4982,41 +4983,32 @@ expand_builtin_signbit (tree exp, rtx target)\n     return expand_expr (arg, target, VOIDmode, EXPAND_NORMAL);\n   }\n \n-  imode = int_mode_for_mode (fmode);\n-  if (imode == BLKmode)\n-    return 0;\n-\n-  bitpos = fmt->signbit;\n-  /* Handle targets with different FP word orders.  */\n-  if (FLOAT_WORDS_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n-    {\n-      int nwords = GET_MODE_BITSIZE (fmode) / BITS_PER_WORD;\n-      int word = nwords - (bitpos / BITS_PER_WORD) - 1;\n-      bitpos = word * BITS_PER_WORD + bitpos % BITS_PER_WORD;\n-    }\n-\n-  /* If the sign bit is not in the lowpart and the floating point format\n-     is wider than an integer, check that is twice the size of an integer\n-     so that we can use gen_highpart below.  */\n-  if (bitpos >= GET_MODE_BITSIZE (rmode)\n-      && GET_MODE_BITSIZE (imode) != 2 * GET_MODE_BITSIZE (rmode))\n-    return 0;\n-\n   temp = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n-  temp = gen_lowpart (imode, temp);\n-\n-  if (GET_MODE_BITSIZE (imode) > GET_MODE_BITSIZE (rmode))\n+  if (GET_MODE_SIZE (fmode) <= UNITS_PER_WORD)\n     {\n-      if (BYTES_BIG_ENDIAN)\n-\tbitpos = GET_MODE_BITSIZE (imode) - 1 - bitpos;\n-      temp = copy_to_mode_reg (imode, temp);\n-      temp = extract_bit_field (temp, 1, bitpos, 1,\n-\t\t\t\tNULL_RTX, rmode, rmode);\n+      imode = int_mode_for_mode (fmode);\n+      if (imode == BLKmode)\n+\treturn 0;\n+      temp = gen_lowpart (imode, temp);\n     }\n   else\n     {\n-      if (GET_MODE_BITSIZE (imode) < GET_MODE_BITSIZE (rmode))\n-\ttemp = gen_lowpart (rmode, temp);\n+      imode = word_mode;\n+      /* Handle targets with different FP word orders.  */\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+        word = (GET_MODE_BITSIZE (fmode) - bitpos) / BITS_PER_WORD;\n+      else\n+        word = bitpos / BITS_PER_WORD;\n+      temp = operand_subword_force (temp, word, fmode);\n+      bitpos = bitpos % BITS_PER_WORD;\n+    }\n+\n+  /* If the bitpos is within the \"result mode\" lowpart, the operation\n+     can be implement with a single bitwise AND.  Otherwise, we need\n+     a right shift and an AND.  */\n+\n+  if (bitpos < GET_MODE_BITSIZE (rmode))\n+    {\n       if (bitpos < HOST_BITS_PER_WIDE_INT)\n \t{\n \t  hi = 0;\n@@ -5028,11 +5020,24 @@ expand_builtin_signbit (tree exp, rtx target)\n \t  lo = 0;\n \t}\n \n-      temp = force_reg (rmode, temp);\n+      if (imode != rmode)\n+\ttemp = gen_lowpart (rmode, temp);\n       temp = expand_binop (rmode, and_optab, temp,\n \t\t\t   immed_double_const (lo, hi, rmode),\n-\t\t\t   target, 1, OPTAB_LIB_WIDEN);\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n     }\n+  else\n+    {\n+      /* Perform a logical right shift to place the signbit in the least\n+         significant bit, then truncate the result to the desired mode\n+\t and mask just this bit.  */\n+      temp = expand_shift (RSHIFT_EXPR, imode, temp,\n+\t\t\t   build_int_cst (NULL_TREE, bitpos), NULL_RTX, 1);\n+      temp = gen_lowpart (rmode, temp);\n+      temp = expand_binop (rmode, and_optab, temp, const1_rtx,\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+    }\n+\n   return temp;\n }\n "}, {"sha": "bee3e6499bf8bf6413b15ffef0b89844f0d7f748", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e4fbead1e43a019db4cd1e7364ca47737d13fa39", "patch": "@@ -1,3 +1,7 @@\n+2005-03-10  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-32.c: Add new run-time tests for long double.\n+\n 2005-03-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/20322"}, {"sha": "3d2a36190a578f35296770f31d5303ee675def72", "filename": "gcc/testsuite/gcc.dg/builtins-32.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fbead1e43a019db4cd1e7364ca47737d13fa39/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-32.c?ref=e4fbead1e43a019db4cd1e7364ca47737d13fa39", "patch": "@@ -12,6 +12,7 @@ extern void abort(void);\n \n extern int signbit(double);\n extern int signbitf(float);\n+extern int signbitl(long double);\n \n int test (double x)\n {\n@@ -23,18 +24,35 @@ int testf (float x)\n   return signbitf(x);\n }\n \n+int testl (long double x)\n+{\n+  return signbitl(x);\n+}\n+\n+\n int main()\n {\n+  if (test (0.0) != 0)\n+    abort ();\n   if (test (1.0) != 0)\n     abort ();\n   if (test (-2.0) == 0)\n     abort ();\n \n+  if (testf (0.0f) != 0)\n+    abort ();\n   if (testf (1.0f) != 0)\n     abort ();\n   if (testf (-2.0f) == 0)\n     abort ();\n \n+  if (testl (0.0l) != 0)\n+    abort ();\n+  if (testl (1.0l) != 0)\n+    abort ();\n+  if (testl (-2.0l) == 0)\n+    abort ();\n+\n   return 0;\n }\n "}]}