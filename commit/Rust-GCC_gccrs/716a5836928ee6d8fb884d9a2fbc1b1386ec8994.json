{"sha": "716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE2YTU4MzY5MjhlZTZkOGZiODg0ZDlhMmZiYzFiMTM4NmVjODk5NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-08T08:39:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-08T15:43:40Z"}, "message": "c++/102228 - make lookup_anon_field O(1)\n\nFor the testcase in PR101555 lookup_anon_field takes the majority\nof parsing time followed by get_class_binding_direct/fields_linear_search\nwhich is PR83309.  The situation with anon aggregates is particularly\ndire when we need to build accesses to their members and the anon\naggregates are nested.  There for each such access we recursively\nbuild sub-accesses to the anon aggregate FIELD_DECLs bottom-up,\nDFS searching for them.  That's inefficient since as I believe\nthere's a 1:1 relationship between anon aggregate types and the\nFIELD_DECL used to place them.\n\nThe patch below does away with the search in lookup_anon_field and\ninstead records the single FIELD_DECL in the anon aggregate types\nlang-specific data, re-using the RTTI typeinfo_var field.  That\nspeeds up the compile of the testcase with -fsyntax-only from\nabout 4.5s to slightly less than 1s.\n\nI tried to poke holes into the 1:1 relationship idea with my C++\nknowledge but failed (which might not say much).  It also leaves\na hole for the case when the C++ FE itself duplicates such type\nand places it at a semantically different position.  I've tried\nto poke holes into it with the duplication mechanism I understand\n(templates) but failed.\n\n2021-09-08  Richard Biener  <rguenther@suse.de>\n\n\tPR c++/102228\ngcc/cp/\n\t* cp-tree.h (ANON_AGGR_TYPE_FIELD): New define.\n\t* decl.c (fixup_anonymous_aggr): Wipe RTTI info put in\n\tplace on invalid code.\n\t* decl2.c (reset_type_linkage): Guard CLASSTYPE_TYPEINFO_VAR\n\taccess.\n\t* module.cc (trees_in::read_class_def): Likewise.  Reconstruct\n\tANON_AGGR_TYPE_FIELD.\n\t* semantics.c (finish_member_declaration): Populate\n\tANON_AGGR_TYPE_FIELD for anon aggregate typed members.\n\t* typeck.c (lookup_anon_field): Remove DFS search and return\n\tANON_AGGR_TYPE_FIELD directly.", "tree": {"sha": "68472729eae9fb81184f64aaeaed5099f7680e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68472729eae9fb81184f64aaeaed5099f7680e7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d27d694151c5604d2daba23dd2a328ae70b65194", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d27d694151c5604d2daba23dd2a328ae70b65194", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d27d694151c5604d2daba23dd2a328ae70b65194"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "ceb53591926e46bf4435f3fc81aa82162f977ade", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "patch": "@@ -4800,6 +4800,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define ANON_UNION_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == UNION_TYPE && ANON_AGGR_TYPE_P (NODE))\n \n+/* For an ANON_AGGR_TYPE_P the single FIELD_DECL it is used with.  */\n+#define ANON_AGGR_TYPE_FIELD(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->typeinfo_var)\n+\n /* Define fields and accessors for nodes representing declared names.  */\n \n /* True if TYPE is an unnamed structured type with a typedef for"}, {"sha": "bce62ad202a52d6d92be34c364f438bf674241c2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "patch": "@@ -5096,6 +5096,9 @@ fixup_anonymous_aggr (tree t)\n       (*vec)[store++] = elt;\n   vec_safe_truncate (vec, store);\n \n+  /* Wipe RTTI info.  */\n+  CLASSTYPE_TYPEINFO_VAR (t) = NULL_TREE;\n+\n   /* Anonymous aggregates cannot have fields with ctors, dtors or complex\n      assignment operators (because they cannot have these methods themselves).\n      For anonymous unions this is already checked because they are not allowed"}, {"sha": "a79a70ba9c2f94666298cbf87276ac23dbb7fd40", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "patch": "@@ -2977,14 +2977,15 @@ reset_type_linkage (tree type)\n \t  SET_DECL_ASSEMBLER_NAME (vt, name);\n \t  reset_decl_linkage (vt);\n \t}\n-      if (tree ti = CLASSTYPE_TYPEINFO_VAR (type))\n-\t{\n-\t  tree name = mangle_typeinfo_for_type (type);\n-\t  DECL_NAME (ti) = name;\n-\t  SET_DECL_ASSEMBLER_NAME (ti, name);\n-\t  TREE_TYPE (name) = type;\n-\t  reset_decl_linkage (ti);\n-\t}\n+      if (!ANON_AGGR_TYPE_P (type))\n+\tif (tree ti = CLASSTYPE_TYPEINFO_VAR (type))\n+\t  {\n+\t    tree name = mangle_typeinfo_for_type (type);\n+\t    DECL_NAME (ti) = name;\n+\t    SET_DECL_ASSEMBLER_NAME (ti, name);\n+\t    TREE_TYPE (name) = type;\n+\t    reset_decl_linkage (ti);\n+\t  }\n       for (tree m = TYPE_FIELDS (type); m; m = DECL_CHAIN (m))\n \t{\n \t  tree mem = STRIP_TEMPLATE (m);"}, {"sha": "71d0fab411f6fb3fc976f8e31b42fe6d0d055761", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "patch": "@@ -11859,8 +11859,9 @@ trees_in::read_class_def (tree defn, tree maybe_template)\n \t\t{\n \t\t  CLASSTYPE_BEFRIENDING_CLASSES (type_dup)\n \t\t    = CLASSTYPE_BEFRIENDING_CLASSES (type);\n-\t\t  CLASSTYPE_TYPEINFO_VAR (type_dup)\n-\t\t    = CLASSTYPE_TYPEINFO_VAR (type);\n+\t\t  if (!ANON_AGGR_TYPE_P (type))\n+\t\t    CLASSTYPE_TYPEINFO_VAR (type_dup)\n+\t\t      = CLASSTYPE_TYPEINFO_VAR (type);\n \t\t}\n \t      for (tree v = type; v; v = TYPE_NEXT_VARIANT (v))\n \t\tTYPE_LANG_SPECIFIC (v) = ls;\n@@ -11891,6 +11892,11 @@ trees_in::read_class_def (tree defn, tree maybe_template)\n \t      *chain = decl;\n \t      chain = &DECL_CHAIN (decl);\n \n+\t      if (TREE_CODE (decl) == FIELD_DECL\n+\t\t  && ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n+\t\tANON_AGGR_TYPE_FIELD\n+\t\t  (TYPE_MAIN_VARIANT (TREE_TYPE (decl))) = decl;\n+\n \t      if (TREE_CODE (decl) == USING_DECL\n \t\t  && TREE_CODE (USING_DECL_SCOPE (decl)) == RECORD_TYPE)\n \t\t{"}, {"sha": "4b7f4ace1806f4b74571b592342b92fa4eec6b5b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "patch": "@@ -3489,6 +3489,14 @@ finish_member_declaration (tree decl)\n   if (TREE_CODE (decl) != CONST_DECL)\n     DECL_CONTEXT (decl) = current_class_type;\n \n+  /* Remember the single FIELD_DECL an anonymous aggregate type is used for.  */\n+  if (TREE_CODE (decl) == FIELD_DECL\n+      && ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      gcc_assert (!ANON_AGGR_TYPE_FIELD (TYPE_MAIN_VARIANT (TREE_TYPE (decl))));\n+      ANON_AGGR_TYPE_FIELD (TYPE_MAIN_VARIANT (TREE_TYPE (decl))) = decl;\n+    }\n+\n   if (TREE_CODE (decl) == USING_DECL)\n     /* For now, ignore class-scope USING_DECLS, so that debugging\n        backends do not see them. */"}, {"sha": "a2398dbe660c004cdd635cac3f61f9d88c3ed6e5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/716a5836928ee6d8fb884d9a2fbc1b1386ec8994/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=716a5836928ee6d8fb884d9a2fbc1b1386ec8994", "patch": "@@ -2618,36 +2618,14 @@ rationalize_conditional_expr (enum tree_code code, tree t,\n    that are directly reachable.  */\n \n tree\n-lookup_anon_field (tree t, tree type)\n+lookup_anon_field (tree, tree type)\n {\n   tree field;\n \n-  t = TYPE_MAIN_VARIANT (t);\n-\n-  for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n-    {\n-      if (TREE_STATIC (field))\n-\tcontinue;\n-      if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n-\tcontinue;\n-\n-      /* If we find it directly, return the field.  */\n-      if (DECL_NAME (field) == NULL_TREE\n-\t  && type == TYPE_MAIN_VARIANT (TREE_TYPE (field)))\n-\t{\n-\t  return field;\n-\t}\n-\n-      /* Otherwise, it could be nested, search harder.  */\n-      if (DECL_NAME (field) == NULL_TREE\n-\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-\t{\n-\t  tree subfield = lookup_anon_field (TREE_TYPE (field), type);\n-\t  if (subfield)\n-\t    return subfield;\n-\t}\n-    }\n-  return NULL_TREE;\n+  type = TYPE_MAIN_VARIANT (type);\n+  field = ANON_AGGR_TYPE_FIELD (type);\n+  gcc_assert (field);\n+  return field;\n }\n \n /* Build an expression representing OBJECT.MEMBER.  OBJECT is an"}]}