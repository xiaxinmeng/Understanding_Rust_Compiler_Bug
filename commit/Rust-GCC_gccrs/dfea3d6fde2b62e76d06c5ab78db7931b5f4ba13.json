{"sha": "dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZlYTNkNmZkZTJiNjJlNzZkMDZjNWFiNzhkYjc5MzFiNWY0YmExMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-08T23:56:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-08T23:56:37Z"}, "message": "symtab.c: Fix comment typos.\n\n\t* symtab.c: Fix comment typos.\n\t* cgraphunit.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* cgraphclones.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* varpool.c: Likewise.\n\t* tree-ssa-strlen.c: Likewise.\n\t* ipa-sra.c: Likewise.\n\t(scan_expr_access, check_all_callers_for_issues): Fix typo\n\tin a dump message.\n\nFrom-SVN: r277995", "tree": {"sha": "eb9d1a51051c51c7112160cd56f63b6a1956fe03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb9d1a51051c51c7112160cd56f63b6a1956fe03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a63d6356bebcf96c8931cad1dae50ce553db0df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a63d6356bebcf96c8931cad1dae50ce553db0df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a63d6356bebcf96c8931cad1dae50ce553db0df3"}], "stats": {"total": 284, "additions": 150, "deletions": 134}, "files": [{"sha": "ab5910737095930543fa609204603634e3d63892", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -1,3 +1,16 @@\n+2019-11-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* symtab.c: Fix comment typos.\n+\t* cgraphunit.c: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cgraphclones.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* varpool.c: Likewise.\n+\t* tree-ssa-strlen.c: Likewise.\n+\t* ipa-sra.c: Likewise.\n+\t(scan_expr_access, check_all_callers_for_issues): Fix typo\n+\tin a dump message.\n+\n 2019-11-08  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/darwin-protos.h: Add include quard."}, {"sha": "96f1261f0ccb7a80d14369f2131284e6b9fffb98", "filename": "gcc/cgraph.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -1048,8 +1048,8 @@ cgraph_edge::remove (void)\n      call call_dest\n \n    At this time the function just creates the direct call,\n-   the referencd representing the if conditional and attaches\n-   them all to the orginal indirect call statement.  \n+   the reference representing the if conditional and attaches\n+   them all to the original indirect call statement.  \n \n    Return direct edge created.  */\n \n@@ -1143,7 +1143,7 @@ cgraph_edge::speculative_call_info (cgraph_edge *&direct,\n   gcc_assert (e && e2 && ref);\n }\n \n-/* Speculative call edge turned out to be direct call to CALLE_DECL.\n+/* Speculative call edge turned out to be direct call to CALLEE_DECL.\n    Remove the speculative call sequence and return edge representing the call.\n    It is up to caller to redirect the call as appropriate. */\n \n@@ -2337,7 +2337,7 @@ set_nothrow_flag_1 (cgraph_node *node, bool nothrow, bool non_call,\n   if (nothrow && !TREE_NOTHROW (node->decl))\n     {\n       /* With non-call exceptions we can't say for sure if other function body\n-\t was not possibly optimized to stil throw.  */\n+\t was not possibly optimized to still throw.  */\n       if (!non_call || node->binds_to_current_def_p ())\n \t{\n \t  TREE_NOTHROW (node->decl) = true;\n@@ -2545,7 +2545,7 @@ set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n    If SET_CONST if false, clear the flag.\n \n    When setting the flag be careful about possible interposition and\n-   do not set the flag for functions that can be interposet and set pure\n+   do not set the flag for functions that can be interposed and set pure\n    flag for functions that can bind to other definition. \n \n    Return true if any change was done. */\n@@ -2739,7 +2739,7 @@ cgraph_node::can_remove_if_no_direct_calls_p (bool will_inline)\n   if (will_inline && address_taken)\n     return false;\n \n-  /* Otheriwse check if we can remove the symbol itself and then verify\n+  /* Otherwise check if we can remove the symbol itself and then verify\n      that only uses of the comdat groups are direct call to THIS\n      or its aliases.   */\n   if (!can_remove_if_no_direct_calls_and_refs_p ())\n@@ -3615,7 +3615,7 @@ cgraph_c_finalize (void)\n   version_info_node = NULL;\n }\n \n-/* A wroker for call_for_symbol_and_aliases.  */\n+/* A worker for call_for_symbol_and_aliases.  */\n \n bool\n cgraph_node::call_for_symbol_and_aliases_1 (bool (*callback) (cgraph_node *,\n@@ -3670,13 +3670,14 @@ cgraph_edge::possibly_call_in_translation_unit_p (void)\n   if (flag_incremental_link == INCREMENTAL_LINK_LTO)\n     return true;\n \n-  /* We may be smarter here and avoid stremaing in indirect calls we can't\n-     track, but that would require arranging stremaing the indirect call\n+  /* We may be smarter here and avoid streaming in indirect calls we can't\n+     track, but that would require arranging streaming the indirect call\n      summary first.  */\n   if (!callee)\n     return true;\n \n-  /* If calle is local to the original translation unit, it will be defined.  */\n+  /* If callee is local to the original translation unit, it will be\n+     defined.  */\n   if (!TREE_PUBLIC (callee->decl) && !DECL_EXTERNAL (callee->decl))\n     return true;\n "}, {"sha": "0abde3d8f91c2800f7ce1a42e53a87106bb17acd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -81,8 +81,9 @@ enum availability\n      program.  */\n   AVAIL_AVAILABLE,\n   /* Function body/variable initializer is known and all it's uses are\n-     explicitly visible within current unit (ie it's address is never taken and\n-     it is not exported to other units). Currently used only for functions.  */\n+     explicitly visible within current unit (i.e. it's address is never taken\n+     and it is not exported to other units). Currently used only for\n+     functions.  */\n   AVAIL_LOCAL\n };\n \n@@ -92,7 +93,7 @@ enum symbol_partitioning_class\n    /* External declarations are ignored by partitioning algorithms and they are\n       added into the boundary later via compute_ltrans_boundary.  */\n    SYMBOL_EXTERNAL,\n-   /* Partitioned symbols are pur into one of partitions.  */\n+   /* Partitioned symbols are put into one of partitions.  */\n    SYMBOL_PARTITION,\n    /* Duplicated symbols (such as comdat or constant pool references) are\n       copied into every node needing them via add_symbol_to_partition.  */\n@@ -146,13 +147,13 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   void DEBUG_FUNCTION verify (void);\n \n   /* Return ipa reference from this symtab_node to\n-     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+     REFERRED_NODE or REFERRED_VARPOOL_NODE. USE_TYPE specify type\n      of the use and STMT the statement (if it exists).  */\n   ipa_ref *create_reference (symtab_node *referred_node,\n \t\t\t     enum ipa_ref_use use_type);\n \n   /* Return ipa reference from this symtab_node to\n-     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+     REFERRED_NODE or REFERRED_VARPOOL_NODE. USE_TYPE specify type\n      of the use and STMT the statement (if it exists).  */\n   ipa_ref *create_reference (symtab_node *referred_node,\n \t\t\t     enum ipa_ref_use use_type, gimple *stmt);\n@@ -371,7 +372,7 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      Assume that symbol is used (so there is no need to take into account\n      garbage collecting linkers)\n \n-     This can happen for comdats, commons and weaks when they are previaled\n+     This can happen for comdats, commons and weaks when they are prevailed\n      by other definition at static linking time.  */\n   inline bool\n   can_be_discarded_p (void)\n@@ -406,7 +407,7 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n      If MEMORY_ACCESSED is true, assume that both memory pointer to THIS\n      and S2 is going to be accessed.  This eliminates the situations when\n-     either THIS or S2 is NULL and is seful for comparing bases when deciding\n+     either THIS or S2 is NULL and is useful for comparing bases when deciding\n      about memory aliasing.  */\n   int equal_address_to (symtab_node *s2, bool memory_accessed = false);\n \n@@ -463,7 +464,7 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      set via finalize_function or finalize_decl  */\n   unsigned definition : 1;\n   /* True when symbol is an alias.\n-     Set by ssemble_alias.  */\n+     Set by assemble_alias.  */\n   unsigned alias : 1;\n   /* When true the alias is translated into its target symbol either by GCC\n      or assembler (it also may just be a duplicate declaration of the same\n@@ -477,7 +478,7 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \t by varasm.c. For those DECL_ASSEMBLER_NAME have\n \t IDENTIFIER_TRANSPARENT_ALIAS set and thus also their assembler\n \t name must be unique.\n-\t Weakrefs belong to this cateogry when we target assembler without\n+\t Weakrefs belong to this category when we target assembler without\n \t .weakref directive.\n        - weakrefs that are renamed by assembler via .weakref directive.\n \t In this case the alias may or may not be definition (depending if\n@@ -942,7 +943,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n      When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n      function's profile to reflect the fact that part of execution is handled\n      by node.\n-     When CALL_DUPLICATOIN_HOOK is true, the ipa passes are acknowledged about\n+     When CALL_DUPLICATION_HOOK is true, the ipa passes are acknowledged about\n      the new clone. Otherwise the caller is responsible for doing so later.\n \n      If the new node is being inlined into another one, NEW_INLINED_TO should be\n@@ -1123,7 +1124,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* Likewise indicate that a node is having address taken.  */\n   void mark_address_taken (void);\n \n-  /* Set fialization priority to PRIORITY.  */\n+  /* Set finalization priority to PRIORITY.  */\n   void set_fini_priority (priority_type priority);\n \n   /* Return the finalization priority.  */\n@@ -1179,7 +1180,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n     If SET_CONST if false, clear the flag.\n \n     When setting the flag be careful about possible interposition and\n-    do not set the flag for functions that can be interposet and set pure\n+    do not set the flag for functions that can be interposed and set pure\n     flag for functions that can bind to other definition. \n \n     Return true if any change was done. */\n@@ -1564,7 +1565,7 @@ class GTY(()) ipa_polymorphic_call_context {\n   ipa_polymorphic_call_context (cgraph_edge *e);\n   /* Build polymorphic call context for IP invariant CST.\n      If specified, OTR_TYPE specify the type of polymorphic call\n-     that takes CST+OFFSET as a prameter.  */\n+     that takes CST+OFFSET as a parameter.  */\n   ipa_polymorphic_call_context (tree cst, tree otr_type = NULL,\n \t\t\t\tHOST_WIDE_INT offset = 0);\n   /* Build context for pointer REF contained in FNDECL at statement STMT.\n@@ -1580,7 +1581,7 @@ class GTY(()) ipa_polymorphic_call_context {\n   /* Make context non-speculative.  */\n   void clear_speculation ();\n \n-  /* Produce context specifying all derrived types of OTR_TYPE.  If OTR_TYPE is\n+  /* Produce context specifying all derived types of OTR_TYPE.  If OTR_TYPE is\n      NULL, the context is set to dummy \"I know nothing\" setting.  */\n   void clear_outer_type (tree otr_type = NULL);\n \n@@ -1603,8 +1604,8 @@ class GTY(()) ipa_polymorphic_call_context {\n   /* Use when we cannot track dynamic type change.  This speculatively assume\n      type change is not happening.  */\n   void possible_dynamic_type_change (bool, tree otr_type = NULL);\n-  /* Assume that both THIS and a given context is valid and strenghten THIS\n-     if possible.  Return true if any strenghtening was made.\n+  /* Assume that both THIS and a given context is valid and strengthen THIS\n+     if possible.  Return true if any strengthening was made.\n      If actual type the context is being used in is known, OTR_TYPE should be\n      set accordingly. This improves quality of combined result.  */\n   bool combine_with (ipa_polymorphic_call_context, tree otr_type = NULL);\n@@ -1651,7 +1652,7 @@ class GTY(()) cgraph_indirect_call_info\n   int param_index;\n   /* ECF flags determined from the caller.  */\n   int ecf_flags;\n-  /* Profile_id of common target obtrained from profile.  */\n+  /* Profile_id of common target obtained from profile.  */\n   int common_target_id;\n   /* Probability that call will land in function with COMMON_TARGET_ID.  */\n   int common_target_probability;\n@@ -1717,7 +1718,7 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect,\n \t\t\t      ipa_ref *&reference);\n \n-  /* Speculative call edge turned out to be direct call to CALLE_DECL.\n+  /* Speculative call edge turned out to be direct call to CALLEE_DECL.\n      Remove the speculative call sequence and return edge representing the call.\n      It is up to caller to redirect the call as appropriate. */\n   cgraph_edge *resolve_speculation (tree callee_decl = NULL);\n@@ -1812,10 +1813,10 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n      to a same call statement:\n      1) a direct call (to expected_fn)\n      2) an indirect call (to call_target)\n-     3) a IPA_REF_ADDR refrence to expected_fn.\n+     3) a IPA_REF_ADDR reference to expected_fn.\n \n      Optimizers may later redirect direct call to clone, so 1) and 3)\n-     do not need to necesarily agree with destination.  */\n+     do not need to necessarily agree with destination.  */\n   unsigned int speculative : 1;\n   /* Set to true when caller is a constructor or destructor of polymorphic\n      type.  */\n@@ -1908,7 +1909,7 @@ struct GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node\n      sections can be resolved.  */\n   void finalize_named_section_flags (void);\n \n-  /* Call calback on varpool symbol and aliases associated to varpool symbol.\n+  /* Call callback on varpool symbol and aliases associated to varpool symbol.\n      When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n      skipped. */\n   bool call_for_symbol_and_aliases (bool (*callback) (varpool_node *, void *),\n@@ -1976,7 +1977,7 @@ struct GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node\n   ENUM_BITFIELD(tls_model) tls_model : 3;\n \n   /* Set if the variable is known to be used by single function only.\n-     This is computed by ipa_signle_use pass and used by late optimizations\n+     This is computed by ipa_single_use pass and used by late optimizations\n      in places where optimization would be valid for local static variable\n      if we did not do any inter-procedural code movement.  */\n   unsigned used_by_single_function : 1;\n@@ -2014,7 +2015,7 @@ is_a_helper <cgraph_node *>::test (symtab_node *p)\n   return p && p->type == SYMTAB_FUNCTION;\n }\n \n-/* Report whether or not THIS symtab node is a vriable, aka varpool_node.  */\n+/* Report whether or not THIS symtab node is a variable, aka varpool_node.  */\n \n template <>\n template <>\n@@ -2105,9 +2106,9 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n \n   /* C++ frontend produce same body aliases all over the place, even before PCH\n      gets streamed out. It relies on us linking the aliases with their function\n-     in order to do the fixups, but ipa-ref is not PCH safe.  Consequentely we\n-     first produce aliases without links, but once C++ FE is sure he won't sream\n-     PCH we build the links via this function.  */\n+     in order to do the fixups, but ipa-ref is not PCH safe.  Consequently we\n+     first produce aliases without links, but once C++ FE is sure it won't\n+     stream PCH we build the links via this function.  */\n   void process_same_body_aliases (void);\n \n   /* Perform simple optimizations based on callgraph.  */\n@@ -2281,7 +2282,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Arrange node to be first in its entry of assembler_name_hash.  */\n   void symtab_prevail_in_asm_name_hash (symtab_node *node);\n \n-  /* Initalize asm name hash unless.  */\n+  /* Initialize asm name hash unless.  */\n   void symtab_initialize_asm_name_hash (void);\n \n   /* Set the DECL_ASSEMBLER_NAME and update symtab hashtables.  */\n@@ -2357,7 +2358,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n \n   bool cpp_implicit_aliases_done;\n \n-  /* Hash table used to hold sectoons.  */\n+  /* Hash table used to hold sections.  */\n   hash_table<section_name_hasher> *GTY(()) section_hash;\n \n   /* Hash table used to convert assembler names into nodes.  */\n@@ -2403,7 +2404,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n \n   /* List of hooks triggered when an edge is removed.  */\n   cgraph_edge_hook_list * GTY((skip)) m_first_edge_removal_hook;\n-  /* List of hooks triggem_red when a cgraph node is removed.  */\n+  /* List of hooks trigger_red when a cgraph node is removed.  */\n   cgraph_node_hook_list * GTY((skip)) m_first_cgraph_removal_hook;\n   /* List of hooks triggered when an edge is duplicated.  */\n   cgraph_2edge_hook_list * GTY((skip)) m_first_edge_duplicated_hook;\n@@ -2506,7 +2507,7 @@ symtab_node::real_symbol_p (void)\n }\n \n /* Return true if DECL should have entry in symbol table if used.\n-   Those are functions and static & external veriables*/\n+   Those are functions and static & external variables.  */\n \n static inline bool\n decl_in_symtab_p (const_tree decl)\n@@ -3264,7 +3265,7 @@ symtab_node::get_availability (symtab_node *ref)\n     return dyn_cast <varpool_node *> (this)->get_availability (ref);\n }\n \n-/* Call calback on symtab node and aliases associated to this node.\n+/* Call callback on symtab node and aliases associated to this node.\n    When INCLUDE_OVERWRITABLE is false, overwritable symbols are skipped. */\n \n inline bool\n@@ -3305,7 +3306,7 @@ cgraph_node::call_for_symbol_and_aliases (bool (*callback) (cgraph_node *,\n   return false;\n }\n \n-/* Call calback on varpool symbol and aliases associated to varpool symbol.\n+/* Call callback on varpool symbol and aliases associated to varpool symbol.\n    When INCLUDE_OVERWRITABLE is false, overwritable symbols are\n    skipped. */\n \n@@ -3326,7 +3327,7 @@ varpool_node::call_for_symbol_and_aliases (bool (*callback) (varpool_node *,\n   return false;\n }\n \n-/* Return true if refernece may be used in address compare.  */\n+/* Return true if reference may be used in address compare.  */\n \n inline bool\n ipa_ref::address_matters_p ()\n@@ -3369,7 +3370,7 @@ ipa_polymorphic_call_context::clear_speculation ()\n   speculative_maybe_derived_type = false;\n }\n \n-/* Produce context specifying all derrived types of OTR_TYPE.  If OTR_TYPE is\n+/* Produce context specifying all derived types of OTR_TYPE.  If OTR_TYPE is\n    NULL, the context is set to dummy \"I know nothing\" setting.  */\n \n inline void"}, {"sha": "41a600e64a54f5fad793a367e4b2e11b3de12a48", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -18,7 +18,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* This module provide facilities for clonning functions. I.e. creating\n+/* This module provide facilities for cloning functions.  I.e. creating\n    new functions based on existing functions with simple modifications,\n    such as replacement of parameters.\n \n@@ -304,7 +304,7 @@ dump_callgraph_transformation (const cgraph_node *original,\n    When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n    function's profile to reflect the fact that part of execution is handled\n    by node.  \n-   When CALL_DUPLICATOIN_HOOK is true, the ipa passes are acknowledged about\n+   When CALL_DUPLICATION_HOOK is true, the ipa passes are acknowledged about\n    the new clone. Otherwise the caller is responsible for doing so later.\n \n    If the new node is being inlined into another one, NEW_INLINED_TO should be\n@@ -381,7 +381,7 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n     {\n       /* Redirect calls to the old version node to point to its new\n \t version.  The only exception is when the edge was proved to\n-\t be unreachable during the clonning procedure.  */\n+\t be unreachable during the cloning procedure.  */\n       if (!e->callee\n \t  || !fndecl_built_in_p (e->callee->decl, BUILT_IN_UNREACHABLE))\n         e->redirect_callee_duplicating_thunks (new_node);"}, {"sha": "aa26160bf3ff14aabd80ae8a0174c6c6586dd682", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -75,15 +75,15 @@ along with GCC; see the file COPYING3.  If not see\n \t   a) early optimizations. These are local passes executed in\n \t      the topological order on the callgraph.\n \n-\t      The purpose of early optimiations is to optimize away simple\n+\t      The purpose of early optimizations is to optimize away simple\n \t      things that may otherwise confuse IP analysis. Very simple\n \t      propagation across the callgraph is done i.e. to discover\n \t      functions without side effects and simple inlining is performed.\n \n \t   b) early small interprocedural passes.\n \n \t      Those are interprocedural passes executed only at compilation\n-\t      time.  These include, for example, transational memory lowering,\n+\t      time.  These include, for example, transactional memory lowering,\n \t      unreachable code removal and other simple transformations.\n \n \t   c) IP analysis stage.  All interprocedural passes do their\n@@ -107,7 +107,7 @@ along with GCC; see the file COPYING3.  If not see\n \t      IP propagation. This is done based on the earlier analysis\n \t      without having function bodies at hand.\n \t   f) Ltrans streaming.  When doing WHOPR LTO, the program\n-\t      is partitioned and streamed into multple object files.\n+\t      is partitioned and streamed into multiple object files.\n \n        Compile time and/or parallel linktime stage (ltrans)\n \n@@ -118,7 +118,7 @@ along with GCC; see the file COPYING3.  If not see\n \t 2) Virtual clone materialization\n \t    (cgraph_materialize_clone)\n \n-\t    IP passes can produce copies of existing functoins (such\n+\t    IP passes can produce copies of existing functions (such\n \t    as versioned clones or inline clones) without actually\n \t    manipulating their bodies by creating virtual clones in\n \t    the callgraph. At this time the virtual clones are\n@@ -336,7 +336,7 @@ symbol_table::process_new_functions (void)\n \t    {\n \t      bool summaried_computed = ipa_fn_summaries != NULL;\n \t      g->get_passes ()->execute_early_local_passes ();\n-\t      /* Early passes compure inline parameters to do inlining\n+\t      /* Early passes compute inline parameters to do inlining\n \t\t and splitting.  This is redundant for functions added late.\n \t\t Just throw away whatever it did.  */\n \t      if (!summaried_computed)\n@@ -694,8 +694,8 @@ cgraph_node::analyze (void)\n \n /* C++ frontend produce same body aliases all over the place, even before PCH\n    gets streamed out. It relies on us linking the aliases with their function\n-   in order to do the fixups, but ipa-ref is not PCH safe.  Consequentely we\n-   first produce aliases without links, but once C++ FE is sure he won't sream\n+   in order to do the fixups, but ipa-ref is not PCH safe.  Consequently we\n+   first produce aliases without links, but once C++ FE is sure he won't stream\n    PCH we build the links via this function.  */\n \n void\n@@ -854,7 +854,7 @@ varpool_node::finalize_decl (tree decl)\n     node->no_reorder = true;\n   if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n       /* Traditionally we do not eliminate static variables when not\n-\t optimizing and when not doing toplevel reoder.  */\n+\t optimizing and when not doing toplevel reorder.  */\n       || (node->no_reorder && !DECL_COMDAT (node->decl)\n \t  && !DECL_ARTIFICIAL (node->decl)))\n     node->force_output = true;\n@@ -875,7 +875,7 @@ varpool_node::finalize_decl (tree decl)\n /* EDGE is an polymorphic call.  Mark all possible targets as reachable\n    and if there is only one target, perform trivial devirtualization. \n    REACHABLE_CALL_TARGETS collects target lists we already walked to\n-   avoid udplicate work.  */\n+   avoid duplicate work.  */\n \n static void\n walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n@@ -1135,7 +1135,7 @@ analyze_functions (bool first_time)\n \t\t\t|| opt_for_fn (edge->callee->decl, optimize)\n \t\t\t/* Weakrefs needs to be preserved.  */\n \t\t\t|| edge->callee->alias\n-\t\t\t/* always_inline functions are inlined aven at -O0.  */\n+\t\t\t/* always_inline functions are inlined even at -O0.  */\n \t\t        || lookup_attribute\n \t\t\t\t (\"always_inline\",\n \t\t\t          DECL_ATTRIBUTES (edge->callee->decl))\n@@ -1229,7 +1229,7 @@ analyze_functions (bool first_time)\n     {\n       next = node->next;\n       /* For symbols declared locally we clear TREE_READONLY when emitting\n-\t the construtor (if one is needed).  For external declarations we can\n+\t the constructor (if one is needed).  For external declarations we can\n \t not safely assume that the type is readonly because we may be called\n \t during its construction.  */\n       if (TREE_CODE (node->decl) == VAR_DECL\n@@ -1862,7 +1862,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       greturn *ret;\n       bool alias_is_noreturn = TREE_THIS_VOLATILE (alias);\n \n-      /* We may be called from expand_thunk that releses body except for\n+      /* We may be called from expand_thunk that releases body except for\n \t DECL_ARGUMENTS.  In this case force_gimple_thunk is true.  */\n       if (in_lto_p && !force_gimple_thunk)\n \tget_untransformed_body ();\n@@ -1995,7 +1995,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t  gimple_call_set_chain (call, decl);\n \t}\n \n-      /* Return slot optimization is always possible and in fact requred to\n+      /* Return slot optimization is always possible and in fact required to\n          return values with DECL_BY_REFERENCE.  */\n       if (aggregate_value_p (resdecl, TREE_TYPE (thunk_fndecl))\n \t  && (!is_gimple_reg_type (TREE_TYPE (resdecl))\n@@ -2252,12 +2252,13 @@ cgraph_node::expand (void)\n   if (cfun)\n     pop_cfun ();\n \n-  /* It would make a lot more sense to output thunks before function body to get more\n-     forward and lest backwarding jumps.  This however would need solving problem\n-     with comdats. See PR48668.  Also aliases must come after function itself to\n-     make one pass assemblers, like one on AIX, happy.  See PR 50689.\n-     FIXME: Perhaps thunks should be move before function IFF they are not in comdat\n-     groups.  */\n+  /* It would make a lot more sense to output thunks before function body to\n+     get more forward and fewer backward jumps.  This however would need\n+     solving problem with comdats.  See PR48668.  Also aliases must come after\n+     function itself to make one pass assemblers, like one on AIX, happy.\n+     See PR 50689.\n+     FIXME: Perhaps thunks should be move before function IFF they are not in\n+     comdat groups.  */\n   assemble_thunks_and_aliases ();\n   release_body ();\n   /* Eliminate all call edges.  This is important so the GIMPLE_CALL no longer\n@@ -2266,7 +2267,7 @@ cgraph_node::expand (void)\n   remove_all_references ();\n }\n \n-/* Node comparer that is responsible for the order that corresponds\n+/* Node comparator that is responsible for the order that corresponds\n    to time when a function was launched for the first time.  */\n \n static int\n@@ -2650,14 +2651,14 @@ symbol_table::compile (void)\n \n   /* When weakref support is missing, we automatically translate all\n      references to NODE to references to its ultimate alias target.\n-     The renaming mechanizm uses flag IDENTIFIER_TRANSPARENT_ALIAS and\n+     The renaming mechanism uses flag IDENTIFIER_TRANSPARENT_ALIAS and\n      TREE_CHAIN.\n \n      Set up this mapping before we output any assembler but once we are sure\n      that all symbol renaming is done.\n \n-     FIXME: All this uglyness can go away if we just do renaming at gimple\n-     level by physically rewritting the IL.  At the moment we can only redirect\n+     FIXME: All this ugliness can go away if we just do renaming at gimple\n+     level by physically rewriting the IL.  At the moment we can only redirect\n      calls, so we need infrastructure for renaming references as well.  */\n #ifndef ASM_OUTPUT_WEAKREF\n   symtab_node *node;"}, {"sha": "a9674af9c941b9c23aef942fc941e5bd44572e46", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -102,7 +102,7 @@ struct GTY(()) param_access\n {\n   /* Type that a potential replacement should have.  This field only has\n      meaning in the summary building and transformation phases, when it is\n-     reconstructoed from the body.  Must not be touched in IPA analysys\n+     reconstructed from the body.  Must not be touched in IPA analysis\n      stage.  */\n   tree type;\n \n@@ -123,7 +123,7 @@ struct GTY(()) param_access\n   unsigned reverse : 1;\n };\n \n-/* This structure has the same purpose as the one above and additoonally it\n+/* This structure has the same purpose as the one above and additionally it\n    contains some fields that are only necessary in the summary generation\n    phase.  */\n \n@@ -142,10 +142,10 @@ struct gensum_param_access\n \n   /* Type that a potential replacement should have.  This field only has\n      meaning in the summary building and transformation phases, when it is\n-     reconstructoed from the body.  Must not be touched in IPA analysys\n+     reconstructed from the body.  Must not be touched in IPA analysis\n      stage.  */\n   tree type;\n-  /* Alias refrerence type to be used in MEM_REFs when adjusting caller\n+  /* Alias reference type to be used in MEM_REFs when adjusting caller\n      arguments.  */\n   tree alias_ptr_type;\n \n@@ -188,7 +188,7 @@ struct gensum_param_desc\n   /* Number of accesses in the access tree rooted in field accesses.  */\n   unsigned access_count;\n \n-  /* If the below is non-zero, this is the nuber of uses as actual arguents.  */\n+  /* If the below is non-zero, this is the number of uses as actual arguments.  */\n   int call_uses;\n   /* Number of times this parameter has been directly passed to.  */\n   unsigned ptr_pt_count;\n@@ -203,7 +203,7 @@ struct gensum_param_desc\n   bool locally_unused;\n   /* An aggregate that is a candidate for breaking up or a pointer passing data\n      by reference that is a candidate for being converted to a set of\n-     parameters passing thosa data by value.  */\n+     parameters passing those data by value.  */\n   bool split_candidate;\n   /* Is this a parameter passing stuff by reference?  */\n   bool by_ref;\n@@ -215,7 +215,7 @@ struct gensum_param_desc\n   int deref_index;\n };\n \n-/* Properly deallocate accesses of DESC.  TODO: Since this data strucutre is\n+/* Properly deallocate accesses of DESC.  TODO: Since this data structure is\n    not in GC memory, this is not necessary and we can consider removing the\n    function.  */\n \n@@ -229,7 +229,7 @@ free_param_decl_accesses (isra_param_desc *desc)\n }\n \n /* Class used to convey information about functions from the\n-   intra-procedurwl analysis stage to inter-procedural one.  */\n+   intra-procedural analysis stage to inter-procedural one.  */\n \n class GTY((for_user)) isra_func_summary\n {\n@@ -245,7 +245,7 @@ class GTY((for_user)) isra_func_summary\n \n   ~isra_func_summary ();\n \n-  /* Mark the function as not a candidate for any IPA-SRA transofrmation.\n+  /* Mark the function as not a candidate for any IPA-SRA transformation.\n      Return true if it was a candidate until now.  */\n \n   bool zap ();\n@@ -272,8 +272,8 @@ class GTY((for_user)) isra_func_summary\n   unsigned m_queued : 1;\n };\n \n-/* Claen up and deallocate isra_func_summary points to.  TODO: Since this data\n-   strucutre is not in GC memory, this is not necessary and we can consider\n+/* Clean up and deallocate isra_func_summary points to.  TODO: Since this data\n+   structure is not in GC memory, this is not necessary and we can consider\n    removing the destructor.  */\n \n isra_func_summary::~isra_func_summary ()\n@@ -285,7 +285,7 @@ isra_func_summary::~isra_func_summary ()\n }\n \n \n-/* Mark the function as not a candidate for any IPA-SRA transofrmation.  Return\n+/* Mark the function as not a candidate for any IPA-SRA transformation.  Return\n    true if it was a candidate until now.  */\n \n bool\n@@ -313,7 +313,7 @@ struct isra_param_flow\n      If aggregate_pass_through or pointer_pass_through below are true, it must\n      contain exactly one element which is passed through from a formal\n      parameter if the given number.  Otherwise, the array contains indices of\n-     collee's formal parameters which are used to calculate value of this\n+     callee's formal parameters which are used to calculate value of this\n      actual argument. */\n   unsigned char inputs[IPA_SRA_MAX_PARAM_FLOW_LEN];\n \n@@ -333,7 +333,7 @@ struct isra_param_flow\n   unsigned safe_to_import_accesses : 1;\n };\n \n-/* Strucutre used to convey information about calls from the intra-procedurwl\n+/* Structure used to convey information about calls from the intra-procedural\n    analysis stage to inter-procedural one.  */\n \n class isra_call_summary\n@@ -348,7 +348,7 @@ class isra_call_summary\n   void dump (FILE *f);\n \n   /* Information about what formal parameters of the caller are used to compute\n-     indivisual actual arguments of this call.  */\n+     individual actual arguments of this call.  */\n   auto_vec <isra_param_flow> m_arg_flow;\n \n   /* Set to true if the call statement does not have a LHS.  */\n@@ -502,7 +502,7 @@ isra_call_summary::dump (FILE *f)\n     }\n }\n \n-/* Duplicate edge summare when an edge is cloned.  */\n+/* Duplicate edge summary when an edge is cloned.  */\n \n void\n ipa_sra_call_summaries::duplicate (cgraph_edge *, cgraph_edge *,\n@@ -526,7 +526,7 @@ namespace {\n \n hash_map<tree, gensum_param_desc *> *decl2desc;\n \n-/* Countdown of allowe Alias analysis steps during summary building.  */\n+/* Countdown of allowed Alias analysis steps during summary building.  */\n \n int aa_walking_limit;\n \n@@ -679,7 +679,7 @@ dump_gensum_param_descriptor (FILE *f, gensum_param_desc *desc)\n     dump_gensum_access (f, acc, 2);\n }\n \n-/* Dump all parameter descriptors in IFS, assuming it describes FNDECl, to\n+/* Dump all parameter descriptors in IFS, assuming it describes FNDECL, to\n    F.  */\n \n static void\n@@ -724,7 +724,7 @@ dump_isra_param_descriptor (FILE *f, isra_param_desc *desc)\n     }\n }\n \n-/* Dump all parameter descriptors in IFS, assuming it describes FNDECl, to\n+/* Dump all parameter descriptors in IFS, assuming it describes FNDECL, to\n    F.  */\n \n static void\n@@ -1288,10 +1288,10 @@ enum isra_scan_context {ISRA_CTX_LOAD, ISRA_CTX_ARG, ISRA_CTX_STORE};\n \n /* Return an access describing memory access to the variable described by DESC\n    at OFFSET with SIZE in context CTX, starting at pointer to the linked list\n-   at a certaint tree level FIRST.  Attempt to create it and put into the\n+   at a certain tree level FIRST.  Attempt to create it and put into the\n    appropriate place in the access tree if does not exist, but fail and return\n    NULL if there are already too many accesses, if it would create a partially\n-   overlapping access or if an access would end up withiin a pre-existing\n+   overlapping access or if an access would end up within a pre-existing\n    non-call access.  */\n \n static gensum_param_access *\n@@ -1416,7 +1416,7 @@ get_access_1 (gensum_param_desc *desc, gensum_param_access **first,\n    at OFFSET with SIZE in context CTX, mark it as used in context CTX.  Attempt\n    to create if it does not exist, but fail and return NULL if there are\n    already too many accesses, if it would create a partially overlapping access\n-   or if an access woule end up in a non-call access.  */\n+   or if an access would end up in a non-call access.  */\n \n static gensum_param_access *\n get_access (gensum_param_desc *desc, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n@@ -1449,7 +1449,7 @@ get_access (gensum_param_desc *desc, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n }\n \n /* Verify that parameter access tree starting with ACCESS is in good shape.\n-   PARENT_OFFSET and PARENT_SIZE are the ciorresponding fields of parent of\n+   PARENT_OFFSET and PARENT_SIZE are the corresponding fields of parent of\n    ACCESS or zero if there is none.  */\n \n static bool\n@@ -1591,7 +1591,7 @@ type_prevails_p (tree old_type, tree new_type)\n }\n \n /* When scanning an expression which is a call argument, this structure\n-   specifies the call and the position of the agrument.  */\n+   specifies the call and the position of the argument.  */\n \n struct scan_call_info\n {\n@@ -1636,7 +1636,7 @@ mark_maybe_modified (ao_ref *, tree, void *data)\n /* Analyze expression EXPR from GIMPLE for accesses to parameters. CTX\n    specifies whether EXPR is used in a load, store or as an argument call. BB\n    must be the basic block in which expr resides.  If CTX specifies call\n-   arguemnt context, CALL_INFO must describe tha call and argument position,\n+   argument context, CALL_INFO must describe that call and argument position,\n    otherwise it is ignored.  */\n \n static void\n@@ -1767,7 +1767,7 @@ scan_expr_access (tree expr, gimple *stmt, isra_scan_context ctx,\n     }\n   else\n     /* Pointer parameters with direct uses should have been ruled out by\n-       analyzing SSA default def when looking at the paremeters.  */\n+       analyzing SSA default def when looking at the parameters.  */\n     gcc_assert (!desc->by_ref);\n \n   gensum_param_access *access = get_access (desc, offset, size, ctx);\n@@ -1818,8 +1818,8 @@ scan_expr_access (tree expr, gimple *stmt, isra_scan_context ctx,\n \t{\n \t  /* We need the same aggregate type on all accesses to be able to\n \t     distinguish transformation spots from pass-through arguments in\n-\t     the transofrmation phase.  */\n-\t  disqualify_split_candidate (desc, \"We do not support aggegate \"\n+\t     the transformation phase.  */\n+\t  disqualify_split_candidate (desc, \"We do not support aggregate \"\n \t\t\t\t      \"type punning.\");\n \t  return;\n \t}\n@@ -2320,7 +2320,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n      offset in this function at IPA level.\n \n      TODO: Measure the overhead and the effect of just being pessimistic.\n-     Maybe this is ony -O3 material?\n+     Maybe this is only -O3 material?\n   */\n   bool pdoms_calculated = false;\n   if (check_pass_throughs)\n@@ -2377,7 +2377,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \n   /* TODO: Add early exit if we disqualified everything.  This also requires\n      that we either relax the restriction that\n-     ipa_param_adjustments.m_always_copy_start mut be the number of PARM_DECLs\n+     ipa_param_adjustments.m_always_copy_start must be the number of PARM_DECLs\n      or store the number of parameters to IPA-SRA function summary and use that\n      when just removing params.  */\n \n@@ -2405,7 +2405,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n }\n \n /* Return true if there are any overlaps among certain accesses of DESC.  If\n-   non-NULL, set *CERTAIN_ACCESS_PRESENT_P upon encountering a certain accesss\n+   non-NULL, set *CERTAIN_ACCESS_PRESENT_P upon encountering a certain access\n    too.  DESC is assumed to be a split candidate that is not locally\n    unused.  */\n \n@@ -2556,7 +2556,7 @@ ipa_sra_generate_summary (void)\n   return;\n }\n \n-/* Write intraproceural analysis information about E and all of its outgoing\n+/* Write intraprocedural analysis information about E and all of its outgoing\n    edges into a stream for LTO WPA.  */\n \n static void\n@@ -2586,7 +2586,7 @@ isra_write_edge_summary (output_block *ob, cgraph_edge *e)\n   streamer_write_bitpack (&bp);\n }\n \n-/* Write intraproceural analysis information about NODE and all of its outgoing\n+/* Write intraprocedural analysis information about NODE and all of its outgoing\n    edges into a stream for LTO WPA.  */\n \n static void\n@@ -2636,7 +2636,7 @@ isra_write_node_summary (output_block *ob, cgraph_node *node)\n     isra_write_edge_summary (ob, e);\n }\n \n-/* Write intraproceural analysis information into a stream for LTO WPA.  */\n+/* Write intraprocedural analysis information into a stream for LTO WPA.  */\n \n static void\n ipa_sra_write_summary (void)\n@@ -2675,7 +2675,7 @@ ipa_sra_write_summary (void)\n   destroy_output_block (ob);\n }\n \n-/* Read intraproceural analysis information about E and all of its outgoing\n+/* Read intraprocedural analysis information about E and all of its outgoing\n    edges into a stream for LTO WPA.  */\n \n static void\n@@ -2703,7 +2703,7 @@ isra_read_edge_summary (struct lto_input_block *ib, cgraph_edge *cs)\n   csum->m_bit_aligned_arg = bp_unpack_value (&bp, 1);\n }\n \n-/* Read intraproceural analysis information about NODE and all of its outgoing\n+/* Read intraprocedural analysis information about NODE and all of its outgoing\n    edges into a stream for LTO WPA.  */\n \n static void\n@@ -2794,7 +2794,7 @@ isra_read_summary_section (struct lto_file_decl_data *file_data,\n   lto_data_in_delete (data_in);\n }\n \n-/* Read intraproceural analysis information into a stream for LTO WPA.  */\n+/* Read intraprocedural analysis information into a stream for LTO WPA.  */\n \n static void\n ipa_sra_read_summary (void)\n@@ -2969,7 +2969,7 @@ check_all_callers_for_issues (cgraph_node *node)\n \t TODO: We could only prevent splitting the problematic parameters if\n \t anybody thinks it is worth it.  */\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"A call of %s has bit-alinged aggregate argument,\"\n+\tfprintf (dump_file, \"A call of %s has bit-aligned aggregate argument,\"\n \t\t \" disabling parameter splitting.\\n\", node->dump_name ());\n \n       isra_func_summary *ifs = func_sums->get (node);\n@@ -3375,7 +3375,7 @@ pull_accesses_from_callee (isra_param_desc *param_desc,\n /* Propagate parameter splitting information through call graph edge CS.\n    Return true if any changes that might need to be propagated within SCCs have\n    been made.  The function also clears the aggregate_pass_through and\n-   pointer_pass_through in call summarries which do not need to be processed\n+   pointer_pass_through in call summaries which do not need to be processed\n    again if this CS is revisited when iterating while changes are propagated\n    within an SCC.  */\n \n@@ -3678,7 +3678,7 @@ push_param_adjustments_for_index (isra_func_summary *ifs, unsigned base_index,\n }\n \n \n-/* Do finall processing of results of IPA propagation regarding NODE, clone it\n+/* Do final processing of results of IPA propagation regarding NODE, clone it\n    if appropriate.  */\n \n static void"}, {"sha": "3e634e22c8668bc00dfa05772c8f0351cc398206", "filename": "gcc/symtab.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -253,7 +253,7 @@ symbol_table::symtab_prevail_in_asm_name_hash (symtab_node *node)\n   insert_to_assembler_name_hash (node, false);\n }\n \n-/* Initalize asm name hash unless.  */\n+/* Initialize asm name hash unless.  */\n \n void\n symbol_table::symtab_initialize_asm_name_hash (void)\n@@ -551,7 +551,7 @@ symtab_node::dump_asm_name () const\n }\n \n /* Return ipa reference from this symtab_node to\n-   REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+   REFERRED_NODE or REFERRED_VARPOOL_NODE. USE_TYPE specify type\n    of the use.  */\n \n ipa_ref *\n@@ -563,7 +563,7 @@ symtab_node::create_reference (symtab_node *referred_node,\n \n \n /* Return ipa reference from this symtab_node to\n-   REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+   REFERRED_NODE or REFERRED_VARPOOL_NODE. USE_TYPE specify type\n    of the use and STMT the statement (if it exists).  */\n \n ipa_ref *\n@@ -732,7 +732,7 @@ symtab_node::remove_stmt_references (gimple *stmt)\n }\n \n /* Remove all stmt references in non-speculative references.\n-   Those are not maintained during inlining & clonning.\n+   Those are not maintained during inlining & cloning.\n    The exception are speculative references that are updated along\n    with callgraph edges associated with them.  */\n \n@@ -1453,7 +1453,7 @@ symtab_node::ultimate_alias_target_1 (enum availability *availability,\n      availability prevails the availability of its target (i.e. static alias of\n      weak definition is available.\n \n-     Transaparent alias is just alternative anme of a given symbol used within\n+     Transparent alias is just alternative name of a given symbol used within\n      one compilation unit and is translated prior hitting the object file.  It\n      inherits the visibility of its target.\n      Weakref is a different animal (and noweak definition is weak).\n@@ -1670,7 +1670,7 @@ symtab_node::set_init_priority (priority_type priority)\n   h->init = priority;\n }\n \n-/* Set fialization priority to PRIORITY.  */\n+/* Set finalization priority to PRIORITY.  */\n \n void\n cgraph_node::set_fini_priority (priority_type priority)\n@@ -1915,7 +1915,7 @@ enum symbol_partitioning_class\n symtab_node::get_partitioning_class (void)\n {\n   /* Inline clones are always duplicated.\n-     This include external delcarations.   */\n+     This include external declarations.   */\n   cgraph_node *cnode = dyn_cast <cgraph_node *> (this);\n \n   if (DECL_ABSTRACT_P (decl))\n@@ -2040,7 +2040,7 @@ symtab_node::nonzero_address ()\n \n    If MEMORY_ACCESSED is true, assume that both memory pointer to THIS\n    and S2 is going to be accessed.  This eliminates the situations when\n-   either THIS or S2 is NULL and is seful for comparing bases when deciding\n+   either THIS or S2 is NULL and is useful for comparing bases when deciding\n    about memory aliasing.  */\n int\n symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n@@ -2074,7 +2074,7 @@ symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n      code and are used only within speculation.  In this case we may make\n      symbol equivalent to its alias even if interposition may break this\n      rule.  Doing so will allow us to turn speculative inlining into\n-     non-speculative more agressively.  */\n+     non-speculative more aggressively.  */\n   if (DECL_VIRTUAL_P (this->decl) && avail1 >= AVAIL_AVAILABLE)\n     binds_local1 = true;\n   if (DECL_VIRTUAL_P (s2->decl) && avail2 >= AVAIL_AVAILABLE)\n@@ -2130,7 +2130,7 @@ symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n \n   /* TODO: Alias oracle basically assume that addresses of global variables\n      are different unless they are declared as alias of one to another while\n-     the code folding comparsions doesn't.\n+     the code folding comparisons doesn't.\n      We probably should be consistent and use this fact here, too, but for\n      the moment return false only when we are called from the alias oracle.  */\n \n@@ -2389,8 +2389,8 @@ symtab_node::output_to_lto_symbol_table_p (void)\n     }\n \n   /* We have real symbol that should be in symbol table.  However try to trim\n-     down the refernces to libraries bit more because linker will otherwise\n-     bring unnecesary object files into the final link.\n+     down the references to libraries bit more because linker will otherwise\n+     bring unnecessary object files into the final link.\n      FIXME: The following checks can easily be confused i.e. by self recursive\n      function or self-referring variable.  */\n "}, {"sha": "15c0c4576b71b747401dc432e9f3b9f72ed688ea", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -1882,7 +1882,7 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t\t  tree adj = fold_build2_loc (loc, MINUS_EXPR,\n \t\t\t\t\t      TREE_TYPE (lhs), lhs, old);\n \t\t  adjust_related_strinfos (loc, si, adj);\n-\t\t  /* Use the constant minimim length as the lower bound\n+\t\t  /* Use the constant minimum length as the lower bound\n \t\t     of the non-constant length.  */\n \t\t  wide_int min = wi::to_wide (old);\n \t\t  wide_int max\n@@ -2145,7 +2145,7 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       strinfo *chainsi;\n \n       /* If string length of src is unknown, use delayed length\n-\t computation.  If string lenth of dst will be needed, it\n+\t computation.  If string length of dst will be needed, it\n \t can be computed by transforming this strcpy call into\n \t stpcpy and subtracting dst from the return value.  */\n \n@@ -2665,7 +2665,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n \n   if (tree dstsize = compute_objsize (dst, 1))\n     {\n-      /* The source length is uknown.  Try to determine the destination\n+      /* The source length is unknown.  Try to determine the destination\n \t size and see if it matches the specified bound.  If not, bail.\n \t Otherwise go on to see if it should be diagnosed for possible\n \t truncation.  */\n@@ -2764,7 +2764,7 @@ handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n     }\n \n   /* If the length argument was computed from strlen(S) for some string\n-     S retrieve the strinfo index for the string (PSS->FIRST) alonng with\n+     S retrieve the strinfo index for the string (PSS->FIRST) along with\n      the location of the strlen() call (PSS->SECOND).  */\n   stridx_strlenloc *pss = strlen_to_stridx->get (len);\n   if (!pss || pss->first <= 0)\n@@ -3267,7 +3267,7 @@ handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n /* Handle a call to memset.\n    After a call to calloc, memset(,0,) is unnecessary.\n    memset(malloc(n),0,n) is calloc(n,1).\n-   return true when the call is transfomred, false otherwise.  */\n+   return true when the call is transformed, false otherwise.  */\n \n static bool\n handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write)\n@@ -4463,7 +4463,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write, const vr_values *rval\n \t     statement and return to signal the caller that it shouldn't\n \t     invalidate anything.\n \n-\t     This is benefical for cases like:\n+\t     This is beneficial for cases like:\n \n \t     char p[20];\n \t     void foo (char *q)"}, {"sha": "ff49ad9f5175d6722871061b740dee736983fefa", "filename": "gcc/varpool.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=dfea3d6fde2b62e76d06c5ab78db7931b5f4ba13", "patch": "@@ -204,7 +204,7 @@ varpool_node::remove_initializer (void)\n       && debug_info_level == DINFO_LEVEL_NONE\n       /* When doing declaration merging we have duplicate\n \t entries for given decl.  Do not attempt to remove\n-\t the boides, or we will end up remiving\n+\t the bodies, or we will end up removing\n \t wrong one.  */\n       && symtab->state != LTO_STREAMING)\n     DECL_INITIAL (decl) = error_mark_node;\n@@ -365,7 +365,7 @@ varpool_node::ctor_useable_for_folding_p (void)\n      overridden at link or run time.\n \n      It is actually requirement for C++ compiler to optimize const variables\n-     consistently. As a GNU extension, do not enfore this rule for user defined\n+     consistently. As a GNU extension, do not enforce this rule for user defined\n      weak variables, so we support interposition on:\n      static const int dummy = 0;\n      extern const int foo __attribute__((__weak__, __alias__(\"dummy\"))); \n@@ -409,7 +409,7 @@ ctor_for_folding (tree decl)\n     return error_mark_node;\n \n   /* Do not care about automatic variables.  Those are never initialized\n-     anyway, because gimplifier exapnds the code.  */\n+     anyway, because gimplifier expands the code.  */\n   if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n     {\n       gcc_assert (!TREE_PUBLIC (decl));\n@@ -552,7 +552,7 @@ varpool_node::assemble_aliases (void)\n bool\n varpool_node::assemble_decl (void)\n {\n-  /* Aliases are outout when their target is produced or by\n+  /* Aliases are output when their target is produced or by\n      output_weakrefs.  */\n   if (alias)\n     return false;\n@@ -790,8 +790,8 @@ varpool_node::create_extra_name_alias (tree alias, tree decl)\n   alias_node = varpool_node::create_alias (alias, decl);\n   alias_node->cpp_implicit_alias = true;\n \n-  /* Extra name alias mechanizm creates aliases really late\n-     via DECL_ASSEMBLER_NAME mechanizm.\n+  /* Extra name alias mechanism creates aliases really late\n+     via DECL_ASSEMBLER_NAME mechanism.\n      This is unfortunate because they are not going through the\n      standard channels.  Ensure they get output.  */\n   if (symtab->cpp_implicit_aliases_done)"}]}