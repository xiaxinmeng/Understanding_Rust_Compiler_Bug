{"sha": "4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlZDZiMjU0NGQ1YjY2NzhmZjEzOWUzZjFlMWZkOTkzNzQ3ZmM4Mw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-05-27T09:28:48Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-05-27T09:28:48Z"}, "message": "re PR fortran/57423 (Incorrect keyword argument names in Fortran OpenMP procedure interfaces in omp_lib)\n\n2013-05-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/57423\n        * libgomp.texi (omp_set_dynamic, omp_set_nested, omp_set_nested,\n        omp_set_num_threads, omp_init_lock, omp_set_lock, omp_test_lock,\n        omp_unset_lock, omp_destroy_lock, omp_init_nest_lock,\n        omp_set_nest_lock, omp_test_nest_lock, omp_unset_nest_lock,\n        omp_destroy_nest_lock): Correct arguments to match the one in\n        the OpenMP spec.\n        * omp_lib.f90.in (omp_init_lock, omp_init_nest_lock,  omp_destroy_lock\n        omp_destroy_nest_lock, omp_set_lock, omp_set_nest_lock, omp_unset_lock,\n        omp_unset_nest_lock, omp_set_dynamic, omp_set_nested,\n        omp_set_num_threads, omp_test_lock, omp_test_nest_lock): Ditto.\n\nFrom-SVN: r199351", "tree": {"sha": "897bfa26ba426aa5090676895b1b0602d049c0c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/897bfa26ba426aa5090676895b1b0602d049c0c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fed6b2544d5b6678ff139e3f1e1fd993747fc83/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b03be25f05a47f7b112fc0c625fde29c1492d90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03be25f05a47f7b112fc0c625fde29c1492d90e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b03be25f05a47f7b112fc0c625fde29c1492d90e"}], "stats": {"total": 136, "additions": 75, "deletions": 61}, "files": [{"sha": "1747cec09886c6d56f3e54e7fa993815bb3ddbef", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fed6b2544d5b6678ff139e3f1e1fd993747fc83/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fed6b2544d5b6678ff139e3f1e1fd993747fc83/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "patch": "@@ -1,3 +1,17 @@\n+2013-05-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/57423\n+\t* libgomp.texi (omp_set_dynamic, omp_set_nested, omp_set_nested,\n+\tomp_set_num_threads, omp_init_lock, omp_set_lock, omp_test_lock,\n+\tomp_unset_lock, omp_destroy_lock, omp_init_nest_lock,\n+\tomp_set_nest_lock, omp_test_nest_lock, omp_unset_nest_lock,\n+\tomp_destroy_nest_lock): Correct arguments to match the one in\n+\tthe OpenMP spec.\n+\t* omp_lib.f90.in (omp_init_lock, omp_init_nest_lock, omp_destroy_lock\n+\tomp_destroy_nest_lock, omp_set_lock, omp_set_nest_lock, omp_unset_lock,\n+\tomp_unset_nest_lock, omp_set_dynamic, omp_set_nested,\n+\tomp_set_num_threads, omp_test_lock, omp_test_nest_lock): Ditto.\n+\n 2013-05-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c/loop-13.c: New test."}, {"sha": "2985128f8ac8a84c10f704641f183078f8e7253c", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fed6b2544d5b6678ff139e3f1e1fd993747fc83/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fed6b2544d5b6678ff139e3f1e1fd993747fc83/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "patch": "@@ -601,13 +601,13 @@ adjustment of team sizes and @code{false} disables it.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_set_dynamic(int set);}\n+@item @emph{Prototype}: @tab @code{void omp_set_dynamic(int dynamic_threads);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_dynamic(set)}\n-@item                   @tab @code{logical, intent(in) :: set}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_dynamic(dynamic_threads)}\n+@item                   @tab @code{logical, intent(in) :: dynamic_threads}\n @end multitable\n \n @item @emph{See also}:\n@@ -657,13 +657,13 @@ dynamic adjustment of team sizes and @code{false} disables it.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_set_nested(int set);}\n+@item @emph{Prototype}: @tab @code{void omp_set_nested(int nested);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_nested(set)}\n-@item                   @tab @code{logical, intent(in) :: set}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_nested(nested)}\n+@item                   @tab @code{logical, intent(in) :: nested}\n @end multitable\n \n @item @emph{See also}:\n@@ -685,13 +685,13 @@ argument of @code{omp_set_num_threads} shall be a positive integer.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_set_num_threads(int n);}\n+@item @emph{Prototype}: @tab @code{void omp_set_num_threads(int num_threads);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_num_threads(n)}\n-@item                   @tab @code{integer, intent(in) :: n}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_num_threads(num_threads)}\n+@item                   @tab @code{integer, intent(in) :: num_threads}\n @end multitable\n \n @item @emph{See also}:\n@@ -750,8 +750,8 @@ an unlocked state.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_init_lock(lock)}\n-@item                   @tab @code{integer(omp_lock_kind), intent(out) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_init_lock(svar)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(out) :: svar}\n @end multitable\n \n @item @emph{See also}:\n@@ -779,8 +779,8 @@ a deadlock occurs.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_lock(lock)}\n-@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_lock(svar)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: svar}\n @end multitable\n \n @item @emph{See also}:\n@@ -809,8 +809,8 @@ does not block if the lock is not available. This function returns\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{logical function omp_test_lock(lock)}\n-@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{logical function omp_test_lock(svar)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: svar}\n @end multitable\n \n @item @emph{See also}:\n@@ -839,8 +839,8 @@ again, set the lock to itself.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_unset_lock(lock)}\n-@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_unset_lock(svar)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: svar}\n @end multitable\n \n @item @emph{See also}:\n@@ -866,8 +866,8 @@ in the unlocked state.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_destroy_lock(lock)}\n-@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_destroy_lock(svar)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: svar}\n @end multitable\n \n @item @emph{See also}:\n@@ -893,8 +893,8 @@ an unlocked state and the nesting count is set to zero.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_init_nest_lock(lock)}\n-@item                   @tab @code{integer(omp_nest_lock_kind), intent(out) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_init_nest_lock(nvar)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(out) :: nvar}\n @end multitable\n \n @item @emph{See also}:\n@@ -921,8 +921,8 @@ nesting count for the lock is incremented.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_nest_lock(lock)}\n-@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_nest_lock(nvar)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: nvar}\n @end multitable\n \n @item @emph{See also}:\n@@ -951,8 +951,8 @@ is returned. Otherwise, the return value equals zero.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{logical function omp_test_nest_lock(lock)}\n-@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{logical function omp_test_nest_lock(nvar)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: nvar}\n @end multitable\n \n \n@@ -982,8 +982,8 @@ one of them is chosen to, again, set the lock to itself.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_unset_nest_lock(lock)}\n-@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_unset_nest_lock(nvar)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: nvar}\n @end multitable\n \n @item @emph{See also}:\n@@ -1009,8 +1009,8 @@ in the unlocked state and its nesting count must equal zero.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_destroy_nest_lock(lock)}\n-@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: lock}\n+@item @emph{Interface}: @tab @code{subroutine omp_destroy_nest_lock(nvar)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: nvar}\n @end multitable\n \n @item @emph{See also}:"}, {"sha": "c9bc5fd003ade11e3ca06771ddb45e29f8faac38", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fed6b2544d5b6678ff139e3f1e1fd993747fc83/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fed6b2544d5b6678ff139e3f1e1fd993747fc83/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "patch": "@@ -39,85 +39,85 @@\n         integer (omp_sched_kind), parameter :: omp_sched_auto = 4\n \n         interface\n-          subroutine omp_init_lock (lock)\n+          subroutine omp_init_lock (svar)\n             use omp_lib_kinds\n-            integer (omp_lock_kind), intent (out) :: lock\n+            integer (omp_lock_kind), intent (out) :: svar\n           end subroutine omp_init_lock\n         end interface\n \n         interface\n-          subroutine omp_init_nest_lock (lock)\n+          subroutine omp_init_nest_lock (nvar)\n             use omp_lib_kinds\n-            integer (omp_nest_lock_kind), intent (out) :: lock\n+            integer (omp_nest_lock_kind), intent (out) :: nvar\n           end subroutine omp_init_nest_lock\n         end interface\n \n         interface\n-          subroutine omp_destroy_lock (lock)\n+          subroutine omp_destroy_lock (svar)\n             use omp_lib_kinds\n-            integer (omp_lock_kind), intent (inout) :: lock\n+            integer (omp_lock_kind), intent (inout) :: svar\n           end subroutine omp_destroy_lock\n         end interface\n \n         interface\n-          subroutine omp_destroy_nest_lock (lock)\n+          subroutine omp_destroy_nest_lock (nvar)\n             use omp_lib_kinds\n-            integer (omp_nest_lock_kind), intent (inout) :: lock\n+            integer (omp_nest_lock_kind), intent (inout) :: nvar\n           end subroutine omp_destroy_nest_lock\n         end interface\n \n         interface\n-          subroutine omp_set_lock (lock)\n+          subroutine omp_set_lock (svar)\n             use omp_lib_kinds\n-            integer (omp_lock_kind), intent (inout) :: lock\n+            integer (omp_lock_kind), intent (inout) :: svar\n           end subroutine omp_set_lock\n         end interface\n \n         interface\n-          subroutine omp_set_nest_lock (lock)\n+          subroutine omp_set_nest_lock (nvar)\n             use omp_lib_kinds\n-            integer (omp_nest_lock_kind), intent (inout) :: lock\n+            integer (omp_nest_lock_kind), intent (inout) :: nvar\n           end subroutine omp_set_nest_lock\n         end interface\n \n         interface\n-          subroutine omp_unset_lock (lock)\n+          subroutine omp_unset_lock (svar)\n             use omp_lib_kinds\n-            integer (omp_lock_kind), intent (inout) :: lock\n+            integer (omp_lock_kind), intent (inout) :: svar\n           end subroutine omp_unset_lock\n         end interface\n \n         interface\n-          subroutine omp_unset_nest_lock (lock)\n+          subroutine omp_unset_nest_lock (nvar)\n             use omp_lib_kinds\n-            integer (omp_nest_lock_kind), intent (inout) :: lock\n+            integer (omp_nest_lock_kind), intent (inout) :: nvar\n           end subroutine omp_unset_nest_lock\n         end interface\n \n         interface omp_set_dynamic\n-          subroutine omp_set_dynamic (set)\n-            logical (4), intent (in) :: set\n+          subroutine omp_set_dynamic (dynamic_threads)\n+            logical (4), intent (in) :: dynamic_threads\n           end subroutine omp_set_dynamic\n-          subroutine omp_set_dynamic_8 (set)\n-            logical (8), intent (in) :: set\n+          subroutine omp_set_dynamic_8 (dynamic_threads)\n+            logical (8), intent (in) :: dynamic_threads\n           end subroutine omp_set_dynamic_8\n         end interface\n \n         interface omp_set_nested\n-          subroutine omp_set_nested (set)\n-            logical (4), intent (in) :: set\n+          subroutine omp_set_nested (nested)\n+            logical (4), intent (in) :: nested\n           end subroutine omp_set_nested\n-          subroutine omp_set_nested_8 (set)\n-            logical (8), intent (in) :: set\n+          subroutine omp_set_nested_8 (nested)\n+            logical (8), intent (in) :: nested\n           end subroutine omp_set_nested_8\n         end interface\n \n         interface omp_set_num_threads\n-          subroutine omp_set_num_threads (set)\n-            integer (4), intent (in) :: set\n+          subroutine omp_set_num_threads (num_threads)\n+            integer (4), intent (in) :: num_threads\n           end subroutine omp_set_num_threads\n-          subroutine omp_set_num_threads_8 (set)\n-            integer (8), intent (in) :: set\n+          subroutine omp_set_num_threads_8 (num_threads)\n+            integer (8), intent (in) :: num_threads\n           end subroutine omp_set_num_threads_8\n         end interface\n \n@@ -143,10 +143,10 @@\n         end interface\n \n         interface\n-          function omp_test_lock (lock)\n+          function omp_test_lock (svar)\n             use omp_lib_kinds\n             logical (4) :: omp_test_lock\n-            integer (omp_lock_kind), intent (inout) :: lock\n+            integer (omp_lock_kind), intent (inout) :: svar\n           end function omp_test_lock\n         end interface\n \n@@ -179,10 +179,10 @@\n         end interface\n \n         interface\n-          function omp_test_nest_lock (lock)\n+          function omp_test_nest_lock (nvar)\n             use omp_lib_kinds\n             integer (4) :: omp_test_nest_lock\n-            integer (omp_nest_lock_kind), intent (inout) :: lock\n+            integer (omp_nest_lock_kind), intent (inout) :: nvar\n           end function omp_test_nest_lock\n         end interface\n "}]}