{"sha": "67166c9ec35d58efd0225b74730983aa480a88f1", "node_id": "C_kwDOANBUbNoAKDY3MTY2YzllYzM1ZDU4ZWZkMDIyNWI3NDczMDk4M2FhNDgwYTg4ZjE", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T22:17:20Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-29T22:34:18Z"}, "message": "Refine ranges using relations in GORI.\n\nThis allows GORI to recognize when a relation passed in applies to the\n2 operands of the current statement.  Check to see if further range\nrefinement is possible before proceeding.\n\n\t* gimple-range-gori.cc (gori_compute::refine_using_relation): New.\n\t(gori_compute::compute_operand1_range): Invoke\n\trefine_using_relation when applicable.\n\t(gori_compute::compute_operand2_range): Ditto.\n\t* gimple-range-gori.h (class gori_compute): Adjust prototypes.", "tree": {"sha": "773ceeb8ff39cc8266b76bd9e20592860a9211c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/773ceeb8ff39cc8266b76bd9e20592860a9211c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67166c9ec35d58efd0225b74730983aa480a88f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67166c9ec35d58efd0225b74730983aa480a88f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67166c9ec35d58efd0225b74730983aa480a88f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67166c9ec35d58efd0225b74730983aa480a88f1/comments", "author": null, "committer": null, "parents": [{"sha": "431cdfbea1f8c452f581ec3974f2581addec9ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431cdfbea1f8c452f581ec3974f2581addec9ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431cdfbea1f8c452f581ec3974f2581addec9ac7"}], "stats": {"total": 149, "additions": 146, "deletions": 3}, "files": [{"sha": "b37d03cddda2fd8ea832a2a907321e5cea23ce59", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 143, "deletions": 3, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67166c9ec35d58efd0225b74730983aa480a88f1/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67166c9ec35d58efd0225b74730983aa480a88f1/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=67166c9ec35d58efd0225b74730983aa480a88f1", "patch": "@@ -934,6 +934,115 @@ gori_compute::compute_logical_operands (vrange &true_range, vrange &false_range,\n     src.get_operand (false_range, name);\n }\n \n+\n+// This routine will try to refine the ranges of OP1 and OP2 given a relation\n+// K between them.  In order to perform this refinement, one of the operands\n+// must be in the definition chain of the other.  The use is refined using\n+// op1/op2_range on the statement, and the defintion is then recalculated\n+// using the relation.\n+\n+bool\n+gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n+\t\t\t       tree op2, vrange &op2_range,\n+\t\t\t       fur_source &src, relation_kind k)\n+{\n+  gcc_checking_assert (TREE_CODE (op1) == SSA_NAME);\n+  gcc_checking_assert (TREE_CODE (op2) == SSA_NAME);\n+  gcc_checking_assert (k != VREL_VARYING && k != VREL_UNDEFINED);\n+\n+  bool change = false;\n+  bool op1_def_p = in_chain_p (op2, op1);\n+  if (!op1_def_p)\n+    if (!in_chain_p (op1, op2))\n+      return false;\n+\n+  tree def_op = op1_def_p ? op1 : op2;\n+  tree use_op = op1_def_p ? op2 : op1;\n+\n+  if (!op1_def_p)\n+    k = relation_swap (k);\n+\n+  // op1_def is true if we want to look up op1, otherwise we want op2.\n+  // if neither is the case, we returned in the above check.\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (def_op);\n+  gimple_range_op_handler op_handler (def_stmt);\n+  if (!op_handler)\n+    return false;\n+  tree def_op1 = op_handler.operand1 ();\n+  tree def_op2 = op_handler.operand2 ();\n+  // if the def isn't binary, the relation will not be useful.\n+  if (!def_op2)\n+    return false;\n+\n+  // Determine if op2 is directly referenced as an operand.\n+  if (def_op1 == use_op)\n+    {\n+      // def_stmt has op1 in the 1st operand position.\n+      Value_Range other_op (TREE_TYPE (def_op2));\n+      src.get_operand (other_op, def_op2);\n+\n+      // Using op1_range as the LHS, and relation REL, evaluate op2.\n+      tree type = TREE_TYPE (def_op1);\n+      Value_Range new_result (type);\n+      if (!op_handler.op1_range (new_result, type,\n+\t\t\t\t op1_def_p ? op1_range : op2_range,\n+\t\t\t\t other_op, k))\n+\treturn false;\n+      if (op1_def_p)\n+\t{\n+\t  change |= op2_range.intersect (new_result);\n+\t  // Recalculate op2.\n+\t  if (op_handler.fold_range (new_result, type, op2_range, other_op))\n+\t    {\n+\t      change |= op1_range.intersect (new_result);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  change |= op1_range.intersect (new_result);\n+\t  // Recalculate op1.\n+\t  if (op_handler.fold_range (new_result, type, op1_range, other_op))\n+\t    {\n+\t      change |= op2_range.intersect (new_result);\n+\t    }\n+\t}\n+    }\n+  else if (def_op2 == use_op)\n+    {\n+      // def_stmt has op1 in the 1st operand position.\n+      Value_Range other_op (TREE_TYPE (def_op1));\n+      src.get_operand (other_op, def_op1);\n+\n+      // Using op1_range as the LHS, and relation REL, evaluate op2.\n+      tree type = TREE_TYPE (def_op2);\n+      Value_Range new_result (type);\n+      if (!op_handler.op2_range (new_result, type,\n+\t\t\t\t op1_def_p ? op1_range : op2_range,\n+\t\t\t\t other_op, k))\n+\treturn false;\n+      if (op1_def_p)\n+\t{\n+\t  change |= op2_range.intersect (new_result);\n+\t  // Recalculate op1.\n+\t  if (op_handler.fold_range (new_result, type, other_op, op2_range))\n+\t    {\n+\t      change |= op1_range.intersect (new_result);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  change |= op1_range.intersect (new_result);\n+\t  // Recalculate op2.\n+\t  if (op_handler.fold_range (new_result, type, other_op, op1_range))\n+\t    {\n+\t      change |= op2_range.intersect (new_result);\n+\t    }\n+\t}\n+    }\n+  return change;\n+}\n+\n // Calculate a range for NAME from the operand 1 position of STMT\n // assuming the result of the statement is LHS.  Return the range in\n // R, or false if no range could be calculated.\n@@ -947,6 +1056,7 @@ gori_compute::compute_operand1_range (vrange &r,\n   gimple *stmt = handler.stmt ();\n   tree op1 = handler.operand1 ();\n   tree op2 = handler.operand2 ();\n+  tree lhs_name = gimple_get_lhs (stmt);\n \n   Value_Range op1_range (TREE_TYPE (op1));\n   Value_Range tmp (TREE_TYPE (op1));\n@@ -959,15 +1069,29 @@ gori_compute::compute_operand1_range (vrange &r,\n   if (op2)\n     {\n       src.get_operand (op2_range, op2);\n-      if (!handler.calc_op1 (tmp, lhs, op2_range))\n+      relation_kind k = VREL_VARYING;\n+      if (rel)\n+\t{\n+\t if (lhs_name == rel->op1 () && op1 == rel->op2 ())\n+\t   k = rel->kind ();\n+\t else if (lhs_name == rel->op2 () && op1 == rel->op1 ())\n+\t   k = relation_swap (rel->kind ());\n+\t else if (op1 == rel->op1 () && op2 == rel->op2 ())\n+\t   refine_using_relation (op1, op1_range, op2, op2_range, src,\n+\t\t\t\t  rel->kind ());\n+\t else if (op1 == rel->op2 () && op2 == rel->op1 ())\n+\t   refine_using_relation (op1, op1_range, op2, op2_range, src,\n+\t\t\t\t  relation_swap (rel->kind ()));\n+       }\n+      if (!handler.calc_op1 (tmp, lhs, op2_range, k))\n \treturn false;\n     }\n   else\n     {\n       // We pass op1_range to the unary operation.  Nomally it's a\n       // hidden range_for_type parameter, but sometimes having the\n       // actual range can result in better information.\n-      if (!handler.calc_op1 (tmp, lhs, op1_range))\n+      if (!handler.calc_op1 (tmp, lhs, op1_range, VREL_VARYING))\n \treturn false;\n     }\n \n@@ -1030,16 +1154,32 @@ gori_compute::compute_operand2_range (vrange &r,\n   gimple *stmt = handler.stmt ();\n   tree op1 = handler.operand1 ();\n   tree op2 = handler.operand2 ();\n+  tree lhs_name = gimple_get_lhs (stmt);\n \n   Value_Range op1_range (TREE_TYPE (op1));\n   Value_Range op2_range (TREE_TYPE (op2));\n   Value_Range tmp (TREE_TYPE (op2));\n \n   src.get_operand (op1_range, op1);\n   src.get_operand (op2_range, op2);\n+  relation_kind k = VREL_VARYING;\n+  if (rel)\n+    {\n+      if (lhs_name == rel->op1 () && op2 == rel->op2 ())\n+       k = rel->kind ();\n+      else if (lhs_name == rel->op2 () && op2 == rel->op1 ())\n+       k = relation_swap (rel->kind ());\n+      else if (op1 == rel->op1 () && op2 == rel->op2 ())\n+       refine_using_relation (op1, op1_range, op2, op2_range, src,\n+\t\t\t      rel->kind ());\n+      else if (op1 == rel->op2 () && op2 == rel->op1 ())\n+       refine_using_relation (op1, op1_range, op2, op2_range, src,\n+\t\t\t      relation_swap (rel->kind ()));\n+    }\n+\n \n   // Intersect with range for op2 based on lhs and op1.\n-  if (!handler.calc_op2 (tmp, lhs, op1_range))\n+  if (!handler.calc_op2 (tmp, lhs, op1_range, k))\n     return false;\n \n   unsigned idx;"}, {"sha": "c7a32162a1bc5633eb9b885bcc3a7b76a4037abb", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67166c9ec35d58efd0225b74730983aa480a88f1/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67166c9ec35d58efd0225b74730983aa480a88f1/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=67166c9ec35d58efd0225b74730983aa480a88f1", "patch": "@@ -166,6 +166,9 @@ class gori_compute : public gori_map\n   bool has_edge_range_p (tree name, edge e);\n   void dump (FILE *f);\n private:\n+  bool refine_using_relation (tree op1, vrange &op1_range,\n+\t\t\t      tree op2, vrange &op2_range,\n+\t\t\t      fur_source &src, relation_kind k);\n   bool may_recompute_p (tree name, edge e);\n   bool may_recompute_p (tree name, basic_block bb = NULL);\n   bool compute_operand_range (vrange &r, gimple *stmt, const vrange &lhs,"}]}