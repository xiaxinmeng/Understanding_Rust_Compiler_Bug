{"sha": "86a8ba5b7527ae5df4165567535e67099ab6c52c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhOGJhNWI3NTI3YWU1ZGY0MTY1NTY3NTM1ZTY3MDk5YWI2YzUyYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-12-22T10:12:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-12-22T10:12:05Z"}, "message": "decl.c (check_ok_for_atomic): Rename into...\n\n\t* gcc-interface/decl.c (check_ok_for_atomic): Rename into...\n\t(check_ok_for_atomic_type): ...this.  When checking the mode, also\n\tcheck that the type is sufficient aligned.  Remove useless code and\n\ttidy up implementation.\n\t(gnat_to_gnu_entity): Adjust to above renaming.\n\t(gnat_to_gnu_component_type): Likewise.\n\t(gnat_to_gnu_field): Likewise.\n\nFrom-SVN: r219007", "tree": {"sha": "8824ea17e8726ddd6a9b09469d169971f54db7ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8824ea17e8726ddd6a9b09469d169971f54db7ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86a8ba5b7527ae5df4165567535e67099ab6c52c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a8ba5b7527ae5df4165567535e67099ab6c52c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a8ba5b7527ae5df4165567535e67099ab6c52c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a8ba5b7527ae5df4165567535e67099ab6c52c/comments", "author": null, "committer": null, "parents": [{"sha": "9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a1e784ae82f0ebff6d018631d3fe3730359f3c1"}], "stats": {"total": 147, "additions": 86, "deletions": 61}, "files": [{"sha": "d3ffcfd002fe852f8cf8899d2e798f17db9e469c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=86a8ba5b7527ae5df4165567535e67099ab6c52c", "patch": "@@ -1,3 +1,13 @@\n+2014-12-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (check_ok_for_atomic): Rename into...\n+\t(check_ok_for_atomic_type): ...this.  When checking the mode, also\n+\tcheck that the type is sufficient aligned.  Remove useless code and\n+\ttidy up implementation.\n+\t(gnat_to_gnu_entity): Adjust to above renaming.\n+\t(gnat_to_gnu_component_type): Likewise.\n+\t(gnat_to_gnu_field): Likewise.\n+\n 2014-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc-interface/misc.c (gnat_get_array_descr_info): New.  Use it for"}, {"sha": "a50f1d30e9e949e0a6e124e4761a471e1d0b2067", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=86a8ba5b7527ae5df4165567535e67099ab6c52c", "patch": "@@ -191,7 +191,7 @@ static vec<variant_desc> build_variant_list (tree,\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n-static void check_ok_for_atomic (tree, Entity_Id, bool);\n+static void check_ok_for_atomic_type (tree, Entity_Id, bool);\n static tree create_field_decl_from (tree, tree, tree, tree, tree,\n \t\t\t\t    vec<subst_pair> );\n static tree create_rep_part (tree, tree, tree);\n@@ -870,7 +870,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   && TYPE_MULTI_ARRAY_P (gnu_inner))\n \t      gnu_inner = TREE_TYPE (gnu_inner);\n \n-\t    check_ok_for_atomic (gnu_inner, gnat_entity, true);\n+\t    check_ok_for_atomic_type (gnu_inner, gnat_entity, true);\n \t  }\n \n \t/* Now check if the type of the object allows atomic access.  Note\n@@ -880,7 +880,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   always copying via an intermediate value, but it's not clear it's\n \t   worth the effort.  */\n \tif (Is_Atomic (gnat_entity))\n-\t  check_ok_for_atomic (gnu_type, gnat_entity, false);\n+\t  check_ok_for_atomic_type (gnu_type, gnat_entity, false);\n \n \t/* If this is an aliased object with an unconstrained nominal subtype,\n \t   make a type that includes the template.  */\n@@ -5035,7 +5035,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n       if (Is_Atomic (gnat_entity))\n-\tcheck_ok_for_atomic (gnu_type, gnat_entity, false);\n+\tcheck_ok_for_atomic_type (gnu_type, gnat_entity, false);\n \n       /* If this is not an unconstrained array type, set some flags.  */\n       if (TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE)\n@@ -5548,7 +5548,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n     gnu_type = make_packable_type (gnu_type, false);\n \n   if (Has_Atomic_Components (gnat_array))\n-    check_ok_for_atomic (gnu_type, gnat_array, true);\n+    check_ok_for_atomic_type (gnu_type, gnat_array, true);\n \n   /* Get and validate any specified Component_Size.  */\n   gnu_comp_size\n@@ -6484,7 +6484,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     }\n \n   if (Is_Atomic (gnat_field))\n-    check_ok_for_atomic (gnu_field_type, gnat_field, false);\n+    check_ok_for_atomic_type (gnu_field_type, gnat_field, false);\n \n   if (Present (Component_Clause (gnat_field)))\n     {\n@@ -8088,78 +8088,63 @@ validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n   return align;\n }\n \f\n-/* Verify that OBJECT, a type or decl, is something we can implement\n-   atomically.  If not, give an error for GNAT_ENTITY.  COMP_P is true\n-   if we require atomic components.  */\n+/* Verify that TYPE is something we can implement atomically.  If not, issue\n+   an error for GNAT_ENTITY.  COMPONENT_P is true if we are being called to\n+   process a component type.  */\n \n static void\n-check_ok_for_atomic (tree object, Entity_Id gnat_entity, bool comp_p)\n+check_ok_for_atomic_type (tree type, Entity_Id gnat_entity, bool component_p)\n {\n   Node_Id gnat_error_point = gnat_entity;\n   Node_Id gnat_node;\n   machine_mode mode;\n+  enum mode_class mclass;\n   unsigned int align;\n   tree size;\n \n-  /* There are three case of what OBJECT can be.  It can be a type, in which\n-     case we take the size, alignment and mode from the type.  It can be a\n-     declaration that was indirect, in which case the relevant values are\n-     that of the type being pointed to, or it can be a normal declaration,\n-     in which case the values are of the decl.  The code below assumes that\n-     OBJECT is either a type or a decl.  */\n-  if (TYPE_P (object))\n-    {\n-      /* If this is an anonymous base type, nothing to check.  Error will be\n-\t reported on the source type.  */\n-      if (!Comes_From_Source (gnat_entity))\n-\treturn;\n-\n-      mode = TYPE_MODE (object);\n-      align = TYPE_ALIGN (object);\n-      size = TYPE_SIZE (object);\n-    }\n-  else if (DECL_BY_REF_P (object))\n-    {\n-      mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (object)));\n-      align = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (object)));\n-      size = TYPE_SIZE (TREE_TYPE (TREE_TYPE (object)));\n-    }\n-  else\n-    {\n-      mode = DECL_MODE (object);\n-      align = DECL_ALIGN (object);\n-      size = DECL_SIZE (object);\n-    }\n+  /* If this is an anonymous base type, nothing to check, the error will be\n+     reported on the source type if need be.  */\n+  if (!Comes_From_Source (gnat_entity))\n+    return;\n \n-  /* Consider all floating-point types atomic and any types that that are\n-     represented by integers no wider than a machine word.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      || ((GET_MODE_CLASS (mode) == MODE_INT\n-\t   || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n-\t  && GET_MODE_BITSIZE (mode) <= BITS_PER_WORD))\n+  mode = TYPE_MODE (type);\n+  mclass = GET_MODE_CLASS (mode);\n+  align = TYPE_ALIGN (type);\n+  size = TYPE_SIZE (type);\n+\n+  /* Consider all aligned floating-point types atomic and any aligned types\n+     that are represented by integers no wider than a machine word.  */\n+  if ((mclass == MODE_FLOAT\n+       || ((mclass == MODE_INT || mclass == MODE_PARTIAL_INT)\n+\t   && GET_MODE_BITSIZE (mode) <= BITS_PER_WORD))\n+      && align >= GET_MODE_ALIGNMENT (mode))\n     return;\n \n-  /* For the moment, also allow anything that has an alignment equal\n-     to its size and which is smaller than a word.  */\n-  if (size && TREE_CODE (size) == INTEGER_CST\n+  /* For the moment, also allow anything that has an alignment equal to its\n+     size and which is smaller than a word.  */\n+  if (size\n+      && TREE_CODE (size) == INTEGER_CST\n       && compare_tree_int (size, align) == 0\n       && align <= BITS_PER_WORD)\n     return;\n \n-  for (gnat_node = First_Rep_Item (gnat_entity); Present (gnat_node);\n+  for (gnat_node = First_Rep_Item (gnat_entity);\n+       Present (gnat_node);\n        gnat_node = Next_Rep_Item (gnat_node))\n-    {\n-      if (!comp_p && Nkind (gnat_node) == N_Pragma\n-\t  && (Get_Pragma_Id (Chars (Pragma_Identifier (gnat_node)))\n-              == Pragma_Atomic))\n-\tgnat_error_point = First (Pragma_Argument_Associations (gnat_node));\n-      else if (comp_p && Nkind (gnat_node) == N_Pragma\n-\t       && (Get_Pragma_Id (Chars (Pragma_Identifier (gnat_node)))\n-\t\t   == Pragma_Atomic_Components))\n-\tgnat_error_point = First (Pragma_Argument_Associations (gnat_node));\n-    }\n+    if (Nkind (gnat_node) == N_Pragma)\n+      {\n+\tunsigned char pragma_id\n+\t  = Get_Pragma_Id (Chars (Pragma_Identifier (gnat_node)));\n+\n+\tif ((pragma_id == Pragma_Atomic && !component_p)\n+\t    || (pragma_id == Pragma_Atomic_Components && component_p))\n+\t  {\n+\t    gnat_error_point = First (Pragma_Argument_Associations (gnat_node));\n+\t    break;\n+\t  }\n+      }\n \n-  if (comp_p)\n+  if (component_p)\n     post_error_ne (\"atomic access to component of & cannot be guaranteed\",\n \t\t   gnat_error_point, gnat_entity);\n   else"}, {"sha": "14c58da4c0299c37488984cca7b1a05030282f35", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=86a8ba5b7527ae5df4165567535e67099ab6c52c", "patch": "@@ -662,7 +662,7 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   info->ndimensions = i;\n   convention_fortran_p = TYPE_CONVENTION_FORTRAN_P (type);\n \n-  /* TODO??? For row major ordering, we probably want to emit nothing and\n+  /* TODO: For row major ordering, we probably want to emit nothing and\n      instead specify it as the default in Dw_TAG_compile_unit.  */\n   info->ordering = (convention_fortran_p\n \t\t    ? array_descr_ordering_column_major"}, {"sha": "f69fb33368dedc2bd1064f9193bcb40b4573a174", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86a8ba5b7527ae5df4165567535e67099ab6c52c", "patch": "@@ -1,3 +1,7 @@\n+2014-12-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/atomic2.ads: New test.\n+\n 2014-12-21  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/17280"}, {"sha": "b332884291edbfc53f41d6062df6dfddb48d96d8", "filename": "gcc/testsuite/gnat.dg/specs/atomic2.ads", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fatomic2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a8ba5b7527ae5df4165567535e67099ab6c52c/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fatomic2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fatomic2.ads?ref=86a8ba5b7527ae5df4165567535e67099ab6c52c", "patch": "@@ -0,0 +1,26 @@\n+-- { dg-do compile }\n+\n+package Atomic2 is\n+\n+  type Rec1 is record\n+    C : Character;\n+    I : Integer;\n+    pragma Atomic (I);\n+  end record;\n+  for Rec1 use record\n+    C at 0 range 0 .. 7;\n+    I at 1 range 0 .. 31; -- { dg-error \"position of atomic field\" }\n+  end record;\n+\n+  type Rec2 is record\n+    C : Character;\n+    I : Integer;\n+    pragma Atomic (I);\n+  end record;\n+  pragma Pack (Rec2);\n+\n+  type My_Int is new Integer;\n+  for My_Int'Alignment use 1;\n+  pragma Atomic (My_Int); -- { dg-error \"atomic access\" }\n+\n+end Atomic2;"}]}