{"sha": "a1e179f5b74bef253aa2020eb5d21b292c42f441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlMTc5ZjViNzRiZWYyNTNhYTIwMjBlYjVkMjFiMjkyYzQyZjQ0MQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@cavium.com", "date": "2012-04-24T07:05:09Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2012-04-24T07:05:09Z"}, "message": "re PR tree-optimization/33512 (Simple bitwise simplification missed)\n\n\n2012-04-24  Andrew Pinski  <apinski@cavium.com>\n\n\tPR tree-opt/33512\n\t* tree-ssa-forwprop.c (defcodefor_name): New function.\n\t(simplify_bitwise_binary): Use defcodefor_name instead of manually\n\tSimplify \"( X | Y) & X\" to X and \"( X & Y) | X\" to X.\n\tSimplify \"(~X | Y) & X\" to \"X & Y\" and\n\t\"(~X & Y) | X\" to \"X | Y\".\n\n2012-04-24  Andrew Pinski  <apinski@cavium.com>\n\n\tPR tree-opt/33512\n\t* gcc.dg/tree-ssa/andor-3.c: New testcase.\n\t* gcc.dg/tree-ssa/andor-4.c: New testcase.\n\t* gcc.dg/tree-ssa/andor-5.c: New testcase.\n\nFrom-SVN: r186749", "tree": {"sha": "4318a722cabc2b845a5409a42ace68e3ffa59666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4318a722cabc2b845a5409a42ace68e3ffa59666"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1e179f5b74bef253aa2020eb5d21b292c42f441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e179f5b74bef253aa2020eb5d21b292c42f441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1e179f5b74bef253aa2020eb5d21b292c42f441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e179f5b74bef253aa2020eb5d21b292c42f441/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57ac4c34019b76318bad402a8715992b65dcd969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ac4c34019b76318bad402a8715992b65dcd969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ac4c34019b76318bad402a8715992b65dcd969"}], "stats": {"total": 275, "additions": 246, "deletions": 29}, "files": [{"sha": "3e639c23749d90aeaa8fa12a12d11c90560b7ed4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1e179f5b74bef253aa2020eb5d21b292c42f441", "patch": "@@ -1,3 +1,12 @@\n+2012-04-24  Andrew Pinski  <apinski@cavium.com>\n+\n+\tPR tree-opt/33512\n+\t* tree-ssa-forwprop.c (defcodefor_name): New function.\n+\t(simplify_bitwise_binary): Use defcodefor_name instead of manually\n+\tSimplify \"( X | Y) & X\" to X and \"( X & Y) | X\" to X.\n+\tSimplify \"(~X | Y) & X\" to \"X & Y\" and\n+\t\"(~X & Y) | X\" to \"X | Y\".\n+\n 2012-04-24  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* recog.c (insn_invalid_p): Add IN_GROUP parameter and use"}, {"sha": "9205f4299ce6c45273cd89a5b85b3250623b6620", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a1e179f5b74bef253aa2020eb5d21b292c42f441", "patch": "@@ -1,3 +1,10 @@\n+2012-04-24  Andrew Pinski  <apinski@cavium.com>\n+\n+\tPR tree-opt/33512\n+\t* gcc.dg/tree-ssa/andor-3.c: New testcase.\n+\t* gcc.dg/tree-ssa/andor-4.c: New testcase.\n+\t* gcc.dg/tree-ssa/andor-5.c: New testcase.\n+\n 2012-04-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/53084"}, {"sha": "a1401c0790bf201f43be9b9c48da5688979c9dbc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/andor-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-3.c?ref=a1e179f5b74bef253aa2020eb5d21b292c42f441", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int f(int y, int x)\n+{\n+  return x & ((~x) | y);\n+}\n+int f1(int y, int x)\n+{\n+  return x & (y | (~x));\n+}\n+int f2(int y, int x)\n+{\n+  return ((~x) | y) & x;\n+}\n+int f3(int y, int x)\n+{\n+  return (y | (~x)) & x;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"~x\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"x_..D. \\& y_..D.\" 4 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1dbdca7dfffb074a96dc9324adb587d40fa6a478", "filename": "gcc/testsuite/gcc.dg/tree-ssa/andor-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-4.c?ref=a1e179f5b74bef253aa2020eb5d21b292c42f441", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int f(int y, int x)\n+{\n+  return x | ((~x) & y);\n+}\n+int f1(int y, int x)\n+{\n+  return x | (y & (~x));\n+}\n+int f2(int y, int x)\n+{\n+  return ((~x) & y) | x;\n+}\n+int f3(int y, int x)\n+{\n+  return (y & (~x)) | x;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"~x\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"x_..D. \\\\\\| y_..D.\" 4 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "15097272a1d3614e8d694cd74d47ce30f8d7a223", "filename": "gcc/testsuite/gcc.dg/tree-ssa/andor-5.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fandor-5.c?ref=a1e179f5b74bef253aa2020eb5d21b292c42f441", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int f(int y, int x)\n+{\n+  int a = x | y;\n+  return a & x;\n+}\n+int f1(int y, int x)\n+{\n+  int a = y | x;\n+  return a & x;\n+}\n+int f2(int y, int x)\n+{\n+  int a = x | y;\n+  return x & a;\n+}\n+int f3(int y, int x)\n+{\n+  int a = x | y;\n+  return x & a;\n+}\n+int f4(int y, int x)\n+{\n+  int a = x & y;\n+  return a | x;\n+}\n+int f5(int y, int x)\n+{\n+  int a = y & x;\n+  return a | x;\n+}\n+int f6(int y, int x)\n+{\n+  int a = x & y;\n+  return x | a;\n+}\n+int f7(int y, int x)\n+{\n+  int a = x & y;\n+  return x | a;\n+}\n+/* These all should be optimized to just return x; */\n+\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\|\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\&\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return x_..D.;\" 8 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "776d2f1bd78a5068850939ed6c88ecb215fa7ea0", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 132, "deletions": 29, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e179f5b74bef253aa2020eb5d21b292c42f441/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=a1e179f5b74bef253aa2020eb5d21b292c42f441", "patch": "@@ -1794,6 +1794,51 @@ simplify_bitwise_binary_1 (enum tree_code code, tree type,\n   return NULL_TREE;\n }\n \n+/* Given a ssa_name in NAME see if it was defined by an assignment and\n+   set CODE to be the code and ARG1 to the first operand on the rhs and ARG2\n+   to the second operand on the rhs. */\n+\n+static inline void\n+defcodefor_name (tree name, enum tree_code *code, tree *arg1, tree *arg2)\n+{\n+  gimple def;\n+  enum tree_code code1;\n+  tree arg11;\n+  tree arg21;\n+  tree arg31;\n+  enum gimple_rhs_class grhs_class;\n+\n+  code1 = TREE_CODE (name);\n+  arg11 = name;\n+  arg21 = NULL_TREE;\n+  grhs_class = get_gimple_rhs_class (code1);\n+\n+  if (code1 == SSA_NAME)\n+    {\n+      def = SSA_NAME_DEF_STMT (name);\n+      \n+      if (def && is_gimple_assign (def)\n+\t  && can_propagate_from (def))\n+\t{\n+\t  code1 = gimple_assign_rhs_code (def);\n+\t  arg11 = gimple_assign_rhs1 (def);\n+          arg21 = gimple_assign_rhs2 (def);\n+          arg31 = gimple_assign_rhs2 (def);\n+\t}\n+    }\n+  else if (grhs_class == GIMPLE_TERNARY_RHS\n+\t   || GIMPLE_BINARY_RHS\n+\t   || GIMPLE_UNARY_RHS\n+\t   || GIMPLE_SINGLE_RHS)\n+    extract_ops_from_tree_1 (name, &code1, &arg11, &arg21, &arg31);\n+\n+  *code = code1;\n+  *arg1 = arg11;\n+  if (arg2)\n+    *arg2 = arg21;\n+  /* Ignore arg3 currently. */\n+}\n+\n /* Simplify bitwise binary operations.\n    Return true if a transformation applied, otherwise return false.  */\n \n@@ -1805,33 +1850,11 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n   tree arg2 = gimple_assign_rhs2 (stmt);\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree res;\n-  gimple def1 = NULL, def2 = NULL;\n-  tree def1_arg1, def2_arg1;\n+  tree def1_arg1, def1_arg2, def2_arg1, def2_arg2;\n   enum tree_code def1_code, def2_code;\n \n-  def1_code = TREE_CODE (arg1);\n-  def1_arg1 = arg1;\n-  if (TREE_CODE (arg1) == SSA_NAME)\n-    {\n-      def1 = SSA_NAME_DEF_STMT (arg1);\n-      if (is_gimple_assign (def1))\n-\t{\n-\t  def1_code = gimple_assign_rhs_code (def1);\n-\t  def1_arg1 = gimple_assign_rhs1 (def1);\n-\t}\n-    }\n-\n-  def2_code = TREE_CODE (arg2);\n-  def2_arg1 = arg2;\n-  if (TREE_CODE (arg2) == SSA_NAME)\n-    {\n-      def2 = SSA_NAME_DEF_STMT (arg2);\n-      if (is_gimple_assign (def2))\n-\t{\n-\t  def2_code = gimple_assign_rhs_code (def2);\n-\t  def2_arg1 = gimple_assign_rhs1 (def2);\n-\t}\n-    }\n+  defcodefor_name (arg1, &def1_code, &def1_arg1, &def1_arg2);\n+  defcodefor_name (arg2, &def2_code, &def2_arg1, &def2_arg2);\n \n   /* Try to fold (type) X op CST -> (type) (X op ((type-x) CST)).  */\n   if (TREE_CODE (arg2) == INTEGER_CST\n@@ -1938,10 +1961,10 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n   if (code == BIT_AND_EXPR\n       && def1_code == BIT_IOR_EXPR\n       && TREE_CODE (arg2) == INTEGER_CST\n-      && TREE_CODE (gimple_assign_rhs2 (def1)) == INTEGER_CST)\n+      && TREE_CODE (def1_arg2) == INTEGER_CST)\n     {\n       tree cst = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg2),\n-\t\t\t      arg2, gimple_assign_rhs2 (def1));\n+\t\t\t      arg2, def1_arg2);\n       tree tem;\n       gimple newop;\n       if (integer_zerop (cst))\n@@ -1971,10 +1994,10 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n        || code == BIT_XOR_EXPR)\n       && def1_code == code \n       && TREE_CODE (arg2) == INTEGER_CST\n-      && TREE_CODE (gimple_assign_rhs2 (def1)) == INTEGER_CST)\n+      && TREE_CODE (def1_arg2) == INTEGER_CST)\n     {\n       tree cst = fold_build2 (code, TREE_TYPE (arg2),\n-\t\t\t      arg2, gimple_assign_rhs2 (def1));\n+\t\t\t      arg2, def1_arg2);\n       gimple_assign_set_rhs1 (stmt, def1_arg1);\n       gimple_assign_set_rhs2 (stmt, cst);\n       update_stmt (stmt);\n@@ -2001,6 +2024,86 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n+  if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR)\n+    {\n+      enum tree_code ocode = code == BIT_AND_EXPR ? BIT_IOR_EXPR : BIT_AND_EXPR;\n+      if (def1_code == ocode)\n+\t{\n+\t  tree x = arg2;\n+\t  enum tree_code coden;\n+\t  tree a1, a2;\n+\t  /* ( X | Y) & X -> X */\n+\t  /* ( X & Y) | X -> X */\n+\t  if (x == def1_arg1\n+\t      || x == def1_arg2)\n+\t    {\n+\t      gimple_assign_set_rhs_from_tree (gsi, x);\n+\t      update_stmt (gsi_stmt (*gsi));\n+\t      return true;\n+\t    }\n+\n+\t  defcodefor_name (def1_arg1, &coden, &a1, &a2);\n+\t  /* (~X | Y) & X -> X & Y */\n+\t  /* (~X & Y) | X -> X | Y */\n+\t  if (coden == BIT_NOT_EXPR && a1 == x)\n+\t    {\n+\t      gimple_assign_set_rhs_with_ops (gsi, code,\n+\t\t\t\t\t      x, def1_arg2);\n+\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n+\t      update_stmt (stmt);\n+\t      return true;\n+\t    }\n+\t  defcodefor_name (def1_arg2, &coden, &a1, &a2);\n+\t  /* (Y | ~X) & X -> X & Y */\n+\t  /* (Y & ~X) | X -> X | Y */\n+\t  if (coden == BIT_NOT_EXPR && a1 == x)\n+\t    {\n+\t      gimple_assign_set_rhs_with_ops (gsi, code,\n+\t\t\t\t\t      x, def1_arg1);\n+\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n+\t      update_stmt (stmt);\n+\t      return true;\n+\t    }\n+\t}\n+      if (def2_code == ocode)\n+\t{\n+\t  enum tree_code coden;\n+\t  tree a1;\n+\t  tree x = arg1;\n+\t  /* X & ( X | Y) -> X */\n+\t  /* X | ( X & Y) -> X */\n+\t  if (x == def2_arg1\n+\t      || x == def2_arg2)\n+\t    {\n+\t      gimple_assign_set_rhs_from_tree (gsi, x);\n+\t      update_stmt (gsi_stmt (*gsi));\n+\t      return true;\n+\t    }\n+\t  defcodefor_name (def2_arg1, &coden, &a1, NULL);\n+\t  /* (~X | Y) & X -> X & Y */\n+\t  /* (~X & Y) | X -> X | Y */\n+\t  if (coden == BIT_NOT_EXPR && a1 == x)\n+\t    {\n+\t      gimple_assign_set_rhs_with_ops (gsi, code,\n+\t\t\t\t\t      x, def2_arg2);\n+\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n+\t      update_stmt (stmt);\n+\t      return true;\n+\t    }\n+\t  defcodefor_name (def2_arg2, &coden, &a1, NULL);\n+\t  /* (Y | ~X) & X -> X & Y */\n+\t  /* (Y & ~X) | X -> X | Y */\n+\t  if (coden == BIT_NOT_EXPR && a1 == x)\n+\t    {\n+\t      gimple_assign_set_rhs_with_ops (gsi, code,\n+\t\t\t\t\t      x, def2_arg1);\n+\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n+\t      update_stmt (stmt);\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+\n   return false;\n }\n "}]}