{"sha": "ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY4ZTdjNGQ2ODIwOTlkNjFlODFhMjBiNDY1MjgwYmNjN2NkYWFiNQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2011-10-10T13:42:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2011-10-10T13:42:41Z"}, "message": "gcc-simulate-thread.exp: New.\n\n        * lib/gcc-simulate-thread.exp: New.\n        * gcc.dg/simulate-thread/guality.h: New.\n        * gcc.dg/simulate-thread/simulate-thread.h: New.\n        * gcc.dg/simulate-thread/simulate-thread.exp: New.\n        * gcc.dg/simulate-thread/simulate-thread.gdb: New.\n        * gcc.dg/simulate-thread/README: New.\n        * g++.dg/simulate-thread/guality.h: New.\n        * g++.dg/simulate-thread/simulate-thread.h: New.\n        * g++.dg/simulate-thread/simulate-thread.exp: New.\n        * g++.dg/simulate-thread/simulate-thread.gdb: New.\n        * c-c++-common/cxxbitfields-2.c: Remove.\n        * c-c++-common/cxxbitfields.c: Remove.\n        * c-c++-common/cxxbitfields-4.c: Remove.\n        * c-c++-common/cxxbitfields-5.c: Remove.\n        * c-c++-common/simulate-thread/bitfields-1.c: New.\n        * c-c++-common/simulate-thread/bitfields-2.c: New.\n        * c-c++-common/simulate-thread/bitfields-3.c: New.\n        * c-c++-common/simulate-thread/bitfields-4.c: New.\n\nFrom-SVN: r179751", "tree": {"sha": "bba6939b464863b1cd47394507ef6db3d08fb471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bba6939b464863b1cd47394507ef6db3d08fb471"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53fbb7241f0d2d4e3a4eb8b3225671b121091b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53fbb7241f0d2d4e3a4eb8b3225671b121091b06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53fbb7241f0d2d4e3a4eb8b3225671b121091b06"}], "stats": {"total": 691, "additions": 607, "deletions": 84}, "files": [{"sha": "d0700e9b7391d203c40566e8888a230816b1cc1b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -1,3 +1,24 @@\n+2011-10-10  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* lib/gcc-simulate-thread.exp: New.\n+\t* gcc.dg/simulate-thread/guality.h: New.\n+\t* gcc.dg/simulate-thread/simulate-thread.h: New.\n+\t* gcc.dg/simulate-thread/simulate-thread.exp: New.\n+\t* gcc.dg/simulate-thread/simulate-thread.gdb: New.\n+\t* gcc.dg/simulate-thread/README: New.\n+\t* g++.dg/simulate-thread/guality.h: New.\n+\t* g++.dg/simulate-thread/simulate-thread.h: New.\n+\t* g++.dg/simulate-thread/simulate-thread.exp: New.\n+\t* g++.dg/simulate-thread/simulate-thread.gdb: New.\n+\t* c-c++-common/cxxbitfields-2.c: Remove.\n+\t* c-c++-common/cxxbitfields.c: Remove.\n+\t* c-c++-common/cxxbitfields-4.c: Remove.\n+\t* c-c++-common/cxxbitfields-5.c: Remove.\n+\t* c-c++-common/simulate-thread/bitfields-1.c: New.\n+\t* c-c++-common/simulate-thread/bitfields-2.c: New.\n+\t* c-c++-common/simulate-thread/bitfields-3.c: New.\n+\t* c-c++-common/simulate-thread/bitfields-4.c: New.\n+\n 2011-10-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/38980"}, {"sha": "b98b56daa91a79b6ae3591a360b519de2a3f06b1", "filename": "gcc/testsuite/c-c++-common/cxxbitfields-2.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-2.c?ref=53fbb7241f0d2d4e3a4eb8b3225671b121091b06", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n-\n-/* Test that we don't store past VAR.K.  */\n-\n-struct S\n-{\n-  volatile int i;\n-  volatile int j: 32;\n-  volatile int k: 15;\n-  volatile char c[2];\n-} var;\n-\n-void setit()\n-{\n-  var.k = 13;\n-}\n-\n-/* { dg-final { scan-assembler-not \"movl.*, var\" } } */"}, {"sha": "7023b31654a73ed6a1af795116028282ecf5d186", "filename": "gcc/testsuite/c-c++-common/cxxbitfields-4.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-4.c?ref=53fbb7241f0d2d4e3a4eb8b3225671b121091b06", "patch": "@@ -1,18 +0,0 @@\n-/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n-\n-struct bits\n-{\n-  char a;\n-  int b:7;\n-  int c:9;\n-  unsigned char d;\n-} x;\n-\n-/* Store into <c> should not clobber <d>.  */\n-void update_c(struct bits *p, int val) \n-{\n-    p -> c = val;\n-}\n-\n-/* { dg-final { scan-assembler \"mov\\[bw\\]\" } } */"}, {"sha": "fba604fccc71fff8c6f0bd7507c7b008606b1895", "filename": "gcc/testsuite/c-c++-common/cxxbitfields-5.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-5.c?ref=53fbb7241f0d2d4e3a4eb8b3225671b121091b06", "patch": "@@ -1,29 +0,0 @@\n-/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n-\n-#include <stdlib.h>\n-\n-struct bits\n-{\n-  char a;\n-  int b:7;\n-  int c:9;\n-  unsigned char d;\n-} x;\n-\n-struct bits *p;\n-\n-static void allocit()\n-{\n-  p = (struct bits *) malloc (sizeof (struct bits));\n-}\n-\n-/* Store into <c> should not clobber <d>.  */\n-/* We should not use a 32-bit move to store into p->, but a smaller move.  */\n-void foo()\n-{\n-  allocit();\n-  p -> c = 55;\n-}\n-\n-/* { dg-final { scan-assembler \"mov\\[bw\\]\" } } */"}, {"sha": "43c840b15ebcfa9c35fd5b4dba3088131ee791b7", "filename": "gcc/testsuite/c-c++-common/cxxbitfields.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fbb7241f0d2d4e3a4eb8b3225671b121091b06/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields.c?ref=53fbb7241f0d2d4e3a4eb8b3225671b121091b06", "patch": "@@ -1,18 +0,0 @@\n-/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n-\n-/* Test that we don't store past VAR.A.  */\n-\n-struct S\n-{\n-  volatile unsigned int a : 4;\n-  unsigned char b;\n-  unsigned int c : 6;\n-} var;\n-\n-void set_a()\n-{\n-  var.a = 12;\n-}\n-\n-/* { dg-final { scan-assembler-not \"movl.*, var\" } } */"}, {"sha": "9ca3a67f3c42a248ff54278d36b669f66d15287f", "filename": "gcc/testsuite/c-c++-common/simulate-thread/bitfields-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-1.c?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"../../gcc.dg/simulate-thread/simulate-thread.h\"\n+\n+/* Test that we don't store past VAR.A.  */\n+\n+struct S\n+{\n+  volatile unsigned int a : 4;\n+  unsigned char b;\n+  unsigned int c : 6;\n+} var = { 1, 2, 3 };\n+\n+static int global = 0;\n+\n+/* Called before each instruction, simulating another thread\n+   executing.  */\n+void simulate_thread_other_threads()\n+{\n+  global++;\n+  var.b = global;\n+  /* Don't go past the 6 bits var.c can hold.  */\n+  var.c = global % 64;\n+}\n+\n+/* Called after each instruction.  Returns 1 if any inconsistency is\n+   found, 0 otherwise.  */\n+int simulate_thread_step_verify()\n+{\n+  int ret = 0;\n+  if (var.b != global)\n+    {\n+      printf(\"FAIL: invalid intermediate value for <b>.\\n\");\n+      ret = 1;\n+    }\n+  if (var.c != global % 64)\n+    {\n+      printf(\"FAIL: invalid intermediate value for <c>.\\n\");\n+      ret = 1;\n+    }\n+  return ret;\n+}\n+\n+/* Called at the end of the program (simulate_thread_fini == 1).  Verifies\n+   the state of the program and returns 1 if any inconsistency is\n+   found, 0 otherwise.  */\n+int simulate_thread_final_verify()\n+{\n+  if (var.a != 12)\n+    {\n+      printf(\"FAIL: invalid final result for <a>.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  var.a = 12;\n+}\n+\n+int main()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "392f779bad58bf458b156b3c8c28b94b34f78578", "filename": "gcc/testsuite/c-c++-common/simulate-thread/bitfields-2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-2.c?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"../../gcc.dg/simulate-thread/simulate-thread.h\"\n+\n+/* Test that we don't store past VAR.K.  */\n+\n+struct S\n+{\n+  volatile int i;\n+  volatile int j: 32;\n+  volatile int k: 15;\n+  volatile unsigned char c[2];\n+} var;\n+\n+static int global = 0;\n+\n+void simulate_thread_other_threads()\n+{\n+  global++;\n+  var.c[0] = global % 256;\n+  var.c[1] = global % 256;\n+}\n+\n+int simulate_thread_step_verify()\n+{\n+  if (var.c[0] != global % 256\n+      || var.c[1] != global % 256)\n+    {\n+      printf(\"FAIL: invalid intermediate result for <var.c[]>.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int simulate_thread_final_verify()\n+{\n+  if (var.k != 13)\n+    {\n+      printf(\"FAIL: invalid final result\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  var.k = 13;\n+}\n+\n+int main()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "78f4d75c8ba7755b0e42bf503455648144bd6737", "filename": "gcc/testsuite/c-c++-common/simulate-thread/bitfields-3.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-3.c?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"../../gcc.dg/simulate-thread/simulate-thread.h\"\n+\n+/* Store into <c> should not clobber <d>.  */\n+\n+struct bits\n+{\n+  char a;\n+  int b:7;\n+  int c:9;\n+  unsigned char d;\n+} var;\n+\n+static int global = 0;\n+\n+void simulate_thread_other_threads()\n+{\n+  global++;\n+  var.d = global;\n+}\n+\n+int simulate_thread_step_verify()\n+{\n+  if (var.d != global)\n+    {\n+      printf(\"FAIL: invalid intermediate result\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int simulate_thread_final_verify()\n+{\n+  if (var.c != 5)\n+    {\n+      printf(\"FAIL: invalid final result\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+__attribute__((noinline))\n+void update_c(struct bits *p, int val) \n+{\n+    p -> c = val;\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  update_c(&var, 5);\n+}\n+\n+int main()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "cd6badf33295e5a6589c19b2fb8d461a47b5c042", "filename": "gcc/testsuite/c-c++-common/simulate-thread/bitfields-4.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fsimulate-thread%2Fbitfields-4.c?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"../../gcc.dg/simulate-thread/simulate-thread.h\"\n+\n+struct bits\n+{\n+  char a;\n+  int b:7;\n+  int c:9;\n+  unsigned char d;\n+} *p;\n+\n+static int global = 0;\n+\n+void simulate_thread_other_threads()\n+{\n+  global++;\n+  p->d = global % 256;\n+}\n+\n+int simulate_thread_step_verify()\n+{\n+  if (p->d != global % 256)\n+    {\n+      printf(\"FAIL: invalid intermediate result\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int simulate_thread_final_verify()\n+{\n+  if (p->c != 55)\n+    {\n+      printf(\"FAIL: invalid final result\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Store into <c> should not clobber <d>.  */\n+/* We should not use a 32-bit move to store into p->, but a smaller move.  */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  p -> c = 55;\n+}\n+  \n+\n+int main()\n+{\n+  p = (struct bits *) calloc (1, sizeof (struct bits));\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "f9e6475c054f3a2a0a081de6aa8d971b7d4a32f5", "filename": "gcc/testsuite/g++.dg/simulate-thread/simulate-thread.exp", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.exp?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,39 @@\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+# Your run of the mill dg test, but verify that we have a working GDB first.\n+\n+load_lib g++-dg.exp\n+load_lib gcc-simulate-thread.exp\n+load_lib torture-options.exp\n+\n+dg-init\n+torture-init\n+set-torture-options [list \\\n+\t{ -O0 -g } \\\n+\t{ -O1 -g } \\\n+\t{ -O2 -g } \\\n+\t{ -O3 -g } \\\n+\t{ -Os -g } ]\n+\n+if [gdb-exists] {\n+  gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \"\"\n+  gcc-dg-runtest [lsort [glob $srcdir/c-c++-common/simulate-thread/*.c]] \"\"\n+}\n+\n+torture-finish\n+dg-finish"}, {"sha": "eb081cb227c05a94545cbcbac32b105d29e48b4e", "filename": "gcc/testsuite/g++.dg/simulate-thread/simulate-thread.gdb", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.gdb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.gdb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.gdb?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1 @@\n+source ../../gcc.dg/simulate-thread/simulate-thread.gdb"}, {"sha": "a07486bebe7d7e26b8f345858973aa19950d94fa", "filename": "gcc/testsuite/g++.dg/simulate-thread/simulate-thread.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fsimulate-thread.h?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1 @@\n+#include \"../../gcc.dg/simulate-thread/simulate-thread.h\""}, {"sha": "5588e04d6dbeb28c0f5dde6c818870bc42db1666", "filename": "gcc/testsuite/gcc.dg/simulate-thread/README", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2FREADME?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,118 @@\n+OVERVIEW\n+--------\n+\n+This is a harness to test the atomicity of certain operations, and to\n+make sure the compiler does not introduce data races in a\n+multi-threaded environment.\n+\n+The basic premise is that we set up testcases such that the thing we\n+want test, say an atomic instruction which stores a double word is in\n+a function of its own.  We then run this testcase within GDB,\n+controlled by a gdb script (simulate-thread.gdb).  The gdb script will\n+break on the function to be tested, and then single step through every\n+machine instruction in the function.  We set this up so GDB can make a\n+couple of inferior function calls before and after each of these\n+single step instructions for a couple of purposes:\n+\n+       1.  One of the calls simulates another thread running in the\n+           process which changes or access memory.\n+\n+       2.  The other calls are used to verify that we always get the\n+           expected behavior.\n+\n+For example, in the case of an atomic store, anyone looking at the\n+memory associated with an atomic variable should never see any in\n+between states. If you have an atomic long long int, and it starts\n+with the value 0, and you write the value MAX_LONG_LONG, any other\n+thread looking at that variable should never see anything other than 0\n+or MAX_LONG_LONG.  If you implement the atomic write as a sequence of\n+2 stores, it is possible for another thread to read the location after\n+the first store, but before the second one is complete. That thread\n+would then see an in-between state (one word would still be 0).\n+\n+We simulate this in the testcase by having GDB step through the\n+program, instruction by instruction, and after each step, making an\n+inferior function call which looks at the value of the atomic variable\n+and verifies that it sees either 0 or MAX_LONG_LONG.  If it sees any\n+other value, it fails the testcase.\n+\n+This way, we are *sure* there is no in between state because we\n+effectively acted like an OS and switched to another thread after\n+every single instruction of the routine is executed and looked at the\n+results each time.\n+\n+We use the same idea to test for data races to see if an illegal load\n+has been hoisted, or that two parallel bitfield writes don't overlap\n+in a data race.\n+\n+Below is a skeleton of how a test should look like.  For more details,\n+look at the tests themselves.\n+\n+ANATOMY OF A TEST\n+-----------------\n+\n+/* { dg-do link } */\n+/* { dg-options \"-some-flags\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+/* NOTE: Any failure must be indicated by displaying \"FAIL:\".  */\n+\n+#include \"simulate-thread.h\"\n+\n+/* Called before each instruction, simulating another thread executing.  */\n+void simulate_thread_other_threads()\n+{\n+}\n+\n+/* Called after each instruction.  Returns 1 if any inconsistency is\n+   found, 0 otherwise.  */\n+int simulate_thread_step_verify()\n+{\n+  if (some_problem)\n+    {\n+      printf(\"FAIL: reason\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Called at the end of the program (simulate_thread_fini == 1).  Verifies\n+   the state of the program and returns 1 if any inconsistency is\n+   found, 0 otherwise.  */\n+int simulate_thread_final_verify()\n+{\n+  if (some_problem)\n+    {\n+      printf(\"FAIL: reason\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* The gdb script will break on simulate_thread_main(), so make sure\n+   GCC does not inline it, thus making the break point fail.  */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  /* Do stuff.  */\n+}\n+\n+int main()\n+{\n+\n+  /* Perform any setup code that will run outside of the testing\n+     harness.  Put code here that you do NOT want to be interrupted on\n+     an instruction basis.  E.g., setup code, and system library\n+     calls.  */\n+\n+     /* Do un-instrumented stuff. */\n+     /* ... */\n+\n+  /* Start the instrumented show.  */\n+  simulate_thread_main();\n+\n+  /* Must be called at the end of the test.  */\n+  simulate_thread_done();\n+\n+  return 0;\n+}"}, {"sha": "6d47388cadf3baecd0c488e790bc3f1698de54f3", "filename": "gcc/testsuite/gcc.dg/simulate-thread/simulate-thread.exp", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.exp?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,38 @@\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Your run of the mill dg test, but verify that we have a working GDB first.\n+\n+load_lib gcc-dg.exp\n+load_lib gcc-simulate-thread.exp\n+load_lib torture-options.exp\n+\n+dg-init\n+torture-init\n+set-torture-options [list \\\n+\t{ -O0 -g } \\\n+\t{ -O1 -g } \\\n+\t{ -O2 -g } \\\n+\t{ -O3 -g } \\\n+\t{ -Os -g } ]\n+\n+if [gdb-exists] {\n+  gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] \"\"\n+  gcc-dg-runtest [lsort [glob $srcdir/c-c++-common/simulate-thread/*.c]] \"\"\n+}\n+\n+torture-finish\n+dg-finish"}, {"sha": "004909f15d18f662fabca118baaa1fd540dd68b9", "filename": "gcc/testsuite/gcc.dg/simulate-thread/simulate-thread.gdb", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.gdb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.gdb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.gdb?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,17 @@\n+set height 0\n+break simulate_thread_main\n+disp/i $pc\n+run\n+\n+set $ret = 0\n+while (simulate_thread_fini != 1) && (! $ret)\n+  call simulate_thread_other_threads()\n+  stepi\n+  set $ret |= simulate_thread_step_verify()\n+end\n+\n+if (! $ret)\n+  set $ret |= simulate_thread_final_verify()\n+end\n+continue\n+quit $ret"}, {"sha": "8dabfa203227664bfb4c21efd14bd1f655973a93", "filename": "gcc/testsuite/gcc.dg/simulate-thread/simulate-thread.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.h?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,7 @@\n+int simulate_thread_fini = 0;\n+\n+void __attribute__((noinline))\n+simulate_thread_done ()\n+{\n+  simulate_thread_fini = 1;\n+}"}, {"sha": "6bac368d43dc4fa5d3e40d85bf9d5fbc545a0fd4", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -747,4 +747,26 @@ proc dg-message { args } {\n     process-message saved-dg-warning \"\" $args\n }\n \n+# Check the existence of a gdb in the path, and return true if there\n+# is one.\n+#\n+# Set env(GDB_FOR_GCC_TESTING) accordingly.\n+\n+proc gdb-exists { args } {\n+    if ![info exists ::env(GDB_FOR_GCC_TESTING)] {\n+\tglobal GDB\n+\tif ![info exists ::env(GDB_FOR_GCC_TESTING)] {\n+\t    if [info exists GDB] {\n+\t\tsetenv GDB_FOR_GCC_TESTING \"$GDB\"\n+\t    } else {\n+\t\tsetenv GDB_FOR_GCC_TESTING \"[transform gdb]\"\n+\t    }\n+\t}\n+    }\n+    if { [which $::env(GDB_FOR_GCC_TESTING)] != 0 } {\n+\treturn 1;\n+    }\n+    return 0;\n+}\n+\n set additional_prunes \"\""}, {"sha": "ba2416acdd747bdf60e2c710b3fc547d1ac10f5f", "filename": "gcc/testsuite/lib/gcc-simulate-thread.exp", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Flib%2Fgcc-simulate-thread.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8e7c4d682099d61e81a20b465280bcc7cdaab5/gcc%2Ftestsuite%2Flib%2Fgcc-simulate-thread.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-simulate-thread.exp?ref=ff8e7c4d682099d61e81a20b465280bcc7cdaab5", "patch": "@@ -0,0 +1,90 @@\n+#   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Utility for running a given test through the simulate-thread harness\n+# using gdb.  This is invoked via dg-final.\n+#\n+# Adapted from the guality harness.\n+#\n+# Call 'fail' if a given test printed \"FAIL:\", otherwise call 'pass'.\n+\n+proc simulate-thread { args } {\n+    if { ![isnative] || [is_remote target] } { return }\n+\n+    if { [llength $args] == 1 } {\n+\tswitch [dg-process-target [lindex $args 0]] {\n+\t\t\"F\" { setup_xfail \"*-*-*\" }\n+\t}\n+    }\n+\n+    # This assumes that we are three frames down from dg-test, and that\n+    # it still stores the filename of the testcase in a local variable \"name\".\n+    # A cleaner solution would require a new DejaGnu release.\n+    upvar 2 name testcase\n+    upvar 2 prog prog\n+    upvar 2 srcdir testsuite_dir\n+\n+    set gdb_name $::env(GDB_FOR_GCC_TESTING)\n+    set exec_file \"[file rootname [file tail $prog]].exe\"\n+    set cmd_file \"$testsuite_dir/gcc.dg/simulate-thread/simulate-thread.gdb\"\n+\n+    if ![file exists $exec_file] {\n+\treturn\n+    }\n+\n+    send_log \"Spawning: $gdb_name -nx -nw -quiet -x $cmd_file ./$exec_file\\n\"\n+    set res [remote_spawn target \"$gdb_name -nx -nw  -x $cmd_file ./$exec_file\"]\n+    if { $res < 0 || $res == \"\" } {\n+\tunsupported \"$testcase\"\n+\treturn\n+    }\n+\n+    set gdb_worked 0\n+    remote_expect target [timeout_value] {\n+\t# Too old GDB\n+\t-re \"Unhandled dwarf expression|Error in sourced command file\" {\n+\t    unsupported \"$testcase\"\n+\t    remote_close target\n+\t    return\n+\t}\n+\t-re \"FAIL:\" {\n+\t    fail \"$testcase\"\n+\t    remote_close target\n+\t    return\n+\t}\n+\t# If the gdb output contained simulate_thread_main, assume\n+\t# that at the very least, we had a working gdb that was able\n+\t# to break in simulate_thread_main.\n+\t-re \"simulate_thread_main\" {\n+\t    set gdb_worked 1\n+\t    exp_continue\n+\t}\n+\ttimeout {\n+\t    unsupported \"$testcase\"\n+\t    remote_close target\n+\t    return\n+\t}\n+    }\n+\n+    remote_close target\n+    if {$gdb_worked} {\n+\tpass \"$testcase\"\n+    } else {\n+\t# Fail in the absence of a sane GDB.\n+\tfail \"$testcase\"\n+    }\n+    return\n+}"}]}