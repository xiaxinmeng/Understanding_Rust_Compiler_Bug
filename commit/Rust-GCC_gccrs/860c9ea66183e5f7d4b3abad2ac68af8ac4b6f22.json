{"sha": "860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwYzllYTY2MTgzZTVmN2Q0YjNhYmFkMmFjNjhhZjhhYzRiNmYyMg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-02-19T04:27:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-02-19T04:27:47Z"}, "message": "search.c (grow_bfs_bases): New subroutine of bfs_walk.\n\n\t* cp/search.c (grow_bfs_bases): New subroutine of bfs_walk.\n\t(bfs_walk): Rewritten using circular queue of BINFO_BASETYPES\n\tvectors, for speed.\n\nFrom-SVN: r63088", "tree": {"sha": "97012c25719e773eaf6b25c2608b5998e3c20cb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97012c25719e773eaf6b25c2608b5998e3c20cb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22/comments", "author": null, "committer": null, "parents": [{"sha": "78bd5210e7d719cf462c189681f3037d63b14c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bd5210e7d719cf462c189681f3037d63b14c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bd5210e7d719cf462c189681f3037d63b14c76"}], "stats": {"total": 144, "additions": 108, "deletions": 36}, "files": [{"sha": "3006cfdd2a9180ab91618061dbcd512ba3a8c0d8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22", "patch": "@@ -1,3 +1,9 @@\n+2003-02-18  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cp/search.c (grow_bfs_bases): New subroutine of bfs_walk.\n+\t(bfs_walk): Rewritten using circular queue of BINFO_BASETYPES\n+\tvectors, for speed.\n+\n 2003-02-18  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/9704"}, {"sha": "395464e0ef967602b8942298e2033adb69ed5021", "filename": "gcc/cp/search.c", "status": "modified", "additions": 102, "deletions": 36, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=860c9ea66183e5f7d4b3abad2ac68af8ac4b6f22", "patch": "@@ -102,6 +102,7 @@ static int look_for_overrides_r (tree, tree);\n static struct search_level *push_search_level (struct stack_level *,\n \t\t\t\t\t       struct obstack *);\n static struct search_level *pop_search_level (struct stack_level *);\n+static void grow_bfs_bases (tree **, size_t *, size_t *);\n static tree bfs_walk (tree, tree (*) (tree, void *),\n \t\t      tree (*) (tree, void *), void *);\n static tree lookup_field_queue_p (tree, void *);\n@@ -1620,6 +1621,43 @@ adjust_result_of_qualified_name_lookup (tree decl,\n }\n \n \f\n+/* Start with enough room for ten concurrent base classes.  That\n+   will be enough for most hierarchies.  */\n+#define BFS_WALK_INITIAL_QUEUE_SIZE 10\n+\n+/* Subroutine of bfs_walk; enlarges the buffer it uses for its\n+   circular queue.  */\n+static void\n+grow_bfs_bases (tree **basep, size_t *sizep, size_t *headp)\n+{\n+  tree *base;\n+  size_t size = *sizep;\n+  size_t head = *headp;\n+\n+  /* If the size is BFS_WALK_INITIAL_QUEUE_SIZE, the old array is on\n+     the stack.  */\n+  if (size == BFS_WALK_INITIAL_QUEUE_SIZE)\n+    {\n+      base = xmalloc (size * 2 * sizeof(tree));\n+      memcpy (base, *basep, size * sizeof(tree));\n+    }\n+  else\n+    base = xrealloc (*basep, size * 2 * sizeof(tree));\n+\n+  *basep = base;\n+  *sizep = size * 2;\n+\n+  /* Shift all the elements between head and the former end of the\n+     array, opening up a gap between tail and head.  If head==0 we\n+     don't need to do anything to achieve this.  */\n+  if (head != 0)\n+    {\n+      memmove (&base[head + size], &base[head],\n+\t       (size - head) * sizeof (tree));\n+      *headp = head + size;\n+    }\n+}\n+\n /* Walk the class hierarchy dominated by TYPE.  FN is called for each\n    type in the hierarchy, in a breadth-first preorder traversal.\n    If it ever returns a non-NULL value, that value is immediately\n@@ -1629,61 +1667,89 @@ adjust_result_of_qualified_name_lookup (tree decl,\n    value returned is nonzero, the base-class is walked; otherwise it\n    is not.  If QFN is NULL, it is treated as a function which always\n    returns 1.  Both FN and QFN are passed the DATA whenever they are\n-   called.  */\n+   called.\n+\n+   Implementation notes: Uses a circular queue, which starts off on\n+   the stack but gets moved to the malloc arena if it needs to be\n+   enlarged.  The underflow and overflow conditions are\n+   indistinguishable except by context: if head == tail and we just\n+   moved the head pointer, the queue is empty, but if we just moved\n+   the tail pointer, the queue is full.  Base class vectors are only\n+   put on the queue if they are nonempty, which is why it's safe to\n+   use do-while for the inner loop.  */\n \n static tree\n bfs_walk (tree binfo, tree (*fn) (tree, void *),\n \t  tree (*qfn) (tree, void *), void *data)\n {\n-  size_t head;\n-  size_t tail;\n   tree rval = NULL_TREE;\n-  /* An array of the base classes of BINFO.  These will be built up in\n-     breadth-first order, except where QFN prunes the search.  */\n-  varray_type bfs_bases;\n \n-  /* Start with enough room for ten base classes.  That will be enough\n-     for most hierarchies.  */\n-  VARRAY_TREE_INIT (bfs_bases, 10, \"search_stack\");\n+  tree bfs_bases_initial[BFS_WALK_INITIAL_QUEUE_SIZE];\n+  /* A circular queue of the base classes of BINFO.  These will be\n+     built up in breadth-first order, except where QFN prunes the\n+     search.  */\n+  size_t head, tail;\n+  size_t bfs_bases_size = BFS_WALK_INITIAL_QUEUE_SIZE;\n+  tree *bfs_bases = bfs_bases_initial;\n+\n+  /* Is the first one what we're looking for?  If so, we're done.  */\n+  rval = fn (binfo, data);\n+  if (rval)\n+    return rval;\n+\n+  /* If it has no base types, we are also done.  */\n+  if (BINFO_BASETYPES (binfo) == 0\n+      || TREE_VEC_LENGTH (BINFO_BASETYPES (binfo)) == 0)\n+    return 0;\n+\n+  /* Otherwise, initialize the queue with its basetypes vector\n+     and proceed.  */\n \n-  /* Put the first type into the stack.  */\n-  VARRAY_TREE (bfs_bases, 0) = binfo;\n-  tail = 1;\n+  head = tail = 0;\n+  bfs_bases[tail++] = BINFO_BASETYPES (binfo);\n \n-  for (head = 0; head < tail; ++head)\n+  do\n     {\n-      int i;\n-      int n_baselinks;\n+      int i, n_baselinks;\n       tree binfos;\n+      \n+      binfos = bfs_bases[head++];\n+      if (head == bfs_bases_size)\n+\thead = 0;\n \n-      /* Pull the next type out of the queue.  */\n-      binfo = VARRAY_TREE (bfs_bases, head);\n-\n-      /* If this is the one we're looking for, we're done.  */\n-      rval = (*fn) (binfo, data);\n-      if (rval)\n-\tbreak;\n-\n-      /* Queue up the base types.  */\n-      binfos = BINFO_BASETYPES (binfo);\n-      n_baselinks = binfos ? TREE_VEC_LENGTH (binfos): 0;\n-      for (i = 0; i < n_baselinks; i++)\n+      i = 0;\n+      n_baselinks = TREE_VEC_LENGTH (binfos);\n+      do\n \t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n+\t  binfo = TREE_VEC_ELT (binfos, i);\n+\t  i++;\n \n \t  if (qfn)\n-\t    base_binfo = (*qfn) (base_binfo, data);\n+\t    binfo = qfn (binfo, data);\n+\t  if (!binfo)\n+\t    continue;\n \n-\t  if (base_binfo)\n-\t    {\n-\t      if (tail == VARRAY_SIZE (bfs_bases))\n-\t\tVARRAY_GROW (bfs_bases, 2 * VARRAY_SIZE (bfs_bases));\n-\t      VARRAY_TREE (bfs_bases, tail) = base_binfo;\n-\t      ++tail;\n-\t    }\n+\t  rval = fn (binfo, data);\n+\t  if (rval)\n+\t    goto done;\n+\n+\t  if (BINFO_BASETYPES (binfo) == 0\n+\t      || TREE_VEC_LENGTH (BINFO_BASETYPES (binfo)) == 0)\n+\t    continue;\n+\n+\t  bfs_bases[tail++] = BINFO_BASETYPES (binfo);\n+\t  if (tail == bfs_bases_size)\n+\t    tail = 0;\n+\t  if (tail == head)\n+\t    grow_bfs_bases (&bfs_bases, &bfs_bases_size, &head);\n \t}\n+      while (i < n_baselinks);\n     }\n+  while (head != tail);\n \n+ done:\n+  if (bfs_bases != bfs_bases_initial)\n+    free (bfs_bases);\n   return rval;\n }\n "}]}