{"sha": "d938e4612a745b6fa19fae8f68acbb3e5062cf47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkzOGU0NjEyYTc0NWI2ZmExOWZhZThmNjhhY2JiM2U1MDYyY2Y0Nw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-10-17T02:28:44Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-10-17T02:28:44Z"}, "message": "re PR tree-optimization/22444 (ICE at tree-into-ssa.c:466)\n\n2005-10-16  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/22444\n\t* tree-ssa-alias.c (compute_flow_insensitive_aliasing):\n\tAssert that we don't hit something with subvars.\n\t(setup_pointers_and_addressables): Don't add things with subvars,\n\tbecause we'll already process the subvars for aliasing purposes.\n\nFrom-SVN: r105486", "tree": {"sha": "ad1e8c913c8f44f1ec22eaa4ef898c576491d8ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad1e8c913c8f44f1ec22eaa4ef898c576491d8ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d938e4612a745b6fa19fae8f68acbb3e5062cf47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d938e4612a745b6fa19fae8f68acbb3e5062cf47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d938e4612a745b6fa19fae8f68acbb3e5062cf47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d938e4612a745b6fa19fae8f68acbb3e5062cf47/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f52714a7200aa5422bd7de330e108490f423e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f52714a7200aa5422bd7de330e108490f423e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f52714a7200aa5422bd7de330e108490f423e93"}], "stats": {"total": 183, "additions": 160, "deletions": 23}, "files": [{"sha": "6612783daf05ddc159fc56ccdb0ad2b85e82a236", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d938e4612a745b6fa19fae8f68acbb3e5062cf47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d938e4612a745b6fa19fae8f68acbb3e5062cf47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d938e4612a745b6fa19fae8f68acbb3e5062cf47", "patch": "@@ -1,3 +1,11 @@\n+2005-10-16  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/22444\n+\t* tree-ssa-alias.c (compute_flow_insensitive_aliasing):\n+\tAssert that we don't hit something with subvars.\n+\t(setup_pointers_and_addressables): Don't add things with subvars,\n+\tbecause we'll already process the subvars for aliasing purposes.\n+\n 2005-10-16  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR target/23424"}, {"sha": "303a74d76755f9762136deb85dafa36586de1f23", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr22444.C", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d938e4612a745b6fa19fae8f68acbb3e5062cf47/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22444.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d938e4612a745b6fa19fae8f68acbb3e5062cf47/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22444.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22444.C?ref=d938e4612a745b6fa19fae8f68acbb3e5062cf47", "patch": "@@ -0,0 +1,141 @@\n+// PR tree-optimization/22444\n+// When creating SFT's, we shouldn't add the original variable\n+// to the addressable vars list, because this may cause false aliasing\n+// with the subvars leading to the subvars not being renamed when they should\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+typedef int ptrdiff_t;\n+typedef unsigned int size_t;\n+namespace std\n+{\n+  template<class _T1, class _T2> struct pair\n+  {\n+    _T1 first;\n+    _T2 second;\n+    pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) { }\n+  };\n+}\n+namespace __gnu_internal\n+{\n+  typedef char __one;\n+  template<typename _Tp> __one __test_type(int _Tp::*);\n+}\n+namespace std\n+{\n+  template<typename _Tp> struct __is_pod\n+  {\n+    enum { __value = (sizeof(__gnu_internal::__test_type<_Tp>(0))!= sizeof(__gnu_internal::__one)) };\n+  };\n+  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t, typename _Pointer = _Tp*, typename _Reference = _Tp&> struct iterator\n+  { };\n+  template<typename _Iterator> struct iterator_traits\n+  {\n+    typedef typename _Iterator::difference_type difference_type;\n+  };\n+  template<typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference>\n+  {\n+    typedef _Iterator iterator_type;\n+    typedef typename iterator_traits<_Iterator>::difference_type difference_type;\n+    typedef typename iterator_traits<_Iterator>::reference reference;\n+    reverse_iterator operator+(difference_type __n) const {}\n+    reverse_iterator& operator+=(difference_type __n) { }\n+    reference operator[](difference_type __n) const { }\n+  };\n+}\n+namespace __gnu_cxx\n+{\n+  template<bool _Thread> class __pool;\n+  template<template <bool> class _PoolTp, bool _Thread> struct __common_pool_policy;\n+  template<typename _Tp> class __mt_alloc_base\n+  {\n+    typedef ptrdiff_t difference_type;\n+    typedef _Tp* pointer;\n+  };\n+  template<typename _Tp, typename _Poolp = __common_pool_policy<__pool, true> > class __mt_alloc : public __mt_alloc_base<_Tp>\n+  {\n+    typedef size_t size_type;\n+  };\n+}\n+namespace std\n+{\n+  template<typename _Tp> struct allocator:public __gnu_cxx::__mt_alloc<_Tp>\n+  {\n+    template<typename _Tp1> struct rebind\n+    {\n+      typedef allocator<_Tp1> other;\n+    };\n+  };\n+  template <class _Arg, class _Result> struct unary_function  { };\n+  template <class _Arg1, class _Arg2, class _Result> struct binary_function\n+  {\n+    typedef _Arg2 second_argument_type;\n+  };\n+  template <class _Tp> struct less : public binary_function<_Tp, _Tp, bool>\n+  {\n+    bool operator()(const _Tp& __x, const _Tp& __y) const { }\n+  };\n+  template <class _Tp> struct _Identity : public unary_function<_Tp,_Tp> { };\n+  struct _Rb_tree_node_base\n+  {\n+    typedef _Rb_tree_node_base* _Base_ptr;\n+    typedef const _Rb_tree_node_base* _Const_Base_ptr;\n+    _Base_ptr _M_right;\n+    static _Base_ptr _S_minimum(_Base_ptr __x) { }\n+    static _Base_ptr _S_maximum(_Base_ptr __x) { }\n+  };\n+  template<typename _Val> struct _Rb_tree_node { };\n+  template<typename _Tp> struct _Rb_tree_iterator\n+  {\n+    typedef _Tp* pointer;\n+    typedef _Rb_tree_iterator<_Tp> _Self;\n+    typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+    pointer operator->() const { }\n+    _Self operator++(int) { }\n+    _Base_ptr _M_node;\n+  };\n+  template<typename _Tp> struct _Rb_tree_const_iterator\n+  {\n+    typedef const _Tp* pointer;\n+    typedef _Rb_tree_iterator<_Tp> iterator;\n+    typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;\n+    _Rb_tree_const_iterator(const iterator& __it) : _M_node(__it._M_node) { }\n+    _Base_ptr _M_node;\n+  };\n+  template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc = allocator<_Val> > struct _Rb_tree\n+  {\n+    typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other _Node_allocator;\n+    typedef _Rb_tree_node_base* _Base_ptr;\n+    typedef const _Rb_tree_node_base* _Const_Base_ptr;\n+    typedef _Rb_tree_node<_Val> _Rb_tree_node;\n+    typedef _Key key_type;\n+    typedef _Val value_type;\n+    typedef value_type* pointer;\n+    typedef _Rb_tree_node* _Link_type;\n+    template<typename _Key_compare, bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value> struct _Rb_tree_impl\n+      : _Node_allocator\n+    {\n+      _Rb_tree_node_base _M_header;\n+    };\n+    _Rb_tree_impl<_Compare> _M_impl;\n+    typedef _Rb_tree_iterator<value_type> iterator;\n+    typedef _Rb_tree_const_iterator<value_type> const_iterator;\n+    typedef std::reverse_iterator<iterator> reverse_iterator;\n+    pair<iterator,bool> insert_unique(const value_type& __x);\n+  };\n+  template<class _Key, class _Compare, class _Alloc> class set\n+  {\n+    typedef _Key key_type;\n+    typedef _Key value_type;\n+    typedef _Compare key_compare;\n+    typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;\n+    typedef _Rb_tree<_Key, value_type, _Identity<value_type>, key_compare, _Key_alloc_type> _Rep_type;\n+    _Rep_type _M_t;\n+    typedef typename _Rep_type::const_iterator iterator;\n+    std::pair<iterator,bool> insert(const value_type& __x)\n+    {\n+      std::pair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x);\n+      return std::pair<iterator, bool>(__p.first, __p.second);\n+    }\n+  };\n+}\n+template class std::set<int, std::less<int>, std::allocator<char> >;"}, {"sha": "84c522554b21c5147efdce1f0f34ab9e72f7851c", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d938e4612a745b6fa19fae8f68acbb3e5062cf47/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d938e4612a745b6fa19fae8f68acbb3e5062cf47/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d938e4612a745b6fa19fae8f68acbb3e5062cf47", "patch": "@@ -799,36 +799,22 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t     \n \t  if (may_alias_p (p_map->var, p_map->set, var, v_map->set, false))\n \t    {\n-\t      subvar_t svars;\n \t      size_t num_tag_refs, num_var_refs;\n \n \t      num_tag_refs = NUM_REFERENCES (tag_ann);\n \t      num_var_refs = NUM_REFERENCES (v_ann);\n \n \t      /* Add VAR to TAG's may-aliases set.  */\n \n-\t      /* If this is an aggregate, we may have subvariables for it\n-\t\t that need to be pointed to.  */\n-\t      if (var_can_have_subvars (var)\n-\t\t  && (svars = get_subvars_for_var (var)))\n-\t\t{\n-\t\t  subvar_t sv;\n+\t      /* We should never have a var with subvars here, because\n+\t         they shouldn't get into the set of addressable vars */\n+\t      gcc_assert (!var_can_have_subvars (var)\n+\t\t\t  || get_subvars_for_var (var) == NULL);\n \n-\t\t  for (sv = svars; sv; sv = sv->next)\n-\t\t    {\n-\t\t      add_may_alias (tag, sv->var);\n-\t\t      /* Update the bitmap used to represent TAG's alias set\n-\t\t\t in case we need to group aliases.  */\n-\t\t      bitmap_set_bit (p_map->may_aliases, DECL_UID (sv->var));\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  add_may_alias (tag, var);\n-\t\t  /* Update the bitmap used to represent TAG's alias set\n-\t\t     in case we need to group aliases.  */\n-\t\t  bitmap_set_bit (p_map->may_aliases, DECL_UID (var));\n-\t\t}\n+\t      add_may_alias (tag, var);\n+\t      /* Update the bitmap used to represent TAG's alias set\n+\t\t in case we need to group aliases.  */\n+\t      bitmap_set_bit (p_map->may_aliases, DECL_UID (var));\n \n \t      /* Update the total number of virtual operands due to\n \t\t aliasing.  Since we are adding one more alias to TAG's\n@@ -1280,7 +1266,9 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n       /* Global variables and addressable locals may be aliased.  Create an\n          entry in ADDRESSABLE_VARS for VAR.  */\n-      if (may_be_aliased (var))\n+      if (may_be_aliased (var)\t  \n+\t  && (!var_can_have_subvars (var) \n+\t      || get_subvars_for_var (var) == NULL))\n \t{\n \t  create_alias_map_for (var, ai);\n \t  mark_sym_for_renaming (var);"}]}