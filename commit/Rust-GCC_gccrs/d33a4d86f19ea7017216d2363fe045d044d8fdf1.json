{"sha": "d33a4d86f19ea7017216d2363fe045d044d8fdf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMzYTRkODZmMTllYTcwMTcyMTZkMjM2M2ZlMDQ1ZDA0NGQ4ZmRmMQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-09-26T18:04:37Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-09-26T18:04:37Z"}, "message": "rs6000.md (movsi_from_sf): Adjust code to eliminate doing a 32-bit shift right or vector extract after...\n\n2017-09-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.md (movsi_from_sf): Adjust code to\n\teliminate doing a 32-bit shift right or vector extract after doing\n\tXSCVDPSPN.  Use zero_extendsidi2 instead of p8_mfvsrd_4_disf to\n\tmove the value to the GPRs.\n\t(movdi_from_sf_zero_ext): Likewise.\n\t(reload_gpr_from_vsxsf): Likewise.\n\t(p8_mfvsrd_4_disf): Delete, no longer used.\n\nFrom-SVN: r253209", "tree": {"sha": "eb531ad193252720de623a4665158dfa4c4dfe9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb531ad193252720de623a4665158dfa4c4dfe9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d33a4d86f19ea7017216d2363fe045d044d8fdf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d33a4d86f19ea7017216d2363fe045d044d8fdf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d33a4d86f19ea7017216d2363fe045d044d8fdf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d33a4d86f19ea7017216d2363fe045d044d8fdf1/comments", "author": null, "committer": null, "parents": [{"sha": "8615012c05130f592b4ef6b11ac6af7cc28718d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8615012c05130f592b4ef6b11ac6af7cc28718d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8615012c05130f592b4ef6b11ac6af7cc28718d2"}], "stats": {"total": 114, "additions": 46, "deletions": 68}, "files": [{"sha": "9b5b9fc97298cdb3d40f93ba2dda5c58eb773f40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d33a4d86f19ea7017216d2363fe045d044d8fdf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d33a4d86f19ea7017216d2363fe045d044d8fdf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d33a4d86f19ea7017216d2363fe045d044d8fdf1", "patch": "@@ -4,6 +4,14 @@\n \tsign extension from a vector register to a GPR by doing a 32-bit\n \tdirect move and then an EXTSW.\n \t(extendsi<mode>2 splitter): Likewise.\n+\t(movsi_from_sf): Adjust code to eliminate doing a 32-bit shift\n+\tright or vector extract after doing XSCVDPSPN.  Use\n+\tzero_extendsidi2 instead of p8_mfvsrd_4_disf to move the value to\n+\tthe GPRs.\n+\t(movdi_from_sf_zero_ext): Likewise.\n+\t(reload_gpr_from_vsxsf): Likewise.\n+\t(p8_mfvsrd_4_disf): Delete, no longer used.\n+\n \n 2017-09-26  Martin Jambor  <mjambor@suse.cz>\n "}, {"sha": "c91719f821f39e878997ab4e296415cd18911299", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 38, "deletions": 68, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d33a4d86f19ea7017216d2363fe045d044d8fdf1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d33a4d86f19ea7017216d2363fe045d044d8fdf1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d33a4d86f19ea7017216d2363fe045d044d8fdf1", "patch": "@@ -6806,25 +6806,25 @@\n ;; needed.\n \n ;;\t\tMR           LWZ          LFIWZX       LXSIWZX   STW\n-;;\t\tSTFS         STXSSP       STXSSPX      VSX->GPR  MTVSRWZ\n-;;\t\tVSX->VSX\n+;;\t\tSTFS         STXSSP       STXSSPX      VSX->GPR  VSX->VSX\n+;;\t\tMTVSRWZ\n \n (define_insn_and_split \"movsi_from_sf\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n \t\t\"=r,         r,           ?*wI,        ?*wH,     m,\n-\t\t m,          wY,          Z,           r,        wIwH,\n-\t\t ?wK\")\n+\t\t m,          wY,          Z,           r,        ?*wIwH,\n+\t\t wIwH\")\n \n \t(unspec:SI [(match_operand:SF 1 \"input_operand\"\n \t\t\"r,          m,           Z,           Z,        r,\n-\t\t f,          wb,          wu,          wIwH,     r,\n-\t\t wK\")]\n+\t\t f,          wb,          wu,          wIwH,     wIwH,\n+\t\t r\")]\n \t\t    UNSPEC_SI_FROM_SF))\n \n    (clobber (match_scratch:V4SF 2\n \t\t\"=X,         X,           X,           X,        X,\n-\t\t X,          X,           X,           wa,       X,\n-\t\t wa\"))]\n+\t\t X,          X,           X,           wIwH,     X,\n+\t\t X\"))]\n \n   \"TARGET_NO_SF_SUBREG\n    && (register_operand (operands[0], SImode)\n@@ -6839,63 +6839,52 @@\n    stxssp %1,%0\n    stxsspx %x1,%y0\n    #\n-   mtvsrwz %x0,%1\n-   #\"\n+   xscvdpspn %x0,%x1\n+   mtvsrwz %x0,%1\"\n   \"&& reload_completed\n-   && register_operand (operands[0], SImode)\n+   && int_reg_operand (operands[0], SImode)\n    && vsx_reg_sfsubreg_ok (operands[1], SFmode)\"\n   [(const_int 0)]\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n   rtx op2 = operands[2];\n-  rtx op0_di = gen_rtx_REG (DImode, REGNO (op0));\n+  rtx op0_di = gen_rtx_REG (DImode, reg_or_subregno (op0));\n+  rtx op2_si = gen_rtx_REG (SImode, reg_or_subregno (op2));\n \n   emit_insn (gen_vsx_xscvdpspn_scalar (op2, op1));\n-\n-  if (int_reg_operand (op0, SImode))\n-    {\n-      emit_insn (gen_p8_mfvsrd_4_disf (op0_di, op2));\n-      emit_insn (gen_lshrdi3 (op0_di, op0_di, GEN_INT (32)));\n-    }\n-  else\n-    {\n-      rtx op1_v16qi = gen_rtx_REG (V16QImode, REGNO (op1));\n-      rtx byte_off = VECTOR_ELT_ORDER_BIG ? const0_rtx : GEN_INT (12);\n-      emit_insn (gen_vextract4b (op0_di, op1_v16qi, byte_off));\n-    }\n-\n+  emit_insn (gen_zero_extendsidi2 (op0_di, op2_si));\n   DONE;\n }\n   [(set_attr \"type\"\n \t\t\"*,          load,        fpload,      fpload,   store,\n-\t\t fpstore,    fpstore,     fpstore,     mftgpr,   mffgpr,\n-\t\t veclogical\")\n+\t\t fpstore,    fpstore,     fpstore,     mftgpr,   fp,\n+\t\t mffgpr\")\n \n    (set_attr \"length\"\n \t\t\"4,          4,           4,           4,        4,\n-\t\t 4,          4,           4,           12,       4,\n-\t\t 8\")])\n+\t\t 4,          4,           4,           8,        4,\n+\t\t 4\")])\n \n ;; movsi_from_sf with zero extension\n ;;\n ;;\t\tRLDICL       LWZ          LFIWZX       LXSIWZX   VSX->GPR\n-;;\t\tMTVSRWZ      VSX->VSX\n+;;\t\tVSX->VSX     MTVSRWZ\n \n (define_insn_and_split \"*movdi_from_sf_zero_ext\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\"\n \t\t\"=r,         r,           ?*wI,        ?*wH,     r,\n-\t\twIwH,        ?wK\")\n+\t\t ?wK,        wIwH\")\n \n \t(zero_extend:DI\n \t (unspec:SI [(match_operand:SF 1 \"input_operand\"\n \t\t\"r,          m,           Z,           Z,        wIwH,\n-\t\t r,          wK\")]\n+\t\t wIwH,       r\")]\n \t\t    UNSPEC_SI_FROM_SF)))\n \n    (clobber (match_scratch:V4SF 2\n \t\t\"=X,         X,           X,           X,        wa,\n-\t\t X,          wa\"))]\n+\t\t wIwH,       X\"))]\n \n   \"TARGET_DIRECT_MOVE_64BIT\n    && (register_operand (operands[0], DImode)\n@@ -6906,40 +6895,29 @@\n    lfiwzx %0,%y1\n    lxsiwzx %x0,%y1\n    #\n-   mtvsrwz %x0,%1\n-   #\"\n+   #\n+   mtvsrwz %x0,%1\"\n   \"&& reload_completed\n+   && register_operand (operands[0], DImode)\n    && vsx_reg_sfsubreg_ok (operands[1], SFmode)\"\n   [(const_int 0)]\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n   rtx op2 = operands[2];\n+  rtx op2_si = gen_rtx_REG (SImode, reg_or_subregno (op2));\n \n   emit_insn (gen_vsx_xscvdpspn_scalar (op2, op1));\n-\n-  if (int_reg_operand (op0, DImode))\n-    {\n-      emit_insn (gen_p8_mfvsrd_4_disf (op0, op2));\n-      emit_insn (gen_lshrdi3 (op0, op0, GEN_INT (32)));\n-    }\n-  else\n-    {\n-      rtx op0_si = gen_rtx_REG (SImode, REGNO (op0));\n-      rtx op1_v16qi = gen_rtx_REG (V16QImode, REGNO (op1));\n-      rtx byte_off = VECTOR_ELT_ORDER_BIG ? const0_rtx : GEN_INT (12);\n-      emit_insn (gen_vextract4b (op0_si, op1_v16qi, byte_off));\n-    }\n-\n+  emit_insn (gen_zero_extendsidi2 (op0, op2_si));\n   DONE;\n }\n   [(set_attr \"type\"\n-\t\t\"*,          load,        fpload,      fpload,  mftgpr,\n-\t\t mffgpr,     veclogical\")\n+\t\t\"*,          load,        fpload,      fpload,   two,\n+\t\t two,        mffgpr\")\n \n    (set_attr \"length\"\n-\t\t\"4,          4,           4,           4,        12,\n-\t\t 4,          8\")])\n+\t\t\"4,          4,           4,           4,        8,\n+\t\t 8,          4\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -8439,9 +8417,9 @@\n \n (define_insn_and_split \"reload_gpr_from_vsxsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"wa\")]\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"ww\")]\n \t\t   UNSPEC_P8V_RELOAD_FROM_VSX))\n-   (clobber (match_operand:V4SF 2 \"register_operand\" \"=wa\"))]\n+   (clobber (match_operand:V4SF 2 \"register_operand\" \"=wIwH\"))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -8450,23 +8428,15 @@\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n   rtx op2 = operands[2];\n-  rtx diop0 = simplify_gen_subreg (DImode, op0, SFmode, 0);\n+  rtx op0_di = gen_rtx_REG (DImode, reg_or_subregno (op0));\n+  rtx op2_si = gen_rtx_REG (SImode, reg_or_subregno (op2));\n \n   emit_insn (gen_vsx_xscvdpspn_scalar (op2, op1));\n-  emit_insn (gen_p8_mfvsrd_4_disf (diop0, op2));\n-  emit_insn (gen_lshrdi3 (diop0, diop0, GEN_INT (32)));\n+  emit_insn (gen_zero_extendsidi2 (op0_di, op2_si));\n   DONE;\n }\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"three\")])\n-\n-(define_insn \"p8_mfvsrd_4_disf\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:V4SF 1 \"register_operand\" \"wa\")]\n-\t\t   UNSPEC_P8V_RELOAD_FROM_VSX))]\n-  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"mfvsrd %0,%x1\"\n-  [(set_attr \"type\" \"mftgpr\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"two\")])\n \n \f\n ;; Next come the multi-word integer load and store and the load and store"}]}