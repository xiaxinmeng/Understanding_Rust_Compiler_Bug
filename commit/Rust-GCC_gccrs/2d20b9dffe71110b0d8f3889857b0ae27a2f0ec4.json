{"sha": "2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQyMGI5ZGZmZTcxMTEwYjBkOGYzODg5ODU3YjBhZTI3YTJmMGVjNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-14T19:54:07Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-14T19:54:07Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r321", "tree": {"sha": "49bbf39d1e87e70f5c10a2157fb14fdf90858250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49bbf39d1e87e70f5c10a2157fb14fdf90858250"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4/comments", "author": null, "committer": null, "parents": [{"sha": "f8e30d7f57f2b963c3977fd283733e329caef7aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e30d7f57f2b963c3977fd283733e329caef7aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e30d7f57f2b963c3977fd283733e329caef7aa"}], "stats": {"total": 27, "additions": 22, "deletions": 5}, "files": [{"sha": "6e0b5f1ef498001ace866ef61bc3cbd701fef9d1", "filename": "gcc/jump.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4", "patch": "@@ -1199,6 +1199,17 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t     is not defined and the condition is tested by a separate compare\n \t     insn.  This is because the code below assumes that the result\n \t     of the compare dies in the following branch.  */\n+\n+\t  /* ??? This has to be turned off.  The problem is that the\n+\t     unconditional jump might indirectly end up branching to the\n+\t     label between TEMP1 and TEMP.  We can't detect this, in general,\n+\t     since it may become a jump to there after further optimizations.\n+\t     If that jump is done, it will be deleted, so we will retry\n+\t     this optimization in the next pass, thus an infinite loop.\n+\n+\t     The present code prevents this by putting the jump after the\n+\t     label, but this is not logically correct.  */\n+#if 0\n \t  else if (this_is_condjump\n \t\t   /* Safe to skip USE and CLOBBER insns here\n \t\t      since they will not be deleted.  */\n@@ -1260,9 +1271,9 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t    /* Get the label out of the LABEL_REF.  */\n \t\t    ultimate = XEXP (ultimate, 0);\n \n-\t\t  /* Insert the jump after any USE or CLOBBER\n-\t\t     that follows TEMP1.  */\n-\t\t  last_insn = prev_real_insn (temp);\n+\t\t  /* Insert the jump immediately before TEMP, specifically\n+\t\t     after the label that is between TEMP1 and TEMP.  */\n+\t\t  last_insn = PREV_INSN (temp);\n \n \t\t  /* If we would be branching to the next insn, the jump\n \t\t     would immediately be deleted and the re-inserted in\n@@ -1288,6 +1299,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t    }\n \t\t}\n \t    }\n+#endif\n \t  /* Detect a conditional jump going to the same place\n \t     as an immediately following unconditional jump.  */\n \t  else if (this_is_condjump\n@@ -2513,6 +2525,8 @@ sets_cc0_p (x)\n /* Follow any unconditional jump at LABEL;\n    return the ultimate label reached by any such chain of jumps.\n    If LABEL is not followed by a jump, return LABEL.\n+   If the chain loops or we can't find end, return LABEL,\n+   since that tells caller to avoid changing the insn.\n \n    If RELOAD_COMPLETED is 0, we do not chain across a NOTE_INSN_LOOP_BEG or\n    a USE or CLOBBER.  */\n@@ -2548,9 +2562,11 @@ follow_jumps (label)\n \n       /* If we have found a cycle, make the insn jump to itself.  */\n       if (JUMP_LABEL (insn) == label)\n-\tbreak;\n+\treturn label;\n       value = JUMP_LABEL (insn);\n     }\n+  if (depth == 10)\n+    return label;\n   return value;\n }\n \n@@ -3098,7 +3114,8 @@ redirect_jump (jump, nlabel)\n       int label_index = nlabel ? INSN_UID (nlabel) : 0;\n \n       delete_from_jump_chain (jump);\n-      if (label_index < max_jump_chain)\n+      if (label_index < max_jump_chain\n+\t  && INSN_UID (jump) < max_jump_chain)\n \t{\n \t  jump_chain[INSN_UID (jump)] = jump_chain[label_index];\n \t  jump_chain[label_index] = jump;"}]}