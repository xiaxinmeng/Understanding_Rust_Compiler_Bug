{"sha": "6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c", "node_id": "C_kwDOANBUbNoAKDZhYjk4ZDhiNThmZTRkM2M4ZmNlOGYzNGI5ZWZjNDE2Yjc2NzBjMWM", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-16T21:37:15Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-16T21:37:15Z"}, "message": "gimple-ssa-warn-access.cc: add missing auto_diagnostic_group\n\nWhilst working on SARIF output I noticed some places where followup notes\nweren't being properly associated with their warnings in\ngcc/gimple-ssa-warn-access.cc.\n\nFixed thusly.\n\ngcc/ChangeLog:\n\t* gimple-ssa-warn-access.cc (warn_string_no_nul): Add\n\tauto_diagnostic_group to group any warning with its note.\n\t(maybe_warn_for_bound): Likewise.\n\t(check_access): Likewise.\n\t(warn_dealloc_offset): Likewise.\n\t(pass_waccess::maybe_warn_memmodel): Likewise.\n\t(pass_waccess::maybe_check_dealloc_call): Likewise.\n\t(pass_waccess::warn_invalid_pointer): Likewise.\n\t(pass_waccess::check_dangling_stores): Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "9a2e1c990b590c2defe61817d609fb3b94d8aff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a2e1c990b590c2defe61817d609fb3b94d8aff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e"}], "stats": {"total": 28, "additions": 22, "deletions": 6}, "files": [{"sha": "eb9297a2bb268ea828ef75bb24af75554d1a4b91", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=6ab98d8b58fe4d3c8fce8f34b9efc416b7670c1c", "patch": "@@ -160,6 +160,8 @@ warn_string_no_nul (location_t loc, GimpleOrTree expr, const char *fname,\n \t\t (unsigned long long) bndrng[1].to_uhwi ());\n     }\n \n+  auto_diagnostic_group d;\n+\n   const tree maxobjsize = max_object_size ();\n   const wide_int maxsiz = wi::to_wide (maxobjsize);\n   if (expr)\n@@ -718,6 +720,7 @@ maybe_warn_for_bound (opt_code opt, location_t loc, GimpleOrTree exp, tree func,\n \t    maybe = false;\n \t}\n \n+      auto_diagnostic_group d;\n       if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n \t{\n \t  if (bndrng[0] == bndrng[1])\n@@ -1387,6 +1390,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n \t\t  && warning_suppressed_p (pad->dst.ref, opt)))\n \t    return false;\n \n+\t  auto_diagnostic_group d;\n \t  location_t loc = get_location (exp);\n \t  bool warned = false;\n \t  if (dstwrite == slen && at_least_one)\n@@ -1505,6 +1509,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n       const bool read\n \t= mode == access_read_only || mode == access_read_write;\n       const bool maybe = pad && pad->dst.parmarray;\n+      auto_diagnostic_group d;\n       if (warn_for_access (loc, func, exp, opt, range, slen, false, read,\n \t\t\t   maybe))\n \t{\n@@ -2019,6 +2024,7 @@ warn_dealloc_offset (location_t loc, gimple *call, const access_ref &aref)\n \t\t (long long)aref.offrng[1].to_shwi ());\n     }\n \n+  auto_diagnostic_group d;\n   if (!warning_at (loc, OPT_Wfree_nonheap_object,\n \t\t   \"%qD called on pointer %qE with nonzero offset%s\",\n \t\t   dealloc_decl, aref.ref, offstr))\n@@ -2902,6 +2908,7 @@ pass_waccess::maybe_warn_memmodel (gimple *stmt, tree ord_sucs,\n   if (!is_valid)\n     {\n       bool warned = false;\n+      auto_diagnostic_group d;\n       if (const char *modname = memmodel_name (sucs))\n \twarned = warning_at (loc, OPT_Winvalid_memory_model,\n \t\t\t     \"invalid memory model %qs for %qD\",\n@@ -2935,6 +2942,7 @@ pass_waccess::maybe_warn_memmodel (gimple *stmt, tree ord_sucs,\n       {\n \t/* If both memory model arguments are valid but their combination\n \t   is not, use their names in the warning.  */\n+\tauto_diagnostic_group d;\n \tif (!warning_at (loc, OPT_Winvalid_memory_model,\n \t\t\t \"invalid failure memory model %qs for %qD\",\n \t\t\t failname, fndecl))\n@@ -2955,6 +2963,7 @@ pass_waccess::maybe_warn_memmodel (gimple *stmt, tree ord_sucs,\n       {\n \t/* If both memory model arguments are valid but their combination\n \t   is not, use their names in the warning.  */\n+\tauto_diagnostic_group d;\n \tif (!warning_at (loc, OPT_Winvalid_memory_model,\n \t\t\t \"failure memory model %qs cannot be stronger \"\n \t\t\t \"than success memory model %qs for %qD\",\n@@ -3684,13 +3693,16 @@ pass_waccess::maybe_check_dealloc_call (gcall *call)\n   if (DECL_P (ref) || EXPR_P (ref))\n     {\n       /* Diagnose freeing a declared object.  */\n-      if (aref.ref_declared ()\n-\t  && warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t\t \"%qD called on unallocated object %qD\",\n-\t\t\t dealloc_decl, ref))\n+      if (aref.ref_declared ())\n \t{\n-\t  inform (get_location (ref), \"declared here\");\n-\t  return;\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t\t  \"%qD called on unallocated object %qD\",\n+\t\t\t  dealloc_decl, ref))\n+\t    {\n+\t      inform (get_location (ref), \"declared here\");\n+\t      return;\n+\t    }\n \t}\n \n       /* Diagnose freeing a pointer that includes a positive offset.\n@@ -3702,6 +3714,7 @@ pass_waccess::maybe_check_dealloc_call (gcall *call)\n     }\n   else if (CONSTANT_CLASS_P (ref))\n     {\n+      auto_diagnostic_group d;\n       if (warning_at (loc, OPT_Wfree_nonheap_object,\n \t\t      \"%qD called on a pointer to an unallocated \"\n \t\t      \"object %qE\", dealloc_decl, ref))\n@@ -3904,6 +3917,7 @@ pass_waccess::warn_invalid_pointer (tree ref, gimple *use_stmt,\n \n       const tree inval_decl = gimple_call_fndecl (inval_stmt);\n \n+      auto_diagnostic_group d;\n       if ((ref && warning_at (use_loc, OPT_Wuse_after_free,\n \t\t\t      (maybe\n \t\t\t       ? G_(\"pointer %qE may be used after %qD\")\n@@ -3929,6 +3943,7 @@ pass_waccess::warn_invalid_pointer (tree ref, gimple *use_stmt,\n \n   if (DECL_NAME (var))\n     {\n+      auto_diagnostic_group d;\n       if ((ref\n \t   && warning_at (use_loc, OPT_Wdangling_pointer_,\n \t\t\t  (maybe\n@@ -4576,6 +4591,7 @@ pass_waccess::check_dangling_stores (basic_block bb,\n       if (!is_auto_decl (rhs_ref.ref))\n \tcontinue;\n \n+      auto_diagnostic_group d;\n       location_t loc = gimple_location (stmt);\n       if (warning_at (loc, OPT_Wdangling_pointer_,\n \t\t      \"storing the address of local variable %qD in %qE\","}]}