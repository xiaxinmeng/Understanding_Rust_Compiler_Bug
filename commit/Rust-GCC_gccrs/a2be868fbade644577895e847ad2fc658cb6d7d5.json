{"sha": "a2be868fbade644577895e847ad2fc658cb6d7d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiZTg2OGZiYWRlNjQ0NTc3ODk1ZTg0N2FkMmZjNjU4Y2I2ZDdkNQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-01-15T03:01:49Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-15T03:01:49Z"}, "message": "loop.c (this_loop_info): Delete.\n\n\t* loop.c (this_loop_info): Delete.\n\t(uid_loop): Add in place of uid_loop_num.  All uses updated.\n \t(loop_number_exit_count): Delete and replace with entry in loop\n\tstructure.  All uses updated.\n\t(loop_number_loop_starts, loop_number_loop_ends): Likewise.\n\t(loop_number_loop_cont, loop_number_cont_dominator): Likewise.\n\t(loop_outer_loop): Likewise.\n\t(loop_invalid, loop_number_exit_labels): Likewise.\n\t(loop_used_count_register): Delete and replace with entry in\n\tloop_info structure.\n\t(find_and_verify_loops): Add loops argument.\n\t(verify_dominator, mark_loop_jump, prescan_loop): Replace loop_start,\n\tloop_end, etc. arguments with loop structure pointer.  All callers\n\tchanged.\n\t(loop_reg_used_before_p, scan_loop, strength_reduce): Likewise.\n\t(check_dbra_loop, next_insn_in_loop, try_copy_prop): Likewise.\n\t(load_mems_and_recount_loop_regs_set, load_mems): Likewise.\n\t(insert_bct): Likewise.\n\t(basic_induction_var): New argument level.\n\t* loop.h (struct loop_info): Delete fields num, loops_enclosed,\n\tvtop, and cont.  Add used_count_register.\n\t(uid_loop): Delete declaration.\n \t(loop_number_exit_count): Likewise.\n\t(loop_number_loop_starts, loop_number_loop_ends): Likewise.\n\t(loop_number_loop_cont, loop_number_cont_dominator): Likewise.\n\t(loop_outer_loop, loop_used_count_register): Likewise.\n\t(loop_invalid, loop_number_exit_labels): Likewise.\n\t(unroll_loop): Replace loop_start and loop_end arguments\n \twith loop structure pointer.\n\t(loop_precondition_p, loop_iterations): Likewise.\n\tInclude basic-block.h.\n\t* unroll.c: (unroll_loop): Replace loop_start and loop_end arguments\n \twith loop structure pointer.\n\t(loop_precondition_p, loop_iterations): Likewise.\n\t* basic-block.h (struct loop): New entries vtop, cont,\n \tcont_dominator, start, end, top, scan_start, exit_labels,\n\texit_count.\n\t* Makefile.in (LOOP_H): Add basic-block.h to dependencies.\n\nFrom-SVN: r31434", "tree": {"sha": "763658a41b42980e79c902cf002544568b86c28e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/763658a41b42980e79c902cf002544568b86c28e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2be868fbade644577895e847ad2fc658cb6d7d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2be868fbade644577895e847ad2fc658cb6d7d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2be868fbade644577895e847ad2fc658cb6d7d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2be868fbade644577895e847ad2fc658cb6d7d5/comments", "author": null, "committer": null, "parents": [{"sha": "d07ecc3bdf8bc2a5d055405bdc0b51c04237fc5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d07ecc3bdf8bc2a5d055405bdc0b51c04237fc5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d07ecc3bdf8bc2a5d055405bdc0b51c04237fc5d"}], "stats": {"total": 982, "additions": 485, "deletions": 497}, "files": [{"sha": "5bce0b790d8418a679f3dbdde2cae95cdc5dcb8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2be868fbade644577895e847ad2fc658cb6d7d5", "patch": "@@ -1,3 +1,44 @@\n+2000-01-15  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.c (this_loop_info): Delete.\n+\t(uid_loop): Add in place of uid_loop_num.  All uses updated.\n+ \t(loop_number_exit_count): Delete and replace with entry in loop\n+\tstructure.  All uses updated.\n+\t(loop_number_loop_starts, loop_number_loop_ends): Likewise.\n+\t(loop_number_loop_cont, loop_number_cont_dominator): Likewise.\n+\t(loop_outer_loop): Likewise.\n+\t(loop_invalid, loop_number_exit_labels): Likewise.\n+\t(loop_used_count_register): Delete and replace with entry in \n+\tloop_info structure.\n+\t(find_and_verify_loops): Add loops argument.\n+\t(verify_dominator, mark_loop_jump, prescan_loop): Replace loop_start,\n+\tloop_end, etc. arguments with loop structure pointer.  All callers\n+\tchanged.\n+\t(loop_reg_used_before_p, scan_loop, strength_reduce): Likewise.\n+\t(check_dbra_loop, next_insn_in_loop, try_copy_prop): Likewise.\n+\t(load_mems_and_recount_loop_regs_set, load_mems): Likewise.\n+\t(insert_bct): Likewise.\n+\t(basic_induction_var): New argument level.\n+\t* loop.h (struct loop_info): Delete fields num, loops_enclosed,\n+\tvtop, and cont.  Add used_count_register.\n+\t(uid_loop): Delete declaration.\n+ \t(loop_number_exit_count): Likewise.\n+\t(loop_number_loop_starts, loop_number_loop_ends): Likewise.\n+\t(loop_number_loop_cont, loop_number_cont_dominator): Likewise.\n+\t(loop_outer_loop, loop_used_count_register): Likewise.\n+\t(loop_invalid, loop_number_exit_labels): Likewise.\n+\t(unroll_loop): Replace loop_start and loop_end arguments\n+ \twith loop structure pointer.\n+\t(loop_precondition_p, loop_iterations): Likewise.\n+\tInclude basic-block.h.\n+\t* unroll.c: (unroll_loop): Replace loop_start and loop_end arguments\n+ \twith loop structure pointer.\n+\t(loop_precondition_p, loop_iterations): Likewise.\n+\t* basic-block.h (struct loop): New entries vtop, cont,\n+ \tcont_dominator, start, end, top, scan_start, exit_labels,\n+\texit_count.  \n+\t* Makefile.in (LOOP_H): Add basic-block.h to dependencies.\n+\n 2000-01-15  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* defaults.h (ASM_OUTPUT_ASCII): Use ISDIGIT."}, {"sha": "0ab31152db40b51d9fe1e9023429555046dc853b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a2be868fbade644577895e847ad2fc658cb6d7d5", "patch": "@@ -756,7 +756,7 @@ RECOG_H = recog.h\n EXPR_H = expr.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H)\n INTEGRATE_H = integrate.h varray.h\n-LOOP_H = loop.h varray.h\n+LOOP_H = loop.h varray.h basic-block.h\n #\f\n # Language makefile fragments.\n "}, {"sha": "912d1efe59769678b70c1dfde33b06a23350bbd3", "filename": "gcc/basic-block.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a2be868fbade644577895e847ad2fc658cb6d7d5", "patch": "@@ -275,6 +275,47 @@ struct loop\n \n   /* Auxiliary info specific to a pass.  */\n   void *info;\n+\n+  /* The following are currently used by loop.c but they are likely to\n+     disappear as loop.c is converted to use the CFG.  */\n+\n+  /* Non-zero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n+  rtx vtop;\n+\n+  /* Non-zero if the loop has a NOTE_INSN_LOOP_CONT.\n+     A continue statement will generate a branch to NEXT_INSN (cont).  */\n+  rtx cont;\n+\n+  /* The dominator of cont.  */\n+  rtx cont_dominator;\n+\n+  /* The NOTE_INSN_LOOP_BEG.  */\n+  rtx start;\n+\n+  /* The NOTE_INSN_LOOP_END.  */\n+  rtx end;\n+\n+  /* For a rotated loop that is entered near the bottom,\n+     this is the label at the top.  Otherwise it is zero.  */\n+  rtx top;\n+\n+  /* Place in the loop where control enters.  */\n+  rtx scan_start;\n+\n+  /* List of all LABEL_REFs which refer to code labels outside the\n+     loop.  Used by routines that need to know all loop exits, such as\n+     final_biv_value and final_giv_value.\n+     \n+     This does not include loop exits due to return instructions.\n+     This is because all bivs and givs are pseudos, and hence must be\n+     dead after a return, so the presense of a return does not affect\n+     any of the optimizations that use this info.  It is simpler to\n+     just not include return instructions on this list.  */\n+  rtx exit_labels;\n+\n+  /* The number of LABEL_REFs on exit_labels for this loop and all\n+     loops nested inside it.  */\n+  int exit_count;\n };\n \n "}, {"sha": "8bddfe01b31000cc33a4b2f080f3d0f557b88953", "filename": "gcc/loop.c", "status": "modified", "additions": 357, "deletions": 440, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a2be868fbade644577895e847ad2fc658cb6d7d5", "patch": "@@ -56,7 +56,7 @@ Boston, MA 02111-1307, USA.  */\n /* Information about the loop being processed used to compute\n    the number of loop iterations for loop unrolling and doloop\n    optimization.  */\n-static struct loop_info this_loop_info;\n+static struct loop_info loop_info_data;\n \n /* Vector mapping INSN_UIDs to luids.\n    The luids are like uids but increase monotonically always.\n@@ -67,7 +67,7 @@ int *uid_luid;\n /* Indexed by INSN_UID, contains the ordinal giving the (innermost) loop\n    number the insn is contained in.  */\n \n-int *uid_loop_num;\n+struct loop **uid_loop;\n \n /* 1 + largest uid of any insn.  */\n \n@@ -82,52 +82,6 @@ static int max_luid;\n \n static int max_loop_num;\n \n-/* Indexed by loop number, contains the first and last insn of each loop.  */\n-\n-static rtx *loop_number_loop_starts, *loop_number_loop_ends;\n-\n-/* Likewise for the continue insn */\n-static rtx *loop_number_loop_cont;\n-\n-/* The first code_label that is reached in every loop iteration.\n-   0 when not computed yet, initially const0_rtx if a jump couldn't be\n-   followed.\n-   Also set to 0 when there is no such label before the NOTE_INSN_LOOP_CONT\n-   of this loop, or in verify_dominator, if a jump couldn't be followed.  */\n-static rtx *loop_number_cont_dominator;\n-\n-/* For each loop, gives the containing loop number, -1 if none.  */\n-\n-int *loop_outer_loop;\n-\n-#ifdef HAVE_decrement_and_branch_on_count\n-/* Records whether resource in use by inner loop.  */\n-\n-int *loop_used_count_register;\n-#endif  /* HAVE_decrement_and_branch_on_count */\n-\n-/* Indexed by loop number, contains a nonzero value if the \"loop\" isn't\n-   really a loop (an insn outside the loop branches into it).  */\n-\n-static char *loop_invalid;\n-\n-/* Indexed by loop number, links together all LABEL_REFs which refer to\n-   code labels outside the loop.  Used by routines that need to know all\n-   loop exits, such as final_biv_value and final_giv_value.\n-\n-   This does not include loop exits due to return instructions.  This is\n-   because all bivs and givs are pseudos, and hence must be dead after a\n-   return, so the presense of a return does not affect any of the\n-   optimizations that use this info.  It is simpler to just not include return\n-   instructions on this list.  */\n-\n-rtx *loop_number_exit_labels;\n-\n-/* Indexed by loop number, counts the number of LABEL_REFs on\n-   loop_number_exit_labels for this loop and all loops nested inside it.  */\n-\n-int *loop_number_exit_count;\n-\n /* Indexed by register number, contains the number of times the reg\n    is set during the loop being scanned.\n    During code motion, a negative value indicates a reg that has been\n@@ -280,10 +234,10 @@ FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n \n-static void verify_dominator PROTO((int));\n-static void find_and_verify_loops PROTO((rtx));\n-static void mark_loop_jump PROTO((rtx, int));\n-static void prescan_loop PROTO((rtx, rtx, struct loop_info *));\n+static void verify_dominator PROTO((struct loop *));\n+static void find_and_verify_loops PROTO((rtx, struct loops *));\n+static void mark_loop_jump PROTO((rtx, struct loop *));\n+static void prescan_loop PROTO((struct loop *));\n static int reg_in_basic_block_p PROTO((rtx, rtx));\n static int consec_sets_invariant_p PROTO((rtx, int, rtx));\n static int labels_in_range_p PROTO((rtx, int));\n@@ -293,8 +247,8 @@ static void count_loop_regs_set PROTO((rtx, rtx, varray_type, varray_type,\n \t\t\t\t       int *, int)); \n static void note_addr_stored PROTO((rtx, rtx, void *));\n static void note_set_pseudo_multiple_uses PROTO((rtx, rtx, void *));\n-static int loop_reg_used_before_p PROTO((rtx, rtx, rtx, rtx, rtx));\n-static void scan_loop PROTO((rtx, rtx, rtx, int, int));\n+static int loop_reg_used_before_p PROTO((const struct loop *, rtx, rtx));\n+static void scan_loop PROTO((struct loop*, int, int));\n #if 0\n static void replace_call_address PROTO((rtx, rtx, rtx));\n #endif\n@@ -308,8 +262,7 @@ static int rtx_equal_for_loop_p PROTO((rtx, rtx, struct movable *));\n static void add_label_notes PROTO((rtx, rtx));\n static void move_movables PROTO((struct movable *, int, int, rtx, rtx, int));\n static int count_nonfixed_reads PROTO((rtx));\n-static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, \n-\t\t\t\t   struct loop_info *, rtx, int, int));\n+static void strength_reduce PROTO((struct loop *, int, int, int));\n static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, int, rtx, rtx));\n@@ -318,11 +271,11 @@ static void check_final_value PROTO((struct induction *, rtx, rtx,\n \t\t\t\t     unsigned HOST_WIDE_INT));\n static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, int, rtx *, rtx, rtx));\n static void update_giv_derive PROTO((rtx));\n-static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *, rtx **, int *));\n+static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, int, rtx *, rtx *, rtx **, int *));\n static rtx simplify_giv_expr PROTO((rtx, int *));\n static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n-static int check_dbra_loop PROTO((rtx, int, rtx, struct loop_info *));\n+static int check_dbra_loop PROTO((struct loop *, int));\n static rtx express_from_1 PROTO((rtx, rtx, rtx));\n static rtx combine_givs_p PROTO((struct induction *, struct induction *));\n static void combine_givs PROTO((struct iv_class *));\n@@ -335,15 +288,15 @@ static int maybe_eliminate_biv_1 PROTO((rtx, rtx, struct iv_class *, int, rtx));\n static int last_use_this_basic_block PROTO((rtx, rtx));\n static void record_initial PROTO((rtx, rtx, void *));\n static void update_reg_last_use PROTO((rtx, rtx));\n-static rtx next_insn_in_loop PROTO((rtx, rtx, rtx, rtx));\n-static void load_mems_and_recount_loop_regs_set PROTO((rtx, rtx, rtx,\n-\t\t\t\t\t\t       rtx, int *));\n-static void load_mems PROTO((rtx, rtx, rtx, rtx));\n+static rtx next_insn_in_loop PROTO((const struct loop *, rtx));\n+static void load_mems_and_recount_loop_regs_set PROTO((const struct loop*,\n+\t\t\t\t\t\t       int *));\n+static void load_mems PROTO((const struct loop *));\n static int insert_loop_mem PROTO((rtx *, void *));\n static int replace_loop_mem PROTO((rtx *, void *));\n static int replace_loop_reg PROTO((rtx *, void *));\n static void note_reg_stored PROTO((rtx, rtx, void *));\n-static void try_copy_prop PROTO((rtx, rtx, rtx, rtx, int));\n+static void try_copy_prop PROTO((const struct loop *, rtx, int));\n static int replace_label PROTO((rtx *, void *));\n \n typedef struct rtx_and_int {\n@@ -364,7 +317,7 @@ typedef struct rtx_pair {\n \n #ifdef HAVE_decrement_and_branch_on_count\n /* Test whether BCT applicable and safe.  */\n-static void insert_bct PROTO((rtx, rtx, struct loop_info *));\n+static void insert_bct PROTO((struct loop *));\n \n /* Auxiliary function that inserts the BCT pattern into the loop.  */\n static void instrument_loop_bct PROTO((rtx, rtx, rtx));\n@@ -464,6 +417,8 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n {\n   register rtx insn;\n   register int i;\n+  struct loops loops_data;\n+  struct loops *loops = &loops_data;\n \n   loop_dump_stream = dumpfile;\n \n@@ -488,34 +443,21 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   if (max_loop_num == 0)\n     return;\n \n+  loops->num = max_loop_num;\n+\n   moved_once = (char *) xcalloc (max_reg_before_loop, sizeof (char));\n \n   /* Get size to use for tables indexed by uids.\n      Leave some space for labels allocated by find_and_verify_loops.  */\n   max_uid_for_loop = get_max_uid () + 1 + max_loop_num * 32;\n \n   uid_luid = (int *) xcalloc (max_uid_for_loop, sizeof (int));\n-  uid_loop_num = (int *) xcalloc (max_uid_for_loop, sizeof (int));\n-\n-  /* Allocate tables for recording each loop.  We set each entry, so they need\n-     not be zeroed.  */\n-  loop_number_loop_starts = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n-  loop_number_loop_ends = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n-  loop_number_loop_cont = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n-  loop_number_cont_dominator = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n-  loop_outer_loop = (int *) xmalloc (max_loop_num * sizeof (int));\n-  loop_invalid = (char *) xmalloc (max_loop_num * sizeof (char));\n-  loop_number_exit_labels = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n-  loop_number_exit_count = (int *) xmalloc (max_loop_num * sizeof (int));\n-\n-#ifdef HAVE_decrement_and_branch_on_count\n-  /* Allocate for BCT optimization */\n-  loop_used_count_register = (int *) xcalloc (max_loop_num, sizeof (int));\n-#endif  /* HAVE_decrement_and_branch_on_count */\n+  uid_loop = (struct loop **) xcalloc (max_uid_for_loop, \n+\t\t\t\t       sizeof (struct loop *));\n \n   /* Find and process each loop.\n      First, find them, and record them in order of their beginnings.  */\n-  find_and_verify_loops (f);\n+  find_and_verify_loops (f, loops);\n \n   /* Now find all register lifetimes.  This must be done after\n      find_and_verify_loops, because it might reorder the insns in the\n@@ -536,8 +478,9 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   /* Now reset it to the actual size we need.  See above.  */\n   max_uid_for_loop = get_max_uid ();\n \n-  /* find_and_verify_loops has already called compute_luids, but it might\n-     have rearranged code afterwards, so we need to recompute the luids now.  */\n+  /* find_and_verify_loops has already called compute_luids, but it\n+     might have rearranged code afterwards, so we need to recompute\n+     the luids now.  */\n   max_luid = compute_luids (f, NULL_RTX, 0);\n \n   /* Don't leave gaps in uid_luid for insns that have been\n@@ -569,10 +512,13 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n \n   /* Now scan the loops, last ones first, since this means inner ones are done\n      before outer ones.  */\n-  for (i = max_loop_num-1; i >= 0; i--)\n-    if (! loop_invalid[i] && loop_number_loop_ends[i])\n-      scan_loop (loop_number_loop_starts[i], loop_number_loop_ends[i],\n-\t\t loop_number_loop_cont[i], unroll_p, bct_p);\n+  for (i = max_loop_num - 1; i >= 0; i--)\n+    {\n+      struct loop *loop = &loops->array[i];\n+\n+      if (! loop->invalid && loop->end)\n+\tscan_loop (loop, unroll_p, bct_p);\n+    }\n \n   /* Replicate the BLOCKs.  */\n   if (write_symbols != NO_DEBUG)\n@@ -583,19 +529,7 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   /* Clean up.  */\n   free (moved_once);\n   free (uid_luid);\n-  free (uid_loop_num);\n-  free (loop_number_loop_starts);\n-  free (loop_number_loop_ends);\n-  free (loop_number_loop_cont);\n-  free (loop_number_cont_dominator);\n-  free (loop_outer_loop);\n-  free (loop_invalid);\n-  free (loop_number_exit_labels);\n-  free (loop_number_exit_count);\n-#ifdef HAVE_decrement_and_branch_on_count\n-  free (loop_used_count_register);\n-#endif  /* HAVE_decrement_and_branch_on_count */\n-\n+  free (uid_loop);\n }\n \f\n /* Returns the next insn, in execution order, after INSN.  START and\n@@ -605,35 +539,30 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n    bottom.  */\n \n static rtx\n-next_insn_in_loop (insn, start, end, loop_top)\n+next_insn_in_loop (loop, insn)\n+     const struct loop *loop;\n      rtx insn;\n-     rtx start;\n-     rtx end;\n-     rtx loop_top;\n {\n   insn = NEXT_INSN (insn);\n \n-  if (insn == end)\n+  if (insn == loop->end)\n     {\n-      if (loop_top)\n+      if (loop->top)\n \t/* Go to the top of the loop, and continue there.  */\n-\tinsn = loop_top;\n+\tinsn = loop->top;\n       else\n \t/* We're done.  */\n \tinsn = NULL_RTX;\n     }\n \n-  if (insn == start)\n+  if (insn == loop->scan_start)\n     /* We're done.  */\n     insn = NULL_RTX;\n \n   return insn;\n }\n \n-/* Optimize one loop whose start is LOOP_START and end is END.\n-   LOOP_START is the NOTE_INSN_LOOP_BEG and END is the matching\n-   NOTE_INSN_LOOP_END.\n-   LOOP_CONT is the NOTE_INSN_LOOP_CONT.  */\n+/* Optimize one loop described by LOOP.  */\n \n /* ??? Could also move memory writes out of loops if the destination address\n    is invariant, the source is invariant, the memory write is not volatile,\n@@ -642,24 +571,21 @@ next_insn_in_loop (insn, start, end, loop_top)\n    write, then we can also mark the memory read as invariant.  */\n \n static void\n-scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n-     rtx loop_start, end, loop_cont;\n+scan_loop (loop, unroll_p, bct_p)\n+     struct loop *loop;\n      int unroll_p, bct_p;\n {\n   register int i;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n   rtx p;\n   /* 1 if we are scanning insns that could be executed zero times.  */\n   int maybe_never = 0;\n   /* 1 if we are scanning insns that might never be executed\n      due to a subroutine call which might exit before they are reached.  */\n   int call_passed = 0;\n-  /* For a rotated loop that is entered near the bottom,\n-     this is the label at the top.  Otherwise it is zero.  */\n-  rtx loop_top = 0;\n   /* Jump insn that enters the loop, or 0 if control drops in.  */\n   rtx loop_entry_jump = 0;\n-  /* Place in the loop where control enters.  */\n-  rtx scan_start;\n   /* Number of insns in the loop.  */\n   int insn_count;\n   int in_libcall = 0;\n@@ -679,7 +605,10 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n   int nregs;\n-  struct loop_info *loop_info = &this_loop_info;\n+  struct loop_info *loop_info = &loop_info_data;\n+\n+  loop->info = loop_info;\n+  loop->top = 0;\n \n   /* Determine whether this loop starts with a jump down to a test at\n      the end.  This will occur for a small number of loops with a test\n@@ -698,24 +627,24 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n      exit test, the code here to detect that case is very conservative.  */\n \n   for (p = NEXT_INSN (loop_start);\n-       p != end\n+       p != loop_end\n \t && GET_CODE (p) != CODE_LABEL && GET_RTX_CLASS (GET_CODE (p)) != 'i'\n \t && (GET_CODE (p) != NOTE\n \t     || (NOTE_LINE_NUMBER (p) != NOTE_INSN_LOOP_BEG\n \t\t && NOTE_LINE_NUMBER (p) != NOTE_INSN_LOOP_END));\n        p = NEXT_INSN (p))\n     ;\n \n-  scan_start = p;\n+  loop->scan_start = p;\n \n   /* Set up variables describing this loop.  */\n-  prescan_loop (loop_start, end, loop_info);\n+  prescan_loop (loop);\n   threshold = (loop_info->has_call ? 1 : 2) * (1 + n_non_fixed_regs);\n \n   /* If loop has a jump before the first label,\n      the true entry is the target of that jump.\n      Start scan from there.\n-     But record in LOOP_TOP the place where the end-test jumps\n+     But record in LOOP->TOP the place where the end-test jumps\n      back to so we can scan that after the end of the loop.  */\n   if (GET_CODE (p) == JUMP_INSN)\n     {\n@@ -730,27 +659,27 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t     do {..} while (0).  If this label was generated previously\n \t     by loop, we can't tell anything about it and have to reject\n \t     the loop.  */\n-\t  && INSN_IN_RANGE_P (JUMP_LABEL (p), loop_start, end))\n+\t  && INSN_IN_RANGE_P (JUMP_LABEL (p), loop_start, loop_end))\n \t{\n-\t  loop_top = next_label (scan_start);\n-\t  scan_start = JUMP_LABEL (p);\n+\t  loop->top = next_label (loop->scan_start);\n+\t  loop->scan_start = JUMP_LABEL (p);\n \t}\n     }\n \n-  /* If SCAN_START was an insn created by loop, we don't know its luid\n+  /* If LOOP->SCAN_START was an insn created by loop, we don't know its luid\n      as required by loop_reg_used_before_p.  So skip such loops.  (This\n      test may never be true, but it's best to play it safe.) \n \n      Also, skip loops where we do not start scanning at a label.  This\n      test also rejects loops starting with a JUMP_INSN that failed the\n      test above.  */\n \n-  if (INSN_UID (scan_start) >= max_uid_for_loop\n-      || GET_CODE (scan_start) != CODE_LABEL)\n+  if (INSN_UID (loop->scan_start) >= max_uid_for_loop\n+      || GET_CODE (loop->scan_start) != CODE_LABEL)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"\\nLoop from %d to %d is phony.\\n\\n\",\n-\t\t INSN_UID (loop_start), INSN_UID (end));\n+\t\t INSN_UID (loop_start), INSN_UID (loop_end));\n       return;\n     }\n \n@@ -769,7 +698,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   VARRAY_CHAR_INIT (may_not_optimize, nregs, \"may_not_optimize\");\n   VARRAY_RTX_INIT (reg_single_usage, nregs, \"reg_single_usage\");\n \n-  count_loop_regs_set (loop_top ? loop_top : loop_start, end,\n+  count_loop_regs_set (loop->top ? loop->top : loop->start, loop->end,\n \t\t       may_not_optimize, reg_single_usage, &insn_count, nregs);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -792,10 +721,10 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   if (loop_dump_stream)\n     {\n       fprintf (loop_dump_stream, \"\\nLoop from %d to %d: %d real insns.\\n\",\n-\t       INSN_UID (loop_start), INSN_UID (end), insn_count);\n-      if (loop_info->cont)\n+\t       INSN_UID (loop_start), INSN_UID (loop_end), insn_count);\n+      if (loop->cont)\n \tfprintf (loop_dump_stream, \"Continue at insn %d.\\n\",\n-\t\t INSN_UID (loop_info->cont));\n+\t\t INSN_UID (loop->cont));\n     }\n \n   /* Scan through the loop finding insns that are safe to move.\n@@ -811,9 +740,9 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n      When MAYBE_NEVER is 0, all insns will be executed at least once\n      so that is not a problem.  */\n \n-  for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top); \n+  for (p = next_insn_in_loop (loop, loop->scan_start); \n        p != NULL_RTX;\n-       p = next_insn_in_loop (p, scan_start, end, loop_top))\n+       p = next_insn_in_loop (loop, p))\n     {\n       if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n \t  && find_reg_note (p, REG_LIBCALL, NULL_RTX))\n@@ -879,8 +808,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t\t      each time for register usage, we should build tables\n \t\t      of the register usage and use them here instead.  */\n \t\t   && (maybe_never\n-\t\t       || loop_reg_used_before_p (set, p, loop_start,\n-\t\t\t\t\t\t  scan_start, end)))\n+\t\t       || loop_reg_used_before_p (loop, set, p)))\n \t    /* It is unsafe to move the set.  \n \n \t       This code used to consider it OK to move a set of a variable\n@@ -980,7 +908,8 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t      /* Set M->cond if either invariant_p or consec_sets_invariant_p\n \t\t returned 2 (only conditionally invariant).  */\n \t      m->cond = ((tem | tem1 | tem2) > 1);\n-\t      m->global = (uid_luid[REGNO_LAST_UID (regno)] > INSN_LUID (end)\n+\t      m->global = (uid_luid[REGNO_LAST_UID (regno)] \n+\t\t\t   > INSN_LUID (loop_end)\n \t\t\t   || uid_luid[REGNO_FIRST_UID (regno)] < INSN_LUID (loop_start));\n \t      m->match = 0;\n \t      m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n@@ -1082,7 +1011,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t\t     assumption.  */\n \t\t  m->global = (INSN_UID (p) >= max_uid_for_loop\n \t\t\t       || (uid_luid[REGNO_LAST_UID (regno)]\n-\t\t\t\t   > INSN_LUID (end))\n+\t\t\t\t   > INSN_LUID (loop_end))\n \t\t\t       || (uid_luid[REGNO_FIRST_UID (regno)]\n \t\t\t\t   < INSN_LUID (p))\n \t\t\t       || (labels_in_range_p\n@@ -1125,8 +1054,8 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t\t  unconditional jump, otherwise the code at the top of the\n \t\t  loop might never be executed.  Unconditional jumps are\n \t\t  followed a by barrier then loop end.  */\n-               && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop_top\n-\t\t     && NEXT_INSN (NEXT_INSN (p)) == end\n+               && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop->top\n+\t\t     && NEXT_INSN (NEXT_INSN (p)) == loop_end\n \t\t     && simplejump_p (p)))\n \tmaybe_never = 1;\n       else if (GET_CODE (p) == NOTE)\n@@ -1169,7 +1098,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \n   if (! optimize_size)\n     move_movables (movables, threshold,\n-\t\t   insn_count, loop_start, end, nregs);\n+\t\t   insn_count, loop_start, loop_end, nregs);\n \n   /* Now candidates that still are negative are those not moved.\n      Change set_in_loop to indicate that those are not actually invariant.  */\n@@ -1179,24 +1108,21 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \n   /* Now that we've moved some things out of the loop, we might be able to\n      hoist even more memory references.  */\n-  load_mems_and_recount_loop_regs_set (scan_start, end, loop_top,\n-\t\t\t\t       loop_start, &insn_count);\n+  load_mems_and_recount_loop_regs_set (loop, &insn_count);\n \n   for (update_start = loop_start;\n        PREV_INSN (update_start) && GET_CODE (PREV_INSN (update_start)) != CODE_LABEL;\n        update_start = PREV_INSN (update_start))\n     ;\n-  update_end = NEXT_INSN (end);\n+  update_end = NEXT_INSN (loop_end);\n \n   reg_scan_update (update_start, update_end, loop_max_reg);\n   loop_max_reg = max_reg_num ();\n \n   if (flag_strength_reduce)\n     {\n       the_movables = movables;\n-      strength_reduce (scan_start, end, loop_top,\n-\t\t       insn_count, loop_start, end,\n-\t\t       loop_info, loop_cont, unroll_p, bct_p);\n+      strength_reduce (loop, insn_count, unroll_p, bct_p);\n \n       reg_scan_update (update_start, update_end, loop_max_reg);\n       loop_max_reg = max_reg_num ();\n@@ -2434,27 +2360,28 @@ constant_high_bytes (p, loop_start)\n    in the array `loop_mems' and the list `loop_store_mems'.  */\n \n static void\n-prescan_loop (start, end, loop_info)\n-     rtx start, end;\n-     struct loop_info *loop_info;\n+prescan_loop (loop)\n+     struct loop *loop;\n {\n   register int level = 1;\n   rtx insn;\n+  struct loop_info *loop_info = loop->info;\n+  rtx start = loop->start;\n+  rtx end = loop->end;\n   /* The label after END.  Jumping here is just like falling off the\n      end of the loop.  We use next_nonnote_insn instead of next_label\n      as a hedge against the (pathological) case where some actual insn\n      might end up between the two.  */\n   rtx exit_target = next_nonnote_insn (end);\n \n-  loop_info->num = uid_loop_num [INSN_UID (start)];\n   loop_info->has_indirect_jump = indirect_jump_in_function;\n   loop_info->has_call = 0;\n   loop_info->has_volatile = 0;\n   loop_info->has_tablejump = 0;\n-  loop_info->loops_enclosed = 1;\n   loop_info->has_multiple_exit_targets = 0;\n-  loop_info->cont = 0;\n-  loop_info->vtop = 0;\n+  loop->cont = 0;\n+  loop->vtop = 0;\n+  loop->level = 1;\n \n   unknown_address_altered = 0;\n   unknown_constant_address_altered = 0;\n@@ -2472,7 +2399,7 @@ prescan_loop (start, end, loop_info)\n \t    {\n \t      ++level;\n \t      /* Count number of loops contained in this one.  */\n-\t      loop_info->loops_enclosed++;\n+\t      loop->level++;\n \t    }\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \t    {\n@@ -2486,7 +2413,7 @@ prescan_loop (start, end, loop_info)\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT)\n \t    {\n \t      if (level == 1)\n-\t\tloop_info->cont = insn;\n+\t\tloop->cont = insn;\n \t    }\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP)\n \t    {\n@@ -2495,7 +2422,7 @@ prescan_loop (start, end, loop_info)\n \t\t start.  Thus, we can assume that the loop condition\n \t\t was true when the loop was entered.  */\n \t      if (level == 1)\n-\t\tloop_info->vtop = insn;\n+\t\tloop->vtop = insn;\n \t    }\n \t}\n       else if (GET_CODE (insn) == CALL_INSN)\n@@ -2565,48 +2492,47 @@ prescan_loop (start, end, loop_info)\n \n   /* Now, rescan the loop, setting up the LOOP_MEMS array.  */\n   if (/* We can't tell what MEMs are aliased by what.  */\n-      !unknown_address_altered \n+      ! unknown_address_altered \n       /* An exception thrown by a called function might land us\n \t anywhere.  */\n-      && !loop_info->has_call\n+      && ! loop_info->has_call\n       /* We don't want loads for MEMs moved to a location before the\n \t one at which their stack memory becomes allocated.  (Note\n \t that this is not a problem for malloc, etc., since those\n \t require actual function calls.  */\n-      && !current_function_calls_alloca\n+      && ! current_function_calls_alloca\n       /* There are ways to leave the loop other than falling off the\n \t end.  */\n-      && !loop_info->has_multiple_exit_targets)\n+      && ! loop_info->has_multiple_exit_targets)\n     for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n \t insn = NEXT_INSN (insn))\n       for_each_rtx (&insn, insert_loop_mem, 0);\n }\n \f\n-/* LOOP_NUMBER_CONT_DOMINATOR is now the last label between the loop start\n+/* LOOP->CONT_DOMINATOR is now the last label between the loop start\n    and the continue note that is a the destination of a (cond)jump after\n    the continue note.  If there is any (cond)jump between the loop start\n-   and what we have so far as LOOP_NUMBER_CONT_DOMINATOR that has a\n-   target between LOOP_DOMINATOR and the continue note, move\n-   LOOP_NUMBER_CONT_DOMINATOR forward to that label; if a jump's\n-   destination cannot be determined, clear LOOP_NUMBER_CONT_DOMINATOR.  */\n+   and what we have so far as LOOP->CONT_DOMINATOR that has a\n+   target between LOOP->DOMINATOR and the continue note, move\n+   LOOP->CONT_DOMINATOR forward to that label; if a jump's\n+   destination cannot be determined, clear LOOP->CONT_DOMINATOR.  */\n \n static void\n-verify_dominator (loop_number)\n-     int loop_number;\n+verify_dominator (loop)\n+     struct loop *loop;\n {\n   rtx insn;\n \n-  if (! loop_number_cont_dominator[loop_number])\n+  if (! loop->cont_dominator)\n     /* This can happen for an empty loop, e.g. in\n        gcc.c-torture/compile/920410-2.c  */\n     return;\n-  if (loop_number_cont_dominator[loop_number] == const0_rtx)\n+  if (loop->cont_dominator == const0_rtx)\n     {\n-      loop_number_cont_dominator[loop_number] = 0;\n+      loop->cont_dominator = 0;\n       return;\n     }\n-  for (insn = loop_number_loop_starts[loop_number];\n-       insn != loop_number_cont_dominator[loop_number];\n+  for (insn = loop->start; insn != loop->cont_dominator;\n        insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == JUMP_INSN\n@@ -2618,20 +2544,20 @@ verify_dominator (loop_number)\n \t  /* If it is not a jump we can easily understand or for\n \t     which we do not have jump target information in the JUMP_LABEL\n \t     field (consider ADDR_VEC and ADDR_DIFF_VEC insns), then clear\n-\t     LOOP_NUMBER_CONT_DOMINATOR.  */\n+\t     LOOP->CONT_DOMINATOR.  */\n \t  if ((! condjump_p (insn)\n \t       && ! condjump_in_parallel_p (insn))\n \t      || label == NULL_RTX)\n \t    {\n-\t      loop_number_cont_dominator[loop_number] = NULL_RTX;\n+\t      loop->cont_dominator = NULL_RTX;\n \t      return;\n \t    }\n \n \t  label_luid = INSN_LUID (label);\n-\t  if (label_luid < INSN_LUID (loop_number_loop_cont[loop_number])\n+\t  if (label_luid < INSN_LUID (loop->cont)\n \t      && (label_luid\n-\t\t  > INSN_LUID (loop_number_cont_dominator[loop_number])))\n-\t    loop_number_cont_dominator[loop_number] = label;\n+\t\t  > INSN_LUID (loop->cont)))\n+\t    loop->cont_dominator = label;\n \t}\n     }\n }\n@@ -2641,141 +2567,140 @@ verify_dominator (loop_number)\n    to from outside the loop.  */\n \n static void\n-find_and_verify_loops (f)\n+find_and_verify_loops (f, loops)\n      rtx f;\n+     struct loops *loops;\n {\n-  rtx insn, label;\n-  int current_loop = -1;\n-  int next_loop = -1;\n-  int loop;\n+  rtx insn;\n+  rtx label;\n+  int num_loops;\n+  struct loop *current_loop;\n+  struct loop *next_loop;\n+  struct loop *loop;\n+\n+  num_loops = loops->num;\n \n   compute_luids (f, NULL_RTX, 0);\n \n   /* If there are jumps to undefined labels,\n      treat them as jumps out of any/all loops.\n      This also avoids writing past end of tables when there are no loops.  */\n-  uid_loop_num[0] = -1;\n+  uid_loop[0] = NULL;\n \n+  loops->array = (struct loop *)\n+    xmalloc (num_loops * sizeof (struct loop));\n+  bzero ((char *)loops->array, num_loops * sizeof (struct loop));\n+      \n   /* Find boundaries of loops, mark which loops are contained within\n      loops, and invalidate loops that have setjmp.  */\n \n+  num_loops = 0;\n+  current_loop = NULL;\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE)\n \tswitch (NOTE_LINE_NUMBER (insn))\n \t  {\n \t  case NOTE_INSN_LOOP_BEG:\n-\t    loop_number_loop_starts[++next_loop] =  insn;\n-\t    loop_number_loop_ends[next_loop] = 0;\n-\t    loop_number_loop_cont[next_loop] = 0;\n-\t    loop_number_cont_dominator[next_loop] = 0;\n-\t    loop_outer_loop[next_loop] = current_loop;\n-\t    loop_invalid[next_loop] = 0;\n-\t    loop_number_exit_labels[next_loop] = 0;\n-\t    loop_number_exit_count[next_loop] = 0;\n+\t    next_loop = loops->array + num_loops;\n+\t    next_loop->num = num_loops;\n+\t    num_loops++;\n+\t    next_loop->start = insn;\n+\t    next_loop->outer = current_loop;\n \t    current_loop = next_loop;\n \t    break;\n \n \t  case NOTE_INSN_SETJMP:\n \t    /* In this case, we must invalidate our current loop and any\n \t       enclosing loop.  */\n-\t    for (loop = current_loop; loop != -1; loop = loop_outer_loop[loop])\n+\t    for (loop = current_loop; loop; loop = loop->outer)\n \t      {\n-\t\tloop_invalid[loop] = 1;\n+\t\tloop->invalid = 1;\n \t\tif (loop_dump_stream)\n \t\t  fprintf (loop_dump_stream,\n \t\t\t   \"\\nLoop at %d ignored due to setjmp.\\n\",\n-\t\t\t   INSN_UID (loop_number_loop_starts[loop]));\n+\t\t\t   INSN_UID (loop->start));\n \t      }\n \t    break;\n \n \t  case NOTE_INSN_LOOP_CONT:\n-\t    loop_number_loop_cont[current_loop] = insn;\n+\t    current_loop->cont = insn;\n \t    break;\n \t  case NOTE_INSN_LOOP_END:\n-\t    if (current_loop == -1)\n+\t    if (! current_loop)\n \t      abort ();\n \n-\t    loop_number_loop_ends[current_loop] = insn;\n+\t    current_loop->end = insn;\n \t    verify_dominator (current_loop);\n-\t    current_loop = loop_outer_loop[current_loop];\n+\t    current_loop = current_loop->outer;\n \t    break;\n \n \t  default:\n \t    break;\n \t  }\n       /* If for any loop, this is a jump insn between the NOTE_INSN_LOOP_CONT\n-\t and NOTE_INSN_LOOP_END notes, update loop_number_loop_dominator.  */\n+\t and NOTE_INSN_LOOP_END notes, update loop->dominator.  */\n       else if (GET_CODE (insn) == JUMP_INSN\n \t       && GET_CODE (PATTERN (insn)) != RETURN\n-\t       && current_loop >= 0)\n+\t       && current_loop)\n \t{\n-\t  int this_loop_num;\n \t  rtx label = JUMP_LABEL (insn);\n \n \t  if (! condjump_p (insn) && ! condjump_in_parallel_p (insn))\n \t    label = NULL_RTX;\n \n-\t  this_loop_num = current_loop;\n+\t  loop = current_loop;\n \t  do\n \t    {\n \t      /* First see if we care about this loop.  */\n-\t      if (loop_number_loop_cont[this_loop_num]\n-\t\t  && loop_number_cont_dominator[this_loop_num] != const0_rtx)\n+\t      if (loop->cont && loop->cont_dominator != const0_rtx)\n \t\t{\n \t\t  /* If the jump destination is not known, invalidate\n-\t\t     loop_number_const_dominator.  */\n+\t\t     loop->const_dominator.  */\n \t\t  if (! label)\n-\t\t    loop_number_cont_dominator[this_loop_num] = const0_rtx;\n+\t\t    loop->cont_dominator = const0_rtx;\n \t\t  else\n \t\t    /* Check if the destination is between loop start and\n \t\t       cont.  */\n \t\t    if ((INSN_LUID (label)\n-\t\t\t < INSN_LUID (loop_number_loop_cont[this_loop_num]))\n+\t\t\t < INSN_LUID (loop->cont))\n \t\t\t&& (INSN_LUID (label)\n-\t\t\t    > INSN_LUID (loop_number_loop_starts[this_loop_num]))\n+\t\t\t    > INSN_LUID (loop->start))\n \t\t\t/* And if there is no later destination already\n \t\t\t   recorded.  */\n-\t\t\t&& (! loop_number_cont_dominator[this_loop_num]\n+\t\t\t&& (! loop->cont_dominator\n \t\t\t    || (INSN_LUID (label)\n-\t\t\t\t> INSN_LUID (loop_number_cont_dominator\n-\t\t\t\t\t     [this_loop_num]))))\n-\t\t      loop_number_cont_dominator[this_loop_num] = label;\n+\t\t\t\t> INSN_LUID (loop->cont_dominator))))\n+\t\t      loop->cont_dominator = label;\n \t\t}\n-\t      this_loop_num = loop_outer_loop[this_loop_num];\n+\t      loop = loop->outer;\n \t    }\n-\t  while (this_loop_num >= 0);\n+\t  while (loop);\n \t}\n \n       /* Note that this will mark the NOTE_INSN_LOOP_END note as being in the\n \t enclosing loop, but this doesn't matter.  */\n-      uid_loop_num[INSN_UID (insn)] = current_loop;\n+      uid_loop[INSN_UID (insn)] = current_loop;\n     }\n \n   /* Any loop containing a label used in an initializer must be invalidated,\n      because it can be jumped into from anywhere.  */\n \n   for (label = forced_labels; label; label = XEXP (label, 1))\n     {\n-      int loop_num;\n-\n-      for (loop_num = uid_loop_num[INSN_UID (XEXP (label, 0))];\n-\t   loop_num != -1;\n-\t   loop_num = loop_outer_loop[loop_num])\n-\tloop_invalid[loop_num] = 1;\n+      for (loop = uid_loop[INSN_UID (XEXP (label, 0))];\n+\t   loop; loop = loop->outer)\n+\tloop->invalid = 1;\n     }\n \n   /* Any loop containing a label used for an exception handler must be\n      invalidated, because it can be jumped into from anywhere.  */\n \n   for (label = exception_handler_labels; label; label = XEXP (label, 1))\n     {\n-      int loop_num;\n-\n-      for (loop_num = uid_loop_num[INSN_UID (XEXP (label, 0))];\n-\t   loop_num != -1;\n-\t   loop_num = loop_outer_loop[loop_num])\n-\tloop_invalid[loop_num] = 1;\n+      for (loop = uid_loop[INSN_UID (XEXP (label, 0))];\n+\t   loop; loop = loop->outer)\n+\tloop->invalid = 1;\n     }\n \n   /* Now scan all insn's in the function.  If any JUMP_INSN branches into a\n@@ -2794,40 +2719,37 @@ find_and_verify_loops (f)\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n       {\n-\tint this_loop_num = uid_loop_num[INSN_UID (insn)];\n+\tstruct loop *this_loop = uid_loop[INSN_UID (insn)];\n \n \tif (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n \t  {\n \t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n \t    if (note)\n \t      {\n-\t\tint loop_num;\n-\n-\t\tfor (loop_num = uid_loop_num[INSN_UID (XEXP (note, 0))];\n-\t\t     loop_num != -1;\n-\t\t     loop_num = loop_outer_loop[loop_num])\n-\t\t  loop_invalid[loop_num] = 1;\n+\t\tfor (loop = uid_loop[INSN_UID (XEXP (note, 0))];\n+\t\t     loop; loop = loop->outer)\n+\t\t  loop->invalid = 1;\n \t      }\n \t  }\n \n \tif (GET_CODE (insn) != JUMP_INSN)\n \t  continue;\n \n-\tmark_loop_jump (PATTERN (insn), this_loop_num);\n+\tmark_loop_jump (PATTERN (insn), this_loop);\n \n \t/* See if this is an unconditional branch outside the loop.  */\n-\tif (this_loop_num != -1\n+\tif (this_loop\n \t    && (GET_CODE (PATTERN (insn)) == RETURN\n \t\t|| (simplejump_p (insn)\n-\t\t    && (uid_loop_num[INSN_UID (JUMP_LABEL (insn))]\n-\t\t\t!= this_loop_num)))\n+\t\t    && (uid_loop[INSN_UID (JUMP_LABEL (insn))]\n+\t\t\t!= this_loop)))\n \t    && get_max_uid () < max_uid_for_loop)\n \t  {\n \t    rtx p;\n \t    rtx our_next = next_real_insn (insn);\n \t    rtx last_insn_to_move = NEXT_INSN (insn);\n-\t    int dest_loop;\n-\t    int outer_loop = -1;\n+\t    struct loop *dest_loop;\n+\t    struct loop *outer_loop = NULL;\n \n \t    /* Go backwards until we reach the start of the loop, a label,\n \t       or a JUMP_INSN.  */\n@@ -2844,21 +2766,21 @@ find_and_verify_loops (f)\n \n \t    if (JUMP_LABEL (insn))\n \t      {\n-\t\tdest_loop = uid_loop_num[INSN_UID (JUMP_LABEL (insn))];\n-\t\tif (dest_loop != -1)\n+\t\tdest_loop = uid_loop[INSN_UID (JUMP_LABEL (insn))];\n+\t\tif (dest_loop)\n \t\t  {\n-\t\t    for (outer_loop = dest_loop; outer_loop != -1;\n-\t\t\t outer_loop = loop_outer_loop[outer_loop])\n-\t\t      if (outer_loop == this_loop_num)\n+\t\t    for (outer_loop = dest_loop; outer_loop;\n+\t\t\t outer_loop = outer_loop->outer)\n+\t\t      if (outer_loop == this_loop)\n \t\t\tbreak;\n \t\t  }\n \t      }\n \n \t    /* Make sure that the target of P is within the current loop.  */\n \n \t    if (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p)\n-\t\t&& uid_loop_num[INSN_UID (JUMP_LABEL (p))] != this_loop_num)\n-\t      outer_loop = this_loop_num;\n+\t\t&& uid_loop[INSN_UID (JUMP_LABEL (p))] != this_loop)\n+\t      outer_loop = this_loop;\n \n \t    /* If we stopped on a JUMP_INSN to the next insn after INSN,\n \t       we have a block of code to try to move.\n@@ -2869,7 +2791,7 @@ find_and_verify_loops (f)\n \t       of the block, invert the jump in P and point it to that label,\n \t       and move the block of code to the spot we found.  */\n \n-\t    if (outer_loop == -1\n+\t    if (! outer_loop\n \t\t&& GET_CODE (p) == JUMP_INSN\n \t\t&& JUMP_LABEL (p) != 0\n \t\t/* Just ignore jumps to labels that were never emitted.\n@@ -2885,7 +2807,7 @@ find_and_verify_loops (f)\n \t      {\n \t\trtx target\n \t\t  = JUMP_LABEL (insn) ? JUMP_LABEL (insn) : get_last_insn ();\n-\t\tint target_loop_num = uid_loop_num[INSN_UID (target)];\n+\t\tstruct loop *target_loop = uid_loop[INSN_UID (target)];\n \t\trtx loc, loc2;\n \n \t\tfor (loc = target; loc; loc = PREV_INSN (loc))\n@@ -2897,7 +2819,7 @@ find_and_verify_loops (f)\n \t\t\t  || GET_CODE (loc2) != JUMP_INSN\n \t\t\t  || (GET_CODE (PATTERN (loc2)) != ADDR_VEC\n \t\t\t      && GET_CODE (PATTERN (loc2)) != ADDR_DIFF_VEC))\n-\t\t      && uid_loop_num[INSN_UID (loc)] == target_loop_num)\n+\t\t      && uid_loop[INSN_UID (loc)] == target_loop)\n \t\t    break;\n \n \t\tif (loc == 0)\n@@ -2910,7 +2832,7 @@ find_and_verify_loops (f)\n \t\t\t    || GET_CODE (loc2) != JUMP_INSN\n \t\t\t    || (GET_CODE (PATTERN (loc2)) != ADDR_VEC\n \t\t\t\t&& GET_CODE (PATTERN (loc2)) != ADDR_DIFF_VEC))\n-\t\t\t&& uid_loop_num[INSN_UID (loc)] == target_loop_num)\n+\t\t\t&& uid_loop[INSN_UID (loc)] == target_loop)\n \t\t      break;\n \n \t\tif (loc)\n@@ -2921,7 +2843,7 @@ find_and_verify_loops (f)\n \t\t    /* Ensure our label doesn't go away.  */\n \t\t    LABEL_NUSES (cond_label)++;\n \n-\t\t    /* Verify that uid_loop_num is large enough and that\n+\t\t    /* Verify that uid_loop is large enough and that\n \t\t       we can invert P.  */\n \t\t   if (invert_jump (p, new_label))\n \t\t     {\n@@ -2954,50 +2876,47 @@ find_and_verify_loops (f)\n \t\t\t\t\t\t  last_insn_to_move);\n \t\t       reorder_insns (new_label, last_insn_to_move, loc);\n \n-\t\t       /* All those insns are now in TARGET_LOOP_NUM.  */\n+\t\t       /* All those insns are now in TARGET_LOOP.  */\n \t\t       for (q = new_label; \n \t\t\t    q != NEXT_INSN (last_insn_to_move);\n \t\t\t    q = NEXT_INSN (q))\n-\t\t\t uid_loop_num[INSN_UID (q)] = target_loop_num;\n+\t\t\t uid_loop[INSN_UID (q)] = target_loop;\n \n \t\t       /* The label jumped to by INSN is no longer a loop exit.\n \t\t\t  Unless INSN does not have a label (e.g., it is a\n-\t\t\t  RETURN insn), search loop_number_exit_labels to find\n+\t\t\t  RETURN insn), search loop->exit_labels to find\n \t\t\t  its label_ref, and remove it.  Also turn off\n \t\t\t  LABEL_OUTSIDE_LOOP_P bit.  */\n \t\t       if (JUMP_LABEL (insn))\n \t\t\t {\n-\t\t\t   int loop_num;\n-\n \t\t\t   for (q = 0,\n-\t\t\t\tr = loop_number_exit_labels[this_loop_num];\n+\t\t\t\tr = this_loop->exit_labels;\n \t\t\t\tr; q = r, r = LABEL_NEXTREF (r))\n \t\t\t     if (XEXP (r, 0) == JUMP_LABEL (insn))\n \t\t\t       {\n \t\t\t\t LABEL_OUTSIDE_LOOP_P (r) = 0;\n \t\t\t\t if (q)\n \t\t\t\t   LABEL_NEXTREF (q) = LABEL_NEXTREF (r);\n \t\t\t\t else\n-\t\t\t\t   loop_number_exit_labels[this_loop_num]\n-\t\t\t\t     = LABEL_NEXTREF (r);\n+\t\t\t\t   this_loop->exit_labels = LABEL_NEXTREF (r);\n \t\t\t\t break;\n \t\t\t       }\n \n-\t\t\t   for (loop_num = this_loop_num;\n-\t\t\t\tloop_num != -1 && loop_num != target_loop_num;\n-\t\t\t\tloop_num = loop_outer_loop[loop_num])\n-\t\t\t     loop_number_exit_count[loop_num]--;\n+\t\t\t   for (loop = this_loop; loop && loop != target_loop;\n+\t\t\t\tloop = loop->outer)\n+\t\t\t     loop->exit_count--;\n \n-\t\t\t   /* If we didn't find it, then something is wrong.  */\n+\t\t\t   /* If we didn't find it, then something is\n+                              wrong.  */\n \t\t\t   if (! r)\n \t\t\t     abort ();\n \t\t\t }\n \n \t\t       /* P is now a jump outside the loop, so it must be put\n-\t\t\t  in loop_number_exit_labels, and marked as such.\n+\t\t\t  in loop->exit_labels, and marked as such.\n \t\t\t  The easiest way to do this is to just call\n \t\t\t  mark_loop_jump again for P.  */\n-\t\t       mark_loop_jump (PATTERN (p), this_loop_num);\n+\t\t       mark_loop_jump (PATTERN (p), this_loop);\n \n \t\t       /* If INSN now jumps to the insn after it,\n \t\t\t  delete INSN.  */\n@@ -3030,12 +2949,12 @@ find_and_verify_loops (f)\n    For speed, we assume that X is part of a pattern of a JUMP_INSN.  */\n \n static void\n-mark_loop_jump (x, loop_num)\n+mark_loop_jump (x, loop)\n      rtx x;\n-     int loop_num;\n+     struct loop *loop;\n {\n-  int dest_loop;\n-  int outer_loop;\n+  struct loop *dest_loop;\n+  struct loop *outer_loop;\n   int i;\n \n   switch (GET_CODE (x))\n@@ -3052,28 +2971,28 @@ mark_loop_jump (x, loop_num)\n \n     case CONST:\n       /* There could be a label reference in here.  */\n-      mark_loop_jump (XEXP (x, 0), loop_num);\n+      mark_loop_jump (XEXP (x, 0), loop);\n       return;\n \n     case PLUS:\n     case MINUS:\n     case MULT:\n-      mark_loop_jump (XEXP (x, 0), loop_num);\n-      mark_loop_jump (XEXP (x, 1), loop_num);\n+      mark_loop_jump (XEXP (x, 0), loop);\n+      mark_loop_jump (XEXP (x, 1), loop);\n       return;\n \n     case LO_SUM:\n       /* This may refer to a LABEL_REF or SYMBOL_REF.  */\n-      mark_loop_jump (XEXP (x, 1), loop_num);\n+      mark_loop_jump (XEXP (x, 1), loop);\n       return;\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      mark_loop_jump (XEXP (x, 0), loop_num);\n+      mark_loop_jump (XEXP (x, 0), loop);\n       return;\n \n     case LABEL_REF:\n-      dest_loop = uid_loop_num[INSN_UID (XEXP (x, 0))];\n+      dest_loop = uid_loop[INSN_UID (XEXP (x, 0))];\n \n       /* Link together all labels that branch outside the loop.  This\n \t is used by final_[bg]iv_value and the loop unrolling code.  Also\n@@ -3082,92 +3001,90 @@ mark_loop_jump (x, loop_num)\n \n       /* A check to make sure the label is not in an inner nested loop,\n \t since this does not count as a loop exit.  */\n-      if (dest_loop != -1)\n+      if (dest_loop)\n \t{\n-\t  for (outer_loop = dest_loop; outer_loop != -1;\n-\t       outer_loop = loop_outer_loop[outer_loop])\n-\t    if (outer_loop == loop_num)\n+\t  for (outer_loop = dest_loop; outer_loop;\n+\t       outer_loop = outer_loop->outer)\n+\t    if (outer_loop == loop)\n \t      break;\n \t}\n       else\n-\touter_loop = -1;\n+\touter_loop = NULL;\n \n-      if (loop_num != -1 && outer_loop == -1)\n+      if (loop && ! outer_loop)\n \t{\n \t  LABEL_OUTSIDE_LOOP_P (x) = 1;\n-\t  LABEL_NEXTREF (x) = loop_number_exit_labels[loop_num];\n-\t  loop_number_exit_labels[loop_num] = x;\n+\t  LABEL_NEXTREF (x) = loop->exit_labels;\n+\t  loop->exit_labels = x;\n \n-\t  for (outer_loop = loop_num;\n-\t       outer_loop != -1 && outer_loop != dest_loop;\n-\t       outer_loop = loop_outer_loop[outer_loop])\n-\t    loop_number_exit_count[outer_loop]++;\n+\t  for (outer_loop = loop;\n+\t       outer_loop && outer_loop != dest_loop;\n+\t       outer_loop = outer_loop->outer)\n+\t    outer_loop->exit_count++;\n \t}\n \n       /* If this is inside a loop, but not in the current loop or one enclosed\n \t by it, it invalidates at least one loop.  */\n \n-      if (dest_loop == -1)\n+      if (! dest_loop)\n \treturn;\n \n       /* We must invalidate every nested loop containing the target of this\n \t label, except those that also contain the jump insn.  */\n \n-      for (; dest_loop != -1; dest_loop = loop_outer_loop[dest_loop])\n+      for (; dest_loop; dest_loop = dest_loop->outer)\n \t{\n \t  /* Stop when we reach a loop that also contains the jump insn.  */\n-\t  for (outer_loop = loop_num; outer_loop != -1;\n-\t       outer_loop = loop_outer_loop[outer_loop])\n+\t  for (outer_loop = loop; outer_loop; outer_loop = outer_loop->outer)\n \t    if (dest_loop == outer_loop)\n \t      return;\n \n \t  /* If we get here, we know we need to invalidate a loop.  */\n-\t  if (loop_dump_stream && ! loop_invalid[dest_loop])\n+\t  if (loop_dump_stream && ! dest_loop->invalid)\n \t    fprintf (loop_dump_stream,\n \t\t     \"\\nLoop at %d ignored due to multiple entry points.\\n\",\n-\t\t     INSN_UID (loop_number_loop_starts[dest_loop]));\n+\t\t     INSN_UID (dest_loop->start));\n \t  \n-\t  loop_invalid[dest_loop] = 1;\n+\t  dest_loop->invalid = 1;\n \t}\n       return;\n \n     case SET:\n       /* If this is not setting pc, ignore.  */\n       if (SET_DEST (x) == pc_rtx)\n-\tmark_loop_jump (SET_SRC (x), loop_num);\n+\tmark_loop_jump (SET_SRC (x), loop);\n       return;\n \n     case IF_THEN_ELSE:\n-      mark_loop_jump (XEXP (x, 1), loop_num);\n-      mark_loop_jump (XEXP (x, 2), loop_num);\n+      mark_loop_jump (XEXP (x, 1), loop);\n+      mark_loop_jump (XEXP (x, 2), loop);\n       return;\n \n     case PARALLEL:\n     case ADDR_VEC:\n       for (i = 0; i < XVECLEN (x, 0); i++)\n-\tmark_loop_jump (XVECEXP (x, 0, i), loop_num);\n+\tmark_loop_jump (XVECEXP (x, 0, i), loop);\n       return;\n \n     case ADDR_DIFF_VEC:\n       for (i = 0; i < XVECLEN (x, 1); i++)\n-\tmark_loop_jump (XVECEXP (x, 1, i), loop_num);\n+\tmark_loop_jump (XVECEXP (x, 1, i), loop);\n       return;\n \n     default:\n       /* Strictly speaking this is not a jump into the loop, only a possible\n \t jump out of the loop.  However, we have no way to link the destination\n \t of this jump onto the list of exit labels.  To be safe we mark this\n \t loop and any containing loops as invalid.  */\n-      if (loop_num != -1)\n+      if (loop)\n \t{\n-\t  for (outer_loop = loop_num; outer_loop != -1;\n-\t       outer_loop = loop_outer_loop[outer_loop])\n+\t  for (outer_loop = loop; outer_loop; outer_loop = outer_loop->outer)\n \t    {\n-\t      if (loop_dump_stream && ! loop_invalid[outer_loop])\n+\t      if (loop_dump_stream && ! outer_loop->invalid)\n \t\tfprintf (loop_dump_stream,\n \t\t\t \"\\nLoop at %d ignored due to unknown exit jump.\\n\",\n-\t\t\t INSN_UID (loop_number_loop_starts[outer_loop]));\n-\t      loop_invalid[outer_loop] = 1;\n+\t\t\t INSN_UID (outer_loop->start));\n+\t      outer_loop->invalid = 1;\n \t    }\n \t}\n       return;\n@@ -3313,7 +3230,7 @@ invariant_p (x)\n \t  && ! current_function_has_nonlocal_goto)\n \treturn 1;\n \n-      if (this_loop_info.has_call\n+      if (loop_info_data.has_call\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n \n@@ -3651,7 +3568,7 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n }\n \f\n /* Given a loop that is bounded by LOOP_START and LOOP_END\n-   and that is entered at SCAN_START,\n+   and that is entered at LOOP_SCAN_START,\n    return 1 if the register set in SET contained in insn INSN is used by\n    any insn that precedes INSN in cyclic order starting\n    from the loop entry point.\n@@ -3661,22 +3578,23 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n    from an inner loop past two loops.  */\n \n static int\n-loop_reg_used_before_p (set, insn, loop_start, scan_start, loop_end)\n-     rtx set, insn, loop_start, scan_start, loop_end;\n+loop_reg_used_before_p (loop, set, insn)\n+     const struct loop *loop;\n+     rtx set, insn;\n {\n   rtx reg = SET_DEST (set);\n   rtx p;\n \n   /* Scan forward checking for register usage.  If we hit INSN, we\n-     are done.  Otherwise, if we hit LOOP_END, wrap around to LOOP_START.  */\n-  for (p = scan_start; p != insn; p = NEXT_INSN (p))\n+     are done.  Otherwise, if we hit LOOP->END, wrap around to LOOP->START.  */\n+  for (p = loop->scan_start; p != insn; p = NEXT_INSN (p))\n     {\n       if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n \t  && reg_overlap_mentioned_p (reg, PATTERN (p)))\n \treturn 1;\n \n-      if (p == loop_end)\n-\tp = loop_start;\n+      if (p == loop->end)\n+\tp = loop->start;\n     }\n \n   return 0;\n@@ -3761,23 +3679,16 @@ static rtx addr_placeholder;\n    givs outside of their loop, and hence will never be reconsidered.\n    But scan_loop must check regnos to make sure they are in bounds. \n    \n-   SCAN_START is the first instruction in the loop, as the loop would\n+   LOOP_SCAN_START is the first instruction in the loop, as the loop would\n    actually be executed.  END is the NOTE_INSN_LOOP_END.  LOOP_TOP is\n    the first instruction in the loop, as it is layed out in the\n    instruction stream.  LOOP_START is the NOTE_INSN_LOOP_BEG.\n    LOOP_CONT is the NOTE_INSN_LOOP_CONT.  */\n \n static void\n-strength_reduce (scan_start, end, loop_top, insn_count,\n-\t\t loop_start, loop_end, loop_info, loop_cont, unroll_p, bct_p)\n-     rtx scan_start;\n-     rtx end;\n-     rtx loop_top;\n+strength_reduce (loop, insn_count, unroll_p, bct_p)\n+     struct loop *loop;\n      int insn_count;\n-     rtx loop_start;\n-     rtx loop_end;\n-     struct loop_info *loop_info;\n-     rtx loop_cont;\n      int unroll_p, bct_p ATTRIBUTE_UNUSED;\n {\n   rtx p;\n@@ -3797,6 +3708,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   int past_loop_latch = 0;\n   /* Temporary list pointers for traversing loop_iv_list.  */\n   struct iv_class *bl, **backbl;\n+  struct loop_info *loop_info = loop->info;\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n      since in that case saving an insn makes more difference\n@@ -3812,11 +3724,16 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   int loop_depth = 0;\n   int n_extra_increment;\n   int unrolled_insn_copies = 0;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  rtx loop_scan_start = loop->scan_start;\n+  rtx loop_top = loop->top;\n+  rtx loop_cont = loop->cont;\n \n-  /* If scan_start points to the loop exit test, we have to be wary of\n+  /* If loop_scan_start points to the loop exit test, we have to be wary of\n      subversive use of gotos inside expression statements.  */\n-  if (prev_nonnote_insn (scan_start) != prev_nonnote_insn (loop_start))\n-    maybe_multiple = back_branch_in_range_p (scan_start, loop_start, loop_end);\n+  if (prev_nonnote_insn (loop_scan_start) != prev_nonnote_insn (loop_start))\n+    maybe_multiple = back_branch_in_range_p (loop_scan_start, loop_start, loop_end);\n \n   VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n   VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n@@ -3840,9 +3757,9 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n   /* Scan through loop to find all possible bivs.  */\n \n-  for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top);\n+  for (p = next_insn_in_loop (loop, loop_scan_start);\n        p != NULL_RTX;\n-       p = next_insn_in_loop (p, scan_start, end, loop_top))\n+       p = next_insn_in_loop (loop, p))\n     {\n       if (GET_CODE (p) == INSN\n \t  && (set = single_set (p))\n@@ -3856,7 +3773,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      int multi_insn_incr = 0;\n \n \t      if (basic_induction_var (SET_SRC (set), GET_MODE (SET_SRC (set)),\n-\t\t\t\t       dest_reg, p, &inc_val, &mult_val,\n+\t\t\t\t       dest_reg, p, loop->level,\n+\t\t\t\t       &inc_val, &mult_val,\n \t\t\t\t       &location, &multi_insn_incr))\n \t\t{\n \t\t  /* It is a possible basic induction variable.\n@@ -3890,23 +3808,23 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  while (1)\n \t    {\n \t      insn = NEXT_INSN (insn);\n-\t      if (insn == scan_start)\n+\t      if (insn == loop_scan_start)\n \t\tbreak;\n-\t      if (insn == end)\n+\t      if (insn == loop_end)\n \t\t{\n \t\t  if (loop_top != 0)\n \t\t    insn = loop_top;\n \t\t  else\n \t\t    break;\n-\t\t  if (insn == scan_start)\n+\t\t  if (insn == loop_scan_start)\n \t\t    break;\n \t\t}\n \n \t      if (GET_CODE (insn) == JUMP_INSN\n \t\t  && GET_CODE (PATTERN (insn)) != RETURN\n \t\t  && (! condjump_p (insn)\n \t\t      || (JUMP_LABEL (insn) != 0\n-\t\t\t  && JUMP_LABEL (insn) != scan_start\n+\t\t\t  && JUMP_LABEL (insn) != loop_scan_start\n \t\t\t  && ! loop_insn_first_p (p, JUMP_LABEL (insn)))))\n \t\t{\n \t\t  maybe_multiple = 1;\n@@ -3932,9 +3850,9 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n \t  /* If this is a jump outside the loop, then it also doesn't\n \t     matter.  Check to see if the target of this branch is on the\n-\t     loop_number_exits_labels list.  */\n+\t     loop->exits_labels list.  */\n \t     \n-\t  for (label = loop_number_exit_labels[uid_loop_num[INSN_UID (loop_start)]];\n+\t  for (label = uid_loop[INSN_UID (loop_start)]->exit_labels;\n \t       label;\n \t       label = LABEL_NEXTREF (label))\n \t    if (XEXP (label, 0) == JUMP_LABEL (p))\n@@ -3970,7 +3888,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t Note that LOOP_TOP is only set for rotated loops and we need\n \t this check for all loops, so compare against the CODE_LABEL\n \t which immediately follows LOOP_START.  */\n-      if (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == NEXT_INSN (loop_start))\n+      if (GET_CODE (p) == JUMP_INSN \n+\t  && JUMP_LABEL (p) == NEXT_INSN (loop_start))\n \tpast_loop_latch = 1;\n \n       /* Unlike in the code motion pass where MAYBE_NEVER indicates that\n@@ -4046,8 +3965,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       /* Can still unroll the loop anyways, but indicate that there is no\n \t strength reduction info available.  */\n       if (unroll_p)\n-\tunroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n-\t\t     loop_info, 0);\n+\tunroll_loop (loop, insn_count, end_insert_before, 0);\n \n       goto egress;\n     }\n@@ -4188,8 +4106,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t\t\t  &SET_SRC (single_set (bl->biv->insn)),\n \t\t\t\t  copy_rtx (src), 0))\n \t    {\n-\t      int loop_num = uid_loop_num[INSN_UID (loop_start)];\n-\t      rtx dominator = loop_number_cont_dominator[loop_num];\n+\t      rtx dominator = uid_loop[INSN_UID (loop_start)]->cont_dominator;\n \t      rtx giv = bl->biv->src_reg;\n \t      rtx giv_insn = bl->biv->insn;\n \t      rtx after_giv = NEXT_INSN (giv_insn);\n@@ -4202,7 +4119,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      /* We can get better optimization if we can move the giv setting\n \t\t before the first giv use.  */\n \t      if (dominator\n-\t\t  && ! loop_insn_first_p (dominator, scan_start)\n+\t\t  && ! loop_insn_first_p (dominator, loop_scan_start)\n \t\t  && ! reg_set_between_p (bl2->biv->src_reg, loop_start,\n \t\t\t\t\t  dominator)\n \t\t  && ! reg_used_between_p (giv, loop_start, dominator)\n@@ -4281,7 +4198,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n     n_extra_increment += bl->biv_count - 1;\n \n   /* If the loop contains volatile memory references do not allow any\n-     replacements to take place, since this could loose the volatile markers.  */\n+     replacements to take place, since this could loose the volatile\n+     markers.  */\n   if (n_extra_increment  && ! loop_info->has_volatile)\n     {\n       int nregs = first_increment_giv + n_extra_increment;\n@@ -4295,7 +4213,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  struct induction **vp, *v, *next;\n \t  int biv_dead_after_loop = 0;\n \n-\t  /* The biv increments lists are in reverse order.  Fix this first.  */\n+\t  /* The biv increments lists are in reverse order.  Fix this\n+             first.  */\n \t  for (v = bl->biv, bl->biv = 0; v; v = next)\n \t    {\n \t      next = v->next_iv;\n@@ -4380,7 +4299,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n \t      for (last_use_insn = v->insn, p = NEXT_INSN (v->insn);\n \t\t   p != next->insn;\n-\t\t   p = next_insn_in_loop (p, scan_start, end, loop_top))\n+\t\t   p = next_insn_in_loop (loop, p))\n \t\t{\n \t\t  if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n \t\t    continue;\n@@ -4459,7 +4378,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t remember the last insn that needed a replacement.  */\n \t      for (last_use_insn = v->insn, p = NEXT_INSN (v->insn);\n \t\t   p != next->insn;\n-\t\t   p = next_insn_in_loop (p, scan_start, end, loop_top))\n+\t\t   p = next_insn_in_loop (loop, p))\n \t\t{\n \t\t  rtx note;\n     \n@@ -4504,21 +4423,21 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   not_every_iteration = 0;\n   loop_depth = 0;\n   maybe_multiple = 0;\n-  p = scan_start;\n+  p = loop_scan_start;\n   while (1)\n     {\n       p = NEXT_INSN (p);\n       /* At end of a straight-in loop, we are done.\n \t At end of a loop entered at the bottom, scan the top.  */\n-      if (p == scan_start)\n+      if (p == loop_scan_start)\n \tbreak;\n-      if (p == end)\n+      if (p == loop_end)\n \t{\n \t  if (loop_top != 0)\n \t    p = loop_top;\n \t  else\n \t    break;\n-\t  if (p == scan_start)\n+\t  if (p == loop_scan_start)\n \t    break;\n \t}\n \n@@ -4608,23 +4527,23 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  while (1)\n \t    {\n \t      insn = NEXT_INSN (insn);\n-\t      if (insn == scan_start)\n+\t      if (insn == loop_scan_start)\n \t\tbreak;\n-\t      if (insn == end)\n+\t      if (insn == loop_end)\n \t\t{\n \t\t  if (loop_top != 0)\n \t\t    insn = loop_top;\n \t\t  else\n \t\t    break;\n-\t\t  if (insn == scan_start)\n+\t\t  if (insn == loop_scan_start)\n \t\t    break;\n \t\t}\n \n \t      if (GET_CODE (insn) == JUMP_INSN\n \t\t  && GET_CODE (PATTERN (insn)) != RETURN\n \t\t  && (! condjump_p (insn)\n \t\t      || (JUMP_LABEL (insn) != 0\n-\t\t\t  && JUMP_LABEL (insn) != scan_start\n+\t\t\t  && JUMP_LABEL (insn) != loop_scan_start\n \t\t\t  && (INSN_UID (JUMP_LABEL (insn)) >= max_uid_for_loop\n \t\t\t      || INSN_UID (insn) >= max_uid_for_loop\n \t\t\t      || (INSN_LUID (JUMP_LABEL (insn))\n@@ -4653,9 +4572,9 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n \t  /* If this is a jump outside the loop, then it also doesn't\n \t     matter.  Check to see if the target of this branch is on the\n-\t     loop_number_exits_labels list.  */\n+\t     loop->exits_labels list.  */\n \t     \n-\t  for (label = loop_number_exit_labels[uid_loop_num[INSN_UID (loop_start)]];\n+\t  for (label = uid_loop[INSN_UID (loop_start)]->exit_labels;\n \t       label;\n \t       label = LABEL_NEXTREF (label))\n \t    if (XEXP (label, 0) == JUMP_LABEL (p))\n@@ -4703,7 +4622,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      be called after all giv's have been identified, since otherwise it may\n      fail if the iteration variable is a giv.  */\n \n-  loop_iterations (loop_start, loop_end, loop_info);\n+  loop_iterations (loop);\n \n   /* Now for each giv for which we still don't know whether or not it is\n      replaceable, check to see if it is replaceable because its final value\n@@ -4722,7 +4641,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   /* Try to prove that the loop counter variable (if any) is always\n      nonnegative; if so, record that fact with a REG_NONNEG note\n      so that \"decrement and branch until zero\" insn can be used.  */\n-  check_dbra_loop (loop_end, insn_count, loop_start, loop_info);\n+  check_dbra_loop (loop, insn_count);\n \n   /* Create reg_map to hold substitutions for replaceable giv regs.\n      Some givs might have been made from biv increments, so look at\n@@ -4771,7 +4690,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      && ! bl->nonneg\n #endif\n \t      ))\n-\tbl->eliminable = maybe_eliminate_biv (bl, loop_start, end, 0,\n+\tbl->eliminable = maybe_eliminate_biv (bl, loop_start, loop_end, 0,\n \t\t\t\t\t      threshold, insn_count);\n       else\n \t{\n@@ -5038,11 +4957,11 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t  /* Check for case where increment is before the address\n \t\t     giv.  Do this test in \"loop order\".  */\n \t\t  else if ((INSN_LUID (v->insn) > INSN_LUID (bl->biv->insn)\n-\t\t\t    && (INSN_LUID (v->insn) < INSN_LUID (scan_start)\n+\t\t\t    && (INSN_LUID (v->insn) < INSN_LUID (loop_scan_start)\n \t\t\t\t|| (INSN_LUID (bl->biv->insn)\n-\t\t\t\t    > INSN_LUID (scan_start))))\n-\t\t\t   || (INSN_LUID (v->insn) < INSN_LUID (scan_start)\n-\t\t\t       && (INSN_LUID (scan_start)\n+\t\t\t\t    > INSN_LUID (loop_scan_start))))\n+\t\t\t   || (INSN_LUID (v->insn) < INSN_LUID (loop_scan_start)\n+\t\t\t       && (INSN_LUID (loop_scan_start)\n \t\t\t\t   < INSN_LUID (bl->biv->insn))))\n \t\t    auto_inc_opt = -1;\n \t\t  else\n@@ -5169,7 +5088,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t loop to ensure that it will always be executed no matter\n \t\t how the loop exits.  Otherwise, emit the insn after the loop,\n \t\t since this is slightly more efficient.  */\n-\t      if (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n+\t      if (uid_loop[INSN_UID (loop_start)]->exit_count)\n \t\tinsert_before = loop_start;\n \t      else\n \t\tinsert_before = end_insert_before;\n@@ -5237,7 +5156,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t doing so in the rare cases where it can occur.  */\n \n       if (all_reduced == 1 && bl->eliminable\n-\t  && maybe_eliminate_biv (bl, loop_start, end, 1,\n+\t  && maybe_eliminate_biv (bl, loop_start, loop_end, 1,\n \t\t\t\t  threshold, insn_count))\n \n \t{\n@@ -5261,7 +5180,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t loop to ensure that it will always be executed no matter\n \t\t how the loop exits.  Otherwise, emit the insn after the\n \t\t loop, since this is slightly more efficient.  */\n-\t      if (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n+\t      if (uid_loop[INSN_UID (loop_start)]->exit_count)\n \t\tinsert_before = loop_start;\n \t      else\n \t\tinsert_before = end_insert_before;\n@@ -5292,7 +5211,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   /* Go through all the instructions in the loop, making all the\n      register substitutions scheduled in REG_MAP.  */\n \n-  for (p = loop_start; p != end; p = NEXT_INSN (p))\n+  for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n     if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n  \t|| GET_CODE (p) == CALL_INSN)\n       {\n@@ -5335,14 +5254,13 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   if (unroll_p\n       || (loop_info->n_iterations > 0\n \t  && unrolled_insn_copies <= insn_count))\n-    unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n-\t\t loop_info, 1);\n+    unroll_loop (loop, insn_count, end_insert_before, 1);\n \n #ifdef HAVE_decrement_and_branch_on_count\n   /* Instrument the loop with BCT insn.  */\n   if (HAVE_decrement_and_branch_on_count && bct_p\n       && flag_branch_on_count_reg)\n-    insert_bct (loop_start, loop_end, loop_info);\n+    insert_bct (loop);\n #endif  /* HAVE_decrement_and_branch_on_count */\n \n   if (loop_dump_stream)\n@@ -6116,12 +6034,13 @@ update_giv_derive (p)\n    If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location,\n-\t\t     multi_insn_incr)\n+basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n+\t\t     location, multi_insn_incr)\n      register rtx x;\n      enum machine_mode mode;\n-     rtx p;\n      rtx dest_reg;\n+     rtx p;\n+     int level;\n      rtx *inc_val;\n      rtx *mult_val;\n      rtx **location;\n@@ -6167,7 +6086,8 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location,\n \t value.  */\n       if (SUBREG_PROMOTED_VAR_P (x))\n \treturn basic_induction_var (SUBREG_REG (x), GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t    dest_reg, p, inc_val, mult_val, location,\n+\t\t\t\t    dest_reg, p, level, \n+\t\t\t\t    inc_val, mult_val, location,\n \t\t\t\t    multi_insn_incr);\n       return 0;\n \n@@ -6200,7 +6120,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location,\n \t\t\t\t      (GET_MODE (SET_SRC (set)) == VOIDmode\n \t\t\t\t       ? GET_MODE (x)\n \t\t\t\t       : GET_MODE (SET_SRC (set))),\n-\t\t\t\t      dest_reg, insn,\n+\t\t\t\t      dest_reg, insn, level,\n \t\t\t\t      inc_val, mult_val, location,\n \t\t\t\t      multi_insn_incr))\n \t    {\n@@ -6223,7 +6143,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location,\n       /* convert_modes aborts if we try to convert to or from CCmode, so just\n          exclude that case.  It is very unlikely that a condition code value\n \t would be a useful iterator anyways.  */\n-      if (this_loop_info.loops_enclosed == 1\n+      if (level == 0\n \t  && GET_MODE_CLASS (mode) != MODE_CC\n \t  && GET_MODE_CLASS (GET_MODE (dest_reg)) != MODE_CC)\n  \t{\n@@ -6237,8 +6157,8 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location,\n \n     case SIGN_EXTEND:\n       return basic_induction_var (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, p, inc_val, mult_val, location,\n-\t\t\t\t  multi_insn_incr);\n+\t\t\t\t  dest_reg, p, level, inc_val, mult_val,\n+\t\t\t\t  location, multi_insn_incr);\n \n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n@@ -6258,7 +6178,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location,\n \t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1)\n \t  && basic_induction_var (XEXP (SET_SRC (set), 0),\n \t\t\t\t  GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, insn, inc_val, mult_val,\n+\t\t\t\t  dest_reg, insn, level, inc_val, mult_val,\n \t\t\t\t  location, multi_insn_incr))\n \t{\n \t  *multi_insn_incr = 1;\n@@ -7908,11 +7828,9 @@ product_cheap_p (a, b)\n    final_[bg]iv_value.  */\n \n static int\n-check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n-     rtx loop_end;\n+check_dbra_loop (loop, insn_count)\n+     struct loop *loop;\n      int insn_count;\n-     rtx loop_start;\n-     struct loop_info *loop_info;\n {\n   struct iv_class *bl;\n   rtx reg;\n@@ -7926,6 +7844,9 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n   rtx jump;\n   rtx first_compare;\n   int compare_and_branch;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  struct loop_info *loop_info = loop->info;\n \n   /* If last insn is a conditional branch, and the insn before tests a\n      register value, try to optimize it.  Otherwise, we can't do anything.  */\n@@ -8041,7 +7962,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n       int reversible_mem_store = 1;\n \n       if (bl->giv_count == 0\n-\t  && ! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n+\t  && ! uid_loop[INSN_UID (loop_start)]->exit_count)\n \t{\n \t  rtx bivreg = regno_reg_rtx[bl->regno];\n \n@@ -8225,7 +8146,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t     calculate a giv or has a non-counting use.  */\n #if ! defined (HAVE_decrement_and_branch_until_zero) \\\n && defined (HAVE_decrement_and_branch_on_count)\n-\t\t  && (! (add_val == 1 && loop_info->vtop\n+\t\t  && (! (add_val == 1 && loop->vtop\n \t\t         && (bl->biv_count == 0\n \t\t\t     || no_use_except_counting)))\n #endif\n@@ -8240,7 +8161,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t  nonneg = 1;\n \t\t  cmp_code = GE;\n \t\t}\n-\t      else if (add_val == 1 && loop_info->vtop\n+\t      else if (add_val == 1 && loop->vtop\n \t\t       && (bl->biv_count == 0\n \t\t\t   || no_use_except_counting))\n \t\t{\n@@ -8483,10 +8404,11 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n    start of the loop.  */\n \n static int\n-maybe_eliminate_biv (bl, loop_start, end, eliminate_p, threshold, insn_count)\n+maybe_eliminate_biv (bl, loop_start, loop_end, eliminate_p, threshold,\n+\t\t     insn_count)\n      struct iv_class *bl;\n      rtx loop_start;\n-     rtx end;\n+     rtx loop_end;\n      int eliminate_p;\n      int threshold, insn_count;\n {\n@@ -8496,7 +8418,7 @@ maybe_eliminate_biv (bl, loop_start, end, eliminate_p, threshold, insn_count)\n   /* Scan all insns in the loop, stopping if we find one that uses the\n      biv in a way that we cannot eliminate.  */\n \n-  for (p = loop_start; p != end; p = NEXT_INSN (p))\n+  for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n     {\n       enum rtx_code code = GET_CODE (p);\n       rtx where = threshold >= insn_count ? loop_start : p;\n@@ -8534,7 +8456,7 @@ maybe_eliminate_biv (bl, loop_start, end, eliminate_p, threshold, insn_count)\n \t}\n     }\n \n-  if (p == end)\n+  if (p == loop_end)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"biv %d %s eliminated.\\n\",\n@@ -9337,31 +9259,29 @@ get_condition_for_loop (x)\n  */\n \n static void\n-insert_bct (loop_start, loop_end, loop_info)\n-     rtx loop_start, loop_end;\n-     struct loop_info *loop_info;\n+insert_bct (loop)\n+     struct loop *loop;\n {\n-  int i;\n   unsigned HOST_WIDE_INT n_iterations;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  struct loop_info *loop_info = loop->info;  \n+  int loop_num = loop->num;\n \n #if 0\n   int increment_direction, compare_direction;\n-\n   /* If the loop condition is <= or >=, the number of iteration\n       is 1 more than the range of the bounds of the loop.  */\n   int add_iteration = 0;\n-\n   enum machine_mode loop_var_mode = word_mode;\n #endif\n \n-  int loop_num = uid_loop_num [INSN_UID (loop_start)];\n-\n   /* It's impossible to instrument a competely unrolled loop.  */\n   if (loop_info->unroll_number == loop_info->n_iterations)\n     return;\n \n   /* Make sure that the count register is not in use.  */\n-  if (loop_used_count_register [loop_num])\n+  if (loop_info->used_count_register)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -9435,9 +9355,15 @@ insert_bct (loop_start, loop_end, loop_info)\n   /* Handle the simpler case, where the bounds are known at compile time.  */\n   if (n_iterations > 0)\n     {\n+      struct loop *outer_loop;\n+      struct loop_info *outer_loop_info;\n+\n       /* Mark all enclosing loops that they cannot use count register.  */\n-      for (i = loop_num; i != -1; i = loop_outer_loop[i])\n-\tloop_used_count_register[i] = 1;\n+      for (outer_loop = loop; outer_loop; outer_loop = outer_loop->outer)\n+\t{\n+\t  outer_loop_info = outer_loop->info;\n+\t  outer_loop_info->used_count_register = 1;\n+\t}\n       instrument_loop_bct (loop_start, loop_end, GEN_INT (n_iterations));\n       return;\n     }\n@@ -9707,17 +9633,13 @@ insert_loop_mem (mem, data)\n    values after load_mems.  */\n \n static void\n-load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n-\t\t\t\t     insn_count)\n-     rtx scan_start;\n-     rtx end;\n-     rtx loop_top;\n-     rtx start;\n+load_mems_and_recount_loop_regs_set (loop, insn_count)\n+     const struct loop *loop;\n      int *insn_count;\n {\n   int nregs = max_reg_num ();\n \n-  load_mems (scan_start, end, loop_top, start);\n+  load_mems (loop);\n   \n   /* Recalculate set_in_loop and friends since load_mems may have\n      created new registers.  */\n@@ -9742,7 +9664,7 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n       bzero ((char *) &may_not_optimize->data, nregs * sizeof (char));\n       bzero ((char *) &reg_single_usage->data, nregs * sizeof (rtx));\n \n-      count_loop_regs_set (loop_top ? loop_top : start, end,\n+      count_loop_regs_set (loop->top ? loop->top : loop->start, loop->end,\n \t\t\t   may_not_optimize, reg_single_usage,\n \t\t\t   insn_count, nregs); \n \n@@ -9767,16 +9689,11 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n     }\n }\n \n-/* Move MEMs into registers for the duration of the loop.  SCAN_START\n-   is the first instruction in the loop (as it is executed).  The\n-   other parameters are as for next_insn_in_loop.  */\n+/* Move MEMs into registers for the duration of the loop.  */\n \n static void\n-load_mems (scan_start, end, loop_top, start)\n-     rtx scan_start;\n-     rtx end;\n-     rtx loop_top;\n-     rtx start;\n+load_mems (loop)\n+     const struct loop *loop;\n {\n   int maybe_never = 0;\n   int i;\n@@ -9792,9 +9709,9 @@ load_mems (scan_start, end, loop_top, start)\n \n   /* Check to see if it's possible that some instructions in the\n      loop are never executed.  */\n-  for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top); \n-       p != NULL_RTX && !maybe_never; \n-       p = next_insn_in_loop (p, scan_start, end, loop_top))\n+  for (p = next_insn_in_loop (loop, loop->scan_start); \n+       p != NULL_RTX && ! maybe_never; \n+       p = next_insn_in_loop (loop, p))\n     {\n       if (GET_CODE (p) == CODE_LABEL)\n \tmaybe_never = 1;\n@@ -9806,8 +9723,8 @@ load_mems (scan_start, end, loop_top, start)\n \t\t  never be executed.  Unconditional jumps are\n \t\t  followed a by barrier then loop end.  */\n \t       && ! (GET_CODE (p) == JUMP_INSN \n-\t\t     && JUMP_LABEL (p) == loop_top\n-\t\t     && NEXT_INSN (NEXT_INSN (p)) == end\n+\t\t     && JUMP_LABEL (p) == loop->top\n+\t\t     && NEXT_INSN (NEXT_INSN (p)) == loop->end\n \t\t     && simplejump_p (p)))\n \t{\n \t  if (!condjump_p (p))\n@@ -9904,9 +9821,9 @@ load_mems (scan_start, end, loop_top, start)\n       /* Now, replace all references to the MEM with the\n \t corresponding pesudos.  */\n       maybe_never = 0;\n-      for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top);\n+      for (p = next_insn_in_loop (loop, loop->scan_start);\n \t   p != NULL_RTX;\n-\t   p = next_insn_in_loop (p, scan_start, end, loop_top))\n+\t   p = next_insn_in_loop (loop, p))\n \t{\n \t  rtx_and_int ri;\n \t  rtx set;\n@@ -9947,7 +9864,7 @@ load_mems (scan_start, end, loop_top, start)\n \t  /* Load the memory immediately before START, which is\n \t     the NOTE_LOOP_BEG.  */\n \t  set = gen_move_insn (reg, mem);\n-\t  emit_insn_before (set, start);\n+\t  emit_insn_before (set, loop->start);\n \n \t  if (written)\n \t    {\n@@ -9956,9 +9873,9 @@ load_mems (scan_start, end, loop_top, start)\n \t\t  /* We must compute the former\n \t\t     right-after-the-end label before we insert\n \t\t     the new one.  */\n-\t\t  end_label = next_label (end);\n+\t\t  end_label = next_label (loop->end);\n \t\t  label = gen_label_rtx ();\n-\t\t  emit_label_after (label, end);\n+\t\t  emit_label_after (label, loop->end);\n \t\t}\n \n \t      /* Store the memory immediately after END, which is\n@@ -9981,7 +9898,7 @@ load_mems (scan_start, end, loop_top, start)\n \t  EXECUTE_IF_SET_IN_REG_SET\n \t    (&copies, FIRST_PSEUDO_REGISTER, j,\n \t     {\n-\t       try_copy_prop (scan_start, loop_top, end, loop_mems[i].reg, j);\n+\t       try_copy_prop (loop, loop_mems[i].reg, j);\n \t     });\n \t  CLEAR_REG_SET (&copies);\n \t}\n@@ -9995,7 +9912,7 @@ load_mems (scan_start, end, loop_top, start)\n       rr.r1 = end_label;\n       rr.r2 = label;\n \n-      for (p = start; p != end; p = NEXT_INSN (p))\n+      for (p = loop->start; p != loop->end; p = NEXT_INSN (p))\n \t{\n \t  for_each_rtx (&p, replace_label, &rr);\n \n@@ -10036,8 +9953,9 @@ note_reg_stored (x, setter, arg)\n    is not used after the loop.\n    The arguments SCAN_START, LOOP_TOP and END are as in load_mems.  */\n static void\n-try_copy_prop (scan_start, loop_top, end, replacement, regno)\n-     rtx scan_start, loop_top, end, replacement;\n+try_copy_prop (loop, replacement, regno)\n+     const struct loop *loop;\n+     rtx replacement;\n      int regno;\n {\n   /* This is the reg that we are copying from.  */\n@@ -10048,9 +9966,9 @@ try_copy_prop (scan_start, loop_top, end, replacement, regno)\n   int replaced_last = 0;\n   int store_is_first = 0;\n \n-  for (insn = next_insn_in_loop (scan_start, scan_start, end, loop_top);\n+  for (insn = next_insn_in_loop (loop, loop->scan_start);\n        insn != NULL_RTX;\n-       insn = next_insn_in_loop (insn, scan_start, end, loop_top))\n+       insn = next_insn_in_loop (loop, insn))\n     {\n       rtx set;\n \n@@ -10214,4 +10132,3 @@ replace_label (x, data)\n \n   return 0;\n }\n-"}, {"sha": "49fb4089e3d4a44d7b544fbd571c7ad7a4120416", "filename": "gcc/loop.h", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=a2be868fbade644577895e847ad2fc658cb6d7d5", "patch": "@@ -19,6 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"varray.h\"\n+#include \"basic-block.h\"\n \n /* Get the luid of an insn.  Catch the error of trying to reference the LUID\n    of an insn added during loop, since these don't have LUIDs.  */\n@@ -159,10 +160,6 @@ struct iv_class {\n \n struct loop_info\n {\n-  /* Loop number.  */\n-  int num;\n-  /* Loops enclosed by this loop including itself.  */\n-  int loops_enclosed;\n   /* Nonzero if there is a subroutine call in the current loop.  */\n   int has_call;\n   /* Nonzero if there is a volatile memory reference in the current\n@@ -200,11 +197,7 @@ struct loop_info\n   unsigned HOST_WIDE_INT n_iterations;\n   /* The number of times the loop body was unrolled.  */\n   unsigned int unroll_number;\n-  /* Non-zero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n-  rtx vtop;\n-  /* Non-zero if the loop has a NOTE_INSN_LOOP_CONT.\n-     A continue statement will generate a branch to NEXT_INSN (cont).  */\n-  rtx cont;\n+  int used_count_register;\n };\n \n /* Definitions used by the basic induction variable discovery code.  */\n@@ -215,12 +208,8 @@ enum iv_mode { UNKNOWN_INDUCT, BASIC_INDUCT, NOT_BASIC_INDUCT,\n \n extern int *uid_luid;\n extern int max_uid_for_loop;\n-extern int *uid_loop_num;\n-extern int *loop_outer_loop;\n-extern rtx *loop_number_exit_labels;\n-extern int *loop_number_exit_count;\n extern int max_reg_before_loop;\n-\n+extern struct loop **uid_loop;\n extern FILE *loop_dump_stream;\n \n extern varray_type reg_iv_type;\n@@ -243,9 +232,9 @@ rtx get_condition_for_loop PROTO((rtx));\n void emit_iv_add_mult PROTO((rtx, rtx, rtx, rtx, rtx));\n rtx express_from PROTO((struct induction *, struct induction *));\n \n-void unroll_loop PROTO((rtx, int, rtx, rtx, struct loop_info *, int));\n+void unroll_loop PROTO((struct loop *, int, rtx, int));\n rtx biv_total_increment PROTO((struct iv_class *, rtx, rtx));\n-unsigned HOST_WIDE_INT loop_iterations PROTO((rtx, rtx, struct loop_info *));\n+unsigned HOST_WIDE_INT loop_iterations PROTO((struct loop *));\n int precondition_loop_p PROTO((rtx, struct loop_info *, \n \t\t\t       rtx *, rtx *, rtx *, \n \t\t\t       enum machine_mode *mode));\n@@ -261,4 +250,3 @@ int loop_insn_first_p PROTO((rtx, rtx));\n /* Forward declarations for non-static functions declared in stmt.c.  */\n void find_loop_tree_blocks PROTO((void));\n void unroll_block_trees PROTO((void));\n-"}, {"sha": "d443af9561769f5be0e0983fd027277e853ab3a2", "filename": "gcc/unroll.c", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2be868fbade644577895e847ad2fc658cb6d7d5/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=a2be868fbade644577895e847ad2fc658cb6d7d5", "patch": "@@ -225,13 +225,10 @@ static rtx loop_find_equiv_value PROTO((rtx, rtx));\n    in loop.c.  */\n \n void\n-unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n-\t     loop_info, strength_reduce_p)\n-     rtx loop_end;\n+unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n+     struct loop *loop;\n      int insn_count;\n-     rtx loop_start;\n      rtx end_insert_before;\n-     struct loop_info *loop_info;\n      int strength_reduce_p;\n {\n   int i, j;\n@@ -257,6 +254,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n      a JUMP_INSN (for conditional jumps) or a BARRIER (for unconditional\n      jumps).  */\n   rtx last_loop_insn;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  struct loop_info *loop_info = loop->info;\n \n   /* Don't bother unrolling huge loops.  Since the minimum factor is\n      two, loops greater than one half of MAX_UNROLLED_INSNS will never\n@@ -370,10 +370,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t}\n \n       /* Remove the loop notes since this is no longer a loop.  */\n-      if (loop_info->vtop)\n-\tdelete_insn (loop_info->vtop);\n-      if (loop_info->cont)\n-\tdelete_insn (loop_info->cont);\n+      if (loop->vtop)\n+\tdelete_insn (loop->vtop);\n+      if (loop->cont)\n+\tdelete_insn (loop->cont);\n       if (loop_start)\n \tdelete_insn (loop_start);\n       if (loop_end)\n@@ -1310,10 +1310,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   if (unroll_type == UNROLL_COMPLETELY)\n     {\n       /* Remove the loop notes since this is no longer a loop.  */\n-      if (loop_info->vtop)\n-\tdelete_insn (loop_info->vtop);\n-      if (loop_info->cont)\n-\tdelete_insn (loop_info->cont);\n+      if (loop->vtop)\n+\tdelete_insn (loop->vtop);\n+      if (loop->cont)\n+\tdelete_insn (loop->cont);\n       if (loop_start)\n \tdelete_insn (loop_start);\n       if (loop_end)\n@@ -1489,7 +1489,7 @@ precondition_loop_p (loop_start, loop_info,\n \t       < GET_MODE_SIZE (GET_MODE (*initial_value))))\n     *mode = GET_MODE (*initial_value);\n \n-  /* Success! */\n+  /* Success!  */\n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"Preconditioning: Successful.\\n\");\n   return 1;\n@@ -2600,7 +2600,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n       biv_splittable = 1;\n       biv_final_value = 0;\n       if (unroll_type != UNROLL_COMPLETELY\n-\t  && (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]]\n+\t  && (uid_loop[INSN_UID (loop_start)]->exit_count\n \t      || unroll_type == UNROLL_NAIVE)\n \t  && (uid_luid[REGNO_LAST_UID (bl->regno)] >= INSN_LUID (loop_end)\n \t      || ! bl->init_insn\n@@ -2690,7 +2690,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t     loop to ensure that it will always be executed no matter\n \t     how the loop exits.  Otherwise emit the insn after the loop,\n \t     since this is slightly more efficient.  */\n-\t  if (! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n+\t  if (! uid_loop[INSN_UID (loop_start)]->exit_count)\n \t    emit_insn_before (gen_move_insn (bl->biv->src_reg,\n \t\t\t\t\t     biv_final_value),\n \t\t\t      end_insert_before);\n@@ -2817,7 +2817,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \n       final_value = 0;\n       if (unroll_type != UNROLL_COMPLETELY\n-\t  && (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]]\n+\t  && (uid_loop[INSN_UID (loop_start)]->exit_count\n \t      || unroll_type == UNROLL_NAIVE)\n \t  && v->giv_type != DEST_ADDR\n \t  /* The next part is true if the pseudo is used outside the loop.\n@@ -3245,25 +3245,24 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n   enum rtx_code code;\n   int jump_count = 0;\n   int label_count = 0;\n-  int this_loop_num = uid_loop_num[INSN_UID (loop_start)];\n+  struct loop *loop = uid_loop[INSN_UID (loop_start)];\n \n   /* In addition to checking all exits of this loop, we must also check\n      all exits of inner nested loops that would exit this loop.  We don't\n      have any way to identify those, so we just give up if there are any\n      such inner loop exits.  */\n \n-  for (label = loop_number_exit_labels[this_loop_num]; label;\n-       label = LABEL_NEXTREF (label))\n+  for (label = loop->exit_labels; label; label = LABEL_NEXTREF (label))\n     label_count++;\n \n-  if (label_count != loop_number_exit_count[this_loop_num])\n+  if (label_count != loop->exit_count)\n     return 0;\n \n   /* HACK: Must also search the loop fall through exit, create a label_ref\n      here which points to the loop_end, and append the loop_number_exit_labels\n      list to it.  */\n   label = gen_rtx_LABEL_REF (VOIDmode, loop_end);\n-  LABEL_NEXTREF (label) = loop_number_exit_labels[this_loop_num];\n+  LABEL_NEXTREF (label) = loop->exit_labels;\n \n   for ( ; label; label = LABEL_NEXTREF (label))\n     {\n@@ -3343,7 +3342,7 @@ final_biv_value (bl, loop_start, loop_end, n_iterations)\n      value of the biv must be invariant.  */\n \n   if (n_iterations != 0\n-      && ! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]]\n+      && ! uid_loop[INSN_UID (loop_start)]->exit_count\n       && invariant_p (bl->initial_value))\n     {\n       increment = biv_total_increment (bl, loop_start, loop_end);\n@@ -3423,7 +3422,7 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n      to be known.  */\n \n   if (n_iterations != 0\n-      && ! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n+      && ! uid_loop[INSN_UID (loop_start)]->exit_count)\n     {\n       /* ?? It is tempting to use the biv's value here since these insns will\n \t be put after the loop, and hence the biv will have its final value\n@@ -3623,9 +3622,8 @@ find_common_reg_term (op0, op1)\n    iterations if it can be calculated, otherwise returns zero.  */\n \n unsigned HOST_WIDE_INT\n-loop_iterations (loop_start, loop_end, loop_info)\n-     rtx loop_start, loop_end;\n-     struct loop_info *loop_info;\n+loop_iterations (loop)\n+     struct loop *loop;\n {\n   rtx comparison, comparison_value;\n   rtx iteration_var, initial_value, increment, final_value;\n@@ -3637,6 +3635,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   int unsigned_p, compare_dir, final_larger;\n   rtx last_loop_insn;\n   rtx reg_term;\n+  struct loop_info *loop_info = loop->info;\n \n   loop_info->n_iterations = 0;\n   loop_info->initial_value = 0;\n@@ -3652,7 +3651,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n      accidentally get the branch for a contained loop if the branch for this\n      loop was deleted.  We can only trust branches immediately before the\n      loop_end.  */\n-  last_loop_insn = PREV_INSN (loop_end);\n+  last_loop_insn = PREV_INSN (loop->end);\n \n   /* ??? We should probably try harder to find the jump insn\n      at the end of the loop.  The following code assumes that\n@@ -3703,12 +3702,14 @@ loop_iterations (loop_start, loop_end, loop_info)\n       return 0;\n     }\n \n-  /* This can happen due to optimization in load_mems.  */\n+  /* The only new registers that care created before loop iterations are\n+     givs made from biv increments, so this should never occur.  */\n+\n   if ((unsigned) REGNO (iteration_var) >= reg_iv_type->num_elements)\n-    return 0;\n+    abort ();\n \n   iteration_info (iteration_var, &initial_value, &increment,\n-\t\t  loop_start, loop_end);\n+\t\t  loop->start, loop->end);\n   if (initial_value == 0)\n     /* iteration_info already printed a message.  */\n     return 0;\n@@ -3755,7 +3756,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   final_value = comparison_value;\n   if (GET_CODE (comparison_value) == REG && invariant_p (comparison_value))\n     {\n-      final_value = loop_find_equiv_value (loop_start, comparison_value);\n+      final_value = loop_find_equiv_value (loop->start, comparison_value);\n       /* If we don't get an invariant final value, we are better\n \t off with the original register.  */\n       if (!invariant_p (final_value))\n@@ -3815,23 +3816,23 @@ loop_iterations (loop_start, loop_end, loop_info)\n \n \t  /* Find what reg1 is equivalent to.  Hopefully it will\n \t     either be reg2 or reg2 plus a constant.  */\n-\t  temp = loop_find_equiv_value (loop_start, reg1);\n+\t  temp = loop_find_equiv_value (loop->start, reg1);\n \t  if (find_common_reg_term (temp, reg2))\n \t    initial_value = temp;\n \t  else\n \t    {\n \t      /* Find what reg2 is equivalent to.  Hopefully it will\n \t\t either be reg1 or reg1 plus a constant.  Let's ignore\n \t\t the latter case for now since it is not so common.  */\n-\t      temp = loop_find_equiv_value (loop_start, reg2);\n+\t      temp = loop_find_equiv_value (loop->start, reg2);\n \t      if (temp == loop_info->iteration_var)\n \t\ttemp = initial_value;\n \t      if (temp == reg1)\n \t\tfinal_value = (const2 == const0_rtx)\n \t\t  ? reg1 : gen_rtx_PLUS (GET_MODE (reg1), reg1, const2);\n \t    }\n \t}\n-      else if (loop_info->vtop && GET_CODE (reg2) == CONST_INT)\n+      else if (loop->vtop && GET_CODE (reg2) == CONST_INT)\n \t{\n \t  rtx temp;\n \n@@ -3842,10 +3843,10 @@ loop_iterations (loop_start, loop_end, loop_info)\n \t      where temp2 = init + const.  If the loop has a vtop we\n \t      can replace initial_value with const.  */\n \n-\t  temp = loop_find_equiv_value (loop_start, reg1);\n+\t  temp = loop_find_equiv_value (loop->start, reg1);\n \t  if (GET_CODE (temp) == MINUS && REG_P (XEXP (temp, 0)))\n \t    {\n-\t      rtx temp2 = loop_find_equiv_value (loop_start, XEXP (temp, 0));\n+\t      rtx temp2 = loop_find_equiv_value (loop->start, XEXP (temp, 0));\n \t      if (GET_CODE (temp2) == PLUS\n \t\t  && XEXP (temp2, 0) == XEXP (temp, 1))\n \t\tinitial_value = XEXP (temp2, 1);\n@@ -3862,7 +3863,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n \n      ??? Without a vtop we could still perform the optimization if we check\n      the initial and final values carefully.  */\n-  if (loop_info->vtop\n+  if (loop->vtop\n       && (reg_term = find_common_reg_term (initial_value, final_value)))\n     {\n       initial_value = subtract_reg_term (initial_value, reg_term);\n@@ -3892,7 +3893,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n       /* ??? Other RTL, such as (neg (reg)) is possible here, but it isn't\n \t clear if it is worthwhile to try to handle such RTL.  */\n       if (GET_CODE (increment) == REG || GET_CODE (increment) == SUBREG)\n-\tincrement = loop_find_equiv_value (loop_start, increment);\n+\tincrement = loop_find_equiv_value (loop->start, increment);\n \n       if (GET_CODE (increment) != CONST_INT)\n \t{"}]}