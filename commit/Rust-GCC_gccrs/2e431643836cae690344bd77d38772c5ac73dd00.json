{"sha": "2e431643836cae690344bd77d38772c5ac73dd00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU0MzE2NDM4MzZjYWU2OTAzNDRiZDc3ZDM4NzcyYzVhYzczZGQwMA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2015-07-04T15:37:04Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2015-07-04T15:37:04Z"}, "message": "[multiple changes]\n\n2015-07-04  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/66725\n\t* io.c (is_char_type): New function to test for BT_CHARACTER\n\t(gfc_match_open, gfc_match_close, match_dt_element): Use it.\n\n\n2015-07-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/66725\n\t* gfortran.dg/pr66725.f90: New test.\n\nFrom-SVN: r225415", "tree": {"sha": "3c98a4c06efdb446e470445ad7fb6b1d73bb8217", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c98a4c06efdb446e470445ad7fb6b1d73bb8217"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e431643836cae690344bd77d38772c5ac73dd00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e431643836cae690344bd77d38772c5ac73dd00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e431643836cae690344bd77d38772c5ac73dd00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e431643836cae690344bd77d38772c5ac73dd00/comments", "author": null, "committer": null, "parents": [{"sha": "26232bbbdae1a1fee034be9ce80831c10712623b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26232bbbdae1a1fee034be9ce80831c10712623b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26232bbbdae1a1fee034be9ce80831c10712623b"}], "stats": {"total": 123, "additions": 122, "deletions": 1}, "files": [{"sha": "981f7427aeacc6cbe1c04c4cc1e3847b8b24e7bb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2e431643836cae690344bd77d38772c5ac73dd00", "patch": "@@ -1,3 +1,9 @@\n+2015-07-04  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/66725\n+\t* io.c (is_char_type): New function to test for BT_CHARACTER\n+\t(gfc_match_open, gfc_match_close, match_dt_element): Use it.\n+\n 2015-07-02  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* trans-common.c: Include <map> after system.h."}, {"sha": "fe3edb9f6e2c3736fecfadad4e9c9abddd92bae8", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=2e431643836cae690344bd77d38772c5ac73dd00", "patch": "@@ -1242,6 +1242,19 @@ gfc_match_format (void)\n }\n \n \n+static bool\n+is_char_type (const char *name, gfc_expr *e)\n+{\n+  if (e->ts.type != BT_CHARACTER)\n+    {\n+      gfc_error (\"%s requires a scalar-default-char-expr at %L\",\n+\t\t   name, &e->where);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+\n /* Match an expression I/O tag of some sort.  */\n \n static match\n@@ -1870,6 +1883,9 @@ gfc_match_open (void)\n       static const char *access_f2003[] = { \"STREAM\", NULL };\n       static const char *access_gnu[] = { \"APPEND\", NULL };\n \n+      if (!is_char_type (\"ACCESS\", open->access))\n+\tgoto cleanup;\n+\n       if (!compare_to_allowed_values (\"ACCESS\", access_f95, access_f2003,\n \t\t\t\t      access_gnu,\n \t\t\t\t      open->access->value.character.string,\n@@ -1882,6 +1898,9 @@ gfc_match_open (void)\n     {\n       static const char *action[] = { \"READ\", \"WRITE\", \"READWRITE\", NULL };\n \n+      if (!is_char_type (\"ACTION\", open->action))\n+\tgoto cleanup;\n+\n       if (!compare_to_allowed_values (\"ACTION\", action, NULL, NULL,\n \t\t\t\t      open->action->value.character.string,\n \t\t\t\t      \"OPEN\", warn))\n@@ -1895,6 +1914,9 @@ gfc_match_open (void)\n \t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n+      if (!is_char_type (\"ASYNCHRONOUS\", open->asynchronous))\n+\tgoto cleanup;\n+\n       if (open->asynchronous->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n@@ -1913,6 +1935,9 @@ gfc_match_open (void)\n \t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n+      if (!is_char_type (\"BLANK\", open->blank))\n+\tgoto cleanup;\n+\n       if (open->blank->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char *blank[] = { \"ZERO\", \"NULL\", NULL };\n@@ -1931,6 +1956,9 @@ gfc_match_open (void)\n \t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n+      if (!is_char_type (\"DECIMAL\", open->decimal))\n+\tgoto cleanup;\n+\n       if (open->decimal->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * decimal[] = { \"COMMA\", \"POINT\", NULL };\n@@ -1949,6 +1977,9 @@ gfc_match_open (void)\n \t{\n \t  static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n \n+\tif (!is_char_type (\"DELIM\", open->delim))\n+\t  goto cleanup;\n+\n \t  if (!compare_to_allowed_values (\"DELIM\", delim, NULL, NULL,\n \t\t\t\t\t  open->delim->value.character.string,\n \t\t\t\t\t  \"OPEN\", warn))\n@@ -1962,7 +1993,10 @@ gfc_match_open (void)\n       if (!gfc_notify_std (GFC_STD_F2003, \"ENCODING= at %C \"\n \t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n-    \n+\n+      if (!is_char_type (\"ENCODING\", open->encoding))\n+\tgoto cleanup;\n+\n       if (open->encoding->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * encoding[] = { \"DEFAULT\", \"UTF-8\", NULL };\n@@ -1979,6 +2013,9 @@ gfc_match_open (void)\n     {\n       static const char *form[] = { \"FORMATTED\", \"UNFORMATTED\", NULL };\n \n+      if (!is_char_type (\"FORM\", open->form))\n+\tgoto cleanup;\n+\n       if (!compare_to_allowed_values (\"FORM\", form, NULL, NULL,\n \t\t\t\t      open->form->value.character.string,\n \t\t\t\t      \"OPEN\", warn))\n@@ -1990,6 +2027,9 @@ gfc_match_open (void)\n     {\n       static const char *pad[] = { \"YES\", \"NO\", NULL };\n \n+      if (!is_char_type (\"PAD\", open->pad))\n+\tgoto cleanup;\n+\n       if (!compare_to_allowed_values (\"PAD\", pad, NULL, NULL,\n \t\t\t\t      open->pad->value.character.string,\n \t\t\t\t      \"OPEN\", warn))\n@@ -2001,6 +2041,9 @@ gfc_match_open (void)\n     {\n       static const char *position[] = { \"ASIS\", \"REWIND\", \"APPEND\", NULL };\n \n+      if (!is_char_type (\"POSITION\", open->position))\n+\tgoto cleanup;\n+\n       if (!compare_to_allowed_values (\"POSITION\", position, NULL, NULL,\n \t\t\t\t      open->position->value.character.string,\n \t\t\t\t      \"OPEN\", warn))\n@@ -2014,6 +2057,9 @@ gfc_match_open (void)\n \t\t\t   \"not allowed in Fortran 95\"))\n       goto cleanup;\n \n+      if (!is_char_type (\"ROUND\", open->round))\n+\tgoto cleanup;\n+\n       if (open->round->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * round[] = { \"UP\", \"DOWN\", \"ZERO\", \"NEAREST\",\n@@ -2034,6 +2080,9 @@ gfc_match_open (void)\n \t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n+      if (!is_char_type (\"SIGN\", open->sign))\n+\tgoto cleanup;\n+\n       if (open->sign->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * sign[] = { \"PLUS\", \"SUPPRESS\", \"PROCESSOR_DEFINED\",\n@@ -2071,6 +2120,9 @@ gfc_match_open (void)\n       static const char *status[] = { \"OLD\", \"NEW\", \"SCRATCH\",\n \t\"REPLACE\", \"UNKNOWN\", NULL };\n \n+      if (!is_char_type (\"STATUS\", open->status))\n+\tgoto cleanup;\n+\n       if (!compare_to_allowed_values (\"STATUS\", status, NULL, NULL,\n \t\t\t\t      open->status->value.character.string,\n \t\t\t\t      \"OPEN\", warn))\n@@ -2256,6 +2308,9 @@ gfc_match_close (void)\n     {\n       static const char *status[] = { \"KEEP\", \"DELETE\", NULL };\n \n+      if (!is_char_type (\"STATUS\", close->status))\n+\tgoto cleanup;\n+\n       if (!compare_to_allowed_values (\"STATUS\", status, NULL, NULL,\n \t\t\t\t      close->status->value.character.string,\n \t\t\t\t      \"CLOSE\", warn))\n@@ -2708,6 +2763,7 @@ match_dt_element (io_kind k, gfc_dt *dt)\n   m = match_out_tag (&tag_iomsg, &dt->iomsg);\n   if (m != MATCH_NO)\n     return m;\n+\n   m = match_out_tag (&tag_iostat, &dt->iostat);\n   if (m != MATCH_NO)\n     return m;\n@@ -3305,6 +3361,9 @@ if (condition) \\\n \t  return MATCH_ERROR;\n \t}\n \n+      if (!is_char_type (\"ASYNCHRONOUS\", dt->asynchronous))\n+\treturn MATCH_ERROR;\n+\n       if (!compare_to_allowed_values\n \t\t(\"ASYNCHRONOUS\", asynchronous, NULL, NULL,\n \t\t dt->asynchronous->value.character.string,\n@@ -3334,6 +3393,9 @@ if (condition) \\\n \t{\n \t  static const char * decimal[] = { \"COMMA\", \"POINT\", NULL };\n \n+      if (!is_char_type (\"DECIMAL\", dt->decimal))\n+\treturn MATCH_ERROR;\n+\n \t  if (!compare_to_allowed_values (\"DECIMAL\", decimal, NULL, NULL,\n \t\t\t\t\t  dt->decimal->value.character.string,\n \t\t\t\t\t  io_kind_name (k), warn))\n@@ -3351,10 +3413,14 @@ if (condition) \\\n \t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n+      if (!is_char_type (\"BLANK\", dt->blank))\n+\treturn MATCH_ERROR;\n+\n       if (dt->blank->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * blank[] = { \"NULL\", \"ZERO\", NULL };\n \n+\n \t  if (!compare_to_allowed_values (\"BLANK\", blank, NULL, NULL,\n \t\t\t\t\t  dt->blank->value.character.string,\n \t\t\t\t\t  io_kind_name (k), warn))\n@@ -3372,6 +3438,9 @@ if (condition) \\\n \t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n+      if (!is_char_type (\"PAD\", dt->pad))\n+\treturn MATCH_ERROR;\n+\n       if (dt->pad->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * pad[] = { \"YES\", \"NO\", NULL };\n@@ -3393,6 +3462,9 @@ if (condition) \\\n \t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n+      if (!is_char_type (\"ROUND\", dt->round))\n+\treturn MATCH_ERROR;\n+\n       if (dt->round->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * round[] = { \"UP\", \"DOWN\", \"ZERO\", \"NEAREST\",\n@@ -3412,6 +3484,10 @@ if (condition) \\\n       if (gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n \t  \"not allowed in Fortran 95\") == false)\n \treturn MATCH_ERROR;  */\n+\n+      if (!is_char_type (\"SIGN\", dt->sign))\n+\treturn MATCH_ERROR;\n+\n       if (dt->sign->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char * sign[] = { \"PLUS\", \"SUPPRESS\", \"PROCESSOR_DEFINED\",\n@@ -3438,6 +3514,9 @@ if (condition) \\\n \t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n+      if (!is_char_type (\"DELIM\", dt->delim))\n+\treturn MATCH_ERROR;\n+\n       if (dt->delim->expr_type == EXPR_CONSTANT)\n \t{\n \t  static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };"}, {"sha": "2b29e1a6759d03759a48e909bd97b7d4250d6305", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2e431643836cae690344bd77d38772c5ac73dd00", "patch": "@@ -1,3 +1,8 @@\n+2015-07-04  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/66725\n+\t* gfortran.dg/pr66725.f90: New test.\n+\n 2015-07-03  Jason Merrill  <jason@redhat.com>\n \n \t* gcc.dg/plugin/wide-int_plugin.c (test_double_int_round_udiv):"}, {"sha": "8ad97f7e18de3881f3479180f491bfeb416f3ceb", "filename": "gcc/testsuite/gfortran.dg/pr66725.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66725.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e431643836cae690344bd77d38772c5ac73dd00/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66725.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66725.f90?ref=2e431643836cae690344bd77d38772c5ac73dd00", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+! PR fortran/66725\n+!\n+program foo\n+\n+   open(unit=1,access = 999)        ! { dg-error \"ACCESS requires\" }\n+   open(unit=1,action = 999)        ! { dg-error \"ACTION requires\" }\n+   open(unit=1,asynchronous = 999)  ! { dg-error \"ASYNCHRONOUS requires\" }\n+   open(unit=1,blank = 999)         ! { dg-error \"BLANK requires\" }\n+   open(unit=1,decimal = 999)       ! { dg-error \"DECIMAL requires\" }\n+   open(unit=1,delim = 999)         ! { dg-error \"DELIM requires\" }\n+   open(unit=1,encoding = 999)      ! { dg-error \"ENCODING requires\" }\n+   open(unit=1,form = 999)          ! { dg-error \"FORM requires\" }\n+   open(unit=1,pad = 999)           ! { dg-error \"PAD requires\" }\n+   open(unit=1,position = 999)      ! { dg-error \"POSITION requires\" }\n+   open(unit=1,round = 999)         ! { dg-error \"ROUND requires\" }\n+   open(unit=1,sign = 999)          ! { dg-error \"SIGN requires\" }\n+   open(unit=1,status = 999)        ! { dg-error \"STATUS requires\" }\n+\n+   close(unit=1, status=999)        ! { dg-error \"STATUS requires\" }\n+\n+   write (unit=1, asynchronous=257) ! { dg-error \"ASYNCHRONOUS requires\" }\n+   write (unit=1, delim=257)        ! { dg-error \"DELIM requires\" }\n+   write (unit=1, decimal=257)      ! { dg-error \"DECIMAL requires\" }\n+   write (unit=1, round=257)        ! { dg-error \"ROUND requires\" }\n+   write (unit=1, sign=257)         ! { dg-error \"SIGN requires\" }\n+\n+   write (unit=1, blank=257)        ! { dg-error \"BLANK requires\" }\n+   write (unit=1, pad=257)          ! { dg-error \"PAD requires\" }\n+\n+end program foo"}]}