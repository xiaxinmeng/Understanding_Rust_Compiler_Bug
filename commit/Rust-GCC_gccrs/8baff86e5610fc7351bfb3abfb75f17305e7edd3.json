{"sha": "8baff86e5610fc7351bfb3abfb75f17305e7edd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJhZmY4NmU1NjEwZmM3MzUxYmZiM2FiZmI3NWYxNzMwNWU3ZWRkMw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2014-10-24T11:30:42Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2014-10-24T11:30:42Z"}, "message": "[AArch64] Cleanup logic around aarch64_final_prescan\n\n\t* config/aarch64/aarch64.h (ADJUST_INSN_LENGTH): Wrap definition in\n\tdo while (0).\n\t* config/aarch64/aarch64.c (is_mem_p): Delete.\n\t(is_memory_op): Rename to...\n\t(has_memory_op): ... This.  Use FOR_EACH_SUBRTX.\n\t(dep_between_memop_and_curr): Assert that the input is a SET.\n\t(aarch64_madd_needs_nop): Add comment.  Do not call\n\tdep_between_memop_and_curr on NULL body.\n\t(aarch64_final_prescan_insn): Add comment.\n\tInclude rtl-iter.h.\n\nFrom-SVN: r216637", "tree": {"sha": "b98b7cf1873d829f4c4aea496c6edad522530bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b98b7cf1873d829f4c4aea496c6edad522530bf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8baff86e5610fc7351bfb3abfb75f17305e7edd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8baff86e5610fc7351bfb3abfb75f17305e7edd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8baff86e5610fc7351bfb3abfb75f17305e7edd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8baff86e5610fc7351bfb3abfb75f17305e7edd3/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f59b31508e341ef159d56a679e0e8a76e6d0b2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f59b31508e341ef159d56a679e0e8a76e6d0b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f59b31508e341ef159d56a679e0e8a76e6d0b2e"}], "stats": {"total": 66, "additions": 46, "deletions": 20}, "files": [{"sha": "918426d7dd3504a653af83df0a7830aeea7630d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baff86e5610fc7351bfb3abfb75f17305e7edd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baff86e5610fc7351bfb3abfb75f17305e7edd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8baff86e5610fc7351bfb3abfb75f17305e7edd3", "patch": "@@ -1,3 +1,16 @@\n+2014-10-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.h (ADJUST_INSN_LENGTH): Wrap definition in\n+\tdo while (0).\n+\t* config/aarch64/aarch64.c (is_mem_p): Delete.\n+\t(is_memory_op): Rename to...\n+\t(has_memory_op): ... This.  Use FOR_EACH_SUBRTX.\n+\t(dep_between_memop_and_curr): Assert that the input is a SET.\n+\t(aarch64_madd_needs_nop): Add comment.  Do not call\n+\tdep_between_memop_and_curr on NULL body.\n+\t(aarch64_final_prescan_insn): Add comment.\n+\tInclude rtl-iter.h.\n+\n 2014-10-24  Richard Biener  <rguenther@suse.de>\n \n \t* Makefile.in (BUILD_CPPLIB): Move $(LIBINTL) $(LIBICONV)"}, {"sha": "de53c948397a660222bde87883b233c4f2ae5048", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baff86e5610fc7351bfb3abfb75f17305e7edd3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baff86e5610fc7351bfb3abfb75f17305e7edd3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8baff86e5610fc7351bfb3abfb75f17305e7edd3", "patch": "@@ -68,6 +68,7 @@\n #include \"aarch64-cost-tables.h\"\n #include \"dumpfile.h\"\n #include \"builtins.h\"\n+#include \"rtl-iter.h\"\n \n /* Defined for convenience.  */\n #define POINTER_BYTES (POINTER_SIZE / BITS_PER_UNIT)\n@@ -7658,17 +7659,19 @@ aarch64_mangle_type (const_tree type)\n   return NULL;\n }\n \n-static int\n-is_mem_p (rtx *x, void *data ATTRIBUTE_UNUSED)\n-{\n-  return MEM_P (*x);\n-}\n+\n+/* Return true if the rtx_insn contains a MEM RTX somewhere\n+   in it.  */\n \n static bool\n-is_memory_op (rtx_insn *mem_insn)\n+has_memory_op (rtx_insn *mem_insn)\n {\n-   rtx pattern = PATTERN (mem_insn);\n-   return for_each_rtx (&pattern, is_mem_p, NULL);\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, PATTERN (mem_insn), ALL)\n+    if (MEM_P (*iter))\n+      return true;\n+\n+  return false;\n }\n \n /* Find the first rtx_insn before insn that will generate an assembly\n@@ -7718,14 +7721,13 @@ dep_between_memop_and_curr (rtx memop)\n   rtx load_reg;\n   int opno;\n \n-  if (!memop)\n-    return false;\n+  gcc_assert (GET_CODE (memop) == SET);\n \n   if (!REG_P (SET_DEST (memop)))\n     return false;\n \n   load_reg = SET_DEST (memop);\n-  for (opno = 0; opno < recog_data.n_operands; opno++)\n+  for (opno = 1; opno < recog_data.n_operands; opno++)\n     {\n       rtx operand = recog_data.operand[opno];\n       if (REG_P (operand)\n@@ -7736,6 +7738,12 @@ dep_between_memop_and_curr (rtx memop)\n   return false;\n }\n \n+\n+/* When working around the Cortex-A53 erratum 835769,\n+   given rtx_insn INSN, return true if it is a 64-bit multiply-accumulate\n+   instruction and has a preceding memory instruction such that a NOP\n+   should be inserted between them.  */\n+\n bool\n aarch64_madd_needs_nop (rtx_insn* insn)\n {\n@@ -7754,24 +7762,26 @@ aarch64_madd_needs_nop (rtx_insn* insn)\n     return false;\n \n   prev = aarch64_prev_real_insn (insn);\n-  if (!prev)\n+  if (!prev || !has_memory_op (prev))\n     return false;\n \n   body = single_set (prev);\n \n   /* If the previous insn is a memory op and there is no dependency between\n-     it and the madd, emit a nop between them.  If we know the previous insn is\n-     a memory op but body is NULL, emit the nop to be safe, it's probably a\n-     load/store pair insn.  */\n-  if (is_memory_op (prev)\n-      && GET_MODE (recog_data.operand[0]) == DImode\n-      && (!dep_between_memop_and_curr (body)))\n+     it and the DImode madd, emit a NOP between them.  If body is NULL then we\n+     have a complex memory operation, probably a load/store pair.\n+     Be conservative for now and emit a NOP.  */\n+  if (GET_MODE (recog_data.operand[0]) == DImode\n+      && (!body || !dep_between_memop_and_curr (body)))\n     return true;\n \n   return false;\n \n }\n \n+\n+/* Implement FINAL_PRESCAN_INSN.  */\n+\n void\n aarch64_final_prescan_insn (rtx_insn *insn)\n {"}, {"sha": "749c19d89d7f30d75eee1ca8fab6c4febebbee32", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baff86e5610fc7351bfb3abfb75f17305e7edd3/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baff86e5610fc7351bfb3abfb75f17305e7edd3/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=8baff86e5610fc7351bfb3abfb75f17305e7edd3", "patch": "@@ -503,8 +503,11 @@ enum target_cpus\n /* If inserting NOP before a mult-accumulate insn remember to adjust the\n    length so that conditional branching code is updated appropriately.  */\n #define ADJUST_INSN_LENGTH(insn, length)\t\\\n-  if (aarch64_madd_needs_nop (insn))\t\t\\\n-    length += 4;\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+       if (aarch64_madd_needs_nop (insn))\t\\\n+         length += 4;\t\t\t\t\\\n+    } while (0)\n \n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\\\n     aarch64_final_prescan_insn (INSN);\t\t\t\\"}]}