{"sha": "6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkyNGI1ZTZiZDNjODllMjI5YzUyZWFmYjEzNTNiY2JlMTdhYjQwNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-23T12:47:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-24T11:00:02Z"}, "message": "emit SLP vectorized loads earlier\n\nThis makes sure to emit SLP vectorized loads where the first scalar\nload is.  This makes SLP dependence checking more powerful because\nhoisting loads can use TBAA and it increases the freedom for\nvector placement when there are constraints from live lanes.\n\nVectorized shifts block inserting vectorized stmts always after\nvectorized defs because it ends up using the original scalar\noperand even when the SLP graph indicates the shift operand\nis vectorized (and we actually emit and cost those stmts).\n\nvect_slp_analyze_and_verify_node_alignment shows we need alignment\nfor too many places, this is a temporary solution and my plan\nis to have a single meta-info for a dataref group instead\n(also getting rid of DR_GROUP_FIRST/NEXT_ELEMENT).\n\n2020-06-24  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_find_first_scalar_stmt_in_slp):\n\tDeclare.\n\t* tree-vect-data-refs.c (vect_preserves_scalar_order_p):\n\tSimplify for new position of vectorized SLP loads.\n\t(vect_slp_analyze_node_dependences): Adjust for it.\n\t(vect_slp_analyze_and_verify_node_alignment): Compute alignment\n\tfor the first stmts dataref.\n\t* tree-vect-slp.c (vect_find_first_scalar_stmt_in_slp): New.\n\t(vect_schedule_slp_instance): Emit loads before the\n\tfirst scalar stmt.\n\t* tree-vect-stmts.c (vectorizable_load): Do what the comment\n\tsays and use vect_find_first_scalar_stmt_in_slp.", "tree": {"sha": "67e4f39131bc598f6b407348c6c047a637437c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67e4f39131bc598f6b407348c6c047a637437c77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d32708e796504eaeaad7d19990909204d74f9ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d32708e796504eaeaad7d19990909204d74f9ba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d32708e796504eaeaad7d19990909204d74f9ba3"}], "stats": {"total": 322, "additions": 213, "deletions": 109}, "files": [{"sha": "eb8288e7a851b6388172725e7aaf08b3e0b41a5c", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 166, "deletions": 101, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "patch": "@@ -232,61 +232,43 @@ vect_preserves_scalar_order_p (dr_vec_info *dr_info_a, dr_vec_info *dr_info_b)\n       && !STMT_VINFO_GROUPED_ACCESS (stmtinfo_b))\n     return true;\n \n-  /* STMT_A and STMT_B belong to overlapping groups.  All loads in a\n-     SLP group are emitted at the position of the last scalar load and\n-     all loads in an interleaving group are emitted at the position\n-     of the first scalar load.\n+  /* STMT_A and STMT_B belong to overlapping groups.  All loads are\n+     emitted at the position of the first scalar load.\n      Stores in a group are emitted at the position of the last scalar store.\n      Compute that position and check whether the resulting order matches\n-     the current one.\n-     We have not yet decided between SLP and interleaving so we have\n-     to conservatively assume both.  */\n-  stmt_vec_info il_a;\n-  stmt_vec_info last_a = il_a = DR_GROUP_FIRST_ELEMENT (stmtinfo_a);\n-  if (last_a)\n+     the current one.  */\n+  stmt_vec_info il_a = DR_GROUP_FIRST_ELEMENT (stmtinfo_a);\n+  if (il_a)\n     {\n-      for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (last_a); s;\n-\t   s = DR_GROUP_NEXT_ELEMENT (s))\n-\tlast_a = get_later_stmt (last_a, s);\n-      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_a)))\n-\t{\n-\t  for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_a); s;\n-\t       s = DR_GROUP_NEXT_ELEMENT (s))\n-\t    if (get_later_stmt (il_a, s) == il_a)\n-\t      il_a = s;\n-\t}\n-      else\n-\til_a = last_a;\n+      if (DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_a)))\n+\tfor (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_a); s;\n+\t     s = DR_GROUP_NEXT_ELEMENT (s))\n+\t  il_a = get_later_stmt (il_a, s);\n+      else /* DR_IS_READ */\n+\tfor (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_a); s;\n+\t     s = DR_GROUP_NEXT_ELEMENT (s))\n+\t  if (get_later_stmt (il_a, s) == il_a)\n+\t    il_a = s;\n     }\n   else\n-    last_a = il_a = stmtinfo_a;\n-  stmt_vec_info il_b;\n-  stmt_vec_info last_b = il_b = DR_GROUP_FIRST_ELEMENT (stmtinfo_b);\n-  if (last_b)\n+    il_a = stmtinfo_a;\n+  stmt_vec_info il_b = DR_GROUP_FIRST_ELEMENT (stmtinfo_b);\n+  if (il_b)\n     {\n-      for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (last_b); s;\n-\t   s = DR_GROUP_NEXT_ELEMENT (s))\n-\tlast_b = get_later_stmt (last_b, s);\n-      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_b)))\n-\t{\n-\t  for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_b); s;\n-\t       s = DR_GROUP_NEXT_ELEMENT (s))\n-\t    if (get_later_stmt (il_b, s) == il_b)\n-\t      il_b = s;\n-\t}\n-      else\n-\til_b = last_b;\n+      if (DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_b)))\n+\tfor (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_b); s;\n+\t     s = DR_GROUP_NEXT_ELEMENT (s))\n+\t  il_b = get_later_stmt (il_b, s);\n+      else /* DR_IS_READ */\n+\tfor (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_b); s;\n+\t     s = DR_GROUP_NEXT_ELEMENT (s))\n+\t  if (get_later_stmt (il_b, s) == il_b)\n+\t    il_b = s;\n     }\n   else\n-    last_b = il_b = stmtinfo_b;\n+    il_b = stmtinfo_b;\n   bool a_after_b = (get_later_stmt (stmtinfo_a, stmtinfo_b) == stmtinfo_a);\n-  return (/* SLP */\n-\t  (get_later_stmt (last_a, last_b) == last_a) == a_after_b\n-\t  /* Interleaving */\n-\t  && (get_later_stmt (il_a, il_b) == il_a) == a_after_b\n-\t  /* Mixed */\n-\t  && (get_later_stmt (il_a, last_b) == il_a) == a_after_b\n-\t  && (get_later_stmt (last_a, il_b) == last_a) == a_after_b);\n+  return (get_later_stmt (il_a, il_b) == il_a) == a_after_b;\n }\n \n /* A subroutine of vect_analyze_data_ref_dependence.  Handle\n@@ -702,71 +684,144 @@ vect_slp_analyze_node_dependences (vec_info *vinfo, slp_tree node,\n   /* This walks over all stmts involved in the SLP load/store done\n      in NODE verifying we can sink them up to the last stmt in the\n      group.  */\n-  stmt_vec_info last_access_info = vect_find_last_scalar_stmt_in_slp (node);\n-  for (unsigned k = 0; k < SLP_TREE_SCALAR_STMTS (node).length (); ++k)\n+  if (DR_IS_WRITE (STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (node))))\n     {\n-      stmt_vec_info access_info = SLP_TREE_SCALAR_STMTS (node)[k];\n-      if (access_info == last_access_info)\n-\tcontinue;\n-      data_reference *dr_a = STMT_VINFO_DATA_REF (access_info);\n-      ao_ref ref;\n-      bool ref_initialized_p = false;\n-      for (gimple_stmt_iterator gsi = gsi_for_stmt (access_info->stmt);\n-\t   gsi_stmt (gsi) != last_access_info->stmt; gsi_next (&gsi))\n+      stmt_vec_info last_access_info = vect_find_last_scalar_stmt_in_slp (node);\n+      for (unsigned k = 0; k < SLP_TREE_SCALAR_STMTS (node).length (); ++k)\n \t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  if (! gimple_vuse (stmt)\n-\t      || (DR_IS_READ (dr_a) && ! gimple_vdef (stmt)))\n+\t  stmt_vec_info access_info = SLP_TREE_SCALAR_STMTS (node)[k];\n+\t  if (access_info == last_access_info)\n \t    continue;\n-\n-\t  /* If we couldn't record a (single) data reference for this\n-\t     stmt we have to resort to the alias oracle.  */\n-\t  stmt_vec_info stmt_info = vinfo->lookup_stmt (stmt);\n-\t  data_reference *dr_b = STMT_VINFO_DATA_REF (stmt_info);\n-\t  if (!dr_b)\n+\t  data_reference *dr_a = STMT_VINFO_DATA_REF (access_info);\n+\t  ao_ref ref;\n+\t  bool ref_initialized_p = false;\n+\t  for (gimple_stmt_iterator gsi = gsi_for_stmt (access_info->stmt);\n+\t       gsi_stmt (gsi) != last_access_info->stmt; gsi_next (&gsi))\n \t    {\n-\t      /* We are moving a store or sinking a load - this means\n-\t         we cannot use TBAA for disambiguation.  */\n-\t      if (!ref_initialized_p)\n-\t\tao_ref_init (&ref, DR_REF (dr_a));\n-\t      if (stmt_may_clobber_ref_p_1 (stmt, &ref, false)\n-\t\t  || ref_maybe_used_by_stmt_p (stmt, &ref, false))\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (! gimple_vuse (stmt))\n+\t\tcontinue;\n+\n+\t      /* If we couldn't record a (single) data reference for this\n+\t\t stmt we have to resort to the alias oracle.  */\n+\t      stmt_vec_info stmt_info = vinfo->lookup_stmt (stmt);\n+\t      data_reference *dr_b = STMT_VINFO_DATA_REF (stmt_info);\n+\t      if (!dr_b)\n+\t\t{\n+\t\t  /* We are moving a store - this means\n+\t\t     we cannot use TBAA for disambiguation.  */\n+\t\t  if (!ref_initialized_p)\n+\t\t    ao_ref_init (&ref, DR_REF (dr_a));\n+\t\t  if (stmt_may_clobber_ref_p_1 (stmt, &ref, false)\n+\t\t      || ref_maybe_used_by_stmt_p (stmt, &ref, false))\n+\t\t    return false;\n+\t\t  continue;\n+\t\t}\n+\n+\t      bool dependent = false;\n+\t      /* If we run into a store of this same instance (we've just\n+\t\t marked those) then delay dependence checking until we run\n+\t\t into the last store because this is where it will have\n+\t\t been sunk to (and we verify if we can do that as well).  */\n+\t      if (gimple_visited_p (stmt))\n+\t\t{\n+\t\t  if (stmt_info != last_store_info)\n+\t\t    continue;\n+\t\t  unsigned i;\n+\t\t  stmt_vec_info store_info;\n+\t\t  FOR_EACH_VEC_ELT (stores, i, store_info)\n+\t\t    {\n+\t\t      data_reference *store_dr\n+\t\t\t= STMT_VINFO_DATA_REF (store_info);\n+\t\t      ddr_p ddr = initialize_data_dependence_relation\n+\t\t\t\t    (dr_a, store_dr, vNULL);\n+\t\t      dependent\n+\t\t\t= vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n+\t\t      free_dependence_relation (ddr);\n+\t\t      if (dependent)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  ddr_p ddr = initialize_data_dependence_relation (dr_a,\n+\t\t\t\t\t\t\t\t   dr_b, vNULL);\n+\t\t  dependent = vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n+\t\t  free_dependence_relation (ddr);\n+\t\t}\n+\t      if (dependent)\n \t\treturn false;\n-\t      continue;\n \t    }\n-\n-\t  bool dependent = false;\n-\t  /* If we run into a store of this same instance (we've just\n-\t     marked those) then delay dependence checking until we run\n-\t     into the last store because this is where it will have\n-\t     been sunk to (and we verify if we can do that as well).  */\n-\t  if (gimple_visited_p (stmt))\n+\t}\n+    }\n+  else /* DR_IS_READ */\n+    {\n+      stmt_vec_info first_access_info\n+\t= vect_find_first_scalar_stmt_in_slp (node);\n+      for (unsigned k = 0; k < SLP_TREE_SCALAR_STMTS (node).length (); ++k)\n+\t{\n+\t  stmt_vec_info access_info = SLP_TREE_SCALAR_STMTS (node)[k];\n+\t  if (access_info == first_access_info)\n+\t    continue;\n+\t  data_reference *dr_a = STMT_VINFO_DATA_REF (access_info);\n+\t  ao_ref ref;\n+\t  bool ref_initialized_p = false;\n+\t  for (gimple_stmt_iterator gsi = gsi_for_stmt (access_info->stmt);\n+\t       gsi_stmt (gsi) != first_access_info->stmt; gsi_prev (&gsi))\n \t    {\n-\t      if (stmt_info != last_store_info)\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (! gimple_vdef (stmt))\n \t\tcontinue;\n-\t      unsigned i;\n-\t      stmt_vec_info store_info;\n-\t      FOR_EACH_VEC_ELT (stores, i, store_info)\n+\n+\t      /* If we couldn't record a (single) data reference for this\n+\t\t stmt we have to resort to the alias oracle.  */\n+\t      stmt_vec_info stmt_info = vinfo->lookup_stmt (stmt);\n+\t      data_reference *dr_b = STMT_VINFO_DATA_REF (stmt_info);\n+\t      if (!dr_b)\n+\t\t{\n+\t\t  /* We are hoisting a load - this means we can use\n+\t\t     TBAA for disambiguation.  */\n+\t\t  if (!ref_initialized_p)\n+\t\t    ao_ref_init (&ref, DR_REF (dr_a));\n+\t\t  if (stmt_may_clobber_ref_p_1 (stmt, &ref, true))\n+\t\t    return false;\n+\t\t  continue;\n+\t\t}\n+\n+\t      bool dependent = false;\n+\t      /* If we run into a store of this same instance (we've just\n+\t\t marked those) then delay dependence checking until we run\n+\t\t into the last store because this is where it will have\n+\t\t been sunk to (and we verify if we can do that as well).  */\n+\t      if (gimple_visited_p (stmt))\n+\t\t{\n+\t\t  if (stmt_info != last_store_info)\n+\t\t    continue;\n+\t\t  unsigned i;\n+\t\t  stmt_vec_info store_info;\n+\t\t  FOR_EACH_VEC_ELT (stores, i, store_info)\n+\t\t    {\n+\t\t      data_reference *store_dr\n+\t\t\t= STMT_VINFO_DATA_REF (store_info);\n+\t\t      ddr_p ddr = initialize_data_dependence_relation\n+\t\t\t\t    (dr_a, store_dr, vNULL);\n+\t\t      dependent\n+\t\t\t= vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n+\t\t      free_dependence_relation (ddr);\n+\t\t      if (dependent)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t      else\n \t\t{\n-\t\t  data_reference *store_dr = STMT_VINFO_DATA_REF (store_info);\n-\t\t  ddr_p ddr = initialize_data_dependence_relation\n-\t\t\t\t(dr_a, store_dr, vNULL);\n-\t\t  dependent\n-\t\t    = vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n+\t\t  ddr_p ddr = initialize_data_dependence_relation (dr_a,\n+\t\t\t\t\t\t\t\t   dr_b, vNULL);\n+\t\t  dependent = vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n \t\t  free_dependence_relation (ddr);\n-\t\t  if (dependent)\n-\t\t    break;\n \t\t}\n+\t      if (dependent)\n+\t\treturn false;\n \t    }\n-\t  else\n-\t    {\n-\t      ddr_p ddr = initialize_data_dependence_relation (dr_a,\n-\t\t\t\t\t\t\t       dr_b, vNULL);\n-\t      dependent = vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n-\t      free_dependence_relation (ddr);\n-\t    }\n-\t  if (dependent)\n-\t    return false;\n \t}\n     }\n   return true;\n@@ -2399,10 +2454,20 @@ vect_slp_analyze_and_verify_node_alignment (vec_info *vinfo, slp_tree node)\n \n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (first_stmt_info);\n   vect_compute_data_ref_alignment (vinfo, dr_info);\n-  /* For creating the data-ref pointer we need alignment of the\n-     first element anyway.  */\n+  /* In several places we need alignment of the first element anyway.  */\n   if (dr_info != first_dr_info)\n     vect_compute_data_ref_alignment (vinfo, first_dr_info);\n+\n+  /* For creating the data-ref pointer we need alignment of the\n+     first element as well.  */\n+  first_stmt_info = vect_find_first_scalar_stmt_in_slp (node);\n+  if (first_stmt_info != SLP_TREE_SCALAR_STMTS (node)[0])\n+    {\n+      first_dr_info = STMT_VINFO_DR_INFO (first_stmt_info);\n+      if (dr_info != first_dr_info)\n+\tvect_compute_data_ref_alignment (vinfo, first_dr_info);\n+    }\n+\n   if (! verify_data_ref_alignment (vinfo, dr_info))\n     {\n       if (dump_enabled_p ())"}, {"sha": "e7a260877a9172e4ac8960e440aa13e1a1d75a55", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "patch": "@@ -1915,6 +1915,25 @@ vect_find_last_scalar_stmt_in_slp (slp_tree node)\n   return last;\n }\n \n+/* Find the first stmt in NODE.  */\n+\n+stmt_vec_info\n+vect_find_first_scalar_stmt_in_slp (slp_tree node)\n+{\n+  stmt_vec_info first = NULL;\n+  stmt_vec_info stmt_vinfo;\n+\n+  for (int i = 0; SLP_TREE_SCALAR_STMTS (node).iterate (i, &stmt_vinfo); i++)\n+    {\n+      stmt_vinfo = vect_orig_stmt (stmt_vinfo);\n+      if (!first\n+\t  || get_later_stmt (stmt_vinfo, first) == first)\n+\tfirst = stmt_vinfo;\n+    }\n+\n+  return first;\n+}\n+\n /* Splits a group of stores, currently beginning at FIRST_VINFO, into\n    two groups: one (still beginning at FIRST_VINFO) of size GROUP1_SIZE\n    (also containing the first GROUP1_SIZE stmts, since stores are\n@@ -4205,15 +4224,33 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t\t     \"------>vectorizing SLP node starting from: %G\",\n \t\t     stmt_info->stmt);\n \n-  /* Vectorized stmts go before the last scalar stmt which is where\n-     all uses are ready.  */\n-  stmt_vec_info last_stmt_info = vect_find_last_scalar_stmt_in_slp (node);\n-  if (last_stmt_info)\n-    si = gsi_for_stmt (last_stmt_info->stmt);\n+  if (STMT_VINFO_DATA_REF (stmt_info)\n+      && SLP_TREE_CODE (node) != VEC_PERM_EXPR)\n+    {\n+      /* Vectorized loads go before the first scalar load to make it\n+\t ready early, vectorized stores go before the last scalar\n+\t stmt which is where all uses are ready.  */\n+      stmt_vec_info last_stmt_info = NULL;\n+      if (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n+\tlast_stmt_info = vect_find_first_scalar_stmt_in_slp (node);\n+      else /* DR_IS_WRITE */\n+\tlast_stmt_info = vect_find_last_scalar_stmt_in_slp (node);\n+      si = gsi_for_stmt (last_stmt_info->stmt);\n+    }\n+  else if (SLP_TREE_CHILDREN (node).is_empty ())\n+    /* This happens for reduction PHIs.  */\n+    si = gsi_for_stmt (vect_find_last_scalar_stmt_in_slp (node)->stmt);\n+  else if (stmt_vec_info first_stmt_info\n+\t     = vect_find_last_scalar_stmt_in_slp (node))\n+    /* ???  Shifts by scalars hit us here again, we end up vectorizing\n+       the shift operand but end up using the scalar operand anyway.\n+       This needs to be better reflected in the SLP tree.  For now\n+       use the last position if available.  */\n+    si = gsi_for_stmt (first_stmt_info->stmt);\n   else\n     {\n-      /* Or if we do not have 1:1 matching scalar stmts emit after the\n-\t children vectorized defs.  */\n+      /* Emit other stmts after the children vectorized defs which is\n+\t earliest possible.  */\n       gimple *last_stmt = NULL;\n       FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n \tif (SLP_TREE_DEF_TYPE (child) == vect_internal_def)"}, {"sha": "de7d77f3872b33c5621830fd2738f8d3925a1a4a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "patch": "@@ -8728,7 +8728,8 @@ vectorizable_load (vec_info *vinfo,\n       /* For BB vectorization always use the first stmt to base\n \t the data ref pointer on.  */\n       if (bb_vinfo)\n-\tfirst_stmt_info_for_drptr = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n+\tfirst_stmt_info_for_drptr\n+\t  = vect_find_first_scalar_stmt_in_slp (slp_node);\n \n       /* Check if the chain of loads is already vectorized.  */\n       if (STMT_VINFO_VEC_STMTS (first_stmt_info).exists ()"}, {"sha": "e4d132493ca24c9babd89aedb3156c456218659a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6924b5e6bd3c89e229c52eafb1353bcbe17ab405/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6924b5e6bd3c89e229c52eafb1353bcbe17ab405", "patch": "@@ -2001,6 +2001,7 @@ extern void vect_get_slp_defs (vec_info *, slp_tree, vec<vec<tree> > *,\n \t\t\t       unsigned n = -1U);\n extern bool vect_slp_bb (basic_block);\n extern stmt_vec_info vect_find_last_scalar_stmt_in_slp (slp_tree);\n+extern stmt_vec_info vect_find_first_scalar_stmt_in_slp (slp_tree);\n extern bool is_simple_and_all_uses_invariant (stmt_vec_info, loop_vec_info);\n extern bool can_duplicate_and_interleave_p (vec_info *, unsigned int, tree,\n \t\t\t\t\t    unsigned int * = NULL,"}]}