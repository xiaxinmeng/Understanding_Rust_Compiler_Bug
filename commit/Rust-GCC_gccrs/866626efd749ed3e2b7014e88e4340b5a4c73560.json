{"sha": "866626efd749ed3e2b7014e88e4340b5a4c73560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY2NjI2ZWZkNzQ5ZWQzZTJiNzAxNGU4OGU0MzQwYjVhNGM3MzU2MA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-08-14T23:11:53Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-08-14T23:11:53Z"}, "message": "PR tree-optimization/78257 - missing memcmp optimization with constant arrays\n\ngcc/ChangeLog:\n\n\tPR middle-end/78257\n\t* builtins.c (expand_builtin_memory_copy_args): Rename called function.\n\t(expand_builtin_stpcpy_1): Remove argument from call.\n\t(expand_builtin_memcmp): Rename called function.\n\t(inline_expand_builtin_bytecmp): Same.\n\t* expr.c (convert_to_bytes): New function.\n\t(constant_byte_string): New function (formerly string_constant).\n\t(string_constant): Call constant_byte_string.\n\t(byte_representation): New function.\n\t* expr.h (byte_representation): Declare.\n\t* fold-const-call.c (fold_const_call): Rename called function.\n\t* fold-const.c (c_getstr): Remove an argument.\n\t(getbyterep): Define a new function.\n\t* fold-const.h (c_getstr): Remove an argument.\n\t(getbyterep): Declare a new function.\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Rename callee.\n\t(gimple_fold_builtin_string_compare): Same.\n\t(gimple_fold_builtin_memchr): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/78257\n\t* gcc.dg/memchr.c: New test.\n\t* gcc.dg/memcmp-2.c: New test.\n\t* gcc.dg/memcmp-3.c: New test.\n\t* gcc.dg/memcmp-4.c: New test.", "tree": {"sha": "9a97cbd204e7f85f1d5388fd61e95f4e6a2ab9ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a97cbd204e7f85f1d5388fd61e95f4e6a2ab9ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/866626efd749ed3e2b7014e88e4340b5a4c73560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866626efd749ed3e2b7014e88e4340b5a4c73560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866626efd749ed3e2b7014e88e4340b5a4c73560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866626efd749ed3e2b7014e88e4340b5a4c73560/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2867118ddda9b56d991c16022f7d3d634ed08313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2867118ddda9b56d991c16022f7d3d634ed08313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2867118ddda9b56d991c16022f7d3d634ed08313"}], "stats": {"total": 959, "additions": 915, "deletions": 44}, "files": [{"sha": "8845816aebdd00670f520ddbaefb69019d848fd2", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -4441,15 +4441,15 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n   /* Try to get the byte representation of the constant SRC points to,\n      with its byte size in NBYTES.  */\n   unsigned HOST_WIDE_INT nbytes;\n-  const char *rep = c_getstr (src, &nbytes);\n+  const char *rep = getbyterep (src, &nbytes);\n \n   /* If the function's constant bound LEN_RTX is less than or equal\n      to the byte size of the representation of the constant argument,\n      and if block move would be done by pieces, we can avoid loading\n      the bytes from memory and only store the computed constant.\n      This works in the overlap (memmove) case as well because\n      store_by_pieces just generates a series of stores of constants\n-     from the representation returned by c_getstr().  */\n+     from the representation returned by getbyterep().  */\n   if (rep\n       && CONST_INT_P (len_rtx)\n       && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= nbytes\n@@ -4698,7 +4698,7 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \t because the latter will potentially produce pessimized code\n \t when used to produce the return value.  */\n       c_strlen_data lendata = { };\n-      if (!c_getstr (src, NULL)\n+      if (!c_getstr (src)\n \t  || !(len = c_strlen (src, 0, &lendata, 1)))\n \treturn expand_movstr (dst, src, target,\n \t\t\t      /*retmode=*/ RETURN_END_MINUS_ONE);\n@@ -5351,11 +5351,11 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n      when the function's result is used for equality to zero, ARG1)\n      points to, with its byte size in NBYTES.  */\n   unsigned HOST_WIDE_INT nbytes;\n-  const char *rep = c_getstr (arg2, &nbytes);\n+  const char *rep = getbyterep (arg2, &nbytes);\n   if (result_eq && rep == NULL)\n     {\n       /* For equality to zero the arguments are interchangeable.  */\n-      rep = c_getstr (arg1, &nbytes);\n+      rep = getbyterep (arg1, &nbytes);\n       if (rep != NULL)\n \tstd::swap (arg1_rtx, arg2_rtx);\n     }\n@@ -7805,8 +7805,8 @@ inline_expand_builtin_bytecmp (tree exp, rtx target)\n   /* Get the object representation of the initializers of ARG1 and ARG2\n      as strings, provided they refer to constant objects, with their byte\n      sizes in LEN1 and LEN2, respectively.  */\n-  const char *bytes1 = c_getstr (arg1, &len1);\n-  const char *bytes2 = c_getstr (arg2, &len2);\n+  const char *bytes1 = getbyterep (arg1, &len1);\n+  const char *bytes2 = getbyterep (arg2, &len2);\n \n   /* Fail if neither argument refers to an initialized constant.  */\n   if (!bytes1 && !bytes2)"}, {"sha": "dd2200ddea87324ffdd97053d4b6b1e6dcbd1986", "filename": "gcc/expr.c", "status": "modified", "additions": 162, "deletions": 18, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -11600,15 +11600,112 @@ is_aligning_offset (const_tree offset, const_tree exp)\n   /* This must now be the address of EXP.  */\n   return TREE_CODE (offset) == ADDR_EXPR && TREE_OPERAND (offset, 0) == exp;\n }\n-\f\n-/* Return the tree node if an ARG corresponds to a string constant or zero\n-   if it doesn't.  If we return nonzero, set *PTR_OFFSET to the (possibly\n-   non-constant) offset in bytes within the string that ARG is accessing.\n-   If MEM_SIZE is non-zero the storage size of the memory is returned.\n-   If DECL is non-zero the constant declaration is returned if available.  */\n \n-tree\n-string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n+/* If EXPR is a constant initializer (either an expression or CONSTRUCTOR),\n+   attempt to obtain its native representation as an array of nonzero BYTES.\n+   Return true on success and false on failure (the latter without modifying\n+   BYTES).  */\n+\n+static bool\n+convert_to_bytes (tree type, tree expr, vec<unsigned char> *bytes)\n+{\n+  if (TREE_CODE (expr) == CONSTRUCTOR)\n+    {\n+      /* Set to the size of the CONSTRUCTOR elements.  */\n+      unsigned HOST_WIDE_INT ctor_size = bytes->length ();\n+\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  tree val, idx;\n+\t  tree eltype = TREE_TYPE (type);\n+\t  unsigned HOST_WIDE_INT elsize =\n+\t    tree_to_uhwi (TYPE_SIZE_UNIT (eltype));\n+\n+\t  /* Jump through hoops to determine the lower bound for languages\n+\t     like Ada that can set it to an (almost) arbitrary value.  */\n+\t  tree dom = TYPE_DOMAIN (type);\n+\t  if (!dom)\n+\t    return false;\n+\t  tree min = TYPE_MIN_VALUE (dom);\n+\t  if (!min || !tree_fits_uhwi_p (min))\n+\t    return false;\n+\t  unsigned HOST_WIDE_INT i, last_idx = tree_to_uhwi (min) - 1;\n+\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, idx, val)\n+\t    {\n+\t      /* Append zeros for elements with no initializers.  */\n+\t      if (!tree_fits_uhwi_p (idx))\n+\t\treturn false;\n+\t      unsigned HOST_WIDE_INT cur_idx = tree_to_uhwi (idx);\n+\t      if (unsigned HOST_WIDE_INT size = cur_idx - (last_idx + 1))\n+\t\t{\n+\t\t  size = size * elsize + bytes->length ();\n+\t\t  bytes->safe_grow_cleared (size);\n+\t\t}\n+\n+\t      if (!convert_to_bytes (eltype, val, bytes))\n+\t\treturn false;\n+\n+\t      last_idx = cur_idx;\n+\t    }\n+\t}\n+      else if (TREE_CODE (type) == RECORD_TYPE)\n+\t{\n+\t  tree val, fld;\n+\t  unsigned HOST_WIDE_INT i;\n+\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, fld, val)\n+\t    {\n+\t      /* Append zeros for members with no initializers and\n+\t\t any padding.  */\n+\t      unsigned HOST_WIDE_INT cur_off = int_byte_position (fld);\n+\t      if (bytes->length () < cur_off)\n+\t\tbytes->safe_grow_cleared (cur_off);\n+\n+\t      if (!convert_to_bytes (TREE_TYPE (val), val, bytes))\n+\t\treturn false;\n+\t    }\n+\t}\n+      else\n+\treturn false;\n+\n+      /* Compute the size of the COSNTRUCTOR elements.  */\n+      ctor_size = bytes->length () - ctor_size;\n+\n+      /* Append zeros to the byte vector to the full size of the type.\n+\t The type size can be less than the size of the CONSTRUCTOR\n+\t if the latter contains initializers for a flexible array\n+\t member.  */\n+      tree size = TYPE_SIZE_UNIT (type);\n+      unsigned HOST_WIDE_INT type_size = tree_to_uhwi (size);\n+      if (ctor_size < type_size)\n+\tif (unsigned HOST_WIDE_INT size_grow = type_size - ctor_size)\n+\t  bytes->safe_grow_cleared (bytes->length () + size_grow);\n+\n+      return true;\n+    }\n+\n+  unsigned char charbuf[MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT];\n+  int len = native_encode_expr (expr, charbuf, sizeof charbuf, 0);\n+  if (len <= 0)\n+    return false;\n+\n+  unsigned n = bytes->length ();\n+  bytes->safe_grow (n + len);\n+  unsigned char *p = bytes->address ();\n+  memcpy (p + n, charbuf, len);\n+  return true;\n+}\n+\n+/* Return a STRING_CST corresponding to ARG's constant initializer either\n+   if it's a string constant, or, when VALREP is set, any other constant,\n+   or null otherwise.\n+   On success, set *PTR_OFFSET to the (possibly non-constant) byte offset\n+   within the byte string that ARG is references.  If nonnull set *MEM_SIZE\n+   to the size of the byte string.  If nonnull, set *DECL to the constant\n+   declaration ARG refers to.  */\n+\n+static tree\n+constant_byte_string (tree arg, tree *ptr_offset, tree *mem_size, tree *decl,\n+\t\t      bool valrep = false)\n {\n   tree dummy = NULL_TREE;;\n   if (!mem_size)\n@@ -11755,18 +11852,43 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n       return array;\n     }\n \n-  if (!VAR_P (array) && TREE_CODE (array) != CONST_DECL)\n-    return NULL_TREE;\n-\n   tree init = ctor_for_folding (array);\n-\n-  /* Handle variables initialized with string literals.  */\n   if (!init || init == error_mark_node)\n     return NULL_TREE;\n+\n+  if (valrep)\n+    {\n+      HOST_WIDE_INT cstoff;\n+      if (!base_off.is_constant (&cstoff))\n+\treturn NULL_TREE;\n+\n+      /* If value representation was requested convert the initializer\n+\t for the whole array or object into a string of bytes forming\n+\t its value representation and return it.  */\n+      auto_vec<unsigned char> bytes;\n+      if (!convert_to_bytes (TREE_TYPE (init), init, &bytes))\n+\treturn NULL_TREE;\n+\n+      unsigned n = bytes.length ();\n+      const char *p = reinterpret_cast<const char *>(bytes.address ());\n+      init = build_string_literal (n, p, char_type_node);\n+      init = TREE_OPERAND (init, 0);\n+      init = TREE_OPERAND (init, 0);\n+\n+      *mem_size = size_int (TREE_STRING_LENGTH (init));\n+      *ptr_offset = wide_int_to_tree (ssizetype, base_off);\n+\n+      if (decl)\n+\t*decl = array;\n+\n+      return init;\n+    }\n+\n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n       /* Convert the 64-bit constant offset to a wider type to avoid\n-\t overflow.  */\n+\t overflow and use it to obtain the initializer for the subobject\n+\t it points into.  */\n       offset_int wioff;\n       if (!base_off.is_constant (&wioff))\n \treturn NULL_TREE;\n@@ -11779,6 +11901,9 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n       unsigned HOST_WIDE_INT fieldoff = 0;\n       init = fold_ctor_reference (TREE_TYPE (arg), init, base_off, 0, array,\n \t\t\t\t  &fieldoff);\n+      if (!init || init == error_mark_node)\n+\treturn NULL_TREE;\n+\n       HOST_WIDE_INT cstoff;\n       if (!base_off.is_constant (&cstoff))\n \treturn NULL_TREE;\n@@ -11791,9 +11916,6 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n \toffset = off;\n     }\n \n-  if (!init)\n-    return NULL_TREE;\n-\n   *ptr_offset = offset;\n \n   tree inittype = TREE_TYPE (init);\n@@ -11864,7 +11986,29 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n \n   return init;\n }\n-\f\n+\n+/* Return STRING_CST if an ARG corresponds to a string constant or zero\n+   if it doesn't.  If we return nonzero, set *PTR_OFFSET to the (possibly\n+   non-constant) offset in bytes within the string that ARG is accessing.\n+   If MEM_SIZE is non-zero the storage size of the memory is returned.\n+   If DECL is non-zero the constant declaration is returned if available.  */\n+\n+tree\n+string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n+{\n+  return constant_byte_string (arg, ptr_offset, mem_size, decl, false);\n+}\n+\n+/* Similar to string_constant, return a STRING_CST corresponding\n+   to the value representation of the first argument if it's\n+   a constant.  */\n+\n+tree\n+byte_representation (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n+{\n+  return constant_byte_string (arg, ptr_offset, mem_size, decl, true);\n+}\n+\n /* Optimize x % C1 == C2 for signed modulo if C1 is a power of two and C2\n    is non-zero and C3 ((1<<(prec-1)) | (C1 - 1)):\n    for C2 > 0 to x & C3 == C2"}, {"sha": "88d55bac30efaa2345ab831287c46839b76e1113", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -289,9 +289,13 @@ expand_normal (tree exp)\n }\n \n \n-/* Return the tree node and offset if a given argument corresponds to\n-   a string constant.  */\n+/* Return STRING_CST and set offset, size and decl, if the first\n+   argument corresponds to a string constant.  */\n extern tree string_constant (tree, tree *, tree *, tree *);\n+/* Similar to string_constant, return a STRING_CST corresponding\n+   to the value representation of the first argument if it's\n+   a constant.  */\n+extern tree byte_representation (tree, tree *, tree *, tree *);\n \n extern enum tree_code maybe_optimize_mod_cmp (enum tree_code, tree *, tree *);\n "}, {"sha": "11ed47db3d95b95da2cb4e42d95f1c7d41ed2544", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -1800,8 +1800,8 @@ fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n \t  && !TREE_SIDE_EFFECTS (arg0)\n \t  && !TREE_SIDE_EFFECTS (arg1))\n \treturn build_int_cst (type, 0);\n-      if ((p0 = c_getstr (arg0, &s0))\n-\t  && (p1 = c_getstr (arg1, &s1))\n+      if ((p0 = getbyterep (arg0, &s0))\n+\t  && (p1 = getbyterep (arg1, &s1))\n \t  && s2 <= s0\n \t  && s2 <= s1)\n \treturn build_cmp_result (type, memcmp (p0, p1, s2));\n@@ -1814,7 +1814,7 @@ fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n \t  && !TREE_SIDE_EFFECTS (arg0)\n \t  && !TREE_SIDE_EFFECTS (arg1))\n \treturn build_int_cst (type, 0);\n-      if ((p0 = c_getstr (arg0, &s0))\n+      if ((p0 = getbyterep (arg0, &s0))\n \t  && s2 <= s0\n \t  && target_char_cst_p (arg1, &c))\n \t{"}, {"sha": "9fc4c2a06fb14886394c226e0ac05aece6c96952", "filename": "gcc/fold-const.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -15485,19 +15485,19 @@ fold_build_pointer_plus_hwi_loc (location_t loc, tree ptr, HOST_WIDE_INT off)\n \t\t\t  ptr, size_int (off));\n }\n \n-/* Return a pointer P to a NUL-terminated string containing the sequence\n+/* Return a pointer to a NUL-terminated string containing the sequence\n    of bytes corresponding to the representation of the object referred to\n    by SRC (or a subsequence of such bytes within it if SRC is a reference\n    to an initialized constant array plus some constant offset).\n-   If STRSIZE is non-null, store the number of bytes in the constant\n-   sequence including the terminating NUL byte.  *STRSIZE is equal to\n-   sizeof(A) - OFFSET where A is the array that stores the constant\n-   sequence that SRC points to and OFFSET is the byte offset of SRC from\n-   the beginning of A.  SRC need not point to a string or even an array\n-   of characters but may point to an object of any type.  */\n+   Set *STRSIZE the number of bytes in the constant sequence including\n+   the terminating NUL byte.  *STRSIZE is equal to sizeof(A) - OFFSET\n+   where A is the array that stores the constant sequence that SRC points\n+   to and OFFSET is the byte offset of SRC from the beginning of A.  SRC\n+   need not point to a string or even an array of characters but may point\n+   to an object of any type.  */\n \n const char *\n-c_getstr (tree src, unsigned HOST_WIDE_INT *strsize /* = NULL */)\n+getbyterep (tree src, unsigned HOST_WIDE_INT *strsize)\n {\n   /* The offset into the array A storing the string, and A's byte size.  */\n   tree offset_node;\n@@ -15506,7 +15506,10 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strsize /* = NULL */)\n   if (strsize)\n     *strsize = 0;\n \n-  src = string_constant (src, &offset_node, &mem_size, NULL);\n+  if (strsize)\n+    src = byte_representation (src, &offset_node, &mem_size, NULL);\n+  else\n+    src = string_constant (src, &offset_node, &mem_size, NULL);\n   if (!src)\n     return NULL;\n \n@@ -15574,6 +15577,18 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strsize /* = NULL */)\n   return offset < init_bytes ? string + offset : \"\";\n }\n \n+/* Return a pointer to a NUL-terminated string corresponding to\n+   the expression STR referencing a constant string, possibly\n+   involving a constant offset.  Return null if STR either doesn't\n+   reference a constant string or if it involves a nonconstant\n+   offset.  */\n+\n+const char *\n+c_getstr (tree str)\n+{\n+  return getbyterep (str, NULL);\n+}\n+\n /* Given a tree T, compute which bits in T may be nonzero.  */\n \n wide_int"}, {"sha": "0c0f5fd46ccc7292bf94ed3c84c3f3ebad26d251", "filename": "gcc/fold-const.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -199,7 +199,8 @@ extern bool expr_not_equal_to (tree t, const wide_int &);\n extern tree const_unop (enum tree_code, tree, tree);\n extern tree const_binop (enum tree_code, tree, tree, tree);\n extern bool negate_mathfn_p (combined_fn);\n-extern const char *c_getstr (tree, unsigned HOST_WIDE_INT * = NULL);\n+extern const char *getbyterep (tree, unsigned HOST_WIDE_INT *);\n+extern const char *c_getstr (tree);\n extern wide_int tree_nonzero_bits (const_tree);\n \n /* Return OFF converted to a pointer offset type suitable as offset for"}, {"sha": "db56cb6aa479d8eaa64cf4317a49dfad32025d8f", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -774,7 +774,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t     strlenopt tests that rely on it for passing are adjusted, this\n \t     hack can be removed.  */\n \t  && !c_strlen (src, 1)\n-\t  && !((tmp_str = c_getstr (src, &tmp_len)) != NULL\n+\t  && !((tmp_str = getbyterep (src, &tmp_len)) != NULL\n \t       && memchr (tmp_str, 0, tmp_len) == NULL)\n \t  && !(srctype\n \t       && AGGREGATE_TYPE_P (srctype)\n@@ -2464,8 +2464,8 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n      For nul-terminated strings then adjusted to their length so that\n      LENx == NULPOSx holds.  */\n   unsigned HOST_WIDE_INT len1 = HOST_WIDE_INT_MAX, len2 = len1;\n-  const char *p1 = c_getstr (str1, &len1);\n-  const char *p2 = c_getstr (str2, &len2);\n+  const char *p1 = getbyterep (str1, &len1);\n+  const char *p2 = getbyterep (str2, &len2);\n \n   /* The position of the terminating nul character if one exists, otherwise\n      a value greater than LENx.  */\n@@ -2662,7 +2662,7 @@ gimple_fold_builtin_memchr (gimple_stmt_iterator *gsi)\n \n   unsigned HOST_WIDE_INT length = tree_to_uhwi (len);\n   unsigned HOST_WIDE_INT string_length;\n-  const char *p1 = c_getstr (arg1, &string_length);\n+  const char *p1 = getbyterep (arg1, &string_length);\n \n   if (p1)\n     {"}, {"sha": "fb21d58b4761e3bc641e0c3ae207c8330e286d61", "filename": "gcc/testsuite/gcc.dg/memchr.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemchr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemchr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemchr.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -0,0 +1,94 @@\n+/* PR middle-end/78257 - missing memcmp optimization with constant arrays\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -fdump-tree-optimized\" } */\n+\n+typedef __INT8_TYPE__  int8_t;\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+typedef __SIZE_TYPE__  size_t;\n+\n+extern void* memchr (const void*, int, size_t);\n+\n+/* Verify that initializers for flexible array members are handled\n+   correctly.  */\n+\n+struct SX\n+{\n+  /* offset */\n+  /*   0    */ int32_t n;\n+  /*   4    */ int8_t: 1;\n+  /*   6    */ int16_t a[];\n+};\n+\n+_Static_assert (__builtin_offsetof (struct SX, a) == 6);\n+\n+const struct SX sx =\n+  {\n+   0x11121314, { 0x2122, 0x3132, 0x4142, 0x5152 }\n+  };\n+\n+const char sx_rep[] =\n+  {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+   0x11, 0x12, 0x13, 0x14, 0, 0, 0x21, 0x22, 0x31, 0x32, 0x41, 0x42, 0x51, 0x52\n+#else\n+   0x14, 0x13, 0x12, 0x11, 0, 0, 0x22, 0x21, 0x32, 0x31, 0x42, 0x41, 0x52, 0x51\n+#endif\n+  };\n+\n+\n+void test_find (void)\n+{\n+  int n = 0, nb = (const char*)&sx.a[4] - (const char*)&sx;\n+  const char *p = (const char*)&sx, *q = sx_rep;\n+\n+  if (nb != sizeof sx_rep)\n+    __builtin_abort ();\n+\n+  n += p      == memchr (p, q[ 0], nb);\n+  n += p +  1 == memchr (p, q[ 1], nb);\n+  n += p +  2 == memchr (p, q[ 2], nb);\n+  n += p +  3 == memchr (p, q[ 3], nb);\n+  n += p +  4 == memchr (p, q[ 4], nb);\n+  n += p +  4 == memchr (p, q[ 5], nb);\n+  n += p +  6 == memchr (p, q[ 6], nb);\n+  n += p +  7 == memchr (p, q[ 7], nb);\n+  n += p +  8 == memchr (p, q[ 8], nb);\n+  n += p +  9 == memchr (p, q[ 9], nb);\n+  n += p + 10 == memchr (p, q[10], nb);\n+  n += p + 11 == memchr (p, q[11], nb);\n+  n += p + 12 == memchr (p, q[12], nb);\n+  n += p + 13 == memchr (p, q[13], nb);\n+\n+  if (n != 14)\n+    __builtin_abort ();\n+}\n+\n+void test_not_find (void)\n+{\n+  int n = 0, nb = (const char*)&sx.a[4] - (const char*)&sx;\n+  const char *p = (const char*)&sx, *q = sx_rep;\n+\n+  if (nb != sizeof sx_rep)\n+    __builtin_abort ();\n+\n+  n += 0 == memchr (p,      0xff, nb);\n+  n += 0 == memchr (p +  1, q[ 0], nb - 1);\n+  n += 0 == memchr (p +  2, q[ 1], nb - 2);\n+  n += 0 == memchr (p +  3, q[ 2], nb - 3);\n+  n += 0 == memchr (p +  4, q[ 3], nb - 4);\n+  n += 0 == memchr (p +  6, q[ 4], nb - 6);\n+  n += 0 == memchr (p +  7, q[ 6], nb - 7);\n+  n += 0 == memchr (p +  8, q[ 7], nb - 8);\n+  n += 0 == memchr (p +  9, q[ 8], nb - 9);\n+  n += 0 == memchr (p + 10, q[ 9], nb - 10);\n+  n += 0 == memchr (p + 11, q[10], nb - 11);\n+  n += 0 == memchr (p + 12, q[11], nb - 12);\n+  n += 0 == memchr (p + 13, q[12], nb - 13);\n+  n += 0 == memchr (p + 14, q[13], nb - 14);\n+\n+  if (n != 14)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "ff99c12b0afcc02d762749cfe925079c85bf3d81", "filename": "gcc/testsuite/gcc.dg/memcmp-2.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-2.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -0,0 +1,183 @@\n+/* PR middle-end/78257 - missing memcmp optimization with constant arrays\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -fdump-tree-optimized\" } */\n+\n+#define assert(e) ((e) ? (void)0 : __builtin_abort ())\n+\n+typedef __INT32_TYPE__ int32_t;\n+\n+extern int memcmp (const void*, const void*, __SIZE_TYPE__);\n+\n+const int32_t i_0 = 0;\n+const int32_t j_0 = 0;\n+\n+void eq_i0_j0 (void)\n+{\n+  const char *pi = (char*)&i_0, *pj = (char*)&j_0;\n+  int n = 0;\n+\n+  n += 0 == memcmp (pi,     pj,     sizeof (int32_t));\n+  n += 0 == memcmp (pi + 1, pj + 1, sizeof (int32_t) - 1);\n+  n += 0 == memcmp (pi + 2, pj + 2, sizeof (int32_t) - 2);\n+  n += 0 == memcmp (pi + 3, pj + 3, sizeof (int32_t) - 3);\n+  n += 0 == memcmp (pi + 4, pj + 4, sizeof (int32_t) - 4);\n+\n+  assert (n == 5);\n+}\n+\n+\n+const int32_t i1234 = 1234;\n+const int32_t j1234 = 1234;\n+\n+void eq_i1234_j1245 (void)\n+{\n+  const char *pi = (char*)&i1234, *pj = (char*)&j1234;\n+  int n = 0;\n+\n+  n += 0 == memcmp (pi,     pj,     sizeof (int32_t));\n+  n += 0 == memcmp (pi + 1, pj + 1, sizeof (int32_t) - 1);\n+  n += 0 == memcmp (pi + 2, pj + 2, sizeof (int32_t) - 2);\n+  n += 0 == memcmp (pi + 3, pj + 3, sizeof (int32_t) - 3);\n+  n += 0 == memcmp (pi + 4, pj + 4, sizeof (int32_t) - 4);\n+\n+  assert (n == 5);\n+}\n+\n+\n+const int32_t a1[2] = { 1234 };\n+const int32_t b1[2] = { 1234 };\n+\n+void eq_a1_b1 (void)\n+{\n+  const char *pi = (char*)&a1, *pj = (char*)&b1;\n+  int n = 0, nb = sizeof a1;\n+\n+  n += 0 == memcmp (pi,     pj,     nb);\n+  n += 0 == memcmp (pi + 1, pj + 1, nb - 1);\n+  n += 0 == memcmp (pi + 2, pj + 2, nb - 2);\n+  n += 0 == memcmp (pi + 3, pj + 3, nb - 3);\n+  n += 0 == memcmp (pi + 4, pj + 4, nb - 4);\n+  n += 0 == memcmp (pi + 5, pj + 5, nb - 5);\n+  n += 0 == memcmp (pi + 6, pj + 6, nb - 6);\n+  n += 0 == memcmp (pi + 7, pj + 7, nb - 7);\n+  n += 0 == memcmp (pi + 8, pj + 8, nb - 8);\n+\n+  assert (n == 9);\n+}\n+\n+const int32_t a2[2] = { 1234 };\n+const int32_t b2[2] = { 1234, 0 };\n+\n+void eq_a2_b2 (void)\n+{\n+  const char *pi = (char*)&a2, *pj = (char*)&b2;\n+  int n = 0, nb = sizeof a2;\n+\n+  n += 0 == memcmp (pi,     pj,     nb);\n+  n += 0 == memcmp (pi + 1, pj + 1, nb - 1);\n+  n += 0 == memcmp (pi + 2, pj + 2, nb - 2);\n+  n += 0 == memcmp (pi + 3, pj + 3, nb - 3);\n+  n += 0 == memcmp (pi + 4, pj + 4, nb - 4);\n+  n += 0 == memcmp (pi + 5, pj + 5, nb - 5);\n+  n += 0 == memcmp (pi + 6, pj + 6, nb - 6);\n+  n += 0 == memcmp (pi + 7, pj + 7, nb - 7);\n+  n += 0 == memcmp (pi + 8, pj + 8, nb - 8);\n+\n+  assert (n == 9);\n+}\n+\n+\n+const int32_t a5[5] = { [3] = 1234, [1] = 0 };\n+const int32_t b5[5] = { 0, 0, 0, 1234 };\n+\n+void eq_a5_b5 (void)\n+{\n+  int n = 0, b = sizeof a5;\n+  const char *pi = (char*)a5, *pj = (char*)b5;\n+\n+  n += 0 == memcmp (pi, pj, b);\n+  n += 0 == memcmp (pi + 1, pj + 1, b - 1);\n+  n += 0 == memcmp (pi + 2, pj + 2, b - 2);\n+  n += 0 == memcmp (pi + 3, pj + 3, b - 3);\n+\n+  n += 0 == memcmp (pi + 4, pj + 4, b - 4);\n+  n += 0 == memcmp (pi + 5, pj + 5, b - 5);\n+  n += 0 == memcmp (pi + 6, pj + 6, b - 6);\n+  n += 0 == memcmp (pi + 7, pj + 7, b - 7);\n+\n+  n += 0 == memcmp (pi + 8, pj + 8, b - 8);\n+  n += 0 == memcmp (pi + 9, pj + 9, b - 9);\n+  n += 0 == memcmp (pi + 10, pj + 10, b - 10);\n+  n += 0 == memcmp (pi + 11, pj + 11, b - 11);\n+\n+  n += 0 == memcmp (pi + 12, pj + 12, b - 12);\n+  n += 0 == memcmp (pi + 13, pj + 13, b - 13);\n+  n += 0 == memcmp (pi + 14, pj + 14, b - 14);\n+  n += 0 == memcmp (pi + 15, pj + 15, b - 15);\n+\n+  n += 0 == memcmp (pi + 16, pj + 16, b - 16);\n+  n += 0 == memcmp (pi + 17, pj + 17, b - 17);\n+  n += 0 == memcmp (pi + 18, pj + 18, b - 18);\n+  n += 0 == memcmp (pi + 19, pj + 19, b - 19);\n+\n+  assert (n == 20);\n+}\n+\n+\n+const int32_t a19[19] = { [13] = 13, [8] = 8, [4] = 4, [1] = 1  };\n+const int32_t b19[19] = { 0, 1, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 0, 13 };\n+\n+void eq_a19_b19 (void)\n+{\n+  int n = 0, b = sizeof a19;\n+  const char *pi = (char*)a19, *pj = (char*)b19;\n+\n+  n += 0 == memcmp (pi,     pj,     b);\n+  n += 0 == memcmp (pi + 1, pj + 1, b - 1);\n+  n += 0 == memcmp (pi + 2, pj + 2, b - 2);\n+  n += 0 == memcmp (pi + 3, pj + 3, b - 3);\n+\n+  n += 0 == memcmp (pi + 14, pj + 14, b - 14);\n+  n += 0 == memcmp (pi + 15, pj + 15, b - 15);\n+  n += 0 == memcmp (pi + 16, pj + 16, b - 16);\n+  n += 0 == memcmp (pi + 17, pj + 17, b - 17);\n+\n+  n += 0 == memcmp (pi + 28, pj + 28, b - 28);\n+  n += 0 == memcmp (pi + 29, pj + 29, b - 29);\n+  n += 0 == memcmp (pi + 30, pj + 30, b - 30);\n+  n += 0 == memcmp (pi + 31, pj + 31, b - 31);\n+\n+  n += 0 == memcmp (pi + 42, pj + 42, b - 42);\n+  n += 0 == memcmp (pi + 43, pj + 43, b - 43);\n+  n += 0 == memcmp (pi + 44, pj + 44, b - 44);\n+  n += 0 == memcmp (pi + 45, pj + 45, b - 45);\n+\n+  n += 0 == memcmp (pi + 56, pj + 56, b - 56);\n+  n += 0 == memcmp (pi + 57, pj + 57, b - 57);\n+  n += 0 == memcmp (pi + 58, pj + 58, b - 58);\n+  n += 0 == memcmp (pi + 59, pj + 59, b - 59);\n+\n+  assert (n == 20);\n+}\n+\n+\n+const int32_t A20[20] = { [13] = 14, [8] = 8, [4] = 4, [1] = 1  };\n+const int32_t b20[20] = { 0, 1, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 0, 13 };\n+\n+void gt_A20_b20 (void)\n+{\n+  int n = memcmp (A20, b20, sizeof A20) > 0;\n+  assert (n == 1);\n+}\n+\n+const int32_t a21[21] = { [13] = 12, [8] = 8, [4] = 4, [1] = 1  };\n+const int32_t B21[21] = { 0, 1, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 0, 13 };\n+\n+void lt_a21_B21 (void)\n+{\n+  int n = memcmp (a21, B21, sizeof a21) < 0;\n+  assert (n == 1);\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "b5b8ac1209fd1f63cb29cc74a8627495f2166e17", "filename": "gcc/testsuite/gcc.dg/memcmp-3.c", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-3.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -0,0 +1,349 @@\n+/* PR middle-end/78257 - missing memcmp optimization with constant arrays\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+   { dg-skip-if \"missing data representation\" { \"pdp11-*-*\" } } */\n+\n+#define offsetof(T, m) __builtin_offsetof (T, m)\n+\n+typedef __INT8_TYPE__  int8_t;\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+typedef __INT64_TYPE__ int64_t;\n+typedef __SIZE_TYPE__  size_t;\n+\n+extern int memcmp (const void*, const void*, size_t);\n+\n+const int32_t ia4[4] = { 0x11121314, 0x21222324, 0x31323334, 0x41424344 };\n+const int32_t ia4_des[4] =\n+  { [2] = 0x31323334, [0] = 0x11121314, 0x21222324, [3] = 0x41424344 };\n+const char ia4_rep[] =\n+  {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+   \"\\x11\\x12\\x13\\x14\" \"\\x21\\x22\\x23\\x24\"\n+   \"\\x31\\x32\\x33\\x34\" \"\\x41\\x42\\x43\\x44\"\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+   \"\\x14\\x13\\x12\\x11\" \"\\x24\\x23\\x22\\x21\"\n+   \"\\x34\\x33\\x32\\x31\" \"\\x44\\x43\\x42\\x41\"\n+#endif\n+  };\n+\n+void eq_ia4 (void)\n+{\n+  int n = 0, b = sizeof ia4;\n+  const char *p = (const char*)ia4, *q = ia4_rep;\n+\n+  n += memcmp (p,      q,      b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+  n += memcmp (p + 9,  q + 9,  b - 9);\n+  n += memcmp (p + 10, q + 10, b - 10);\n+  n += memcmp (p + 11, q + 11, b - 11);\n+  n += memcmp (p + 12, q + 12, b - 12);\n+  n += memcmp (p + 13, q + 13, b - 13);\n+  n += memcmp (p + 14, q + 14, b - 14);\n+  n += memcmp (p + 15, q + 15, b - 15);\n+  n += memcmp (p + 16, q + 16, b - 16);\n+\n+  p = (const char*)ia4_des;\n+\n+  n += memcmp (p,      q,      b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+  n += memcmp (p + 9,  q + 9,  b - 9);\n+  n += memcmp (p + 10, q + 10, b - 10);\n+  n += memcmp (p + 11, q + 11, b - 11);\n+  n += memcmp (p + 12, q + 12, b - 12);\n+  n += memcmp (p + 13, q + 13, b - 13);\n+  n += memcmp (p + 14, q + 14, b - 14);\n+  n += memcmp (p + 15, q + 15, b - 15);\n+  n += memcmp (p + 16, q + 16, b - 16);\n+\n+  if (n != 0)\n+    __builtin_abort ();\n+}\n+\n+const float fa4[4] = { 1.0, 2.0, 3.0, 4.0 };\n+const float fa4_des[4] = { [0] = fa4[0], [1] = 2.0, [2] = fa4[2], [3] = 4.0 };\n+\n+void eq_fa4 (void)\n+{\n+  int n = 0, b = sizeof fa4;\n+  const char *p = (const char*)fa4, *q = (const char*)fa4_des;\n+\n+  n += memcmp (p,      q,      b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+  n += memcmp (p + 9,  q + 9,  b - 9);\n+  n += memcmp (p + 10, q + 10, b - 10);\n+  n += memcmp (p + 11, q + 11, b - 11);\n+  n += memcmp (p + 12, q + 12, b - 12);\n+  n += memcmp (p + 13, q + 13, b - 13);\n+  n += memcmp (p + 14, q + 14, b - 14);\n+  n += memcmp (p + 15, q + 15, b - 15);\n+  n += memcmp (p + 16, q + 16, b - 16);\n+\n+  if (n != 0)\n+    __builtin_abort ();\n+}\n+\n+/* Verify \"greater than\" comparison with the difference in the last byte.  */\n+const char ia4_xrep_16[sizeof ia4] =\n+  {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+   0x11, 0x12, 0x13, 0x14, 0x21, 0x22, 0x23, 0x24,\n+   0x31, 0x32, 0x33, 0x34, 0x41, 0x42, 0x43\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+   0x14, 0x13, 0x12, 0x11, 0x24, 0x23, 0x22, 0x21,\n+   0x34, 0x33, 0x32, 0x31, 0x44, 0x43, 0x42\n+#endif\n+  };\n+\n+void gt_ia4 (void)\n+{\n+  int n = 0, b = sizeof ia4;\n+  const char *p = (const char*)ia4, *q = ia4_xrep_16;\n+\n+  n += 0 < memcmp (p,      q,      b);\n+  n += 0 < memcmp (p + 1,  q + 1,  b - 1);\n+  n += 0 < memcmp (p + 2,  q + 2,  b - 2);\n+  n += 0 < memcmp (p + 3,  q + 3,  b - 3);\n+  n += 0 < memcmp (p + 4,  q + 4,  b - 4);\n+  n += 0 < memcmp (p + 5,  q + 5,  b - 5);\n+  n += 0 < memcmp (p + 6,  q + 6,  b - 6);\n+  n += 0 < memcmp (p + 7,  q + 7,  b - 7);\n+  n += 0 < memcmp (p + 8,  q + 8,  b - 8);\n+  n += 0 < memcmp (p + 9,  q + 9,  b - 9);\n+  n += 0 < memcmp (p + 10, q + 10, b - 10);\n+  n += 0 < memcmp (p + 11, q + 11, b - 11);\n+  n += 0 < memcmp (p + 12, q + 12, b - 12);\n+  n += 0 < memcmp (p + 13, q + 13, b - 13);\n+  n += 0 < memcmp (p + 14, q + 14, b - 14);\n+  n += 0 < memcmp (p + 15, q + 15, b - 15);\n+\n+  if (n != 16)\n+    __builtin_abort ();\n+}\n+\n+struct S8_16_32\n+{\n+  int8_t  i8;\n+  int16_t i16;\n+  int32_t i32;\n+};\n+\n+_Static_assert (sizeof (struct S8_16_32) == 8);\n+\n+const struct S8_16_32 s8_16_32 = { 1, 0x2122, 0x31323334 };\n+const struct S8_16_32 s8_16_32_des =\n+  { .i8 = 1, .i16 = 0x2122, .i32 = 0x31323334 };\n+\n+const char s8_16_32_rep[] =\n+  {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+   1, 0, 0x21, 0x22, 0x31, 0x32, 0x33, 0x34\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+   1, 0, 0x22, 0x21, 0x34, 0x33, 0x32, 0x31\n+#endif\n+  };\n+\n+void eq_s8_16_32 (void)\n+{\n+  int n = 0, b = sizeof s8_16_32;\n+  const char *p = (char*)&s8_16_32, *q = s8_16_32_rep;\n+\n+  n += memcmp (p,     q,     b);\n+  n += memcmp (p + 1, q + 1, b - 1);\n+  n += memcmp (p + 2, q + 2, b - 2);\n+  n += memcmp (p + 3, q + 3, b - 3);\n+  n += memcmp (p + 4, q + 4, b - 4);\n+  n += memcmp (p + 5, q + 5, b - 5);\n+  n += memcmp (p + 6, q + 6, b - 6);\n+  n += memcmp (p + 7, q + 7, b - 7);\n+\n+  p = (char*)&s8_16_32_des;\n+\n+  n += memcmp (p,     q,     b);\n+  n += memcmp (p + 1, q + 1, b - 1);\n+  n += memcmp (p + 2, q + 2, b - 2);\n+  n += memcmp (p + 3, q + 3, b - 3);\n+  n += memcmp (p + 4, q + 4, b - 4);\n+  n += memcmp (p + 5, q + 5, b - 5);\n+  n += memcmp (p + 6, q + 6, b - 6);\n+  n += memcmp (p + 7, q + 7, b - 7);\n+\n+  if (n != 0)\n+    __builtin_abort ();\n+}\n+\n+\n+struct S8_16_32_64\n+{\n+  /*  0 */ int8_t   i8;\n+  /*  1 */ int8_t:  1;\n+  /*  2 */ int16_t  i16;\n+  /*  4 */ int32_t: 1;\n+  /*  8 */ int32_t  i32;\n+  /* 12 */ int32_t: 1;\n+  /* 16 */ int64_t  i64;\n+  /* 24 */ int8_t:  0;\n+};\n+\n+_Static_assert (offsetof (struct S8_16_32_64, i16) == 2);\n+_Static_assert (offsetof (struct S8_16_32_64, i32) == 8);\n+_Static_assert (offsetof (struct S8_16_32_64, i64) == 16);\n+_Static_assert (sizeof (struct S8_16_32_64) == 24);\n+\n+const struct S8_16_32_64 s8_16_32_64 =\n+  { 1, 0x2122, 0x31323334, 0x4142434445464748LLU };\n+\n+const char s8_16_32_64_rep[sizeof s8_16_32_64] =\n+  {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+   \"\\x01\" \"\\x00\" \"\\x21\\x22\" \"\\x00\\x00\\x00\\x00\" \"\\x31\\x32\\x33\\x34\"\n+   \"\\x00\\x00\\x00\\x00\" \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\"\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+   \"\\x01\" \"\\x00\" \"\\x22\\x21\" \"\\x00\\x00\\x00\\x00\" \"\\x34\\x33\\x32\\x31\"\n+   \"\\x00\\x00\\x00\\x00\" \"\\x48\\x47\\x46\\x45\\x44\\x43\\x42\\x41\"\n+#endif\n+  };\n+\n+const struct S8_16_32_64 s8_16_32_64_des =\n+  { .i64 = 0x4142434445464748LLU, .i16 = 0x2122, .i32 = 0x31323334, .i8 = 1 };\n+\n+\n+void eq_8_16_32_64 (void)\n+{\n+  int n = 0, b = sizeof s8_16_32_64;\n+  const char *p = (char*)&s8_16_32_64, *q = s8_16_32_64_rep;\n+\n+  n += memcmp (p, q, b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+  n += memcmp (p + 9,  q + 9,  b - 9);\n+  n += memcmp (p + 10, q + 10, b - 10);\n+  n += memcmp (p + 11, q + 11, b - 11);\n+  n += memcmp (p + 12, q + 12, b - 12);\n+  n += memcmp (p + 13, q + 13, b - 13);\n+  n += memcmp (p + 14, q + 14, b - 14);\n+  n += memcmp (p + 15, q + 15, b - 15);\n+  n += memcmp (p + 16, q + 16, b - 16);\n+  n += memcmp (p + 17, q + 17, b - 17);\n+  n += memcmp (p + 18, q + 18, b - 18);\n+  n += memcmp (p + 19, q + 19, b - 19);\n+  n += memcmp (p + 20, q + 20, b - 20);\n+  n += memcmp (p + 21, q + 21, b - 21);\n+  n += memcmp (p + 22, q + 22, b - 22);\n+  n += memcmp (p + 23, q + 23, b - 23);\n+\n+  p = (char*)&s8_16_32_64_des;\n+\n+  n += memcmp (p, q, b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+  n += memcmp (p + 9,  q + 9,  b - 9);\n+  n += memcmp (p + 10, q + 10, b - 10);\n+  n += memcmp (p + 11, q + 11, b - 11);\n+  n += memcmp (p + 12, q + 12, b - 12);\n+  n += memcmp (p + 13, q + 13, b - 13);\n+  n += memcmp (p + 14, q + 14, b - 14);\n+  n += memcmp (p + 15, q + 15, b - 15);\n+  n += memcmp (p + 16, q + 16, b - 16);\n+  n += memcmp (p + 17, q + 17, b - 17);\n+  n += memcmp (p + 18, q + 18, b - 18);\n+  n += memcmp (p + 19, q + 19, b - 19);\n+  n += memcmp (p + 20, q + 20, b - 20);\n+  n += memcmp (p + 21, q + 21, b - 21);\n+  n += memcmp (p + 22, q + 22, b - 22);\n+  n += memcmp (p + 23, q + 23, b - 23);\n+\n+  if (n != 0)\n+    __builtin_abort ();\n+}\n+\n+struct S64_x_3\n+{\n+  int64_t i64a[3];\n+};\n+\n+_Static_assert (sizeof (struct S64_x_3) == 24);\n+\n+const struct S64_x_3 s64_x_3 =\n+  { { 0x0000000021220001LLU, 0x0000000031323334LLU, 0x4142434445464748LLU } };\n+\n+const char s64_x_3_rep[sizeof s64_x_3] =\n+  {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+   \"\\x00\\x00\\x00\\x00\\x21\\x22\\x00\\x01\"\n+   \"\\x00\\x00\\x00\\x00\\x31\\x32\\x33\\x34\"\n+   \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\"\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+   \"\\x01\\x00\\x22\\x21\\x00\\x00\\x00\\x00\"\n+   \"\\x34\\x33\\x32\\x31\\x00\\x00\\x00\\x00\"\n+   \"\\x48\\x47\\x46\\x45\\x44\\x43\\x42\\x41\"\n+#endif\n+  };\n+\n+void eq_64_x_3 (void)\n+{\n+  int n = 0, b = sizeof s8_16_32_64;\n+  const char *p = (char*)&s8_16_32_64, *q = s64_x_3_rep;\n+  n += memcmp (p, q, b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+  n += memcmp (p + 9,  q + 9,  b - 9);\n+  n += memcmp (p + 10, q + 10, b - 10);\n+  n += memcmp (p + 11, q + 11, b - 11);\n+  n += memcmp (p + 12, q + 12, b - 12);\n+  n += memcmp (p + 13, q + 13, b - 13);\n+  n += memcmp (p + 14, q + 14, b - 14);\n+  n += memcmp (p + 15, q + 15, b - 15);\n+  n += memcmp (p + 16, q + 16, b - 16);\n+  n += memcmp (p + 17, q + 17, b - 17);\n+  n += memcmp (p + 18, q + 18, b - 18);\n+  n += memcmp (p + 19, q + 19, b - 19);\n+  n += memcmp (p + 20, q + 20, b - 20);\n+  n += memcmp (p + 21, q + 21, b - 21);\n+  n += memcmp (p + 22, q + 22, b - 22);\n+  n += memcmp (p + 23, q + 23, b - 23);\n+\n+  if (n != 0)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "bbac71975013a02ac364498186225b7f57709ae5", "filename": "gcc/testsuite/gcc.dg/memcmp-4.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866626efd749ed3e2b7014e88e4340b5a4c73560/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-4.c?ref=866626efd749ed3e2b7014e88e4340b5a4c73560", "patch": "@@ -0,0 +1,81 @@\n+/* PR middle-end/78257 - missing memcmp optimization with constant arrays\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -fdump-tree-optimized\" } */\n+\n+typedef __INT8_TYPE__  int8_t;\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+typedef __SIZE_TYPE__  size_t;\n+\n+extern int memcmp (const void*, const void*, size_t);\n+\n+/* Verify that initializers for flexible array members are handled\n+   correctly.  */\n+\n+struct Si16_x\n+{\n+  int16_t n, a[];\n+};\n+\n+const struct Si16_x si16_4 =\n+  {\n+   0x1112, { 0x2122, 0x3132, 0x4142 }\n+  };\n+\n+const char si16_4_rep[] =\n+  {\n+   0x12, 0x11, 0x22, 0x21, 0x32, 0x31, 0x42, 0x41\n+  };\n+\n+void eq_si16_x (void)\n+{\n+  int n = 0, b = sizeof si16_4_rep;\n+  const char *p = (const char*)&si16_4, *q = si16_4_rep;\n+\n+  n += memcmp (p,      q,      b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+\n+  p = (const char*)&si16_4.n;\n+\n+  n += memcmp (p,      q,          b);\n+  n += memcmp (p + 1,  q + 1,  b - 1);\n+  n += memcmp (p + 2,  q + 2,  b - 2);\n+  n += memcmp (p + 3,  q + 3,  b - 3);\n+  n += memcmp (p + 4,  q + 4,  b - 4);\n+  n += memcmp (p + 5,  q + 5,  b - 5);\n+  n += memcmp (p + 6,  q + 6,  b - 6);\n+  n += memcmp (p + 7,  q + 7,  b - 7);\n+  n += memcmp (p + 8,  q + 8,  b - 8);\n+\n+  p = (const char*)si16_4.a;\n+  q = si16_4_rep + 2;\n+\n+  n += memcmp (p,      q,      b - 2);\n+  n += memcmp (p + 1,  q + 1,  b - 3);\n+  n += memcmp (p + 2,  q + 2,  b - 4);\n+  n += memcmp (p + 3,  q + 3,  b - 5);\n+  n += memcmp (p + 4,  q + 4,  b - 6);\n+  n += memcmp (p + 5,  q + 5,  b - 7);\n+  n += memcmp (p + 6,  q + 6,  b - 8);\n+\n+  p = (const char*)&si16_4.a[1];\n+  q = si16_4_rep + 4;\n+\n+  n += memcmp (p,      q,      b - 4);\n+  n += memcmp (p + 1,  q + 1,  b - 5);\n+  n += memcmp (p + 2,  q + 2,  b - 6);\n+  n += memcmp (p + 3,  q + 3,  b - 7);\n+  n += memcmp (p + 4,  q + 4,  b - 8);\n+\n+  if (n != 0)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}]}