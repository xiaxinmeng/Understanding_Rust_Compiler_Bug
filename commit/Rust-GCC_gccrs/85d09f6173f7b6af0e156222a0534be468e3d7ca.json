{"sha": "85d09f6173f7b6af0e156222a0534be468e3d7ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVkMDlmNjE3M2Y3YjZhZjBlMTU2MjIyYTA1MzRiZTQ2OGUzZDdjYQ==", "commit": {"author": {"name": "Cary Coutant", "email": "ccoutant@google.com", "date": "2013-11-22T22:25:49Z"}, "committer": {"name": "Cary Coutant", "email": "ccoutant@gcc.gnu.org", "date": "2013-11-22T22:25:49Z"}, "message": "Fix demangler to handle conversion operators correctly.\n\nlibiberty/\n\tPR other/59195\n\t* cp-demangle.c (struct d_info_checkpoint): New struct.\n\t(struct d_print_info): Add current_template field.\n\t(d_operator_name): Set flag when processing a conversion\n\toperator.\n\t(cplus_demangle_type): When processing <template-args> for\n\ta conversion operator, backtrack if necessary.\n\t(d_expression_1): Renamed from d_expression.\n\t(d_expression): New wrapper around d_expression_1.\n\t(d_checkpoint): New function.\n\t(d_backtrack): New function.\n\t(d_print_init): Initialize current_template.\n\t(d_print_comp): Set current_template.\n\t(d_print_cast): Put current_template in scope for\n\tprinting conversion operator name.\n\t(cplus_demangle_init_info): Initialize is_expression and\n\tis_conversion.\n\t* cp-demangle.h (struct d_info): Add is_expression and\n\tis_conversion fields.\n\t* testsuite/demangle-expected: New test cases.\n\nFrom-SVN: r205292", "tree": {"sha": "cf760059b7f5810b1dae01b0b0f0aa1360c3155d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf760059b7f5810b1dae01b0b0f0aa1360c3155d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85d09f6173f7b6af0e156222a0534be468e3d7ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d09f6173f7b6af0e156222a0534be468e3d7ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d09f6173f7b6af0e156222a0534be468e3d7ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d09f6173f7b6af0e156222a0534be468e3d7ca/comments", "author": null, "committer": null, "parents": [{"sha": "9065ada9b5fa30d47ec723fbfbbeaad1082035cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9065ada9b5fa30d47ec723fbfbbeaad1082035cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9065ada9b5fa30d47ec723fbfbbeaad1082035cb"}], "stats": {"total": 238, "additions": 202, "deletions": 36}, "files": [{"sha": "825ddd2d1fa4bee4b20e575d0251ef4ce3b2b595", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=85d09f6173f7b6af0e156222a0534be468e3d7ca", "patch": "@@ -1,3 +1,26 @@\n+2013-11-22  Cary Coutant  <ccoutant@google.com>\n+    \n+\tPR other/59195\n+\t* cp-demangle.c (struct d_info_checkpoint): New struct.\n+\t(struct d_print_info): Add current_template field.\n+\t(d_operator_name): Set flag when processing a conversion\n+\toperator.\n+\t(cplus_demangle_type): When processing <template-args> for\n+\ta conversion operator, backtrack if necessary.\n+\t(d_expression_1): Renamed from d_expression.\n+\t(d_expression): New wrapper around d_expression_1.\n+\t(d_checkpoint): New function.\n+\t(d_backtrack): New function.\n+\t(d_print_init): Initialize current_template.\n+\t(d_print_comp): Set current_template.\n+\t(d_print_cast): Put current_template in scope for\n+\tprinting conversion operator name.\n+\t(cplus_demangle_init_info): Initialize is_expression and\n+\tis_conversion.\n+\t* cp-demangle.h (struct d_info): Add is_expression and\n+\tis_conversion fields.\n+\t* testsuite/demangle-expected: New test cases.\n+\n 2013-11-15  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* configure: Regenerate."}, {"sha": "029151e320aadddd23642470434b5aa90761f9e1", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 154, "deletions": 36, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=85d09f6173f7b6af0e156222a0534be468e3d7ca", "patch": "@@ -287,6 +287,19 @@ struct d_saved_scope\n   struct d_print_template *templates;\n };\n \n+/* Checkpoint structure to allow backtracking.  This holds copies\n+   of the fields of struct d_info that need to be restored\n+   if a trial parse needs to be backtracked over.  */\n+\n+struct d_info_checkpoint\n+{\n+  const char *n;\n+  int next_comp;\n+  int next_sub;\n+  int did_subs;\n+  int expansion;\n+};\n+\n enum { D_PRINT_BUFFER_LENGTH = 256 };\n struct d_print_info\n {\n@@ -318,6 +331,8 @@ struct d_print_info\n   struct d_saved_scope *saved_scopes;\n   /* Number of saved scopes in the above array.  */\n   int num_saved_scopes;\n+  /* The nearest enclosing template, if any.  */\n+  const struct demangle_component *current_template;\n };\n \n #ifdef CP_DEMANGLE_DEBUG\n@@ -444,6 +459,10 @@ d_add_substitution (struct d_info *, struct demangle_component *);\n \n static struct demangle_component *d_substitution (struct d_info *, int);\n \n+static void d_checkpoint (struct d_info *, struct d_info_checkpoint *);\n+\n+static void d_backtrack (struct d_info *, struct d_info_checkpoint *);\n+\n static void d_growable_string_init (struct d_growable_string *, size_t);\n \n static inline void\n@@ -1734,8 +1753,15 @@ d_operator_name (struct d_info *di)\n   if (c1 == 'v' && IS_DIGIT (c2))\n     return d_make_extended_operator (di, c2 - '0', d_source_name (di));\n   else if (c1 == 'c' && c2 == 'v')\n-    return d_make_comp (di, DEMANGLE_COMPONENT_CAST,\n-\t\t\tcplus_demangle_type (di), NULL);\n+    {\n+      struct demangle_component *type;\n+      int was_conversion = di->is_conversion;\n+\n+      di->is_conversion = ! di->is_expression;\n+      type = cplus_demangle_type (di);\n+      di->is_conversion = was_conversion;\n+      return d_make_comp (di, DEMANGLE_COMPONENT_CAST, type, NULL);\n+    }\n   else\n     {\n       /* LOW is the inclusive lower bound.  */\n@@ -2284,13 +2310,61 @@ cplus_demangle_type (struct d_info *di)\n       ret = d_template_param (di);\n       if (d_peek_char (di) == 'I')\n \t{\n-\t  /* This is <template-template-param> <template-args>.  The\n-\t     <template-template-param> part is a substitution\n+\t  /* This may be <template-template-param> <template-args>.\n+\t     If this is the type for a conversion operator, we can\n+\t     have a <template-template-param> here only by following\n+\t     a derivation like this:\n+\n+\t     <nested-name>\n+\t     -> <template-prefix> <template-args>\n+\t     -> <prefix> <template-unqualified-name> <template-args>\n+\t     -> <unqualified-name> <template-unqualified-name> <template-args>\n+\t     -> <source-name> <template-unqualified-name> <template-args>\n+\t     -> <source-name> <operator-name> <template-args>\n+\t     -> <source-name> cv <type> <template-args>\n+\t     -> <source-name> cv <template-template-param> <template-args> <template-args>\n+\n+\t     where the <template-args> is followed by another.\n+\t     Otherwise, we must have a derivation like this:\n+\n+\t     <nested-name>\n+\t     -> <template-prefix> <template-args>\n+\t     -> <prefix> <template-unqualified-name> <template-args>\n+\t     -> <unqualified-name> <template-unqualified-name> <template-args>\n+\t     -> <source-name> <template-unqualified-name> <template-args>\n+\t     -> <source-name> <operator-name> <template-args>\n+\t     -> <source-name> cv <type> <template-args>\n+\t     -> <source-name> cv <template-param> <template-args>\n+\n+\t     where we need to leave the <template-args> to be processed\n+\t     by d_prefix (following the <template-prefix>).\n+\n+\t     The <template-template-param> part is a substitution\n \t     candidate.  */\n-\t  if (! d_add_substitution (di, ret))\n-\t    return NULL;\n-\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n-\t\t\t     d_template_args (di));\n+\t  if (! di->is_conversion)\n+\t    {\n+\t      if (! d_add_substitution (di, ret))\n+\t\treturn NULL;\n+\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n+\t\t\t\t d_template_args (di));\n+\t    }\n+\t  else\n+\t    {\n+\t      struct demangle_component *args;\n+\t      struct d_info_checkpoint checkpoint;\n+\n+\t      d_checkpoint (di, &checkpoint);\n+\t      args = d_template_args (di);\n+\t      if (d_peek_char (di) == 'I')\n+\t\t{\n+\t\t  if (! d_add_substitution (di, ret))\n+\t\t    return NULL;\n+\t\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n+\t\t\t\t     args);\n+\t\t}\n+\t      else\n+\t\td_backtrack (di, &checkpoint);\n+\t    }\n \t}\n       break;\n \n@@ -2976,8 +3050,8 @@ op_is_new_cast (struct demangle_component *op)\n                 ::= <expr-primary>\n */\n \n-static struct demangle_component *\n-d_expression (struct d_info *di)\n+static inline struct demangle_component *\n+d_expression_1 (struct d_info *di)\n {\n   char peek;\n \n@@ -3005,7 +3079,7 @@ d_expression (struct d_info *di)\n     {\n       d_advance (di, 2);\n       return d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n-\t\t\t  d_expression (di), NULL);\n+\t\t\t  d_expression_1 (di), NULL);\n     }\n   else if (peek == 'f' && d_peek_next_char (di) == 'p')\n     {\n@@ -3110,7 +3184,7 @@ d_expression (struct d_info *di)\n \t\t&& d_check_char (di, '_'))\n \t      operand = d_exprlist (di, 'E');\n \t    else\n-\t      operand = d_expression (di);\n+\t      operand = d_expression_1 (di);\n \n \t    if (suffix)\n \t      /* Indicate the suffix variant for d_print_comp.  */\n@@ -3130,7 +3204,7 @@ d_expression (struct d_info *di)\n \t    if (op_is_new_cast (op))\n \t      left = cplus_demangle_type (di);\n \t    else\n-\t      left = d_expression (di);\n+\t      left = d_expression_1 (di);\n \t    if (!strcmp (code, \"cl\"))\n \t      right = d_exprlist (di, 'E');\n \t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n@@ -3141,7 +3215,7 @@ d_expression (struct d_info *di)\n \t\t\t\t       right, d_template_args (di));\n \t      }\n \t    else\n-\t      right = d_expression (di);\n+\t      right = d_expression_1 (di);\n \n \t    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,\n \t\t\t\td_make_comp (di,\n@@ -3157,9 +3231,9 @@ d_expression (struct d_info *di)\n \t    if (!strcmp (code, \"qu\"))\n \t      {\n \t\t/* ?: expression.  */\n-\t\tfirst = d_expression (di);\n-\t\tsecond = d_expression (di);\n-\t\tthird = d_expression (di);\n+\t\tfirst = d_expression_1 (di);\n+\t\tsecond = d_expression_1 (di);\n+\t\tthird = d_expression_1 (di);\n \t      }\n \t    else if (code[0] == 'n')\n \t      {\n@@ -3183,7 +3257,7 @@ d_expression (struct d_info *di)\n \t\telse if (d_peek_char (di) == 'i'\n \t\t\t && d_peek_next_char (di) == 'l')\n \t\t  /* initializer-list.  */\n-\t\t  third = d_expression (di);\n+\t\t  third = d_expression_1 (di);\n \t\telse\n \t\t  return NULL;\n \t      }\n@@ -3203,6 +3277,18 @@ d_expression (struct d_info *di)\n     }\n }\n \n+static struct demangle_component *\n+d_expression (struct d_info *di)\n+{\n+  struct demangle_component *ret;\n+  int was_expression = di->is_expression;\n+\n+  di->is_expression = 1;\n+  ret = d_expression_1 (di);\n+  di->is_expression = was_expression;\n+  return ret;\n+}\n+\n /* <expr-primary> ::= L <type> <(value) number> E\n                   ::= L <type> <(value) float> E\n                   ::= L <mangled-name> E\n@@ -3588,6 +3674,26 @@ d_substitution (struct d_info *di, int prefix)\n     }\n }\n \n+static void\n+d_checkpoint (struct d_info *di, struct d_info_checkpoint *checkpoint)\n+{\n+  checkpoint->n = di->n;\n+  checkpoint->next_comp = di->next_comp;\n+  checkpoint->next_sub = di->next_sub;\n+  checkpoint->did_subs = di->did_subs;\n+  checkpoint->expansion = di->expansion;\n+}\n+\n+static void\n+d_backtrack (struct d_info *di, struct d_info_checkpoint *checkpoint)\n+{\n+  di->n = checkpoint->n;\n+  di->next_comp = checkpoint->next_comp;\n+  di->next_sub = checkpoint->next_sub;\n+  di->did_subs = checkpoint->did_subs;\n+  di->expansion = checkpoint->expansion;\n+}\n+\n /* Initialize a growable string.  */\n \n static void\n@@ -3684,6 +3790,7 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n \n   dpi->saved_scopes = NULL;\n   dpi->num_saved_scopes = 0;\n+  dpi->current_template = NULL;\n }\n \n /* Free a print information structure.  */\n@@ -4165,6 +4272,12 @@ d_print_comp (struct d_print_info *dpi, int options,\n       {\n \tstruct d_print_mod *hold_dpm;\n \tstruct demangle_component *dcl;\n+\tconst struct demangle_component *hold_current;\n+\n+\t/* This template may need to be referenced by a cast operator\n+\t   contained in its subtree.  */\n+\thold_current = dpi->current_template;\n+\tdpi->current_template = dc;\n \n \t/* Don't push modifiers into a template definition.  Doing so\n \t   could give the wrong definition for a template argument.\n@@ -4201,6 +4314,7 @@ d_print_comp (struct d_print_info *dpi, int options,\n           }\n \n \tdpi->modifiers = hold_dpm;\n+\tdpi->current_template = hold_current;\n \n \treturn;\n       }\n@@ -5418,28 +5532,32 @@ static void\n d_print_cast (struct d_print_info *dpi, int options,\n               const struct demangle_component *dc)\n {\n-  if (d_left (dc)->type != DEMANGLE_COMPONENT_TEMPLATE)\n-    d_print_comp (dpi, options, d_left (dc));\n-  else\n-    {\n-      struct d_print_mod *hold_dpm;\n-      struct d_print_template dpt;\n-\n-      /* It appears that for a templated cast operator, we need to put\n-\t the template parameters in scope for the operator name, but\n-\t not for the parameters.  The effect is that we need to handle\n-\t the template printing here.  */\n-\n-      hold_dpm = dpi->modifiers;\n-      dpi->modifiers = NULL;\n+  struct d_print_template dpt;\n \n+  /* For a cast operator, we need the template parameters from\n+     the enclosing template in scope for processing the type.  */\n+  if (dpi->current_template != NULL)\n+    {\n       dpt.next = dpi->templates;\n       dpi->templates = &dpt;\n-      dpt.template_decl = d_left (dc);\n+      dpt.template_decl = dpi->current_template;\n+    }\n \n+  if (d_left (dc)->type != DEMANGLE_COMPONENT_TEMPLATE)\n+    {\n+      d_print_comp (dpi, options, d_left (dc));\n+      if (dpi->current_template != NULL)\n+\tdpi->templates = dpt.next;\n+    }\n+  else\n+    {\n       d_print_comp (dpi, options, d_left (d_left (dc)));\n \n-      dpi->templates = dpt.next;\n+      /* For a templated cast operator, we need to remove the template\n+\t parameters from scope after printing the operator name,\n+\t so we need to handle the template printing here.  */\n+      if (dpi->current_template != NULL)\n+\tdpi->templates = dpt.next;\n \n       if (d_last_char (dpi) == '<')\n \td_append_char (dpi, ' ');\n@@ -5450,8 +5568,6 @@ d_print_cast (struct d_print_info *dpi, int options,\n       if (d_last_char (dpi) == '>')\n \td_append_char (dpi, ' ');\n       d_append_char (dpi, '>');\n-\n-      dpi->modifiers = hold_dpm;\n     }\n }\n \n@@ -5484,6 +5600,8 @@ cplus_demangle_init_info (const char *mangled, int options, size_t len,\n   di->last_name = NULL;\n \n   di->expansion = 0;\n+  di->is_expression = 0;\n+  di->is_conversion = 0;\n }\n \n /* Internal implementation for the demangler.  If MANGLED is a g++ v3 ABI"}, {"sha": "6fce0252dc4d0665c6812047e9ad8fa73b0c9978", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=85d09f6173f7b6af0e156222a0534be468e3d7ca", "patch": "@@ -122,6 +122,11 @@ struct d_info\n      mangled name to the demangled name, such as standard\n      substitutions and builtin types.  */\n   int expansion;\n+  /* Non-zero if we are parsing an expression.  */\n+  int is_expression;\n+  /* Non-zero if we are parsing the type operand of a conversion\n+     operator, but not when in an expression.  */\n+  int is_conversion;\n };\n \n /* To avoid running past the ending '\\0', don't:"}, {"sha": "3ff08e6e5f2255c483122b0606116e01c299331d", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d09f6173f7b6af0e156222a0534be468e3d7ca/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=85d09f6173f7b6af0e156222a0534be468e3d7ca", "patch": "@@ -4297,3 +4297,23 @@ void f<int>()\n --format=gnu-v3\n _ZSt7forwardIRN1x14refobjiteratorINS0_3refINS0_4mime30multipart_section_processorObjIZ15get_body_parserIZZN14mime_processor21make_section_iteratorERKNS2_INS3_10sectionObjENS0_10ptrrefBaseEEEbENKUlvE_clEvEUlSB_bE_ZZNS6_21make_section_iteratorESB_bENKSC_clEvEUlSB_E0_ENS1_INS2_INS0_20outputrefiteratorObjIiEES8_EEEERKSsSB_OT_OT0_EUlmE_NS3_32make_multipart_default_discarderISP_EEEES8_EEEEEOT_RNSt16remove_referenceISW_E4typeE\n x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >& std::forward<x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >&>(std::remove_reference<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> > >::type&)\n+#\n+--format=gnu-v3 --no-params\n+_ZNK7strings8internal8SplitterINS_9delimiter5AnyOfENS_9SkipEmptyEEcvT_ISt6vectorI12basic_stringIcSt11char_traitsIcESaIcEESaISD_EEvEEv\n+strings::internal::Splitter<strings::delimiter::AnyOf, strings::SkipEmpty>::operator std::vector<basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<basic_string<char, std::char_traits<char>, std::allocator<char> > > ><std::vector<basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<basic_string<char, std::char_traits<char>, std::allocator<char> > > >, void>() const\n+strings::internal::Splitter<strings::delimiter::AnyOf, strings::SkipEmpty>::operator std::vector<basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<basic_string<char, std::char_traits<char>, std::allocator<char> > > ><std::vector<basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<basic_string<char, std::char_traits<char>, std::allocator<char> > > >, void>\n+#\n+--format=gnu-v3 --no-params\n+_ZN1AcvT_I1CEEv\n+A::operator C<C>()\n+A::operator C<C>\n+#\n+--format=gnu-v3 --no-params\n+_ZN1AcvPT_I1CEEv\n+A::operator C*<C>()\n+A::operator C*<C>\n+#\n+--format=gnu-v3 --no-params\n+_ZN1AcvT_IiEI1CEEv\n+A::operator C<int><C>()\n+A::operator C<int><C>"}]}