{"sha": "0f2907682ea0bc5a977d66aa110fe3b30119d4bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYyOTA3NjgyZWEwYmM1YTk3N2Q2NmFhMTEwZmUzYjMwMTE5ZDRiYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-25T19:17:24Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2000-09-25T19:17:24Z"}, "message": "i386.c: Fix formatting.\n\n2000-09-25  Kazu Hirata  <kazu@hxi.com>\n\n\t* config/i386/i386.c: Fix formatting.\n\nFrom-SVN: r36628", "tree": {"sha": "b5a3b97f0b6cd42cd51aaf293607284d87c6ca80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5a3b97f0b6cd42cd51aaf293607284d87c6ca80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f2907682ea0bc5a977d66aa110fe3b30119d4bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2907682ea0bc5a977d66aa110fe3b30119d4bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2907682ea0bc5a977d66aa110fe3b30119d4bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2907682ea0bc5a977d66aa110fe3b30119d4bb/comments", "author": null, "committer": null, "parents": [{"sha": "e592386fbb53765d99c2c02bc44914725a4136fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e592386fbb53765d99c2c02bc44914725a4136fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e592386fbb53765d99c2c02bc44914725a4136fb"}], "stats": {"total": 282, "additions": 140, "deletions": 142}, "files": [{"sha": "f5f2424a0b53dabbaa6a6a9b771c74b15dc8aa21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2907682ea0bc5a977d66aa110fe3b30119d4bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2907682ea0bc5a977d66aa110fe3b30119d4bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f2907682ea0bc5a977d66aa110fe3b30119d4bb", "patch": "@@ -1,3 +1,7 @@\n+2000-09-25  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/i386/i386.c: Fix formatting.\n+\n 2000-09-24  Alan Lehotsky  <alehotsky@cygnus.com>\n \n \t* emit-rtl-c (gen_lowpart_common): Accept non-paradoxical SUBREG when"}, {"sha": "efc0eaa453183739ea419812058dd31231c1b8d0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 136, "deletions": 142, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2907682ea0bc5a977d66aa110fe3b30119d4bb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2907682ea0bc5a977d66aa110fe3b30119d4bb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0f2907682ea0bc5a977d66aa110fe3b30119d4bb", "patch": "@@ -17,7 +17,7 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA. */\n+Boston, MA 02111-1307, USA.  */\n \n #include <setjmp.h>\n #include \"config.h\"\n@@ -60,7 +60,7 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2). */\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n@@ -81,7 +81,7 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2). */\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n@@ -102,7 +102,7 @@ struct processor_costs pentium_cost = {\n   6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2). */\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n@@ -123,7 +123,7 @@ struct processor_costs pentiumpro_cost = {\n   2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2). */\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n@@ -144,7 +144,7 @@ struct processor_costs k6_cost = {\n   3,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2). */\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n@@ -165,7 +165,7 @@ struct processor_costs athlon_cost = {\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2). */\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {6, 6, 20},\t\t\t\t/* cost of loading fp registers\n@@ -224,7 +224,7 @@ const char * const qi_reg_name[] = QI_REGISTER_NAMES;\n const char * const qi_high_reg_name[] = QI_HIGH_REGISTER_NAMES;\n \n /* Array of the smallest class containing reg number REGNO, indexed by\n-   REGNO.  Used by REGNO_REG_CLASS in i386.h. */\n+   REGNO.  Used by REGNO_REG_CLASS in i386.h.  */\n \n enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n {\n@@ -247,7 +247,7 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n \n /* The \"default\" register map.  */\n \n-int const dbx_register_map[FIRST_PSEUDO_REGISTER] = \n+int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n {\n   0, 2, 1, 3, 6, 7, 4, 5,\t\t/* general regs */\n   12, 13, 14, 15, 16, 17, 18, 19,\t/* fp regs */\n@@ -310,7 +310,7 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n \t17 for %st(6) (gcc regno = 14)\n \t18 for %st(7) (gcc regno = 15)\n */\n-int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] = \n+int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n {\n   0, 2, 1, 3, 6, 7, 5, 4,\t\t/* general regs */\n   11, 12, 13, 14, 15, 16, 17, 18,\t/* fp regs */\n@@ -319,8 +319,6 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   29, 30, 31, 32, 33, 34, 35, 36,\t/* MMX registers */\n };\n \n-\n-\n /* Test and compare insns in i386.md store the information needed to\n    generate branch and scc insns here.  */\n \n@@ -351,18 +349,18 @@ const char *ix86_arch_string;\t\t/* for -march=<xxx> */\n const char *ix86_reg_alloc_order;\n static char regs_allocated[FIRST_PSEUDO_REGISTER];\n \n-/* # of registers to use to pass arguments. */\n+/* # of registers to use to pass arguments.  */\n const char *ix86_regparm_string;\n \n /* ix86_regparm_string as a number */\n int ix86_regparm;\n \n /* Alignment to use for loops and jumps:  */\n \n-/* Power of two alignment for loops. */\n+/* Power of two alignment for loops.  */\n const char *ix86_align_loops_string;\n \n-/* Power of two alignment for non-loop jumps. */\n+/* Power of two alignment for non-loop jumps.  */\n const char *ix86_align_jumps_string;\n \n /* Power of two alignment for stack boundary in bytes.  */\n@@ -375,14 +373,14 @@ int ix86_preferred_stack_boundary;\n int ix86_branch_cost;\n const char *ix86_branch_cost_string;\n \n-/* Power of two alignment for functions. */\n+/* Power of two alignment for functions.  */\n int ix86_align_funcs;\n const char *ix86_align_funcs_string;\n \n-/* Power of two alignment for loops. */\n+/* Power of two alignment for loops.  */\n int ix86_align_loops;\n \n-/* Power of two alignment for non-loop jumps. */\n+/* Power of two alignment for non-loop jumps.  */\n int ix86_align_jumps;\n \f\n static void output_pic_addr_const PARAMS ((FILE *, rtx, int));\n@@ -463,7 +461,7 @@ override_options ()\n       int align_func;\n       int branch_cost;\n     }\n-  const processor_target_table[PROCESSOR_max] = \n+  const processor_target_table[PROCESSOR_max] =\n     {\n       {&i386_cost, 0, 0, 2, 2, 2, 1},\n       {&i486_cost, 0, 0, 4, 4, 4, 1},\n@@ -475,10 +473,10 @@ override_options ()\n \n   static struct pta\n     {\n-      const char *name;\t\t/* processor name or nickname. */\n+      const char *name;\t\t/* processor name or nickname.  */\n       enum processor_type processor;\n     }\n-  const processor_alias_table[] = \n+  const processor_alias_table[] =\n     {\n       {\"i386\", PROCESSOR_I386},\n       {\"i486\", PROCESSOR_I486},\n@@ -490,7 +488,7 @@ override_options ()\n       {\"athlon\", PROCESSOR_ATHLON},\n     };\n \n-  int const pta_size = sizeof(processor_alias_table)/sizeof(struct pta);\n+  int const pta_size = sizeof (processor_alias_table) / sizeof (struct pta);\n \n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n@@ -563,7 +561,7 @@ override_options ()\n \t}\n     }\n \n-  /* Validate -mregparm= value. */\n+  /* Validate -mregparm= value.  */\n   if (ix86_regparm_string)\n     {\n       ix86_regparm = atoi (ix86_regparm_string);\n@@ -592,7 +590,7 @@ override_options ()\n \t       ix86_align_jumps, MAX_CODE_ALIGN);\n     }\n \n-  /* Validate -malign-functions= value, or provide default. */\n+  /* Validate -malign-functions= value, or provide default.  */\n   ix86_align_funcs = processor_target_table[ix86_cpu].align_func;\n   if (ix86_align_funcs_string)\n     {\n@@ -613,7 +611,7 @@ override_options ()\n       ix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n     }\n \n-  /* Validate -mbranch-cost= value, or provide default. */\n+  /* Validate -mbranch-cost= value, or provide default.  */\n   ix86_branch_cost = processor_target_table[ix86_cpu].branch_cost;\n   if (ix86_branch_cost_string)\n     {\n@@ -685,7 +683,7 @@ order_regs_for_local_alloc ()\n \t}\n     }\n \n-  /* If user did not specify a register allocation order, use natural order. */\n+  /* If user did not specify a register allocation order, use natural order.  */\n   else\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -742,12 +740,12 @@ ix86_valid_type_attribute_p (type, attributes, identifier, args)\n   if (is_attribute_p (\"stdcall\", identifier))\n     return (args == NULL_TREE);\n \n-  /* Cdecl attribute says the callee is a normal C declaration. */\n+  /* Cdecl attribute says the callee is a normal C declaration.  */\n   if (is_attribute_p (\"cdecl\", identifier))\n     return (args == NULL_TREE);\n \n   /* Regparm attribute specifies how many integer arguments are to be\n-     passed in registers. */\n+     passed in registers.  */\n   if (is_attribute_p (\"regparm\", identifier))\n     {\n       tree cst;\n@@ -779,7 +777,7 @@ ix86_comp_type_attributes (type1, type2)\n      tree type1;\n      tree type2;\n {\n-  /* Check for mismatch of non-default calling convention. */\n+  /* Check for mismatch of non-default calling convention.  */\n   const char *rtdstr = TARGET_RTD ? \"cdecl\" : \"stdcall\";\n \n   if (TREE_CODE (type1) != FUNCTION_TYPE)\n@@ -817,10 +815,10 @@ ix86_return_pops_args (fundecl, funtype, size)\n {\n   int rtd = TARGET_RTD && (!fundecl || TREE_CODE (fundecl) != IDENTIFIER_NODE);\n \n-    /* Cdecl functions override -mrtd, and never pop the stack. */\n+    /* Cdecl functions override -mrtd, and never pop the stack.  */\n   if (! lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (funtype))) {\n \n-    /* Stdcall functions will pop the stack if not variable args. */\n+    /* Stdcall functions will pop the stack if not variable args.  */\n     if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (funtype)))\n       rtd = 1;\n \n@@ -961,7 +959,7 @@ function_arg (cum, mode, type, named)\n \n   switch (mode)\n     {\n-      /* For now, pass fp/complex values on the stack. */\n+      /* For now, pass fp/complex values on the stack.  */\n     default:\n       break;\n \n@@ -1117,15 +1115,15 @@ constant_call_address_operand (op, mode)\n \n /* Match exactly zero and one.  */\n \n-int \n+int\n const0_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n   return op == CONST0_RTX (mode);\n }\n \n-int \n+int\n const1_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n@@ -1164,7 +1162,7 @@ incdec_operand (op, mode)\n   return 0;\n }\n \n-/* Return false if this is the stack pointer, or any other fake \n+/* Return false if this is the stack pointer, or any other fake\n    register eliminable to the stack pointer.  Otherwise, this is\n    a register operand.\n \n@@ -1243,7 +1241,7 @@ q_regs_operand (op, mode)\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n   return QI_REG_P (op);\n-}     \n+}\n \n /* Return true if op is a NON_Q_REGS class register.  */\n \n@@ -1257,7 +1255,7 @@ non_q_regs_operand (op, mode)\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n   return NON_QI_REG_P (op);\n-}     \n+}\n \n /* Return 1 if OP is a comparison operator that can use the condition code\n    generated by a logical operation, which characteristicly does not set\n@@ -1403,7 +1401,7 @@ ext_register_operand (op, mode)\n }\n \n /* Return 1 if this is a valid binary floating-point operation.\n-   OP is the expression matched, and MODE is its mode. */\n+   OP is the expression matched, and MODE is its mode.  */\n \n int\n binary_fp_operator (op, mode)\n@@ -1523,11 +1521,11 @@ aligned_operand (op, mode)\n   if (!general_operand (op, mode))\n     return 0;\n \n-  /* Registers and immediate operands are always \"aligned\". */\n+  /* Registers and immediate operands are always \"aligned\".  */\n   if (GET_CODE (op) != MEM)\n     return 1;\n \n-  /* Don't even try to do any aligned optimizations with volatiles. */\n+  /* Don't even try to do any aligned optimizations with volatiles.  */\n   if (MEM_VOLATILE_P (op))\n     return 0;\n \n@@ -1696,7 +1694,7 @@ asm_output_function_prefix (file, name)\n   xops[0] = pic_offset_table_rtx;\n   xops[1] = stack_pointer_rtx;\n \n-  /* Deep branch prediction favors having a return for every call. */\n+  /* Deep branch prediction favors having a return for every call.  */\n   if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)\n     {\n       if (!pic_label_output)\n@@ -1706,9 +1704,9 @@ asm_output_function_prefix (file, name)\n \t     sense to have .type information for local labels.   This caused\n \t     the SCO OpenServer 5.0.4 ELF assembler grief (why are you giving\n   \t     me debug info for a label that you're declaring non-global?) this\n-\t     was changed to call ASM_OUTPUT_LABEL() instead. */\n+\t     was changed to call ASM_OUTPUT_LABEL() instead.  */\n \n-\t  ASM_OUTPUT_LABEL (file, pic_label_name); \n+\t  ASM_OUTPUT_LABEL (file, pic_label_name);\n \n \t  xops[1] = gen_rtx_MEM (SImode, xops[1]);\n \t  output_asm_insn (\"mov{l}\\t{%1, %0|%0, %1}\", xops);\n@@ -1726,15 +1724,15 @@ load_pic_register ()\n \n   if (global_offset_table_name == NULL)\n     {\n-      global_offset_table_name = \n+      global_offset_table_name =\n \tggc_alloc_string (\"_GLOBAL_OFFSET_TABLE_\", 21);\n       ggc_add_string_root (&global_offset_table_name, 1);\n     }\n   gotsym = gen_rtx_SYMBOL_REF (Pmode, global_offset_table_name);\n \n   if (TARGET_DEEP_BRANCH_PREDICTION)\n     {\n-      if (pic_label_name == NULL) \n+      if (pic_label_name == NULL)\n \t{\n \t  pic_label_name = ggc_alloc_string (NULL, 32);\n \t  ggc_add_string_root (&pic_label_name, 1);\n@@ -1801,7 +1799,7 @@ ix86_initial_elimination_offset (from, to)\n   int nregs;\n \n   /* Stack grows downward:\n-    \n+\n      [arguments]\n \t\t\t\t\t\t<- ARG_POINTER\n      saved pc\n@@ -1824,7 +1822,7 @@ ix86_initial_elimination_offset (from, to)\n   else if (from == FRAME_POINTER_REGNUM\n \t   && to == HARD_FRAME_POINTER_REGNUM)\n     {\n-      ix86_compute_frame_size (get_frame_size (), &nregs, &padding1, (int *)0);\n+      ix86_compute_frame_size (get_frame_size (), &nregs, &padding1, (int *) 0);\n       padding1 += nregs * UNITS_PER_WORD;\n       return -padding1;\n     }\n@@ -1833,8 +1831,7 @@ ix86_initial_elimination_offset (from, to)\n       /* ARG_POINTER or FRAME_POINTER to STACK_POINTER elimination.  */\n       int frame_size = frame_pointer_needed ? 8 : 4;\n       HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (),\n-\t\t\t\t\t\t     &nregs, &padding1, (int *)0);\n-\n+\t\t\t\t\t\t     &nregs, &padding1, (int *) 0);\n \n       if (to != STACK_POINTER_REGNUM)\n \tabort ();\n@@ -1849,8 +1846,8 @@ ix86_initial_elimination_offset (from, to)\n \n /* Compute the size of local storage taking into consideration the\n    desired stack alignment which is to be maintained.  Also determine\n-   the number of registers saved below the local storage.  \n- \n+   the number of registers saved below the local storage.\n+\n    PADDING1 returns padding before stack frame and PADDING2 returns\n    padding after stack frame;\n  */\n@@ -1904,7 +1901,7 @@ ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n \t      & -stack_alignment_needed) - offset;\n   total_size += padding1;\n \n-  /* Align stack boundary. */\n+  /* Align stack boundary.  */\n   padding2 = ((total_size + preferred_alignment - 1)\n \t      & -preferred_alignment) - total_size;\n \n@@ -1943,13 +1940,13 @@ ix86_emit_save_regs ()\n       }\n }\n \n-/* Expand the prologue into a bunch of separate insns. */\n+/* Expand the prologue into a bunch of separate insns.  */\n \n void\n ix86_expand_prologue ()\n {\n-  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), (int *)0, (int *)0,\n-\t\t\t\t\t\t (int *)0);\n+  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), (int *) 0, (int *) 0,\n+\t\t\t\t\t\t (int *) 0);\n   rtx insn;\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n@@ -2001,7 +1998,7 @@ ix86_expand_prologue ()\n \n #ifdef SUBTARGET_PROLOGUE\n   SUBTARGET_PROLOGUE;\n-#endif  \n+#endif\n \n   if (pic_reg_used)\n     load_pic_register ();\n@@ -2057,7 +2054,7 @@ ix86_emit_restore_regs_using_mov (pointer, offset)\n       }\n }\n \n-/* Restore function stack, frame, and registers. */\n+/* Restore function stack, frame, and registers.  */\n \n void\n ix86_expand_epilogue (emit_return)\n@@ -2071,8 +2068,7 @@ ix86_expand_epilogue (emit_return)\n   int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), &nregs,\n-\t\t\t\t\t\t (int *)0, (int *)0);\n-\n+\t\t\t\t\t\t (int *) 0, (int *) 0);\n \n   /* Calculate start of saved registers relative to ebp.  */\n   offset = -nregs * UNITS_PER_WORD;\n@@ -2086,7 +2082,7 @@ ix86_expand_epilogue (emit_return)\n \n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n-     less work than reloading sp and popping the register.  \n+     less work than reloading sp and popping the register.\n \n      The default code result in stack adjustment using add/lea instruction,\n      while this code results in LEAVE instruction (or discrete equivalent),\n@@ -2112,7 +2108,7 @@ ix86_expand_epilogue (emit_return)\n \n       if (!frame_pointer_needed)\n \tix86_emit_epilogue_esp_adjustment (tsize + nregs * UNITS_PER_WORD);\n-      /* If not an i386, mov & pop is faster than \"leave\". */\n+      /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_size)\n \temit_insn (gen_leave ());\n       else\n@@ -2156,7 +2152,7 @@ ix86_expand_epilogue (emit_return)\n \n       /* i386 can only pop 64K bytes.  If asked to pop more, pop\n \t return address, do explicit add, and jump indirectly to the\n-\t caller. */\n+\t caller.  */\n \n       if (current_function_pops_args >= 65536)\n \t{\n@@ -2286,7 +2282,7 @@ ix86_decompose_address (addr, out)\n   /* Special case: encode reg+reg instead of reg*2.  */\n   if (!base && index && scale && scale == 2)\n     base = index, scale = 1;\n-  \n+\n   /* Special case: scaling cannot be encoded without base or displacement.  */\n   if (!base && !disp && index && scale != 1)\n     disp = const0_rtx;\n@@ -2337,13 +2333,13 @@ ix86_address_cost (x)\n      since it's predecode logic can't detect the length of instructions\n      and it degenerates to vector decoded.  Increase cost of such\n      addresses here.  The penalty is minimally 2 cycles.  It may be worthwhile\n-     to split such addresses or even refuse such addresses at all.  \n+     to split such addresses or even refuse such addresses at all.\n \n      Following addressing modes are affected:\n       [base+scale*index]\n       [scale*index+disp]\n       [base+index]\n-   \n+\n      The first and last case  may be avoidable by explicitly coding the zero in\n      memory address, but I don't have AMD-K6 machine handy to check this\n      theory.  */\n@@ -2353,7 +2349,7 @@ ix86_address_cost (x)\n \t  || (parts.disp && !parts.base && parts.index && parts.scale != 1)\n \t  || (!parts.disp && parts.base && parts.index && parts.scale == 1)))\n     cost += 10;\n-      \n+\n   return cost;\n }\n \f\n@@ -2393,7 +2389,7 @@ ix86_find_base_term (x)\n \f\n /* Determine if a given CONST RTX is a valid memory displacement\n    in PIC mode.  */\n-   \n+\n int\n legitimate_pic_address_disp_p (disp)\n      register rtx disp;\n@@ -2567,8 +2563,8 @@ legitimate_address_p (mode, addr, strict)\n \t    }\n \n           /* This code used to verify that a symbolic pic displacement\n-\t     includes the pic_offset_table_rtx register. \n-\t    \n+\t     includes the pic_offset_table_rtx register.\n+\n \t     While this is good idea, unfortunately these constructs may\n \t     be created by \"adds using lea\" optimization for incorrect\n \t     code like:\n@@ -2615,14 +2611,14 @@ legitimate_address_p (mode, addr, strict)\n \f\n /* Return an unique alias set for the GOT.  */\n \n-static HOST_WIDE_INT   \n+static HOST_WIDE_INT\n ix86_GOT_alias_set ()\n {\n     static HOST_WIDE_INT set = -1;\n     if (set == -1)\n       set = new_alias_set ();\n     return set;\n-}   \n+}\n \n /* Return a legitimate reference for ORIG (an address) using the\n    register REG.  If REG is 0, a new pseudo is generated.\n@@ -2673,21 +2669,21 @@ legitimize_pic_address (orig, reg)\n   else if (GET_CODE (addr) == SYMBOL_REF)\n     {\n       /* This symbol must be referenced via a load from the\n-\t Global Offset Table (@GOT). */\n+\t Global Offset Table (@GOT).  */\n \n       current_function_uses_pic_offset_table = 1;\n       new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 6);\n       new = gen_rtx_CONST (Pmode, new);\n       new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n       new = gen_rtx_MEM (Pmode, new);\n       RTX_UNCHANGING_P (new) = 1;\n-      MEM_ALIAS_SET (new) = ix86_GOT_alias_set ();\t\n+      MEM_ALIAS_SET (new) = ix86_GOT_alias_set ();\n \n       if (reg == 0)\n \treg = gen_reg_rtx (Pmode);\n       emit_move_insn (reg, new);\n       new = reg;\n-    }      \n+    }\n   else\n     {\n       if (GET_CODE (addr) == CONST)\n@@ -2799,7 +2795,7 @@ legitimize_address (x, oldx, mode)\n \n   if (GET_CODE (x) == PLUS)\n     {\n-      /* Canonicalize shifts by 0, 1, 2, 3 into multiply. */\n+      /* Canonicalize shifts by 0, 1, 2, 3 into multiply.  */\n \n       if (GET_CODE (XEXP (x, 0)) == ASHIFT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n@@ -2821,7 +2817,7 @@ legitimize_address (x, oldx, mode)\n \t\t\t\t      GEN_INT (1 << log));\n \t}\n \n-      /* Put multiply first if it isn't already. */\n+      /* Put multiply first if it isn't already.  */\n       if (GET_CODE (XEXP (x, 1)) == MULT)\n \t{\n \t  rtx tmp = XEXP (x, 0);\n@@ -3047,10 +3043,10 @@ output_pic_addr_const (file, x, code)\n     }\n }\n \n-/* This is called from dwarfout.c via ASM_OUTPUT_DWARF_ADDR_CONST.  \n+/* This is called from dwarfout.c via ASM_OUTPUT_DWARF_ADDR_CONST.\n    We need to handle our special PIC relocations.  */\n \n-void \n+void\n i386_dwarf_output_addr_const (file, x)\n      FILE *file;\n      rtx x;\n@@ -3121,7 +3117,7 @@ put_condition_code (code, mode, reverse, fp, file)\n       /* ??? Use \"nbe\" instead of \"a\" for fcmov losage on some assemblers.\n \t Those same assemblers have the same but opposite losage on cmov.  */\n       if (mode != CCmode)\n-\tabort();\n+\tabort ();\n       suffix = fp ? \"nbe\" : \"a\";\n       break;\n     case LT:\n@@ -3130,11 +3126,11 @@ put_condition_code (code, mode, reverse, fp, file)\n       else if (mode == CCmode || mode == CCGCmode)\n \tsuffix = \"l\";\n       else\n-\tabort();\n+\tabort ();\n       break;\n     case LTU:\n       if (mode != CCmode)\n-\tabort();\n+\tabort ();\n       suffix = \"b\";\n       break;\n     case GE:\n@@ -3143,12 +3139,12 @@ put_condition_code (code, mode, reverse, fp, file)\n       else if (mode == CCmode || mode == CCGCmode)\n \tsuffix = \"ge\";\n       else\n-\tabort();\n+\tabort ();\n       break;\n     case GEU:\n       /* ??? As above.  */\n       if (mode != CCmode)\n-\tabort();\n+\tabort ();\n       suffix = fp ? \"nb\" : \"ae\";\n       break;\n     case LE:\n@@ -3301,7 +3297,7 @@ print_operand (file, x, code)\n \n \tcase 'z':\n \t  /* 387 opcodes don't get size suffixes if the operands are\n-\t     registers. */\n+\t     registers.  */\n \n \t  if (STACK_REG_P (x))\n \t    return;\n@@ -3439,7 +3435,7 @@ print_operand (file, x, code)\n       fprintf (file, \"0x%lx\", l);\n     }\n \n- /* These float cases don't actually occur as immediate operands. */\n+ /* These float cases don't actually occur as immediate operands.  */\n  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n     {\n       REAL_VALUE_TYPE r;\n@@ -3604,7 +3600,7 @@ print_operand_address (file, addr)\n    references.  The RTL can be REG, offsettable MEM, integer constant, or\n    CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n    split and \"num\" is its length.  lo_half and hi_half are output arrays\n-   that parallel \"operands\". */\n+   that parallel \"operands\".  */\n \n void\n split_di (operands, num, lo_half, hi_half)\n@@ -3645,7 +3641,7 @@ split_di (operands, num, lo_half, hi_half)\n    emitted here, or returned to the caller, like all output_* functions.\n \n    There is no guarantee that the operands are the same mode, as they\n-   might be within FLOAT or FLOAT_EXTEND expressions. */\n+   might be within FLOAT or FLOAT_EXTEND expressions.  */\n \n #ifndef SYSV386_COMPAT\n /* Set to 1 for compatibility with brain-damaged assemblers.  No-one\n@@ -3975,13 +3971,13 @@ output_fp_compare (insn, operands, eflags_p, unordered_p)\n     {\n       /* Encoded here as eflags_p | intmode | unordered_p | stack_top_dies.  */\n \n-      static const char * const alt[24] = \n+      static const char * const alt[24] =\n       {\n \t\"fcom%z1\\t%y1\",\n \t\"fcomp%z1\\t%y1\",\n \t\"fucom%z1\\t%y1\",\n \t\"fucomp%z1\\t%y1\",\n-\t\n+\n \t\"ficom%z1\\t%y1\",\n \t\"ficomp%z1\\t%y1\",\n \tNULL,\n@@ -4001,7 +3997,7 @@ output_fp_compare (insn, operands, eflags_p, unordered_p)\n \t\"fcomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n \t\"fucom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n \t\"fucomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\n+\n \t\"ficom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n \t\"ficomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n \tNULL,\n@@ -4037,7 +4033,7 @@ output_fp_compare (insn, operands, eflags_p, unordered_p)\n \tof the function.\n \n \tThe name of the block is a local symbol made with this statement:\n-\t\n+\n \t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n \n \tOf course, since you are writing the definition of\n@@ -4159,12 +4155,12 @@ ix86_output_function_block_profiler (file, block_or_label)\n \n \t`__bb' consists of two words. In the first word the number\n \tof the basic block has to be stored. In the second word\n-\tthe address of a block allocated in the object module \n+\tthe address of a block allocated in the object module\n \thas to be stored.\n \n \tThe basic block number is given by BLOCKNO.\n \n-\tThe address of the block is given by the label created with \n+\tThe address of the block is given by the label created with\n \n \t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n \n@@ -4188,23 +4184,23 @@ ix86_output_function_block_profiler (file, block_or_label)\n \teither in this macro or in the macros MACHINE_STATE_SAVE\n \tand MACHINE_STATE_RESTORE. The last two macros will be\n \tused in the function `__bb_trace_func', so you must make\n-\tsure that the function prologue does not change any \n+\tsure that the function prologue does not change any\n \tregister prior to saving it with MACHINE_STATE_SAVE.\n \n    else if profile_block_flag != 0\n \n \tOutput code to increment the counter directly.\n \tBasic blocks are numbered separately from zero within each\n \tcompiled object module. The count associated with block number\n-\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n+\tBLOCKNO is at index BLOCKNO in an array of words; the name of\n \tthis array is a local symbol made with this statement:\n \n \t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n \n \tOf course, since you are writing the definition of\n \t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n \tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result. \n+\tname that you know will result.\n \n \tIf described in a virtual assembler language the code to be\n \toutput looks like:\n@@ -4368,7 +4364,7 @@ ix86_expand_binary_operator (code, mode, operands)\n       else\n \tdst = gen_reg_rtx (mode);\n     }\n-  \n+\n   /* Both source operands cannot be in memory.  */\n   if (GET_CODE (src1) == MEM && GET_CODE (src2) == MEM)\n     {\n@@ -4380,11 +4376,11 @@ ix86_expand_binary_operator (code, mode, operands)\n \n   /* If the operation is not commutable, source 1 cannot be a constant\n      or non-matching memory.  */\n-  if ((CONSTANT_P (src1) \n+  if ((CONSTANT_P (src1)\n        || (!matching_memory && GET_CODE (src1) == MEM))\n       && GET_RTX_CLASS (code) != 'c')\n     src1 = force_reg (mode, src1);\n-    \n+\n   /* If optimizing, copy to regs to improve CSE */\n   if (optimize && ! no_new_pseudos)\n     {\n@@ -4478,7 +4474,7 @@ ix86_expand_unary_operator (code, mode, operands)\n   /* When source operand is memory, destination must match.  */\n   if (!matching_memory && GET_CODE (src) == MEM)\n     src = force_reg (mode, src);\n-  \n+\n   /* If optimizing, copy to regs to improve CSE */\n   if (optimize && ! no_new_pseudos)\n     {\n@@ -4713,7 +4709,7 @@ ix86_cc_mode (code, op0, op1)\n       else\n \treturn CCGCmode;\n     default:\n-      abort();\n+      abort ();\n     }\n }\n \n@@ -4730,7 +4726,7 @@ ix86_use_fcomi_compare (code)\n \t      || ix86_fp_compare_mode (code) == CCFPmode));\n }\n \n-/* Swap, force into registers, or otherwise massage the two operands \n+/* Swap, force into registers, or otherwise massage the two operands\n    to a fp comparison.  The operands are updated in place; the new\n    comparsion code is returned.  */\n \n@@ -4865,8 +4861,8 @@ ix86_expand_fp_compare (code, op0, op1, scratch)\n \t\t  code = NE;\n \t\t  break;\n \t\tcase GE:\n-\t\t  /* We'd have to use `xorb 1,ah; andb 0x41,ah', so it's \n-\t\t     faster in all cases to just fall back on sahf. */\n+\t\t  /* We'd have to use `xorb 1,ah; andb 0x41,ah', so it's\n+\t\t     faster in all cases to just fall back on sahf.  */\n \t\t  goto do_sahf;\n \t\tcase LE:\n \t\t  mask = 0x41;\n@@ -5027,7 +5023,7 @@ ix86_expand_branch (code, label)\n \n     case SFmode:\n     case DFmode:\n-    case XFmode:   \n+    case XFmode:\n       /* Don't expand the comparison early, so that we get better code\n \t when jump or whoever decides to reverse the comparison.  */\n       {\n@@ -5254,7 +5250,7 @@ ix86_expand_int_movcc (operands)\n       && GET_CODE (ix86_compare_op1) == CONST_INT\n       && GET_MODE (operands[0]) != HImode\n       && (unsigned int)INTVAL (ix86_compare_op1) != 0xffffffff\n-      && GET_CODE (operands[2]) == CONST_INT \n+      && GET_CODE (operands[2]) == CONST_INT\n       && GET_CODE (operands[3]) == CONST_INT)\n     {\n       if (code == LEU)\n@@ -5275,7 +5271,7 @@ ix86_expand_int_movcc (operands)\n      HImode insns, we'd be swallowed in word prefix ops.  */\n \n   if (GET_MODE (operands[0]) != HImode\n-      && GET_CODE (operands[2]) == CONST_INT \n+      && GET_CODE (operands[2]) == CONST_INT\n       && GET_CODE (operands[3]) == CONST_INT)\n     {\n       rtx out = operands[0];\n@@ -5289,7 +5285,7 @@ ix86_expand_int_movcc (operands)\n \t  /* Detect overlap between destination and compare sources.  */\n \t  rtx tmp = out;\n \n-\t  /* To simplify rest of code, restrict to the GEU case. */\n+\t  /* To simplify rest of code, restrict to the GEU case.  */\n \t  if (compare_code == LTU)\n \t    {\n \t      int tmp = ct;\n@@ -5444,7 +5440,7 @@ ix86_expand_int_movcc (operands)\n        *   decl dest\t\t\tmovl cf, dest\n        *   andl (cf-ct),dest\t\t1:\n        *   addl ct,dest\n-       * \n+       *\n        * Size 20.\t\t\tSize 14.\n        *\n        * This is reasonably steep, but branch mispredict costs are\n@@ -5489,9 +5485,9 @@ ix86_expand_int_movcc (operands)\n       if (optimize_size)\n \treturn 0; /* FAIL */\n \n-      /* If one of the two operands is an interesting constant, load a \n+      /* If one of the two operands is an interesting constant, load a\n \t constant with the above and mask it in with a logical operation.  */\n-\t \n+\n       if (GET_CODE (operands[2]) == CONST_INT)\n \t{\n \t  var = operands[3];\n@@ -5566,7 +5562,7 @@ ix86_expand_fp_movcc (operands)\n   rtx tmp;\n \n   /* The floating point conditional move instructions don't directly\n-     support conditions resulting from a signed integer comparison. */\n+     support conditions resulting from a signed integer comparison.  */\n \n   code = GET_CODE (operands[1]);\n   switch (code)\n@@ -5694,7 +5690,7 @@ ix86_split_to_parts (operand, parts, mode)\n    insns have been emitted.  Operands 2-4 contain the input values\n    int the correct order; operands 5-7 contain the output values.  */\n \n-int \n+int\n ix86_split_long_move (operands1)\n      rtx operands1[];\n {\n@@ -5730,7 +5726,7 @@ ix86_split_long_move (operands1)\n       part[1][0] = part[1][1];\n     }\n \n-  /* We need to do copy in the right order in case an address register \n+  /* We need to do copy in the right order in case an address register\n      of the source overlaps the destination.  */\n   if (REG_P (part[0][0]) && GET_CODE (part[1][0]) == MEM)\n     {\n@@ -6055,11 +6051,11 @@ ix86_expand_strlensi_unroll_1 (out, align_rtx, scratch)\n \n       /* Now compare the bytes.  */\n \n-      /* Compare the first n unaligned byte on a byte per byte basis. */\n+      /* Compare the first n unaligned byte on a byte per byte basis.  */\n       emit_cmp_and_jump_insns (mem, const0_rtx, EQ, NULL,\n \t\t\t       QImode, 1, 0, end_0_label);\n \n-      /* Increment the address. */\n+      /* Increment the address.  */\n       emit_insn (gen_addsi3 (out, out, const1_rtx));\n \n       /* Not needed with an alignment of 2 */\n@@ -6106,13 +6102,13 @@ ix86_expand_strlensi_unroll_1 (out, align_rtx, scratch)\n        emit_move_insn (reg, tmpreg);\n        emit_insn (gen_lshrsi3 (reg, reg, GEN_INT (16)));\n \n-       /* If zero is not in the first two bytes, move two bytes forward. */\n+       /* If zero is not in the first two bytes, move two bytes forward.  */\n        emit_insn (gen_testsi_ccno_1 (tmpreg, GEN_INT (0x8080)));\n        tmp = gen_rtx_REG (CCNOmode, FLAGS_REG);\n        tmp = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n        emit_insn (gen_rtx_SET (VOIDmode, tmpreg,\n \t\t\t       gen_rtx_IF_THEN_ELSE (SImode, tmp,\n-\t\t\t\t       \t\t     reg, \n+\t\t\t\t       \t\t     reg,\n \t\t\t\t       \t\t     tmpreg)));\n        /* Emit lea manually to avoid clobbering of flags.  */\n        emit_insn (gen_rtx_SET (SImode, reg,\n@@ -6140,15 +6136,15 @@ ix86_expand_strlensi_unroll_1 (out, align_rtx, scratch)\n        tmp = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n        JUMP_LABEL (tmp) = end_2_label;\n \n-       /* Not in the first two.  Move two bytes forward. */\n+       /* Not in the first two.  Move two bytes forward.  */\n        emit_insn (gen_lshrsi3 (tmpreg, tmpreg, GEN_INT (16)));\n        emit_insn (gen_addsi3 (out, out, GEN_INT (2)));\n \n        emit_label (end_2_label);\n \n     }\n \n-  /* Avoid branch in fixing the byte. */\n+  /* Avoid branch in fixing the byte.  */\n   tmpreg = gen_lowpart (QImode, tmpreg);\n   emit_insn (gen_addqi3_cc (tmpreg, tmpreg, tmpreg));\n   emit_insn (gen_subsi3_carry (out, out, GEN_INT (3)));\n@@ -6471,14 +6467,14 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n \tcost = 0;\n \n       /* Floating point stores require value to be ready one cycle ealier.  */\n-      if (insn_type == TYPE_FMOV \n+      if (insn_type == TYPE_FMOV\n \t  && get_attr_memory (insn) == MEMORY_STORE\n \t  && !ix86_agi_dependant (insn, dep_insn, insn_type))\n \tcost += 1;\n       break;\n \n     case PROCESSOR_PENTIUMPRO:\n-      /* Since we can't represent delayed latencies of load+operation, \n+      /* Since we can't represent delayed latencies of load+operation,\n \t increase the cost here for non-imov insns.  */\n       if (dep_insn_type != TYPE_IMOV\n \t  && dep_insn_type != TYPE_FMOV\n@@ -6506,7 +6502,7 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n \t  && (dep_insn_type == TYPE_PUSH || dep_insn_type == TYPE_POP))\n \treturn 1;\n \n-      /* Since we can't represent delayed latencies of load+operation, \n+      /* Since we can't represent delayed latencies of load+operation,\n \t increase the cost here for non-imov insns.  */\n       if ((memory = get_attr_memory (dep_insn) == MEMORY_LOAD)\n           || memory == MEMORY_BOTH)\n@@ -6628,7 +6624,7 @@ ix86_reorder_insn (insnp, slot)\n   if (insnp != slot)\n     {\n       rtx insn = *insnp;\n-      do \n+      do\n \tinsnp[0] = insnp[1];\n       while (++insnp != slot);\n       *insnp = insn;\n@@ -6676,7 +6672,7 @@ ix86_pent_find_pair (e_ready, ready, type, first)\n \t       cycles longer.  */\n \t    if (memory == MEMORY_BOTH && second_memory == MEMORY_BOTH)\n \t      currentcycles += 2;\n-  \n+\n \t    /* Read modify/write instruction followed by read/modify\n \t       takes one cycle longer.  */\n \t    if (memory == MEMORY_BOTH && second_memory == MEMORY_LOAD\n@@ -6769,13 +6765,13 @@ ix86_sched_reorder_ppro (ready, e_ready)\n   rtx *insnp;\n   int i;\n \n-  /* At this point .ppro.decode contains the state of the three \n+  /* At this point .ppro.decode contains the state of the three\n      decoders from last \"cycle\".  That is, those insns that were\n-     actually independent.  But here we're scheduling for the \n+     actually independent.  But here we're scheduling for the\n      decoder, and we may find things that are decodable in the\n      same cycle.  */\n \n-  memcpy (decode, ix86_sched_data.ppro.decode, sizeof(decode));\n+  memcpy (decode, ix86_sched_data.ppro.decode, sizeof (decode));\n   issued_this_cycle = 0;\n \n   insnp = e_ready;\n@@ -6843,8 +6839,7 @@ ix86_sched_reorder_ppro (ready, e_ready)\n   ix86_sched_data.ppro.issued_this_cycle = issued_this_cycle;\n }\n \n-  \n-/* We are about to being issuing insns for this clock cycle.  \n+/* We are about to being issuing insns for this clock cycle.\n    Override the default sort algorithm to better slot instructions.  */\n int\n ix86_sched_reorder (dump, sched_verbose, ready, n_ready, clock_var)\n@@ -6991,7 +6986,7 @@ ix86_data_alignment (type, align)\n     }\n   else if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n-      \n+\n       if (TYPE_MODE (type) == DCmode && align < 64)\n \treturn 64;\n       if (TYPE_MODE (type) == XCmode && align < 128)\n@@ -7056,7 +7051,7 @@ ix86_local_alignment (type, align)\n   else if (TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == VECTOR_TYPE\n \t   || TREE_CODE (type) == INTEGER_TYPE)\n     {\n-      \n+\n       if (TYPE_MODE (type) == DFmode && align < 64)\n \treturn 64;\n       if (ALIGN_MODE_128 (TYPE_MODE (type)) && align < 128)\n@@ -7443,7 +7438,7 @@ ix86_init_builtins ()\n     = build_function_type (V4SF_type_node,\n \t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n \t\t\t\t      endlink));\n-\t\t\t   \n+\n   /* Normal vector binops.  */\n   tree v4sf_ftype_v4sf_v4sf\n     = build_function_type (V4SF_type_node,\n@@ -7517,7 +7512,7 @@ ix86_init_builtins ()\n \tdefault:\n \t  abort ();\n \t}\n-      \n+\n       /* Override for comparisons.  */\n       if (d->icode == CODE_FOR_maskcmpv4sf3\n \t  || d->icode == CODE_FOR_maskncmpv4sf3\n@@ -7552,7 +7547,7 @@ ix86_init_builtins ()\n   /* Everything beyond this point is SSE only.  */\n   if (! TARGET_SSE)\n     return;\n-  \n+\n   /* comi/ucomi insns.  */\n   for (i = 0, d = bdesc_comi; i < sizeof (bdesc_comi) / sizeof *d; i++, d++)\n     def_builtin (d->name, int_ftype_v4sf_v4sf, d->code);\n@@ -8040,7 +8035,7 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n     case IX86_BUILTIN_STORESS:\n       return ix86_expand_store_builtin (CODE_FOR_sse_storess, arglist, -1);\n \n-    case IX86_BUILTIN_LOADHPS:      \n+    case IX86_BUILTIN_LOADHPS:\n     case IX86_BUILTIN_LOADLPS:\n       icode = (fcode == IX86_BUILTIN_LOADHPS\n \t       ? CODE_FOR_sse_movhps : CODE_FOR_sse_movlps);\n@@ -8064,7 +8059,7 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn 0;\n       emit_insn (pat);\n       return target;\n-      \n+\n     case IX86_BUILTIN_STOREHPS:\n     case IX86_BUILTIN_STORELPS:\n       icode = (fcode == IX86_BUILTIN_STOREHPS\n@@ -8125,7 +8120,7 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn 0;\n       emit_insn (pat);\n       return target;\n-  \n+\n     case IX86_BUILTIN_SHUFPS:\n       icode = CODE_FOR_sse_shufps;\n       arg0 = TREE_VALUE (arglist);\n@@ -8198,7 +8193,7 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n \t\t\t\t\t\t      XEXP (target, 0))));\n       emit_insn (gen_sse_shufps (op0, op0, op0, GEN_INT (0)));\n       return op0;\n-      \n+\n     case IX86_BUILTIN_SETPS:\n       target = assign_386_stack_local (V4SFmode, 0);\n       op0 = change_address (target, SFmode, XEXP (target, 0));\n@@ -8265,13 +8260,12 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n   for (i = 0, d = bdesc_1arg; i < sizeof (bdesc_1arg) / sizeof *d; i++, d++)\n     if (d->code == fcode)\n       return ix86_expand_unop_builtin (d->icode, arglist, target, 0);\n-  \n+\n   for (i = 0, d = bdesc_comi; i < sizeof (bdesc_comi) / sizeof *d; i++, d++)\n     if (d->code == fcode)\n       return ix86_expand_sse_comi (d, arglist, target);\n-  \n+\n  fail:\n   /* @@@ Should really do something sensible here.  */\n   return 0;\n-  \n }"}]}