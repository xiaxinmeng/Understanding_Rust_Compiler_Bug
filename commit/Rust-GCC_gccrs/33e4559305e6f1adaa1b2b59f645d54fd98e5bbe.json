{"sha": "33e4559305e6f1adaa1b2b59f645d54fd98e5bbe", "node_id": "C_kwDOANBUbNoAKDMzZTQ1NTkzMDVlNmYxYWRhYTFiMmI1OWY2NDVkNTRmZDk4ZTViYmU", "commit": {"author": {"name": "Takayuki 'January June' Suwa", "email": "jjsuwa_sys3175@yahoo.co.jp", "date": "2023-01-27T03:17:33Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2023-02-23T22:31:39Z"}, "message": "xtensa: Eliminate the use of callee-saved register that saves and restores only once\n\nIn the case of the CALL0 ABI, values that must be retained before and\nafter function calls are placed in the callee-saved registers (A12\nthrough A15) and referenced later.  However, it is often the case that\nthe save and the reference are each only once and a simple register-\nregister move (with two exceptions; i. the register saved to/restored\nfrom is the stack pointer, ii. the function needs an additional stack\npointer adjustment to grow the stack).\n\ne.g. in the following example, if there are no other occurrences of\nregister A14:\n\n;; before\n\t; prologue {\n  ...\n\ts32i.n\ta14, sp, 16\n  ...\t\t\t\t;; no frame pointer needed\n\t\t\t\t;; no additional stack growth\n\t; } prologue\n  ...\n\tmov.n\ta14, a6\t\t;; A6 is not SP\n  ...\n\tcall0\tfoo\n  ...\n\tmov.n\ta8, a14\t\t;; A8 is not SP\n  ...\n\t; epilogue {\n  ...\n\tl32i.n\ta14, sp, 16\n  ...\n\t; } epilogue\n\nIt can be possible like this:\n\n;; after\n\t; prologue {\n  ...\n\t(no save needed)\n  ...\n\t; } prologue\n  ...\n\ts32i.n\ta6, sp, 16\t;; replaced with A14's slot\n  ...\n\tcall0\tfoo\n  ...\n\tl32i.n\ta8, sp, 16\t;; through SP\n  ...\n\t; epilogue {\n  ...\n\t(no restoration needed)\n  ...\n\t; } epilogue\n\nThis patch adds the abovementioned logic to the function prologue/epilogue\nRTL expander code.\n\ngcc/ChangeLog:\n\n\t* config/xtensa/xtensa.cc (machine_function): Add new member\n\t'eliminated_callee_saved_bmp'.\n\t(xtensa_can_eliminate_callee_saved_reg_p): New function to\n\tdetermine whether the register can be eliminated or not.\n\t(xtensa_expand_prologue): Add invoking the above function and\n\telimination the use of callee-saved register by using its stack\n\tslot through the stack pointer (or the frame pointer if needed)\n\tdirectly.\n\t(xtensa_expand_prologue): Modify to not emit register restoration\n\tinsn from its stack slot if the register is already eliminated.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/xtensa/elim_callee_saved.c: New.", "tree": {"sha": "9fcc90b296dfcd754ee999d384eb85aadbcead7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fcc90b296dfcd754ee999d384eb85aadbcead7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe/comments", "author": {"login": "jjsuwa-sys3175", "id": 73290592, "node_id": "MDQ6VXNlcjczMjkwNTky", "avatar_url": "https://avatars.githubusercontent.com/u/73290592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjsuwa-sys3175", "html_url": "https://github.com/jjsuwa-sys3175", "followers_url": "https://api.github.com/users/jjsuwa-sys3175/followers", "following_url": "https://api.github.com/users/jjsuwa-sys3175/following{/other_user}", "gists_url": "https://api.github.com/users/jjsuwa-sys3175/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjsuwa-sys3175/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjsuwa-sys3175/subscriptions", "organizations_url": "https://api.github.com/users/jjsuwa-sys3175/orgs", "repos_url": "https://api.github.com/users/jjsuwa-sys3175/repos", "events_url": "https://api.github.com/users/jjsuwa-sys3175/events{/privacy}", "received_events_url": "https://api.github.com/users/jjsuwa-sys3175/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7423f5b56ad436f51ac1b9defb954e2bdc5b06ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7423f5b56ad436f51ac1b9defb954e2bdc5b06ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7423f5b56ad436f51ac1b9defb954e2bdc5b06ab"}], "stats": {"total": 170, "additions": 145, "deletions": 25}, "files": [{"sha": "e52fba0825509a606048707c927e52aa812d8c47", "filename": "gcc/config/xtensa/xtensa.cc", "status": "modified", "additions": 107, "deletions": 25, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc?ref=33e4559305e6f1adaa1b2b59f645d54fd98e5bbe", "patch": "@@ -105,6 +105,7 @@ struct GTY(()) machine_function\n   bool epilogue_done;\n   bool inhibit_logues_a1_adjusts;\n   rtx last_logues_a9_content;\n+  HOST_WIDE_INT eliminated_callee_saved_bmp;\n };\n \n static void xtensa_option_override (void);\n@@ -3346,6 +3347,66 @@ xtensa_emit_adjust_stack_ptr (HOST_WIDE_INT offset, int flags)\n     cfun->machine->last_logues_a9_content = GEN_INT (offset);\n }\n \n+static bool\n+xtensa_can_eliminate_callee_saved_reg_p (unsigned int regno,\n+\t\t\t\t\t rtx_insn **p_insnS,\n+\t\t\t\t\t rtx_insn **p_insnR)\n+{\n+  df_ref ref;\n+  rtx_insn *insn, *insnS = NULL, *insnR = NULL;\n+  rtx pattern;\n+\n+  if (!optimize || !df || call_used_or_fixed_reg_p (regno))\n+    return false;\n+\n+  for (ref = DF_REG_DEF_CHAIN (regno);\n+       ref; ref = DF_REF_NEXT_REG (ref))\n+    if (DF_REF_CLASS (ref) != DF_REF_REGULAR\n+\t|| DEBUG_INSN_P (insn = DF_REF_INSN (ref)))\n+      continue;\n+    else if (GET_CODE (pattern = PATTERN (insn)) == SET\n+\t     && REG_P (SET_DEST (pattern))\n+\t     && REGNO (SET_DEST (pattern)) == regno\n+\t     && REG_NREGS (SET_DEST (pattern)) == 1\n+\t     && REG_P (SET_SRC (pattern))\n+\t     && REGNO (SET_SRC (pattern)) != A1_REG)\n+      {\n+\tif (insnS)\n+\t  return false;\n+\tinsnS = insn;\n+\tcontinue;\n+      }\n+    else\n+      return false;\n+\n+  for (ref = DF_REG_USE_CHAIN (regno);\n+       ref; ref = DF_REF_NEXT_REG (ref))\n+    if (DF_REF_CLASS (ref) != DF_REF_REGULAR\n+\t|| DEBUG_INSN_P (insn = DF_REF_INSN (ref)))\n+      continue;\n+    else if (GET_CODE (pattern = PATTERN (insn)) == SET\n+\t     && REG_P (SET_SRC (pattern))\n+\t     && REGNO (SET_SRC (pattern)) == regno\n+\t     && REG_NREGS (SET_SRC (pattern)) == 1\n+\t     && REG_P (SET_DEST (pattern))\n+\t     && REGNO (SET_DEST (pattern)) != A1_REG)\n+      {\n+\tif (insnR)\n+\t  return false;\n+\tinsnR = insn;\n+\tcontinue;\n+      }\n+    else\n+      return false;\n+\n+  if (!insnS || !insnR)\n+    return false;\n+\n+  *p_insnS = insnS, *p_insnR = insnR;\n+\n+  return true;\n+}\n+\n /* minimum frame = reg save area (4 words) plus static chain (1 word)\n    and the total number of words must be a multiple of 128 bits.  */\n #define MIN_FRAME_SIZE (8 * UNITS_PER_WORD)\n@@ -3385,6 +3446,7 @@ xtensa_expand_prologue (void)\n       df_ref ref;\n       bool stack_pointer_needed = frame_pointer_needed\n \t\t\t\t  || crtl->calls_eh_return;\n+      bool large_stack_needed;\n \n       /* Check if the function body really needs the stack pointer.  */\n       if (!stack_pointer_needed && df)\n@@ -3433,23 +3495,41 @@ xtensa_expand_prologue (void)\n \t    }\n \t}\n \n+      large_stack_needed = total_size > 1024\n+\t\t\t   || (!callee_save_size && total_size > 128);\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n-\t{\n-\t  if (xtensa_call_save_reg(regno))\n-\t    {\n-\t      rtx x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (offset));\n-\t      rtx mem = gen_frame_mem (SImode, x);\n-\t      rtx reg = gen_rtx_REG (SImode, regno);\n+\tif (xtensa_call_save_reg(regno))\n+\t  {\n+\t    rtx x = gen_rtx_PLUS (Pmode,\n+\t\t\t\t  stack_pointer_rtx, GEN_INT (offset));\n+\t    rtx mem = gen_frame_mem (SImode, x);\n+\t    rtx_insn *insnS, *insnR;\n+\n+\t    if (!large_stack_needed\n+\t\t&& xtensa_can_eliminate_callee_saved_reg_p (regno,\n+\t\t\t\t\t\t\t    &insnS, &insnR))\n+\t      {\n+\t\tif (frame_pointer_needed)\n+\t\t  mem = replace_rtx (mem, stack_pointer_rtx,\n+\t\t\t\t     hard_frame_pointer_rtx);\n+\t\tSET_DEST (PATTERN (insnS)) = mem;\n+\t\tdf_insn_rescan (insnS);\n+\t\tSET_SRC (PATTERN (insnR)) = copy_rtx (mem);\n+\t\tdf_insn_rescan (insnR);\n+\t\tcfun->machine->eliminated_callee_saved_bmp |= 1 << regno;\n+\t      }\n+\t    else\n+\t      {\n+\t\trtx reg = gen_rtx_REG (SImode, regno);\n \n-\t      offset -= UNITS_PER_WORD;\n-\t      insn = emit_move_insn (mem, reg);\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\t\t    gen_rtx_SET (mem, reg));\n-\t    }\n-\t}\n-      if (total_size > 1024\n-\t  || (!callee_save_size && total_size > 128))\n+\t\tinsn = emit_move_insn (mem, reg);\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t\tadd_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t      gen_rtx_SET (mem, reg));\n+\t      }\n+\t    offset -= UNITS_PER_WORD;\n+\t  }\n+      if (large_stack_needed)\n \txtensa_emit_adjust_stack_ptr (callee_save_size - total_size,\n \t\t\t\t      ADJUST_SP_NEED_NOTE);\n     }\n@@ -3538,16 +3618,18 @@ xtensa_expand_epilogue (bool sibcall_p)\n \temit_insn (gen_blockage ());\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n-\t{\n-\t  if (xtensa_call_save_reg(regno))\n-\t    {\n-\t      rtx x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (offset));\n-\n-\t      offset -= UNITS_PER_WORD;\n-\t      emit_move_insn (gen_rtx_REG (SImode, regno),\n-\t\t\t      gen_frame_mem (SImode, x));\n-\t    }\n-\t}\n+\tif (xtensa_call_save_reg(regno))\n+\t  {\n+\t    if (! (cfun->machine->eliminated_callee_saved_bmp\n+\t\t   & (1 << regno)))\n+\t      {\n+\t\trtx x = gen_rtx_PLUS (Pmode,\n+\t\t\t\t      stack_pointer_rtx, GEN_INT (offset));\n+\t\temit_move_insn (gen_rtx_REG (SImode, regno),\n+\t\t\t\tgen_frame_mem (SImode, x));\n+\t      }\n+\t    offset -= UNITS_PER_WORD;\n+\t  }\n \n       if (cfun->machine->current_frame_size > 0)\n \t{"}, {"sha": "cd3d6b9f2496fbfe6f09302e280c3c012c32ef26", "filename": "gcc/testsuite/gcc.target/xtensa/elim_callee_saved.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe/gcc%2Ftestsuite%2Fgcc.target%2Fxtensa%2Felim_callee_saved.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e4559305e6f1adaa1b2b59f645d54fd98e5bbe/gcc%2Ftestsuite%2Fgcc.target%2Fxtensa%2Felim_callee_saved.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fxtensa%2Felim_callee_saved.c?ref=33e4559305e6f1adaa1b2b59f645d54fd98e5bbe", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mabi=call0\" } */\n+\n+extern void foo(void);\n+\n+/* eliminated one register (the reservoir of variable 'a') by its stack slot through the stack pointer.  */\n+int test0(int a) {\n+  int array[252];  /* the maximum bound of non-large stack.  */\n+  foo();\n+  asm volatile(\"\" : : \"m\"(array));\n+  return a;\n+}\n+\n+/* cannot eliminate if large stack is needed, because the offset from TOS cannot fit into single L32I/S32I instruction.  */\n+int test1(int a) {\n+  int array[10000];  /* requires large stack.  */\n+  foo();\n+  asm volatile(\"\" : : \"m\"(array));\n+  return a;\n+}\n+\n+/* register A15 is the reservoir of the stack pointer and cannot be eliminated if the frame pointer is needed.\n+   other registers still can be, but through the frame pointer rather the stack pointer.  */\n+int test2(int a) {\n+  int* p = __builtin_alloca(16);\n+  foo();\n+  asm volatile(\"\" : : \"r\"(p));\n+  return a;\n+}\n+\n+/* in -O0 the composite hard registers may still remain unsplitted at pro_and_epilogue and must be excluded.  */\n+extern double bar(void);\n+int __attribute__((optimize(0))) test3(int a) {\n+  return bar() + a;\n+}\n+\n+/* { dg-final { scan-assembler-times \"mov\\t|mov.n\\t\" 21 } } */\n+/* { dg-final { scan-assembler-times \"a15, 8\" 2 } } */"}]}