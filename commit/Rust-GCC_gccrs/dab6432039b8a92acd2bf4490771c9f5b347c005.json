{"sha": "dab6432039b8a92acd2bf4490771c9f5b347c005", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFiNjQzMjAzOWI4YTkyYWNkMmJmNDQ5MDc3MWM5ZjViMzQ3YzAwNQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2020-05-10T11:27:02Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-07T09:26:54Z"}, "message": "[Ada] Ada2020: AI12-0198 potentially unevaluated components of arrays\n\ngcc/ada/\n\n\t* sem_util.ads (Interval_Lists): Reordering routine.\n\t* sem_util.adb (Interval_Lists): Reordering routines to keep\n\tthem alphabetically ordered.", "tree": {"sha": "bae008821158ddedaffe2a6dd5fd075a84ca867c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bae008821158ddedaffe2a6dd5fd075a84ca867c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dab6432039b8a92acd2bf4490771c9f5b347c005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab6432039b8a92acd2bf4490771c9f5b347c005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dab6432039b8a92acd2bf4490771c9f5b347c005", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab6432039b8a92acd2bf4490771c9f5b347c005/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ea624b0f9957a454467bfd0c856b87c90012cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea624b0f9957a454467bfd0c856b87c90012cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ea624b0f9957a454467bfd0c856b87c90012cf4"}], "stats": {"total": 433, "additions": 239, "deletions": 194}, "files": [{"sha": "9383c5f6d0df46939dc3c37c81305289975e7357", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 234, "deletions": 189, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab6432039b8a92acd2bf4490771c9f5b347c005/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab6432039b8a92acd2bf4490771c9f5b347c005/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=dab6432039b8a92acd2bf4490771c9f5b347c005", "patch": "@@ -28897,6 +28897,16 @@ package body Sem_Util is\n       --  Check that list is sorted, lacks null intervals, and has gaps\n       --  between intervals.\n \n+      function Chosen_Interval (Choice : Node_Id) return Discrete_Interval;\n+      --  Given an element of a Discrete_Choices list, a\n+      --  Static_Discrete_Predicate list, or an Others_Discrete_Choices\n+      --  list (but not an N_Others_Choice node) return the corresponding\n+      --  interval. If an element that does not represent a single\n+      --  contiguous interval due to a static predicate (or which\n+      --  represents a single contiguous interval whose bounds depend on\n+      --  a static predicate) is encountered, then that is an error on the\n+      --  part of whoever built the list in question.\n+\n       function In_Interval\n         (Value : Uint; Interval : Discrete_Interval) return Boolean;\n       --  Does the given value lie within the given interval?\n@@ -28948,6 +28958,8 @@ package body Sem_Util is\n          Intervals : Discrete_Interval_List (1 .. Max_I);\n          Num_I     : Nat := 0;\n \n+      --  Start of processing for Aggregate_Intervals\n+\n       begin\n          --  No action needed if there are no intervals\n \n@@ -28984,18 +28996,10 @@ package body Sem_Util is\n          end;\n       end Aggregate_Intervals;\n \n-      -----------------\n-      -- In_Interval --\n-      -----------------\n-      function In_Interval\n-        (Value : Uint; Interval : Discrete_Interval) return Boolean is\n-      begin\n-         return Value >= Interval.Low and then Value <= Interval.High;\n-      end In_Interval;\n-\n       ------------------------\n       --  Check_Consistency --\n       ------------------------\n+\n       procedure Check_Consistency (Intervals : Discrete_Interval_List) is\n       begin\n          if Serious_Errors_Detected > 0 then\n@@ -29016,19 +29020,79 @@ package body Sem_Util is\n          end loop;\n       end Check_Consistency;\n \n-      function Chosen_Interval (Choice : Node_Id) return Discrete_Interval;\n-      --  Given an element of a Discrete_Choices list, a\n-      --  Static_Discrete_Predicate list, or an Others_Discrete_Choices\n-      --  list (but not an N_Others_Choice node) return the corresponding\n-      --  interval. If an element that does not represent a single\n-      --  contiguous interval due to a static predicate (or which\n-      --  represents a single contiguous interval whose bounds depend on\n-      --  a static predicate) is encountered, then that is an error on the\n-      --  part of whoever built the list in question.\n+      ---------------------------\n+      -- Choice_List_Intervals --\n+      ---------------------------\n+\n+      function Choice_List_Intervals\n+        (Discrete_Choices : List_Id) return Discrete_Interval_List\n+      is\n+         function Unmerged_Choice_Count return Nat;\n+         --  The number of intervals before adjacent intervals are merged.\n+\n+         ---------------------------\n+         -- Unmerged_Choice_Count --\n+         ---------------------------\n+\n+         function Unmerged_Choice_Count return Nat is\n+            Choice : Node_Id := First (Discrete_Choices);\n+            Count  : Nat := 0;\n+         begin\n+            while Present (Choice) loop\n+               --  Non-contiguous choices involving static predicates\n+               --  have already been normalized away.\n+\n+               if Nkind (Choice) = N_Others_Choice then\n+                  Count :=\n+                    Count + List_Length (Others_Discrete_Choices (Choice));\n+               else\n+                  Count := Count + 1;  -- an ordinary expression or range\n+               end if;\n+\n+               Next (Choice);\n+            end loop;\n+            return Count;\n+         end Unmerged_Choice_Count;\n+\n+         --  Local variables\n+\n+         Choice : Node_Id := First (Discrete_Choices);\n+         Result : Discrete_Interval_List (1 .. Unmerged_Choice_Count);\n+         Count  : Nat := 0;\n+\n+      --  Start of processing for Choice_List_Intervals\n+\n+      begin\n+         while Present (Choice) loop\n+            if Nkind (Choice) = N_Others_Choice then\n+               declare\n+                  Others_Choice : Node_Id\n+                    := First (Others_Discrete_Choices (Choice));\n+               begin\n+                  while Present (Others_Choice) loop\n+                     Count := Count + 1;\n+                     Result (Count) := Chosen_Interval (Others_Choice);\n+                     Next (Others_Choice);\n+                  end loop;\n+               end;\n+            else\n+               Count := Count + 1;\n+               Result (Count) := Chosen_Interval (Choice);\n+            end if;\n+\n+            Next (Choice);\n+         end loop;\n+\n+         pragma Assert (Count = Result'Last);\n+         Normalize_Interval_List (Result, Count);\n+         Check_Consistency (Result (1 .. Count));\n+         return Result (1 .. Count);\n+      end Choice_List_Intervals;\n \n       ---------------------\n       -- Chosen_Interval --\n       ---------------------\n+\n       function Chosen_Interval (Choice : Node_Id) return Discrete_Interval is\n       begin\n          case Nkind (Choice) is\n@@ -29061,93 +29125,105 @@ package body Sem_Util is\n          end case;\n       end Chosen_Interval;\n \n-      --------------------\n-      -- Type_Intervals --\n-      --------------------\n-      function Type_Intervals\n-        (Typ : Entity_Id) return Discrete_Interval_List\n+      -----------------\n+      -- In_Interval --\n+      -----------------\n+\n+      function In_Interval\n+        (Value : Uint; Interval : Discrete_Interval) return Boolean is\n+      begin\n+         return Value >= Interval.Low and then Value <= Interval.High;\n+      end In_Interval;\n+\n+      ---------------\n+      -- Is_Subset --\n+      ---------------\n+\n+      function Is_Subset\n+        (Subset, Of_Set : Discrete_Interval_List) return Boolean\n       is\n+         --  Returns True iff for each interval of Subset we can find\n+         --  a single interval of Of_Set which contains the Subset interval.\n       begin\n-         if Has_Static_Predicate (Typ) then\n-            declare\n-               --  No sorting or merging needed\n-               SDP_List : constant List_Id := Static_Discrete_Predicate (Typ);\n-               Range_Or_Expr : Node_Id := First (SDP_List);\n-               Result :\n-                 Discrete_Interval_List (1 .. List_Length (SDP_List));\n-            begin\n-               for Idx in Result'Range loop\n-                  Result (Idx) := Chosen_Interval (Range_Or_Expr);\n-                  Next (Range_Or_Expr);\n+         if Of_Set'Length = 0 then\n+            return Subset'Length = 0;\n+         end if;\n+\n+         declare\n+            Set_Index : Pos range Of_Set'Range := Of_Set'First;\n+\n+         begin\n+            for Ss_Idx in Subset'Range loop\n+               while not In_Interval\n+                 (Value    => Subset (Ss_Idx).Low,\n+                  Interval => Of_Set (Set_Index))\n+               loop\n+                  if Set_Index = Of_Set'Last then\n+                     return False;\n+                  end if;\n+\n+                  Set_Index := Set_Index + 1;\n                end loop;\n-               pragma Assert (not Present (Range_Or_Expr));\n-               Check_Consistency (Result);\n-               return Result;\n-            end;\n-         else\n-            declare\n-               Low  : constant Uint := Expr_Value (Type_Low_Bound (Typ));\n-               High : constant Uint := Expr_Value (Type_High_Bound (Typ));\n-            begin\n-               if Low > High then\n-                  declare\n-                     Null_Array : Discrete_Interval_List (1 .. 0);\n-                  begin\n-                     return Null_Array;\n-                  end;\n-               else\n-                  return (1 => (Low => Low, High => High));\n+\n+               if not In_Interval\n+                 (Value    => Subset (Ss_Idx).High,\n+                  Interval => Of_Set (Set_Index))\n+               then\n+                  return False;\n                end if;\n-            end;\n-         end if;\n-      end Type_Intervals;\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Is_Subset;\n \n       -----------------------------\n       -- Normalize_Interval_List --\n       -----------------------------\n+\n       procedure Normalize_Interval_List\n-        (List : in out Discrete_Interval_List; Last : out Nat) is\n+        (List : in out Discrete_Interval_List; Last : out Nat)\n+      is\n+         Temp_0 : Discrete_Interval := (others => Uint_0);\n+         --  Cope with Heap_Sort_G idiosyncrasies.\n \n-         procedure Move_Interval (From, To : Natural);\n-         --  Copy interval from one location to another\n+         function Is_Null (Idx : Pos) return Boolean;\n+         --  True iff List (Idx) defines a null range\n \n          function Lt_Interval (Idx1, Idx2 : Natural) return Boolean;\n          --  Compare two list elements\n \n-         Temp_0 : Discrete_Interval := (others => Uint_0);\n-         --  cope with Heap_Sort_G idiosyncrasies.\n+         procedure Merge_Intervals (Null_Interval_Count : out Nat);\n+         --  Merge contiguous ranges by replacing one with merged range and\n+         --  the other with a null value. Return a count of the null intervals,\n+         --  both preexisting and those introduced by merging.\n+\n+         procedure Move_Interval (From, To : Natural);\n+         --  Copy interval from one location to another\n \n          function Read_Interval (From : Natural) return Discrete_Interval;\n          --  Normal array indexing unless From = 0\n \n-         -------------------\n-         -- Read_Interval --\n-         -------------------\n-         function Read_Interval (From : Natural) return Discrete_Interval is\n-         begin\n-            if From = 0 then\n-               return Temp_0;\n-            else\n-               return List (Pos (From));\n-            end if;\n-         end Read_Interval;\n+         ----------------------\n+         -- Interval_Sorting --\n+         ----------------------\n \n-         -------------------\n-         -- Move_Interval --\n-         -------------------\n-         procedure Move_Interval (From, To : Natural) is\n-            Rhs : constant Discrete_Interval := Read_Interval (From);\n+         package Interval_Sorting is\n+           new Gnat.Heap_Sort_G (Move_Interval, Lt_Interval);\n+\n+         -------------\n+         -- Is_Null --\n+         -------------\n+\n+         function Is_Null (Idx : Pos) return Boolean is\n          begin\n-            if To = 0 then\n-               Temp_0 := Rhs;\n-            else\n-               List (Pos (To)) := Rhs;\n-            end if;\n-         end Move_Interval;\n+            return List (Idx).Low > List (Idx).High;\n+         end Is_Null;\n \n          -----------------\n          -- Lt_Interval --\n          -----------------\n+\n          function Lt_Interval (Idx1, Idx2 : Natural) return Boolean is\n             Elem1  : constant Discrete_Interval := Read_Interval (Idx1);\n             Elem2  : constant Discrete_Interval := Read_Interval (Idx2);\n@@ -29157,33 +29233,19 @@ package body Sem_Util is\n             if Null_1 /= Null_2 then\n                --  So that sorting moves null intervals to high end\n                return Null_2;\n+\n             elsif Elem1.Low /= Elem2.Low then\n                return Elem1.Low < Elem2.Low;\n+\n             else\n                return Elem1.High < Elem2.High;\n             end if;\n          end Lt_Interval;\n \n-         package Interval_Sorting is\n-           new Gnat.Heap_Sort_G (Move_Interval, Lt_Interval);\n-\n-         function Is_Null (Idx : Pos) return Boolean;\n-         --  True iff List (Idx) defines a null range\n-\n-         function Is_Null (Idx : Pos) return Boolean is\n-         begin\n-            return List (Idx).Low > List (Idx).High;\n-         end Is_Null;\n-\n-         procedure Merge_Intervals (Null_Interval_Count : out Nat);\n-         --  Merge contiguous ranges by replacing one with merged range\n-         --  and the other with a null value. Return a count of the\n-         --  null intervals, both preexisting and those introduced by\n-         --  merging.\n-\n          ---------------------\n          -- Merge_Intervals --\n          ---------------------\n+\n          procedure Merge_Intervals (Null_Interval_Count : out Nat) is\n             Not_Null : Pos range List'Range;\n             --  Index of the most recently examined non-null interval\n@@ -29199,17 +29261,24 @@ package body Sem_Util is\n \n             Null_Interval_Count := 0;\n             Not_Null := List'First;\n+\n             for Idx in List'First + 1 .. List'Last loop\n                if Is_Null (Idx) then\n+\n                   --  all remaining elements are null\n+\n                   Null_Interval_Count :=\n                     Null_Interval_Count + List (Idx .. List'Last)'Length;\n                   return;\n+\n                elsif List (Idx).Low = List (Not_Null).High + 1 then\n+\n                   --  Merge the two intervals into one; discard the other\n+\n                   List (Not_Null).High := List (Idx).High;\n                   List (Idx) := Null_Interval;\n                   Null_Interval_Count := Null_Interval_Count + 1;\n+\n                else\n                   if List (Idx).Low <= List (Not_Null).High then\n                      raise Intervals_Error;\n@@ -29220,118 +29289,94 @@ package body Sem_Util is\n                end if;\n             end loop;\n          end Merge_Intervals;\n+\n+         -------------------\n+         -- Move_Interval --\n+         -------------------\n+\n+         procedure Move_Interval (From, To : Natural) is\n+            Rhs : constant Discrete_Interval := Read_Interval (From);\n+         begin\n+            if To = 0 then\n+               Temp_0 := Rhs;\n+            else\n+               List (Pos (To)) := Rhs;\n+            end if;\n+         end Move_Interval;\n+\n+         -------------------\n+         -- Read_Interval --\n+         -------------------\n+\n+         function Read_Interval (From : Natural) return Discrete_Interval is\n+         begin\n+            if From = 0 then\n+               return Temp_0;\n+            else\n+               return List (Pos (From));\n+            end if;\n+         end Read_Interval;\n+\n+      --  Start of processing for Normalize_Interval_Lists\n+\n       begin\n          Interval_Sorting.Sort (Natural (List'Last));\n+\n          declare\n             Null_Interval_Count : Nat;\n+\n          begin\n             Merge_Intervals (Null_Interval_Count);\n             Last := List'Last - Null_Interval_Count;\n+\n             if Null_Interval_Count /= 0 then\n                --  Move null intervals introduced during merging to high end\n                Interval_Sorting.Sort (Natural (List'Last));\n             end if;\n          end;\n       end Normalize_Interval_List;\n \n-      ---------------------------\n-      -- Choice_List_Intervals --\n-      ---------------------------\n-      function Choice_List_Intervals\n-        (Discrete_Choices : List_Id) return Discrete_Interval_List\n-      is\n-         function Unmerged_Choice_Count return Nat;\n-         --  The number of intervals before adjacent intervals are merged.\n-\n-         ---------------------------\n-         -- Unmerged_Choice_Count --\n-         ---------------------------\n-         function Unmerged_Choice_Count return Nat is\n-            Choice : Node_Id := First (Discrete_Choices);\n-            Count  : Nat := 0;\n-         begin\n-            while Present (Choice) loop\n-               --  Non-contiguous choices involving static predicates\n-               --  have already been normalized away.\n-\n-               if Nkind (Choice) = N_Others_Choice then\n-                  Count :=\n-                    Count + List_Length (Others_Discrete_Choices (Choice));\n-               else\n-                  Count := Count + 1;  -- an ordinary expression or range\n-               end if;\n-\n-               Next (Choice);\n-            end loop;\n-            return Count;\n-         end Unmerged_Choice_Count;\n-\n-         Choice : Node_Id := First (Discrete_Choices);\n-         Result : Discrete_Interval_List (1 .. Unmerged_Choice_Count);\n-         Count  : Nat := 0;\n-      begin\n-         while Present (Choice) loop\n-            if Nkind (Choice) = N_Others_Choice then\n-               declare\n-                  Others_Choice : Node_Id\n-                    := First (Others_Discrete_Choices (Choice));\n-               begin\n-                  while Present (Others_Choice) loop\n-                     Count := Count + 1;\n-                     Result (Count) := Chosen_Interval (Others_Choice);\n-                     Next (Others_Choice);\n-                  end loop;\n-               end;\n-            else\n-               Count := Count + 1;\n-               Result (Count) := Chosen_Interval (Choice);\n-            end if;\n-            Next (Choice);\n-         end loop;\n-         pragma Assert (Count = Result'Last);\n-         Normalize_Interval_List (Result, Count);\n-         Check_Consistency (Result (1 .. Count));\n-         return Result (1 .. Count);\n-      end Choice_List_Intervals;\n+      --------------------\n+      -- Type_Intervals --\n+      --------------------\n \n-      ---------------\n-      -- Is_Subset --\n-      ---------------\n-      function Is_Subset\n-        (Subset, Of_Set : Discrete_Interval_List) return Boolean\n+      function Type_Intervals (Typ : Entity_Id) return Discrete_Interval_List\n       is\n-         --  Returns True iff for each interval of Subset we can find\n-         --  a single interval of Of_Set which contains the Subset interval.\n       begin\n-         if Of_Set'Length = 0 then\n-            return Subset'Length = 0;\n-         end if;\n+         if Has_Static_Predicate (Typ) then\n+            declare\n+               --  No sorting or merging needed\n+               SDP_List : constant List_Id := Static_Discrete_Predicate (Typ);\n+               Range_Or_Expr : Node_Id := First (SDP_List);\n+               Result : Discrete_Interval_List (1 .. List_Length (SDP_List));\n \n-         declare\n-            Set_Index : Pos range Of_Set'Range := Of_Set'First;\n-         begin\n-            for Ss_Idx in Subset'Range loop\n-               while not In_Interval\n-                 (Value    => Subset (Ss_Idx).Low,\n-                  Interval => Of_Set (Set_Index))\n-               loop\n-                  if Set_Index = Of_Set'Last then\n-                     return False;\n-                  end if;\n-                  Set_Index := Set_Index + 1;\n+            begin\n+               for Idx in Result'Range loop\n+                  Result (Idx) := Chosen_Interval (Range_Or_Expr);\n+                  Next (Range_Or_Expr);\n                end loop;\n \n-               if not In_Interval\n-                 (Value    => Subset (Ss_Idx).High,\n-                  Interval => Of_Set (Set_Index))\n-               then\n-                  return False;\n+               pragma Assert (not Present (Range_Or_Expr));\n+               Check_Consistency (Result);\n+               return Result;\n+            end;\n+         else\n+            declare\n+               Low  : constant Uint := Expr_Value (Type_Low_Bound (Typ));\n+               High : constant Uint := Expr_Value (Type_High_Bound (Typ));\n+            begin\n+               if Low > High then\n+                  declare\n+                     Null_Array : Discrete_Interval_List (1 .. 0);\n+                  begin\n+                     return Null_Array;\n+                  end;\n+               else\n+                  return (1 => (Low => Low, High => High));\n                end if;\n-            end loop;\n-         end;\n-\n-         return True;\n-      end Is_Subset;\n+            end;\n+         end if;\n+      end Type_Intervals;\n \n    end Interval_Lists;\n "}, {"sha": "fc8177c838517cd6d41512d5e23643e87b4ae81b", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab6432039b8a92acd2bf4490771c9f5b347c005/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab6432039b8a92acd2bf4490771c9f5b347c005/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=dab6432039b8a92acd2bf4490771c9f5b347c005", "patch": "@@ -3122,17 +3122,17 @@ package Sem_Util is\n       --  components are covered by the others choice then the length of the\n       --  result is zero.\n \n+      function Choice_List_Intervals\n+        (Discrete_Choices : List_Id) return Discrete_Interval_List;\n+      --  Given a discrete choice list, returns the (unique) interval\n+      --  list representing the chosen values.\n+\n       function Type_Intervals (Typ : Entity_Id) return Discrete_Interval_List;\n       --  Given a static discrete type or subtype, returns the (unique)\n       --  interval list representing the values of the type/subtype.\n       --  If no static predicates are involved, the length of the result\n       --  will be at most one.\n \n-      function Choice_List_Intervals (Discrete_Choices : List_Id)\n-                                     return Discrete_Interval_List;\n-      --  Given a discrete choice list, returns the (unique) interval\n-      --  list representing the chosen values.\n-\n       function Is_Subset (Subset, Of_Set : Discrete_Interval_List)\n         return Boolean;\n       --  Returns True iff every value belonging to some interval of"}]}