{"sha": "65356e64cf0fc85effb4b77d9e253c7d28bf407c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzNTZlNjRjZjBmYzg1ZWZmYjRiNzdkOWUyNTNjN2QyOGJmNDA3Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-14T10:24:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-14T10:24:47Z"}, "message": "[multiple changes]\n\n2003-11-13  Vincent Celier  <celier@gnat.com>\n\n\t* 5bml-tgt.adb (Build_Dynamic_Library): Use\n\tOsint.Include_Dir_Default_Prefix instead of\n\tSdefault.Include_Dir_Default_Name.\n\n\t* gnatlbr.adb: Update Copyright notice\n\t(Gnatlbr): : Use Osint.Include_Dir_Default_Prefix instead of\n\tSdefault.Include_Dir_Default_Name and Osint.Object_Dir_Default_Prefix\n\tinstead of Sdefault.Object_Dir_Default_Name\n\n\t* gnatlink.adb:\n\t(Process_Binder_File): Never suppress the option following -Xlinker\n\n\t* mdll-utl.adb:\n\t(Gcc): Use Osint.Object_Dir_Default_Prefix instead of\n\tSdefault.Object_Dir_Default_Name.\n\n\t* osint.ads, osint.adb:\n\t(Include_Dir_Default_Prefix, Object_Dir_Default_Prefix): New functions\n\tMinor reformatting.\n\n\t* vms_conv.ads: Minor reformating\n\tRemove GNAT STANDARD and GNAT PSTA\n\n\t* vms_conv.adb:\n\tAllow GNAT MAKE to have several files on the command line.\n\t(Init_Object_Dirs): Use Osint.Object_Dir_Default_Prefix instead of\n\tSdefault.Object_Dir_Default_Name.\n\tMinor Reformating\n\tRemove data for GNAT STANDARD\n\n\t* vms_data.ads:\n\tAdd new compiler qualifier /PRINT_STANDARD (-gnatS)\n\tRemove data for GNAT STANDARD\n\tRemove options and documentation for -gnatwb/-gnatwB: these warning\n\toptions no longer exist.\n\n2003-11-13  Ed Falis  <falis@gnat.com>\n\n\t* 5zthrini.adb: (Init_RTS): Made visible\n\n\t* 5zthrini.adb:\n\t(Register): Removed unnecessary call to taskVarGet that checked whether\n\t an ATSD was already set as a task var for the argument thread.\n\n\t* s-thread.adb:\n\tUpdated comment to reflect that this is a VxWorks version\n\tAdded context clause for System.Threads.Initialization\n\tAdded call to System.Threads.Initialization.Init_RTS\n\n2003-11-13  Jerome Guitton  <guitton@act-europe.fr>\n\n\t* 5zthrini.adb:\n\t(Init_RTS): New procedure, for the initialization of the run-time lib.\n\n\t* s-thread.adb:\n\tRemove dependancy on System.Init, so that this file can be used in the\n\tAE653 sequential run-time lib.\n\n2003-11-13  Robert Dewar  <dewar@gnat.com>\n\n\t* bindgen.adb: Minor reformatting\n\n2003-11-13  Ed Schonberg  <schonberg@gnat.com>\n\n\t* checks.adb:\n\t(Apply_Discriminant_Check): Do no apply check if target type is derived\n\tfrom source type with no applicable constraint.\n\n\t* lib-writ.adb:\n\t(Ensure_System_Dependency): Do not apply the style checks that may have\n\tbeen specified for the main unit.\n\n\t* sem_ch8.adb:\n\t(Find_Selected_Component): Further improvement in error message, with\n\tRM reference.\n\n\t* sem_res.adb:\n\t(Resolve): Handle properly the case of an illegal overloaded protected\n\tprocedure.\n\n2003-11-13  Javier Miranda  <miranda@gnat.com>\n\n\t* exp_aggr.adb:\n\t(Has_Default_Init_Comps): New function to check the presence of\n\tdefault initialization in an aggregate.\n\t(Build_Record_Aggr_Code): Recursively expand the ancestor in case of\n\textension aggregate of a limited record. In addition, a new formal\n\twas added to do not initialize the record controller (if any) during\n\tthis recursive expansion of ancestors.\n\t(Init_Controller): Add support for limited record components.\n\t(Expand_Record_Aggregate): In case of default initialized components\n\tconvert the aggregate into a set of assignments.\n\n\t* par-ch4.adb (P_Aggregate_Or_Paren_Expr): Update the comment\n\tdescribing the new syntax.\n\tNothing else needed to be done because this subprogram delegates part of\n\tits work to P_Precord_Or_Array_Component_Association.\n\t(P_Record_Or_Array_Component_Association): Give support to the new\n\tsyntax for default initialization of components.\n\n\t* sem_aggr.adb:\n\t(Resolve_Aggregate): Relax the strictness of the frontend in case of\n\tlimited aggregates.\n\t(Resolve_Record_Aggregate): Give support to default initialized\n\tcomponents.\n\t(Get_Value): In case of default initialized components, duplicate\n\tthe corresponding default expression (from the record type\n\tdeclaration). In case of default initialization in the *others*\n\tchoice, do not check that all components have the same type.\n\t(Resolve_Extension_Aggregate): Give support to limited extension\n\taggregates.\n\n\t* sem_ch3.adb:\n\t(Check_Initialization): Relax the strictness of the front-end in case\n\tof aggregate and extension aggregates. This test is now done in\n\tGet_Value in a per-component manner.\n\n\t* sem_ch4.adb (Analyze_Allocator): Don't post an error if the\n\texpression corresponds to a limited aggregate. This test is now done\n\tin Get_Value.\n\n\t* sinfo.ads, sinfo.adb (N_Component_Association): Addition of\n\tBox_Present flag.\n\n\t* sprint.adb (Sprint_Node_Actual): Modified to print an mbox if\n\tpresent in an N_Component_Association node\n\n2003-11-13  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* sem_ch9.adb (Analyze_Accept_Statement): A procedure hides a\n\ttype-conformant entry only if they are homographs.\n\n2003-11-13  GNAT Script  <nobody@gnat.com>\n\n\t* Make-lang.in: Makefile automatically updated\n\nFrom-SVN: r73596", "tree": {"sha": "704f7caa7117a84574764938ed1020c5cdb1d890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/704f7caa7117a84574764938ed1020c5cdb1d890"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65356e64cf0fc85effb4b77d9e253c7d28bf407c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65356e64cf0fc85effb4b77d9e253c7d28bf407c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65356e64cf0fc85effb4b77d9e253c7d28bf407c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65356e64cf0fc85effb4b77d9e253c7d28bf407c/comments", "author": null, "committer": null, "parents": [{"sha": "f2b7f367d58c9da38eee0599a97ef3527d82e96b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b7f367d58c9da38eee0599a97ef3527d82e96b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2b7f367d58c9da38eee0599a97ef3527d82e96b"}], "stats": {"total": 5573, "additions": 2585, "deletions": 2988}, "files": [{"sha": "59c6d5613428128b985d948670f0f41490267b74", "filename": "gcc/ada/5bml-tgt.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2F5bml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2F5bml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5bml-tgt.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -35,10 +35,10 @@ with Ada.Text_IO; use Ada.Text_IO;\n with MLib.Fil;\n with MLib.Utl;\n with Namet;  use Namet;\n+with Osint;  use Osint;\n with Opt;\n with Output; use Output;\n with Prj.Com;\n-with Sdefault;\n \n package body MLib.Tgt is\n \n@@ -175,9 +175,9 @@ package body MLib.Tgt is\n                   Last : Natural;\n \n                begin\n-                  Open (File, In_File,\n-                        Sdefault.Include_Dir_Default_Name.all &\n-                        \"/s-osinte.ads\");\n+                  Open\n+                    (File, In_File,\n+                     Include_Dir_Default_Prefix & \"/s-osinte.ads\");\n \n                   while not End_Of_File (File) loop\n                      Get_Line (File, Line, Last);"}, {"sha": "0b49e0eee241cd2cb61605180af89a65bca0eb89", "filename": "gcc/ada/5zthrini.adb", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2F5zthrini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2F5zthrini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zthrini.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--            Copyright (C) 1992-2003 Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,15 +36,17 @@\n \n with System.Secondary_Stack;\n with System.Storage_Elements;\n+with System.Soft_Links;\n with Interfaces.C;\n-with Unchecked_Conversion;\n \n package body System.Threads.Initialization is\n \n    use Interfaces.C;\n \n    package SSS renames System.Secondary_Stack;\n \n+   package SSL renames System.Soft_Links;\n+\n    procedure Initialize_Task_Hooks;\n    --  Register the appropriate hooks (Register and Reset_TSD) to the\n    --  underlying OS, so that they will be called when a task is created\n@@ -60,6 +62,19 @@ package body System.Threads.Initialization is\n    procedure Initialize_Task_Hooks is separate;\n    --  Separate, as these hooks are different for AE653 and VxWorks 5.5.\n \n+   --------------\n+   -- Init_RTS --\n+   --------------\n+\n+   procedure Init_RTS is\n+   begin\n+      SSL.Get_Jmpbuf_Address := Get_Jmpbuf_Address'Access;\n+      SSL.Get_Sec_Stack_Addr := Get_Sec_Stack_Addr'Access;\n+      SSL.Get_Current_Excep  := Get_Current_Excep'Access;\n+      SSL.Set_Jmpbuf_Address := Set_Jmpbuf_Address'Access;\n+      SSL.Set_Sec_Stack_Addr := Set_Sec_Stack_Addr'Access;\n+   end Init_RTS;\n+\n    --------------\n    -- Register --\n    --------------\n@@ -76,9 +91,7 @@ package body System.Threads.Initialization is\n       --  (depending on configRecord.c, allocation could be disabled).\n       --  Otherwise, everything could have been done in Thread_Body_Enter.\n \n-      if OSI.taskIdVerify (T) = OSI.ERROR\n-        or else OSI.taskVarGet (T, Current_ATSD'Access) /= OSI.ERROR\n-      then\n+      if OSI.taskIdVerify (T) = OSI.ERROR then\n          return OSI.ERROR;\n       end if;\n \n@@ -102,6 +115,7 @@ package body System.Threads.Initialization is\n \n begin\n    Initialize_Task_Hooks;\n+   Init_RTS;\n \n    --  Register the environment task\n    declare"}, {"sha": "ffad8f3a2bdf0f81a16a06176caa946f60d6dc93", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -1,3 +1,141 @@\n+2003-11-13  Vincent Celier  <celier@gnat.com>\n+\n+\t* 5bml-tgt.adb (Build_Dynamic_Library): Use\n+\tOsint.Include_Dir_Default_Prefix instead of\n+\tSdefault.Include_Dir_Default_Name.\n+\n+\t* gnatlbr.adb: Update Copyright notice\n+\t(Gnatlbr): : Use Osint.Include_Dir_Default_Prefix instead of\n+\tSdefault.Include_Dir_Default_Name and Osint.Object_Dir_Default_Prefix\n+\tinstead of Sdefault.Object_Dir_Default_Name\n+\n+\t* gnatlink.adb: \n+\t(Process_Binder_File): Never suppress the option following -Xlinker\n+\n+\t* mdll-utl.adb: \n+\t(Gcc): Use Osint.Object_Dir_Default_Prefix instead of\n+\tSdefault.Object_Dir_Default_Name.\n+\n+\t* osint.ads, osint.adb: \n+\t(Include_Dir_Default_Prefix, Object_Dir_Default_Prefix): New functions\n+\tMinor reformatting.\n+\n+\t* vms_conv.ads: Minor reformating\n+\tRemove GNAT STANDARD and GNAT PSTA\n+\n+\t* vms_conv.adb: \n+\tAllow GNAT MAKE to have several files on the command line.\n+\t(Init_Object_Dirs): Use Osint.Object_Dir_Default_Prefix instead of\n+\tSdefault.Object_Dir_Default_Name.\n+\tMinor Reformating\n+\tRemove data for GNAT STANDARD\n+\n+\t* vms_data.ads: \n+\tAdd new compiler qualifier /PRINT_STANDARD (-gnatS)\n+\tRemove data for GNAT STANDARD\n+\tRemove options and documentation for -gnatwb/-gnatwB: these warning\n+\toptions no longer exist.\n+\n+2003-11-13  Ed Falis  <falis@gnat.com>\n+\n+\t* 5zthrini.adb: (Init_RTS): Made visible\n+\n+\t* 5zthrini.adb: \n+\t(Register): Removed unnecessary call to taskVarGet that checked whether\n+\t an ATSD was already set as a task var for the argument thread.\n+\n+\t* s-thread.adb: \n+\tUpdated comment to reflect that this is a VxWorks version\n+\tAdded context clause for System.Threads.Initialization\n+\tAdded call to System.Threads.Initialization.Init_RTS\n+\n+2003-11-13  Jerome Guitton  <guitton@act-europe.fr>\n+\n+\t* 5zthrini.adb: \n+\t(Init_RTS): New procedure, for the initialization of the run-time lib.\n+\n+\t* s-thread.adb: \n+\tRemove dependancy on System.Init, so that this file can be used in the\n+\tAE653 sequential run-time lib.\n+\n+2003-11-13  Robert Dewar  <dewar@gnat.com>\n+\n+\t* bindgen.adb: Minor reformatting\n+\n+2003-11-13  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* checks.adb: \n+\t(Apply_Discriminant_Check): Do no apply check if target type is derived\n+\tfrom source type with no applicable constraint.\n+\n+\t* lib-writ.adb: \n+\t(Ensure_System_Dependency): Do not apply the style checks that may have\n+\tbeen specified for the main unit.\n+\n+\t* sem_ch8.adb: \n+\t(Find_Selected_Component): Further improvement in error message, with\n+\tRM reference.\n+\n+\t* sem_res.adb: \n+\t(Resolve): Handle properly the case of an illegal overloaded protected\n+\tprocedure.\n+\n+2003-11-13  Javier Miranda  <miranda@gnat.com>\n+\n+\t* exp_aggr.adb: \n+\t(Has_Default_Init_Comps): New function to check the presence of\n+\tdefault initialization in an aggregate.\n+\t(Build_Record_Aggr_Code): Recursively expand the ancestor in case of\n+\textension aggregate of a limited record. In addition, a new formal\n+\twas added to do not initialize the record controller (if any) during\n+\tthis recursive expansion of ancestors.\n+\t(Init_Controller): Add support for limited record components.\n+\t(Expand_Record_Aggregate): In case of default initialized components\n+\tconvert the aggregate into a set of assignments.\n+\n+\t* par-ch4.adb (P_Aggregate_Or_Paren_Expr): Update the comment\n+\tdescribing the new syntax.\n+\tNothing else needed to be done because this subprogram delegates part of\n+\tits work to P_Precord_Or_Array_Component_Association.\n+\t(P_Record_Or_Array_Component_Association): Give support to the new\n+\tsyntax for default initialization of components.\n+\n+\t* sem_aggr.adb: \n+\t(Resolve_Aggregate): Relax the strictness of the frontend in case of\n+\tlimited aggregates.\n+\t(Resolve_Record_Aggregate): Give support to default initialized\n+\tcomponents.\n+\t(Get_Value): In case of default initialized components, duplicate\n+\tthe corresponding default expression (from the record type\n+\tdeclaration). In case of default initialization in the *others*\n+\tchoice, do not check that all components have the same type.\n+\t(Resolve_Extension_Aggregate): Give support to limited extension\n+\taggregates.\n+\n+\t* sem_ch3.adb: \n+\t(Check_Initialization): Relax the strictness of the front-end in case\n+\tof aggregate and extension aggregates. This test is now done in\n+\tGet_Value in a per-component manner.\n+\n+\t* sem_ch4.adb (Analyze_Allocator): Don't post an error if the\n+\texpression corresponds to a limited aggregate. This test is now done\n+\tin Get_Value.\n+\n+\t* sinfo.ads, sinfo.adb (N_Component_Association): Addition of\n+\tBox_Present flag.\n+\n+\t* sprint.adb (Sprint_Node_Actual): Modified to print an mbox if\n+\tpresent in an N_Component_Association node\n+\n+2003-11-13  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sem_ch9.adb (Analyze_Accept_Statement): A procedure hides a\n+\ttype-conformant entry only if they are homographs.\n+\n+2003-11-13  GNAT Script  <nobody@gnat.com>\n+\n+\t* Make-lang.in: Makefile automatically updated\n+\n 2003-11-12  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* adadecode.c: Use <> form of include for ctype.h."}, {"sha": "ecc03c6f4e026345ce77a620bd38e9f49d6d00eb", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 1269, "deletions": 2133, "changes": 3402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c"}, {"sha": "bfb4a69ec36ea67f1e02a3ea7b31d3efc7d78952", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -1895,6 +1895,7 @@ package body Bindgen is\n \n    procedure Gen_Output_File (Filename : String) is\n       Is_Public_Version : constant Boolean := Get_Gnat_Build_Type = Public;\n+\n    begin\n       --  Acquire settings for Interrupt_State pragmas\n "}, {"sha": "02649747cc4c4cb2bc9d30cf5b1beabd2a2f6567", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -1183,6 +1183,26 @@ package body Checks is\n                if No (DconS) then\n                   return;\n                end if;\n+\n+               --  A further optimization: if T_Typ is derived from S_Typ\n+               --  without imposing a constraint, no check is needed.\n+\n+               if Nkind (Original_Node (Parent (T_Typ))) =\n+                 N_Full_Type_Declaration\n+               then\n+                  declare\n+                     Type_Def : Node_Id :=\n+                                 Type_Definition\n+                                   (Original_Node (Parent (T_Typ)));\n+                  begin\n+                     if Nkind (Type_Def) = N_Derived_Type_Definition\n+                       and then Is_Entity_Name (Subtype_Indication (Type_Def))\n+                       and then Entity (Subtype_Indication (Type_Def)) = S_Typ\n+                     then\n+                        return;\n+                     end if;\n+                  end;\n+               end if;\n             end if;\n \n             DconT  := First_Elmt (Discriminant_Constraint (T_Typ));"}, {"sha": "e2413bbd4f91ed1a151e7015b2b3424d4a84bc2c", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 127, "deletions": 26, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -70,6 +70,10 @@ package body Exp_Aggr is\n    --  statement of variant part will usually be small and probably in near\n    --  sorted order.\n \n+   function Has_Default_Init_Comps (N : Node_Id) return Boolean;\n+   --  N is an aggregate (record or array). Checks the presence of\n+   --  default initialization (<>) in any component.\n+\n    ------------------------------------------------------\n    -- Local subprograms for Record Aggregate Expansion --\n    ------------------------------------------------------\n@@ -97,12 +101,13 @@ package body Exp_Aggr is\n    --  assignments component per component.\n \n    function Build_Record_Aggr_Code\n-     (N      : Node_Id;\n-      Typ    : Entity_Id;\n-      Target : Node_Id;\n-      Flist  : Node_Id   := Empty;\n-      Obj    : Entity_Id := Empty)\n-      return   List_Id;\n+     (N                             : Node_Id;\n+      Typ                           : Entity_Id;\n+      Target                        : Node_Id;\n+      Flist                         : Node_Id   := Empty;\n+      Obj                           : Entity_Id := Empty;\n+      Is_Limited_Ancestor_Expansion : Boolean   := False)\n+      return List_Id;\n    --  N is an N_Aggregate or a N_Extension_Aggregate. Typ is the type\n    --  of the aggregate. Target is an expression containing the\n    --  location on which the component by component assignments will\n@@ -113,6 +118,8 @@ package body Exp_Aggr is\n    --  object declaration and dynamic allocation cases, it contains\n    --  an entity that allows to know if the value being created needs to be\n    --  attached to the final list in case of pragma finalize_Storage_Only.\n+   --  Is_Limited_Ancestor_Expansion indicates that the function has been\n+   --  called recursively to expand the limited ancestor to avoid copying it.\n \n    function Has_Mutable_Components (Typ : Entity_Id) return Boolean;\n    --  Return true if one of the component is of a discriminated type with\n@@ -1269,12 +1276,13 @@ package body Exp_Aggr is\n    ----------------------------\n \n    function Build_Record_Aggr_Code\n-     (N      : Node_Id;\n-      Typ    : Entity_Id;\n-      Target : Node_Id;\n-      Flist  : Node_Id   := Empty;\n-      Obj    : Entity_Id := Empty)\n-      return   List_Id\n+     (N                             : Node_Id;\n+      Typ                           : Entity_Id;\n+      Target                        : Node_Id;\n+      Flist                         : Node_Id   := Empty;\n+      Obj                           : Entity_Id := Empty;\n+      Is_Limited_Ancestor_Expansion : Boolean   := False)\n+      return List_Id\n    is\n       Loc     : constant Source_Ptr := Sloc (N);\n       L       : constant List_Id    := New_List;\n@@ -1540,20 +1548,50 @@ package body Exp_Aggr is\n              Selector_Name => Make_Identifier (Loc, Name_uController));\n          Set_Assignment_OK (Ref);\n \n-         if Init_Pr then\n-            Append_List_To (L,\n-              Build_Initialization_Call (Loc,\n-                Id_Ref       => Ref,\n-                Typ          => RTE (RE_Record_Controller),\n-                In_Init_Proc => Within_Init_Proc));\n-         end if;\n+         --  Give support to default initialization of limited types and\n+         --  components\n \n-         Append_To (L,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Reference_To (Find_Prim_Op (RTE (RE_Record_Controller),\n-                 Name_Initialize), Loc),\n-             Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n+         if (Nkind (Target) = N_Identifier\n+             and then Is_Limited_Type (Etype (Target)))\n+           or else (Nkind (Target) = N_Selected_Component\n+                    and then Is_Limited_Type (Etype (Selector_Name (Target))))\n+           or else (Nkind (Target) = N_Unchecked_Type_Conversion\n+                    and then Is_Limited_Type (Etype (Target)))\n+         then\n+\n+            if Init_Pr then\n+               Append_List_To (L,\n+                 Build_Initialization_Call (Loc,\n+                   Id_Ref       => Ref,\n+                   Typ          => RTE (RE_Limited_Record_Controller),\n+                   In_Init_Proc => Within_Init_Proc));\n+            end if;\n+\n+            Append_To (L,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To\n+                         (Find_Prim_Op (RTE (RE_Limited_Record_Controller),\n+                    Name_Initialize), Loc),\n+                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n+\n+         else\n+            if Init_Pr then\n+               Append_List_To (L,\n+                 Build_Initialization_Call (Loc,\n+                   Id_Ref       => Ref,\n+                   Typ          => RTE (RE_Record_Controller),\n+                   In_Init_Proc => Within_Init_Proc));\n+            end if;\n+\n+            Append_To (L,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (Find_Prim_Op (RTE (RE_Record_Controller),\n+                    Name_Initialize), Loc),\n+                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n+\n+         end if;\n \n          Append_To (L,\n            Make_Attach_Call (\n@@ -1648,6 +1686,21 @@ package body Exp_Aggr is\n                   Check_Ancestor_Discriminants (Entity (A));\n                end if;\n \n+            --  If the ancestor part is a limited type, a recursive call\n+            --  expands the ancestor.\n+\n+            elsif Is_Limited_Type (Etype (A)) then\n+               Ancestor_Is_Expression := True;\n+\n+               Append_List_To (Start_L,\n+                  Build_Record_Aggr_Code (\n+                    N                             => Expression (A),\n+                    Typ                           => Etype (Expression (A)),\n+                    Target                        => Target,\n+                    Flist                         => Flist,\n+                    Obj                           => Obj,\n+                    Is_Limited_Ancestor_Expansion => True));\n+\n             --  If the ancestor part is an expression \"E\", we generate\n             --     T(tmp) := E;\n \n@@ -1767,6 +1820,22 @@ package body Exp_Aggr is\n       while Present (Comp) loop\n          Selector  := Entity (First (Choices (Comp)));\n \n+         --  Default initialization of a limited component\n+\n+         if Box_Present (Comp)\n+            and then Is_Limited_Type (Etype (Selector))\n+         then\n+            Append_List_To (L,\n+              Build_Initialization_Call (Loc,\n+                Id_Ref => Make_Selected_Component (Loc,\n+                            Prefix => New_Copy_Tree (Target),\n+                            Selector_Name => New_Occurrence_Of (Selector,\n+                                                                Loc)),\n+                Typ    => Etype (Selector)));\n+\n+            goto Next_Comp;\n+         end if;\n+\n          --  ???\n \n          if Ekind (Selector) /= E_Discriminant\n@@ -1900,6 +1969,8 @@ package body Exp_Aggr is\n             end;\n          end if;\n \n+         <<Next_Comp>>\n+\n          Next (Comp);\n       end loop;\n \n@@ -1997,7 +2068,9 @@ package body Exp_Aggr is\n       --  In the Has_Controlled component case, all the intermediate\n       --  controllers must be initialized\n \n-      if Has_Controlled_Component (Typ) then\n+      if Has_Controlled_Component (Typ)\n+        and not Is_Limited_Ancestor_Expansion\n+      then\n          declare\n             Inner_Typ : Entity_Id;\n             Outer_Typ : Entity_Id;\n@@ -4082,6 +4155,9 @@ package body Exp_Aggr is\n       then\n          Convert_To_Assignments (N, Typ);\n \n+      elsif Has_Default_Init_Comps (N) then\n+         Convert_To_Assignments (N, Typ);\n+\n       elsif Has_Delayed_Nested_Aggregate_Or_Tagged_Comps then\n          Convert_To_Assignments (N, Typ);\n \n@@ -4402,6 +4478,31 @@ package body Exp_Aggr is\n       end if;\n    end Expand_Record_Aggregate;\n \n+   ----------------------------\n+   -- Has_Default_Init_Comps --\n+   ----------------------------\n+\n+   function Has_Default_Init_Comps (N : Node_Id) return Boolean is\n+      Comps  : constant List_Id := Component_Associations (N);\n+      C      : Node_Id;\n+   begin\n+      pragma Assert (Nkind (N) = N_Aggregate\n+                     or else Nkind (N) = N_Extension_Aggregate);\n+      if No (Comps) then\n+         return False;\n+      end if;\n+\n+      C := First (Comps);\n+      while Present (C) loop\n+         if Box_Present (C) then\n+            return True;\n+         end if;\n+\n+         Next (C);\n+      end loop;\n+      return False;\n+   end Has_Default_Init_Comps;\n+\n    --------------------------\n    -- Is_Delayed_Aggregate --\n    --------------------------"}, {"sha": "b79efa15e4f8763ac0eee7199c12ba58cd1bdf39", "filename": "gcc/ada/gnatlbr.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fgnatlbr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fgnatlbr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlbr.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,7 +47,6 @@ with GNAT.OS_Lib;          use GNAT.OS_Lib;\n with Gnatvsn;              use Gnatvsn;\n with Interfaces.C_Streams; use Interfaces.C_Streams;\n with Osint;                use Osint;\n-with Sdefault;             use Sdefault;\n with System;\n \n procedure GnatLbr is\n@@ -192,7 +191,7 @@ begin\n             --  there are two.\n             --\n             Include_Dirs := 0;\n-            Include_Dir_Name := String_Access (Include_Dir_Default_Name);\n+            Include_Dir_Name := new String'(Include_Dir_Default_Prefix);\n             Get_Next_Dir_In_Path_Init (String_Access (Include_Dir_Name));\n \n             loop\n@@ -208,7 +207,7 @@ begin\n             end loop;\n \n             Object_Dirs := 0;\n-            Object_Dir_Name := String_Access (Object_Dir_Default_Name);\n+            Object_Dir_Name := new String'(Object_Dir_Default_Prefix);\n             Get_Next_Dir_In_Path_Init (String_Access (Object_Dir_Name));\n \n             loop"}, {"sha": "ed01ba859fae0aaaec1c99e68999031cc6298216", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -619,6 +619,10 @@ procedure Gnatlink is\n       GNAT_Shared : Boolean := False;\n       --  Save state of -shared option.\n \n+      Xlinker_Was_Previous : Boolean := False;\n+      --  Indicate that \"-Xlinker\" was the option preceding the current\n+      --  option. If True, then the current option is never suppressed.\n+\n       --  Rollback data\n \n       --  These data items are used to store current binder file context.\n@@ -936,8 +940,17 @@ procedure Gnatlink is\n       --  Process switches and options\n \n       if Next_Line (Nfirst .. Nlast) /= End_Info then\n+         Xlinker_Was_Previous := False;\n+\n          loop\n-            if Next_Line (Nfirst .. Nlast) = \"-static\" then\n+            if Xlinker_Was_Previous\n+              or else Next_Line (Nfirst .. Nlast) = \"-Xlinker\"\n+            then\n+               Linker_Options.Increment_Last;\n+               Linker_Options.Table (Linker_Options.Last) :=\n+                 new String'(Next_Line (Nfirst .. Nlast));\n+\n+            elsif Next_Line (Nfirst .. Nlast) = \"-static\" then\n                GNAT_Static := True;\n \n             elsif Next_Line (Nfirst .. Nlast) = \"-shared\" then\n@@ -946,9 +959,7 @@ procedure Gnatlink is\n             --  Add binder options only if not already set on the command\n             --  line. This rule is a way to control the linker options order.\n \n-            elsif not Is_Option_Present (Next_Line (Nfirst .. Nlast))\n-              or else Next_Line (Nfirst .. Nlast) = \"-Xlinker\"\n-            then\n+            elsif not Is_Option_Present (Next_Line (Nfirst .. Nlast)) then\n                if Nlast > Nfirst + 2 and then\n                  Next_Line (Nfirst .. Nfirst + 1) = \"-L\"\n                then\n@@ -1125,6 +1136,8 @@ procedure Gnatlink is\n                end if;\n             end if;\n \n+            Xlinker_Was_Previous := Next_Line (Nfirst .. Nlast) = \"-Xlinker\";\n+\n             Get_Next_Line;\n             exit when Next_Line (Nfirst .. Nlast) = End_Info;\n "}, {"sha": "ea5ec34bd4f994ab3da10cb1089a679fb0578199", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -91,6 +91,8 @@ package body Lib.Writ is\n       System_Fname : File_Name_Type;\n       --  File name for system spec if needed for dummy entry\n \n+      Save_Style : constant Boolean := Style_Check;\n+\n    begin\n       --  Nothing to do if we already compiled System\n \n@@ -133,9 +135,12 @@ package body Lib.Writ is\n         Error_Location  => No_Location);\n \n       --  Parse system.ads so that the checksum is set right\n+      --  Style checks are not applied.\n \n+      Style_Check := False;\n       Initialize_Scanner (Units.Last, System_Source_File_Index);\n       Discard_List (Par (Configuration_Pragmas => False));\n+      Style_Check := Save_Style;\n    end Ensure_System_Dependency;\n \n    ---------------"}, {"sha": "2608e92f224e858fdec0fed3ef2972076ef2569b", "filename": "gcc/ada/mdll-utl.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fmdll-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fmdll-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll-utl.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -30,7 +30,7 @@ with Ada.Text_IO;\n with Ada.Exceptions;\n \n with GNAT.Directory_Operations;\n-with Sdefault;\n+with Osint;\n \n package body MDLL.Utl is\n \n@@ -155,7 +155,7 @@ package body MDLL.Utl is\n       Base_File   : String := \"\";\n       Build_Lib   : Boolean := False)\n    is\n-      use Sdefault;\n+      use Osint;\n \n       Arguments : OS_Lib.Argument_List\n         (1 .. 5 + Files'Length + Options'Length);\n@@ -167,7 +167,7 @@ package body MDLL.Utl is\n       Out_V     : aliased String := Output_File;\n       Bas_Opt   : aliased String := \"-Wl,--base-file,\" & Base_File;\n       Lib_Opt   : aliased String := \"-mdll\";\n-      Lib_Dir   : aliased String := \"-L\" & Object_Dir_Default_Name.all;\n+      Lib_Dir   : aliased String := \"-L\" & Object_Dir_Default_Prefix;\n \n    begin\n       A := A + 1;"}, {"sha": "28f8ed88d23f8418a16a754a6240292ffeec4030", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 84, "deletions": 62, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -41,9 +41,12 @@ with GNAT.HTable;\n package body Osint is\n \n    Running_Program : Program_Type := Unspecified;\n-   Program_Set     : Boolean      := False;\n+   --  comment required here ???\n \n-   Std_Prefix      : String_Ptr;\n+   Program_Set : Boolean := False;\n+   --  comment required here ???\n+\n+   Std_Prefix : String_Ptr;\n    --  Standard prefix, computed dynamically the first time Relocate_Path\n    --  is called, and cached for subsequent calls.\n \n@@ -66,8 +69,7 @@ package body Osint is\n \n    function Append_Suffix_To_File_Name\n      (Name   : Name_Id;\n-      Suffix : String)\n-      return   Name_Id;\n+      Suffix : String) return Name_Id;\n    --  Appends Suffix to Name and returns the new name.\n \n    function OS_Time_To_GNAT_Time (T : OS_Time) return Time_Stamp_Type;\n@@ -81,14 +83,14 @@ package body Osint is\n    --  The executable must be located in a directory called \"bin\", or\n    --  under root/lib/gcc-lib/..., or under root/libexec/gcc/... Thus, if\n    --  the executable is stored in directory \"/foo/bar/bin\", this routine\n-   --  returns \"/foo/bar/\".\n-   --  Return \"\" if the location is not recognized as described above.\n+   --  returns \"/foo/bar/\".  Return \"\" if the location is not recognized\n+   --  as described above.\n \n    function Update_Path (Path : String_Ptr) return String_Ptr;\n    --  Update the specified path to replace the prefix with the location\n    --  where GNAT is installed. See the file prefix.c in GCC for details.\n \n-   procedure Write_With_Check (A  : Address; N  : Integer);\n+   procedure Write_With_Check (A : Address; N  : Integer);\n    --  Writes N bytes from buffer starting at address A to file whose FD is\n    --  stored in Output_FD, and whose file name is stored as a File_Name_Type\n    --  in Output_File_Name. A check is made for disk full, and if this is\n@@ -99,8 +101,7 @@ package body Osint is\n      (N    : File_Name_Type;\n       T    : File_Type;\n       Dir  : Natural;\n-      Name : String)\n-      return File_Name_Type;\n+      Name : String) return File_Name_Type;\n    --  See if the file N whose name is Name exists in directory Dir. Dir is\n    --  an index into the Lib_Search_Directories table if T = Library.\n    --  Otherwise if T = Source, Dir is an index into the\n@@ -112,8 +113,7 @@ package body Osint is\n \n    function To_Path_String_Access\n      (Path_Addr : Address;\n-      Path_Len  : Integer)\n-      return      String_Access;\n+      Path_Len  : Integer) return String_Access;\n    --  Converts a C String to an Ada String. Are we doing this to avoid\n    --  withing Interfaces.C.Strings ???\n \n@@ -218,17 +218,15 @@ package body Osint is\n      Equal      => \"=\");\n \n    function Smart_Find_File\n-     (N    : File_Name_Type;\n-      T    : File_Type)\n-      return File_Name_Type;\n+     (N : File_Name_Type;\n+      T : File_Type) return File_Name_Type;\n    --  Exactly like Find_File except that if File_Cache_Enabled is True this\n    --  routine looks first in the hash table to see if the full name of the\n    --  file is already available.\n \n    function Smart_File_Stamp\n-     (N    : File_Name_Type;\n-      T    : File_Type)\n-      return Time_Stamp_Type;\n+     (N : File_Name_Type;\n+      T : File_Type) return Time_Stamp_Type;\n    --  Takes the same parameter as the routine above (N is a file name\n    --  without any prefix directory information) and behaves like File_Stamp\n    --  except that if File_Cache_Enabled is True this routine looks first in\n@@ -591,8 +589,7 @@ package body Osint is\n \n    function Append_Suffix_To_File_Name\n      (Name   : Name_Id;\n-      Suffix : String)\n-      return   Name_Id\n+      Suffix : String) return Name_Id\n    is\n    begin\n       Get_Name_String (Name);\n@@ -785,7 +782,7 @@ package body Osint is\n          return new String'(\"\");\n       end Get_Install_Dir;\n \n-   --  Beginning of Executable_Prefix\n+   --  Start of processing for Executable_Prefix\n \n    begin\n       Osint.Fill_Arg (Exec_Name'Address, 0);\n@@ -799,7 +796,7 @@ package body Osint is\n          end if;\n       end loop;\n \n-      --  If you are here, the user has typed the executable name with no\n+      --  If we come here, the user has typed the executable name with no\n       --  directory prefix.\n \n       return Get_Install_Dir (GNAT.OS_Lib.Locate_Exec_On_Path (Exec_Name).all);\n@@ -890,9 +887,8 @@ package body Osint is\n    ---------------\n \n    function Find_File\n-     (N :    File_Name_Type;\n-      T :    File_Type)\n-      return File_Name_Type\n+     (N : File_Name_Type;\n+      T : File_Type) return File_Name_Type\n    is\n    begin\n       Get_Name_String (N);\n@@ -1089,8 +1085,7 @@ package body Osint is\n    --  call to Get_Next_Dir_In_Path_Init, updated by Get_Next_Dir_In_Path.\n \n    function Get_Next_Dir_In_Path\n-     (Search_Path : String_Access)\n-      return        String_Access\n+     (Search_Path : String_Access) return String_Access\n    is\n       Lower_Bound : Positive := Search_Path_Pos;\n       Upper_Bound : Positive;\n@@ -1143,8 +1138,7 @@ package body Osint is\n \n    function Get_RTS_Search_Dir\n      (Search_Dir : String;\n-      File_Type  : Search_File_Type)\n-      return       String_Ptr\n+      File_Type  : Search_File_Type) return String_Ptr\n    is\n       procedure Get_Current_Dir\n         (Dir    : System.Address;\n@@ -1299,6 +1293,28 @@ package body Osint is\n       end if;\n    end Get_RTS_Search_Dir;\n \n+   --------------------------------\n+   -- Include_Dir_Default_Prefix --\n+   --------------------------------\n+\n+   function Include_Dir_Default_Prefix return String is\n+      Include_Dir : String_Access :=\n+                      String_Access (Update_Path (Include_Dir_Default_Name));\n+\n+   begin\n+      if Include_Dir = null then\n+         return \"\";\n+\n+      else\n+         declare\n+            Result : constant String := Include_Dir.all;\n+         begin\n+            Free (Include_Dir);\n+            return Result;\n+         end;\n+      end if;\n+   end Include_Dir_Default_Prefix;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -1409,8 +1425,7 @@ package body Osint is\n      (N    : File_Name_Type;\n       T    : File_Type;\n       Dir  : Natural;\n-      Name : String)\n-      return File_Name_Type\n+      Name : String) return File_Name_Type\n    is\n       Dir_Name : String_Ptr;\n \n@@ -1451,9 +1466,8 @@ package body Osint is\n    -------------------------------\n \n    function Matching_Full_Source_Name\n-     (N    : File_Name_Type;\n-      T    : Time_Stamp_Type)\n-      return File_Name_Type\n+     (N : File_Name_Type;\n+      T : Time_Stamp_Type) return File_Name_Type\n    is\n    begin\n       Get_Name_String (N);\n@@ -1680,6 +1694,28 @@ package body Osint is\n       return Number_File_Names;\n    end Number_Of_Files;\n \n+   -------------------------------\n+   -- Object_Dir_Default_Prefix --\n+   -------------------------------\n+\n+   function Object_Dir_Default_Prefix return String is\n+      Object_Dir : String_Access :=\n+                     String_Access (Update_Path (Object_Dir_Default_Name));\n+\n+   begin\n+      if Object_Dir = null then\n+         return \"\";\n+\n+      else\n+         declare\n+            Result : constant String := Object_Dir.all;\n+         begin\n+            Free (Object_Dir);\n+            return Result;\n+         end;\n+      end if;\n+   end Object_Dir_Default_Prefix;\n+\n    ----------------------\n    -- Object_File_Name --\n    ----------------------\n@@ -1768,8 +1804,7 @@ package body Osint is\n    function Read_Default_Search_Dirs\n      (Search_Dir_Prefix       : String_Access;\n       Search_File             : String_Access;\n-      Search_Dir_Default_Name : String_Access)\n-      return                  String_Access\n+      Search_Dir_Default_Name : String_Access) return String_Access\n    is\n       Prefix_Len : constant Integer := Search_Dir_Prefix.all'Length;\n       Buffer     : String (1 .. Prefix_Len + Search_File.all'Length + 1);\n@@ -1888,8 +1923,7 @@ package body Osint is\n \n    function Read_Library_Info\n      (Lib_File  : File_Name_Type;\n-      Fatal_Err : Boolean := False)\n-      return      Text_Buffer_Ptr\n+      Fatal_Err : Boolean := False) return Text_Buffer_Ptr\n    is\n       Lib_FD : File_Descriptor;\n       --  The file descriptor for the current library file. A negative value\n@@ -2201,9 +2235,8 @@ package body Osint is\n    ----------------------\n \n    function Smart_File_Stamp\n-     (N    : File_Name_Type;\n-      T    : File_Type)\n-      return Time_Stamp_Type\n+     (N : File_Name_Type;\n+      T : File_Type) return Time_Stamp_Type\n    is\n       Time_Stamp : Time_Stamp_Type;\n \n@@ -2228,8 +2261,7 @@ package body Osint is\n \n    function Smart_Find_File\n      (N : File_Name_Type;\n-      T : File_Type)\n-      return File_Name_Type\n+      T : File_Type) return File_Name_Type\n    is\n       Full_File_Name : File_Name_Type;\n \n@@ -2320,13 +2352,11 @@ package body Osint is\n \n    function To_Canonical_Dir_Spec\n      (Host_Dir     : String;\n-      Prefix_Style : Boolean)\n-      return         String_Access\n+      Prefix_Style : Boolean) return String_Access\n    is\n       function To_Canonical_Dir_Spec\n         (Host_Dir    : Address;\n-         Prefix_Flag : Integer)\n-         return        Address;\n+         Prefix_Flag : Integer) return Address;\n       pragma Import (C, To_Canonical_Dir_Spec, \"__gnat_to_canonical_dir_spec\");\n \n       C_Host_Dir      : String (1 .. Host_Dir'Length + 1);\n@@ -2362,13 +2392,11 @@ package body Osint is\n \n    function To_Canonical_File_List\n      (Wildcard_Host_File : String;\n-      Only_Dirs          : Boolean)\n-      return               String_Access_List_Access\n+      Only_Dirs          : Boolean) return String_Access_List_Access\n    is\n       function To_Canonical_File_List_Init\n         (Host_File : Address;\n-         Only_Dirs : Integer)\n-      return Integer;\n+         Only_Dirs : Integer) return Integer;\n       pragma Import (C, To_Canonical_File_List_Init,\n                      \"__gnat_to_canonical_file_list_init\");\n \n@@ -2421,8 +2449,7 @@ package body Osint is\n    ----------------------------\n \n    function To_Canonical_File_Spec\n-     (Host_File : String)\n-      return      String_Access\n+     (Host_File : String) return String_Access\n    is\n       function To_Canonical_File_Spec (Host_File : Address) return Address;\n       pragma Import\n@@ -2457,8 +2484,7 @@ package body Osint is\n    ----------------------------\n \n    function To_Canonical_Path_Spec\n-     (Host_Path : String)\n-      return      String_Access\n+     (Host_Path : String) return String_Access\n    is\n       function To_Canonical_Path_Spec (Host_Path : Address) return Address;\n       pragma Import\n@@ -2492,13 +2518,11 @@ package body Osint is\n \n    function To_Host_Dir_Spec\n      (Canonical_Dir : String;\n-      Prefix_Style  : Boolean)\n-      return          String_Access\n+      Prefix_Style  : Boolean) return String_Access\n    is\n       function To_Host_Dir_Spec\n         (Canonical_Dir : Address;\n-         Prefix_Flag   : Integer)\n-         return          Address;\n+         Prefix_Flag   : Integer) return Address;\n       pragma Import (C, To_Host_Dir_Spec, \"__gnat_to_host_dir_spec\");\n \n       C_Canonical_Dir : String (1 .. Canonical_Dir'Length + 1);\n@@ -2528,8 +2552,7 @@ package body Osint is\n    ----------------------------\n \n    function To_Host_File_Spec\n-     (Canonical_File : String)\n-      return           String_Access\n+     (Canonical_File : String) return String_Access\n    is\n       function To_Host_File_Spec (Canonical_File : Address) return Address;\n       pragma Import (C, To_Host_File_Spec, \"__gnat_to_host_file_spec\");\n@@ -2559,8 +2582,7 @@ package body Osint is\n \n    function To_Path_String_Access\n      (Path_Addr : Address;\n-      Path_Len  : Integer)\n-      return      String_Access\n+      Path_Len  : Integer) return String_Access\n    is\n       subtype Path_String is String (1 .. Path_Len);\n       type    Path_String_Access is access Path_String;"}, {"sha": "18e261039dcf84384970d59d8a035b71b0d2a475", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -217,6 +217,14 @@ package Osint is\n    -- Search Dir Routines --\n    -------------------------\n \n+   function Include_Dir_Default_Prefix return String;\n+   --  Return the directory of the run-time library sources, as modified\n+   --  by update_path.\n+\n+   function Object_Dir_Default_Prefix return String;\n+   --  Return the directory of the run-time library ALI and object files, as\n+   --  modified by update_path.\n+\n    procedure Add_Default_Search_Dirs;\n    --  This routine adds the default search dirs indicated by the\n    --  environment variables and sdefault package."}, {"sha": "d7b0afb5c59dd42326d9867696a13347b4dc48f5", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -28,6 +28,8 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram body ordering check. Subprograms are in order\n --  by RM section rather than alphabetical\n \n+with Hostparm; use Hostparm;\n+\n separate (Par)\n package body Ch4 is\n \n@@ -1116,6 +1118,7 @@ package body Ch4 is\n    --  POSITIONAL_ARRAY_AGGREGATE ::=\n    --    (EXPRESSION, EXPRESSION {, EXPRESSION})\n    --  | (EXPRESSION {, EXPRESSION}, others => EXPRESSION)\n+   --  | (EXPRESSION {, EXPRESSION}, others => <>)\n \n    --  NAMED_ARRAY_AGGREGATE ::=\n    --    (ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION})\n@@ -1354,13 +1357,15 @@ package body Ch4 is\n \n    --  RECORD_COMPONENT_ASSOCIATION ::=\n    --    [COMPONENT_CHOICE_LIST =>] EXPRESSION\n+   --  | COMPONENT_CHOICE_LIST => <>\n \n    --  COMPONENT_CHOICE_LIST =>\n    --    component_SELECTOR_NAME {| component_SELECTOR_NAME}\n    --  | others\n \n    --  ARRAY_COMPONENT_ASSOCIATION ::=\n    --    DISCRETE_CHOICE_LIST => EXPRESSION\n+   --  | DISCRETE_CHOICE_LIST => <>\n \n    --  Note: this routine only handles the named cases, including others.\n    --  Cases where the component choice list is not present have already\n@@ -1376,7 +1381,27 @@ package body Ch4 is\n       Set_Choices (Assoc_Node, P_Discrete_Choice_List);\n       Set_Sloc (Assoc_Node, Token_Ptr);\n       TF_Arrow;\n-      Set_Expression (Assoc_Node, P_Expression);\n+\n+      if Token = Tok_Box then\n+         if not Extensions_Allowed then\n+            Error_Msg_SP\n+              (\"Limited aggregates are an Ada0X extension\");\n+\n+            if OpenVMS then\n+               Error_Msg_SP\n+                 (\"\\unit must be compiled with \" &\n+                  \"'/'E'X'T'E'N'S'I'O'N'S'_'A'L'L'O'W'E'D qualifier\");\n+            else\n+               Error_Msg_SP\n+                 (\"\\unit must be compiled with -gnatX switch\");\n+            end if;\n+         end if;\n+\n+         Set_Box_Present (Assoc_Node);\n+         Scan; -- Past box\n+      else\n+         Set_Expression (Assoc_Node, P_Expression);\n+      end if;\n       return Assoc_Node;\n    end P_Record_Or_Array_Component_Association;\n "}, {"sha": "fe6d1f936a48b77cc0e8d6deed53b64a2d269b66", "filename": "gcc/ada/s-thread.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fs-thread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fs-thread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -31,13 +31,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the VxWorks/Cert version of this package\n+--  This is the VxWorks version of this package\n \n-with System.Init;\n with System.Secondary_Stack;\n \n with Unchecked_Conversion;\n \n+with System.Threads.Initialization;\n+\n package body System.Threads is\n \n    package SSS renames System.Secondary_Stack;\n@@ -48,6 +49,12 @@ package body System.Threads is\n    function From_Address is\n       new Unchecked_Conversion (Address, ATSD_Access);\n \n+   procedure Init_Float;\n+   pragma Import (C, Init_Float, \"__gnat_init_float\");\n+\n+   procedure Install_Handler;\n+   pragma Import (C, Install_Handler, \"__gnat_install_handler\");\n+\n    -----------------------\n    -- Get_Current_Excep --\n    -----------------------\n@@ -122,8 +129,8 @@ package body System.Threads is\n       SSS.SS_Init (TSD.Sec_Stack_Addr, Sec_Stack_Size);\n       Current_ATSD := Process_ATSD_Address;\n \n-      System.Init.Install_Handler;\n-      System.Init.Init_Float;\n+      Install_Handler;\n+      Init_Float;\n    end Thread_Body_Enter;\n \n    ----------------------------------\n@@ -136,6 +143,7 @@ package body System.Threads is\n       pragma Unreferenced (EO);\n    begin\n       --  No action for this target\n+\n       null;\n    end Thread_Body_Exceptional_Exit;\n \n@@ -146,7 +154,10 @@ package body System.Threads is\n    procedure Thread_Body_Leave is\n    begin\n       --  No action for this target\n+\n       null;\n    end Thread_Body_Leave;\n \n+begin\n+   System.Threads.Initialization.Init_RTS;\n end System.Threads;"}, {"sha": "8a7f003ced87de91a7105276bfd994639d4bed83", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 129, "deletions": 25, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -866,7 +866,9 @@ package body Sem_Aggr is\n          Error_Msg_N (\"aggregate type cannot have limited component\", N);\n          Explain_Limited_Type (Typ, N);\n \n-      elsif Is_Limited_Type (Typ) then\n+      elsif Is_Limited_Type (Typ)\n+        and not Extensions_Allowed\n+      then\n          Error_Msg_N (\"aggregate type cannot be limited\", N);\n          Explain_Limited_Type (Typ, N);\n \n@@ -1913,7 +1915,9 @@ package body Sem_Aggr is\n          Error_Msg_N (\"type of extension aggregate must be tagged\", N);\n          return;\n \n-      elsif Is_Limited_Type (Typ) then\n+      elsif Is_Limited_Type (Typ)\n+        and not Extensions_Allowed\n+      then\n          Error_Msg_N (\"aggregate type cannot be limited\", N);\n          Explain_Limited_Type (Typ, N);\n          return;\n@@ -2017,7 +2021,19 @@ package body Sem_Aggr is\n       --\n       --  This variable is updated as a side effect of function Get_Value\n \n-      procedure Add_Association (Component : Entity_Id; Expr : Node_Id);\n+      Mbox_Present : Boolean := False;\n+      Others_Mbox  : Boolean := False;\n+      --  Variables used in case of default initialization to provide a\n+      --  functionality similar to Others_Etype. Mbox_Present indicates\n+      --  that the component takes its default initialization; Others_Mbox\n+      --  indicates that at least one component takes its default initiali-\n+      --  zation. Similar to Others_Etype, they are also updated as a side\n+      --  effect of function Get_Value.\n+\n+      procedure Add_Association\n+        (Component   : Entity_Id;\n+         Expr        : Node_Id;\n+         Box_Present : Boolean := False);\n       --  Builds a new N_Component_Association node which associates\n       --  Component to expression Expr and adds it to the new association\n       --  list New_Assoc_List being built.\n@@ -2064,16 +2080,21 @@ package body Sem_Aggr is\n       -- Add_Association --\n       ---------------------\n \n-      procedure Add_Association (Component : Entity_Id; Expr : Node_Id) is\n+      procedure Add_Association\n+        (Component   : Entity_Id;\n+         Expr        : Node_Id;\n+         Box_Present : Boolean := False)\n+      is\n          Choice_List : constant List_Id := New_List;\n          New_Assoc   : Node_Id;\n \n       begin\n          Append (New_Occurrence_Of (Component, Sloc (Expr)), Choice_List);\n          New_Assoc :=\n            Make_Component_Association (Sloc (Expr),\n-             Choices    => Choice_List,\n-             Expression => Expr);\n+             Choices     => Choice_List,\n+             Expression  => Expr,\n+             Box_Present => Box_Present);\n          Append (New_Assoc, New_Assoc_List);\n       end Add_Association;\n \n@@ -2174,7 +2195,37 @@ package body Sem_Aggr is\n          Expr          : Node_Id := Empty;\n          Selector_Name : Node_Id;\n \n+         procedure Check_Non_Limited_Type;\n+         --  Relax check to allow the default initialization of limited types.\n+         --  For example:\n+         --      record\n+         --         C : Lim := (..., others => <>);\n+         --      end record;\n+\n+         procedure Check_Non_Limited_Type is\n+         begin\n+            if Is_Limited_Type (Etype (Compon))\n+               and then Comes_From_Source (Compon)\n+               and then not In_Instance_Body\n+            then\n+\n+               if Extensions_Allowed\n+                 and then Present (Expression (Assoc))\n+                 and then Nkind (Expression (Assoc)) = N_Aggregate\n+               then\n+                  null;\n+               else\n+                  Error_Msg_N\n+                    (\"initialization not allowed for limited types\", N);\n+                  Explain_Limited_Type (Etype (Compon), Compon);\n+               end if;\n+\n+            end if;\n+         end Check_Non_Limited_Type;\n+\n       begin\n+         Mbox_Present := False;\n+\n          if Present (From) then\n             Assoc := First (From);\n          else\n@@ -2186,14 +2237,6 @@ package body Sem_Aggr is\n             while Present (Selector_Name) loop\n                if Nkind (Selector_Name) = N_Others_Choice then\n                   if Consider_Others_Choice and then No (Expr) then\n-                     if Present (Others_Etype) and then\n-                        Base_Type (Others_Etype) /= Base_Type (Etype (Compon))\n-                     then\n-                        Error_Msg_N (\"components in OTHERS choice must \" &\n-                                     \"have same type\", Selector_Name);\n-                     end if;\n-\n-                     Others_Etype := Etype (Compon);\n \n                      --  We need to duplicate the expression for each\n                      --  successive component covered by the others choice.\n@@ -2202,10 +2245,34 @@ package body Sem_Aggr is\n                      --  indispensable otherwise, because each one must be\n                      --  expanded individually to preserve side-effects.\n \n-                     if Expander_Active then\n-                        return New_Copy_Tree (Expression (Assoc));\n+                     if Box_Present (Assoc) then\n+                        Others_Mbox  := True;\n+                        Mbox_Present := True;\n+\n+                        if Expander_Active then\n+                           return New_Copy_Tree (Expression (Parent (Compon)));\n+                        else\n+                           return Expression (Parent (Compon));\n+                        end if;\n                      else\n-                        return Expression (Assoc);\n+\n+                        Check_Non_Limited_Type;\n+\n+                        if Present (Others_Etype) and then\n+                           Base_Type (Others_Etype) /= Base_Type (Etype\n+                                                                   (Compon))\n+                        then\n+                           Error_Msg_N (\"components in OTHERS choice must \" &\n+                                        \"have same type\", Selector_Name);\n+                        end if;\n+\n+                        Others_Etype := Etype (Compon);\n+\n+                        if Expander_Active then\n+                           return New_Copy_Tree (Expression (Assoc));\n+                        else\n+                           return Expression (Assoc);\n+                        end if;\n                      end if;\n                   end if;\n \n@@ -2216,10 +2283,27 @@ package body Sem_Aggr is\n                      --  components are grouped together with a \"|\" choice.\n                      --  For instance \"filed1 | filed2 => Expr\"\n \n-                     if Present (Next (Selector_Name)) then\n-                        Expr := New_Copy_Tree (Expression (Assoc));\n+                     if Box_Present (Assoc) then\n+                        Mbox_Present := True;\n+\n+                        --  Duplicate the default expression of the component\n+                        --  from the record type declaration\n+\n+                        if Present (Next (Selector_Name)) then\n+                           Expr := New_Copy_Tree\n+                                     (Expression (Parent (Compon)));\n+                        else\n+                           Expr := Expression (Parent (Compon));\n+                        end if;\n                      else\n-                        Expr := Expression (Assoc);\n+\n+                        Check_Non_Limited_Type;\n+\n+                        if Present (Next (Selector_Name)) then\n+                           Expr := New_Copy_Tree (Expression (Assoc));\n+                        else\n+                           Expr := Expression (Assoc);\n+                        end if;\n                      end if;\n \n                      Generate_Reference (Compon, Selector_Name);\n@@ -2753,7 +2837,18 @@ package body Sem_Aggr is\n          Component := Node (Component_Elmt);\n          Expr := Get_Value (Component, Component_Associations (N), True);\n \n-         if No (Expr) then\n+         if Mbox_Present and then Is_Limited_Type (Etype (Component)) then\n+\n+            --  In case of default initialization of a limited component we\n+            --  pass the limited component to the expander. The expander will\n+            --  generate calls to the corresponding initialization subprograms.\n+\n+            Add_Association\n+              (Component   => Component,\n+               Expr        => Empty,\n+               Box_Present => True);\n+\n+         elsif No (Expr) then\n             Error_Msg_NE (\"no value supplied for component &!\", N, Component);\n          else\n             Resolve_Aggr_Expr (Expr, Component);\n@@ -2783,7 +2878,9 @@ package body Sem_Aggr is\n             Typech := Empty;\n \n             if Nkind (Selectr) = N_Others_Choice then\n-               if No (Others_Etype) then\n+               if No (Others_Etype)\n+                  and then not Others_Mbox\n+               then\n                   Error_Msg_N\n                     (\"OTHERS must represent at least one component\", Selectr);\n                end if;\n@@ -2804,8 +2901,10 @@ package body Sem_Aggr is\n                --  component supplied by a previous expansion.\n \n                if No (New_Assoc) then\n+                  if Box_Present (Parent (Selectr)) then\n+                     null;\n \n-                  if Chars (Selectr) /= Name_uTag\n+                  elsif Chars (Selectr) /= Name_uTag\n                     and then Chars (Selectr) /= Name_uParent\n                     and then Chars (Selectr) /= Name_uController\n                   then\n@@ -2827,8 +2926,13 @@ package body Sem_Aggr is\n                   Typech := Base_Type (Etype (Component));\n \n                elsif Typech /= Base_Type (Etype (Component)) then\n-                  Error_Msg_N\n-                    (\"components in choice list must have same type\", Selectr);\n+\n+                  if not Box_Present (Parent (Selectr)) then\n+                     Error_Msg_N\n+                       (\"components in choice list must have same type\",\n+                        Selectr);\n+                  end if;\n+\n                end if;\n \n                Next (Selectr);"}, {"sha": "38c7580c846fd32ad56fe28eccace2840a9a0447", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -6234,9 +6234,19 @@ package body Sem_Ch3 is\n            or else Is_Limited_Composite (T))\n         and then not In_Instance\n       then\n-         Error_Msg_N\n-           (\"cannot initialize entities of limited type\", Exp);\n-         Explain_Limited_Type (T, Exp);\n+         --  Relax the strictness of the front-end in case of limited\n+         --  aggregates and extension aggregates.\n+\n+         if Extensions_Allowed\n+           and then (Nkind (Exp) = N_Aggregate\n+                     or else Nkind (Exp) = N_Extension_Aggregate)\n+         then\n+            null;\n+         else\n+            Error_Msg_N\n+              (\"cannot initialize entities of limited type\", Exp);\n+            Explain_Limited_Type (T, Exp);\n+         end if;\n       end if;\n    end Check_Initialization;\n "}, {"sha": "1e363590e025495c4e65da526d3d21b0f8918115", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -338,7 +338,8 @@ package body Sem_Ch4 is\n             Check_Restriction (No_Protected_Type_Allocators, N);\n          end if;\n \n-         if Is_Limited_Type (Type_Id)\n+         if Nkind (Expression (E)) /= N_Aggregate\n+           and then Is_Limited_Type (Type_Id)\n            and then Comes_From_Source (N)\n            and then not In_Instance_Body\n          then"}, {"sha": "5240193769950e2a34d235f6e533689e4460002c", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -4063,10 +4063,9 @@ package body Sem_Ch8 is\n                if Is_Access_Type (P_Type)\n                  and then Ekind (Designated_Type (P_Type)) = E_Incomplete_Type\n                then\n-                  Error_Msg_Node_2 := Selector_Name (N);\n-                  Error_Msg_NE (\n-                    \"\\incomplete type& has no visible component&\", P,\n-                      Designated_Type (P_Type));\n+                  Error_Msg_N\n+                    (\"\\dereference must not be of an incomplete type \" &\n+                       \"('R'M 3.10.1)\", P);\n                end if;\n \n             else"}, {"sha": "d7bff861585fdb91ce7bd142305c6dac6c2f937d", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -294,6 +294,7 @@ package body Sem_Ch9 is\n             while Present (E1) loop\n \n                if Ekind (E1) = E_Procedure\n+                 and then Chars (E1) = Chars (Entry_Nam)\n                  and then Type_Conformant (E1, Entry_Nam)\n                then\n                   Error_Msg_N (\"entry name is not visible\", N);"}, {"sha": "ed3adbd051bfd9eac47a46580a201fd6c3772cf3", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -1940,9 +1940,25 @@ package body Sem_Res is\n                if Is_Overloaded (N)\n                  and then Nkind (N) = N_Function_Call\n                then\n-                  Error_Msg_Node_2 := Typ;\n-                  Error_Msg_NE (\"no visible interpretation of&\" &\n-                    \" matches expected type&\", N, Name (N));\n+                  declare\n+                     Subp_Name : Node_Id;\n+                  begin\n+                     if Is_Entity_Name (Name (N)) then\n+                        Subp_Name := Name (N);\n+\n+                     elsif Nkind (Name (N)) = N_Selected_Component then\n+\n+                        --  Protected operation: retrieve operation name.\n+\n+                        Subp_Name := Selector_Name (Name (N));\n+                     else\n+                        raise Program_Error;\n+                     end if;\n+\n+                     Error_Msg_Node_2 := Typ;\n+                     Error_Msg_NE (\"no visible interpretation of&\" &\n+                       \" matches expected type&\", N, Subp_Name);\n+                  end;\n \n                   if All_Errors_Mode then\n                      declare"}, {"sha": "3f734d756a61e640a8355233e7c9b87000e8764f", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -297,6 +297,7 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Component_Association\n         or else NT (N).Nkind = N_Formal_Package_Declaration\n         or else NT (N).Nkind = N_Formal_Subprogram_Declaration);\n       return Flag15 (N);\n@@ -2729,6 +2730,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Component_Association\n         or else NT (N).Nkind = N_Formal_Package_Declaration\n         or else NT (N).Nkind = N_Formal_Subprogram_Declaration);\n       Set_Flag15 (N, Val);"}, {"sha": "acadd64052cac8e3bc828f3af399d48899c2e014", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -3008,6 +3008,7 @@ package Sinfo is\n       --  Choices (List1)\n       --  Loop_Actions (List2-Sem)\n       --  Expression (Node3)\n+      --  Box_Present (Flag15)\n \n       --  Note: this structure is used for both record component associations\n       --  and array component associations, since the two cases aren't always"}, {"sha": "9d1e37a10160a7653ac7ddf5857e515916273dbf", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -928,7 +928,11 @@ package body Sprint is\n             Set_Debug_Sloc;\n             Sprint_Bar_List (Choices (Node));\n             Write_Str (\" => \");\n-            Sprint_Node (Expression (Node));\n+            if Box_Present (Node) then\n+               Write_Str_With_Col_Check (\"<>\");\n+            else\n+               Sprint_Node (Expression (Node));\n+            end if;\n \n          when N_Component_Clause =>\n             Write_Indent;"}, {"sha": "479ecde92ee295b207db9d384e99f54f2879e6ce", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 655, "deletions": 666, "changes": 1321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -25,8 +25,7 @@\n ------------------------------------------------------------------------------\n \n with Hostparm;\n-with Osint;    use Osint;\n-with Sdefault; use Sdefault;\n+with Osint; use Osint;\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n with Ada.Command_Line;        use Ada.Command_Line;\n@@ -141,7 +140,7 @@ package body VMS_Conv is\n \n    begin\n       Object_Dirs := 0;\n-      Object_Dir_Name := String_Access (Object_Dir_Default_Name);\n+      Object_Dir_Name := new String'(Object_Dir_Default_Prefix);\n       Get_Next_Dir_In_Path_Init (Object_Dir_Name);\n \n       loop\n@@ -287,13 +286,13 @@ package body VMS_Conv is\n \n          Make =>\n            (Cname    => new S'(\"MAKE\"),\n-            Usage    => new S'(\"GNAT MAKE file /qualifiers (includes \"\n+            Usage    => new S'(\"GNAT MAKE file(s) /qualifiers (includes \"\n                                & \"COMPILE /qualifiers)\"),\n             VMS_Only => False,\n             Unixcmd  => new S'(\"gnatmake\"),\n             Unixsws  => null,\n             Switches => Make_Switches'Access,\n-            Params   => new Parameter_Array'(1 => File),\n+            Params   => new Parameter_Array'(1 => Unlimited_Files),\n             Defext   => \"   \"),\n \n          Name =>\n@@ -340,16 +339,6 @@ package body VMS_Conv is\n             Params   => new Parameter_Array'(1 => Unlimited_Files),\n             Defext   => \"   \"),\n \n-         Standard =>\n-           (Cname    => new S'(\"STANDARD\"),\n-            Usage    => new S'(\"GNAT STANDARD\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatpsta\"),\n-            Unixsws  => null,\n-            Switches => Standard_Switches'Access,\n-            Params   => new Parameter_Array'(1 .. 0 => File),\n-            Defext   => \"   \"),\n-\n          Stub =>\n            (Cname    => new S'(\"STUB\"),\n             Usage    => new S'(\"GNAT STUB file [directory]/qualifiers\"),\n@@ -1092,231 +1081,270 @@ package body VMS_Conv is\n             Arg_Idx := Argv'First;\n \n             <<Tryagain_After_Coalesce>>\n-               loop\n-                  declare\n-                     Next_Arg_Idx : Integer;\n-                     Arg          : String_Access;\n-\n-                  begin\n-                     Next_Arg_Idx := Get_Arg_End (Argv.all, Arg_Idx);\n-                     Arg := new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n+            loop\n+               declare\n+                  Next_Arg_Idx : Integer;\n+                  Arg          : String_Access;\n \n-                     --  The first one must be a command name\n+               begin\n+                  Next_Arg_Idx := Get_Arg_End (Argv.all, Arg_Idx);\n+                  Arg := new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n \n-                     if Arg_Num = 1 and then Arg_Idx = Argv'First then\n+                  --  The first one must be a command name\n \n-                        Command := Matching_Name (Arg.all, Commands);\n+                  if Arg_Num = 1 and then Arg_Idx = Argv'First then\n \n-                        if Command = null then\n-                           raise Error_Exit;\n-                        end if;\n+                     Command := Matching_Name (Arg.all, Commands);\n \n-                        The_Command := Command.Command;\n+                     if Command = null then\n+                        raise Error_Exit;\n+                     end if;\n \n-                        --  Give usage information if only command given\n+                     The_Command := Command.Command;\n \n-                        if Argument_Count = 1 and then Next_Arg_Idx = Argv'Last\n-                          and then Command.Command /= VMS_Conv.Standard\n-                        then\n-                           Output_Version;\n-                           New_Line;\n-                           Put_Line\n-                             (\"List of available qualifiers and options\");\n-                           New_Line;\n+                     --  Give usage information if only command given\n \n-                           Put (Command.Usage.all);\n-                           Set_Col (53);\n-                           Put_Line (Command.Unix_String.all);\n+                     if Argument_Count = 1\n+                       and then Next_Arg_Idx = Argv'Last\n+                     then\n+                        Output_Version;\n+                        New_Line;\n+                        Put_Line\n+                          (\"List of available qualifiers and options\");\n+                        New_Line;\n \n-                           declare\n-                              Sw : Item_Ptr := Command.Switches;\n+                        Put (Command.Usage.all);\n+                        Set_Col (53);\n+                        Put_Line (Command.Unix_String.all);\n \n-                           begin\n-                              while Sw /= null loop\n-                                 Put (\"   \");\n-                                 Put (Sw.Name.all);\n+                        declare\n+                           Sw : Item_Ptr := Command.Switches;\n \n-                                 case Sw.Translation is\n+                        begin\n+                           while Sw /= null loop\n+                              Put (\"   \");\n+                              Put (Sw.Name.all);\n \n-                                    when T_Other =>\n-                                       Set_Col (53);\n-                                       Put_Line (Sw.Unix_String.all &\n-                                                 \"/<other>\");\n+                              case Sw.Translation is\n \n-                                    when T_Direct =>\n-                                       Set_Col (53);\n-                                       Put_Line (Sw.Unix_String.all);\n+                                 when T_Other =>\n+                                    Set_Col (53);\n+                                    Put_Line (Sw.Unix_String.all &\n+                                              \"/<other>\");\n \n-                                    when T_Directories =>\n-                                       Put (\"=(direc,direc,..direc)\");\n-                                       Set_Col (53);\n-                                       Put (Sw.Unix_String.all);\n-                                       Put (\" direc \");\n-                                       Put (Sw.Unix_String.all);\n-                                       Put_Line (\" direc ...\");\n+                                 when T_Direct =>\n+                                    Set_Col (53);\n+                                    Put_Line (Sw.Unix_String.all);\n \n-                                    when T_Directory =>\n-                                       Put (\"=directory\");\n-                                       Set_Col (53);\n-                                       Put (Sw.Unix_String.all);\n+                                 when T_Directories =>\n+                                    Put (\"=(direc,direc,..direc)\");\n+                                    Set_Col (53);\n+                                    Put (Sw.Unix_String.all);\n+                                    Put (\" direc \");\n+                                    Put (Sw.Unix_String.all);\n+                                    Put_Line (\" direc ...\");\n \n-                                       if Sw.Unix_String (Sw.Unix_String'Last)\n-                                         /= '='\n-                                       then\n-                                          Put (' ');\n-                                       end if;\n+                                 when T_Directory =>\n+                                    Put (\"=directory\");\n+                                    Set_Col (53);\n+                                    Put (Sw.Unix_String.all);\n \n-                                       Put_Line (\"directory \");\n+                                    if Sw.Unix_String (Sw.Unix_String'Last)\n+                                    /= '='\n+                                    then\n+                                       Put (' ');\n+                                    end if;\n \n-                                    when T_File | T_No_Space_File =>\n-                                       Put (\"=file\");\n-                                       Set_Col (53);\n-                                       Put (Sw.Unix_String.all);\n+                                    Put_Line (\"directory \");\n \n-                                       if Sw.Translation = T_File\n-                                         and then Sw.Unix_String\n-                                                   (Sw.Unix_String'Last)\n-                                                     /= '='\n-                                       then\n-                                          Put (' ');\n-                                       end if;\n+                                 when T_File | T_No_Space_File =>\n+                                    Put (\"=file\");\n+                                    Set_Col (53);\n+                                    Put (Sw.Unix_String.all);\n+\n+                                    if Sw.Translation = T_File\n+                                      and then Sw.Unix_String\n+                                        (Sw.Unix_String'Last)\n+                                    /= '='\n+                                    then\n+                                       Put (' ');\n+                                    end if;\n \n-                                       Put_Line (\"file \");\n+                                    Put_Line (\"file \");\n \n-                                    when T_Numeric =>\n-                                       Put (\"=nnn\");\n-                                       Set_Col (53);\n+                                 when T_Numeric =>\n+                                    Put (\"=nnn\");\n+                                    Set_Col (53);\n \n-                                       if Sw.Unix_String (Sw.Unix_String'First)\n-                                         = '`'\n-                                       then\n-                                          Put (Sw.Unix_String\n-                                               (Sw.Unix_String'First + 1\n-                                                .. Sw.Unix_String'Last));\n-                                       else\n-                                          Put (Sw.Unix_String.all);\n-                                       end if;\n+                                    if Sw.Unix_String (Sw.Unix_String'First)\n+                                    = '`'\n+                                    then\n+                                       Put (Sw.Unix_String\n+                                              (Sw.Unix_String'First + 1\n+                                               .. Sw.Unix_String'Last));\n+                                    else\n+                                       Put (Sw.Unix_String.all);\n+                                    end if;\n \n-                                       Put_Line (\"nnn\");\n+                                    Put_Line (\"nnn\");\n \n-                                    when T_Alphanumplus =>\n-                                       Put (\"=xyz\");\n-                                       Set_Col (53);\n+                                 when T_Alphanumplus =>\n+                                    Put (\"=xyz\");\n+                                    Set_Col (53);\n \n-                                       if Sw.Unix_String (Sw.Unix_String'First)\n-                                         = '`'\n-                                       then\n-                                          Put (Sw.Unix_String\n-                                               (Sw.Unix_String'First + 1\n-                                                .. Sw.Unix_String'Last));\n-                                       else\n-                                          Put (Sw.Unix_String.all);\n-                                       end if;\n+                                    if Sw.Unix_String (Sw.Unix_String'First)\n+                                    = '`'\n+                                    then\n+                                       Put (Sw.Unix_String\n+                                              (Sw.Unix_String'First + 1\n+                                               .. Sw.Unix_String'Last));\n+                                    else\n+                                       Put (Sw.Unix_String.all);\n+                                    end if;\n \n-                                       Put_Line (\"xyz\");\n+                                    Put_Line (\"xyz\");\n \n-                                    when T_String =>\n-                                       Put (\"=\");\n-                                       Put ('\"');\n-                                       Put (\"<string>\");\n-                                       Put ('\"');\n-                                       Set_Col (53);\n+                                 when T_String =>\n+                                    Put (\"=\");\n+                                    Put ('\"');\n+                                    Put (\"<string>\");\n+                                    Put ('\"');\n+                                    Set_Col (53);\n \n-                                       Put (Sw.Unix_String.all);\n+                                    Put (Sw.Unix_String.all);\n \n-                                       if Sw.Unix_String (Sw.Unix_String'Last)\n-                                         /= '='\n-                                       then\n-                                          Put (' ');\n-                                       end if;\n+                                    if Sw.Unix_String (Sw.Unix_String'Last)\n+                                    /= '='\n+                                    then\n+                                       Put (' ');\n+                                    end if;\n \n-                                       Put (\"<string>\");\n-                                       New_Line;\n+                                    Put (\"<string>\");\n+                                    New_Line;\n \n-                                    when T_Commands =>\n-                                       Put (\" (switches for \");\n-                                       Put (Sw.Unix_String\n-                                            (Sw.Unix_String'First + 7\n-                                             .. Sw.Unix_String'Last));\n-                                       Put (')');\n-                                       Set_Col (53);\n-                                       Put (Sw.Unix_String\n-                                            (Sw.Unix_String'First\n-                                             .. Sw.Unix_String'First + 5));\n-                                       Put_Line (\" switches\");\n+                                 when T_Commands =>\n+                                    Put (\" (switches for \");\n+                                    Put (Sw.Unix_String\n+                                           (Sw.Unix_String'First + 7\n+                                            .. Sw.Unix_String'Last));\n+                                    Put (')');\n+                                    Set_Col (53);\n+                                    Put (Sw.Unix_String\n+                                           (Sw.Unix_String'First\n+                                            .. Sw.Unix_String'First + 5));\n+                                    Put_Line (\" switches\");\n \n-                                    when T_Options =>\n-                                       declare\n-                                          Opt : Item_Ptr := Sw.Options;\n+                                 when T_Options =>\n+                                    declare\n+                                       Opt : Item_Ptr := Sw.Options;\n \n-                                       begin\n-                                          Put_Line (\"=(option,option..)\");\n+                                    begin\n+                                       Put_Line (\"=(option,option..)\");\n \n-                                          while Opt /= null loop\n-                                             Put (\"      \");\n-                                             Put (Opt.Name.all);\n+                                       while Opt /= null loop\n+                                          Put (\"      \");\n+                                          Put (Opt.Name.all);\n \n-                                             if Opt = Sw.Options then\n-                                                Put (\" (D)\");\n-                                             end if;\n+                                          if Opt = Sw.Options then\n+                                             Put (\" (D)\");\n+                                          end if;\n \n-                                             Set_Col (53);\n-                                             Put_Line (Opt.Unix_String.all);\n-                                             Opt := Opt.Next;\n-                                          end loop;\n-                                       end;\n+                                          Set_Col (53);\n+                                          Put_Line (Opt.Unix_String.all);\n+                                          Opt := Opt.Next;\n+                                       end loop;\n+                                    end;\n \n-                                 end case;\n+                              end case;\n \n-                                 Sw := Sw.Next;\n-                              end loop;\n-                           end;\n+                              Sw := Sw.Next;\n+                           end loop;\n+                        end;\n \n-                           raise Normal_Exit;\n-                        end if;\n+                        raise Normal_Exit;\n+                     end if;\n \n                      --  Special handling for internal debugging switch /?\n \n-                     elsif Arg.all = \"/?\" then\n-                        Display_Command := True;\n+                  elsif Arg.all = \"/?\" then\n+                     Display_Command := True;\n \n                      --  Copy -switch unchanged\n \n-                     elsif Arg (Arg'First) = '-' then\n-                        Place (' ');\n-                        Place (Arg.all);\n+                  elsif Arg (Arg'First) = '-' then\n+                     Place (' ');\n+                     Place (Arg.all);\n \n                      --  Copy quoted switch with quotes stripped\n \n-                     elsif Arg (Arg'First) = '\"' then\n-                        if Arg (Arg'Last) /= '\"' then\n-                           Put (Standard_Error, \"misquoted argument: \");\n-                           Put_Line (Standard_Error, Arg.all);\n-                           Errors := Errors + 1;\n+                  elsif Arg (Arg'First) = '\"' then\n+                     if Arg (Arg'Last) /= '\"' then\n+                        Put (Standard_Error, \"misquoted argument: \");\n+                        Put_Line (Standard_Error, Arg.all);\n+                        Errors := Errors + 1;\n \n-                        else\n-                           Place (' ');\n-                           Place (Arg (Arg'First + 1 .. Arg'Last - 1));\n-                        end if;\n+                     else\n+                        Place (' ');\n+                        Place (Arg (Arg'First + 1 .. Arg'Last - 1));\n+                     end if;\n \n                      --  Parameter Argument\n \n-                     elsif Arg (Arg'First) /= '/'\n-                       and then Make_Commands_Active = null\n-                     then\n-                        Param_Count := Param_Count + 1;\n+                  elsif Arg (Arg'First) /= '/'\n+                    and then Make_Commands_Active = null\n+                  then\n+                     Param_Count := Param_Count + 1;\n \n-                        if Param_Count <= Command.Params'Length then\n+                     if Param_Count <= Command.Params'Length then\n \n-                           case Command.Params (Param_Count) is\n+                        case Command.Params (Param_Count) is\n \n-                              when File | Optional_File =>\n-                                 declare\n-                                    Normal_File : constant String_Access :=\n-                                                    To_Canonical_File_Spec\n-                                                      (Arg.all);\n+                           when File | Optional_File =>\n+                              declare\n+                                 Normal_File : constant String_Access :=\n+                                   To_Canonical_File_Spec\n+                                     (Arg.all);\n \n-                                 begin\n+                              begin\n+                                 Place (' ');\n+                                 Place_Lower (Normal_File.all);\n+\n+                                 if Is_Extensionless (Normal_File.all)\n+                                   and then Command.Defext /= \"   \"\n+                                 then\n+                                    Place ('.');\n+                                    Place (Command.Defext);\n+                                 end if;\n+                              end;\n+\n+                           when Unlimited_Files =>\n+                              declare\n+                                 Normal_File :\n+                                 constant String_Access :=\n+                                   To_Canonical_File_Spec (Arg.all);\n+\n+                                 File_Is_Wild  : Boolean := False;\n+                                 File_List     : String_Access_List_Access;\n+\n+                              begin\n+                                 for J in Arg'Range loop\n+                                    if Arg (J) = '*'\n+                                      or else Arg (J) = '%'\n+                                    then\n+                                       File_Is_Wild := True;\n+                                    end if;\n+                                 end loop;\n+\n+                                 if File_Is_Wild then\n+                                    File_List := To_Canonical_File_List\n+                                      (Arg.all, False);\n+\n+                                    for J in File_List.all'Range loop\n+                                       Place (' ');\n+                                       Place_Lower (File_List.all (J).all);\n+                                    end loop;\n+\n+                                 else\n                                     Place (' ');\n                                     Place_Lower (Normal_File.all);\n \n@@ -1326,36 +1354,92 @@ package body VMS_Conv is\n                                        Place ('.');\n                                        Place (Command.Defext);\n                                     end if;\n-                                 end;\n+                                 end if;\n \n-                              when Unlimited_Files =>\n-                                 declare\n-                                    Normal_File :\n-                                      constant String_Access :=\n-                                        To_Canonical_File_Spec (Arg.all);\n+                                 Param_Count := Param_Count - 1;\n+                              end;\n+\n+                           when Other_As_Is =>\n+                              Place (' ');\n+                              Place (Arg.all);\n+\n+                           when Unlimited_As_Is =>\n+                              Place (' ');\n+                              Place (Arg.all);\n+                              Param_Count := Param_Count - 1;\n+\n+                           when Files_Or_Wildcard =>\n+\n+                              --  Remove spaces from a comma separated list\n+                              --  of file names and adjust control variables\n+                              --  accordingly.\n+\n+                              while Arg_Num < Argument_Count and then\n+                                (Argv (Argv'Last) = ',' xor\n+                                   Argument (Arg_Num + 1)\n+                                   (Argument (Arg_Num + 1)'First) = ',')\n+                              loop\n+                                 Argv := new String'\n+                                   (Argv.all & Argument (Arg_Num + 1));\n+                                 Arg_Num := Arg_Num + 1;\n+                                 Arg_Idx := Argv'First;\n+                                 Next_Arg_Idx :=\n+                                   Get_Arg_End (Argv.all, Arg_Idx);\n+                                 Arg := new String'\n+                                   (Argv (Arg_Idx .. Next_Arg_Idx));\n+                              end loop;\n+\n+                              --  Parse the comma separated list of VMS\n+                              --  filenames and place them on the command\n+                              --  line as space separated Unix style\n+                              --  filenames. Lower case and add default\n+                              --  extension as appropriate.\n \n-                                    File_Is_Wild  : Boolean := False;\n-                                    File_List     : String_Access_List_Access;\n+                              declare\n+                                 Arg1_Idx : Integer := Arg'First;\n+\n+                                 function Get_Arg1_End\n+                                   (Arg  : String; Arg_Idx : Integer)\n+                                       return Integer;\n+                                 --  Begins looking at Arg_Idx + 1 and\n+                                 --  returns the index of the last character\n+                                 --  before a comma or else the index of the\n+                                 --  last character in the string Arg.\n \n+                                 ------------------\n+                                 -- Get_Arg1_End --\n+                                 ------------------\n+\n+                                 function Get_Arg1_End\n+                                   (Arg  : String; Arg_Idx : Integer)\n+                                       return Integer\n+                                 is\n                                  begin\n-                                    for J in Arg'Range loop\n-                                       if Arg (J) = '*'\n-                                         or else Arg (J) = '%'\n-                                       then\n-                                          File_Is_Wild := True;\n+                                    for J in Arg_Idx + 1 .. Arg'Last loop\n+                                       if Arg (J) = ',' then\n+                                          return J - 1;\n                                        end if;\n                                     end loop;\n \n-                                    if File_Is_Wild then\n-                                       File_List := To_Canonical_File_List\n-                                         (Arg.all, False);\n+                                    return Arg'Last;\n+                                 end Get_Arg1_End;\n \n-                                       for J in File_List.all'Range loop\n-                                          Place (' ');\n-                                          Place_Lower (File_List.all (J).all);\n-                                       end loop;\n+                              begin\n+                                 loop\n+                                    declare\n+                                       Next_Arg1_Idx :\n+                                       constant Integer :=\n+                                         Get_Arg1_End (Arg.all, Arg1_Idx);\n \n-                                    else\n+                                       Arg1 :\n+                                       constant String :=\n+                                         Arg (Arg1_Idx .. Next_Arg1_Idx);\n+\n+                                       Normal_File :\n+                                       constant String_Access :=\n+                                         To_Canonical_File_Spec (Arg1);\n+\n+                                    begin\n                                        Place (' ');\n                                        Place_Lower (Normal_File.all);\n \n@@ -1365,542 +1449,447 @@ package body VMS_Conv is\n                                           Place ('.');\n                                           Place (Command.Defext);\n                                        end if;\n-                                    end if;\n-\n-                                    Param_Count := Param_Count - 1;\n-                                 end;\n-\n-                              when Other_As_Is =>\n-                                 Place (' ');\n-                                 Place (Arg.all);\n-\n-                              when Unlimited_As_Is =>\n-                                 Place (' ');\n-                                 Place (Arg.all);\n-                                 Param_Count := Param_Count - 1;\n-\n-                              when Files_Or_Wildcard =>\n-\n-                                 --  Remove spaces from a comma separated list\n-                                 --  of file names and adjust control variables\n-                                 --  accordingly.\n-\n-                                 while Arg_Num < Argument_Count and then\n-                                   (Argv (Argv'Last) = ',' xor\n-                                    Argument (Arg_Num + 1)\n-                                      (Argument (Arg_Num + 1)'First) = ',')\n-                                 loop\n-                                    Argv := new String'\n-                                           (Argv.all & Argument (Arg_Num + 1));\n-                                    Arg_Num := Arg_Num + 1;\n-                                    Arg_Idx := Argv'First;\n-                                    Next_Arg_Idx :=\n-                                      Get_Arg_End (Argv.all, Arg_Idx);\n-                                    Arg := new String'\n-                                            (Argv (Arg_Idx .. Next_Arg_Idx));\n-                                 end loop;\n-\n-                                 --  Parse the comma separated list of VMS\n-                                 --  filenames and place them on the command\n-                                 --  line as space separated Unix style\n-                                 --  filenames. Lower case and add default\n-                                 --  extension as appropriate.\n-\n-                                 declare\n-                                    Arg1_Idx : Integer := Arg'First;\n-\n-                                    function Get_Arg1_End\n-                                      (Arg  : String; Arg_Idx : Integer)\n-                                       return Integer;\n-                                    --  Begins looking at Arg_Idx + 1 and\n-                                    --  returns the index of the last character\n-                                    --  before a comma or else the index of the\n-                                    --  last character in the string Arg.\n \n-                                    ------------------\n-                                    -- Get_Arg1_End --\n-                                    ------------------\n+                                       Arg1_Idx := Next_Arg1_Idx + 1;\n+                                    end;\n \n-                                    function Get_Arg1_End\n-                                      (Arg  : String; Arg_Idx : Integer)\n-                                       return Integer\n-                                    is\n-                                    begin\n-                                       for J in Arg_Idx + 1 .. Arg'Last loop\n-                                          if Arg (J) = ',' then\n-                                             return J - 1;\n-                                          end if;\n-                                       end loop;\n+                                    exit when Arg1_Idx > Arg'Last;\n \n-                                       return Arg'Last;\n-                                    end Get_Arg1_End;\n+                                    --  Don't allow two or more commas in\n+                                    --  a row\n \n-                                 begin\n-                                    loop\n-                                       declare\n-                                          Next_Arg1_Idx :\n-                                            constant Integer :=\n-                                              Get_Arg1_End (Arg.all, Arg1_Idx);\n-\n-                                          Arg1 :\n-                                            constant String :=\n-                                              Arg (Arg1_Idx .. Next_Arg1_Idx);\n-\n-                                          Normal_File :\n-                                            constant String_Access :=\n-                                              To_Canonical_File_Spec (Arg1);\n-\n-                                       begin\n-                                          Place (' ');\n-                                          Place_Lower (Normal_File.all);\n-\n-                                          if Is_Extensionless (Normal_File.all)\n-                                            and then Command.Defext /= \"   \"\n-                                          then\n-                                             Place ('.');\n-                                             Place (Command.Defext);\n-                                          end if;\n-\n-                                          Arg1_Idx := Next_Arg1_Idx + 1;\n-                                       end;\n-\n-                                       exit when Arg1_Idx > Arg'Last;\n-\n-                                       --  Don't allow two or more commas in\n-                                       --  a row\n-\n-                                       if Arg (Arg1_Idx) = ',' then\n-                                          Arg1_Idx := Arg1_Idx + 1;\n-                                          if Arg1_Idx > Arg'Last or else\n-                                            Arg (Arg1_Idx) = ','\n-                                          then\n-                                             Put_Line\n-                                               (Standard_Error,\n-                                                \"Malformed Parameter: \" &\n-                                                Arg.all);\n-                                             Put (Standard_Error, \"usage: \");\n-                                             Put_Line (Standard_Error,\n-                                                       Command.Usage.all);\n-                                             raise Error_Exit;\n-                                          end if;\n+                                    if Arg (Arg1_Idx) = ',' then\n+                                       Arg1_Idx := Arg1_Idx + 1;\n+                                       if Arg1_Idx > Arg'Last or else\n+                                         Arg (Arg1_Idx) = ','\n+                                       then\n+                                          Put_Line\n+                                            (Standard_Error,\n+                                             \"Malformed Parameter: \" &\n+                                             Arg.all);\n+                                          Put (Standard_Error, \"usage: \");\n+                                          Put_Line (Standard_Error,\n+                                                    Command.Usage.all);\n+                                          raise Error_Exit;\n                                        end if;\n+                                    end if;\n \n-                                    end loop;\n-                                 end;\n-                           end case;\n-                        end if;\n-\n-                        --  Qualifier argument\n-\n-                     else\n-                        --  This code is too heavily nested, should be\n-                        --  separated out as separate subprogram ???\n-\n-                        declare\n-                           Sw   : Item_Ptr;\n-                           SwP  : Natural;\n-                           P2   : Natural;\n-                           Endp : Natural := 0; -- avoid warning!\n-                           Opt  : Item_Ptr;\n-\n-                        begin\n-                           SwP := Arg'First;\n-                           while SwP < Arg'Last\n-                             and then Arg (SwP + 1) /= '='\n-                           loop\n-                              SwP := SwP + 1;\n-                           end loop;\n+                                 end loop;\n+                              end;\n+                        end case;\n+                     end if;\n \n-                           --  At this point, the switch name is in\n-                           --  Arg (Arg'First..SwP) and if that is not the\n-                           --  whole switch, then there is an equal sign at\n-                           --  Arg (SwP + 1) and the rest of Arg is what comes\n-                           --  after the equal sign.\n+                     --  Qualifier argument\n \n-                           --  If make commands are active, see if we have\n-                           --  another COMMANDS_TRANSLATION switch belonging\n-                           --  to gnatmake.\n+                  else\n+                     --  This code is too heavily nested, should be\n+                     --  separated out as separate subprogram ???\n+\n+                     declare\n+                        Sw   : Item_Ptr;\n+                        SwP  : Natural;\n+                        P2   : Natural;\n+                        Endp : Natural := 0; -- avoid warning!\n+                        Opt  : Item_Ptr;\n+\n+                     begin\n+                        SwP := Arg'First;\n+                        while SwP < Arg'Last\n+                          and then Arg (SwP + 1) /= '='\n+                        loop\n+                           SwP := SwP + 1;\n+                        end loop;\n+\n+                        --  At this point, the switch name is in\n+                        --  Arg (Arg'First..SwP) and if that is not the\n+                        --  whole switch, then there is an equal sign at\n+                        --  Arg (SwP + 1) and the rest of Arg is what comes\n+                        --  after the equal sign.\n+\n+                        --  If make commands are active, see if we have\n+                        --  another COMMANDS_TRANSLATION switch belonging\n+                        --  to gnatmake.\n+\n+                        if Make_Commands_Active /= null then\n+                           Sw :=\n+                             Matching_Name\n+                               (Arg (Arg'First .. SwP),\n+                                Command.Switches,\n+                                Quiet => True);\n+\n+                           if Sw /= null\n+                             and then Sw.Translation = T_Commands\n+                           then\n+                              null;\n \n-                           if Make_Commands_Active /= null then\n+                           else\n                               Sw :=\n                                 Matching_Name\n-                                (Arg (Arg'First .. SwP),\n-                                 Command.Switches,\n-                                 Quiet => True);\n-\n-                              if Sw /= null\n-                                and then Sw.Translation = T_Commands\n-                              then\n-                                 null;\n-\n-                              else\n-                                 Sw :=\n-                                   Matching_Name\n-                                   (Arg (Arg'First .. SwP),\n-                                    Make_Commands_Active.Switches,\n-                                    Quiet => False);\n-                              end if;\n+                                  (Arg (Arg'First .. SwP),\n+                                   Make_Commands_Active.Switches,\n+                                   Quiet => False);\n+                           end if;\n \n                            --  For case of GNAT MAKE or CHOP, if we cannot\n                            --  find the switch, then see if it is a\n                            --  recognized compiler switch instead, and if\n                            --  so process the compiler switch.\n \n-                           elsif Command.Name.all = \"MAKE\"\n-                             or else Command.Name.all = \"CHOP\" then\n+                        elsif Command.Name.all = \"MAKE\"\n+                          or else Command.Name.all = \"CHOP\" then\n+                           Sw :=\n+                             Matching_Name\n+                               (Arg (Arg'First .. SwP),\n+                                Command.Switches,\n+                                Quiet => True);\n+\n+                           if Sw = null then\n                               Sw :=\n                                 Matching_Name\n-                                (Arg (Arg'First .. SwP),\n-                                 Command.Switches,\n-                                 Quiet => True);\n-\n-                              if Sw = null then\n-                                 Sw :=\n+                                  (Arg (Arg'First .. SwP),\n                                    Matching_Name\n-                                   (Arg (Arg'First .. SwP),\n-                                    Matching_Name\n-                                      (\"COMPILE\", Commands).Switches,\n-                                    Quiet => False);\n-                              end if;\n+                                     (\"COMPILE\", Commands).Switches,\n+                                   Quiet => False);\n+                           end if;\n \n                            --  For all other cases, just search the relevant\n                            --  command.\n \n-                           else\n-                              Sw :=\n-                                Matching_Name\n-                                (Arg (Arg'First .. SwP),\n-                                 Command.Switches,\n-                                 Quiet => False);\n-                           end if;\n-\n-                           if Sw /= null then\n-                              case Sw.Translation is\n+                        else\n+                           Sw :=\n+                             Matching_Name\n+                               (Arg (Arg'First .. SwP),\n+                                Command.Switches,\n+                                Quiet => False);\n+                        end if;\n \n-                                 when T_Direct =>\n-                                    Place_Unix_Switches (Sw.Unix_String);\n-                                    if SwP < Arg'Last\n-                                      and then Arg (SwP + 1) = '='\n+                        if Sw /= null then\n+                           case Sw.Translation is\n+\n+                              when T_Direct =>\n+                                 Place_Unix_Switches (Sw.Unix_String);\n+                                 if SwP < Arg'Last\n+                                   and then Arg (SwP + 1) = '='\n+                                 then\n+                                    Put (Standard_Error,\n+                                         \"qualifier options ignored: \");\n+                                    Put_Line (Standard_Error, Arg.all);\n+                                 end if;\n+\n+                              when T_Directories =>\n+                                 if SwP + 1 > Arg'Last then\n+                                    Put (Standard_Error,\n+                                         \"missing directories for: \");\n+                                    Put_Line (Standard_Error, Arg.all);\n+                                    Errors := Errors + 1;\n+\n+                                 elsif Arg (SwP + 2) /= '(' then\n+                                    SwP := SwP + 2;\n+                                    Endp := Arg'Last;\n+\n+                                 elsif Arg (Arg'Last) /= ')' then\n+\n+                                    --  Remove spaces from a comma separated\n+                                    --  list of file names and adjust\n+                                    --  control variables accordingly.\n+\n+                                    if Arg_Num < Argument_Count and then\n+                                      (Argv (Argv'Last) = ',' xor\n+                                         Argument (Arg_Num + 1)\n+                                         (Argument (Arg_Num + 1)'First) = ',')\n                                     then\n-                                       Put (Standard_Error,\n-                                            \"qualifier options ignored: \");\n-                                       Put_Line (Standard_Error, Arg.all);\n-                                    end if;\n-\n-                                 when T_Directories =>\n-                                    if SwP + 1 > Arg'Last then\n-                                       Put (Standard_Error,\n-                                            \"missing directories for: \");\n-                                       Put_Line (Standard_Error, Arg.all);\n-                                       Errors := Errors + 1;\n-\n-                                    elsif Arg (SwP + 2) /= '(' then\n-                                       SwP := SwP + 2;\n-                                       Endp := Arg'Last;\n-\n-                                    elsif Arg (Arg'Last) /= ')' then\n-\n-                                       --  Remove spaces from a comma separated\n-                                       --  list of file names and adjust\n-                                       --  control variables accordingly.\n-\n-                                       if Arg_Num < Argument_Count and then\n-                                         (Argv (Argv'Last) = ',' xor\n-                                          Argument (Arg_Num + 1)\n-                                          (Argument (Arg_Num + 1)'First) = ',')\n-                                       then\n-                                          Argv :=\n-                                            new String'(Argv.all\n-                                                        & Argument\n-                                                           (Arg_Num + 1));\n-                                          Arg_Num := Arg_Num + 1;\n-                                          Arg_Idx := Argv'First;\n-                                          Next_Arg_Idx\n-                                            := Get_Arg_End (Argv.all, Arg_Idx);\n-                                          Arg := new String'\n-                                            (Argv (Arg_Idx .. Next_Arg_Idx));\n-                                          goto Tryagain_After_Coalesce;\n-                                       end if;\n-\n-                                       Put (Standard_Error,\n-                                            \"incorrectly parenthesized \" &\n-                                            \"or malformed argument: \");\n-                                       Put_Line (Standard_Error, Arg.all);\n-                                       Errors := Errors + 1;\n-\n-                                    else\n-                                       SwP := SwP + 3;\n-                                       Endp := Arg'Last - 1;\n+                                       Argv :=\n+                                         new String'(Argv.all\n+                                                     & Argument\n+                                                       (Arg_Num + 1));\n+                                       Arg_Num := Arg_Num + 1;\n+                                       Arg_Idx := Argv'First;\n+                                       Next_Arg_Idx\n+                                       := Get_Arg_End (Argv.all, Arg_Idx);\n+                                       Arg := new String'\n+                                         (Argv (Arg_Idx .. Next_Arg_Idx));\n+                                       goto Tryagain_After_Coalesce;\n                                     end if;\n \n-                                    while SwP <= Endp loop\n-                                       declare\n-                                          Dir_Is_Wild       : Boolean := False;\n-                                          Dir_Maybe_Is_Wild : Boolean := False;\n-                                          Dir_List : String_Access_List_Access;\n-                                       begin\n-                                          P2 := SwP;\n-\n-                                          while P2 < Endp\n-                                            and then Arg (P2 + 1) /= ','\n-                                          loop\n+                                    Put (Standard_Error,\n+                                         \"incorrectly parenthesized \" &\n+                                         \"or malformed argument: \");\n+                                    Put_Line (Standard_Error, Arg.all);\n+                                    Errors := Errors + 1;\n+\n+                                 else\n+                                    SwP := SwP + 3;\n+                                    Endp := Arg'Last - 1;\n+                                 end if;\n+\n+                                 while SwP <= Endp loop\n+                                    declare\n+                                       Dir_Is_Wild       : Boolean := False;\n+                                       Dir_Maybe_Is_Wild : Boolean := False;\n+                                       Dir_List : String_Access_List_Access;\n+                                    begin\n+                                       P2 := SwP;\n \n-                                             --  A wildcard directory spec on\n-                                             --  VMS will contain either * or\n-                                             --  % or ...\n+                                       while P2 < Endp\n+                                         and then Arg (P2 + 1) /= ','\n+                                       loop\n \n-                                             if Arg (P2) = '*' then\n-                                                Dir_Is_Wild := True;\n+                                          --  A wildcard directory spec on\n+                                          --  VMS will contain either * or\n+                                          --  % or ...\n \n-                                             elsif Arg (P2) = '%' then\n-                                                Dir_Is_Wild := True;\n+                                          if Arg (P2) = '*' then\n+                                             Dir_Is_Wild := True;\n \n-                                             elsif Dir_Maybe_Is_Wild\n-                                               and then Arg (P2) = '.'\n-                                               and then Arg (P2 + 1) = '.'\n-                                             then\n-                                                Dir_Is_Wild := True;\n-                                                Dir_Maybe_Is_Wild := False;\n+                                          elsif Arg (P2) = '%' then\n+                                             Dir_Is_Wild := True;\n \n-                                             elsif Dir_Maybe_Is_Wild then\n-                                                Dir_Maybe_Is_Wild := False;\n+                                          elsif Dir_Maybe_Is_Wild\n+                                            and then Arg (P2) = '.'\n+                                            and then Arg (P2 + 1) = '.'\n+                                          then\n+                                             Dir_Is_Wild := True;\n+                                             Dir_Maybe_Is_Wild := False;\n \n-                                             elsif Arg (P2) = '.'\n-                                               and then Arg (P2 + 1) = '.'\n-                                             then\n-                                                Dir_Maybe_Is_Wild := True;\n+                                          elsif Dir_Maybe_Is_Wild then\n+                                             Dir_Maybe_Is_Wild := False;\n \n-                                             end if;\n+                                          elsif Arg (P2) = '.'\n+                                            and then Arg (P2 + 1) = '.'\n+                                          then\n+                                             Dir_Maybe_Is_Wild := True;\n \n-                                             P2 := P2 + 1;\n-                                          end loop;\n+                                          end if;\n \n-                                          if Dir_Is_Wild then\n-                                             Dir_List := To_Canonical_File_List\n-                                               (Arg (SwP .. P2), True);\n+                                          P2 := P2 + 1;\n+                                       end loop;\n \n-                                             for J in Dir_List.all'Range loop\n-                                                Place_Unix_Switches\n-                                                  (Sw.Unix_String);\n-                                                Place_Lower\n-                                                  (Dir_List.all (J).all);\n-                                             end loop;\n+                                       if Dir_Is_Wild then\n+                                          Dir_List := To_Canonical_File_List\n+                                            (Arg (SwP .. P2), True);\n \n-                                          else\n+                                          for J in Dir_List.all'Range loop\n                                              Place_Unix_Switches\n                                                (Sw.Unix_String);\n                                              Place_Lower\n-                                               (To_Canonical_Dir_Spec\n-                                                (Arg (SwP .. P2), False).all);\n-                                          end if;\n+                                               (Dir_List.all (J).all);\n+                                          end loop;\n \n-                                          SwP := P2 + 2;\n-                                       end;\n-                                    end loop;\n+                                       else\n+                                          Place_Unix_Switches\n+                                            (Sw.Unix_String);\n+                                          Place_Lower\n+                                            (To_Canonical_Dir_Spec\n+                                               (Arg (SwP .. P2), False).all);\n+                                       end if;\n \n-                                 when T_Directory =>\n-                                    if SwP + 1 > Arg'Last then\n-                                       Put (Standard_Error,\n-                                            \"missing directory for: \");\n-                                       Put_Line (Standard_Error, Arg.all);\n-                                       Errors := Errors + 1;\n+                                       SwP := P2 + 2;\n+                                    end;\n+                                 end loop;\n \n-                                    else\n-                                       Place_Unix_Switches (Sw.Unix_String);\n+                              when T_Directory =>\n+                                 if SwP + 1 > Arg'Last then\n+                                    Put (Standard_Error,\n+                                         \"missing directory for: \");\n+                                    Put_Line (Standard_Error, Arg.all);\n+                                    Errors := Errors + 1;\n \n-                                       --  Some switches end in \"=\". No space\n-                                       --  here\n+                                 else\n+                                    Place_Unix_Switches (Sw.Unix_String);\n \n-                                       if Sw.Unix_String\n-                                         (Sw.Unix_String'Last) /= '='\n-                                       then\n-                                          Place (' ');\n-                                       end if;\n+                                    --  Some switches end in \"=\". No space\n+                                    --  here\n \n-                                       Place_Lower\n-                                         (To_Canonical_Dir_Spec\n-                                          (Arg (SwP + 2 .. Arg'Last),\n-                                           False).all);\n+                                    if Sw.Unix_String\n+                                      (Sw.Unix_String'Last) /= '='\n+                                    then\n+                                       Place (' ');\n                                     end if;\n \n-                                 when T_File | T_No_Space_File =>\n-                                    if SwP + 1 > Arg'Last then\n-                                       Put (Standard_Error,\n-                                            \"missing file for: \");\n-                                       Put_Line (Standard_Error, Arg.all);\n-                                       Errors := Errors + 1;\n+                                    Place_Lower\n+                                      (To_Canonical_Dir_Spec\n+                                         (Arg (SwP + 2 .. Arg'Last),\n+                                          False).all);\n+                                 end if;\n \n-                                    else\n-                                       Place_Unix_Switches (Sw.Unix_String);\n-\n-                                       --  Some switches end in \"=\". No space\n-                                       --  here.\n-\n-                                       if Sw.Translation = T_File\n-                                         and then Sw.Unix_String\n-                                                   (Sw.Unix_String'Last) /= '='\n-                                       then\n-                                          Place (' ');\n-                                       end if;\n+                              when T_File | T_No_Space_File =>\n+                                 if SwP + 1 > Arg'Last then\n+                                    Put (Standard_Error,\n+                                         \"missing file for: \");\n+                                    Put_Line (Standard_Error, Arg.all);\n+                                    Errors := Errors + 1;\n \n-                                       Place_Lower\n-                                         (To_Canonical_File_Spec\n-                                          (Arg (SwP + 2 .. Arg'Last)).all);\n-                                    end if;\n-\n-                                 when T_Numeric =>\n-                                    if\n-                                      OK_Integer (Arg (SwP + 2 .. Arg'Last))\n-                                    then\n-                                       Place_Unix_Switches (Sw.Unix_String);\n-                                       Place (Arg (SwP + 2 .. Arg'Last));\n+                                 else\n+                                    Place_Unix_Switches (Sw.Unix_String);\n \n-                                    else\n-                                       Put (Standard_Error, \"argument for \");\n-                                       Put (Standard_Error, Sw.Name.all);\n-                                       Put_Line\n-                                         (Standard_Error, \" must be numeric\");\n-                                       Errors := Errors + 1;\n-                                    end if;\n+                                    --  Some switches end in \"=\". No space\n+                                    --  here.\n \n-                                 when T_Alphanumplus =>\n-                                    if\n-                                      OK_Alphanumerplus\n-                                        (Arg (SwP + 2 .. Arg'Last))\n+                                    if Sw.Translation = T_File\n+                                      and then Sw.Unix_String\n+                                        (Sw.Unix_String'Last) /= '='\n                                     then\n-                                       Place_Unix_Switches (Sw.Unix_String);\n-                                       Place (Arg (SwP + 2 .. Arg'Last));\n-\n-                                    else\n-                                       Put (Standard_Error, \"argument for \");\n-                                       Put (Standard_Error, Sw.Name.all);\n-                                       Put_Line (Standard_Error,\n-                                                 \" must be alphanumeric\");\n-                                       Errors := Errors + 1;\n+                                       Place (' ');\n                                     end if;\n \n-                                 when T_String =>\n-\n-                                    --  A String value must be extended to the\n-                                    --  end of the Argv, otherwise strings like\n-                                    --  \"foo/bar\" get split at the slash.\n-                                    --\n-                                    --  The begining and ending of the string\n-                                    --  are flagged with embedded nulls which\n-                                    --  are removed when building the Spawn\n-                                    --  call. Nulls are use because they won't\n-                                    --  show up in a /? output. Quotes aren't\n-                                    --  used because that would make it\n-                                    --  difficult to embed them.\n+                                    Place_Lower\n+                                      (To_Canonical_File_Spec\n+                                         (Arg (SwP + 2 .. Arg'Last)).all);\n+                                 end if;\n \n+                              when T_Numeric =>\n+                                 if\n+                                   OK_Integer (Arg (SwP + 2 .. Arg'Last))\n+                                 then\n                                     Place_Unix_Switches (Sw.Unix_String);\n-                                    if Next_Arg_Idx /= Argv'Last then\n-                                       Next_Arg_Idx := Argv'Last;\n-                                       Arg := new String'\n-                                         (Argv (Arg_Idx .. Next_Arg_Idx));\n-\n-                                       SwP := Arg'First;\n-                                       while SwP < Arg'Last and then\n-                                         Arg (SwP + 1) /= '=' loop\n-                                          SwP := SwP + 1;\n-                                       end loop;\n-                                    end if;\n-                                    Place (ASCII.NUL);\n                                     Place (Arg (SwP + 2 .. Arg'Last));\n-                                    Place (ASCII.NUL);\n \n-                                 when T_Commands =>\n-\n-                                    --  Output -largs/-bargs/-cargs\n-\n-                                    Place (' ');\n-                                    Place (Sw.Unix_String\n-                                           (Sw.Unix_String'First ..\n-                                            Sw.Unix_String'First + 5));\n-\n-                                    if Sw.Unix_String\n-                                         (Sw.Unix_String'First + 7 ..\n-                                          Sw.Unix_String'Last) =\n-                                       \"MAKE\"\n-                                    then\n-                                       Make_Commands_Active := null;\n+                                 else\n+                                    Put (Standard_Error, \"argument for \");\n+                                    Put (Standard_Error, Sw.Name.all);\n+                                    Put_Line\n+                                      (Standard_Error, \" must be numeric\");\n+                                    Errors := Errors + 1;\n+                                 end if;\n+\n+                              when T_Alphanumplus =>\n+                                 if\n+                                   OK_Alphanumerplus\n+                                     (Arg (SwP + 2 .. Arg'Last))\n+                                 then\n+                                    Place_Unix_Switches (Sw.Unix_String);\n+                                    Place (Arg (SwP + 2 .. Arg'Last));\n \n-                                    else\n-                                       --  Set source of new commands, also\n-                                       --  setting this non-null indicates that\n-                                       --  we are in the special commands mode\n-                                       --  for processing the -xargs case.\n-\n-                                       Make_Commands_Active :=\n-                                         Matching_Name\n-                                         (Sw.Unix_String\n-                                            (Sw.Unix_String'First + 7 ..\n-                                               Sw.Unix_String'Last),\n-                                          Commands);\n-                                    end if;\n+                                 else\n+                                    Put (Standard_Error, \"argument for \");\n+                                    Put (Standard_Error, Sw.Name.all);\n+                                    Put_Line (Standard_Error,\n+                                              \" must be alphanumeric\");\n+                                    Errors := Errors + 1;\n+                                 end if;\n+\n+                              when T_String =>\n+\n+                                 --  A String value must be extended to the\n+                                 --  end of the Argv, otherwise strings like\n+                                 --  \"foo/bar\" get split at the slash.\n+                                 --\n+                                 --  The begining and ending of the string\n+                                 --  are flagged with embedded nulls which\n+                                 --  are removed when building the Spawn\n+                                 --  call. Nulls are use because they won't\n+                                 --  show up in a /? output. Quotes aren't\n+                                 --  used because that would make it\n+                                 --  difficult to embed them.\n+\n+                                 Place_Unix_Switches (Sw.Unix_String);\n+                                 if Next_Arg_Idx /= Argv'Last then\n+                                    Next_Arg_Idx := Argv'Last;\n+                                    Arg := new String'\n+                                      (Argv (Arg_Idx .. Next_Arg_Idx));\n \n-                                 when T_Options =>\n-                                    if SwP + 1 > Arg'Last then\n-                                       Place_Unix_Switches\n-                                         (Sw.Options.Unix_String);\n-                                       SwP := Endp + 1;\n-\n-                                    elsif Arg (SwP + 2) /= '(' then\n-                                       SwP := SwP + 2;\n-                                       Endp := Arg'Last;\n-\n-                                    elsif Arg (Arg'Last) /= ')' then\n-                                       Put\n-                                         (Standard_Error,\n-                                          \"incorrectly parenthesized \" &\n-                                          \"argument: \");\n-                                       Put_Line (Standard_Error, Arg.all);\n-                                       Errors := Errors + 1;\n-                                       SwP := Endp + 1;\n+                                    SwP := Arg'First;\n+                                    while SwP < Arg'Last and then\n+                                    Arg (SwP + 1) /= '=' loop\n+                                       SwP := SwP + 1;\n+                                    end loop;\n+                                 end if;\n+                                 Place (ASCII.NUL);\n+                                 Place (Arg (SwP + 2 .. Arg'Last));\n+                                 Place (ASCII.NUL);\n \n-                                    else\n-                                       SwP := SwP + 3;\n-                                       Endp := Arg'Last - 1;\n-                                    end if;\n+                              when T_Commands =>\n \n-                                    while SwP <= Endp loop\n-                                       P2 := SwP;\n+                                 --  Output -largs/-bargs/-cargs\n \n-                                       while P2 < Endp\n-                                         and then Arg (P2 + 1) /= ','\n-                                       loop\n-                                          P2 := P2 + 1;\n-                                       end loop;\n+                                 Place (' ');\n+                                 Place (Sw.Unix_String\n+                                          (Sw.Unix_String'First ..\n+                                             Sw.Unix_String'First + 5));\n+\n+                                 if Sw.Unix_String\n+                                   (Sw.Unix_String'First + 7 ..\n+                                      Sw.Unix_String'Last) =\n+                                     \"MAKE\"\n+                                 then\n+                                    Make_Commands_Active := null;\n+\n+                                 else\n+                                    --  Set source of new commands, also\n+                                    --  setting this non-null indicates that\n+                                    --  we are in the special commands mode\n+                                    --  for processing the -xargs case.\n+\n+                                    Make_Commands_Active :=\n+                                      Matching_Name\n+                                        (Sw.Unix_String\n+                                             (Sw.Unix_String'First + 7 ..\n+                                                  Sw.Unix_String'Last),\n+                                         Commands);\n+                                 end if;\n+\n+                              when T_Options =>\n+                                 if SwP + 1 > Arg'Last then\n+                                    Place_Unix_Switches\n+                                      (Sw.Options.Unix_String);\n+                                    SwP := Endp + 1;\n+\n+                                 elsif Arg (SwP + 2) /= '(' then\n+                                    SwP := SwP + 2;\n+                                    Endp := Arg'Last;\n+\n+                                 elsif Arg (Arg'Last) /= ')' then\n+                                    Put\n+                                      (Standard_Error,\n+                                       \"incorrectly parenthesized \" &\n+                                       \"argument: \");\n+                                    Put_Line (Standard_Error, Arg.all);\n+                                    Errors := Errors + 1;\n+                                    SwP := Endp + 1;\n+\n+                                 else\n+                                    SwP := SwP + 3;\n+                                    Endp := Arg'Last - 1;\n+                                 end if;\n+\n+                                 while SwP <= Endp loop\n+                                    P2 := SwP;\n+\n+                                    while P2 < Endp\n+                                      and then Arg (P2 + 1) /= ','\n+                                    loop\n+                                       P2 := P2 + 1;\n+                                    end loop;\n \n-                                       --  Option name is in Arg (SwP .. P2)\n+                                    --  Option name is in Arg (SwP .. P2)\n \n-                                       Opt := Matching_Name (Arg (SwP .. P2),\n-                                                             Sw.Options);\n+                                    Opt := Matching_Name (Arg (SwP .. P2),\n+                                                          Sw.Options);\n \n-                                       if Opt /= null then\n-                                          Place_Unix_Switches\n-                                            (Opt.Unix_String);\n-                                       end if;\n+                                    if Opt /= null then\n+                                       Place_Unix_Switches\n+                                         (Opt.Unix_String);\n+                                    end if;\n \n-                                       SwP := P2 + 2;\n-                                    end loop;\n+                                    SwP := P2 + 2;\n+                                 end loop;\n \n-                                 when T_Other =>\n-                                    Place_Unix_Switches\n-                                      (new String'(Sw.Unix_String.all &\n-                                                   Arg.all));\n+                              when T_Other =>\n+                                 Place_Unix_Switches\n+                                   (new String'(Sw.Unix_String.all &\n+                                                Arg.all));\n \n-                              end case;\n-                           end if;\n-                        end;\n-                     end if;\n+                           end case;\n+                        end if;\n+                     end;\n+                  end if;\n \n-                     Arg_Idx := Next_Arg_Idx + 1;\n-                  end;\n+                  Arg_Idx := Next_Arg_Idx + 1;\n+               end;\n \n-                  exit when Arg_Idx > Argv'Last;\n+               exit when Arg_Idx > Argv'Last;\n \n-               end loop;\n+            end loop;\n          end Process_Argument;\n \n          Arg_Num := Arg_Num + 1;"}, {"sha": "e945f7fbf9839b670c8cc1672ef937ca1ffa69b0", "filename": "gcc/ada/vms_conv.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fvms_conv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fvms_conv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.ads?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -25,7 +25,7 @@\n ------------------------------------------------------------------------------\n \n --  This package is part of the GNAT driver. It contains a procedure\n---  VMS_Conversion to convert the command line in VMS form to the wquivalent\n+--  VMS_Conversion to convert the command line in VMS form to the equivalent\n --  command line with switches for the GNAT tools that the GNAT driver will\n --  invoke.\n --\n@@ -97,18 +97,17 @@ package VMS_Conv is\n \n    type Command_Type is\n      (Bind, Chop, Clean, Compile, Elim, Find, Krunch, Library, Link, List,\n-      Make, Name, Preprocess, Pretty, Shared, Standard, Stub, Xref, Undefined);\n+      Make, Name, Preprocess, Pretty, Shared, Stub, Xref, Undefined);\n \n-   type Alternate_Command is (Comp, Ls, Kr, Pp, Prep, Psta);\n+   type Alternate_Command is (Comp, Ls, Kr, Pp, Prep);\n    --  Alternate command libel for non VMS system\n \n    Corresponding_To : constant array (Alternate_Command) of Command_Type :=\n      (Comp  => Compile,\n       Ls    => List,\n       Kr    => Krunch,\n       Prep  => Preprocess,\n-      Pp    => Pretty,\n-      Psta  => Standard);\n+      Pp    => Pretty);\n    --  Mapping of alternate commands to commands\n \n    subtype Real_Command_Type is Command_Type range Bind .. Xref;"}, {"sha": "74da7099f540ed2b64f3b386e39000a7b0fd2086", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65356e64cf0fc85effb4b77d9e253c7d28bf407c/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=65356e64cf0fc85effb4b77d9e253c7d28bf407c", "patch": "@@ -1591,6 +1591,17 @@ package VMS_Data is\n    --   communicated to the compiler through logical names\n    --   ADA_PRJ_INCLUDE_FILE and ADA_PRJ_OBJECTS_FILE.\n \n+   S_GCC_Psta    : aliased constant S := \"/PRINT_STANDARD \"                &\n+                                            \"-gnatS\";\n+   --        /PRINT_STANDARD\n+   --\n+   --   cause the compiler to output a representation of package Standard\n+   --   in a form very close to standard Ada. It is not quite possible to\n+   --   do this and remain entirely Standard (since new numeric base types\n+   --   cannot be created in standard Ada), but the output is easily\n+   --   readable to any Ada programmer, and is useful to determine the\n+   --   characteristics of target dependent types in package Standard.\n+\n    S_GCC_Report  : aliased constant S := \"/REPORT_ERRORS=\"                 &\n                                             \"VERBOSE \"                     &\n                                                \"-gnatv \"                   &\n@@ -2278,10 +2289,6 @@ package VMS_Data is\n                                                \"-gnatwA \"                  &\n                                             \"ALL_GCC \"                     &\n                                                \"-Wall \"                    &\n-                                            \"BIASED_ROUNDING \"             &\n-                                               \"-gnatwb \"                  &\n-                                            \"NOBIASED_ROUNDING \"           &\n-                                               \"-gnatwB \"                  &\n                                             \"CONDITIONALS \"                &\n                                                \"-gnatwc \"                  &\n                                             \"NOCONDITIONALS \"              &\n@@ -2399,30 +2406,6 @@ package VMS_Data is\n    --                           backend.  Most of these are not relevant\n    --                           to Ada.\n    --\n-   --   BIASED_ROUNDING         Activate warnings on biased rounding.\n-   --                           If a static floating-point expression has\n-   --                           a value that is exactly half way between\n-   --                           two adjacent machine numbers, then the\n-   --                           rules of Ada (Ada Reference Manual,\n-   --                           para 4.9(38)) require that this rounding\n-   --                           be done away from zero, even if the normal\n-   --                           unbiased rounding rules at run time would\n-   --                           require rounding towards zero.\n-   --\n-   --                           This warning message alerts you to such\n-   --                           instances where compile-time rounding and\n-   --                           run-time rounding are not equivalent.\n-   --                           If it is important to get proper run-time\n-   --                           rounding, then you can force this by\n-   --                           making one of the operands into a\n-   --                           variable. The default is that such\n-   --                           warnings are not generated. Note that\n-   --                           /WARNINGS=ALL does not affect the setting\n-   --                           of this warning option.\n-   --\n-   --   NOBIASED_ROUNDING       Suppress warnings on biased rounding.\n-   --                           Disable warnings on biased rounding.\n-   --\n    --   CONDITIONALS            Activate warnings for conditional\n    --                           Expressions used in tests that are known\n    --                           to be True or False at compile time. The\n@@ -2820,6 +2803,7 @@ package VMS_Data is\n       S_GCC_OptX    'Access,\n       S_GCC_Polling 'Access,\n       S_GCC_Project 'Access,\n+      S_GCC_Psta    'Access,\n       S_GCC_Report  'Access,\n       S_GCC_ReportX 'Access,\n       S_GCC_Repinfo 'Access,\n@@ -4643,12 +4627,6 @@ package VMS_Data is\n       S_Shared_Verb    'Access,\n       S_Shared_ZZZZZ   'Access);\n \n-   --------------------------------\n-   -- Switches for GNAT STANDARD --\n-   --------------------------------\n-\n-   Standard_Switches : aliased constant Switches := (1 .. 0 => null);\n-\n    ----------------------------\n    -- Switches for GNAT STUB --\n    ----------------------------"}]}