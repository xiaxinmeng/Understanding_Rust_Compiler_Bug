{"sha": "e784c52cd2d0599cc29c8a66240af64cfac79371", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc4NGM1MmNkMmQwNTk5Y2MyOWM4YTY2MjQwYWY2NGNmYWM3OTM3MQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-09T09:03:22Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-09T09:03:22Z"}, "message": "re PR target/40657 (allocate local variables with fewer instructions)\n\n\tPR target/40657\n\t* config/arm/arm.c (thumb1_extra_regs_pushed): New arg FOR_PROLOGUE.\n\tAll callers changed.\n\tHandle the case when we're called for the epilogue.\n\t(thumb_unexpanded_epilogue): Use it.\n\t(thumb1_expand_epilogue): Likewise.\n\ntestsuite/\n\tPR target/40657\n\t* gcc.target/arm/pr40657-1.c: New test.\n\t* gcc.target/arm/pr40657-2.c: New test.\n\t* gcc.c-torture/execute/pr40657.c: New test.\n\nFrom-SVN: r161988", "tree": {"sha": "be889d32ba5885b93f3e713bd003853799f88d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be889d32ba5885b93f3e713bd003853799f88d3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e784c52cd2d0599cc29c8a66240af64cfac79371", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e784c52cd2d0599cc29c8a66240af64cfac79371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e784c52cd2d0599cc29c8a66240af64cfac79371", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e784c52cd2d0599cc29c8a66240af64cfac79371/comments", "author": null, "committer": null, "parents": [{"sha": "ac2856486dd4f460c7cdb0db6a027df6010fee49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac2856486dd4f460c7cdb0db6a027df6010fee49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac2856486dd4f460c7cdb0db6a027df6010fee49"}], "stats": {"total": 209, "additions": 161, "deletions": 48}, "files": [{"sha": "a5d4ceb4978217a7fe21e0d87479c1fe583bc43d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e784c52cd2d0599cc29c8a66240af64cfac79371", "patch": "@@ -1,3 +1,12 @@\n+2010-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/40657\n+\t* config/arm/arm.c (thumb1_extra_regs_pushed): New arg FOR_PROLOGUE.\n+\tAll callers changed.\n+\tHandle the case when we're called for the epilogue.\n+\t(thumb_unexpanded_epilogue): Use it.\n+\t(thumb1_expand_epilogue): Likewise.\n+\n 2010-07-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-vrp.c (extract_range_from_binary_expr) <BIT_AND_EXPR>: If"}, {"sha": "db4f701e06805c349c93ba1d5823d0812610680b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 89, "deletions": 48, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e784c52cd2d0599cc29c8a66240af64cfac79371", "patch": "@@ -19565,6 +19565,81 @@ is_called_in_ARM_mode (tree func)\n #endif\n }\n \n+/* Given the stack offsets and register mask in OFFSETS, decide how\n+   many additional registers to push instead of subtracting a constant\n+   from SP.  For epilogues the principle is the same except we use pop.\n+   FOR_PROLOGUE indicates which we're generating.  */\n+static int\n+thumb1_extra_regs_pushed (arm_stack_offsets *offsets, bool for_prologue)\n+{\n+  HOST_WIDE_INT amount;\n+  unsigned long live_regs_mask = offsets->saved_regs_mask;\n+  /* Extract a mask of the ones we can give to the Thumb's push/pop\n+     instruction.  */\n+  unsigned long l_mask = live_regs_mask & (for_prologue ? 0x40ff : 0xff);\n+  /* Then count how many other high registers will need to be pushed.  */\n+  unsigned long high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n+  int n_free, reg_base;\n+\n+  if (!for_prologue && frame_pointer_needed)\n+    amount = offsets->locals_base - offsets->saved_regs;\n+  else\n+    amount = offsets->outgoing_args - offsets->saved_regs;\n+\n+  /* If the stack frame size is 512 exactly, we can save one load\n+     instruction, which should make this a win even when optimizing\n+     for speed.  */\n+  if (!optimize_size && amount != 512)\n+    return 0;\n+\n+  /* Can't do this if there are high registers to push.  */\n+  if (high_regs_pushed != 0)\n+    return 0;\n+\n+  /* Shouldn't do it in the prologue if no registers would normally\n+     be pushed at all.  In the epilogue, also allow it if we'll have\n+     a pop insn for the PC.  */\n+  if  (l_mask == 0\n+       && (for_prologue\n+\t   || TARGET_BACKTRACE\n+\t   || (live_regs_mask & 1 << LR_REGNUM) == 0\n+\t   || TARGET_INTERWORK\n+\t   || crtl->args.pretend_args_size != 0))\n+    return 0;\n+\n+  /* Don't do this if thumb_expand_prologue wants to emit instructions\n+     between the push and the stack frame allocation.  */\n+  if (for_prologue\n+      && ((flag_pic && arm_pic_register != INVALID_REGNUM)\n+\t  || (!frame_pointer_needed && CALLER_INTERWORKING_SLOT_SIZE > 0)))\n+    return 0;\n+\n+  reg_base = 0;\n+  n_free = 0;\n+  if (!for_prologue)\n+    {\n+      reg_base = arm_size_return_regs () / UNITS_PER_WORD;\n+      live_regs_mask >>= reg_base;\n+    }\n+\n+  while (reg_base + n_free < 8 && !(live_regs_mask & 1)\n+\t && (for_prologue || call_used_regs[reg_base + n_free]))\n+    {\n+      live_regs_mask >>= 1;\n+      n_free++;\n+    }\n+\n+  if (n_free == 0)\n+    return 0;\n+  gcc_assert (amount / 4 * 4 == amount);\n+\n+  if (amount >= 512 && (amount - n_free * 4) < 512)\n+    return (amount - 508) / 4;\n+  if (amount <= n_free * 4)\n+    return amount / 4;\n+  return 0;\n+}\n+\n /* The bits which aren't usefully expanded as rtl.  */\n const char *\n thumb_unexpanded_epilogue (void)\n@@ -19573,6 +19648,7 @@ thumb_unexpanded_epilogue (void)\n   int regno;\n   unsigned long live_regs_mask = 0;\n   int high_regs_pushed = 0;\n+  int extra_pop;\n   int had_to_push_lr;\n   int size;\n \n@@ -19592,6 +19668,13 @@ thumb_unexpanded_epilogue (void)\n      the register is used to hold a return value.  */\n   size = arm_size_return_regs ();\n \n+  extra_pop = thumb1_extra_regs_pushed (offsets, false);\n+  if (extra_pop > 0)\n+    {\n+      unsigned long extra_mask = (1 << extra_pop) - 1;\n+      live_regs_mask |= extra_mask << (size / UNITS_PER_WORD);\n+    }\n+\n   /* The prolog may have pushed some high registers to use as\n      work registers.  e.g. the testsuite file:\n      gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c\n@@ -19675,7 +19758,9 @@ thumb_unexpanded_epilogue (void)\n \t\t       live_regs_mask);\n \n       /* We have either just popped the return address into the\n-\t PC or it is was kept in LR for the entire function.  */\n+\t PC or it is was kept in LR for the entire function.\n+\t Note that thumb_pushpop has already called thumb_exit if the\n+\t PC was in the list.  */\n       if (!had_to_push_lr)\n \tthumb_exit (asm_out_file, LR_REGNUM);\n     }\n@@ -19821,51 +19906,6 @@ thumb_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n     }\n }\n \n-/* Given the stack offsets and register mask in OFFSETS, decide\n-   how many additional registers to push instead of subtracting\n-   a constant from SP.  */\n-static int\n-thumb1_extra_regs_pushed (arm_stack_offsets *offsets)\n-{\n-  HOST_WIDE_INT amount = offsets->outgoing_args - offsets->saved_regs;\n-  unsigned long live_regs_mask = offsets->saved_regs_mask;\n-  /* Extract a mask of the ones we can give to the Thumb's push instruction.  */\n-  unsigned long l_mask = live_regs_mask & 0x40ff;\n-  /* Then count how many other high registers will need to be pushed.  */\n-  unsigned long high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n-  int n_free;\n-\n-  /* If the stack frame size is 512 exactly, we can save one load\n-     instruction, which should make this a win even when optimizing\n-     for speed.  */\n-  if (!optimize_size && amount != 512)\n-    return 0;\n-\n-  /* Can't do this if there are high registers to push, or if we\n-     are not going to do a push at all.  */\n-  if (high_regs_pushed != 0 || l_mask == 0)\n-    return 0;\n-\n-  /* Don't do this if thumb1_expand_prologue wants to emit instructions\n-     between the push and the stack frame allocation.  */\n-  if ((flag_pic && arm_pic_register != INVALID_REGNUM)\n-      || (!frame_pointer_needed && CALLER_INTERWORKING_SLOT_SIZE > 0))\n-    return 0;\n-\n-  for (n_free = 0; n_free < 8 && !(live_regs_mask & 1); live_regs_mask >>= 1)\n-    n_free++;\n-\n-  if (n_free == 0)\n-    return 0;\n-  gcc_assert (amount / 4 * 4 == amount);\n-\n-  if (amount >= 512 && (amount - n_free * 4) < 512)\n-    return (amount - 508) / 4;\n-  if (amount <= n_free * 4)\n-    return amount / 4;\n-  return 0;\n-}\n-\n /* Generate the rest of a function's prologue.  */\n void\n thumb1_expand_prologue (void)\n@@ -19902,7 +19942,7 @@ thumb1_expand_prologue (void)\n \t\t    stack_pointer_rtx);\n \n   amount = offsets->outgoing_args - offsets->saved_regs;\n-  amount -= 4 * thumb1_extra_regs_pushed (offsets);\n+  amount -= 4 * thumb1_extra_regs_pushed (offsets, true);\n   if (amount)\n     {\n       if (amount < 512)\n@@ -19987,6 +20027,7 @@ thumb1_expand_epilogue (void)\n       emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));\n       amount = offsets->locals_base - offsets->saved_regs;\n     }\n+  amount -= 4 * thumb1_extra_regs_pushed (offsets, false);\n \n   gcc_assert (amount >= 0);\n   if (amount)\n@@ -20209,7 +20250,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t   || (high_regs_pushed == 0 && l_mask))\n     {\n       unsigned long mask = l_mask;\n-      mask |= (1 << thumb1_extra_regs_pushed (offsets)) - 1;\n+      mask |= (1 << thumb1_extra_regs_pushed (offsets, true)) - 1;\n       thumb_pushpop (f, mask, 1, &cfa_offset, mask);\n     }\n "}, {"sha": "71906e60a9acab90302dcb12e3101f44a52ac906", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e784c52cd2d0599cc29c8a66240af64cfac79371", "patch": "@@ -1,3 +1,10 @@\n+2010-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/40657\n+\t* gcc.target/arm/pr40657-1.c: New test.\n+\t* gcc.target/arm/pr40657-2.c: New test.\n+\t* gcc.c-torture/execute/pr40657.c: New test.\n+\n 2010-07-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/tree-ssa/vrp50.c: New test."}, {"sha": "e6d8dda9f99e8cb8fadaa15cc8a1f769aa03127c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr40657.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr40657.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr40657.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr40657.c?ref=e784c52cd2d0599cc29c8a66240af64cfac79371", "patch": "@@ -0,0 +1,23 @@\n+/* Verify that that Thumb-1 epilogue size optimization does not clobber the\n+   return value.  */\n+\n+long long v = 0x123456789abc;\n+\n+__attribute__((noinline)) void bar (int *x)\n+{\n+  asm volatile (\"\" : \"=m\" (x) ::);\n+}\n+\n+__attribute__((noinline)) long long foo()\n+{\n+  int x;\n+  bar(&x);\n+  return v;\n+}\n+\n+int main ()\n+{\n+  if (foo () != v)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "a6ac6c78a1cf0c796b70e83212483027905bfa60", "filename": "gcc/testsuite/gcc.target/arm/pr40657-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40657-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40657-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40657-1.c?ref=e784c52cd2d0599cc29c8a66240af64cfac79371", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-Os -march=armv5te -mthumb\" }  */\n+/* { dg-require-effective-target arm_thumb1_ok } */\n+/* { dg-final { scan-assembler \"pop.*r1.*pc\" } } */\n+/* { dg-final { scan-assembler-not \"sub\\[\\\\t \\]*sp,\\[\\\\t \\]*sp\" } } */\n+/* { dg-final { scan-assembler-not \"add\\[\\\\t \\]*sp,\\[\\\\t \\]*sp\" } } */\n+\n+extern void bar(int*);\n+int foo()\n+{\n+  int x;\n+  bar(&x);\n+  return x;\n+}"}, {"sha": "31d48376730485a9e79f5cc04ba168ecdf5e7ae3", "filename": "gcc/testsuite/gcc.target/arm/pr40657-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40657-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e784c52cd2d0599cc29c8a66240af64cfac79371/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40657-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40657-2.c?ref=e784c52cd2d0599cc29c8a66240af64cfac79371", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-Os -march=armv4t -mthumb\" }  */\n+/* { dg-require-effective-target arm_thumb1_ok } */\n+/* { dg-final { scan-assembler-not \"sub\\[\\\\t \\]*sp,\\[\\\\t \\]*sp\" } } */\n+/* { dg-final { scan-assembler-not \"add\\[\\\\t \\]*sp,\\[\\\\t \\]*sp\" } } */\n+\n+/* Here, we test that if there's a pop of r[4567] in the epilogue,\n+   add sp,sp,#12 is removed and replaced by three additional pops\n+   of lower-numbered regs.  */\n+\n+extern void bar(int*);\n+\n+int t1, t2, t3, t4, t5;\n+int foo()\n+{\n+  int i,j,k,x = 0;\n+  for (i = 0; i < t1; i++)\n+    for (j = 0; j < t2; j++)\n+\t  bar(&x);\n+  return x;\n+}"}]}