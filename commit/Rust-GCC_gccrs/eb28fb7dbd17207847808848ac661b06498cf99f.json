{"sha": "eb28fb7dbd17207847808848ac661b06498cf99f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIyOGZiN2RiZDE3MjA3ODQ3ODA4ODQ4YWM2NjFiMDY0OThjZjk5Zg==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-04-12T17:34:03Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-04-12T17:34:03Z"}, "message": "+ * trans-types.c: Update copyright years.\n\n+       * trans-types.c: Update copyright years.  Reformat long comment\n+       explaining array descriptor format.  Remove obsolete mention of\n+       TYPE_SET.\n+\n\nFrom-SVN: r123753", "tree": {"sha": "9ff3e9515f456382067cf3f57a0a5755a7248b03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ff3e9515f456382067cf3f57a0a5755a7248b03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb28fb7dbd17207847808848ac661b06498cf99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb28fb7dbd17207847808848ac661b06498cf99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb28fb7dbd17207847808848ac661b06498cf99f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb28fb7dbd17207847808848ac661b06498cf99f/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08e7ceb3d3d4d3763bdb5cfbb1dd0a78b27f0e5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e7ceb3d3d4d3763bdb5cfbb1dd0a78b27f0e5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08e7ceb3d3d4d3763bdb5cfbb1dd0a78b27f0e5d"}], "stats": {"total": 79, "additions": 42, "deletions": 37}, "files": [{"sha": "58b790be898d7550853c29edf537a13d9c22947c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb28fb7dbd17207847808848ac661b06498cf99f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb28fb7dbd17207847808848ac661b06498cf99f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eb28fb7dbd17207847808848ac661b06498cf99f", "patch": "@@ -1,5 +1,9 @@\n 2007-04-12  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n+\t* trans-types.c: Update copyright years.  Reformat long comment\n+\texplaining array descriptor format.  Remove obsolete mention of\n+\tTYPE_SET.\n+\n \t* arith.c (gfc_arith_uplus): Rename to ...\n \t(gfc_arith_identity): ... this.\n \t(gfc_parentheses): New function."}, {"sha": "24a3f3c1b48fcf8a35cf8e7e1eecb08b462abe7f", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb28fb7dbd17207847808848ac661b06498cf99f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb28fb7dbd17207847808848ac661b06498cf99f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=eb28fb7dbd17207847808848ac661b06498cf99f", "patch": "@@ -1,6 +1,6 @@\n /* Backend support for Fortran 95 basic types and derived types.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n+   Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n \n@@ -755,7 +755,7 @@ gfc_get_element_type (tree type)\n   return element;\n }\n \f\n-/* Build an array. This function is called from gfc_sym_type().\n+/* Build an array.  This function is called from gfc_sym_type().\n    Actually returns array descriptor type.\n \n    Format of array descriptors is as follows:\n@@ -775,54 +775,55 @@ gfc_get_element_type (tree type)\n       index ubound;\n     }\n \n-   Translation code should use gfc_conv_descriptor_* rather than accessing\n-   the descriptor directly. Any changes to the array descriptor type will\n-   require changes in gfc_conv_descriptor_* and gfc_build_array_initializer.\n+   Translation code should use gfc_conv_descriptor_* rather than\n+   accessing the descriptor directly.  Any changes to the array\n+   descriptor type will require changes in gfc_conv_descriptor_* and\n+   gfc_build_array_initializer.\n \n-   This is represented internally as a RECORD_TYPE. The index nodes are\n-   gfc_array_index_type and the data node is a pointer to the data. See below\n-   for the handling of character types.\n+   This is represented internally as a RECORD_TYPE. The index nodes\n+   are gfc_array_index_type and the data node is a pointer to the\n+   data.  See below for the handling of character types.\n \n    The dtype member is formatted as follows:\n     rank = dtype & GFC_DTYPE_RANK_MASK // 3 bits\n     type = (dtype & GFC_DTYPE_TYPE_MASK) >> GFC_DTYPE_TYPE_SHIFT // 3 bits\n     size = dtype >> GFC_DTYPE_SIZE_SHIFT\n \n-   I originally used nested ARRAY_TYPE nodes to represent arrays, but this\n-   generated poor code for assumed/deferred size arrays.  These require\n-   use of PLACEHOLDER_EXPR/WITH_RECORD_EXPR, which isn't part of the GENERIC\n-   grammar.  Also, there is no way to explicitly set the array stride, so\n-   all data must be packed(1).  I've tried to mark all the functions which\n-   would require modification with a GCC ARRAYS comment.\n+   I originally used nested ARRAY_TYPE nodes to represent arrays, but\n+   this generated poor code for assumed/deferred size arrays.  These\n+   require use of PLACEHOLDER_EXPR/WITH_RECORD_EXPR, which isn't part\n+   of the GENERIC grammar.  Also, there is no way to explicitly set\n+   the array stride, so all data must be packed(1).  I've tried to\n+   mark all the functions which would require modification with a GCC\n+   ARRAYS comment.\n \n-   The data component points to the first element in the array.\n-   The offset field is the position of the origin of the array\n-   (ie element (0, 0 ...)).  This may be outsite the bounds of the array.\n+   The data component points to the first element in the array.  The\n+   offset field is the position of the origin of the array (ie element\n+   (0, 0 ...)).  This may be outsite the bounds of the array.\n \n    An element is accessed by\n-   data[offset + index0*stride0 + index1*stride1 + index2*stride2]\n+    data[offset + index0*stride0 + index1*stride1 + index2*stride2]\n    This gives good performance as the computation does not involve the\n-   bounds of the array.  For packed arrays, this is optimized further by\n-   substituting the known strides.\n+   bounds of the array.  For packed arrays, this is optimized further\n+   by substituting the known strides.\n \n-   This system has one problem: all array bounds must be withing 2^31 elements\n-   of the origin (2^63 on 64-bit machines).  For example\n-   integer, dimension (80000:90000, 80000:90000, 2) :: array\n-   may not work properly on 32-bit machines because 80000*80000 > 2^31, so\n-   the calculation for stride02 would overflow.  This may still work, but\n-   I haven't checked, and it relies on the overflow doing the right thing.\n+   This system has one problem: all array bounds must be within 2^31\n+   elements of the origin (2^63 on 64-bit machines).  For example\n+    integer, dimension (80000:90000, 80000:90000, 2) :: array\n+   may not work properly on 32-bit machines because 80000*80000 >\n+   2^31, so the calculation for stride02 would overflow.  This may\n+   still work, but I haven't checked, and it relies on the overflow\n+   doing the right thing.\n \n    The way to fix this problem is to access elements as follows:\n-   data[(index0-lbound0)*stride0 + (index1-lbound1)*stride1]\n-   Obviously this is much slower.  I will make this a compile time option,\n-   something like -fsmall-array-offsets.  Mixing code compiled with and without\n-   this switch will work.\n-\n-   (1) This can be worked around by modifying the upper bound of the previous\n-   dimension.  This requires extra fields in the descriptor (both real_ubound\n-   and fake_ubound).  In tree.def there is mention of TYPE_SEP, which\n-   may allow us to do this.  However I can't find mention of this anywhere\n-   else.  */\n+    data[(index0-lbound0)*stride0 + (index1-lbound1)*stride1]\n+   Obviously this is much slower.  I will make this a compile time\n+   option, something like -fsmall-array-offsets.  Mixing code compiled\n+   with and without this switch will work.\n+\n+   (1) This can be worked around by modifying the upper bound of the\n+   previous dimension.  This requires extra fields in the descriptor\n+   (both real_ubound and fake_ubound).  */\n \n \n /* Returns true if the array sym does not require a descriptor.  */"}]}