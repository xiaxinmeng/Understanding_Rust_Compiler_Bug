{"sha": "d2c5305bdbe4a625a341df26803cd475ffe2f478", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJjNTMwNWJkYmU0YTYyNWEzNDFkZjI2ODAzY2Q0NzVmZmUyZjQ3OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-03T04:05:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-03T04:05:43Z"}, "message": "class.c (struct base_info): Remove.\n\n\t* class.c (struct base_info): Remove.\n\t(determine_primary_base): Take has_virtual_p rather than a\n\tbase_info as input.  Don't calculate max_has_virtual.\n\t(finish_struct_bits): Remove max_has_virtual argument.\n\t(create_vtable_ptr): Remove max_has_virtual_p argument.\n\t(layout_virtual_bases): Remove max argument.\n\t(layout_basetypes): Likewise.\n\t(layout_class_type): Remove max_has_virtual_p argument.\n\t(finish_struct_1): Remove max_has_virtual.\n\nFrom-SVN: r31174", "tree": {"sha": "616f7aa90c153e2612e1b6b9d80cc6bea9023769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/616f7aa90c153e2612e1b6b9d80cc6bea9023769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2c5305bdbe4a625a341df26803cd475ffe2f478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c5305bdbe4a625a341df26803cd475ffe2f478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2c5305bdbe4a625a341df26803cd475ffe2f478", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c5305bdbe4a625a341df26803cd475ffe2f478/comments", "author": null, "committer": null, "parents": [{"sha": "a71811fe383203d239582ed2980b7909c7829095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71811fe383203d239582ed2980b7909c7829095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a71811fe383203d239582ed2980b7909c7829095"}], "stats": {"total": 130, "additions": 44, "deletions": 86}, "files": [{"sha": "6d5d7d32d36252aea8ac3b77eb0f2bc1e7cb4354", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c5305bdbe4a625a341df26803cd475ffe2f478/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c5305bdbe4a625a341df26803cd475ffe2f478/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d2c5305bdbe4a625a341df26803cd475ffe2f478", "patch": "@@ -1,5 +1,15 @@\n 2000-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (struct base_info): Remove.\n+\t(determine_primary_base): Take has_virtual_p rather than a\n+\tbase_info as input.  Don't calculate max_has_virtual.\n+\t(finish_struct_bits): Remove max_has_virtual argument.\n+\t(create_vtable_ptr): Remove max_has_virtual_p argument.\n+\t(layout_virtual_bases): Remove max argument.\n+\t(layout_basetypes): Likewise.\n+\t(layout_class_type): Remove max_has_virtual_p argument.\n+\t(finish_struct_1): Remove max_has_virtual.\n+\t\n \t* cp-tree.h (dfs_mark_primary_bases_queue_p): New function.\n \t(layout_basetypes): Remove.\n \t* class.c (propagate_binfo_offsets): Moved here from tree.c."}, {"sha": "edb0e3d3529b9d86bba9351609459ecb441848c9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 34, "deletions": 86, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c5305bdbe4a625a341df26803cd475ffe2f478/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c5305bdbe4a625a341df26803cd475ffe2f478/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d2c5305bdbe4a625a341df26803cd475ffe2f478", "patch": "@@ -1,5 +1,5 @@\n /* Functions related to building classes and their related objects.\n-   Copyright (C) 1987, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 92-97, 1998, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -72,8 +72,6 @@ typedef struct class_stack_node {\n static int current_class_stack_size;\n static class_stack_node_t current_class_stack;\n \n-struct base_info;\n-\n static tree get_vfield_name PROTO((tree));\n static void finish_struct_anon PROTO((tree));\n static tree build_vbase_pointer PROTO((tree, tree));\n@@ -92,7 +90,7 @@ static tree get_vtable_entry_n PROTO((tree, unsigned HOST_WIDE_INT));\n static void add_virtual_function PROTO((tree *, tree *, int *, tree, tree));\n static tree delete_duplicate_fields_1 PROTO((tree, tree));\n static void delete_duplicate_fields PROTO((tree));\n-static void finish_struct_bits PROTO((tree, int));\n+static void finish_struct_bits PROTO((tree));\n static int alter_access PROTO((tree, tree, tree, tree));\n static void handle_using_decl PROTO((tree, tree));\n static int overrides PROTO((tree, tree));\n@@ -107,7 +105,7 @@ static void modify_one_vtable PROTO((tree, tree, tree));\n static void modify_all_vtables PROTO((tree, tree));\n static void modify_all_direct_vtables PROTO((tree, int, tree, tree));\n static void modify_all_indirect_vtables PROTO((tree, int, int, tree, tree));\n-static void determine_primary_base PROTO((tree, struct base_info *));\n+static void determine_primary_base PROTO((tree, int *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n static int field_decl_cmp PROTO ((const tree *, const tree *));\n@@ -133,15 +131,15 @@ static void check_methods PROTO((tree));\n static void remove_zero_width_bit_fields PROTO((tree));\n static void check_bases PROTO((tree, int *, int *, int *));\n static void check_bases_and_members PROTO((tree, int *));\n-static void create_vtable_ptr PROTO((tree, int *, int *, int *, tree *, tree *));\n-static void layout_class_type PROTO((tree, int *, int *, int *, tree *, tree *));\n+static void create_vtable_ptr PROTO((tree, int *, int *, tree *, tree *));\n+static void layout_class_type PROTO((tree, int *, int *, tree *, tree *));\n static void fixup_pending_inline PROTO((struct pending_inline *));\n static void fixup_inline_methods PROTO((tree));\n static void set_primary_base PROTO((tree, int, int *));\n static void propagate_binfo_offsets PROTO((tree, tree));\n-static int layout_basetypes PROTO((tree, int));\n+static void layout_basetypes PROTO((tree));\n static tree dfs_mark_primary_bases_and_set_vbase_offsets PROTO((tree, void *));\n-static int layout_virtual_bases PROTO((tree, int));\n+static void layout_virtual_bases PROTO((tree));\n static void remove_base_fields PROTO((tree));\n \n /* Variables shared between class.c and call.c.  */\n@@ -1501,12 +1499,6 @@ handle_using_decl (using_decl, t)\n     alter_access (t, binfo, fdecl, access);\n }\n \f\n-struct base_info\n-{\n-  int has_virtual;\n-  int max_has_virtual;\n-};\n-\n /* Run through the base clases of T, updating\n    CANT_HAVE_DEFAULT_CTOR_P, CANT_HAVE_CONST_CTOR_P, and\n    NO_CONST_ASN_REF_P.  Also set flag bits in T based on properties of\n@@ -1653,12 +1645,13 @@ set_primary_base (t, i, has_virtual_p)\n /* Determine the primary class for T.  */\n \n static void\n-determine_primary_base (t, b)\n+determine_primary_base (t, has_virtual_p)\n      tree t;\n-     struct base_info *b;\n+     int *has_virtual_p;\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n-  bzero ((char *) b, sizeof (struct base_info));\n+\n+  *has_virtual_p = 0;\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n@@ -1679,7 +1672,7 @@ determine_primary_base (t, b)\n \n \t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t    {\n-\t      set_primary_base (t, i, &b->has_virtual);\n+\t      set_primary_base (t, i, has_virtual_p);\n \t      CLASSTYPE_VFIELDS (t) = copy_list (CLASSTYPE_VFIELDS (basetype));\n \t    }\n \t  else\n@@ -1697,38 +1690,22 @@ determine_primary_base (t, b)\n \t\t\t\t VF_BASETYPE_VALUE (vfields),\n \t\t\t\t CLASSTYPE_VFIELDS (t));\n \n-\t      if (b->has_virtual == 0)\n-\t\tset_primary_base (t, i, &b->has_virtual);\n+\t      if (*has_virtual_p == 0)\n+\t\tset_primary_base (t, i, has_virtual_p);\n \t    }\n \t}\n     }\n \n   if (!TYPE_VFIELD (t))\n     CLASSTYPE_VFIELD_PARENT (t) = -1;\n-\n-  {\n-    tree vfields;\n-    /* Find the base class with the largest number of virtual functions.  */\n-    for (vfields = CLASSTYPE_VFIELDS (t); \n-\t vfields; \n-\t vfields = TREE_CHAIN (vfields))\n-      {\n-\tif (CLASSTYPE_VSIZE (VF_BASETYPE_VALUE (vfields)) > b->max_has_virtual)\n-\t  b->max_has_virtual = CLASSTYPE_VSIZE (VF_BASETYPE_VALUE (vfields));\n-\tif (VF_DERIVED_VALUE (vfields)\n-\t    && CLASSTYPE_VSIZE (VF_DERIVED_VALUE (vfields)) > b->max_has_virtual)\n-\t  b->max_has_virtual = CLASSTYPE_VSIZE (VF_DERIVED_VALUE (vfields));\n-      }\n-  }\n }\n \f\n-/* Set memoizing fields and bits of T (and its variants) for later use.\n-   MAX_HAS_VIRTUAL is the largest size of any T's virtual function tables.  */\n+/* Set memoizing fields and bits of T (and its variants) for later\n+   use.  */\n \n static void\n-finish_struct_bits (t, max_has_virtual)\n+finish_struct_bits (t)\n      tree t;\n-     int max_has_virtual;\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n@@ -1756,7 +1733,7 @@ finish_struct_bits (t, max_has_virtual)\n       variants = TYPE_NEXT_VARIANT (variants);\n     }\n \n-  if (n_baseclasses && max_has_virtual)\n+  if (n_baseclasses && TYPE_POLYMORPHIC_P (t))\n     /* For a class w/o baseclasses, `finish_struct' has set\n        CLASS_TYPE_ABSTRACT_VIRTUALS correctly (by\n        definition). Similarly for a class whose base classes do not\n@@ -4011,12 +3988,11 @@ check_bases_and_members (t, empty_p)\n    TYPE_FIELDS list.  */\n \n static void\n-create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n+create_vtable_ptr (t, empty_p, has_virtual_p, \n \t\t   pending_virtuals_p, pending_hard_virtuals_p)\n      tree t;\n      int *empty_p;\n      int *has_virtual_p;\n-     int *max_has_virtual_p;\n      tree *pending_virtuals_p;\n      tree *pending_hard_virtuals_p;\n {\n@@ -4025,14 +4001,8 @@ create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n   /* If possible, we reuse the virtual function table pointer from one\n      of our base classes.  */\n   if (CLASSTYPE_N_BASECLASSES (t))\n-    {\n-      struct base_info base_info;\n-\n-      /* Remember where we got our vfield from.  */\n-      determine_primary_base (t, &base_info);\n-      *has_virtual_p = base_info.has_virtual;\n-      *max_has_virtual_p = base_info.max_has_virtual;\n-    }\n+    /* Remember where we got our vfield from.  */\n+    determine_primary_base (t, has_virtual_p);\n \n   /* Loop over the virtual functions, adding them to our various\n      vtables.  */\n@@ -4333,13 +4303,11 @@ dfs_mark_primary_bases_and_set_vbase_offsets (binfo, data)\n }\n \n /* Set BINFO_OFFSET for all of the virtual bases for T.  Update\n-   TYPE_ALIGN and TYPE_SIZE for T.  Return the maximum of MAX and the\n-   largest CLASSTYPE_VSIZE for any of the virtual bases.  */\n+   TYPE_ALIGN and TYPE_SIZE for T.  */\n \n-static int\n-layout_virtual_bases (t, max)\n+static void\n+layout_virtual_bases (t)\n      tree t;\n-     int max;\n {\n   tree vbase;\n   int dsize;\n@@ -4390,10 +4358,6 @@ layout_virtual_bases (t, max)\n \t\t  dfs_mark_primary_bases_and_set_vbase_offsets,\n \t\t  dfs_mark_primary_bases_queue_p, \n \t\t  t);\n-\n-\t/* While we're here, see if this new virtual base class has\n-\t   more virtual functions than we expected.  */\n-\tmax = MAX (CLASSTYPE_VSIZE (basetype), max);\n       }\n \n   /* We're done with the various marks, now, so clear them.  */\n@@ -4406,22 +4370,16 @@ layout_virtual_bases (t, max)\n   TYPE_SIZE (t) = size_int (dsize);\n   TYPE_SIZE_UNIT (t) = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (t),\n \t\t\t\t   size_int (BITS_PER_UNIT));\n-\n-  return max;\n }\n \n /* Finish the work of layout_record, now taking virtual bases into account.\n    Also compute the actual offsets that our base classes will have.\n    This must be performed after the fields are laid out, since virtual\n-   baseclasses must lay down at the end of the record.\n+   baseclasses must lay down at the end of the record.  */\n \n-   Returns the maximum number of virtual functions any of the\n-   baseclasses provide.  */\n-\n-static int\n-layout_basetypes (rec, max)\n+static void\n+layout_basetypes (rec)\n      tree rec;\n-     int max;\n {\n   tree vbase_types;\n \n@@ -4437,7 +4395,7 @@ layout_basetypes (rec, max)\n   remove_base_fields (rec);\n \n   /* Allocate the virtual base classes.  */\n-  max = layout_virtual_bases (rec, max);\n+  layout_virtual_bases (rec);\n \n   /* Get all the virtual base types that this type uses.  The\n      TREE_VALUE slot holds the virtual baseclass type.  Note that\n@@ -4458,21 +4416,18 @@ layout_basetypes (rec, max)\n \t\t\tbasetype, rec);\n \t}\n     }\n-\n-  return max;\n }\n \n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n    BINFO_OFFSETs for all of the base-classes.  Position the vtable\n    pointer.  */\n \n static void\n-layout_class_type (t, empty_p, has_virtual_p, max_has_virtual_p,\n+layout_class_type (t, empty_p, has_virtual_p, \n \t\t   pending_virtuals_p, pending_hard_virtuals_p)\n      tree t;\n      int *empty_p;\n      int *has_virtual_p;\n-     int *max_has_virtual_p;\n      tree *pending_virtuals_p;\n      tree *pending_hard_virtuals_p;\n {\n@@ -4484,7 +4439,7 @@ layout_class_type (t, empty_p, has_virtual_p, max_has_virtual_p,\n \t\t\t     TYPE_FIELDS (t));\n \n   /* Create a pointer to our virtual function table.  */\n-  create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n+  create_vtable_ptr (t, empty_p, has_virtual_p,\n \t\t     pending_virtuals_p, pending_hard_virtuals_p);\n \n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n@@ -4545,7 +4500,7 @@ layout_class_type (t, empty_p, has_virtual_p, max_has_virtual_p,\n      virtual function table.  */\n   if (CLASSTYPE_N_BASECLASSES (t))\n     /* layout_basetypes will remove the base subobject fields.  */\n-    *max_has_virtual_p = layout_basetypes (t, *max_has_virtual_p);\n+    layout_basetypes (t);\n }\n      \n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n@@ -4581,7 +4536,6 @@ finish_struct_1 (t)\n {\n   tree x;\n   int has_virtual;\n-  int max_has_virtual;\n   tree pending_virtuals = NULL_TREE;\n   tree pending_hard_virtuals = NULL_TREE;\n   int n_fields = 0;\n@@ -4607,15 +4561,14 @@ finish_struct_1 (t)\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n   CLASSTYPE_VFIELD_PARENT (t) = -1;\n   has_virtual = 0;\n-  max_has_virtual = 0;\n   CLASSTYPE_RTTI (t) = NULL_TREE;\n \n   /* Do end-of-class semantic processing: checking the validity of the\n      bases and members and add implicitly generated methods.  */\n   check_bases_and_members (t, &empty);\n \n   /* Layout the class itself.  */\n-  layout_class_type (t, &empty, &has_virtual, &max_has_virtual,\n+  layout_class_type (t, &empty, &has_virtual,\n \t\t     &pending_virtuals, &pending_hard_virtuals);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n@@ -4670,11 +4623,6 @@ finish_struct_1 (t)\n       TYPE_VFIELD (t) = vfield;\n     }\n \n-  if (has_virtual > max_has_virtual)\n-    max_has_virtual = has_virtual;\n-  if (max_has_virtual > 0)\n-    TYPE_POLYMORPHIC_P (t) = 1;\n-\n   if (flag_rtti && TYPE_POLYMORPHIC_P (t) && !pending_hard_virtuals)\n     modify_all_vtables (t, NULL_TREE);\n \n@@ -4756,7 +4704,7 @@ finish_struct_1 (t)\n \tCLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n \n-  if (max_has_virtual || CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+  if (TYPE_POLYMORPHIC_P (t))\n     {\n       CLASSTYPE_VSIZE (t) = has_virtual;\n       if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n@@ -4801,7 +4749,7 @@ finish_struct_1 (t)\n     CLASSTYPE_VFIELDS (t) \n       = chainon (CLASSTYPE_VFIELDS (t), build_tree_list (NULL_TREE, t));\n \n-  finish_struct_bits (t, max_has_virtual);\n+  finish_struct_bits (t);\n \n   /* Complete the rtl for any static member objects of the type we're\n      working on.  */"}]}