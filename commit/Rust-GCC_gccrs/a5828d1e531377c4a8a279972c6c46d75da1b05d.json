{"sha": "a5828d1e531377c4a8a279972c6c46d75da1b05d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU4MjhkMWU1MzEzNzdjNGE4YTI3OTk3MmM2YzQ2ZDc1ZGExYjA1ZA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2007-09-10T07:40:30Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2007-09-10T07:40:30Z"}, "message": "tree-pass.h (pass_cselim): Declare new pass.\n\n        * tree-pass.h (pass_cselim): Declare new pass.\n        * passes.c (init_optimization_passes): Link in pass_cselim.\n        * tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Renamed from\n        tree_ssa_phiopt; add do_store_elim parameter, handle it by calling\n        cond_store_replacement.\n        (condstoretemp): New static variable.\n        (cond_store_replacement): New function.\n        (tree_ssa_phiopt, tree_ssa_cs_elim): New wrappers around\n        tree_ssa_phiopt_worker.\n        (struct name_to_bb): New.\n        (get_non_trapping, name_to_bb_hash, name_to_bb_eq, add_or_mark_expr,\n        nt_init_block, nt_fini_block): New static functions.\n        (seen_ssa_names, nontrap_set): New static variables.\n        (gate_cselim, pass_cselim): Define new pass.\n        * common.opt (ftree-cselim): New flag.\n        * toplev.c (process_options): Set flag_tree_cselim if required.\n\nFrom-SVN: r128324", "tree": {"sha": "c03c05f82a86dbfb3dca7ceb9ce0a4d39d1efdbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c03c05f82a86dbfb3dca7ceb9ce0a4d39d1efdbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5828d1e531377c4a8a279972c6c46d75da1b05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5828d1e531377c4a8a279972c6c46d75da1b05d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5828d1e531377c4a8a279972c6c46d75da1b05d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5828d1e531377c4a8a279972c6c46d75da1b05d/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf369845fd042cc7bd25cb8b824857af6f22f446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf369845fd042cc7bd25cb8b824857af6f22f446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf369845fd042cc7bd25cb8b824857af6f22f446"}], "stats": {"total": 446, "additions": 419, "deletions": 27}, "files": [{"sha": "8acb6471705e2460584c0da2a734ff15fe55229b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5828d1e531377c4a8a279972c6c46d75da1b05d", "patch": "@@ -1,3 +1,22 @@\n+2007-09-10  Michael Matz  <matz@suse.de>\n+\n+\t* tree-pass.h (pass_cselim): Declare new pass.\n+\t* passes.c (init_optimization_passes): Link in pass_cselim.\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Renamed from\n+\ttree_ssa_phiopt; add do_store_elim parameter, handle it by calling\n+\tcond_store_replacement.\n+\t(condstoretemp): New static variable.\n+\t(cond_store_replacement): New function.\n+\t(tree_ssa_phiopt, tree_ssa_cs_elim): New wrappers around\n+\ttree_ssa_phiopt_worker.\n+\t(struct name_to_bb): New.\n+\t(get_non_trapping, name_to_bb_hash, name_to_bb_eq, add_or_mark_expr,\n+\tnt_init_block, nt_fini_block): New static functions.\n+\t(seen_ssa_names, nontrap_set): New static variables.\n+\t(gate_cselim, pass_cselim): Define new pass.\n+\t* common.opt (ftree-cselim): New flag.\n+\t* toplev.c (process_options): Set flag_tree_cselim if required.\n+\n 2007-09-10  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* simplify-rtx.c (simplify_relational_operation_1): For recent"}, {"sha": "a2afcf277aec9952799c81d2854ac0e8e087263a", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a5828d1e531377c4a8a279972c6c46d75da1b05d", "patch": "@@ -1052,6 +1052,10 @@ ftree-store-copy-prop\n Common Report Var(flag_tree_store_copy_prop) Optimization\n Enable copy propagation for stores and loads\n \n+ftree-cselim\n+Common Report Var(flag_tree_cselim) Init(2) Optimization\n+Transform condition stores into unconditional ones\n+\n ftree-dce\n Common Report Var(flag_tree_dce) Optimization\n Enable SSA dead code elimination optimization on trees"}, {"sha": "7f4484226e60d483d33b3bf42e26d853d3e432c1", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a5828d1e531377c4a8a279972c6c46d75da1b05d", "patch": "@@ -569,6 +569,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_merge_phi);\n       NEXT_PASS (pass_vrp);\n       NEXT_PASS (pass_dce);\n+      NEXT_PASS (pass_cselim);\n       NEXT_PASS (pass_dominator);\n       /* The only const/copy propagation opportunities left after\n \t DOM should be due to degenerate PHI nodes.  So rather than"}, {"sha": "76887bc25e08382e42173564687d96162656d8f6", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a5828d1e531377c4a8a279972c6c46d75da1b05d", "patch": "@@ -1920,6 +1920,13 @@ process_options (void)\n   if (flag_var_tracking == AUTODETECT_VALUE)\n     flag_var_tracking = optimize >= 1;\n \n+  if (flag_tree_cselim == AUTODETECT_VALUE)\n+#ifdef HAVE_conditional_move\n+    flag_tree_cselim = 1;\n+#else\n+    flag_tree_cselim = 0;\n+#endif\n+\n   /* If the user specifically requested variable tracking with tagging\n      uninitialized variables, we need to turn on variable tracking.\n      (We already determined above that variable tracking is feasible.)  */"}, {"sha": "df879d85d9f3254327e3c5351a3ba2efab09adb4", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=a5828d1e531377c4a8a279972c6c46d75da1b05d", "patch": "@@ -301,6 +301,7 @@ extern struct tree_opt_pass pass_cse_sincos;\n extern struct tree_opt_pass pass_convert_to_rsqrt;\n extern struct tree_opt_pass pass_warn_function_return;\n extern struct tree_opt_pass pass_warn_function_noreturn;\n+extern struct tree_opt_pass pass_cselim;\n extern struct tree_opt_pass pass_phiopt;\n extern struct tree_opt_pass pass_forwprop;\n extern struct tree_opt_pass pass_phiprop;"}, {"sha": "a8376cf5885e80124d84ff37e398ddf1445d0e8b", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 387, "deletions": 27, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5828d1e531377c4a8a279972c6c46d75da1b05d/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=a5828d1e531377c4a8a279972c6c46d75da1b05d", "patch": "@@ -33,8 +33,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n #include \"langhooks.h\"\n+#include \"pointer-set.h\"\n+#include \"domwalk.h\"\n \n-static unsigned int tree_ssa_phiopt (void);\n+static unsigned int tree_ssa_phiopt_worker (bool);\n static bool conditional_replacement (basic_block, basic_block,\n \t\t\t\t     edge, edge, tree, tree, tree);\n static bool value_replacement (basic_block, basic_block,\n@@ -43,6 +45,9 @@ static bool minmax_replacement (basic_block, basic_block,\n \t\t\t\tedge, edge, tree, tree, tree);\n static bool abs_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, tree, tree, tree);\n+static bool cond_store_replacement (basic_block, basic_block, edge, edge,\n+\t\t\t\t    struct pointer_set_t *);\n+static struct pointer_set_t * get_non_trapping (void);\n static void replace_phi_edge_with_variable (basic_block, edge, tree, tree);\n \n /* This pass tries to replaces an if-then-else block with an\n@@ -133,11 +138,62 @@ static void replace_phi_edge_with_variable (basic_block, edge, tree, tree);\n \n static unsigned int\n tree_ssa_phiopt (void)\n+{\n+  return tree_ssa_phiopt_worker (false);\n+}\n+\n+/* This pass tries to transform conditional stores into unconditional\n+   ones, enabling further simplifications with the simpler then and else\n+   blocks.  In particular it replaces this:\n+\n+     bb0:\n+       if (cond) goto bb2; else goto bb1;\n+     bb1:\n+       *p = RHS\n+     bb2:\n+\n+   with\n+\n+     bb0:\n+       if (cond) goto bb1; else goto bb2;\n+     bb1:\n+       condtmp' = *p;\n+     bb2:\n+       condtmp = PHI <RHS, condtmp'>\n+       *p = condtmp\n+\n+   This transformation can only be done under several constraints,\n+   documented below.  */\n+\n+static unsigned int\n+tree_ssa_cs_elim (void)\n+{\n+  return tree_ssa_phiopt_worker (true);\n+}\n+\n+/* For conditional store replacement we need a temporary to\n+   put the old contents of the memory in.  */\n+static tree condstoretemp;\n+\n+/* The core routine of conditional store replacement and normal\n+   phi optimizations.  Both share much of the infrastructure in how\n+   to match applicable basic block patterns.  DO_STORE_ELIM is true\n+   when we want to do conditional store replacement, false otherwise.  */\n+static unsigned int\n+tree_ssa_phiopt_worker (bool do_store_elim)\n {\n   basic_block bb;\n   basic_block *bb_order;\n   unsigned n, i;\n   bool cfgchanged = false;\n+  struct pointer_set_t *nontrap = 0;\n+\n+  if (do_store_elim)\n+    {\n+      condstoretemp = NULL_TREE;\n+      /* Calculate the set of non-trapping memory accesses.  */\n+      nontrap = get_non_trapping ();\n+    }\n \n   /* Search every basic block for COND_EXPR we may be able to optimize.\n \n@@ -209,36 +265,60 @@ tree_ssa_phiopt (void)\n           || single_pred (bb1) != bb)\n \tcontinue;\n \n-      phi = phi_nodes (bb2);\n-\n-      /* Check to make sure that there is only one PHI node.\n-         TODO: we could do it with more than one iff the other PHI nodes\n-\t have the same elements for these two edges.  */\n-      if (!phi || PHI_CHAIN (phi) != NULL)\n-\tcontinue;\n-\n-      arg0 = PHI_ARG_DEF_TREE (phi, e1->dest_idx);\n-      arg1 = PHI_ARG_DEF_TREE (phi, e2->dest_idx);\n-\n-      /* Something is wrong if we cannot find the arguments in the PHI\n-\t node.  */\n-      gcc_assert (arg0 != NULL && arg1 != NULL);\n-\n-      /* Do the replacement of conditional if it can be done.  */\n-      if (conditional_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\tcfgchanged = true;\n-      else if (value_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\tcfgchanged = true;\n-      else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\tcfgchanged = true;\n-      else if (minmax_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\tcfgchanged = true;\n+      if (do_store_elim)\n+\t{\n+\t  /* bb1 is the middle block, bb2 the join block, bb the split block,\n+\t     e1 the fallthrough edge from bb1 to bb2.  We can't do the\n+\t     optimization if the join block has more than two predecessors.  */\n+\t  if (EDGE_COUNT (bb2->preds) > 2)\n+\t    continue;\n+\t  if (cond_store_replacement (bb1, bb2, e1, e2, nontrap))\n+\t    cfgchanged = true;\n+\t}\n+      else\n+\t{\n+\t  phi = phi_nodes (bb2);\n+\n+\t  /* Check to make sure that there is only one PHI node.\n+\t     TODO: we could do it with more than one iff the other PHI nodes\n+\t     have the same elements for these two edges.  */\n+\t  if (!phi || PHI_CHAIN (phi) != NULL)\n+\t    continue;\n+\n+\t  arg0 = PHI_ARG_DEF_TREE (phi, e1->dest_idx);\n+\t  arg1 = PHI_ARG_DEF_TREE (phi, e2->dest_idx);\n+\n+\t  /* Something is wrong if we cannot find the arguments in the PHI\n+\t     node.  */\n+\t  gcc_assert (arg0 != NULL && arg1 != NULL);\n+\n+\t  /* Do the replacement of conditional if it can be done.  */\n+\t  if (conditional_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t    cfgchanged = true;\n+\t  else if (value_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t    cfgchanged = true;\n+\t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t    cfgchanged = true;\n+\t  else if (minmax_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t    cfgchanged = true;\n+\t}\n     }\n \n   free (bb_order);\n   \n-  /* If the CFG has changed, we should cleanup the CFG. */\n-  return cfgchanged ? TODO_cleanup_cfg : 0;\n+  if (do_store_elim)\n+    pointer_set_destroy (nontrap);\n+  /* If the CFG has changed, we should cleanup the CFG.  */\n+  if (cfgchanged && do_store_elim)\n+    {\n+      /* In cond-store replacement we have added some loads on edges\n+         and new VOPS (as we moved the store, and created a load).  */\n+      bsi_commit_edge_inserts ();\n+      return TODO_cleanup_cfg | TODO_update_ssa_only_virtuals;\n+    }\n+  else if (cfgchanged)\n+    return TODO_cleanup_cfg;\n+  return 0;\n }\n \n /* Returns the list of basic blocks in the function in an order that guarantees\n@@ -991,6 +1071,259 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   return true;\n }\n \n+/* Auxiliary functions to determine the set of memory accesses which\n+   can't trap because they are preceded by accesses to the same memory\n+   portion.  We do that for INDIRECT_REFs, so we only need to track\n+   the SSA_NAME of the pointer indirectly referenced.  The algorithm\n+   simply is a walk over all instructions in dominator order.  When\n+   we see an INDIRECT_REF we determine if we've already seen a same\n+   ref anywhere up to the root of the dominator tree.  If we do the\n+   current access can't trap.  If we don't see any dominator access\n+   the current access might trap, but might also make later accesses\n+   non-trapping, so we remember it.  */\n+\n+/* A hash-table of SSA_NAMEs, and in which basic block an INDIRECT_REF\n+   through it was seen, which would constitute a no-trap region for\n+   same accesses.  */\n+struct name_to_bb\n+{\n+  tree ssa_name;\n+  basic_block bb;\n+};\n+\n+/* The hash table for remembering what we've seen.  */\n+static htab_t seen_ssa_names;\n+\n+/* The set of INDIRECT_REFs which can't trap.  */\n+static struct pointer_set_t *nontrap_set;\n+\n+/* The hash function, based on the pointer to the pointer SSA_NAME.  */\n+static hashval_t\n+name_to_bb_hash (const void *p)\n+{\n+  tree n = ((struct name_to_bb *)p)->ssa_name;\n+  return htab_hash_pointer (n);\n+}\n+\n+/* The equality function of *P1 and *P2.  SSA_NAMEs are shared, so\n+   it's enough to simply compare them for equality.  */\n+static int\n+name_to_bb_eq (const void *p1, const void *p2)\n+{\n+  tree n1 = ((struct name_to_bb *)p1)->ssa_name;\n+  tree n2 = ((struct name_to_bb *)p2)->ssa_name;\n+\n+  return n1 == n2;\n+}\n+\n+/* We see a the expression EXP in basic block BB.  If it's an interesting\n+   expression (an INDIRECT_REF through an SSA_NAME) possibly insert the\n+   expression into the set NONTRAP or the hash table of seen expressions.  */\n+static void\n+add_or_mark_expr (basic_block bb, tree exp, struct pointer_set_t *nontrap)\n+{\n+  if (INDIRECT_REF_P (exp)\n+      && TREE_CODE (TREE_OPERAND (exp, 0)) == SSA_NAME)\n+    {\n+      tree name = TREE_OPERAND (exp, 0);\n+      struct name_to_bb map;\n+      void **slot;\n+      basic_block found_bb = 0;\n+\n+      /* Try to find the last seen INDIRECT_REF through the same\n+         SSA_NAME, which can trap.  */\n+      map.ssa_name = name;\n+      map.bb = 0;\n+      slot = htab_find_slot (seen_ssa_names, &map, INSERT);\n+      if (*slot)\n+        found_bb = ((struct name_to_bb *)*slot)->bb;\n+\n+      /* If we've found a trapping INDIRECT_REF, _and_ it dominates EXP\n+         (it's in a basic block on the path from us to the dominator root)\n+\t then we can't trap.  */\n+      if (found_bb && found_bb->aux == (void *)1)\n+\t{\n+\t  pointer_set_insert (nontrap, exp);\n+\t}\n+      else\n+        {\n+\t  /* EXP might trap, so insert it into the hash table.  */\n+\t  if (*slot)\n+\t    {\n+              ((struct name_to_bb *)*slot)->bb = bb;\n+\t    }\n+\t  else\n+\t    {\n+\t      struct name_to_bb *nmap = XNEW (struct name_to_bb);\n+\t      nmap->ssa_name = name;\n+\t      nmap->bb = bb;\n+\t      *slot = nmap;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Called by walk_dominator_tree, when entering the block BB.  */\n+static void\n+nt_init_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+  /* Mark this BB as being on the path to dominator root.  */\n+  bb->aux = (void*)1;\n+\n+  /* And walk the statements in order.  */\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t{\n+\t  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t  add_or_mark_expr (bb, rhs, nontrap_set);\n+\t  add_or_mark_expr (bb, lhs, nontrap_set);\n+\t}\n+    }\n+}\n+\n+/* Called by walk_dominator_tree, when basic block BB is exited.  */\n+static void\n+nt_fini_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n+{\n+  /* This BB isn't on the path to dominator root anymore.  */\n+  bb->aux = NULL;\n+}\n+\n+/* This is the entry point of gathering non trapping memory accesses.\n+   It will do a dominator walk over the whole function, and it will\n+   make use of the bb->aux pointers.  It returns a set of trees\n+   (the INDIRECT_REFs itself) which can't trap.  */\n+static struct pointer_set_t *\n+get_non_trapping (void)\n+{\n+  struct pointer_set_t *nontrap;\n+  struct dom_walk_data walk_data;\n+\n+  nontrap = pointer_set_create ();\n+  seen_ssa_names = htab_create (128, name_to_bb_hash, name_to_bb_eq,\n+\t\t\t\tfree);\n+  /* We're going to do a dominator walk, so ensure that we have\n+     dominance information.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Setup callbacks for the generic dominator tree walker.  */\n+  nontrap_set = nontrap;\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children_before_stmts = nt_init_block;\n+  walk_data.before_dom_children_walk_stmts = NULL;\n+  walk_data.before_dom_children_after_stmts = NULL;\n+  walk_data.after_dom_children_before_stmts = NULL;\n+  walk_data.after_dom_children_walk_stmts = NULL;\n+  walk_data.after_dom_children_after_stmts = nt_fini_block;\n+  walk_data.global_data = NULL;\n+  walk_data.block_local_data_size = 0;\n+  walk_data.interesting_blocks = NULL;\n+\n+  init_walk_dominator_tree (&walk_data);\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  fini_walk_dominator_tree (&walk_data);\n+  htab_delete (seen_ssa_names);\n+\n+  return nontrap;\n+}\n+\n+/* Do the main work of conditional store replacement.  We already know\n+   that the recognized pattern looks like so:\n+\n+   split:\n+     if (cond) goto MIDDLE_BB; else goto JOIN_BB (edge E1)\n+   MIDDLE_BB:\n+     something\n+     fallthrough (edge E0)\n+   JOIN_BB:\n+     some more\n+\n+   We check that MIDDLE_BB contains only one store, that that store\n+   doesn't trap (not via NOTRAP, but via checking if an access to the same\n+   memory location dominates us) and that the store has a \"simple\" RHS.  */\n+\n+static bool\n+cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n+\t\t\tedge e0, edge e1, struct pointer_set_t *nontrap)\n+{\n+  tree assign = last_and_only_stmt (middle_bb);\n+  tree lhs, rhs, newexpr, name;\n+  tree newphi;\n+  block_stmt_iterator bsi;\n+\n+  /* Check if middle_bb contains of only one store.  */\n+  if (!assign\n+      || TREE_CODE (assign) != GIMPLE_MODIFY_STMT)\n+    return false;\n+\n+  lhs = GIMPLE_STMT_OPERAND (assign, 0);\n+  if (!INDIRECT_REF_P (lhs))\n+    return false;\n+  rhs = GIMPLE_STMT_OPERAND (assign, 1);\n+  if (TREE_CODE (rhs) != SSA_NAME && !is_gimple_min_invariant (rhs))\n+    return false;\n+  /* Prove that we can move the store down.  We could also check\n+     TREE_THIS_NOTRAP here, but in that case we also could move stores,\n+     whose value is not available readily, which we want to avoid.  */\n+  if (!pointer_set_contains (nontrap, lhs))\n+    return false;\n+\n+  /* Now we've checked the constraints, so do the transformation:\n+     1) Remove the single store.  */\n+  mark_symbols_for_renaming (assign);\n+  bsi = bsi_for_stmt (assign);\n+  bsi_remove (&bsi, true);\n+\n+  /* 2) Create a temporary where we can store the old content\n+        of the memory touched by the store, if we need to.  */\n+  if (!condstoretemp || TREE_TYPE (lhs) != TREE_TYPE (condstoretemp))\n+    {\n+      condstoretemp = create_tmp_var (TREE_TYPE (lhs), \"cstore\");\n+      get_var_ann (condstoretemp);\n+    }\n+  add_referenced_var (condstoretemp);\n+\n+  /* 3) Insert a load from the memory of the store to the temporary\n+        on the edge which did not contain the store.  */\n+  lhs = unshare_expr (lhs);\n+  newexpr = build_gimple_modify_stmt (condstoretemp, lhs);\n+  name = make_ssa_name (condstoretemp, newexpr);\n+  GIMPLE_STMT_OPERAND (newexpr, 0) = name;\n+  mark_symbols_for_renaming (newexpr);\n+  bsi_insert_on_edge (e1, newexpr);\n+\n+  /* 4) Create a PHI node at the join block, with one argument\n+        holding the old RHS, and the other holding the temporary\n+        where we stored the old memory contents.  */\n+  newphi = create_phi_node (condstoretemp, join_bb);\n+  add_phi_arg (newphi, rhs, e0);\n+  add_phi_arg (newphi, name, e1);\n+\n+  lhs = unshare_expr (lhs);\n+  newexpr = build_gimple_modify_stmt (lhs, PHI_RESULT (newphi));\n+  mark_symbols_for_renaming (newexpr);\n+\n+  /* 5) Insert that PHI node.  */\n+  bsi = bsi_start (join_bb);\n+  while (!bsi_end_p (bsi) && TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR)\n+    bsi_next (&bsi);\n+  if (bsi_end_p (bsi))\n+    {\n+      bsi = bsi_last (join_bb);\n+      bsi_insert_after (&bsi, newexpr, BSI_NEW_STMT);\n+    }\n+  else\n+    bsi_insert_before (&bsi, newexpr, BSI_NEW_STMT);\n+\n+  return true;\n+}\n \n /* Always do these optimizations if we have SSA\n    trees to work on.  */\n@@ -1020,3 +1353,30 @@ struct tree_opt_pass pass_phiopt =\n     | TODO_verify_stmts,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n+\n+static bool\n+gate_cselim (void)\n+{\n+  return flag_tree_cselim;\n+}\n+\n+struct tree_opt_pass pass_cselim =\n+{\n+  \"cselim\",\t\t\t\t/* name */\n+  gate_cselim,\t\t\t\t/* gate */\n+  tree_ssa_cs_elim,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_PHIOPT,\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_verify_flow\n+    | TODO_verify_stmts,\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}]}