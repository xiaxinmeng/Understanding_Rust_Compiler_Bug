{"sha": "1f3d066157f480765d8f1c97bcfe614607abb52c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYzZDA2NjE1N2Y0ODA3NjVkOGYxYzk3YmNmZTYxNDYwN2FiYjUyYw==", "commit": {"author": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2003-10-15T22:24:56Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2003-10-15T22:24:56Z"}, "message": "linux.h (MD_FALLBACK_FRAME_STATE_FOR): New\n\n\n\t* config/mips/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New\n\t* config/mips/mips.h (DWARF_FRAME_REGNUM): Fixed to allow unwind\n\tfrom leaf functions.\n\t(DWARF_FRAME_RETURN_COLUMN): Ditto.\n\t(SIGNAL_UNWIND_RETURN_COLUMN): New, used\n\tby MD_FALLBACK_FRAME_STATE_FOR.\n\t* testsuite/gcc.dg/cleanup-9.c: Added mips*-*-linux* target.\n\nFrom-SVN: r72536", "tree": {"sha": "1676c66a6731dde19d97a0e826f6952a0f4fac10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1676c66a6731dde19d97a0e826f6952a0f4fac10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f3d066157f480765d8f1c97bcfe614607abb52c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3d066157f480765d8f1c97bcfe614607abb52c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3d066157f480765d8f1c97bcfe614607abb52c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3d066157f480765d8f1c97bcfe614607abb52c/comments", "author": null, "committer": null, "parents": [{"sha": "6492b8d80d97923f61dc12869ddf0d732d203ecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6492b8d80d97923f61dc12869ddf0d732d203ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6492b8d80d97923f61dc12869ddf0d732d203ecb"}], "stats": {"total": 81, "additions": 77, "deletions": 4}, "files": [{"sha": "8712242f43ddb382ab760a55a63175bf84e69a00", "filename": "gcc/config/mips/linux.h", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3d066157f480765d8f1c97bcfe614607abb52c/gcc%2Fconfig%2Fmips%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3d066157f480765d8f1c97bcfe614607abb52c/gcc%2Fconfig%2Fmips%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux.h?ref=1f3d066157f480765d8f1c97bcfe614607abb52c", "patch": "@@ -190,3 +190,73 @@ Boston, MA 02111-1307, USA.  */\n %{!static:-rpath-link %R/lib:%R/usr/lib} \\\n %{!shared: %{pthread:-lpthread} \\\n   %{profile:-lc_p} %{!profile: -lc}}\"\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+#ifdef IN_LIBGCC2\n+#include <signal.h>\n+\n+/* The third parameter to the signal handler points to something with\n+ * this structure defined in asm/ucontext.h, but the name clashes with\n+ * struct ucontext from sys/ucontext.h so this private copy is used. */\n+typedef struct _sig_ucontext {\n+    unsigned long         uc_flags;\n+    struct _sig_ucontext  *uc_link;\n+    stack_t               uc_stack;\n+    struct sigcontext uc_mcontext;\n+    sigset_t      uc_sigmask;\n+} _sig_ucontext_t;\n+\n+#endif /* IN_LIBGCC2  */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)            \\\n+  do {                                                               \\\n+    u_int32_t *pc_ = (u_int32_t *) (CONTEXT)->ra;                \\\n+    struct sigcontext *sc_;                                          \\\n+    _Unwind_Ptr new_cfa_;                                            \\\n+    int i_;                                                          \\\n+                                                                     \\\n+    /* 24021061 li v0, 0x1061 (rt_sigreturn)*/                       \\\n+    /* 0000000c syscall    */                                        \\\n+    /*    or */                                                      \\\n+    /* 24021017 li v0, 0x1017 (sigreturn) */                         \\\n+    /* 0000000c syscall  */                                          \\\n+    if (*(pc_ + 1) != 0x0000000c)                                    \\\n+      break;                                                         \\\n+    if (*(pc_ + 0) == 0x24021017)                                    \\\n+      {                                                              \\\n+        struct sigframe {                                            \\\n+          u_int32_t  trampoline[2];                                \\\n+          struct sigcontext sigctx;                                  \\\n+        } *rt_ = (CONTEXT)->ra;                                      \\\n+        sc_ = &rt_->sigctx;                                          \\\n+      }                                                              \\\n+    else if (*(pc_ + 0) == 0x24021061)                               \\\n+      {                                                              \\\n+        struct rt_sigframe {                                         \\\n+          u_int32_t  trampoline[2];                                \\\n+          struct siginfo info;                                       \\\n+          _sig_ucontext_t uc;                                        \\\n+        } *rt_ = (CONTEXT)->ra;                                      \\\n+        sc_ = &rt_->uc.uc_mcontext;                                  \\\n+      }                                                              \\\n+    else                                                             \\\n+      break;                                                         \\\n+                                                                     \\\n+    new_cfa_ = (_Unwind_Ptr)sc_;                                     \\\n+    (FS)->cfa_how = CFA_REG_OFFSET;                                  \\\n+    (FS)->cfa_reg = STACK_POINTER_REGNUM;                            \\\n+    (FS)->cfa_offset = new_cfa_ - (_Unwind_Ptr) (CONTEXT)->cfa;      \\\n+                                                                     \\\n+    for (i_ = 0; i_ < 32; i_++) {                                    \\\n+      (FS)->regs.reg[i_].how = REG_SAVED_OFFSET;                     \\\n+      (FS)->regs.reg[i_].loc.offset                                  \\\n+        = (_Unwind_Ptr)&(sc_->sc_regs[i_]) - new_cfa_;               \\\n+    }                                                                \\\n+    (FS)->regs.reg[SIGNAL_UNWIND_RETURN_COLUMN].how = REG_SAVED_OFFSET; \\\n+    (FS)->regs.reg[SIGNAL_UNWIND_RETURN_COLUMN].loc.offset           \\\n+        = (_Unwind_Ptr)&(sc_->sc_pc) - new_cfa_;                     \\\n+    (FS)->retaddr_column = SIGNAL_UNWIND_RETURN_COLUMN;              \\\n+                                                                     \\\n+    goto SUCCESS;                                                    \\\n+  } while (0)"}, {"sha": "23fe28571097e87c9ce0273de0bef530a52ffe7b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3d066157f480765d8f1c97bcfe614607abb52c/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3d066157f480765d8f1c97bcfe614607abb52c/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=1f3d066157f480765d8f1c97bcfe614607abb52c", "patch": "@@ -1216,11 +1216,14 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define DBX_REGISTER_NUMBER(REGNO) mips_dbx_regno[ (REGNO) ]\n \n /* The mapping from gcc register number to DWARF 2 CFA column number.  */\n-#define DWARF_FRAME_REGNUM(REG)\t\t\t\t\\\n-  (REG == GP_REG_FIRST + 31 ? DWARF_FRAME_RETURN_COLUMN : REG)\n+#define DWARF_FRAME_REGNUM(REG)\t(REG)\n \n /* The DWARF 2 CFA column which tracks the return address.  */\n-#define DWARF_FRAME_RETURN_COLUMN (FP_REG_LAST + 1)\n+#define DWARF_FRAME_RETURN_COLUMN (GP_REG_FIRST + 31)\n+\n+/* The DWARF 2 CFA column which tracks the return address from a\n+   signal handler context.  */\n+#define SIGNAL_UNWIND_RETURN_COLUMN (FP_REG_LAST + 1)\n \n /* Before the prologue, RA lives in r31.  */\n #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (VOIDmode, GP_REG_FIRST + 31)"}, {"sha": "29048d2f78ae156e47799b4ac5cfd07f424a5f64", "filename": "gcc/testsuite/gcc.dg/cleanup-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3d066157f480765d8f1c97bcfe614607abb52c/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3d066157f480765d8f1c97bcfe614607abb52c/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c?ref=1f3d066157f480765d8f1c97bcfe614607abb52c", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* } } */\n+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* mips*-*-linux* } } */\n /* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n /* Verify that cleanups work with exception handling through realtime\n    signal frames.  */"}]}