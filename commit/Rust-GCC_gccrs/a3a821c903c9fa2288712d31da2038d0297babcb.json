{"sha": "a3a821c903c9fa2288712d31da2038d0297babcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhODIxYzkwM2M5ZmEyMjg4NzEyZDMxZGEyMDM4ZDAyOTdiYWJjYg==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2018-01-14T05:19:29Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2018-01-14T05:19:29Z"}, "message": "rs6000-p8swap.c (rs6000_sum_of_two_registers_p): New function.\n\ngcc/ChangeLog:\n\n2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* config/rs6000/rs6000-p8swap.c (rs6000_sum_of_two_registers_p):\n\tNew function.\n\t(rs6000_quadword_masked_address_p): Likewise.\n\t(quad_aligned_load_p): Likewise.\n\t(quad_aligned_store_p): Likewise.\n\t(const_load_sequence_p): Add comment to describe the outer-most loop.\n\t(mimic_memory_attributes_and_flags): New function.\n\t(rs6000_gen_stvx): Likewise.\n\t(replace_swapped_aligned_store): Likewise.\n\t(rs6000_gen_lvx): Likewise.\n\t(replace_swapped_aligned_load): Likewise.\n\t(replace_swapped_load_constant): Capitalize argument name in\n\tcomment describing this function.\n\t(rs6000_analyze_swaps): Add a third pass to search for vector loads\n\tand stores that access quad-word aligned addresses and replace\n\twith stvx or lvx instructions when appropriate.\n\t* config/rs6000/rs6000-protos.h (rs6000_sum_of_two_registers_p):\n\tNew function prototype.\n\t(rs6000_quadword_masked_address_p): Likewise.\n\t(rs6000_gen_lvx): Likewise.\n\t(rs6000_gen_stvx): Likewise.\n\t* config/rs6000/vsx.md (*vsx_le_perm_load_<mode>): For modes\n\tVSX_D (V2DF, V2DI), modify this split to select lvx instruction\n\twhen memory address is aligned.\n\t(*vsx_le_perm_load_<mode>): For modes VSX_W (V4SF, V4SI), modify\n\tthis split to select lvx instruction when memory address is aligned.\n\t(*vsx_le_perm_load_v8hi): Modify this split to select lvx\n\tinstruction when memory address is aligned.\n\t(*vsx_le_perm_load_v16qi): Likewise.\n\t(four unnamed splitters): Modify to select the stvx instruction\n\twhen memory is aligned.\n\ngcc/testsuite/ChangeLog:\n\n2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* gcc.target/powerpc/pr48857.c: Modify dejagnu directives to look\n\tfor lvx and stvx instead of lxvd2x and stxvd2x and require\n\tlittle-endian target.  Add comments.\n\t* gcc.target/powerpc/swaps-p8-28.c: Add functions for more\n\tcomprehensive testing.\n\t* gcc.target/powerpc/swaps-p8-29.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-30.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-31.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-32.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-33.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-34.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-35.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-36.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-37.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-38.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-39.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-40.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-41.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-42.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-43.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-44.c: Likewise.\n\t* gcc.target/powerpc/swaps-p8-45.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-2.c: Add comment and remove\n\tscan-assembler-not directives that forbid lvx and xxpermdi.\n\t* gcc.target/powerpc/vec-extract-3.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-5.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-6.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-7.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-8.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-9.c: Likewise.\n\t* gcc.target/powerpc/vsx-vector-6-le.c: Change\n\tscan-assembler-times directives to reflect different numbers of\n\texpected xxlnor, xxlor, xvcmpgtdp, and xxland instructions.\n\nlibcpp/ChangeLog:\n\n2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* lex.c (search_line_fast): Remove illegal coercion of an\n\tunaligned pointer value to vector pointer type and replace with\n\tuse of __builtin_vec_vsx_ld () built-in function, which operates\n\ton unaligned pointer values.\n\nFrom-SVN: r256656", "tree": {"sha": "0814f0d7d5cbfd6b7af7fdf2aaa8949fb1b9fad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0814f0d7d5cbfd6b7af7fdf2aaa8949fb1b9fad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a821c903c9fa2288712d31da2038d0297babcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a821c903c9fa2288712d31da2038d0297babcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a821c903c9fa2288712d31da2038d0297babcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a821c903c9fa2288712d31da2038d0297babcb/comments", "author": null, "committer": null, "parents": [{"sha": "ffad1c54d2e4b698bab8d198a65c6183e74449a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffad1c54d2e4b698bab8d198a65c6183e74449a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffad1c54d2e4b698bab8d198a65c6183e74449a8"}], "stats": {"total": 3504, "additions": 3358, "deletions": 146}, "files": [{"sha": "dd1910df7f80c5be39e88e7b1bf82ca669a7a546", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -1,3 +1,37 @@\n+2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* config/rs6000/rs6000-p8swap.c (rs6000_sum_of_two_registers_p):\n+\tNew function.\n+\t(rs6000_quadword_masked_address_p): Likewise.\n+\t(quad_aligned_load_p): Likewise.\n+\t(quad_aligned_store_p): Likewise.\n+\t(const_load_sequence_p): Add comment to describe the outer-most loop.\n+\t(mimic_memory_attributes_and_flags): New function.\n+\t(rs6000_gen_stvx): Likewise.\n+\t(replace_swapped_aligned_store): Likewise.\n+\t(rs6000_gen_lvx): Likewise.\n+\t(replace_swapped_aligned_load): Likewise.\n+\t(replace_swapped_load_constant): Capitalize argument name in\n+\tcomment describing this function.\n+\t(rs6000_analyze_swaps): Add a third pass to search for vector loads\n+\tand stores that access quad-word aligned addresses and replace\n+\twith stvx or lvx instructions when appropriate.\n+\t* config/rs6000/rs6000-protos.h (rs6000_sum_of_two_registers_p):\n+\tNew function prototype.\n+\t(rs6000_quadword_masked_address_p): Likewise.\n+\t(rs6000_gen_lvx): Likewise.\n+\t(rs6000_gen_stvx): Likewise.\n+\t* config/rs6000/vsx.md (*vsx_le_perm_load_<mode>): For modes\n+\tVSX_D (V2DF, V2DI), modify this split to select lvx instruction\n+\twhen memory address is aligned.\n+\t(*vsx_le_perm_load_<mode>): For modes VSX_W (V4SF, V4SI), modify\n+\tthis split to select lvx instruction when memory address is aligned.\n+\t(*vsx_le_perm_load_v8hi): Modify this split to select lvx\n+\tinstruction when memory address is aligned.\n+\t(*vsx_le_perm_load_v16qi): Likewise.\n+\t(four unnamed splitters): Modify to select the stvx instruction\n+\twhen memory is aligned.\n+\n 2018-01-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* predict.c (determine_unlikely_bbs): Handle correctly BBs"}, {"sha": "876f339a79ed7f01ca4cd5610c31a7d229c18dcf", "filename": "gcc/config/rs6000/rs6000-p8swap.c", "status": "modified", "additions": 529, "deletions": 6, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -328,6 +328,142 @@ insn_is_swap_p (rtx insn)\n   return 1;\n }\n \n+/* Return true iff EXPR represents the sum of two registers.  */\n+bool\n+rs6000_sum_of_two_registers_p (const_rtx expr)\n+{\n+  if (GET_CODE (expr) == PLUS)\n+    {\n+      const_rtx operand1 = XEXP (expr, 0);\n+      const_rtx operand2 = XEXP (expr, 1);\n+      return (REG_P (operand1) && REG_P (operand2));\n+    }\n+  return false;\n+}\n+\n+/* Return true iff EXPR represents an address expression that masks off\n+   the low-order 4 bits in the style of an lvx or stvx rtl pattern.  */\n+bool\n+rs6000_quadword_masked_address_p (const_rtx expr)\n+{\n+  if (GET_CODE (expr) == AND)\n+    {\n+      const_rtx operand1 = XEXP (expr, 0);\n+      const_rtx operand2 = XEXP (expr, 1);\n+      if ((REG_P (operand1) || rs6000_sum_of_two_registers_p (operand1))\n+\t  && CONST_SCALAR_INT_P (operand2) && INTVAL (operand2) == -16)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return TRUE if INSN represents a swap of a swapped load from memory\n+   and the memory address is quad-word aligned.  */\n+static bool\n+quad_aligned_load_p (swap_web_entry *insn_entry, rtx_insn *insn)\n+{\n+  unsigned uid = INSN_UID (insn);\n+  if (!insn_entry[uid].is_swap || insn_entry[uid].is_load)\n+    return false;\n+\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\n+  /* Since insn is known to represent a swap instruction, we know it\n+     \"uses\" only one input variable.  */\n+  df_ref use = DF_INSN_INFO_USES (insn_info);\n+\n+  /* Figure out where this input variable is defined.  */\n+  struct df_link *def_link = DF_REF_CHAIN (use);\n+\n+  /* If there is no definition or the definition is artificial or there are\n+     multiple definitions, punt.  */\n+  if (!def_link || !def_link->ref || DF_REF_IS_ARTIFICIAL (def_link->ref)\n+      || def_link->next)\n+    return false;\n+\n+  rtx def_insn = DF_REF_INSN (def_link->ref);\n+  unsigned uid2 = INSN_UID (def_insn);\n+  /* We're looking for a load-with-swap insn.  If this is not that,\n+     return false.  */\n+  if (!insn_entry[uid2].is_load || !insn_entry[uid2].is_swap)\n+    return false;\n+\n+  /* If the source of the rtl def is not a set from memory, return\n+     false.  */\n+  rtx body = PATTERN (def_insn);\n+  if (GET_CODE (body) != SET\n+      || GET_CODE (SET_SRC (body)) != VEC_SELECT\n+      || GET_CODE (XEXP (SET_SRC (body), 0)) != MEM)\n+    return false;\n+\n+  rtx mem = XEXP (SET_SRC (body), 0);\n+  rtx base_reg = XEXP (mem, 0);\n+  return ((REG_P (base_reg) || rs6000_sum_of_two_registers_p (base_reg))\n+\t  && MEM_ALIGN (mem) >= 128) ? true : false;\n+}\n+\n+/* Return TRUE if INSN represents a store-with-swap of a swapped value\n+   and the memory address is quad-word aligned.  */\n+static bool\n+quad_aligned_store_p (swap_web_entry *insn_entry, rtx_insn *insn)\n+{\n+  unsigned uid = INSN_UID (insn);\n+  if (!insn_entry[uid].is_swap || !insn_entry[uid].is_store)\n+    return false;\n+\n+  rtx body = PATTERN (insn);\n+  rtx dest_address = XEXP (SET_DEST (body), 0);\n+  rtx swap_reg = XEXP (SET_SRC (body), 0);\n+\n+  /* If the base address for the memory expression is not represented\n+     by a single register and is not the sum of two registers, punt.  */\n+  if (!REG_P (dest_address) && !rs6000_sum_of_two_registers_p (dest_address))\n+    return false;\n+\n+  /* Confirm that the value to be stored is produced by a swap\n+     instruction.  */\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  df_ref use;\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    {\n+      struct df_link *def_link = DF_REF_CHAIN (use);\n+\n+      /* If this is not the definition of the candidate swap register,\n+\t then skip it.  I am interested in a different definition.  */\n+      if (!rtx_equal_p (DF_REF_REG (use), swap_reg))\n+\tcontinue;\n+\n+      /* If there is no def or the def is artifical or there are\n+\t multiple defs, punt.  */\n+      if (!def_link || !def_link->ref || DF_REF_IS_ARTIFICIAL (def_link->ref)\n+\t  || def_link->next)\n+\treturn false;\n+\n+      rtx def_insn = DF_REF_INSN (def_link->ref);\n+      unsigned uid2 = INSN_UID (def_insn);\n+\n+      /* If this source value is not a simple swap, return false */\n+      if (!insn_entry[uid2].is_swap || insn_entry[uid2].is_load\n+\t  || insn_entry[uid2].is_store)\n+\treturn false;\n+\n+      /* I've processed the use that I care about, so break out of\n+\t this loop.  */\n+      break;\n+    }\n+\n+  /* At this point, we know the source data comes from a swap.  The\n+     remaining question is whether the memory address is aligned.  */\n+  rtx set = single_set (insn);\n+  if (set)\n+    {\n+      rtx dest = SET_DEST (set);\n+      if (MEM_P (dest))\n+\treturn (MEM_ALIGN (dest) >= 128);\n+    }\n+  return false;\n+}\n+\n /* Return 1 iff UID, known to reference a swap, is both fed by a load\n    and a feeder of a store.  */\n static unsigned int\n@@ -372,6 +508,9 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n \n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n   df_ref use;\n+\n+  /* Iterate over the definitions that are used by this insn.  Since\n+     this is known to be a swap insn, expect only one used definnition.  */\n   FOR_EACH_INSN_INFO_USE (use, insn_info)\n     {\n       struct df_link *def_link = DF_REF_CHAIN (use);\n@@ -1353,7 +1492,326 @@ replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)\n   insn->set_deleted ();\n }\n \n-/* Given that swap_insn represents a swap of a load of a constant\n+/* Make NEW_MEM_EXP's attributes and flags resemble those of\n+   ORIGINAL_MEM_EXP.  */\n+static void\n+mimic_memory_attributes_and_flags (rtx new_mem_exp, const_rtx original_mem_exp)\n+{\n+  RTX_FLAG (new_mem_exp, jump) = RTX_FLAG (original_mem_exp, jump);\n+  RTX_FLAG (new_mem_exp, call) = RTX_FLAG (original_mem_exp, call);\n+  RTX_FLAG (new_mem_exp, unchanging) = RTX_FLAG (original_mem_exp, unchanging);\n+  RTX_FLAG (new_mem_exp, volatil) = RTX_FLAG (original_mem_exp, volatil);\n+  RTX_FLAG (new_mem_exp, frame_related) =\n+    RTX_FLAG (original_mem_exp, frame_related);\n+\n+  /* The following fields may not be used with MEM subexpressions */\n+  RTX_FLAG (new_mem_exp, in_struct) = RTX_FLAG (original_mem_exp, in_struct);\n+  RTX_FLAG (new_mem_exp, return_val) = RTX_FLAG (original_mem_exp, return_val);\n+\n+  struct mem_attrs original_attrs = *get_mem_attrs(original_mem_exp);\n+\n+  alias_set_type set = original_attrs.alias;\n+  set_mem_alias_set (new_mem_exp, set);\n+\n+  addr_space_t addrspace = original_attrs.addrspace;\n+  set_mem_addr_space (new_mem_exp, addrspace);\n+\n+  unsigned int align = original_attrs.align;\n+  set_mem_align (new_mem_exp, align);\n+\n+  tree expr = original_attrs.expr;\n+  set_mem_expr (new_mem_exp, expr);\n+\n+  if (original_attrs.offset_known_p)\n+    {\n+      HOST_WIDE_INT offset = original_attrs.offset;\n+      set_mem_offset (new_mem_exp, offset);\n+    }\n+  else\n+    clear_mem_offset (new_mem_exp);\n+\n+  if (original_attrs.size_known_p)\n+    {\n+      HOST_WIDE_INT size = original_attrs.size;\n+      set_mem_size (new_mem_exp, size);\n+    }\n+  else\n+    clear_mem_size (new_mem_exp);\n+}\n+\n+/* Generate an rtx expression to represent use of the stvx insn to store\n+   the value represented by register SRC_EXP into the memory at address\n+   DEST_EXP, with vector mode MODE.  */\n+rtx\n+rs6000_gen_stvx (enum machine_mode mode, rtx dest_exp, rtx src_exp)\n+{\n+  rtx memory_address = XEXP (dest_exp, 0);\n+  rtx stvx;\n+\n+  if (rs6000_sum_of_two_registers_p (memory_address))\n+    {\n+      rtx op1, op2;\n+      op1 = XEXP (memory_address, 0);\n+      op2 = XEXP (memory_address, 1);\n+      if (mode == V16QImode)\n+\tstvx = gen_altivec_stvx_v16qi_2op (src_exp, op1, op2);\n+      else if (mode == V8HImode)\n+\tstvx = gen_altivec_stvx_v8hi_2op (src_exp, op1, op2);\n+#ifdef HAVE_V8HFmode\n+      else if (mode == V8HFmode)\n+\tstvx = gen_altivec_stvx_v8hf_2op (src_exp, op1, op2);\n+#endif\n+      else if (mode == V4SImode)\n+\tstvx = gen_altivec_stvx_v4si_2op (src_exp, op1, op2);\n+      else if (mode == V4SFmode)\n+\tstvx = gen_altivec_stvx_v4sf_2op (src_exp, op1, op2);\n+      else if (mode == V2DImode)\n+\tstvx = gen_altivec_stvx_v2di_2op (src_exp, op1, op2);\n+      else if (mode == V2DFmode)\n+\tstvx = gen_altivec_stvx_v2df_2op (src_exp, op1, op2);\n+      else if (mode == V1TImode)\n+\tstvx = gen_altivec_stvx_v1ti_2op (src_exp, op1, op2);\n+      else\n+\t/* KFmode, TFmode, other modes not expected in this context.  */\n+\tgcc_unreachable ();\n+    }\n+  else\t\t\t\t/* REG_P (memory_address) */\n+    {\n+      if (mode == V16QImode)\n+\tstvx = gen_altivec_stvx_v16qi_1op (src_exp, memory_address);\n+      else if (mode == V8HImode)\n+\tstvx = gen_altivec_stvx_v8hi_1op (src_exp, memory_address);\n+#ifdef HAVE_V8HFmode\n+      else if (mode == V8HFmode)\n+\tstvx = gen_altivec_stvx_v8hf_1op (src_exp, memory_address);\n+#endif\n+      else if (mode == V4SImode)\n+\tstvx = gen_altivec_stvx_v4si_1op (src_exp, memory_address);\n+      else if (mode == V4SFmode)\n+\tstvx = gen_altivec_stvx_v4sf_1op (src_exp, memory_address);\n+      else if (mode == V2DImode)\n+\tstvx = gen_altivec_stvx_v2di_1op (src_exp, memory_address);\n+      else if (mode == V2DFmode)\n+\tstvx = gen_altivec_stvx_v2df_1op (src_exp, memory_address);\n+      else if (mode == V1TImode)\n+\tstvx = gen_altivec_stvx_v1ti_1op (src_exp, memory_address);\n+      else\n+\t/* KFmode, TFmode, other modes not expected in this context.  */\n+\tgcc_unreachable ();\n+    }\n+\n+  rtx new_mem_exp = SET_DEST (stvx);\n+  mimic_memory_attributes_and_flags (new_mem_exp, dest_exp);\n+  return stvx;\n+}\n+\n+/* Given that STORE_INSN represents an aligned store-with-swap of a\n+   swapped value, replace the store with an aligned store (without\n+   swap) and replace the swap with a copy insn.  */\n+static void\n+replace_swapped_aligned_store (swap_web_entry *insn_entry,\n+\t\t\t       rtx_insn *store_insn)\n+{\n+  unsigned uid = INSN_UID (store_insn);\n+  gcc_assert (insn_entry[uid].is_swap && insn_entry[uid].is_store);\n+\n+  rtx body = PATTERN (store_insn);\n+  rtx dest_address = XEXP (SET_DEST (body), 0);\n+  rtx swap_reg = XEXP (SET_SRC (body), 0);\n+  gcc_assert (REG_P (dest_address)\n+\t      || rs6000_sum_of_two_registers_p (dest_address));\n+\n+  /* Find the swap instruction that provides the value to be stored by\n+   * this store-with-swap instruction. */\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (store_insn);\n+  df_ref use;\n+  rtx_insn *swap_insn = NULL;\n+  unsigned uid2 = 0;\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    {\n+      struct df_link *def_link = DF_REF_CHAIN (use);\n+\n+      /* if this is not the definition of the candidate swap register,\n+\t then skip it.  I am only interested in the swap insnd.  */\n+      if (!rtx_equal_p (DF_REF_REG (use), swap_reg))\n+\tcontinue;\n+\n+      /* If there is no def or the def is artifical or there are\n+\t multiple defs, we should not be here.  */\n+      gcc_assert (def_link && def_link->ref && !def_link->next\n+\t\t  && !DF_REF_IS_ARTIFICIAL (def_link->ref));\n+\n+      swap_insn = DF_REF_INSN (def_link->ref);\n+      uid2 = INSN_UID (swap_insn);\n+\n+      /* If this source value is not a simple swap, we should not be here.  */\n+      gcc_assert (insn_entry[uid2].is_swap && !insn_entry[uid2].is_load\n+\t\t  && !insn_entry[uid2].is_store);\n+\n+      /* We've processed the use we care about, so break out of\n+\t this loop.  */\n+      break;\n+    }\n+\n+  /* At this point, swap_insn and uid2 represent the swap instruction\n+     that feeds the store.  */\n+  gcc_assert (swap_insn);\n+  rtx set = single_set (store_insn);\n+  gcc_assert (set);\n+  rtx dest_exp = SET_DEST (set);\n+  rtx src_exp = XEXP (SET_SRC (body), 0);\n+  enum machine_mode mode = GET_MODE (dest_exp);\n+  gcc_assert (MEM_P (dest_exp));\n+  gcc_assert (MEM_ALIGN (dest_exp) >= 128);\n+\n+  /* Replace the copy with a new insn.  */\n+  rtx stvx;\n+  stvx = rs6000_gen_stvx (mode, dest_exp, src_exp);\n+\n+  rtx_insn *new_insn = emit_insn_before (stvx, store_insn);\n+  rtx new_body = PATTERN (new_insn);\n+\n+  gcc_assert ((GET_CODE (new_body) == SET)\n+\t      && (GET_CODE (SET_DEST (new_body)) == MEM));\n+\n+  set_block_for_insn (new_insn, BLOCK_FOR_INSN (store_insn));\n+  df_insn_rescan (new_insn);\n+\n+  df_insn_delete (store_insn);\n+  remove_insn (store_insn);\n+  store_insn->set_deleted ();\n+\n+  /* Replace the swap with a copy.  */\n+  uid2 = INSN_UID (swap_insn);\n+  mark_swaps_for_removal (insn_entry, uid2);\n+  replace_swap_with_copy (insn_entry, uid2);\n+}\n+\n+/* Generate an rtx expression to represent use of the lvx insn to load\n+   from memory SRC_EXP into register DEST_EXP with vector mode MODE. */\n+rtx\n+rs6000_gen_lvx (enum machine_mode mode, rtx dest_exp, rtx src_exp)\n+{\n+  rtx memory_address = XEXP (src_exp, 0);\n+  rtx lvx;\n+\n+  if (rs6000_sum_of_two_registers_p (memory_address))\n+    {\n+      rtx op1, op2;\n+      op1 = XEXP (memory_address, 0);\n+      op2 = XEXP (memory_address, 1);\n+\n+      if (mode == V16QImode)\n+\tlvx = gen_altivec_lvx_v16qi_2op (dest_exp, op1, op2);\n+      else if (mode == V8HImode)\n+\tlvx = gen_altivec_lvx_v8hi_2op (dest_exp, op1, op2);\n+#ifdef HAVE_V8HFmode\n+      else if (mode == V8HFmode)\n+\tlvx = gen_altivec_lvx_v8hf_2op (dest_exp, op1, op2);\n+#endif\n+      else if (mode == V4SImode)\n+\tlvx = gen_altivec_lvx_v4si_2op (dest_exp, op1, op2);\n+      else if (mode == V4SFmode)\n+\tlvx = gen_altivec_lvx_v4sf_2op (dest_exp, op1, op2);\n+      else if (mode == V2DImode)\n+\tlvx = gen_altivec_lvx_v2di_2op (dest_exp, op1, op2);\n+      else if (mode == V2DFmode)\n+\tlvx = gen_altivec_lvx_v2df_2op (dest_exp, op1, op2);\n+      else if (mode == V1TImode)\n+\tlvx = gen_altivec_lvx_v1ti_2op (dest_exp, op1, op2);\n+      else\n+\t/* KFmode, TFmode, other modes not expected in this context.  */\n+\tgcc_unreachable ();\n+    }\n+  else\t\t\t\t/* REG_P (memory_address) */\n+    {\n+      if (mode == V16QImode)\n+\tlvx = gen_altivec_lvx_v16qi_1op (dest_exp, memory_address);\n+      else if (mode == V8HImode)\n+\tlvx = gen_altivec_lvx_v8hi_1op (dest_exp, memory_address);\n+#ifdef HAVE_V8HFmode\n+      else if (mode == V8HFmode)\n+\tlvx = gen_altivec_lvx_v8hf_1op (dest_exp, memory_address);\n+#endif\n+      else if (mode == V4SImode)\n+\tlvx = gen_altivec_lvx_v4si_1op (dest_exp, memory_address);\n+      else if (mode == V4SFmode)\n+\tlvx = gen_altivec_lvx_v4sf_1op (dest_exp, memory_address);\n+      else if (mode == V2DImode)\n+\tlvx = gen_altivec_lvx_v2di_1op (dest_exp, memory_address);\n+      else if (mode == V2DFmode)\n+\tlvx = gen_altivec_lvx_v2df_1op (dest_exp, memory_address);\n+      else if (mode == V1TImode)\n+\tlvx = gen_altivec_lvx_v1ti_1op (dest_exp, memory_address);\n+      else\n+\t/* KFmode, TFmode, other modes not expected in this context.  */\n+\tgcc_unreachable ();\n+    }\n+\n+  rtx new_mem_exp = SET_SRC (lvx);\n+  mimic_memory_attributes_and_flags (new_mem_exp, src_exp);\n+\n+  return lvx;\n+}\n+\n+/* Given that SWAP_INSN represents a swap of an aligned\n+   load-with-swap, replace the load with an aligned load (without\n+   swap) and replace the swap with a copy insn.  */\n+static void\n+replace_swapped_aligned_load (swap_web_entry *insn_entry, rtx swap_insn)\n+{\n+  /* Find the load.  */\n+  unsigned uid = INSN_UID (swap_insn);\n+  /* Only call this if quad_aligned_load_p (swap_insn).  */\n+  gcc_assert (insn_entry[uid].is_swap && !insn_entry[uid].is_load);\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (swap_insn);\n+\n+  /* Since insn is known to represent a swap instruction, we know it\n+     \"uses\" only one input variable.  */\n+  df_ref use = DF_INSN_INFO_USES (insn_info);\n+\n+  /* Figure out where this input variable is defined.  */\n+  struct df_link *def_link = DF_REF_CHAIN (use);\n+  gcc_assert (def_link && !def_link->next);\n+  gcc_assert (def_link && def_link->ref &&\n+\t      !DF_REF_IS_ARTIFICIAL (def_link->ref) && !def_link->next);\n+\n+  rtx_insn *def_insn = DF_REF_INSN (def_link->ref);\n+  unsigned uid2 = INSN_UID (def_insn);\n+\n+  /* We're expecting a load-with-swap insn.  */\n+  gcc_assert (insn_entry[uid2].is_load && insn_entry[uid2].is_swap);\n+\n+  /* We expect this to be a set to memory, with source representing a\n+     swap (indicated by code VEC_SELECT).  */\n+  rtx body = PATTERN (def_insn);\n+  gcc_assert ((GET_CODE (body) == SET)\n+\t      && (GET_CODE (SET_SRC (body)) == VEC_SELECT)\n+\t      && (GET_CODE (XEXP (SET_SRC (body), 0)) == MEM));\n+\n+  rtx src_exp = XEXP (SET_SRC (body), 0);\n+  enum machine_mode mode = GET_MODE (src_exp);\n+  rtx lvx = rs6000_gen_lvx (mode, SET_DEST (body), src_exp);\n+\n+  rtx_insn *new_insn = emit_insn_before (lvx, def_insn);\n+  rtx new_body = PATTERN (new_insn);\n+\n+  gcc_assert ((GET_CODE (new_body) == SET)\n+\t      && (GET_CODE (SET_SRC (new_body)) == MEM));\n+\n+  set_block_for_insn (new_insn, BLOCK_FOR_INSN (def_insn));\n+  df_insn_rescan (new_insn);\n+\n+  df_insn_delete (def_insn);\n+  remove_insn (def_insn);\n+  def_insn->set_deleted ();\n+\n+  /* Replace the swap with a copy.  */\n+  mark_swaps_for_removal (insn_entry, uid);\n+  replace_swap_with_copy (insn_entry, uid);\n+}\n+\n+/* Given that SWAP_INSN represents a swap of a load of a constant\n    vector value, replace with a single instruction that loads a\n    swapped variant of the original constant.\n \n@@ -2144,8 +2602,17 @@ rs6000_analyze_swaps (function *fun)\n   /* Clean up.  */\n   free (insn_entry);\n \n-  /* Use additional pass over rtl to replace swap(load(vector constant))\n-     with load(swapped vector constant). */\n+  /* Use a second pass over rtl to detect that certain vector values\n+     fetched from or stored to memory on quad-word aligned addresses\n+     can use lvx/stvx without swaps.  */\n+\n+  /* First, rebuild ud chains.  */\n+  df_remove_problem (df_chain);\n+  df_process_deferred_rescans ();\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n+  df_chain_add_problem (DF_UD_CHAIN);\n+  df_analyze ();\n+\n   swap_web_entry *pass2_insn_entry;\n   pass2_insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());\n \n@@ -2174,13 +2641,69 @@ rs6000_analyze_swaps (function *fun)\n     if (pass2_insn_entry[i].is_swap && !pass2_insn_entry[i].is_load\n \t&& !pass2_insn_entry[i].is_store)\n       {\n-\tinsn = pass2_insn_entry[i].insn;\n-\tif (const_load_sequence_p (pass2_insn_entry, insn))\n-\t  replace_swapped_load_constant (pass2_insn_entry, insn);\n+\t/* Replace swap of aligned load-swap with aligned unswapped\n+\t   load.  */\n+\trtx_insn *rtx_insn = pass2_insn_entry[i].insn;\n+\tif (quad_aligned_load_p (pass2_insn_entry, rtx_insn))\n+\t  replace_swapped_aligned_load (pass2_insn_entry, rtx_insn);\n+      }\n+    else if (pass2_insn_entry[i].is_swap && pass2_insn_entry[i].is_store)\n+      {\n+\t/* Replace aligned store-swap of swapped value with aligned\n+\t   unswapped store.  */\n+\trtx_insn *rtx_insn = pass2_insn_entry[i].insn;\n+\tif (quad_aligned_store_p (pass2_insn_entry, rtx_insn))\n+\t  replace_swapped_aligned_store (pass2_insn_entry, rtx_insn);\n       }\n \n   /* Clean up.  */\n   free (pass2_insn_entry);\n+\n+  /* Use a third pass over rtl to replace swap(load(vector constant))\n+     with load(swapped vector constant).  */\n+\n+  /* First, rebuild ud chains.  */\n+  df_remove_problem (df_chain);\n+  df_process_deferred_rescans ();\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n+  df_chain_add_problem (DF_UD_CHAIN);\n+  df_analyze ();\n+\n+  swap_web_entry *pass3_insn_entry;\n+  pass3_insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());\n+\n+  /* Walk the insns to gather basic data.  */\n+  FOR_ALL_BB_FN (bb, fun)\n+    FOR_BB_INSNS_SAFE (bb, insn, curr_insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  pass3_insn_entry[uid].insn = insn;\n+\n+\t  pass3_insn_entry[uid].is_relevant = 1;\n+\t  pass3_insn_entry[uid].is_load = insn_is_load_p (insn);\n+\t  pass3_insn_entry[uid].is_store = insn_is_store_p (insn);\n+\n+\t  /* Determine if this is a doubleword swap.  If not,\n+\t     determine whether it can legally be swapped.  */\n+\t  if (insn_is_swap_p (insn))\n+\t    pass3_insn_entry[uid].is_swap = 1;\n+\t}\n+    }\n+\n+  e = get_max_uid ();\n+  for (unsigned i = 0; i < e; ++i)\n+    if (pass3_insn_entry[i].is_swap && !pass3_insn_entry[i].is_load\n+\t&& !pass3_insn_entry[i].is_store)\n+      {\n+\tinsn = pass3_insn_entry[i].insn;\n+\tif (const_load_sequence_p (pass3_insn_entry, insn))\n+\t  replace_swapped_load_constant (pass3_insn_entry, insn);\n+      }\n+\n+  /* Clean up.  */\n+  free (pass3_insn_entry);\n   return 0;\n }\n "}, {"sha": "9c6c9a61c1544847b320f67ba3138a9ceb22d800", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -254,5 +254,9 @@ namespace gcc { class context; }\n class rtl_opt_pass;\n \n extern rtl_opt_pass *make_pass_analyze_swaps (gcc::context *);\n+extern bool rs6000_sum_of_two_registers_p (const_rtx expr);\n+extern bool rs6000_quadword_masked_address_p (const_rtx exp);\n+extern rtx rs6000_gen_lvx (enum machine_mode, rtx, rtx);\n+extern rtx rs6000_gen_stvx (enum machine_mode, rtx, rtx);\n \n #endif  /* rs6000-protos.h */"}, {"sha": "6762a00beaadc95df36b6db7ae46b640b3df4c62", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 212, "deletions": 4, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -434,7 +434,7 @@\n         (match_operand:VSX_D 1 \"indexed_or_indirect_operand\" \"Z\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n   \"#\"\n-  \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n+  \"&& 1\"\n   [(set (match_dup 2)\n         (vec_select:<MODE>\n           (match_dup 1)\n@@ -445,6 +445,33 @@\n           (parallel [(const_int 1) (const_int 0)])))]\n   \"\n {\n+  rtx mem = operands[1];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register destination is not in the altivec\n+     range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((reg_or_subregno (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+\t  || ALTIVEC_REGNO_P (reg_or_subregno (operands[0]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+        {\n+\t  /* Replace the source memory address with masked address.  */\n+          rtx lvx_set_expr = rs6000_gen_lvx (mode, operands[0], mem);\n+\t  emit_insn (lvx_set_expr);\n+\t  DONE;\n+        }\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+        {\n+\t  /* This rtl is already in the form that matches lvx\n+\t     instruction, so leave it alone.  */\n+\t  DONE;\n+        }\n+      /* Otherwise, fall through to transform into a swapping load.  */\n+    }\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n@@ -457,7 +484,7 @@\n         (match_operand:VSX_W 1 \"indexed_or_indirect_operand\" \"Z\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n   \"#\"\n-  \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n+  \"&& 1\"\n   [(set (match_dup 2)\n         (vec_select:<MODE>\n           (match_dup 1)\n@@ -470,6 +497,33 @@\n                      (const_int 0) (const_int 1)])))]\n   \"\n {\n+  rtx mem = operands[1];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register destination is not in the altivec\n+     range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((REGNO(operands[0]) >= FIRST_PSEUDO_REGISTER)\n+\t  || ALTIVEC_REGNO_P (REGNO(operands[0]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+        {\n+\t  /* Replace the source memory address with masked address.  */\n+          rtx lvx_set_expr = rs6000_gen_lvx (mode, operands[0], mem);\n+\t  emit_insn (lvx_set_expr);\n+\t  DONE;\n+        }\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+        {\n+\t  /* This rtl is already in the form that matches lvx\n+\t     instruction, so leave it alone.  */\n+\t  DONE;\n+        }\n+      /* Otherwise, fall through to transform into a swapping load.  */\n+    }\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n@@ -482,7 +536,7 @@\n         (match_operand:V8HI 1 \"indexed_or_indirect_operand\" \"Z\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n   \"#\"\n-  \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n+  \"&& 1\"\n   [(set (match_dup 2)\n         (vec_select:V8HI\n           (match_dup 1)\n@@ -499,6 +553,33 @@\n                      (const_int 2) (const_int 3)])))]\n   \"\n {\n+  rtx mem = operands[1];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register destination is not in the altivec\n+     range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((REGNO(operands[0]) >= FIRST_PSEUDO_REGISTER)\n+\t  || ALTIVEC_REGNO_P (REGNO(operands[0]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+        {\n+\t  /* Replace the source memory address with masked address.  */\n+\t  rtx lvx_set_expr = rs6000_gen_lvx (mode, operands[0], mem);\n+\t  emit_insn (lvx_set_expr);\n+\t  DONE;\n+        }\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+        {\n+\t  /* This rtl is already in the form that matches lvx\n+\t     instruction, so leave it alone.  */\n+\t  DONE;\n+        }\n+      /* Otherwise, fall through to transform into a swapping load.  */\n+    }\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n@@ -511,7 +592,7 @@\n         (match_operand:V16QI 1 \"indexed_or_indirect_operand\" \"Z\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n   \"#\"\n-  \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n+  \"&& 1\"\n   [(set (match_dup 2)\n         (vec_select:V16QI\n           (match_dup 1)\n@@ -536,6 +617,33 @@\n                      (const_int 6) (const_int 7)])))]\n   \"\n {\n+  rtx mem = operands[1];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register destination is not in the altivec\n+     range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((REGNO(operands[0]) >= FIRST_PSEUDO_REGISTER)\n+\t  || ALTIVEC_REGNO_P (REGNO(operands[0]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+        {\n+\t  /* Replace the source memory address with masked address.  */\n+\t  rtx lvx_set_expr = rs6000_gen_lvx (mode, operands[0], mem);\n+\t  emit_insn (lvx_set_expr);\n+\t  DONE;\n+        }\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+        {\n+\t  /* This rtl is already in the form that matches lvx\n+\t     instruction, so leave it alone.  */\n+\t  DONE;\n+        }\n+      /* Otherwise, fall through to transform into a swapping load.  */\n+    }\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n@@ -564,6 +672,31 @@\n           (match_dup 2)\n           (parallel [(const_int 1) (const_int 0)])))]\n {\n+  rtx mem = operands[0];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register source is not in the altivec range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+\t{\n+\t  rtx stvx_set_expr = rs6000_gen_stvx (mode, mem, operands[1]);\n+\t  emit_insn (stvx_set_expr);\n+\t  DONE;\n+\t}\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+\t{\n+\t  /* This rtl is already in the form that matches stvx instruction,\n+\t     so leave it alone.  */\n+\t  DONE;\n+\t}\n+      /* Otherwise, fall through to transform into a swapping store.  */\n+    }\n+\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n                                        : operands[1];\n })\n@@ -611,6 +744,31 @@\n           (parallel [(const_int 2) (const_int 3)\n \t             (const_int 0) (const_int 1)])))]\n {\n+  rtx mem = operands[0];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register source is not in the altivec range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+\t{\n+\t  rtx stvx_set_expr = rs6000_gen_stvx (mode, mem, operands[1]);\n+\t  emit_insn (stvx_set_expr);\n+\t  DONE;\n+\t}\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+\t{\n+\t  /* This rtl is already in the form that matches stvx instruction,\n+\t     so leave it alone.  */\n+\t  DONE;\n+\t}\n+      /* Otherwise, fall through to transform into a swapping store.  */\n+    }\n+\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n                                        : operands[1];\n })\n@@ -665,6 +823,31 @@\n                      (const_int 0) (const_int 1)\n                      (const_int 2) (const_int 3)])))]\n {\n+  rtx mem = operands[0];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register source is not in the altivec range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+\t{\n+\t  rtx stvx_set_expr = rs6000_gen_stvx (mode, mem, operands[1]);\n+\t  emit_insn (stvx_set_expr);\n+\t  DONE;\n+\t}\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+\t{\n+\t  /* This rtl is already in the form that matches stvx instruction,\n+\t     so leave it alone.  */\n+\t  DONE;\n+\t}\n+      /* Otherwise, fall through to transform into a swapping store.  */\n+    }\n+\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n                                        : operands[1];\n })\n@@ -733,6 +916,31 @@\n                      (const_int 4) (const_int 5)\n                      (const_int 6) (const_int 7)])))]\n {\n+  rtx mem = operands[0];\n+\n+  /* Don't apply the swap optimization if we've already performed register\n+     allocation and the hard register source is not in the altivec range.  */\n+  if ((MEM_ALIGN (mem) >= 128)\n+      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+    {\n+      rtx mem_address = XEXP (mem, 0);\n+      enum machine_mode mode = GET_MODE (mem);\n+      if (REG_P (mem_address) || rs6000_sum_of_two_registers_p (mem_address))\n+\t{\n+\t  rtx stvx_set_expr = rs6000_gen_stvx (mode, mem, operands[1]);\n+\t  emit_insn (stvx_set_expr);\n+\t  DONE;\n+\t}\n+      else if (rs6000_quadword_masked_address_p (mem_address))\n+\t{\n+\t  /* This rtl is already in the form that matches stvx instruction,\n+\t     so leave it alone.  */\n+\t  DONE;\n+\t}\n+      /* Otherwise, fall through to transform into a swapping store.  */\n+    }\n+\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n                                        : operands[1];\n })"}, {"sha": "f2976406a5f9dea63747b1640feb5843e9677d6b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -1,3 +1,39 @@\n+2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* gcc.target/powerpc/pr48857.c: Modify dejagnu directives to look\n+\tfor lvx and stvx instead of lxvd2x and stxvd2x and require\n+\tlittle-endian target.  Add comments.\n+\t* gcc.target/powerpc/swaps-p8-28.c: Add functions for more\n+\tcomprehensive testing.\n+\t* gcc.target/powerpc/swaps-p8-29.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-30.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-31.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-32.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-33.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-34.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-35.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-36.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-37.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-38.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-39.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-40.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-41.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-42.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-43.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-44.c: Likewise.\n+\t* gcc.target/powerpc/swaps-p8-45.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-2.c: Add comment and remove\n+\tscan-assembler-not directives that forbid lvx and xxpermdi.\n+\t* gcc.target/powerpc/vec-extract-3.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-5.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-6.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-7.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-8.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-9.c: Likewise.\n+\t* gcc.target/powerpc/vsx-vector-6-le.c: Change\n+\tscan-assembler-times directives to reflect different numbers of\n+\texpected xxlnor, xxlor, xvcmpgtdp, and xxland instructions.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "2a391282ee2cf1136a86e45b6f9b0744ae2d7e70", "filename": "gcc/testsuite/gcc.target/powerpc/pr48857.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48857.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48857.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48857.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -1,10 +1,13 @@\n-/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* Expected instruction selection as characterized by\n+   scan-assembler-times directives below is only relevant to\n+   little-endian targets.  */\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n /* { dg-options \"-O2 -mcpu=power7 -mabi=altivec\" } */\n-/* { dg-final { scan-assembler-times \"lxvd2x\" 1 } } */\n-/* { dg-final { scan-assembler-times \"stxvd2x\" 1 } } */\n+/* { dg-final { scan-assembler-times \"lvx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stvx\" 1 } } */\n /* { dg-final { scan-assembler-not \"ld\" } } */\n /* { dg-final { scan-assembler-not \"lwz\" } } */\n /* { dg-final { scan-assembler-not \"stw\" } } */\n@@ -15,12 +18,19 @@ typedef vector long long v2di_type;\n v2di_type\n return_v2di (v2di_type *ptr)\n {\n-  return *ptr;\t\t/* should generate lxvd2x 34,0,3.  */\n+  /* As of pr48857, should generate lxvd2x 34,0,3\n+     followed by xxpermdi 34,34,34,2.  Subsequent optimization\n+     recognizes that ptr refers to an aligned vector and replaces\n+     this with lvx 2,0,3.  */\n+  return *ptr;\n }\n \n void\n pass_v2di (v2di_type arg, v2di_type *ptr)\n {\n-  *ptr = arg;\t\t/* should generate stxvd2x 34,0,{3,5}.  */\n+  /* As of pr48857, should generate xxpermdi 34,34,34,2 followed by\n+     stxvd2x 34,0,5.  Subsequent optimization recognizes that ptr\n+     refers to an aligned vector and replaces this with stvx 2,0,5.  */\n+  *ptr = arg;\n }\n "}, {"sha": "03309d716fea4ed82087cfb8b1eabca55efba835", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-28.c", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-28.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -12,10 +12,100 @@ vector char y = { 0, 1, 2, 3,\n \t\t  8, 9, 10, 11,\n \t\t  12, 13, 14, 15 };\n \n+vector char x, z;\n+\n vector char\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector char\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector char *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector char\n+foo2 (void)\n+{\n+  vector char v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector char\n+foo3 (vector char *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  char a_field;\n+  vector char a_vector;\n+};\n+\n+vector char\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector char arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector char *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector char arg)\n+{\n+  vector char v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector char *arg1, vector char arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector char v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n@@ -24,6 +114,47 @@ main (int argc, char *argv[])\n   vector char fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[15] != 15)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[14] != 14)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[13] != 13)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[12] != 12)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[4] != 4 || fetched_value[11] != 11)\n+    abort ();\n+\n+  for (int i = 0; i < 16; i++)\n+    z[i] = 15 - i;\n+\n+  baz (z);\n+  if (x[0] != 15 || x[15] != 0)\n+    abort ();\n+\n+  vector char source = { 8, 7, 6, 5, 4, 3, 2, 1,\n+\t\t\t 0, 9, 10, 11, 12, 13, 14, 15 };\n+\n+  baz1 (source);\n+  if (x[3] != 5 || x[8] != 0)\n+    abort ();\n+\n+  vector char dest;\n+  baz2 (&dest, source);\n+  if (dest[4] != 4 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[7] != 1 || a_struct.a_vector[15] != 15)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "943f4e732edcdac60ddb164d96e1e0a78a581725", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-29.c", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-29.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -12,10 +12,100 @@ const vector char y = { 0, 1, 2, 3,\n \t\t\t8, 9, 10, 11,\n \t\t\t12, 13, 14, 15 };\n \n+vector char x, z;\n+\n vector char\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector char\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector char *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector char\n+foo2 (void)\n+{\n+  vector char v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector char\n+foo3 (vector char *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  char a_field;\n+  vector char a_vector;\n+};\n+\n+vector char\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector char arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector char *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector char arg)\n+{\n+  vector char v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector char *arg1, vector char arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector char v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n@@ -24,6 +114,47 @@ main (int argc, char *argv[])\n   vector char fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[15] != 15)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[14] != 14)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[13] != 13)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[12] != 12)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[4] != 4 || fetched_value[11] != 11)\n+    abort ();\n+\n+  for (int i = 0; i < 16; i++)\n+    z[i] = 15 - i;\n+\n+  baz (z);\n+  if (x[0] != 15 || x[15] != 0)\n+    abort ();\n+\n+  vector char source = { 8, 7, 6, 5, 4, 3, 2, 1,\n+\t\t\t 0, 9, 10, 11, 12, 13, 14, 15 };\n+\n+  baz1 (source);\n+  if (x[3] != 5 || x[8] != 0)\n+    abort ();\n+\n+  vector char dest;\n+  baz2 (&dest, source);\n+  if (dest[4] != 4 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[7] != 1 || a_struct.a_vector[15] != 15)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "eddecf570c871af890a2ae05665c7e4a84008bba", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-30.c", "status": "modified", "additions": 140, "deletions": 5, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-30.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -2,8 +2,12 @@\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-mcpu=power8 -O3 \" } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n-/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+/* Previous versions of this test required that the assembler does not\n+   contain xxpermdi or xxswapd.  However, with the more sophisticated\n+   code generation used today, it is now possible that xxpermdi (aka\n+   xxswapd) show up without being part of a lxvd2x or stxvd2x\n+   sequence.  */\n \n #include <altivec.h>\n \n@@ -14,10 +18,100 @@ const vector char y = { 0, 1, 2, 3,\n \t\t\t8, 9, 10, 11,\n \t\t\t12, 13, 14, 15 };\n \n+vector char x, z;\n+\n vector char\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector char\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector char *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector char\n+foo2 (void)\n+{\n+  vector char v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector char\n+foo3 (vector char *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  char a_field;\n+  vector char a_vector;\n+};\n+\n+vector char\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector char arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector char *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector char arg)\n+{\n+  vector char v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector char *arg1, vector char arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector char v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n@@ -26,6 +120,47 @@ main (int argc, char *argv[])\n   vector char fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[15] != 15)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[14] != 14)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[13] != 13)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[12] != 12)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[4] != 4 || fetched_value[11] != 11)\n+    abort ();\n+\n+  for (int i = 0; i < 16; i++)\n+    z[i] = 15 - i;\n+\n+  baz (z);\n+  if (x[0] != 15 || x[15] != 0)\n+    abort ();\n+\n+  vector char source = { 8, 7, 6, 5, 4, 3, 2, 1,\n+\t\t\t 0, 9, 10, 11, 12, 13, 14, 15 };\n+\n+  baz1 (source);\n+  if (x[3] != 5 || x[8] != 0)\n+    abort ();\n+\n+  vector char dest;\n+  baz2 (&dest, source);\n+  if (dest[4] != 4 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[7] != 1 || a_struct.a_vector[15] != 15)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "976a9cffdb212d43d3cf648258b57188fbc572dc", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-31.c", "status": "modified", "additions": 135, "deletions": 6, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-31.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,21 +7,150 @@\n \n extern void abort (void);\n \n-vector short y = { 0, 1, 2, 3,\n-\t\t   4, 5, 6, 7 };\n+vector short x;\n+vector short y = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+vector short z;\n \n vector short\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector short\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector short *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector short\n+foo2 (void)\n+{\n+  vector short v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector short\n+foo3 (vector short *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector short a_vector;\n+};\n+\n+vector short\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector short arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector short *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector short arg)\n+{\n+  vector short v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector short *arg1, vector short arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector short v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (int argc, short *argv[])\n {\n   vector short fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[7] != 7)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[6] != 6)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[5] != 5)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[4] != 4)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[4] != 4 || fetched_value[3] != 3)\n+    abort ();\n+\n+  for (int i = 0; i < 8; i++)\n+    z[i] = 7 - i;\n+\n+  baz (z);\n+  if (x[0] != 7 || x[7] != 0)\n+    abort ();\n+\n+  vector short source = { 8, 7, 6, 5, 4, 3, 2, 1 };\n+\n+  baz1 (source);\n+  if (x[3] != 5 || x[7] != 1)\n+    abort ();\n+\n+  vector short dest;\n+  baz2 (&dest, source);\n+  if (dest[4] != 4 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[7] != 1 || a_struct.a_vector[5] != 3)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "98d5c62dab9610457c19f079eab4ae367b8ab06d", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-32.c", "status": "modified", "additions": 135, "deletions": 6, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-32.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,21 +7,150 @@\n \n extern void abort (void);\n \n-const vector short y = { 0, 1, 2, 3,\n-\t\t\t 4, 5, 6, 7 };\n+vector short x;\n+const vector short y = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+vector short z;\n \n vector short\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector short\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector short *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector short\n+foo2 (void)\n+{\n+  vector short v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector short\n+foo3 (vector short *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector short a_vector;\n+};\n+\n+vector short\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector short arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector short *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector short arg)\n+{\n+  vector short v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector short *arg1, vector short arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector short v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (int argc, short *argv[])\n {\n   vector short fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[7] != 7)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[6] != 6)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[5] != 5)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[4] != 4)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[4] != 4 || fetched_value[3] != 3)\n+    abort ();\n+\n+  for (int i = 0; i < 8; i++)\n+    z[i] = 7 - i;\n+\n+  baz (z);\n+  if (x[0] != 7 || x[7] != 0)\n+    abort ();\n+\n+  vector short source = { 8, 7, 6, 5, 4, 3, 2, 1 };\n+\n+  baz1 (source);\n+  if (x[3] != 5 || x[7] != 1)\n+    abort ();\n+\n+  vector short dest;\n+  baz2 (&dest, source);\n+  if (dest[4] != 4 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[7] != 1 || a_struct.a_vector[5] != 3)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "4e189d8a82b6a9bbc9fba2def401ac986b409591", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-33.c", "status": "modified", "additions": 142, "deletions": 9, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-33.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -2,28 +2,161 @@\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-mcpu=power8 -O3 \" } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n-/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+/* Previous versions of this test required that the assembler does not\n+   contain xxpermdi or xxswapd.  However, with the more sophisticated\n+   code generation used today, it is now possible that xxpermdi (aka\n+   xxswapd) show up without being part of a lxvd2x or stxvd2x\n+   sequence.  */\n \n #include <altivec.h>\n \n extern void abort (void);\n \n-const vector short y = { 0, 1, 2, 3,\n-\t\t\t 4, 5, 6, 7 };\n+vector short x;\n+const vector short y = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+vector short z;\n \n vector short\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector short\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector short *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector short\n+foo2 (void)\n+{\n+  vector short v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector short\n+foo3 (vector short *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector short a_vector;\n+};\n+\n+vector short\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector short arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector short *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector short arg)\n+{\n+  vector short v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector short *arg1, vector short arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector short v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (int argc, short *argv[])\n {\n   vector short fetched_value = foo ();\n-  if (fetched_value[0] != 0 || fetched_value[15] != 15)\n+  if (fetched_value[0] != 0 || fetched_value[7] != 7)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[6] != 6)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[5] != 5)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[4] != 4)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[4] != 4 || fetched_value[3] != 3)\n+    abort ();\n+\n+  for (int i = 0; i < 8; i++)\n+    z[i] = 7 - i;\n+\n+  baz (z);\n+  if (x[0] != 7 || x[7] != 0)\n+    abort ();\n+\n+  vector short source = { 8, 7, 6, 5, 4, 3, 2, 1 };\n+\n+  baz1 (source);\n+  if (x[3] != 5 || x[7] != 1)\n+    abort ();\n+\n+  vector short dest;\n+  baz2 (&dest, source);\n+  if (dest[4] != 4 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[7] != 1 || a_struct.a_vector[5] != 3)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "8ee9795b9a5045052fef9ea741156f17852d509e", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-34.c", "status": "modified", "additions": 136, "deletions": 4, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-34.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,152 @@\n \n extern void abort (void);\n \n+vector int x;\n vector int y = { 0, 1, 2, 3 };\n+vector int z;\n \n vector int\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector int\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector int *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector int\n+foo2 (void)\n+{\n+  vector int v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector int\n+foo3 (vector int *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector int a_vector;\n+};\n+\n+vector int\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector int arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector int *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector int arg)\n+{\n+  vector int v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector int *arg1, vector int arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector int v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (int argc, int *argv[])\n {\n   vector int fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[3] != 3)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[2] != 2)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[1] != 1)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[0] != 0)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[2] != 2 || fetched_value[3] != 3)\n+    abort ();\n+\n+  z[0] = 7;\n+  z[1] = 6;\n+  z[2] = 5;\n+  z[3] = 4;\n+\n+  baz (z);\n+  if (x[0] != 7 || x[3] != 4)\n+    abort ();\n+\n+  vector int source = { 8, 7, 6, 5 };\n+\n+  baz1 (source);\n+  if (x[2] != 6 || x[1] != 7)\n+    abort ();\n+\n+  vector int dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 8 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[3] != 5 || a_struct.a_vector[0] != 8)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "13f2ea745bd4597090fdecfba5c6c2c1fe5899ae", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-35.c", "status": "modified", "additions": 136, "deletions": 4, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-35.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,152 @@\n \n extern void abort (void);\n \n+vector int x;\n const vector int y = { 0, 1, 2, 3 };\n+vector int z;\n \n vector int\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector int\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector int *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector int\n+foo2 (void)\n+{\n+  vector int v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector int\n+foo3 (vector int *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector int a_vector;\n+};\n+\n+vector int\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector int arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector int *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector int arg)\n+{\n+  vector int v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector int *arg1, vector int arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector int v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (int argc, int *argv[])\n {\n   vector int fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[3] != 3)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[2] != 2)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[1] != 1)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[0] != 0)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[2] != 2 || fetched_value[3] != 3)\n+    abort ();\n+\n+  z[0] = 7;\n+  z[1] = 6;\n+  z[2] = 5;\n+  z[3] = 4;\n+\n+  baz (z);\n+  if (x[0] != 7 || x[3] != 4)\n+    abort ();\n+\n+  vector int source = { 8, 7, 6, 5 };\n+\n+  baz1 (source);\n+  if (x[2] != 6 || x[1] != 7)\n+    abort ();\n+\n+  vector int dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 8 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[3] != 5 || a_struct.a_vector[0] != 8)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "f825f8bcfec8b9ba28e1b93010f1c0d1cce0c4df", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-36.c", "status": "modified", "additions": 142, "deletions": 6, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-36.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -2,27 +2,163 @@\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-mcpu=power8 -O3 \" } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n-/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+/* Previous versions of this test required that the assembler does not\n+   contain xxpermdi or xxswapd.  However, with the more sophisticated\n+   code generation used today, it is now possible that xxpermdi (aka\n+   xxswapd) show up without being part of a lxvd2x or stxvd2x\n+   sequence.  */\n \n #include <altivec.h>\n \n extern void abort (void);\n \n+vector int x;\n const vector int y = { 0, 1, 2, 3 };\n+vector int z;\n \n vector int\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector int\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector int *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector int\n+foo2 (void)\n+{\n+  vector int v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector int\n+foo3 (vector int *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector int a_vector;\n+};\n+\n+vector int\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector int arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector int *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector int arg)\n+{\n+  vector int v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector int *arg1, vector int arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector int v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (int argc, int *argv[])\n {\n   vector int fetched_value = foo ();\n   if (fetched_value[0] != 0 || fetched_value[3] != 3)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 1 || fetched_value[2] != 2)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 2 || fetched_value[1] != 1)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 3 || fetched_value[0] != 0)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[2] != 2 || fetched_value[3] != 3)\n+    abort ();\n+\n+  z[0] = 7;\n+  z[1] = 6;\n+  z[2] = 5;\n+  z[3] = 4;\n+\n+  baz (z);\n+  if (x[0] != 7 || x[3] != 4)\n+    abort ();\n+\n+  vector int source = { 8, 7, 6, 5 };\n+\n+  baz1 (source);\n+  if (x[3] != 6 || x[2] != 7)\n+    abort ();\n+\n+  vector int dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 8 || dest[1] != 7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[3] != 5 || a_struct.a_vector[0] != 8)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "775d37fe6f609b6eacbab3d42d54645b3069fa56", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-37.c", "status": "modified", "additions": 138, "deletions": 6, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-37.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,152 @@\n \n extern void abort (void);\n \n-vector float y = { 0.0f, 0.1f, 0.2f, 0.3f };\n+vector float x;\n+vector float y = { 0.0F, 0.1F, 0.2F, 0.3F };\n+vector float z;\n \n vector float\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector float\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector float *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector float\n+foo2 (void)\n+{\n+  vector float v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector float\n+foo3 (vector float *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector float a_vector;\n+};\n+\n+vector float\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector float arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector float *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector float arg)\n+{\n+  vector float v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector float *arg1, vector float arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector float v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (float argc, float *argv[])\n {\n   vector float fetched_value = foo ();\n-  if (fetched_value[0] != 0.0f || fetched_value[3] != 0.3f)\n+  if (fetched_value[0] != 0.0F || fetched_value[3] != 0.3F)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 0.1F || fetched_value[2] != 0.2F)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 0.2F || fetched_value[1] != 0.1F)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 0.3F || fetched_value[0] != 0.0F)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[2] != 0.2F || fetched_value[3] != 0.3F)\n+    abort ();\n+\n+  z[0] = 0.7F;\n+  z[1] = 0.6F;\n+  z[2] = 0.5F;\n+  z[3] = 0.4F;\n+\n+  baz (z);\n+  if (x[0] != 0.7F || x[3] != 0.4F)\n+    abort ();\n+\n+  vector float source = { 0.8F, 0.7F, 0.6F, 0.5F };\n+\n+  baz1 (source);\n+  if (x[2] != 0.6F || x[1] != 0.7F)\n+    abort ();\n+\n+  vector float dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 0.8F || dest[1] != 0.7F)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[3] != 0.5F || a_struct.a_vector[0] != 0.8F)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "8bd52dee391a69168cb5681aa13501a1486f7da3", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-38.c", "status": "modified", "additions": 138, "deletions": 6, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-38.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,152 @@\n \n extern void abort (void);\n \n-const vector float y = { 0.0f, 0.1f, 0.2f, 0.3f };\n+vector float x;\n+const vector float y = { 0.0F, 0.1F, 0.2F, 0.3F };\n+vector float z;\n \n vector float\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector float\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector float *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector float\n+foo2 (void)\n+{\n+  vector float v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector float\n+foo3 (vector float *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector float a_vector;\n+};\n+\n+vector float\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector float arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector float *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector float arg)\n+{\n+  vector float v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector float *arg1, vector float arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector float v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (float argc, float *argv[])\n {\n   vector float fetched_value = foo ();\n-  if (fetched_value[0] != 0.0f || fetched_value[3] != 0.3f)\n+  if (fetched_value[0] != 0.0F || fetched_value[3] != 0.3F)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 0.1F || fetched_value[2] != 0.2F)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 0.2F || fetched_value[1] != 0.1F)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 0.3F || fetched_value[0] != 0.0F)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[2] != 0.2F || fetched_value[3] != 0.3F)\n+    abort ();\n+\n+  z[0] = 0.7F;\n+  z[1] = 0.6F;\n+  z[2] = 0.5F;\n+  z[3] = 0.4F;\n+\n+  baz (z);\n+  if (x[0] != 0.7F || x[3] != 0.4F)\n+    abort ();\n+\n+  vector float source = { 0.8F, 0.7F, 0.6F, 0.5F };\n+\n+  baz1 (source);\n+  if (x[2] != 0.6F || x[1] != 0.7F)\n+    abort ();\n+\n+  vector float dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 0.8F || dest[1] != 0.7F)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[3] != 0.5F || a_struct.a_vector[0] != 0.8F)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "94add40de7e6c688e4656e50fa510cf5defc9c47", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-39.c", "status": "modified", "additions": 144, "deletions": 8, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-39.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -2,27 +2,163 @@\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-mcpu=power8 -O3 \" } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n-/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+/* Previous versions of this test required that the assembler does not\n+   contain xxpermdi or xxswapd.  However, with the more sophisticated\n+   code generation used today, it is now possible that xxpermdi (aka\n+   xxswapd) show up without being part of a lxvd2x or stxvd2x\n+   sequence.  */\n \n #include <altivec.h>\n \n extern void abort (void);\n \n-const vector float y = { 0.0f, 0.1f, 0.2f, 0.3f };\n+vector float x;\n+const vector float y = { 0.0F, 0.1F, 0.2F, 0.3F };\n+vector float z;\n \n vector float\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector float\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector float *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector float\n+foo2 (void)\n+{\n+  vector float v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector float\n+foo3 (vector float *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector float a_vector;\n+};\n+\n+vector float\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector float arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector float *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector float arg)\n+{\n+  vector float v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector float *arg1, vector float arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector float v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (float argc, float *argv[])\n {\n   vector float fetched_value = foo ();\n-  if (fetched_value[0] != 0.0f || fetched_value[3] != 0.3)\n+  if (fetched_value[0] != 0.0F || fetched_value[3] != 0.3F)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 0.1F || fetched_value[2] != 0.2F)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[2] != 0.2F || fetched_value[1] != 0.1F)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[3] != 0.3F || fetched_value[0] != 0.0F)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[2] != 0.2F || fetched_value[3] != 0.3F)\n+    abort ();\n+\n+  z[0] = 0.7F;\n+  z[1] = 0.6F;\n+  z[2] = 0.5F;\n+  z[3] = 0.4F;\n+\n+  baz (z);\n+  if (x[0] != 0.7F || x[3] != 0.4F)\n+    abort ();\n+\n+  vector float source = { 0.8F, 0.7F, 0.6F, 0.5F };\n+\n+  baz1 (source);\n+  if (x[3] != 0.6F || x[2] != 0.7F)\n+    abort ();\n+\n+  vector float dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 0.8F || dest[1] != 0.7F)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[3] != 0.5F || a_struct.a_vector[0] != 0.8F)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "50610d9ab81d4b56f8b1866543af8c42de2de2ed", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-40.c", "status": "modified", "additions": 138, "deletions": 8, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-40.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,150 @@\n \n extern void abort (void);\n \n-vector long long int y = { 0, 1 };\n+vector long long x;\n+vector long long y = { 1024, 2048 };\n+vector long long z;\n \n-vector long long int\n+vector long long\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector long long\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector long long *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector long long\n+foo2 (void)\n+{\n+  vector long long v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector long long\n+foo3 (vector long long *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector long long a_vector;\n+};\n+\n+vector long long\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector long long arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector long long *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector long long arg)\n+{\n+  vector long long v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector long long *arg1, vector long long arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector long long v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, int *argv[])\n+main (long long argc, long long *argv[])\n {\n-  vector long long int fetched_value = foo ();\n-  if (fetched_value[0] != 0 || fetched_value[1] != 1)\n+  vector long long fetched_value = foo ();\n+  if (fetched_value[0] != 1024 || fetched_value[1] != 2048)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[0] != 1024 || fetched_value[1] != 2048)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n     abort ();\n-  else\n-    return 0;\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n+    abort ();\n+\n+  z[0] = 7096;\n+  z[1] = 6048;\n+\n+  baz (z);\n+  if (x[0] != 7096 || x[1] != 6048)\n+    abort ();\n+\n+  vector long long source = { 8192, 7096};\n+\n+  baz1 (source);\n+  if (x[0] != 8192 || x[1] != 7096)\n+    abort ();\n+\n+  vector long long dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 8192 || dest[1] != 7096)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[1] != 7096 || a_struct.a_vector[0] != 8192)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "f8b1d03b9086b25d932214241147d927ac90a3ff", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-41.c", "status": "modified", "additions": 138, "deletions": 8, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-41.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,150 @@\n \n extern void abort (void);\n \n-const vector long long int y = { 0, 1 };\n+vector long long x;\n+const vector long long y = { 1024, 2048 };\n+vector long long z;\n \n-vector long long int\n+vector long long\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector long long\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector long long *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector long long\n+foo2 (void)\n+{\n+  vector long long v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector long long\n+foo3 (vector long long *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector long long a_vector;\n+};\n+\n+vector long long\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector long long arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector long long *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector long long arg)\n+{\n+  vector long long v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector long long *arg1, vector long long arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector long long v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (long long argc, long long *argv[])\n {\n-  vector long long int fetched_value = foo ();\n-  if (fetched_value[0] != 0 || fetched_value[1] != 1)\n+  vector long long fetched_value = foo ();\n+  if (fetched_value[0] != 1024 || fetched_value[1] != 2048)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[0] != 1024 || fetched_value[1] != 2048)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n     abort ();\n-  else\n-    return 0;\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n+    abort ();\n+\n+  z[0] = 7096;\n+  z[1] = 6048;\n+\n+  baz (z);\n+  if (x[0] != 7096 || x[1] != 6048)\n+    abort ();\n+\n+  vector long long source = { 8192, 7096};\n+\n+  baz1 (source);\n+  if (x[0] != 8192 || x[1] != 7096)\n+    abort ();\n+\n+  vector long long dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 8192 || dest[1] != 7096)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[1] != 7096 || a_struct.a_vector[0] != 8192)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "a8efc304d519a2dbd85f2844eab13595fed524ca", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-42.c", "status": "modified", "additions": 144, "deletions": 10, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-42.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -2,27 +2,161 @@\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-mcpu=power8 -O3 \" } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n-/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+/* Previous versions of this test required that the assembler does not\n+   contain xxpermdi or xxswapd.  However, with the more sophisticated\n+   code generation used today, it is now possible that xxpermdi (aka\n+   xxswapd) show up without being part of a lxvd2x or stxvd2x\n+   sequence.  */\n \n #include <altivec.h>\n \n extern void abort (void);\n \n-const vector long long int y = { 0, 1 };\n+vector long long x;\n+const vector long long y = { 1024, 2048 };\n+vector long long z;\n \n-vector long long int\n+vector long long\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector long long\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector long long *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector long long\n+foo2 (void)\n+{\n+  vector long long v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector long long\n+foo3 (vector long long *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector long long a_vector;\n+};\n+\n+vector long long\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector long long arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector long long *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector long long arg)\n+{\n+  vector long long v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector long long *arg1, vector long long arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector long long v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (long long argc, long long *argv[])\n {\n-  vector long long int fetched_value = foo ();\n-  if (fetched_value[0] != 0 || fetched_value[1] != 1)\n+  vector long long fetched_value = foo ();\n+  if (fetched_value[0] != 1024 || fetched_value[1] != 2048)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n+    abort ();\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[0] != 1024 || fetched_value[1] != 2048)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n     abort ();\n-  else\n-    return 0;\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[1] != 2048 || fetched_value[0] != 1024)\n+    abort ();\n+\n+  z[0] = 7096;\n+  z[1] = 6048;\n+\n+  baz (z);\n+  if (x[0] != 7096 || x[1] != 6048)\n+    abort ();\n+\n+  vector long long source = { 8192, 7096};\n+\n+  baz1 (source);\n+  if (x[0] != 8192 || x[1] != 7096)\n+    abort ();\n+\n+  vector long long dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 8192 || dest[1] != 7096)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[1] != 7096 || a_struct.a_vector[0] != 8192)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "ca1dc97fabf7bf7cbf513d9d09233d11c67b699c", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-43.c", "status": "modified", "additions": 136, "deletions": 6, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-43.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,150 @@\n \n extern void abort (void);\n \n-vector double y = { 0.0, 0.1 };\n+vector double x;\n+vector double y = { 0.1, 0.2 };\n+vector double z;\n \n vector double\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector double\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector double *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector double\n+foo2 (void)\n+{\n+  vector double v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector double\n+foo3 (vector double *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector double a_vector;\n+};\n+\n+vector double\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector double arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector double *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector double arg)\n+{\n+  vector double v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector double *arg1, vector double arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector double v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (double argc, double *argv[])\n {\n   vector double fetched_value = foo ();\n-  if (fetched_value[0] != 0 || fetched_value[1] != 0.1)\n+  if (fetched_value[0] != 0.1 || fetched_value[1] != 0.2)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[0] != 0.1 || fetched_value[1] != 0.2)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n+    abort ();\n+\n+  z[0] = 0.7;\n+  z[1] = 0.6;\n+\n+  baz (z);\n+  if (x[0] != 0.7 || x[1] != 0.6)\n+    abort ();\n+\n+  vector double source = { 0.8, 0.7 };\n+\n+  baz1 (source);\n+  if (x[0] != 0.8 || x[1] != 0.7)\n+    abort ();\n+\n+  vector double dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 0.8 || dest[1] != 0.7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[1] != 0.7 || a_struct.a_vector[0] != 0.8)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "648016988a926dc402fbfcde4dd76c3fbc4483fc", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-44.c", "status": "modified", "additions": 136, "deletions": 6, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-44.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,20 +7,150 @@\n \n extern void abort (void);\n \n-const vector double y = { 0.0, 0.1 };\n+vector double x;\n+const vector double y = { 0.1, 0.2 };\n+vector double z;\n \n vector double\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector double\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector double *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector double\n+foo2 (void)\n+{\n+  vector double v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector double\n+foo3 (vector double *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector double a_vector;\n+};\n+\n+vector double\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector double arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector double *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector double arg)\n+{\n+  vector double v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector double *arg1, vector double arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector double v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (double argc, double *argv[])\n {\n   vector double fetched_value = foo ();\n-  if (fetched_value[0] != 0.0 || fetched_value[1] != 0.1)\n+  if (fetched_value[0] != 0.1 || fetched_value[1] != 0.2)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[0] != 0.1 || fetched_value[1] != 0.2)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n+    abort ();\n+\n+  z[0] = 0.7;\n+  z[1] = 0.6;\n+\n+  baz (z);\n+  if (x[0] != 0.7 || x[1] != 0.6)\n+    abort ();\n+\n+  vector double source = { 0.8, 0.7 };\n+\n+  baz1 (source);\n+  if (x[0] != 0.8 || x[1] != 0.7)\n+    abort ();\n+\n+  vector double dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 0.8 || dest[1] != 0.7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[1] != 0.7 || a_struct.a_vector[0] != 0.8)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "3e8c7e7756774321f583d424f6bacc0d06400aa0", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-45.c", "status": "modified", "additions": 142, "deletions": 8, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-45.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -2,27 +2,161 @@\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-mcpu=power8 -O3 \" } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n-/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+/* Previous versions of this test required that the assembler does not\n+   contain xxpermdi or xxswapd.  However, with the more sophisticated\n+   code generation used today, it is now possible that xxpermdi (aka\n+   xxswapd) show up without being part of a lxvd2x or stxvd2x\n+   sequence.  */\n \n #include <altivec.h>\n \n extern void abort (void);\n \n-const vector double y = { 0.0, 0.1 };\n+vector double x;\n+const vector double y = { 0.1, 0.2 };\n+vector double z;\n \n vector double\n foo (void)\n {\n-  return y;\n+  return y;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+vector double\n+foo1 (void)\n+{\n+  x = y;\t\t\t/* Remove 2 redundant swaps here.  */\n+  return x;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+fill_local (vector double *vp)\n+{\n+  *vp = x;\t\t\t/* Remove 2 redundant swaps here.  */\n+}\n+\n+/* Test aligned load from local.  */\n+vector double\n+foo2 (void)\n+{\n+  vector double v;\n+\n+  /* Need to be clever here because v will normally reside in a\n+     register rather than memory.  */\n+  fill_local (&v);\n+  return v;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+\n+/* Test aligned load from pointer.  */\n+vector double\n+foo3 (vector double *arg)\n+{\n+  return *arg;\t\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* In this structure, the compiler should insert padding to assure\n+   that a_vector is properly aligned.  */\n+struct bar {\n+  short a_field;\n+  vector double a_vector;\n+};\n+\n+vector double\n+foo4 (struct bar *bp)\n+{\n+  return bp->a_vector;\t\t/* Remove 1 swap and use lvx.  */\n+}\n+\n+/* Test aligned store to global.  */\n+void\n+baz (vector double arg)\n+{\n+  x = arg;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void __attribute__ ((noinline))\n+copy_local (vector double *arg)\n+{\n+  x = *arg;\t\t\t/* Remove 2 redundant swaps.  */\n+}\n+\n+\n+/* Test aligned store to local.  */\n+void\n+baz1 (vector double arg)\n+{\n+  vector double v;\n+\n+  /* Need cleverness, because v will normally reside in a register\n+     rather than memory.  */\n+  v = arg;\t\t\t/* Aligned store to local: remove 1\n+\t\t\t\t   swap and use stvx.  */\n+  copy_local (&v);\n+}\n+\n+/* Test aligned store to pointer.  */\n+void\n+baz2 (vector double *arg1, vector double arg2)\n+{\n+  /* Assume arg2 resides in register.  */\n+  *arg1 = arg2;\t\t\t/* Remove 1 swap and use stvx.  */\n+}\n+\n+void\n+baz3 (struct bar *bp, vector double v)\n+{\n+  /* Assume v resides in register.  */\n+  bp->a_vector = v;\t\t/* Remove 1 swap and use stvx.  */\n }\n \n int\n-main (int argc, char *argv[])\n+main (double argc, double *argv[])\n {\n   vector double fetched_value = foo ();\n-  if (fetched_value[0] != 0.0 || fetched_value[15] != 0.1)\n+  if (fetched_value[0] != 0.1 || fetched_value[1] != 0.2)\n+    abort ();\n+\n+  fetched_value = foo1 ();\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n     abort ();\n-  else\n-    return 0;\n+\n+  fetched_value = foo2 ();\n+  if (fetched_value[0] != 0.1 || fetched_value[1] != 0.2)\n+    abort ();\n+\n+  fetched_value = foo3 (&x);\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n+    abort ();\n+\n+  struct bar a_struct;\n+  a_struct.a_vector = x;\t/* Remove 2 redundant swaps.  */\n+  fetched_value = foo4 (&a_struct);\n+  if (fetched_value[1] != 0.2 || fetched_value[0] != 0.1)\n+    abort ();\n+\n+  z[0] = 0.7;\n+  z[1] = 0.6;\n+\n+  baz (z);\n+  if (x[0] != 0.7 || x[1] != 0.6)\n+    abort ();\n+\n+  vector double source = { 0.8, 0.7 };\n+\n+  baz1 (source);\n+  if (x[0] != 0.8 || x[1] != 0.7)\n+    abort ();\n+\n+  vector double dest;\n+  baz2 (&dest, source);\n+  if (dest[0] != 0.8 || dest[1] != 0.7)\n+    abort ();\n+\n+  baz3 (&a_struct, source);\n+  if (a_struct.a_vector[1] != 0.7 || a_struct.a_vector[0] != 0.8)\n+    abort ();\n+\n+  return 0;\n }"}, {"sha": "2aea0baeff410c528b1f0d61ff29f9609e8b2e3b", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-2.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -33,5 +33,7 @@ add_long_1 (vector long *p, long x)\n /* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n /* { dg-final { scan-assembler-not \"lxvx\"     } } */\n /* { dg-final { scan-assembler-not \"lxv\"      } } */\n-/* { dg-final { scan-assembler-not \"lvx\"      } } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+/* With recent enhancements to the code generator, it is considered\n+ * legal to implement vec_extract with lvx and xxpermdi.  Previous\n+ * versions of this test forbid both instructions.  */"}, {"sha": "aeacbfb262ba11cedfd439fdb94f261588c629d2", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-3.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-3.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -22,5 +22,7 @@ add_long_n (vector long *p, long x, long n)\n /* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n /* { dg-final { scan-assembler-not \"lxvx\"     } } */\n /* { dg-final { scan-assembler-not \"lxv\"      } } */\n-/* { dg-final { scan-assembler-not \"lvx\"      } } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+/* With recent enhancements to the code generator, it is considered\n+ * legal to implement vec_extract with lvx and xxpermdi.  Previous\n+ * versions of this test forbid both instructions.  */"}, {"sha": "9ee7bf2aa6c3ecd2859ec96787b12c0ed5e00847", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-5.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-5.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -64,5 +64,7 @@ add_signed_char_n (vector signed char *p, int n)\n /* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n /* { dg-final { scan-assembler-not \"lxvx\"     } } */\n /* { dg-final { scan-assembler-not \"lxv\"      } } */\n-/* { dg-final { scan-assembler-not \"lvx\"      } } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+/* With recent enhancements to the code generator, it is considered\n+ * legal to implement vec_extract with lvx and xxpermdi.  Previous\n+ * versions of this test forbid both instructions.  */"}, {"sha": "c18f439080d5fd04679e70f25e5aba3658f3d4b2", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-6.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-6.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -64,5 +64,7 @@ add_unsigned_char_n (vector unsigned char *p, int n)\n /* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n /* { dg-final { scan-assembler-not \"lxvx\"     } } */\n /* { dg-final { scan-assembler-not \"lxv\"      } } */\n-/* { dg-final { scan-assembler-not \"lvx\"      } } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+/* With recent enhancements to the code generator, it is considered\n+ * legal to implement vec_extract with lvx and xxpermdi.  Previous\n+ * versions of this test forbid both instructions.  */"}, {"sha": "c3bc1dec1285404641c98a2e7ba234b6fd6a0245", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-7.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-7.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -40,5 +40,7 @@ add_float_n (vector float *p, long n)\n /* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n /* { dg-final { scan-assembler-not \"lxvx\"     } } */\n /* { dg-final { scan-assembler-not \"lxv\"      } } */\n-/* { dg-final { scan-assembler-not \"lvx\"      } } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+/* With recent enhancements to the code generator, it is considered\n+ * legal to implement vec_extract with lvx and xxpermdi.  Previous\n+ * versions of this test forbid both instructions.  */"}, {"sha": "12e7c8977fc7f44312a18317c7194a6d1eb6b33c", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-8.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-8.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -40,5 +40,7 @@ add_int_n (vector int *p, int n)\n /* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n /* { dg-final { scan-assembler-not \"lxvx\"     } } */\n /* { dg-final { scan-assembler-not \"lxv\"      } } */\n-/* { dg-final { scan-assembler-not \"lvx\"      } } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+/* With recent enhancements to the code generator, it is considered\n+ * legal to implement vec_extract with lvx and xxpermdi.  Previous\n+ * versions of this test forbid both instructions.  */"}, {"sha": "2adadf2195180e5b3c331210c0db85635497507b", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-9.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-9.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -64,5 +64,7 @@ add_short_n (vector short *p, int n)\n /* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n /* { dg-final { scan-assembler-not \"lxvx\"     } } */\n /* { dg-final { scan-assembler-not \"lxv\"      } } */\n-/* { dg-final { scan-assembler-not \"lvx\"      } } */\n-/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+/* With recent enhancements to the code generator, it is considered\n+ * legal to implement vec_extract with lvx and xxpermdi.  Previous\n+ * versions of this test forbid both instructions.  */"}, {"sha": "ddb0089c396034d0c0f839dc352021e48074d7d6", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-vector-6-le.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vector-6-le.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vector-6-le.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vector-6-le.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -7,10 +7,10 @@\n \n /* { dg-final { scan-assembler-times \"xvabsdp\" 1 } } */\n /* { dg-final { scan-assembler-times \"xvadddp\" 1 } } */\n-/* { dg-final { scan-assembler-times \"xxlnor\" 6 } } */\n-/* { dg-final { scan-assembler-times \"xxlor\" 16 } } */\n+/* { dg-final { scan-assembler-times \"xxlnor\" 8 } } */\n+/* { dg-final { scan-assembler-times \"xxlor\" 30 } } */\n /* { dg-final { scan-assembler-times \"xvcmpeqdp\" 5 } } */\n-/* { dg-final { scan-assembler-times \"xvcmpgtdp\" 7 } } */\n+/* { dg-final { scan-assembler-times \"xvcmpgtdp\" 8 } } */\n /* { dg-final { scan-assembler-times \"xvcmpgedp\" 6 } } */\n /* { dg-final { scan-assembler-times \"xvrdpim\" 1 } } */\n /* { dg-final { scan-assembler-times \"xvmaddadp\" 1 } } */\n@@ -26,7 +26,7 @@\n /* { dg-final { scan-assembler-times \"xvmsubasp\" 1 } } */\n /* { dg-final { scan-assembler-times \"xvnmaddasp\" 1 } } */\n /* { dg-final { scan-assembler-times \"vmsumshs\" 1 } } */\n-/* { dg-final { scan-assembler-times \"xxland\" 9 } } */\n+/* { dg-final { scan-assembler-times \"xxland\" 13 } } */\n \n /* Source code for the test in vsx-vector-6.h */\n #include \"vsx-vector-6.h\""}, {"sha": "b69e3645bad934624dd8cc82843ee50467f72ec5", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -1,3 +1,10 @@\n+2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* lex.c (search_line_fast): Remove illegal coercion of an\n+\tunaligned pointer value to vector pointer type and replace with\n+\tuse of __builtin_vec_vsx_ld () built-in function, which operates\n+\ton unaligned pointer values.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "92c62517a4d48dbf043116319615d18152d1f367", "filename": "libcpp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a821c903c9fa2288712d31da2038d0297babcb/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a821c903c9fa2288712d31da2038d0297babcb/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=a3a821c903c9fa2288712d31da2038d0297babcb", "patch": "@@ -568,7 +568,7 @@ search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n     {\n       vc m_nl, m_cr, m_bs, m_qm;\n \n-      data = *((const vc *)s);\n+      data = __builtin_vec_vsx_ld (0, s);\n       s += 16;\n \n       m_nl = (vc) __builtin_vec_cmpeq(data, repl_nl);"}]}