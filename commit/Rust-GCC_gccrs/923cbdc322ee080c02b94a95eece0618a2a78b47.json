{"sha": "923cbdc322ee080c02b94a95eece0618a2a78b47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIzY2JkYzMyMmVlMDgwYzAyYjk0YTk1ZWVjZTA2MThhMmE3OGI0Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-18T15:35:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-18T15:35:47Z"}, "message": "unroll.c: Include predict.h.\n\n\t* unroll.c: Include predict.h.\n\t(unroll_loop): Drop prediction notes on preconditioning.\n\t* predict.def (PRED_LOOP_PRECONDITIONG, PRED_LOOP_CONDITION):\n\tNew; add comments on the others.\n\t* Makefile.in: (unroll.o): Add dependancy on predict.h.\n\t* loop.c (strength_reduce): Fix branch prediction.\n\n\t* stmt.c (emit_case_nodes): Optimize test whether index is in given\n\tinterval.\n\n\t* predict.c (estimate_probability): Do not bail out early\n\twhen note is present.\n\t(combine_predictions_for_insn): Fix note removal code.\n\nFrom-SVN: r43441", "tree": {"sha": "0803743d2349ea46ce205c05df7cae76a3374b1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0803743d2349ea46ce205c05df7cae76a3374b1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/923cbdc322ee080c02b94a95eece0618a2a78b47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923cbdc322ee080c02b94a95eece0618a2a78b47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923cbdc322ee080c02b94a95eece0618a2a78b47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923cbdc322ee080c02b94a95eece0618a2a78b47/comments", "author": null, "committer": null, "parents": [{"sha": "049d2def48689b21149b6a7ad19c865e1d393627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049d2def48689b21149b6a7ad19c865e1d393627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/049d2def48689b21149b6a7ad19c865e1d393627"}], "stats": {"total": 91, "additions": 82, "deletions": 9}, "files": [{"sha": "51c11e7acc2b56385ad4e1aaf857a72a06498d11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=923cbdc322ee080c02b94a95eece0618a2a78b47", "patch": "@@ -1,3 +1,23 @@\n+Mon Jun 18 17:27:24 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* unroll.c: Include predict.h.\n+\t(unroll_loop): Drop prediction notes on preconditioning.\n+\t* predict.def (PRED_LOOP_PRECONDITIONG, PRED_LOOP_CONDITION):\n+\tNew; add comments on the others.\n+\t* Makefile.in: (unroll.o): Add dependancy on predict.h.\n+\t* loop.c (strength_reduce): Fix branch prediction.\n+\n+Mon Jun 18 17:26:56 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* stmt.c (emit_case_nodes): Optimize test whether index is in given\n+\tinterval.\n+\n+Mon Jun 18 15:43:10 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (estimate_probability): Do not bail out early\n+\twhen note is present.\n+\t(combine_predictions_for_insn): Fix note removal code.\n+\n 2001-06-18  Ben Elliston  <bje@redhat.com>\n \n \t* except.c (resolve_fixup_regions): Initialise \"cleanup\"."}, {"sha": "75b3dbcee8f7b612e136f3204eb98e4f7400d7e5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=923cbdc322ee080c02b94a95eece0618a2a78b47", "patch": "@@ -1450,7 +1450,7 @@ doloop.o : doloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) toplev.h\n unroll.o : unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) insn-config.h function.h \\\n    $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \\\n-   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H)\n+   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H)\n flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(EXPR_H) ssa.h $(GGC_H) $(TM_P_H)"}, {"sha": "82f09f3ecbb3741da9a9bb4d83706373a7581045", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=923cbdc322ee080c02b94a95eece0618a2a78b47", "patch": "@@ -4505,7 +4505,7 @@ strength_reduce (loop, flags)\n   if ((flags & LOOP_BCT)\n       && loop_info->n_iterations / loop_info->unroll_number > 1)\n     {\n-      int n = loop_info->n_iterations / loop_info->unroll_number - 1;\n+      int n = loop_info->n_iterations / loop_info->unroll_number;\n       predict_insn (PREV_INSN (loop->end),\n \t\t    PRED_LOOP_ITERATIONS,\n \t\t    REG_BR_PROB_BASE - REG_BR_PROB_BASE / n);"}, {"sha": "38818cbc079963d49067508c7d563820ecfae99e", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=923cbdc322ee080c02b94a95eece0618a2a78b47", "patch": "@@ -208,7 +208,6 @@ combine_predictions_for_insn (insn, bb)\n      probability combination techniques.  */\n   while (*pnote)\n     {\n-      rtx *next_pnote = &XEXP (*pnote, 1);\n       if (REG_NOTE_KIND (*pnote) == REG_BR_PRED)\n \t{\n \t  int predictor = INTVAL (XEXP (XEXP (*pnote, 0), 0));\n@@ -219,7 +218,8 @@ combine_predictions_for_insn (insn, bb)\n \t    best_probability = probability, best_predictor = predictor;\n \t  *pnote = XEXP (*pnote, 1);\n \t}\n-      pnote = next_pnote;\n+      else\n+        pnote = &XEXP (*pnote, 1);\n     }\n   dump_prediction (PRED_FIRST_MATCH, best_probability, bb);\n   if (!prob_note)\n@@ -313,9 +313,6 @@ estimate_probability (loops_info)\n \t  || ! any_condjump_p (last_insn))\n \tcontinue;\n \n-      if (find_reg_note (last_insn, REG_BR_PROB, 0))\n-\tcontinue;\n-\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  /* Predict edges to blocks that return immediately to be"}, {"sha": "ff8171bcc6872406020c7564310e041d324f59cf", "filename": "gcc/predict.def", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=923cbdc322ee080c02b94a95eece0618a2a78b47", "patch": "@@ -36,15 +36,47 @@ Boston, MA 02111-1307, USA.  */\n    REG_BR_PROB_BASE / 2).  */\n    \n \n+/* An combined heuristics using probability determined by first\n+   matching heuristics from this list.  */\n DEF_PREDICTOR (PRED_FIRST_MATCH, \"first match\", PROB_ALWAYS)\n+\n+/* Mark unconditional jump as taken.  */\n DEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS)\n+\n+/* Use number of loop iterations determined by loop unroller to set\n+   probability.  */\n DEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS)\n+\n+/* Hints dropped by user via __builtin_expect feature.  */\n DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY)\n+\n+/* Branch to basic block containing call marked by noreturn attribute.  */\n DEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", PROB_ALWAYS)\n+\n+/* Loopback edge is taken.  */\n DEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", PROB_VERY_LIKELY)\n+\n+/* Edge causing loop to terminate is probably not taken. */\n DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", PROB_LIKELY)\n+\n+/* Condition emitted by preconditiong code to ensure that variable\n+   setting number of iterations is greater than initial value of iterator.  */\n+DEF_PREDICTOR (PRED_LOOP_CONDITION, \"loop condition\", PROB_VERY_LIKELY)\n+\n+/* Preconditioning makes linear list of branches.  */\n+DEF_PREDICTOR (PRED_LOOP_PRECONDITIONING, \"loop preconditioning\", PROB_VERY_LIKELY)\n+\n+/* Copied condition for the first iteration of loop is probably true.  */\n DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", PROB_LIKELY)\n+\n+/* Pointers are usually not NULL.  */\n DEF_PREDICTOR (PRED_POINTER, \"pointer\", PROB_LIKELY)\n+\n+/* NE is probable, EQ not etc...  */\n DEF_PREDICTOR (PRED_OPCODE, \"opcode\", PROB_LIKELY)\n+\n+/* Branch guarding call is probably taken.  */\n DEF_PREDICTOR (PRED_CALL, \"call\", PROB_LIKELY)\n+\n+/* Branch causing function to terminate is probably not taken.  */\n DEF_PREDICTOR (PRED_ERROR_RETURN, \"error return\", PROB_LIKELY)"}, {"sha": "ee4523c33c50e19a82a0b991769ff7d4b9b6e12f", "filename": "gcc/stmt.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=923cbdc322ee080c02b94a95eece0618a2a78b47", "patch": "@@ -6293,8 +6293,10 @@ emit_case_nodes (index, node, default_label, index_type)\n \t  /* Node has no children so we check low and high bounds to remove\n \t     redundant tests.  Only one of the bounds can exist,\n \t     since otherwise this node is bounded--a case tested already.  */\n+\t  int high_bound = node_has_high_bound (node, index_type);\n+\t  int low_bound = node_has_low_bound (node, index_type);\n \n-\t  if (!node_has_high_bound (node, index_type))\n+\t  if (!high_bound && low_bound)\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n@@ -6306,7 +6308,7 @@ emit_case_nodes (index, node, default_label, index_type)\n \t\t\t\t       default_label);\n \t    }\n \n-\t  if (!node_has_low_bound (node, index_type))\n+\t  else if (!low_bound && high_bound)\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n@@ -6317,6 +6319,24 @@ emit_case_nodes (index, node, default_label, index_type)\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n+\t  else if (!low_bound && !high_bound)\n+\t    {\n+\t      /* Instead of doing two branches emit test (index-low) <= (high-low).  */\n+\t      tree new_bound = fold (build (MINUS_EXPR, index_type, node->high,\n+\t\t\t\t\t    node->low));\n+\t      rtx new_index;\n+\t      \n+\t      new_index = expand_binop (mode, sub_optab, index,\n+\t\t\t      \t\texpand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t        NULL_RTX, 0, OPTAB_WIDEN);\n+\t\t\t\t\n+\t      emit_cmp_and_jump_insns (new_index,\n+\t\t\t\t       expand_expr (new_bound, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       GT, NULL_RTX, mode, 1, 0,\n+\t\t\t\t       default_label);\n+\t    }\n \n \t  emit_jump (label_rtx (node->code_label));\n \t}"}, {"sha": "9a09f5d3d3e08cde131f68f7044e4ce8f6b692de", "filename": "gcc/unroll.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923cbdc322ee080c02b94a95eece0618a2a78b47/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=923cbdc322ee080c02b94a95eece0618a2a78b47", "patch": "@@ -167,6 +167,7 @@ enum unroll_types\n #include \"toplev.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n+#include \"predict.h\"\n \n /* This controls which loops are unrolled, and by how much we unroll\n    them.  */\n@@ -962,6 +963,7 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t      emit_cmp_and_jump_insns (initial_value, final_value,\n \t\t\t\t       neg_inc ? LE : GE,\n \t\t\t\t       NULL_RTX, mode, 0, 0, labels[1]);\n+\t      predict_insn_def (get_last_insn (), PRED_LOOP_CONDITION, NOT_TAKEN);\n \t      JUMP_LABEL (get_last_insn ()) = labels[1];\n \t      LABEL_NUSES (labels[1])++;\n \t    }\n@@ -1007,6 +1009,8 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t\t\t\t       labels[i]);\n \t      JUMP_LABEL (get_last_insn ()) = labels[i];\n \t      LABEL_NUSES (labels[i])++;\n+\t      predict_insn (get_last_insn (), PRED_LOOP_PRECONDITIONING,\n+\t\t\t    REG_BR_PROB_BASE / (unroll_number - i));\n \t    }\n \n \t  /* If the increment is greater than one, then we need another branch,"}]}