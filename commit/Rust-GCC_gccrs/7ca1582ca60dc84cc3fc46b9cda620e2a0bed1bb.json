{"sha": "7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb", "node_id": "C_kwDOANBUbNoAKDdjYTE1ODJjYTYwZGM4NGNjM2ZjNDZiOWNkYTYyMGUyYTBiZWQxYmI", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-01-18T15:57:39Z"}, "committer": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-01-18T16:23:23Z"}, "message": "[vect] Add main vectorized loop unrolling\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop.cc (vect_estimate_min_profitable_iters): Pass new\n\targument suggested_unroll_factor.\n\t(vect_analyze_loop_costing): Likewise.\n\t(_loop_vec_info::_loop_vec_info): Initialize new member\n\tsuggested_unroll_factor.\n\t(vect_determine_partial_vectors_and_peeling): Make epilogue of unrolled\n\tmain loop use partial vectors.\n\t(vect_analyze_loop_2): Pass and use new argument\n\tsuggested_unroll_factor.\n\t(vect_analyze_loop_1): Change to intialize local\n\tsuggested_unroll_factor and use it.\n\t(vectorizable_reduction): Don't use single_defuse_cycle when unrolling.\n\t* tree-vectorizer.h (_loop_vec_info::_loop_vec_info): Add new member\n\tsuggested_unroll_factor.\n\t(vector_costs::vector_costs): Add new member m_suggested_unroll_factor.\n\t(vector_costs::suggested_unroll_factor): New getter function.\n\t(finish_cost): Set return argument suggested_unroll_factor.", "tree": {"sha": "a196d384a55b73b1e8248ef4da31ebbb782e0cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a196d384a55b73b1e8248ef4da31ebbb782e0cc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "254ada46ae0f21bd6f40314214f969f368328e22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254ada46ae0f21bd6f40314214f969f368328e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/254ada46ae0f21bd6f40314214f969f368328e22"}], "stats": {"total": 106, "additions": 94, "deletions": 12}, "files": [{"sha": "0fe3529b2d1cf36617c04c1d0f1c4c7bb363607c", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 70, "deletions": 11, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb", "patch": "@@ -154,7 +154,8 @@ along with GCC; see the file COPYING3.  If not see\n    http://gcc.gnu.org/projects/tree-ssa/vectorization.html\n */\n \n-static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *);\n+static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *,\n+\t\t\t\t\t\tunsigned *);\n static stmt_vec_info vect_is_simple_reduction (loop_vec_info, stmt_vec_info,\n \t\t\t\t\t       bool *, bool *);\n \n@@ -831,6 +832,7 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     skip_main_loop_edge (nullptr),\n     skip_this_loop_edge (nullptr),\n     reusable_accumulators (),\n+    suggested_unroll_factor (1),\n     max_vectorization_factor (0),\n     mask_skip_niters (NULL_TREE),\n     rgroup_compare_type (NULL_TREE),\n@@ -1834,7 +1836,8 @@ vect_known_niters_smaller_than_vf (loop_vec_info loop_vinfo)\n    definitely no, or -1 if it's worth retrying.  */\n \n static int\n-vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n+vect_analyze_loop_costing (loop_vec_info loop_vinfo,\n+\t\t\t   unsigned *suggested_unroll_factor)\n {\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n@@ -1868,7 +1871,8 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n \n   int min_profitable_iters, min_profitable_estimate;\n   vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n-\t\t\t\t      &min_profitable_estimate);\n+\t\t\t\t      &min_profitable_estimate,\n+\t\t\t\t      suggested_unroll_factor);\n \n   if (min_profitable_iters < 0)\n     {\n@@ -2152,10 +2156,16 @@ vect_determine_partial_vectors_and_peeling (loop_vec_info loop_vinfo,\n \t vectors to the epilogue, with the main loop continuing to operate\n \t on full vectors.\n \n+\t If we are unrolling we also do not want to use partial vectors. This\n+\t is to avoid the overhead of generating multiple masks and also to\n+\t avoid having to execute entire iterations of FALSE masked instructions\n+\t when dealing with one or less full iterations.\n+\n \t ??? We could then end up failing to use partial vectors if we\n \t decide to peel iterations into a prologue, and if the main loop\n \t then ends up processing fewer than VF iterations.  */\n-      if (param_vect_partial_vector_usage == 1\n+      if ((param_vect_partial_vector_usage == 1\n+\t   || loop_vinfo->suggested_unroll_factor > 1)\n \t  && !LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n \t  && !vect_known_niters_smaller_than_vf (loop_vinfo))\n \tLOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (loop_vinfo) = true;\n@@ -2222,7 +2232,8 @@ vect_determine_partial_vectors_and_peeling (loop_vec_info loop_vinfo,\n    for it.  The different analyses will record information in the\n    loop_vec_info struct.  */\n static opt_result\n-vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n+vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal,\n+\t\t     unsigned *suggested_unroll_factor)\n {\n   opt_result ok = opt_result::success ();\n   int res;\n@@ -2382,6 +2393,12 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n      set of rgroups.  */\n   gcc_assert (LOOP_VINFO_MASKS (loop_vinfo).is_empty ());\n \n+  /* Apply the suggested unrolling factor, this was determined by the backend\n+     during finish_cost the first time we ran the analyzis for this\n+     vector mode.  */\n+  if (loop_vinfo->suggested_unroll_factor > 1)\n+    LOOP_VINFO_VECT_FACTOR (loop_vinfo) *= loop_vinfo->suggested_unroll_factor;\n+\n   /* This is the point where we can re-start analysis with SLP forced off.  */\n start_over:\n \n@@ -2573,7 +2590,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n     return ok;\n \n   /* Check the costings of the loop make vectorizing worthwhile.  */\n-  res = vect_analyze_loop_costing (loop_vinfo);\n+  res = vect_analyze_loop_costing (loop_vinfo, suggested_unroll_factor);\n   if (res < 0)\n     {\n       ok = opt_result::failure_at (vect_location,\n@@ -2851,15 +2868,38 @@ vect_analyze_loop_1 (class loop *loop, vec_info_shared *shared,\n \n   machine_mode vector_mode = vector_modes[mode_i];\n   loop_vinfo->vector_mode = vector_mode;\n+  unsigned int suggested_unroll_factor = 1;\n \n   /* Run the main analysis.  */\n-  opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal);\n+  opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal,\n+\t\t\t\t\t&suggested_unroll_factor);\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"***** Analysis %s with vector mode %s\\n\",\n \t\t     res ? \"succeeded\" : \" failed\",\n \t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n \n+  if (!main_loop_vinfo && suggested_unroll_factor > 1)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Re-trying analysis for unrolling\"\n+\t\t\t \" with unroll factor %d.\\n\",\n+\t\t\t suggested_unroll_factor);\n+      loop_vec_info unroll_vinfo\n+\t= vect_create_loop_vinfo (loop, shared, loop_form_info, main_loop_vinfo);\n+      unroll_vinfo->vector_mode = vector_mode;\n+      unroll_vinfo->suggested_unroll_factor = suggested_unroll_factor;\n+      opt_result new_res = vect_analyze_loop_2 (unroll_vinfo, fatal, NULL);\n+      if (new_res)\n+\t{\n+\t  delete loop_vinfo;\n+\t  loop_vinfo = unroll_vinfo;\n+\t}\n+      else\n+\tdelete unroll_vinfo;\n+    }\n+\n   /* Remember the autodetected vector mode.  */\n   if (vector_mode == VOIDmode)\n     autodetected_vector_mode = loop_vinfo->vector_mode;\n@@ -3860,7 +3900,8 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n static void\n vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t\t\t\t    int *ret_min_profitable_niters,\n-\t\t\t\t    int *ret_min_profitable_estimate)\n+\t\t\t\t    int *ret_min_profitable_estimate,\n+\t\t\t\t    unsigned *suggested_unroll_factor)\n {\n   int min_profitable_iters;\n   int min_profitable_estimate;\n@@ -4227,7 +4268,22 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n   /* Complete the target-specific cost calculations.  */\n   finish_cost (loop_vinfo->vector_costs, loop_vinfo->scalar_costs,\n-\t       &vec_prologue_cost, &vec_inside_cost, &vec_epilogue_cost);\n+\t       &vec_prologue_cost, &vec_inside_cost, &vec_epilogue_cost,\n+\t       suggested_unroll_factor);\n+\n+  if (suggested_unroll_factor && *suggested_unroll_factor > 1\n+      && LOOP_VINFO_MAX_VECT_FACTOR (loop_vinfo) != MAX_VECTORIZATION_FACTOR\n+      && !known_le (LOOP_VINFO_VECT_FACTOR (loop_vinfo) *\n+\t\t    *suggested_unroll_factor,\n+\t\t    LOOP_VINFO_MAX_VECT_FACTOR (loop_vinfo)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't unroll as unrolled vectorization factor larger\"\n+\t\t\t \" than maximum vectorization factor: %d\\n\",\n+\t\t\t LOOP_VINFO_MAX_VECT_FACTOR (loop_vinfo));\n+      *suggested_unroll_factor = 1;\n+    }\n \n   vec_outside_cost = (int)(vec_prologue_cost + vec_epilogue_cost);\n \n@@ -7194,10 +7250,13 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n \n    This only works when we see both the reduction PHI and its only consumer\n    in vectorizable_reduction and there are no intermediate stmts\n-   participating.  */\n+   participating.  When unrolling we want each unrolled iteration to have its\n+   own reduction accumulator since one of the main goals of unrolling a\n+   reduction is to reduce the aggregate loop-carried latency.  */\n   if (ncopies > 1\n       && (STMT_VINFO_RELEVANT (stmt_info) <= vect_used_only_live)\n-      && reduc_chain_length == 1)\n+      && reduc_chain_length == 1\n+      && loop_vinfo->suggested_unroll_factor == 1)\n     single_defuse_cycle = true;\n \n   if (single_defuse_cycle || lane_reduc_code_p)"}, {"sha": "524c86ca02f782bead66e08f2751971ff93d8cd5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7ca1582ca60dc84cc3fc46b9cda620e2a0bed1bb", "patch": "@@ -642,6 +642,13 @@ typedef class _loop_vec_info : public vec_info {\n      about the reductions that generated them.  */\n   hash_map<tree, vect_reusable_accumulator> reusable_accumulators;\n \n+  /* The number of times that the target suggested we unroll the vector loop\n+     in order to promote more ILP.  This value will be used to re-analyze the\n+     loop for vectorization and if successful the value will be folded into\n+     vectorization_factor (and therefore exactly divides\n+     vectorization_factor).  */\n+  unsigned int suggested_unroll_factor;\n+\n   /* Maximum runtime vectorization factor, or MAX_VECTORIZATION_FACTOR\n      if there is no particular limit.  */\n   unsigned HOST_WIDE_INT max_vectorization_factor;\n@@ -1465,6 +1472,7 @@ class vector_costs\n   unsigned int epilogue_cost () const;\n   unsigned int outside_cost () const;\n   unsigned int total_cost () const;\n+  unsigned int suggested_unroll_factor () const;\n \n protected:\n   unsigned int record_stmt_cost (stmt_vec_info, vect_cost_model_location,\n@@ -1484,6 +1492,9 @@ class vector_costs\n   /* The costs of the three regions, indexed by vect_cost_model_location.  */\n   unsigned int m_costs[3];\n \n+  /* The suggested unrolling factor determined at finish_cost.  */\n+  unsigned int m_suggested_unroll_factor;\n+\n   /* True if finish_cost has been called.  */\n   bool m_finished;\n };\n@@ -1496,6 +1507,7 @@ vector_costs::vector_costs (vec_info *vinfo, bool costing_for_scalar)\n   : m_vinfo (vinfo),\n     m_costing_for_scalar (costing_for_scalar),\n     m_costs (),\n+    m_suggested_unroll_factor(1),\n     m_finished (false)\n {\n }\n@@ -1544,6 +1556,15 @@ vector_costs::total_cost () const\n   return body_cost () + outside_cost ();\n }\n \n+/* Return the suggested unroll factor.  */\n+\n+inline unsigned int\n+vector_costs::suggested_unroll_factor () const\n+{\n+  gcc_checking_assert (m_finished);\n+  return m_suggested_unroll_factor;\n+}\n+\n #define VECT_MAX_COST 1000\n \n /* The maximum number of intermediate steps required in multi-step type\n@@ -1720,12 +1741,14 @@ add_stmt_cost (vector_costs *costs, stmt_info_for_cost *i)\n static inline void\n finish_cost (vector_costs *costs, const vector_costs *scalar_costs,\n \t     unsigned *prologue_cost, unsigned *body_cost,\n-\t     unsigned *epilogue_cost)\n+\t     unsigned *epilogue_cost, unsigned *suggested_unroll_factor = NULL)\n {\n   costs->finish_cost (scalar_costs);\n   *prologue_cost = costs->prologue_cost ();\n   *body_cost = costs->body_cost ();\n   *epilogue_cost = costs->epilogue_cost ();\n+  if (suggested_unroll_factor)\n+    *suggested_unroll_factor = costs->suggested_unroll_factor ();\n }\n \n inline void"}]}