{"sha": "423284053ec51832bc4c823fb90dc41e632e37ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIzMjg0MDUzZWM1MTgzMmJjNGM4MjNmYjkwZGM0MWU2MzJlMzdhYw==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-01-28T22:44:21Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-01-29T19:07:58Z"}, "message": "c++: Fix class NTTP with template arguments [PR92948]\n\nThis PR points out an ICE with an alias template and class NTTP, but I\nfound that there are more issues.  Trouble arise when we use a\n(non-type) template parameter as an argument to the template arg list of\na template that accepts a class NTTP and a conversion to a class is\ninvolved, e.g.\n\n  struct A { A(int) { } };\n  template<A a> struct B { };\n\n  template<int X> void fn () {\n      B<X> b;\n  }\n\nNormally for such a conversion we create a TARGET_EXPR with an\nAGGR_INIT_EXPR that calls a __ct_comp with some arguments, but not in\nthis case: when converting X to type A in convert_nontype_argument we\nare in a template and the template parameter 'X' is value-dependent, and\nAGGR_INIT_EXPR don't work in templates.  So it just creates a TARGET_EXPR\nthat contains \"A::A(*this, X)\", but with that overload resolution fails:\n  error: no matching function for call to 'A::A(A*, int)'\nThat happens because finish_call_expr for a BASELINK creates a dummy\nobject, so we have 'this' twice.  I thought for the value-dependent case\nwe could use IMPLICIT_CONV_EXPR, as in the patch below.  Note that I\nonly do this when we convert to a different type than the type of the\nexpr.  The point is to avoid the call to a converting ctor.\n\nThe second issue was an ICE in tsubst_copy: when there's a conversion\nlike the above involved then\n /* Wrapper to make a C++20 template parameter object const.  */\n  op = tsubst_copy (op, args, complain, in_decl);\nmight not produce a _ZT... VAR_DECL with const type, so the assert\n  gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (op)));\nfails.  Allowing IMPLICIT_CONV_EXPR there probably makes sense.\n\nAnd since convert_nontype_argument uses value_dependent_expression_p\na lot, I used a dedicated bool to speed things up.\n\n2020-01-29  Marek Polacek  <polacek@redhat.com>\n\n\tPR c++/92948 - Fix class NTTP with template arguments.\n\t* pt.c (convert_nontype_argument): Use IMPLICIT_CONV_EXPR when\n\tconverting a value-dependent expression to a class type.\n\t(tsubst_copy) <case VIEW_CONVERT_EXPR>: Allow IMPLICIT_CONV_EXPR\n\tas the result of the tsubst_copy call.\n\n\t* g++.dg/cpp2a/nontype-class28.C: New test.\n\t* g++.dg/cpp2a/nontype-class29.C: New test.", "tree": {"sha": "31c68739d30bdd25bb42e502b72f14664e4d0a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31c68739d30bdd25bb42e502b72f14664e4d0a80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/423284053ec51832bc4c823fb90dc41e632e37ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423284053ec51832bc4c823fb90dc41e632e37ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/423284053ec51832bc4c823fb90dc41e632e37ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423284053ec51832bc4c823fb90dc41e632e37ac/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8f4febf75e9e44f847b65776d7f5f38940b3bf"}], "stats": {"total": 113, "additions": 99, "deletions": 14}, "files": [{"sha": "10ef41931258dead8d9792810b40b3f1cc3abfd7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=423284053ec51832bc4c823fb90dc41e632e37ac", "patch": "@@ -1,3 +1,11 @@\n+2020-01-29  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/92948 - Fix class NTTP with template arguments.\n+\t* pt.c (convert_nontype_argument): Use IMPLICIT_CONV_EXPR when\n+\tconverting a value-dependent expression to a class type.\n+\t(tsubst_copy) <case VIEW_CONVERT_EXPR>: Allow IMPLICIT_CONV_EXPR\n+\tas the result of the tsubst_copy call.\n+\n 2020-01-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/91118"}, {"sha": "fccf4e9545386db8d3e1e45245d0ed053c2c8ceb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=423284053ec51832bc4c823fb90dc41e632e37ac", "patch": "@@ -7074,7 +7074,8 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n   if (non_dep)\n     expr = instantiate_non_dependent_expr_internal (expr, complain);\n \n-  if (value_dependent_expression_p (expr))\n+  const bool val_dep_p = value_dependent_expression_p (expr);\n+  if (val_dep_p)\n     expr = canonicalize_expr_argument (expr, complain);\n \n   /* 14.3.2/5: The null pointer{,-to-member} conversion is applied\n@@ -7100,10 +7101,17 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t     a conversion function with a value-dependent argument, which\n \t     could invoke taking the address of a temporary representing\n \t     the result of the conversion.  */\n-\t  if (COMPOUND_LITERAL_P (expr)\n-\t      && CONSTRUCTOR_IS_DEPENDENT (expr)\n-\t      && MAYBE_CLASS_TYPE_P (expr_type)\n-\t      && TYPE_HAS_CONVERSION (expr_type))\n+\t  if (!same_type_ignoring_top_level_qualifiers_p (type, expr_type)\n+\t      && ((COMPOUND_LITERAL_P (expr)\n+\t\t   && CONSTRUCTOR_IS_DEPENDENT (expr)\n+\t\t   && MAYBE_CLASS_TYPE_P (expr_type)\n+\t\t   && TYPE_HAS_CONVERSION (expr_type))\n+\t\t  /* Similarly, converting e.g. an integer to a class\n+\t\t     involves a constructor call.  convert_like would\n+\t\t     create a TARGET_EXPR, but in a template we can't\n+\t\t     use AGGR_INIT_EXPR, and the TARGET_EXPR would lead\n+\t\t     to a bogus error.  */\n+\t\t  || (val_dep_p && MAYBE_CLASS_TYPE_P (type))))\n \t    {\n \t      expr = build1 (IMPLICIT_CONV_EXPR, type, expr);\n \t      IMPLICIT_CONV_EXPR_NONTYPE_ARG (expr) = true;\n@@ -7189,8 +7197,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n       /* Notice that there are constant expressions like '4 % 0' which\n \t do not fold into integer constants.  */\n-      if (TREE_CODE (expr) != INTEGER_CST\n-\t  && !value_dependent_expression_p (expr))\n+      if (TREE_CODE (expr) != INTEGER_CST && !val_dep_p)\n \t{\n \t  if (complain & tf_error)\n \t    {\n@@ -7265,7 +7272,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \tHere, we do not care about functions, as they are invalid anyway\n \tfor a parameter of type pointer-to-object.  */\n \n-      if (value_dependent_expression_p (expr))\n+      if (val_dep_p)\n \t/* Non-type template parameters are OK.  */\n \t;\n       else if (cxx_dialect >= cxx11 && integer_zerop (expr))\n@@ -7333,8 +7340,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t    }\n \t}\n \n-      if (TYPE_REF_OBJ_P (TREE_TYPE (expr))\n-\t  && value_dependent_expression_p (expr))\n+      if (TYPE_REF_OBJ_P (TREE_TYPE (expr)) && val_dep_p)\n \t/* OK, dependent reference.  We don't want to ask whether a DECL is\n \t   itself value-dependent, since what we want here is its address.  */;\n       else\n@@ -7412,7 +7418,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n       /* [temp.arg.nontype] bullet 1 says the pointer to member\n          expression must be a pointer-to-member constant.  */\n-      if (!value_dependent_expression_p (expr)\n+      if (!val_dep_p\n \t  && !check_valid_ptrmem_cst_expr (type, expr, complain))\n \treturn NULL_TREE;\n \n@@ -7429,7 +7435,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n     {\n       /* [temp.arg.nontype] bullet 1 says the pointer to member\n          expression must be a pointer-to-member constant.  */\n-      if (!value_dependent_expression_p (expr)\n+      if (!val_dep_p\n \t  && !check_valid_ptrmem_cst_expr (type, expr, complain))\n \treturn NULL_TREE;\n \n@@ -7452,7 +7458,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n     {\n       /* Replace the argument with a reference to the corresponding template\n \t parameter object.  */\n-      if (!value_dependent_expression_p (expr))\n+      if (!val_dep_p)\n \texpr = get_template_parm_object (expr, complain);\n       if (expr == error_mark_node)\n \treturn NULL_TREE;\n@@ -16406,7 +16412,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t}\n \t      else\n \t\t{\n-\t\t  gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (op)));\n+\t\t  gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (op))\n+\t\t\t      || (TREE_CODE (op) == IMPLICIT_CONV_EXPR\n+\t\t\t\t  && IMPLICIT_CONV_EXPR_NONTYPE_ARG (op)));\n \t\t  return op;\n \t\t}\n \t    }"}, {"sha": "a8db2cbfd661922711d948067cad3f12d5ba1720", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=423284053ec51832bc4c823fb90dc41e632e37ac", "patch": "@@ -1,3 +1,9 @@\n+2020-01-29  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/92948 - Fix class NTTP with template arguments.\n+\t* g++.dg/cpp2a/nontype-class28.C: New test.\n+\t* g++.dg/cpp2a/nontype-class29.C: New test.\n+\n 2020-01-29  Joel Hutton  <Joel.Hutton@arm.com>\n \n \tPR target/93221"}, {"sha": "80b9b4993555564703db08157bdcc815db7aa098", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class28.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class28.C?ref=423284053ec51832bc4c823fb90dc41e632e37ac", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/92948 - Fix class NTTP with template arguments.\n+// { dg-do compile { target c++2a } }\n+\n+struct A {\n+  constexpr A(int) { }\n+};\n+\n+template<A>\n+struct B {\n+  using U = unsigned;\n+};\n+\n+template<A a>\n+using U = B<a>;\n+\n+template<int X, typename Y = typename B<X>::U>\n+void foo()\n+{\n+}\n+\n+template<int X, typename Y = typename U<X>::U>\n+void foo2()\n+{\n+}\n+\n+template<typename Y = typename B<1>::U>\n+void foo3()\n+{\n+}\n+\n+void\n+g ()\n+{\n+  foo<1>();\n+  foo2<1>();\n+  foo3<>();\n+}"}, {"sha": "2d2e9690a06e67eb7b3d73dfc9e5136c8a2f21ef", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class29.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423284053ec51832bc4c823fb90dc41e632e37ac/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class29.C?ref=423284053ec51832bc4c823fb90dc41e632e37ac", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/92948 - Fix class NTTP with template arguments.\n+// { dg-do run { target c++2a } }\n+\n+struct A {\n+  int i;\n+  constexpr A(int n) : i(n) { }\n+};\n+\n+template<A a>\n+struct B {\n+  static constexpr int i = a.i;\n+};\n+\n+template<int X>\n+void foo()\n+{\n+  B<X> b;\n+  if (b.i != 42)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  foo<42>();\n+}"}]}