{"sha": "4c73896d18e03c31a811c941082a6ed94605a905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM3Mzg5NmQxOGUwM2MzMWE4MTFjOTQxMDgyYTZlZDk0NjA1YTkwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-13T06:18:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-13T06:18:15Z"}, "message": "trans-array.c (gfc_conv_descriptor_data_get): Rename from gfc_conv_descriptor_data.\n\n        * trans-array.c (gfc_conv_descriptor_data_get): Rename from\n        gfc_conv_descriptor_data.  Cast the result to the DATAPTR type.\n        (gfc_conv_descriptor_data_set, gfc_conv_descriptor_data_addr): New.\n        (gfc_trans_allocate_array_storage): Use them.\n        (gfc_array_allocate, gfc_array_deallocate): Likewise.\n        (gfc_trans_dummy_array_bias, gfc_conv_expr_descriptor): Likewise.\n        (gfc_trans_deferred_array): Likewise.\n        * trans-expr.c (gfc_conv_function_call): Likewise.\n        (gfc_trans_subcomponent_assign): Likewise.\n        (gfc_trans_pointer_assignment): Likewise.\n        * trans-intrinsic.c (gfc_conv_allocated): Likewise.\n        * trans-types.c (gfc_array_descriptor_base): New.\n        (gfc_get_element_type): Use GFC_TYPE_ARRAY_DATAPTR_TYPE.\n        (gfc_get_array_descriptor_base): Break out from ...\n        (gfc_get_array_type_bounds): ... here.  Create type variants.\n        * trans-array.h (gfc_conv_descriptor_data_get): Declare.\n        (gfc_conv_descriptor_data_set, gfc_conv_descriptor_data_addr): Declare.\n\nFrom-SVN: r100872", "tree": {"sha": "33ec9baebc91f457ac91d8a14ac4a7044925dbfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33ec9baebc91f457ac91d8a14ac4a7044925dbfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c73896d18e03c31a811c941082a6ed94605a905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c73896d18e03c31a811c941082a6ed94605a905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c73896d18e03c31a811c941082a6ed94605a905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c73896d18e03c31a811c941082a6ed94605a905/comments", "author": null, "committer": null, "parents": [{"sha": "9204496d6524abc0c2e55152ebc2ad6698006301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9204496d6524abc0c2e55152ebc2ad6698006301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9204496d6524abc0c2e55152ebc2ad6698006301"}], "stats": {"total": 284, "additions": 164, "deletions": 120}, "files": [{"sha": "4bd62d10febcf6cd8848848b3285d39ecb2ed997", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4c73896d18e03c31a811c941082a6ed94605a905", "patch": "@@ -1,3 +1,23 @@\n+2005-06-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* trans-array.c (gfc_conv_descriptor_data_get): Rename from\n+\tgfc_conv_descriptor_data.  Cast the result to the DATAPTR type.\n+\t(gfc_conv_descriptor_data_set, gfc_conv_descriptor_data_addr): New.\n+\t(gfc_trans_allocate_array_storage): Use them.\n+\t(gfc_array_allocate, gfc_array_deallocate): Likewise.\n+\t(gfc_trans_dummy_array_bias, gfc_conv_expr_descriptor): Likewise.\n+\t(gfc_trans_deferred_array): Likewise.\n+\t* trans-expr.c (gfc_conv_function_call): Likewise.\n+\t(gfc_trans_subcomponent_assign): Likewise.\n+\t(gfc_trans_pointer_assignment): Likewise.\n+\t* trans-intrinsic.c (gfc_conv_allocated): Likewise.\n+\t* trans-types.c (gfc_array_descriptor_base): New.\n+\t(gfc_get_element_type): Use GFC_TYPE_ARRAY_DATAPTR_TYPE.\n+\t(gfc_get_array_descriptor_base): Break out from ...\n+\t(gfc_get_array_type_bounds): ... here.  Create type variants.\n+\t* trans-array.h (gfc_conv_descriptor_data_get): Declare.\n+\t(gfc_conv_descriptor_data_set, gfc_conv_descriptor_data_addr): Declare.\n+\n 2005-06-11  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-expr.c (gfc_conv_variable): POINTER results don't need f2c\n@@ -7,7 +27,7 @@\n \t(gfc_return_by_reference): Always look at sym, never at sym->result.\n \n 2005-06-11  Steven G. Kargl  <kargls@comcast.net>\n-        \n+\t\n \tPR fortran/17792\n \tPR fortran/21375\n \t* trans-array.c (gfc_array_deallocate): pstat is new argument\n@@ -154,7 +174,7 @@\n \tdereference the temporary upon return.\n \n 2005-05-29  Janne Blomqvist  <jblomqvi@vipunen.hut.fi>\n-            Steven G. Kargl  <kargls@comcast.net>\n+\t    Steven G. Kargl  <kargls@comcast.net>\n   \n \tfortran/PR20846\n \t* io.c (gfc_match_inquire): Implement constraints on UNIT and FILE usage.\n@@ -171,7 +191,7 @@\n \t(gfc_check_integer_range): Chop extra bits in subnormal numbers.\n \n 2005-05-28  Jerry DeLisle   <jvdelisle@verizon.net>\n-            Steven G. Kargl  <kargls@comcast.net>\n+\t    Steven G. Kargl  <kargls@comcast.net>\n \n \t* intrinsic.texi: added documentation for BIT_SIZE, BTEST, CHAR, CEILING\n \tand CMPLX\n@@ -443,7 +463,7 @@\n \t* trans-const.c (gfc_conv_mpz_to_tree): Fix comment.\n \n 2005-04-19  Arnaud Desitter  <arnaud.desitter@ouce.ox.ac.uk>\n-            Steven G. Kargl  <kargls@comcast.net>\n+\t    Steven G. Kargl  <kargls@comcast.net>\n \n \t* invoke.texi: Update -Waliasing description\n "}, {"sha": "2060fa1787dc286ed9782170ee6544b60daf1726", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 64, "deletions": 44, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4c73896d18e03c31a811c941082a6ed94605a905", "patch": "@@ -134,22 +134,60 @@ gfc_array_dataptr_type (tree desc)\n #define LBOUND_SUBFIELD 1\n #define UBOUND_SUBFIELD 2\n \n+/* This provides READ-ONLY access to the data field.  The field itself\n+   doesn't have the proper type.  */\n+\n tree\n-gfc_conv_descriptor_data (tree desc)\n+gfc_conv_descriptor_data_get (tree desc)\n {\n-  tree field;\n-  tree type;\n+  tree field, type, t;\n \n   type = TREE_TYPE (desc);\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   field = TYPE_FIELDS (type);\n   gcc_assert (DATA_FIELD == 0);\n-  gcc_assert (field != NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == ARRAY_TYPE);\n \n-  return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = fold_convert (GFC_TYPE_ARRAY_DATAPTR_TYPE (type), t);\n+\n+  return t;\n+}\n+\n+/* This provides WRITE access to the data field.  */\n+\n+void\n+gfc_conv_descriptor_data_set (stmtblock_t *block, tree desc, tree value)\n+{\n+  tree field, type, t;\n+\n+  type = TREE_TYPE (desc);\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+\n+  field = TYPE_FIELDS (type);\n+  gcc_assert (DATA_FIELD == 0);\n+\n+  t = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  gfc_add_modify_expr (block, t, fold_convert (TREE_TYPE (field), value));\n+}\n+\n+\n+/* This provides address access to the data field.  This should only be\n+   used by array allocation, passing this on to the runtime.  */\n+\n+tree\n+gfc_conv_descriptor_data_addr (tree desc)\n+{\n+  tree field, type, t;\n+\n+  type = TREE_TYPE (desc);\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+\n+  field = TYPE_FIELDS (type);\n+  gcc_assert (DATA_FIELD == 0);\n+\n+  t = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  return gfc_build_addr_expr (NULL, t);\n }\n \n tree\n@@ -407,18 +445,14 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n   tree tmp;\n   tree args;\n   tree desc;\n-  tree data;\n   bool onstack;\n \n   desc = info->descriptor;\n-  data = gfc_conv_descriptor_data (desc);\n+  info->offset = gfc_index_zero_node;\n   if (size == NULL_TREE)\n     {\n       /* A callee allocated array.  */\n-      gfc_add_modify_expr (&loop->pre, data, convert (TREE_TYPE (data), \n-                                                      gfc_index_zero_node));\n-      info->data = data;\n-      info->offset = gfc_index_zero_node;\n+      gfc_conv_descriptor_data_set (&loop->pre, desc, null_pointer_node);\n       onstack = FALSE;\n     }\n   else\n@@ -436,11 +470,8 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \t  tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)),\n \t\t\t\t  tmp);\n \t  tmp = gfc_create_var (tmp, \"A\");\n-\t  tmp = gfc_build_addr_expr (TREE_TYPE (data), tmp);\n-\t  gfc_add_modify_expr (&loop->pre, data, tmp);\n-\t  info->data = data;\n-\t  info->offset = gfc_index_zero_node;\n-\n+\t  tmp = gfc_build_addr_expr (NULL, tmp);\n+\t  gfc_conv_descriptor_data_set (&loop->pre, desc, tmp);\n \t}\n       else\n \t{\n@@ -454,13 +485,11 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \t  else\n \t    gcc_unreachable ();\n \t  tmp = gfc_build_function_call (tmp, args);\n-\t  tmp = convert (TREE_TYPE (data), tmp);\n-\t  gfc_add_modify_expr (&loop->pre, data, tmp);\n-\n-\t  info->data = data;\n-\t  info->offset = gfc_index_zero_node;\n+\t  tmp = gfc_evaluate_now (tmp, &loop->pre);\n+\t  gfc_conv_descriptor_data_set (&loop->pre, desc, tmp);\n \t}\n     }\n+  info->data = gfc_conv_descriptor_data_get (desc);\n \n   /* The offset is zero because we create temporaries with a zero\n      lower bound.  */\n@@ -470,7 +499,8 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n   if (!onstack)\n     {\n       /* Free the temporary.  */\n-      tmp = convert (pvoid_type_node, info->data);\n+      tmp = gfc_conv_descriptor_data_get (desc);\n+      tmp = fold_convert (pvoid_type_node, tmp);\n       tmp = gfc_chainon_list (NULL_TREE, tmp);\n       tmp = gfc_build_function_call (gfor_fndecl_internal_free, tmp);\n       gfc_add_expr_to_block (&loop->post, tmp);\n@@ -1308,7 +1338,7 @@ gfc_conv_array_data (tree descriptor)\n         }\n     }\n   else\n-    return gfc_conv_descriptor_data (descriptor);\n+    return gfc_conv_descriptor_data_get (descriptor);\n }\n \n \n@@ -2749,9 +2779,8 @@ gfc_array_allocate (gfc_se * se, gfc_ref * ref, tree pstat)\n \t\t\t      lower, upper, &se->pre);\n \n   /* Allocate memory to store the data.  */\n-  tmp = gfc_conv_descriptor_data (se->expr);\n-  pointer = gfc_build_addr_expr (NULL, tmp);\n-  pointer = gfc_evaluate_now (pointer, &se->pre);\n+  tmp = gfc_conv_descriptor_data_addr (se->expr);\n+  pointer = gfc_evaluate_now (tmp, &se->pre);\n \n   if (TYPE_PRECISION (gfc_array_index_type) == 32)\n     allocate = gfor_fndecl_allocate;\n@@ -2766,8 +2795,6 @@ gfc_array_allocate (gfc_se * se, gfc_ref * ref, tree pstat)\n   tmp = gfc_build_function_call (allocate, tmp);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n-  pointer = gfc_conv_descriptor_data (se->expr);\n-  \n   tmp = gfc_conv_descriptor_offset (se->expr);\n   gfc_add_modify_expr (&se->pre, tmp, offset);\n }\n@@ -2786,10 +2813,8 @@ gfc_array_deallocate (tree descriptor, tree pstat)\n \n   gfc_start_block (&block);\n   /* Get a pointer to the data.  */\n-  tmp = gfc_conv_descriptor_data (descriptor);\n-  tmp = gfc_build_addr_expr (NULL, tmp);\n-  var = gfc_create_var (TREE_TYPE (tmp), \"ptr\");\n-  gfc_add_modify_expr (&block, var, tmp);\n+  tmp = gfc_conv_descriptor_data_addr (descriptor);\n+  var = gfc_evaluate_now (tmp, &block);\n \n   /* Parameter is the address of the data component.  */\n   tmp = gfc_chainon_list (NULL_TREE, var);\n@@ -3253,7 +3278,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   /* This is for the case where the array data is used directly without\n      calling the repack function.  */\n   if (no_repack || partial != NULL_TREE)\n-    stmt_packed = gfc_conv_descriptor_data (dumdesc);\n+    stmt_packed = gfc_conv_descriptor_data_get (dumdesc);\n   else\n     stmt_packed = NULL_TREE;\n \n@@ -3420,7 +3445,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t\n       /* Only do the cleanup if the array was repacked.  */\n       tmp = gfc_build_indirect_ref (dumdesc);\n-      tmp = gfc_conv_descriptor_data (tmp);\n+      tmp = gfc_conv_descriptor_data_get (tmp);\n       tmp = build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n       stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \n@@ -3843,10 +3868,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       tmp = gfc_build_indirect_ref (tmp);\n       tmp = gfc_build_array_ref (tmp, offset);\n       offset = gfc_build_addr_expr (gfc_array_dataptr_type (desc), tmp);\n-\n-      tmp = gfc_conv_descriptor_data (parm);\n-      gfc_add_modify_expr (&loop.pre, tmp,\n-\t\t\t   fold_convert (TREE_TYPE (tmp), offset));\n+      gfc_conv_descriptor_data_set (&loop.pre, parm, offset);\n \n       if (se->direct_byref)\n \t{\n@@ -4013,9 +4035,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   /* NULLIFY the data pointer.  */\n-  tmp = gfc_conv_descriptor_data (descriptor);\n-  gfc_add_modify_expr (&fnblock, tmp,\n-\t\t       convert (TREE_TYPE (tmp), integer_zero_node));\n+  gfc_conv_descriptor_data_set (&fnblock, descriptor, null_pointer_node);\n \n   gfc_add_expr_to_block (&fnblock, body);\n \n@@ -4028,7 +4048,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n       /* Deallocate if still allocated at the end of the procedure.  */\n       deallocate = gfc_array_deallocate (descriptor, null_pointer_node);\n \n-      tmp = gfc_conv_descriptor_data (descriptor);\n+      tmp = gfc_conv_descriptor_data_get (descriptor);\n       tmp = build2 (NE_EXPR, boolean_type_node, tmp, \n \t\t    build_int_cst (TREE_TYPE (tmp), 0));\n       tmp = build3_v (COND_EXPR, tmp, deallocate, build_empty_stmt ());"}, {"sha": "377411c4e9539a12aa6e06055bd0fc0a1c525509", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=4c73896d18e03c31a811c941082a6ed94605a905", "patch": "@@ -96,7 +96,9 @@ tree gfc_conv_array_lbound (tree, int);\n tree gfc_conv_array_ubound (tree, int);\n \n /* Build expressions for accessing components of an array descriptor.  */\n-tree gfc_conv_descriptor_data (tree);\n+tree gfc_conv_descriptor_data_get (tree);\n+void gfc_conv_descriptor_data_set (stmtblock_t *, tree, tree);\n+tree gfc_conv_descriptor_data_addr (tree);\n tree gfc_conv_descriptor_offset (tree);\n tree gfc_conv_descriptor_dtype (tree);\n tree gfc_conv_descriptor_stride (tree, tree);"}, {"sha": "4395534e0500075acc192662c7c12c2950e5f204", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=4c73896d18e03c31a811c941082a6ed94605a905", "patch": "@@ -1353,7 +1353,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  /* Check the data pointer hasn't been modified.  This would\n \t\t     happen in a function returning a pointer.  */\n-\t\t  tmp = gfc_conv_descriptor_data (info->descriptor);\n+\t\t  tmp = gfc_conv_descriptor_data_get (info->descriptor);\n \t\t  tmp = build2 (NE_EXPR, boolean_type_node, tmp, info->data);\n \t\t  gfc_trans_runtime_check (tmp, gfc_strconst_fault, &se->pre);\n \t\t}\n@@ -1714,12 +1714,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t{\n \t  /* Array pointer.  */\n \t  if (expr->expr_type == EXPR_NULL)\n-\t    {\n-\t      dest = gfc_conv_descriptor_data (dest);\n-\t      tmp = fold_convert (TREE_TYPE (se.expr),\n-\t\t\t\t  null_pointer_node);\n-\t      gfc_add_modify_expr (&block, dest, tmp);\n-\t    }\n+\t    gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n \t  else\n \t    {\n \t      rss = gfc_walk_expr (expr);\n@@ -2065,11 +2060,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_conv_expr_descriptor (&lse, expr1, lss);\n       /* Implement Nullify.  */\n       if (expr2->expr_type == EXPR_NULL)\n-        {\n-          lse.expr = gfc_conv_descriptor_data (lse.expr);\n-          rse.expr = fold_convert (TREE_TYPE (lse.expr), null_pointer_node);\n-          gfc_add_modify_expr (&block, lse.expr, rse.expr);\n-        }\n+\tgfc_conv_descriptor_data_set (&block, lse.expr, null_pointer_node);\n       else\n         {\n           lse.direct_byref = 1;"}, {"sha": "ab498efce2422a1efd5ed84114193f76e691bf24", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=4c73896d18e03c31a811c941082a6ed94605a905", "patch": "@@ -2189,7 +2189,7 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n   arg1se.descriptor_only = 1;\n   gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n \n-  tmp = gfc_conv_descriptor_data (arg1se.expr);\n+  tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n   tmp = build2 (NE_EXPR, boolean_type_node, tmp,\n \t\tfold_convert (TREE_TYPE (tmp), null_pointer_node));\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n@@ -2235,7 +2235,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           /* A pointer to an array.  */\n           arg1se.descriptor_only = 1;\n           gfc_conv_expr_lhs (&arg1se, arg1->expr);\n-          tmp2 = gfc_conv_descriptor_data (arg1se.expr);\n+          tmp2 = gfc_conv_descriptor_data_get (arg1se.expr);\n         }\n       tmp = build2 (NE_EXPR, boolean_type_node, tmp2,\n \t\t    fold_convert (TREE_TYPE (tmp2), null_pointer_node));"}, {"sha": "f0e54536b54a3436d25ed5515a30771b02957079", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 68, "deletions": 57, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c73896d18e03c31a811c941082a6ed94605a905/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=4c73896d18e03c31a811c941082a6ed94605a905", "patch": "@@ -59,6 +59,7 @@ tree gfc_charlen_type_node;\n \n static GTY(()) tree gfc_desc_dim_type;\n static GTY(()) tree gfc_max_array_element_size;\n+static GTY(()) tree gfc_array_descriptor_base[GFC_MAX_DIMENSIONS];\n \n /* Arrays for all integral and real kinds.  We'll fill this in at runtime\n    after the target has a chance to process command-line options.  */\n@@ -688,7 +689,7 @@ gfc_get_element_type (tree type)\n   else\n     {\n       gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n-      element = TREE_TYPE (TYPE_FIELDS (type));\n+      element = GFC_TYPE_ARRAY_DATAPTR_TYPE (type);\n \n       gcc_assert (TREE_CODE (element) == POINTER_TYPE);\n       element = TREE_TYPE (element);\n@@ -1095,32 +1096,75 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, int packed)\n   return type;\n }\n \n+/* Return or create the base type for an array descriptor.  */\n+\n+static tree\n+gfc_get_array_descriptor_base (int dimen)\n+{\n+  tree fat_type, fieldlist, decl, arraytype;\n+  char name[16 + GFC_RANK_DIGITS + 1];\n+\n+  gcc_assert (dimen >= 1 && dimen <= GFC_MAX_DIMENSIONS);\n+  if (gfc_array_descriptor_base[dimen - 1])\n+    return gfc_array_descriptor_base[dimen - 1];\n+\n+  /* Build the type node.  */\n+  fat_type = make_node (RECORD_TYPE);\n+\n+  sprintf (name, \"array_descriptor\" GFC_RANK_PRINTF_FORMAT, dimen);\n+  TYPE_NAME (fat_type) = get_identifier (name);\n+\n+  /* Add the data member as the first element of the descriptor.  */\n+  decl = build_decl (FIELD_DECL, get_identifier (\"data\"), ptr_type_node);\n+\n+  DECL_CONTEXT (decl) = fat_type;\n+  fieldlist = decl;\n+\n+  /* Add the base component.  */\n+  decl = build_decl (FIELD_DECL, get_identifier (\"offset\"),\n+\t\t     gfc_array_index_type);\n+  DECL_CONTEXT (decl) = fat_type;\n+  fieldlist = chainon (fieldlist, decl);\n+\n+  /* Add the dtype component.  */\n+  decl = build_decl (FIELD_DECL, get_identifier (\"dtype\"),\n+\t\t     gfc_array_index_type);\n+  DECL_CONTEXT (decl) = fat_type;\n+  fieldlist = chainon (fieldlist, decl);\n+\n+  /* Build the array type for the stride and bound components.  */\n+  arraytype =\n+    build_array_type (gfc_get_desc_dim_type (),\n+\t\t      build_range_type (gfc_array_index_type,\n+\t\t\t\t\tgfc_index_zero_node,\n+\t\t\t\t\tgfc_rank_cst[dimen - 1]));\n+\n+  decl = build_decl (FIELD_DECL, get_identifier (\"dim\"), arraytype);\n+  DECL_CONTEXT (decl) = fat_type;\n+  fieldlist = chainon (fieldlist, decl);\n+\n+  /* Finish off the type.  */\n+  TYPE_FIELDS (fat_type) = fieldlist;\n+\n+  gfc_finish_type (fat_type);\n+\n+  gfc_array_descriptor_base[dimen - 1] = fat_type;\n+  return fat_type;\n+}\n \n /* Build an array (descriptor) type with given bounds.  */\n \n tree\n gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \t\t\t   tree * ubound, int packed)\n {\n-  tree fat_type, fat_pointer_type;\n-  tree fieldlist;\n-  tree arraytype;\n-  tree decl;\n-  int n;\n   char name[8 + GFC_RANK_DIGITS + GFC_MAX_SYMBOL_LEN];\n+  tree fat_type, base_type, arraytype, lower, upper, stride, tmp;\n   const char *typename;\n-  tree lower;\n-  tree upper;\n-  tree stride;\n-  tree tmp;\n+  int n;\n \n-  /* Build the type node.  */\n-  fat_type = make_node (RECORD_TYPE);\n-  GFC_DESCRIPTOR_TYPE_P (fat_type) = 1;\n-  TYPE_LANG_SPECIFIC (fat_type) = (struct lang_type *)\n-    ggc_alloc_cleared (sizeof (struct lang_type));\n-  GFC_TYPE_ARRAY_RANK (fat_type) = dimen;\n-  GFC_TYPE_ARRAY_DTYPE (fat_type) = NULL_TREE;\n+  base_type = gfc_get_array_descriptor_base (dimen);\n+  fat_type = build_variant_type_copy (base_type);\n \n   tmp = TYPE_NAME (etype);\n   if (tmp && TREE_CODE (tmp) == TYPE_DECL)\n@@ -1129,20 +1173,22 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n     typename = IDENTIFIER_POINTER (tmp);\n   else\n     typename = \"unknown\";\n-\n   sprintf (name, \"array\" GFC_RANK_PRINTF_FORMAT \"_%.*s\", dimen,\n \t   GFC_MAX_SYMBOL_LEN, typename);\n   TYPE_NAME (fat_type) = get_identifier (name);\n-  TYPE_PACKED (fat_type) = 0;\n \n-  fat_pointer_type = build_pointer_type (fat_type);\n+  GFC_DESCRIPTOR_TYPE_P (fat_type) = 1;\n+  TYPE_LANG_SPECIFIC (fat_type) = (struct lang_type *)\n+    ggc_alloc_cleared (sizeof (struct lang_type));\n+\n+  GFC_TYPE_ARRAY_RANK (fat_type) = dimen;\n+  GFC_TYPE_ARRAY_DTYPE (fat_type) = NULL_TREE;\n \n   /* Build an array descriptor record type.  */\n   if (packed != 0)\n     stride = gfc_index_one_node;\n   else\n     stride = NULL_TREE;\n-\n   for (n = 0; n < dimen; n++)\n     {\n       GFC_TYPE_ARRAY_STRIDE (fat_type, n) = stride;\n@@ -1183,6 +1229,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \tstride = NULL_TREE;\n     }\n   GFC_TYPE_ARRAY_SIZE (fat_type) = stride;\n+\n   /* TODO: known offsets for descriptors.  */\n   GFC_TYPE_ARRAY_OFFSET (fat_type) = NULL_TREE;\n \n@@ -1193,42 +1240,6 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n   arraytype = build_pointer_type (arraytype);\n   GFC_TYPE_ARRAY_DATAPTR_TYPE (fat_type) = arraytype;\n \n-  /* The pointer to the array data.  */\n-  decl = build_decl (FIELD_DECL, get_identifier (\"data\"), arraytype);\n-\n-  DECL_CONTEXT (decl) = fat_type;\n-  /* Add the data member as the first element of the descriptor.  */\n-  fieldlist = decl;\n-\n-  /* Add the base component.  */\n-  decl = build_decl (FIELD_DECL, get_identifier (\"offset\"),\n-\t\t     gfc_array_index_type);\n-  DECL_CONTEXT (decl) = fat_type;\n-  fieldlist = chainon (fieldlist, decl);\n-\n-  /* Add the dtype component.  */\n-  decl = build_decl (FIELD_DECL, get_identifier (\"dtype\"),\n-\t\t     gfc_array_index_type);\n-  DECL_CONTEXT (decl) = fat_type;\n-  fieldlist = chainon (fieldlist, decl);\n-\n-  /* Build the array type for the stride and bound components.  */\n-  arraytype =\n-    build_array_type (gfc_get_desc_dim_type (),\n-\t\t      build_range_type (gfc_array_index_type,\n-\t\t\t\t\tgfc_index_zero_node,\n-\t\t\t\t\tgfc_rank_cst[dimen - 1]));\n-\n-  decl = build_decl (FIELD_DECL, get_identifier (\"dim\"), arraytype);\n-  DECL_CONTEXT (decl) = fat_type;\n-  DECL_INITIAL (decl) = NULL_TREE;\n-  fieldlist = chainon (fieldlist, decl);\n-\n-  /* Finish off the type.  */\n-  TYPE_FIELDS (fat_type) = fieldlist;\n-\n-  gfc_finish_type (fat_type);\n-\n   return fat_type;\n }\n \f"}]}