{"sha": "62e79a48df295e01bc3278c1f38678a397f75c0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlNzlhNDhkZjI5NWUwMWJjMzI3OGMxZjM4Njc4YTM5N2Y3NWMwYw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2014-07-21T12:24:06Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-07-21T12:24:06Z"}, "message": "re PR target/55701 (Inline some instances of memset for ARM)\n\n\tPR target/55701\n\t* config/arm/arm.md (setmem): New pattern.\n\t* config/arm/arm-protos.h (struct tune_params): New fields.\n\t(arm_gen_setmem): New prototype.\n\t* config/arm/arm.c (arm_slowmul_tune): Initialize new fields.\n\t(arm_fastmul_tune, arm_strongarm_tune, arm_xscale_tune): Ditto.\n\t(arm_9e_tune, arm_v6t2_tune, arm_cortex_tune): Ditto.\n\t(arm_cortex_a8_tune, arm_cortex_a7_tune): Ditto.\n\t(arm_cortex_a15_tune, arm_cortex_a53_tune): Ditto.\n\t(arm_cortex_a57_tune, arm_cortex_a5_tune): Ditto.\n\t(arm_cortex_a9_tune, arm_cortex_a12_tune): Ditto.\n\t(arm_v7m_tune, arm_v6m_tune, arm_fa726te_tune): Ditto.\n\t(arm_const_inline_cost): New function.\n\t(arm_block_set_max_insns): New function.\n\t(arm_block_set_non_vect_profit_p): New function.\n\t(arm_block_set_vect_profit_p): New function.\n\t(arm_block_set_unaligned_vect): New function.\n\t(arm_block_set_aligned_vect): New function.\n\t(arm_block_set_unaligned_non_vect): New function.\n\t(arm_block_set_aligned_non_vect): New function.\n\t(arm_block_set_vect, arm_gen_setmem): New functions.\n\n\t* gcc.target/arm/memset-inline-1.c: New test.\n\t* gcc.target/arm/memset-inline-2.c: New test.\n\t* gcc.target/arm/memset-inline-3.c: New test.\n\t* gcc.target/arm/memset-inline-4.c: New test.\n\t* gcc.target/arm/memset-inline-5.c: New test.\n\t* gcc.target/arm/memset-inline-6.c: New test.\n\t* gcc.target/arm/memset-inline-7.c: New test.\n\t* gcc.target/arm/memset-inline-8.c: New test.\n\t* gcc.target/arm/memset-inline-9.c: New test.\n\nFrom-SVN: r212893", "tree": {"sha": "6ebda4f953763ad5239cb59cb0f4a2495b8529d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ebda4f953763ad5239cb59cb0f4a2495b8529d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62e79a48df295e01bc3278c1f38678a397f75c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e79a48df295e01bc3278c1f38678a397f75c0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e79a48df295e01bc3278c1f38678a397f75c0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e79a48df295e01bc3278c1f38678a397f75c0c/comments", "author": null, "committer": null, "parents": [{"sha": "8cde4e713af3f47e8fe7fefaa64ba404d91efdd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cde4e713af3f47e8fe7fefaa64ba404d91efdd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cde4e713af3f47e8fe7fefaa64ba404d91efdd8"}], "stats": {"total": 1237, "additions": 1219, "deletions": 18}, "files": [{"sha": "ccc2b976fc1f2704b8f978513aa9c6c4c16e2c5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -1,3 +1,27 @@\n+2014-07-21  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR target/55701\n+\t* config/arm/arm.md (setmem): New pattern.\n+\t* config/arm/arm-protos.h (struct tune_params): New fields.\n+\t(arm_gen_setmem): New prototype.\n+\t* config/arm/arm.c (arm_slowmul_tune): Initialize new fields.\n+\t(arm_fastmul_tune, arm_strongarm_tune, arm_xscale_tune): Ditto.\n+\t(arm_9e_tune, arm_v6t2_tune, arm_cortex_tune): Ditto.\n+\t(arm_cortex_a8_tune, arm_cortex_a7_tune): Ditto.\n+\t(arm_cortex_a15_tune, arm_cortex_a53_tune): Ditto.\n+\t(arm_cortex_a57_tune, arm_cortex_a5_tune): Ditto.\n+\t(arm_cortex_a9_tune, arm_cortex_a12_tune): Ditto.\n+\t(arm_v7m_tune, arm_v6m_tune, arm_fa726te_tune): Ditto.\n+\t(arm_const_inline_cost): New function.\n+\t(arm_block_set_max_insns): New function.\n+\t(arm_block_set_non_vect_profit_p): New function.\n+\t(arm_block_set_vect_profit_p): New function.\n+\t(arm_block_set_unaligned_vect): New function.\n+\t(arm_block_set_aligned_vect): New function.\n+\t(arm_block_set_unaligned_non_vect): New function.\n+\t(arm_block_set_aligned_non_vect): New function.\n+\t(arm_block_set_vect, arm_gen_setmem): New functions.\n+\n 2014-07-21  Bin Cheng  <bin.cheng@arm.com>\n \n \t* config/arm/arm.c (output_move_neon): Handle REG explicitly."}, {"sha": "19467f6eff751fd8d6a61021c4269de7592e32be", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -278,6 +278,10 @@ struct tune_params\n   /* Prefer 32-bit encoding instead of 16-bit encoding where subset of flags\n      would be set.  */\n   bool disparage_partial_flag_setting_t16_encodings;\n+  /* Prefer to inline string operations like memset by using Neon.  */\n+  bool string_ops_prefer_neon;\n+  /* Maximum number of instructions to inline calls to memset.  */\n+  int max_insns_inline_memset;\n };\n \n extern const struct tune_params *current_tune;\n@@ -290,6 +294,7 @@ extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n #endif /* RTX_CODE */\n \n+extern bool arm_gen_setmem (rtx *);\n extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n extern bool arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n "}, {"sha": "9bff2ee74000dc4018910f63fa82aa04fffd3b59", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 575, "deletions": 18, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -1698,7 +1698,9 @@ const struct tune_params arm_slowmul_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_fastmul_tune =\n@@ -1715,7 +1717,9 @@ const struct tune_params arm_fastmul_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n /* StrongARM has early execution of branches, so a sequence that is worth\n@@ -1735,7 +1739,9 @@ const struct tune_params arm_strongarm_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_xscale_tune =\n@@ -1752,7 +1758,9 @@ const struct tune_params arm_xscale_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_9e_tune =\n@@ -1769,7 +1777,9 @@ const struct tune_params arm_9e_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_v6t2_tune =\n@@ -1786,7 +1796,9 @@ const struct tune_params arm_v6t2_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n /* Generic Cortex tuning.  Use more specific tunings if appropriate.  */\n@@ -1804,7 +1816,9 @@ const struct tune_params arm_cortex_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_cortex_a8_tune =\n@@ -1821,7 +1835,9 @@ const struct tune_params arm_cortex_a8_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_cortex_a7_tune =\n@@ -1838,7 +1854,9 @@ const struct tune_params arm_cortex_a7_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,\t\t\t/* Vectorizer costs.  */\n   false,\t\t\t\t\t/* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_cortex_a15_tune =\n@@ -1855,7 +1873,9 @@ const struct tune_params arm_cortex_a15_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  true, true                                    /* Prefer 32-bit encodings.  */\n+  true, true,                                   /* Prefer 32-bit encodings.  */\n+  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_cortex_a53_tune =\n@@ -1872,7 +1892,9 @@ const struct tune_params arm_cortex_a53_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,\t\t\t/* Vectorizer costs.  */\n   false,\t\t\t\t\t/* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_cortex_a57_tune =\n@@ -1889,7 +1911,9 @@ const struct tune_params arm_cortex_a57_tune =\n   {true, true},                                /* Prefer non short circuit.  */\n   &arm_default_vec_cost,                       /* Vectorizer costs.  */\n   false,                                       /* Prefer Neon for 64-bits bitops.  */\n-  true, true                                   /* Prefer 32-bit encodings.  */\n+  true, true,                                  /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n /* Branches can be dual-issued on Cortex-A5, so conditional execution is\n@@ -1909,7 +1933,9 @@ const struct tune_params arm_cortex_a5_tune =\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_cortex_a9_tune =\n@@ -1926,7 +1952,9 @@ const struct tune_params arm_cortex_a9_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_cortex_a12_tune =\n@@ -1943,7 +1971,9 @@ const struct tune_params arm_cortex_a12_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n /* armv7m tuning.  On Cortex-M4 cores for example, MOVW/MOVT take a single\n@@ -1967,7 +1997,9 @@ const struct tune_params arm_v7m_tune =\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n /* The arm_v6m_tune is duplicated from arm_cortex_tune, rather than\n@@ -1986,7 +2018,9 @@ const struct tune_params arm_v6m_tune =\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n const struct tune_params arm_fa726te_tune =\n@@ -2003,7 +2037,9 @@ const struct tune_params arm_fa726te_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false                                  /* Prefer 32-bit encodings.  */\n+  false, false,                                 /* Prefer 32-bit encodings.  */\n+  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n+  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n };\n \n \n@@ -16899,6 +16935,14 @@ arm_const_double_inline_cost (rtx val)\n \t\t\t      NULL_RTX, NULL_RTX, 0, 0));\n }\n \n+/* Cost of loading a SImode constant.  */\n+static inline int\n+arm_const_inline_cost (enum rtx_code code, rtx val)\n+{\n+  return arm_gen_constant (code, SImode, NULL_RTX, INTVAL (val),\n+                           NULL_RTX, NULL_RTX, 1, 0);\n+}\n+\n /* Return true if it is worthwhile to split a 64-bit constant into two\n    32-bit operations.  This is the case if optimizing for size, or\n    if we have load delay slots, or if one 32-bit part can be done with\n@@ -31521,6 +31565,519 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n \n }\n \n+/* Maximum number of instructions to set block of memory.  */\n+static int\n+arm_block_set_max_insns (void)\n+{\n+  if (optimize_function_for_size_p (cfun))\n+    return 4;\n+  else\n+    return current_tune->max_insns_inline_memset;\n+}\n+\n+/* Return TRUE if it's profitable to set block of memory for\n+   non-vectorized case.  VAL is the value to set the memory\n+   with.  LENGTH is the number of bytes to set.  ALIGN is the\n+   alignment of the destination memory in bytes.  UNALIGNED_P\n+   is TRUE if we can only set the memory with instructions\n+   meeting alignment requirements.  USE_STRD_P is TRUE if we\n+   can use strd to set the memory.  */\n+static bool\n+arm_block_set_non_vect_profit_p (rtx val,\n+\t\t\t\t unsigned HOST_WIDE_INT length,\n+\t\t\t\t unsigned HOST_WIDE_INT align,\n+\t\t\t\t bool unaligned_p, bool use_strd_p)\n+{\n+  int num = 0;\n+  /* For leftovers in bytes of 0-7, we can set the memory block using\n+     strb/strh/str with minimum instruction number.  */\n+  const int leftover[8] = {0, 1, 1, 2, 1, 2, 2, 3};\n+\n+  if (unaligned_p)\n+    {\n+      num = arm_const_inline_cost (SET, val);\n+      num += length / align + length % align;\n+    }\n+  else if (use_strd_p)\n+    {\n+      num = arm_const_double_inline_cost (val);\n+      num += (length >> 3) + leftover[length & 7];\n+    }\n+  else\n+    {\n+      num = arm_const_inline_cost (SET, val);\n+      num += (length >> 2) + leftover[length & 3];\n+    }\n+\n+  /* We may be able to combine last pair STRH/STRB into a single STR\n+     by shifting one byte back.  */\n+  if (unaligned_access && length > 3 && (length & 3) == 3)\n+    num--;\n+\n+  return (num <= arm_block_set_max_insns ());\n+}\n+\n+/* Return TRUE if it's profitable to set block of memory for\n+   vectorized case.  LENGTH is the number of bytes to set.\n+   ALIGN is the alignment of destination memory in bytes.\n+   MODE is the vector mode used to set the memory.  */\n+static bool\n+arm_block_set_vect_profit_p (unsigned HOST_WIDE_INT length,\n+\t\t\t     unsigned HOST_WIDE_INT align,\n+\t\t\t     enum machine_mode mode)\n+{\n+  int num;\n+  bool unaligned_p = ((align & 3) != 0);\n+  unsigned int nelt = GET_MODE_NUNITS (mode);\n+\n+  /* Instruction loading constant value.  */\n+  num = 1;\n+  /* Instructions storing the memory.  */\n+  num += (length + nelt - 1) / nelt;\n+  /* Instructions adjusting the address expression.  Only need to\n+     adjust address expression if it's 4 bytes aligned and bytes\n+     leftover can only be stored by mis-aligned store instruction.  */\n+  if (!unaligned_p && (length & 3) != 0)\n+    num++;\n+\n+  /* Store the first 16 bytes using vst1:v16qi for the aligned case.  */\n+  if (!unaligned_p && mode == V16QImode)\n+    num--;\n+\n+  return (num <= arm_block_set_max_insns ());\n+}\n+\n+/* Set a block of memory using vectorization instructions for the\n+   unaligned case.  We fill the first LENGTH bytes of the memory\n+   area starting from DSTBASE with byte constant VALUE.  ALIGN is\n+   the alignment requirement of memory.  Return TRUE if succeeded.  */\n+static bool\n+arm_block_set_unaligned_vect (rtx dstbase,\n+\t\t\t      unsigned HOST_WIDE_INT length,\n+\t\t\t      unsigned HOST_WIDE_INT value,\n+\t\t\t      unsigned HOST_WIDE_INT align)\n+{\n+  unsigned int i, j, nelt_v16, nelt_v8, nelt_mode;\n+  rtx dst, mem;\n+  rtx val_elt, val_vec, reg;\n+  rtx rval[MAX_VECT_LEN];\n+  rtx (*gen_func) (rtx, rtx);\n+  enum machine_mode mode;\n+  unsigned HOST_WIDE_INT v = value;\n+\n+  gcc_assert ((align & 0x3) != 0);\n+  nelt_v8 = GET_MODE_NUNITS (V8QImode);\n+  nelt_v16 = GET_MODE_NUNITS (V16QImode);\n+  if (length >= nelt_v16)\n+    {\n+      mode = V16QImode;\n+      gen_func = gen_movmisalignv16qi;\n+    }\n+  else\n+    {\n+      mode = V8QImode;\n+      gen_func = gen_movmisalignv8qi;\n+    }\n+  nelt_mode = GET_MODE_NUNITS (mode);\n+  gcc_assert (length >= nelt_mode);\n+  /* Skip if it isn't profitable.  */\n+  if (!arm_block_set_vect_profit_p (length, align, mode))\n+    return false;\n+\n+  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n+  mem = adjust_automodify_address (dstbase, mode, dst, 0);\n+\n+  v = sext_hwi (v, BITS_PER_WORD);\n+  val_elt = GEN_INT (v);\n+  for (j = 0; j < nelt_mode; j++)\n+    rval[j] = val_elt;\n+\n+  reg = gen_reg_rtx (mode);\n+  val_vec = gen_rtx_CONST_VECTOR (mode, gen_rtvec_v (nelt_mode, rval));\n+  /* Emit instruction loading the constant value.  */\n+  emit_move_insn (reg, val_vec);\n+\n+  /* Handle nelt_mode bytes in a vector.  */\n+  for (i = 0; (i + nelt_mode <= length); i += nelt_mode)\n+    {\n+      emit_insn ((*gen_func) (mem, reg));\n+      if (i + 2 * nelt_mode <= length)\n+\temit_insn (gen_add2_insn (dst, GEN_INT (nelt_mode)));\n+    }\n+\n+  /* If there are not less than nelt_v8 bytes leftover, we must be in\n+     V16QI mode.  */\n+  gcc_assert ((i + nelt_v8) > length || mode == V16QImode);\n+\n+  /* Handle (8, 16) bytes leftover.  */\n+  if (i + nelt_v8 < length)\n+    {\n+      emit_insn (gen_add2_insn (dst, GEN_INT (length - i)));\n+      /* We are shifting bytes back, set the alignment accordingly.  */\n+      if ((length & 1) != 0 && align >= 2)\n+\tset_mem_align (mem, BITS_PER_UNIT);\n+\n+      emit_insn (gen_movmisalignv16qi (mem, reg));\n+    }\n+  /* Handle (0, 8] bytes leftover.  */\n+  else if (i < length && i + nelt_v8 >= length)\n+    {\n+      if (mode == V16QImode)\n+\t{\n+\t  reg = gen_lowpart (V8QImode, reg);\n+\t  mem = adjust_automodify_address (dstbase, V8QImode, dst, 0);\n+\t}\n+      emit_insn (gen_add2_insn (dst, GEN_INT ((length - i)\n+\t\t\t\t\t      + (nelt_mode - nelt_v8))));\n+      /* We are shifting bytes back, set the alignment accordingly.  */\n+      if ((length & 1) != 0 && align >= 2)\n+\tset_mem_align (mem, BITS_PER_UNIT);\n+\n+      emit_insn (gen_movmisalignv8qi (mem, reg));\n+    }\n+\n+  return true;\n+}\n+\n+/* Set a block of memory using vectorization instructions for the\n+   aligned case.  We fill the first LENGTH bytes of the memory area\n+   starting from DSTBASE with byte constant VALUE.  ALIGN is the\n+   alignment requirement of memory.  Return TRUE if succeeded.  */\n+static bool\n+arm_block_set_aligned_vect (rtx dstbase,\n+\t\t\t    unsigned HOST_WIDE_INT length,\n+\t\t\t    unsigned HOST_WIDE_INT value,\n+\t\t\t    unsigned HOST_WIDE_INT align)\n+{\n+  unsigned int i, j, nelt_v8, nelt_v16, nelt_mode;\n+  rtx dst, addr, mem;\n+  rtx val_elt, val_vec, reg;\n+  rtx rval[MAX_VECT_LEN];\n+  enum machine_mode mode;\n+  unsigned HOST_WIDE_INT v = value;\n+\n+  gcc_assert ((align & 0x3) == 0);\n+  nelt_v8 = GET_MODE_NUNITS (V8QImode);\n+  nelt_v16 = GET_MODE_NUNITS (V16QImode);\n+  if (length >= nelt_v16 && unaligned_access && !BYTES_BIG_ENDIAN)\n+    mode = V16QImode;\n+  else\n+    mode = V8QImode;\n+\n+  nelt_mode = GET_MODE_NUNITS (mode);\n+  gcc_assert (length >= nelt_mode);\n+  /* Skip if it isn't profitable.  */\n+  if (!arm_block_set_vect_profit_p (length, align, mode))\n+    return false;\n+\n+  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n+\n+  v = sext_hwi (v, BITS_PER_WORD);\n+  val_elt = GEN_INT (v);\n+  for (j = 0; j < nelt_mode; j++)\n+    rval[j] = val_elt;\n+\n+  reg = gen_reg_rtx (mode);\n+  val_vec = gen_rtx_CONST_VECTOR (mode, gen_rtvec_v (nelt_mode, rval));\n+  /* Emit instruction loading the constant value.  */\n+  emit_move_insn (reg, val_vec);\n+\n+  i = 0;\n+  /* Handle first 16 bytes specially using vst1:v16qi instruction.  */\n+  if (mode == V16QImode)\n+    {\n+      mem = adjust_automodify_address (dstbase, mode, dst, 0);\n+      emit_insn (gen_movmisalignv16qi (mem, reg));\n+      i += nelt_mode;\n+      /* Handle (8, 16) bytes leftover using vst1:v16qi again.  */\n+      if (i + nelt_v8 < length && i + nelt_v16 > length)\n+\t{\n+\t  emit_insn (gen_add2_insn (dst, GEN_INT (length - nelt_mode)));\n+\t  mem = adjust_automodify_address (dstbase, mode, dst, 0);\n+\t  /* We are shifting bytes back, set the alignment accordingly.  */\n+\t  if ((length & 0x3) == 0)\n+\t    set_mem_align (mem, BITS_PER_UNIT * 4);\n+\t  else if ((length & 0x1) == 0)\n+\t    set_mem_align (mem, BITS_PER_UNIT * 2);\n+\t  else\n+\t    set_mem_align (mem, BITS_PER_UNIT);\n+\n+\t  emit_insn (gen_movmisalignv16qi (mem, reg));\n+\t  return true;\n+\t}\n+      /* Fall through for bytes leftover.  */\n+      mode = V8QImode;\n+      nelt_mode = GET_MODE_NUNITS (mode);\n+      reg = gen_lowpart (V8QImode, reg);\n+    }\n+\n+  /* Handle 8 bytes in a vector.  */\n+  for (; (i + nelt_mode <= length); i += nelt_mode)\n+    {\n+      addr = plus_constant (Pmode, dst, i);\n+      mem = adjust_automodify_address (dstbase, mode, addr, i);\n+      emit_move_insn (mem, reg);\n+    }\n+\n+  /* Handle single word leftover by shifting 4 bytes back.  We can\n+     use aligned access for this case.  */\n+  if (i + UNITS_PER_WORD == length)\n+    {\n+      addr = plus_constant (Pmode, dst, i - UNITS_PER_WORD);\n+      mem = adjust_automodify_address (dstbase, mode,\n+\t\t\t\t       addr, i - UNITS_PER_WORD);\n+      /* We are shifting 4 bytes back, set the alignment accordingly.  */\n+      if (align > UNITS_PER_WORD)\n+\tset_mem_align (mem, BITS_PER_UNIT * UNITS_PER_WORD);\n+\n+      emit_move_insn (mem, reg);\n+    }\n+  /* Handle (0, 4), (4, 8) bytes leftover by shifting bytes back.\n+     We have to use unaligned access for this case.  */\n+  else if (i < length)\n+    {\n+      emit_insn (gen_add2_insn (dst, GEN_INT (length - nelt_mode)));\n+      mem = adjust_automodify_address (dstbase, mode, dst, 0);\n+      /* We are shifting bytes back, set the alignment accordingly.  */\n+      if ((length & 1) == 0)\n+\tset_mem_align (mem, BITS_PER_UNIT * 2);\n+      else\n+\tset_mem_align (mem, BITS_PER_UNIT);\n+\n+      emit_insn (gen_movmisalignv8qi (mem, reg));\n+    }\n+\n+  return true;\n+}\n+\n+/* Set a block of memory using plain strh/strb instructions, only\n+   using instructions allowed by ALIGN on processor.  We fill the\n+   first LENGTH bytes of the memory area starting from DSTBASE\n+   with byte constant VALUE.  ALIGN is the alignment requirement\n+   of memory.  */\n+static bool\n+arm_block_set_unaligned_non_vect (rtx dstbase,\n+\t\t\t\t  unsigned HOST_WIDE_INT length,\n+\t\t\t\t  unsigned HOST_WIDE_INT value,\n+\t\t\t\t  unsigned HOST_WIDE_INT align)\n+{\n+  unsigned int i;\n+  rtx dst, addr, mem;\n+  rtx val_exp, val_reg, reg;\n+  enum machine_mode mode;\n+  HOST_WIDE_INT v = value;\n+\n+  gcc_assert (align == 1 || align == 2);\n+\n+  if (align == 2)\n+    v |= (value << BITS_PER_UNIT);\n+\n+  v = sext_hwi (v, BITS_PER_WORD);\n+  val_exp = GEN_INT (v);\n+  /* Skip if it isn't profitable.  */\n+  if (!arm_block_set_non_vect_profit_p (val_exp, length,\n+\t\t\t\t\talign, true, false))\n+    return false;\n+\n+  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n+  mode = (align == 2 ? HImode : QImode);\n+  val_reg = force_reg (SImode, val_exp);\n+  reg = gen_lowpart (mode, val_reg);\n+\n+  for (i = 0; (i + GET_MODE_SIZE (mode) <= length); i += GET_MODE_SIZE (mode))\n+    {\n+      addr = plus_constant (Pmode, dst, i);\n+      mem = adjust_automodify_address (dstbase, mode, addr, i);\n+      emit_move_insn (mem, reg);\n+    }\n+\n+  /* Handle single byte leftover.  */\n+  if (i + 1 == length)\n+    {\n+      reg = gen_lowpart (QImode, val_reg);\n+      addr = plus_constant (Pmode, dst, i);\n+      mem = adjust_automodify_address (dstbase, QImode, addr, i);\n+      emit_move_insn (mem, reg);\n+      i++;\n+    }\n+\n+  gcc_assert (i == length);\n+  return true;\n+}\n+\n+/* Set a block of memory using plain strd/str/strh/strb instructions,\n+   to permit unaligned copies on processors which support unaligned\n+   semantics for those instructions.  We fill the first LENGTH bytes\n+   of the memory area starting from DSTBASE with byte constant VALUE.\n+   ALIGN is the alignment requirement of memory.  */\n+static bool\n+arm_block_set_aligned_non_vect (rtx dstbase,\n+\t\t\t\tunsigned HOST_WIDE_INT length,\n+\t\t\t\tunsigned HOST_WIDE_INT value,\n+\t\t\t\tunsigned HOST_WIDE_INT align)\n+{\n+  unsigned int i;\n+  rtx dst, addr, mem;\n+  rtx val_exp, val_reg, reg;\n+  unsigned HOST_WIDE_INT v;\n+  bool use_strd_p;\n+\n+  use_strd_p = (length >= 2 * UNITS_PER_WORD && (align & 3) == 0\n+\t\t&& TARGET_LDRD && current_tune->prefer_ldrd_strd);\n+\n+  v = (value | (value << 8) | (value << 16) | (value << 24));\n+  if (length < UNITS_PER_WORD)\n+    v &= (0xFFFFFFFF >> (UNITS_PER_WORD - length) * BITS_PER_UNIT);\n+\n+  if (use_strd_p)\n+    v |= (v << BITS_PER_WORD);\n+  else\n+    v = sext_hwi (v, BITS_PER_WORD);\n+\n+  val_exp = GEN_INT (v);\n+  /* Skip if it isn't profitable.  */\n+  if (!arm_block_set_non_vect_profit_p (val_exp, length,\n+\t\t\t\t\talign, false, use_strd_p))\n+    {\n+      if (!use_strd_p)\n+\treturn false;\n+\n+      /* Try without strd.  */\n+      v = (v >> BITS_PER_WORD);\n+      v = sext_hwi (v, BITS_PER_WORD);\n+      val_exp = GEN_INT (v);\n+      use_strd_p = false;\n+      if (!arm_block_set_non_vect_profit_p (val_exp, length,\n+\t\t\t\t\t    align, false, use_strd_p))\n+\treturn false;\n+    }\n+\n+  i = 0;\n+  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n+  /* Handle double words using strd if possible.  */\n+  if (use_strd_p)\n+    {\n+      val_reg = force_reg (DImode, val_exp);\n+      reg = val_reg;\n+      for (; (i + 8 <= length); i += 8)\n+\t{\n+\t  addr = plus_constant (Pmode, dst, i);\n+\t  mem = adjust_automodify_address (dstbase, DImode, addr, i);\n+\t  emit_move_insn (mem, reg);\n+\t}\n+    }\n+  else\n+    val_reg = force_reg (SImode, val_exp);\n+\n+  /* Handle words.  */\n+  reg = (use_strd_p ? gen_lowpart (SImode, val_reg) : val_reg);\n+  for (; (i + 4 <= length); i += 4)\n+    {\n+      addr = plus_constant (Pmode, dst, i);\n+      mem = adjust_automodify_address (dstbase, SImode, addr, i);\n+      if ((align & 3) == 0)\n+\temit_move_insn (mem, reg);\n+      else\n+\temit_insn (gen_unaligned_storesi (mem, reg));\n+    }\n+\n+  /* Merge last pair of STRH and STRB into a STR if possible.  */\n+  if (unaligned_access && i > 0 && (i + 3) == length)\n+    {\n+      addr = plus_constant (Pmode, dst, i - 1);\n+      mem = adjust_automodify_address (dstbase, SImode, addr, i - 1);\n+      /* We are shifting one byte back, set the alignment accordingly.  */\n+      if ((align & 1) == 0)\n+\tset_mem_align (mem, BITS_PER_UNIT);\n+\n+      /* Most likely this is an unaligned access, and we can't tell at\n+\t compilation time.  */\n+      emit_insn (gen_unaligned_storesi (mem, reg));\n+      return true;\n+    }\n+\n+  /* Handle half word leftover.  */\n+  if (i + 2 <= length)\n+    {\n+      reg = gen_lowpart (HImode, val_reg);\n+      addr = plus_constant (Pmode, dst, i);\n+      mem = adjust_automodify_address (dstbase, HImode, addr, i);\n+      if ((align & 1) == 0)\n+\temit_move_insn (mem, reg);\n+      else\n+\temit_insn (gen_unaligned_storehi (mem, reg));\n+\n+      i += 2;\n+    }\n+\n+  /* Handle single byte leftover.  */\n+  if (i + 1 == length)\n+    {\n+      reg = gen_lowpart (QImode, val_reg);\n+      addr = plus_constant (Pmode, dst, i);\n+      mem = adjust_automodify_address (dstbase, QImode, addr, i);\n+      emit_move_insn (mem, reg);\n+    }\n+\n+  return true;\n+}\n+\n+/* Set a block of memory using vectorization instructions for both\n+   aligned and unaligned cases.  We fill the first LENGTH bytes of\n+   the memory area starting from DSTBASE with byte constant VALUE.\n+   ALIGN is the alignment requirement of memory.  */\n+static bool\n+arm_block_set_vect (rtx dstbase,\n+\t\t    unsigned HOST_WIDE_INT length,\n+\t\t    unsigned HOST_WIDE_INT value,\n+\t\t    unsigned HOST_WIDE_INT align)\n+{\n+  /* Check whether we need to use unaligned store instruction.  */\n+  if (((align & 3) != 0 || (length & 3) != 0)\n+      /* Check whether unaligned store instruction is available.  */\n+      && (!unaligned_access || BYTES_BIG_ENDIAN))\n+    return false;\n+\n+  if ((align & 3) == 0)\n+    return arm_block_set_aligned_vect (dstbase, length, value, align);\n+  else\n+    return arm_block_set_unaligned_vect (dstbase, length, value, align);\n+}\n+\n+/* Expand string store operation.  Firstly we try to do that by using\n+   vectorization instructions, then try with ARM unaligned access and\n+   double-word store if profitable.  OPERANDS[0] is the destination,\n+   OPERANDS[1] is the number of bytes, operands[2] is the value to\n+   initialize the memory, OPERANDS[3] is the known alignment of the\n+   destination.  */\n+bool\n+arm_gen_setmem (rtx *operands)\n+{\n+  rtx dstbase = operands[0];\n+  unsigned HOST_WIDE_INT length;\n+  unsigned HOST_WIDE_INT value;\n+  unsigned HOST_WIDE_INT align;\n+\n+  if (!CONST_INT_P (operands[2]) || !CONST_INT_P (operands[1]))\n+    return false;\n+\n+  length = UINTVAL (operands[1]);\n+  if (length > 64)\n+    return false;\n+\n+  value = (UINTVAL (operands[2]) & 0xFF);\n+  align = UINTVAL (operands[3]);\n+  if (TARGET_NEON && length >= 8\n+      && current_tune->string_ops_prefer_neon\n+      && arm_block_set_vect (dstbase, length, value, align))\n+    return true;\n+\n+  if (!unaligned_access && (align & 3) != 0)\n+    return arm_block_set_unaligned_non_vect (dstbase, length, value, align);\n+\n+  return arm_block_set_aligned_non_vect (dstbase, length, value, align);\n+}\n+\n /* Implement the TARGET_ASAN_SHADOW_OFFSET hook.  */\n \n static unsigned HOST_WIDE_INT"}, {"sha": "0547d7b61f63cf2c36bc73a5e624cdffa3e43e73", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -6716,6 +6716,20 @@\n })\n \n \n+(define_expand \"setmemsi\"\n+  [(match_operand:BLK 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"const_int_operand\" \"\")\n+   (match_operand:SI 2 \"const_int_operand\" \"\")\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_32BIT\"\n+{\n+  if (arm_gen_setmem (operands))\n+    DONE;\n+\n+  FAIL;\n+})\n+\n+\n ;; Move a block of memory if it is word aligned and MORE than 2 words long.\n ;; We could let this apply for blocks of less than this, but it clobbers so\n ;; many registers that there is then probably a better way."}, {"sha": "b7dd1c2fb45df54b3782ed03ba62ecc6125d0197", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -1,3 +1,16 @@\n+2014-07-21  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR target/55701\n+\t* gcc.target/arm/memset-inline-1.c: New test.\n+\t* gcc.target/arm/memset-inline-2.c: New test.\n+\t* gcc.target/arm/memset-inline-3.c: New test.\n+\t* gcc.target/arm/memset-inline-4.c: New test.\n+\t* gcc.target/arm/memset-inline-5.c: New test.\n+\t* gcc.target/arm/memset-inline-6.c: New test.\n+\t* gcc.target/arm/memset-inline-7.c: New test.\n+\t* gcc.target/arm/memset-inline-8.c: New test.\n+\t* gcc.target/arm/memset-inline-9.c: New test.\n+\n 2014-07-21  Tom de Vries  <tom@codesourcery.com>\n \n \tPR target/61827"}, {"sha": "ff137b334254a46e9c707e5d6747b382cedb0fbd", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-1.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O2 -fno-inline\"  } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+short a[LEN];\n+void\n+foo (void)\n+{\n+    memset (a, -1, 14);\n+    return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  foo ();\n+  check ((signed char *)a, 14, sizeof (a), -1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { ! arm_thumb1_ok } } } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6deaffe232dadd6f3cf889abc286de77f9e9d8e8", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-2.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -Os -fno-inline\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+short a[LEN];\n+void\n+foo (void)\n+{\n+  memset (a, -1, 14);\n+  return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  foo ();\n+  check ((signed char *)a, 14, sizeof (a), -1);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-assembler \"bl?\\[ \\t\\]*memset\" { target { ! arm_neon } } } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "777639520677f668f7cfd691805c25260d52212f", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-3.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-3.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+short a[LEN];\n+void\n+foo (void)\n+{\n+    memset (a, -1, 7);\n+    return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  foo ();\n+  check ((signed char *)a, 7, sizeof (a), -1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { ! arm_thumb1_ok } } } } */\n+/* { dg-final { scan-assembler-not \"strh\" { target { ! arm_thumb1 } } } } */\n+/* { dg-final { scan-assembler-not \"strb\" { target { ! arm_thumb1 } } } } */"}, {"sha": "381a2c2099bc0a4af41d0e0e1c33db78436a0437", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-4.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-4.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n+/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n+/* { dg-add-options \"arm_neon\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+int a[LEN];\n+int b[LEN];\n+int c[LEN];\n+void\n+foo1 (void)\n+{\n+    memset (a, -1, 8);\n+    return;\n+}\n+\n+void\n+foo2 (void)\n+{\n+  memset (b, 1, 12);\n+  return;\n+}\n+\n+void\n+foo3 (void)\n+{\n+  memset (c, 1, 13);\n+  return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  int i;\n+\n+  foo1 ();\n+  check ((signed char *)a, 8, sizeof (a), -1);\n+\n+  foo2 ();\n+  check ((signed char *)b, 12, sizeof (b), 1);\n+\n+  foo3 ();\n+  check ((signed char *)c, 13, sizeof (c), 1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]+memset\" { target { ! arm_thumb1_ok } } } } */\n+/* { dg-final { scan-assembler-times \"vst1\\.8\" 1 { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { scan-assembler \"vstr\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "9107d811a94ffe9b5ec738d803bef8c2e5a4aadf", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-5.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-5.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n+/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n+/* { dg-add-options \"arm_neon\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+int a[LEN];\n+int b[LEN];\n+int c[LEN];\n+int d[LEN];\n+void\n+foo1 (void)\n+{\n+    memset (a, -1, 16);\n+    return;\n+}\n+\n+void\n+foo2 (void)\n+{\n+  memset (b, 1, 25);\n+  return;\n+}\n+\n+void\n+foo3 (void)\n+{\n+  memset (c, -1, 19);\n+  return;\n+}\n+\n+void\n+foo4 (void)\n+{\n+  memset (d, 1, 23);\n+  return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  foo1 ();\n+  check ((signed char *)a, 16, sizeof (a), -1);\n+\n+  foo2 ();\n+  check ((signed char *)b, 25, sizeof (b), 1);\n+\n+  foo3 ();\n+  check ((signed char *)c, 19, sizeof (c), -1);\n+\n+  foo4 ();\n+  check ((signed char *)d, 23, sizeof (d), 1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]+memset\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { scan-assembler \"vst1\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { scan-assembler-not \"vstr\"  { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { cleanup-saved-temps } } */\n+"}, {"sha": "fcb2e26a95da4119882a74543b73c56068e6f8c0", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-6.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-6.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n+/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n+/* { dg-add-options \"arm_neon\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+int a[LEN];\n+int b[LEN];\n+int c[LEN];\n+void\n+foo1 (void)\n+{\n+    memset (a, -1, 20);\n+    return;\n+}\n+\n+void\n+foo2 (void)\n+{\n+  memset (b, 1, 24);\n+  return;\n+}\n+\n+void\n+foo3 (void)\n+{\n+  memset (c, -1, 32);\n+  return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  foo1 ();\n+  check ((signed char *)a, 20, sizeof (a), -1);\n+\n+  foo2 ();\n+  check ((signed char *)b, 24, sizeof (b), 1);\n+\n+  foo3 ();\n+  check ((signed char *)c, 32, sizeof (c), -1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]+memset\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { scan-assembler-times \"vst1\" 3 { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { scan-assembler-times \"vstr\" 4 { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { cleanup-saved-temps } } */\n+\n+"}, {"sha": "7326c5f857cffe2d8699a1c8a154da652f8e15e1", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-7.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-7.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,171 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+short a[LEN];\n+int b[LEN];\n+\n+void\n+init (signed char *arr, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    arr[i] = 0;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+#define TEST(a,l,v)\t\t\t\\\n+\tinit ((signed char*)(a), sizeof (a));\t\t\\\n+\tmemset ((a), (v), (l));\t\t\t\t\\\n+\tcheck ((signed char *)(a), (l), sizeof (a), (v));\n+int\n+main(void)\n+{\n+  TEST (a, 1, -1);\n+  TEST (a, 2, -1);\n+  TEST (a, 3, -1);\n+  TEST (a, 4, -1);\n+  TEST (a, 5, -1);\n+  TEST (a, 6, -1);\n+  TEST (a, 7, -1);\n+  TEST (a, 8, -1);\n+  TEST (a, 9, 1);\n+  TEST (a, 10, -1);\n+  TEST (a, 11, 1);\n+  TEST (a, 12, -1);\n+  TEST (a, 13, 1);\n+  TEST (a, 14, -1);\n+  TEST (a, 15, 1);\n+  TEST (a, 16, -1);\n+  TEST (a, 17, 1);\n+  TEST (a, 18, -1);\n+  TEST (a, 19, 1);\n+  TEST (a, 20, -1);\n+  TEST (a, 21, 1);\n+  TEST (a, 22, -1);\n+  TEST (a, 23, 1);\n+  TEST (a, 24, -1);\n+  TEST (a, 25, 1);\n+  TEST (a, 26, -1);\n+  TEST (a, 27, 1);\n+  TEST (a, 28, -1);\n+  TEST (a, 29, 1);\n+  TEST (a, 30, -1);\n+  TEST (a, 31, 1);\n+  TEST (a, 32, -1);\n+  TEST (a, 33, 1);\n+  TEST (a, 34, -1);\n+  TEST (a, 35, 1);\n+  TEST (a, 36, -1);\n+  TEST (a, 37, 1);\n+  TEST (a, 38, -1);\n+  TEST (a, 39, 1);\n+  TEST (a, 40, -1);\n+  TEST (a, 41, 1);\n+  TEST (a, 42, -1);\n+  TEST (a, 43, 1);\n+  TEST (a, 44, -1);\n+  TEST (a, 45, 1);\n+  TEST (a, 46, -1);\n+  TEST (a, 47, 1);\n+  TEST (a, 48, -1);\n+  TEST (a, 49, 1);\n+  TEST (a, 50, -1);\n+  TEST (a, 51, 1);\n+  TEST (a, 52, -1);\n+  TEST (a, 53, 1);\n+  TEST (a, 54, -1);\n+  TEST (a, 55, 1);\n+  TEST (a, 56, -1);\n+  TEST (a, 57, 1);\n+  TEST (a, 58, -1);\n+  TEST (a, 59, 1);\n+  TEST (a, 60, -1);\n+  TEST (a, 61, 1);\n+  TEST (a, 62, -1);\n+  TEST (a, 63, 1);\n+  TEST (a, 64, -1);\n+\n+  TEST (b, 1, -1);\n+  TEST (b, 2, -1);\n+  TEST (b, 3, -1);\n+  TEST (b, 4, -1);\n+  TEST (b, 5, -1);\n+  TEST (b, 6, -1);\n+  TEST (b, 7, -1);\n+  TEST (b, 8, -1);\n+  TEST (b, 9, 1);\n+  TEST (b, 10, -1);\n+  TEST (b, 11, 1);\n+  TEST (b, 12, -1);\n+  TEST (b, 13, 1);\n+  TEST (b, 14, -1);\n+  TEST (b, 15, 1);\n+  TEST (b, 16, -1);\n+  TEST (b, 17, 1);\n+  TEST (b, 18, -1);\n+  TEST (b, 19, 1);\n+  TEST (b, 20, -1);\n+  TEST (b, 21, 1);\n+  TEST (b, 22, -1);\n+  TEST (b, 23, 1);\n+  TEST (b, 24, -1);\n+  TEST (b, 25, 1);\n+  TEST (b, 26, -1);\n+  TEST (b, 27, 1);\n+  TEST (b, 28, -1);\n+  TEST (b, 29, 1);\n+  TEST (b, 30, -1);\n+  TEST (b, 31, 1);\n+  TEST (b, 32, -1);\n+  TEST (b, 33, 1);\n+  TEST (b, 34, -1);\n+  TEST (b, 35, 1);\n+  TEST (b, 36, -1);\n+  TEST (b, 37, 1);\n+  TEST (b, 38, -1);\n+  TEST (b, 39, 1);\n+  TEST (b, 40, -1);\n+  TEST (b, 41, 1);\n+  TEST (b, 42, -1);\n+  TEST (b, 43, 1);\n+  TEST (b, 44, -1);\n+  TEST (b, 45, 1);\n+  TEST (b, 46, -1);\n+  TEST (b, 47, 1);\n+  TEST (b, 48, -1);\n+  TEST (b, 49, 1);\n+  TEST (b, 50, -1);\n+  TEST (b, 51, 1);\n+  TEST (b, 52, -1);\n+  TEST (b, 53, 1);\n+  TEST (b, 54, -1);\n+  TEST (b, 55, 1);\n+  TEST (b, 56, -1);\n+  TEST (b, 57, 1);\n+  TEST (b, 58, -1);\n+  TEST (b, 59, 1);\n+  TEST (b, 60, -1);\n+  TEST (b, 61, 1);\n+  TEST (b, 62, -1);\n+  TEST (b, 63, 1);\n+  TEST (b, 64, -1);\n+\n+  return 0;\n+}\n+"}, {"sha": "96c4d798e5b34e3766ce15b4587d69ebe1bbfaf7", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-8.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-8.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n+/* { dg-options \"-save-temps -O2 -fno-inline\"  } */\n+/* { dg-add-options \"arm_neon\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+short a[LEN];\n+void\n+foo (void)\n+{\n+    memset (a, -1, 14);\n+    return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  foo ();\n+  check ((signed char *)a, 14, sizeof (a), -1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { ! arm_thumb1_ok } } } } */\n+/* { dg-final { scan-assembler \"vst1\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { scan-assembler-not \"vstr\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "be9323aae51c694e6357e3c2cc717ee1154def4c", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-9.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e79a48df295e01bc3278c1f38678a397f75c0c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-9.c?ref=62e79a48df295e01bc3278c1f38678a397f75c0c", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n+/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n+/* { dg-options \"-save-temps -Os -fno-inline\" } */\n+/* { dg-add-options \"arm_neon\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define LEN (100)\n+short a[LEN];\n+void\n+foo (void)\n+{\n+  memset (a, -1, 14);\n+  return;\n+}\n+\n+void\n+check (signed char *arr, int idx, int len, int v)\n+{\n+  int i;\n+  for (i = 0; i < idx; i++)\n+    if (arr[i] != v)\n+      abort ();\n+\n+  for (i = idx; i < len; i++)\n+    if (arr[i] != 0)\n+      abort ();\n+}\n+\n+int\n+main(void)\n+{\n+  foo ();\n+  check ((signed char *)a, 14, sizeof (a), -1);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { scan-assembler \"vst1\" { target { arm_little_endian && arm_neon } } } } */\n+/* { dg-final { cleanup-saved-temps } } */"}]}