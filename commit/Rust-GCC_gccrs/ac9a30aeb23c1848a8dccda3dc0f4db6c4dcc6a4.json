{"sha": "ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5YTMwYWViMjNjMTg0OGE4ZGNjZGEzZGMwZjRkYjZjNGRjYzZhNA==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-03-25T10:28:12Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-03-25T10:28:12Z"}, "message": "ChangeLog gcc/\n2011-03-25  Kai Tietz  <ktietz@redhat.com>\n\n\t* c-typeck.c (comptypes_internal): Replace target\n\thook call of comp_type_attributes by version in tree.c file.\n\t* gimple.c (gimple_types_compatible_p_1): Likewise.\n\t* tree-ssa.c (useless_type_conversion_p): Likewise.\n\t* tree.c (build_type_attribute_qual_variant): Likewise.\n\t(attribute_value_equal): New static helper function.\n\t(comp_type_attributes): New function.\n\t(merge_attributes): Use attribute_value_equal for comparison.\n\t(attribute_list_contained): Likewise.\n\t* tree.h (comp_type_attributes): New prototype.\n\nChangeLog cp/\n2011-03-25  Kai Tietz  <ktietz@redhat.com>\n\n        * decl.c (decls_match): Replace target hook\n        call of comp_type_attributes by version in tree.c file.\n        * search.c (check_final_overrider): Likewise.\n        * typeck.c (structural_comptypes): Likewise.\n\nFrom-SVN: r171445", "tree": {"sha": "be8ddf3016bda6d36649fda53d90b6b9c806b5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be8ddf3016bda6d36649fda53d90b6b9c806b5c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/comments", "author": null, "committer": null, "parents": [{"sha": "afdac1169969fcdbe4a376244aa2f115485d917c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afdac1169969fcdbe4a376244aa2f115485d917c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afdac1169969fcdbe4a376244aa2f115485d917c"}], "stats": {"total": 145, "additions": 107, "deletions": 38}, "files": [{"sha": "ee9130e663b170e721d5ba1fe278a1e67591fe44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -1,3 +1,16 @@\n+2011-03-25  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* c-typeck.c (comptypes_internal): Replace target\n+\thook call of comp_type_attributes by version in tree.c file.\n+\t* gimple.c (gimple_types_compatible_p_1): Likewise.\n+\t* tree-ssa.c (useless_type_conversion_p): Likewise.\n+\t* tree.c (build_type_attribute_qual_variant): Likewise.\n+\t(attribute_value_equal): New static helper function.\n+\t(comp_type_attributes): New function.\n+\t(merge_attributes): Use attribute_value_equal for comparison.\n+\t(attribute_list_contained): Likewise.\n+\t* tree.h (comp_type_attributes): New prototype.\n+\n 2011-03-25  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-cfg.c (verify_gimple_assign_unary): Drop special casing"}, {"sha": "049a8af8330821d599981cab84dcc0a6e77ee854", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -1079,7 +1079,7 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n     return 1;\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n-  if (!(attrval = targetm.comp_type_attributes (t1, t2)))\n+  if (!(attrval = comp_type_attributes (t1, t2)))\n      return 0;\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */"}, {"sha": "8bf29c7a4578e9fdb5a257c568f8177379f2548e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -1,3 +1,10 @@\n+2011-03-25  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* decl.c (decls_match): Replace target hook\n+\tcall of comp_type_attributes by version in tree.c file.\n+\t* search.c (check_final_overrider): Likewise.\n+\t* typeck.c (structural_comptypes): Likewise.\n+\n 2011-03-21  Kai Tietz  <ktietz@redhat.com>\n \n \tPR target/12171"}, {"sha": "895527c2c3e48156e64cb055c396eda198009996", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -1012,8 +1012,8 @@ decls_match (tree newdecl, tree olddecl)\n \t    types_match =\n \t      compparms (p1, p2)\n \t      && (TYPE_ATTRIBUTES (TREE_TYPE (newdecl)) == NULL_TREE\n-\t          || targetm.comp_type_attributes (TREE_TYPE (newdecl),\n-\t\t\t\t\t\t   TREE_TYPE (olddecl)) != 0);\n+\t          || comp_type_attributes (TREE_TYPE (newdecl),\n+\t\t\t\t\t   TREE_TYPE (olddecl)) != 0);\n \t}\n       else\n \ttypes_match = 0;"}, {"sha": "9ec6fc31963172daf80612229beb853b3ff1e387", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -1897,7 +1897,7 @@ check_final_overrider (tree overrider, tree basefn)\n     }\n \n   /* Check for conflicting type attributes.  */\n-  if (!targetm.comp_type_attributes (over_type, base_type))\n+  if (!comp_type_attributes (over_type, base_type))\n     {\n       error (\"conflicting type attributes specified for %q+#D\", overrider);\n       error (\"  overriding %q+#D\", basefn);"}, {"sha": "a45ed2d7f044008d014fefbf5c03b9f888436436", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -1338,7 +1338,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n   /* If we get here, we know that from a target independent POV the\n      types are the same.  Make sure the target attributes are also\n      the same.  */\n-  return targetm.comp_type_attributes (t1, t2);\n+  return comp_type_attributes (t1, t2);\n }\n \n /* Return true if T1 and T2 are related as allowed by STRICT.  STRICT"}, {"sha": "7f29bd01e4053502acba900af76578c4a0e59d19", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -3615,7 +3615,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \t\t\t state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n \n-      if (!targetm.comp_type_attributes (t1, t2))\n+      if (!comp_type_attributes (t1, t2))\n \tgoto different_types;\n \n       if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))"}, {"sha": "05eb2a22e2eca30f30f4694f8fdcb7637d7c9183", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -1438,7 +1438,7 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n \n       /* Defer to the target if necessary.  */\n       if (TYPE_ATTRIBUTES (inner_type) || TYPE_ATTRIBUTES (outer_type))\n-\treturn targetm.comp_type_attributes (outer_type, inner_type) != 0;\n+\treturn comp_type_attributes (outer_type, inner_type) != 0;\n \n       return true;\n     }"}, {"sha": "ef6a812ddf01db7ef808d21eb431e384c4da18ac", "filename": "gcc/tree.c", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -4287,7 +4287,7 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n \t its canonical type, we will need to use structural equality\n \t checks for this type. */\n       if (TYPE_STRUCTURAL_EQUALITY_P (ttype)\n-          || !targetm.comp_type_attributes (ntype, ttype))\n+          || !comp_type_attributes (ntype, ttype))\n \tSET_TYPE_STRUCTURAL_EQUALITY (ntype);\n       else if (TYPE_CANONICAL (ntype) == ntype)\n \tTYPE_CANONICAL (ntype) = TYPE_CANONICAL (ttype);\n@@ -4300,6 +4300,75 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n   return ttype;\n }\n \n+/* Compare two attributes for their value identity.  Return true if the\n+   attribute values are known to be equal; otherwise return false.\n+*/\n+\n+static bool\n+attribute_value_equal (const_tree attr1, const_tree attr2)\n+{\n+  if (TREE_VALUE (attr1) == TREE_VALUE (attr2))\n+    return true;\n+\n+  if (TREE_VALUE (attr1) != NULL_TREE\n+      && TREE_CODE (TREE_VALUE (attr1)) == TREE_LIST\n+      && TREE_VALUE (attr2) != NULL\n+      && TREE_CODE (TREE_VALUE (attr2)) == TREE_LIST)\n+    return (simple_cst_list_equal (TREE_VALUE (attr1),\n+\t\t\t\t   TREE_VALUE (attr2)) == 1);\n+\n+  return (simple_cst_equal (TREE_VALUE (attr1), TREE_VALUE (attr2)) == 1);\n+}\n+\n+/* Return 0 if the attributes for two types are incompatible, 1 if they\n+   are compatible, and 2 if they are nearly compatible (which causes a\n+   warning to be generated).  */\n+int\n+comp_type_attributes (const_tree type1, const_tree type2)\n+{\n+  const_tree a1 = TYPE_ATTRIBUTES (type1);\n+  const_tree a2 = TYPE_ATTRIBUTES (type2);\n+  const_tree a;\n+\n+  if (a1 == a2)\n+    return 1;\n+  for (a = a1; a != NULL_TREE; a = TREE_CHAIN (a))\n+    {\n+      const struct attribute_spec *as;\n+      const_tree attr;\n+\n+      as = lookup_attribute_spec (TREE_PURPOSE (a));\n+      if (!as || as->affects_type_identity == false)\n+        continue;\n+\n+      attr = lookup_attribute (as->name, CONST_CAST_TREE (a2));\n+      if (!attr || !attribute_value_equal (a, attr))\n+        break;\n+    }\n+  if (!a)\n+    {\n+      for (a = a2; a != NULL_TREE; a = TREE_CHAIN (a))\n+\t{\n+\t  const struct attribute_spec *as;\n+\n+\t  as = lookup_attribute_spec (TREE_PURPOSE (a));\n+\t  if (!as || as->affects_type_identity == false)\n+\t    continue;\n+\n+\t  if (!lookup_attribute (as->name, CONST_CAST_TREE (a1)))\n+\t    break;\n+\t  /* We don't need to compare trees again, as we did this\n+\t     already in first loop.  */\n+\t}\n+      /* All types - affecting identity - are equal, so\n+         there is no need to call target hook for comparison.  */\n+      if (!a)\n+        return 1;\n+    }\n+  /* As some type combinations - like default calling-convention - might\n+     be compatible, we have to call the target hook to get the final result.  */\n+  return targetm.comp_type_attributes (type1, type2);\n+}\n \n /* Return a type like TTYPE except that its TYPE_ATTRIBUTE\n    is ATTRIBUTE.\n@@ -5300,23 +5369,10 @@ merge_attributes (tree a1, tree a2)\n \t      tree a;\n \t      for (a = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n \t\t\t\t\t attributes);\n-\t\t   a != NULL_TREE;\n+\t\t   a != NULL_TREE && !attribute_value_equal (a, a2);\n \t\t   a = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n \t\t\t\t\t TREE_CHAIN (a)))\n-\t\t{\n-\t\t  if (TREE_VALUE (a) != NULL\n-\t\t      && TREE_CODE (TREE_VALUE (a)) == TREE_LIST\n-\t\t      && TREE_VALUE (a2) != NULL\n-\t\t      && TREE_CODE (TREE_VALUE (a2)) == TREE_LIST)\n-\t\t    {\n-\t\t      if (simple_cst_list_equal (TREE_VALUE (a),\n-\t\t\t\t\t\t TREE_VALUE (a2)) == 1)\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  else if (simple_cst_equal (TREE_VALUE (a),\n-\t\t\t\t\t     TREE_VALUE (a2)) == 1)\n-\t\t    break;\n-\t\t}\n+\t\t;\n \t      if (a == NULL_TREE)\n \t\t{\n \t\t  a1 = copy_node (a2);\n@@ -6254,24 +6310,12 @@ attribute_list_contained (const_tree l1, const_tree l2)\n \t const_tree.  */\n       for (attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n \t\t\t\t    CONST_CAST_TREE(l1));\n-\t   attr != NULL_TREE;\n+\t   attr != NULL_TREE && !attribute_value_equal (t2, attr);\n \t   attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n \t\t\t\t    TREE_CHAIN (attr)))\n-\t{\n-\t  if (TREE_VALUE (t2) != NULL\n-\t      && TREE_CODE (TREE_VALUE (t2)) == TREE_LIST\n-\t      && TREE_VALUE (attr) != NULL\n-\t      && TREE_CODE (TREE_VALUE (attr)) == TREE_LIST)\n-\t    {\n-\t      if (simple_cst_list_equal (TREE_VALUE (t2),\n-\t\t\t\t\t TREE_VALUE (attr)) == 1)\n-\t\tbreak;\n-\t    }\n-\t  else if (simple_cst_equal (TREE_VALUE (t2), TREE_VALUE (attr)) == 1)\n-\t    break;\n-\t}\n+\t;\n \n-      if (attr == 0)\n+      if (attr == NULL_TREE)\n \treturn 0;\n     }\n "}, {"sha": "9a288cb69ac100bde2a365c14c0dab5a1ebd9543", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ac9a30aeb23c1848a8dccda3dc0f4db6c4dcc6a4", "patch": "@@ -4286,6 +4286,11 @@ extern tree build_type_attribute_variant (tree, tree);\n extern tree build_decl_attribute_variant (tree, tree);\n extern tree build_type_attribute_qual_variant (tree, tree, int);\n \n+/* Return 0 if the attributes for two types are incompatible, 1 if they\n+   are compatible, and 2 if they are nearly compatible (which causes a\n+   warning to be generated).  */\n+extern int comp_type_attributes (const_tree, const_tree);\n+\n /* Structure describing an attribute and a function to handle it.  */\n struct attribute_spec\n {"}]}