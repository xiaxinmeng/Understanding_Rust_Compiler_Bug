{"sha": "84756fd40adc5ceb732dccc84056e08d3ef0186d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ3NTZmZDQwYWRjNWNlYjczMmRjY2M4NDA1NmUwOGQzZWYwMTg2ZA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2011-10-25T08:58:54Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-10-25T08:58:54Z"}, "message": "Support expansion of reserved locations wrapped in virtual locations\n\nlibcpp/\n\n\t* include/line-map.h (linemap_expand_location): Take a line table\n\tparameter.  Update comment.\n\t(linemap_resolve_location): Update comment.\n\t(linemap_expand_location_full): Remove.\n\t* line-map.c (linemap_resolve_location):  Handle reserved\n\tlocations; return a NULL map in those cases.\n\t(linemap_expand_location): If location is reserved, return a\n\tzeroed expanded location.  Update comment.  Take a line table to\n\tassert that the function takes non-virtual locations only.\n\t(linemap_expand_location_full): remove.\n\t(linemap_dump_location): Handle the fact that\n\tlinemap_resolve_location can return NULL line maps when the\n\tlocation resolves to a reserved location.\n\ngcc/\n\t* input.c (expand_location): Rewrite using\n\tlinemap_resolve_location and linemap_expand_location.  Add a\n\tcomment.\n\nFrom-SVN: r180426", "tree": {"sha": "9772bc60a136c3ea7e6977711cf51d5fb4469798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9772bc60a136c3ea7e6977711cf51d5fb4469798"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84756fd40adc5ceb732dccc84056e08d3ef0186d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84756fd40adc5ceb732dccc84056e08d3ef0186d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84756fd40adc5ceb732dccc84056e08d3ef0186d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84756fd40adc5ceb732dccc84056e08d3ef0186d/comments", "author": null, "committer": null, "parents": [{"sha": "ae5f5715d62c096065139a40cc91e4acfc070c8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae5f5715d62c096065139a40cc91e4acfc070c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae5f5715d62c096065139a40cc91e4acfc070c8c"}], "stats": {"total": 175, "additions": 111, "deletions": 64}, "files": [{"sha": "1788d6af8885f39950cb81af269bde1f772d181a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84756fd40adc5ceb732dccc84056e08d3ef0186d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84756fd40adc5ceb732dccc84056e08d3ef0186d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84756fd40adc5ceb732dccc84056e08d3ef0186d", "patch": "@@ -1,3 +1,9 @@\n+2011-10-24  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* input.c (expand_location): Rewrite using\n+\tlinemap_resolve_location and linemap_expand_location.  Add a\n+\tcomment.\n+\n 2011-10-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/50596"}, {"sha": "4077f9e5dbdff9d316a3dc1069594de4a0d499dc", "filename": "gcc/input.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84756fd40adc5ceb732dccc84056e08d3ef0186d/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84756fd40adc5ceb732dccc84056e08d3ef0186d/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=84756fd40adc5ceb732dccc84056e08d3ef0186d", "patch": "@@ -30,20 +30,23 @@ location_t input_location;\n \n struct line_maps *line_table;\n \n+/* Expand the source location LOC into a human readable location.  If\n+   LOC resolves to a builtin location, the file name of the readable\n+   location is set to the string \"<built-in>\".  */\n+\n expanded_location\n expand_location (source_location loc)\n {\n   expanded_location xloc;\n+  const struct line_map *map;\n+\n+  loc = linemap_resolve_location (line_table, loc,\n+\t\t\t\t  LRK_SPELLING_LOCATION, &map);\n+  xloc = linemap_expand_location (line_table, map, loc);\n+\n   if (loc <= BUILTINS_LOCATION)\n-    {\n-      xloc.file = loc == UNKNOWN_LOCATION ? NULL : _(\"<built-in>\");\n-      xloc.line = 0;\n-      xloc.column = 0;\n-      xloc.sysp = 0;\n-    }\n-  else\n-    xloc = linemap_expand_location_full (line_table, loc,\n-\t\t\t\t\t LRK_SPELLING_LOCATION);\n+    xloc.file = loc == UNKNOWN_LOCATION ? NULL : _(\"<built-in>\");\n+\n   return xloc;\n }\n "}, {"sha": "d7fb84f576b9fd675451ee390677740cee05b95f", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84756fd40adc5ceb732dccc84056e08d3ef0186d/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84756fd40adc5ceb732dccc84056e08d3ef0186d/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=84756fd40adc5ceb732dccc84056e08d3ef0186d", "patch": "@@ -1,3 +1,21 @@\n+2011-10-24  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* include/line-map.h (linemap_expand_location): Take a line table\n+\tparameter.  Update comment.\n+\t(linemap_resolve_location): Update comment.\n+\t(linemap_expand_location_full): Remove.\n+\t* line-map.c (linemap_resolve_location):  Handle reserved\n+\tlocations; return a NULL map in those cases.\n+\t(linemap_expand_location): If location is reserved, return a\n+\tzeroed expanded location.  Update comment.  Take a line table to\n+\tassert that the function takes non-virtual locations only.\n+\t(linemap_expand_location_full): remove.\n+\t(linemap_dump_location): Handle the fact that\n+\tlinemap_resolve_location can return NULL line maps when the\n+\tlocation resolves to a reserved location.\n+\n+\t* line-map.c (linemap_macro_map_lookup): Fix logic.\n+\n 2011-10-22  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR bootstrap/50778"}, {"sha": "112bc020309b7bd2a45ac6ee0119063fff446937", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84756fd40adc5ceb732dccc84056e08d3ef0186d/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84756fd40adc5ceb732dccc84056e08d3ef0186d/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=84756fd40adc5ceb732dccc84056e08d3ef0186d", "patch": "@@ -651,7 +651,10 @@ enum location_resolution_kind\n    LRK_SPELLING_LOCATION.\n \n    If LOC_MAP is not NULL, *LOC_MAP is set to the map encoding the\n-   returned location.  */\n+   returned location.  Note that if the resturned location wasn't originally\n+   encoded by a map, the *MAP is set to NULL.  This can happen if LOC\n+   resolves to a location reserved for the client code, like\n+   UNKNOWN_LOCATION or BUILTINS_LOCATION in GCC.  */\n \n source_location linemap_resolve_location (struct line_maps *,\n \t\t\t\t\t  source_location loc,\n@@ -670,19 +673,13 @@ source_location linemap_unwind_toward_expansion (struct line_maps *,\n \t\t\t\t\t\t const struct line_map **loc_map);\n \n /* Expand source code location LOC and return a user readable source\n-   code location.  LOC must be a spelling (non-virtual) location.  */\n-\n-expanded_location linemap_expand_location (const struct line_map *,\n+   code location.  LOC must be a spelling (non-virtual) location.  If\n+   it's a location < RESERVED_LOCATION_COUNT a zeroed expanded source\n+   location is returned.  */\n+expanded_location linemap_expand_location (struct line_maps *,\n+\t\t\t\t\t   const struct line_map *,\n \t\t\t\t\t   source_location loc);\n \n-/* Expand source code location LOC and return a user readable source\n-   code location.  LOC can be a virtual location.  The LRK parameter\n-   is the same as for linemap_resolve_location.  */\n-\n-expanded_location linemap_expand_location_full (struct line_maps *,\n-\t\t\t\t\t\tsource_location loc,\n-\t\t\t\t\t\tenum location_resolution_kind lrk);\n-\n /* Statistics about maps allocation and usage as returned by\n    linemap_get_statistics.  */\n struct linemap_stats"}, {"sha": "7a1decc7501e37b77b36ab9bbc19b4c0d21ab831", "filename": "libcpp/line-map.c", "status": "modified", "additions": 66, "deletions": 43, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84756fd40adc5ceb732dccc84056e08d3ef0186d/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84756fd40adc5ceb732dccc84056e08d3ef0186d/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=84756fd40adc5ceb732dccc84056e08d3ef0186d", "patch": "@@ -755,12 +755,12 @@ linemap_location_in_system_header_p (struct line_maps *set,\n {\n   const struct line_map *map = NULL;\n \n-  if (location < RESERVED_LOCATION_COUNT)\n-    return false;\n-\n   location =\n     linemap_resolve_location (set, location, LRK_SPELLING_LOCATION, &map);\n \n+  if (location < RESERVED_LOCATION_COUNT)\n+    return false;\n+\n   return LINEMAP_SYSP (map);\n }\n \n@@ -1039,15 +1039,26 @@ linemap_macro_loc_to_exp_point (struct line_maps *set,\n    LRK_SPELLING_LOCATION.\n \n    If MAP is non-NULL, *MAP is set to the map of the resolved\n-   location.  */\n+   location.  Note that if the resturned location wasn't originally\n+   encoded by a map, the *MAP is set to NULL.  This can happen if LOC\n+   resolves to a location reserved for the client code, like\n+   UNKNOWN_LOCATION or BUILTINS_LOCATION in GCC.  */\n \n source_location\n linemap_resolve_location (struct line_maps *set,\n \t\t\t  source_location loc,\n \t\t\t  enum location_resolution_kind lrk,\n \t\t\t  const struct line_map **map)\n {\n-  linemap_assert (set && loc >= RESERVED_LOCATION_COUNT);\n+  if (loc < RESERVED_LOCATION_COUNT)\n+    {\n+      /* A reserved location wasn't encoded in a map.  Let's return a\n+\t NULL map here, just like what linemap_ordinary_map_lookup\n+\t does.  */\n+      if (map)\n+\t*map = NULL;\n+      return loc;\n+    }\n \n   switch (lrk)\n     {\n@@ -1101,37 +1112,44 @@ linemap_unwind_toward_expansion (struct line_maps *set,\n }\n \n /* Expand source code location LOC and return a user readable source\n-   code location.  LOC must be a spelling (non-virtual) location.  */\n+   code location.  LOC must be a spelling (non-virtual) location.  If\n+   it's a location < RESERVED_LOCATION_COUNT a zeroed expanded source\n+   location is returned.  */\n \n expanded_location\n-linemap_expand_location (const struct line_map *map,\n+linemap_expand_location (struct line_maps *set,\n+\t\t\t const struct line_map *map,\n \t\t\t source_location loc)\n \n {\n   expanded_location xloc;\n \n-  xloc.file = LINEMAP_FILE (map);\n-  xloc.line = SOURCE_LINE (map, loc);\n-  xloc.column = SOURCE_COLUMN (map, loc);\n-  xloc.sysp = LINEMAP_SYSP (map) != 0;\n-\n-  return xloc;\n-}\n-\n-/* Expand source code location LOC and return a user readable source\n-   code location.  LOC can be a virtual location.  The LRK parameter\n-   is the same as for linemap_resolve_location.  */\n+  memset (&xloc, 0, sizeof (xloc));\n+\n+  if (loc < RESERVED_LOCATION_COUNT)\n+    /* The location for this token wasn't generated from a line map.\n+       It was probably a location for a builtin token, chosen by some\n+       client code.  Let's not try to expand the location in that\n+       case.  */;\n+  else if (map == NULL)\n+    /* We shouldn't be getting a NULL map with a location that is not\n+       reserved by the client code.  */\n+    abort ();\n+  else\n+    {\n+      /* MAP must be an ordinary map and LOC must be non-virtual,\n+\t encoded into this map, obviously; the accessors used on MAP\n+\t below ensure it is ordinary.  Let's just assert the\n+\t non-virtualness of LOC here.  */\n+      if (linemap_location_from_macro_expansion_p (set, loc))\n+\tabort ();\n \n-expanded_location\n-linemap_expand_location_full (struct line_maps *set,\n-\t\t\t      source_location loc,\n-\t\t\t      enum location_resolution_kind lrk)\n-{\n-  const struct line_map *map;\n-  expanded_location xloc;\n+      xloc.file = LINEMAP_FILE (map);\n+      xloc.line = SOURCE_LINE (map, loc);\n+      xloc.column = SOURCE_COLUMN (map, loc);\n+      xloc.sysp = LINEMAP_SYSP (map) != 0;\n+    }\n \n-  loc = linemap_resolve_location (set, loc, lrk, &map);\n-  xloc = linemap_expand_location (map, loc);\n   return xloc;\n }\n \n@@ -1145,32 +1163,37 @@ linemap_dump_location (struct line_maps *set,\n {\n   const struct line_map *map;\n   source_location location;\n-  const char *path, *from;\n-  int l,c,s,e;\n+  const char *path = \"\", *from = \"\";\n+  int l = -1, c = -1, s = -1, e = -1;\n \n   if (loc == 0)\n     return;\n \n   location =\n     linemap_resolve_location (set, loc, LRK_MACRO_DEFINITION_LOCATION, &map);\n-  path = LINEMAP_FILE (map);\n-\n-  l = SOURCE_LINE (map, location);\n-  c = SOURCE_COLUMN (map, location);\n-  s = LINEMAP_SYSP (map) != 0;\n-  e = location != loc;\n \n-  if (e)\n-    from = \"N/A\";\n+  if (map == NULL)\n+    /* Only reserved locations can be tolerated in this case.  */\n+    linemap_assert (location < RESERVED_LOCATION_COUNT);\n   else\n-    from = (INCLUDED_FROM (set, map))\n-      ? LINEMAP_FILE (INCLUDED_FROM (set, map))\n-      : \"<NULL>\";\n+    {\n+      path = LINEMAP_FILE (map);\n+      l = SOURCE_LINE (map, location);\n+      c = SOURCE_COLUMN (map, location);\n+      s = LINEMAP_SYSP (map) != 0;\n+      e = location != loc;\n+      if (e)\n+\tfrom = \"N/A\";\n+      else\n+\tfrom = (INCLUDED_FROM (set, map))\n+\t  ? LINEMAP_FILE (INCLUDED_FROM (set, map))\n+\t  : \"<NULL>\";\n+    }\n \n   /* P: path, L: line, C: column, S: in-system-header, M: map address,\n-     E: macro expansion?.   */\n-  fprintf (stream, \"{P:%s;F:%s;L:%d;C:%d;S:%d;M:%p;E:%d,LOC:%d}\",\n-\t   path, from, l, c, s, (void*)map, e, loc);\n+     E: macro expansion?, LOC: original location, R: resolved location   */\n+  fprintf (stream, \"{P:%s;F:%s;L:%d;C:%d;S:%d;M:%p;E:%d,LOC:%d,R:%d}\",\n+\t   path, from, l, c, s, (void*)map, e, loc, location);\n }\n \n /* Compute and return statistics about the memory consumption of some"}]}