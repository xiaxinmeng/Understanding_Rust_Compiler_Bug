{"sha": "6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjNGE2MDQ1MDg5YWRjOWVjOWVmYmJjMDdkYjI1YzRhMjFmYzBmZg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-11-07T10:23:38Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-11-07T10:23:38Z"}, "message": "Introduce -fsanitize-address-use-after-scope\n\n\t* c-warn.c (warn_for_unused_label): Save all labels used\n\tin goto or in &label.\n\t* asan.c (enum asan_check_flags): Move the enum to header file.\n\t(asan_init_shadow_ptr_types): Make type creation more generic.\n\t(shadow_mem_size): New function.\n\t(asan_emit_stack_protection): Use newly added ASAN_SHADOW_GRANULARITY.\n\tRewritten stack unpoisoning code.\n\t(build_shadow_mem_access): Add new argument return_address.\n\t(instrument_derefs): Instrument local variables if use after scope\n\tsanitization is enabled.\n\t(asan_store_shadow_bytes): New function.\n\t(asan_expand_mark_ifn): Likewise.\n\t(asan_sanitize_stack_p): Moved from asan_sanitize_stack_p.\n\t* asan.h (enum asan_mark_flags): Moved here from asan.c\n\t(asan_protect_stack_decl): Protect all declaration that need\n\tto live in memory.\n\t(asan_sanitize_use_after_scope): New function.\n\t(asan_no_sanitize_address_p): Likewise.\n\t* cfgexpand.c (partition_stack_vars): Consider\n\tasan_sanitize_use_after_scope in condition.\n\t(expand_stack_vars): Likewise.\n\t* common.opt (-fsanitize-address-use-after-scope): New option.\n\t* doc/invoke.texi (use-after-scope-direct-emission-threshold):\n\tExplain the parameter.\n\t* flag-types.h (enum sanitize_code): Define SANITIZE_USE_AFTER_SCOPE.\n\t* gimplify.c (build_asan_poison_call_expr): New function.\n\t(asan_poison_variable): Likewise.\n\t(gimplify_bind_expr): Generate poisoning/unpoisoning for local\n\tvariables that have address taken.\n\t(gimplify_decl_expr): Likewise.\n\t(gimplify_target_expr): Likewise for C++ temporaries.\n\t(sort_by_decl_uid): New function.\n\t(gimplify_expr): Unpoison all variables for a label we can jump\n\tfrom outside of a scope.\n\t(gimplify_switch_expr): Unpoison variables defined in the switch\n\tcontext.\n\t(gimplify_function_tree): Clear asan_poisoned_variables.\n\t(asan_poison_variables): New function.\n\t(warn_switch_unreachable_r): Handle IFN_ASAN_MARK.\n\t* internal-fn.c (expand_ASAN_MARK): New function.\n\t* internal-fn.def (ASAN_MARK): Declare.\n\t* opts.c (finish_options): Handle -fstack-reuse if\n\t-fsanitize-address-use-after-scope is enabled.\n\t(common_handle_option): Enable address sanitization if\n\t-fsanitize-address-use-after-scope is enabled.\n\t* params.def (PARAM_USE_AFTER_SCOPE_DIRECT_EMISSION_THRESHOLD):\n\tNew parameter.\n\t* params.h: Likewise.\n\t* sancov.c (pass_sanopt::execute): Handle IFN_ASAN_MARK.\n\t* sanitizer.def: Define __asan_poison_stack_memory and\n\t__asan_unpoison_stack_memory functions.\n\t* asan.c (asan_mark_poison_p): New function.\n\t(transform_statements): Handle asan_mark_poison_p calls.\n\t* gimple.c (nonfreeing_call_p): Handle IFN_ASAN_MARK.\n\nFrom-SVN: r241896", "tree": {"sha": "8994878a3b2edbefb1b3d57b17318ab3eeb0db8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8994878a3b2edbefb1b3d57b17318ab3eeb0db8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2447ab8593cace422936ef8ecbe67d32fe0f83ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2447ab8593cace422936ef8ecbe67d32fe0f83ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2447ab8593cace422936ef8ecbe67d32fe0f83ca"}], "stats": {"total": 762, "additions": 663, "deletions": 99}, "files": [{"sha": "3af754fbf1062b8a8cc957702585faddd8f5a1b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -1,3 +1,58 @@\n+2016-11-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* asan.c (enum asan_check_flags): Move the enum to header file.\n+\t(asan_init_shadow_ptr_types): Make type creation more generic.\n+\t(shadow_mem_size): New function.\n+\t(asan_emit_stack_protection): Use newly added ASAN_SHADOW_GRANULARITY.\n+\tRewritten stack unpoisoning code.\n+\t(build_shadow_mem_access): Add new argument return_address.\n+\t(instrument_derefs): Instrument local variables if use after scope\n+\tsanitization is enabled.\n+\t(asan_store_shadow_bytes): New function.\n+\t(asan_expand_mark_ifn): Likewise.\n+\t(asan_sanitize_stack_p): Moved from asan_sanitize_stack_p.\n+\t* asan.h (enum asan_mark_flags): Moved here from asan.c\n+\t(asan_protect_stack_decl): Protect all declaration that need\n+\tto live in memory.\n+\t(asan_sanitize_use_after_scope): New function.\n+\t(asan_no_sanitize_address_p): Likewise.\n+\t* cfgexpand.c (partition_stack_vars): Consider\n+\tasan_sanitize_use_after_scope in condition.\n+\t(expand_stack_vars): Likewise.\n+\t* common.opt (-fsanitize-address-use-after-scope): New option.\n+\t* doc/invoke.texi (use-after-scope-direct-emission-threshold):\n+\tExplain the parameter.\n+\t* flag-types.h (enum sanitize_code): Define SANITIZE_USE_AFTER_SCOPE.\n+\t* gimplify.c (build_asan_poison_call_expr): New function.\n+\t(asan_poison_variable): Likewise.\n+\t(gimplify_bind_expr): Generate poisoning/unpoisoning for local\n+\tvariables that have address taken.\n+\t(gimplify_decl_expr): Likewise.\n+\t(gimplify_target_expr): Likewise for C++ temporaries.\n+\t(sort_by_decl_uid): New function.\n+\t(gimplify_expr): Unpoison all variables for a label we can jump\n+\tfrom outside of a scope.\n+\t(gimplify_switch_expr): Unpoison variables defined in the switch\n+\tcontext.\n+\t(gimplify_function_tree): Clear asan_poisoned_variables.\n+\t(asan_poison_variables): New function.\n+\t(warn_switch_unreachable_r): Handle IFN_ASAN_MARK.\n+\t* internal-fn.c (expand_ASAN_MARK): New function.\n+\t* internal-fn.def (ASAN_MARK): Declare.\n+\t* opts.c (finish_options): Handle -fstack-reuse if\n+\t-fsanitize-address-use-after-scope is enabled.\n+\t(common_handle_option): Enable address sanitization if\n+\t-fsanitize-address-use-after-scope is enabled.\n+\t* params.def (PARAM_USE_AFTER_SCOPE_DIRECT_EMISSION_THRESHOLD):\n+\tNew parameter.\n+\t* params.h: Likewise.\n+\t* sancov.c (pass_sanopt::execute): Handle IFN_ASAN_MARK.\n+\t* sanitizer.def: Define __asan_poison_stack_memory and\n+\t__asan_unpoison_stack_memory functions.\n+\t* asan.c (asan_mark_poison_p): New function.\n+\t(transform_statements): Handle asan_mark_poison_p calls.\n+\t* gimple.c (nonfreeing_call_p): Handle IFN_ASAN_MARK.\n+\n 2016-11-07  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR driver/78196"}, {"sha": "1e0ce8df64673b93eba3d81daf9ae6112da7078a", "filename": "gcc/asan.c", "status": "modified", "additions": 248, "deletions": 54, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -245,6 +245,22 @@ static unsigned HOST_WIDE_INT asan_shadow_offset_value;\n static bool asan_shadow_offset_computed;\n static vec<char *> sanitized_sections;\n \n+/* Return true if STMT is ASAN_MARK poisoning internal function call.  */\n+static inline bool\n+asan_mark_poison_p (gimple *stmt)\n+{\n+  return (gimple_call_internal_p (stmt, IFN_ASAN_MARK)\n+\t  && tree_to_uhwi (gimple_call_arg (stmt, 0)) == ASAN_MARK_CLOBBER);\n+\n+}\n+\n+/* Set of variable declarations that are going to be guarded by\n+   use-after-scope sanitizer.  */\n+\n+static hash_set<tree> *asan_handled_variables = NULL;\n+\n+hash_set <tree> *asan_used_labels = NULL;\n+\n /* Sets shadow offset to value in string VAL.  */\n \n bool\n@@ -287,6 +303,14 @@ set_sanitized_sections (const char *sections)\n     }\n }\n \n+bool\n+asan_sanitize_stack_p (void)\n+{\n+  return ((flag_sanitize & SANITIZE_ADDRESS)\n+\t  && ASAN_STACK\n+\t  && !asan_no_sanitize_address_p ());\n+}\n+\n /* Checks whether section SEC should be sanitized.  */\n \n static bool\n@@ -315,22 +339,13 @@ asan_shadow_offset ()\n \n alias_set_type asan_shadow_set = -1;\n \n-/* Pointer types to 1 resp. 2 byte integers in shadow memory.  A separate\n+/* Pointer types to 1, 2 or 4 byte integers in shadow memory.  A separate\n    alias set is used for all shadow memory accesses.  */\n-static GTY(()) tree shadow_ptr_types[2];\n+static GTY(()) tree shadow_ptr_types[3];\n \n /* Decl for __asan_option_detect_stack_use_after_return.  */\n static GTY(()) tree asan_detect_stack_use_after_return;\n \n-/* Various flags for Asan builtins.  */\n-enum asan_check_flags\n-{\n-  ASAN_CHECK_STORE = 1 << 0,\n-  ASAN_CHECK_SCALAR_ACCESS = 1 << 1,\n-  ASAN_CHECK_NON_ZERO_LEN = 1 << 2,\n-  ASAN_CHECK_LAST = 1 << 3\n-};\n-\n /* Hashtable support for memory references used by gimple\n    statements.  */\n \n@@ -933,12 +948,16 @@ static void\n asan_init_shadow_ptr_types (void)\n {\n   asan_shadow_set = new_alias_set ();\n-  shadow_ptr_types[0] = build_distinct_type_copy (signed_char_type_node);\n-  TYPE_ALIAS_SET (shadow_ptr_types[0]) = asan_shadow_set;\n-  shadow_ptr_types[0] = build_pointer_type (shadow_ptr_types[0]);\n-  shadow_ptr_types[1] = build_distinct_type_copy (short_integer_type_node);\n-  TYPE_ALIAS_SET (shadow_ptr_types[1]) = asan_shadow_set;\n-  shadow_ptr_types[1] = build_pointer_type (shadow_ptr_types[1]);\n+  tree types[3] = { signed_char_type_node, short_integer_type_node,\n+\t\t    integer_type_node };\n+\n+  for (unsigned i = 0; i < 3; i++)\n+    {\n+      shadow_ptr_types[i] = build_distinct_type_copy (types[i]);\n+      TYPE_ALIAS_SET (shadow_ptr_types[i]) = asan_shadow_set;\n+      shadow_ptr_types[i] = build_pointer_type (shadow_ptr_types[i]);\n+    }\n+\n   initialize_sanitizer_builtins ();\n }\n \n@@ -1022,6 +1041,15 @@ asan_function_start (void)\n \t\t\t current_function_funcdef_no);\n }\n \n+/* Return number of shadow bytes that are occupied by a local variable\n+   of SIZE bytes.  */\n+\n+static unsigned HOST_WIDE_INT\n+shadow_mem_size (unsigned HOST_WIDE_INT size)\n+{\n+  return ROUND_UP (size, ASAN_SHADOW_GRANULARITY) / ASAN_SHADOW_GRANULARITY;\n+}\n+\n /* Insert code to protect stack vars.  The prologue sequence should be emitted\n    directly, epilogue sequence returned.  BASE is the register holding the\n    stack base, against which OFFSETS array offsets are relative to, OFFSETS\n@@ -1047,7 +1075,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   HOST_WIDE_INT base_offset = offsets[length - 1];\n   HOST_WIDE_INT base_align_bias = 0, offset, prev_offset;\n   HOST_WIDE_INT asan_frame_size = offsets[0] - base_offset;\n-  HOST_WIDE_INT last_offset, last_size;\n+  HOST_WIDE_INT last_offset;\n   int l;\n   unsigned char cur_shadow_byte = ASAN_STACK_MAGIC_LEFT;\n   tree str_cst, decl, id;\n@@ -1205,10 +1233,10 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n \t\t\t\t       (aoff - prev_offset)\n \t\t\t\t       >> ASAN_SHADOW_SHIFT);\n \t  prev_offset = aoff;\n-\t  for (i = 0; i < 4; i++, aoff += (1 << ASAN_SHADOW_SHIFT))\n+\t  for (i = 0; i < 4; i++, aoff += ASAN_SHADOW_GRANULARITY)\n \t    if (aoff < offset)\n \t      {\n-\t\tif (aoff < offset - (1 << ASAN_SHADOW_SHIFT) + 1)\n+\t\tif (aoff < offset - (HOST_WIDE_INT)ASAN_SHADOW_GRANULARITY + 1)\n \t\t  shadow_bytes[i] = 0;\n \t\telse\n \t\t  shadow_bytes[i] = offset - aoff;\n@@ -1282,35 +1310,66 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   if (STRICT_ALIGNMENT)\n     set_mem_align (shadow_mem, (GET_MODE_ALIGNMENT (SImode)));\n \n-  prev_offset = base_offset;\n+  /* Unpoison shadow memory of a stack at the very end of a function.\n+     As we're poisoning stack variables at the end of their scope,\n+     shadow memory must be properly unpoisoned here.  The easiest approach\n+     would be to collect all variables that should not be unpoisoned and\n+     we unpoison shadow memory of the whole stack except ranges\n+     occupied by these variables.  */\n   last_offset = base_offset;\n-  last_size = 0;\n-  for (l = length; l; l -= 2)\n+  HOST_WIDE_INT current_offset = last_offset;\n+  if (length)\n     {\n-      offset = base_offset + ((offsets[l - 1] - base_offset)\n-\t\t\t     & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1));\n-      if (last_offset + last_size != offset)\n+      HOST_WIDE_INT var_end_offset = 0;\n+      HOST_WIDE_INT stack_start = offsets[length - 1];\n+      gcc_assert (last_offset == stack_start);\n+\n+      for (int l = length - 2; l > 0; l -= 2)\n \t{\n-\t  shadow_mem = adjust_address (shadow_mem, VOIDmode,\n-\t\t\t\t       (last_offset - prev_offset)\n-\t\t\t\t       >> ASAN_SHADOW_SHIFT);\n-\t  prev_offset = last_offset;\n-\t  asan_clear_shadow (shadow_mem, last_size >> ASAN_SHADOW_SHIFT);\n-\t  last_offset = offset;\n-\t  last_size = 0;\n+\t  HOST_WIDE_INT var_offset = offsets[l];\n+\t  current_offset = var_offset;\n+\t  var_end_offset = offsets[l - 1];\n+\t  HOST_WIDE_INT rounded_size = ROUND_UP (var_end_offset - var_offset,\n+\t\t\t\t\t     BITS_PER_UNIT);\n+\n+\t  /* Should we unpoison the variable?  */\n+\t  if (asan_handled_variables != NULL\n+\t      && asan_handled_variables->contains (decl))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  const char *n = (DECL_NAME (decl)\n+\t\t\t\t   ? IDENTIFIER_POINTER (DECL_NAME (decl))\n+\t\t\t\t   : \"<unknown>\");\n+\t\t  fprintf (dump_file, \"Unpoisoning shadow stack for variable: \"\n+\t\t\t   \"%s (%\" PRId64 \"B)\\n\", n,\n+\t\t\t   var_end_offset - var_offset);\n+\t\t}\n+\n+\t      unsigned HOST_WIDE_INT s\n+\t\t= shadow_mem_size (current_offset - last_offset);\n+\t      asan_clear_shadow (shadow_mem, s);\n+\t      HOST_WIDE_INT shift\n+\t\t= shadow_mem_size (current_offset - last_offset + rounded_size);\n+\t      shadow_mem = adjust_address (shadow_mem, VOIDmode, shift);\n+\t      last_offset = var_offset + rounded_size;\n+\t      current_offset = last_offset;\n+\t    }\n+\n \t}\n-      last_size += base_offset + ((offsets[l - 2] - base_offset)\n-\t\t\t\t  & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1))\n-\t\t   - offset;\n-    }\n-  if (last_size)\n-    {\n-      shadow_mem = adjust_address (shadow_mem, VOIDmode,\n-\t\t\t\t   (last_offset - prev_offset)\n-\t\t\t\t   >> ASAN_SHADOW_SHIFT);\n-      asan_clear_shadow (shadow_mem, last_size >> ASAN_SHADOW_SHIFT);\n+\n+      /* Handle last redzone.  */\n+      current_offset = offsets[0];\n+      asan_clear_shadow (shadow_mem,\n+\t\t\t shadow_mem_size (current_offset - last_offset));\n     }\n \n+  /* Clean-up set with instrumented stack variables.  */\n+  delete asan_handled_variables;\n+  asan_handled_variables = NULL;\n+  delete asan_used_labels;\n+  asan_used_labels = NULL;\n+\n   do_pending_stack_adjust ();\n   if (lab)\n     emit_label (lab);\n@@ -1590,12 +1649,14 @@ insert_if_then_before_iter (gcond *cond,\n   gsi_insert_after (&cond_insert_point, cond, GSI_NEW_STMT);\n }\n \n-/* Build\n-   (base_addr >> ASAN_SHADOW_SHIFT) + asan_shadow_offset ().  */\n+/* Build (base_addr >> ASAN_SHADOW_SHIFT) + asan_shadow_offset ().\n+   If RETURN_ADDRESS is set to true, return memory location instread\n+   of a value in the shadow memory.  */\n \n static tree\n build_shadow_mem_access (gimple_stmt_iterator *gsi, location_t location,\n-\t\t\t tree base_addr, tree shadow_ptr_type)\n+\t\t\t tree base_addr, tree shadow_ptr_type,\n+\t\t\t bool return_address = false)\n {\n   tree t, uintptr_type = TREE_TYPE (base_addr);\n   tree shadow_type = TREE_TYPE (shadow_ptr_type);\n@@ -1618,11 +1679,15 @@ build_shadow_mem_access (gimple_stmt_iterator *gsi, location_t location,\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n-  t = build2 (MEM_REF, shadow_type, gimple_assign_lhs (g),\n-\t      build_int_cst (shadow_ptr_type, 0));\n-  g = gimple_build_assign (make_ssa_name (shadow_type), MEM_REF, t);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+  if (!return_address)\n+    {\n+      t = build2 (MEM_REF, shadow_type, gimple_assign_lhs (g),\n+\t\t  build_int_cst (shadow_ptr_type, 0));\n+      g = gimple_build_assign (make_ssa_name (shadow_type), MEM_REF, t);\n+      gimple_set_location (g, location);\n+      gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+    }\n+\n   return gimple_assign_lhs (g);\n }\n \n@@ -1826,7 +1891,9 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \t{\n \t  /* Automatic vars in the current function will be always\n \t     accessible.  */\n-\t  if (decl_function_context (inner) == current_function_decl)\n+\t  if (decl_function_context (inner) == current_function_decl\n+\t      && (!asan_sanitize_use_after_scope ()\n+\t\t  || !TREE_ADDRESSABLE (inner)))\n \t    return;\n \t}\n       /* Always instrument external vars, they might be dynamically\n@@ -2141,8 +2208,10 @@ transform_statements (void)\n \t\t If the current instruction is a function call that\n \t\t might free something, let's forget about the memory\n \t\t references that got instrumented.  Otherwise we might\n-\t\t miss some instrumentation opportunities.  */\n-\t      if (is_gimple_call (s) && !nonfreeing_call_p (s))\n+\t\t miss some instrumentation opportunities.  Do the same\n+\t\t for a ASAN_MARK poisoning internal function.  */\n+\t      if (is_gimple_call (s)\n+\t\t  && (!nonfreeing_call_p (s) || asan_mark_poison_p (s)))\n \t\tempty_mem_ref_hash_table ();\n \n \t      gsi_next (&i);\n@@ -2576,6 +2645,131 @@ asan_finish_file (void)\n   flag_sanitize |= SANITIZE_ADDRESS;\n }\n \n+/* Poison or unpoison (depending on IS_CLOBBER variable) shadow memory based\n+   on SHADOW address.  Newly added statements will be added to ITER with\n+   given location LOC.  We mark SIZE bytes in shadow memory, where\n+   LAST_CHUNK_SIZE is greater than zero in situation where we are at the\n+   end of a variable.  */\n+\n+static void\n+asan_store_shadow_bytes (gimple_stmt_iterator *iter, location_t loc,\n+\t\t\t tree shadow,\n+\t\t\t unsigned HOST_WIDE_INT base_addr_offset,\n+\t\t\t bool is_clobber, unsigned size,\n+\t\t\t unsigned last_chunk_size)\n+{\n+  tree shadow_ptr_type;\n+\n+  switch (size)\n+    {\n+    case 1:\n+      shadow_ptr_type = shadow_ptr_types[0];\n+      break;\n+    case 2:\n+      shadow_ptr_type = shadow_ptr_types[1];\n+      break;\n+    case 4:\n+      shadow_ptr_type = shadow_ptr_types[2];\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  unsigned char c = (char) is_clobber ? ASAN_STACK_MAGIC_USE_AFTER_SCOPE : 0;\n+  unsigned HOST_WIDE_INT val = 0;\n+  for (unsigned i = 0; i < size; ++i)\n+    {\n+      unsigned char shadow_c = c;\n+      if (i == size - 1 && last_chunk_size && !is_clobber)\n+\tshadow_c = last_chunk_size;\n+      val |= (unsigned HOST_WIDE_INT) shadow_c << (BITS_PER_UNIT * i);\n+    }\n+\n+  /* Handle last chunk in unpoisoning.  */\n+  tree magic = build_int_cst (TREE_TYPE (shadow_ptr_type), val);\n+\n+  tree dest = build2 (MEM_REF, TREE_TYPE (shadow_ptr_type), shadow,\n+\t\t      build_int_cst (shadow_ptr_type, base_addr_offset));\n+\n+  gimple *g = gimple_build_assign (dest, magic);\n+  gimple_set_location (g, loc);\n+  gsi_insert_after (iter, g, GSI_NEW_STMT);\n+}\n+\n+/* Expand the ASAN_MARK builtins.  */\n+\n+bool\n+asan_expand_mark_ifn (gimple_stmt_iterator *iter)\n+{\n+  gimple *g = gsi_stmt (*iter);\n+  location_t loc = gimple_location (g);\n+  HOST_WIDE_INT flags = tree_to_shwi (gimple_call_arg (g, 0));\n+  gcc_assert (flags < ASAN_MARK_LAST);\n+  bool is_clobber = (flags & ASAN_MARK_CLOBBER) != 0;\n+\n+  tree base = gimple_call_arg (g, 1);\n+  gcc_checking_assert (TREE_CODE (base) == ADDR_EXPR);\n+  tree decl = TREE_OPERAND (base, 0);\n+  gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n+  if (asan_handled_variables == NULL)\n+    asan_handled_variables = new hash_set<tree> (16);\n+  asan_handled_variables->add (decl);\n+  tree len = gimple_call_arg (g, 2);\n+\n+  gcc_assert (tree_fits_shwi_p (len));\n+  unsigned HOST_WIDE_INT size_in_bytes = tree_to_shwi (len);\n+  gcc_assert (size_in_bytes);\n+\n+  g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t   NOP_EXPR, base);\n+  gimple_set_location (g, loc);\n+  gsi_replace (iter, g, false);\n+  tree base_addr = gimple_assign_lhs (g);\n+\n+  /* Generate direct emission if size_in_bytes is small.  */\n+  if (size_in_bytes <= ASAN_PARAM_USE_AFTER_SCOPE_DIRECT_EMISSION_THRESHOLD)\n+    {\n+      unsigned HOST_WIDE_INT shadow_size = shadow_mem_size (size_in_bytes);\n+\n+      tree shadow = build_shadow_mem_access (iter, loc, base_addr,\n+\t\t\t\t\t     shadow_ptr_types[0], true);\n+\n+      for (unsigned HOST_WIDE_INT offset = 0; offset < shadow_size;)\n+\t{\n+\t  unsigned size = 1;\n+\t  if (shadow_size - offset >= 4)\n+\t    size = 4;\n+\t  else if (shadow_size - offset >= 2)\n+\t    size = 2;\n+\n+\t  unsigned HOST_WIDE_INT last_chunk_size = 0;\n+\t  unsigned HOST_WIDE_INT s = (offset + size) * ASAN_SHADOW_GRANULARITY;\n+\t  if (s > size_in_bytes)\n+\t    last_chunk_size = ASAN_SHADOW_GRANULARITY - (s - size_in_bytes);\n+\n+\t  asan_store_shadow_bytes (iter, loc, shadow, offset, is_clobber,\n+\t\t\t\t   size, last_chunk_size);\n+\t  offset += size;\n+\t}\n+    }\n+  else\n+    {\n+      g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t       NOP_EXPR, len);\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (iter, g, GSI_SAME_STMT);\n+      tree sz_arg = gimple_assign_lhs (g);\n+\n+      tree fun = builtin_decl_implicit (is_clobber ? BUILT_IN_ASAN_CLOBBER_N\n+\t\t\t\t\t: BUILT_IN_ASAN_UNCLOBBER_N);\n+      g = gimple_build_call (fun, 2, base_addr, sz_arg);\n+      gimple_set_location (g, loc);\n+      gsi_insert_after (iter, g, GSI_NEW_STMT);\n+    }\n+\n+  return false;\n+}\n+\n /* Expand the ASAN_{LOAD,STORE} builtins.  */\n \n bool"}, {"sha": "042af1ff799fec880112b578a43d366d8976582d", "filename": "gcc/asan.h", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -29,16 +29,22 @@ extern bool asan_protect_global (tree);\n extern void initialize_sanitizer_builtins (void);\n extern tree asan_dynamic_init_call (bool);\n extern bool asan_expand_check_ifn (gimple_stmt_iterator *, bool);\n+extern bool asan_expand_mark_ifn (gimple_stmt_iterator *);\n \n extern gimple_stmt_iterator create_cond_insert_point\n      (gimple_stmt_iterator *, bool, bool, bool, basic_block *, basic_block *);\n \n /* Alias set for accessing the shadow memory.  */\n extern alias_set_type asan_shadow_set;\n \n+/* Hash set of labels that are either used in a goto, or their address\n+   has been taken.  */\n+extern hash_set <tree> *asan_used_labels;\n+\n /* Shadow memory is found at\n    (address >> ASAN_SHADOW_SHIFT) + asan_shadow_offset ().  */\n #define ASAN_SHADOW_SHIFT\t3\n+#define ASAN_SHADOW_GRANULARITY (1UL << ASAN_SHADOW_SHIFT)\n \n /* Red zone size, stack and global variables are padded by ASAN_RED_ZONE_SIZE\n    up to 2 * ASAN_RED_ZONE_SIZE - 1 bytes.  */\n@@ -50,22 +56,32 @@ extern alias_set_type asan_shadow_set;\n    the frame.  Middle is for padding in between variables, right is\n    above the last protected variable and partial immediately after variables\n    up to ASAN_RED_ZONE_SIZE alignment.  */\n-#define ASAN_STACK_MAGIC_LEFT\t\t0xf1\n-#define ASAN_STACK_MAGIC_MIDDLE\t\t0xf2\n-#define ASAN_STACK_MAGIC_RIGHT\t\t0xf3\n-#define ASAN_STACK_MAGIC_PARTIAL\t0xf4\n-#define ASAN_STACK_MAGIC_USE_AFTER_RET\t0xf5\n+#define ASAN_STACK_MAGIC_LEFT\t\t  0xf1\n+#define ASAN_STACK_MAGIC_MIDDLE\t\t  0xf2\n+#define ASAN_STACK_MAGIC_RIGHT\t\t  0xf3\n+#define ASAN_STACK_MAGIC_PARTIAL\t  0xf4\n+#define ASAN_STACK_MAGIC_USE_AFTER_RET\t  0xf5\n+#define ASAN_STACK_MAGIC_USE_AFTER_SCOPE  0xf8\n \n #define ASAN_STACK_FRAME_MAGIC\t\t0x41b58ab3\n #define ASAN_STACK_RETIRED_MAGIC\t0x45e0360e\n \n-/* Return true if DECL should be guarded on the stack.  */\n-\n-static inline bool\n-asan_protect_stack_decl (tree decl)\n+/* Various flags for Asan builtins.  */\n+enum asan_check_flags\n {\n-  return DECL_P (decl) && !DECL_ARTIFICIAL (decl);\n-}\n+  ASAN_CHECK_STORE = 1 << 0,\n+  ASAN_CHECK_SCALAR_ACCESS = 1 << 1,\n+  ASAN_CHECK_NON_ZERO_LEN = 1 << 2,\n+  ASAN_CHECK_LAST = 1 << 3\n+};\n+\n+/* Flags for Asan check builtins.  */\n+enum asan_mark_flags\n+{\n+  ASAN_MARK_CLOBBER = 1 << 0,\n+  ASAN_MARK_UNCLOBBER = 1 << 1,\n+  ASAN_MARK_LAST = 1 << 2\n+};\n \n /* Return the size of padding needed to insert after a protected\n    decl of SIZE.  */\n@@ -81,6 +97,8 @@ extern bool set_asan_shadow_offset (const char *);\n \n extern void set_sanitized_sections (const char *);\n \n+extern bool asan_sanitize_stack_p (void);\n+\n /* Return TRUE if builtin with given FCODE will be intercepted by\n    libasan.  */\n \n@@ -105,4 +123,30 @@ asan_intercepted_p (enum built_in_function fcode)\n \t || fcode == BUILT_IN_STRNCMP\n \t || fcode == BUILT_IN_STRNCPY;\n }\n+\n+/* Return TRUE if we should instrument for use-after-scope sanity checking.  */\n+\n+static inline bool\n+asan_sanitize_use_after_scope (void)\n+{\n+  return (flag_sanitize_address_use_after_scope && asan_sanitize_stack_p ());\n+}\n+\n+static inline bool\n+asan_no_sanitize_address_p (void)\n+{\n+  return lookup_attribute (\"no_sanitize_address\",\n+\t\t\t   DECL_ATTRIBUTES (current_function_decl));\n+}\n+\n+/* Return true if DECL should be guarded on the stack.  */\n+\n+static inline bool\n+asan_protect_stack_decl (tree decl)\n+{\n+  return DECL_P (decl)\n+    && (!DECL_ARTIFICIAL (decl)\n+\t|| (asan_sanitize_use_after_scope () && TREE_ADDRESSABLE (decl)));\n+}\n+\n #endif /* TREE_ASAN */"}, {"sha": "39e6de147df05da037fab44e0d231a74dd2e175e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -1,3 +1,8 @@\n+2016-11-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* c-warn.c (warn_for_unused_label): Save all labels used\n+\tin goto or in &label.\n+\n 2016-11-03  Jason Merrill  <jason@redhat.com>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): Correct"}, {"sha": "18ee24787a964d352c79a668efcecb2e1d27d3fa", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"diagnostic.h\"\n #include \"intl.h\"\n-\n+#include \"asan.h\"\n \n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language\n@@ -1627,6 +1627,13 @@ warn_for_unused_label (tree label)\n       else\n \twarning (OPT_Wunused_label, \"label %q+D declared but not defined\", label);\n     }\n+  else if (asan_sanitize_use_after_scope ())\n+    {\n+      if (asan_used_labels == NULL)\n+\tasan_used_labels = new hash_set<tree> (16);\n+\n+      asan_used_labels->add (label);\n+    }\n }\n \n /* Warn for division by zero according to the value of DIVISOR.  LOC"}, {"sha": "7ffb5585b762dbff2f17d4ab9bbeb0ce7ac3ad6b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -868,18 +868,6 @@ union_stack_vars (size_t a, size_t b)\n     }\n }\n \n-/* Return true if the current function should have its stack frame\n-   protected by address sanitizer.  */\n-\n-static inline bool\n-asan_sanitize_stack_p (void)\n-{\n-  return ((flag_sanitize & SANITIZE_ADDRESS)\n-\t  && ASAN_STACK\n-\t  && !lookup_attribute (\"no_sanitize_address\",\n-\t\t\t\tDECL_ATTRIBUTES (current_function_decl)));\n-}\n-\n /* A subroutine of expand_used_vars.  Binpack the variables into\n    partitions constrained by the interference graph.  The overall\n    algorithm used is as follows:\n@@ -941,7 +929,8 @@ partition_stack_vars (void)\n \t     sizes, as the shorter vars wouldn't be adequately protected.\n \t     Don't do that for \"large\" (unsupported) alignment objects,\n \t     those aren't protected anyway.  */\n-\t  if (asan_sanitize_stack_p () && isize != jsize\n+\t  if ((asan_sanitize_stack_p ())\n+\t      && isize != jsize\n \t      && ialign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t    break;\n \n@@ -1128,7 +1117,8 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n       if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t{\n \t  base = virtual_stack_vars_rtx;\n-\t  if (asan_sanitize_stack_p () && pred)\n+\t  if ((asan_sanitize_stack_p ())\n+\t      && pred)\n \t    {\n \t      HOST_WIDE_INT prev_offset\n \t\t= align_base (frame_offset,"}, {"sha": "a60bebf0c9c265091f57cb7f8aa594dbd6db8650", "filename": "gcc/common.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -986,6 +986,9 @@ fsanitize-recover\n Common Report\n This switch is deprecated; use -fsanitize-recover= instead.\n \n+fsanitize-address-use-after-scope\n+Common Driver Report Var(flag_sanitize_address_use_after_scope) Init(0)\n+\n fsanitize-undefined-trap-on-error\n Common Driver Report Var(flag_sanitize_undefined_trap_on_error) Init(0)\n Use trap instead of a library function for undefined behavior sanitization."}, {"sha": "e0afc269471f53e074d351a52615efbc8ec0307d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -10290,6 +10290,10 @@ is greater or equal to this number, use callbacks instead of inline checks.\n E.g. to disable inline code use\n @option{--param asan-instrumentation-with-call-threshold=0}.\n \n+@item use-after-scope-direct-emission-threshold\n+If size of a local variables in bytes is smaller of equal to this number,\n+direct instruction emission is utilized to poison and unpoison local variables.\n+\n @item chkp-max-ctor-size\n Static constructors generated by Pointer Bounds Checker may become very\n large and significantly increase compile time at optimization level\n@@ -10500,6 +10504,7 @@ thread-safe code.\n Enable AddressSanitizer, a fast memory error detector.\n Memory access instructions are instrumented to detect\n out-of-bounds and use-after-free bugs.\n+The option enables @option{-fsanitize-address-use-after-scope}.\n See @uref{https://github.com/google/sanitizers/wiki/AddressSanitizer} for\n more details.  The run-time behavior can be influenced using the\n @env{ASAN_OPTIONS} environment variable.  When set to @code{help=1},\n@@ -10511,6 +10516,7 @@ The option can't be combined with @option{-fsanitize=thread}.\n @item -fsanitize=kernel-address\n @opindex fsanitize=kernel-address\n Enable AddressSanitizer for Linux kernel.\n+The option enables @option{-fsanitize-address-use-after-scope}.\n See @uref{https://github.com/google/kasan/wiki} for more details.\n \n @item -fsanitize=thread\n@@ -10710,8 +10716,8 @@ except for @option{-fsanitize=unreachable} and @option{-fsanitize=return}),\n @option{-fsanitize=float-cast-overflow}, @option{-fsanitize=float-divide-by-zero},\n @option{-fsanitize=bounds-strict},\n @option{-fsanitize=kernel-address} and @option{-fsanitize=address}.\n-For these sanitizers error recovery is turned on by default, except @option{-fsanitize=address},\n-for which this feature is experimental.\n+For these sanitizers error recovery is turned on by default,\n+except @option{-fsanitize=address}, for which this feature is experimental.\n @option{-fsanitize-recover=all} and @option{-fno-sanitize-recover=all} is also\n accepted, the former enables recovery for all sanitizers that support it,\n the latter disables recovery for all sanitizers that support it.\n@@ -10733,6 +10739,11 @@ Similarly @option{-fno-sanitize-recover} is equivalent to\n -fno-sanitize-recover=undefined,float-cast-overflow,float-divide-by-zero,bounds-strict\n @end smallexample\n \n+@item -fsanitize-address-use-after-scope\n+@opindex fsanitize-address-use-after-scope\n+Enable sanitization of local variables to detect use-after-scope bugs.\n+The option sets @option{-fstack-reuse} to @samp{none}.\n+\n @item -fsanitize-undefined-trap-on-error\n @opindex fsanitize-undefined-trap-on-error\n The @option{-fsanitize-undefined-trap-on-error} option instructs the compiler to"}, {"sha": "0a3dc72ea216b5bd07104ed0704bdd289c3d96f8", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"selftest.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"asan.h\"\n \n \n /* All the tuples have their operand vector (if present) at the very bottom\n@@ -2629,6 +2630,8 @@ nonfreeing_call_p (gimple *call)\n       {\n       case IFN_ABNORMAL_DISPATCHER:\n         return true;\n+      case IFN_ASAN_MARK:\n+\treturn tree_to_uhwi (gimple_call_arg (call, 0)) == ASAN_MARK_UNCLOBBER;\n       default:\n \tif (gimple_call_flags (call) & ECF_LEAF)\n \t  return true;"}, {"sha": "e5930e6136847c0e692b3fb8d08d273c3869697a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 219, "deletions": 15, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -59,6 +59,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-walk.h\"\n #include \"langhooks-def.h\"\t/* FIXME: for lhd_set_decl_assembler_name */\n #include \"builtins.h\"\n+#include \"asan.h\"\n+\n+/* Hash set of poisoned variables in a bind expr.  */\n+static hash_set<tree> *asan_poisoned_variables = NULL;\n \n enum gimplify_omp_var_data\n {\n@@ -151,6 +155,7 @@ struct gimplify_ctx\n   tree return_temp;\n \n   vec<tree> case_labels;\n+  hash_set<tree> *live_switch_vars;\n   /* The formal temporary table.  Should this be persistent?  */\n   hash_table<gimplify_hasher> *temp_htab;\n \n@@ -1088,6 +1093,121 @@ build_stack_save_restore (gcall **save, gcall **restore)\n \t\t\t 1, tmp_var);\n }\n \n+/* Generate IFN_ASAN_MARK call that poisons shadow of a for DECL variable.  */\n+\n+static tree\n+build_asan_poison_call_expr (tree decl)\n+{\n+  /* Do not poison variables that have size equal to zero.  */\n+  tree unit_size = DECL_SIZE_UNIT (decl);\n+  if (zerop (unit_size))\n+    return NULL_TREE;\n+\n+  tree base = build_fold_addr_expr (decl);\n+\n+  return build_call_expr_internal_loc (UNKNOWN_LOCATION, IFN_ASAN_MARK,\n+\t\t\t\t       void_type_node, 3,\n+\t\t\t\t       build_int_cst (integer_type_node,\n+\t\t\t\t\t\t      ASAN_MARK_CLOBBER),\n+\t\t\t\t       base, unit_size);\n+}\n+\n+/* Generate IFN_ASAN_MARK call that would poison or unpoison, depending\n+   on POISON flag, shadow memory of a DECL variable.  The call will be\n+   put on location identified by IT iterator, where BEFORE flag drives\n+   position where the stmt will be put.  */\n+\n+static void\n+asan_poison_variable (tree decl, bool poison, gimple_stmt_iterator *it,\n+\t\t      bool before)\n+{\n+  /* When within an OMP context, do not emit ASAN_MARK internal fns.  */\n+  if (gimplify_omp_ctxp)\n+    return;\n+\n+  tree unit_size = DECL_SIZE_UNIT (decl);\n+  tree base = build_fold_addr_expr (decl);\n+\n+  /* Do not poison variables that have size equal to zero.  */\n+  if (zerop (unit_size))\n+    return;\n+\n+  /* It's necessary to have all stack variables aligned to ASAN granularity\n+     bytes.  */\n+  if (DECL_ALIGN_UNIT (decl) <= ASAN_SHADOW_GRANULARITY)\n+    SET_DECL_ALIGN (decl, BITS_PER_UNIT * ASAN_SHADOW_GRANULARITY);\n+\n+  HOST_WIDE_INT flags = poison ? ASAN_MARK_CLOBBER : ASAN_MARK_UNCLOBBER;\n+\n+  gimple *g\n+    = gimple_build_call_internal (IFN_ASAN_MARK, 3,\n+\t\t\t\t  build_int_cst (integer_type_node, flags),\n+\t\t\t\t  base, unit_size);\n+\n+  if (before)\n+    gsi_insert_before (it, g, GSI_NEW_STMT);\n+  else\n+    gsi_insert_after (it, g, GSI_NEW_STMT);\n+}\n+\n+/* Generate IFN_ASAN_MARK internal call that depending on POISON flag\n+   either poisons or unpoisons a DECL.  Created statement is appended\n+   to SEQ_P gimple sequence.  */\n+\n+static void\n+asan_poison_variable (tree decl, bool poison, gimple_seq *seq_p)\n+{\n+  gimple_stmt_iterator it = gsi_last (*seq_p);\n+  bool before = false;\n+\n+  if (gsi_end_p (it))\n+    before = true;\n+\n+  asan_poison_variable (decl, poison, &it, before);\n+}\n+\n+/* Sort pair of VAR_DECLs A and B by DECL_UID.  */\n+\n+static int\n+sort_by_decl_uid (const void *a, const void *b)\n+{\n+  const tree *t1 = (const tree *)a;\n+  const tree *t2 = (const tree *)b;\n+\n+  int uid1 = DECL_UID (*t1);\n+  int uid2 = DECL_UID (*t2);\n+\n+  if (uid1 < uid2)\n+    return -1;\n+  else if (uid1 > uid2)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Generate IFN_ASAN_MARK internal call for all VARIABLES\n+   depending on POISON flag.  Created statement is appended\n+   to SEQ_P gimple sequence.  */\n+\n+static void\n+asan_poison_variables (hash_set<tree> *variables, bool poison, gimple_seq *seq_p)\n+{\n+  unsigned c = variables->elements ();\n+  if (c == 0)\n+    return;\n+\n+  auto_vec<tree> sorted_variables (c);\n+\n+  for (hash_set<tree>::iterator it = variables->begin ();\n+       it != variables->end (); ++it)\n+    sorted_variables.safe_push (*it);\n+\n+  sorted_variables.qsort (sort_by_decl_uid);\n+\n+  for (unsigned i = 0; i < sorted_variables.length (); i++)\n+    asan_poison_variable (sorted_variables[i], poison, seq_p);\n+}\n+\n /* Gimplify a BIND_EXPR.  Just voidify and recurse.  */\n \n static enum gimplify_status\n@@ -1231,6 +1351,17 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \t\t}\n \t    }\n \t}\n+\n+      if (asan_poisoned_variables != NULL\n+\t  && asan_poisoned_variables->contains (t))\n+\t{\n+\t  asan_poisoned_variables->remove (t);\n+\t  asan_poison_variable (t, true, &cleanup);\n+\t}\n+\n+      if (gimplify_ctxp->live_switch_vars != NULL\n+\t  && gimplify_ctxp->live_switch_vars->contains (t))\n+\tgimplify_ctxp->live_switch_vars->remove (t);\n     }\n \n   if (ret_clauses)\n@@ -1475,13 +1606,29 @@ gimplify_decl_expr (tree *stmt_p, gimple_seq *seq_p)\n   if (VAR_P (decl) && !DECL_EXTERNAL (decl))\n     {\n       tree init = DECL_INITIAL (decl);\n+      bool is_vla = false;\n \n       if (TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST\n \t  || (!TREE_STATIC (decl)\n \t      && flag_stack_check == GENERIC_STACK_CHECK\n \t      && compare_tree_int (DECL_SIZE_UNIT (decl),\n \t\t\t\t   STACK_CHECK_MAX_VAR_SIZE) > 0))\n-\tgimplify_vla_decl (decl, seq_p);\n+\t{\n+\t  gimplify_vla_decl (decl, seq_p);\n+\t  is_vla = true;\n+\t}\n+\n+      if (asan_sanitize_use_after_scope ()\n+\t  && !asan_no_sanitize_address_p ()\n+\t  && !is_vla\n+\t  && TREE_ADDRESSABLE (decl)\n+\t  && !TREE_STATIC (decl))\n+\t{\n+\t  asan_poisoned_variables->add (decl);\n+\t  asan_poison_variable (decl, false, seq_p);\n+\t  if (gimplify_ctxp->live_switch_vars)\n+\t    gimplify_ctxp->live_switch_vars->add (decl);\n+\t}\n \n       /* Some front ends do not explicitly declare all anonymous\n \t artificial variables.  We compensate here by declaring the\n@@ -1591,6 +1738,13 @@ warn_switch_unreachable_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n       /* Walk the sub-statements.  */\n       *handled_ops_p = false;\n       break;\n+    case GIMPLE_CALL:\n+      if (gimple_call_internal_p (stmt, IFN_ASAN_MARK))\n+\t{\n+\t  *handled_ops_p = false;\n+\t  break;\n+\t}\n+      /* Fall through.  */\n     default:\n       /* Save the first \"real\" statement (not a decl/lexical scope/...).  */\n       wi->info = stmt;\n@@ -1802,6 +1956,8 @@ collect_fallthrough_labels (gimple_stmt_iterator *gsi_p,\n \t  if (find_label_entry (labels, label))\n \t    prev = gsi_stmt (*gsi_p);\n \t}\n+      else if (gimple_call_internal_p (gsi_stmt (*gsi_p), IFN_ASAN_MARK))\n+\t;\n       else\n \tprev = gsi_stmt (*gsi_p);\n       gsi_next (gsi_p);\n@@ -2082,6 +2238,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n     {\n       vec<tree> labels;\n       vec<tree> saved_labels;\n+      hash_set<tree> *saved_live_switch_vars;\n       tree default_case = NULL_TREE;\n       gswitch *switch_stmt;\n \n@@ -2093,6 +2250,8 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n          labels.  Save all the things from the switch body to append after.  */\n       saved_labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels.create (8);\n+      saved_live_switch_vars = gimplify_ctxp->live_switch_vars;\n+      gimplify_ctxp->live_switch_vars = new hash_set<tree> (4);\n       bool old_in_switch_expr = gimplify_ctxp->in_switch_expr;\n       gimplify_ctxp->in_switch_expr = true;\n \n@@ -2107,6 +2266,9 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n \n       labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels = saved_labels;\n+      gcc_assert (gimplify_ctxp->live_switch_vars->elements () == 0);\n+      delete gimplify_ctxp->live_switch_vars;\n+      gimplify_ctxp->live_switch_vars = saved_live_switch_vars;\n \n       preprocess_case_label_vec_for_gimple (labels, index_type,\n \t\t\t\t\t    &default_case);\n@@ -6164,6 +6326,9 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   tree init = TARGET_EXPR_INITIAL (targ);\n   enum gimplify_status ret;\n \n+  bool unpoison_empty_seq = false;\n+  gimple_stmt_iterator unpoison_it;\n+\n   if (init)\n     {\n       tree cleanup = NULL_TREE;\n@@ -6177,7 +6342,14 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t  gimplify_vla_decl (temp, pre_p);\n \t}\n       else\n-\tgimple_add_tmp_var (temp);\n+\t{\n+\t  /* Save location where we need to place unpoisoning.  It's possible\n+\t     that a variable will be converted to needs_to_live_in_memory.  */\n+\t  unpoison_it = gsi_last (*pre_p);\n+\t  unpoison_empty_seq = gsi_end_p (unpoison_it);\n+\n+\t  gimple_add_tmp_var (temp);\n+\t}\n \n       /* If TARGET_EXPR_INITIAL is void, then the mere evaluation of the\n \t expression is supposed to initialize the slot.  */\n@@ -6213,20 +6385,34 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       /* Add a clobber for the temporary going out of scope, like\n \t gimplify_bind_expr.  */\n       if (gimplify_ctxp->in_cleanup_point_expr\n-\t  && needs_to_live_in_memory (temp)\n-\t  && flag_stack_reuse == SR_ALL)\n-\t{\n-\t  tree clobber = build_constructor (TREE_TYPE (temp),\n-\t\t\t\t\t    NULL);\n-\t  TREE_THIS_VOLATILE (clobber) = true;\n-\t  clobber = build2 (MODIFY_EXPR, TREE_TYPE (temp), temp, clobber);\n-\t  if (cleanup)\n-\t    cleanup = build2 (COMPOUND_EXPR, void_type_node, cleanup,\n-\t\t\t      clobber);\n-\t  else\n-\t    cleanup = clobber;\n-\t}\n+\t  && needs_to_live_in_memory (temp))\n+\t{\n+\t  if (flag_stack_reuse == SR_ALL)\n+\t    {\n+\t      tree clobber = build_constructor (TREE_TYPE (temp),\n+\t\t\t\t\t\tNULL);\n+\t      TREE_THIS_VOLATILE (clobber) = true;\n+\t      clobber = build2 (MODIFY_EXPR, TREE_TYPE (temp), temp, clobber);\n+\t      if (cleanup)\n+\t\tcleanup = build2 (COMPOUND_EXPR, void_type_node, cleanup,\n+\t\t\t\t  clobber);\n+\t      else\n+\t\tcleanup = clobber;\n+\t    }\n+\t  if (asan_sanitize_use_after_scope ())\n+\t    {\n+\t      tree asan_cleanup = build_asan_poison_call_expr (temp);\n+\t      if (asan_cleanup)\n+\t\t{\n+\t\t  if (unpoison_empty_seq)\n+\t\t    unpoison_it = gsi_start (*pre_p);\n \n+\t\t  asan_poison_variable (temp, false, &unpoison_it,\n+\t\t\t\t\tunpoison_empty_seq);\n+\t\t  gimple_push_cleanup (temp, asan_cleanup, false, pre_p);\n+\t\t}\n+\t    }\n+\t}\n       if (cleanup)\n \tgimple_push_cleanup (temp, cleanup, false, pre_p);\n \n@@ -10824,6 +11010,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   location_t saved_location;\n   enum gimplify_status ret;\n   gimple_stmt_iterator pre_last_gsi, post_last_gsi;\n+  tree label;\n \n   save_expr = *expr_p;\n   if (save_expr == NULL_TREE)\n@@ -11239,10 +11426,24 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase LABEL_EXPR:\n \t  ret = gimplify_label_expr (expr_p, pre_p);\n+\t  label = LABEL_EXPR_LABEL (*expr_p);\n+\t  gcc_assert (decl_function_context (label) == current_function_decl);\n+\n+\t  /* If the label is used in a goto statement, or address of the label\n+\t     is taken, we need to unpoison all variables that were seen so far.\n+\t     Doing so would prevent us from reporting a false positives.  */\n+\t  if (asan_sanitize_use_after_scope ()\n+\t      && asan_used_labels != NULL\n+\t      && asan_used_labels->contains (label))\n+\t    asan_poison_variables (asan_poisoned_variables, false, pre_p);\n \t  break;\n \n \tcase CASE_LABEL_EXPR:\n \t  ret = gimplify_case_label_expr (expr_p, pre_p);\n+\n+\t  if (gimplify_ctxp->live_switch_vars)\n+\t    asan_poison_variables (gimplify_ctxp->live_switch_vars, false,\n+\t\t\t\t   pre_p);\n \t  break;\n \n \tcase RETURN_EXPR:\n@@ -12336,7 +12537,10 @@ gimplify_function_tree (tree fndecl)\n       && !needs_to_live_in_memory (ret))\n     DECL_GIMPLE_REG_P (ret) = 1;\n \n+  asan_poisoned_variables = new hash_set<tree> ();\n   bind = gimplify_body (fndecl, true);\n+  delete asan_poisoned_variables;\n+  asan_poisoned_variables = NULL;\n \n   /* The tree body of the function is no longer needed, replace it\n      with the new GIMPLE body.  */"}, {"sha": "cbee97ea82c88fb29c16549fd7a8ce2ce7f41f14", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -237,6 +237,15 @@ expand_ASAN_CHECK (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in the sanopt pass.  */\n+\n+static void\n+expand_ASAN_MARK (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+\n /* This should get expanded in the tsan pass.  */\n \n static void"}, {"sha": "6a0a7f6e1b86785682d4b2ed804a8bf7799ceb66", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -158,6 +158,7 @@ DEF_INTERNAL_FN (UBSAN_OBJECT_SIZE, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN, NULL)\n DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW, \".R...\")\n+DEF_INTERNAL_FN (ASAN_MARK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW, \".R..\")\n DEF_INTERNAL_FN (ADD_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (SUB_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (MUL_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "2f230cea315fd21df3eebfe300c9f8af63bb31d4", "filename": "gcc/opts.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -979,6 +979,25 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n       opts->x_flag_aggressive_loop_optimizations = 0;\n       opts->x_flag_strict_overflow = 0;\n     }\n+\n+  /* Enable -fsanitize-address-use-after-scope if address sanitizer is\n+     enabled.  */\n+  if (opts->x_flag_sanitize\n+      && !opts_set->x_flag_sanitize_address_use_after_scope)\n+    opts->x_flag_sanitize_address_use_after_scope = true;\n+\n+  /* Force -fstack-reuse=none in case -fsanitize-address-use-after-scope\n+     is enabled.  */\n+  if (opts->x_flag_sanitize_address_use_after_scope)\n+    {\n+      if (opts->x_flag_stack_reuse != SR_NONE\n+\t  && opts_set->x_flag_stack_reuse != SR_NONE)\n+\terror_at (loc,\n+\t\t  \"-fsanitize-address-use-after-scope requires \"\n+\t\t  \"-fstack-reuse=none option\");\n+\n+      opts->x_flag_stack_reuse = SR_NONE;\n+    }\n }\n \n #define LEFT_COLUMN\t27\n@@ -1452,8 +1471,8 @@ const struct sanitizer_opts_s sanitizer_opts[] =\n {\n #define SANITIZER_OPT(name, flags, recover) \\\n     { #name, flags, sizeof #name - 1, recover }\n-  SANITIZER_OPT (address, SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS, true),\n-  SANITIZER_OPT (kernel-address, SANITIZE_ADDRESS | SANITIZE_KERNEL_ADDRESS,\n+  SANITIZER_OPT (address, (SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS), true),\n+  SANITIZER_OPT (kernel-address, (SANITIZE_ADDRESS | SANITIZE_KERNEL_ADDRESS),\n \t\t true),\n   SANITIZER_OPT (thread, SANITIZE_THREAD, false),\n   SANITIZER_OPT (leak, SANITIZE_LEAK, false),\n@@ -1781,6 +1800,10 @@ common_handle_option (struct gcc_options *opts,\n       /* Deferred.  */\n       break;\n \n+    case OPT_fsanitize_address_use_after_scope:\n+      opts->x_flag_sanitize_address_use_after_scope = value;\n+      break;\n+\n     case OPT_fsanitize_recover:\n       if (value)\n \topts->x_flag_sanitize_recover"}, {"sha": "89f70936d2e913ab0ba2f5c4671a23cdee25abc9", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -1168,6 +1168,12 @@ DEFPARAM (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD,\n          \"in function becomes greater or equal to this number.\",\n          7000, 0, INT_MAX)\n \n+DEFPARAM (PARAM_USE_AFTER_SCOPE_DIRECT_EMISSION_THRESHOLD,\n+\t \"use-after-scope-direct-emission-threshold\",\n+\t \"Use direct poisoning/unpoisoning intructions for variables \"\n+\t \"smaller or equal to this number.\",\n+\t 256, 0, INT_MAX)\n+\n DEFPARAM (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS,\n \t  \"uninit-control-dep-attempts\",\n \t  \"Maximum number of nested calls to search for control dependencies \""}, {"sha": "0a2905ce1fff42f619849f9d85af2ab63e79fbfc", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -244,5 +244,7 @@ extern void init_param_values (int *params);\n   PARAM_VALUE (PARAM_ASAN_USE_AFTER_RETURN)\n #define ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD \\\n   PARAM_VALUE (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD)\n+#define ASAN_PARAM_USE_AFTER_SCOPE_DIRECT_EMISSION_THRESHOLD \\\n+  ((unsigned) PARAM_VALUE (PARAM_USE_AFTER_SCOPE_DIRECT_EMISSION_THRESHOLD))\n \n #endif /* ! GCC_PARAMS_H */"}, {"sha": "1c142e92326538008d3a1c2660a315fd6f16d77a", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -165,6 +165,10 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT,\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_AFTER_DYNAMIC_INIT,\n \t\t      \"__asan_after_dynamic_init\",\n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_CLOBBER_N, \"__asan_poison_stack_memory\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, 0)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_UNCLOBBER_N, \"__asan_unpoison_stack_memory\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, 0)\n \n /* Thread Sanitizer */\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_INIT, \"__tsan_init\", "}, {"sha": "320e14e9421a3702f8e1f8c2a3d39ac8aa1d9f09", "filename": "gcc/sanopt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=6dc4a6045089adc9ec9efbbc07db25c4a21fc0ff", "patch": "@@ -732,6 +732,9 @@ pass_sanopt::execute (function *fun)\n \t\tcase IFN_ASAN_CHECK:\n \t\t  no_next = asan_expand_check_ifn (&gsi, use_calls);\n \t\t  break;\n+\t\tcase IFN_ASAN_MARK:\n+\t\t  no_next = asan_expand_mark_ifn (&gsi);\n+\t\t  break;\n \t\tdefault:\n \t\t  break;\n \t\t}"}]}