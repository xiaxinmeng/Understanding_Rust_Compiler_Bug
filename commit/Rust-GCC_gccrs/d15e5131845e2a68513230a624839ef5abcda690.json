{"sha": "d15e5131845e2a68513230a624839ef5abcda690", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1ZTUxMzE4NDVlMmE2ODUxMzIzMGE2MjQ4MzllZjVhYmNkYTY5MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T17:59:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T17:59:25Z"}, "message": "Remove AND_COMPL_HARD_REG_SET\n\nUse \"x &= ~y\" instead of \"AND_COMPL_HARD_REG_SET (x, y)\", or just\n\"x & ~y\" if the result is a temporary.  This means that we're splitting\nit into two operations, but the compiler should be able to combine them\nfor reasonable values of FIRST_PSEUDO_REGISTER.\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* hard-reg-set.h (AND_COMPL_HARD_REG_SET): Delete.\n\t* caller-save.c (setup_save_areas): Use \"&~\" instead of\n\tAND_COMPL_HARD_REG_SET.\n\t(save_call_clobbered_regs): Likewise.\n\t* config/epiphany/epiphany.c (epiphany_conditional_register_usage):\n\tLikewise.\n\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n\t* config/gcn/gcn.c (gcn_md_reorg): Likewise.\n\t* config/i386/i386.c (ix86_conditional_register_usage): Likewise.\n\t* config/mips/mips.c (mips_class_max_nregs): Likewise.\n\t(mips_conditional_register_usage): Likewise.\n\t* config/sh/sh.c (output_stack_adjust): Likewise.\n\t* ira-color.c (form_allocno_hard_regs_nodes_forest): Likewise.\n\t(setup_profitable_hard_regs): Likewise.\n\t(get_conflict_and_start_profitable_regs): Likewise.\n\t* ira-conflicts.c (print_allocno_conflicts): Likewise.\n\t(ira_build_conflicts): Likewise.\n\t* ira-costs.c (restrict_cost_classes): Likewise.\n\t(setup_regno_cost_classes_by_aclass): Likewise.\n\t* ira-lives.c (process_bb_node_lives): Likewise.\n\t* ira.c (setup_class_hard_regs, setup_reg_subclasses): Likewise.\n\t(setup_class_subset_and_memory_move_costs, setup_pressure_classes)\n\t(setup_allocno_and_important_classes, setup_class_translate_array)\n\t(setup_reg_class_relations, setup_prohibited_class_mode_regs):\n\tLikewise.\n\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n\t* lra-constraints.c (prohibited_class_reg_set_mode_p): Likewise.\n\t(process_alt_operands, inherit_in_ebb): Likewise.\n\t* lra-eliminations.c (update_reg_eliminate): Likewise.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* reload1.c (update_eliminables_and_spill, reload_as_needed): Likewise.\n\t* resource.c (find_dead_or_set_registers): Likewise.\n\t(mark_target_live_regs): Likewise.\n\t* sched-deps.c (get_implicit_reg_pending_clobbers): Likewise.\n\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n\t(implicit_clobber_conflict_p): Likewise.\n\t* shrink-wrap.c (requires_stack_frame_p): Likewise.\n\t(try_shrink_wrapping): Likewise.\n\nFrom-SVN: r275532", "tree": {"sha": "ef0379a5c245addad8d4072f885d6fc06dae2fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef0379a5c245addad8d4072f885d6fc06dae2fd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d15e5131845e2a68513230a624839ef5abcda690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15e5131845e2a68513230a624839ef5abcda690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15e5131845e2a68513230a624839ef5abcda690", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15e5131845e2a68513230a624839ef5abcda690/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44942965f4eae141bd1f8300e7f77d0c9a3936e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44942965f4eae141bd1f8300e7f77d0c9a3936e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44942965f4eae141bd1f8300e7f77d0c9a3936e4"}], "stats": {"total": 335, "additions": 158, "deletions": 177}, "files": [{"sha": "1fc84aee644d6bda2ec616d6484cfadc10748b5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -1,3 +1,44 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h (AND_COMPL_HARD_REG_SET): Delete.\n+\t* caller-save.c (setup_save_areas): Use \"&~\" instead of\n+\tAND_COMPL_HARD_REG_SET.\n+\t(save_call_clobbered_regs): Likewise.\n+\t* config/epiphany/epiphany.c (epiphany_conditional_register_usage):\n+\tLikewise.\n+\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n+\t* config/gcn/gcn.c (gcn_md_reorg): Likewise.\n+\t* config/i386/i386.c (ix86_conditional_register_usage): Likewise.\n+\t* config/mips/mips.c (mips_class_max_nregs): Likewise.\n+\t(mips_conditional_register_usage): Likewise.\n+\t* config/sh/sh.c (output_stack_adjust): Likewise.\n+\t* ira-color.c (form_allocno_hard_regs_nodes_forest): Likewise.\n+\t(setup_profitable_hard_regs): Likewise.\n+\t(get_conflict_and_start_profitable_regs): Likewise.\n+\t* ira-conflicts.c (print_allocno_conflicts): Likewise.\n+\t(ira_build_conflicts): Likewise.\n+\t* ira-costs.c (restrict_cost_classes): Likewise.\n+\t(setup_regno_cost_classes_by_aclass): Likewise.\n+\t* ira-lives.c (process_bb_node_lives): Likewise.\n+\t* ira.c (setup_class_hard_regs, setup_reg_subclasses): Likewise.\n+\t(setup_class_subset_and_memory_move_costs, setup_pressure_classes)\n+\t(setup_allocno_and_important_classes, setup_class_translate_array)\n+\t(setup_reg_class_relations, setup_prohibited_class_mode_regs):\n+\tLikewise.\n+\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n+\t* lra-constraints.c (prohibited_class_reg_set_mode_p): Likewise.\n+\t(process_alt_operands, inherit_in_ebb): Likewise.\n+\t* lra-eliminations.c (update_reg_eliminate): Likewise.\n+\t* lra-lives.c (process_bb_lives): Likewise.\n+\t* reload1.c (update_eliminables_and_spill, reload_as_needed): Likewise.\n+\t* resource.c (find_dead_or_set_registers): Likewise.\n+\t(mark_target_live_regs): Likewise.\n+\t* sched-deps.c (get_implicit_reg_pending_clobbers): Likewise.\n+\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n+\t(implicit_clobber_conflict_p): Likewise.\n+\t* shrink-wrap.c (requires_stack_frame_p): Likewise.\n+\t(try_shrink_wrapping): Likewise.\n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* hard-reg-set.h (HARD_REG_SET::operator|): New function."}, {"sha": "8c88af9ed04c2918aa01d711e14dd1a022ba5ed5", "filename": "gcc/caller-save.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -455,8 +455,7 @@ setup_save_areas (void)\n       if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n \tmark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);\n \n-      AND_COMPL_HARD_REG_SET (used_regs, call_fixed_reg_set);\n-      AND_COMPL_HARD_REG_SET (used_regs, this_insn_sets);\n+      used_regs &= ~(call_fixed_reg_set | this_insn_sets);\n       hard_regs_to_save &= used_regs;\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n@@ -540,8 +539,7 @@ setup_save_areas (void)\n \t  if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n \t    mark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);\n \n-\t  AND_COMPL_HARD_REG_SET (used_regs, call_fixed_reg_set);\n-\t  AND_COMPL_HARD_REG_SET (used_regs, this_insn_sets);\n+\t  used_regs &= ~(call_fixed_reg_set | this_insn_sets);\n \t  hard_regs_to_save &= used_regs;\n \t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t    if (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n@@ -796,7 +794,7 @@ save_call_clobbered_regs (void)\n \t\t afterwards.  */\n \t      CLEAR_HARD_REG_SET (this_insn_sets);\n \t      note_stores (insn, mark_set_regs, &this_insn_sets);\n-\t      AND_COMPL_HARD_REG_SET (hard_regs_saved, this_insn_sets);\n+\t      hard_regs_saved &= ~this_insn_sets;\n \t    }\n \n \t  if (code == CALL_INSN\n@@ -852,9 +850,9 @@ save_call_clobbered_regs (void)\n \t      note_stores (insn, mark_set_regs, &this_insn_sets);\n \n \t      /* Compute which hard regs must be saved before this call.  */\n-\t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, call_fixed_reg_set);\n-\t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, this_insn_sets);\n-\t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, hard_regs_saved);\n+\t      hard_regs_to_save &= ~(call_fixed_reg_set\n+\t\t\t\t     | this_insn_sets\n+\t\t\t\t     | hard_regs_saved);\n \t      get_call_reg_set_usage (insn, &call_def_reg_set,\n \t\t\t\t      call_used_reg_set);\n \t      hard_regs_to_save &= call_def_reg_set;"}, {"sha": "41cd89e10042af74785e3e00a6f0801f158c8528", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -2242,7 +2242,7 @@ epiphany_conditional_register_usage (void)\n     CLEAR_HARD_REG_SET (reg_class_contents[SHORT_INSN_REGS]);\n   reg_class_contents[SIBCALL_REGS] = reg_class_contents[GENERAL_REGS];\n   /* It would be simpler and quicker if we could just use\n-     AND_COMPL_HARD_REG_SET, alas, call_used_reg_set is yet uninitialized;\n+     &~, alas, call_used_reg_set is yet uninitialized;\n      it is set up later by our caller.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (!call_used_regs[i])"}, {"sha": "8a1f3994e33a014a7434085ce11209e5c15a98b4", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -5201,8 +5201,7 @@ frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n      not fixed.  However, allow the ICC/ICR temporary registers to be allocated\n      if we did not need to use them in reloading other registers.  */\n   memset (&tmp_reg->regs, 0, sizeof (tmp_reg->regs));\n-  tmp_reg->regs = call_used_reg_set;\n-  AND_COMPL_HARD_REG_SET (tmp_reg->regs, fixed_reg_set);\n+  tmp_reg->regs = call_used_reg_set &~ fixed_reg_set;\n   SET_HARD_REG_BIT (tmp_reg->regs, ICC_TEMP);\n   SET_HARD_REG_BIT (tmp_reg->regs, ICR_TEMP);\n \n@@ -5311,7 +5310,7 @@ frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n \n \t      CLEAR_HARD_REG_SET (mentioned_regs);\n \t      find_all_hard_regs (PATTERN (insn), &mentioned_regs);\n-\t      AND_COMPL_HARD_REG_SET (tmp_reg->regs, mentioned_regs);\n+\t      tmp_reg->regs &= ~mentioned_regs;\n \n \t      pattern = PATTERN (insn);\n \t      if (GET_CODE (pattern) == COND_EXEC)\n@@ -5347,8 +5346,7 @@ frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n \t\t}\n \n \t      if (! skip_nested_if)\n-\t\tAND_COMPL_HARD_REG_SET (frv_ifcvt.nested_cc_ok_rewrite,\n-\t\t\t\t\tmentioned_regs);\n+\t\tfrv_ifcvt.nested_cc_ok_rewrite &= ~mentioned_regs;\n \t    }\n \n \t  if (insn == last_insn)"}, {"sha": "473f6ed4c1e3fbed8a9487616cfbf0753e6ab089", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -4628,7 +4628,7 @@ gcn_md_reorg (void)\n \t  prev_insn->age += 1 + nops_rqd;\n \n \t  written |= iwrites;\n-\t  AND_COMPL_HARD_REG_SET (prev_insn->writes, written);\n+\t  prev_insn->writes &= ~written;\n \t}\n \n       /* Track the current instruction as a previous instruction.  */"}, {"sha": "5e68a870181f6553b2b8bf7c42dd2fedf77fcb27", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -497,27 +497,23 @@ ix86_conditional_register_usage (void)\n \n   /* If MMX is disabled, disable the registers.  */\n   if (! TARGET_MMX)\n-    AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t    reg_class_contents[(int) MMX_REGS]);\n+    accessible_reg_set &= ~reg_class_contents[MMX_REGS];\n \n   /* If SSE is disabled, disable the registers.  */\n   if (! TARGET_SSE)\n-    AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t    reg_class_contents[(int) ALL_SSE_REGS]);\n+    accessible_reg_set &= ~reg_class_contents[ALL_SSE_REGS];\n \n   /* If the FPU is disabled, disable the registers.  */\n   if (! (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387))\n-    AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t    reg_class_contents[(int) FLOAT_REGS]);\n+    accessible_reg_set &= ~reg_class_contents[FLOAT_REGS];\n \n   /* If AVX512F is disabled, disable the registers.  */\n   if (! TARGET_AVX512F)\n     {\n       for (i = FIRST_EXT_REX_SSE_REG; i <= LAST_EXT_REX_SSE_REG; i++)\n \tCLEAR_HARD_REG_BIT (accessible_reg_set, i);\n \n-      AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t      reg_class_contents[(int) ALL_MASK_REGS]);\n+      accessible_reg_set &= ~reg_class_contents[ALL_MASK_REGS];\n     }\n }\n "}, {"sha": "4c61154b2b9eb69d013382a5b3a26bd367a61835", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -12981,7 +12981,7 @@ mips_class_max_nregs (enum reg_class rclass, machine_mode mode)\n       if (mips_hard_regno_mode_ok (ST_REG_FIRST, mode))\n \tsize = MIN (size, 4);\n \n-      AND_COMPL_HARD_REG_SET (left, reg_class_contents[(int) ST_REGS]);\n+      left &= ~reg_class_contents[ST_REGS];\n     }\n   if (hard_reg_set_intersect_p (left, reg_class_contents[(int) FP_REGS]))\n     {\n@@ -12993,7 +12993,7 @@ mips_class_max_nregs (enum reg_class rclass, machine_mode mode)\n \t    size = MIN (size, UNITS_PER_FPREG);\n \t}\n \n-      AND_COMPL_HARD_REG_SET (left, reg_class_contents[(int) FP_REGS]);\n+      left &= ~reg_class_contents[FP_REGS];\n     }\n   if (!hard_reg_set_empty_p (left))\n     size = MIN (size, UNITS_PER_WORD);\n@@ -20431,27 +20431,20 @@ mips_conditional_register_usage (void)\n       global_regs[CCDSP_SC_REGNUM] = 1;\n     }\n   else\n-    AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t    reg_class_contents[(int) DSP_ACC_REGS]);\n+    accessible_reg_set &= ~reg_class_contents[DSP_ACC_REGS];\n \n   if (!ISA_HAS_HILO)\n-    AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t    reg_class_contents[(int) MD_REGS]);\n+    accessible_reg_set &= ~reg_class_contents[MD_REGS];\n \n   if (!TARGET_HARD_FLOAT)\n-    {\n-      AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t      reg_class_contents[(int) FP_REGS]);\n-      AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t      reg_class_contents[(int) ST_REGS]);\n-    }\n+    accessible_reg_set &= ~(reg_class_contents[FP_REGS]\n+\t\t\t    | reg_class_contents[ST_REGS]);\n   else if (!ISA_HAS_8CC)\n     {\n       /* We only have a single condition-code register.  We implement\n \t this by fixing all the condition-code registers and generating\n \t RTL that refers directly to ST_REG_FIRST.  */\n-      AND_COMPL_HARD_REG_SET (accessible_reg_set,\n-\t\t\t      reg_class_contents[(int) ST_REGS]);\n+      accessible_reg_set &= ~reg_class_contents[ST_REGS];\n       if (!ISA_HAS_CCF)\n \tSET_HARD_REG_BIT (accessible_reg_set, FPSW_REGNUM);\n       fixed_regs[FPSW_REGNUM] = call_used_regs[FPSW_REGNUM] = 1;\n@@ -20493,8 +20486,7 @@ mips_conditional_register_usage (void)\n       /* Do not allow HI and LO to be treated as register operands.\n \t There are no MTHI or MTLO instructions (or any real need\n \t for them) and one-way registers cannot easily be reloaded.  */\n-      AND_COMPL_HARD_REG_SET (operand_reg_set,\n-\t\t\t      reg_class_contents[(int) MD_REGS]);\n+      operand_reg_set &= ~reg_class_contents[MD_REGS];\n     }\n   /* $f20-$f23 are call-clobbered for n64.  */\n   if (mips_abi == ABI_64)"}, {"sha": "7cc8857b735570e7dfefc9b5bc02e6628e8cdc84", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -6707,9 +6707,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t    temp = -1;\n \t  if (temp < 0 && ! current_function_interrupt && epilogue_p >= 0)\n \t    {\n-\t      HARD_REG_SET temps;\n-\t      temps = call_used_reg_set;\n-\t      AND_COMPL_HARD_REG_SET (temps, call_fixed_reg_set);\n+\t      HARD_REG_SET temps = call_used_reg_set & ~call_fixed_reg_set;\n \t      if (epilogue_p > 0)\n \t\t{\n \t\t  int nreg = 0;"}, {"sha": "7d41162c4959a0b9665a4065ad28f440b20c7a24", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -127,8 +127,8 @@ struct hard_reg_set_container\n    These take just one argument.\n \n    Also define:\n-   IOR_COMPL_HARD_REG_SET and AND_COMPL_HARD_REG_SET\n-   These take two arguments TO and FROM; they read from FROM\n+   IOR_COMPL_HARD_REG_SET\n+   This takes two arguments TO and FROM; it reads from FROM\n    and combines its complement bitwise into TO.\n \n    Also define:\n@@ -153,7 +153,6 @@ struct hard_reg_set_container\n #define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n \n #define IOR_COMPL_HARD_REG_SET(TO, FROM) ((TO) |= ~ (FROM))\n-#define AND_COMPL_HARD_REG_SET(TO, FROM) ((TO) &= ~ (FROM))\n \n static inline bool\n hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n@@ -216,13 +215,6 @@ SET_HARD_REG_SET (HARD_REG_SET &set)\n     set.elts[i] = -1;\n }\n \n-inline void\n-AND_COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n-{\n-  for (unsigned int i = 0; i < ARRAY_SIZE (to.elts); ++i)\n-    to.elts[i] &= ~from.elts[i];\n-}\n-\n inline void\n IOR_COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {"}, {"sha": "8d68c87c2693af2db17dffa22273ce5d15bc95f0", "filename": "gcc/ira-color.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -716,8 +716,7 @@ form_allocno_hard_regs_nodes_forest (void)\n \t    (allocno_data->profitable_hard_regs,\n \t     ALLOCNO_MEMORY_COST (a) - ALLOCNO_CLASS_COST (a)));\n     }\n-  SET_HARD_REG_SET (temp);\n-  AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);\n+  temp = ~ira_no_alloc_regs;\n   add_allocno_hard_regs (temp, 0);\n   qsort (allocno_hard_regs_vec.address () + start,\n \t allocno_hard_regs_vec.length () - start,\n@@ -1047,8 +1046,8 @@ setup_profitable_hard_regs (void)\n \t    {\n \t      ira_object_t obj = ALLOCNO_OBJECT (a, k);\n \t      \n-\t      AND_COMPL_HARD_REG_SET (data->profitable_hard_regs,\n-\t\t\t\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+\t      data->profitable_hard_regs\n+\t\t&= ~OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n \t    }\n \t}\n     }\n@@ -1089,9 +1088,8 @@ setup_profitable_hard_regs (void)\n \t\t       hard_regno + num);\n \t\t}\n \t      else\n-\t\tAND_COMPL_HARD_REG_SET\n-\t\t  (ALLOCNO_COLOR_DATA (conflict_a)->profitable_hard_regs,\n-\t\t   ira_reg_mode_hard_regset[hard_regno][mode]);\n+\t\tALLOCNO_COLOR_DATA (conflict_a)->profitable_hard_regs\n+\t\t  &= ~ira_reg_mode_hard_regset[hard_regno][mode];\n \t    }\n \t}\n     }\n@@ -1590,12 +1588,10 @@ get_conflict_and_start_profitable_regs (ira_allocno_t a, bool retry_p,\n       conflict_regs[i] = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n     }\n   if (retry_p)\n-    {\n-      *start_profitable_regs = reg_class_contents[ALLOCNO_CLASS (a)];\n-      AND_COMPL_HARD_REG_SET (*start_profitable_regs,\n-\t\t\t      ira_prohibited_class_mode_regs\n-\t\t\t      [ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)]);\n-    }\n+    *start_profitable_regs\n+      = (reg_class_contents[ALLOCNO_CLASS (a)]\n+\t &~ (ira_prohibited_class_mode_regs\n+\t     [ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)]));\n   else\n     *start_profitable_regs = ALLOCNO_COLOR_DATA (a)->profitable_hard_regs;\n }"}, {"sha": "ac8014afb9239dd4220ff998c5a105c57d965f88", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -660,15 +660,15 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n \t      putc (')', file);\n \t    }\n \t}\n-      conflicting_hard_regs = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n-      AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n-      conflicting_hard_regs &= reg_class_contents[ALLOCNO_CLASS (a)];\n+      conflicting_hard_regs = (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj)\n+\t\t\t       & ~ira_no_alloc_regs\n+\t\t\t       & reg_class_contents[ALLOCNO_CLASS (a)]);\n       print_hard_reg_set (file, \"\\n;;     total conflict hard regs:\",\n \t\t\t  conflicting_hard_regs);\n \n-      conflicting_hard_regs = OBJECT_CONFLICT_HARD_REGS (obj);\n-      AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n-      conflicting_hard_regs &= reg_class_contents[ALLOCNO_CLASS (a)];\n+      conflicting_hard_regs = (OBJECT_CONFLICT_HARD_REGS (obj)\n+\t\t\t       & ~ira_no_alloc_regs\n+\t\t\t       & reg_class_contents[ALLOCNO_CLASS (a)]);\n       print_hard_reg_set (file, \";;     conflict hard regs:\",\n \t\t\t  conflicting_hard_regs);\n       putc ('\\n', file);\n@@ -738,11 +738,9 @@ ira_build_conflicts (void)\n   if (! targetm.class_likely_spilled_p (base))\n     CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   else\n-    {\n-      temp_hard_reg_set = reg_class_contents[base];\n-      AND_COMPL_HARD_REG_SET (temp_hard_reg_set, ira_no_alloc_regs);\n-      temp_hard_reg_set &= call_used_reg_set;\n-    }\n+    temp_hard_reg_set = (reg_class_contents[base]\n+\t\t\t & ~ira_no_alloc_regs\n+\t\t\t & call_used_reg_set);\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       int i, n = ALLOCNO_NUM_OBJECTS (a);"}, {"sha": "5d672acf81af52cb90ec3e71aec4537c0829f6b7", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -255,9 +255,8 @@ restrict_cost_classes (cost_classes_t full, machine_mode mode,\n       /* Calculate the set of registers in CL that belong to REGS and\n \t are valid for MODE.  */\n       HARD_REG_SET valid_for_cl = reg_class_contents[cl] & regs;\n-      AND_COMPL_HARD_REG_SET (valid_for_cl,\n-\t\t\t      ira_prohibited_class_mode_regs[cl][mode]);\n-      AND_COMPL_HARD_REG_SET (valid_for_cl, ira_no_alloc_regs);\n+      valid_for_cl &= ~(ira_prohibited_class_mode_regs[cl][mode]\n+\t\t\t| ira_no_alloc_regs);\n       if (hard_reg_set_empty_p (valid_for_cl))\n \tcontinue;\n \n@@ -341,8 +340,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \n   if ((classes_ptr = cost_classes_aclass_cache[aclass]) == NULL)\n     {\n-      temp = reg_class_contents[aclass];\n-      AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);\n+      temp = reg_class_contents[aclass] & ~ira_no_alloc_regs;\n       /* We exclude classes from consideration which are subsets of\n \t ACLASS only if ACLASS is an uniform class.  */\n       exclude_p = ira_uniform_class_p[aclass];\n@@ -354,8 +352,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \t    {\n \t      /* Exclude non-uniform classes which are subsets of\n \t\t ACLASS.  */\n-\t      temp2 = reg_class_contents[cl];\n-\t      AND_COMPL_HARD_REG_SET (temp2, ira_no_alloc_regs);\n+\t      temp2 = reg_class_contents[cl] & ~ira_no_alloc_regs;\n \t      if (hard_reg_set_subset_p (temp2, temp) && cl != aclass)\n \t\tcontinue;\n \t    }"}, {"sha": "6f4012f6bb0115c854a6df1f36e181874a7d1b41", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -1129,8 +1129,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n       reg_live_out = df_get_live_out (bb);\n       sparseset_clear (objects_live);\n       REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n-      AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);\n-      AND_COMPL_HARD_REG_SET (hard_regs_live, ira_no_alloc_regs);\n+      hard_regs_live &= ~(eliminable_regset | ira_no_alloc_regs);\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (hard_regs_live, i))\n \t  {"}, {"sha": "7926ae09db99befc0ed8919a541d6849353a6140", "filename": "gcc/ira.c", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -471,8 +471,7 @@ setup_class_hard_regs (void)\n   ira_assert (SHRT_MAX >= FIRST_PSEUDO_REGISTER);\n   for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n     {\n-      temp_hard_regset = reg_class_contents[cl];\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+      temp_hard_regset = reg_class_contents[cl] & ~no_unit_alloc_regs;\n       CLEAR_HARD_REG_SET (processed_hard_reg_set);\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t{\n@@ -541,17 +540,15 @@ setup_reg_subclasses (void)\n       if (i == (int) NO_REGS)\n \tcontinue;\n \n-      temp_hard_regset = reg_class_contents[i];\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+      temp_hard_regset = reg_class_contents[i] & ~no_unit_alloc_regs;\n       if (hard_reg_set_empty_p (temp_hard_regset))\n \tcontinue;\n       for (j = 0; j < N_REG_CLASSES; j++)\n \tif (i != j)\n \t  {\n \t    enum reg_class *p;\n \n-\t    temp_hard_regset2 = reg_class_contents[j];\n-\t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t    temp_hard_regset2 = reg_class_contents[j] & ~no_unit_alloc_regs;\n \t    if (! hard_reg_set_subset_p (temp_hard_regset,\n \t\t\t\t\t temp_hard_regset2))\n \t      continue;\n@@ -605,10 +602,8 @@ setup_class_subset_and_memory_move_costs (void)\n   for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n     for (cl2 = (int) N_REG_CLASSES - 1; cl2 >= 0; cl2--)\n       {\n-\ttemp_hard_regset = reg_class_contents[cl];\n-\tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\ttemp_hard_regset2 = reg_class_contents[cl2];\n-\tAND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\ttemp_hard_regset = reg_class_contents[cl] & ~no_unit_alloc_regs;\n+\ttemp_hard_regset2 = reg_class_contents[cl2] & ~no_unit_alloc_regs;\n \tira_class_subset_p[cl][cl2]\n \t  = hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2);\n \tif (! hard_reg_set_empty_p (temp_hard_regset2)\n@@ -815,10 +810,10 @@ setup_pressure_classes (void)\n \t\t register pressure class.  */\n \t      for (m = 0; m < NUM_MACHINE_MODES; m++)\n \t\t{\n-\t\t  temp_hard_regset = reg_class_contents[cl];\n-\t\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t\t  AND_COMPL_HARD_REG_SET (temp_hard_regset,\n-\t\t\t\t\t  ira_prohibited_class_mode_regs[cl][m]);\n+\t\t  temp_hard_regset\n+\t\t    = (reg_class_contents[cl]\n+\t\t       & ~(no_unit_alloc_regs\n+\t\t\t   | ira_prohibited_class_mode_regs[cl][m]));\n \t\t  if (hard_reg_set_empty_p (temp_hard_regset))\n \t\t    continue;\n \t\t  ira_init_register_move_cost_if_necessary ((machine_mode) m);\n@@ -832,8 +827,7 @@ setup_pressure_classes (void)\n \t    }\n \t  curr = 0;\n \t  insert_p = true;\n-\t  temp_hard_regset = reg_class_contents[cl];\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t  temp_hard_regset = reg_class_contents[cl] & ~no_unit_alloc_regs;\n \t  /* Remove so far added pressure classes which are subset of the\n \t     current candidate class.  Prefer GENERAL_REGS as a pressure\n \t     register class to another class containing the same\n@@ -844,8 +838,8 @@ setup_pressure_classes (void)\n \t  for (i = 0; i < n; i++)\n \t    {\n \t      cl2 = pressure_classes[i];\n-\t      temp_hard_regset2 = reg_class_contents[cl2];\n-\t      AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t      temp_hard_regset2 = (reg_class_contents[cl2]\n+\t\t\t\t   & ~no_unit_alloc_regs);\n \t      if (hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2)\n \t\t  && (! hard_reg_set_equal_p (temp_hard_regset,\n \t\t\t\t\t      temp_hard_regset2)\n@@ -907,8 +901,8 @@ setup_pressure_classes (void)\n \t for which no reg class is defined.  */\n       if (REGNO_REG_CLASS (i) == NO_REGS)\n \tSET_HARD_REG_BIT (ignore_hard_regs, i);\n-    AND_COMPL_HARD_REG_SET (temp_hard_regset, ignore_hard_regs);\n-    AND_COMPL_HARD_REG_SET (temp_hard_regset2, ignore_hard_regs);\n+    temp_hard_regset &= ~ignore_hard_regs;\n+    temp_hard_regset2 &= ~ignore_hard_regs;\n     ira_assert (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset));\n   }\n #endif\n@@ -1000,14 +994,11 @@ setup_allocno_and_important_classes (void)\n      same set of hard registers.  */\n   for (i = 0; i < LIM_REG_CLASSES; i++)\n     {\n-      temp_hard_regset = reg_class_contents[i];\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+      temp_hard_regset = reg_class_contents[i] & ~no_unit_alloc_regs;\n       for (j = 0; j < n; j++)\n \t{\n \t  cl = classes[j];\n-\t  temp_hard_regset2 = reg_class_contents[cl];\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset2,\n-\t\t\t\t  no_unit_alloc_regs);\n+\t  temp_hard_regset2 = reg_class_contents[cl] & ~no_unit_alloc_regs;\n \t  if (hard_reg_set_equal_p (temp_hard_regset,\n \t\t\t\t    temp_hard_regset2))\n \t    break;\n@@ -1036,13 +1027,12 @@ setup_allocno_and_important_classes (void)\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     if (ira_class_hard_regs_num[cl] > 0)\n       {\n-\ttemp_hard_regset = reg_class_contents[cl];\n-\tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\ttemp_hard_regset = reg_class_contents[cl] & ~no_unit_alloc_regs;\n \tset_p = false;\n \tfor (j = 0; j < ira_allocno_classes_num; j++)\n \t  {\n-\t    temp_hard_regset2 = reg_class_contents[ira_allocno_classes[j]];\n-\t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t    temp_hard_regset2 = (reg_class_contents[ira_allocno_classes[j]]\n+\t\t\t\t & ~no_unit_alloc_regs);\n \t    if ((enum reg_class) cl == ira_allocno_classes[j])\n \t      break;\n \t    else if (hard_reg_set_subset_p (temp_hard_regset,\n@@ -1117,8 +1107,8 @@ setup_class_translate_array (enum reg_class *class_translate,\n \t{\n \t  aclass = classes[i];\n \t  temp_hard_regset = (reg_class_contents[aclass]\n-\t\t\t      & reg_class_contents[cl]);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t\t\t      & reg_class_contents[cl]\n+\t\t\t      & ~no_unit_alloc_regs);\n \t  if (! hard_reg_set_empty_p (temp_hard_regset))\n \t    {\n \t      min_cost = INT_MAX;\n@@ -1220,10 +1210,8 @@ setup_reg_class_relations (void)\n \t  ira_reg_classes_intersect_p[cl1][cl2] = false;\n \t  ira_reg_class_intersect[cl1][cl2] = NO_REGS;\n \t  ira_reg_class_subset[cl1][cl2] = NO_REGS;\n-\t  temp_hard_regset = reg_class_contents[cl1];\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t  temp_set2 = reg_class_contents[cl2];\n-\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n+\t  temp_hard_regset = reg_class_contents[cl1] & ~no_unit_alloc_regs;\n+\t  temp_set2 = reg_class_contents[cl2] & ~no_unit_alloc_regs;\n \t  if (hard_reg_set_empty_p (temp_hard_regset)\n \t      && hard_reg_set_empty_p (temp_set2))\n \t    {\n@@ -1262,14 +1250,13 @@ setup_reg_class_relations (void)\n \t  ira_reg_class_subunion[cl1][cl2] = NO_REGS;\n \t  ira_reg_class_superunion[cl1][cl2] = NO_REGS;\n \t  intersection_set = (reg_class_contents[cl1]\n-\t\t\t      & reg_class_contents[cl2]);\n-\t  AND_COMPL_HARD_REG_SET (intersection_set, no_unit_alloc_regs);\n-\t  union_set = reg_class_contents[cl1] | reg_class_contents[cl2];\n-\t  AND_COMPL_HARD_REG_SET (union_set, no_unit_alloc_regs);\n+\t\t\t      & reg_class_contents[cl2]\n+\t\t\t      & ~no_unit_alloc_regs);\n+\t  union_set = ((reg_class_contents[cl1] | reg_class_contents[cl2])\n+\t\t       & ~no_unit_alloc_regs);\n \t  for (cl3 = 0; cl3 < N_REG_CLASSES; cl3++)\n \t    {\n-\t      temp_hard_regset = reg_class_contents[cl3];\n-\t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t      temp_hard_regset = reg_class_contents[cl3] & ~no_unit_alloc_regs;\n \t      if (hard_reg_set_subset_p (temp_hard_regset, intersection_set))\n \t\t{\n \t\t  /* CL3 allocatable hard register set is inside of\n@@ -1280,7 +1267,7 @@ setup_reg_class_relations (void)\n \t\t      temp_set2\n \t\t\t= (reg_class_contents\n \t\t\t   [ira_reg_class_intersect[cl1][cl2]]);\n-\t\t      AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n+\t\t      temp_set2 &= ~no_unit_alloc_regs;\n \t\t      if (! hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \t\t\t  /* If the allocatable hard register sets are\n \t\t\t     the same, prefer GENERAL_REGS or the\n@@ -1298,8 +1285,8 @@ setup_reg_class_relations (void)\n \t\t\tira_reg_class_intersect[cl1][cl2] = (enum reg_class) cl3;\n \t\t    }\n \t\t  temp_set2\n-\t\t    = reg_class_contents[ira_reg_class_subset[cl1][cl2]];\n-\t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n+\t\t    = (reg_class_contents[ira_reg_class_subset[cl1][cl2]]\n+\t\t       & ~no_unit_alloc_regs);\n \t\t  if (! hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \t\t      /* Ignore unavailable hard registers and prefer\n \t\t\t smallest class for debugging purposes.  */\n@@ -1317,8 +1304,8 @@ setup_reg_class_relations (void)\n \t\t     union of allocatable hard register sets of CL1\n \t\t     and CL2.  */\n \t\t  temp_set2\n-\t\t    = reg_class_contents[ira_reg_class_subunion[cl1][cl2]];\n-\t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n+\t\t    = (reg_class_contents[ira_reg_class_subunion[cl1][cl2]]\n+\t\t       & ~no_unit_alloc_regs);\n \t \t  if (ira_reg_class_subunion[cl1][cl2] == NO_REGS\n \t\t      || (hard_reg_set_subset_p (temp_set2, temp_hard_regset)\n \t\t\t  \n@@ -1341,8 +1328,8 @@ setup_reg_class_relations (void)\n \t\t     of allocatable hard register sets of CL1 and\n \t\t     CL2.  */\n \t\t  temp_set2\n-\t\t    = reg_class_contents[ira_reg_class_superunion[cl1][cl2]];\n-\t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n+\t\t    = (reg_class_contents[ira_reg_class_superunion[cl1][cl2]]\n+\t\t       & ~no_unit_alloc_regs);\n \t \t  if (ira_reg_class_superunion[cl1][cl2] == NO_REGS\n \t\t      || (hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \n@@ -1491,8 +1478,7 @@ setup_prohibited_class_mode_regs (void)\n \n   for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n     {\n-      temp_hard_regset = reg_class_contents[cl];\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+      temp_hard_regset = reg_class_contents[cl] & ~no_unit_alloc_regs;\n       for (j = 0; j < NUM_MACHINE_MODES; j++)\n \t{\n \t  count = 0;"}, {"sha": "c2244f575101f714e41164faa48d7e367eb6067e", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -619,8 +619,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n   biggest_nregs = hard_regno_nregs (hard_regno, biggest_mode);\n   nregs_diff = (biggest_nregs\n \t\t- hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno)));\n-  available_regs = reg_class_contents[rclass];\n-  AND_COMPL_HARD_REG_SET (available_regs, lra_no_alloc_regs);\n+  available_regs = reg_class_contents[rclass] & ~lra_no_alloc_regs;\n   for (i = 0; i < rclass_size; i++)\n     {\n       if (try_only_hard_regno >= 0)"}, {"sha": "16d96c562b149ffcca8d7efe4927caff42b91141", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -1854,8 +1854,7 @@ prohibited_class_reg_set_mode_p (enum reg_class rclass,\n   HARD_REG_SET temp;\n   \n   lra_assert (hard_reg_set_subset_p (reg_class_contents[rclass], set));\n-  temp = set;\n-  AND_COMPL_HARD_REG_SET (temp, lra_no_alloc_regs);\n+  temp = set & ~lra_no_alloc_regs;\n   return (hard_reg_set_subset_p\n \t  (temp, ira_prohibited_class_mode_regs[rclass][mode]));\n }\n@@ -2513,13 +2512,11 @@ process_alt_operands (int only_alternative)\n \n \t      if (this_alternative != NO_REGS)\n \t\t{\n-\t\t  HARD_REG_SET available_regs;\n-\t\t  \n-\t\t  available_regs = reg_class_contents[this_alternative];\n-\t\t  AND_COMPL_HARD_REG_SET\n-\t\t    (available_regs,\n-\t\t     ira_prohibited_class_mode_regs[this_alternative][mode]);\n-\t\t  AND_COMPL_HARD_REG_SET (available_regs, lra_no_alloc_regs);\n+\t\t  HARD_REG_SET available_regs\n+\t\t    = (reg_class_contents[this_alternative]\n+\t\t       & ~((ira_prohibited_class_mode_regs\n+\t\t\t    [this_alternative][mode])\n+\t\t\t   | lra_no_alloc_regs));\n \t\t  if (hard_reg_set_empty_p (available_regs))\n \t\t    {\n \t\t      /* There are no hard regs holding a value of given\n@@ -6407,8 +6404,8 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t      else\n \t\t\tadd_to_hard_reg_set (&s, PSEUDO_REGNO_MODE (dst_regno),\n \t\t\t\t\t     reg_renumber[dst_regno]);\n-\t\t      AND_COMPL_HARD_REG_SET (live_hard_regs, s);\n-\t\t      AND_COMPL_HARD_REG_SET (potential_reload_hard_regs, s);\n+\t\t      live_hard_regs &= ~s;\n+\t\t      potential_reload_hard_regs &= ~s;\n \t\t    }\n \t\t  /* We should invalidate potential inheritance or\n \t\t     splitting for the current insn usages to the next"}, {"sha": "749834e84dd0a8ab5d74575b07ea2132fcf1c3b3", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -1203,7 +1203,7 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t  }\n       }\n   lra_no_alloc_regs |= temp_hard_reg_set;\n-  AND_COMPL_HARD_REG_SET (eliminable_regset, temp_hard_reg_set);\n+  eliminable_regset &= ~temp_hard_reg_set;\n   spill_pseudos (temp_hard_reg_set);\n   return result;\n }"}, {"sha": "e1674b570ac32a56f900263c4a441ce710f9acb7", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -671,7 +671,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   sparseset_clear (pseudos_live_through_setjumps);\n   CLEAR_HARD_REG_SET (last_call_used_reg_set);\n   REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n-  AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);\n+  hard_regs_live &= ~eliminable_regset;\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n     {\n       update_pseudo_point (j, curr_point, USE_POINT);"}, {"sha": "90cee06773bc4c761cae11799cc3505cd417a5a4", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -3929,7 +3929,7 @@ update_eliminables_and_spill (void)\n   HARD_REG_SET to_spill;\n   CLEAR_HARD_REG_SET (to_spill);\n   update_eliminables (&to_spill);\n-  AND_COMPL_HARD_REG_SET (used_spill_regs, to_spill);\n+  used_spill_regs &= ~to_spill;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (TEST_HARD_REG_BIT (to_spill, i))\n@@ -4783,8 +4783,8 @@ reload_as_needed (int live_known)\n          be partially clobbered by the call.  */\n       else if (CALL_P (insn))\n \t{\n-\t  AND_COMPL_HARD_REG_SET (reg_reloaded_valid, call_used_reg_set);\n-\t  AND_COMPL_HARD_REG_SET (reg_reloaded_valid, reg_reloaded_call_part_clobbered);\n+\t  reg_reloaded_valid &= ~(call_used_reg_set\n+\t\t\t\t  | reg_reloaded_call_part_clobbered);\n \n \t  /* If this is a call to a setjmp-type function, we must not\n \t     reuse any reload reg contents across the call; that will"}, {"sha": "2d30e08a4d3c160ce0a48a92a0218419ce3f4224", "filename": "gcc/resource.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -450,8 +450,8 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \tcase CODE_LABEL:\n \t  /* After a label, any pending dead registers that weren't yet\n \t     used can be made dead.  */\n-\t  AND_COMPL_HARD_REG_SET (pending_dead_regs, needed.regs);\n-\t  AND_COMPL_HARD_REG_SET (res->regs, pending_dead_regs);\n+\t  pending_dead_regs &= ~needed.regs;\n+\t  res->regs &= ~pending_dead_regs;\n \t  CLEAR_HARD_REG_SET (pending_dead_regs);\n \n \t  continue;\n@@ -565,14 +565,12 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \t\t    }\n \n \t\t  target_res = *res;\n-\t\t  scratch = target_set.regs;\n-\t\t  AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n-\t\t  AND_COMPL_HARD_REG_SET (target_res.regs, scratch);\n+\t\t  scratch = target_set.regs & ~needed.regs;\n+\t\t  target_res.regs &= ~scratch;\n \n \t\t  fallthrough_res = *res;\n-\t\t  scratch = set.regs;\n-\t\t  AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n-\t\t  AND_COMPL_HARD_REG_SET (fallthrough_res.regs, scratch);\n+\t\t  scratch = set.regs & ~needed.regs;\n+\t\t  fallthrough_res.regs &= ~scratch;\n \n \t\t  if (!ANY_RETURN_P (this_jump_insn->jump_label ()))\n \t\t    find_dead_or_set_registers\n@@ -601,9 +599,8 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n       mark_referenced_resources (insn, &needed, true);\n       mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \n-      scratch = set.regs;\n-      AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n-      AND_COMPL_HARD_REG_SET (res->regs, scratch);\n+      scratch = set.regs & ~needed.regs;\n+      res->regs &= ~scratch;\n     }\n \n   return jump_insn;\n@@ -1048,8 +1045,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t\t  /* CALL clobbers all call-used regs that aren't fixed except\n \t\t     sp, ap, and fp.  Do this before setting the result of the\n \t\t     call live.  */\n-\t\t  AND_COMPL_HARD_REG_SET (current_live_regs,\n-\t\t\t\t\t  regs_invalidated_by_this_call);\n+\t\t  current_live_regs &= ~regs_invalidated_by_this_call;\n \t\t}\n \n \t      /* A CALL_INSN sets any global register live, since it may\n@@ -1097,7 +1093,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \n \t      /* A label clobbers the pending dead registers since neither\n \t\t reload nor jump will propagate a value across a label.  */\n-\t      AND_COMPL_HARD_REG_SET (current_live_regs, pending_dead_regs);\n+\t      current_live_regs &= ~pending_dead_regs;\n \t      CLEAR_HARD_REG_SET (pending_dead_regs);\n \n \t      /* We must conservatively assume that all registers that used\n@@ -1160,8 +1156,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t{\n \t  mark_referenced_resources (insn, &needed, true);\n \n-\t  scratch = needed.regs;\n-\t  AND_COMPL_HARD_REG_SET (scratch, set.regs);\n+\t  scratch = needed.regs & ~set.regs;\n \t  new_resources.regs |= scratch;\n \n \t  mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);"}, {"sha": "36a6669f113e8ce3738ab201bb5eadf23b56a44c", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -2885,7 +2885,7 @@ get_implicit_reg_pending_clobbers (HARD_REG_SET *temp, rtx_insn *insn)\n   preprocess_constraints (insn);\n   alternative_mask preferred = get_preferred_alternatives (insn);\n   ira_implicitly_set_insn_hard_regs (temp, preferred);\n-  AND_COMPL_HARD_REG_SET (*temp, ira_no_alloc_regs);\n+  *temp &= ~ira_no_alloc_regs;\n }\n \n /* Analyze an INSN with pattern X to find all dependencies.  */"}, {"sha": "9447b9228298b11ba9f4664b96efb5a88442a5d5", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -1248,8 +1248,8 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n   /* Exclude registers that are partially call clobbered.  */\n   if (def->crosses_call\n       && !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n-    AND_COMPL_HARD_REG_SET (reg_rename_p->available_for_renaming,\n-                            sel_hrd.regs_for_call_clobbered[mode]);\n+    reg_rename_p->available_for_renaming\n+      &= ~sel_hrd.regs_for_call_clobbered[mode];\n \n   /* Leave only those that are ok to rename.  */\n   EXECUTE_IF_SET_IN_HARD_REG_SET (reg_rename_p->available_for_renaming,\n@@ -1270,8 +1270,7 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n                             cur_reg);\n     }\n \n-  AND_COMPL_HARD_REG_SET (reg_rename_p->available_for_renaming,\n-                          reg_rename_p->unavailable_hard_regs);\n+  reg_rename_p->available_for_renaming &= ~reg_rename_p->unavailable_hard_regs;\n \n   /* Regno is always ok from the renaming part of view, but it really\n      could be in *unavailable_hard_regs already, so set it here instead\n@@ -2105,7 +2104,7 @@ implicit_clobber_conflict_p (insn_t through_insn, expr_t expr)\n   preprocess_constraints (insn);\n   alternative_mask prefrred = get_preferred_alternatives (insn);\n   ira_implicitly_set_insn_hard_regs (&temp, prefrred);\n-  AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);\n+  temp &= ~ira_no_alloc_regs;\n \n   /* If any implicit clobber registers intersect with regular ones in\n      through_insn, we have a dependency and thus bail out.  */"}, {"sha": "f1af1cb6dd135c09b72bf76d470bfd5c3c34a5fd", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15e5131845e2a68513230a624839ef5abcda690/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=d15e5131845e2a68513230a624839ef5abcda690", "patch": "@@ -76,7 +76,7 @@ requires_stack_frame_p (rtx_insn *insn, HARD_REG_SET prologue_used,\n     }\n   if (hard_reg_set_intersect_p (hardregs, prologue_used))\n     return true;\n-  AND_COMPL_HARD_REG_SET (hardregs, call_used_reg_set);\n+  hardregs &= ~call_used_reg_set;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (TEST_HARD_REG_BIT (hardregs, regno)\n \t&& df_regs_ever_live_p (regno))\n@@ -687,7 +687,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n \tHARD_REG_SET this_used;\n \tCLEAR_HARD_REG_SET (this_used);\n \tnote_uses (&PATTERN (insn), record_hard_reg_uses, &this_used);\n-\tAND_COMPL_HARD_REG_SET (this_used, prologue_clobbered);\n+\tthis_used &= ~prologue_clobbered;\n \tprologue_used |= this_used;\n \tnote_stores (insn, record_hard_reg_sets, &prologue_clobbered);\n       }"}]}