{"sha": "62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlNDVlM2U3MDM1ZWI3YzY2OGJlOGVjOTk4OGM1N2UyZDQzMzdmOQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-04-25T10:43:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:43:14Z"}, "message": "checks.adb (Insert_Valid_Check): Code cleanup.\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Insert_Valid_Check): Code cleanup.\n\t* exp_ch6.adb (Add_Validation_Call_By_Copy_Code): New routine.\n\t(Expand_Actuals): Generate proper copy-back for a validation\n\tvariable when it acts as the argument of a type conversion.\n\t* sem_util.adb (Is_Validation_Variable_Reference): Augment the\n\tpredicate to operate on type qualifications.\n\nFrom-SVN: r247180", "tree": {"sha": "d09258eb3fc0f0efe76d341eadb436343b040e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d09258eb3fc0f0efe76d341eadb436343b040e10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9"}], "stats": {"total": 192, "additions": 153, "deletions": 39}, "files": [{"sha": "55a1526b072b245e42a0ece6da1de81fe4924239", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "patch": "@@ -1,3 +1,12 @@\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Insert_Valid_Check): Code cleanup.\n+\t* exp_ch6.adb (Add_Validation_Call_By_Copy_Code): New routine.\n+\t(Expand_Actuals): Generate proper copy-back for a validation\n+\tvariable when it acts as the argument of a type conversion.\n+\t* sem_util.adb (Is_Validation_Variable_Reference): Augment the\n+\tpredicate to operate on type qualifications.\n+\n 2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb, exp_ch6.adb, binde.adb, sem_disp.adb, s-fileio.adb:"}, {"sha": "2bcd059219d9399a8b8877bcca803e09941e4e64", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "patch": "@@ -7286,10 +7286,11 @@ package body Checks is\n \n       declare\n          DRC : constant Boolean := Do_Range_Check (Exp);\n-         CE  : Node_Id;\n-         Obj : Node_Id;\n-         PV  : Node_Id;\n-         Var : Entity_Id;\n+\n+         CE     : Node_Id;\n+         Obj    : Node_Id;\n+         PV     : Node_Id;\n+         Var_Id : Entity_Id;\n \n       begin\n          Set_Do_Range_Check (Exp, False);\n@@ -7301,22 +7302,22 @@ package body Checks is\n          --    1) The evaluation of the object results in only one read in the\n          --       case where the object is atomic or volatile.\n \n-         --         Temp ... := Object;  --  read\n+         --         Var ... := Object;  --  read\n \n          --    2) The captured value is the one verified by attribute 'Valid.\n          --       As a result the object is not evaluated again, which would\n          --       result in an unwanted read in the case where the object is\n          --       atomic or volatile.\n \n-         --         if not Temp'Valid then    --  OK, no read of Object\n+         --         if not Var'Valid then     --  OK, no read of Object\n \n          --         if not Object'Valid then  --  Wrong, extra read of Object\n \n          --    3) The captured value replaces the original object reference.\n          --       As a result the object is not evaluated again, in the same\n          --       vein as 2).\n \n-         --         ... Temp ...    --  OK, no read of Object\n+         --         ... Var ...     --  OK, no read of Object\n \n          --         ... Object ...  --  Wrong, extra read of Object\n \n@@ -7326,24 +7327,24 @@ package body Checks is\n \n          --         procedure Call (Val : in out ...);\n \n-         --         Temp : ... := Object;   --  read Object\n-         --         if not Temp'Valid then  --  validity check\n-         --         Call (Temp);            --  modify Temp\n-         --         Object := Temp;         --  update Object\n+         --         Var : ... := Object;   --  read Object\n+         --         if not Var'Valid then  --  validity check\n+         --         Call (Var);            --  modify Var\n+         --         Object := Var;         --  update Object\n \n          if Is_Variable (Exp) then\n-            Obj := New_Copy_Tree (Exp);\n-            Var := Make_Temporary (Loc, 'T', Exp);\n+            Obj    := New_Copy_Tree (Exp);\n+            Var_Id := Make_Temporary (Loc, 'T', Exp);\n \n             Insert_Action (Exp,\n               Make_Object_Declaration (Loc,\n-                Defining_Identifier => Var,\n+                Defining_Identifier => Var_Id,\n                 Object_Definition   => New_Occurrence_Of (Typ, Loc),\n                 Expression          => Relocate_Node (Exp)));\n-            Set_Validated_Object (Var, Obj);\n+            Set_Validated_Object (Var_Id, Obj);\n \n-            Rewrite (Exp, New_Occurrence_Of (Var, Loc));\n-            PV := New_Occurrence_Of (Var, Loc);\n+            Rewrite (Exp, New_Occurrence_Of (Var_Id, Loc));\n+            PV := New_Occurrence_Of (Var_Id, Loc);\n \n          --  Otherwise the expression does not denote a variable. Force its\n          --  evaluation by capturing its value in a constant. Generate:"}, {"sha": "2a425285d75489494389b6c613b77d08fbd97006", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 102, "deletions": 18, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "patch": "@@ -1180,6 +1180,10 @@ package body Exp_Ch6 is\n       --  that all that is needed is to simply create a temporary and copy\n       --  the value in and out of the temporary.\n \n+      procedure Add_Validation_Call_By_Copy_Code (Act : Node_Id);\n+      --  Perform copy-back for actual parameter Act which denotes a validation\n+      --  variable.\n+\n       procedure Check_Fortran_Logical;\n       --  A value of type Logical that is passed through a formal parameter\n       --  must be normalized because .TRUE. usually does not have the same\n@@ -1618,6 +1622,85 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Simple_Call_By_Copy_Code;\n \n+      --------------------------------------\n+      -- Add_Validation_Call_By_Copy_Code --\n+      --------------------------------------\n+\n+      procedure Add_Validation_Call_By_Copy_Code (Act : Node_Id) is\n+         Expr    : Node_Id;\n+         Obj     : Node_Id;\n+         Obj_Typ : Entity_Id;\n+         Var     : Node_Id;\n+         Var_Id  : Entity_Id;\n+\n+      begin\n+         Var := Act;\n+\n+         --  Use the expression when the context qualifies a reference in some\n+         --  fashion.\n+\n+         while Nkind_In (Var, N_Qualified_Expression,\n+                              N_Type_Conversion,\n+                              N_Unchecked_Type_Conversion)\n+         loop\n+            Var := Expression (Var);\n+         end loop;\n+\n+         --  Copy the value of the validation variable back into the object\n+         --  being validated.\n+\n+         if Is_Entity_Name (Var) then\n+            Var_Id  := Entity (Var);\n+            Obj     := Validated_Object (Var_Id);\n+            Obj_Typ := Etype (Obj);\n+\n+            Expr := New_Occurrence_Of (Var_Id, Loc);\n+\n+            --  A type conversion is needed when the validation variable and\n+            --  the validated object carry different types. This case occurs\n+            --  when the actual is qualified in some fashion.\n+\n+            --    Common:\n+            --      subtype Int is Integer range ...;\n+            --      procedure Call (Val : in out Integer);\n+\n+            --    Original:\n+            --      Object : Int;\n+            --      Call (Integer (Object));\n+\n+            --    Expanded:\n+            --      Object : Int;\n+            --      Var : Integer := Object;  --  conversion to base type\n+            --      if not Var'Valid then     --  validity check\n+            --      Call (Var);               --  modify Var\n+            --      Object := Int (Var);      --  conversion to subtype\n+\n+            if Etype (Var_Id) /= Obj_Typ then\n+               Expr :=\n+                 Make_Type_Conversion (Loc,\n+                   Subtype_Mark => New_Occurrence_Of (Obj_Typ, Loc),\n+                   Expression   => Expr);\n+            end if;\n+\n+            --  Generate:\n+            --    Object := Var;\n+            --      <or>\n+            --    Object := Object_Type (Var);\n+\n+            Append_To (Post_Call,\n+              Make_Assignment_Statement (Loc,\n+                Name       => Obj,\n+                Expression => Expr));\n+\n+         --  If the flow reaches this point, then this routine was invoked with\n+         --  an actual which does not denote a validation variable.\n+\n+         else\n+            pragma Assert (False);\n+            null;\n+         end if;\n+      end Add_Validation_Call_By_Copy_Code;\n+\n       ---------------------------\n       -- Check_Fortran_Logical --\n       ---------------------------\n@@ -1831,10 +1914,26 @@ package body Exp_Ch6 is\n                end if;\n             end if;\n \n-            --  If argument is a type conversion for a type that is passed\n-            --  by copy, then we must pass the parameter by copy.\n+            --  The actual denotes a variable which captures the value of an\n+            --  object for validation purposes. Add a copy-back to reflect any\n+            --  potential changes in value back into the original object.\n+\n+            --    Var : ... := Object;\n+            --    if not Var'Valid then  --  validity check\n+            --    Call (Var);            --  modify var\n+            --    Object := Var;         --  update Object\n+\n+            --  This case is given higher priority because the subsequent check\n+            --  for type conversion may add an extra copy of the variable and\n+            --  prevent proper value propagation back in the original object.\n+\n+            if Is_Validation_Variable_Reference (Actual) then\n+               Add_Validation_Call_By_Copy_Code (Actual);\n \n-            if Nkind (Actual) = N_Type_Conversion\n+            --  If argument is a type conversion for a type that is passed by\n+            --  copy, then we must pass the parameter by copy.\n+\n+            elsif Nkind (Actual) = N_Type_Conversion\n               and then\n                 (Is_Numeric_Type (E_Formal)\n                   or else Is_Access_Type (E_Formal)\n@@ -1913,21 +2012,6 @@ package body Exp_Ch6 is\n             then\n                Add_Call_By_Copy_Code;\n \n-            --  The actual denotes a variable which captures the value of an\n-            --  object for validation purposes. Add a copy-back to reflect any\n-            --  potential changes in value back into the original object.\n-\n-            --    Temp : ... := Object;\n-            --    if not Temp'Valid then ...\n-            --    Call (Temp);\n-            --    Object := Temp;\n-\n-            elsif Is_Validation_Variable_Reference (Actual) then\n-               Append_To (Post_Call,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       => Validated_Object (Entity (Actual)),\n-                   Expression => New_Occurrence_Of (Entity (Actual), Loc)));\n-\n             elsif Nkind (Actual) = N_Indexed_Component\n               and then Is_Entity_Name (Prefix (Actual))\n               and then Has_Volatile_Components (Entity (Prefix (Actual)))"}, {"sha": "a1187824bfaa5789692acfd907ee62e9b0543b7f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e45e3e7035eb7c668be8ec9988c57e2d4337f9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "patch": "@@ -15282,12 +15282,32 @@ package body Sem_Util is\n    --------------------------------------\n \n    function Is_Validation_Variable_Reference (N : Node_Id) return Boolean is\n+      Var    : Node_Id;\n+      Var_Id : Entity_Id;\n+\n    begin\n+      Var := N;\n+\n+      --  Use the expression when the context qualifies a reference in some\n+      --  fashion.\n+\n+      while Nkind_In (Var, N_Qualified_Expression,\n+                           N_Type_Conversion,\n+                           N_Unchecked_Type_Conversion)\n+      loop\n+         Var := Expression (Var);\n+      end loop;\n+\n+      Var_Id := Empty;\n+\n+      if Is_Entity_Name (Var) then\n+         Var_Id := Entity (Var);\n+      end if;\n+\n       return\n-        Is_Entity_Name (N)\n-          and then Present (Entity (N))\n-          and then Ekind (Entity (N)) = E_Variable\n-          and then Present (Validated_Object (Entity (N)));\n+        Present (Var_Id)\n+          and then Ekind (Var_Id) = E_Variable\n+          and then Present (Validated_Object (Var_Id));\n    end Is_Validation_Variable_Reference;\n \n    ----------------------------"}]}