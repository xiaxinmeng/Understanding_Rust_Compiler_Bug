{"sha": "4d7cf10d2194682a8dbb606631728c612bfaf3bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ3Y2YxMGQyMTk0NjgyYThkYmI2MDY2MzE3MjhjNjEyYmZhZjNiYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-08-16T09:10:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-08-16T09:10:23Z"}, "message": "ipa-utils.h (ipa_polymorphic_call_context): Turn into class; add ctors.\n\n\n\t* ipa-utils.h (ipa_polymorphic_call_context): Turn into class; add ctors.\n\t(possible_polymorphic_call_targets, dump_possible_polymorphic_call_targets,\n\tpossible_polymorphic_call_target_p, possible_polymorphic_call_target_p): Simplify.\n\t(get_dynamic_type): Remove.\n\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): Remove.\n\t(clear_speculation): Bring to ipa-deivrt.h\n\t(get_class_context): Rename to ...\n\t(ipa_polymorphic_call_context::restrict_to_inner_class): ... this one.\n\t(contains_type_p): Update.\n\t(get_dynamic_type): Rename to ...\n\tipa_polymorphic_call_context::get_dynamic_type(): ... this one.\n\t(possible_polymorphic_call_targets): UPdate.\n\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children): Update.\n\t* ipa-prop.c (ipa_analyze_call_uses): Update.\n\nFrom-SVN: r214060", "tree": {"sha": "b907ef9a6a408c9953805ab48b6f020422eeead2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b907ef9a6a408c9953805ab48b6f020422eeead2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d7cf10d2194682a8dbb606631728c612bfaf3bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d7cf10d2194682a8dbb606631728c612bfaf3bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d7cf10d2194682a8dbb606631728c612bfaf3bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d7cf10d2194682a8dbb606631728c612bfaf3bb/comments", "author": null, "committer": null, "parents": [{"sha": "1a985ca83a4da70b0810727942e02badc70852ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a985ca83a4da70b0810727942e02badc70852ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a985ca83a4da70b0810727942e02badc70852ab"}], "stats": {"total": 306, "additions": 170, "deletions": 136}, "files": [{"sha": "13a15ef7bf9c8e8383328a81979386b9d80f8f0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d7cf10d2194682a8dbb606631728c612bfaf3bb", "patch": "@@ -1,3 +1,20 @@\n+2014-08-15  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.h (ipa_polymorphic_call_context): Turn into class; add ctors.\n+\t(possible_polymorphic_call_targets, dump_possible_polymorphic_call_targets,\n+\tpossible_polymorphic_call_target_p, possible_polymorphic_call_target_p): Simplify.\n+\t(get_dynamic_type): Remove.\n+\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): Remove.\n+\t(clear_speculation): Bring to ipa-deivrt.h\n+\t(get_class_context): Rename to ...\n+\t(ipa_polymorphic_call_context::restrict_to_inner_class): ... this one.\n+\t(contains_type_p): Update.\n+\t(get_dynamic_type): Rename to ...\n+\tipa_polymorphic_call_context::get_dynamic_type(): ... this one.\n+\t(possible_polymorphic_call_targets): UPdate.\n+\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children): Update.\n+\t* ipa-prop.c (ipa_analyze_call_uses): Update.\n+\n 2014-08-15  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* doc/invoke.texi (SH options): Document missing processor variant"}, {"sha": "ba57b86cf4dd644ca4a7a4366ed1d13489cb6902", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 91, "deletions": 107, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=4d7cf10d2194682a8dbb606631728c612bfaf3bb", "patch": "@@ -141,10 +141,6 @@ static bool odr_types_equivalent_p (tree, tree, bool, bool *,\n \n static bool odr_violation_reported = false;\n \n-/* Dummy polymorphic call context.  */\n-\n-const ipa_polymorphic_call_context ipa_dummy_polymorphic_call_context\n-   = {0, 0, NULL, NULL, false, true, true};\n \n /* Pointer set of all call targets appearing in the cache.  */\n static hash_set<cgraph_node *> *cached_polymorphic_call_targets;\n@@ -1853,23 +1849,13 @@ contains_polymorphic_type_p (const_tree type)\n   return false;\n }\n \n-/* Clear speculative info from CONTEXT.  */\n-\n-static void\n-clear_speculation (ipa_polymorphic_call_context *context)\n-{\n-  context->speculative_outer_type = NULL;\n-  context->speculative_offset = 0;\n-  context->speculative_maybe_derived_type = false;\n-}\n-\n-/* CONTEXT->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n-   is contained at CONTEXT->OFFSET.  Walk the memory representation of\n-   CONTEXT->OUTER_TYPE and find the outermost class type that match\n-   EXPECTED_TYPE or contain EXPECTED_TYPE as a base.  Update CONTEXT\n+/* THIS->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n+   is contained at THIS->OFFSET.  Walk the memory representation of\n+   THIS->OUTER_TYPE and find the outermost class type that match\n+   EXPECTED_TYPE or contain EXPECTED_TYPE as a base.  Update THIS\n    to represent it.\n \n-   For example when CONTEXT represents type\n+   For example when THIS represents type\n    class A\n      {\n        int a;\n@@ -1880,32 +1866,31 @@ clear_speculation (ipa_polymorphic_call_context *context)\n    sizeof(int). \n \n    If we can not find corresponding class, give up by setting\n-   CONTEXT->OUTER_TYPE to EXPECTED_TYPE and CONTEXT->OFFSET to NULL. \n+   THIS->OUTER_TYPE to EXPECTED_TYPE and THIS->OFFSET to NULL. \n    Return true when lookup was sucesful.  */\n \n-static bool\n-get_class_context (ipa_polymorphic_call_context *context,\n-\t\t   tree expected_type)\n+bool\n+ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n {\n-  tree type = context->outer_type;\n-  HOST_WIDE_INT offset = context->offset;\n+  tree type = outer_type;\n+  HOST_WIDE_INT cur_offset = offset;\n   bool speculative = false;\n   bool speculation_valid = false;\n   bool valid = false;\n \n- if (!context->outer_type)\n+ if (!outer_type)\n    {\n-     type = context->outer_type = expected_type;\n-     context->offset = offset = 0;\n+     type = outer_type = expected_type;\n+     offset = cur_offset = 0;\n    }\n \n- if (context->speculative_outer_type == context->outer_type\n-     && (!context->maybe_derived_type\n-\t || context->speculative_maybe_derived_type))\n+ if (speculative_outer_type == outer_type\n+     && (!maybe_derived_type\n+\t || speculative_maybe_derived_type))\n    {\n-      context->speculative_outer_type = NULL;\n-      context->speculative_offset = 0;\n-      context->speculative_maybe_derived_type = false;\n+      speculative_outer_type = NULL;\n+      speculative_offset = 0;\n+      speculative_maybe_derived_type = false;\n    }\n \n   /* See if speculative type seem to be derrived from outer_type.\n@@ -1917,14 +1902,14 @@ get_class_context (ipa_polymorphic_call_context *context,\n      MAYBE_DERIVED_TYPE is false and we have full non-speculative information or\n      the loop bellow will correctly update SPECULATIVE_OUTER_TYPE\n      and SPECULATIVE_MAYBE_DERIVED_TYPE.  */\n-  if (context->speculative_outer_type\n-      && context->speculative_offset >= context->offset\n-      && contains_type_p (context->speculative_outer_type,\n-\t\t\t  context->offset - context->speculative_offset,\n-\t\t\t  context->outer_type))\n-    speculation_valid = context->maybe_derived_type;\n+  if (speculative_outer_type\n+      && speculative_offset >= offset\n+      && contains_type_p (speculative_outer_type,\n+\t\t\t  offset - speculative_offset,\n+\t\t\t  outer_type))\n+    speculation_valid = maybe_derived_type;\n   else\n-    clear_speculation (context);\n+    clear_speculation ();\n \t\t\t       \n   /* Find the sub-object the constant actually refers to and mark whether it is\n      an artificial one (as opposed to a user-defined one).\n@@ -1950,19 +1935,19 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t      gcc_assert (valid);\n \n \t      /* If we did not match the offset, just give up on speculation.  */\n-\t      if (offset != 0\n-\t\t  || (types_same_for_odr (context->speculative_outer_type,\n-\t\t\t\t\t  context->outer_type)\n-\t\t      && (context->maybe_derived_type\n-\t\t\t  == context->speculative_maybe_derived_type)))\n-\t\tclear_speculation (context);\n+\t      if (cur_offset != 0\n+\t\t  || (types_same_for_odr (speculative_outer_type,\n+\t\t\t\t\t  outer_type)\n+\t\t      && (maybe_derived_type\n+\t\t\t  == speculative_maybe_derived_type)))\n+\t\tclear_speculation ();\n \t      return true;\n \t    }\n \t  else\n \t    {\n \t      /* Type can not contain itself on an non-zero offset.  In that case\n \t\t just give up.  */\n-\t      if (offset != 0)\n+\t      if (cur_offset != 0)\n \t\t{\n \t\t  valid = false;\n \t\t  goto give_up;\n@@ -1971,17 +1956,17 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t      /* If speculation is not valid or we determined type precisely,\n \t\t we are done.  */\n \t      if (!speculation_valid\n-\t\t  || !context->maybe_derived_type)\n+\t\t  || !maybe_derived_type)\n \t\t{\n-\t\t  clear_speculation (context);\n+\t\t  clear_speculation ();\n \t          return true;\n \t\t}\n \t      /* Otherwise look into speculation now.  */\n \t      else\n \t\t{\n \t\t  speculative = true;\n-\t\t  type = context->speculative_outer_type;\n-\t\t  offset = context->speculative_offset;\n+\t\t  type = speculative_outer_type;\n+\t\t  cur_offset = speculative_offset;\n \t\t  continue;\n \t\t}\n \t    }\n@@ -1997,31 +1982,31 @@ get_class_context (ipa_polymorphic_call_context *context,\n \n \t      pos = int_bit_position (fld);\n \t      size = tree_to_uhwi (DECL_SIZE (fld));\n-\t      if (pos <= offset && (pos + size) > offset)\n+\t      if (pos <= cur_offset && (pos + size) > cur_offset)\n \t\tbreak;\n \t    }\n \n \t  if (!fld)\n \t    goto give_up;\n \n \t  type = TYPE_MAIN_VARIANT (TREE_TYPE (fld));\n-\t  offset -= pos;\n+\t  cur_offset -= pos;\n \t  /* DECL_ARTIFICIAL represents a basetype.  */\n \t  if (!DECL_ARTIFICIAL (fld))\n \t    {\n \t      if (!speculative)\n \t\t{\n-\t\t  context->outer_type = type;\n-\t\t  context->offset = offset;\n+\t\t  outer_type = type;\n+\t\t  offset = cur_offset;\n \t\t  /* As soon as we se an field containing the type,\n \t\t     we know we are not looking for derivations.  */\n-\t\t  context->maybe_derived_type = false;\n+\t\t  maybe_derived_type = false;\n \t\t}\n \t      else\n \t\t{\n-\t\t  context->speculative_outer_type = type;\n-\t\t  context->speculative_offset = offset;\n-\t\t  context->speculative_maybe_derived_type = false;\n+\t\t  speculative_outer_type = type;\n+\t\t  speculative_offset = cur_offset;\n+\t\t  speculative_maybe_derived_type = false;\n \t\t}\n \t    }\n \t}\n@@ -2033,19 +2018,19 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t  if (!tree_fits_shwi_p (TYPE_SIZE (subtype))\n \t      || !tree_to_shwi (TYPE_SIZE (subtype)) <= 0)\n \t    goto give_up;\n-\t  offset = offset % tree_to_shwi (TYPE_SIZE (subtype));\n+\t  cur_offset = cur_offset % tree_to_shwi (TYPE_SIZE (subtype));\n \t  type = subtype;\n \t  if (!speculative)\n \t    {\n-\t      context->outer_type = type;\n-\t      context->offset = offset;\n-\t      context->maybe_derived_type = false;\n+\t      outer_type = type;\n+\t      offset = cur_offset;\n+\t      maybe_derived_type = false;\n \t    }\n \t  else\n \t    {\n-\t      context->speculative_outer_type = type;\n-\t      context->speculative_offset = offset;\n-\t      context->speculative_maybe_derived_type = false;\n+\t      speculative_outer_type = type;\n+\t      speculative_offset = cur_offset;\n+\t      speculative_maybe_derived_type = false;\n \t    }\n \t}\n       /* Give up on anything else.  */\n@@ -2056,13 +2041,13 @@ get_class_context (ipa_polymorphic_call_context *context,\n   /* If we failed to find subtype we look for, give up and fall back to the\n      most generic query.  */\n give_up:\n-  clear_speculation (context);\n+  clear_speculation ();\n   if (valid)\n     return true;\n-  context->outer_type = expected_type;\n-  context->offset = 0;\n-  context->maybe_derived_type = true;\n-  context->maybe_in_construction = true;\n+  outer_type = expected_type;\n+  offset = 0;\n+  maybe_derived_type = true;\n+  maybe_in_construction = true;\n   /* POD can be changed to an instance of a polymorphic type by\n      placement new.  Here we play safe and assume that any\n      non-polymorphic type is POD.  */\n@@ -2071,7 +2056,7 @@ get_class_context (ipa_polymorphic_call_context *context,\n        || !polymorphic_type_binfo_p (TYPE_BINFO (type)))\n       && (!TYPE_SIZE (type)\n \t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t  || (offset + tree_to_uhwi (TYPE_SIZE (expected_type)) <=\n+\t  || (cur_offset + tree_to_uhwi (TYPE_SIZE (expected_type)) <=\n \t      tree_to_uhwi (TYPE_SIZE (type)))))\n     return true;\n   return false;\n@@ -2083,10 +2068,10 @@ static bool\n contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n \t\t tree otr_type)\n {\n-  ipa_polymorphic_call_context context = {offset, 0,\n-\t\t\t\t\t  TYPE_MAIN_VARIANT (outer_type),\n-\t\t\t\t\t  NULL, false, true, false};\n-  return get_class_context (&context, otr_type);\n+  ipa_polymorphic_call_context context;\n+  context.offset = offset;\n+  context.outer_type = TYPE_MAIN_VARIANT (outer_type);\n+  return context.restrict_to_inner_class (otr_type);\n }\n \n /* Lookup base of BINFO that has virtual table VTABLE with OFFSET.  */\n@@ -2834,7 +2819,7 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n     return false;\n }\n \n-/* CONTEXT is polymorphic call context obtained from get_polymorphic_context.\n+/* THIS is polymorphic call context obtained from get_polymorphic_context.\n    OTR_OBJECT is pointer to the instance returned by OBJ_TYPE_REF_OBJECT.\n    INSTANCE is pointer to the outer instance as returned by\n    get_polymorphic_context.  To avoid creation of temporary expressions,\n@@ -2851,19 +2836,18 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n    So it is not suitable for use withing fold_stmt and similar uses.  */\n \n bool\n-get_dynamic_type (tree instance,\n-\t\t  ipa_polymorphic_call_context *context,\n-\t\t  tree otr_object,\n-\t\t  tree otr_type,\n-\t\t  gimple call)\n+ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n+\t\t\t\t\t\ttree otr_object,\n+\t\t\t\t\t\ttree otr_type,\n+\t\t\t\t\t\tgimple call)\n {\n   struct type_change_info tci;\n   ao_ref ao;\n   bool function_entry_reached = false;\n   tree instance_ref = NULL;\n   gimple stmt = call;\n \n-  if (!context->maybe_in_construction && !context->maybe_derived_type)\n+  if (!maybe_in_construction && !maybe_derived_type)\n     return false;\n \n   /* We need to obtain refernce to virtual table pointer.  It is better\n@@ -2916,11 +2900,11 @@ get_dynamic_type (tree instance,\n \t\t     or from INSTANCE with offset OFFSET.  */\n \t\t  if (base_ref\n \t\t      && ((TREE_CODE (base_ref) == MEM_REF\n-\t\t           && ((offset2 == context->offset\n+\t\t           && ((offset2 == offset\n \t\t                && TREE_OPERAND (base_ref, 0) == instance)\n \t\t\t       || (!offset2 && TREE_OPERAND (base_ref, 0) == otr_object)))\n \t\t\t  || (DECL_P (instance) && base_ref == instance\n-\t\t\t      && offset2 == context->offset)))\n+\t\t\t      && offset2 == offset)))\n \t\t    {\n \t\t      stmt = SSA_NAME_DEF_STMT (ref);\n \t\t      instance_ref = ref_exp;\n@@ -2959,13 +2943,13 @@ get_dynamic_type (tree instance,\n       print_generic_expr (dump_file, otr_object, TDF_SLIM);\n       fprintf (dump_file, \"  Outer instance pointer: \");\n       print_generic_expr (dump_file, instance, TDF_SLIM);\n-      fprintf (dump_file, \" offset: %i (bits)\", (int)context->offset);\n+      fprintf (dump_file, \" offset: %i (bits)\", (int)offset);\n       fprintf (dump_file, \" vtbl reference: \");\n       print_generic_expr (dump_file, instance_ref, TDF_SLIM);\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  tci.offset = context->offset;\n+  tci.offset = offset;\n   tci.instance = instance;\n   tci.vtbl_ptr_ref = instance_ref;\n   gcc_assert (TREE_CODE (instance) != MEM_REF);\n@@ -3021,17 +3005,17 @@ get_dynamic_type (tree instance,\n      and we can stop, we will never see the calls into constructors of\n      sub-objects in this code. \n \n-     Therefore if the static outer type was found (context->outer_type)\n+     Therefore if the static outer type was found (outer_type)\n      we can safely ignore tci.speculative that is set on calls and give up\n      only if there was dyanmic type store that may affect given variable\n      (seen_unanalyzed_store)  */\n \n   if (!tci.type_maybe_changed)\n     {\n-      if (!context->outer_type || tci.seen_unanalyzed_store)\n+      if (!outer_type || tci.seen_unanalyzed_store)\n \treturn false;\n-      if (context->maybe_in_construction)\n-        context->maybe_in_construction = false;\n+      if (maybe_in_construction)\n+        maybe_in_construction = false;\n       if (dump_file)\n \tfprintf (dump_file, \"  No dynamic type change found.\\n\");\n       return true;\n@@ -3044,25 +3028,25 @@ get_dynamic_type (tree instance,\n       if (!tci.speculative\n \t  /* Again in instances located in static storage we are interested only\n \t     in constructor stores.  */\n-\t  || (context->outer_type\n+\t  || (outer_type\n \t      && !tci.seen_unanalyzed_store\n-\t      && context->offset == tci.offset\n+\t      && offset == tci.offset\n \t      && types_same_for_odr (tci.known_current_type,\n-\t\t\t\t     context->outer_type)))\n+\t\t\t\t     outer_type)))\n \t{\n-\t  context->outer_type = tci.known_current_type;\n-\t  context->offset = tci.known_current_offset;\n-\t  context->maybe_in_construction = false;\n-\t  context->maybe_derived_type = false;\n+\t  outer_type = tci.known_current_type;\n+\t  offset = tci.known_current_offset;\n+\t  maybe_in_construction = false;\n+\t  maybe_derived_type = false;\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Determined dynamic type.\\n\");\n \t}\n-      else if (!context->speculative_outer_type\n-\t       || context->speculative_maybe_derived_type)\n+      else if (!speculative_outer_type\n+\t       || speculative_maybe_derived_type)\n \t{\n-\t  context->speculative_outer_type = tci.known_current_type;\n-\t  context->speculative_offset = tci.known_current_offset;\n-\t  context->speculative_maybe_derived_type = false;\n+\t  speculative_outer_type = tci.known_current_type;\n+\t  speculative_offset = tci.known_current_offset;\n+\t  speculative_maybe_derived_type = false;\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Determined speculative dynamic type.\\n\");\n \t}\n@@ -3253,7 +3237,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   /* Do not bother to compute speculative info when user do not asks for it.  */\n   if (!speculative_targetsp || !context.speculative_outer_type)\n-    clear_speculation (&context);\n+    context.clear_speculation ();\n \n   type = get_odr_type (otr_type, true);\n \n@@ -3263,7 +3247,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   /* Lookup the outer class type we want to walk.  */\n   if ((context.outer_type || context.speculative_outer_type)\n-      && !get_class_context (&context, otr_type))\n+      && !context.restrict_to_inner_class (otr_type))\n     {\n       if (completep)\n \t*completep = false;\n@@ -3274,7 +3258,7 @@ possible_polymorphic_call_targets (tree otr_type,\n       return nodes;\n     }\n \n-  /* Check that get_class_context kept the main variant.  */\n+  /* Check that restrict_to_inner_class kept the main variant.  */\n   gcc_assert (!context.outer_type\n \t      || TYPE_MAIN_VARIANT (context.outer_type) == context.outer_type);\n "}, {"sha": "a4556f1a49471fcf56c8344b220abd675ad39663", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=4d7cf10d2194682a8dbb606631728c612bfaf3bb", "patch": "@@ -2356,9 +2356,9 @@ ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n \t\t\t\t\t    &otr_type, &otr_token,\n \t\t\t\t\t    &context, call);\n \n-      if (get_dynamic_type (instance, &context,\n-\t\t\t    OBJ_TYPE_REF_OBJECT (target),\n-\t\t\t    otr_type, call))\n+      if (context.get_dynamic_type (instance,\n+\t\t\t\t    OBJ_TYPE_REF_OBJECT (target),\n+\t\t\t\t    otr_type, call))\n \t{\n \t  gcc_assert (TREE_CODE (otr_type) == RECORD_TYPE);\n \t  cs->indirect_info->polymorphic = true;"}, {"sha": "d4980ebaf13305002d9a164491cea96fcc9c9264", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 58, "deletions": 24, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=4d7cf10d2194682a8dbb606631728c612bfaf3bb", "patch": "@@ -36,7 +36,9 @@ struct ipa_dfs_info {\n \n /* Context of polymorphic call.  This is used by ipa-devirt walkers of the\n    type inheritance graph.  */\n-struct ipa_polymorphic_call_context {\n+\n+class ipa_polymorphic_call_context {\n+public:\n   /* The called object appears in an object of type OUTER_TYPE\n      at offset OFFSET.  When information is not 100% reliable, we\n      use SPECULATIVE_OUTER_TYPE and SPECULATIVE_OFFSET. */\n@@ -51,10 +53,58 @@ struct ipa_polymorphic_call_context {\n   /* True if speculative outer object may be of derived type.  We always\n      speculate that construction does not happen.  */\n   bool speculative_maybe_derived_type;\n+\n+  /* Build empty \"I know nothing\" context.  */\n+  ipa_polymorphic_call_context ();\n+\n+  /* Build polymorphic call context for indirect call E.  */\n+  ipa_polymorphic_call_context (cgraph_edge *e);\n+\n+  /* Make context non-speculative.  */\n+  void clear_speculation ();\n+\n+  /* Walk container types and modify context to point to actual class\n+     containing EXPECTED_TYPE as base class.  */\n+  bool restrict_to_inner_class (tree expected_type);\n+\n+  /* Look for vtable stores or constructor calls to work out dynamic type\n+     of memory location.  */\n+  bool get_dynamic_type (tree, tree, tree, gimple);\n };\n \n-/* Context representing \"I know nothing\".  */\n-extern const ipa_polymorphic_call_context ipa_dummy_polymorphic_call_context;\n+/* Build polymorphic call context for indirect call E.  */\n+\n+inline\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context (cgraph_edge *e)\n+{\n+  offset = e->indirect_info->offset;\n+  speculative_offset = e->indirect_info->speculative_offset;\n+  outer_type = e->indirect_info->outer_type;\n+  speculative_outer_type = e->indirect_info->speculative_outer_type;\n+  maybe_in_construction = e->indirect_info->maybe_in_construction;\n+  maybe_derived_type = e->indirect_info->maybe_derived_type;\n+  speculative_maybe_derived_type = e->indirect_info->speculative_maybe_derived_type;\n+}\n+\n+/* Build empty \"I know nothing\" context.  */\n+\n+inline\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context ()\n+ : offset(0), speculative_offset(0), outer_type(NULL),\n+   speculative_outer_type(NULL), maybe_in_construction(false),\n+   maybe_derived_type(false), speculative_maybe_derived_type(false)\n+{\n+}\n+\n+/* Make context non-speculative.  */\n+\n+inline void\n+ipa_polymorphic_call_context::clear_speculation ()\n+{\n+  speculative_outer_type = NULL;\n+  speculative_offset = 0;\n+  speculative_maybe_derived_type = false;\n+}\n \n /* In ipa-utils.c  */\n void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);\n@@ -95,7 +145,6 @@ tree get_polymorphic_call_info (tree, tree, tree *,\n \t\t\t\tHOST_WIDE_INT *,\n \t\t\t\tipa_polymorphic_call_context *,\n \t\t\t\tgimple call = NULL);\n-bool get_dynamic_type (tree, ipa_polymorphic_call_context *, tree, tree, gimple);\n bool get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *,\n \t\t\t\t\t       tree, tree, HOST_WIDE_INT);\n bool decl_maybe_in_construction_p (tree, tree, gimple, tree);\n@@ -121,13 +170,7 @@ possible_polymorphic_call_targets (struct cgraph_edge *e,\n \t\t\t\t   int *nonconstruction_targets = NULL)\n {\n   gcc_checking_assert (e->indirect_info->polymorphic);\n-  ipa_polymorphic_call_context context = {e->indirect_info->offset,\n-\t\t\t\t\t  e->indirect_info->speculative_offset,\n-\t\t\t\t\t  e->indirect_info->outer_type,\n-\t\t\t\t\t  e->indirect_info->speculative_outer_type,\n-\t\t\t\t\t  e->indirect_info->maybe_in_construction,\n-\t\t\t\t\t  e->indirect_info->maybe_derived_type,\n-\t\t\t\t\t  e->indirect_info->speculative_maybe_derived_type};\n+  ipa_polymorphic_call_context context(e);\n   return possible_polymorphic_call_targets (e->indirect_info->otr_type,\n \t\t\t\t\t    e->indirect_info->otr_token,\n \t\t\t\t\t    context,\n@@ -163,13 +206,7 @@ inline void\n dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e)\n {\n   gcc_checking_assert (e->indirect_info->polymorphic);\n-  ipa_polymorphic_call_context context = {e->indirect_info->offset,\n-\t\t\t\t\t  e->indirect_info->speculative_offset,\n-\t\t\t\t\t  e->indirect_info->outer_type,\n-\t\t\t\t\t  e->indirect_info->speculative_outer_type,\n-\t\t\t\t\t  e->indirect_info->maybe_in_construction,\n-\t\t\t\t\t  e->indirect_info->maybe_derived_type,\n-\t\t\t\t\t  e->indirect_info->speculative_maybe_derived_type};\n+  ipa_polymorphic_call_context context(e);\n   dump_possible_polymorphic_call_targets (f, e->indirect_info->otr_type,\n \t\t\t\t\t  e->indirect_info->otr_token,\n \t\t\t\t\t  context);\n@@ -182,11 +219,7 @@ inline bool\n possible_polymorphic_call_target_p (struct cgraph_edge *e,\n \t\t\t\t    struct cgraph_node *n)\n {\n-  ipa_polymorphic_call_context context = {e->indirect_info->offset, 0,\n-\t\t\t\t\t  e->indirect_info->outer_type, NULL,\n-\t\t\t\t\t  e->indirect_info->maybe_in_construction,\n-\t\t\t\t\t  e->indirect_info->maybe_derived_type,\n-\t\t\t\t\t  false};\n+  ipa_polymorphic_call_context context(e);\n   return possible_polymorphic_call_target_p (e->indirect_info->otr_type,\n \t\t\t\t\t     e->indirect_info->otr_token,\n \t\t\t\t\t     context, n);\n@@ -199,10 +232,11 @@ inline bool\n possible_polymorphic_call_target_p (tree call,\n \t\t\t\t    struct cgraph_node *n)\n {\n+  ipa_polymorphic_call_context context;\n   return possible_polymorphic_call_target_p (obj_type_ref_class (call),\n \t\t\t\t\t     tree_to_uhwi\n \t\t\t\t\t       (OBJ_TYPE_REF_TOKEN (call)),\n-\t\t\t\t\t     ipa_dummy_polymorphic_call_context,\n+\t\t\t\t\t     context,\n \t\t\t\t\t     n);\n }\n #endif  /* GCC_IPA_UTILS_H  */"}, {"sha": "f191ec05af3cbf909e8ec91d2a9d50c9298ed39b", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7cf10d2194682a8dbb606631728c612bfaf3bb/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=4d7cf10d2194682a8dbb606631728c612bfaf3bb", "patch": "@@ -4374,8 +4374,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t\t\t\t\t    fn,\n \t\t\t\t\t\t    &otr_type, &otr_token, &context, stmt);\n \n-\t      get_dynamic_type (instance, &context,\n-\t\t\t\tOBJ_TYPE_REF_OBJECT (fn), otr_type, stmt);\n+\t      context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn), otr_type, stmt);\n \n \t      vec <cgraph_node *>targets\n \t\t= possible_polymorphic_call_targets (obj_type_ref_class (fn),"}]}