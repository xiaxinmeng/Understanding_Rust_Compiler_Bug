{"sha": "0a0504855047048c80698790a06b7b25936723e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEwNTA0ODU1MDQ3MDQ4YzgwNjk4NzkwYTA2YjdiMjU5MzY3MjNlNQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-09-09T20:53:41Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-09-09T20:53:41Z"}, "message": "Makefile.def: Remove libbanshee.\n\nToplevel:\n\n2004-09-09  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* Makefile.def: Remove libbanshee.\n\t* Makefile.tpl: Ditto.\n\t* configure.in: Ditto.\n\t* Makefile.in: Regen.\n\t* configure: Ditto.\n\ngcc/\n\n2004-09-09  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* Makefile.in: Remove libbanshee, tree-alias-*.\n\tRemove tree-alias-common.h dependencies.\n\t* common.opt: Remove -ftree-points-to.\n\t* configure.ac: Remove libbanshee.\n\t* flags.h: Remove pta_type, flag_tree_points_to.\n\t* gengtype.c (open_base_files): Remove tree-alias-type.h.\n\t* opts.c (OPT_ftree_points_to): Remove.\n\t* toplev.c: Remove tree-alias-common.h, flag_tree_points_to.\n\t* tree-dfa.c: Remove tree-alias-common.h\n\t* tree-into-ssa.c: Ditto.\n\t* tree-outof-ssa.c: Ditto.\n\t* tree-ssa-copyrename.c: Ditto.\n\t* tree-ssa-live.c: Ditto.\n\t* tree-optimize.c: Ditto.\n\t* tree-ssa.c: Ditto.\n\tRemove pass_build_pta, pass_del_pta.\n\t* tree-pass.h: Ditto.\n\t* tree-ssa-alias.c: Remove tree-alias-common.h.\n\t(struct alias_stats_d):\tRemove pta_queries, pta_resolved.\n\t(pass_may_alias): Remove PROP_pta requirement.\n\t(may_alias_p): Remove pta_queries, pta_resolved, use of andersens.\n\t(get_tmt_for): Ditto.\n\t(dump_alias_stats): Ditto.\n\t* doc/passes.texi: Remove blurb about points-to analysis.\n\t* fortran/Make-lang.in: Remove tree-alias-*.o.\n\nFrom-SVN: r87253", "tree": {"sha": "e6d9fc1af5cc4eae0924109da7c638ebc146d00c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6d9fc1af5cc4eae0924109da7c638ebc146d00c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a0504855047048c80698790a06b7b25936723e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0504855047048c80698790a06b7b25936723e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a0504855047048c80698790a06b7b25936723e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0504855047048c80698790a06b7b25936723e5/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1a404bd99198779b2115d99ab84535a5b7fd9fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a404bd99198779b2115d99ab84535a5b7fd9fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a404bd99198779b2115d99ab84535a5b7fd9fb"}], "stats": {"total": 32530, "additions": 156, "deletions": 32374}, "files": [{"sha": "654023ab4d81c0aca81566880f388b0b2a3ba82b", "filename": "ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -1,3 +1,11 @@\n+2004-09-09  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* Makefile.def: Remove libbanshee.\n+\t* Makefile.tpl: Ditto.\n+\t* configure.in: Ditto.\n+\t* Makefile.in: Regen.\n+\t* configure: Ditto.\n+\n 2004-09-08  David Edelsohn  <edelsohn@gnu.org>\n \n \t* ltmain.sh: Use $pic_object as $non_pic_object if"}, {"sha": "366405a18521afe03683fdd6e97c2d9883c365cd", "filename": "Makefile.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -70,7 +70,6 @@ host_modules= { module= itcl; };\n host_modules= { module= ld; bootstrap=true; };\n host_modules= { module= libcpp; bootstrap=true; };\n host_modules= { module= libgui; };\n-host_modules= { module= libbanshee; bootstrap=true; no_install=true; };\n host_modules= { module= libiberty; bootstrap=true; };\n host_modules= { module= libtool; };\n host_modules= { module= m4; };\n@@ -253,7 +252,6 @@ dependencies = { module=all-gcc; on=all-binutils; };\n dependencies = { module=all-gcc; on=all-gas; };\n dependencies = { module=all-gcc; on=all-ld; };\n dependencies = { module=all-gcc; on=all-zlib; };\n-dependencies = { module=all-gcc; on=all-libbanshee; };\n dependencies = { module=all-gcc; on=all-libcpp; hard=true; };\n dependencies = { module=all-gcc; on=all-build-libiberty; };\n "}, {"sha": "8047c004da80363f182e7c05b5d10d8db950471a", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 721, "changes": 722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -104,7 +104,7 @@ REALLY_SET_LIB_PATH = \\\n   $(RPATH_ENVVAR)=`echo \"$(HOST_LIB_PATH):$(TARGET_LIB_PATH):$$$(RPATH_ENVVAR)\" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR);\n \n # This is the list of directories to be built for the build system.\n-BUILD_CONFIGDIRS = libiberty libbanshee\n+BUILD_CONFIGDIRS = libiberty\n # Build programs are put under this directory.\n BUILD_SUBDIR = @build_subdir@\n # This is set by the configure script to the arguments to use when configuring\n@@ -678,7 +678,6 @@ configure-host:  \\\n     maybe-configure-ld \\\n     maybe-configure-libcpp \\\n     maybe-configure-libgui \\\n-    maybe-configure-libbanshee \\\n     maybe-configure-libiberty \\\n     maybe-configure-libtool \\\n     maybe-configure-m4 \\\n@@ -780,7 +779,6 @@ all-host:  \\\n     maybe-all-ld \\\n     maybe-all-libcpp \\\n     maybe-all-libgui \\\n-    maybe-all-libbanshee \\\n     maybe-all-libiberty \\\n     maybe-all-libtool \\\n     maybe-all-m4 \\\n@@ -877,7 +875,6 @@ info-host:  \\\n     maybe-info-ld \\\n     maybe-info-libcpp \\\n     maybe-info-libgui \\\n-    maybe-info-libbanshee \\\n     maybe-info-libiberty \\\n     maybe-info-libtool \\\n     maybe-info-m4 \\\n@@ -970,7 +967,6 @@ dvi-host:  \\\n     maybe-dvi-ld \\\n     maybe-dvi-libcpp \\\n     maybe-dvi-libgui \\\n-    maybe-dvi-libbanshee \\\n     maybe-dvi-libiberty \\\n     maybe-dvi-libtool \\\n     maybe-dvi-m4 \\\n@@ -1063,7 +1059,6 @@ TAGS-host:  \\\n     maybe-TAGS-ld \\\n     maybe-TAGS-libcpp \\\n     maybe-TAGS-libgui \\\n-    maybe-TAGS-libbanshee \\\n     maybe-TAGS-libiberty \\\n     maybe-TAGS-libtool \\\n     maybe-TAGS-m4 \\\n@@ -1156,7 +1151,6 @@ install-info-host:  \\\n     maybe-install-info-ld \\\n     maybe-install-info-libcpp \\\n     maybe-install-info-libgui \\\n-    maybe-install-info-libbanshee \\\n     maybe-install-info-libiberty \\\n     maybe-install-info-libtool \\\n     maybe-install-info-m4 \\\n@@ -1249,7 +1243,6 @@ installcheck-host:  \\\n     maybe-installcheck-ld \\\n     maybe-installcheck-libcpp \\\n     maybe-installcheck-libgui \\\n-    maybe-installcheck-libbanshee \\\n     maybe-installcheck-libiberty \\\n     maybe-installcheck-libtool \\\n     maybe-installcheck-m4 \\\n@@ -1342,7 +1335,6 @@ mostlyclean-host:  \\\n     maybe-mostlyclean-ld \\\n     maybe-mostlyclean-libcpp \\\n     maybe-mostlyclean-libgui \\\n-    maybe-mostlyclean-libbanshee \\\n     maybe-mostlyclean-libiberty \\\n     maybe-mostlyclean-libtool \\\n     maybe-mostlyclean-m4 \\\n@@ -1435,7 +1427,6 @@ clean-host:  \\\n     maybe-clean-ld \\\n     maybe-clean-libcpp \\\n     maybe-clean-libgui \\\n-    maybe-clean-libbanshee \\\n     maybe-clean-libiberty \\\n     maybe-clean-libtool \\\n     maybe-clean-m4 \\\n@@ -1528,7 +1519,6 @@ distclean-host:  \\\n     maybe-distclean-ld \\\n     maybe-distclean-libcpp \\\n     maybe-distclean-libgui \\\n-    maybe-distclean-libbanshee \\\n     maybe-distclean-libiberty \\\n     maybe-distclean-libtool \\\n     maybe-distclean-m4 \\\n@@ -1621,7 +1611,6 @@ maintainer-clean-host:  \\\n     maybe-maintainer-clean-ld \\\n     maybe-maintainer-clean-libcpp \\\n     maybe-maintainer-clean-libgui \\\n-    maybe-maintainer-clean-libbanshee \\\n     maybe-maintainer-clean-libiberty \\\n     maybe-maintainer-clean-libtool \\\n     maybe-maintainer-clean-m4 \\\n@@ -1771,7 +1760,6 @@ do-check: unstage  \\\n     maybe-check-ld \\\n     maybe-check-libcpp \\\n     maybe-check-libgui \\\n-    maybe-check-libbanshee \\\n     maybe-check-libiberty \\\n     maybe-check-libtool \\\n     maybe-check-m4 \\\n@@ -1883,7 +1871,6 @@ install-host-nogcc:  \\\n     maybe-install-ld \\\n     maybe-install-libcpp \\\n     maybe-install-libgui \\\n-    maybe-install-libbanshee \\\n     maybe-install-libiberty \\\n     maybe-install-libtool \\\n     maybe-install-m4 \\\n@@ -1952,7 +1939,6 @@ install-host:  \\\n     maybe-install-ld \\\n     maybe-install-libcpp \\\n     maybe-install-libgui \\\n-    maybe-install-libbanshee \\\n     maybe-install-libiberty \\\n     maybe-install-libtool \\\n     maybe-install-m4 \\\n@@ -12798,305 +12784,6 @@ maintainer-clean-libgui:\n @endif libgui\n \n \n-.PHONY: configure-libbanshee maybe-configure-libbanshee\n-maybe-configure-libbanshee:\n-@if libbanshee\n-maybe-configure-libbanshee: configure-libbanshee\n-configure-libbanshee:\n-\t@test -f stage_last && exit 0; \\\n-\ttest ! -f libbanshee/Makefile || exit 0; \\\n-\t[ -d libbanshee ] || mkdir libbanshee; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(HOST_EXPORTS) \\\n-\techo Configuring in libbanshee; \\\n-\tcd libbanshee || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  \\.) \\\n-\t    srcdiroption=\"--srcdir=.\"; \\\n-\t    libsrcdir=\".\";; \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\t  *) \\\n-\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\tesac; \\\n-\t$(SHELL) $${libsrcdir}/configure \\\n-\t  $(HOST_CONFIGARGS) $${srcdiroption}  \\\n-\t  || exit 1\n-@endif libbanshee\n-\n-.PHONY: all-libbanshee maybe-all-libbanshee\n-maybe-all-libbanshee:\n-@if libbanshee\n-maybe-all-libbanshee: all-libbanshee\n-all-libbanshee: configure-libbanshee\n-\t@test -f stage_last && exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\t(cd libbanshee && $(MAKE) $(FLAGS_TO_PASS)  all)\n-@endif libbanshee\n-\n-.PHONY: check-libbanshee maybe-check-libbanshee\n-maybe-check-libbanshee:\n-@if libbanshee\n-maybe-check-libbanshee: check-libbanshee\n-\n-check-libbanshee:\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\t(cd libbanshee && $(MAKE) $(FLAGS_TO_PASS) check)\n-\n-@endif libbanshee\n-\n-.PHONY: install-libbanshee maybe-install-libbanshee\n-maybe-install-libbanshee:\n-@if libbanshee\n-maybe-install-libbanshee: install-libbanshee\n-\n-install-libbanshee:\n-\n-@endif libbanshee\n-\n-# Other targets (info, dvi, etc.)\n-\n-.PHONY: maybe-info-libbanshee info-libbanshee\n-maybe-info-libbanshee:\n-@if libbanshee\n-maybe-info-libbanshee: info-libbanshee\n-\n-info-libbanshee: \\\n-    configure-libbanshee \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing info in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          info) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-dvi-libbanshee dvi-libbanshee\n-maybe-dvi-libbanshee:\n-@if libbanshee\n-maybe-dvi-libbanshee: dvi-libbanshee\n-\n-dvi-libbanshee: \\\n-    configure-libbanshee \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing dvi in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          dvi) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-TAGS-libbanshee TAGS-libbanshee\n-maybe-TAGS-libbanshee:\n-@if libbanshee\n-maybe-TAGS-libbanshee: TAGS-libbanshee\n-\n-TAGS-libbanshee: \\\n-    configure-libbanshee \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing TAGS in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          TAGS) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-install-info-libbanshee install-info-libbanshee\n-maybe-install-info-libbanshee:\n-@if libbanshee\n-maybe-install-info-libbanshee: install-info-libbanshee\n-\n-install-info-libbanshee: \\\n-    configure-libbanshee \\\n-    info-libbanshee \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing install-info in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          install-info) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-installcheck-libbanshee installcheck-libbanshee\n-maybe-installcheck-libbanshee:\n-@if libbanshee\n-maybe-installcheck-libbanshee: installcheck-libbanshee\n-\n-installcheck-libbanshee: \\\n-    configure-libbanshee \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing installcheck in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          installcheck) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-mostlyclean-libbanshee mostlyclean-libbanshee\n-maybe-mostlyclean-libbanshee:\n-@if libbanshee\n-maybe-mostlyclean-libbanshee: mostlyclean-libbanshee\n-\n-mostlyclean-libbanshee: \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing mostlyclean in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          mostlyclean) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-clean-libbanshee clean-libbanshee\n-maybe-clean-libbanshee:\n-@if libbanshee\n-maybe-clean-libbanshee: clean-libbanshee\n-\n-clean-libbanshee: \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing clean in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          clean) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-distclean-libbanshee distclean-libbanshee\n-maybe-distclean-libbanshee:\n-@if libbanshee\n-maybe-distclean-libbanshee: distclean-libbanshee\n-\n-distclean-libbanshee: \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing distclean in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          distclean) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-.PHONY: maybe-maintainer-clean-libbanshee maintainer-clean-libbanshee\n-maybe-maintainer-clean-libbanshee:\n-@if libbanshee\n-maybe-maintainer-clean-libbanshee: maintainer-clean-libbanshee\n-\n-maintainer-clean-libbanshee: \n-\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\techo \"Doing maintainer-clean in libbanshee\" ; \\\n-\t(cd libbanshee && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          maintainer-clean) \\\n-\t  || exit 1\n-\n-@endif libbanshee\n-\n-\n .PHONY: configure-libiberty maybe-configure-libiberty\n maybe-configure-libiberty:\n @if libiberty\n@@ -28255,10 +27942,6 @@ stage1-start::\n \t@[ -d stage1-libcpp ] || mkdir stage1-libcpp; \\\n \tset stage1-libcpp libcpp ; @CREATE_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@[ -d stage1-libbanshee ] || mkdir stage1-libbanshee; \\\n-\tset stage1-libbanshee libbanshee ; @CREATE_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@[ -d stage1-libiberty ] || mkdir stage1-libiberty; \\\n \tset stage1-libiberty libiberty ; @CREATE_LINK_TO_DIR@ \n@@ -28294,9 +27977,6 @@ stage1-end::\n @if libcpp\n \t@set libcpp stage1-libcpp ; @UNDO_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@set libbanshee stage1-libbanshee ; @UNDO_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@set libiberty stage1-libiberty ; @UNDO_LINK_TO_DIR@ \n @endif libiberty\n@@ -28325,7 +28005,6 @@ all-stage1:     \\\n   maybe-all-stage1-intl   \\\n   maybe-all-stage1-ld \\\n   maybe-all-stage1-libcpp  \\\n-  maybe-all-stage1-libbanshee \\\n   maybe-all-stage1-libiberty                        \\\n   maybe-all-stage1-zlib       \n \n@@ -28339,7 +28018,6 @@ clean-stage1:     \\\n   maybe-clean-stage1-intl   \\\n   maybe-clean-stage1-ld \\\n   maybe-clean-stage1-libcpp  \\\n-  maybe-clean-stage1-libbanshee \\\n   maybe-clean-stage1-libiberty                        \\\n   maybe-clean-stage1-zlib       \n \n@@ -28776,60 +28454,6 @@ clean-stage1-libcpp:\n @endif libcpp-bootstrap\n \n \n-.PHONY: configure-stage1-libbanshee maybe-configure-stage1-libbanshee\n-.PHONY: all-stage1-libbanshee maybe-all-stage1-libbanshee\n-.PHONY: clean-stage1-libbanshee maybe-clean-stage1-libbanshee\n-\n-maybe-configure-stage1-libbanshee:\n-maybe-all-stage1-libbanshee:\n-maybe-clean-stage1-libbanshee:\n-\n-@if libbanshee-bootstrap\n-maybe-configure-stage1-libbanshee: configure-stage1-libbanshee\n-configure-stage1-libbanshee:\n-\t@$(MAKE) stage1-start\n-\t@[ -f libbanshee/Makefile ] && exit 0 || : ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(HOST_EXPORTS)  \\\n-\techo Configuring stage 1 in libbanshee ; \\\n-\tcd libbanshee || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  \\.) \\\n-\t    srcdiroption=\"--srcdir=.\"; \\\n-\t    libsrcdir=\".\";; \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\t  *) \\\n-\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\tesac; \\\n-\t$(SHELL) $${libsrcdir}/configure \\\n-\t  $(HOST_CONFIGARGS) $${srcdiroption} \\\n-\t  --disable-intermodule \t  --disable-coverage --enable-languages=\"$(STAGE1_LANGUAGES)\" \n-\n-maybe-all-stage1-libbanshee: all-stage1-libbanshee\n-all-stage1-libbanshee: configure-stage1-libbanshee\n-\t@$(MAKE) stage1-start\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(HOST_EXPORTS)  \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\tCFLAGS=\"$(STAGE1_CFLAGS)\" \n-\n-maybe-clean-stage1-libbanshee: clean-stage1-libbanshee\n-clean-stage1-libbanshee:\n-\t@[ -f libbanshee/Makefile ] || [ -f stage1-libbanshee/Makefile ] \\\n-\t  || exit 0 ; \\\n-\t[ -f libbanshee/Makefile ] || $(MAKE) stage1-start ; \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\tCFLAGS=\"$(STAGE1_CFLAGS)\"  clean\n-@endif libbanshee-bootstrap\n-\n-\n .PHONY: configure-stage1-libiberty maybe-configure-stage1-libiberty\n .PHONY: all-stage1-libiberty maybe-all-stage1-libiberty\n .PHONY: clean-stage1-libiberty maybe-clean-stage1-libiberty\n@@ -29003,11 +28627,6 @@ stage2-start::\n \tset stage2-libcpp libcpp ; @CREATE_LINK_TO_DIR@  ; \\\n \tset stage1-libcpp prev-libcpp ; @CREATE_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@[ -d stage2-libbanshee ] || mkdir stage2-libbanshee; \\\n-\tset stage2-libbanshee libbanshee ; @CREATE_LINK_TO_DIR@  ; \\\n-\tset stage1-libbanshee prev-libbanshee ; @CREATE_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@[ -d stage2-libiberty ] || mkdir stage2-libiberty; \\\n \tset stage2-libiberty libiberty ; @CREATE_LINK_TO_DIR@  ; \\\n@@ -29053,10 +28672,6 @@ stage2-end::\n \t@set libcpp stage2-libcpp ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libcpp stage1-libcpp ; @UNDO_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@set libbanshee stage2-libbanshee ; @UNDO_LINK_TO_DIR@  ; \\\n-\tset prev-libbanshee stage1-libbanshee ; @UNDO_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@set libiberty stage2-libiberty ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libiberty stage1-libiberty ; @UNDO_LINK_TO_DIR@ \n@@ -29087,7 +28702,6 @@ all-stage2:     \\\n   maybe-all-stage2-intl   \\\n   maybe-all-stage2-ld \\\n   maybe-all-stage2-libcpp  \\\n-  maybe-all-stage2-libbanshee \\\n   maybe-all-stage2-libiberty                        \\\n   maybe-all-stage2-zlib       \n \n@@ -29101,7 +28715,6 @@ clean-stage2:     \\\n   maybe-clean-stage2-intl   \\\n   maybe-clean-stage2-ld \\\n   maybe-clean-stage2-libcpp  \\\n-  maybe-clean-stage2-libbanshee \\\n   maybe-clean-stage2-libiberty                        \\\n   maybe-clean-stage2-zlib       \n \n@@ -29554,62 +29167,6 @@ clean-stage2-libcpp:\n @endif libcpp-bootstrap\n \n \n-.PHONY: configure-stage2-libbanshee maybe-configure-stage2-libbanshee\n-.PHONY: all-stage2-libbanshee maybe-all-stage2-libbanshee\n-.PHONY: clean-stage2-libbanshee maybe-clean-stage2-libbanshee\n-\n-maybe-configure-stage2-libbanshee:\n-maybe-all-stage2-libbanshee:\n-maybe-clean-stage2-libbanshee:\n-\n-@if libbanshee-bootstrap\n-maybe-configure-stage2-libbanshee: configure-stage2-libbanshee\n-configure-stage2-libbanshee:\n-\t@$(MAKE) stage2-start\n-\t@[ -f libbanshee/Makefile ] && exit 0 || : ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\techo Configuring stage 2 in libbanshee ; \\\n-\tcd libbanshee || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  \\.) \\\n-\t    srcdiroption=\"--srcdir=.\"; \\\n-\t    libsrcdir=\".\";; \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\t  *) \\\n-\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\tesac; \\\n-\t$(SHELL) $${libsrcdir}/configure \\\n-\t  $(HOST_CONFIGARGS) $${srcdiroption} \\\n-\t  @stage2_werror_flag@ \n-\n-maybe-all-stage2-libbanshee: all-stage2-libbanshee\n-all-stage2-libbanshee: configure-stage2-libbanshee\n-\t@$(MAKE) stage2-start\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t \n-\n-maybe-clean-stage2-libbanshee: clean-stage2-libbanshee\n-clean-stage2-libbanshee:\n-\t@[ -f libbanshee/Makefile ] || [ -f stage2-libbanshee/Makefile ] \\\n-\t  || exit 0 ; \\\n-\t[ -f libbanshee/Makefile ] || $(MAKE) stage2-start ; \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t  clean\n-@endif libbanshee-bootstrap\n-\n-\n .PHONY: configure-stage2-libiberty maybe-configure-stage2-libiberty\n .PHONY: all-stage2-libiberty maybe-all-stage2-libiberty\n .PHONY: clean-stage2-libiberty maybe-clean-stage2-libiberty\n@@ -29790,11 +29347,6 @@ stage3-start::\n \tset stage3-libcpp libcpp ; @CREATE_LINK_TO_DIR@  ; \\\n \tset stage2-libcpp prev-libcpp ; @CREATE_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@[ -d stage3-libbanshee ] || mkdir stage3-libbanshee; \\\n-\tset stage3-libbanshee libbanshee ; @CREATE_LINK_TO_DIR@  ; \\\n-\tset stage2-libbanshee prev-libbanshee ; @CREATE_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@[ -d stage3-libiberty ] || mkdir stage3-libiberty; \\\n \tset stage3-libiberty libiberty ; @CREATE_LINK_TO_DIR@  ; \\\n@@ -29840,10 +29392,6 @@ stage3-end::\n \t@set libcpp stage3-libcpp ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libcpp stage2-libcpp ; @UNDO_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@set libbanshee stage3-libbanshee ; @UNDO_LINK_TO_DIR@  ; \\\n-\tset prev-libbanshee stage2-libbanshee ; @UNDO_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@set libiberty stage3-libiberty ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libiberty stage2-libiberty ; @UNDO_LINK_TO_DIR@ \n@@ -29875,7 +29423,6 @@ all-stage3:     \\\n   maybe-all-stage3-intl   \\\n   maybe-all-stage3-ld \\\n   maybe-all-stage3-libcpp  \\\n-  maybe-all-stage3-libbanshee \\\n   maybe-all-stage3-libiberty                        \\\n   maybe-all-stage3-zlib       \n \n@@ -29889,7 +29436,6 @@ clean-stage3:     \\\n   maybe-clean-stage3-intl   \\\n   maybe-clean-stage3-ld \\\n   maybe-clean-stage3-libcpp  \\\n-  maybe-clean-stage3-libbanshee \\\n   maybe-clean-stage3-libiberty                        \\\n   maybe-clean-stage3-zlib       \n \n@@ -30342,62 +29888,6 @@ clean-stage3-libcpp:\n @endif libcpp-bootstrap\n \n \n-.PHONY: configure-stage3-libbanshee maybe-configure-stage3-libbanshee\n-.PHONY: all-stage3-libbanshee maybe-all-stage3-libbanshee\n-.PHONY: clean-stage3-libbanshee maybe-clean-stage3-libbanshee\n-\n-maybe-configure-stage3-libbanshee:\n-maybe-all-stage3-libbanshee:\n-maybe-clean-stage3-libbanshee:\n-\n-@if libbanshee-bootstrap\n-maybe-configure-stage3-libbanshee: configure-stage3-libbanshee\n-configure-stage3-libbanshee:\n-\t@$(MAKE) stage3-start\n-\t@[ -f libbanshee/Makefile ] && exit 0 || : ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\techo Configuring stage 3 in libbanshee ; \\\n-\tcd libbanshee || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  \\.) \\\n-\t    srcdiroption=\"--srcdir=.\"; \\\n-\t    libsrcdir=\".\";; \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\t  *) \\\n-\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\tesac; \\\n-\t$(SHELL) $${libsrcdir}/configure \\\n-\t  $(HOST_CONFIGARGS) $${srcdiroption} \\\n-\t  @stage2_werror_flag@ \n-\n-maybe-all-stage3-libbanshee: all-stage3-libbanshee\n-all-stage3-libbanshee: configure-stage3-libbanshee\n-\t@$(MAKE) stage3-start\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t \n-\n-maybe-clean-stage3-libbanshee: clean-stage3-libbanshee\n-clean-stage3-libbanshee:\n-\t@[ -f libbanshee/Makefile ] || [ -f stage3-libbanshee/Makefile ] \\\n-\t  || exit 0 ; \\\n-\t[ -f libbanshee/Makefile ] || $(MAKE) stage3-start ; \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t  clean\n-@endif libbanshee-bootstrap\n-\n-\n .PHONY: configure-stage3-libiberty maybe-configure-stage3-libiberty\n .PHONY: all-stage3-libiberty maybe-all-stage3-libiberty\n .PHONY: clean-stage3-libiberty maybe-clean-stage3-libiberty\n@@ -30608,11 +30098,6 @@ stage4-start::\n \tset stage4-libcpp libcpp ; @CREATE_LINK_TO_DIR@  ; \\\n \tset stage3-libcpp prev-libcpp ; @CREATE_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@[ -d stage4-libbanshee ] || mkdir stage4-libbanshee; \\\n-\tset stage4-libbanshee libbanshee ; @CREATE_LINK_TO_DIR@  ; \\\n-\tset stage3-libbanshee prev-libbanshee ; @CREATE_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@[ -d stage4-libiberty ] || mkdir stage4-libiberty; \\\n \tset stage4-libiberty libiberty ; @CREATE_LINK_TO_DIR@  ; \\\n@@ -30658,10 +30143,6 @@ stage4-end::\n \t@set libcpp stage4-libcpp ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libcpp stage3-libcpp ; @UNDO_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@set libbanshee stage4-libbanshee ; @UNDO_LINK_TO_DIR@  ; \\\n-\tset prev-libbanshee stage3-libbanshee ; @UNDO_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@set libiberty stage4-libiberty ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libiberty stage3-libiberty ; @UNDO_LINK_TO_DIR@ \n@@ -30693,7 +30174,6 @@ all-stage4:     \\\n   maybe-all-stage4-intl   \\\n   maybe-all-stage4-ld \\\n   maybe-all-stage4-libcpp  \\\n-  maybe-all-stage4-libbanshee \\\n   maybe-all-stage4-libiberty                        \\\n   maybe-all-stage4-zlib       \n \n@@ -30707,7 +30187,6 @@ clean-stage4:     \\\n   maybe-clean-stage4-intl   \\\n   maybe-clean-stage4-ld \\\n   maybe-clean-stage4-libcpp  \\\n-  maybe-clean-stage4-libbanshee \\\n   maybe-clean-stage4-libiberty                        \\\n   maybe-clean-stage4-zlib       \n \n@@ -31160,62 +30639,6 @@ clean-stage4-libcpp:\n @endif libcpp-bootstrap\n \n \n-.PHONY: configure-stage4-libbanshee maybe-configure-stage4-libbanshee\n-.PHONY: all-stage4-libbanshee maybe-all-stage4-libbanshee\n-.PHONY: clean-stage4-libbanshee maybe-clean-stage4-libbanshee\n-\n-maybe-configure-stage4-libbanshee:\n-maybe-all-stage4-libbanshee:\n-maybe-clean-stage4-libbanshee:\n-\n-@if libbanshee-bootstrap\n-maybe-configure-stage4-libbanshee: configure-stage4-libbanshee\n-configure-stage4-libbanshee:\n-\t@$(MAKE) stage4-start\n-\t@[ -f libbanshee/Makefile ] && exit 0 || : ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\techo Configuring stage 4 in libbanshee ; \\\n-\tcd libbanshee || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  \\.) \\\n-\t    srcdiroption=\"--srcdir=.\"; \\\n-\t    libsrcdir=\".\";; \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\t  *) \\\n-\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\tesac; \\\n-\t$(SHELL) $${libsrcdir}/configure \\\n-\t  $(HOST_CONFIGARGS) $${srcdiroption} \\\n-\t  @stage2_werror_flag@ \n-\n-maybe-all-stage4-libbanshee: all-stage4-libbanshee\n-all-stage4-libbanshee: configure-stage4-libbanshee\n-\t@$(MAKE) stage4-start\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t \n-\n-maybe-clean-stage4-libbanshee: clean-stage4-libbanshee\n-clean-stage4-libbanshee:\n-\t@[ -f libbanshee/Makefile ] || [ -f stage4-libbanshee/Makefile ] \\\n-\t  || exit 0 ; \\\n-\t[ -f libbanshee/Makefile ] || $(MAKE) stage4-start ; \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t  clean\n-@endif libbanshee-bootstrap\n-\n-\n .PHONY: configure-stage4-libiberty maybe-configure-stage4-libiberty\n .PHONY: all-stage4-libiberty maybe-all-stage4-libiberty\n .PHONY: clean-stage4-libiberty maybe-clean-stage4-libiberty\n@@ -31423,11 +30846,6 @@ stageprofile-start::\n \tset stageprofile-libcpp libcpp ; @CREATE_LINK_TO_DIR@  ; \\\n \tset stage1-libcpp prev-libcpp ; @CREATE_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@[ -d stageprofile-libbanshee ] || mkdir stageprofile-libbanshee; \\\n-\tset stageprofile-libbanshee libbanshee ; @CREATE_LINK_TO_DIR@  ; \\\n-\tset stage1-libbanshee prev-libbanshee ; @CREATE_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@[ -d stageprofile-libiberty ] || mkdir stageprofile-libiberty; \\\n \tset stageprofile-libiberty libiberty ; @CREATE_LINK_TO_DIR@  ; \\\n@@ -31473,10 +30891,6 @@ stageprofile-end::\n \t@set libcpp stageprofile-libcpp ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libcpp stage1-libcpp ; @UNDO_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@set libbanshee stageprofile-libbanshee ; @UNDO_LINK_TO_DIR@  ; \\\n-\tset prev-libbanshee stage1-libbanshee ; @UNDO_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@set libiberty stageprofile-libiberty ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libiberty stage1-libiberty ; @UNDO_LINK_TO_DIR@ \n@@ -31507,7 +30921,6 @@ all-stageprofile:     \\\n   maybe-all-stageprofile-intl   \\\n   maybe-all-stageprofile-ld \\\n   maybe-all-stageprofile-libcpp  \\\n-  maybe-all-stageprofile-libbanshee \\\n   maybe-all-stageprofile-libiberty                        \\\n   maybe-all-stageprofile-zlib       \n \n@@ -31521,7 +30934,6 @@ clean-stageprofile:     \\\n   maybe-clean-stageprofile-intl   \\\n   maybe-clean-stageprofile-ld \\\n   maybe-clean-stageprofile-libcpp  \\\n-  maybe-clean-stageprofile-libbanshee \\\n   maybe-clean-stageprofile-libiberty                        \\\n   maybe-clean-stageprofile-zlib       \n \n@@ -31974,62 +31386,6 @@ clean-stageprofile-libcpp:\n @endif libcpp-bootstrap\n \n \n-.PHONY: configure-stageprofile-libbanshee maybe-configure-stageprofile-libbanshee\n-.PHONY: all-stageprofile-libbanshee maybe-all-stageprofile-libbanshee\n-.PHONY: clean-stageprofile-libbanshee maybe-clean-stageprofile-libbanshee\n-\n-maybe-configure-stageprofile-libbanshee:\n-maybe-all-stageprofile-libbanshee:\n-maybe-clean-stageprofile-libbanshee:\n-\n-@if libbanshee-bootstrap\n-maybe-configure-stageprofile-libbanshee: configure-stageprofile-libbanshee\n-configure-stageprofile-libbanshee:\n-\t@$(MAKE) stageprofile-start\n-\t@[ -f libbanshee/Makefile ] && exit 0 || : ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\techo Configuring stage profile in libbanshee ; \\\n-\tcd libbanshee || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  \\.) \\\n-\t    srcdiroption=\"--srcdir=.\"; \\\n-\t    libsrcdir=\".\";; \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\t  *) \\\n-\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\tesac; \\\n-\t$(SHELL) $${libsrcdir}/configure \\\n-\t  $(HOST_CONFIGARGS) $${srcdiroption} \\\n-\t  @stage2_werror_flag@ \n-\n-maybe-all-stageprofile-libbanshee: all-stageprofile-libbanshee\n-all-stageprofile-libbanshee: configure-stageprofile-libbanshee\n-\t@$(MAKE) stageprofile-start\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-generate\" \n-\n-maybe-clean-stageprofile-libbanshee: clean-stageprofile-libbanshee\n-clean-stageprofile-libbanshee:\n-\t@[ -f libbanshee/Makefile ] || [ -f stageprofile-libbanshee/Makefile ] \\\n-\t  || exit 0 ; \\\n-\t[ -f libbanshee/Makefile ] || $(MAKE) stageprofile-start ; \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-generate\"  clean\n-@endif libbanshee-bootstrap\n-\n-\n .PHONY: configure-stageprofile-libiberty maybe-configure-stageprofile-libiberty\n .PHONY: all-stageprofile-libiberty maybe-all-stageprofile-libiberty\n .PHONY: clean-stageprofile-libiberty maybe-clean-stageprofile-libiberty\n@@ -32207,11 +31563,6 @@ stagefeedback-start::\n \tset stagefeedback-libcpp libcpp ; @CREATE_LINK_TO_DIR@  ; \\\n \tset stage1-libcpp prev-libcpp ; @CREATE_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@[ -d stagefeedback-libbanshee ] || mkdir stagefeedback-libbanshee; \\\n-\tset stagefeedback-libbanshee libbanshee ; @CREATE_LINK_TO_DIR@  ; \\\n-\tset stage1-libbanshee prev-libbanshee ; @CREATE_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@[ -d stagefeedback-libiberty ] || mkdir stagefeedback-libiberty; \\\n \tset stagefeedback-libiberty libiberty ; @CREATE_LINK_TO_DIR@  ; \\\n@@ -32257,10 +31608,6 @@ stagefeedback-end::\n \t@set libcpp stagefeedback-libcpp ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libcpp stage1-libcpp ; @UNDO_LINK_TO_DIR@ \n @endif libcpp\n-@if libbanshee\n-\t@set libbanshee stagefeedback-libbanshee ; @UNDO_LINK_TO_DIR@  ; \\\n-\tset prev-libbanshee stage1-libbanshee ; @UNDO_LINK_TO_DIR@ \n-@endif libbanshee\n @if libiberty\n \t@set libiberty stagefeedback-libiberty ; @UNDO_LINK_TO_DIR@  ; \\\n \tset prev-libiberty stage1-libiberty ; @UNDO_LINK_TO_DIR@ \n@@ -32291,7 +31638,6 @@ all-stagefeedback:     \\\n   maybe-all-stagefeedback-intl   \\\n   maybe-all-stagefeedback-ld \\\n   maybe-all-stagefeedback-libcpp  \\\n-  maybe-all-stagefeedback-libbanshee \\\n   maybe-all-stagefeedback-libiberty                        \\\n   maybe-all-stagefeedback-zlib       \n \n@@ -32305,7 +31651,6 @@ clean-stagefeedback:     \\\n   maybe-clean-stagefeedback-intl   \\\n   maybe-clean-stagefeedback-ld \\\n   maybe-clean-stagefeedback-libcpp  \\\n-  maybe-clean-stagefeedback-libbanshee \\\n   maybe-clean-stagefeedback-libiberty                        \\\n   maybe-clean-stagefeedback-zlib       \n \n@@ -32758,62 +32103,6 @@ clean-stagefeedback-libcpp:\n @endif libcpp-bootstrap\n \n \n-.PHONY: configure-stagefeedback-libbanshee maybe-configure-stagefeedback-libbanshee\n-.PHONY: all-stagefeedback-libbanshee maybe-all-stagefeedback-libbanshee\n-.PHONY: clean-stagefeedback-libbanshee maybe-clean-stagefeedback-libbanshee\n-\n-maybe-configure-stagefeedback-libbanshee:\n-maybe-all-stagefeedback-libbanshee:\n-maybe-clean-stagefeedback-libbanshee:\n-\n-@if libbanshee-bootstrap\n-maybe-configure-stagefeedback-libbanshee: configure-stagefeedback-libbanshee\n-configure-stagefeedback-libbanshee:\n-\t@$(MAKE) stagefeedback-start\n-\t@[ -f libbanshee/Makefile ] && exit 0 || : ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\techo Configuring stage feedback in libbanshee ; \\\n-\tcd libbanshee || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  \\.) \\\n-\t    srcdiroption=\"--srcdir=.\"; \\\n-\t    libsrcdir=\".\";; \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\t  *) \\\n-\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n-\t    libsrcdir=\"$$s/libbanshee\";; \\\n-\tesac; \\\n-\t$(SHELL) $${libsrcdir}/configure \\\n-\t  $(HOST_CONFIGARGS) $${srcdiroption} \\\n-\t  @stage2_werror_flag@ \n-\n-maybe-all-stagefeedback-libbanshee: all-stagefeedback-libbanshee\n-all-stagefeedback-libbanshee: configure-stagefeedback-libbanshee\n-\t@$(MAKE) stagefeedback-start\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s;  \\\n-\t$(STAGE_HOST_EXPORTS)  \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-use\" \n-\n-maybe-clean-stagefeedback-libbanshee: clean-stagefeedback-libbanshee\n-clean-stagefeedback-libbanshee:\n-\t@[ -f libbanshee/Makefile ] || [ -f stagefeedback-libbanshee/Makefile ] \\\n-\t  || exit 0 ; \\\n-\t[ -f libbanshee/Makefile ] || $(MAKE) stagefeedback-start ; \\\n-\tcd libbanshee && \\\n-\t$(MAKE) $(FLAGS_TO_PASS)  \\\n-\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-use\"  clean\n-@endif libbanshee-bootstrap\n-\n-\n .PHONY: configure-stagefeedback-libiberty maybe-configure-stagefeedback-libiberty\n .PHONY: all-stagefeedback-libiberty maybe-all-stagefeedback-libiberty\n .PHONY: clean-stagefeedback-libiberty maybe-clean-stagefeedback-libiberty\n@@ -33216,14 +32505,6 @@ all-stage3-gcc: maybe-all-stage3-zlib\n all-stage4-gcc: maybe-all-stage4-zlib\n all-stageprofile-gcc: maybe-all-stageprofile-zlib\n all-stagefeedback-gcc: maybe-all-stagefeedback-zlib\n-all-gcc: maybe-all-libbanshee\n-\n-all-stage1-gcc: maybe-all-stage1-libbanshee\n-all-stage2-gcc: maybe-all-stage2-libbanshee\n-all-stage3-gcc: maybe-all-stage3-libbanshee\n-all-stage4-gcc: maybe-all-stage4-libbanshee\n-all-stageprofile-gcc: maybe-all-stageprofile-libbanshee\n-all-stagefeedback-gcc: maybe-all-stagefeedback-libbanshee\n all-gcc: all-libcpp\n \n all-stage1-gcc: all-stage1-libcpp\n@@ -33582,7 +32863,6 @@ all-prebootstrap: maybe-all-gas\n all-prebootstrap: maybe-all-intl\n all-prebootstrap: maybe-all-ld\n all-prebootstrap: maybe-all-libcpp\n-all-prebootstrap: maybe-all-libbanshee\n all-prebootstrap: maybe-all-libiberty\n all-prebootstrap: maybe-all-zlib\n @endif gcc-no-bootstrap"}, {"sha": "d685c39ded58c00a08dd888181f0c962e47f34e2", "filename": "Makefile.tpl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -107,7 +107,7 @@ REALLY_SET_LIB_PATH = \\\n   $(RPATH_ENVVAR)=`echo \"$(HOST_LIB_PATH):$(TARGET_LIB_PATH):$$$(RPATH_ENVVAR)\" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR);\n \n # This is the list of directories to be built for the build system.\n-BUILD_CONFIGDIRS = libiberty libbanshee\n+BUILD_CONFIGDIRS = libiberty\n # Build programs are put under this directory.\n BUILD_SUBDIR = @build_subdir@\n # This is set by the configure script to the arguments to use when configuring"}, {"sha": "35c07a2104e6afad789ffe6288b83d3a996af19c", "filename": "configure", "status": "modified", "additions": 95, "deletions": 97, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -11,8 +11,6 @@\n ac_help=\n ac_default_prefix=/usr/local\n # Any additions from configure.in:\n-ac_help=\"$ac_help\n-  --without-libbanshee   Don't build with libbanshee\"\n ac_help=\"$ac_help\n   --enable-libada        Builds libada directory\"\n ac_help=\"$ac_help\n@@ -593,7 +591,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:597: checking host system type\" >&5\n+echo \"configure:595: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -614,7 +612,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:618: checking target system type\" >&5\n+echo \"configure:616: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -632,7 +630,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:636: checking build system type\" >&5\n+echo \"configure:634: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -687,7 +685,7 @@ test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:691: checking for a BSD compatible install\" >&5\n+echo \"configure:689: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -740,7 +738,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether ln works\"\"... $ac_c\" 1>&6\n-echo \"configure:744: checking whether ln works\" >&5\n+echo \"configure:742: checking whether ln works\" >&5\n if eval \"test \\\"`echo '$''{'acx_cv_prog_LN'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -764,7 +762,7 @@ else\n fi\n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:768: checking whether ln -s works\" >&5\n+echo \"configure:766: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -891,7 +889,7 @@ build_tools=\"build-texinfo build-byacc build-flex build-bison build-m4 build-fix\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libbanshee libcpp\"\n+host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -1084,21 +1082,6 @@ case \"${host}\" in\n     ;;\n esac\n \n-# Check whether --with-libbanshee or --without-libbanshee was given.\n-if test \"${with_libbanshee+set}\" = set; then\n-  withval=\"$with_libbanshee\"\n-  :\n-fi\n-\n-case ${with_libbanshee} in\n-  no)\n-    noconfigdirs=\"$noconfigdirs libbanshee\" ;;\n-  yes|\"\")\n-    with_libbanshee=yes\n-    ;;\n-  *)\n-    { echo \"configure: error: --with-libbanshee can only be empty, \"yes\" or \"no\" (empty defaults to \"yes\".\" 1>&2; exit 1; }\n-esac\n \n # Check whether --enable-libada or --disable-libada was given.\n if test \"${enable_libada+set}\" = set; then\n@@ -1788,7 +1771,7 @@ else\n   # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1792: checking for $ac_word\" >&5\n+echo \"configure:1775: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1818,7 +1801,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1822: checking for $ac_word\" >&5\n+echo \"configure:1805: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1869,7 +1852,7 @@ fi\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1873: checking for $ac_word\" >&5\n+echo \"configure:1856: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1901,7 +1884,7 @@ fi\n fi\n \n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:1905: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n+echo \"configure:1888: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -1912,12 +1895,12 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext << EOF\n \n-#line 1916 \"configure\"\n+#line 1899 \"configure\"\n #include \"confdefs.h\"\n \n main(){return(0);}\n EOF\n-if { (eval echo configure:1921: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1904: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -1943,12 +1926,12 @@ if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:1947: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo \"configure:1930: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1952: checking whether we are using GNU C\" >&5\n+echo \"configure:1935: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1957,7 +1940,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1961: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1944: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1976,7 +1959,7 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1980: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1963: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2043,7 +2026,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}gnatbind\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2047: checking for $ac_word\" >&5\n+echo \"configure:2030: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2075,7 +2058,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"gnatbind\", so it can be a program name with args.\n set dummy gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2079: checking for $ac_word\" >&5\n+echo \"configure:2062: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2108,7 +2091,7 @@ fi\n fi\n \n echo $ac_n \"checking whether compiler driver understands Ada\"\"... $ac_c\" 1>&6\n-echo \"configure:2112: checking whether compiler driver understands Ada\" >&5\n+echo \"configure:2095: checking whether compiler driver understands Ada\" >&5\n if eval \"test \\\"`echo '$''{'acx_cv_cc_gcc_supports_ada'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2141,7 +2124,7 @@ else\n fi\n \n echo $ac_n \"checking how to compare bootstrapped objects\"\"... $ac_c\" 1>&6\n-echo \"configure:2145: checking how to compare bootstrapped objects\" >&5\n+echo \"configure:2128: checking how to compare bootstrapped objects\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_prog_cmp_skip'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2239,9 +2222,9 @@ saved_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"$CFLAGS $gmpinc\"\n # Check GMP actually works\n echo $ac_n \"checking for correct version of gmp.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2243: checking for correct version of gmp.h\" >&5\n+echo \"configure:2226: checking for correct version of gmp.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 2245 \"configure\"\n+#line 2228 \"configure\"\n #include \"confdefs.h\"\n #include \"gmp.h\"\n int main() {\n@@ -2252,7 +2235,7 @@ choke me\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2256: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2239: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"yes\" 1>&6\n else\n@@ -2265,20 +2248,20 @@ rm -f conftest*\n \n if test x\"$have_gmp\" = xyes; then\n   echo $ac_n \"checking for MPFR\"\"... $ac_c\" 1>&6\n-echo \"configure:2269: checking for MPFR\" >&5\n+echo \"configure:2252: checking for MPFR\" >&5\n \n   saved_LIBS=\"$LIBS\"\n   LIBS=\"$LIBS $gmplibs\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2274 \"configure\"\n+#line 2257 \"configure\"\n #include \"confdefs.h\"\n #include <gmp.h>\n #include <mpfr.h>\n int main() {\n mpfr_t n; mpfr_init(n);\n ; return 0; }\n EOF\n-if { (eval echo configure:2282: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2265: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"yes\" 1>&6\n else\n@@ -2721,10 +2704,6 @@ if test x${with_newlib} != xno && echo \" ${target_configdirs} \" | grep \" target-\n   extra_host_args=\"$extra_host_args --with-newlib\"\n fi\n \n-if test x${with_libbanshee} = xyes && echo \" ${configdirs} \" | grep \" libbanshee \" >/dev/null 2>&1; then\n-  extra_host_args=\"$extra_host_args --with-libbanshee\"\n-fi\n-\n # Default to using --with-stabs for certain targets.\n if test x${with_stabs} = x ; then\n   case \"${target}\" in\n@@ -2759,7 +2738,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2766: checking for $ac_word\" >&5\n+echo \"configure:2742: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_BISON'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2794,7 +2773,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2801: checking for $ac_word\" >&5\n+echo \"configure:2777: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_YACC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2829,7 +2808,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2836: checking for $ac_word\" >&5\n+echo \"configure:2812: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_M4'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2864,7 +2843,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2871: checking for $ac_word\" >&5\n+echo \"configure:2847: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_FLEX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2899,7 +2878,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2906: checking for $ac_word\" >&5\n+echo \"configure:2882: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_LEX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2934,7 +2913,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2941: checking for $ac_word\" >&5\n+echo \"configure:2917: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_MAKEINFO'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3568,7 +3547,7 @@ test -n \"$target_alias\" && ncn_target_tool_prefix=$target_alias-\n   # Extract the first word of \"${ncn_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3575: checking for $ac_word\" >&5\n+echo \"configure:3551: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3601,7 +3580,7 @@ if test -z \"$ac_cv_prog_AR\" ; then\n     # Extract the first word of \"ar\", so it can be a program name with args.\n set dummy ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3608: checking for $ac_word\" >&5\n+echo \"configure:3584: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3640,7 +3619,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3647: checking for $ac_word\" >&5\n+echo \"configure:3623: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3673,7 +3652,7 @@ if test -z \"$ac_cv_prog_AS\" ; then\n     # Extract the first word of \"as\", so it can be a program name with args.\n set dummy as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3680: checking for $ac_word\" >&5\n+echo \"configure:3656: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3712,7 +3691,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}dlltool\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3719: checking for $ac_word\" >&5\n+echo \"configure:3695: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3745,7 +3724,7 @@ if test -z \"$ac_cv_prog_DLLTOOL\" ; then\n     # Extract the first word of \"dlltool\", so it can be a program name with args.\n set dummy dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3752: checking for $ac_word\" >&5\n+echo \"configure:3728: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3784,7 +3763,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}ld\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3791: checking for $ac_word\" >&5\n+echo \"configure:3767: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3817,7 +3796,7 @@ if test -z \"$ac_cv_prog_LD\" ; then\n     # Extract the first word of \"ld\", so it can be a program name with args.\n set dummy ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3824: checking for $ac_word\" >&5\n+echo \"configure:3800: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3856,7 +3835,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}nm\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3863: checking for $ac_word\" >&5\n+echo \"configure:3839: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3889,7 +3868,7 @@ if test -z \"$ac_cv_prog_NM\" ; then\n     # Extract the first word of \"nm\", so it can be a program name with args.\n set dummy nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3896: checking for $ac_word\" >&5\n+echo \"configure:3872: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3928,7 +3907,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3935: checking for $ac_word\" >&5\n+echo \"configure:3911: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3961,7 +3940,7 @@ if test -z \"$ac_cv_prog_RANLIB\" ; then\n     # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3968: checking for $ac_word\" >&5\n+echo \"configure:3944: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4000,7 +3979,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}windres\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4007: checking for $ac_word\" >&5\n+echo \"configure:3983: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4033,7 +4012,7 @@ if test -z \"$ac_cv_prog_WINDRES\" ; then\n     # Extract the first word of \"windres\", so it can be a program name with args.\n set dummy windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4040: checking for $ac_word\" >&5\n+echo \"configure:4016: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4072,7 +4051,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}objcopy\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}objcopy; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4079: checking for $ac_word\" >&5\n+echo \"configure:4055: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4105,7 +4084,7 @@ if test -z \"$ac_cv_prog_OBJCOPY\" ; then\n     # Extract the first word of \"objcopy\", so it can be a program name with args.\n set dummy objcopy; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4112: checking for $ac_word\" >&5\n+echo \"configure:4088: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4144,7 +4123,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}objdump\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}objdump; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4151: checking for $ac_word\" >&5\n+echo \"configure:4127: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4177,7 +4156,7 @@ if test -z \"$ac_cv_prog_OBJDUMP\" ; then\n     # Extract the first word of \"objdump\", so it can be a program name with args.\n set dummy objdump; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4184: checking for $ac_word\" >&5\n+echo \"configure:4160: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4223,7 +4202,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4230: checking for $ac_word\" >&5\n+echo \"configure:4206: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4256,7 +4235,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_AR_FOR_TARGET\" ; then\n     # Extract the first word of \"ar\", so it can be a program name with args.\n set dummy ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4263: checking for $ac_word\" >&5\n+echo \"configure:4239: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4295,7 +4274,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4302: checking for $ac_word\" >&5\n+echo \"configure:4278: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4328,7 +4307,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_AS_FOR_TARGET\" ; then\n     # Extract the first word of \"as\", so it can be a program name with args.\n set dummy as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4335: checking for $ac_word\" >&5\n+echo \"configure:4311: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4367,7 +4346,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}dlltool\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4374: checking for $ac_word\" >&5\n+echo \"configure:4350: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4400,7 +4379,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_DLLTOOL_FOR_TARGET\" ; then\n     # Extract the first word of \"dlltool\", so it can be a program name with args.\n set dummy dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4407: checking for $ac_word\" >&5\n+echo \"configure:4383: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4439,7 +4418,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ld\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4446: checking for $ac_word\" >&5\n+echo \"configure:4422: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4472,7 +4451,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_LD_FOR_TARGET\" ; then\n     # Extract the first word of \"ld\", so it can be a program name with args.\n set dummy ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4479: checking for $ac_word\" >&5\n+echo \"configure:4455: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4511,7 +4490,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}nm\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4518: checking for $ac_word\" >&5\n+echo \"configure:4494: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4544,7 +4523,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_NM_FOR_TARGET\" ; then\n     # Extract the first word of \"nm\", so it can be a program name with args.\n set dummy nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4551: checking for $ac_word\" >&5\n+echo \"configure:4527: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4583,7 +4562,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4590: checking for $ac_word\" >&5\n+echo \"configure:4566: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4616,7 +4595,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_RANLIB_FOR_TARGET\" ; then\n     # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4623: checking for $ac_word\" >&5\n+echo \"configure:4599: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4655,7 +4634,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}windres\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4662: checking for $ac_word\" >&5\n+echo \"configure:4638: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4688,7 +4667,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_WINDRES_FOR_TARGET\" ; then\n     # Extract the first word of \"windres\", so it can be a program name with args.\n set dummy windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4695: checking for $ac_word\" >&5\n+echo \"configure:4671: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4773,7 +4752,7 @@ RANLIB_FOR_TARGET=${RANLIB_FOR_TARGET}${extra_ranlibflags_for_target}\n NM_FOR_TARGET=${NM_FOR_TARGET}${extra_nmflags_for_target}\n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:4780: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:4756: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -4820,7 +4799,7 @@ esac\n # gcc for stageN-gcc and stagePREV-gcc for stage(N-1).  In case this is not\n # possible, however, we can resort to mv.\n echo $ac_n \"checking if symbolic links between directories work\"\"... $ac_c\" 1>&6\n-echo \"configure:4827: checking if symbolic links between directories work\" >&5\n+echo \"configure:4803: checking if symbolic links between directories work\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_prog_ln_s_dir'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4934,15 +4913,34 @@ trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15\n # Transform confdefs.h into DEFS.\n # Protect against shell expansion while executing Makefile rules.\n # Protect against Makefile macro expansion.\n-cat > conftest.defs <<\\EOF\n-s%#define \\([A-Za-z_][A-Za-z0-9_]*\\) *\\(.*\\)%-D\\1=\\2%g\n-s%[ \t`~#$^&*(){}\\\\|;'\"<>?]%\\\\&%g\n-s%\\[%\\\\&%g\n-s%\\]%\\\\&%g\n-s%\\$%$$%g\n-EOF\n-DEFS=`sed -f conftest.defs confdefs.h | tr '\\012' ' '`\n-rm -f conftest.defs\n+#\n+# If the first sed substitution is executed (which looks for macros that\n+# take arguments), then we branch to the quote section.  Otherwise,\n+# look for a macro that doesn't take arguments.\n+cat >confdef2opt.sed <<\\_ACEOF\n+t clear\n+: clear\n+s,^[ \t]*#[ \t]*define[ \t][ \t]*\\([^ \t(][^ \t(]*([^)]*)\\)[ \t]*\\(.*\\),-D\\1=\\2,g\n+t quote\n+s,^[ \t]*#[ \t]*define[ \t][ \t]*\\([^ \t][^ \t]*\\)[ \t]*\\(.*\\),-D\\1=\\2,g\n+t quote\n+d\n+: quote\n+s,[ \t`~#$^&*(){}\\\\|;'\"<>?],\\\\&,g\n+s,\\[,\\\\&,g\n+s,\\],\\\\&,g\n+s,\\$,$$,g\n+p\n+_ACEOF\n+# We use echo to avoid assuming a particular line-breaking character.\n+# The extra dot is to prevent the shell from consuming trailing\n+# line-breaks from the sub-command output.  A line-break within\n+# single-quotes doesn't work because, if this script is created in a\n+# platform that uses two characters for line-breaks (e.g., DOS), tr\n+# would break.\n+ac_LF_and_DOT=`echo; echo .`\n+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr \"$ac_LF_and_DOT\" ' .'`\n+rm -f confdef2opt.sed\n \n \n # Without the \"./\", some shells look in PATH for config.status."}, {"sha": "9c32e1209164339eba40b618a43f1a69e1988ce0", "filename": "configure.in", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -136,7 +136,7 @@ build_tools=\"build-texinfo build-byacc build-flex build-bison build-m4 build-fix\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libbanshee libcpp\"\n+host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -308,17 +308,6 @@ case \"${host}\" in\n     ;;\n esac\n \n-AC_ARG_WITH(libbanshee,\n-[  --without-libbanshee   Don't build with libbanshee])\n-case ${with_libbanshee} in\n-  no)\n-    noconfigdirs=\"$noconfigdirs libbanshee\" ;;\n-  yes|\"\")\n-    with_libbanshee=yes\n-    ;;\n-  *)\n-    AC_MSG_ERROR([--with-libbanshee can only be empty, \"yes\" or \"no\" (empty defaults to \"yes\".])\n-esac\n \n AC_ARG_ENABLE(libada,\n [  --enable-libada        Builds libada directory],\n@@ -1526,10 +1515,6 @@ if test x${with_newlib} != xno && echo \" ${target_configdirs} \" | grep \" target-\n   extra_host_args=\"$extra_host_args --with-newlib\"\n fi\n \n-if test x${with_libbanshee} = xyes && echo \" ${configdirs} \" | grep \" libbanshee \" >/dev/null 2>&1; then\n-  extra_host_args=\"$extra_host_args --with-libbanshee\"\n-fi\n-\n # Default to using --with-stabs for certain targets.\n if test x${with_stabs} = x ; then\n   case \"${target}\" in"}, {"sha": "99aab874f9ef85bc52cb9d2c68779e1326e7fd0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -1,3 +1,31 @@\n+2004-09-09  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* Makefile.in: Remove libbanshee, tree-alias-*.\n+\tRemove tree-alias-common.h dependencies.\n+\t* common.opt: Remove -ftree-points-to.\n+\t* configure.ac: Remove libbanshee.\n+\t* flags.h: Remove pta_type, flag_tree_points_to.\n+\t* gengtype.c (open_base_files): Remove tree-alias-type.h.\n+\t* opts.c (OPT_ftree_points_to): Remove.\n+\t* toplev.c: Remove tree-alias-common.h, flag_tree_points_to.\n+\t* tree-dfa.c: Remove tree-alias-common.h\n+\t* tree-into-ssa.c: Ditto.\n+\t* tree-outof-ssa.c: Ditto.\n+\t* tree-ssa-copyrename.c: Ditto.\n+\t* tree-ssa-live.c: Ditto.\n+\t* tree-optimize.c: Ditto.\n+\t* tree-ssa.c: Ditto.\n+\tRemove pass_build_pta, pass_del_pta.\n+\t* tree-pass.h: Ditto.\n+\t* tree-ssa-alias.c: Remove tree-alias-common.h.\n+\t(struct alias_stats_d):\tRemove pta_queries, pta_resolved.\n+\t(pass_may_alias): Remove PROP_pta requirement.\n+\t(may_alias_p): Remove pta_queries, pta_resolved, use of andersens.\n+\t(get_tmt_for): Ditto.\n+\t(dump_alias_stats): Ditto.\n+\t* doc/passes.texi: Remove blurb about points-to analysis.\n+\t* fortran/Make-lang.in: Remove tree-alias-*.o.\n+\t\n 2004-09-09  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* genattrtab.c (write_insn_cases): New function, split out from"}, {"sha": "01c771775a351a4f659440c681ad903800ae9a01", "filename": "gcc/Makefile.in", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -200,8 +200,6 @@ SYSCALLS.c.X-warn = -Wno-strict-prototypes -Wno-error\n # recognizing that the loop will always be executed at least once.  We need\n # a new loop optimizer.\n reload1.o-warn = -Wno-error\n-# These warnings are due to libbanshee.\n-tree-alias-ander.o-warn = -Wno-error\n \n # All warnings have to be shut off in stage1 if the compiler used then\n # isn't gcc; configure determines that.  WARN_CFLAGS will be either\n@@ -286,9 +284,6 @@ ZLIBINC = @zlibinc@\n GMPLIBS = @GMPLIBS@\n GMPINC = @GMPINC@\n \n-BANSHEELIB = @BANSHEELIB@\n-BANSHEEINC = @BANSHEEINC@\n-\n CPPLIB = ../libcpp/libcpp.a\n CPPINC = -I$(srcdir)/../libcpp/include\n \n@@ -757,15 +752,15 @@ LIBIBERTY = ../libiberty/libiberty.a\n BUILD_LIBIBERTY = ../$(build_subdir)/libiberty/libiberty.a\n \n # Dependencies on the intl and portability libraries.\n-LIBDEPS= $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP) $(BANSHEELIB)\n+LIBDEPS= $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP)\n \n # Likewise, for use in the tools that must run on this machine\n # even if we are cross-building GCC.\n BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n \n # How to link with both our special library facilities\n # and the system's installed libraries.\n-LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(BANSHEELIB) $(LIBIBERTY)\n+LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY)\n \n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n@@ -794,7 +789,7 @@ BUILD_VARRAY = build-varray.o\n # libintl.h will be found in ../intl if we are using the included libintl.\n INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \\\n \t   -I$(srcdir)/../include @INCINTL@ \\\n-\t   $(CPPINC) $(BANSHEEINC) $(GMPINC)\n+\t   $(CPPINC) $(GMPINC)\n \n .c.o:\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n@@ -890,9 +885,9 @@ C_OBJS = c-parse.o c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n OBJS-common = \\\n  tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t\t\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n- tree-alias-type.o gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n- tree-outof-ssa.o tree-alias-common.o tree-ssa-ccp.o tree-vn.o             \\\n- @ANDER@ tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o  \\\n+ gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n+ tree-outof-ssa.o tree-ssa-ccp.o tree-vn.o             \\\n+ tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o  \\\n  tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \\\n  tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n@@ -1556,7 +1551,7 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \tvarray.h $(HASHTAB_H) $(SPLAY_TREE_H) bitmap.h $(TREE_H) $(RTL_H) \\\n \tfunction.h insn-config.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n \tcselib.h insn-addr.h $(OPTABS_H) libfuncs.h debug.h $(GGC_H) \\\n-\tcgraph.h tree-alias-type.h $(TREE_FLOW_H) reload.h $(CPP_ID_DATA_H)\n+\tcgraph.h $(TREE_FLOW_H) reload.h $(CPP_ID_DATA_H)\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n@@ -1599,31 +1594,19 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(PARAMS_H) $(FLAGS_H) function.h $(EXPR_H) $(RTL_H) toplev.h \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) \\\n    langhooks.h $(REGS_H)\n-tree-alias-type.o: tree-alias-type.c tree-alias-type.h $(SYSTEM_H) $(CONFIG_H) \\\n-   $(GGC_H) $(TM_H) coretypes.h $(VARRAY_H)\n-tree-alias-ander.o: tree-alias-ander.c tree-alias-ander.h $(SYSTEM_H) \\\n-   $(CONFIG_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) tree-alias-common.h \\\n-   $(TM_H) coretypes.h cgraph.h tree-pass.h\n-tree-alias-common.o: tree-alias-common.c tree-alias-common.h $(SYSTEM_H) \\\n-   $(CONFIG_H) $(GGC_H) $(TREE_H) gt-tree-alias-common.h $(TREE_FLOW_H) \\\n-   $(TM_H) coretypes.h cgraph.h tree-pass.h $(TIMEVAR_H) tree-alias-type.h \\\n-   bitmap.h tree-alias-ander.h $(FLAGS_H) $(RTL_H) $(TM_P_H) \\\n-   hard-reg-set.h $(BASIC_BLOCK_H) output.h errors.h $(EXPR_H) \\\n-   $(DIAGNOSTIC_H) $(C_COMMON_H) tree-inline.h varray.h $(C_TREE_H) \\\n-   $(TREE_GIMPLE_H) $(HASHTAB_H) function.h\n tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n-   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h $(CFGLOOP_H) \\\n    tree-pass.h\n tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n-   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h domwalk.h tree-pass.h \\\n    $(GGC_H)\n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n-   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h domwalk.h \\\n    tree-pass.h $(TREE_SSA_LIVE_H)\n tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -1665,12 +1648,12 @@ domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) domwalk.h $(GGC_H)\n tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n-   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H)\n tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    diagnostic.h errors.h toplev.h function.h $(TIMEVAR_H) tree-pass.h \\\n-   tree-alias-common.h $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H)\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H)\n tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n    $(GGC_H) output.h diagnostic.h errors.h toplev.h $(TIMEVAR_H) \\\n@@ -1697,7 +1680,7 @@ tree-iterator.o : tree-iterator.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n    errors.h tree-inline.h $(HASHTAB_H) $(FLAGS_H) function.h $(TIMEVAR_H) \\\n-   tree-alias-common.h convert.h $(TM_H) coretypes.h langhooks.h \\\n+   convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) tree-pass.h params.h\n tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(GGC_H) diagnostic.h errors.h \\\n@@ -1736,11 +1719,11 @@ tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    tree-pass.h flags.h\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n-   function.h $(TIMEVAR_H) tree-alias-common.h convert.h $(TM_H) coretypes.h \\\n+   function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h \\\n    langhooks.h $(TREE_DUMP_H) tree-pass.h params.h\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n-   $(GGC_H) output.h diagnostic.h errors.h $(FLAGS_H) tree-alias-common.h \\\n+   $(GGC_H) output.h diagnostic.h errors.h $(FLAGS_H) \\\n    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h function.h \\\n    langhooks.h $(FLAGS_H) cgraph.h tree-inline.h tree-mudflap.h $(GGC_H) \\\n    cgraph.h tree-pass.h\n@@ -2430,8 +2413,6 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-phinodes.c $(srcdir)/tree-cfg.c \\\n   $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-propagate.c \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n-  $(srcdir)/tree-alias-type.h $(srcdir)/tree-alias-common.h \\\n-  $(srcdir)/tree-alias-type.c $(srcdir)/tree-alias-common.c \\\n   $(srcdir)/tree-chrec.h \\\n   $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \\\n   $(srcdir)/tree-profile.c $(srcdir)/rtl-profile.c $(srcdir)/tree-nested.c \\\n@@ -2451,7 +2432,7 @@ gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \\\n gt-dwarf2out.h gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parse.h \\\n gt-c-pragma.h gtype-c.h gt-input.h gt-cfglayout.h \\\n-gt-tree-alias-common.h gt-tree-mudflap.h \\\n+gt-tree-mudflap.h \\\n gt-tree-ssa-ccp.h gt-tree-eh.h \\\n gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-cfg.h gt-tree-nested.h \\"}, {"sha": "619740c24de85838bb5ee9f0d7cf20a7eabff502", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -876,9 +876,6 @@ ftree-loop-optimize\n Common Report Var(flag_tree_loop_optimize) Init(1)\n Enable loop optimizations on tree level\n \n-ftree-points-to=\n-Common Joined RejectNegative\n-\n ftree-pre\n Common Report Var(flag_tree_pre)\n Enable SSA-PRE optimization on trees"}, {"sha": "e44ca74819f9ad691e43dfa2e7523f3309581c5c", "filename": "gcc/configure", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -309,7 +309,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP strict1_warn warn_cflags WERROR nocommon_flag TREEBROWSER EGREP valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR stage1_cflags COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file PACKAGE VERSION USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS STMP_FIXINC STMP_FIXPROTO collect2 libgcc_visibility GGC zlibdir zlibinc MAINT ANDER BANSHEEINC BANSHEELIB gcc_tooldir dollar slibdir objdir subdirs srcdir all_boot_languages all_compilers all_gtfiles all_gtfiles_files_langs all_gtfiles_files_files all_lang_makefrags all_lang_makefiles all_languages all_stagestuff build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines check_languages cc_set_by_configure quoted_cc_set_by_configure cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir libstdcxx_incdir gcc_version gcc_version_full gcc_version_trigger host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file stage_prefix_set_by_configure quoted_stage_prefix_set_by_configure symbolic_link thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs target_cpu_default GMPLIBS GMPINC LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP strict1_warn warn_cflags WERROR nocommon_flag TREEBROWSER EGREP valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR stage1_cflags COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file PACKAGE VERSION USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS STMP_FIXINC STMP_FIXPROTO collect2 libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir objdir subdirs srcdir all_boot_languages all_compilers all_gtfiles all_gtfiles_files_langs all_gtfiles_files_files all_lang_makefrags all_lang_makefiles all_languages all_stagestuff build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines check_languages cc_set_by_configure quoted_cc_set_by_configure cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir libstdcxx_incdir gcc_version gcc_version_full gcc_version_trigger host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file stage_prefix_set_by_configure quoted_stage_prefix_set_by_configure symbolic_link thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs target_cpu_default GMPLIBS GMPINC LIBOBJS LTLIBOBJS'\n ac_subst_files='language_hooks'\n \n # Initialize some variables set by options.\n@@ -925,7 +925,6 @@ Optional Packages:\n   --with-gc={page,zone}   choose the garbage collection mechanism to use\n                           with the compiler\n   --with-system-zlib      use installed libz\n-  --with-libbanshee\t  enable libbanshee\n   --with-slibdir=DIR      shared libraries in DIR LIBDIR\n \n Some influential environment variables:\n@@ -5291,7 +5290,7 @@ if test \"${gcc_cv_prog_makeinfo_modern+set}\" = set; then\n else\n     ac_prog_version=`$MAKEINFO --version 2>&1 |\n                    sed -n 's/^.*GNU texinfo.* \\([0-9][0-9.]*\\).*$/\\1/p'`\n-  echo \"configure:5294: version of makeinfo is $ac_prog_version\" >&5\n+  echo \"configure:5293: version of makeinfo is $ac_prog_version\" >&5\n   case $ac_prog_version in\n     '')     gcc_cv_prog_makeinfo_modern=no;;\n     4.[2-9]*)\n@@ -12186,38 +12185,6 @@ else\n   MAINT='#'\n fi\n \n-echo \"$as_me:$LINENO: checking whether to use libbanshee for points-to alias analysis\" >&5\n-echo $ECHO_N \"checking whether to use libbanshee for points-to alias analysis... $ECHO_C\" >&6\n-\n-# Check whether --with-libbanshee or --without-libbanshee was given.\n-if test \"${with_libbanshee+set}\" = set; then\n-  withval=\"$with_libbanshee\"\n-  libbanshee=\"$with_libbanshee\"\n-else\n-  libbanshee=no\n-fi;\n-\n-if test x\"$libbanshee\" = xyes; then\n-\tBANSHEELIB=\"../libbanshee/points-to/libandersen.a ../libbanshee/engine/libbansheeengine.a ../libbanshee/libcompat/libbansheecompat.a \"\n-\tBANSHEEINC=\"-I\\$(srcdir)/../libbanshee/libcompat -I\\$(srcdir)/../libbanshee -I\\$(srcdir)/../libbanshee/points-to\"\n-\tANDER=\"tree-alias-ander.o\"\n-\n-cat >>confdefs.h <<\\_ACEOF\n-#define HAVE_BANSHEE 1\n-_ACEOF\n-\n-else\n-\tBANSHEELIB=\"\"\n-\tBANSHEEINC=\"\"\n-\tANDER=\"\"\n-fi\n-echo \"$as_me:$LINENO: result: $with_libbanshee\" >&5\n-echo \"${ECHO_T}$with_libbanshee\" >&6\n-\n-\n-\n-\n-\n # --------------\n # Language hooks\n # --------------\n@@ -13250,9 +13217,6 @@ s,@GGC@,$GGC,;t t\n s,@zlibdir@,$zlibdir,;t t\n s,@zlibinc@,$zlibinc,;t t\n s,@MAINT@,$MAINT,;t t\n-s,@ANDER@,$ANDER,;t t\n-s,@BANSHEEINC@,$BANSHEEINC,;t t\n-s,@BANSHEELIB@,$BANSHEELIB,;t t\n s,@gcc_tooldir@,$gcc_tooldir,;t t\n s,@dollar@,$dollar,;t t\n s,@slibdir@,$slibdir,;t t"}, {"sha": "6dbb802146041b4ba971b42fd5af756515e3ac4c", "filename": "gcc/configure.ac", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -2973,28 +2973,6 @@ else\n fi\n AC_SUBST(MAINT)dnl\n \n-AC_MSG_CHECKING([whether to use libbanshee for points-to alias analysis])\n-AC_ARG_WITH(libbanshee,\n-[  --with-libbanshee\t  enable libbanshee],\n-libbanshee=\"$with_libbanshee\",\n-libbanshee=no)\n-\n-if test x\"$libbanshee\" = xyes; then\n-\tBANSHEELIB=\"../libbanshee/points-to/libandersen.a ../libbanshee/engine/libbansheeengine.a ../libbanshee/libcompat/libbansheecompat.a \"\n-\tBANSHEEINC=\"-I\\$(srcdir)/../libbanshee/libcompat -I\\$(srcdir)/../libbanshee -I\\$(srcdir)/../libbanshee/points-to\"\n-\tANDER=\"tree-alias-ander.o\"\n-\tAC_DEFINE(HAVE_BANSHEE, 1, [Define if BANSHEE is available])\n-else\n-\tBANSHEELIB=\"\"\n-\tBANSHEEINC=\"\"\n-\tANDER=\"\"\n-fi\n-AC_MSG_RESULT($with_libbanshee)\n-\n-AC_SUBST(ANDER)\n-AC_SUBST(BANSHEEINC)\n-AC_SUBST(BANSHEELIB)\n-\n # --------------\n # Language hooks\n # --------------"}, {"sha": "0ffeae757e905dadae54fed9701783e0c4fd7378", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -240,12 +240,6 @@ for the variable within this function.  This data is needed by the\n SSA rewriting routines.  The pass is located in @file{tree-dfa.c}\n and is described by @code{pass_referenced_vars}.\n \n-@item Points-to analysis\n-\n-This pass constructs flow-insensitive alias analysis information.\n-The pass is located in @file{tree-alias-common.c} and described by\n-@code{pass_build_pta}.\n-\n @item Enter static single assignment form\n \n This pass rewrites the function such that it is in SSA form.  After"}, {"sha": "78c6d5a88851f56d2bd579482da5f5e0d2e11606", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -240,14 +240,6 @@ extern enum graph_dump_types graph_dump_format;\n    and to print them when we are done.  */\n extern int flag_detailed_statistics;\n \n-/* Enable points-to analysis on trees.  */\n-enum pta_type\n-  {\n-    PTA_NONE,\n-    PTA_ANDERSEN\n-  };\n-extern enum pta_type flag_tree_points_to;\n-\n extern int flag_web;\n \n /* Nonzero means that we defer emitting functions until they are actually"}, {"sha": "9517f56ffa64c649cb12d3ba4edf3c48d172252f", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -83,7 +83,7 @@ F95_OBJS = $(F95_PARSER_OBJS) \\\n F95_ADDITIONAL_OBJS = \\\n \ttree-cfg.o tree-dfa.o tree-optimize.o tree-gimple.o \\\n \ttree-ssa.o tree-ssa-ccp.o tree-ssa-dce.o \\\n-\ttree-alias-common.o tree-alias-type.o gimplify.o stor-layout.o\n+\tgimplify.o stor-layout.o\n \n # GFORTRAN uses GMP for its internal arithmetics.\n F95_LIBS = $(GMPLIBS) $(LIBS)"}, {"sha": "aaf69f42f14ae61f9af28bb888918b72a058161c", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -1085,7 +1085,7 @@ open_base_files (void)\n       \"function.h\", \"insn-config.h\", \"expr.h\", \"hard-reg-set.h\",\n       \"basic-block.h\", \"cselib.h\", \"insn-addr.h\", \"optabs.h\",\n       \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n-      \"tree-alias-type.h\", \"tree-flow.h\", \"reload.h\",\n+      \"tree-flow.h\", \"reload.h\",\n       \"cpp-id-data.h\",\n       \"tree-chrec.h\",\n       NULL"}, {"sha": "d570b8fe7f0f8f788e042928d22371e0e1de3e52", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -954,22 +954,6 @@ common_handle_option (size_t scode, const char *arg, int value)\n       flag_tracer_set = true;\n       break;\n \n-    case OPT_ftree_points_to_:\n-      if (!strcmp (arg, \"andersen\"))\n-#ifdef HAVE_BANSHEE\n-        flag_tree_points_to = PTA_ANDERSEN;\n-#else\n-        warning (\"Andersen's PTA not available - libbanshee not compiled.\");\n-#endif\n-      else if (!strcmp (arg, \"none\"))\n-\tflag_tree_points_to = PTA_NONE;\n-      else\n-\t{\n-\t  warning (\"`%s`: unknown points-to analysis algorithm\", arg);\n-\t  return 0;\n-\t}\n-      break;\n-\n     case OPT_funroll_loops:\n       flag_unroll_loops_set = true;\n       break;"}, {"sha": "eeb111df3c5d09d81d3edd597ee78178699069dd", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -74,7 +74,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n-#include \"tree-alias-common.h\" \n #include \"cfgloop.h\"\n #include \"hosthooks.h\"\n #include \"cgraph.h\"\n@@ -332,9 +331,6 @@ rtx stack_limit_rtx;\n    one, unconditionally renumber instruction UIDs.  */\n int flag_renumber_insns = 1;\n \n-/* Enable points-to analysis on trees.  */\n-enum pta_type flag_tree_points_to = PTA_NONE;\n-\n /* Nonzero if we should track variables.  When\n    flag_var_tracking == AUTODETECT_FLAG_VAR_TRACKING it will be set according\n    to optimize, debug_info_level and debug_hooks in process_options ().  */"}, {"sha": "471a7fd99f30bd74b987371e058f93668bee0593", "filename": "gcc/tree-alias-ander.c", "status": "removed", "additions": 0, "deletions": 933, "changes": 933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-ander.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-ander.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-ander.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,933 +0,0 @@\n-/* Tree based Andersen points-to analysis\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-*/\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"ggc.h\"\n-#include \"bitmap.h\"\n-#include \"tree-alias-type.h\"\n-#include \"tree-alias-ander.h\"\n-#include \"flags.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"output.h\"\n-#include \"errors.h\"\n-#include \"expr.h\"\n-#include \"diagnostic.h\"\n-#include \"tree.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-inline.h\"\n-#include \"varray.h\"\n-#include \"tree-gimple.h\"\n-#include \"splay-tree.h\"\n-#include \"engine/util.h\"\n-#include \"libcompat/regions.h\"\n-#include \"andersen_terms.h\"\n-#include \"cgraph.h\"\n-#include \"tree-pass.h\"\n-\n-\n-/*  Andersen's interprocedural points-to analysis.\n-    This is a flow-insensitive, context insensitive algorithm.\n-\n-    This file is an implementation of the alias_ops structure used by\n-    tree-alias-common.c to drive PTA analysis. \n-    \n-    All these functions do is generate constraints for and through\n-    libbanshee. When we query for a points-to set, we ask libbanshee\n-    to solve the constraints and give us the answer.  The terms of the\n-    constraints are the aterms, which are an opaque data structure\n-    that stores libbanshee specific data for the constraints.  \n-\n-    The constraints to be generated come from andersen's paper. By\n-    constraint, we mean something like \"the points-to set of A must be\n-    a subset or equal to the points-to set of B\" or \"the points-to set\n-    of A must include Q\".  In order to avoid having to write all the\n-    constraints directly in the code, we use helper functions such as\n-    pta_assignment, pta_rvalue, etc, that generate the necessary\n-    constraint terms  for us, making for much more readable code.\n-\n-    One could replace libbanshee with some other constraint solving\n-    engine, and you'd simply have to replace the implementation of the\n-    pta_* functions, and provide replacements for the aterm specific\n-    functions (like making a list of aterms, printing the label of an\n-    aterm).  However, libbanshee is extremely fast, and extremely low\n-    memory usage, so one would be hard pressed to do better than it\n-    anyway.    \n-\n-    Understanding how constraint solving and what each constraint means is\n-    beyond the scope of this documentation.  See the libbanshee\n-    documentation, and references therein for more enlightenment.\n-    \n-    That said, our constraints inclusion constraints of set\n-    expressions.  Given the helper functions, the various inference\n-    functions we implement should *look* relatively straightforward.  \n-\n-    In order to save time during queries, we cache the resulting\n-    points-to sets of each variable, rather than recalculate them\n-    again and again. (libbanshee actually has it's own internal\n-    caching, but the function call overhead for calling the solver is\n-    non-trivial, given the number of queries).\n-\n-    Todo: Don't pass alias ops as first argument, just have a global\n-    \"current_alias_ops\".  */\n-\t\t\t\t\n-static unsigned int id_num = 1;\n-static region andersen_rgn;\n-static void andersen_simple_assign (struct tree_alias_ops *,\n-\t\t\t\t    alias_var, alias_var);\n-static void andersen_addr_assign (struct tree_alias_ops *,\n-\t\t\t\t  alias_var, alias_var);\n-static void andersen_ptr_assign (struct tree_alias_ops *,\n-\t\t\t\t alias_var, alias_var);\n-static void andersen_op_assign (struct tree_alias_ops *,\n-\t\t\t\talias_var, varray_type, tree, bitmap);\n-static void andersen_heap_assign (struct tree_alias_ops *, alias_var);\n-static void andersen_assign_ptr (struct tree_alias_ops *,\n-\t\t\t\t alias_var, alias_var);\n-static void andersen_function_def (struct tree_alias_ops *, alias_var,\n-\t\t\t\t   varray_type, alias_var);\n-static int andersen_function_call (struct tree_alias_ops *, alias_var,\n-\t\t\t\t   alias_var, varray_type, bitmap);\n-static void andersen_init (struct tree_alias_ops *);\n-static int print_out_result (splay_tree_node, void *);\n-static void andersen_cleanup (struct tree_alias_ops *);\n-static bool andersen_may_alias (struct tree_alias_ops *, alias_var,\n-\t\t\t\talias_var);\n-static bool andersen_same_points_to_set (struct tree_alias_ops *, \n-\t\t\t\t\t alias_var, alias_var);\n-static bool andersen_empty_points_to_set (struct tree_alias_ops *,\n-\t\t\t\t\t  alias_var);\n-static alias_var andersen_add_var (struct tree_alias_ops *, tree);\n-static alias_var andersen_add_var_same (struct tree_alias_ops *,\n-\t\t\t\t\t    tree, alias_var);\n-static bool pointer_destroying_op (tree);\n-static aterm_list get_ptset (alias_var);\n-static splay_tree ptamap;\n-\n-\n-static struct tree_alias_ops andersen_ops = {\n-  andersen_init,\n-  andersen_cleanup,\n-  andersen_add_var,\n-  andersen_add_var_same,\n-  andersen_simple_assign,\n-  andersen_addr_assign,\n-  andersen_ptr_assign,\n-  andersen_op_assign,\n-  andersen_heap_assign,\n-  andersen_assign_ptr,\n-  andersen_function_def,\n-  andersen_function_call,\n-  andersen_may_alias,\n-  andersen_same_points_to_set,\n-  andersen_empty_points_to_set,\n-  0, /* data */\n-  0, /* Currently non-interprocedural */\n-  1  /* Can do IP on all statics without help.  */\n-};\n-struct tree_alias_ops *andersen_alias_ops = &andersen_ops;\n-\n-static void term_inclusion (aterm, aterm);\n-static void pta_init (void);\n-static void pta_reset (void);\n-static aterm get_ref (aterm);\n-static argterm fun_rec_aterm (aterm_list);\n-static aterm pta_make_lam (const char *, aterm, aterm_list);\n-static aterm pta_make_ref (const char *);\n-static aterm pta_bottom (void);\n-static aterm pta_join (aterm, aterm);\n-static aterm pta_deref (aterm);\n-static aterm pta_rvalue (aterm);\n-static aterm pta_address (aterm);\n-static void pta_assignment (aterm, aterm);\n-static aterm pta_make_fun (const char *, aterm, aterm_list);\n-static aterm pta_application (aterm, aterm_list);\n-\n-typedef aterm contents_type;\n-static contents_type pta_get_contents (aterm);\n-static void pr_ptset_aterm_elem (aterm);\n-static void pta_pr_ptset (contents_type);\n-\n-/* Hook for debugging.  This function is called instead of\n-   aterm_inclusion, and lets us print the actual constraints as they\n-   are generated.  */\n-\n-static void\n-term_inclusion (aterm t1, aterm t2)\n-{\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Constraint: \");\n-      aterm_print (dump_file, t1);\n-      fprintf (dump_file, \" <= \");\n-      aterm_print (dump_file, t2);\n-      fprintf (dump_file,  \"\\n\");\n-    }\n-\n-  aterm_inclusion (t1, t2);\n-}\n-\n-/* Initialize libbanshee's constraint engine.  */\n-\n-static void\n-pta_init (void)\n-{\n-  andersen_terms_init ();\n-}\n-\n-/* Reset libbanshee's constraint engine.  We do this when we are done\n-   using it, as it releases the memory libbanshee is using.  */\n-\n-static void\n-pta_reset (void)\n-{\n-  andersen_terms_reset ();\n-}\n-\n-static aterm\n-get_ref (aterm t)\n-{\n-  struct ref_decon r_decon;\n-  r_decon = ref_decon (t);\n-\n-  assert (r_decon.f1);\n-\n-  return r_decon.f1;\n-}\n-\n-/* Make a function record out of the arguments.  */\n-\n-static argterm\n-fun_rec_aterm (aterm_list args)\n-{\n-  region scratch;\n-  int counter = 0;\n-  argterm rest, result;\n-  aterm_list_scanner scan;\n-  aterm temp;\n-  char field_name[512];\n-  argterm_map map;\n-\n-  scratch = newregion ();\n-  map = new_argterm_map (scratch);\n-  aterm_list_scan (args, &scan);\n-  while (aterm_list_next (&scan, &temp))\n-    {\n-      snprintf (field_name, 512, \"%d\", counter++);\n-      argterm_map_cons (argterm_make_field (field_name, temp), map);\n-    }\n-\n-  rest = argterm_wild ();\n-  /* rest = argterm_fresh(); */\n-\n-  /*  safe since field_add makes a copy of the string*/\n-  result = argterm_row (map, rest);\n-\n-  deleteregion (scratch);\n-\n-  return result;\n-}\n-\n-\n-static aterm\n-pta_make_lam (const char *id, aterm ret, aterm_list args)\n-{\n-  return lam (label_term_constant (id), fun_rec_aterm (args), ret);\n-}\n-\n-/* Make a label reference to the given id.  */\n-\n-static aterm\n-pta_make_ref (const char *id)\n-{\n-\n-  aterm var = aterm_fresh (id);\n-\n-  label_term tag = label_term_constant (id);\n-\n-  return ref (tag, var, var);\n-}\n-\n-/* Return the empty set.  */\n-\n-static aterm\n-pta_bottom (void)\n-{\n-  return aterm_zero ();\n-}\n-\n-/* Join two terms, such that anything in set t1 will also be in set\n-   t2, and vice versa.  */\n-\n-static aterm\n-pta_join (aterm t1, aterm t2)\n-{\n-  aterm result;\n-  region scratch_rgn = newregion ();\n-  aterm_list list = new_aterm_list (scratch_rgn);\n-\n-  aterm_list_cons (t1, list);\n-  aterm_list_cons (t2, list);\n-\n-\n-  result = aterm_union (list);\n-  deleteregion (scratch_rgn);\n-\n-  return result;\n-}\n-\n-/* Generate the constraint for a dereference of term t1.  */\n-\n-static aterm\n-pta_deref (aterm t1)\n-{\n-  return ref_proj2 (t1);\n-}\n-\n-/* Generate the constraint for t1 being an rvalue.  */\n-\n-static aterm\n-pta_rvalue (aterm t1)\n-{\n-  return pta_deref (t1);\n-}\n-\n-/* Generate the constraint for taking the address of t1.  */\n-\n-static aterm\n-pta_address (aterm t1)\n-{\n-  return ref (label_term_one (), aterm_one (), t1);\n-}\n-\n-/* Generate the constraint for assigning t2 to t1.  */\n-\n-static void\n-pta_assignment (aterm t1, aterm t2)\n-{\n-  term_inclusion (t1, ref_pat1 (t2));\n-}\n-\n-/* Make a function from the given name, return value, and arguments.  */\n-\n-static aterm\n-pta_make_fun (const char *name, aterm ret, aterm_list args)\n-{\n-  aterm temp;\n-  aterm_list_scanner scan;\n-  region scratch_rgn = newregion ();\n-  aterm_list arg_list = new_aterm_list (scratch_rgn);\n-\n-  aterm_list_scan (args, &scan);\n-\n-  while (aterm_list_next (&scan, &temp))\n-    {\n-      aterm_list_cons (get_ref (temp), arg_list);\n-    }\n-\n-  return pta_make_lam (name, get_ref (ret), arg_list);\n-}\n-\n-/* Return the constraint for calling function T with arguments\n-   ACTUALS.  */\n-\n-static aterm\n-pta_application (aterm t, aterm_list actuals)\n-{\n-  argterm args = fun_rec_aterm (actuals);\n-\n-  term_inclusion (t, lam_pat1 (args));\n-  return pta_address (lam_proj2 (t));\n-}\n-\n-/* Return the contents of set expression T.  */\n-\n-static contents_type\n-pta_get_contents (aterm t)\n-{\n-  struct ref_decon t_decon;\n-  t_decon = ref_decon (t);\n-\n-  return t_decon.f1;\n-}\n-\n-/* Print out a points-to set element.  */\n-\n-static void\n-pr_ptset_aterm_elem (aterm t)\n-{\n-  struct ref_decon ref;\n-  struct lam_decon lam;\n-\n-  ref = ref_decon (t);\n-  lam = lam_decon (t);\n-\n-  fprintf (dump_file, \",\");\n-  if (ref.f0)\n-    label_term_print (dump_file, ref.f0);\n-  else if (lam.f0)\n-    label_term_print (dump_file, lam.f0);\n-}\n-\n-\n-/* Print out a points-to set.  */\n-\n-static void\n-pta_pr_ptset (contents_type t)\n-{\n-  int size;\n-  region scratch_rgn;\n-  aterm_list ptset;\n-  scratch_rgn = newregion ();\n-  ptset = aterm_list_copy (scratch_rgn, aterm_tlb (t));\n-\n-  size = aterm_list_length (ptset);\n-\n-  fprintf (dump_file, \"{\");\n-  if (!aterm_list_empty (ptset))\n-    {\n-      struct ref_decon ref;\n-      struct lam_decon lam;\n-      ref = ref_decon (aterm_list_head (ptset));\n-      lam = lam_decon (aterm_list_head (ptset));\n-      if (ref.f0)\n-\tlabel_term_print (dump_file, ref.f0);\n-      else if (lam.f0)\n-\tlabel_term_print (dump_file, lam.f0);\n-\n-      /*      aterm_pr(stdout,aterm_hd(ptset)); */\n-      ptset = aterm_list_tail (ptset);\n-    }\n-  aterm_list_app (ptset, pr_ptset_aterm_elem);\n-  fprintf (dump_file, \"}(%d)\\n\", size);\n-  deleteregion (scratch_rgn);\n-}\n-\n-/* Initialize Andersen alias analysis.  */\n-static int initted = 0;\n-\n-static void\n-andersen_init (struct tree_alias_ops *ops ATTRIBUTE_UNUSED)\n-{\n-#if 0\n-  /* Don't claim we can do ip partial unless we have unit_at_a_time on.  */\n-  if (!flag_unit_at_a_time)   \n-#endif\n-    andersen_ops.ip_partial = 0;\n-  if (!initted || (!andersen_ops.ip_partial && !andersen_ops.ip))\n-    {\n-      pta_init ();\n-      andersen_rgn = newregion ();\n-      initted = 1;\n-    }\n-\n-  ptamap = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n-\n-}\n-\n-static int\n-print_out_result (splay_tree_node node, void *data ATTRIBUTE_UNUSED)\n-{\n-  fprintf (dump_file, \"%s :=\",\n-\t   alias_get_name (ALIAS_VAR_DECL (((alias_var) node->value))));\n-  pta_pr_ptset (pta_get_contents ((aterm) node->key));\n-  return 0;\n-}\n-\n-/* Cleanup after Andersen alias analysis.  */\n-\n-static void\n-andersen_cleanup (struct tree_alias_ops *ops ATTRIBUTE_UNUSED)\n-{\n-  if (dump_file)\n-    {\n-      if (dump_flags & TDF_STATS)\n-\t{\n-\t  fprintf (dump_file, \"\\nPoints-to stats:\\n\");\n-\t  andersen_terms_stats (dump_file);\n-\t}\n-\n-      fprintf (dump_file, \"\\nPoints-to sets:\\n\");\n-      splay_tree_foreach (ptamap, print_out_result, NULL);\n-    }\n-\n-  splay_tree_delete (ptamap);\n-\n-  if (!andersen_ops.ip_partial && !andersen_ops.ip)\n-    {\n-      pta_reset ();\n-      deleteregion (andersen_rgn);\n-      andersen_rgn = NULL;\n-    }\n-}\n-\n-/* Add decl to the analyzer, and return a var for it.  For\n-   Andersen, we create a new alias var for the declaration, and\n-   return that.  */\n-\n-static alias_var\n-andersen_add_var (struct tree_alias_ops *ops ATTRIBUTE_UNUSED, tree decl)\n-{\n-  alias_var ret;\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Adding variable %s\\n\",\n-\t     alias_get_name (decl));\n-\n-  if (alias_get_name (decl) != NULL)\n-    {\n-      ret = alias_var_new_with_aterm (decl,\n-\t\t\t\t       pta_make_ref (alias_get_name (decl)));\n-    }\n-  else\n-    {\n-      char *tmp_name;\n-      ASM_FORMAT_PRIVATE_NAME (tmp_name, \"unnamed var\", id_num++);\n-      ret = alias_var_new_with_aterm (decl, pta_make_ref (tmp_name));\n-    }\n-  splay_tree_insert (ptamap, (splay_tree_key) ALIAS_VAR_ATERM (ret),\n-\t\t     (splay_tree_value) ret);\n-  ALIAS_VAR_PTSET (ret) = NULL;\n-\n-  return ret;\n-}\n-\n-/* Add a variable to the analyzer that is equivalent (as far as\n-   aliases go) to some existing alias variable.\n-   For Andersen, we just call a function that does this for us.  */\n-\n-static alias_var\n-andersen_add_var_same (struct tree_alias_ops *ops ATTRIBUTE_UNUSED, tree decl,\n-\t\t       alias_var tv)\n-{\n-  alias_var ret;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Adding variable %s same as %s\\n\",\n-\t     alias_get_name (decl), alias_get_name (ALIAS_VAR_DECL (tv)));\n-\n-  if (alias_get_name (decl) != NULL)\n-    ret = alias_var_new_with_aterm (decl,\n-\t\t\t\t     pta_make_ref (alias_get_name (decl)));\n-  else\n-    {\n-      char *tmp_name;\n-      ASM_FORMAT_PRIVATE_NAME (tmp_name, \"unnamed var\", id_num++);\n-      ret = alias_var_new_with_aterm (decl, pta_make_ref (tmp_name));\n-    }\n-\n-  pta_join (ALIAS_VAR_ATERM (tv), ALIAS_VAR_ATERM (ret));\n-  splay_tree_insert (ptamap, (splay_tree_key) ALIAS_VAR_ATERM (ret),\n-\t\t     (splay_tree_value) ret);\n-  ALIAS_VAR_PTSET (tv) = NULL;\n-  ALIAS_VAR_PTSET (ret) = NULL;\n-\n-  return ret;\n-}\n-\n-/* Inference for simple assignment (lhs = rhs) */\n-\n-static void\n-andersen_simple_assign (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t\talias_var lhs, alias_var rhs)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Simple assignment %s = %s\\n\",\n-\t     alias_get_name (ALIAS_VAR_DECL (lhs)),\n-\t     alias_get_name (ALIAS_VAR_DECL (rhs)));\n-  if (lhs == rhs)\n-    return;\n-  \n-  /* The rvalue is just the term itself, and we generate a constraint\n-     for assigning it to the lhs.  */\n-  pta_assignment (ALIAS_VAR_ATERM (lhs),\n-\t\t  pta_rvalue (ALIAS_VAR_ATERM (rhs)));\n-}\n-\n-/* Inference for address assignment (lhs = &addr) */\n-\n-static void\n-andersen_addr_assign (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t      alias_var lhs, alias_var addr)\n-{\n-  if (addr == NULL)\n-    return;\n- if (dump_file && (dump_flags & TDF_DETAILS))\n-   fprintf (dump_file, \"Address assignment %s = &%s\\n\",\n-\t    alias_get_name (ALIAS_VAR_DECL (lhs)),\n-\t    alias_get_name (ALIAS_VAR_DECL (addr)));\n-\n- /* The rvalue here is the address of a term, and we generate a\n-    constraint to assign this address to the lhs.  */\n-  pta_assignment (ALIAS_VAR_ATERM (lhs),\n-\t\t  pta_rvalue (pta_address (ALIAS_VAR_ATERM (addr))));\n-}\n-\n-\n-/* Inference for pointer assignment (lhs = *ptr) */\n-\n-static void\n-andersen_ptr_assign (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t     alias_var lhs, alias_var ptr)\n-{\n-\n-  if (ptr == NULL)\n-    return;\n- if (dump_file && (dump_flags & TDF_DETAILS))\n-   fprintf (dump_file, \"Pointer assignment %s = *%s\\n\",\n-\t    alias_get_name (ALIAS_VAR_DECL (lhs)),\n-\t    alias_get_name (ALIAS_VAR_DECL (ptr)));\n-\n-  pta_assignment (ALIAS_VAR_ATERM (lhs),\n-\t\t  pta_rvalue (pta_deref (ALIAS_VAR_ATERM (ptr))));\n-\n-}\n-\n-/* Determine if OP destroys the current assumed to be valid pointer\n-   (whether it generates a new valid pointer is not relevant).  */\n-\n-static bool\n-pointer_destroying_op (tree op)\n-{\n-  switch (TREE_CODE (op))\n-    {\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_NOT_EXPR:\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case LE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case LROTATE_EXPR:\n-    case RROTATE_EXPR:\n-      return true;\n-    default:\n-      return false;\n-    }\n-  return false;\n-}\n-\n-/* Inference rule for operations (lhs = operation(operands)).  */\n-\n-static void\n-andersen_op_assign (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t    alias_var lhs, varray_type operands, tree operation,\n-\t\t    bitmap addrargs)\n-{\n-  aterm newvar = NULL;\n-  \n-  if (VARRAY_ACTIVE_SIZE (operands) == 0)\n-    return;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Op assignment %s = \",\n-\t       alias_get_name (ALIAS_VAR_DECL (lhs)));\n-      print_generic_stmt (dump_file, operation, dump_flags);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  \n-      \n-  /* Pointer destroying operations do not give us the same valid pointer\n-     back, and thus, are assignment to pta_bottom.  */\n-  if (pointer_destroying_op (operation))\n-    {\n-      pta_assignment (ALIAS_VAR_ATERM (lhs), pta_rvalue (pta_bottom ()));\n-      return;\n-    }\n-  \n-  /* Operations in general we can't track the exact effect of.  Thus,\n-     we conservatively assume that it could make the LHS point to\n-     *anything* the RHS points to.  To signify this, we join the RHS\n-     variables together and assign it to the LHS.  */\n-  /* The >2 case occurs when we are dealing with constructors.  */\n-  if (VARRAY_ACTIVE_SIZE (operands) > 2)\n-    {\n-      size_t i;\n-      alias_var tv1 = VARRAY_GENERIC_PTR (operands, 0);\n-      newvar = ALIAS_VAR_ATERM (tv1);\n-      for (i = 1; i < VARRAY_ACTIVE_SIZE (operands); i++)\n-\t{\n-\t  alias_var tempvar = VARRAY_GENERIC_PTR (operands, i);\n-\t  aterm t2 = ALIAS_VAR_ATERM (tempvar);\n-\t  if (bitmap_bit_p (addrargs, i))\n-\t    newvar = pta_join (newvar, pta_address (t2));\n-\t  else\n-\t    newvar = pta_join (newvar, t2);\n-\t}\n-    }\n-  else if (VARRAY_ACTIVE_SIZE (operands) == 2)\n-    {\n-      alias_var tv1 = VARRAY_GENERIC_PTR (operands, 0);\n-      alias_var tv2 = VARRAY_GENERIC_PTR (operands, 1);\n-      aterm t1 = ALIAS_VAR_ATERM (tv1);\n-      aterm t2 = ALIAS_VAR_ATERM (tv2);\n-      if (bitmap_bit_p (addrargs, 0) && bitmap_bit_p (addrargs, 1))\n-\tnewvar = pta_join (pta_address (t1), pta_address (t2));\n-      else if (bitmap_bit_p (addrargs, 0))\n-\tnewvar = pta_join (pta_address (t1), t2);\n-      else if (bitmap_bit_p (addrargs, 1))\n-\tnewvar = pta_join (t1, pta_address (t2));\n-      else\n-\tnewvar = pta_join (t1, t2);\n-    }\n-  else if (VARRAY_ACTIVE_SIZE (operands) == 1)\n-    {\n-      alias_var tv1 = VARRAY_GENERIC_PTR (operands, 0);\n-      aterm t1 = ALIAS_VAR_ATERM (tv1);\n-      if (bitmap_bit_p (addrargs, 0))\n-\tnewvar = pta_address (t1);\n-      else\n-\tnewvar = t1;\n-    }\n-  pta_assignment (ALIAS_VAR_ATERM (lhs), pta_rvalue (newvar));\n-}\n-\n-/* Inference for heap assignment (lhs = alloc).  */\n-\n-static void\n-andersen_heap_assign (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t      alias_var lhs ATTRIBUTE_UNUSED)\n-{\n-#if 0\n-  alias_type type1;\n-  ECR tau;\n-  type1 = ECR_get_type (alias_var_get_ECR (lhs));\n-  tau = alias_ltype_loc (type1);\n-\n-  if (ECR_get_type (tau) == alias_bottom)\n-    ECR_set_type (tau, alias_ltype_new ());\n-#endif\n-}\n-\n-/* Inference for assignment to a pointer (*ptr = rhs).  */\n-\n-static void\n-andersen_assign_ptr (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t     alias_var ptr, alias_var rhs)\n-{\n-\n-  if (rhs == NULL)\n-    return;\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Assignment to pointer  *%s = %s\\n\",\n-\t     alias_get_name (ALIAS_VAR_DECL (ptr)),\n-\t     alias_get_name (ALIAS_VAR_DECL (rhs)));\n-  /* The RHS is a standard rvalue, and the LHS is a pointer\n-     dereference.  */\n-  pta_assignment (pta_deref (ALIAS_VAR_ATERM (ptr)),\n-\t\t  pta_rvalue (ALIAS_VAR_ATERM (rhs)));\n-}\n-\n-/* Inference for a function definition.  */\n-\n-static void\n-andersen_function_def (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t       alias_var func, varray_type params,\n-\t\t       alias_var retval)\n-{\n-  aterm_list args = new_aterm_list (andersen_rgn);\n-  aterm fun_type;\n-\n-  size_t l = VARRAY_ACTIVE_SIZE (params);\n-  size_t i;\n-\n-  /* Set up the arguments for the new function type.  */\n-  for (i = 0; i < l; i++)\n-    {\n-      alias_var tv = VARRAY_GENERIC_PTR (params, i);\n-      aterm_list_cons (ALIAS_VAR_ATERM (tv), args);\n-    }\n-  /* Create the function type.  */\n-  fun_type = pta_make_fun (alias_get_name (ALIAS_VAR_DECL (func)),\n-\t\t\t   ALIAS_VAR_ATERM (retval), args);\n-\n-  /* Assign the function type itself to the function.  */\n-  pta_assignment (ALIAS_VAR_ATERM (func), fun_type);\n-}\n-\n-/* Inference for a function call assignment.  */\n-\n-static int\n-andersen_function_call (struct tree_alias_ops *ops,\n-\t\t\talias_var lhs, alias_var func,\n-\t\t\tvarray_type args, bitmap addrargs)\n-{\n-  aterm_list actuals = new_aterm_list (andersen_rgn);\n-  aterm ftype = ALIAS_VAR_ATERM (func);\n-  aterm ret = NULL;\n-  aterm res;\n-  tree decl = ALIAS_VAR_DECL (func);\n-\n-  size_t i;\n-\n-  if (lhs)\n-    ret = ALIAS_VAR_ATERM (lhs);\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (args); i++)\n-    {\n-      alias_var argtv = VARRAY_GENERIC_PTR (args, i);\n-      aterm arg = ALIAS_VAR_ATERM (argtv);\n-      if (bitmap_bit_p (addrargs, i))\n-\taterm_list_cons (pta_rvalue (pta_address (arg)), actuals);\n-      else\n-\taterm_list_cons (pta_rvalue (arg), actuals);\n-    }\n-  aterm_list_reverse (actuals);\n-  \n-  /* Generate the constraint that calls the function with it's\n-     arguments, and gives us the result.  This in turn applies\n-     whatever constraints are in that function.  */\n-  res = pta_application (pta_rvalue (ftype), actuals);\n-  /* We only need care about the result if we have an LHS.  If we do,\n-     assign the result of function application back to the LHS.  */\n-  if (ret)\n-    pta_assignment (ret, pta_rvalue (res));\n-\n-  /* We can handle functions we've got trees for. non-statics will\n-     just have incoming parameters assigned to global_var if\n-     necessary.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && DECL_PTA_ALIASVAR (decl)\n-      && ops->ip_partial\n-      && (cgraph_local_info (decl)->local))\n-    {\n-      return 0;\n-    }\n-  return 1;\n-}\n-\n-\n-/* Simple pointer comparison function for list sorting.  */\n-\n-static int \n-simple_cmp (const aterm a, const aterm b)\n-{\n-  return (int *)a - (int *)b;\n-}\n-\n-\n-/* Get the points-to set for TV, caching if it we had to compute it.  */\n-   \n-static aterm_list \n-get_ptset (alias_var tv)\n-{\n-  aterm_list ptset;\n-  ptset = ALIAS_VAR_PTSET (tv);\n-  if (ptset != NULL)\n-    return ptset;\n-  ptset = aterm_tlb (pta_get_contents (ALIAS_VAR_ATERM (tv)));\n-  ALIAS_VAR_PTSET (tv) = ptset;\n-  return ptset;\n-}\n-  \n-  \n-/* Determine if two aterm's have the same points-to set.  */\n-\n-static bool\n-andersen_same_points_to_set (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t\t     alias_var ptrtv, alias_var vartv)\n-{\n-  aterm_list ptset1, ptset2;\n-  aterm_list_scanner scan1, scan2;\n-  aterm data1, data2;\n-  region scratch_rgn = newregion ();\n-\n-  ptset1 = get_ptset (ptrtv);\n-  ptset2 = get_ptset (vartv);\n-  \n-  if (aterm_list_length (ptset1) != aterm_list_length (ptset2))\n-    {\n-      deleteregion (scratch_rgn);\n-      return false;\n-    }\n-\n-  if (ptset1 == ptset2)\n-    {\n-      deleteregion (scratch_rgn);\n-      return true;\n-    }\n-\n-  ptset1 = aterm_list_copy (scratch_rgn, ptset1);\n-  ptset2 = aterm_list_copy (scratch_rgn, ptset2);\n-  \n-  if (aterm_list_length (ptset1) != aterm_list_length (ptset2))\n-    {\n-      deleteregion (scratch_rgn);\n-      return false;\n-    }\n-\n-  ptset1 = aterm_list_sort (ptset1, simple_cmp);\n-  ptset2 = aterm_list_sort (ptset2, simple_cmp);\n-  \n-  aterm_list_scan (ptset1, &scan1);\n-  aterm_list_scan (ptset2, &scan2);\n-  while (aterm_list_next (&scan1, &data1))\n-    {\n-      aterm_list_next (&scan2, &data2);\n-      if (data1 != data2)\n-\t{\n-\t  deleteregion(scratch_rgn);\n-\t  return false;\n-\t}\n-    }\n-  deleteregion(scratch_rgn);\n-  return true;  \n-}\n-\n-\n-/* Determine if two variables may alias.  In our case, this means\n-   whether the decl represented by PTRTV can point to VARTV.  */\n-\n-static bool\n-andersen_may_alias (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t    alias_var ptrtv, alias_var vartv)\n-{\n-  aterm_list ptset;\n-  ptset = get_ptset (ptrtv);\n-\n-  if (aterm_list_empty (ptset))\n-    return false;\n-\n-  return aterm_list_member (ptset, ALIAS_VAR_ATERM (vartv));\n-}\n-\n-/* Determine whether PTRTV has an empty points-to set. IE it may not\n-   point to anything.  */\n-\n-static bool \n-andersen_empty_points_to_set (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n-\t\t\t      alias_var ptrtv)\n-{\n-  aterm_list ptset;\n-  ptset = get_ptset (ptrtv);\n-  return aterm_list_empty (ptset);  \n-}"}, {"sha": "4af8b2c99d6a40bb34ecb607cb888d3a2c9e740d", "filename": "gcc/tree-alias-ander.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-ander.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-ander.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-ander.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,29 +0,0 @@\n-/* Tree based Andersen points-to analysis\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-*/\n-\n-#ifndef TREE_ALIAS_ANDER\n-#define TREE_ALIAS_ANDER\n-\n-#include \"tree-alias-common.h\"\n-\n-extern struct tree_alias_ops *andersen_alias_ops;\n-\n-#endif /* TREE_ALIAS_ANDER */"}, {"sha": "21b8b497039e04a185fb14ebfa010a2e8e4f1c55", "filename": "gcc/tree-alias-common.c", "status": "removed", "additions": 0, "deletions": 1251, "changes": 1251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-common.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,1251 +0,0 @@\n-/* Tree based points-to analysis\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-*/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"ggc.h\"\n-#include \"tree-alias-type.h\"\n-#include \"bitmap.h\"\n-#include \"tree-alias-common.h\"\n-\n-/* If we have andersen's points-to analysis, include it.  */\n-#ifdef HAVE_BANSHEE\n-#include \"tree-alias-ander.h\"\n-#endif\n-\n-#include \"flags.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"output.h\"\n-#include \"errors.h\"\n-#include \"expr.h\"\n-#include \"diagnostic.h\"\n-#include \"tree.h\"\n-#include \"c-common.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-inline.h\"\n-#include \"varray.h\"\n-#include \"c-tree.h\"\n-#include \"tree-gimple.h\"\n-#include \"hashtab.h\"\n-#include \"function.h\"\n-#include \"cgraph.h\"\n-#include \"tree-pass.h\"\n-#include \"timevar.h\"\n-\n-/* Reduce ifdefery later.  */\n-#ifndef HAVE_BANSHEE\n-#define HAVE_BANSHEE 0\n-#endif\n-\n-/*  This file contains the implementation of the common parts of the\n-    tree points-to analysis infrastructure.\n-    \n-    Overview:\n-    \n-    This file contains the points-to analysis driver.  It does two main things:\n-    1. Keeps track of the PTA data for each variable (IE the data each\n-    specific PTA implementation wants to keep associated with a\n-    variable).\n-    2. Walks the function trees, calling the appropriate functions that\n-    each PTA implementation has implemented.\n-    \n-    In order to speed up PTA queries, the PTA specific data is stored\n-    in the tree for *_DECL's, in DECL_PTA_ALIASVAR.  This way, we only\n-    need to use the hash table for non-DECL's.  */\n-#define FIELD_BASED 0\n-\n-/*  Array of all created alias_vars.\n-    Note that this should contain all the alias_vars we wanted\n-    marked during GC.  */\n-static GTY((param_is (union alias_var_def))) varray_type alias_vars = NULL;\n-struct tree_alias_ops *current_alias_ops;\n-\n-/*  Array of local (to a function) alias_vars.\n-    Note that this should contain all the alias_vars that are\n-    local to this function.  We delete these from alias_vars before\n-    collection.  */\n-static GTY(()) varray_type local_alias_vars;\n-static GTY(()) varray_type local_alias_varnums;\n-tree pta_global_var;\n-static bitmap addrargs;\t\t\t\t\t\t \n-static alias_var get_alias_var_decl (tree);\n-static alias_var get_alias_var (tree);\n-static void find_func_aliases (tree);\n-static void deal_with_call_aliasing (tree, alias_var);\n-static alias_var create_fun_alias_var_ptf (tree, tree);\n-static alias_var create_fun_alias_var (tree, int);\n-static alias_var create_alias_var (tree);\n-static void intra_function_call (varray_type);\n-static void get_values_from_constructor (tree, varray_type *, bitmap, int *);\n-static bool call_may_clobber (tree);\n-static bool call_may_return (tree);\n-\n-/* Return true if a EXPR, which is a CALL_EXPR, may clobber variables.  */\n-\n-static bool\n-call_may_clobber (tree expr)\n-{\n-  int flags;\n-\n-  if (TREE_CODE (expr) != CALL_EXPR)\n-    return false;\n-\n-  flags = call_expr_flags (expr);\n-  return (! (flags & (ECF_CONST | ECF_PURE | ECF_NORETURN)));\n-}\n-\n-/* Return true if a EXPR, which is a CALL_EXPR, may return.  */\n-\n-static bool\n-call_may_return (tree expr)\n-{\n-  int flags;\n-  \n-  if (TREE_CODE (expr) != CALL_EXPR)\n-    return false;\n-\n-  flags = call_expr_flags (expr);\n-  return ! (flags & ECF_NORETURN);\n-}\n-\n-/*  Get the alias_var for DECL.  \n-    Creates the alias_var if it does not exist already. Also\n-    handles FUNCTION_DECL properly.  */\n-\n-static alias_var\n-get_alias_var_decl (tree decl)\n-{\n-  alias_var newvar;\n-  gcc_assert (TREE_CODE (decl) != FIELD_DECL);\n-  if (DECL_P (decl))\n-    {\n-      if (DECL_PTA_ALIASVAR (decl))\n-\treturn DECL_PTA_ALIASVAR (decl);\n-    }\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    newvar = create_fun_alias_var  (decl, 0);\n-  else\n-    {\n-      newvar = create_alias_var (decl);\n-      /* Assign globals to global var for purposes of intraprocedural\n-\t analysis.  */\n-      if (TREE_STATIC (decl) && decl != pta_global_var)\n-\t{\n-\t  current_alias_ops->addr_assign (current_alias_ops, \n-\t\t\t\t\t  get_alias_var (pta_global_var), \n-\t\t\t\t\t  newvar);\n-\t  /* If the global has some DECL_INITIAL, we need to process\n-\t     it here.  */\n-\t  if (DECL_INITIAL (decl))\n-\t    find_func_aliases (decl);\n-\t}\n-    }\n-\n-  if (!current_alias_ops->ip)\n-    {\n-      if (!current_alias_ops->ip_partial\n-\t  || (TREE_CODE (decl) != FUNCTION_DECL\n-\t      && TREE_CODE (decl) != PARM_DECL))\n-\t{\n-\t  VARRAY_PUSH_INT (local_alias_varnums, ALIAS_VAR_VARNUM (newvar));\n-\t  VARRAY_PUSH_TREE (local_alias_vars, decl);\n-\t}\n-    }\n-  return newvar;\n-}\n-\n-/* Get the alias_var for an expression EXPR.\n-   Note that this function expects to only be handed a RHS or LHS, not\n-   a MODIFY_EXPR.  */\n-\n-static alias_var\n-get_alias_var (tree expr)\n-{\n-  /* If it's a decl, get the alias var of the decl. We farm this off\n-     to get_alias_var_decl so it can abort if the alias var doesn't\n-     exist, and in case something else *knows* it has a decl, and\n-     wants the alias var.  */\n-\n-  if (DECL_P (expr))\n-    return get_alias_var_decl (expr);\n-\n-  /* True constants have no aliases (unless modifiable strings are on,\n-     in which case i don't think we'll end up with a STRING_CST anyway) */\n-  if (TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n-    return NULL;\n-\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n-      {\n-\t/* Find the first non-array ref, and return its alias variable.  */\n-\ttree p;\n-\n-\tfor (p = expr;\n-\t     TREE_CODE (p) == ARRAY_REF || TREE_CODE (p) == ARRAY_RANGE_REF;\n-\t     p = TREE_OPERAND (p, 0))\n-\t  ;\n-\treturn get_alias_var (p);\n-      }\n-      break;\n-    case COMPONENT_REF:\n-      {\n-#if FIELD_BASED\n-\tbool safe = true;\n-\ttree p;\n-\tfor (p = expr; \n-\t     TREE_CODE (p) == COMPONENT_REF || TREE_CODE (p) == INDIRECT_REF;\n-\t     p = TREE_OPERAND (p, 0))\n-\t  {\n-\t    if (TREE_CODE (TREE_TYPE (p)) == UNION_TYPE \n-\t\t|| TREE_CODE (TREE_TYPE (p)) == QUAL_UNION_TYPE)\n-\t      {\n-\t\tsafe = false;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tif (!safe)\n-\t  {\n-\t    for (p = expr; TREE_CODE (p) == COMPONENT_REF;\n-\t\t p = TREE_OPERAND (p, 0));\n-\t    return get_alias_var (p);\n-\t  }\n-\telse\n-\t  {\n-\t    return get_alias_var (TREE_OPERAND (expr, 1));\n-\t  }\n-#else\n-        /* Find the first non-component ref, and return its alias variable.  */\n-\ttree p;\n-\tfor (p = expr; TREE_CODE (p) == COMPONENT_REF;\n-\t     p = TREE_OPERAND (p, 0));\n-\treturn get_alias_var (p);\n-#endif\n-      }\n-      break;\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case FIX_CEIL_EXPR:\n-    case FIX_FLOOR_EXPR:\n-    case FIX_ROUND_EXPR:\n-    case ADDR_EXPR:\n-    case INDIRECT_REF:\n-    case BIT_FIELD_REF:\n-      /* If it's a ref or cast or conversion of something, get the\n-         alias var of the something.  */\n-      return get_alias_var (TREE_OPERAND (expr, 0));\n-      break;\n-\n-    default:\n-      return NULL;\n-    }\n-}\n-\n-/*  Perform conservative aliasing for an intraprocedural mode function\n-    call.  ARGS are the arguments that were passed to that function\n-    call.  */\n-\n-static void\n-intra_function_call (varray_type args)\n-{\n-  size_t l = VARRAY_ACTIVE_SIZE (args);\n-  size_t i;\n-  alias_var av = get_alias_var (pta_global_var);\n-\n-  /* We assume assignments among the actual parameters.  */\n-  for (i = 0; i < l; i++)\n-    {\n-      alias_var argi = VARRAY_GENERIC_PTR (args, i);\n-      size_t j;\n-      for (j = 0; j < l; j++)\n-\t{\n-\t  alias_var argj;\n-\t  if (i == j)\n-\t    continue;\n-\t  argj = VARRAY_GENERIC_PTR (args, j);\n-\t  /* Restricted pointers can't be aliased with other\n-\t     restricted pointers.  */\n-\t  if (!TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (argi)))\n-\t      || !TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (argj))))\n-\t    /* Do a bit of TBAA to avoid pointless assignments.  */\n-\t    if (alias_sets_conflict_p (get_alias_set (ALIAS_VAR_DECL (argi)),\n-\t\t\t\t       get_alias_set (ALIAS_VAR_DECL (argj))))\t      \n-\t      current_alias_ops->simple_assign (current_alias_ops, argi, argj);\n-\t}\n-    }\n-  /* We assume that an actual parameter can point to any global.  */\n-  for (i = 0; i < l; i++)\n-    {\n-      alias_var argav = VARRAY_GENERIC_PTR (args, i);\n-      /* Restricted pointers can't be aliased with other\n-\t restricted pointers.  */\n-      if (!TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (argav)))\n-\t  || !TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (av))))\n-\t{\n-\t  /* Arguments can alias globals, and whatever they point to\n-\t     can point to a global as well.  */\n-\t  current_alias_ops->simple_assign (current_alias_ops, argav, av);\n-\t}\n-    }\n-}\n-\n-/* Put all pointers in a constructor in an array.  */\n-\n-static void\n-get_values_from_constructor (tree constructor, varray_type *vals, \n-\t\t\t     bitmap addrargs, int *i)\n-{\n-  tree elt_list;\n-  switch (TREE_CODE (constructor))\n-    {\n-    case CONSTRUCTOR:\n-      {\n-\tfor (elt_list = CONSTRUCTOR_ELTS (constructor);\n-\t     elt_list;\n-\t     elt_list = TREE_CHAIN (elt_list))\n-\t  {\n-\t    tree value = TREE_VALUE (elt_list);\n-\t    if (TREE_CODE (value) == TREE_LIST\n-\t\t|| TREE_CODE (value) == CONSTRUCTOR)\n-\t      {\n-\t\tget_values_from_constructor (value, vals, addrargs, i);\t\t\t      }\n-\t    else\n-\t      {\n-\t\talias_var aav;\n-\t\taav = get_alias_var (value);\n-\t\tif (aav)\n-\t\t  VARRAY_PUSH_GENERIC_PTR (*vals, aav);\n-\t\tif (TREE_CODE (value) == ADDR_EXPR)\n-\t\t  bitmap_set_bit (addrargs, *i);\n-\t\t*i = *i + 1;\n-\t      }\n-\t  }\n-      }\n-      break;\n-    case TREE_LIST:\n-      for (elt_list = constructor;\n-\t   elt_list;\n-\t   elt_list = TREE_CHAIN (elt_list))\n-\t{\n-\t  get_values_from_constructor (TREE_VALUE (elt_list), vals, addrargs, i);\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Deal with the possible return values of a call that we don't have\n-   actual PTA info about.  */\n-\n-static void\n-deal_with_call_aliasing (tree callargs, alias_var lhsAV)\n-{\n-  tree arg, argp;\n-  \n-  for (argp = callargs;\n-       argp;\n-       argp = TREE_CHAIN (argp))\n-    {\n-      arg = TREE_VALUE (argp);\n-      /* If we take the address of a variable directly in the\n-\t argument, the return value could be the address of that\n-\t variable.  */ \n-      if (TREE_CODE (arg) == ADDR_EXPR)\n-\tcurrent_alias_ops->addr_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\tget_alias_var (arg));\n-      /* If we pass in a pointer, we could return that pointer.  */\n-      else if (POINTER_TYPE_P (TREE_TYPE (arg)))\n-\t{\n-\t  alias_var argtv = get_alias_var (arg);\n-\t  if (argtv)\n-\t    current_alias_ops->simple_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t      argtv);\n-\t}\n-    }\n-}\n-\n-/* Find the operand of the component ref that actually is doing\n-   something to the DECL  */\n-static tree\n-find_op_of_decl (tree cref)\n-{\n-  while (!DECL_P (TREE_OPERAND (cref, 0)))\n-    {\n-      cref = TREE_OPERAND (cref, 0);\n-    }\n-  return cref;\n-}\n-\n-\n-/*  Tree walker that is the heart of the aliasing infrastructure.\n-    TP is a pointer to the current tree.\n-    WALK_SUBTREES specifies whether to continue traversing subtrees or\n-    not.\n-    Returns NULL_TREE when we should stop.\n-    \n-    This function is the main part of the aliasing infrastructure. It\n-    walks the trees, calling the appropriate alias analyzer functions to process\n-    various statements.  */\n-\n-static void\n-find_func_aliases (tree stp)\n-{\n-  if (TREE_CODE (stp) == RETURN_EXPR)\n-    {\n-      stp = TREE_OPERAND (stp, 0);\n-      if (!stp)\n-\treturn;\n-    }\n-  \n-  if (TREE_CODE (stp) == MODIFY_EXPR\n-      || (DECL_P (stp) && DECL_INITIAL (stp) != NULL_TREE ))\n-    {\n-      tree op0, op1;\n-      alias_var lhsAV = NULL;\n-      alias_var rhsAV = NULL;\n-\n-      if (DECL_P (stp))\n-\t{\n-\t  op0 = stp;\n-\t  op1 = DECL_INITIAL (stp);\n-\t}\n-      else\n-\t{\n-\t  op0 = TREE_OPERAND (stp, 0);\n-\t  op1 = TREE_OPERAND (stp, 1);\n-\t  if (TREE_CODE (op1) == WITH_SIZE_EXPR)\n-\t    op1 = TREE_OPERAND (op1, 0);\n-\t}\n-\n-      /* lhsAV should always have an alias variable */\n-      lhsAV = get_alias_var (op0);\n-      if (!lhsAV)\n-\treturn;\n-      /* rhsAV might not have one, c.f. c = 5 */\n-      rhsAV = get_alias_var (op1);\n-#if !FIELD_BASED\n-      while (TREE_CODE (op1) == COMPONENT_REF \n-\t     && TREE_CODE (TREE_OPERAND (op1, 0)) == COMPONENT_REF)\n-\t{\n-\t  op1 = TREE_OPERAND (op1, 0);\n-\t}\n-      while (TREE_CODE (op1) == BIT_FIELD_REF)\n-\t{\n-\t  op1 = TREE_OPERAND (op1, 0);\n-\t}\n-      /* Take care of fact that we may have multi-level component\n-\t refs.  */ \n-      if (TREE_CODE (op1) == COMPONENT_REF)\n-\top1 = find_op_of_decl (op1);\n-#endif\n-      \n-      /* You would think we could test rhsAV at the top, rather than\n-\t 50 separate times, but we can't, because it can be NULL for\n-\t operator assignments, where we'd still collect the individual\n-\t alias vars for the operator.  */\n-\n-      /* Note that structures are treated as a single alias\n-\t variable, since we can disambiguate based on TBAA first,\n-\t and fall back on points-to.  */\n-      /* x = <something> */\n-      if (is_gimple_variable (op0))\n-\t{\n-\t  /* x = y */\n-\t  if (is_gimple_variable (op1))\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->simple_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\t  rhsAV);\n-\t    }\n-\t  /* x = foo.y */\n-\t  else if (TREE_CODE (op1) == COMPONENT_REF \n-\t\t   && DECL_P (TREE_OPERAND (op1, 0)))\n-\t    {\n-\t         if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->simple_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\t  rhsAV);\n-\t    }\n-\t  /* x = (cast) [maybe-addr-expr] y */\n-\t  else if (is_gimple_cast (op1))\n-\t    {\n-\t      tree stripped_op1 = op1;\n-\t      STRIP_NOPS (stripped_op1);\n-\t      if (rhsAV != NULL)\n-\t\t{\n-\t\t  if (TREE_CODE (stripped_op1) == ADDR_EXPR)\n-\t\t    current_alias_ops->addr_assign (current_alias_ops, lhsAV, \n-\t\t\t\t\t\t    rhsAV);\n-\t\t  else\n-\t\t    current_alias_ops->simple_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\t      rhsAV);\n-\t\t}\n-\t    }\n-\t  /* x = *y or x = foo->y */\n-\t  else if (TREE_CODE (op1) == INDIRECT_REF \n-\t\t   || TREE_CODE (op1) == ARRAY_REF\n-\t\t   || (TREE_CODE (op1) == COMPONENT_REF\n-\t\t       && TREE_CODE (TREE_OPERAND (op1, 0)) == INDIRECT_REF))\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->ptr_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t       rhsAV);\n-\t    }\n-\t  /* x = &y = x = &foo.y */\n-\t  else if (TREE_CODE (op1) == ADDR_EXPR)\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->addr_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\trhsAV);\n-\t    }\n-\t  /* x = func(...) */\n-\t  else if (TREE_CODE (op1) == CALL_EXPR)\n-\t    {\n-\t      /* Heap assignment. These are __attribute__ malloc or\n-\t\t something, I'll deal with it later.  */\n-\t      if (0)\n-\t\t{}\n-\t      else\n-\t\t{\n-\t\t  \n-\t\t  /* NORETURN functions have no effect on aliasing.  */\n-\t\t  if (call_may_return (op1))\n-\t\t    {\t\t      \n-\t\t      varray_type args;\n-\t\t      tree arg;\n-\t\t      tree callop0, callop1;\n-\t\t      int argnum;\n-\t\t      \n-\t\t      /* Collect the arguments */\n-\t\t      VARRAY_GENERIC_PTR_INIT (args, 1, \"Arguments\");\n-\t\t      bitmap_clear (addrargs);\n-\t\t      callop1 = TREE_OPERAND (op1, 1);\n-\t\t      callop0 = TREE_OPERAND (op1, 0);\n-\t\t      for (arg = callop1, argnum = 0;\n-\t\t\t   arg;\n-\t\t\t   arg = TREE_CHAIN (arg), argnum++)\n-\t\t\t{\n-\t\t\t  alias_var aav = get_alias_var (TREE_VALUE (arg));\n-\t\t\t  if (aav)\n-\t\t\t    {\n-\t\t\t      VARRAY_PUSH_GENERIC_PTR (args, aav);\n-\t\t\t      if (TREE_CODE (TREE_VALUE (arg)) == ADDR_EXPR)\n-\t\t\t\tbitmap_set_bit (addrargs, argnum);\n-\t\t\t    }\n-\t\t\t}\n-\t\t      /* Simulate the call */\n-\t\t      if (current_alias_ops->function_call (current_alias_ops, lhsAV,\n-\t\t\t\t\t\t\t    get_alias_var (callop0),\n-\t\t\t\t\t\t\t    args, addrargs))\n-\t\t\t{ \n-\t\t\t  if (call_may_clobber (op1)\n-\t\t\t      && !current_alias_ops->ip\n-                              && flag_argument_noalias != 2)\n-\t\t\t    {\n-\t\t\t      intra_function_call (args);\n-\t\t\t    }\n-\t\t\t  if (POINTER_TYPE_P (TREE_TYPE (op0)))\n-\t\t\t    deal_with_call_aliasing (callop1, lhsAV);\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  /* x = op (...) */\n-\t  else\n-\t    {\n-\t      bitmap_clear (addrargs);\n-\t      if (TREE_CODE (op1) == CONSTRUCTOR)\n-\t        {\n-\t\t  varray_type ops;\n-\t\t  int i = 0;\n-\t\t  VARRAY_GENERIC_PTR_INIT (ops, 1, \"Operands\");\n-\t\t  get_values_from_constructor (op1, &ops, addrargs, &i);\n-\t\t  current_alias_ops->op_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\tops, op1, addrargs);\n-\t\t}\n-\t      else\n-\t\tswitch (TREE_CODE_CLASS (TREE_CODE (op1)))\n-\t\t  {\n-\t\t  case 'e':  /* an expression */\n-\t\t  case 's':  /* an expression with side effects */\n-\t\t  case '<':  /* a comparison expression */\n-\t\t  case '1':  /* a unary arithmetic expression */\n-\t\t  case 'r':  /* a reference */\n-\t\t  case '2':  /* a binary arithmetic expression */\n-\t\t    {\n-\t\t      tree op;\n-\t\t      varray_type ops;\n-\t\t      int i;\n-\t\t      VARRAY_GENERIC_PTR_INIT (ops, 1, \"Operands\");\n-\t\t      for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (op1)); i++)\n-\t\t\t{\n-\t\t\t  alias_var aav;\n-\t\t\t  op = TREE_OPERAND (op1, i);\n-\t\t\t  aav = get_alias_var (op);\n-\t\t\t  if (aav)\n-\t\t\t    VARRAY_PUSH_GENERIC_PTR (ops, aav);\n-\t\t\t  if (TREE_CODE (op) == ADDR_EXPR)\n-\t\t\t    bitmap_set_bit (addrargs, i);\n-\t\t\t}\n-\t\t      current_alias_ops->op_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\t    ops, op1, addrargs);\n-\t\t    }\n-\t\t    break;\n-\t\t  default:\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n-      /* *x = <something> */\n-      else\n-\t{\n-\t  /* x.f = y  or x->f = y */\n-\t  if ((TREE_CODE (op0) == COMPONENT_REF \n-\t       || TREE_CODE (op0) == BIT_FIELD_REF)\n-\t      && is_gimple_variable (op1))\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->simple_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\t  rhsAV);\n-\t    }\n-\t  /* x.f = &y or x->f = &y */\n-\t  else if (TREE_CODE (op0) == COMPONENT_REF \n-\t\t   && TREE_CODE (op1) == ADDR_EXPR)\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->addr_assign (current_alias_ops, lhsAV,\n-\t\t\t\t\t\trhsAV);\n-\t    }\n-\t  /* *x.f = y or *x->f = y */\n-\t  else if ((TREE_CODE (op0) == INDIRECT_REF \n-\t\t    || TREE_CODE (op0) == ARRAY_REF)\n-\t\t   && TREE_CODE (TREE_OPERAND (op0, 0)) == COMPONENT_REF\n-\t\t   && is_gimple_variable (op1))\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->assign_ptr (current_alias_ops, lhsAV,\n-\t\t\t\t\t       rhsAV);\n-\t    }\n-\t  /* *x = &y */\n-\t  else if ((TREE_CODE (op0) == INDIRECT_REF\n-\t\t    || TREE_CODE (op0) == ARRAY_REF)\n-\t\t   && TREE_CODE (op1) == ADDR_EXPR)\n-\t    {\n-\t      /* This becomes temp = &y and *x = temp .  */\n-\t      alias_var tempvar;\n-\t      tree temp = create_tmp_var_raw (void_type_node, \"aliastmp\");\n-\t      tempvar = current_alias_ops->add_var (current_alias_ops, temp);\n-\t      current_alias_ops->addr_assign (current_alias_ops, tempvar,\n-\t\t\t\t\t      rhsAV);\n-\t      current_alias_ops->assign_ptr (current_alias_ops, lhsAV,\n-\t\t\t\t\t     tempvar);\n-\t    }\n-\n-\t  /* *x = *y */\n-\t  else if ((TREE_CODE (op0) == INDIRECT_REF \n-\t\t    || TREE_CODE (op0) == ARRAY_REF)\n-\t\t   && (TREE_CODE (op1) == INDIRECT_REF\n-\t\t       || TREE_CODE (op1) == ARRAY_REF))\n-\t    {\n-\t      /* This becomes temp = *y and *x = temp .  */\n-\t      alias_var tempvar;\n-\t      tree temp;\n-\t      temp = create_tmp_var_raw (void_type_node, \"aliastmp\");\n-\t      tempvar = current_alias_ops->add_var (current_alias_ops, temp);\n-\t      current_alias_ops->ptr_assign (current_alias_ops, tempvar,\n-\t\t\t\t\t     rhsAV);\n-\t      current_alias_ops->assign_ptr (current_alias_ops, lhsAV,\n-\t\t\t\t\t     tempvar);\n-\t    }\n-\n-\t  /* *x = (cast) y */\n-\t  else if ((TREE_CODE (op0) == INDIRECT_REF \n-\t\t    || TREE_CODE (op0) == ARRAY_REF)\n-\t\t   && is_gimple_cast (op1))\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\t{\n-\t\t  /* This becomes temp = (cast) y and  *x = temp.  */\n-\t\t  alias_var tempvar;\n-\t\t  tree temp;\n-\t\t  temp = create_tmp_var_raw (void_type_node, \"aliastmp\");\n-\t\t  tempvar = current_alias_ops->add_var (current_alias_ops,\n-\t\t\t\t\t\t\ttemp);\n-\t\t  current_alias_ops->simple_assign (current_alias_ops,\n-\t\t\t\t\t\t    tempvar, rhsAV);\n-\t\t  current_alias_ops->assign_ptr (current_alias_ops, lhsAV,\n-\t\t\t\t\t\t tempvar);\n-\t\t}\n-\t    }\n-\t  /* *x = <something else> */\n-\t  else\n-\t    {\n-\t      if (rhsAV != NULL)\n-\t\tcurrent_alias_ops->assign_ptr (current_alias_ops, lhsAV,\n-\t\t\t\t\t       rhsAV);\n-\t    }\n-\t}\n-    }\n-  /* Calls without return values.  */\n-  else if (TREE_CODE (stp) == CALL_EXPR)\n-    {\n-      alias_var callvar;\n-      varray_type args;\n-      tree arg;\n-      callvar = get_alias_var (TREE_OPERAND (stp, 0));\n-      if (callvar != NULL)\n-\t{\n-\t\n-\t  /* NORETURN and CONST functions with no return value\n-\t     have no effect on aliasing (as may be seen above,\n-\t     const functions that return a value might have an\n-\t     effect on aliasing, since the return value can point\n-\t     to one of the arguments.  */\n-\t  if (call_may_clobber (stp))\n-\t    {\n-\t      int argnum;\n-\t      VARRAY_GENERIC_PTR_INIT (args, 1, \"Arguments\");\n-\t      bitmap_clear (addrargs);\n-\t      for (arg = TREE_OPERAND (stp, 1), argnum=0; \n-\t\t   arg; \n-\t\t   arg = TREE_CHAIN (arg), argnum++)\n-\t\t{\n-\t\t  alias_var aav = get_alias_var (TREE_VALUE (arg));\n-\t\t  if (aav)\n-\t\t    {\n-\t\t      VARRAY_PUSH_GENERIC_PTR (args, aav);\n-\t\t      if (TREE_CODE (TREE_VALUE (arg)) == ADDR_EXPR)\n-\t\t\tbitmap_set_bit (addrargs, argnum);\n-\t\t    }\n-\t\t  \n-\t\t}\n-\t      \n-\t      if (current_alias_ops->function_call (current_alias_ops, NULL,\n-\t\t\t\t\t\t    callvar, args, addrargs))\n-\t\tif (!current_alias_ops->ip && flag_argument_noalias != 2)\n-\t\t  intra_function_call (args);\n-\t    }\n-\t}\n-  }\n-}\n-\n-/*  Create the alias_var for a function definition DECL, it's\n-    arguments, and it's return value. If FORCE is true, we force \n-    creation of the alias_var, regardless of whether one exists already.\n-    \n-    This includes creation of alias_var's for\n-    - The function itself.\n-    - The arguments.\n-    - The return value.  */\n-\n-static alias_var\n-create_fun_alias_var (tree decl, int force)\n-{\n-  alias_var avar, retvar;\n-  tree rdecl;\n-  varray_type params = NULL;\n-\n-  if (!force)\n-    {\n-      if (DECL_PTA_ALIASVAR (decl))\n-        return DECL_PTA_ALIASVAR (decl);\n-    }\n-\n-  VARRAY_GENERIC_PTR_INIT (params, 1, \"Arguments\");\n-  if (DECL_ARGUMENTS (decl) != NULL)\n-    {\n-      tree arg;\n-      for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n-\t{\n-\t  alias_var var = get_alias_var (arg);\n-\t  VARRAY_PUSH_GENERIC_PTR (params, var);\n-\t  /* Incoming pointers can point to pta_global_var, unless\n-\t     either we are interprocedural, or we can do ip on all\n-\t     statics + this function has been defined + it's not an\n-\t     external function.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (arg))\n-\t      && !current_alias_ops->ip\n-\t      /* FIXME: Need to let analyzer decide in partial case.  */\n-\t      && (!current_alias_ops->ip_partial\n-\t\t  || !cgraph_local_info (decl)->local))\n-\t    current_alias_ops->simple_assign (current_alias_ops, var,\n-\t\t\t\t\t      get_alias_var (pta_global_var));\n-\t}\n-    }\n-  else if (TYPE_ARG_TYPES (TREE_TYPE (decl)) != NULL)\n-    {\n-      tree arg;\n-      /* FIXME: Handle varargs */\n-      for (arg = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\t   arg && TREE_VALUE (arg) != void_type_node;\n-\t   arg = TREE_CHAIN (arg))\n-\t{\n-\t  tree fakedecl = create_tmp_var_raw (TREE_VALUE (arg), \"normarg\");\n-\t  alias_var var;\n-\t  DECL_CONTEXT (fakedecl) = current_function_decl; \n-\t  var = get_alias_var (fakedecl);\n-\t  VARRAY_PUSH_GENERIC_PTR (params, var);\n-\n-\t  /* Incoming pointers can point to pta_global_var, unless\n-\t     either we are interprocedural, or we can do ip on all\n-\t     statics + this function has been defined + it's not an\n-\t     external function.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (fakedecl))\n-\t      && !current_alias_ops->ip\n-\t      /* FIXME: need to let analyzer decide in partial case.  */\n-\t      && (!current_alias_ops->ip_partial\n-\t\t  || !TREE_STATIC (decl)\n-\t\t  || TREE_PUBLIC (decl)))\n-\t    current_alias_ops->simple_assign (current_alias_ops, var,\n-\t\t\t\t\t      get_alias_var (pta_global_var));\n-\t}\n-    }\n-  /* Functions declared like void f() are *not* equivalent to void\n-     f(void). You can pass an argument to them. Thus, we need to\n-     create some fake argument that would alias any actuals that get\n-     passed to our function.  */\n-  else\n-    {\n-      tree fakedecl = create_tmp_var_raw (void_type_node, \"fakearg\");\n-      alias_var fakevar;\n-      DECL_CONTEXT (fakedecl) = current_function_decl;\n-      fakevar = get_alias_var (fakedecl);\n-      VARRAY_PUSH_GENERIC_PTR (params, fakevar);\n-    }\n-\n-  if (!DECL_RESULT (decl))\n-    {\n-      rdecl = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (decl)), \"_rv_\");\n-      retvar = current_alias_ops->add_var (current_alias_ops, rdecl);\n-      DECL_PTA_ALIASVAR (rdecl) = retvar;\n-    }\n-  else\n-    {\n-      retvar = current_alias_ops->add_var (current_alias_ops,\n-\t\t\t\t\t   DECL_RESULT (decl));\n-      DECL_PTA_ALIASVAR (DECL_RESULT (decl)) = retvar;\n-    }\n-  VARRAY_PUSH_GENERIC_PTR (alias_vars, retvar);\n-  ALIAS_VAR_VARNUM (retvar) = VARRAY_ACTIVE_SIZE (alias_vars) - 1;\n-  avar = current_alias_ops->add_var (current_alias_ops, decl);\n-  VARRAY_PUSH_GENERIC_PTR (alias_vars, avar);\n-  ALIAS_VAR_VARNUM (avar) = VARRAY_ACTIVE_SIZE (alias_vars) - 1;\n-\n-  current_alias_ops->function_def (current_alias_ops, avar, params, retvar);\n-  DECL_PTA_ALIASVAR (decl) = avar;\n-\n-  /* FIXME: Also, if this is a defining declaration then add the annotation\n-     to all extern definitions of the function.  */\n-  return avar;\n-}\n-\n-/*  Create an alias variable for a pointer-to-member function DECL of \n-    type TYPE, it's arguments, and it's return value.\n-    Returns the alias_var for the PTF.\n-    \n-    This includes creating alias_var's for\n-    - The function itself.\n-    - The arguments.\n-    - The return value.  */\n-\n-static alias_var\n-create_fun_alias_var_ptf (tree decl, tree type)\n-{\n-  alias_var avar, retvar;\n-  tree rdecl;\n-  varray_type params = NULL;\n-\n-  if (DECL_PTA_ALIASVAR (decl))\n-    return DECL_PTA_ALIASVAR (decl);\n-\n-  VARRAY_GENERIC_PTR_INIT (params, 1, \"Arguments\");\n-\n-  if (TYPE_ARG_TYPES  (type) != NULL)\n-    {\n-      tree arg;\n-      /* FIXME: Handle varargs */\n-      for (arg = TYPE_ARG_TYPES (type);\n-\t   arg && TREE_VALUE (arg) != void_type_node;\n-\t   arg = TREE_CHAIN (arg))\n-\t{\n-\t  tree fakedecl = create_tmp_var_raw (TREE_VALUE (arg), \"ptfarg\");\n-\t  alias_var var;\n-\t  DECL_CONTEXT (fakedecl) = DECL_CONTEXT (decl);\n-\t  var = get_alias_var (fakedecl);\n-\t  VARRAY_PUSH_GENERIC_PTR (params, var);\n-\t}\n-    }\n-  /* Functions declared like void f() are *not* equivalent to void\n-     f(void). You can pass an argument to them. Thus, we need to\n-     create some fake argument that would alias any actuals that get\n-     passed to our function.  */\n-  else\n-    {\n-      tree fakedecl = create_tmp_var_raw (void_type_node, \"fakearg\");\n-      alias_var fakevar;\n-      DECL_CONTEXT (fakedecl) = DECL_CONTEXT (decl);\n-      fakevar = get_alias_var (fakedecl);\n-      VARRAY_PUSH_GENERIC_PTR (params, fakevar);\n-    }\n-\n-  rdecl = create_tmp_var_raw (TREE_TYPE (type), \"_rv_\");\n-  retvar = current_alias_ops->add_var (current_alias_ops, rdecl);\n-  VARRAY_PUSH_GENERIC_PTR (alias_vars, retvar);\n-  ALIAS_VAR_VARNUM (retvar) = VARRAY_ACTIVE_SIZE (alias_vars) - 1;\n-\n-  avar = current_alias_ops->add_var (current_alias_ops, decl);\n-  VARRAY_PUSH_GENERIC_PTR (alias_vars, avar);\n-  ALIAS_VAR_VARNUM (avar) = VARRAY_ACTIVE_SIZE (alias_vars) - 1;\n-\n-  current_alias_ops->function_def (current_alias_ops, avar, params, retvar);\n-  DECL_PTA_ALIASVAR (decl) = avar;\n-\n-  return avar;\n-}\n-\n-/*  Create the alias_var for a *_DECL node DECL.\n-    Returns the alias_var for DECL.\n-    \n-    This function also handles creation of alias_var's for PTF \n-    variables.  */\n-\n-static alias_var\n-create_alias_var (tree decl)\n-{\n-  alias_var avar;\n-\n-  gcc_assert (DECL_P (decl));\n-  \n-  if (DECL_PTA_ALIASVAR (decl))\n-    return DECL_PTA_ALIASVAR (decl);\n-\n-  if (POINTER_TYPE_P (TREE_TYPE (decl))\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == FUNCTION_TYPE)\n-    {\n-      avar = create_fun_alias_var_ptf (decl, TREE_TYPE (TREE_TYPE (decl)));\n-    }\n-  else\n-    avar = current_alias_ops->add_var (current_alias_ops, decl);\n-\n-  if (DECL_P (decl))\n-    {\n-      DECL_PTA_ALIASVAR (decl) = avar;\n-    }\n-\n-  VARRAY_PUSH_GENERIC_PTR (alias_vars, avar);\n-  ALIAS_VAR_VARNUM (avar) = VARRAY_ACTIVE_SIZE (alias_vars) - 1;\n-  return avar;\n-}\n-\n-/* Create points-to sets for the current function.  */\n-\n-static void\n-create_alias_vars (void)\n-{\n-  basic_block bb;\n-#if HAVE_BANSHEE\n-  if (flag_tree_points_to == PTA_ANDERSEN)\n-    current_alias_ops = andersen_alias_ops;\n-  else\n-#endif\n-   {\n-     current_alias_ops = NULL;\n-     flag_tree_points_to = PTA_NONE;\n-     return;\n-   }\n-\n-  pta_global_var = build_decl (VAR_DECL, get_identifier (\".pta_global_var\"),\n-\t\t\t       size_type_node);\n-  DECL_ARTIFICIAL (pta_global_var) = 1;\n-  TREE_READONLY (pta_global_var) = 1;\n-  DECL_EXTERNAL (pta_global_var) = 0;\n-  TREE_STATIC (pta_global_var) = 1;\n-  TREE_USED (pta_global_var) = 1;\n-  DECL_CONTEXT (pta_global_var) = current_function_decl; \n-  TREE_THIS_VOLATILE (pta_global_var) = 1;\n-  TREE_ADDRESSABLE (pta_global_var) = 0;\n-\n-  init_alias_vars ();\n-\n-  DECL_PTA_ALIASVAR (current_function_decl) = NULL;\n-  get_alias_var (current_function_decl);\n-\n-  /* First, walk the variables and their DECL_INITIAL's */\n-  if (cfun->unexpanded_var_list)\n-    {\n-      tree vars, var;\n-      for (vars = cfun->unexpanded_var_list; vars; vars = TREE_CHAIN (vars))\n-\t{\n-\t  var = TREE_VALUE (vars);\n-\t  if (TREE_CODE (var) != LABEL_DECL\n-\t      && TREE_STATIC (var)\n-\t      && DECL_INITIAL (var))\n-\t    find_func_aliases (var);\n-\t}\n-    }\n-\n-  /* Now walk all statements and derive aliases.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator bsi; \n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tfind_func_aliases (bsi_stmt (bsi));\n-    }\n-\n-  pta_global_var = NULL_TREE;\n-}\n-\n-static bool\n-gate_pta (void)\n-{\n-#ifdef HAVE_BANSHEE\n-  return flag_tree_points_to != PTA_NONE;\n-#else\n-  return false;\n-#endif\n-}\n-\n-struct tree_opt_pass pass_build_pta = \n-{\n-  \"pta\",\t\t\t\t/* name */\n-  gate_pta,\t\t\t\t/* gate */\n-  create_alias_vars,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PTA,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  PROP_pta,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};\n- \n-\n-/* Delete created points-to sets.  */\n-\n-static void\n-delete_alias_vars (void)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (local_alias_vars); i++)\n-    {\n-      tree key = VARRAY_TREE (local_alias_vars, i);\n-      gcc_assert (DECL_P (key));\n-      DECL_PTA_ALIASVAR (key) = NULL;\n-    }\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (local_alias_varnums); i ++)\n-    VARRAY_GENERIC_PTR (alias_vars, VARRAY_INT (local_alias_varnums, i)) = NULL;\n-  if (!current_alias_ops->ip && !current_alias_ops->ip_partial)\n-    {\n-      /*      VARRAY_CLEAR (alias_vars); */\n-      VARRAY_CLEAR (local_alias_vars);\n-      VARRAY_CLEAR (local_alias_varnums);\n-    }\n-  BITMAP_XFREE (addrargs);\n-  current_alias_ops->cleanup (current_alias_ops);\n-}\n-\n-struct tree_opt_pass pass_del_pta = \n-{\n-  \"pta\",\t\t\t\t/* name */\n-  gate_pta,\t\t\t\t/* gate */\n-  delete_alias_vars,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PTA,\t\t\t\t/* tv_id */\n-  PROP_pta,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  PROP_pta,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};\n- \n-\n-/*  Initialize points-to analysis machinery.  */\n-\n-void\n-init_alias_vars (void)\n-{\n-  current_alias_ops->init (current_alias_ops);\n-  addrargs = BITMAP_XMALLOC ();\n-  VARRAY_TREE_INIT (local_alias_vars, 10, \"Local alias vars\");\n-  VARRAY_INT_INIT (local_alias_varnums, 10, \"Local alias varnums\");\n-  if ((!current_alias_ops->ip && !current_alias_ops->ip_partial)\n-      || alias_vars == NULL)\n-    VARRAY_GENERIC_PTR_INIT (alias_vars, 10, \"Alias vars\");\n-}\n-\n-/* Return true if PTR can't point to anything (i.e. it has an empty\n-   points-to set.  */\n-bool \n-empty_points_to_set (tree ptr)\n-{\n- alias_var ptrtv;\n-  \n-#if !FIELD_BASED\n-#else\n-  if (TREE_CODE (ptr) == COMPONENT_REF)\n-    ptr = TREE_OPERAND (ptr, 1);\n-#endif\n-\n-  gcc_assert (DECL_P (ptr));\n-  ptrtv = DECL_PTA_ALIASVAR (ptr);\n-  if (!ptrtv)\n-    return true;\n-\n-  return current_alias_ops->empty_points_to_set (current_alias_ops, ptrtv);\n-}\n-\n-/* Return true if PTR and VAR have the same points-to set.  */\n-\n-bool\n-same_points_to_set (tree ptr, tree var)\n-{\n-  alias_var ptrtv, vartv;\n-  \n-#if !FIELD_BASED\n-#else\n-  if (TREE_CODE (ptr) == COMPONENT_REF)\n-    ptr = TREE_OPERAND (ptr, 1);\n-  if (TREE_CODE (var) == COMPONENT_REF)\n-    var = TREE_OPERAND (var, 1);\n-#endif\n-\n-  if (ptr == var)\n-    return true;\n-\n-  gcc_assert (DECL_P (ptr));\n-  ptrtv = DECL_PTA_ALIASVAR (ptr);\n-  if (!ptrtv)\n-    return false;\n-\n-  gcc_assert (DECL_P (var));\n-  vartv = DECL_PTA_ALIASVAR (var);\n-  if (!vartv)\n-    return false;\n-\n-  return current_alias_ops->same_points_to_set (current_alias_ops, vartv, ptrtv);\n-}\n-\n-/*  Determine whether two variables (PTR and VAR) may-alias.\n-    Returns TRUE if PTR may-alias VAR.  */\n-\n-bool\n-ptr_may_alias_var (tree ptr, tree var)\n-{\n-  alias_var ptrtv, vartv;\n-\n-#if !FIELD_BASED\n-#else\n-  if (TREE_CODE (ptr) == COMPONENT_REF)\n-    ptr = TREE_OPERAND (ptr, 1);\n-  if (TREE_CODE (var) == COMPONENT_REF)\n-    var = TREE_OPERAND (var, 1);\n-#endif\n-\n-  if (ptr == var)\n-    return true;\n-\n-  gcc_assert (DECL_P (ptr));\n-  ptrtv = DECL_PTA_ALIASVAR (ptr);\n-  if (!ptrtv)\n-    return false;\n-\n-  gcc_assert (DECL_P (var));\n-  vartv = DECL_PTA_ALIASVAR (var);\n-  if (!vartv)\n-    return false;\n-\n-  return current_alias_ops->may_alias (current_alias_ops, ptrtv, vartv);\n-}\n-\n-#define MASK_POINTER(P)\t((unsigned)((unsigned long)(P) & 0xffff))\n-\n-const char *\n-alias_get_name (tree t)\n-{\n-  const char *name;\n-\n-#if FIELD_BASED\n-  if (TREE_CODE (t) == FIELD_DECL)\n-    {\n-      /* First get the name of the field, then the prefix, then smash them\n-\t together.  */\n-      const char *fieldname = IDENTIFIER_POINTER (DECL_NAME (t));\n-      const char *prefix = alias_get_name (DECL_CONTEXT (t));\n-      char *smashed;\n-      size_t neededlen = strlen (fieldname) + strlen (prefix) + 2;\n-      smashed = ggc_alloc (neededlen);\n-      sprintf (smashed, \"%s.%s\", prefix, fieldname);\n-      name = smashed;\n-\n-    }\n-  else if (TYPE_P (t))\n-    {\n-      if (TYPE_NAME (t) && IDENTIFIER_POINTER (TYPE_NAME (t)))\n-\tname = IDENTIFIER_POINTER (TYPE_NAME (t));\n-      else\n-\tname = \"<unnamed type>\";\n-    }\n-  else\n-#endif\n-    {\n-      if (TREE_CODE (t) == FUNCTION_DECL)\n-\tname = IDENTIFIER_POINTER (DECL_NAME (t));\n-      else if (TREE_CODE (t) == RESULT_DECL)\n-\tname = \"<return value>\";\n-      else\n-\tname = get_name (t);\n-    }\n-\n-  if (!name)\n-    {\n-      char *namep;\n-      /* 2 = UF\n-\t 4 = the masked pointer\n-\t 2 = the <> around it\n-\t 1 = the terminator.  */\n-      namep = ggc_alloc (2 + 4 + 2 + 1);\n-      sprintf (namep, \"<UV%x>\", MASK_POINTER (t));\n-      return namep;\n-    }\n-\n-  return name;\n-}\n-\n-#include \"gt-tree-alias-common.h\""}, {"sha": "ec93ce3dad2a8b5bac874c98b0e2a5efddeb1948", "filename": "gcc/tree-alias-common.h", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-common.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,123 +0,0 @@\n-/* Tree based points-to analysis\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-*/\n-\n-#ifndef TREE_ALIAS_COMMON\n-#define TREE_ALIAS_COMMON\n-\n-#include \"tree-alias-type.h\"\n-\n-/* Alias analysis function pointers.\n-   Functions implemented by the actual alias analysis algorithms in\n-   order for them to work with the common points-to structure.  */\n-struct tree_alias_ops\n-{\n-  /* Initialization.\n-     Called right before we start using the other functions.  */\n-  void (*init) (struct tree_alias_ops *);\n-\n-  /* Cleanup. \n-     Called when we are finished with the alias analyzer.  */\n-  void (*cleanup) (struct tree_alias_ops *);\n-\n-  /* Add variable.\n-     Called when we want to inform the alias analyzer about a new\n-     variable we've found.  */\n-  alias_var (*add_var) (struct tree_alias_ops *, tree);\n-\n-  /* Add variable equivalent to existing one.\n-     Called when we want to inform the alias analyzer about a new\n-     variable that has the same points-to set as an existing\n-     variable.  */ \n-  alias_var (*add_var_same) (struct tree_alias_ops *, tree,\n-\t\t\t\t alias_var);\n-  \n-  /* Process a simple assignment (a = b).\n-     Called to process simple assignment statements of the form a = b,\n-     where a and b are both variables.  */\n-  void (*simple_assign) (struct tree_alias_ops *, alias_var,\n-\t\t\t alias_var);\n-  /* Process an address assignment (a = &b).\n-     Called to process address assignment statements of the form a =\n-     &b, where a and b are both variables.  */\n-  void (*addr_assign) (struct tree_alias_ops *, alias_var, alias_var);\n-\n-  /* Process a pointer assignment (a = *b).\n-     Called to process pointer assignment statements of the form a =\n-     *b, where a and b are both variables.  */\n-  void (*ptr_assign) (struct tree_alias_ops *, alias_var, alias_var);\n-\n-  /* Process an operator assignment (a = op (...))\n-     Called to process operators of the form a = op(...), where a is a\n-     variable.  */\n-  void (*op_assign) (struct tree_alias_ops *, alias_var, varray_type, \n-\t\t     tree, bitmap);\n-  /* Process a heap assignment (a = alloc (...))\n-     Called to process a heap assignment of the form a = alloc\n-     (...), where a is a variable, and *alloc is a function that\n-     returns new memory.  */\n-  void (*heap_assign) (struct tree_alias_ops *, alias_var);\n-\n-  /* Process an assignment to a pointer (*a = b)\n-     Called to process assignment to pointer statements of the form\n-     *a = b, where a and b are both variables.  */\n-  void (*assign_ptr) (struct tree_alias_ops *, alias_var, alias_var);\n-\n-  /* Process a function definition.\n-     Called to inform the alias analyzer about a new function\n-     definition.  */\n-  void (*function_def) (struct tree_alias_ops *, alias_var,\n-\t\t\tvarray_type, alias_var);\n-\n-  /* Process a function call.\n-     Return 1 if we need to assume conservative side-effects.  */\n-  int (*function_call) (struct tree_alias_ops *, alias_var,\n-\t\t\talias_var, varray_type, bitmap);\n-\n-  /* Determine if two alias variables may alias.   */\n-  bool (*may_alias) (struct tree_alias_ops *, alias_var, alias_var);\n-\n-  /* Determine if two alias variables have the same points-to set.  */\n-  bool (*same_points_to_set) (struct tree_alias_ops *, alias_var, \n-\t\t\t      alias_var);\n-  \n-  /* Determine if the alias variable has an empty points-to set.  */\n-  bool (*empty_points_to_set) (struct tree_alias_ops *, alias_var);\n-  \n-  /* Private data.  */\n-  void *data;\n-\n-  /* Interprocedural.  */\n-  unsigned int ip:1; \n-\n-  /* Can do conservative interprocedural analysis if we save the \n-   * info.  */\n-  unsigned int ip_partial:1; \n-\n-};\n-\n-extern struct tree_alias_ops *current_alias_ops;\n-extern void init_alias_vars (void);\n-extern bool ptr_may_alias_var (tree, tree);\n-extern bool same_points_to_set (tree, tree);\n-extern bool empty_points_to_set (tree);\n-extern const char *alias_get_name (tree);\n-\n-#endif /* TREE_ALIAS_COMMON */"}, {"sha": "20bcbf733fd1bf9137857f3164452959d4a58185", "filename": "gcc/tree-alias-type.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-type.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,37 +0,0 @@\n-/* Tree based linear points-to analysis\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-*/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"ggc.h\"\n-#include \"tree-alias-type.h\"\n-\n-alias_var\n-alias_var_new_with_aterm (tree decl, struct aterm_ *term)\n-{\n-  alias_var ret = ggc_alloc (sizeof (struct alias_var_aterm));\n-  ALIAS_VAR_KIND (ret) = ATERM_AVAR;\n-  ALIAS_VAR_DECL (ret) = decl;\n-  ALIAS_VAR_ATERM (ret) = term;\n-  return ret;\n-}"}, {"sha": "5c81af764631c443929e6773561dc6925ec3d203", "filename": "gcc/tree-alias-type.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/gcc%2Ftree-alias-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-type.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,68 +0,0 @@\n-/* Tree based linear points-to analysis\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-*/\n-\n-#ifndef TREE_ALIAS_TYPE_H\n-#define TREE_ALIAS_TYPE_H\n-\n-#include \"varray.h\"\n-\n-union alias_var_def;\n-struct aterm_;\n-struct aterm_list_a;\n-\n-enum alias_var_kind\n-{\n-  ATERM_AVAR\n-};\n-\n-struct alias_var_common  GTY (())\n-{\n-  enum alias_var_kind kind;\n-  unsigned int varnum;\n-  tree decl;\n-};\n-\n-struct alias_var_aterm GTY (())\n-{\n-  struct alias_var_common common;\n-  struct aterm_ * GTY((skip (\"\"))) term;\n-  struct aterm_list_a *GTY ((skip (\"\"))) ptset;\n-};\n-\n-union alias_var_def GTY ((desc (\"%0.common.kind\")))\n-{\n-  struct alias_var_common GTY ((tag (\"-1\"))) common;\n-  struct alias_var_aterm GTY ((tag (\"ATERM_AVAR\"))) aterm;\n-};\n-\n-typedef union alias_var_def *alias_var;\n-\n-#define ALIAS_VAR_KIND(x) ((x)->common.kind)\n-#define ALIAS_VAR_VARNUM(x) ((x)->common.varnum)\n-#define ALIAS_VAR_DECL(x) ((x)->common.decl)\n-#define ALIAS_VAR_ATERM(x) ((x)->aterm.term)\n-#define ALIAS_VAR_PTSET(x) ((x)->aterm.ptset)\n-union alias_type_def;\n-typedef union alias_type_def *alias_type;\n-\n-alias_var alias_var_new_with_aterm (tree, struct aterm_ *);\n-\n-#endif /* TREE_ALIAS_TYPE_H */"}, {"sha": "3ceb60afd3ba9d0291a163a45e2514371bbe9f04", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -42,7 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-gimple.h\"\n #include \"tree-flow.h\"\n #include \"tree-inline.h\"\n-#include \"tree-alias-common.h\"\n #include \"tree-pass.h\"\n #include \"convert.h\"\n #include \"params.h\""}, {"sha": "80e36dc29d20cc7cc9aba7773a3298002e42067d", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-inline.h\"\n #include \"varray.h\"\n #include \"timevar.h\"\n-#include \"tree-alias-common.h\"\n #include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-pass.h\""}, {"sha": "c07701a9c06bc78180bbcbe7d4d5d313c73317b5", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -44,7 +44,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-inline.h\"\n #include \"tree-mudflap.h\"\n #include \"tree-pass.h\"\n-#include \"tree-alias-common.h\"\n #include \"ggc.h\"\n #include \"cgraph.h\"\n #include \"graph.h\"\n@@ -346,7 +345,6 @@ init_tree_optimization_passes (void)\n \n   p = &pass_all_optimizations.sub;\n   NEXT_PASS (pass_referenced_vars);\n-  NEXT_PASS (pass_build_pta);\n   NEXT_PASS (pass_build_ssa);\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_rename_ssa_copies);\n@@ -384,7 +382,6 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_tail_calls);\n   NEXT_PASS (pass_late_warn_uninitialized);\n-  NEXT_PASS (pass_del_pta);\n   NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_remove_useless_vars);"}, {"sha": "4c8c21677ca3c6bb46392794dbc57e16d29570d8", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -42,7 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-inline.h\"\n #include \"varray.h\"\n #include \"timevar.h\"\n-#include \"tree-alias-common.h\"\n #include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\""}, {"sha": "fa9151f105b32bcfd4a341d4abe8937aac0c5dbf", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -119,8 +119,6 @@ extern struct tree_opt_pass pass_lower_eh;\n extern struct tree_opt_pass pass_build_cfg;\n extern struct tree_opt_pass pass_tree_profile;\n extern struct tree_opt_pass pass_referenced_vars;\n-extern struct tree_opt_pass pass_build_pta;\n-extern struct tree_opt_pass pass_del_pta;\n extern struct tree_opt_pass pass_sra;\n extern struct tree_opt_pass pass_tail_recursion;\n extern struct tree_opt_pass pass_tail_calls;"}, {"sha": "f00fcc1e97b6e7f1ecb4918625779f474aecfb99", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -39,7 +39,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-gimple.h\"\n #include \"tree-flow.h\"\n #include \"tree-inline.h\"\n-#include \"tree-alias-common.h\"\n #include \"tree-pass.h\"\n #include \"convert.h\"\n #include \"params.h\"\n@@ -125,8 +124,6 @@ struct alias_stats_d\n   unsigned int simple_resolved;\n   unsigned int tbaa_queries;\n   unsigned int tbaa_resolved;\n-  unsigned int pta_queries;\n-  unsigned int pta_resolved;\n };\n \n \n@@ -354,7 +351,7 @@ struct tree_opt_pass pass_may_alias =\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n   TV_TREE_MAY_ALIAS,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa | PROP_pta,\t/* properties_required */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n   PROP_alias,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n@@ -1618,18 +1615,6 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n \t}\n     }\n \n-  if (flag_tree_points_to != PTA_NONE)\n-      alias_stats.pta_queries++;\n-\n-  /* If -ftree-points-to is given, check if PTR may point to VAR.  */\n-  if (flag_tree_points_to == PTA_ANDERSEN\n-      && !ptr_may_alias_var (ptr, var))\n-    {\n-      alias_stats.alias_noalias++;\n-      alias_stats.pta_resolved++;\n-      return false;\n-    }\n-\n   alias_stats.alias_mayalias++;\n   return true;\n }\n@@ -2119,9 +2104,7 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n   for (i = 0, tag = NULL_TREE; i < ai->num_pointers; i++)\n     {\n       struct alias_map_d *curr = ai->pointers[i];\n-      if (tag_set == curr->set \n-\t  && (flag_tree_points_to == PTA_NONE \n-\t      || same_points_to_set (curr->var, ptr)))\n+      if (tag_set == curr->set)\n \t{\n \t  tag = var_ann (curr->var)->type_mem_tag;\n \t  break;\n@@ -2203,10 +2186,6 @@ dump_alias_stats (FILE *file)\n \t   alias_stats.tbaa_queries);\n   fprintf (file, \"Total TBAA resolved:\\t%u\\n\",\n \t   alias_stats.tbaa_resolved);\n-  fprintf (file, \"Total PTA queries:\\t%u\\n\",\n-\t   alias_stats.pta_queries);\n-  fprintf (file, \"Total PTA resolved:\\t%u\\n\",\n-\t   alias_stats.pta_resolved);\n }\n   \n "}, {"sha": "1db85ff9f083532c02a0a7df606642b18640b3b0", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-gimple.h\"\n #include \"tree-inline.h\"\n #include \"timevar.h\"\n-#include \"tree-alias-common.h\"\n #include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\""}, {"sha": "a1c716bf71fb3b2dd6079c9826998f93bc2901ad", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-inline.h\"\n #include \"varray.h\"\n #include \"timevar.h\"\n-#include \"tree-alias-common.h\"\n #include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\""}, {"sha": "2da6c99651efffcd2b8ec8088f8f76c017608d51", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0504855047048c80698790a06b7b25936723e5/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=0a0504855047048c80698790a06b7b25936723e5", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-inline.h\"\n #include \"varray.h\"\n #include \"timevar.h\"\n-#include \"tree-alias-common.h\"\n #include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-pass.h\""}, {"sha": "d89921897ae6b00d4a280883194d448ed042c839", "filename": "libbanshee/.cvsignore", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2F.cvsignore?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1 +0,0 @@\n-autom4te.cache"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libbanshee/AUTHORS", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FAUTHORS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FAUTHORS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FAUTHORS?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libbanshee/COPYING", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FCOPYING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FCOPYING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FCOPYING?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "af706e1ead2e64513dba9e0f876a254eace8ec88", "filename": "libbanshee/COPYRIGHT", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FCOPYRIGHT", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FCOPYRIGHT", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FCOPYRIGHT?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,26 +0,0 @@\n-Copyright (c) 2000-2001\n-     The Regents of the University of California.  All rights reserved.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions\n-are met:\n-1. Redistributions of source code must retain the above copyright\n-   notice, this list of conditions and the following disclaimer.\n-2. Redistributions in binary form must reproduce the above copyright\n-   notice, this list of conditions and the following disclaimer in the\n-   documentation and/or other materials provided with the distribution.\n-3. Neither the name of the University nor the names of its contributors\n-   may be used to endorse or promote products derived from this software\n-   without specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n-ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n-OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n-SUCH DAMAGE."}, {"sha": "bda508999284022d4eb91c8743aad9ae4f30be44", "filename": "libbanshee/ChangeLog", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FChangeLog?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,162 +0,0 @@\n-2004-06-27  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n-\n-\tPR bootstrap/15627\n-\t* engine/flowrow-sort.c (update_upper_bound): Converted comment to\n-\tC-style.\n-\t(flowrow_inclusion): Likewise.\n-\t(flowrow_extract_field): Unnest field_eq.\n-\t* engine/setif-sort.c (search_ubs): Unnest search_ubs_aux.\n-\t(search_lbs): Unnest search_lbs_aux.\n-\t(setif_inclusion): Unnest collapse_cycle_lower, collapse_cycle_upper,\n-\tupdate_lower_bound, update_upper_bound.\n-\n-2004-06-15  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* Makefile.in: Regenerate with automake 1.8.5.\n-\t* aclocal.m4: Likewise.\n-\t* engine/Makefile.in: Likewise.\n-\t* libcompat/Makefile.in: Likewise.\n-\t* points-to/Makefile.in: Likewise.\n-\t* configure: Regenerate.\n-\t* .cvsignore: New file.\n-\n-2004-05-28  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* configure.in: Rename to ...\n-\t* configure.ac: this.  Update to modern autoconf style. \n-\tCorrect AC_INIT macro with the actual package name.\n-\tReplace gcc_AC_HEADER_STDBOOL and GCC_AC_C__BOOL with AC_HEADER_STDBOOL.\n-\t* acinclude.m4, stamp.h-in: Delete.\n-\t* config.h, configure: Regenerate with autoconf 2.59.\n-\t* aclocal.m4, Makefile.in: Regenerate with automake 1.7.9.\n-\t* engine/Makefile.in: Likewise.\n-\t* libcompat/Makefile.in: Likewise.\n-\t* points-to/Makefile.in: Likewise.\n-\n-2004-05-24  Daniel Berlin  <dberlin@dberlin.org>\n-\t\n-\tPR other/15627\n-\t* engine/util.h: Include ansidecl.h.\n-\tMake max and min static inline.\n-\t* engine/util.c: Remove max and min from here.\n-\n-2004-03-26  Andreas Jaeger  <aj@suse.de>\n-\n-        * configure.in: Remove GCC_NO_EXECUTABLES.\n-        * configure: Regenerated.\n-\n-2004-03-07  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\t* engine/Makefile.am (AM_CFLAGS): Add -I$(top_srcddir)/../include, so we\n-\tcan get ansidecl.h and friends.\n-\t* engine/array.c (array_extend): Fix unsigned/signed comparison.\n-\t* engine/banshee.h (struct gen_e): Just make void * when empty, instead\n-\tof empty struct.\n-\t* engine/compiler.h: Don't ever define HAVE_VARIADIC_MACROS, -pedantic\n-\twhines about them even when we know we can use them.\n-\t* engine/dot.c: constify our char *'s everywhere.\n-\t(declare_node): Cast &result to char * before casting to hash_data *.\n-\t* engine/dot.h: constify our char *'s everywhere.\n-\t* engine/flow-var.c: Ditto.\n-\t* engine/flow-var.h: Ditto.\n-\t* engine/flowrow-sort.c: Include ansidecl.h.\n-\t(get_contour): Mark unused parameter.\n-\t(update_upper_bound): Make comment /* instead of //.\n-\t(field_eq): Staticify.\n-\t* engine/hash.c (string_hash): Staticify.\n-\t(string_eq): Ditto.\n-\t(entry_cmp): Ditto.\n-\t* engine/hash.h: Move comments around.\n-\t(hash_table_apply): Add prototype.\n-\t* engine/hashset.c (INIT_TABLE_SIZE): Remove extra semicolon.\n-\t(EMPTY_KEY): Ditto.\n-\t* engine/jcollection.c (jcoll_create_chain): // -> /* comment.\n-\t(jcoll_accum): Staticify.\n-\t* engine/list.c (sort_linked_list): Staticify.\n-\t(compare): Use comparator_fn as last argument, not void *.\n-\t* engine/list.h: Declare the functions even for opaque lists.\n-\t(list_clear macro): don't return value.\n-\t* engine/setif-sort.c: Replaced with new version from banshee cvs.\n-\t* engine/setif-var.c: constify our char *'s.\n-\t* engine/setif-var.h: Ditto.\n-\t* engine/setst-var.c: Ditto.\n-\t* engine/setst-var.h: Ditto.\n-\t* engine/stamp.c (stamp_string): Use long, not int.\n-\tCast through char *.\n-\t* engine/stamp.h (stamp): Long, not int.\n-\t* engine/term-sort.c (term_print_stats): Mark argument unused.\n-\tinclude ansidecl.h.\n-\t* engine/term-var.c: constify the char *'s.\n-\t* engine/term-var.h: Ditto.\n-\t* engine/ufind.h (union find update macro): Don't return uf_update's value\n-\t(which is void anyway).\n-\t* engine/util.c (ptr_hash): Return long, not int.\n-\t* engine/util.h (ptr_hash): Ditto.\n-\n-2004-02-29  Andreas Jaeger  <aj@suse.de>\n-\n-\t* configure.in: Set ac_libbanshee_warn_cflags for GCC.\n-\t* configure: Regenerated.\n-\n-\t* libcompat/Makefile.am (AM_CFLAGS): Add\n-\tac_libbanshee_warn_cflags.\n-\t* engine/Makefile.am (AM_CFLAGS): Likewise.\n-\t* points-to/Makefile.am (AM_CFLAGS): Likewise.\n-\n-\t* libcompat/Makefile.in: Regenerated.\n-\t* engine/Makefile.in: Regenerated.\n-\t* points-to/Makefile.in: Regenerated.\n-\t* Makefile.in: Regenerated.\n-\n-\t* libcompat/radix-tree.c: Include <stdlib.h> for calloc.\n-\n-2004-02-03  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\tFix PR other/12220\n-\t* engine/Makefile.am: Remove -fno-strict-aliasing.\n-\t* libcompat/Makefile.am: Ditto.\n-\t* points-to/Makefile.am: Ditto.\n-\t* configure: Regenerated.\n-\t* config.h.in: Ditto.\n-\t* Makefile.in: Ditto.\n-\t* engine/Makefile.am: Ditto.\n-\t* libcompat/Makefile.am: Ditto.\n-\t* points-to/Makefile.am: Ditto.\n-\n-2003-07-01  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\t* acinclude.m4: New, copy the bool tests from gcc.\n-\n-\t* configure.in: Use the new bool tests.\n-\n-\t* Regenerate configure.\n-\n-\t* engine/bool.h: Rewrite to use the part of gcc's system.h that does\n-\tbool type handling.\n-\n-2002-12-26  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\t* Makefile.am: Use the same flag passing hack all other subdirs use.\n-\n-\t* */Makefile.am: Use -fno-strict-aliasing till i get rid of the\n-\ttype-punning.\n-\n-\t* Regenerate configure and Makefiles.\n-\n-\t* engine/setst-*.c: Remove nested functions.\n-\n-2002-11-28  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* aclocal.m4: Don't call aclocal and automake with a\n-\tversion number suffix.\n-\t* Makefile.in, config.h.in, configure,\n-\tengine/Makefile.in, libcompat/Makefile.in,\n-\tpoints-to/Makefile.in: Regenerate.\n-\n-2002-11-24  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\t* points-to/andersen_terms.c: Fix multi-line string literals\n-\n-2002-10-31  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\t* Autoconf'ed, automak'ed, de-nested functified, etc."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libbanshee/INSTALL", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FINSTALL", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FINSTALL", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FINSTALL?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "9b9d70b08424f7bf9b1785520c223c74900bfa3a", "filename": "libbanshee/Makefile.am", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FMakefile.am?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,41 +0,0 @@\n-SUBDIRS = engine points-to libcompat\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"EXPECT=$(EXPECT)\" \\\n-\t\"RUNTEST=$(RUNTEST)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"tooldir=$(tooldir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\""}, {"sha": "e500862bfbb6d7fc6db090df202ab6cde011bf98", "filename": "libbanshee/Makefile.in", "status": "removed", "additions": 0, "deletions": 603, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FMakefile.in?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,603 +0,0 @@\n-# Makefile.in generated by automake 1.8.5 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-srcdir = @srcdir@\n-top_srcdir = @top_srcdir@\n-VPATH = @srcdir@\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-top_builddir = .\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-INSTALL = @INSTALL@\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-subdir = .\n-DIST_COMMON = README $(am__configure_deps) $(srcdir)/../install-sh \\\n-\t$(srcdir)/../missing $(srcdir)/../mkinstalldirs \\\n-\t$(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n-\t$(srcdir)/config.h.in $(top_srcdir)/configure AUTHORS COPYING \\\n-\tChangeLog INSTALL NEWS\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno configure.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = config.h\n-CONFIG_CLEAN_FILES =\n-SOURCES =\n-DIST_SOURCES =\n-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n-\thtml-recursive info-recursive install-data-recursive \\\n-\tinstall-exec-recursive install-info-recursive \\\n-\tinstall-recursive installcheck-recursive installdirs-recursive \\\n-\tpdf-recursive ps-recursive uninstall-info-recursive \\\n-\tuninstall-recursive\n-ETAGS = etags\n-CTAGS = ctags\n-DIST_SUBDIRS = $(SUBDIRS)\n-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n-distdir = $(PACKAGE)-$(VERSION)\n-top_distdir = $(distdir)\n-am__remove_distdir = \\\n-  { test ! -d $(distdir) \\\n-    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \\\n-         && rm -fr $(distdir); }; }\n-DIST_ARCHIVES = $(distdir).tar.gz\n-GZIP_ENV = --best\n-distuninstallcheck_listfiles = find . -type f -print\n-distcleancheck_listfiles = find . -type f -print\n-ACLOCAL = @ACLOCAL@\n-AMDEP_FALSE = @AMDEP_FALSE@\n-AMDEP_TRUE = @AMDEP_TRUE@\n-AMTAR = @AMTAR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@\n-MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n-MAKEINFO = @MAKEINFO@\n-OBJEXT = @OBJEXT@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_RANLIB = @ac_ct_RANLIB@\n-ac_ct_STRIP = @ac_ct_STRIP@\n-ac_libbanshee_warn_cflags = @ac_libbanshee_warn_cflags@\n-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@\n-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-bindir = @bindir@\n-build_alias = @build_alias@\n-datadir = @datadir@\n-exec_prefix = @exec_prefix@\n-host_alias = @host_alias@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-oldincludedir = @oldincludedir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-sysconfdir = @sysconfdir@\n-target_alias = @target_alias@\n-SUBDIRS = engine points-to libcompat\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"EXPECT=$(EXPECT)\" \\\n-\t\"RUNTEST=$(RUNTEST)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"tooldir=$(tooldir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n-\n-all: config.h\n-\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n-\n-.SUFFIXES:\n-am--refresh:\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --gnu '; \\\n-\t      cd $(srcdir) && $(AUTOMAKE) --gnu  \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  Makefile'; \\\n-\tcd $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --gnu  Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\tcd $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\tcd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-\n-config.h: stamp-h1\n-\t@if test ! -f $@; then \\\n-\t  rm -f stamp-h1; \\\n-\t  $(MAKE) stamp-h1; \\\n-\telse :; fi\n-\n-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n-\t@rm -f stamp-h1\n-\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n-\tcd $(top_srcdir) && $(AUTOHEADER)\n-\trm -f stamp-h1\n-\ttouch $@\n-\n-distclean-hdr:\n-\t-rm -f config.h stamp-h1\n-uninstall-info-am:\n-\n-# This directory's subdirectories are mostly independent; you can cd\n-# into them and run `make' without going through this Makefile.\n-# To change the values of `make' variables: instead of editing Makefiles,\n-# (1) if the variable is set in `config.status', edit `config.status'\n-#     (which will cause the Makefiles to be regenerated when you run `make');\n-# (2) otherwise, pass the desired values on the `make' command line.\n-$(RECURSIVE_TARGETS):\n-\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n-\tdot_seen=no; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    dot_seen=yes; \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n-\tdone; \\\n-\tif test \"$$dot_seen\" = \"no\"; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n-\tfi; test -z \"$$fail\"\n-\n-mostlyclean-recursive clean-recursive distclean-recursive \\\n-maintainer-clean-recursive:\n-\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n-\tdot_seen=no; \\\n-\tcase \"$@\" in \\\n-\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n-\t  *) list='$(SUBDIRS)' ;; \\\n-\tesac; \\\n-\trev=''; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = \".\"; then :; else \\\n-\t    rev=\"$$subdir $$rev\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\trev=\"$$rev .\"; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tfor subdir in $$rev; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n-\tdone && test -z \"$$fail\"\n-tags-recursive:\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  test \"$$subdir\" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n-\tdone\n-ctags-recursive:\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  test \"$$subdir\" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n-\tdone\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\ttags=; \\\n-\there=`pwd`; \\\n-\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n-\t  include_option=--etags-include; \\\n-\t  empty_fix=.; \\\n-\telse \\\n-\t  include_option=--include; \\\n-\t  empty_fix=; \\\n-\tfi; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = .; then :; else \\\n-\t    test ! -f $$subdir/TAGS || \\\n-\t      tags=\"$$tags $$include_option=$$here/$$subdir/TAGS\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\tif test -z \"$(ETAGS_ARGS)$$tags$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t    $$tags $$unique; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\ttags=; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$tags$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$tags $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && cd $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) $$here\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\n-distdir: $(DISTFILES)\n-\t$(am__remove_distdir)\n-\tmkdir $(distdir)\n-\t$(mkdir_p) $(distdir)/..\n-\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n-\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's|.|.|g'`; \\\n-\tlist='$(DISTFILES)'; for file in $$list; do \\\n-\t  case $$file in \\\n-\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-\t    $(top_srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$topsrcdirstrip/|$(top_builddir)/|\"`;; \\\n-\t  esac; \\\n-\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n-\t  dir=`echo \"$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n-\t  if test \"$$dir\" != \"$$file\" && test \"$$dir\" != \".\"; then \\\n-\t    dir=\"/$$dir\"; \\\n-\t    $(mkdir_p) \"$(distdir)$$dir\"; \\\n-\t  else \\\n-\t    dir=''; \\\n-\t  fi; \\\n-\t  if test -d $$d/$$file; then \\\n-\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n-\t      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \\\n-\t    fi; \\\n-\t    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \\\n-\t  else \\\n-\t    test -f $(distdir)/$$file \\\n-\t    || cp -p $$d/$$file $(distdir)/$$file \\\n-\t    || exit 1; \\\n-\t  fi; \\\n-\tdone\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = .; then :; else \\\n-\t    test -d \"$(distdir)/$$subdir\" \\\n-\t    || mkdir \"$(distdir)/$$subdir\" \\\n-\t    || exit 1; \\\n-\t    (cd $$subdir && \\\n-\t      $(MAKE) $(AM_MAKEFLAGS) \\\n-\t        top_distdir=\"../$(top_distdir)\" \\\n-\t        distdir=\"../$(distdir)/$$subdir\" \\\n-\t        distdir) \\\n-\t      || exit 1; \\\n-\t  fi; \\\n-\tdone\n-\t-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \\; -o \\\n-\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n-\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n-\t  ! -type d ! -perm -444 -exec $(SHELL) $(install_sh) -c -m a+r {} {} \\; \\\n-\t|| chmod -R a+r $(distdir)\n-dist-gzip: distdir\n-\t$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n-\t$(am__remove_distdir)\n-\n-dist-bzip2: distdir\n-\t$(AMTAR) chof - $(distdir) | bzip2 -9 -c >$(distdir).tar.bz2\n-\t$(am__remove_distdir)\n-\n-dist-tarZ: distdir\n-\t$(AMTAR) chof - $(distdir) | compress -c >$(distdir).tar.Z\n-\t$(am__remove_distdir)\n-\n-dist-shar: distdir\n-\tshar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz\n-\t$(am__remove_distdir)\n-\n-dist-zip: distdir\n-\t-rm -f $(distdir).zip\n-\tzip -rq $(distdir).zip $(distdir)\n-\t$(am__remove_distdir)\n-\n-dist dist-all: distdir\n-\t$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n-\t$(am__remove_distdir)\n-\n-# This target untars the dist file and tries a VPATH configuration.  Then\n-# it guarantees that the distribution is self-contained by making another\n-# tarfile.\n-distcheck: dist\n-\tcase '$(DIST_ARCHIVES)' in \\\n-\t*.tar.gz*) \\\n-\t  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(AMTAR) xf - ;;\\\n-\t*.tar.bz2*) \\\n-\t  bunzip2 -c $(distdir).tar.bz2 | $(AMTAR) xf - ;;\\\n-\t*.tar.Z*) \\\n-\t  uncompress -c $(distdir).tar.Z | $(AMTAR) xf - ;;\\\n-\t*.shar.gz*) \\\n-\t  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\\\n-\t*.zip*) \\\n-\t  unzip $(distdir).zip ;;\\\n-\tesac\n-\tchmod -R a-w $(distdir); chmod a+w $(distdir)\n-\tmkdir $(distdir)/_build\n-\tmkdir $(distdir)/_inst\n-\tchmod a-w $(distdir)\n-\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n-\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n-\t  && cd $(distdir)/_build \\\n-\t  && ../configure --srcdir=.. --prefix=\"$$dc_install_base\" \\\n-\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n-\t        distuninstallcheck \\\n-\t  && chmod -R a-w \"$$dc_install_base\" \\\n-\t  && ({ \\\n-\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n-\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n-\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n-\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n-\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n-\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n-\t  && rm -rf \"$$dc_destdir\" \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n-\t  && rm -rf $(DIST_ARCHIVES) \\\n-\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck\n-\t$(am__remove_distdir)\n-\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n-\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n-\t  sed -e '1{h;s/./=/g;p;x;}' -e '$${p;x;}'\n-distuninstallcheck:\n-\t@cd $(distuninstallcheck_dir) \\\n-\t&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \\\n-\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n-\t        if test -n \"$(DESTDIR)\"; then \\\n-\t          echo \"  (check DESTDIR support)\"; \\\n-\t        fi ; \\\n-\t        $(distuninstallcheck_listfiles) ; \\\n-\t        exit 1; } >&2\n-distcleancheck: distclean\n-\t@if test '$(srcdir)' = . ; then \\\n-\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n-\t  exit 1 ; \\\n-\tfi\n-\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n-\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n-\t       $(distcleancheck_listfiles) ; \\\n-\t       exit 1; } >&2\n-check-am: all-am\n-check: check-recursive\n-all-am: Makefile config.h\n-installdirs: installdirs-recursive\n-installdirs-am:\n-install: install-recursive\n-install-exec: install-exec-recursive\n-install-data: install-data-recursive\n-uninstall: uninstall-recursive\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-recursive\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-rm -f $(CONFIG_CLEAN_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-recursive\n-\n-clean-am: clean-generic mostlyclean-am\n-\n-distclean: distclean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-generic distclean-hdr distclean-tags\n-\n-dvi: dvi-recursive\n-\n-dvi-am:\n-\n-html: html-recursive\n-\n-info: info-recursive\n-\n-info-am:\n-\n-install-data-am:\n-\n-install-exec-am:\n-\n-install-info: install-info-recursive\n-\n-install-man:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-recursive\n-\n-mostlyclean-am: mostlyclean-generic\n-\n-pdf: pdf-recursive\n-\n-pdf-am:\n-\n-ps: ps-recursive\n-\n-ps-am:\n-\n-uninstall-am: uninstall-info-am\n-\n-uninstall-info: uninstall-info-recursive\n-\n-.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am am--refresh check \\\n-\tcheck-am clean clean-generic clean-recursive ctags \\\n-\tctags-recursive dist dist-all dist-bzip2 dist-gzip dist-shar \\\n-\tdist-tarZ dist-zip distcheck distclean distclean-generic \\\n-\tdistclean-hdr distclean-recursive distclean-tags \\\n-\tdistcleancheck distdir distuninstallcheck dvi dvi-am html \\\n-\thtml-am info info-am install install-am install-data \\\n-\tinstall-data-am install-exec install-exec-am install-info \\\n-\tinstall-info-am install-man install-strip installcheck \\\n-\tinstallcheck-am installdirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-recursive \\\n-\tmostlyclean mostlyclean-generic mostlyclean-recursive pdf \\\n-\tpdf-am ps ps-am tags tags-recursive uninstall uninstall-am \\\n-\tuninstall-info-am\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libbanshee/NEWS", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FNEWS?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "f5e2198957b055ea7cbef592933346d099ec397d", "filename": "libbanshee/README", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2FREADME?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,11 +0,0 @@\n-This is banshee, a toolkit for constructing constraint-based program analyses.\n-See the user manual in docs/banshee.ps for a complete description of banshee.\n-\n-This is a beta release of banshee. Although banshee has been designed to solve\n-many kinds of constraints, it has only been extensively tested on \n-Andersen's-style points-to analysis. \n-\n-banshee is distributed under the BSD license. See the COPYRIGHT file for more\n-details.\n-\n-Send bug reports to jkodumal@cs.berkeley.edu.\n\\ No newline at end of file"}, {"sha": "bd9f0ce73fb9a10b6f5a4b0b48609bd2d8079c69", "filename": "libbanshee/aclocal.m4", "status": "removed", "additions": 0, "deletions": 948, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Faclocal.m4?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,948 +0,0 @@\n-# generated automatically by aclocal 1.8.5 -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-# Free Software Foundation, Inc.\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-#                                                        -*- Autoconf -*-\n-# Copyright (C) 2002, 2003  Free Software Foundation, Inc.\n-# Generated from amversion.in; do not edit by hand.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version=\"1.8\"])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION so it can be traced.\n-# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-\t [AM_AUTOMAKE_VERSION([1.8.5])])\n-\n-# AM_AUX_DIR_EXPAND\n-\n-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is `.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[dnl Rely on autoconf to set up CDPATH properly.\n-AC_PREREQ([2.50])dnl\n-# expand $ac_aux_dir to an absolute path\n-am_aux_dir=`cd $ac_aux_dir && pwd`\n-])\n-\n-# AM_CONDITIONAL                                              -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 2000, 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 6\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ(2.52)dnl\n- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])\n-AC_SUBST([$1_FALSE])\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.])\n-fi])])\n-\n-# serial 7\t\t\t\t\t\t-*- Autoconf -*-\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n-# Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-\n-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n-# written in clear, in which case automake, when reading aclocal.m4,\n-# will think it sees a *use*, and therefore will trigger all it's\n-# C support machinery.  Also note that it means that autoscan, seeing\n-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n-\n-\n-\n-# _AM_DEPENDENCIES(NAME)\n-# ----------------------\n-# See how the compiler implements dependency checking.\n-# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n-# We try a few techniques and use that to set a single cache variable.\n-#\n-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n-# dependency, and given that the user is not expected to run this macro,\n-# just rely on AC_PROG_CC.\n-AC_DEFUN([_AM_DEPENDENCIES],\n-[AC_REQUIRE([AM_SET_DEPDIR])dnl\n-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n-AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n-AC_REQUIRE([AM_DEP_TRACK])dnl\n-\n-ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n-       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n-       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n-       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n-                   [depcc=\"$$1\"   am_compiler_list=])\n-\n-AC_CACHE_CHECK([dependency style of $depcc],\n-               [am_cv_$1_dependencies_compiler_type],\n-[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named `D' -- because `-MD' means `put the output\n-  # in D'.\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_$1_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n-  fi\n-  for depmode in $am_compiler_list; do\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n-      # Solaris 8's {/usr,}/bin/sh.\n-      touch sub/conftst$i.h\n-    done\n-    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n-\n-    case $depmode in\n-    nosideeffect)\n-      # after this tag, mechanisms are not by side-effect, so they'll\n-      # only be used when explicitly requested\n-      if test \"x$enable_dependency_tracking\" = xyes; then\n-\tcontinue\n-      else\n-\tbreak\n-      fi\n-      ;;\n-    none) break ;;\n-    esac\n-    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle `-M -o', and we need to detect this.\n-    if depmode=$depmode \\\n-       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \\\n-         >/dev/null 2>conftest.err &&\n-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&\n-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_$1_dependencies_compiler_type=$depmode\n-        break\n-      fi\n-    fi\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_$1_dependencies_compiler_type=none\n-fi\n-])\n-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n-AM_CONDITIONAL([am__fastdep$1], [\n-  test \"x$enable_dependency_tracking\" != xno \\\n-  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n-])\n-\n-\n-# AM_SET_DEPDIR\n-# -------------\n-# Choose a directory name for dependency files.\n-# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n-AC_DEFUN([AM_SET_DEPDIR],\n-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n-])\n-\n-\n-# AM_DEP_TRACK\n-# ------------\n-AC_DEFUN([AM_DEP_TRACK],\n-[AC_ARG_ENABLE(dependency-tracking,\n-[  --disable-dependency-tracking  speeds up one-time build\n-  --enable-dependency-tracking   do not reject slow dependency extractors])\n-if test \"x$enable_dependency_tracking\" != xno; then\n-  am_depcomp=\"$ac_aux_dir/depcomp\"\n-  AMDEPBACKSLASH='\\'\n-fi\n-AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n-AC_SUBST([AMDEPBACKSLASH])\n-])\n-\n-# Generate code to set up dependency tracking.   -*- Autoconf -*-\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-#serial 2\n-\n-# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-# ------------------------------\n-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[for mf in $CONFIG_FILES; do\n-  # Strip MF so we end up with the name of the file.\n-  mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-  # Check whether this is an Automake generated Makefile or not.\n-  # We used to match only the files named `Makefile.in', but\n-  # some people rename them; so instead we look at the file content.\n-  # Grep'ing the first line is not enough: some people post-process\n-  # each Makefile.in and add a new line on top of each file to say so.\n-  # So let's grep whole file.\n-  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then\n-    dirpart=`AS_DIRNAME(\"$mf\")`\n-  else\n-    continue\n-  fi\n-  grep '^DEP_FILES *= *[[^ @%:@]]' < \"$mf\" > /dev/null || continue\n-  # Extract the definition of DEP_FILES from the Makefile without\n-  # running `make'.\n-  DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-  test -z \"$DEPDIR\" && continue\n-  # When using ansi2knr, U may be empty or an underscore; expand it\n-  U=`sed -n 's/^U = //p' < \"$mf\"`\n-  test -d \"$dirpart/$DEPDIR\" || mkdir \"$dirpart/$DEPDIR\"\n-  # We invoke sed twice because it is the simplest approach to\n-  # changing $(DEPDIR) to its actual value in the expansion.\n-  for file in `sed -n '\n-    /^DEP_FILES = .*\\\\\\\\$/ {\n-      s/^DEP_FILES = //\n-      :loop\n-\ts/\\\\\\\\$//\n-\tp\n-\tn\n-\t/\\\\\\\\$/ b loop\n-      p\n-    }\n-    /^DEP_FILES = / s/^DEP_FILES = //p' < \"$mf\" | \\\n-       sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n-    # Make sure the directory exists.\n-    test -f \"$dirpart/$file\" && continue\n-    fdir=`AS_DIRNAME([\"$file\"])`\n-    AS_MKDIR_P([$dirpart/$fdir])\n-    # echo \"creating $dirpart/$file\"\n-    echo '# dummy' > \"$dirpart/$file\"\n-  done\n-done\n-])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-\n-\n-# AM_OUTPUT_DEPENDENCY_COMMANDS\n-# -----------------------------\n-# This macro should only be invoked once -- use via AC_REQUIRE.\n-#\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each `.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[AC_CONFIG_COMMANDS([depfiles],\n-     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n-\n-# Do all the work for Automake.                            -*- Autoconf -*-\n-\n-# This macro actually does too much some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n-# Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 11\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.58])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-# test to see if srcdir already configured\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\" &&\n-   test -f $srcdir/config.status; then\n-  AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n- AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n-AM_MISSING_PROG(AUTOCONF, autoconf)\n-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n-AM_MISSING_PROG(AUTOHEADER, autoheader)\n-AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AM_MISSING_PROG(AMTAR, tar)\n-AM_PROG_INSTALL_SH\n-AM_PROG_INSTALL_STRIP\n-AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n-# We need awk for the \"check\" target.  The system \"awk\" is bad on\n-# some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-                  [_AM_DEPENDENCIES(CC)],\n-                  [define([AC_PROG_CC],\n-                          defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-                  [_AM_DEPENDENCIES(CXX)],\n-                  [define([AC_PROG_CXX],\n-                          defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n-])\n-])\n-\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $1 | $1:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $1\" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-\n-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-install_sh=${install_sh-\"$am_aux_dir/install-sh\"}\n-AC_SUBST(install_sh)])\n-\n-#                                                          -*- Autoconf -*-\n-# Copyright (C) 2003  Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 1\n-\n-# Check whether the underlying file-system supports filenames\n-# with a leading dot.  For instance MS-DOS doesn't.\n-AC_DEFUN([AM_SET_LEADING_DOT],\n-[rm -rf .tst 2>/dev/null\n-mkdir .tst 2>/dev/null\n-if test -d .tst; then\n-  am__leading_dot=.\n-else\n-  am__leading_dot=_\n-fi\n-rmdir .tst 2>/dev/null\n-AC_SUBST([am__leading_dot])])\n-\n-# Add --enable-maintainer-mode option to configure.\n-# From Jim Meyering\n-\n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004\n-# Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 3\n-\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode is disabled by default\n-  AC_ARG_ENABLE(maintainer-mode,\n-[  --enable-maintainer-mode  enable make rules and dependencies not useful\n-\t\t\t  (and sometimes confusing) to the casual installer],\n-      USE_MAINTAINER_MODE=$enableval,\n-      USE_MAINTAINER_MODE=no)\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL(MAINTAINER_MODE, [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST(MAINT)dnl\n-]\n-)\n-\n-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n-\n-# Check to see how 'make' treats includes.\t-*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 2\n-\n-# AM_MAKE_INCLUDE()\n-# -----------------\n-# Check to see how make treats includes.\n-AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n-am__doit:\n-\t@echo done\n-.PHONY: am__doit\n-END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n-am__include=\"#\"\n-am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# We grep out `Entering directory' and `Leaving directory'\n-# messages which can occur if `w' ends up in MAKEFLAGS.\n-# In particular we don't look at `^make:' because GNU make might\n-# be invoked under some other name (usually \"gmake\"), in which\n-# case it prints its new name instead of `make'.\n-if test \"`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`\" = \"done\"; then\n-   am__include=include\n-   am__quote=\n-   _am_result=GNU\n-fi\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   if test \"`$am_make -s -f confmf 2> /dev/null`\" = \"done\"; then\n-      am__include=.include\n-      am__quote=\"\\\"\"\n-      _am_result=BSD\n-   fi\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n-\n-#  -*- Autoconf -*-\n-\n-\n-# Copyright (C) 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 3\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it supports --run.\n-# If it does, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-test x\"${MISSING+set}\" = xset || MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --run true\"; then\n-  am_missing_run=\"$MISSING --run \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN([`missing' script is too old or missing])\n-fi\n-])\n-\n-# AM_PROG_MKDIR_P\n-# ---------------\n-# Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.\n-\n-# Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories\n-# created by `make install' are always world readable, even if the\n-# installer happens to have an overly restrictive umask (e.g. 077).\n-# This was a mistake.  There are at least two reasons why we must not\n-# use `-m 0755':\n-#   - it causes special bits like SGID to be ignored,\n-#   - it may be too restrictive (some setups expect 775 directories).\n-#\n-# Do not use -m 0755 and let people choose whatever they expect by\n-# setting umask.\n-#\n-# We cannot accept any implementation of `mkdir' that recognizes `-p'.\n-# Some implementations (such as Solaris 8's) are not thread-safe: if a\n-# parallel make tries to run `mkdir -p a/b' and `mkdir -p a/c'\n-# concurrently, both version can detect that a/ is missing, but only\n-# one can create it and the other will error out.  Consequently we\n-# restrict ourselves to GNU make (using the --version option ensures\n-# this.)\n-AC_DEFUN([AM_PROG_MKDIR_P],\n-[if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then\n-  # Keeping the `.' argument allows $(mkdir_p) to be used without\n-  # argument.  Indeed, we sometimes output rules like\n-  #   $(mkdir_p) $(somedir)\n-  # where $(somedir) is conditionally defined.\n-  # (`test -n '$(somedir)' && $(mkdir_p) $(somedir)' is a more\n-  # expensive solution, as it forces Make to start a sub-shell.)\n-  mkdir_p='mkdir -p -- .'\n-else\n-  # On NextStep and OpenStep, the `mkdir' command does not\n-  # recognize any option.  It will interpret all options as\n-  # directories to create, and then abort because `.' already\n-  # exists.\n-  for d in ./-p ./--version;\n-  do\n-    test -d $d && rmdir $d\n-  done\n-  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.\n-  if test -f \"$ac_aux_dir/mkinstalldirs\"; then\n-    mkdir_p='$(mkinstalldirs)'\n-  else\n-    mkdir_p='$(install_sh) -d'\n-  fi\n-fi\n-AC_SUBST([mkdir_p])])\n-\n-# Helper functions for option handling.                    -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003  Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 2\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# ------------------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ----------------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[AC_FOREACH([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-#\n-# Check to make sure that the build environment is sane.\n-#\n-\n-# Copyright (C) 1996, 1997, 2000, 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 3\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Just in case\n-sleep 1\n-echo timestamp > conftest.file\n-# Do `set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`\n-   if test \"$[*]\" = \"X\"; then\n-      # -L didn't work.\n-      set X `ls -t $srcdir/configure conftest.file`\n-   fi\n-   rm -f conftest.file\n-   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-      # If neither matched, then we have a broken ls.  This can happen\n-      # if, for instance, CONFIG_SHELL is bash and it inherits a\n-      # broken ls alias from the environment.  This has actually\n-      # happened.  Such a system could not be considered \"sane\".\n-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-alias in your environment])\n-   fi\n-\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT(yes)])\n-\n-# AM_PROG_INSTALL_STRIP\n-\n-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# One issue with vendor `install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in `make install-strip', and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using `strip' when the user\n-# run `make install-strip'.  However `strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the `STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\${SHELL} \\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-"}, {"sha": "5081afd06db3a5ba85f24af8344025cb4f0106ef", "filename": "libbanshee/config.h.in", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fconfig.h.in?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,112 +0,0 @@\n-/* config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define to 1 if you have the `atexit' function. */\n-#undef HAVE_ATEXIT\n-\n-/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n-#undef HAVE_DOPRNT\n-\n-/* Define to 1 if you have the `dup2' function. */\n-#undef HAVE_DUP2\n-\n-/* Define to 1 if you have the <fcntl.h> header file. */\n-#undef HAVE_FCNTL_H\n-\n-/* Define to 1 if you have the `floor' function. */\n-#undef HAVE_FLOOR\n-\n-/* Define to 1 if you have the `getpagesize' function. */\n-#undef HAVE_GETPAGESIZE\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#undef HAVE_INTTYPES_H\n-\n-/* Define to 1 if you have the <limits.h> header file. */\n-#undef HAVE_LIMITS_H\n-\n-/* Define to 1 if you have the <memory.h> header file. */\n-#undef HAVE_MEMORY_H\n-\n-/* Define to 1 if you have the `memset' function. */\n-#undef HAVE_MEMSET\n-\n-/* Define to 1 if you have a working `mmap' system call. */\n-#undef HAVE_MMAP\n-\n-/* Define to 1 if you have the `munmap' function. */\n-#undef HAVE_MUNMAP\n-\n-/* Define to 1 if stdbool.h conforms to C99. */\n-#undef HAVE_STDBOOL_H\n-\n-/* Define to 1 if you have the <stddef.h> header file. */\n-#undef HAVE_STDDEF_H\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#undef HAVE_STDINT_H\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#undef HAVE_STDLIB_H\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#undef HAVE_STRINGS_H\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#undef HAVE_STRING_H\n-\n-/* Define to 1 if you have the <sys/param.h> header file. */\n-#undef HAVE_SYS_PARAM_H\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#undef HAVE_SYS_STAT_H\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#undef HAVE_SYS_TYPES_H\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#undef HAVE_UNISTD_H\n-\n-/* Define to 1 if you have the `vprintf' function. */\n-#undef HAVE_VPRINTF\n-\n-/* Define to 1 if the system has the type `_Bool'. */\n-#undef HAVE__BOOL\n-\n-/* Name of package */\n-#undef PACKAGE\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#undef PACKAGE_BUGREPORT\n-\n-/* Define to the full name of this package. */\n-#undef PACKAGE_NAME\n-\n-/* Define to the full name and version of this package. */\n-#undef PACKAGE_STRING\n-\n-/* Define to the one symbol short name of this package. */\n-#undef PACKAGE_TARNAME\n-\n-/* Define to the version of this package. */\n-#undef PACKAGE_VERSION\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#undef STDC_HEADERS\n-\n-/* Version number of package */\n-#undef VERSION\n-\n-/* Define to empty if `const' does not conform to ANSI C. */\n-#undef const\n-\n-/* Define to `__inline__' or `__inline' if that's what the C compiler\n-   calls it, or to nothing if 'inline' is not supported under any name.  */\n-#ifndef __cplusplus\n-#undef inline\n-#endif\n-\n-/* Define to `int' if <sys/types.h> does not define. */\n-#undef pid_t\n-\n-/* Define to `unsigned' if <sys/types.h> does not define. */\n-#undef size_t"}, {"sha": "606be415ef67e0318d0f28b3cf9bdefd355052ee", "filename": "libbanshee/configure", "status": "removed", "additions": 0, "deletions": 6376, "changes": 6376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fconfigure?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "2a8792c9bdfe3948266b9fec1a93d7a1ada5ed88", "filename": "libbanshee/configure.ac", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fconfigure.ac?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,46 +0,0 @@\n-# Process this file with autoconf to produce a configure script.\n-AC_PREREQ(2.59)\n-AC_INIT(libbanshee,0.9,dberlin@dberlin.org)\n-AC_CONFIG_SRCDIR(engine/flowrow-sort.c)\n-AC_CONFIG_HEADERS(config.h)\n-AM_INIT_AUTOMAKE\n-\n-# Checks for programs.\n-AC_PROG_CC\n-AC_PROG_INSTALL\n-AC_PROG_RANLIB\n-# Checks for libraries.\n-# FIXME: Replace `main' with a function in `-llambda':\n-#AC_CHECK_LIB([lambda], [main])\n-# FIXME: Replace `main' with a function in `-lm':\n-#AC_CHECK_LIB([m], [main])\n-\n-\n-if test x$GCC = xyes; then\n-  ac_libbanshee_warn_cflags='-W -Wall -pedantic -Wwrite-strings  -Wstrict-prototypes -Wmissing-prototypes'\n-fi\n-AC_SUBST(ac_libbanshee_warn_cflags)\n-\n-AM_MAINTAINER_MODE\n-# Checks for header files.\n-AC_HEADER_STDC\n-AC_CHECK_HEADERS([fcntl.h limits.h stddef.h stdlib.h string.h sys/param.h unistd.h])\n-AC_HEADER_STDBOOL\n-\n-# Checks for typedefs, structures, and compiler characteristics.\n-AC_C_CONST\n-AC_C_INLINE\n-AC_TYPE_PID_T\n-AC_TYPE_SIZE_T\n-\n-# Checks for library functions.\n-AC_FUNC_MEMCMP\n-AC_FUNC_MMAP\n-AC_FUNC_VPRINTF\n-AC_CHECK_FUNCS([atexit dup2 floor getpagesize memset munmap])\n-\n-AC_CONFIG_FILES([Makefile\n-                 engine/Makefile\n-                 libcompat/Makefile\n-                 points-to/Makefile])\n-AC_OUTPUT"}, {"sha": "b65636ed5e74cdc17c04d29fec1d18b7a8486840", "filename": "libbanshee/engine/ChangeLog", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2FChangeLog?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,18 +0,0 @@\n-2004-05-28 Aaron W. LaFramboise <aaronraolete36@aaronwl.com>\n-\n-\t* engine/util.c (vfail): Remove unnecessary sync, fsync, and fflush.\n-\n-2003-07-01  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\t* bool.h: Can't include gcc's system.h and bool.h at the same time.\n-\n-2003-06-25  Daniel Berlin  <dberlin@dberlin.org>\n-\n-\t* compiler.h: Fix the grouping of the #if\n-\n-2003-02-02  Daniel Berlin  <dberlin@dberlin.org>\n-\t\n-\t* compiler.h: Only define HAVE_VARIADIC_MACROS if IN_GCC is not\n-\tdefined.\n-\t* util.h: Add prototypes for min and max.\n-"}, {"sha": "d3a8ba6d805009c7dcddb8737c5cb0a089c97f60", "filename": "libbanshee/engine/Makefile.am", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2FMakefile.am?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,6 +0,0 @@\n-AM_CFLAGS = -I$(srcdir)/../libcompat -I$(top_srcdir)/../include -I$(srcdir)/../include -I. -Ddeletes= -Dtraditional= -Dsameregion= -Dparentptr= @ac_libbanshee_warn_cflags@\n-noinst_LIBRARIES = libbansheeengine.a\n-libbansheeengine_a_SOURCES =  array.c bounds.c hash.c hashset.c list.c stamp.c \\\n-ufind.c util.c setif-sort.c termhash.c setif-var.c flow-var.c flowrow-sort.c \\\n-setst-var.c jcollection.c banshee.c buffer.c setst-sort.c term-var.c \\\n-term-sort.c  dot.c "}, {"sha": "341f6e8508ae1740cc1e99c21d2c60fb940f38af", "filename": "libbanshee/engine/Makefile.in", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2FMakefile.in?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,418 +0,0 @@\n-# Makefile.in generated by automake 1.8.5 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-SOURCES = $(libbansheeengine_a_SOURCES)\n-\n-srcdir = @srcdir@\n-top_srcdir = @top_srcdir@\n-VPATH = @srcdir@\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-top_builddir = ..\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-INSTALL = @INSTALL@\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-subdir = engine\n-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in ChangeLog\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = $(top_builddir)/config.h\n-CONFIG_CLEAN_FILES =\n-LIBRARIES = $(noinst_LIBRARIES)\n-AR = ar\n-ARFLAGS = cru\n-libbansheeengine_a_AR = $(AR) $(ARFLAGS)\n-libbansheeengine_a_LIBADD =\n-am_libbansheeengine_a_OBJECTS = array.$(OBJEXT) bounds.$(OBJEXT) \\\n-\thash.$(OBJEXT) hashset.$(OBJEXT) list.$(OBJEXT) \\\n-\tstamp.$(OBJEXT) ufind.$(OBJEXT) util.$(OBJEXT) \\\n-\tsetif-sort.$(OBJEXT) termhash.$(OBJEXT) setif-var.$(OBJEXT) \\\n-\tflow-var.$(OBJEXT) flowrow-sort.$(OBJEXT) setst-var.$(OBJEXT) \\\n-\tjcollection.$(OBJEXT) banshee.$(OBJEXT) buffer.$(OBJEXT) \\\n-\tsetst-sort.$(OBJEXT) term-var.$(OBJEXT) term-sort.$(OBJEXT) \\\n-\tdot.$(OBJEXT)\n-libbansheeengine_a_OBJECTS = $(am_libbansheeengine_a_OBJECTS)\n-DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)\n-depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n-@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/array.Po ./$(DEPDIR)/banshee.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/bounds.Po ./$(DEPDIR)/buffer.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/dot.Po ./$(DEPDIR)/flow-var.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/flowrow-sort.Po ./$(DEPDIR)/hash.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/hashset.Po ./$(DEPDIR)/jcollection.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/list.Po ./$(DEPDIR)/setif-sort.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/setif-var.Po ./$(DEPDIR)/setst-sort.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/setst-var.Po ./$(DEPDIR)/stamp.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/term-sort.Po ./$(DEPDIR)/term-var.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/termhash.Po ./$(DEPDIR)/ufind.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/util.Po\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n-SOURCES = $(libbansheeengine_a_SOURCES)\n-DIST_SOURCES = $(libbansheeengine_a_SOURCES)\n-ETAGS = etags\n-CTAGS = ctags\n-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n-ACLOCAL = @ACLOCAL@\n-AMDEP_FALSE = @AMDEP_FALSE@\n-AMDEP_TRUE = @AMDEP_TRUE@\n-AMTAR = @AMTAR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@\n-MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n-MAKEINFO = @MAKEINFO@\n-OBJEXT = @OBJEXT@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_RANLIB = @ac_ct_RANLIB@\n-ac_ct_STRIP = @ac_ct_STRIP@\n-ac_libbanshee_warn_cflags = @ac_libbanshee_warn_cflags@\n-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@\n-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-bindir = @bindir@\n-build_alias = @build_alias@\n-datadir = @datadir@\n-exec_prefix = @exec_prefix@\n-host_alias = @host_alias@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-oldincludedir = @oldincludedir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-sysconfdir = @sysconfdir@\n-target_alias = @target_alias@\n-AM_CFLAGS = -I$(srcdir)/../libcompat -I$(top_srcdir)/../include -I$(srcdir)/../include -I. -Ddeletes= -Dtraditional= -Dsameregion= -Dparentptr= @ac_libbanshee_warn_cflags@\n-noinst_LIBRARIES = libbansheeengine.a\n-libbansheeengine_a_SOURCES = array.c bounds.c hash.c hashset.c list.c stamp.c \\\n-ufind.c util.c setif-sort.c termhash.c setif-var.c flow-var.c flowrow-sort.c \\\n-setst-var.c jcollection.c banshee.c buffer.c setst-sort.c term-var.c \\\n-term-sort.c  dot.c \n-\n-all: all-am\n-\n-.SUFFIXES:\n-.SUFFIXES: .c .o .obj\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  engine/Makefile'; \\\n-\tcd $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --gnu  engine/Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-\n-clean-noinstLIBRARIES:\n-\t-test -z \"$(noinst_LIBRARIES)\" || rm -f $(noinst_LIBRARIES)\n-libbansheeengine.a: $(libbansheeengine_a_OBJECTS) $(libbansheeengine_a_DEPENDENCIES) \n-\t-rm -f libbansheeengine.a\n-\t$(libbansheeengine_a_AR) libbansheeengine.a $(libbansheeengine_a_OBJECTS) $(libbansheeengine_a_LIBADD)\n-\t$(RANLIB) libbansheeengine.a\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/array.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/banshee.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bounds.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/buffer.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dot.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flow-var.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flowrow-sort.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hash.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hashset.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jcollection.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/list.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/setif-sort.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/setif-var.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/setst-sort.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/setst-var.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stamp.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/term-sort.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/term-var.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/termhash.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ufind.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util.Po@am__quote@\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\tif $(COMPILE) -MT $@ -MD -MP -MF \"$(DEPDIR)/$*.Tpo\" -c -o $@ $<; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/$*.Tpo\" \"$(DEPDIR)/$*.Po\"; else rm -f \"$(DEPDIR)/$*.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tdepfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\tif $(COMPILE) -MT $@ -MD -MP -MF \"$(DEPDIR)/$*.Tpo\" -c -o $@ `$(CYGPATH_W) '$<'`; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/$*.Tpo\" \"$(DEPDIR)/$*.Po\"; else rm -f \"$(DEPDIR)/$*.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tdepfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n-uninstall-info-am:\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\ttags=; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\tif test -z \"$(ETAGS_ARGS)$$tags$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t    $$tags $$unique; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\ttags=; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$tags$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$tags $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && cd $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) $$here\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\n-distdir: $(DISTFILES)\n-\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n-\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's|.|.|g'`; \\\n-\tlist='$(DISTFILES)'; for file in $$list; do \\\n-\t  case $$file in \\\n-\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-\t    $(top_srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$topsrcdirstrip/|$(top_builddir)/|\"`;; \\\n-\t  esac; \\\n-\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n-\t  dir=`echo \"$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n-\t  if test \"$$dir\" != \"$$file\" && test \"$$dir\" != \".\"; then \\\n-\t    dir=\"/$$dir\"; \\\n-\t    $(mkdir_p) \"$(distdir)$$dir\"; \\\n-\t  else \\\n-\t    dir=''; \\\n-\t  fi; \\\n-\t  if test -d $$d/$$file; then \\\n-\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n-\t      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \\\n-\t    fi; \\\n-\t    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \\\n-\t  else \\\n-\t    test -f $(distdir)/$$file \\\n-\t    || cp -p $$d/$$file $(distdir)/$$file \\\n-\t    || exit 1; \\\n-\t  fi; \\\n-\tdone\n-check-am: all-am\n-check: check-am\n-all-am: Makefile $(LIBRARIES)\n-installdirs:\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-rm -f $(CONFIG_CLEAN_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am\n-\n-distclean: distclean-am\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-tags\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am:\n-\n-install-exec-am:\n-\n-install-info: install-info-am\n-\n-install-man:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am: uninstall-info-am\n-\n-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n-\tclean-noinstLIBRARIES ctags distclean distclean-compile \\\n-\tdistclean-generic distclean-tags distdir dvi dvi-am html \\\n-\thtml-am info info-am install install-am install-data \\\n-\tinstall-data-am install-exec install-exec-am install-info \\\n-\tinstall-info-am install-man install-strip installcheck \\\n-\tinstallcheck-am installdirs maintainer-clean \\\n-\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n-\tmostlyclean-generic pdf pdf-am ps ps-am tags uninstall \\\n-\tuninstall-am uninstall-info-am\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "be297533fa61cf90d973d30ebc0f8f0a7cb5b385", "filename": "libbanshee/engine/array.c", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Farray.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,96 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <regions.h>\n-#include <assert.h>\n-#include <limits.h>\n-#include \"array.h\"\n-\n-struct array {\n-  region sameregion r;\n-  void *sameregion data;\n-  size_t elemsize;\n-  type_t elemtype;\n-  size_t nelems, nalloc;\n-};\n-\n-struct array *new_array(region r, size_t initialsize,\n-\t\t\tsize_t typesize, type_t typeinfo)\n-{\n-  struct array *a = ralloc(r, struct array);\n-\n-  a->r = r;\n-  a->data = typed_rarrayalloc(r, initialsize, typesize, typeinfo);\n-  a->elemsize = typesize;\n-  a->elemtype = typeinfo;\n-  a->nelems = 0;\n-  a->nalloc = initialsize;\n-\n-  return a;\n-}\n-\n-void *array_extend(struct array *a, int by)\n-{\n-  size_t oldelems = a->nelems;\n-\n-  if (by < 0)\n-    assert(((unsigned int)-by) <= a->nelems && by != INT_MIN);\n-  else if (a->nelems + by > a->nalloc)\n-    {\n-      size_t newsize = a->nalloc * 2 + by;\n-      void *newdata = typed_rarrayalloc(a->r, newsize, a->elemsize, a->elemtype);\n-\n-      /* XXX: could work harder to support really large array sizes\n-\t (this code will fail for a->nalloc >= (max(size_t)-by)/2) */\n-      assert(newsize > a->nalloc); /* die when we get really big */\n-      typed_rarraycopy(newdata, a->data, a->nelems, a->elemsize, a->elemtype);\n-      a->data = newdata;\n-      a->nalloc = newsize;\n-    }\n-  a->nelems += by;\n-\n-  return (char *)a->data + a->elemsize * oldelems;\n-}\n-\n-void array_reset(struct array *a)\n-{\n-  a->nelems = 0;\n-}\n-\n-size_t array_length(struct array *a)\n-{\n-  return a->nelems;\n-}\n-\n-void *array_data(struct array *a)\n-{\n-  return a->data;\n-}\n-"}, {"sha": "6fe3a6cf17d2fc6f4f1324bec784f5646a304a45", "filename": "libbanshee/engine/array.h", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Farray.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,76 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef ARRAY_H\n-#define ARRAY_H\n-\n-/* A region-based growable array type */\n-\n-struct array;\n-\n-struct array *new_array(region r, size_t initialsize,\n-\t\t\tsize_t typesize, type_t typeinfo);\n-void *array_extend(struct array *a, int by);\n-void array_reset(struct array *a);\n-size_t array_length(struct array *a);\n-void *array_data(struct array *a);\n-\n-\n-#define DECLARE_ARRAY(name, type) \\\n-typedef struct name ## _a *name; \\\n-name new_ ## name(region r, size_t initialsize); \\\n-type *name ## _extend(name a, int by); \\\n-void name ## _reset(name a); \\\n-size_t name ## _length(name a); \\\n-type *name ## _data(name a);\n-\n-#define DEFINE_ARRAY(name, type) \\\n-name new_ ## name(region r, size_t initialsize) \\\n-{ \\\n-  return (name)new_array(r, initialsize, sizeof(type), rctypeof(type)); \\\n-} \\\n-type *name ## _extend(name a, int by) \\\n-{ \\\n-  return array_extend((struct array *)a, by); \\\n-} \\\n-void name ## _reset(name a) \\\n-{ \\\n-  return array_reset((struct array *)a); \\\n-} \\\n-size_t name ## _length(name a) \\\n-{ \\\n-  return array_length((struct array *)a); \\\n-} \\\n-type *name ## _data(name a) \\\n-{ \\\n-  return array_data((struct array *)a); \\\n-}\n-\n-#endif"}, {"sha": "54b975afd9c34fc84d2c0286cee7c29eeac67b9b", "filename": "libbanshee/engine/banshee.c", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbanshee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbanshee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fbanshee.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,67 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdio.h>\n-#include <regions.h>\n-#include \"banshee.h\"\n-#include \"setif-sort.h\"\n-#include \"setst-sort.h\"\n-#include \"flowrow-sort.h\"\n-#include \"setif-var.h\"\n-\n-DEFINE_LIST(gen_e_list,gen_e)\n-\n-void engine_init(void)\n-{\n-  region_init(); \n-  stamp_init();\n-}\n-\n-void engine_reset(void) deletes\n-{\n-  stamp_reset();\n-}\n-\n-/* TODO */\n-void engine_update(void)\n-{\n-}\n-\n-void engine_stats(FILE *f)\n-{\n-  setif_print_stats(f);\n-  setst_print_stats(f);\n-  flowrow_print_stats(f);\n-}\n-\n-void print_constraint_graphs(FILE *f)\n-{\n-  setif_print_constraint_graph(f);\n-}"}, {"sha": "f9b647d02a75f40f7de96dc712455c4d80989644", "filename": "libbanshee/engine/banshee.h", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbanshee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbanshee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fbanshee.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,105 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef BANSHEE_H\n-#define BANSHEE_H\n-\n-#include <stdio.h>\n-#include \"linkage.h\"\n-#include \"stamp.h\"\n-#include \"list.h\"\n-#include \"util.h\"\n-#include \"dot.h\"\n-\n-#define ALIAS_TYPE -2\n-#define VAR_TYPE -1\n-#define ZERO_TYPE 0\n-#define ONE_TYPE 1\n-#define UNION_TYPE 2\n-#define INTER_TYPE 3\n-#define CONSTANT_TYPE 4\n-\n-EXTERN_C_BEGIN\n-\n-\n-#ifdef NONSPEC\n-\n-typedef enum sort_kind\n-{\n-  flowrow_sort, \n-  setif_sort,\n-  setst_sort,\n-  flowterm_sort,\n-  term_sort\n-} sort_kind;\n-\n-typedef struct gen_e\n-{\n-  sort_kind sort;\n-} *gen_e;\n-#else\n-typedef void *gen_e;\n-#endif\n-\n-DECLARE_LIST(gen_e_list,gen_e)\n-\n- typedef void (*gen_e_pr_fn_ptr) (FILE *, gen_e);\n-\n-/* \n-  Function pointers that are common to all sorts\n-*/\n-\n-/* inclusion */\n-typedef void (*incl_fn_ptr) (gen_e, gen_e) deletes;   \n-\n-/* match constructed terms */  \n-typedef void (*con_match_fn_ptr) (gen_e, gen_e) deletes;\n-\n-/* make fresh variables */\n-typedef gen_e (*fresh_fn_ptr) (const char *);\n-typedef gen_e (*fresh_small_fn_ptr) (const char *);\n-typedef gen_e (*fresh_large_fn_ptr) (const char *);     \n-\n-/* get a stamp */\n-typedef stamp (*get_stamp_fn_ptr) (gen_e);\n-\n-/* extract a term from a proj pat */\n-typedef gen_e (*get_proj_fn_ptr) (gen_e_list);\n-\n-void engine_init(void);\n-void engine_reset(void) deletes;\n-void engine_update(void);\n-void engine_stats(FILE *f);\n-\n-void print_constraint_graphs(FILE *f);\n-\n-EXTERN_C_END\n-\n-#endif /* BANSHEE_H */"}, {"sha": "87638fc2dc6d5eba0bc450b19f07773c5fe49ca5", "filename": "libbanshee/engine/bool.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fbool.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,63 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef BOOL_H\n-#define BOOL_H\n-#ifndef GCC_SYSTEM_H\n-#include \"config.h\"\n-/* 1 if we have _Bool.  */\n-#ifndef HAVE__BOOL\n-# define HAVE__BOOL \\\n-   ((GCC_VERSION >= 3000) || (__STDC_VERSION__ >= 199901L))\n-#endif\n-/* Provide some sort of boolean type.  We use stdbool.h if it's\n-  available.  This must be after all inclusion of system headers,\n-  as some of them will mess us up.  */\n-#undef bool\n-#undef true\n-#undef false\n-#undef TRUE\n-#undef FALSE\n-\n-#ifdef HAVE_STDBOOL_H\n-# include <stdbool.h>\n-#else\n-# if !HAVE__BOOL\n-typedef char _Bool;\n-# endif\n-# define bool _Bool\n-# define true 1\n-# define false 0\n-#endif\n-\n-#define TRUE true\n-#define FALSE false\n-#endif\n-#endif"}, {"sha": "9b14b75b4d950970851c18288311b42d24548c81", "filename": "libbanshee/engine/bounds.c", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fbounds.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,89 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdlib.h>\n-#include <assert.h>\n-#include \"bounds.h\"\n-\n-struct bounds\n-{\n-  hash_set set;\n-  gen_e_list elems;\n-};\n-\n-bounds bounds_create(region r)\n-{\n-  bounds result;\n-  \n-  result = ralloc(r, struct bounds);\n-  result->set = hs_create(r);\n-  result->elems = new_gen_e_list(r);\n-\n-  return result;\n-}\n-\n-gen_e_list bounds_exprs(bounds b)\n-{\n-  return b->elems;\n-}\n-\n-bool bounds_add(bounds b, gen_e e, stamp s)\n-{\n-  if (hs_member(b->set, s))\t\n-    return TRUE;\n-  \n-  else\n-    {\n-      gen_e_list_cons(e,b->elems);\n-      return FALSE;\n-    }\n-}\n-\n-bool bounds_empty(bounds b)\n-{\n-  return (gen_e_list_empty(b->elems));\n-}\n-\n-bool bounds_query(bounds b, stamp x)\n-{\n-  return (hs_query(b->set, x));\n-}\n-\n-void bounds_set(bounds b,gen_e_list l)\n-{\n-  b->elems = l;\n-}\n-\n-void bounds_delete(bounds b)\n-{\n-  hs_delete(b->set);\n-}\n-\n-"}, {"sha": "8b52247b36232652cbd8e375f6e6d1f820389fe6", "filename": "libbanshee/engine/bounds.h", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fbounds.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,56 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef BOUNDS_H\n-#define BOUNDS_H\n-\n-#include \"linkage.h\"\n-#include \"banshee.h\"\n-#include \"stamp.h\"\n-#include \"hashset.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct bounds *bounds;\n-\n-bounds bounds_create(region r);\n-\n-gen_e_list bounds_exprs(bounds);\n-\n-/* returns true if the bound was already present */\n-bool bounds_add(bounds,gen_e,stamp);\n-bool bounds_query(bounds,stamp); \n-bool bounds_empty(bounds);\n-void bounds_delete(bounds);  \n-void bounds_set(bounds,gen_e_list);\n-\n-EXTERN_C_END\n-\n-#endif /* BOUNDS_H */"}, {"sha": "68f062d365c379ef3c8efd66109a902ec18df749", "filename": "libbanshee/engine/buffer.c", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fbuffer.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,129 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <assert.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include \"buffer.h\"\n-\n-/* Invariant: buffer always null-terminated */\n-struct growbuf\n-{\n-  region r;\n-  unsigned int maxsize, cursize;\n-  char *buffer;\n-};\n-\n-/* Make a new buffer with initial size */\n-growbuf growbuf_new(region r, int size)\n-{\n-  growbuf b = ralloc(r, struct growbuf);\n-\n-  assert(size > 0);\n-  b->r = r;\n-  b->maxsize = size; /* Force some growth! */\n-  b->cursize = 1;\n-  b->buffer = rstralloc(r, size);\n-  b->buffer[0] = '\\0';\n-  return b;\n-}\n-\n-/* Empty a buffer */\n-void growbuf_reset(growbuf b)\n-{\n-  assert(b->maxsize > 0);\n-  b->cursize = 1;\n-  b->buffer[0] = '\\0';\n-}\n-\n-/* Print to a buffer */\n-int gprintf(growbuf b, const char *fmt, ...)\n-{\n-  va_list args;\n-  va_start(args, fmt);\n-  return gvprintf(b, fmt, args);\n-}\n-\n-/* Print to a buffer */\n-int gvprintf(growbuf b, const char *fmt, va_list args)\n-{\n-  int nchars;\n-\n-  if (!fmt) /* Bug (?)/feature of vnsprintf -- printing \\0 returns -1,\n-\t       goes into infinite loop. */\n-    return 0;\n-  while (1)\n-    {\n-      char *bufStart;\n-      int sizeLeft;\n-\n-      bufStart = b->buffer + b->cursize - 1; /* chop trailing \\0 */\n-      sizeLeft = b->maxsize - b->cursize + 1; /* +1 size we're chooping\n-\t\t\t\t\t\t the trailing \\0 */\n-      assert(*bufStart == '\\0');\n-      nchars = vsnprintf(bufStart, sizeLeft, fmt, args);\n-      if (nchars > -1 && nchars < sizeLeft)\n-\t{\n-\t  b->cursize += nchars; /* nchars doesn't include \\0,\n-\t\t\t\t   but we overwrote our \\0 */\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  /* How much room do we need?  In the new glibc, nchars\n-\t     tells us how much (not including the trailing null).\n-\t     So we need the current size, -1 since we'll remove the null,\n-\t     plus the new size, plus 1 for the new null. */\n-\t  int newSize = (nchars > -1) ? b->cursize - 1 + nchars + 1\n-\t                              : b->maxsize * 2;\n-\t  char *newBuf;\n-\n-\t  /* fprintf(stderr, \"Reallocating buffer, newSize=%d\\n\", newSize); */\n-\t  newBuf = rstralloc(b->r, newSize);\n-\t  memcpy(newBuf, b->buffer, b->cursize);\n-\t  newBuf[b->cursize-1] = '\\0';  /* vsnprintf has printed something! */\n-\t  b->buffer = newBuf;\n-\t  b->maxsize = newSize;\n-\t  /* b->cursize unchanged */\n-\t}\n-    }\n-  return nchars;\n-}\n-\n-/* Get the contents of a buffer */\n-char *growbuf_contents(growbuf b)\n-{\n-  return b->buffer;\n-}\n-\n-bool growbuf_empty(growbuf b)\n-{\n-  return b->cursize == 1; /* Buffer always null terminated */\n-}"}, {"sha": "c270ade32c367d73f63857b04955a24dbccebe4d", "filename": "libbanshee/engine/buffer.h", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fbuffer.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,58 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef BUFFER_H\n-#define BUFFER_H\n-\n-/*\n- * Growable buffers\n- *\n- * Always null terminated.\n- */\n-\n-#include <stdarg.h>\n-#include \"bool.h\"\n-#include \"regions.h\"\n-#include \"linkage.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct growbuf *growbuf;\n-\n-growbuf growbuf_new(region, int);   /* Make a new buffer with initial size */\n-void growbuf_reset(growbuf);        /* Empty a buffer */\n-int gprintf(growbuf, const char *, ...);      /* Print to a buffer */\n-int gvprintf(growbuf, const char *, va_list); /* Print to a buffer */\n-char *growbuf_contents(growbuf);    /* Get the contents of a buffer */\n-bool growbuf_empty(growbuf);        /* Return true iff buffer is empty */\n-\n-EXTERN_C_END\n-\n-#endif"}, {"sha": "6c90a63d26c0126620b3e6676229522bc38d6af9", "filename": "libbanshee/engine/compiler.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fcompiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fcompiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fcompiler.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,48 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef COMPILER_H\n-#define COMPILER_H\n-\n-# if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n-#  define HAVE_C99\n-# endif\n-\n-# if 0\n-/*(defined(__GNUC__) || defined(HAVE_C99)) && !defined (IN_GCC) */\n-#  define HAVE_VARIADIC_MACROS\n-# endif\n-\n-\n-# if !defined(__GNUC__) && !defined(__attribute__)\n-#  define __attribute__(attributes)\n-# endif\n-\n-#endif /* !COMPILER_H */"}, {"sha": "73c772fee53c250e64dba84ea47f04a8cab69a0d", "filename": "libbanshee/engine/dot.c", "status": "removed", "additions": 0, "deletions": 362, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fdot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fdot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fdot.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,362 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <assert.h>\n-#include <regions.h>\n-#include \"dot.h\"\n-#include \"hash.h\"\n-\n-static FILE *of;\n-static hash_table node_hash_table;\n-static region dot_region;\n-static int node_count;\n-static const char *edge_op;\n-\n-static void print_n_attrs(node_attr *attrs, int n)\n-{\n-  int i;\n-  fputc('[',of);\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      const char *name;\n-      switch (attrs[i].name)\n-\t{ \n-\tcase n_color:\n-\t  name = \"color\";\n-\t  break;\n-\tcase n_fontcolor:\n-\t  name = \"fontcolor\";\n-\t  break;\n-\tcase n_fontname:\n-\t  name = \"fontname\";\n-\t  break;\n-\tcase n_fontsize:\n-\t  name = \"fontsize\";\n-\t  break;\n-\tcase n_height:\n-\t  name = \"height\";\n-\t  break;\n-\tcase n_width:\n-\t  name = \"width\";\n-\t  break;\n-\tcase n_label:\n-\t  name = \"label\";\n-\t  break;\n-\tcase n_layer:\n-\t  name = \"layer\";\n-\t  break;\n-\tcase n_shape:\n-\t  name = \"shape\";\n-\t  break;\n-\tcase n_shapefile:\n-\t  name = \"shapefile\";\n-\t  break;\n-\tcase n_style:\n-\t  name = \"style\";\n-\t  break;\n-\tdefault:\n-\t  name = \"\";\n-\t  assert(0);\n-\t  break;\n-\t}\n-      if (i > 0)\n-\tfputc(',',of);\n-      fprintf(of,\"%s = %s\",name,attrs[i].value);\n-    }\n-\n-  fputc(']',of);\n-}\n-\n-static void print_e_attrs(edge_attr *attrs, int n)\n-{\n-  int i;\n-  fputc('[',of);\n-  for (i = 0; i < n; i++)\n-    {\n-      const char *name;\n-      switch(attrs[i].name)\n-\t{\n-\tcase e_color:\n-\t  name = \"color\";\n-\t  break;\n-\tcase e_decorate:\n-\t  name = \"decorate\";\n-\t  break;\n-\tcase e_dir:\n-\t  name = \"dir\";\n-\t  break;\n-\tcase e_fontcolor:\n-\t  name = \"fontcolor\";\n-\t  break;\n-\tcase e_fontname:\n-\t  name = \"fontname\";\n-\t  break;\n-\tcase e_fontsize:\n-\t  name = \"fontsize\";\n-\t  break;\n-\tcase e_id:\n-\t  name = \"id\";\n-\t  break;\n-\tcase e_label:\n-\t  name = \"label\";\n-\t  break;\n-\tcase e_layer:\n-\t  name = \"layer\";\n-\t  break;\n-\tcase e_minlen:\n-\t  name = \"minlen\";\n-\t  break;\n-\tcase e_style:\n-\t  name = \"style\";\n-\t  break;\n-\tcase e_weight:\n-\t  name = \"weight\";\n-\t  break;\n-\tdefault : \n-\t  name = \"\";\n-\t  assert(0);\n-\t  break;\n-\t}\n-      if (i > 0)\n-\tfputc(',',of);\n-      fprintf(of,\"%s = %s\",name,attrs[i].value);\n-    }\n-  fputc(']',of);\n-}\n-\n-static void print_g_attrs(graph_attr *attrs, int n)\n-{\n- int i;\n-  fputc('[',of);\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      const char *name;\n-      switch (attrs[i].name)\n-\t{ \n-\tcase g_center:\n-\t  name = \"center\";\n-\t  break;\n-\tcase g_clusterrank:\n-\t  name = \"clusterrank\";\n-\t  break;\n-\tcase g_color:\n-\t  name = \"color\";\n-\t  break;\n-\tcase g_concentrate:\n-\t  name = \"concentrate\";\n-\t  break;\n-\tcase g_fontcolor:\n-\t  name = \"fontcolor\";\n-\t  break;\n-\tcase g_fontname:\n-\t  name = \"fontname\";\n-\t  break;\n-\tcase g_fontsize:\n-\t  name = \"fontsize\";\n-\t  break;\n-\tcase g_label:\n-\t  name = \"label\";\n-\t  break;\n-\tcase g_layerseq:\n-\t  name = \"layerseq\";\n-\t  break;\n-\tcase g_margin:\n-\t  name = \"margin\";\n-\t  break;\n-\tcase g_mclimit:\n-\t  name = \"mclimit\";\n-\t  break;\n-\tcase g_nodesep:\n-\t  name = \"nodesep\";\n-\t  break;\n-\tcase g_nslimit:\n-\t  name = \"nslimit\";\n-\t  break;\n-\tcase g_ordering:\n-\t  name = \"ordering\";\n-\t  break;\n-\tcase g_orientation:\n-\t  name = \"orientation\";\n-\t  break;\n-\tcase g_page:\n-\t  name = \"page\";\n-\t  break;\n-\tcase g_rank:\n-\t  name = \"rank\";\n-\t  break;\n-\tcase g_rankdir:\n-\t  name = \"rankdir\";\n-\t  break;\n-\tcase g_ranksep:\n-\t  name = \"ranksep\";\n-\t  break;\n-\tcase g_ratio:\n-\t  name = \"ratio\";\n-\t  break;\n-\tcase g_size:\n-\t  name = \"size\";\n-\t  break;\n-\tdefault : \n-\t  name = \"\";\n-\t  assert(0);\n-\t  break;\n-\t}\n-      if (i > 0)\n-\tfputc(',',of);\n-      fprintf(of,\"%s = %s\",name,attrs[i].value);\n-    }\n-  fputc(']',of);\n-}\n-\n-\n-void dot_start(FILE *to,const char *name,bool is_directed,bool is_strict)\n-{\n-  const char *graph_type,*strict;\n-\n-\n-  node_count = 0;\n-  dot_region = newregion();\n-  node_hash_table = make_string_hash_table(dot_region,8,TRUE);\n-  of = to;\n-\n-  if (is_directed)\n-    {\n-      edge_op = \"->\";\n-      graph_type = \"digraph\";\n-    }\n-  else\n-    {\n-      edge_op = \"--\";\n-      graph_type = \"graph\";\n-    }\n-\n-  if (is_strict)\n-    strict = \"strict\";\n-  else\n-    strict = \"\";\n-\n-  fprintf(of,\"%s %s %s{\\n\",strict,graph_type,name);  \n-  \n-}\n-\n-void dot_global_graph_style(graph_attr *attrs, int n)\n-{\n-  fputs(\"graph \",of);\n-  print_g_attrs(attrs,n);\n-  fputc(';',of);\n-  fputc('\\n',of);\n-}\n-\n-void dot_global_edge_style(edge_attr *attrs, int n)\n-{\n-  fputs(\"edge \",of);\n-  print_e_attrs(attrs,n);\n-  fputc(';',of);\n-  fputc('\\n',of);\n-}\n-\n-void dot_global_node_style(node_attr *attrs, int n)\n-{\n-  fputs(\"node \",of);\n-  print_n_attrs(attrs,n);\n-  fputc(';',of);\n-  fputc('\\n',of);\n-}\n-\n-/* by default, set the node's name to label */\n-static void declare_node(dot_node n, char *label)\n-{\n-  int i;\n-  char mangled[512];\n-\n-  if (label[0] == '\\\"')\n-    mangled[0] = 's';\n-  else\n-    mangled[0] = label[0];\n-\n-  for (i = 1; label[i] && i < 512 ;i++)\n-    {\n-      if (label[i] == '\\\"')\n-\tmangled[i] = '_';\n-      else mangled[i] = label[i];\n-    }\n-  mangled[i] = '\\0';\n-  \n-  fprintf(of,\"nd_%d [label=\\\"%s\\\"]\\n\",n,mangled);\n-}\n-\n-dot_node dot_get_node(char *label) deletes\n-{\n-  dot_node result;\n-  if (!hash_table_lookup(node_hash_table,(hash_key)label,(hash_data *)(char *)&result))\n-    {\n-      dot_node newnode = node_count++;\n-      \n-      declare_node(newnode,label);\n-      hash_table_insert(node_hash_table,\n-\t\t\t(hash_key)rstrdup(dot_region,label),\n-\t\t\t(hash_data)newnode);\n-      \n-      return newnode;\n-    }\n-  else\n-    return result;\n-  \n-}\n-\n-void dot_node_style(dot_node node,node_attr *attrs, int n)\n-{\n-  fprintf(of,\"nd_%d \",node);\n-  print_n_attrs(attrs,n);\n-  fputc(';',of);\n-  fputc('\\n',of);\n-}\n-\n-void dot_plain_edge(dot_node from, dot_node to)\n-{\n-  fprintf(of,\"nd_%d %s nd_%d;\\n\",from,edge_op,to);\n-}\n-\n-void dot_styled_edge(dot_node from, dot_node to, edge_attr *attrs, int n)\n-{\n-  fprintf(of,\"nd_%d %s nd_%d \",from,edge_op,to);\n-  print_e_attrs(attrs,n);\n-  fputc(';',of);\n-  fputc('\\n',of);\n-}\n-\n-void dot_end(void) deletes\n-{\n-  fputc('}',of);\n-  hash_table_delete(node_hash_table);\n-  deleteregion_ptr(&dot_region);\n-}"}, {"sha": "7e221e6814578ba50e4d3beed8c0ed19f8e66e31", "filename": "libbanshee/engine/dot.h", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fdot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fdot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fdot.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,126 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef DOT_H\n-#define DOT_H\n-\n-#include <stdio.h>\n-#include \"linkage.h\"\n-#include \"bool.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef int dot_node;\n-\n-typedef struct\n-{\n-  enum n_attrs\n-  {\n-    n_color,\n-    n_fontcolor,\n-    n_fontname,\n-    n_fontsize,\n-    n_height,\n-    n_width,\n-    n_label,\n-    n_layer,\n-    n_shape,\n-    n_shapefile,\n-    n_style\n-  } name;\n-  const char *value;\n-} node_attr;\n-\n-typedef struct\n-{\n-  enum e_attrs\n-  {\n-    e_color,\n-    e_decorate,\n-    e_dir,\n-    e_fontcolor,\n-    e_fontname,\n-    e_fontsize,\n-    e_id,\n-    e_label,\n-    e_layer,\n-    e_minlen,\n-    e_style,\n-    e_weight\n-  } name;\n-  const char *value;\n-} edge_attr;\n-\n-typedef struct\n-{\n-  enum g_attrs\n-  {\n-    g_center,\n-    g_clusterrank,\n-    g_color,\n-    g_concentrate,\n-    g_fontcolor,\n-    g_fontname,\n-    g_fontsize,\n-    g_label,\n-    g_layerseq,\n-    g_margin,\n-    g_mclimit,\n-    g_nodesep,\n-    g_nslimit,\n-    g_ordering,\n-    g_orientation,\n-    g_page,\n-    g_rank,\n-    g_rankdir,\n-    g_ranksep,\n-    g_ratio,\n-    g_size\n-  } name;\n-  const char *value;\n-} graph_attr;\n-\n-void dot_start(FILE *to,const char *name,bool directed,bool strict);\n-\n-void dot_global_graph_style(graph_attr *attrs,int n);\n-void dot_global_edge_style(edge_attr *attrs,int n);\n-void dot_global_node_style(node_attr *attrs,int n);\n-\n-dot_node dot_get_node(char *label) deletes;\n-void dot_node_style(dot_node node,node_attr *attrs,int n);\n-\n-void dot_plain_edge(dot_node from, dot_node to);\n-void dot_styled_edge(dot_node from, dot_node to, edge_attr *attrs,int n);\n-\n-void dot_end(void) deletes;\n-\n-EXTERN_C_END\n-\n-#endif /* DOT_H */"}, {"sha": "4c60aa4eb4729a4468ab1060147513bf5c79ccdb", "filename": "libbanshee/engine/flow-var.c", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflow-var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflow-var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fflow-var.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,181 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdio.h>\n-#include <assert.h>\n-#include \"banshee.h\"\n-#include \"flow-var.h\"\n-#include \"ufind.h\"\n-#include \"bounds.h\"\n-\n-DECLARE_UFIND(contour_elt,contour)\n-\n-struct flow_var /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type; /* alias or var */\n-  stamp st;\n-  gen_e alias;\n-  bounds sameregion ubs;\n-  bounds sameregion lbs;\n-  contour_elt elt; \n-  const char *name;\n-};\n-\n-DEFINE_UFIND(contour_elt,contour)\n-DEFINE_LIST(flow_var_list, flow_var)\n-\n-#define get_contour(x) (contour_elt_get_info((x)->elt))\n-\n-static flow_var make_var(region r, const char *name, stamp st)\n-{\n-  flow_var result = ralloc(r,struct flow_var);\n-\n-  result->type = VAR_TYPE;\n-  result->st = st;\n-  result->alias = NULL;\n-  result->ubs = bounds_create(r);\n-  result->lbs = bounds_create(r);\n-  result->elt = new_contour_elt(r,NULL);\n-  result->name = name;\n-\n-#ifdef NONSPEC\n-  result->sort = flow_sort;\n-#endif\n-\n-  return result;\n-}\n-\n-flow_var fv_fresh(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh());\n-}\n-\n-flow_var fv_fresh_large(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_large());\n-}\n-\n-flow_var fv_fresh_small(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_small());\n-}\n-\n-const char * fv_get_name(flow_var v)\n-{\n-  return v->name;\n-}\n-\n-gen_e_list fv_get_lbs(flow_var v)\n-{\n-  return bounds_exprs(v->lbs);\n-}\n-\n-gen_e_list fv_get_ubs(flow_var v)\n-{\n-  return bounds_exprs(v->ubs);\n-}\n-\n-bool fv_add_ub(flow_var v, gen_e e, stamp st)\n-{\n-  return bounds_add(v->ubs,e,st);\n-}\n-\n-bool fv_add_lb(flow_var v, gen_e e, stamp st)\n-{\n-  return bounds_add(v->lbs,e,st);\n-}\n-\n-bool fv_is_ub(flow_var v, stamp st)\n-{\n-  bool self_edge = v->st == st,\n-    in_bounds = bounds_query(v->ubs,st);\n-\n-  return (self_edge || in_bounds);\n-}\n-\n-bool fv_is_lb(flow_var v, stamp st)\n-{\n-  bool self_edge = v->st == st,\n-    in_bounds = bounds_query(v->lbs,st);\n-\n-  return (self_edge || in_bounds);\n-}\n-\n-void fv_set_alias(flow_var v, gen_e e)\n-{\n-  assert(v->type == VAR_TYPE);\n-\n-  v->type = ALIAS_TYPE;\n-  v->alias = e;\n-}\n-\n-gen_e fv_get_alias(flow_var v)\n-{\n-  return v->alias;\n-}\n-\n-bool fv_has_contour(flow_var v)\n-{\n-  return (get_contour(v) != NULL);\n-}\n-\n-void fv_set_contour(flow_var v, contour c)\n-{\n-  contour_elt_update(v->elt,c);\n-}\n-\n-static contour combine_contour(contour c1, contour c2)\n-{\n-  if (c1 == NULL)\n-    return c2;\n-  else if (c2 == NULL)\n-    return c1;\n-\n-  else \n-    {\n-      fail(\"Attempt to unify two distinct contours\\n\");\n-      return NULL;\n-    }\n-\n-}\n-void fv_unify_contour(flow_var v1, flow_var v2)\n-{\n-  contour_elt_unify(combine_contour,v1->elt,v2->elt);\n-}\n-\n-\n-gen_e fv_instantiate_contour(flow_var v) deletes\n-{\n-  contour c = get_contour(v);\n-  return c->instantiate(c->fresh,c->get_stamp,c->shape);\n-}"}, {"sha": "2d77007824aa5fe8ea44d4a4d4678b2340d53593", "filename": "libbanshee/engine/flow-var.h", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflow-var.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflow-var.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fflow-var.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,76 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef FLOW_VAR_H\n-#define FLOW_VAR_H\n-\n-#include \"linkage.h\"\n-#include \"banshee.h\"\n-#include \"jcollection.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct flow_var *flow_var;\n-\n-typedef gen_e (*contour_inst_fn_ptr) (fresh_fn_ptr,get_stamp_fn_ptr,gen_e) deletes;\n-\n-struct contour\n-{\n-  gen_e shape;\n-  fresh_fn_ptr fresh;\n-  get_stamp_fn_ptr get_stamp;\n-  contour_inst_fn_ptr instantiate;\n-};\n-\n-typedef struct contour *contour;\n-\n-DECLARE_LIST(flow_var_list, flow_var)\n-   \n-flow_var fv_fresh(region r, const char *name);\n-flow_var fv_fresh_large(region r, const char *name);\n-flow_var fv_fresh_small(region r, const char *name);\n-const char * fv_get_name(flow_var v);\n-gen_e_list fv_get_lbs(flow_var v);\n-gen_e_list fv_get_ubs(flow_var v);\n-bool fv_add_ub(flow_var v, gen_e e, stamp st);\n-bool fv_add_lb(flow_var v, gen_e e, stamp st);\n-bool fv_is_ub(flow_var v, stamp st);\n-bool fv_is_lb(flow_var v, stamp st);\n-\n-void fv_set_alias(flow_var v, gen_e e);\n-gen_e fv_get_alias(flow_var v);\n-void fv_set_contour(flow_var v, contour c);\n-bool fv_has_contour(flow_var v);\n-void fv_unify_contour(flow_var v1, flow_var v2);\n-gen_e fv_instantiate_contour(flow_var v) deletes;\n-\n-EXTERN_C_END\n-\n-#endif /* FLOW_VAR_H */"}, {"sha": "f129025e4123944871cc49b86bc99aeadac8a7cd", "filename": "libbanshee/engine/flowrow-sort.c", "status": "removed", "additions": 0, "deletions": 1109, "changes": 1109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflowrow-sort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflowrow-sort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fflowrow-sort.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,1109 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <regions.h>\n-#include <assert.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include <ansidecl.h>\n-#include \"flowrow-sort.h\"\n-#include \"termhash.h\"\n-\n-#include \"setif-sort.h\"\n-\n-#define ABS_TYPE 2\n-#define WILD_TYPE 3\n-#define ROW_TYPE 4\n-\n-/* generic flow row */\n-struct flowrow_gen\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-#ifdef NONSPEC\n-  sort_kind base_sort; \n-#endif\n-};\n-\n-typedef struct flowrow_gen *flowrow_gen;\n-\n-struct flowrow\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif \n-  int type;\t\t\n-  stamp st;\t\n-#ifdef NONSPEC\n-  sort_kind base_sort; \n-#endif\n-  flowrow_map fields;\n-  gen_e rest;\n-};\n-\n-typedef struct flowrow *flowrow;\n-\n-struct field_split\n-{\n-  gen_e_list matched1;\n-  gen_e_list matched2;\n-  flowrow_map nomatch1;\n-  flowrow_map nomatch2;\n-};\n-\n-region flowrow_region;\n-term_hash flowrow_hash;\n-struct flowrow_stats flowrow_stats;\n-static void fields_print(FILE *f,flowrow_map m,field_print_fn_ptr field_print) deletes;\n-\n-stamp flowrow_get_stamp(gen_e e)\n-{\n-  if ( ((flowrow_gen)e)->type == ALIAS_TYPE)\n-    return ((flowrow_gen)fv_get_alias( (flow_var)e ))->st;\n-  else\n-    return ((flowrow_gen)e)->st;\n-  \n-}\n-\n-static flowrow_map flowrow_get_fields(gen_e e)\n-{\n-  assert (flowrow_is_row(e));\n-  \n-  return ((flowrow)e)->fields;\n-}\n-\n-static gen_e flowrow_get_rest(gen_e e)\n-{\n-  assert(flowrow_is_row(e));\n-\n-  return ((flowrow)e)->rest;\n-}\n-\n-\n-static int field_compare(const flowrow_field f1,const flowrow_field f2)\n-\t\t\t\n-{\n-  int compare = strcmp(f1->label,f2->label);\n-  return compare;\n-}\n-\n-\n-static int field_compare_ne(const flowrow_field f1,const flowrow_field f2)\n-\t\t\t\n-{\n-  int compare = strcmp(f1->label,f2->label);\n-\n-  if (! compare) /* rows should never have two fields with the same labels */\n-    {\n-      failure(\"Multiple fields in this row share the same label\\n\");\n-    }\n-  return compare;\n-}\n-\n-static struct field_split split_fields(region r, flowrow_map fields1,\n-\t\t\t\t       flowrow_map fields2)\n-{\n-  struct field_split split;\n-  flowrow_map_scanner scan1, scan2;\n-  flowrow_field field1,field2;\n-  bool consumed1 = TRUE,consumed2 = TRUE, \n-    fields1_remain = TRUE, fields2_remain = TRUE;;\n-\n-  split.matched1 = new_gen_e_list(r);\n-  split.matched2 = new_gen_e_list(r);\n-  split.nomatch1 = new_flowrow_map(r);\n-  split.nomatch2 = new_flowrow_map(r);\n-\n-  flowrow_map_scan(fields1,&scan1);\n-  flowrow_map_scan(fields2,&scan2);\n- \n-  while (TRUE)\n-    {\n-      if (consumed1)\n-\tfields1_remain = flowrow_map_next(&scan1,&field1);\n-      if (consumed2)\n-     \tfields2_remain = flowrow_map_next(&scan2,&field2);\n-\n-      if (fields1_remain && fields2_remain)\n-\t{\n-\t  int compare_fields = field_compare(field1,field2);\n-\n-\t  if (compare_fields < 0)\n-\t    {\n-\t      flowrow_map_cons(field1,split.nomatch1);\n-\t      consumed1 = TRUE;\n-\t      consumed2 = FALSE;\n-\t    }\n-\t  else if (compare_fields > 0)\n-\t    {\n-\t      flowrow_map_cons(field2,split.nomatch2);\n-\t      consumed2 = TRUE;\n-\t      consumed1 = FALSE;\n-\t    }\n-\t  else /* two fields are equal */\n-\t    {\n-\t      gen_e_list_cons(field1->expr,split.matched1);\n-\t      gen_e_list_cons(field2->expr,split.matched2);\n-\t      consumed1 = TRUE;\n-\t      consumed2 = TRUE;\n-\t      continue;\n-\t    }\n-\t}\n-      else if (fields1_remain)\n-\t{\n-\t  /* flowrow_map_append(split.nomatch1,flowrow_map_copy(r,fields1)); */\n-\t  flowrow_map_cons(field1,split.nomatch1);\n-\t  \n-\t  while (flowrow_map_next(&scan1,&field1))\n-\t    {\n-\t      flowrow_map_cons(field1,split.nomatch1);\n-\t    }\n-\n-\t  break;\n-\t}\n-      else if (fields2_remain)\n-\t{\n-\t  /* flowrow_map_append(split.nomatch2,flowrow_map_copy(r,fields2)); */\n-\t  flowrow_map_cons(field2,split.nomatch2);\n-\t  while (flowrow_map_next(&scan2,&field2))\n-\t    {\n-\t      flowrow_map_cons(field2,split.nomatch2);\n-\t    }\n-\t  break;\n-\t}\n-      else /* no remaining fields, so */ break;\n-    }\n-  \n-  return split;\n-}\n-\n-static bool flowrow_is_normalized(gen_e r)\n-{\n- if ( flowrow_is_row(r) )\n-    {\n-      gen_e rest = flowrow_get_rest(r);\n-      \n-      if ( flowrow_is_row(rest) || flowrow_is_alias(rest) )\n-\treturn FALSE;\n-    }\n- else if ( flowrow_is_alias(r) )\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-static gen_e normalize(get_stamp_fn_ptr get_stamp,\n-\t\t\t flowrow_map m,gen_e r) deletes\n-{\n-  if (flowrow_is_row(r))\n-    {\n-      flowrow_map_append(m,\n-\t\t\t flowrow_map_copy(flowrow_region,\n-\t\t\t\t\t  flowrow_get_fields(r)));\n-      return normalize(get_stamp,m,flowrow_get_rest(r));\n-    }\n-  else if (flowrow_is_alias(r))\n-    {\n-      assert (! flowrow_is_alias(fv_get_alias((flow_var)r)) );\n-      return normalize(get_stamp, m,fv_get_alias((flow_var)r));\n-    }\n-  else\n-    return flowrow_row(get_stamp,m,r);\n-}\n-\n-static gen_e normalize_row(get_stamp_fn_ptr get_stamp, gen_e r) deletes\n-{\n-  if (flowrow_is_normalized(r))\n-    return r;\n-  else /* normalize the row */\n-    return normalize(get_stamp,new_flowrow_map(flowrow_region),r);\n-}\n-\n-static bool eq(gen_e e1, gen_e e2)\n-{\n-  return ( flowrow_get_stamp(e1) == flowrow_get_stamp(e2) ); \n-}\n-\n-\n-/*\n-  A row constraint row1 <= row2 is l-inductive iff row2 is a var and for all \n-  X = tlv(row1), o(row2) > o(X). \n-  \n-  tlv(row) = {X} if row is a var X, {} otherwise \n-*/\n-static bool l_inductive(gen_e e1, gen_e e2)\n-{\n-  if (flowrow_is_var(e2))\n-    {\n-      if (flowrow_is_var(e1))\n-\treturn flowrow_get_stamp(e2) > flowrow_get_stamp(e1);\n-      else return TRUE;\n-    }\n-  return FALSE;\n-}\n-      \n-/* \n-   A row constraint row1 <= row2 is r-inductive iff row1 is a var and for all\n-   X = tlv(row2), o(row1) > o(X)\n-*/\n-static bool r_inductive(gen_e e1, gen_e e2)\n-{\n-  if (flowrow_is_var(e1))\n-    {\n-      if (flowrow_is_var(e2))\n-\treturn flowrow_get_stamp(e1) > flowrow_get_stamp(e2);\n-      else return TRUE;\n-    }\n-  return FALSE;\n-}\n-\n-static inline bool flowrow_minimal(flowrow r)\n-{\n-  return flowrow_is_zero(r->rest);\n-}\n-\n-static inline bool flowrow_maximal(flowrow r)\n-{\n-  return flowrow_is_one(r->rest);\n-}\n-\n-static inline bool flowrow_closed(flowrow r)\n-{\n-  return flowrow_is_abs(r->rest);\n-}\n-\n-static inline bool flowrow_wildcard(flowrow r)\n-{\n-  return flowrow_is_wild(r->rest);\n-}\n-\n-static inline bool flowrow_var(flowrow r)\n-{\n-  return flowrow_is_var(r->rest);\n-}\n-\n-static gen_e contour_instantiate(fresh_fn_ptr fresh,\n-\t\t\t\t get_stamp_fn_ptr get_stamp, \n-\t\t\t\t gen_e e) deletes\n-{\n-  if (flowrow_is_row(e))\n-    {\n-      gen_e result;\n-      flowrow_map_scanner scan;\n-      flowrow_field f;\n-      gen_e row = normalize_row(get_stamp,e);\n-\n-      region scratch_rgn = newregion();\n-\n-      flowrow_map new_fields = new_flowrow_map(scratch_rgn);\n-            \n-      flowrow_map_scan(flowrow_get_fields(row),&scan);\n-\n-      while (flowrow_map_next(&scan,&f))\n-\t{\n-\t  flowrow_field new_field =\n-\t    ralloc(flowrow_region,struct flowrow_field);\n-\t  new_field->label = f->label;\n-\t  new_field->expr = fresh(NULL);\n-\t  \n-\t  flowrow_map_cons(new_field,new_fields);\n-\t}\n-      \n-      result = flowrow_row(get_stamp,new_fields,flowrow_fresh(NULL));\n-\n-      deleteregion(scratch_rgn);\n-\n-      assert( flowrow_is_row(result) );\n-      \n-      return result;\n-    }\n-  \n-  else /* TODO */\n-    {\n-      failure(\"Unmatched contour\\n\");\n-      return NULL;\n-    }\n-}\n-\n-static contour get_contour(fresh_fn_ptr fresh,get_stamp_fn_ptr get_stamp, \n-\t\t\t   gen_e zero_elem ATTRIBUTE_UNUSED,gen_e e)\n-{\n-  if (flowrow_is_row(e))\n-    {\n-      contour result;\n-\n-      result = ralloc(flowrow_region,struct contour);\n-      result->shape = e;\n-      result->fresh = fresh;\n-      result->get_stamp = get_stamp;\n-      result->instantiate = contour_instantiate;\n-\t  \n-      return result;\n-    }\n-  else /* TODO */\n-    {\n-      failure(\"Unmatched contour\\n\");\n-      return NULL;\n-    }\n-}\n-  \n-\n-static  void trans_lbs(fresh_fn_ptr fresh,get_stamp_fn_ptr get_stamp, \n-\t\t       incl_fn_ptr field_incl, gen_e zero_elem,\n-\t\t       flow_var v, gen_e e) deletes\n-{\n-  gen_e temp;\n-  gen_e_list_scanner scan;\n-  \n-  gen_e_list_scan(fv_get_lbs(v),&scan);\n-  while (gen_e_list_next(&scan,&temp))\n-      flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,temp,e);\n-  \n-}\n-\n-static  void trans_ubs(fresh_fn_ptr fresh,get_stamp_fn_ptr get_stamp, \n-\t\t       incl_fn_ptr field_incl, gen_e zero_elem,\n-\t\t       flow_var v, gen_e e) deletes\n-{\n-  gen_e temp;\n-  gen_e_list_scanner scan;\n-  \n-  gen_e_list_scan(fv_get_ubs(v),&scan);\n-  while (gen_e_list_next(&scan,&temp))\n-    flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e,temp);\n-}\n-\n-static  void update_lower_bound(fresh_fn_ptr fresh,get_stamp_fn_ptr get_stamp, \n-\t\t\t\tincl_fn_ptr field_incl, gen_e zero_elem,\n-\t\t\t\tflow_var v,gen_e e) deletes\n-{\n-  if (fv_has_contour(v)) /* _ <= v, and v has a contour */\n-    {\n-      gen_e shape = fv_instantiate_contour(v);\n-      \n-      fv_set_alias(v,shape);\n-      trans_ubs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-      trans_lbs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-      \n-      flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e,shape);\n-      \n-    }\n-  \n-  else if (flowrow_is_var(e)) \n-    {\n-      flow_var v_lb = (flow_var)e;\n-      \n-      if (fv_has_contour(v_lb)) /* v1 <= v2, v1 has a contour */\n-\t{\n-\t  gen_e shape = fv_instantiate_contour(v_lb);\n-\t  \n-\t  fv_set_alias(v_lb,shape);\n-\t  trans_ubs(fresh,get_stamp,field_incl,zero_elem,v_lb,shape);\n-\t  trans_lbs(fresh,get_stamp,field_incl,zero_elem,v_lb,shape);\n-\t  \n-\t  flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,\n-\t\t\t    shape,(gen_e)v);\n-\t  \n-\t}\n-      \n-      else /* we have v1 <= v2, no contours */\n-\t{\n-\t  bool redundant;\n-\t  \n-\t  fv_unify_contour(v,(flow_var)e);\n-\t  redundant = fv_add_lb(v,e,flowrow_get_stamp(e));\n-\t  \n-\t  if (! redundant)\n-\t    trans_ubs(fresh,get_stamp,field_incl,zero_elem,v,e);\n-\t      \n-\t}\n-    }\n-  else /* we have c(...) <= v, and v has no contour */\n-    {\n-      gen_e shape = NULL;\n-      fv_set_contour(v,get_contour(fresh,get_stamp,zero_elem,e));\n-      \n-      shape = fv_instantiate_contour(v);\n-      fv_set_alias(v,shape);\n-      trans_ubs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-      trans_lbs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-      \n-      flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e,shape);\n-      \n-    }\n-}\n-\n-static  void update_upper_bound(fresh_fn_ptr fresh,get_stamp_fn_ptr get_stamp, \n-\t\t\t\tincl_fn_ptr field_incl, gen_e zero_elem,\n-\t\t\t\tflow_var v,gen_e e) deletes\n-{\n-  if (fv_has_contour(v)) /* v isn't aliased, and we discovered a contour*/\n-    {\n-      gen_e shape = fv_instantiate_contour(v);\n-      \n-      fv_set_alias(v,shape);\n-      trans_ubs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-      trans_lbs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-      \n-      flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,shape,e);\n-\t  \n-    }\n-  \n-  else if (flowrow_is_var(e)) \n-    {\n-      flow_var v2 = (flow_var)e;\n-\t  \n-      if (fv_has_contour(v2)) /* v2 isn't aliased, and we discovered a contour */\n-\t{\n-\t  gen_e shape = fv_instantiate_contour(v2);\n-\t     \n-\t  fv_set_alias(v2,shape);\n-\t  trans_ubs(fresh,get_stamp,field_incl,zero_elem,v2,shape);\n-\t  trans_lbs(fresh,get_stamp,field_incl,zero_elem,v2,shape);\t      \n-\n-\n-\t  flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,\n-\t\t\t    (gen_e)v,shape);\n-\n-\t}\n-\n-      else /* we have v1 <= v2, no contours */\n-\t{\n-\t  bool redundant;\n-\t    \n-\t  fv_unify_contour(v,(flow_var)e);\n-\t  redundant = fv_add_ub(v,e,flowrow_get_stamp(e));\n-\n-\t  if (! redundant)\n-\t    trans_lbs(fresh,get_stamp,field_incl,zero_elem,v,e);\n-\t      \n-\t}\n-    }\n-  else /* we have v <= c(...), and v has no contour */\n-    {\n-      gen_e shape = NULL;\n-      fv_set_contour(v,get_contour(fresh,get_stamp,zero_elem,e));\n-\t  \n-      shape = fv_instantiate_contour(v);\n-\n-      if (! flowrow_is_row(shape) )\n-\t{\n-\t  assert(0);\n-\t}\n-\t  \n-      fv_set_alias(v,shape);\n-      trans_ubs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-      trans_lbs(fresh,get_stamp,field_incl,zero_elem,v,shape);\n-\t  \n-\t\n-      flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,shape,e);\n-\t  \n-    }\n-\n-}\n-\n-/* END */\n-\n-\n-void flowrow_inclusion(fresh_fn_ptr fresh,get_stamp_fn_ptr get_stamp, \n-\t\t       incl_fn_ptr field_incl, gen_e zero_elem, gen_e a, \n-\t\t       gen_e b) deletes\n-{\n-  gen_e e1 = normalize_row(get_stamp, a),\n-    e2 = normalize_row(get_stamp, b);\n-\n-  if (eq(e1,e2))\n-    return;\n-  else if (flowrow_is_zero(e1) || flowrow_is_wild(e1))\n-    return;\n-  else if (flowrow_is_one(e2) || flowrow_is_wild(e2))\n-    return;\n-\n-  else if ( l_inductive(e1,e2) )\n-    {\n-      flow_var v2 = (flow_var)e2;\n-      \n-      flowrow_stats.rows_l_inductive++;\n-      \n-      update_lower_bound(fresh,get_stamp,field_incl,zero_elem,v2,e1);\n-      return;\n-    }\n-  \n-  else if ( r_inductive(e1,e2) )\n-    {\n-      flow_var v1 = (flow_var)e1;\n-\n-      flowrow_stats.rows_r_inductive++;\n-\n-      update_upper_bound(fresh,get_stamp,field_incl,zero_elem,v1,e2);\n-      return;\n-    }\n-\n-  else if ( flowrow_is_row(e1) && flowrow_is_row(e2))\n-    {\n-      region scratch_rgn = newregion();\n-  \n-      flowrow r1 = (flowrow)e1,\n-\tr2 = (flowrow)e2;\n-\n-      struct field_split split = \n-\tsplit_fields(scratch_rgn,r1->fields,r2->fields);\n-      \n-      if ( gen_e_list_empty(split.matched1) ) \n-\t{\n-\t  assert ( gen_e_list_empty(split.matched2) );\n-\n-\t  if (flowrow_wildcard(r1) || flowrow_minimal(r1))\n-\t    {\n-\t      gen_e newrow = \n-\t\tflowrow_row(get_stamp,split.nomatch1,flowrow_get_rest(e1));\n-\t\t\n-\t      flowrow_inclusion(fresh,get_stamp,field_incl, zero_elem,newrow, \n-\t\t\t\tflowrow_get_rest(e2));\n-\t    }\n-\t  else if (flowrow_maximal(r2) || flowrow_closed(r2))\n-\t    {\n-\t      gen_e newrow =\n-\t\tflowrow_row(get_stamp,split.nomatch2,flowrow_get_rest(e2));\n-\n-\t      flowrow_inclusion(fresh, get_stamp,field_incl,zero_elem,\n-\t\t\t\tflowrow_get_rest(e1),newrow);\n-\t    }\n-\t  else \n-\t    {\n-\t      gen_e rest1 = flowrow_get_rest(e1),\n-\t\trest2 = flowrow_get_rest(e2);\n-\n-\t      /*assert( flowrow_is_var(rest1) && flowrow_is_var(rest2));*/\n-\n-\t      if ( eq(rest1,rest2))\n-\t\t  failure(\"Recursive row resolution\\n\");\n-\t      else\n-\t\t{\n-\t\t  gen_e fv = flowrow_fresh(NULL);\n-\t\t  gen_e newrow1 = flowrow_row(get_stamp,split.nomatch1,fv);\n-\t\t  gen_e newrow2 = flowrow_row(get_stamp,split.nomatch2,fv);\n-\t\t    \n-\t\t  flowrow_inclusion(fresh,get_stamp,field_incl,\n-\t\t\t\t    zero_elem,rest1,newrow2);\n-\t\t  flowrow_inclusion(fresh,get_stamp,field_incl,\n-\t\t\t\t    zero_elem,newrow1,rest2);\n-\t\t}\n-\n-\t    } \n-\t}\n-\n-      else /* some fields matched */\n-\t{\n-\t  gen_e_list_scanner scan1, scan2;\n-\t  gen_e f1,f2;\n-\n-\t  assert( gen_e_list_length(split.matched1) \n-\t\t  == gen_e_list_length(split.matched2) );\n-\t  \n-\t  gen_e_list_scan(split.matched1,&scan1);\n-\t  gen_e_list_scan(split.matched2,&scan2);\n-\n-\t  while (gen_e_list_next(&scan1,&f1) &&\n-\t\t gen_e_list_next(&scan2,&f2) )\n-\t    {\n-\t      field_incl(f1,f2);\n-\t    }\n-\t  \n-\t  if ( flowrow_wildcard(r1) && flowrow_wildcard(r2) )\n-\t    {\n-\t      goto END;\n-\t    }\n-\t  else\n-\t    {\n-\t      flowrow_map fields1 = split.nomatch1;\n-\t      flowrow_map fields2 = split.nomatch2;\n-\t\t     \n-\t      gen_e newrow1 = flowrow_row(get_stamp,fields1,r1->rest);\n-\t      gen_e newrow2 = flowrow_row(get_stamp,fields2,r2->rest);\n-\t      \n-\t      flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,\n-\t\t\t\tnewrow1, newrow2);\n-\t    }\n-\t}\n-    END:\n-      deleteregion(scratch_rgn);\n-    }\n-  \n-  else /* potentially a problem normalizing a row? */\n-    {\n-      failure(\"Unmatched case in row inclusion\\n\");\n-      return;\n-    }\n-}\n-\n-gen_e flowrow_row(get_stamp_fn_ptr get_stamp,flowrow_map f, gen_e rest) deletes\n-{\n-  flowrow_map fields = flowrow_map_copy(flowrow_region,f);\n-\n-  if (flowrow_map_empty(fields))\n-    {\n-      return rest;\n-    }\n-  else\n-    { \n-      flowrow_map_scanner scan;\n-      flowrow_field temp;\n-      gen_e result;\n-      int i = 2,\n-\tlength = flowrow_map_length(fields);\n-      stamp st[2+2*length];\n-\n-      st[0] = ROW_TYPE;\n-      if (rest)\n-\tst[1] = flowrow_get_stamp(rest);\n-      else\n-\tassert(0);\n-\n-      flowrow_map_sort(fields,field_compare_ne);\n-  \n-      flowrow_map_scan(fields,&scan);\n-      while(flowrow_map_next(&scan,&temp))\n-      {\n-\tst[i++] = stamp_string(temp->label);\n-\tif (temp->expr)\n-\t  st[i++] = get_stamp(temp->expr);\n-\telse\n-\t  assert(0);\n-      }\n-\n-      if ( (result = term_hash_find(flowrow_hash,st,2 + 2*length)) == NULL)\n-\t{\n-\t  flowrow r = ralloc(flowrow_region, struct flowrow);\n-\t  r->type = ROW_TYPE;\n-\t  r->st = stamp_fresh();\n-\t  r->fields = fields;\n-\t  r->rest = rest;\n-\n-#ifdef NONSPEC\n-\t  r->base_sort = row_map_head(fields)->expr->sort;\n-\t  r->sort = flowrow_sort;\n-#endif\n-\t  result = (gen_e) r;\n-\t  term_hash_insert(flowrow_hash,result,st,2+2*length);\n-\t}\n-      /*  assert(flowrow_is_normalized(result)); */\n-      return result;\n-\n-    }\n-}\n-\n-#ifndef NONSPEC\n-static struct flowrow_gen zero_row = {ZERO_TYPE,ZERO_TYPE};\n-static struct flowrow_gen one_row = {ONE_TYPE,ONE_TYPE};\n-static struct flowrow_gen abs_row = {ABS_TYPE, ABS_TYPE};\n-static struct flowrow_gen wild_row = {WILD_TYPE, WILD_TYPE};\n-\n-gen_e flowrow_zero(void)\n-{\n-  return (gen_e)&zero_row;\n-}\n-\n-gen_e flowrow_one(void)\n-{\n-  return (gen_e)&one_row;\n-}\n-\n-gen_e flowrow_abs(void)\n-{\n-  return (gen_e)&abs_row;\n-}\n-\n-gen_e flowrow_wild(void)\n-{\n-  return (gen_e)&wild_row;\n-}\n-\n-gen_e flowrow_fresh(const char *name)\n-{\n-  flowrow_stats.fresh++;\n-  return (gen_e)fv_fresh(flowrow_region,name);\n-}\n-\n-gen_e flowrow_fresh_small(const char *name)\n-{\n-  flowrow_stats.fresh_small++;\n-  return (gen_e)fv_fresh_small(flowrow_region,name);\n-}\n-\n-gen_e flowrow_fresh_large(const char *name)\n-{\n-  flowrow_stats.fresh_large++;\n-  return (gen_e)fv_fresh_large(flowrow_region,name);\n-}\n-\n-#else\n-static struct flowrow_gen term_zero_row = {flowrow_sort,ZERO_TYPE,ZERO_TYPE,term_sort};\n-static struct flowrow_gen term_one_row = {flowrow_sort,ONE_TYPE,ONE_TYPE,term_sort};\n-static struct flowrow_gen term_abs_row = {flowrow_sort,ABS_TYPE, ABS_TYPE,term_sort};\n-static struct flowrow_gen term_wild_row = {flowrow_sort,WILD_TYPE, WILD_TYPE,term_sort};\n-\n-\n-static struct flowrow_gen setif_zero_row = {flowrow_sort,ZERO_TYPE,ZERO_TYPE,setif_sort};\n-static struct flowrow_gen setif_one_row = {flowrow_sort,ONE_TYPE,ONE_TYPE,setif_sort};\n-static struct flowrow_gen setif_abs_row = {flowrow_sort,ABS_TYPE, ABS_TYPE,setif_sort};\n-static struct flowrow_gen setif_wild_row = {flowrow_sort,WILD_TYPE, WILD_TYPE,setif_sort};\n-\n-static struct flowrow_gen setst_zero_row = {flowrow_sort,ZERO_TYPE,ZERO_TYPE,setst_sort};\n-static struct flowrow_gen setst_one_row = {flowrow_sort,ONE_TYPE,ONE_TYPE,setst_sort};\n-static struct flowrow_gen setst_abs_row = {flowrow_sort,ABS_TYPE, ABS_TYPE,setst_sort};\n-static struct flowrow_gen setst_wild_row = {flowrow_sort,WILD_TYPE, WILD_TYPE,setst_sort};\n-\n-\n-gen_e flowrow_zero(sort_kind base_sort)\n-{\n-  switch (base_sort)\n-    {\n-    case setif_sort:\n-      return (gen_e)&setif_zero_row;\n-    case setst_sort:\n-      return (gen_e)&setst_zero_row;\n-    case term_sort:\n-      return (gen_e)&term_zero_row;\n-    default:\n-      {\n-\tfailure(\"No matching base sort: flowrow_zero\\n\");\n-\treturn NULL;\n-      }\n-    }\n-  \n-  return NULL;\n-}\n-\n-gen_e flowrow_one(sort_kind base_sort)\n-{\n-  switch (base_sort)\n-    {\n-    case setif_sort:\n-      return (gen_e)&setif_one_row;\n-    case setst_sort:\n-      return (gen_e)&setst_one_row;\n-    case term_sort:\n-      return (gen_e)&term_one_row;\n-    default:\n-      {\n-\tfailure(\"No matching base sort: flowrow_one\\n\");\n-\treturn NULL;\n-      }\n-    }\n-  \n-  return NULL;\n-}\n-\n-gen_e flowrow_abs(sort_kind base_sort)\n-{\n-  switch (base_sort)\n-    {\n-    case setif_sort:\n-      return (gen_e)&setif_abs_row;\n-    case setst_sort:\n-      return (gen_e)&setst_abs_row;\n-    case term_sort:\n-      return (gen_e)&term_abs_row;\n-    default:\n-      {\n-\tfailure(\"No matching base sort: flowrow_abs\\n\");\n-\treturn NULL;\n-      }\n-    }\n-  \n-  return NULL;\n-}\n-\n-gen_e flowrow_wild(sort_kind base_sort)\n-{\n-\n-  switch (base_sort)\n-    {\n-    case setif_sort:\n-      return (gen_e)&setif_wild_row;\n-    case setst_sort:\n-      return (gen_e)&setst_wild_row;\n-    case term_sort:\n-      return (gen_e)&term_wild_row;\n-    default:\n-      {\n-\tfailure(\"No matching base sort: flowrow_wild\\n\");\n-\treturn NULL;\n-      }\n-    }\n-  \n-  return NULL;\n-}\n-\n-gen_e flowrow_fresh(const char *name,sort_kind base_sort)\n-{\n-\n-  switch (base_sort)\n-    {\n-    case setif_sort:\n-      return \n-    case setst_sort:\n-      return (gen_e)&setst_one_row;\n-    case term_sort:\n-      return (gen_e)&term_one_row;\n-    default:\n-      {\n-\tfailure(\"No matching base sort: flowrow_one\\n\");\n-\treturn NULL;\n-      }\n-    }\n-  \n-  return NULL;\n-}\n-\n-gen_e flowrow_fresh_small(sort_kind base_sort)\n-{\n-\n-  switch (base_sort)\n-    {\n-    case setif_sort:\n-      return (gen_e)&setif_one_row;\n-    case setst_sort:\n-      return (gen_e)&setst_one_row;\n-    case term_sort:\n-      return (gen_e)&term_one_row;\n-    default:\n-      {\n-\tfailure(\"No matching base sort: flowrow_one\\n\");\n-\treturn NULL;\n-      }\n-    }\n-  \n-  return NULL;\n-}\n-\n-gen_e flowrow_fresh_large(sort_kind base_sort)\n-{\n-\n-}\n-\n-sort_kind flowrow_base_sort(gen_e e)\n-{\n-\n-}\n-#endif /* NONSPEC */\n-\n-static const char* field_eq_name;\n-static bool field_eq(const flowrow_field f)\n-{\n-  return (! strcmp(f->label,field_eq_name));\n-}\n-\n-gen_e flowrow_extract_field(const char *name, gen_e e)\n-{\n-  if (flowrow_is_row(e))\n-    {\n-      flowrow_map fields = flowrow_get_fields(e);\n-      flowrow_field f;\n-      \n-      field_eq_name = name;\n-      f = flowrow_map_find(fields,field_eq);\n-\n-      if (f)\n-\treturn f->expr;\n-    }\n-  return NULL;\n-}\n-\n-gen_e flowrow_extract_rest(gen_e e)\n-{\n-  if (flowrow_is_row(e))\n-    return flowrow_get_rest(e);\n-  else\n-    return NULL;\n-}\n-\n-flowrow_map flowrow_extract_fields(gen_e e)\n-{\n-  if (flowrow_is_row(e))\n-    return flowrow_map_copy(flowrow_region,flowrow_get_fields(e));\n-  else\n-    return NULL;\n-}\n-\n-\n-bool flowrow_is_alias(gen_e e)\n-{\n-  return ((flowrow_gen)e)->type == ALIAS_TYPE;\n-}\n-\n-bool flowrow_is_zero(gen_e e)\n-{\n-  return ((flowrow_gen)e)->type == ZERO_TYPE;\n-}\n-\n-bool flowrow_is_one(gen_e e)\n-{\n-  return ((flowrow_gen)e)->type == ONE_TYPE;\n-}\n-\n-bool flowrow_is_abs(gen_e e)\n-{\n-  return ((flowrow_gen)e)->type == ABS_TYPE;\n-}\n-\n-bool flowrow_is_wild(gen_e e)\n-{\n-  return ((flowrow_gen)e)->type == WILD_TYPE;\n-}\n-\n-bool flowrow_is_var(gen_e e)\n-{\n-  return ((flowrow_gen)e)->type == VAR_TYPE;\n-}\n-\n-bool flowrow_is_row(gen_e e)\n-{\n-  return ((flowrow_gen)e)->type == ROW_TYPE;\n-}\n-\n-void flowrow_init(void)\n-{\n-  flowrow_region = newregion();\n-  flowrow_hash = make_term_hash(flowrow_region);\n-}\n-\n-static void flowrow_reset_stats(void)\n-{\n-  flowrow_stats.fresh = 0;\n-  flowrow_stats.fresh_small = 0;\n-  flowrow_stats.fresh_large = 0;\n-\n-  flowrow_stats.rows_disjoint_wild = 0;\n-  flowrow_stats.rows_equal = 0;\n-  flowrow_stats.rows_zero_one_wild = 0;\n-  flowrow_stats.rows_l_inductive = 0;\n-  flowrow_stats.rows_r_inductive = 0;\n-  flowrow_stats.rows_disjoint_r1_minimal = 0;\n-  flowrow_stats.rows_disjoint_r1_var_r2_minimal = 0;\n-  flowrow_stats.rows_disjoint_r1_var_r2_maximal = 0;\n-  flowrow_stats.rows_disjoint_r1_var_r2_closed = 0;\n-  flowrow_stats.rows_disjoint_r1_var_r2_var_lt = 0;\n-  flowrow_stats.rows_disjoint_r1_var_r2_var_gt = 0;\n-  flowrow_stats.rows_equal_domains = 0;\n-  flowrow_stats.rows_nonempty_intersection = 0;\n-  flowrow_stats.rows_fresh = 0;\n-  flowrow_stats.rows_fresh_large = 0;\n-}\n-\n-void flowrow_reset(void) deletes\n-{\n-  term_hash_delete(flowrow_hash);\n-  deleteregion_ptr(&flowrow_region);\n-\n-  flowrow_reset_stats();\n-\n-  flowrow_region = newregion();\n-  flowrow_hash = make_term_hash(flowrow_region);\n-\n-}\n-\n-static void fields_print(FILE *f,flowrow_map m,field_print_fn_ptr field_print) deletes\n-{\n-  flowrow_map_scanner scan;\n-  flowrow_field temp;\n-\n-  flowrow_map_scan(m,&scan);\n-\n-  if (flowrow_map_next(&scan,&temp))\n-    {\n-      fprintf(f,\"%s : \",temp->label);\n-      \n-      if (field_print)\n-\tfield_print(f,temp->expr);\n-      else\n-\tfprintf(f,\"?\");\n-    }\n-\n-  while (flowrow_map_next(&scan,&temp))\n-    {\n-      fprintf(f,\",%s : \",temp->label);\n-     \n-      if (field_print)\n-\tfield_print(f,temp->expr);\n-      else\n- \tfprintf(f,\"?\");\n-    }\n-}\n-\n-void flowrow_print(FILE *f,get_stamp_fn_ptr get_stamp, \n-\t\t   field_print_fn_ptr field_print,gen_e row) deletes\n-{\n-  gen_e e = normalize_row(get_stamp,row);\n-\n-  switch ( ((flowrow_gen)e)->type)\n-    {\n-    case ZERO_TYPE:\n-      fprintf(f, \"0\");\n-      break;\n-    case ONE_TYPE:\n-      fprintf(f, \"1\");\n-      break;\n-    case ABS_TYPE:\n-      fprintf(f, \"abs\");\n-      break;\n-    case WILD_TYPE:\n-      fprintf(f, \"wild\");\n-      break;\n-    case VAR_TYPE:\n-      fprintf(f, fv_get_name((flow_var)e));\n-      break;\n-    case ROW_TYPE:\n-      fprintf(f, \"<\");\n-      fields_print(f, flowrow_get_fields(e), field_print);\n-      fprintf(f, \"|\");\n-      flowrow_print(f, get_stamp, field_print, flowrow_get_rest(e));\n-      fprintf(f, \">\");\n-      break;\n-    default:\n-      assert(0);\n-      break;\n-    }\n-}\n-\n-void flowrow_print_stats(FILE *f)\n-{\n-  fprintf(f,\"\\n========== Flow Var Stats ==========\\n\");\n-  fprintf(f,\"Fresh : %d\\n\",flowrow_stats.fresh); \n-  fprintf(f,\"Fresh Small : %d\\n\",flowrow_stats.fresh_small);\n-  fprintf(f,\"Fresh Large : %d\\n\",flowrow_stats.fresh_large);\n-  fprintf(f,\"=====================================\\n\");\n-}\n-\n-DEFINE_LIST(flowrow_map,flowrow_field)"}, {"sha": "8d79b42c29da2d928dd38dfe866c1cf92fd6b5f8", "filename": "libbanshee/engine/flowrow-sort.h", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflowrow-sort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fflowrow-sort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fflowrow-sort.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,133 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef FLOWROW_SORT_H\n-#define FLOWROW_SORT_H\n-\n-\n-#include \"stdio.h\"\n-#include \"banshee.h\"\n-#include \"termhash.h\"\n-#include \"flow-var.h\"\n-\n-struct flowrow_field\n-{\n-  char *label;\n-  gen_e expr;\n-};\n-\n-typedef struct flowrow_field *flowrow_field;\n-\n-DECLARE_LIST(flowrow_map,flowrow_field)\n-\n-extern region flowrow_region;\n-\n-void flowrow_inclusion(fresh_fn_ptr fresh, get_stamp_fn_ptr get_stamp, \n-\t\t       incl_fn_ptr field_incl,gen_e zero_elem, gen_e e1, \n-\t\t       gen_e e2) deletes;\n-\n-gen_e flowrow_row(get_stamp_fn_ptr get_stamp,flowrow_map fields, gen_e rest) deletes;\n-\n-gen_e flowrow_extract_field(const char *name, gen_e e);\n-gen_e flowrow_extract_rest(gen_e e);\n-flowrow_map flowrow_extract_fields(gen_e e);\n-\n-stamp flowrow_get_stamp(gen_e e);\n-\n-#ifndef NONSPEC\n-gen_e flowrow_zero(void);\n-gen_e flowrow_one(void);\n-gen_e flowrow_abs(void);\n-gen_e flowrow_wild(void);\n-gen_e flowrow_fresh(const char *name);\n-gen_e flowrow_fresh_small(const char *name);\n-gen_e flowrow_fresh_large(const char *name);\n-#else\n-sort_kind flowrow_base_sort(gen_e e);\n-gen_e flowrow_zero(sort_kind base_sort);\n-gen_e flowrow_one(sort_kind base_sort);\n-gen_e flowrow_abs(sort_kind base_sort);\n-gen_e flowrow_wild(sort_kind base_sort);\n-gen_e flowrow_fresh(sort_kind base_sort);\n-gen_e flowrow_fresh_small(sort_kind base_sort);\n-gen_e flowrow_fresh_large(sort_kind base_sort);\n-#endif\n-\n-bool flowrow_is_zero(gen_e e);\n-bool flowrow_is_one(gen_e e);\n-bool flowrow_is_abs(gen_e e);\n-bool flowrow_is_wild(gen_e e);\n-bool flowrow_is_var(gen_e e);\n-bool flowrow_is_row(gen_e e);\n-bool flowrow_is_alias(gen_e e);\n-\n-\n-void flowrow_init(void);\n-void flowrow_reset(void) deletes;\n-\n-typedef void (* field_print_fn_ptr) (FILE *f,gen_e e) deletes;\n-\n-void flowrow_print(FILE *f,get_stamp_fn_ptr get_stamp,\n-\t\t   field_print_fn_ptr field_print,gen_e e) deletes;\n-void flowrow_print_stats(FILE *f);\n-\n-extern struct flowrow_stats flowrow_stats;\n-\n-struct flowrow_stats\n-{\n-  int fresh;\n-  int fresh_small;\n-  int fresh_large;\n-\n-  int rows_disjoint_wild;\n-  int rows_equal;\n-  int rows_zero_one_wild;\n-  int rows_l_inductive;\n-  int rows_r_inductive;\n-  int rows_disjoint_r1_minimal;\n-  int rows_disjoint_r1_var_r2_minimal;\n-  int rows_disjoint_r1_var_r2_maximal;\n-  int rows_disjoint_r1_var_r2_closed;\n-  int rows_disjoint_r1_var_r2_var_lt;\n-  int rows_disjoint_r1_var_r2_var_gt;\n-  int rows_equal_domains;\n-  int rows_nonempty_intersection;\n-  int rows_fresh;\n-  int rows_fresh_large;\n-};\n-\n-#endif /* FLOWROW_H */\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "bf315cee4a5f67b8a4055fa34e1da0fe803daf16", "filename": "libbanshee/engine/hash.c", "status": "removed", "additions": 0, "deletions": 427, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fhash.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,427 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <string.h>\n-#include \"hash.h\"\n-#include \"util.h\"\n-\n-struct bucket\n-{\n-  hash_key key;\n-  hash_data data;\n-  struct bucket *next;\n-};\n-\n-#define scan_bucket(b, var) for (var = b; var; var = var->next)\n-\n-struct Hash_table\n-{\n-  region r;          /* Region for this table */\n-  hash_fn hash;      /* Function for hashing keys */\n-  keyeq_fn cmp;      /* Function for comparing keys */\n-\n-  int size;          /* Number of buckets */\n-  int elts;          /* Number of elements */\n-  bool internal_rgn; /* TRUE if the ht uses an internal region */\n-  bucket *table;     /* Array of (size) buckets */\n-};\n-\n-static void rehash(hash_table ht) deletes; \n-\n-/* Make a new hash table, with size buckets initially.  The actual\n-   table is allocated in a local region, which is discarded on rehashing. */\n-hash_table make_hash_table(region r, int size, hash_fn hash,\n-\t\t\t   keyeq_fn cmp, bool internal_rgn)\n-{\n-  hash_table result;\n-\n-  assert(size > 0);\n-  result = ralloc(r, struct Hash_table);\n-  \n-  if (internal_rgn)\n-    result->r = newregion();\n-  else\n-    result->r = r;\n-\n-  result->internal_rgn = internal_rgn;\n-  result->hash = hash;\n-  result->cmp = cmp;\n-  result->size = size;\n-  result->elts = 0;\n-  result->table = rarrayalloc(result->r, size, bucket);\n-\n-  return result;\n-}\n-\n-/* Hash a string */\n-static int string_hash(char *str)\n-{\n-  char *c;\n-  int h;\n-\n-  c = str;\n-  h = 0;\n-  if (!c)\n-    return 0;\n-  while (*c)\n-    h = 33*h + 720 + *c++; /* SML/NJ's string hash function */\n-  return h;\n-}\n-\n-/* Return TRUE iff s1 == s2 */\n-static bool string_eq(char *s1, char *s2)\n-{\n-  return !strcmp(s1, s2);\n-}\n-\n-/* Make a hash table for strings. */\n-hash_table make_string_hash_table(region rhash, int size, bool internal_rgn)\n-{\n-  return make_hash_table(rhash, size, (hash_fn) string_hash,\n-\t\t\t (keyeq_fn) string_eq,internal_rgn);\n-}\n-\n-/* Zero out ht.  Doesn't reclaim bucket space. */\n-void hash_table_reset(hash_table ht) deletes\n-{\n-  int i;\n-  \n-  if (ht->internal_rgn)\n-    {\n-      deleteregion(ht->r);\n-      ht->r = newregion();  \n-    }\n-\n-  ht->elts = 0;\n-  for (i = 0; i < ht->size; i++)\n-    ht->table[i] = NULL;\n-}\n-\n-void hash_table_delete(hash_table ht) deletes\n-{\n-  if (ht->internal_rgn)\n-    deleteregion(ht->r);\n-}\n-\n-\n-/* Return the number of entries in ht */\n-int hash_table_size(hash_table ht)\n-{\n-  return ht->elts;\n-}\n-\n-/* Return the bucket corresponding to k in ht */\n-static inline bucket *find_bucket(hash_table ht, hash_key k)\n-{\n-  int hash;\n-\n-  hash = ht->hash(k);\n-  if (hash < 0)\n-    hash = -1*hash;\n-  return &ht->table[hash % ht->size];\n-}\n-\n-/* Lookup k in ht.  Returns corresponding data in *d, and function\n-   result is TRUE if the k was in ht, false otherwise. */\n-bool hash_table_lookup(hash_table ht, hash_key k, hash_data *d)\n-{\n-  bucket cur;\n-\n-  cur = *find_bucket(ht, k);\n-  while (cur)\n-    {\n-      if (ht->cmp(k, cur->key))\n-\t{\n-\t  if (d)\n-\t    *d = cur->data;\n-\t  return TRUE;\n-\t}\n-      cur = cur->next;\n-    }\n-  return FALSE;\n-}\n-\n-\n-/* Add k:d to ht.  If k was already in ht, replace old entry by k:d.\n-   Rehash if necessary.  Returns TRUE if k was not already in ht. */\n-bool hash_table_insert(hash_table ht, hash_key k, hash_data d) deletes\n-{\n-  bucket *cur;\n-\n-  if (ht->elts > ht->size*15)\n-    rehash(ht);\n-  cur = find_bucket(ht, k);\n-  while (*cur)\n-    {\n-      if (ht->cmp(k, (*cur)->key))\n-\t{\n-\t  (*cur)->data = d;\n-\t  return FALSE; /* Replace */\n-\t}\n-      cur = &(*cur)->next;\n-    }\n-  *cur = ralloc(ht->r, struct bucket);\n-  (*cur)->key = k;\n-  (*cur)->data = d;\n-  (*cur)->next = NULL;\n-  ht->elts++;\n-  return TRUE; /* New key */\n-}\n-\n-/* Remove mapping for k in ht.  Returns TRUE if k was in ht. */\n-bool hash_table_remove(hash_table ht, hash_key k) \n-{\n-  bucket *cur;\n-  bucket *prev = NULL;\n-\n-  cur = find_bucket(ht, k);\n-  while (*cur)\n-    {\n-      if (ht->cmp(k, (*cur)->key))\n-\t{\n-\t  if (!*prev)\n-\t    (*prev)->next = (*cur)->next;\n-\t  else\n-\t    *cur = NULL;\n-\t  ht->elts--;\n-\t  return TRUE;\n-\t}\n-      prev = cur;\n-      cur = &(*cur)->next;\n-    }\n-  return FALSE;\n-}\n-\n-/* Return a copy of ht */\n-hash_table hash_table_copy(region r, hash_table ht)\n-{\n-  int i;\n-  hash_table result;\n-  bucket cur, newbucket, *prev;\n-\n-  result = make_hash_table(r, ht->size, ht->hash, ht->cmp,ht->internal_rgn);\n-  result->elts = ht->elts;\n-  \n-  for (i = 0; i < ht->size; i++)\n-    {\n-      prev = &result->table[i];\n-      scan_bucket(ht->table[i], cur)\n-\t{\n-\t  newbucket = ralloc(result->r, struct bucket);\n-\t  newbucket->key = cur->key;\n-\t  newbucket->data = cur->data;\n-\t  newbucket->next = NULL;\n-\t  assert(!*prev);\n-\t  *prev = newbucket;\n-\t  prev = &newbucket->next;\n-\t}\n-    }\n-  return result;\n-  /*\n-  hash_table result;\n-  hash_table_scanner hts;\n-  hash_key k;\n-  hash_data d;\n-  \n-  result = make_hash_table(r, ht->size, ht->hash, ht->cmp);\n-  hash_table_scan(ht, &hts);\n-  while (hash_table_next(&hts, &k, &d))\n-    insist(hash_table_insert(result, k, d));\n-  \n-  return result;\n-  */\n-}\n-\n-/* Increase size of ht (double it) and reinsert all the elements */\n-static void rehash(hash_table ht) deletes\n-{\n-  int old_table_size, i;\n-  bucket *old_table, cur;\n-  region old_region;\n-\n-#ifdef DEBUG\n-  printf(\"Rehash table size=%d, elts=%d\\n\", ht->size, ht->elts);\n-#endif\n-\n-  old_table_size = ht->size;\n-  old_table = ht->table;\n-  old_region = ht->r;\n-\n-  if (ht->internal_rgn)\n-    ht->r = newregion();\n-\n-  ht->size = ht->size*2;\n-  ht->elts = 0;\n-  ht->table = rarrayalloc(ht->r, ht->size, bucket);\n-\n-  for (i = 0; i < old_table_size; i++)\n-    scan_bucket(old_table[i], cur)\n-      insist(hash_table_insert(ht, cur->key, cur->data));\n-\n-  if (ht->internal_rgn)\n-    deleteregion(old_region);\n-}\n-\n-/* Begin scanning ht */\n-void hash_table_scan(hash_table ht, hash_table_scanner *hts)\n-{\n-  hts->ht = ht;\n-  hts->i = 0;\n-  hts->cur = hts->ht->table[0];\n-}\n-\n-/* Get next elt in table, storing the elt in *k and *d if k and d are\n-   non-NULL, respectively.  Returns TRUE if there is a next elt, FALSE\n-   otherwise. */\n-bool hash_table_next(hash_table_scanner *hts, hash_key *k, hash_data *d)\n-{\n-  while (hts->cur == NULL)\n-    {\n-      hts->i++;\n-      if (hts->i < hts->ht->size)\n-\thts->cur = hts->ht->table[hts->i];\n-      else\n-\tbreak;\n-    }\n-\n-  if (hts->i == hts->ht->size)\n-    {\n-      return FALSE;\n-    }\n-  else\n-    {\n-      if (k)\n-\t*k = hts->cur->key;\n-      if (d)\n-\t*d = hts->cur->data;\n-      hts->cur = hts->cur->next;\n-    }\n-  return TRUE;\n-}\n-\n-/* Apply f to all elements of ht, in some arbitrary order */\n-void hash_table_apply(hash_table ht, hash_apply_fn f, void *arg)\n-{\n-  int i;\n-  bucket cur;\n-\n-  for (i = 0; i < ht->size; i++)\n-    scan_bucket(ht->table[i], cur)\n-      f(cur->key, cur->data, arg);\n-}\n-\n-/* Map f to all elements on ht, creating a new hash table */\n-hash_table hash_table_map(hash_table ht, hash_map_fn f, void *arg)\n-{\n-  int i;\n-  hash_table result;\n-  bucket cur, newbucket, *prev;\n-\n-  result = make_hash_table(ht->r, ht->size, ht->hash, ht->cmp,ht->internal_rgn);\n-  result->elts = ht->elts;\n-  \n-  for (i = 0; i < ht->size; i++)\n-    {\n-      prev = &result->table[i];\n-      scan_bucket(ht->table[i], cur)\n-\t{\n-\t  newbucket = ralloc(ht->r, struct bucket);\n-\t  newbucket->key = cur->key;\n-\t  newbucket->data = f(cur->key, cur->data, arg);\n-\t  newbucket->next = NULL;\n-\t  assert(!*prev);\n-\t  *prev = newbucket;\n-\t  prev = &newbucket->next;\n-\t}\n-    }\n-  return result;\n-  /*\n-  hash_table result;\n-  int i;\n-  bucket cur;\n-\n-  result = make_hash_table(ht->r, ht->size, ht->hash, ht->cmp);\n-  for (i = 0; i < ht->size; i++)\n-    scan_bucket(ht->table[i], cur)\n-      insist(hash_table_insert(result, cur->key, f(cur->key, cur->data, arg)));\n-  return result;\n-  */\n-}\n-\n-static keycmp_fn cur_cmp = NULL;\n-\n-static int entry_cmp(const void *a, const void *b)\n-{\n-  struct sorted_entry *ae = (struct sorted_entry *) a;\n-  struct sorted_entry *be = (struct sorted_entry *) b;\n-  return cur_cmp(ae->k, be->k);\n-}\n-\n-/* Begin scanning ht in sorted order according to f */\n-void hash_table_scan_sorted(hash_table ht, keycmp_fn f,\n-\t\t\t    hash_table_scanner_sorted *htss)\n-{\n-  hash_table_scanner hts;\n-  int i;\n-\n-  htss->r = newregion();\n-  htss->size = hash_table_size(ht);\n-  htss->entries = rarrayalloc(htss->r, htss->size, struct sorted_entry);\n-  htss->i = 0;\n-\n-  hash_table_scan(ht, &hts);\n-  i = 0;\n-  while (hash_table_next(&hts, &htss->entries[i].k,\n-\t\t\t &htss->entries[i].d))\n-    i++;\n-  assert(i == htss->size);\n-  cur_cmp = f;\n-  qsort(htss->entries, htss->size, sizeof(struct sorted_entry), entry_cmp);\n-  cur_cmp = NULL;\n-}\n-\n-/* Just like hash_table_next, but scans in sorted order */\n-bool hash_table_next_sorted(hash_table_scanner_sorted *htss, hash_key *k,\n-\t\t\t    hash_data *d) deletes\n-{\n-  if (htss->i < htss->size)\n-    {\n-      *k = htss->entries[htss->i].k;\n-      *d = htss->entries[htss->i].d;\n-      htss->i++;\n-      return TRUE;\n-    }\n-  else\n-    {\n-      deleteregion(htss->r);\n-      htss->r = NULL;\n-      return FALSE;\n-    }\n-}"}, {"sha": "eb93ac88b316948070b9544c854f046fc71c4693", "filename": "libbanshee/engine/hash.h", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fhash.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,140 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef HASH_H\n-#define HASH_H\n-\n-#include <regions.h>\n-#include \"bool.h\"\n-/*#include \"hash_info.h\"*/ /* Includes hash_key, hash_data typedef */\n-#include \"linkage.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef void *hash_key;\n-typedef void *hash_data;\n-\n-/* Function to hash a key */\n-typedef int (*hash_fn)(hash_key k);\n-\n-/* Function returning true iff k1 and k2 are equal */\n-typedef bool (*keyeq_fn)(hash_key k1, hash_key k2);\n-\n-/* Function applied to elts in the hash table */\n-typedef void (*hash_apply_fn)(hash_key k, hash_data d, void *arg);\n-\n-/* Function mapped to elts in the hash table */\n-typedef hash_data (*hash_map_fn)(hash_key k, hash_data d, void *arg);\n-\n-typedef struct Hash_table *hash_table;\n-\n-/* Make a new hash table, with size buckets initially. */\n-hash_table make_hash_table(region rhash, int size, hash_fn hash,\n-\t\t\t   keyeq_fn cmp, bool internal_rgn);\n-\n-/* Make a hash table for strings. */\n-hash_table make_string_hash_table(region rhash, int size, bool internal_rgn);\n-\n-/* Zero out ht.  Doesn't reclaim bucket space. */\n-void hash_table_reset(hash_table ht) deletes;\n-\n-/* Delete ht and internal memory associated with it. The top level pointer\n- must still be deleted. */\n-void hash_table_delete(hash_table ht) deletes;\n-\n-/* Return the number of entries in ht */\n-int hash_table_size(hash_table ht);\n-\n-\n-/* Lookup k in ht.  If d is not NULL, returns corresponding data in *d.\n-   Function result is TRUE if the k was in ht, false otherwise. */\n-bool hash_table_lookup(hash_table ht, hash_key k, hash_data *d);\n-\n-/* Add k:d to ht.  If k was already in ht, replace old entry by k:d.\n-   Rehash if necessary.  Returns TRUE if k was not already in ht. */\n-bool hash_table_insert(hash_table ht, hash_key k, hash_data d) deletes;\n-\n-/* Remove mapping for k in ht.  Returns TRUE if k was in ht. */\n-bool hash_table_remove(hash_table ht, hash_key k);\n-\n-/* Return a copy of ht, allocated in rhash */\n-hash_table hash_table_copy(region rhash, hash_table ht);\n-\n-/* Apply f to all elements of ht, in some arbitrary order */\n-void hash_table_apply(hash_table ht, hash_apply_fn f, void *arg);\n-\n-/* Map f to all elements on ht, creating a new hash table */\n-hash_table hash_table_map(hash_table ht, hash_map_fn f, void *arg);\n-\n-typedef struct bucket *bucket;\n-typedef struct\n-{\n-  hash_table ht;\n-  int i;\n-  bucket cur;\n-} hash_table_scanner; /* Opaque type!  Do not modify fields. */\n-\n-/* Begin scanning ht */\n-void hash_table_scan(hash_table ht, hash_table_scanner *);\n-\n-/* Get next elt in table, storing the elt in *k and *d if k and d are\n-   non-NULL, respectively.  Returns TRUE if there is a next elt, FALSE\n-   otherwise. */\n-bool hash_table_next(hash_table_scanner *, hash_key *k, hash_data *d);\n-\n-/* Total order on hash table keys, only uesd for hash_table_scan_sorted */\n-typedef int (*keycmp_fn)(hash_key k1, hash_key k2);\n-\n-struct sorted_entry\n-{\n-  hash_key k;\n-  hash_data d;\n-};\n-\n-typedef struct\n-{\n-  region r;\n-  int i;\n-  int size;\n-  struct sorted_entry *entries;\n-} hash_table_scanner_sorted;\n-\n-/* Begin scanning ht in sorted order according to f */\n-void hash_table_scan_sorted(hash_table ht, keycmp_fn f,\n-\t\t\t    hash_table_scanner_sorted *htss);\n-\n-/* Just like hash_table_next, but scans in sorted order */\n-bool hash_table_next_sorted(hash_table_scanner_sorted *htss, hash_key *k,\n-\t\t\t    hash_data *d) deletes;\n-\n-\n-EXTERN_C_END\n-\n-#endif"}, {"sha": "27195e767bdca66d44712060f51e792ce0d8d5e4", "filename": "libbanshee/engine/hashset.c", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhashset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhashset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fhashset.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,217 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdlib.h>\n-#include <assert.h>\n-#include <math.h>\n-\n-#include \"hashset.h\"\n-#include \"util.h\"\n-#define INIT_TABLE_SIZE 2\n-#define EMPTY_KEY 0\n-#define UB(n) ((1<<n)-1) /* 2^n-1 */\n-#define CAP(n) (1<<n)   /* 2^n */\n- \n-struct hash_set\n-{\n-  int *traditional table;\n-  unsigned int ub;\n-  unsigned int capacity;\n-  unsigned int inserts;\n-  unsigned int size;\n-};\n-\n-static const int prime_1 = 83;\n-static const int prime_2 = 5189;\n-static const int init_table_size = INIT_TABLE_SIZE;\n-static const int empty_key = EMPTY_KEY;\n-\n-hash_set hs_create(region r)\n-{\n-      \n-  hash_set hs = ralloc(r, struct hash_set);\n-    \n-  hs->ub = UB(init_table_size);\n-  hs->size = init_table_size;\n-  hs->capacity = CAP(init_table_size);\n-  hs->table = (int *)calloc(hs->capacity, sizeof(int));\n-  hs->inserts = 0;\n-  return hs;\n-}\n-\n-int hs_num_items(hash_set hs)\n-{\n-  return hs->inserts;\n-}\n-\n-int *hs_list_items(hash_set hs)\n-{\n-  return hs->table;\n-}\n-\n-static bool member(int *table, int ub, int i, int value)\n-{\n-  while (table[i] != empty_key)\n-    {\n-      if (table[i] == value)\n-\treturn TRUE;\n-      \n-      else\n-\ti = ub & (i + prime_2);\n-    }\n-  return FALSE;\n-}\n-\n-static inline void reinsert(int *table, int ub, int value)\n-{\n-  int i;\n-\n-  i = ub & (prime_1 * value);\n-\n-  while (table[i] != empty_key)\n-    {\n-      /* possibly the value is already present */ \n-      if (table[i] == value)\n-\treturn;\n-      \n-      else\n-\ti = ub & (i + prime_2);\n-    }\n-\n-  table[i] = value;\n-}\n-\n-static bool member_or_insert(int *table, int ub, int i, int value)\n-{\n-  while (table[i] != empty_key)\n-    {\n-      if (table[i] == value)\n-\treturn TRUE;\n-      \n-      else\n-\ti = ub & (i + prime_2);\n-    }\n-  table[i] = value;\n-  return FALSE;\n-}\n-\n-static void rehash(hash_set hs)\n-{\n-  int *old_table;\n-  int old_capacity, i;\n-\n-  old_table = hs->table;\n-  old_capacity = hs->capacity;\n-  hs->capacity *= 2;\n-  hs->ub = UB(++hs->size);\n-  hs->table = (int *)calloc(hs->capacity, sizeof(int));\n-  assert(hs->table);\n-  \n-  \n-  for (i = 0; i < old_capacity; i++)\n-    {\n-      reinsert(hs->table, hs->ub, old_table[i]);\n-    }\n-\n-  free(old_table);\n-}\n-/*\n-static void post_insert(hash_set hs)\n-{\n-  float percent_full;\n-\n-  int capacity = hs->capacity;\n-  int inserts = ++hs->inserts;\n-\n-  printf(\"%d,%d->%f\\n\",inserts,capacity,percent_full);\n-  assert(capacity);\n-  percent_full = (float) inserts / capacity;\n-\n- \n-  if (percent_full != percent_full)\n-    {\n-      assert (0);\n-    }\n-\n-  if (percent_full >= .85)\n-    rehash(hs);\n-}\n-*/\n-\n-static void post_insert(hash_set hs)\n-{\n-  int capacity = hs->capacity;\n-  int inserts = ++hs->inserts;\n-\n-  float percent_capacity = capacity * .85;\n- \n- /*\n-  printf(\"%d,%d->%f\\n\",inserts,capacity,percent_capacity);\n- */\n-\n-  if ( (float) inserts >= percent_capacity)\n-    {\n-      rehash(hs);\n-    }\n-\n-}\n-\n-\n-bool hs_query(hash_set hs, int entry)\n-{\n-  int hash;\n-  int ub = hs->ub;\n-\n-  hash = ub & (prime_1 * abs(entry));\n-  return member(hs->table, ub, hash, entry);\n-}\n-\n-bool hs_member(hash_set hs, int entry)\n-{\n-  int hash;\n-  int ub = hs->ub;\n-\n-  hash = ub & (prime_1 * abs(entry));\n-  if (member_or_insert(hs->table, ub, hash, entry))\n-    return TRUE;\n-  \n-  else\n-    {\n-      post_insert(hs);\n-      return FALSE;\n-    }\n-}\n-\n-void hs_delete(hash_set hs)\n-{\n-  free(hs->table);\n-}\n-\n-"}, {"sha": "0b06cd0a657a49fdbc3b87d250edcb86e5e6d381", "filename": "libbanshee/engine/hashset.h", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhashset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fhashset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fhashset.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,50 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef HASHSET_H\n-#define HASHSET_H\n-\n-#include \"linkage.h\"\n-#include \"banshee.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct hash_set *hash_set;\n-\n-hash_set hs_create(region r);\n-void hs_delete(hash_set);\n-bool hs_member(hash_set,int); /* adds the entry if not present */\n-bool hs_query(hash_set,int);  /* query only */\n-int *hs_list_items(hash_set); \n-int hs_num_items(hash_set);\n-\n-EXTERN_C_END\n-\n-#endif /* HASHSET_H */"}, {"sha": "8df072c8c8dd60337d85bf11f16d11e2adc1e05f", "filename": "libbanshee/engine/jcollection.c", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fjcollection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fjcollection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fjcollection.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,326 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <assert.h>\n-#include \"jcollection.h\"\n-#include \"hashset.h\"\n-#include \"termhash.h\"\n-\n-\n-/* \n-   static term_hash jcoll_hash;\n- */\n-\n-struct jcoll_dict\n-{\n-  region r;\n-  term_hash hash; \n-  get_stamp_fn_ptr get_stamp;\n-};\n-\n-enum jcoll_type\n-{\n-  j_single,\n-  j_chain,\n-  j_join\n-};\n-\n-/* generic jcoll type */ \n-struct jcoll\n-{\n-  enum jcoll_type type;\n-  stamp st;\n-};\n-\n-struct jcoll_single\n-{\n-  enum jcoll_type type;\n-  stamp st;\n-  gen_e entry;\n-};\n-\n-struct jcoll_chain\n-{\n-  enum jcoll_type type;\n-  stamp st;\n-  gen_e_list sameregion entries;\n-};\n-\n-struct jcoll_join\n-{\n-  enum jcoll_type type;\n-  stamp st;\n-  jcoll_list sameregion joins;\n-  gen_e_list sameregion cache;\n-};\n-\n-typedef struct jcoll_single *jcoll_single;\n-typedef struct jcoll_chain *jcoll_chain;\n-typedef struct jcoll_join *jcoll_join;\n-\n-DEFINE_LIST(jcoll_list,jcoll)\n-\n-\n-\n-jcoll jcoll_new(jcoll_dict d, gen_e e)\n-{\n-  jcoll_single result = ralloc(d->r, struct jcoll_single);\n-  result->type = j_single;\n-  result->st = stamp_fresh();\n-  result->entry = e;\n-  return (jcoll)result;\n-}\n-\n-jcoll jcoll_jjoin(jcoll_dict d,jcoll_list list)\n-{\n-\n-  if (jcoll_list_empty(list))\n-    return NULL;\n-  else if (jcoll_list_length(list) == 1)\n-    return jcoll_list_head(list);\n-\n-  else\n-    {\n-      int i = 0,\n-\tlength = jcoll_list_length(list) + 1;\n-      stamp sts[length];\n-      jcoll_join result;\n-      \n-      jcoll_list_scanner scan;\n-      jcoll temp;\n-      \n-      sts[i++] = j_join;\n-\n-      jcoll_list_scan(list,&scan);\n-      while (jcoll_list_next(&scan,&temp))\n-\t{\n-\t  stamp st = temp ? temp->st : 0;\n-\t  sts[i++] = st;\n-\t}\n-      qsort(&sts[1],length-1,sizeof(int),ptr_cmp);\n-      \n-      if ( NULL == (result = (jcoll_join)term_hash_find(d->hash,sts,length)) )\n-\t{\n-\t  result = ralloc(d->r,struct jcoll_join);\n-\t  \n-\t  result->type = j_join;\n-\t  result->st = stamp_fresh();\n-\t  result->joins = list;\n-\t  result->cache = new_gen_e_list(d->r);\n-\t  term_hash_insert(d->hash,(gen_e)result,sts,length);\n-\t}\n-      return (jcoll)result;\n-    }\n-\n-}\n-\n-/*\n-  Hash chains \n- */\n-jcoll jcoll_create_chain(jcoll_dict d, gen_e_list elems)\n-{\n-  int i = 0,\n-    length = gen_e_list_length(elems) + 1;\n-  stamp sts[length];\n-  gen_e_list_scanner scan;\n-  gen_e temp;\n-  jcoll_chain result;\n-\n-  sts[i++] = j_chain; \n-  \n-  gen_e_list_scan(elems,&scan);\n-  while (gen_e_list_next(&scan,&temp))\n-    {\n-      sts[i++] = d->get_stamp(temp);\n-    }\n-  qsort(&sts[1],length-1,sizeof(int),ptr_cmp); /* FIX, first pos should always be chain */\n-\n-  if ( NULL == (result = (jcoll_chain)term_hash_find(d->hash,sts,length)) )\n-    {\n-      result = ralloc(d->r,struct jcoll_chain);\n-      result->type = j_chain;\n-      result->st = stamp_fresh();\n-      result->entries = elems;\n-      term_hash_insert(d->hash,(gen_e)result,sts,\n-\t\t       length);\n-    }\n-  return (jcoll)result;\n-}\n-\n-typedef void (*japp_fn_ptr) (void *, void *);\n-\n-static void app_aux(hash_set h, get_stamp_fn_ptr get_stamp, japp_fn_ptr app,\n-\t\t    jcoll j, void *data)\n-{\n-  if (! j)\n-    return;\n-\n-  switch(j->type)\n-    {\n-    case j_single:\n-      {\n-\tjcoll_single single = (jcoll_single) j;\n-\t\n-\tif (! hs_member(h,get_stamp(single->entry)) )\n-\t    app(single->entry, data);\n-      }\n-      break;\n-    case j_chain:\n-      {\n-\tjcoll_chain chain = (jcoll_chain) j;\n-\n-\tif (! hs_member(h,chain->st) )\n-\t  {\n-\t    gen_e_list_scanner scan;\n-\t    gen_e entry;\n-\t    \n-\t    gen_e_list_scan(chain->entries, &scan);\n-\t    while (gen_e_list_next(&scan, &entry))\n-\t      {\n-\t\tif (! hs_member(h, get_stamp(entry)) )\n-\t\t  app(entry, data);\n-\t      }\n-\t\t\t\t   \n-\t  }\n-\t\n-      }\n-      break;\n-    case j_join:\n-      {\n-\tjcoll_join join = (jcoll_join) j;\n-\n-\tif (! hs_member(h, join->st))\n-\t  {\n-\t    if (! gen_e_list_empty(join->cache))\n-\t      {\n-\t\t  gen_e_list_scanner scan;\n-\t\t  gen_e entry;\n-\t    \n-\t\t  gen_e_list_scan(join->cache, &scan);\n-\t\t  while (gen_e_list_next(&scan, &entry))\n-\t\t    {\n-\t\t      if (! hs_member(h, get_stamp(entry)) )\n-\t\t\tapp(entry, data);\n-\t\t    }\n-\t      }\n-\t    else \n-\t      {\n-\t\tjcoll_list_scanner scan;\n-\t\tjcoll temp;\n-\n-\t\tjcoll_list_scan(join->joins, &scan);\n-\t\twhile (jcoll_list_next(&scan,&temp))\n-\t\t  {\n-\t\t    app_aux(h,get_stamp,app,temp, data);\n-\t\t  }\n-\n-\t      }\n-\t  }\n-\n-      }\n-      break;\n-    }\n-\n-}\n-\n-static void jcoll_app(jcoll_dict d, japp_fn_ptr app, jcoll j, void *data) deletes\n-{\n-  region scratch_rgn = newregion();\n-  hash_set hash = hs_create(scratch_rgn);\n-  app_aux(hash,d->get_stamp, app, j, data);\n-  hs_delete(hash);\n-  deleteregion(scratch_rgn);\n-}\n-  static void jcoll_accum(void *e, void *accum)\n-    {\n-      gen_e_list_cons((gen_e) e, (gen_e_list) accum);\n-    }\n-\n-gen_e_list jcoll_flatten(jcoll_dict d, jcoll j) deletes\n-{\n-  \n-  gen_e_list accum = NULL;\n-  \n-  \n-  if (j == NULL)\n-    return new_gen_e_list(d->r);\n-\n-  switch (j->type)\n-    {\n-    case j_single:\n-      {\n-\tjcoll_single single = (jcoll_single)j;\n-\t\n-\taccum = new_gen_e_list(d->r);\n-\tgen_e_list_cons(single->entry,accum);\n-      }\n-      break;\n-    case j_chain:\n-      {\n-\tjcoll_chain chain = (jcoll_chain)j;\n-\t/* accum = gen_e_list_copy(r,chain->entries); */\n-\taccum = chain->entries;\n-      }\n-      break;\n-    case j_join:\n-      {\n-\tjcoll_join join = (jcoll_join)j;\n-\t\n-\tif (! gen_e_list_empty(join->cache))\n-\t  return join->cache;\n-\telse\n-\t  {\n-\t    accum = new_gen_e_list(d->r);\n-\t    jcoll_app(d, jcoll_accum,j, accum);\n-\t    \n-\t    gen_e_list_append(join->cache,accum /* gen_e_list_copy(r,accum)*/);\n-\t  }\n-      }\n-      break;\n-    }\n-\n-  return accum;\n-}\n-\n-jcoll_dict jcoll_create_dict(region r,get_stamp_fn_ptr get_stamp)\n-{\n-  jcoll_dict result = ralloc(r,struct jcoll_dict);\n-\n-  result->r = r;\n-  result->hash = make_term_hash(r);\n-  result->get_stamp = get_stamp;\n-  return result;\n-}\n-\n-\n-void jcoll_delete_dict(jcoll_dict d)\n-{\n-  term_hash_delete(d->hash);\n-}"}, {"sha": "b1f0e717d4e1f03d6929a388be65f76956934f8b", "filename": "libbanshee/engine/jcollection.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fjcollection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fjcollection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fjcollection.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,63 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef JCOLLECTION_H\n-#define JCOLLECTION_H\n-\n-#include \"linkage.h\"\n-#include \"banshee.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct jcoll *jcoll;\n-\n-typedef struct jcoll_dict *jcoll_dict;\n-\n-DECLARE_LIST(jcoll_list,jcoll)\n-\n-jcoll jcoll_new(jcoll_dict d, gen_e e);\n-jcoll jcoll_jjoin(jcoll_dict d, jcoll_list list);\n-gen_e_list jcoll_flatten(jcoll_dict d, jcoll j) deletes;\n-jcoll jcoll_create_chain(jcoll_dict d, gen_e_list elems);\n-\n-jcoll_dict jcoll_create_dict(region r,get_stamp_fn_ptr get_stamp);\n-void jcoll_delete_dict(jcoll_dict d);\n-\n-EXTERN_C_END\n-\n-#endif /* JCOLLECTION_H */\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "ef70bbe24685b883235f2c6bd94896274ef78fe7", "filename": "libbanshee/engine/linkage.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Flinkage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Flinkage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Flinkage.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,44 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef LINKAGE_H\n-#define LINKAGE_H\n-\n-#ifdef __cplusplus\n-# define EXTERN_C extern \"C\"\n-# define EXTERN_C_BEGIN extern \"C\" {\n-# define EXTERN_C_END }\n-#else\n-# define EXTERN_C\n-# define EXTERN_C_BEGIN\n-# define EXTERN_C_END\n-#endif\n-\n-#endif "}, {"sha": "3972e2dd9044b709226b3e60f8de4b926cc47949", "filename": "libbanshee/engine/list.c", "status": "removed", "additions": 0, "deletions": 438, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Flist.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Flist.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Flist.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,438 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <assert.h>\n-#include \"list.h\"\n-#include \"util.h\"\n-\n-struct list_node\n-{  \n-  void *data;\n-  struct list_node *sameregion next;\n-};\n-\n-#define scan_node(b,var) for (var = b; var; var = var->next)\n-\n-struct list \n-{\n-  region sameregion r;\n-  int length;\n-  list_node sameregion head;\n-};\n-\n-struct list *new_list(region r)\n-{\n-  struct list *result;\n-\n-  assert(r);\n-  \n-  result = ralloc(r,struct list);\n-  result->r = r;\n-  result->length = 0;\n-  result->head = NULL;\n-  \n-  return result;\n-}\n-\n-int list_size(struct list *l)\n-{\n-  return l->length;\n-}\n-\n-struct list *list_cons(void *data, struct list *l)\n-{\n-  list_node newnode = ralloc(l->r, struct list_node);\n-  newnode->next = l->head;\n-  newnode->data = data;\n-  \n-  l->head = newnode;\n-  l->length++;\n-\n-  return l;\n-}\n-\n-struct list *list_reverse(struct list *l)\n-{\n-\n-  if (list_empty(l))\n-    return l;\n-\n-  else\n-    {\n-      list_node temp,reversed = NULL; \n-\n-      while (l->head)\n-\t{\n-\t  temp = l->head->next;\n-\t  \n-\t  l->head->next = reversed;\n-\t  \n-\t  reversed = l->head;\n-\n-\t  l->head = temp;\n-\t}\n-\n-      l->head = reversed;\n-      return l;\n-    }\n-\n-}\n-\n-bool list_empty(struct list *l)\n-{\n-  return (l->head == NULL);\n-}\n-\n-static inline list_node tail(list_node n)\n-{\n-  if (n == NULL)\n-    return NULL;\n-  else \n-    {\n-      list_node temp = NULL,\n-\ttail = NULL;\n-      \n-      scan_node(n,temp)\n-\ttail = temp;\n-      \n-      assert(tail && tail->next == NULL);\n-      \n-      return tail;\n-    }\n-}\n-\n-struct list *list_append(struct list *a, struct list *b)\n-{\n-  list_node tl;\n-\n-  assert( a && b );\n-  assert( a != b);\n-  assert( ptr_eq(a->r,b->r) );\n-\n-  tl = tail(a->head);\n-\n-  \n-  if (! tl)\n-    {\n-      a->head = b->head;\n-      a->length = b->length;\n-    } \n-  \n-  else\n-    {\n-      tl->next = b->head;\n-      a->length += b->length;\n-    }\n-  return a;\n-}\n-\n-struct list *list_app(struct list *l,app_fn app)\n-{\n-  list_node n = NULL;\n-\n-  \n-  assert(l);\n-  \n-  scan_node(l->head,n)\n-    {\n-      app(n->data);\n-    }\n-  return l;\n-}\n-\n-void *list_find(struct list *l,eq_fn eq)\n-{\n-  list_node n = NULL;\n-  assert(l);\n-  \n-  scan_node(l->head,n)\n-    {\n-      if (eq(n->data))\n-\treturn n;\n-    }\n-  \n-  return NULL;\n-}\n-\n-struct list *list_tail(struct list *l)\n-{\n-  l->length--;\n-  l->head = l->head->next;\n-  return l;\n-}\n-\n-void *list_head(struct list *l)\n-{\n-  return l->head->data;\n-}\n-\n-struct list *list_filter(region r,struct list *l,eq_fn eq)\n-{\n-  struct list *result;\n-  list_node n = NULL;\n-  assert(l);\n-\n-  result = new_list(r);\n-  \n-  scan_node(l->head,n)\n-    {\n-      if (eq(n->data))\n-\tlist_cons(n->data,result);\n-    }\n-  \n-  return result;\n-}\n-\n-struct list *list_keep(struct list *l, eq_fn eq)\n-{\n-  list_node prev, n;\n-  assert(l);\n-\n-  while (l->head && !eq(l->head->data))\n-    {\n-      l->head = l->head->next;\n-    }\n-\n-  prev = l->head;\n-  scan_node(l->head->next,n)\n-    {\n-      if (!eq(n->data))\n-\t  prev->next = n->next;\n-      else prev = n;\n-    }\n-  return l;\n-}\n-\n-struct list *list_filter2(struct list *l,eq_fn eq)\n-{\n-  return list_filter(l->r,l,eq);\n-}\n-\n-struct list *list_copy(region r, struct list *l)\n-{\n-\n-  struct list *result;\n-  list_node n = NULL;\n-#ifndef NDEBUG\n-  int count = 0;\n-#endif  \n-  assert(l);\n-\n-  result = new_list(r);\n-  \n-  scan_node(l->head,n)\n-    {\n-      list_cons(n->data,result);\n-      assert(++count <= l->length);\n-    }\n- \n-  return list_reverse(result);\n-}\n-/* A Linked-List Memory Sort\n-   by Philip J. Erdelsky\n-   pje@acm.org\n-   http://www.alumni.caltech.edu/~pje/\n-*/\n-\n-#include <stdio.h>\n-\n-static void *sort_linked_list(void *p, unsigned index,\n-  int (*compare)(const void *,const void *, comparator_fn), long *pcount, comparator_fn data)\n-{\n-  unsigned base;\n-  unsigned long block_size;\n-\n-  struct record\n-  {\n-    struct record *next[1];\n-    /* other members not directly accessed by this function */\n-  };\n-\n-  struct tape\n-  {\n-    struct record *first, *last;\n-    unsigned long count;\n-  } tape[4];\n-\n-  /* Distribute the records alternately to tape[0] and tape[1]. */\n-\n-  tape[0].count = tape[1].count = 0L;\n-  tape[0].first = NULL;\n-  base = 0;\n-  while (p != NULL)\n-  {\n-    struct record *next = ((struct record *)p)->next[index];\n-    ((struct record *)p)->next[index] = tape[base].first;\n-    tape[base].first = ((struct record *)p);\n-    tape[base].count++;\n-    p = next;\n-    base ^= 1;\n-  }\n-\n-  /* If the list is empty or contains only a single record, then */\n-  /* tape[1].count == 0L and this part is vacuous.               */\n-\n-  for (base = 0, block_size = 1L; tape[base+1].count != 0L;\n-    base ^= 2, block_size <<= 1)\n-  {\n-    int dest;\n-    struct tape *tape0, *tape1;\n-    tape0 = tape + base;\n-    tape1 = tape + base + 1;\n-    dest = base ^ 2;\n-    tape[dest].count = tape[dest+1].count = 0;\n-    for (; tape0->count != 0; dest ^= 1)\n-    {\n-      unsigned long n0, n1;\n-      struct tape *output_tape = tape + dest;\n-      n0 = n1 = block_size;\n-      while (1)\n-      {\n-        struct record *chosen_record;\n-        struct tape *chosen_tape;\n-        if (n0 == 0 || tape0->count == 0)\n-        {\n-          if (n1 == 0 || tape1->count == 0)\n-            break;\n-          chosen_tape = tape1;\n-          n1--;\n-        }\n-        else if (n1 == 0 || tape1->count == 0)\n-        {\n-          chosen_tape = tape0;\n-          n0--;\n-        }\n-        else if ((*compare)(tape0->first, tape1->first, data) > 0)\n-        {\n-          chosen_tape = tape1;\n-          n1--;\n-        }\n-        else\n-        {\n-          chosen_tape = tape0;\n-          n0--;\n-        }\n-        chosen_tape->count--;\n-        chosen_record = chosen_tape->first;\n-        chosen_tape->first = chosen_record->next[index];\n-        if (output_tape->count == 0)\n-          output_tape->first = chosen_record;\n-        else\n-          output_tape->last->next[index] = chosen_record;\n-        output_tape->last = chosen_record;\n-        output_tape->count++;\n-      }\n-    }\n-  }\n-\n-  if (tape[base].count > 1L)\n-    tape[base].last->next[index] = NULL;\n-  if (pcount != NULL)\n-    *pcount = tape[base].count;\n-  return tape[base].first;\n-}\n-\n-\n-\n-static int compare(const void *node1, const void *node2, comparator_fn data)\n-{\n-   comparator_fn cmp = (comparator_fn) data;\n-   return cmp(((struct list_node *)node1)->data,\n-\t      ((struct list_node *)node2)->data);\n-}\n-\n-struct list *list_sort(struct list *l, comparator_fn cmp)\n-{\n-  long pcount;\n-  l->head = sort_linked_list(l->head,1,compare,&pcount, cmp);\n-  assert(pcount == l->length);\n-  return l;\n-}\n-\n-struct list *list_merge(struct list *a,struct list *b, comparator_fn cmp)\n-{\n-  return list_sort( list_append(a,b),cmp);\n-}\n-\n-void list_scan(struct list *a,struct list_scanner *scan)\n-{ \n-  scan->l = a;\n-  scan->cur = a->head;\n-}\n-\n-bool list_next(struct list_scanner *scan, void **data)\n-{\n-  if (!scan->cur)\n-    return FALSE;\n-  else\n-    {\n-      if (data)\n-\t*data = scan->cur->data;\n-      scan->cur = scan->cur->next;\n-      return TRUE;\n-    }\n-}\n-\n-void list_clear(struct list *l)\n-{ \n-  l->head = NULL;\n-  l->length = 0;\n-}\n-\n-bool list_member(struct list *l,void *data)\n-{\n-  list_node n = NULL;\n-  scan_node(l->head,n)\n-    {\n-      if (n->data == data)\n-\treturn TRUE;\n-    }\n-  return FALSE;\n-}\n-\n-\n-struct list *list_from_array(region r,void **data, int length)\n-{\n-  struct list *result = new_list(r);\n-  int i;\n-  \n-  for (i = length -1; i >= 0; i--)\n-    {\n-      list_cons(data[i],result);\n-    }\n-  return result;\n-}\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "1dfae50c0f1d67b55696fc58d2cb9e9ed311e84b", "filename": "libbanshee/engine/list.h", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Flist.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,216 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef LIST_H\n-#define LIST_H\n-\n-#include <regions.h>\n-#include \"bool.h\"\n-\n-typedef void *list_data;\n-typedef void (*app_fn) (void *);\n-typedef bool (*eq_fn)(const void *);\n-typedef int (*comparator_fn)(const void *,const void *);\n-\n-struct list;\n-\n-typedef struct list_node *list_node;\n-\n-struct list_scanner\n-{\n-  struct list *l;\n-  list_node cur;\n-}; /* Opaque type. Do not modify fields */\n-\n-\n-struct list *new_list(region r);\n-int list_size(struct list *a);\n-struct list *list_cons(void *data, struct list *a);\n-struct list *list_append(struct list *a, struct list *b);\n-struct list *list_app(struct list *a,app_fn app);\n-void *list_find(struct list *a,eq_fn eq);\n-void *list_head(struct list *a);\n-struct list *list_tail(struct list *a);\n-struct list *list_filter(region r,struct list *a,eq_fn eq);\n-struct list *list_filter2(struct list *a,eq_fn eq);\n-struct list *list_keep(struct list *a,eq_fn eq);\n-struct list *list_copy(region r, struct list *a);\n-struct list *list_sort(struct list *a, comparator_fn cmp);\n-struct list *list_merge(struct list *a,struct list *b, comparator_fn cmp);\n-void list_scan(struct list *a,struct list_scanner *scan);\n-bool list_next(struct list_scanner *scan, void **data);\n-bool list_empty(struct list *a);\n-bool list_member(struct list *a, void *data);\n-void list_clear(struct list *a);\n-struct list *list_reverse(struct list *a);\n-struct list *list_from_array(region r,void **data, int length);\n-\n-#define DECLARE_OPAQUE_LIST(name,type) \\\n-typedef struct list_scanner name ## _scanner; \\\n-typedef void (* name ## _app_fn) (type); \\\n-typedef bool (* name ## _eq_fn) (const type); \\\n-typedef int (* name ## _comparator_fn)(const type,const type); \\\n-name new_ ## name(region r); \\\n-int name ## _length(name a); \\\n-name name ## _cons(type data, name a); \\\n-name name ## _append(name a, name b); \\\n-name name ## _app(name a, name ## _app_fn app); \\\n-type name ## _find(name a, name ## _eq_fn eq); \\\n-type name ## _head(name a); \\\n-name name ## _tail(name a); \\\n-name name ## _filter(region r,name a, name ## _eq_fn eq); \\\n-name name ## _filter2(name a, name ## _eq_fn eq); \\\n-name name ## _keep(name a, name ## _eq_fn eq); \\\n-name name ## _copy(region r, name a); \\\n-name name ## _sort(name a, name ## _comparator_fn cmp); \\\n-name name ## _merge(name a,name b, name ## _comparator_fn cmp); \\\n-void name ## _scan(name a, name ##_scanner *scan); \\\n-bool name ## _next(name ##_scanner *scan, type *data); \\\n-bool name ## _empty(name a); \\\n-void name ## _clear(name a); \\\n-bool name ## _member(name a, type data); \\\n-name name ## _reverse(name a); \\\n-name name ## _from_array(region r,type data[], int length);\n-\n-#define DECLARE_LIST(name,type) \\\n-typedef struct name ## _a *name; \\\n-typedef struct list_scanner name ## _scanner; \\\n-typedef void (* name ## _app_fn) (type); \\\n-typedef bool (* name ## _eq_fn) (const type); \\\n-typedef int (* name ## _comparator_fn)(const type,const type); \\\n-name new_ ## name(region r); \\\n-int name ## _length(name a); \\\n-name name ## _cons(type data, name a); \\\n-name name ## _append(name a, name b); \\\n-name name ## _app(name a, name ## _app_fn app); \\\n-type name ## _find(name a, name ## _eq_fn eq); \\\n-type name ## _head(name a); \\\n-name name ## _tail(name a); \\\n-name name ## _filter(region r,name a, name ## _eq_fn eq); \\\n-name name ## _filter2(name a, name ## _eq_fn eq); \\\n-name name ## _keep(name a, name ## _eq_fn eq); \\\n-name name ## _copy(region r, name a); \\\n-name name ## _sort(name a, name ## _comparator_fn cmp); \\\n-name name ## _merge(name a,name b, name ## _comparator_fn cmp); \\\n-void name ## _scan(name a, name ##_scanner *scan); \\\n-bool name ## _next(name ##_scanner *scan, type *data); \\\n-bool name ## _empty(name a); \\\n-void name ## _clear(name a); \\\n-bool name ## _member(name a, type data); \\\n-name name ## _reverse(name a); \\\n-name name ## _from_array(region r,type data[], int length);\n-\n-#define DEFINE_LIST(name,type) \\\n-name new_ ## name(region r) \\\n-{ \\\n- return (name)new_list(r);  \\\n-} \\\n-int name ## _length(name a) \\\n-{ \\\n- return list_size((struct list *)a); \\\n-} \\\n-name name ## _cons(type data, name a) \\\n-{ \\\n- return (name)list_cons((void *)data,(struct list *) a ); \\\n-}\\\n-name name ## _append(name a, name b) \\\n-{ \\\n- return (name)list_append((struct list *)a,(struct list *)b);  \\\n-} \\\n-name name ## _app(name a, name ## _app_fn app) \\\n-{ \\\n- return (name)list_app((struct list *) a, (app_fn) app); \\\n-} \\\n-type name ## _find(name a, name ## _eq_fn eq) \\\n-{ \\\n- return (type)list_find((struct list *)a, (eq_fn) eq); \\\n-} \\\n-name name ## _tail(name a) \\\n-{\\\n- return (name)list_tail((struct list *)a);\\\n-}\\\n-type name ## _head(name a) \\\n-{ \\\n- return (type)list_head((struct list *)a); \\\n-} \\\n-name name ## _filter(region r,name a, name ## _eq_fn eq) \\\n-{ \\\n- return (name)list_filter(r,(struct list *)a, (eq_fn) eq); \\\n-} \\\n-name name ## _keep(name a, name ## _eq_fn eq) \\\n-{ \\\n- return (name)list_keep((struct list *)a, (eq_fn) eq); \\\n-} \\\n-name name ## _filter2(name a, name ## _eq_fn eq) \\\n-{ \\\n- return (name)list_filter2((struct list *)a, (eq_fn) eq); \\\n-} \\\n-name name ## _copy(region r, name a) \\\n-{ \\\n- return (name)list_copy(r,(struct list *) a); \\\n-} \\\n-name name ## _sort(name a, name ## _comparator_fn cmp) \\\n-{ \\\n- return (name)list_sort((struct list *)a,(comparator_fn) cmp); \\\n-} \\\n-name name ## _merge(name a,name b, name ## _comparator_fn cmp) \\\n-{ \\\n- return (name)list_merge((struct list *)a,(struct list *)b,(comparator_fn)cmp); \\\n-} \\\n-void name ## _scan(name a, name ##_scanner *scan) \\\n-{ \\\n- list_scan((struct list *)a,(struct list_scanner *)scan);\\\n-}\\\n-bool name ## _next(name ##_scanner *scan, type *data) \\\n-{ \\\n- return list_next((struct list_scanner *)scan, (void **)data); \\\n-} \\\n-bool name ## _empty(name a) \\\n-{ \\\n- return list_empty((struct list *)a); \\\n-} \\\n-void name ## _clear(name a) \\\n-{ \\\n- list_clear((struct list *)a); \\\n-} \\\n-bool name ## _member(name a, type data) \\\n-{ \\\n- return list_member((struct list *)a,(void *)data); \\\n-} \\\n-name name ## _reverse(name a) \\\n-{\\\n- return (name)list_reverse((struct list *)a);\\\n-}\\\n-name name ## _from_array(region r,type data[], int length) \\\n-{\\\n- return (name)list_from_array(r,(void **)data,length); \\\n-}\\\n-\n-#endif /* LIST_H */"}, {"sha": "84facdb01603aa22e18ac1c5c1d3ac47119840c5", "filename": "libbanshee/engine/malloc.c", "status": "removed", "additions": 0, "deletions": 5400, "changes": 5400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fmalloc.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "96e0652d2cb2d73d95d6958697811dd16de9dbdd", "filename": "libbanshee/engine/nonspec.c", "status": "removed", "additions": 0, "deletions": 852, "changes": 852, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fnonspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fnonspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fnonspec.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,852 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include \"banshee.h\"\n-#include \"flowrow-sort.h\"\n-#include \"flowrow-var.h\"\n-#include \"setif-sort.h\"\n-#include \"setif-var.h\"\n-#include \"setst-sort.h\"\n-#include \"setst-var.h\"\n-#include \"term-sort.h\"\n-#include \"term-var.h\"\n-\n-struct constructor\n-{\n-  sort_kind sort;\n-  int type;\n-  int arity;\n-  char *name;\n-  sig_elt *sig;\n-};\n-\n-typedef struct constructor *constructor;\n-\n-typedef enum \n-{\n-  vnc_pos,\n-  vnc_neg,\n-  vnc_non\n-} vnc_kind;\n-\n-struct sig_elt\n-{\n-  vnc_kind variance;\n-  sort_kind sort;\n-};\n-\n-typedef struct sig_elt sig_elt;\n-\n-typedef struct proj_pat\n-{\n-  sort_kind sort;\n-  int type;\n-  stamp st;\n-  int i;\n-  gen_e exp;\n-  vnc_kind variance;\n-  constructor c;\n-} *proj_pat;\n-\n-\n-typedef struct cons_expr  \n-{\n-  sort_kind sort;\n-  int type;\n-  stamp st;\n-  int arity;\n-  char *name;\n-  sig_elt *sig;\n-  gen_e *exps;\n-} * cons_expr;\n-\n-\n-static int new_type()\n-{\n-  static int type = 10;\n-  int ret = type;\n-  if (type > 2000)\n-    {\n-      fprintf(stderr, \"Exceeded maximum number of constructors\\n\");\n-      assert(0);\n-    }\n-  type += 2;\n-  return ret;\n-}\n-\n-static bool fixed_sort(sort_kind s)\n-{\n-  return !(s == sort_term || s == sort_set);\n-}\n-\n-/* \n-   Convention : constructor types are even, pats are odd.\n-   The smallest specialized type is 10.\n-*/\n-static bool setif_is_pat(gen_e e)\n-{\n-  int type = ((setif_term)e)->type;\n-  return ( (type & 1) && (type > 10) );\n-}\n-\n-static bool setst_is_pat(gen_e e)\n-{\n-  int type = ((setst_term)e)->type;\n-  return ( (type & 1) && (type > 10) );\n-}\n-\n-static gen_e get_proj_var(sort_kind s, bool large)\n-{\n-  switch (s)\n-    {\n-    case setif_sort:\n-      {\n-\tif (large)\n-\t  return (gen_e)sv_fresh_large(get_sort_region(setif_sort),NULL);\n-\telse return (gen_e)sv_fresh(get_sort_region(setif_sort),NULL);\t  \n-      }\n-      break;\n-    case setst_sort:\n-      {\n-\tif (large)\n-\t  return (gen_e)st_fresh_large(get_sort_region(setst_sort),NULL);\n-\telse return (gen_e)st_fresh(get_sort_region(setst_sort),NULL);\t\n-      }\n-      break;\n-    case flowrow_sort:\n-      {\n-\tif (large)\n-\t  return (gen_e)fv_fresh_large(get_sort_region(flowrow_sort),NULL);\n-\telse return (gen_e)fv_fresh(get_sort_region(flowrow_sort),NULL);\n-      }\n-      break;\n-    case term_sort:\n-      {\n-\tif (large)\n-\t  return (gen_e)tv_fresh_large(get_sort_region(term_sort),NULL);\n-\telse return (gen_e)tv_fresh(get_sort_region(term_sort),NULL)\n-      }\t\n-      break;\n-    default:\n-      {\n-\tfail(\"Unmatched sort in get_proj_var\\n\");\n-\treturn NULL;\n-      }\n-      break;\n-    }\n-\n-  return NULL;\n-}\n-\n-static gen_e get_sort_zero(sort_kind s)\n-{\n-switch (s)\n-    {\n-    case setif_sort:\n-      return setif_zero();\n-    case setst_sort:\n-      return setst_zero();\n-    case flowrow_sort:\n-      return flowrow_zero();\n-    case term_sort:\n-      return term_zero();\n-    default:\n-      fail(\"Unmatched sort in get_sort_zero\\n\");\n-      return NULL;\n-    }\n-  return NULL;\n-}\n-\n-static gen_e get_sort_one(sort_kind s)\n-{\n-switch (s)\n-    {\n-    case setif_sort:\n-      return setif_one();\n-    case setst_sort:\n-      return setst_one();\n-    case flowrow_sort:\n-      return flowrow_one();\n-    case term_sort:\n-      return term_one();\n-    default:\n-      fail(\"Unmatched sort in get_sort_zero\\n\");\n-      return NULL;\n-    }\n-  return NULL;\n-}\n-\n-static region get_sort_region(sort s)\n-{\n-  switch (s)\n-    {\n-    case setif_sort:\n-      return setif_region;\n-    case setst_sort:\n-      return setst_region;\n-    case flowrow_sort:\n-      return flowrow_region;\n-    case term_sort:\n-      return term_region:\n-    default:\n-      fail(\"Unmatched sort in get_sort_region\\n\");\n-      return NULL;\n-    }\n-  return NULL;\n-}\n-\n-static term_hash get_sort_hash(sort s)\n-{\n-  switch (s)\n-    {\n-    case setif_sort:\n-      return setif_hash;\n-    case setst_sort:\n-      return setst_hash;\n-    case flowrow_sort:\n-      return flowrow_hash;\n-    case term_sort:\n-      return term_hash:\n-    default:\n-      fail(\"Unmatched sort in get_sort_hash\\n\");\n-      return NULL;\n-    }\n-  return NULL;\n-}\n-\n-constructor make_constructor(const char *name,sort_kind sort, sig_elt s[],\n-\t\t\t     int arity)\n-{\n-  constructor c = ralloc(expr_region,struct constructor);\n-  sig_elt *sig = rarrayalloc(expr_region,arity,sig_elt);\n-  \n-  c->type = new_type();\n-\n-  if (arity)\n-    {\n-      memcpy(sig,s,sizeof(sig_elt)*arity);\n-    }\n-\n-  if ( fixed_sort(sort) )\n-    failure(\"Specified sort does not allow constructor types\\n\");\n-  \n-  c->sort = sort;\n-  c->arity = arity;\n-  c->name = rstrdup(expr_region,name);\n-  c->sig = sig;\n-  \n-  return c;\n-}\n-\n-gen_e constructor_expr(constructor c, gen_e exps[], int arity)\n-{\n-  cons_expr result;\n-  int i;\n-  region sort_region = get_sort_region(c->sort);\n-  term_hash sort_hash = get_sort_hash(c->sort);\n-  \n-  stamp *st = rarrayalloc(sort_region,arity + 1,stamp);\n-  st[0] = c->type;\n-  \n-  // Dynamic arity check\n-  if(arity != c->arity)\n-      failure(\"Signature mismatch\\n\");\n-  \n-  // Dynamic sort checks\n-  for (i = 0; i < arity; i++)\n-    {\n-      if ( c->sig[i].sort != exps[i]->sort)\n-\tfailure(stderr,\"Signature mismatch\\n\");\n-      st[i+1] = exps[i]->st;\n-    }\n-\n-  // Hash-consing of terms\n-  if (!(result = term_hash_find(sort_hash,st,arity+1)) || arity == 0 )\n-    {\n-      gen_e *e = rarrayalloc(sort_region,arity,gen_e);\n-      \n-      if (arity)\n-\tmemcpy(e,exps,sizeof(gen_e)*arity);\n-      else \n-\te = NULL;\n-\n-      result = ralloc(sort_region,struct cons_expr);  \n-      result->type = st[0];\n-      result->st = stamp_fresh();\n-      result->sort = c->sort;\n-      result->arity = c->arity;\n-      result->name = c->name;\n-      result->sig = c->sig;\n-      result->exps = e;\n-      \n-      term_hash_insert(expr_hash,result,st,arity+1);\n-    }\n-\n-  return (gen_e)result;\n-}\n-\n-static gen_e proj_pat(constructor c, int i, gen_e e)\n-{\n-  proj_pat pat;\n-  region sort_region = get_sort_region(e->sort);\n-  term_hash sort_hash = get_sort_hash(e->sort);\n-  \n-  stamp s[3];\n-  s[0] = c->type + 1;\n-  s[1] = e->st;\n-  s[2] = i;\n-  \n-  if (! (pat = term_hash_find(sort_hash,s,3)) )\n-    {\n-      pat = ralloc(sort_region,struct proj_pat);\n-      pat->type = s[0];\n-      pat->st = stamp_fresh();\n-      pat->sort = c->sort;\n-      pat->exp = e;\n-      pat->variance = c->sig[i].variance;\n-      pat->c = c;\n-      pat->i = i;\n-      term_hash_insert(sort_hash,pat,s,3);\n-    }\n-  \n-  return (gen_e)pat;\n-}\n-\n-gen_e setif_proj_pat(constructor c,int i,gen_e e)\n-{\n-  return proj_pat(c,i,e);\n-}\n-\n-gen_e setst_proj_pat(constructor c, int i, gen_e e)\n-{\n-  return proj_pat(c,i,e);\n-}\n-\n-gen_e setif_proj(constructor c, int i, gen_e e)\n-{\n-  setif_var v;\n-  gen_e proj_var, proj;\n-  \n-  gen_e nonspec_get_proj(gen_e_list arg1)\n-    {\n-      proj_pat pat;\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-      \n-      gen_e_list_scan(arg1,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  pat = (proj_pat)temp;\n-\t  if ( pat_match(pat->type,c->type) && i == pat->i )\n-\t    return pat->exp;\n-\t}\n-      return NULL;\n-    }\n-  \n-  if (e->sort != setif_sort)\n-    {\n-      failure(\"Sort check : setif_proj\\n\");\n-    }\n-\n-  else if (i < 0 || i > c->arity)\n-    {\n-      failure(\"Signature mismatch\\n\");\n-    }\n-  \n-  else if (setif_is_zero(e))\n-    return get_sort_zero(c->sig[i].sort);\n-  \n-  else if ( ((setif_term)e)->type == c->type )\n-    {\n-      cons_expr constructed = (cons_expr)e;\n-      return constructed->exps[i];\n-    }\n-  \n-  else if (setif_is_var(e))\n-    {\n-      v = (setif_var)e;\n-      if ( (proj = sv_get_ub_proj(v,nonspec_get_proj)) )\n-\t{\n-\t  return proj;\n-\t}\n-      else\n-\t{\n-\t  gen_e pat;\n-\t  gen_e_list_scanner scan;\n-\t  gen_e lb;\n-\t  proj_var = get_proj_var(c->sig[i].sort,FALSE);\n-\t  pat = setif_proj_pat(c,i,proj_var);\n-\t  sv_add_ub_proj(sort_region,v,pat);\n-\t  \n-\t  gen_e_list_scan(sv_get_lbs(v),&scan);\n-\t  while (gen_e_list_next(&scan,&lb))\n-\t    {\n-\t      setif_inclusion(lb,pat);\n-\t    }\n-\t  return proj_var;\n-\t}\n-    }\n-\n-  else if (setif_is_union(e))\n-    {\n-      if( (proj = nonspec_get_proj(setif_get_proj_cache(e))) )\n-\treturn proj;\n-      else\n-\t{\n-\t  gen_e pat;\n-\t  proj_var = get_proj_var(c->sig[i].sort,FALSE);\n-\t  pat = setif_proj_pat(c,i,proj_var);\n-\t  \n-\t  setif_set_proj_cache(e,pat);\n-\t  \n-\t  setif_inclusion(e,pat);\n-\t  return proj_var;\n-\t}\n-    }\n-  else \n-    {\n-      gen_e pat;\n-      proj_var = get_proj_var(c->sig[i].sort,FALSE);\n-      pat = setif_proj_pat(c,i,proj_var);\n-      setif_inclusion(e,pat);\n-      return proj_var;\n-    }\n-}\n-\n-gen_e setst_proj(constructor c, int i, gen_e e)\n-{\n-  setst_var v;\n-  gen_e proj_var, proj;\n-  \n-  gen_e nonspec_get_proj(gen_e_list arg1)\n-    {\n-      proj_pat pat;\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-      \n-      gen_e_list_scan(arg1,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  pat = (proj_pat)temp;\n-\t  if ( pat_match(pat->type,c->type) && i == pat->i )\n-\t    return pat->exp;\n-\t}\n-      return NULL;\n-    }\n-  \n-  if (e->sort != setst_sort)\n-    {\n-      failure(\"Sort check : setst_proj\\n\");\n-    }\n-\n-  else if (i < 0 || i > c->arity)\n-    {\n-      failure(\"Signature mismatch\\n\");\n-    }\n-  \n-  else if (setst_is_zero(e))\n-    return get_sort_zero(c->sig[i].sort);\n-  \n-  else if ( ((setst_term)e)->type == c->type )\n-    {\n-      cons_expr constructed = (cons_expr)e;\n-      return constructed->exps[i];\n-    }\n-  \n-  else if (setst_is_var(e))\n-    {\n-      v = (setst_var)e;\n-      if ( (proj = sv_get_ub_proj(v,nonspec_get_proj)) )\n-\t{\n-\t  return proj;\n-\t}\n-      else\n-\t{\n-\t  gen_e pat;\n-\t  gen_e_list_scanner scan;\n-\t  gen_e lb;\n-\t  proj_var = get_proj_var(c->sig[i].sort,FALSE);\n-\t  pat = setst_proj_pat(c,i,proj_var);\n-\t  sv_add_ub_proj(sort_region,v,pat);\n-\t  \n-\t  gen_e_list_scan(sv_get_lbs(v),&scan);\n-\t  while (gen_e_list_next(&scan,&lb))\n-\t    {\n-\t      setst_inclusion(lb,pat);\n-\t    }\n-\t  return proj_var;\n-\t}\n-    }\n-\n-  else if (setst_is_union(e))\n-    {\n-      if( (proj = nonspec_get_proj(setst_get_proj_cache(e))) )\n-\treturn proj;\n-      else\n-\t{\n-\t  gen_e pat;\n-\t  proj_var = get_proj_var(c->sig[i].sort,FALSE);\n-\t  pat = setst_proj_pat(c,i,proj_var);\n-\t  \n-\t  setst_set_proj_cache(e,pat);\n-\t  \n-\t  setst_inclusion(e,pat);\n-\t  return proj_var;\n-\t}\n-    }\n-  else \n-    {\n-      gen_e pat;\n-      proj_var = get_proj_var(c->sig[i].sort,FALSE);\n-      pat = setst_proj_pat(c,i,proj_var);\n-      setst_inclusion(e,pat);\n-      return proj_var;\n-    }\n-}\n-\n-static void setif_con_match(gen_e e1, gen_e e2)\n-{\n-  // Case where e1 is a constructor expression and e2 is a proj_pat\n-  if (pat_match(((setif_term)e2)->type,((setif_term)e1)->type))\n-    {\n-      cons_expr c = (cons_expr)e1;\n-      proj_pat p = (proj_pat)e2;\n-      int i = p->i;\n-      \n-      if (c->sig[i].variance == vnc_pos)\n-\tcall_inclusion_fn(c->exps[i],p->exp);\n-      else if (c->sig[i].variance == vnc_neg)\n-\tcall_inclusion_fn(p->exp,c->exps[i]);\n-      else\n-\tcall_unify_fn(c->exps[i],p->exp);\n-    }\n-  else if (setif_is_pat(e2)) \n-    {\n-      return;\n-    }\n-  \n-  // Case where e1 and e2 are constructor expressions\n-  else \n-    {\n-      cons_expr c1 = (cons_expr)e1,\n-\tc2 = (cons_expr)e2;\n-      \n-      if (c1->type != c2->type)\n-\tfailure(\"Constructor mismatch\\n\");\n-      else\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < c1->arity; i++)\n-\t    {\n-\t      if (c1->sig[i].variance == vnc_pos)\n-\t\tcall_inclusion_fn(e1,e2);\n-\t      else if (c1->sig[i].variance == vnc_neg)\n-\t\tcall_inclusion_fn(e2,e1);\n-\t      else\n-\t\tcall_unify_fn(e1,e2);\n-\t    }\n-\t  \n-\t}\n-    } \n-}\n-\n-static void setst_con_match(gen_e e1, gen_e e2)\n-{\n-  // Case where e1 is a constructor expression and e2 is a proj_pat\n-  if (pat_match(((setst_term)e2)->type,((setst_term)e1)->type))\n-    {\n-      cons_expr c = (cons_expr)e1;\n-      proj_pat p = (proj_pat)e2;\n-      int i = p->i;\n-      \n-      if (c->sig[i].variance == vnc_pos)\n-\tcall_inclusion_fn(c->exps[i],p->exp);\n-      else if (c->sig[i].variance == vnc_neg)\n-\tcall_inclusion_fn(p->exp,c->exps[i]);\n-      else\n-\tcall_unify_fn(c->exps[i],p->exp);\n-    }\n-  else if (setst_is_pat(e2)) \n-    {\n-      return;\n-    }\n-  \n-  // Case where e1 and e2 are constructor expressions\n-  else \n-    {\n-      cons_expr c1 = (cons_expr)e1,\n-\tc2 = (cons_expr)e2;\n-      \n-      if (c1->type != c2->type)\n-\tfailure(\"Constructor mismatch\\n\");\n-      else\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < c1->arity; i++)\n-\t    {\n-\t      if (c1->sig[i].variance == vnc_pos)\n-\t\tcall_inclusion_fn(e1,e2);\n-\t      else if (c1->sig[i].variance == vnc_neg)\n-\t\tcall_inclusion_fn(e2,e1);\n-\t      else\n-\t\tcall_unify_fn(e1,e2);\n-\t    }\n-\t  \n-\t}\n-    } \n-}\n-\n-// given x <= proj(c,i,e)\n-// proj_merge(region,e,get_proj_i_arg,fresh_large_fn_ptr,\n-// sort_inclusion_fn_ptr,set_inclusion)\n-static bool nonspec_res_proj(set_var v1,gen_e e2)\n-{\n-  proj_pat projection_pat = (proj_pat)e2;\n-  \n-  gen_e setif_get_proj(gen_e_list arg1)\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-      proj_pat pat;\n-\n-      gen_e_list_scan(arg1,&scan);\n-      while(gen_e_list_next(&scan,&temp))\n-\t{\n-\t  pat = (proj_pat)temp;\n-\t  if ( pat->type == ((setif_term)e2)->type && \n-\t       pat->i == ((proj_pat)e2)->i)\n-\t    return pat->exp;\n-\t}\n-      return NULL;\n-    }\n-  \n-  gen_e fresh_large(void)\n-    {\n-      return get_proj_var( ((proj_pat)e2)->exp->sort,TRUE);\n-    }\n-  \n-  bool sort_inclusion(gen_e e1, gen_e e2)\n-    {\n-      if ( projection_pat->variance == vnc_pos )\n-\treturn call_inclusion_fn(e1,e2);\n-      else if ( projection_pat->variance == vnc_neg)\n-\treturn call_inclusion_fn(e2,e1);\n-      else \n-\treturn call_unify_fn(e1,e2);\n-    }\n-  \n-  gen_e proj_con(gen_e e)\n-    {\n-      return make_proj_pat( ((proj_pat)e2)->c, ((proj_pat)e2)->i,e);\n-    }\n-  \n-  return setif_proj_merge(setif_region,v1,((proj_pat)e2)->exp,\n-\t\t\t  setif_get_proj,proj_con,\n-\t\t\t  fresh_large,sort_inclusion,\n-\t\t\t  call_setif_inclusion);\n-  \n-}\n-\n-\n-void call_setif_inclusion(gen_e e1,gen_e e2)\n-{\n-  setif_inclusion(setif_con_match,setif_res_proj,e1,e2);\n-}\n-\n-void call_setif_unify(gen_e e1, gen_e e2)\n-{\n-  setif_inclusion(setif_con_match,setif_res_proj,e1,e2);\n-  setif_inclusion(setif_con_match,setif_res_proj,e2,e1);\n-}\n-\n-void call_setst_inclusion(gen_e e1, gen_e e2)\n-{\n-  setst_inclusion(setst_con_match,e1,e2);\n-}\n-\n-void call_setst_unify(gen_e e1, gen_e e2)\n-{\n-  setst_inclusion(setst_con_match,e1,e2);\n-  setst_inclusion(setst_con_match,e2,e1);\n-}\n-\n-void call_flowrow_inclusion(gen_e e1,gen_e e2)\n-{\n-\n-  if ( (e1->sort != flowrow_sort) || (e2->sort != flowrow_sort) )\n-    failure(\"Constraint system is not well-sorted\\n\");\n-\n-  if ( flowrow_base_sort(e1) != flowrow_base_sert(e2))\n-    failure(\"Constraint system is not well-sorted\\n\");\n-\n-\n-  flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e1,e2);\n-}\n-\n-void call_flowrow_unify(gen_e e1, gen_e e2)\n-{\n-  flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e1,e2);\n-  flowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e2,e1);\n-}\n-\n-static void term_con_match(gen_e e1, gen_e e2)\n-{\n-  cons_expr c1 = (cons_expr)e1,\n-    c2 = (cons_expr)e2;\n-  \n-  if (c1->type != c2->type)\n-    failure(\"Constructor mismatch\\n\");\n-  else\n-    {\n-      int i;\n-      for (i = 0; i < c1->arity; i++)\n-\t{\n-\t  call_unify_fn(e1,e2);\n-\t}\n-      \n-    }\n-}\n-\n-static void term_occurs(term_var v, gen_e e)\n-{\n-  gen_e ecr = term_get_ecr(e);\n-  \n-  if (((gen_term)ecr)->type == VAR_TYPE)\n-    return ( term_get_stamp((gen_e)v) == term_get_stamp(e) );\n-\n-  else if (((gen_term)ecr)->type >= 10)\n-    {\n-      cons_expr c_e = (cons_expr) e;\n-      int i;\n-      for (int i = 0; i < arity; i++)\n-\t{\n-\t  if (term_occurs(v,c->exps[i]))\n-\t    return TRUE;\n-\t}\n-    }\n-  \n-  return FALSE;\n-}\n-\n-void call_term_unify(gen_e e1, gen_e e2)\n-{\n-  term_unify(term_con_match,term_occurs,e1,e2);\n-}\n-\n-void call_term_cunify(gen_e e1, gen_e e2)\n-{\n-  term_cunify(term_con_match,term_occurs,e1,e2);\n-}\n-\n-\n-static void call_inclusion_fn(gen_e e1, gen_e e2)\n-{\n-  switch (e1->sort)\n-    {\n-    case sort_setif:\n-      {\n-\tsetif_inclusion(setif_con_match,setif_res_proj,e1,e2);\n-      }\n-      break;\n-    case sort_setst:\n-      {\n-\tsetst_inclusion(setst_con_match,e1,e2);\n-      }\n-      break;\n-    case sort_term:\n-      {\n-\tterm_unify(term_con_match,term_occurs,e1,e2);\n-      }    \n-      break;\n-    case sort_row:\n-      {\n-\t/* TODO */\n-\tflowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e1,e2);\n-      }\n-      break;\n-    default :\n-      fail(\"Unmatched sort in call inclusion\\n\");\n-    }\n-}\n-\n-static bool call_unify_fn(gen_e e1, gen_e e2)\n-{\n-\n-  switch (e1->sort)\n-    {\n-    case sort_setif:\n-      {\n-\tsetif_inclusion(setif_con_match,setif_res_proj,e1,e2);\n-\tsetif_inclusion(setif_con_match,setif_res_proj,e2,e1);\n-      }\n-      break;\n-    case sort_setst:\n-      {\n-\tsetst_inclusion(setst_con_match,e1,e2);\n-\tsetst_inclusion(setst_con_match,e2,e1);\n-      }\n-      break;\n-    case sort_term:\n-      {\n-\tterm_unify(term_con_match,term_occurs,e1,e2);\n-      }    \n-      break;\n-    case sort_row:\n-      {\n-\t/* TODO */\n-\tflowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e1,e2);\n-\tflowrow_inclusion(fresh,get_stamp,field_incl,zero_elem,e2,e1);\n-      }\n-      break;\n-    default :\n-      fail(\"Unmatched sort in call inclusion\\n\");\n-    }\n-}\n-\n-void nonspec_init(void)\n-{\n-  banshee_init();\n-  setif_init();\n-  setst_init();\n-  flowrow_init();\n-}\n-\n-void nonspec_reset(void)\n-{\n-  flowrow_reset();\n-  setst_reset();\n-  setif_reset();\n-  banshee_reset();\n-}\n-\n-void expr_print(FILE *f,gen_e e)\n-{\n-\n-}"}, {"sha": "bfa3b9d8b906a10a4b547fc12f8ac99eb4bb1c87", "filename": "libbanshee/engine/nonspec.h", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fnonspec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fnonspec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fnonspec.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,189 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef NONSPEC_H\n-#define NONSPEC_H\n-\n-#include <stdio.h>\n-\n-EXTERN_C_BEGIN\n-\n-typedef enum \n-{\n-  vnc_pos,\n-  vnc_neg,\n-  vnc_non\n-} vnc_kind;\n-\n-struct sig_elt\n-{\n-  vnc_kind variance;\n-  sort_kind sort;\n-};\n-\n-typedef struct sig_elt sig_elt;\n-typedef struct constructor *constructor;\n-\n-struct flowrow_field\n-{\n-  char *label;\n-  gen_e expr;\n-};\n-\n-DECLARE_LIST(flowrow_map,flowrow_field)\n-\n-/*\n-   Flags\n-*/\n-extern bool flag_merge_projections;\n-extern bool flag_eliminate_cycles;\n-extern bool flag_occurs_check;\n-\n-/* \n-   Operations for building terms\n-*/\n-\n-/* Defines a new constructor for sort s with the given signature */\n-constructor make_constructor(const char *name,sort_kind sort, sig_elt[],\n-\t\t\t     int arity);\n-\n-/* Build the term c(exps[0]....exps[n]) */\n-gen_e constructor_expr(constructor c, gen_e exps[], int arity);\n-\n-/* make a constant of sort s */\n-gen_e setif_constant(const char *name);\n-\n-gen_e setst_constant(const char *name);\n-\n-gen_e term_constant(const char *name);\n-\n-/* Creates a projection pattern projpat(c,i,e) */\n-gen_e setif_proj_pat(constructor c,int i,gen_e e);\n-\n-gen_e setst_proj_pat(constructor c, int i, gen_e e);\n-\n-/* Adds a constraint e <= projpat(c,i,fv) where fv is a fresh variable */\n-gen_e setif_proj(constructor c, int i, gen_e e);\n-\n-gen_e setst_proj(constructor c, int i, gen_e e);\n-\n-/* Make a new variable of sort s */\n-gen_e setif_fresh(const char *name);\n-\n-gen_e term_fresh(const char *name);\n-\n-gen_e flowrow_fresh(const char *name);\n-\n-gen_e setst_fresh(const char *name);\n-\n-/* Operations for unions */\n-\n-gen_e setif_union(gen_e exps[]);\n-\n-gen_e setif_inter(gen_e exps[]);\n-\n-gen_e setst_union(gen_e exps[]);\n-\n-gen_e setst_inter(gen_e exps[]);\n-\n-/* Empty set of sort s */\n-gen_e setif_zero(void);\n-\n-gen_e setst_zero(void);\n-\n-gen_e flowrow_zero(sort_kind base_sort);\n-\n-gen_e term_zero(void);\n-\n-/* Universal set of sort s */\n-gen_e setif_one(void);\n-\n-gen_e setst_one(void);\n-\n-gen_e flowrow_one(sort_kind base_sort);\n-\n-gen_e term_one(void);\n-\n-/*\n-  Operations for building flowrows \n-*/\n-\n-/* Closed flowrow of base sort s */\n-gen_e flowrow_abs(sort_kind base_sort);\n-\n-/* Wild flowrow of base sort s */\n-gen_e flowrow_wild(sort_kind base_sort);\n-\n-/* Build a flowrow of <l : e>_fields o <rest>  */\n-gen_e flowrow_row(flowrow_map fields, gen_e rest);\n-\n-/* \n-   Inclusion functions\n-*/\n-void call_setif_inclusion(gen_e e1,gen_e e2);\n-void call_setif_unify(gen_e e1, gen_e e2);\n-\n-void call_setst_inclusion(gen_e e1, gen_e e2);\n-void call_setst_unify(gen_e e1, gen_e e2);\n-\n-void call_flowrow_inclusion(gen_e e1,gen_e e2);\n-void call_flowrow_unify(gen_e e1, gen_e e2);\n-\n-void call_term_unify(gen_e e1, gen_e e2);\n-void call_term_cunify(gen_e e1, gen_e e2);\n-\n-/*\n-  Extracting solutions \n- */\n-struct decon\n-{\n-  int arity;\n-  gen_e[1];\n-};\n-struct decon deconstruct_expr(constructor c,gen_e e);\n-\n-gen_e_list setif_tlb(gen_e e);\n-\n-gen_e_list setst_tlb(gen_e e);\n-\n-gen_e term_get_ecr(gen_e e);\n-\n-gen_e flowrow_extract_field(const char *label,gen_e row);\n-flowrow_map flowrow_extract_fields(gen_e row);\n-gen_e flowrow_extract_rest(gen_e row);\n-\n-void nonspec_init(void);\n-void nonspec_reset(void);\n-\n-void expr_print(FILE *f,gen_e e);\n-\n-EXTERN_C_END\n-\n-#endif /* NONSPEC_H */"}, {"sha": "0be31cc272f6dce762ea72c40d7d5411389b4fee", "filename": "libbanshee/engine/setif-sort.c", "status": "removed", "additions": 0, "deletions": 1155, "changes": 1155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-sort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-sort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetif-sort.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,1155 +0,0 @@\n-/*\n- * Copyright (c) 2000-2004\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <assert.h>\n-#include <setjmp.h>\n-#include \"regions.h\"\n-#include \"bounds.h\"\n-#include \"jcollection.h\"\n-#include \"setif-sort.h\"\n-#include \"util.h\"\n-\n-bool flag_eliminate_cycles = TRUE;\n-bool flag_merge_projections = TRUE;\n-\n-struct setif_union_ /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  gen_e_list exprs;\n-  gen_e_list proj_cache;\n-};\n-\n-struct setif_inter_ /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  gen_e_list exprs;\n-};\n-\n-struct setif_constant_ /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  char *name;\n-};\n-\n-typedef struct setif_inter_ *setif_inter_;\n-typedef struct setif_union_ *setif_union_;\n-typedef struct setif_constant_ *setif_constant_;\n-\n-static setif_var_list setif_vars;\n-static region tlb_cache_region;\n-static setif_var_list tlb_var_cache;\n-static jcoll_dict tlb_dict;\n-\n-\n-region setif_region;\n-term_hash setif_hash;\n-struct setif_stats setif_stats;\n-\n-stamp setif_get_stamp(gen_e e) \n-{\n-#ifdef NONSPEC\n-  assert(e->sort == setif_sort);\n-#endif\n-  \n-  if ( ((setif_term)e)->type == VAR_TYPE)\n-    return sv_get_stamp( (setif_var)e );\n-  \n-  else\n-    return ((setif_term)e)->st;\n-}\n-\n-static void tlv_lower_aux(jmp_buf buf,stamp st, gen_e e)\n-{\n-  if ( setif_is_var(e) && (setif_get_stamp(e) > st) ) \n-    longjmp(buf,1);\n-  \n-  else if (setif_is_union(e))\n-    {\n-      gen_e temp;\n-      gen_e_list exprs = ((setif_union_)e)->exprs;\n-      gen_e_list_scanner scan;\n-      \n-      gen_e_list_scan(exprs,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\ttlv_lower_aux(buf,st,temp);\n-    }\n-}\n-\n-static bool tlv_lower(stamp st, gen_e e)\n-{\n-  jmp_buf buf;\n-  int higher;\n-  \n-  higher = setjmp(buf);\n-  if (higher)\n-    return FALSE;\n-\n-  tlv_lower_aux(buf,st,e);\n-  \n-  return TRUE;\n-}\n-\n-static void invalidate_tlb_cache(void) deletes\n-{\n-  assert(tlb_cache_region);\n-\n-  setif_var_list_app(tlb_var_cache,sv_clear_tlb_cache);\n-  jcoll_delete_dict(tlb_dict);\n-  deleteregion_ptr(&tlb_cache_region);\n-\n-  tlb_cache_region = newregion();\n-  tlb_dict = jcoll_create_dict(tlb_cache_region,setif_get_stamp);\n-  tlb_var_cache = new_setif_var_list(tlb_cache_region);\n-}\n-\n-static void set_tlb_cache(setif_var v, jcoll j)\n-{\n-  setif_var_list_cons(v,tlb_var_cache);\n-  sv_set_tlb_cache(v,j);\n-}\n-\n-/* \n-   A constraint e1 <= e2 is l-inductive iff e2 is a variable x and\n-   for each y in tlv(e1), stamp(y) < stamp(x) \n-*/ \n-static bool l_inductive(gen_e e1, gen_e e2)\n-{\n-  if (setif_is_var(e2) && tlv_lower(setif_get_stamp(e2), e1))\n-    return TRUE;\n-  \n-  else return FALSE;\n-}\n-\n-/*  \n-    A constraint e1 <= e2 is r-inductive iff e1 is a variable x and\n-    for each y in tlv(e2), stamp(y) < stamp(x) \n-*/ \n-static bool r_inductive(gen_e e1, gen_e e2)\n-{\n-  if (setif_is_var(e1) && tlv_lower(setif_get_stamp(e1), e2))\n-    return TRUE;\n-  \n-  else return FALSE;\n-}\n-\n-static bool eq(gen_e e1, gen_e e2)\n-{\n-  return ( setif_get_stamp(e1) == setif_get_stamp(e2) );\n-}\n-\n-gen_e_list setif_get_union(gen_e e)\n-{\n-  assert ( ((setif_term)e)->type == UNION_TYPE);\n-\n-  return ( (setif_union_) e)->exprs;\n-}\n-\n-gen_e_list setif_get_inter(gen_e e)\n-{\n-  assert ( ((setif_term)e)->type == INTER_TYPE);\n-\n-  return ( (setif_inter_) e)->exprs;\n-}\n-\n-static void search_ubs_aux(setif_var v, setif_var goal, setif_var_list cycle,\n-\t\t\t   bool* found)\n-{\n-  assert(! *found); \n-  \n-  if (sv_eq (v, goal))\n-    {\n-      *found = TRUE;\n-      return;\n-    }\n-  else if (sv_lt(v,goal))\n-    {\n-      return;\n-    }\n-  else \n-    {\n-      gen_e_list_scanner scan;\n-      gen_e ub;\n-      gen_e_list ubs = sv_get_ubs(v);\n-      \n-      gen_e_list_scan(ubs,&scan);\n-      while (gen_e_list_next(&scan,&ub))\n-      {\n-\tif (setif_is_var(ub))\n-\t  {\n-\t    search_ubs_aux((setif_var)ub, goal, cycle, found);\n-\t    if (*found)\n-\t      {\n-\t\tsetif_var_list_cons(v,cycle);\n-\t\treturn;\n-\t      }\n-\t  }\n-      }\n-    }\n-}\n-\n-\n-static setif_var_list search_ubs(region r, setif_var v1, setif_var goal)\n-{\n-  bool found;\n-  setif_var_list cycle;\n-  \n-  found = FALSE;\n-  cycle = new_setif_var_list(r);\n-  search_ubs_aux(v1, goal, cycle, &found);\n-\n-  return cycle;\n-}\n-\n-\n-static void search_lbs_aux(setif_var v, setif_var goal, setif_var_list cycle,\n-\t\t\t   bool* found)\n-{\n-  assert (! *found);\n-  if (sv_eq(v,goal))\n-    {\n-      *found = TRUE;\n-      return;\n-    }\n-  else if (sv_lt(v,goal))\n-    {\n-      return;\n-    }\n-  else\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e lb;\n-      gen_e_list lbs = sv_get_lbs(v);\n-      \n-      gen_e_list_scan(lbs,&scan);\n-      while (gen_e_list_next(&scan,&lb))\n-      {\n-\tif (setif_is_var(lb))\n-\t  {\n-\t    search_lbs_aux((setif_var)lb, goal, cycle, found);\n-\t    if (*found)\n-\t      {\n-\t\tsetif_var_list_cons(v,cycle);\n-\t\treturn;\n-\t      }\n-\t  }\n-      }\n-    }\n-    \n-}\n-\n-\n-static setif_var_list search_lbs(region r, setif_var v1, setif_var goal)\n-{\n-  bool found;\n-  setif_var_list cycle;\n- \n-  found = FALSE;\n-  cycle = new_setif_var_list(r);\n-  search_lbs_aux(v1, goal, cycle, &found);\n-\n-  return cycle; \n-}\n-\n-\n-static setif_var_list cycle_detect(region r,setif_var v1,setif_var v2)\n-{\n-  if (sv_union_component(v1,v2))\n-    return new_setif_var_list(r);\n-\n-  else\n-    {\n-      setif_stats.cycles_searched_forward++;\n-      return search_ubs(r, v2, v1);\n-    }\n-}\n-\n-\n-static setif_var_list cycle_detect_rev(region r, setif_var v1, setif_var v2)\n-{\n-  if (sv_union_component(v1,v2))\n-    return new_setif_var_list(r);\n-\n-  else\n-    {\n-      setif_stats.cycles_searched_backward++;\n-      return search_lbs(r, v1, v2);\n-    }\n-}\n-\n-\n-static void collapse_cycle_lower(region r, setif_var witness,\n-\t\t\t\t setif_var_list cycle,\n-\t\t\t\t con_match_fn_ptr con_match,\n-\t\t\t\t res_proj_fn_ptr res_proj) deletes\n-{\n-  gen_e lb;\n-  gen_e_list_scanner scan_bounds;\n-  setif_var_list_scanner scan_cycle;\n-  setif_var var;\n-\n-#ifndef NDEBUG\n-  stamp lowest = sv_get_stamp(witness);\n-#endif\n-  bounds b = bounds_create(r);\n-  \n-  /* Collect all lower bounds in the cycle, and add transitive edges */\n-  setif_var_list_scan(cycle,&scan_cycle);\n-  while(setif_var_list_next(&scan_cycle,&var))\n-    {\n-      assert( sv_get_stamp(var) > lowest);\n-      gen_e_list_scan(sv_get_lbs(var),&scan_bounds);\n-      while(gen_e_list_next(&scan_bounds,&lb))\n-\tbounds_add(b,lb,setif_get_stamp(lb));\n-    }\n-\n-  sv_unify(witness,cycle);\n-  assert(sv_get_stamp(witness) == lowest);\n-  \n-  gen_e_list_scan(bounds_exprs(b),&scan_bounds);\n-  while (gen_e_list_next(&scan_bounds,&lb))\n-    setif_inclusion(con_match,res_proj,lb, (gen_e) witness);\n-  \n-  bounds_delete(b);\n-  invalidate_tlb_cache();\n-\n-  setif_stats.cycles_collapsed_backward++;\n-  setif_stats.cycles_length_backward += setif_var_list_length(cycle);\n-}\n-\n-static void collapse_cycle_upper(region r, setif_var witness,\n-\t\t\t\t setif_var_list cycle,\n-\t\t\t\t con_match_fn_ptr con_match,\n-\t\t\t\t res_proj_fn_ptr res_proj) deletes\n-{\n-  gen_e ub;\n-  gen_e_list_scanner scan_bounds;\n-  setif_var_list_scanner scan_cycle;\n-  setif_var var;\n-\n-#ifndef NDEBUG\n-  stamp lowest = sv_get_stamp(witness);\n-#endif\n-  bounds b = bounds_create(r);\n-  \n-  /* Collect all upper bounds in the cycle, and add transitive edges */\n-  setif_var_list_scan(cycle,&scan_cycle);\n-  while(setif_var_list_next(&scan_cycle,&var))\n-    { \n-      assert( sv_get_stamp(var) > lowest);\n-\n-      gen_e_list_scan(sv_get_ubs(var),&scan_bounds);\n-      while(gen_e_list_next(&scan_bounds,&ub))\n-\tbounds_add(b,ub,setif_get_stamp(ub));\n-      \n-      gen_e_list_scan(sv_get_ub_projs(var),&scan_bounds);\n-      while(gen_e_list_next(&scan_bounds,&ub))\n-\tbounds_add(b,ub,setif_get_stamp(ub));\n-    }\n-\n-  sv_unify(witness,cycle);\n-  assert(sv_get_stamp(witness) == lowest);\n-\n-  gen_e_list_scan(bounds_exprs(b),&scan_bounds);\n-  while (gen_e_list_next(&scan_bounds,&ub))\n-    setif_inclusion(con_match,res_proj,(gen_e) witness, ub);\n-    \n-  bounds_delete(b);\n-  invalidate_tlb_cache();\n-\n-  setif_stats.cycles_collapsed_forward++;\n-  setif_stats.cycles_length_backward += setif_var_list_length(cycle);\n-}\n-\n-static void update_lower_bound(setif_var v, gen_e e,\n-\t\t\t       con_match_fn_ptr con_match,\n-\t\t\t       res_proj_fn_ptr res_proj) deletes\n-{\n-  if (sv_add_lb(v,e,setif_get_stamp(e)))\n-    {\n-      if (setif_is_var(e))\n-\tsetif_stats.redundant_succ++;\n-      \n-      else\n-\tsetif_stats.redundant_source++;\n-    }\n-\n-  else\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e ub;\n-      \n-      if (setif_is_var(e))\n-\tsetif_stats.added_succ++;\n-      else\n-\tsetif_stats.added_source++;\n-      \n-      invalidate_tlb_cache();\n-\n-      gen_e_list_scan(sv_get_ubs(v),&scan);\n-      while(gen_e_list_next(&scan,&ub))\n-\tsetif_inclusion(con_match,res_proj,e,ub);\n-      \n-      gen_e_list_scan(sv_get_ub_projs(v),&scan);\n-      while (gen_e_list_next(&scan,&ub))\n-\tsetif_inclusion(con_match,res_proj,e,ub);\n-\n-    }\n-  \n-}\n-\n-static void update_upper_bound(setif_var v, gen_e e,\n-\t\t\t       con_match_fn_ptr con_match,\n-\t\t\t       res_proj_fn_ptr res_proj) deletes\n-{\n-  if (sv_add_ub(v,e,setif_get_stamp(e)))\n-    {\n-      if (setif_is_var(e))\n-\tsetif_stats.redundant_pred++;\n-    \n-      else\n-\tsetif_stats.redundant_sink++;\n-    }\n-  \n-  else\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e lb;\n-\n-      if (setif_is_var(e))\n-\tsetif_stats.added_pred++;\n-      else\n-\tsetif_stats.added_sink++;\n-\n-      invalidate_tlb_cache();\n-      \n-      gen_e_list_scan(sv_get_lbs(v),&scan);\n-      while (gen_e_list_next(&scan,&lb))\n-\tsetif_inclusion(con_match,res_proj,lb,e);\n-\n-    }\n-  \n-}\n-\n-\n-void setif_inclusion(con_match_fn_ptr con_match, res_proj_fn_ptr res_proj,\n-\t\t     gen_e e1, gen_e e2) deletes\n-{\n-  if (eq(e1,e2))\n-    return;\n-  \n-  else if ( setif_is_zero(e1) || setif_is_one(e2) )\n-    return;\n-\n-  /* c <= d */\n-  else if ( setif_is_constant(e1) && setif_is_constant(e2) )\n-    {\n-\n-  failure(\"Inconsistent system of constraints\\n\");\n-      return;\n-    }\n-\n-  else if ( setif_is_union(e1) )\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-\n-      gen_e_list exprs = setif_get_union(e1);\n-      \n-      gen_e_list_scan(exprs,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  setif_inclusion(con_match,res_proj,temp,e2);\n-\t}\n-\n-      return;\n-    }\n-  \n-  else if ( setif_is_inter(e2) )\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-\n-      gen_e_list exprs = setif_get_inter(e2);\n-\n-      gen_e_list_scan(exprs,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  setif_inclusion(con_match,res_proj,e1,temp);\n-\t}\n-\n-      return;\n-    }\n-\n-  else if ( l_inductive(e1,e2) ) /* _ <= 'x */ \n-    {\n-      setif_var v2 = ((setif_var)e2);\n-\n-      if (setif_is_var(e1))\n-\t{\n-\t  setif_var v1 = ((setif_var)e1);\n-\t  \n-\t  if (flag_eliminate_cycles)\n-\t    {\n-\t      region scratch = newregion();\n-\t      setif_var_list cycle = cycle_detect(scratch,v1,v2);\n-\t      \n-\t      if (! setif_var_list_empty(cycle))\n-\t\tcollapse_cycle_upper(scratch,v1,cycle,con_match,res_proj);\n-\t      else\n-\t\tupdate_lower_bound(v2,e1,con_match,res_proj);\n-\t      \n-\t      deleteregion(scratch);\n-\t    }\n-\t  \n-\t  else \n-\t    update_lower_bound(v2,e1,con_match,res_proj);\n-\t}\n-      else /* e1 is a source */\n-\tupdate_lower_bound(v2,e1,con_match,res_proj);\n-    }\n-\n-  else if ( r_inductive(e1,e2) ) /* 'x <= _ */\n-    {\n-      setif_var v1 = ((setif_var)e1);\n-     \n-      if (setif_is_var(e2))\n-\t{\n-\t  setif_var v2 = ((setif_var)e2);\n-\t  \n-\t  if (flag_eliminate_cycles)\n-\t    {\n-\t      region scratch = newregion();\n-\t      setif_var_list cycle = cycle_detect_rev(scratch,v1,v2);\n-\t      \n-\t      if (! setif_var_list_empty(cycle))\n-\t\tcollapse_cycle_lower(scratch,v2,cycle,con_match,res_proj);\n-\t      else\n-\t\tupdate_upper_bound(v1,e2,con_match,res_proj);\n-\t      \n-\t      deleteregion(scratch);\n-\t    }\n-      \n-\t  else\n-\t    update_upper_bound(v1,e2,con_match,res_proj);\n-\t}\n-      else /* e2 is a sink */\n-\t{\n-\t  if (flag_merge_projections && res_proj(v1,e2))\n-\t    return;\n-\t  else\n-\t    update_upper_bound(v1,e2,con_match,res_proj);\n-\t}\n-    }\n-\n-  else /* c(...) <= c(...) or c(...) <= projpat(c,i,e) */\n-  {\n-    con_match(e1,e2);\n-    return;\n-  }\n-  \n-}\n-\n-#ifdef NONSPEC\n-static struct setif_term zero = {setif_sort,ZERO_TYPE,ZERO_TYPE}; \n-static struct setif_term one  = {setif_sort,ONE_TYPE,ONE_TYPE};\n-#else\n-static struct setif_term zero = {ZERO_TYPE,ZERO_TYPE};\n-static struct setif_term one  = {ONE_TYPE,ONE_TYPE};\n-#endif /* NONSPEC */\n-\n-gen_e setif_zero(void)\n-{\n-  return (gen_e)&zero;\n-}\n-\n-gen_e setif_one(void)\n-{\n-  return (gen_e)&one;\n-}\n-\n-gen_e setif_fresh(const char *name)\n-{\n-  setif_var result = sv_fresh(setif_region,name);\n-  setif_var_list_cons(result,setif_vars);\n-\n-  setif_stats.fresh++;\n-  return (gen_e)result;\n-}\n-\n-gen_e setif_fresh_large(const char *name)\n-{\n-  setif_var result = sv_fresh_large(setif_region,name);\n-  setif_var_list_cons(result,setif_vars);\n-\n-  setif_stats.fresh_large++;\n-  return (gen_e)result;\n-}\n-\n-gen_e setif_fresh_small(const char *name)\n-{\n-  setif_var result = sv_fresh_small(setif_region,name);\n-  setif_var_list_cons(result,setif_vars);\n-\n-  setif_stats.fresh_small++;\n-  return (gen_e)result;\n-}\n-\n-gen_e setif_constant(const char *str) deletes\n-{\n-  stamp st[2];\n-  gen_e result;\n-  char *name = rstrdup(setif_region,str);\n-\n-  assert (str != NULL);\n-  \n-  st[0] = CONSTANT_TYPE;\n-  st[1] = stamp_string(name); \n-\n-  if ( (result = term_hash_find(setif_hash,st,2)) == NULL)\n-    {\n-      setif_constant_ c = ralloc(setif_region, struct setif_constant_);\n-#ifdef NONSPEC\n-      c->sort = setif_sort;\n-#endif\n-      c->type = CONSTANT_TYPE;\n-      c->st = stamp_fresh();\n-      c->name = name;\n-\n-      result = (gen_e) c;\n-      term_hash_insert(setif_hash,result,st,2);\n-      \n-      setif_stats.distinct_constants++;\n-      \n-      return result;\n-    }\n-  \n-  else\n-    {\n-      setif_stats.hashed_constants++;\n-      return result;\n-    }\n-}\n-\n-static bool filter_zero(const gen_e e)\n-{\n-  return (!setif_is_zero(e));\n-}\n-\n-\n-static bool filter_one(const gen_e e)\n-{\n-  return (!setif_is_one(e));\n-}\n-\n-gen_e setif_union(gen_e_list exprs) deletes\n-{\n-  gen_e_list filtered = gen_e_list_filter(setif_region,exprs,filter_zero);\n-  \n-  if ( gen_e_list_empty(filtered) )\n-    {\n-      setif_stats.filtered_unions++;\n-      return setif_zero();\n-    }\n-  else if (gen_e_list_length(filtered) == 1)\n-    {\n-      setif_stats.filtered_unions++;\n-      return gen_e_list_head(filtered);\n-    }\n-\n-  else \n-    {\n-      int i = 0;\n-      gen_e temp,result;\n-      gen_e_list_scanner scan;\n-      stamp st[ gen_e_list_length(filtered) + 1 ];\n-     \n-      st[0] = UNION_TYPE;\n-\n-      gen_e_list_scan(filtered,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  st[++i] = setif_get_stamp(temp);\n-\t}\n-      \n-      if ( (result = \n-\t   term_hash_find(setif_hash,st,gen_e_list_length(filtered)+1)) \n-\t   == NULL )\n-\t{\n-\t  struct setif_union_ *u = ralloc(setif_region,struct setif_union_);\n-\t  \n-\t  u->type = UNION_TYPE;\n-\t  u->st = stamp_fresh();\n-\t  u->proj_cache = new_gen_e_list(setif_region);\n-\t  u->exprs = filtered;\n-\t \n-\t  result = (gen_e)u;\n-\t  term_hash_insert(setif_hash,result,st,gen_e_list_length(filtered)+1);\n-\t\n-\t  setif_stats.distinct_unions++;\n-\t  return result;\n-\t}\n-      else\n-\t{\n-\t  setif_stats.hashed_unions++;\n-\t  return result;\n-\t}\n-    }\n-}\n-\n-gen_e setif_inter(gen_e_list exprs) deletes\n-{\n-  gen_e_list filtered = gen_e_list_filter(setif_region,exprs,filter_one);\n-  \n-  if ( gen_e_list_empty(filtered) )\n-    {\n-      setif_stats.filtered_intersections++;\n-      return setif_one();\n-    }\n-  else if (gen_e_list_length(filtered) == 1)\n-    {\n-      setif_stats.filtered_intersections++;\n-      return gen_e_list_head(filtered);\n-    }\n-\n-  else \n-    {\n-      int i = 0;\n-      gen_e temp,result;\n-      gen_e_list_scanner scan;\n-      stamp st[ gen_e_list_length(filtered) + 1 ];\n-     \n-      st[0] = INTER_TYPE;\n-\n-      gen_e_list_scan(filtered,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  st[++i] = setif_get_stamp(temp);\n-\t}\n-      \n-      if ( (result = \n-\t   term_hash_find(setif_hash,st,gen_e_list_length(filtered)+1)) \n-\t   == NULL )\n-\t{\n-\t  struct setif_inter_ *u = ralloc(setif_region,struct setif_inter_);\n-\t  \n-\t  u->type = UNION_TYPE;\n-\t  u->st = stamp_fresh();\n-\t  u->exprs = filtered;\n-\t \n-\t  result = (gen_e)u;\n-\t  term_hash_insert(setif_hash,result,st,gen_e_list_length(filtered)+1);\n-\t  \n-\t  setif_stats.distinct_intersections++;\n-\t  \n-\t  return result;\n-\t}\n-      else \n-\t{\n-\t  setif_stats.hashed_intersections++;\n-\t  return result;\n-\t}\n-    }\n-}\n-\n-bool setif_is_zero(gen_e e)\n-{\n-  return ((setif_term)e)->type == ZERO_TYPE;\n-}\n-\n-bool setif_is_one(gen_e e)\n-{  \n-  return ((setif_term)e)->type == ONE_TYPE;\n-}\n-\n-bool setif_is_var(gen_e e)\n-{\n-  return ((setif_term)e)->type == VAR_TYPE;\n-}\n-\n-bool setif_is_union(gen_e e)\n-{\n-  return ((setif_term)e)->type == UNION_TYPE;\n-}\n-\n-bool setif_is_inter(gen_e e)\n-{\n-  return ((setif_term)e)->type == INTER_TYPE;\n-}\n-\n-bool setif_is_constant(gen_e e)\n-{\n-  return ((setif_term)e)->type == CONSTANT_TYPE;\n-}\n-\n-char *setif_get_constant_name(gen_e e)\n-{\n-  assert( ((setif_term)e)->type == CONSTANT_TYPE );\n-  \n-  return ((setif_constant_)e)->name;\n-}\n-\n-void setif_init(void)\n-{\n-  setif_region = newregion();\n-  tlb_cache_region = newregion(); \n-  setif_vars = new_setif_var_list(setif_region);\n-  tlb_var_cache = new_setif_var_list(tlb_cache_region);\n-  setif_hash = make_term_hash(setif_region);\n-  tlb_dict = jcoll_create_dict(tlb_cache_region,setif_get_stamp);\n-}\n-\n-\n-\n-static void setif_reset_stats(void)\n-{\n-  setif_stats.fresh = 0;\n-  setif_stats.fresh_small = 0;\n-  setif_stats.fresh_large = 0;\n-\n-  setif_stats.distinct_constructors = 0;\n-  setif_stats.hashed_constructors = 0;\n-  setif_stats.distinct_constants = 0;\n-  setif_stats.hashed_constants = 0;\n-  setif_stats.distinct_unions = 0;\n-  setif_stats.filtered_unions = 0;\n-  setif_stats.hashed_unions = 0;\n-  setif_stats.distinct_intersections = 0;\n-  setif_stats.filtered_intersections = 0;\n-  setif_stats.hashed_intersections = 0;\n-\n-  setif_stats.redundant_pred = 0;\n-  setif_stats.redundant_succ = 0;\n-  setif_stats.redundant_source = 0;\n-  setif_stats.redundant_sink = 0;\n-  \n-  setif_stats.added_pred = 0;\n-  setif_stats.added_succ = 0;\n-  setif_stats.added_source = 0;\n-  setif_stats.added_sink = 0;\n-  \n-  setif_stats.cycles_searched_forward = 0;\n-  setif_stats.cycles_searched_backward = 0;\n-  \n-  setif_stats.cycles_collapsed_forward = 0;\n-  setif_stats.cycles_collapsed_backward = 0;\n-  \n-  setif_stats.cycles_length_forward = 0;\n-  setif_stats.cycles_length_backward = 0;\n-}\n-\n-void setif_reset(void) deletes\n-{\n-  term_hash_delete(setif_hash);\n-  invalidate_tlb_cache();\n-  deleteregion_ptr(&setif_region);\n-  deleteregion_ptr(&tlb_cache_region);\n-\n-  setif_reset_stats();\n-\n-  setif_region = newregion();\n-  tlb_cache_region = newregion();\n-  setif_vars = new_setif_var_list(setif_region);\n-  tlb_var_cache = new_setif_var_list(tlb_cache_region);\n-  setif_hash = make_term_hash(setif_region);\n-}\n-\n-static jcoll tlb_aux(gen_e e)\n-{\n-  if (setif_is_var(e))\n-    {\n-      setif_var v = (setif_var)e;\n-\n-      if ( sv_get_tlb_cache(v) != NULL)\n-\treturn sv_get_tlb_cache(v);\n-      \n-      else\n-\t{\n-\t  jcoll result;\n-\t  gen_e_list sources = new_gen_e_list(tlb_cache_region);\n-\t  jcoll_list jvars = new_jcoll_list(tlb_cache_region);\n-\t  gen_e_list_scanner scan;\n-\t  gen_e lb;\n-\n-\t  gen_e_list_scan(sv_get_lbs(v),&scan);\n-\t  while (gen_e_list_next(&scan,&lb))\n-\t    {\n-\t      if (setif_is_var(lb))\n-\t\tjcoll_list_cons(tlb_aux(lb),jvars);\n-\t      else\n-\t\tgen_e_list_cons(lb,sources);\n-\t\t/* jsources = jcoll_jcons(tlb_cache_region,lb,jsources); */\n-\t    }\n-\n-\t  if (! gen_e_list_empty(sources))\n-\t   jcoll_list_cons(jcoll_create_chain(tlb_dict,sources),jvars);\n-\t  \n-\t  result =\n-\t    jcoll_jjoin(tlb_dict,jvars);\n-\t  \n-\t  set_tlb_cache(v,result);\n-\t  return result;\t\n-\t}\n-    }\n-  else if (setif_is_union(e))\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-      jcoll_list jexprs = new_jcoll_list(tlb_cache_region);\n-      \n-      gen_e_list_scan(setif_get_union(e),&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  jcoll_list_cons(tlb_aux(temp),jexprs);\n-\t}\n-\n-      return jcoll_jjoin(tlb_dict,jexprs);\n-      \n-    }\n-  else\n-    {\n-      failure(\"Unmatched case in setif tlb computation\\n\");\n-      return NULL;\n-    }\n-}\n-\n-gen_e_list setif_tlb(gen_e e) deletes\n-{\n-  return jcoll_flatten(tlb_dict,tlb_aux(e));\n-}\n-\n-void setif_set_proj_cache(gen_e e,gen_e elem)\n-{\n-  if (setif_is_union(e))\n-    {\n-      setif_union_ u = (setif_union_)e;\n-      gen_e_list_cons(elem,u->proj_cache);\n-    }\n-}\n-\n-gen_e_list setif_get_proj_cache(gen_e e)\n-{\n-  if (setif_is_union(e))\n-    {\n-      setif_union_ u = (setif_union_)e;\n-      return u->proj_cache;\n-    }\n-  else\n-    {\n-      failure(\"Term does not cache projections\\n\");\n-      return NULL;\n-    }\n-}\n-\n-\n-bool setif_proj_merge(setif_var v, gen_e se, get_proj_fn_ptr get_proj,\n-\t\t      proj_con_fn_ptr proj_con,fresh_large_fn_ptr fresh_large,\n-\t\t      incl_fn_ptr sort_incl, incl_fn_ptr set_incl) deletes\n-{\n-  gen_e proj;\n-  \n-  if ((proj = sv_get_ub_proj(v,get_proj)) != NULL)\n-    {\n-      sort_incl(proj, se);\n-      return TRUE;\n-    }\n-  \n-  else\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e lb;\n-      \n-      gen_e proj_var;\n-      gen_e proj_cons;\n-      \n-      /* create a projection variable for this projection */ \n-      proj_var = fresh_large(NULL);\n-      \n-      assert(setif_is_var(proj_var));\n-\n-      proj_cons = proj_con(proj_var);\n-\n-      sv_add_ub_proj(v, proj_cons);\n-      \n-      /* apply the transitive rule to each of v's lower bounds */ \n-      gen_e_list_scan(sv_get_lbs(v),&scan);\n-      while (gen_e_list_next(&scan,&lb))\n-\t{\n-\t  set_incl(lb,proj_cons);\n-\t}\n-\t\n-      sort_incl(proj_var, se);\n-      return TRUE;\n-    }\n-\n-}\n-\n-\n-void setif_print_stats(FILE *f)\n-{\n-  fprintf(f,\"\\n========== SetIF Var Stats ==========\\n\");\n-  fprintf(f,\"Fresh : %d\\n\",setif_stats.fresh); \n-  fprintf(f,\"Fresh Small : %d\\n\",setif_stats.fresh_small);\n-  fprintf(f,\"Fresh Large : %d\\n\",setif_stats.fresh_large);\n-  fprintf(f,\"Total : %d\\n\",setif_stats.fresh + setif_stats.fresh_small \n-\t  + setif_stats.fresh_large);\n-  fprintf(f,\"\\n========== SetIF Sort Stats ==========\\n\");\n-  fprintf(f,\"\\n\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Additions\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Pred:   %d\\n\",setif_stats.added_pred);\n-  fprintf(f,\"Succ:   %d\\n\",setif_stats.added_succ);\n-  fprintf(f,\"Source: %d\\n\",setif_stats.added_source);\n-  fprintf(f,\"Sink:   %d\",setif_stats.added_sink);\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Total:  %d\",setif_stats.added_pred + setif_stats.added_succ\n-\t  + setif_stats.added_source + setif_stats.added_sink);\n-  fprintf(f,\"\\n\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Redundant\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Pred:   %d\\n\",setif_stats.redundant_pred);\n-  fprintf(f,\"Succ:   %d\\n\",setif_stats.redundant_succ);\n-  fprintf(f,\"Source: %d\\n\",setif_stats.redundant_source);\n-  fprintf(f,\"Sink:   %d\",setif_stats.redundant_sink);\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Total:  %d\\n\",\n-\t setif_stats.redundant_pred+setif_stats.redundant_succ+setif_stats.redundant_source+setif_stats.redundant_sink);\n-\n-  fprintf(f,\"\\n\");\n-  \n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Forward Cycles\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Collapsed:      %d\\n\",setif_stats.cycles_collapsed_forward);\n-  fprintf(f,\"Searched:       %d\\n\",setif_stats.cycles_searched_forward);\n-  fprintf(f,\"Hit rate:       %f\\n\",\n-\t ((float)setif_stats.cycles_collapsed_forward)/((float)setif_stats.cycles_searched_forward));\n-  fprintf(f,\"Average Length: %f\\n\",\n-\t 1+((float)setif_stats.cycles_length_forward) / ((float)setif_stats.cycles_collapsed_forward));\n-  fprintf(f,\"\\n\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Reverse Cycles\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Collapsed:      %d\\n\",setif_stats.cycles_collapsed_backward);\n-  fprintf(f,\"Searched:       %d\\n\",setif_stats.cycles_searched_backward);\n-  fprintf(f,\"Hit rate:       %f\\n\",\n-\t ((float)setif_stats.cycles_collapsed_backward)/((float)setif_stats.cycles_searched_backward));\n-  fprintf(f,\"Average Length: %f\\n\",\n-\t 1+((float)setif_stats.cycles_length_backward) / ((float)setif_stats.cycles_collapsed_backward));\n-  fprintf(f,\"=====================================\\n\");\n-}\n-\n-/*\n-  for now, print stamps and types for sources and sinks.\n-  must eventually rely on specialized code\n-*/\n-void setif_print_constraint_graph(FILE *f)\n-{ \n-  setif_var_list_scanner scan;\n-  gen_e_list_scanner scan_edges;\n-  gen_e edge;\n-  setif_var v;\n-  dot_node n1,n2;\n-  char temp_str[512];\n-    \n-  graph_attr graph_style[3] = {{g_size,\"\\\"8.5,11\\\"\"},\n-\t\t\t       {g_center,\"true\"},\n-\t\t\t       {g_orientation,\"portrait\"}};\n-  edge_attr succ_edge[1] = {{e_style,\"solid\"}};\n-  edge_attr pred_edge[1] = {{e_style,\"dotted\"}};\n-\n-   dot_start(f,\"setif\",TRUE,TRUE);\n-  dot_global_graph_style(graph_style,3);\n-\n-  setif_var_list_scan(setif_vars,&scan);\n-  while(setif_var_list_next(&scan,&v))\n-    {\n-      snprintf(temp_str,512,\"%s:%ld\",sv_get_name(v),sv_get_stamp(v));\n-      n1 = dot_get_node(temp_str);\n-      gen_e_list_scan(sv_get_lbs(v),&scan_edges);\n-      while(gen_e_list_next(&scan_edges,&edge))\n-\t{\n-\t  if (setif_is_var(edge))\n-\t    {\n-\t      snprintf(temp_str,512,\"%s:%ld\",sv_get_name((setif_var)edge),\n-\t\t       setif_get_stamp(edge));\n-\t      n2 = dot_get_node(temp_str);\n-\t    }\n-\t  else\n-\t    {\n-\t      snprintf(temp_str,512,\"source:%ld\",setif_get_stamp(edge));\n-\t      n2 = dot_get_node(temp_str);\n-\t    }\n-\t  dot_styled_edge(n2,n1,pred_edge,1);\n-\t}\n-\n-      gen_e_list_scan(sv_get_ubs(v),&scan_edges);\n-      while(gen_e_list_next(&scan_edges,&edge))\n-\t{\n-\t  if (setif_is_var(edge))\n-\t    {\n-\t      snprintf(temp_str,512,\"%s:%ld\",sv_get_name((setif_var)edge),\n-\t\t       setif_get_stamp(edge));\n-\t      n2 = dot_get_node(temp_str);\n-\t    }\n-\t  else\n-\t    {\n-\t      snprintf(temp_str,512,\"sink:%ld\",setif_get_stamp(edge));\n-\t      n2 = dot_get_node(temp_str);\n-\t    }\n-\t  dot_styled_edge(n1,n2,succ_edge,1);\n-\t}\n-\n-      gen_e_list_scan(sv_get_ub_projs(v),&scan_edges);\n-      while(gen_e_list_next(&scan_edges,&edge))\n-\t{\n-\t  snprintf(temp_str,512,\"projpat:%ld\",setif_get_stamp(edge));\n-\t  n2 = dot_get_node(temp_str);\n-\t  dot_styled_edge(n1,n2,succ_edge,1);\n-\t}\n-      \n-    }\n-  \n-  dot_end();\n-}\n-"}, {"sha": "7cfabc8175261a923b7c6657df2af8d3b62ba1ad", "filename": "libbanshee/engine/setif-sort.h", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-sort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-sort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetif-sort.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,134 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef SETIF_SORT_H\n-#define SETIF_SORT_H\n-\n-#include <stdio.h>\n-#include \"banshee.h\"\n-#include \"termhash.h\"\n-#include \"setif-var.h\"\n-\n-\n-struct setif_term /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  const sort_kind sort;\n-#endif\n-  const int type;\n-  const stamp st;\n-};\n-\n-typedef struct setif_term *setif_term;\n-\n-extern bool flag_merge_projections;\n-extern bool flag_eliminate_cycles;\n-\n-extern region setif_region;\n-extern term_hash setif_hash;\n-\n-typedef bool (*res_proj_fn_ptr) (setif_var v,gen_e proj) deletes;\n-typedef gen_e (*proj_con_fn_ptr) (gen_e) deletes;\n-\n-stamp setif_get_stamp(gen_e e);\n-void setif_inclusion(con_match_fn_ptr,res_proj_fn_ptr, gen_e, gen_e) deletes;\n-\n-bool setif_proj_merge(setif_var v, gen_e se, get_proj_fn_ptr get_proj,\n-\t\t      proj_con_fn_ptr make_proj,fresh_large_fn_ptr fresh_var,\n-\t\t      incl_fn_ptr sort_incl, incl_fn_ptr set_incl) deletes;\n-\n-gen_e setif_zero(void);\n-gen_e setif_one(void);\n-gen_e setif_fresh(const char *name);\n-gen_e setif_fresh_large(const char *name);\n-gen_e setif_fresh_small(const char *name);\n-gen_e setif_constant(const char *name) deletes;\n-gen_e setif_union(gen_e_list exprs) deletes;\n-gen_e setif_inter(gen_e_list exprs) deletes;\n-bool setif_is_zero(gen_e e);\n-bool setif_is_one(gen_e e);\n-bool setif_is_var(gen_e e);\n-bool setif_is_union(gen_e e);\n-bool setif_is_inter(gen_e e);\n-bool setif_is_constant(gen_e e);\n-char *setif_get_constant_name(gen_e e);\n-\n-gen_e_list setif_get_union(gen_e e);\n-gen_e_list setif_get_inter(gen_e e);\n-\n-gen_e_list setif_tlb(gen_e e) deletes;\n-\n-void setif_set_proj_cache(gen_e e, gen_e elem);\n-gen_e_list setif_get_proj_cache(gen_e e);\n-\n-void setif_init(void);\n-void setif_reset(void) deletes;\n-void setif_print_stats(FILE *f);\n-void setif_print_constraint_graph(FILE *f);\n-\n-extern struct setif_stats setif_stats;\n-struct setif_stats\n-{\n-  int fresh;\n-  int fresh_small;\n-  int fresh_large;\n-\n-  int distinct_constructors;\n-  int hashed_constructors;\n-  int distinct_constants;\n-  int hashed_constants;\n-  int distinct_unions;\n-  int filtered_unions;\n-  int hashed_unions;\n-  int distinct_intersections;\n-  int filtered_intersections;\n-  int hashed_intersections;\n-\n-  int redundant_pred;\n-  int redundant_succ;\n-  int redundant_source;\n-  int redundant_sink;\n-  \n-  int added_pred;\n-  int added_succ;\n-  int added_source;\n-  int added_sink;\n-  \n-  int cycles_searched_forward;\n-  int cycles_searched_backward;\n-  \n-  int cycles_collapsed_forward;\n-  int cycles_collapsed_backward;\n-  \n-  int cycles_length_forward;\n-  int cycles_length_backward;\n-};\n-\n-#endif /* SETIF_SORT_H */"}, {"sha": "21941021284437fb5b3e3cf6208d2bb40b45020a", "filename": "libbanshee/engine/setif-var.c", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetif-var.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,226 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdio.h>\n-#include <assert.h>\n-#include <regions.h>\n-#include \"setif-var.h\"\n-#include \"ufind.h\"\n-#include \"bounds.h\"\n-\n-struct sv_info\n-{\n-  stamp st;\n-  bounds sameregion lbs;\n-  bounds sameregion ubs;\n-  jcoll tlb_cache;\n-  gen_e_list ub_projs;\n-  const char *name;\n-  uf_element component;\n-};\n-\n-typedef struct sv_info *sv_info;\n-\n-DECLARE_UFIND(sv_elt,sv_info)\n- \n-DEFINE_UFIND(sv_elt,sv_info)\n-\n-DEFINE_LIST(setif_var_list,setif_var)\n-\n-#define get_info(v) (sv_elt_get_info((v)->elt))\n-\n-struct setif_var /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  sv_elt elt;\n-};\n-    \n-bool sv_lt(setif_var v1, setif_var v2)\n-{\n-  return ( sv_get_stamp(v1) < sv_get_stamp(v2) );\n-}\n-\n-bool sv_eq(setif_var v1, setif_var v2)\n-{\n-  return ( sv_get_stamp(v1) == sv_get_stamp(v2) );\n-}\n-\n-static setif_var make_var(region r, const char *name, stamp st)\n-{\n-  setif_var result = ralloc(r, struct setif_var);\n-  sv_info info = ralloc(r, struct sv_info);\n- \n-  info->st = st;\n-  info->lbs = bounds_create(r);\n-  info->ubs = bounds_create(r);\n-  info->tlb_cache = NULL;\n-  info->ub_projs = new_gen_e_list(r);\n-  info->name = name ? rstrdup(r,name) : \"fv\";\n-  info->component = new_uf_element(r, NULL);\n-\n-  result->type = VAR_TYPE;\n-  result->elt = new_sv_elt(r,info); \n-  \n-#ifdef NONSPEC\n-  result->sort = setif_sort;\n-#endif  \n-  \n-  return result;\n-}\n-\n-setif_var sv_fresh(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh());\n-}\n-\n-setif_var sv_fresh_large(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_large());\n-}\n-\n-setif_var sv_fresh_small(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_small());\n-}\n-\n-stamp sv_get_stamp(setif_var v)\n-{\n-  return get_info(v)->st;\n-}\n-\n-const char *sv_get_name(setif_var v)\n-{\n-  return get_info(v)->name;\n-}\n-\n-\n-static sv_info combine(sv_info i1, sv_info i2)\n-{\n-  if (i1->st < i2->st)\n-    return i1;\n-  else return i2;\n-}\n-\n-void sv_unify(setif_var v,setif_var_list vars)\n-{\n-  setif_var temp;\n-  setif_var_list_scanner scan;\n-  \n-  setif_var_list_scan(vars,&scan);\n-\n-  while (setif_var_list_next(&scan,&temp))\n-    {\n-      sv_elt_unify(combine,v->elt,temp->elt);\n-    }\n-}\n-\n-gen_e_list sv_get_lbs(setif_var v)\n-{\n-  return bounds_exprs(get_info(v)->lbs);\n-}\n-\n-gen_e_list sv_get_ubs(setif_var v)\n-{\n-  return bounds_exprs(get_info(v)->ubs);\n-}\n-\n-bool sv_add_ub(setif_var v, gen_e e, stamp s)\n-{\n-  return bounds_add(get_info(v)->ubs,e,s);\n-}\n-\n-bool sv_add_lb(setif_var v, gen_e e, stamp s)\n-{\n-  return bounds_add(get_info(v)->lbs,e,s);\n-}\n-\n-bool sv_is_ub(setif_var v, stamp s)\n-{\n-  bool self_edge = sv_get_stamp(v) == s,\n-    in_bounds = bounds_query(get_info(v)->ubs,s);\n-  \n-  return (self_edge || in_bounds);\n-}\n-\n-bool sv_is_lb(setif_var v, stamp s)\n-{\n-\n-  bool self_edge = sv_get_stamp(v) == s,\n-    in_bounds = bounds_query(get_info(v)->lbs,s);\n-  \n-  return (self_edge || in_bounds);\n-\n-}\n-\n-void sv_add_ub_proj(setif_var v, gen_e e)\n-{\n-  gen_e_list_cons(e,get_info(v)->ub_projs);\n-}\n-\n-gen_e sv_get_ub_proj(setif_var v, get_proj_fn_ptr get_proj)\n-{\n-  return get_proj(get_info(v)->ub_projs);\n-}\n-\n-gen_e_list sv_get_ub_projs(setif_var v)\n-{\n-  return get_info(v)->ub_projs;\n-}\n-\n-\n-bool sv_union_component(setif_var v1, setif_var v2)\n-{\n-  if (uf_eq(get_info(v1)->component,get_info(v2)->component))\n-    return FALSE;\n-  \n-  else\n-    {\n-      uf_union(get_info(v1)->component,get_info(v2)->component);\n-      return TRUE;\n-    }\n-}\n-\n-void sv_set_tlb_cache(setif_var v, jcoll j)\n-{\n-  get_info(v)->tlb_cache = j;\n-}\n-\n-jcoll sv_get_tlb_cache(setif_var v)\n-{\n-  return get_info(v)->tlb_cache;\n-}\n-\n-void sv_clear_tlb_cache(setif_var v)\n-{\n-  get_info(v)->tlb_cache = NULL;\n-}"}, {"sha": "6ded7363ae28e156425070fdcfbd66565144772d", "filename": "libbanshee/engine/setif-var.h", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-var.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetif-var.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetif-var.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,72 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef SETIF_VAR_H\n-#define SETIF_VAR_H\n-\n-#include \"linkage.h\"\n-#include \"banshee.h\"\n-#include \"jcollection.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct setif_var *setif_var;\n-\n-DECLARE_LIST(setif_var_list,setif_var)\n-    \n-bool sv_lt(setif_var v1, setif_var v2);\n-bool sv_eq(setif_var v1, setif_var v2);\n-setif_var sv_fresh(region r, const char *name);\n-setif_var sv_fresh_large(region r, const char *name);\n-setif_var sv_fresh_small(region r, const char *name);\n-stamp sv_get_stamp(setif_var v);\n-const char *sv_get_name(setif_var v);\n-void sv_unify(setif_var v,setif_var_list vars);\n-gen_e_list sv_get_lbs(setif_var v);\n-gen_e_list sv_get_ubs(setif_var v);\n-bool sv_add_ub(setif_var v, gen_e e, stamp st);\n-bool sv_add_lb(setif_var v, gen_e e, stamp st);\n-bool sv_is_ub(setif_var v, stamp st);\n-bool sv_is_lb(setif_var v, stamp st);\n-void sv_set_tlb_cache(setif_var v, jcoll j);\n-jcoll sv_get_tlb_cache(setif_var v);\n-void sv_clear_tlb_cache(setif_var v);\n-void sv_add_ub_proj(setif_var v, gen_e e);\n-\n-gen_e sv_get_ub_proj(setif_var v, get_proj_fn_ptr get_proj);\n-gen_e_list sv_get_ub_projs(setif_var v);\n-\n-bool sv_union_component(setif_var v1, setif_var v2);\n-\n-EXTERN_C_END\n-\n-\n-#endif /* SETIF_VAR_H */\n-"}, {"sha": "5d89817ed00a92b19fecd868f9aed69a185dbe18", "filename": "libbanshee/engine/setst-sort.c", "status": "removed", "additions": 0, "deletions": 907, "changes": 907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-sort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-sort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetst-sort.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,907 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <regions.h>\n-#include <assert.h>\n-#include <stdio.h>\n-#include \"bounds.h\"\n-#include \"setst-sort.h\"\n-\n-\n-struct setst_union_\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  gen_e_list exprs;\n-  gen_e_list proj_cache;\n-};\n-\n-struct setst_inter_\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  gen_e_list exprs;\n-};\n-\n-struct setst_constant_\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  char *name;\n-};\n-\n-typedef struct setst_inter_ *setst_inter_;\n-typedef struct setst_union_ *setst_union_;\n-typedef struct setst_constant_ *setst_constant_;\n-\n-static region tlb_cache_region;\n-static jcoll_dict tlb_dict;\n-static setst_var_list setst_vars;\n-static bool setst_changed = FALSE;\n-\n-region setst_region;\n-term_hash setst_hash;\n-struct setst_stats setst_stats;\n-\n-stamp setst_get_stamp(gen_e e)\n-{\n-#ifdef NONSPEC\n-  assert(e->sort == setst_sort);\n-#endif\n-  \n-  if ( ((setst_term)e)->type == VAR_TYPE)\n-    return st_get_stamp( (setst_var)e );\n-  \n-  else\n-    return ((setst_term)e)->st;\n-}\n-\n-static bool eq(gen_e e1, gen_e e2)\n-{\n-  return ( setst_get_stamp(e1) == setst_get_stamp(e2) );\n-}\n-\n-static gen_e_list get_union(gen_e e)\n-{\n-  assert ( ((setst_term)e)->type == UNION_TYPE);\n-\n-  return ( (setst_union_) e)->exprs;\n-}\n-\n-static gen_e_list get_inter(gen_e e)\n-{\n-  assert ( ((setst_term)e)->type == INTER_TYPE);\n-\n-  return ( (setst_inter_) e)->exprs;\n-}\n-\n-static void update_lower_bound(setst_var v, gen_e e)\n-{      \n-  if (setst_is_var(e))\n-    {\n-      if (st_add_lb(v,(setst_var)e))\n-\t{\n-\t  setst_stats.redundant_var++;\n-\t}\n-      else\n-\t{\n-\t  setst_stats.added_var++;\n-\t  setst_changed = TRUE;\n-\t}\n-    }\n-  else\n-    {\n-      if (st_add_source(v, e,setst_get_stamp(e)))\n-\t{\n-\t  setst_stats.redundant_source++;\n-\t}\n-      else\n-\t{\n-\t  setst_stats.added_source++;\n-\t  setst_changed = TRUE;\n-\t}\n-    }\n-  \n-}\n-\n-static void update_upper_bound(setst_var v, gen_e e)\n-{\n-  assert(! setst_is_var(e));\n-\n-  if (st_add_sink(v,e,setst_get_stamp(e)))\n-    {\n-      setst_stats.redundant_sink++;\n-    }\n-  else\n-    {\n-      setst_stats.added_sink++;\n-      setst_changed = TRUE;\n-    }\n-}\n-\n-\n-void setst_inclusion(con_match_fn_ptr con_match,gen_e e1, gen_e e2)\n-{\n-  if (eq(e1,e2))\n-    return;\n-\n-  else if ( setst_is_zero(e1) || setst_is_one(e2) )\n-    return;\n-\n-  else if (setst_is_union(e1))\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-\n-      gen_e_list exprs = get_union(e1);\n-      \n-      gen_e_list_scan(exprs,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  setst_inclusion(con_match,temp,e2);\n-\t}\n-\n-      return;\n-    }\n-\n-  else if (setst_is_inter(e2))\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-      \n-      gen_e_list exprs = get_inter(e2);\n-\n-      gen_e_list_scan(exprs,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  setst_inclusion(con_match,e1,temp);\n-\t}\n-\n-      return;\n-    }\n-\n-  else if (setst_is_var(e2))\n-    {\n-      setst_var v = (setst_var)e2;\n-\n-      update_lower_bound(v,e1);\n-    }\n-\n-  else if (setst_is_var(e1))\n-    {\n-      setst_var v = (setst_var)e1;\n-\n-      update_upper_bound(v,e2);\n-    }\n-\n-  else con_match(e1,e2);\n-}\n-\n-#ifdef NONSPEC\n-static struct setst_term zero = {ZERO_TYPE,setst_sort,ZERO_TYPE};\n-static struct setst_term one  = {ONE_TYPE,setst_sort,ONE_TYPE};\n-#else\n-static struct setst_term zero = {ZERO_TYPE,ZERO_TYPE};\n-static struct setst_term one  = {ONE_TYPE,ONE_TYPE};\n-#endif /* NONSPEC */\n-\n-gen_e setst_zero(void)\n-{\n-  return (gen_e)&zero;\n-}\n-\n-gen_e setst_one(void)\n-{\n-  return (gen_e)&one;\n-}\n-\n-gen_e setst_fresh(const char *name)\n-{\n-  setst_var v = st_fresh(setst_region,name);\n-  setst_var_list_cons(v,setst_vars);\n-  return (gen_e)v;\n-}\n-\n-gen_e setst_fresh_large(const char *name)\n-{\n-  setst_var v = st_fresh_large(setst_region,name);\n-  setst_var_list_cons(v,setst_vars);\n-  return (gen_e)v;\n-}\n-\n-gen_e setst_fresh_small(const char *name)\n-{\n-  setst_var v = st_fresh_small(setst_region,name);\n-  setst_var_list_cons(v,setst_vars);\n-  return (gen_e)v;\n-}\n-\n-gen_e setst_constant(const char *str) deletes\n-{\n-  stamp st[2];\n-  gen_e result;\n-  char *name = rstrdup(setst_region,str);\n-\n-  assert (str != NULL);\n-  \n-  st[0] = CONSTANT_TYPE;\n-  st[1] = stamp_string(name); \n-\n-  if ( (result = term_hash_find(setst_hash,st,2)) == NULL)\n-    {\n-      setst_constant_ c = ralloc(setst_region, struct setst_constant_);\n-      c->type = CONSTANT_TYPE;\n-      c->st = stamp_fresh();\n-      c->name = name;\n-\n-      result = (gen_e) c;\n-      term_hash_insert(setst_hash,result,st,2);\n-      \n-      setst_stats.distinct_constants++;\n-      \n-      return result;\n-    }\n-  \n-  else\n-    {\n-      setst_stats.hashed_constants++;\n-      return result;\n-    }\n-}\n-\n-static bool filter_zero(const gen_e e)\n-{\n-  return (!setst_is_zero(e));\n-}\n-\n-\n-static bool filter_one(const gen_e e)\n-{\n-  return (!setst_is_one(e));\n-}\n-\n-gen_e setst_union(gen_e_list exprs) deletes\n-{\n-  gen_e_list filtered = gen_e_list_filter(setst_region,exprs,filter_zero);\n-  \n-  if ( gen_e_list_empty(filtered) )\n-    {\n-      setst_stats.filtered_unions++;\n-      return setst_zero();\n-    }\n-  else if (gen_e_list_length(filtered) == 1)\n-    {\n-      setst_stats.filtered_unions++;\n-      return gen_e_list_head(filtered);\n-    }\n-\n-  else \n-    {\n-      int i = 0;\n-      gen_e temp,result;\n-      gen_e_list_scanner scan;\n-      stamp st[ gen_e_list_length(filtered) + 1 ];\n-     \n-      st[0] = UNION_TYPE;\n-\n-      gen_e_list_scan(filtered,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  st[++i] = setst_get_stamp(temp);\n-\t}\n-      \n-      if ( (result = \n-\t   term_hash_find(setst_hash,st,gen_e_list_length(filtered)+1)) \n-\t   == NULL )\n-\t{\n-\t  struct setst_union_ *u = ralloc(setst_region,struct setst_union_);\n-\t  \n-\t  u->type = UNION_TYPE;\n-\t  u->st = stamp_fresh();\n-\t  u->proj_cache = new_gen_e_list(setst_region);\n-\t  u->exprs = filtered;\n-\t \n-\t  result = (gen_e)u;\n-\t  term_hash_insert(setst_hash,result,st,gen_e_list_length(filtered)+1);\n-\t\n-\t  setst_stats.distinct_unions++;\n-\t  return result;\n-\t}\n-      else\n-\t{\n-\t  setst_stats.hashed_unions++;\n-\t  return result;\n-\t}\n-    }\n-}\n-\n-gen_e setst_inter(gen_e_list exprs) deletes\n-{\n-  gen_e_list filtered = gen_e_list_filter(setst_region,exprs,filter_one);\n-  \n-  if ( gen_e_list_empty(filtered) )\n-    {\n-      setst_stats.filtered_intersections++;\n-      return setst_one();\n-    }\n-  else if (gen_e_list_length(filtered) == 1)\n-    {\n-      setst_stats.filtered_intersections++;\n-      return gen_e_list_head(filtered);\n-    }\n-\n-  else \n-    {\n-      int i = 0;\n-      gen_e temp,result;\n-      gen_e_list_scanner scan;\n-      stamp st[ gen_e_list_length(filtered) + 1 ];\n-     \n-      st[0] = INTER_TYPE;\n-\n-      gen_e_list_scan(filtered,&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  st[++i] = setst_get_stamp(temp);\n-\t}\n-      \n-      if ( (result = \n-\t   term_hash_find(setst_hash,st,gen_e_list_length(filtered)+1)) \n-\t   == NULL )\n-\t{\n-\t  struct setst_inter_ *u = ralloc(setst_region,struct setst_inter_);\n-\t  \n-\t  u->type = UNION_TYPE;\n-\t  u->st = stamp_fresh();\n-\t  u->exprs = filtered;\n-\t \n-\t  result = (gen_e)u;\n-\t  term_hash_insert(setst_hash,result,st,gen_e_list_length(filtered)+1);\n-\t  \n-\t  setst_stats.distinct_intersections++;\n-\t  \n-\t  return result;\n-\t}\n-      else \n-\t{\n-\t  setst_stats.hashed_intersections++;\n-\t  return result;\n-\t}\n-    }\n-}\n-\n-\n-gen_e_list setst_get_union(gen_e e)\n-{\n-  assert (((setst_term)e)->type == UNION_TYPE);\n-\n-  return ((setst_union_)e)->exprs;\n-}\n-\n-\n-gen_e_list setst_get_inter(gen_e e)\n-{\n-  assert (((setst_term)e)->type == INTER_TYPE);\n-\n-  return ((setst_inter_)e)->exprs;\n-}\n-\n-static void invalidate_tlb_cache(void)\n-{\n-  assert(tlb_cache_region);\n-\n-  jcoll_delete_dict(tlb_dict);\n-  setst_var_list_app(setst_vars,st_clear_tlb_cache);\n-  deleteregion_ptr(&tlb_cache_region);\n-  \n-  tlb_cache_region = newregion();\n-  tlb_dict = jcoll_create_dict(tlb_cache_region,setst_get_stamp);\n-}\n-\n-static void set_tlb_cache(setst_var v,jcoll j)\n-{\n-  st_set_tlb_cache(v,j);\n-}\n-\n-static void collect_sinks(bounds b,setst_var v)\n-{\n-  gen_e sink;\n-  gen_e_list_scanner scan;\n-\n-  gen_e_list_scan(st_get_sinks(v),&scan);\n-\n-  while (gen_e_list_next(&scan,&sink))\n-    {\n-      bounds_add(b,sink,setst_get_stamp(sink));\n-    }  \n-}\n-\n-static void collect_sources(bounds b, setst_var v)\n-{\n-  gen_e source;\n-  gen_e_list_scanner scan;\n-\n-  gen_e_list_scan(st_get_sources(v),&scan);\n-\n-  while (gen_e_list_next(&scan,&source))\n-    {\n-      bounds_add(b,source,setst_get_stamp(source));\n-    }  \n-}\n-\n-static void collect_lower_bounds(bounds b, setst_var v)\n-{\n-  setst_var lb;\n-  setst_var_list_scanner scan;\n-\n-  setst_var_list_scan(st_get_lbs(v),&scan);\n-\n-  while (setst_var_list_next(&scan,&lb))\n-    {\n-      bounds_add(b,(gen_e)lb,st_get_stamp(lb));\n-    }  \n-}\n- \n-static void apply_sources(setst_var witness, bounds sources)\n-{\n-  gen_e source;\n-  gen_e_list_scanner scan;\n-\n-  gen_e_list_scan(bounds_exprs(sources),&scan);\n-\n-  while (gen_e_list_next(&scan,&source))\n-    {\n-      if ( st_add_source(witness,source,setst_get_stamp(source)))\n-\tsetst_stats.redundant_source++;\n-\t\n-      else\n-\tsetst_stats.added_source++;\n-    }  \n-}\n-\n-static void apply_sinks(setst_var witness, bounds sinks)\n-{\n-  gen_e sink;\n-  gen_e_list_scanner scan;\n-\n-  gen_e_list_scan(bounds_exprs(sinks),&scan);\n-\n-  while (gen_e_list_next(&scan,&sink))\n-    {\n-      if (st_add_sink(witness,sink,setst_get_stamp(sink)))\n-\tsetst_stats.redundant_sink++;\n-\t\n-      else\n-\tsetst_stats.added_sink++;\n-    }  \n-}\n-\n-static void apply_lower_bounds(setst_var witness,bounds lower)\n-{\n-  gen_e lb;\n-  gen_e_list_scanner scan;\n-\n-  gen_e_list_scan(bounds_exprs(lower),&scan);\n-\n-  while (gen_e_list_next(&scan,&lb))\n-    {\n-      if (st_add_lb(witness,(setst_var)lb))\n-\tsetst_stats.redundant_var++;\n-      else\n-\tsetst_stats.added_var++;\n-    }  \n-}\n-\n-static void collapse_cycle(setst_var witness, setst_var_list cycle) deletes\n-{\n-  setst_var_list_scanner var_scan;\n-  setst_var temp;\n-  region scratch_rgn = newregion();\n-\n-  bounds sources = bounds_create(scratch_rgn);\n-  bounds sinks = bounds_create(scratch_rgn);\n-  bounds lower = bounds_create(scratch_rgn);\n- \n-\n-  setst_stats.cycles_collapsed++;\n-\n-  /* force at least another iteration */\n-  setst_changed = TRUE;\n-\n-  /* collect all bounds */\n-  setst_var_list_scan(cycle,&var_scan);\n-  while (setst_var_list_next(&var_scan,&temp))\n-    {\n-      collect_sources(sources,temp);\n-      collect_sinks(sinks,temp);\n-      collect_lower_bounds(lower,temp);  \n-    }\n- \n-  /* unify all vars */\n-  st_unify(witness,cycle);\n-\n-  /* add all bounds back */\n-  apply_sources(witness,sources);\n-  apply_sinks(witness,sinks);\n-  apply_lower_bounds(witness,lower);\n- \n-  /* cleanup */\n-  bounds_delete(sources);\n-  bounds_delete(sinks);\n-  bounds_delete(lower);\n-  deleteregion(scratch_rgn);\n-\n-  /* remove self edges */\n-  st_repair_bounds(witness);\n-}\n-/*\n-static bool cycle_detect(setst_var goal, setst_var_list path,\n-\t\t\t setst_var_list *result)\n-{\n-  int pos = st_get_path_pos(goal);\n-  setst_stats.cycles_searched++;\n-  \n-  if (pos)\n-    {  \n-      setst_var_list_scanner scan;\n-      setst_var temp;\n-      setst_var_list cycle = new_setst_var_list(tlb_cache_region);\n-      \n-      setst_var_list_scan(path,&scan);\n-      while(setst_var_list_next(&scan,&temp))\n-\t{\n-\t  if (st_get_path_pos(temp) >= pos)\n-\t    setst_var_list_cons(temp,cycle);\n-\t}\n-      \n-      *result = cycle;\n-      return TRUE;\n-    }\n-  \n-  else \n-    return FALSE;\n-}\n-\n-*/\n-static bool cycle_detect(setst_var goal, setst_var_list path,\n-\t\t\t setst_var_list *result)\n-{\n-  setst_var_list cycle = \n-    setst_var_list_reverse(setst_var_list_copy(tlb_cache_region,path));\n-\n-  setst_stats.cycles_searched++;\n-\n-  while (!setst_var_list_empty(cycle) && \n-\t !eq((gen_e)setst_var_list_head(cycle),(gen_e)goal))\n-    {\n-      setst_var_list_tail(cycle);\n-    }\n-  \n-  if (setst_var_list_empty(cycle))\n-    {\n-      return FALSE;\n-    }\n-  else\n-    {\n-      *result = cycle;\n-      return TRUE;\n-    }\n-}\n-\n-static jcoll tlb_aux(gen_e e,int path_len,setst_var_list path) deletes\n-{\n-  if (setst_is_var(e))\n-    {\n-      setst_var_list cycle;\n-      setst_var v = (setst_var)e;\n-      if ( cycle_detect(v,path,&cycle) )\n-\t{\n-\t  setst_stats.cycles_length += setst_var_list_length(cycle);\n-\t  collapse_cycle(v,cycle);\n-\t  return NULL;\n-\t}\n-      else\n-\t{\n-\t  if (st_get_tlb_cache(v) != NULL)\n-\t    return st_get_tlb_cache(v);\n-\t  else \n-\t    {\n-\t      jcoll result;\n-\t      setst_var_list_scanner scan;\n-\t      setst_var lb;\n-\t      jcoll_list jvars = new_jcoll_list(tlb_cache_region);\n-\t      \n-\t      gen_e_list sources = gen_e_list_copy(tlb_cache_region,\n-\t\t\t\t\t\t   st_get_sources(v));\n-\t      \n-\t      st_set_path_pos(v,path_len);\n-\t      setst_var_list_scan(st_get_lbs(v),&scan);\n-\t      while (setst_var_list_next(&scan,&lb))\n-\t\t{\n-\t\t  setst_var_list_cons(v,path);\n-\t\t  jcoll_list_cons(tlb_aux((gen_e)lb,++path_len,path),\n-\t\t\t\t  jvars);\n-\t\t  setst_var_list_tail(path); \n-\t\t}\n-\t      \n-\t      if (! gen_e_list_empty(sources))\n-\t\tjcoll_list_cons(jcoll_create_chain(tlb_dict,sources),\n-\t\t\t\tjvars);\n-\t      result = jcoll_jjoin(tlb_dict,jvars);\n-\t      set_tlb_cache(v,result);\n-\t      st_set_path_pos(v,0);\n-\t      return result;\n-\t    }\n-\t  \n-\t}\n-    }\n-  else if (setst_is_union(e))\n-    {\n-      gen_e_list_scanner scan;\n-      gen_e temp;\n-      jcoll_list jexprs = new_jcoll_list(tlb_cache_region);\n-      \n-      gen_e_list_scan(setst_get_union(e),&scan);\n-      while (gen_e_list_next(&scan,&temp))\n-\t{\n-\t  jcoll_list_cons(tlb_aux(temp,++path_len,path),jexprs);\n-\t}\n-      \n-      return jcoll_jjoin(tlb_dict,jexprs);\n-    }\n-  else\n-    {\n-      fail(\"Unmatched case in setst tlb computation\\n\");\n-      return NULL;\n-    }\n-}\n-static gen_e_list tlb(gen_e e)\n-{\n-  return jcoll_flatten(tlb_dict,\n-\t\t       tlb_aux(e,1,new_setst_var_list(tlb_cache_region)) );\n-}\n-static void match_sinks(incl_fn_ptr setst_incl)\n-{\n-  gen_e_list_scanner tlb_scanner, sink_scanner;\n-  setst_var_list_scanner var_scanner;\n-  setst_var v;\n-  gen_e lb, sink;\n-  \n-  setst_var_list_scan(setst_vars,&var_scanner);\n-  \n-  while (setst_var_list_next(&var_scanner,&v))\n-    {\n-      gen_e_list tlbs = tlb((gen_e)v);\n-      gen_e_list snks = st_get_sinks(v);\n-      \n-      \n-      if(gen_e_list_empty(st_get_sinks(v)))\n-\t{\n-\t  setst_stats.no_sinks++;\n-\t  continue;\n-\t}\n-      else if(st_get_seen(v))\n-\t{\n-\t  setst_stats.incycle_vars++;\n-\t  continue;\n-\t}\n-      else if (gen_e_list_length(tlbs) == st_get_src_sz(v) \n-\t       && gen_e_list_length(snks) == st_get_snk_sz(v) )\n-\t{\n-\t  setst_stats.unchanged_vars++;\n-\t  continue;\n-\t}\n-      st_set_seen(v,TRUE);\n-      \n-      st_set_src_sz(v,gen_e_list_length(tlbs));\n-      st_set_snk_sz(v,gen_e_list_length(snks));\n-      \n-      gen_e_list_scan(tlbs,&tlb_scanner);\n-      \n-      while (gen_e_list_next(&tlb_scanner,&lb))\n-\t{\n-\t  gen_e_list_scan(snks,&sink_scanner);\n-\t  \n-\t  while (gen_e_list_next(&sink_scanner,&sink))\n-\t    setst_incl(lb,sink);\n-\t}\n-    }\n-}\n-static void iterate(incl_fn_ptr setst_incl)\n-{\n-  setst_var_list_scanner var_scanner;\n-  setst_var v; \n-  /* static int iterations = 0; */\n-  setst_changed = FALSE;\n-  \n-  setst_var_list_scan(setst_vars,&var_scanner);\n-  while (setst_var_list_next(&var_scanner,&v))\n-    {\n-      st_set_seen(v,FALSE);\n-    }\n-  \n-  invalidate_tlb_cache();\n-  match_sinks(setst_incl);\n-  \n-  /*  fprintf(stderr,\"Iterations : %d\\n\",++iterations); */\n-  \n-  if (setst_changed)\n-    iterate(setst_incl);\n-}  \n-gen_e_list setst_tlb(gen_e e,incl_fn_ptr setst_incl) deletes\n-{\n-  if (! setst_changed)\n-    {\n-      return tlb(e);\n-    }\n-  else\n-    {\n-      iterate(setst_incl);\n-      return tlb(e);\n-    }\n-  \n-}\n-\n-void setst_set_proj_cache(gen_e e, gen_e elem)\n-{\n-  if (setst_is_union(e))\n-    {\n-      setst_union_ u = (setst_union_)e;\n-      gen_e_list_cons(elem,u->proj_cache);\n-    }\n-}\n-\n-gen_e_list setst_get_proj_cache(gen_e e)\n-{\n-\n-  if (setst_is_union(e))\n-    {\n-      setst_union_ u = (setst_union_)e;\n-      return u->proj_cache;\n-    }\n-  else\n-    {\n-      fail(\"Term does not cache projections\\n\");\n-      return NULL;\n-    }\n-}\n-\n-void setst_init(void)\n-{\n-  setst_region = newregion();\n-  tlb_cache_region = newregion();\n-  setst_hash = make_term_hash(setst_region);\n-  setst_vars = new_setst_var_list(setst_region);\n-  tlb_dict = jcoll_create_dict(tlb_cache_region,setst_get_stamp);\n-}\n-\n-void setst_reset(void) deletes\n-{\n-  term_hash_delete(setst_hash);\n-  deleteregion_ptr(&setst_region);\n-\n-  setst_region = newregion();\n-  setst_hash = make_term_hash(setst_region);\n-  setst_vars = new_setst_var_list(setst_region);\n-  invalidate_tlb_cache();\n-  setst_changed = FALSE;\n-}\n-\n-bool setst_is_zero(gen_e e)\n-{\n-  return ((setst_term)e)->type == ZERO_TYPE;\n-}\n-\n-bool setst_is_one(gen_e e)\n-{  \n-  return ((setst_term)e)->type == ONE_TYPE;\n-}\n-\n-bool setst_is_var(gen_e e)\n-{\n-  return ((setst_term)e)->type == VAR_TYPE;\n-}\n-\n-bool setst_is_union(gen_e e)\n-{\n-  return ((setst_term)e)->type == UNION_TYPE;\n-}\n-\n-bool setst_is_inter(gen_e e)\n-{\n-  return ((setst_term)e)->type == INTER_TYPE;\n-}\n-\n-char *setst_get_constant_name(gen_e e)\n-{\n-  assert( ((setst_term)e)->type == CONSTANT_TYPE );\n-  \n-  return ((setst_constant_)e)->name;\n-}\n-\n-void setst_print_stats(FILE *f)\n-{ \n-  fprintf(f,\"\\n========== SetST Var Stats ==========\\n\");\n-  fprintf(f,\"Fresh : %d\\n\",setst_stats.fresh); \n-  fprintf(f,\"Fresh Small : %d\\n\",setst_stats.fresh_small);\n-  fprintf(f,\"Fresh Large : %d\\n\",setst_stats.fresh_large);\n-  fprintf(f,\"Total : %d\\n\",setst_stats.fresh + setst_stats.fresh_small \n-\t  + setst_stats.fresh_large);\n-  fprintf(f,\"\\n========== SetST Sort Stats ==========\\n\");\n-  fprintf(f,\"\\n\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Additions\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Var:   %d\\n\",setst_stats.added_var);\n-  fprintf(f,\"Source: %d\\n\",setst_stats.added_source);\n-  fprintf(f,\"Sink:   %d\",setst_stats.added_sink);\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Total:  %d\",setst_stats.added_var + setst_stats.added_source\n-\t  + setst_stats.added_sink);\n-  fprintf(f,\"\\n\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Redundant\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Var:   %d\\n\",setst_stats.redundant_var);\n-  fprintf(f,\"Source: %d\\n\",setst_stats.redundant_source);\n-  fprintf(f,\"Sink:   %d\",setst_stats.redundant_sink);\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Total:  %d\\n\",\n-\t setst_stats.redundant_var + setst_stats.redundant_source\n-\t  + setst_stats.redundant_sink);\n- \n-  fprintf(f,\"\\n\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Iteration Optimizations\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Skipped vars:   %d\\n\",setst_stats.incycle_vars);\n-  fprintf(f,\"Unchanged vars: %d\\n\",setst_stats.unchanged_vars);\n-  fprintf(f,\"Vars w/o sinks: %d\\n\",setst_stats.no_sinks);\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Cycles\");\n-  fprintf(f,\"\\n------------------------------\\n\");\n-  fprintf(f,\"Collapsed:      %d\\n\",setst_stats.cycles_collapsed);\n-  fprintf(f,\"Searched:       %d\\n\",setst_stats.cycles_searched);\n-  fprintf(f,\"Hit rate:       %f\\n\",\n-\t ((float)setst_stats.cycles_collapsed)/((float)setst_stats.cycles_searched));\n-  fprintf(f,\"Average Length: %f\\n\",\n-\t ((float)setst_stats.cycles_length) / ((float)setst_stats.cycles_collapsed));\n-  fprintf(f,\"=====================================\\n\");\n-}\n-"}, {"sha": "5aafde398cfc035adc22f04f2d3dd25da1a236e6", "filename": "libbanshee/engine/setst-sort.h", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-sort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-sort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetst-sort.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,121 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef SETST_SORT_H\n-#define SETST_SORT_H\n-\n-#include \"banshee.h\"\n-#include \"termhash.h\"\n-#include \"setst-var.h\"\n-\n-extern region setst_region;\n-extern term_hash setst_hash;\n-\n-struct setst_term /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-};\n-\n-typedef struct setst_term *setst_term;\n-\n-stamp setst_get_stamp(gen_e e);\n-void setst_inclusion(con_match_fn_ptr,gen_e, gen_e);\n-\n-gen_e setst_zero(void);\n-gen_e setst_one(void);\n-gen_e setst_fresh(const char *name);\n-gen_e setst_fresh_large(const char *name);\n-gen_e setst_fresh_small(const char *name);\n-gen_e setst_constant(const char *name) deletes;\n-gen_e setst_union(gen_e_list exprs) deletes;\n-gen_e setst_inter(gen_e_list exprs) deletes;\n-bool setst_is_zero(gen_e e);\n-bool setst_is_one(gen_e e);\n-bool setst_is_var(gen_e e);\n-bool setst_is_union(gen_e e);\n-bool setst_is_inter(gen_e e);\n-bool setst_is_constant(gen_e e);\n-\n-char *setst_get_constant_name(gen_e e);\n-gen_e_list setst_get_union(gen_e e);\n-gen_e_list setst_get_inter(gen_e e);\n-\n-gen_e_list setst_tlb(gen_e e,incl_fn_ptr setst_incl) deletes;\n-void setst_set_proj_cache(gen_e e, gen_e elem);\n-gen_e_list setst_get_proj_cache(gen_e e);\n-\n-\n-void setst_init(void);\n-void setst_reset(void) deletes;\n-void setst_print_stats(FILE *f);\n-\n-extern struct setst_stats setst_stats;\n-\n-struct setst_stats\n-{\n-  int fresh;\n-  int fresh_large;\n-  int fresh_small;\n-\n-  int distinct_constructors;\n-  int hashed_constructors;\n-  int distinct_constants;\n-  int hashed_constants;\n-  int distinct_unions;\n-  int filtered_unions;\n-  int hashed_unions;\n-  int distinct_intersections;\n-  int filtered_intersections;\n-  int hashed_intersections;\n-\n-  int redundant_var;\n-  int redundant_source;\n-  int redundant_sink;\n-  \n-  int added_var;\n-  int added_source;\n-  int added_sink;\n-\n-  int incycle_vars;\n-  int unchanged_vars;\n-  int no_sinks;\n-  \n-  int cycles_searched;\n-  int cycles_collapsed;\n-  int cycles_length;\n-};\n-\n-\n-#endif /* SETST_SORT_H */\n-"}, {"sha": "ba4c59eb5de20af2347327909a753c4e17f0e704", "filename": "libbanshee/engine/setst-var.c", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetst-var.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,249 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdio.h>\n-#include <assert.h>\n-#include <regions.h>\n-#include \"setst-var.h\"\n-#include \"jcollection.h\"\n-#include \"ufind.h\"\n-#include \"bounds.h\"\n-\n-struct st_info\n-{\n-  stamp st;\n-  bounds lbs;\n-  bounds sources;\n-  bounds sinks;\n-  jcoll tlb_cache;\n-  const char *name;\n-  bool seen;\n-  int path_pos;\n-  int src_sz;\n-  int snk_sz;\n-};\n-\n-typedef struct st_info *st_info;\n-\n-DECLARE_UFIND(st_elt,st_info)\n-\n-DEFINE_UFIND(st_elt,st_info)\n-\n-DEFINE_LIST(setst_var_list,setst_var)\n-\n-#define get_info(v) (st_elt_get_info((v)->elt))\n-\n-struct setst_var /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  st_elt elt;\n-};\n-\n-bool st_eq(setst_var v1, setst_var v2)\n-{\n-  return (st_get_stamp(v1) == st_get_stamp(v2));\n-}\n-\n-static setst_var make_var(region r, const char *name, stamp st)\n-{\n-  setst_var result = ralloc(r,struct setst_var);\n-  st_info info = ralloc(r, struct st_info);\n-\n-  info->st = st;\n-  info->lbs = bounds_create(r);\n-  info->sources = bounds_create(r);\n-  info->sinks = bounds_create(r);\n-  info->tlb_cache = NULL;\n-  info->name = name ? rstrdup(r,name) : \"fv\";\n-  info->seen = FALSE;\n-  info->path_pos = 0;\n-  info->src_sz = 0;\n-  info->snk_sz = 0;\n-\n-  result->type = VAR_TYPE;\n-  result->elt = new_st_elt(r,info);\n-\n-\n-#ifdef NONSPEC\n-  result->sort = setst_sort;\n-#endif\n-\n-  return result;\n-}\n-\n-setst_var st_fresh(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh());\n-}\n-\n-setst_var st_fresh_large(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_large());\n-}\n-\n-setst_var st_fresh_small(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_small());\n-}\n-\n-stamp st_get_stamp(setst_var v)\n-{\n-  return get_info(v)->st;\n-}\n-\n-const char *st_get_name(setst_var v)\n-{\n-  return get_info(v)->name;\n-}\n-\n-void st_unify(setst_var v,setst_var_list vars)\n-{\n-  setst_var temp;\n-  setst_var_list_scanner scan;\n-\n-  setst_var_list_scan(vars,&scan);\n-\n-  while (setst_var_list_next(&scan,&temp)) \n-    {\n-      st_elt_union(v->elt,temp->elt);\n-    }\n-}\n-\n-setst_var_list st_get_lbs(setst_var v)\n-{\n-  return (setst_var_list)bounds_exprs(get_info(v)->lbs);\n-}\n-\n-gen_e_list st_get_sources(setst_var v)\n-{\n-  return bounds_exprs(get_info(v)->sources);\n-}\n-\n-gen_e_list st_get_sinks(setst_var v)\n-{\n-  return bounds_exprs(get_info(v)->sinks);\n-}\n-\n-bool st_add_lb(setst_var v, setst_var lb)\n-{\n-  return bounds_add(get_info(v)->lbs,(gen_e)lb,st_get_stamp(lb));\n-}\n-\n-bool st_add_source(setst_var v, gen_e source, stamp s)\n-{\n-  return bounds_add(get_info(v)->sources,source,s);\n-}\n-\n-bool st_add_sink(setst_var v, gen_e sink, stamp s)\n-{\n-  return bounds_add(get_info(v)->sinks,sink,s);\n-}\n-\n-jcoll st_get_tlb_cache(setst_var v)\n-{\n-  return get_info(v)->tlb_cache;\n-}\n-\n-void st_set_tlb_cache(setst_var v, jcoll j)\n-{\n-  get_info(v)->tlb_cache = j;\n-}\n-\n-void st_clear_tlb_cache(setst_var v)\n-{\n-  get_info(v)->tlb_cache = NULL;\n-}\n-\n-gen_e st_get_ub_proj(setst_var v, get_proj_fn_ptr get_proj)\n-{\n-  return get_proj(st_get_sinks(v));\n-}\n-static setst_var neq_temp;\n-static bool neq (const setst_var v2)\n-{\n-  return (!(st_get_stamp (neq_temp) == st_get_stamp (v2)));\n-}\n-void st_repair_bounds(setst_var v1)\n-{\n-  setst_var_list lbs;\n-  neq_temp = v1;\n-  lbs = setst_var_list_filter2(st_get_lbs(v1),neq);  \n-\n-  bounds_set(get_info(v1)->lbs,(gen_e_list)lbs);\n-}\n-\n-void st_set_path_pos(setst_var v, int pos)\n-{\n-  get_info(v)->path_pos = pos;\n-}\n-\n-int st_get_path_pos(setst_var v)\n-{\n-  return get_info(v)->path_pos;\n-}\n-\n-void st_set_seen(setst_var v, bool b)\n-{\n-  get_info(v)->seen = b;\n-}\n-\n-bool st_get_seen(setst_var v)\n-{\n-  return get_info(v)->seen;\n-}\n-\n-void st_set_src_sz(setst_var v, int size)\n-{\n-  get_info(v)->src_sz = size;\n-}\n-\n-int st_get_src_sz(setst_var v)\n-{\n-  return get_info(v)->src_sz;\n-}\n-\n-void st_set_snk_sz(setst_var v, int size)\n-{\n-  get_info(v)->snk_sz = size;\n-}\n-\n-int st_get_snk_sz(setst_var v)\n-{\n-  return get_info(v)->snk_sz;\n-}\n-\n-\n-\n-\n-\n-"}, {"sha": "6ef2f84a0059b9c5e4a673e0a8ecc996ca3e8ef8", "filename": "libbanshee/engine/setst-var.h", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-var.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fsetst-var.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fsetst-var.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,77 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef SETST_VAR_H\n-#define SETST_VAR_H\n-\n-#include \"linkage.h\"\n-#include \"banshee.h\"\n-#include \"jcollection.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct setst_var *setst_var;\n-\n-DECLARE_LIST(setst_var_list,setst_var)\n-\n-bool st_eq(setst_var v1, setst_var v2);\n-setst_var st_fresh(region r, const char *name);\n-setst_var st_fresh_large(region r, const char *name);\n-setst_var st_fresh_small(region r, const char *name);\n-stamp st_get_stamp(setst_var v);\n-const char *st_get_name(setst_var v);\n-void st_unify(setst_var v,setst_var_list vars);\n-setst_var_list st_get_lbs(setst_var v); \n-gen_e_list st_get_sources(setst_var v);\n-gen_e_list st_get_sinks(setst_var v);\n-gen_e st_get_ub_proj(setst_var v, get_proj_fn_ptr get_proj);\n-bool st_add_lb(setst_var v, setst_var lb);\n-bool st_add_source(setst_var v, gen_e source, stamp s);\n-bool st_add_sink(setst_var v, gen_e sink, stamp s);\n-\n-void st_set_path_pos(setst_var v, int pos);\n-int st_get_path_pos(setst_var v);\n-void st_set_seen(setst_var v, bool b);\n-bool st_get_seen(setst_var v);\n-void st_set_src_sz(setst_var v, int size);\n-int st_get_src_sz(setst_var v);\n-void st_set_snk_sz(setst_var v, int size);\n-int st_get_snk_sz(setst_var v);\n-\n-jcoll st_get_tlb_cache(setst_var v);\n-void st_set_tlb_cache(setst_var v, jcoll j);\n-void st_clear_tlb_cache(setst_var v);\n-\n-void st_repair_bounds(setst_var v);\n-\n-EXTERN_C_END\n-\n-#endif /* SETST_VAR_H */\n-"}, {"sha": "8a1f5a95faf7301ff02895f504a61aa1ef30575d", "filename": "libbanshee/engine/stamp.c", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fstamp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fstamp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fstamp.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,120 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdio.h>\n-#include \"stamp.h\"\n-#include \"util.h\"\n-#include \"hash.h\"\n-#include \"list.h\"\n-#define INITIAL_SIZE 32\n-#define INITIAL1 0\n-#define INITIAL2 2000\n-#define INITIAL3 536870911\n-#define MIN -1073741824 /* -2^30 */\n-#define MAX  1073741824 /* 2^30 */\n-\n-static hash_table str_hash;\n-static region str_hash_rgn;\n-\n-static int count1 = INITIAL1, count2 = INITIAL2, count3 = INITIAL3;\n-static int bounds1 = MIN, bounds2 = 536870911, bounds3 = MAX;\n-\n-static inline stamp check1(int i)\n-{\n-  if (i <= bounds1)\n-    fail (\"Unable to create stamp with small index\\n\");\n-  return i;\n-}\n-\n-static inline stamp check2(int i)\n-{\n-  if (i > bounds2)\n-    fail (\"Unable to create a stamp with regular index\\n\");\n-  return i;\n-}\n-\n-static inline stamp check3(int i)\n-{\n-  if (i >= bounds3)\n-    fail (\"Unable to create a stamp with large index\\n\");\n-  return i;\n-}\n-\n-stamp stamp_fresh(void)\n-{\n-  return (check2(++count2));\n-}\n-\n-stamp stamp_fresh_small(void)\n-{\n-  return (check1(--count1));\n-}\n-\n-stamp stamp_fresh_large(void)\n-{\n-  return (check3(++count3));\n-}\n-\n-stamp stamp_string(const char *str) deletes\n-{\n-  long st;\n-  assert(str_hash != NULL);\n-\n-  if (! hash_table_lookup(str_hash,(hash_key)str, (void *)(char *) &st))\n-    {\n-      st = stamp_fresh();\n-      (void)hash_table_insert(str_hash,(hash_key)str,(hash_data) st);\n-    }\n-  return st;\n-}\n-\n-void stamp_reset(void) deletes\n-{\n-  count1 = INITIAL1;\n-  count2 = INITIAL2;\n-  count3 = INITIAL3;\n-  hash_table_reset(str_hash);\n-  deleteregion_ptr(&str_hash_rgn);\n-}\n-\n-\n-\n-void stamp_init(void)\n-{\n-  str_hash_rgn = newregion();\n-  str_hash = make_string_hash_table(str_hash_rgn,INITIAL_SIZE,FALSE);\n-\n-}\n-#if 0\n-const char *stamp_to_str(region r,stamp st)\n-{\n-  return inttostr(r,st);\n-}\n-#endif"}, {"sha": "52c55598327078eaad9f5eb2a829f0fc15a90c85", "filename": "libbanshee/engine/stamp.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fstamp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fstamp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fstamp.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,57 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef STAMP_H\n-#define STAMP_H\n-\n-#include <regions.h>\n-#include \"linkage.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef long stamp;\n-\n-stamp stamp_fresh(void);\n-stamp stamp_fresh_small(void);\n-stamp stamp_fresh_large(void);\n-\n-stamp stamp_string(const char *) deletes;\n-\n-const char *stamp_to_str(region r,stamp st);\n-\n-void stamp_reset(void) deletes;\n-void stamp_init(void);\n-\n-EXTERN_C_END\n-\n-#endif /* STAMP_H */\n-\n-\n-"}, {"sha": "7503f296338d18bbbd2a12a33ed4246912668136", "filename": "libbanshee/engine/term-sort.c", "status": "removed", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-sort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-sort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fterm-sort.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,291 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <regions.h>\n-#include <assert.h>\n-#include <ansidecl.h>\n-#include \"term-sort.h\"\n-\n-struct term_constant_ /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  char *name;\n-};\n-\n-typedef struct term_constant_ *term_constant_;\n-\n-region term_sort_region;\n-term_hash term_sort_hash;\n-bool flag_occurs_check = FALSE;\n-\n-struct term_stats term_stats;\n-\n-stamp term_get_stamp(gen_e e)\n-{\n-  if ( ((gen_term)e)->type == VAR_TYPE )\n-    return ((gen_term)term_get_ecr(e))->st;\n-  else \n-    return ((gen_term)e)->st;\n-}\n-\n-gen_e term_fresh(const char *name)\n-{\n-  term_stats.fresh++;\n-  return (gen_e)tv_fresh(term_sort_region,name);\n-}\n-\n-gen_e term_fresh_large(const char *name)\n-{\n-  term_stats.fresh_large++;\n-  return (gen_e)tv_fresh_large(term_sort_region,name);\n-}\n-\n-gen_e term_fresh_small(const char *name)\n-{\n-  term_stats.fresh_small++;\n-  return (gen_e)tv_fresh_small(term_sort_region,name);\n-}\n-\n-\n-#ifdef NONSPEC\n-static struct gen_term zero = {ZERO_TYPE,term_sort,ZERO_TYPE};\n-static struct gen_term one  = {ONE_TYPE,term_sort,ONE_TYPE};\n-#else\n-static struct gen_term zero = {ZERO_TYPE,ZERO_TYPE};\n-static struct gen_term one  = {ONE_TYPE,ONE_TYPE};\n-#endif /* NONSPEC */\n-\n-gen_e term_zero(void)\n-{\n-  return (gen_e)&zero;\n-}\n-\n-gen_e term_one(void)\n-{\n-  return (gen_e)&one;\n-}\n-\n-\n-gen_e term_constant(const char *str)\n-{\n-  stamp st[2];\n-  gen_e result;\n-  char *name = rstrdup(term_sort_region,str);\n-\n-  assert (str != NULL);\n-  \n-  st[0] = CONSTANT_TYPE;\n-  st[1] = stamp_string(name); \n-\n-  if ( (result = term_hash_find(term_sort_hash,st,2)) == NULL)\n-    {\n-      term_constant_ c = ralloc(term_sort_region, struct term_constant_);\n-      c->type = CONSTANT_TYPE;\n-      c->st = stamp_fresh();\n-      c->name = name;\n-\n-      result = (gen_e) c;\n-      term_hash_insert(term_sort_hash,result,st,2);\n-      \n-      return result;\n-    }\n-  \n-  else\n-    {\n-      return result;\n-    }\n-\n-}\n-\n-static bool term_is_bottom(gen_e e)\n-{\n-  return (term_is_zero(e) || term_is_var(e));\n-}\n-\n-bool term_is_zero(gen_e e)\n-{\n-  return ( ((gen_term)term_get_ecr(e))->type == ZERO_TYPE);\n-}\n-\n-bool term_is_one(gen_e e)\n-{\n-  return ( ((gen_term)term_get_ecr(e))->type == ONE_TYPE);\n-}\n-\n-bool term_is_var(gen_e e)\n-{\n-  return ( ((gen_term)term_get_ecr(e))->type == VAR_TYPE);\n-}\n-\n-bool term_is_constant(gen_e e)\n-{\n-  return ( ((gen_term)term_get_ecr(e))->type == CONSTANT_TYPE);\n-}\n-\n-char *term_get_constant_name(gen_e e)\n-{\n-  gen_e ecr = term_get_ecr(e);\n-  if(! term_is_constant(ecr))\n-    return NULL;\n-  else\n-    return ((term_constant_)ecr)->name;\n-}\n-\n-gen_e term_get_ecr(gen_e e)\n-{\n-  if (((gen_term)e)->type == VAR_TYPE)\n-    return tv_get_ecr((term_var)e);\n-  else return e;\n-}\n-\n-static void fire_pending(term_var v, gen_e e, \n-\t\t\t con_match_fn_ptr con_match, \n-\t\t\t occurs_check_fn_ptr occurs)\n-{\n-  gen_e_list_scanner scan;\n-  gen_e temp;\n-\n-  gen_e_list_scan(tv_get_pending(v),&scan);\n-  while (gen_e_list_next(&scan,&temp))\n-    {\n-      term_unify(con_match,occurs,temp,e);\n-    }\n-}\n-\n-static bool eq(gen_e e1, gen_e e2)\n-{\n-  return term_get_ecr(e1) == term_get_ecr(e2);\n-}\n-\n-void term_unify(con_match_fn_ptr con_match, occurs_check_fn_ptr occurs,\n-\t\tgen_e a, gen_e b)\n-{\n-  gen_e e1 = term_get_ecr(a),\n-    e2 = term_get_ecr(b);\n-\n-  if ( eq(e1,e2) )\n-    {\n-      return;\n-    }\n-  if (term_is_constant(e1) && term_is_constant(e2))\n-    { \n-      failure(\"Inconsistent system of constraints\\n\");\n-    }\n-  else if (term_is_var(e1))\n-    {\n-      term_var v = (term_var)e1;\n-   \n-\n-      if (! term_is_bottom(e2))\n-\tfire_pending(v,e2,con_match,occurs);\n-\n-      if (term_is_var(e2)) \n-\ttv_unify_vars(v,(term_var)e2);\n-      else /* v = e2, e2 is not a var */\n-\t{ \n-\t  if (occurs(v,e2))\n-\t    failure(\"Unify terms: occurs check failed\\n\");\n-\t  tv_unify(v,e2); \n-\t}\n-    }\n-  else if (term_is_var(e2))\n-    {\n-      term_var v = (term_var)e2;\n-\n-      if (! term_is_bottom(e2))\n-\tfire_pending(v,e1,con_match,occurs);\n-      \n-      /* v = e1, e1 is not a var */\n-      if (occurs(v,e1))\n-\tfailure(\"Unify terms: occurs check failed\\n\");\n-      tv_unify(v,e1); \n-      \n-    }\n-  else con_match(e1,e2);\n-}\n-\n-void term_cunify(con_match_fn_ptr con_match, occurs_check_fn_ptr occurs,\n-\t\t gen_e e1, gen_e e2)\n-{\n-  if (term_is_bottom(e1) && term_is_var(e1))\n-    {\n-      term_var v1 = (term_var)e1;\n-      tv_add_pending(v1,e2);\n-    }\n-  else \n-    {\n-      term_unify(con_match,occurs,e1,e2);\n-    }\n-}\n-\n-static void term_reset_stats(void)\n-{\n-  term_stats.fresh = 0;\n-  term_stats.fresh_small = 0;\n-  term_stats.fresh_large = 0;\n-}\n-\n-void term_print_stats(FILE *f)\n-{\n-  fprintf(f,\"\\n========== Term Var Stats ==========\\n\");\n-  fprintf(f,\"Fresh : %d\\n\",term_stats.fresh); \n-  fprintf(f,\"Fresh Small : %d\\n\",term_stats.fresh_small);\n-  fprintf(f,\"Fresh Large : %d\\n\",term_stats.fresh_large);\n-  fprintf(f,\"=====================================\\n\");\n-}\n-\n-/* TODO */\n-void term_print_constraint_graph(FILE *f ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-void term_init(void)\n-{\n-  term_sort_region = newregion();\n-  term_sort_hash = make_term_hash(term_sort_region);\n-}\n-\n-void term_reset(void)\n-{\n-  term_hash_delete(term_sort_hash);\n-  deleteregion_ptr(&term_sort_region);\n- \n-  term_reset_stats();\n- \n-  term_sort_region = newregion();\n-  term_sort_hash = make_term_hash(term_sort_region);\n-}\n-\n-\n-"}, {"sha": "21a5dc5cff11f9d199f5b28585b38000c8a3abb7", "filename": "libbanshee/engine/term-sort.h", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-sort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-sort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fterm-sort.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,101 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef TERM_SORT_H\n-#define TERM_SORT_H\n-\n-#include <stdio.h>\n-#include \"banshee.h\"\n-#include \"termhash.h\"\n-#include \"term-var.h\"\n-\n-EXTERN_C_BEGIN\n-\n-extern bool flag_occurs_check;\n-extern region term_sort_region;\n-extern term_hash term_sort_hash;\n-\n-struct gen_term /* extends gen_e */\n-{\n-#ifdef NONSPEC\n-  const sort_kind sort;\n-#endif\n-  const int type;\n-  const stamp st;\n-};\n-\n-typedef struct gen_term *gen_term;\n-\n-/* return TRUE if v occurs in e, fals otherwise */\n-typedef bool (* occurs_check_fn_ptr) (term_var v, gen_e e);\n-\n-stamp term_get_stamp(gen_e e);\n-\n-gen_e term_fresh(const char *name);\n-gen_e term_fresh_large(const char *name);\n-gen_e term_fresh_small(const char *name);\n-gen_e term_zero(void);\n-gen_e term_one(void);\n-gen_e term_constant(const char *name);\n-\n-bool term_is_zero(gen_e e);\n-bool term_is_one(gen_e e);\n-bool term_is_var(gen_e e);\n-bool term_is_constant(gen_e e);\n-\n-char *term_get_constant_name(gen_e e);\n-gen_e term_get_ecr(gen_e e);\n-\n-void term_unify(con_match_fn_ptr con_match, occurs_check_fn_ptr occurs,\n-\t\tgen_e e1, gen_e e2);\n-void term_cunify(con_match_fn_ptr con_match,  occurs_check_fn_ptr occurs,\n-\t\t gen_e e1, gen_e e2);\n-\n-void term_print_stats(FILE *f);\n-void term_print_constraint_graph(FILE *f);\n-\n-void term_init(void);\n-void term_reset(void);\n-\n-extern struct term_stats term_stats;\n-\n-struct term_stats\n-{\n-  int fresh;\n-  int fresh_small;\n-  int fresh_large;\n-};\n-\n-EXTERN_C_END\n-\n-#endif /* TERM_SORT_H */\n-\n-\n-"}, {"sha": "9b8e2059871739cc367b24615239e6d9e7a0a091", "filename": "libbanshee/engine/term-var.c", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fterm-var.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,133 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdio.h>\n-#include <regions.h>\n-#include <assert.h>\n-#include \"ufind.h\"\n-#include \"term-var.h\"\n-\n-DECLARE_UFIND(tv_elt,gen_e)\n- \n-DEFINE_UFIND(tv_elt,gen_e)\n-\n-DEFINE_LIST(term_var_list,term_var)\n-\n-struct term_var\n-{\n-#ifdef NONSPEC\n-  sort_kind sort;\n-#endif\n-  int type;\n-  stamp st;\n-  gen_e_list pending;\n-  const char *name;\n-  tv_elt elt;\n-};\n-\n-static term_var make_var(region r, const char *name, stamp st)\n-{\n-  term_var result = ralloc(r, struct term_var);\n-  gen_e info = (gen_e) result;\n-\n-  result->type = VAR_TYPE;\n-  result->st = st;\n-  result->pending = new_gen_e_list(r);\n-  result->name = name ? rstrdup(r,name) : \"fv\";\n-  result->elt = new_tv_elt(r,info);\n-\n-  return result;\n-}\n-\n-term_var tv_fresh(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh());\n-}\n-\n-term_var tv_fresh_small(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_small());\n-}\n-\n-term_var tv_fresh_large(region r, const char *name)\n-{\n-  return make_var(r,name,stamp_fresh_large());\n-}\n-\n-static term_var tv_get_v_ecr(term_var v)\n-{\n-  term_var ecr = (term_var)tv_get_ecr(v);\n-  assert (ecr->type == VAR_TYPE); /* this is a hack, but should be ok */\n-\n-  return ecr;\n-}\n-\n-const char *tv_get_name(term_var v)\n-{\n-  return tv_get_v_ecr(v)->name;\n-}\n-\n-gen_e_list tv_get_pending(term_var v)\n-{\n-  return tv_get_v_ecr(v)->pending;\n-}\n-\n-void tv_add_pending(term_var v,gen_e e)\n-{\n-  gen_e_list_cons(e,tv_get_v_ecr(v)->pending);\n-}\n-\n-void tv_unify(term_var v, gen_e e)\n-{\n-  tv_elt_update(v->elt,e);\n-  \n-  assert(tv_get_ecr(v) == e);\n-}\n-\n-static gen_e tv_combine(gen_e e1, gen_e e2)\n-{\n-  term_var v1 = (term_var)e1,\n-    v2 = (term_var)e2;\n-  \n-  if (! (v1 == v2) )\n-    gen_e_list_append(tv_get_pending(v1), tv_get_pending(v2));\n-  \n-  return e1;\n-}\n-\n-void tv_unify_vars(term_var v1, term_var v2)\n-{\n-  tv_elt_unify(tv_combine,v1->elt, v2->elt);\n-}\n-\n-gen_e tv_get_ecr(term_var v)\n-{\n-  return tv_elt_get_info(v->elt);\n-}"}, {"sha": "1ca035ff8c6d234a939e72e788849089122326d6", "filename": "libbanshee/engine/term-var.h", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-var.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fterm-var.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fterm-var.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,60 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef TERM_VAR_H\n-#define TERM_VAR_H\n-\n-#include \"linkage.h\"\n-#include \"banshee.h\"\n-\n-EXTERN_C_BEGIN\n-\n-typedef struct term_var *term_var;\n-\n-DECLARE_LIST(term_var_list,term_var)\n-\n-term_var tv_fresh(region r, const char *name);\n-term_var tv_fresh_small(region r, const char *name);\n-term_var tv_fresh_large(region r, const char *name);\n-\n-const char *tv_get_name(term_var v);\n-\n-gen_e_list tv_get_pending(term_var v);\n-void tv_add_pending(term_var v,gen_e e);\n-\n-void tv_unify(term_var v, gen_e e);\n-void tv_unify_vars(term_var v1, term_var v2);\n-\n-gen_e tv_get_ecr(term_var v);\n-\n-\n-EXTERN_C_END\n-\n-#endif /* TERM_VAR_H */"}, {"sha": "b42f9ba7304f765e859e679d1affc90bd5d683b8", "filename": "libbanshee/engine/termhash.c", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Ftermhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Ftermhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Ftermhash.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,262 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <string.h>\n-#include \"termhash.h\"\n-#include \"hash.h\"\n-#include \"termhash.h\"\n-#include \"util.h\"\n-\n-#define UB(n) ((1<<n)-1)   \n-#define CAP(n) (1<<n)      \n-#define INITIAL_TABLE_SIZE 8 /* the initial table size is 2^8 */\n-  \n-/*  An individual entry in the table consists of an array of stamps  */ \n-/*  (same arity as the expr's constructor) in addition to the expr */ \n-/*  itself. */ \n-typedef struct hash_entry *hash_entry;\n-\n-/*  A term_bucket is a list of entries (an list of exprs that have  */ \n-/*  collided after hashing) */ \n-typedef struct term_bucket *term_bucket;\n-\n-struct hash_entry\n-{\n-  int length;\n-  stamp *stamps;\n-  gen_e e;\n-};\n-\n-struct term_bucket\n-{\n-  hash_entry entry;\n-  struct term_bucket *next;\n-};\n-\n-#define scan_term_bucket(b,var) for(var = b; var; var = var->next)\n-\n-/*  size: initial_table_size + number of rehashes */ \n-/*  capacity: 2^size (for array size) */ \n-/*  ub: 2^size-1 (for array indexing) */ \n-/*  inserts: num of elements inserted into the array */ \n-struct term_hash\n-{\n-  term_bucket * term_buckets;\n-  region rgn;\n-  int ub;\n-  int size;\n-  int capacity;\n-  int inserts;\n-};\n-\n-static int hash(int ub, stamp stamps[], int len);\n-static void post_insert(term_hash tab) deletes;\n-static void rehash(term_hash tab) deletes;\n-static void reinsert(term_hash tab, term_bucket b);\n-static void insert(term_hash tab, gen_e e, stamp * stamps, int len);\n-static void insert_entry(term_hash tab, struct hash_entry *entry);\n-static gen_e walk(term_bucket b, stamp * stamps, int len);\n-\n-static const int primes[] =\n-  { 83, 1789, 5189, 5449, 5659, 6703, 7517, 7699, 8287, 8807, 9067, 9587,\n-    10627, 10939, 11239};\n-/*\n-static const int prime_1 = 83;\n-static const int prime_2 = 1789;\n-*/\n-static const int initial_table_size = INITIAL_TABLE_SIZE;\n-\n-term_hash make_term_hash(region rgn)\n-{\n-  int ub, n;\n-  int i;\n-\n-  region r;\n-  \n-  term_hash tab = ralloc(rgn, struct term_hash);\n-\n-  r = newregion();\n-  ub = UB(initial_table_size);\n-  n = CAP(initial_table_size);\n-  \n-  \n-  tab->term_buckets = rarrayalloc(r, n, term_bucket);\n-  \n-  for (i = 0; i < n; i++)\n-    {\n-      tab->term_buckets[i] = NULL;\n-    }\n-  \n-  tab->rgn = r;\n-  tab->ub = ub;\n-  tab->size = initial_table_size;\n-  tab->capacity = n;\n-  tab->inserts = 0;\n-  return tab;\n-}\n-\n-void term_hash_delete(term_hash tab) deletes\n-{\n-  deleteregion(tab->rgn);\n-}\n-\n-gen_e term_hash_find(term_hash tab, stamp stamps[], int len)\n-{\n-  int hash_val;\n-\n-  term_bucket b;\n-  hash_val = hash(tab->ub, stamps, len);\n-  b = tab->term_buckets[hash_val];\n-  return walk(b, stamps, len);\n-}\n-\n-static gen_e walk(term_bucket b, stamp stamps[], int len)\n-{\n-  term_bucket cur;\n-  scan_term_bucket(b,cur)\n-    {\n-      if (len == cur->entry->length \n-\t  && (memcmp(stamps, cur->entry->stamps, sizeof(int)*len) == 0) )\n-\treturn cur->entry->e;\n-    }\n-  return NULL;\n-}\n-\n-/*  Should call t_hash_find to see if a gen_e with the given stamp  */ \n-/*  signature is already in the table. If so, insert should return */ \n-/*  true and do nothing. */ \n-bool term_hash_insert(term_hash tab, gen_e e, stamp * stamps, int len) deletes\n-{\n-  if (term_hash_find(tab, stamps, len) != NULL)\n-    {\n-      return TRUE;\n-    }\n-  insert(tab, e, stamps, len);\n-  post_insert(tab);\n-  return FALSE;\n-}\n-\n-\n-/*  Insert an expression e represented by the given stamp array into */ \n-/*  the hash table. */ \n-static void insert(term_hash tab, gen_e e, stamp stamps[], int len)\n-{\n-  hash_entry entry;\n-  stamp * stamp_cpy;\n-  int i;\n-\n-  \n-  entry = ralloc(tab->rgn, struct hash_entry);\n-\n-  stamp_cpy = rarrayalloc(tab->rgn, len, stamp);\n-  for (i = 0; i < len; i++)\n-    {\n-      stamp_cpy[i] = stamps[i];\n-    }\n-\n-  entry->length = len;\n-  entry->stamps = stamp_cpy;\n-  entry->e = e;\n-  insert_entry(tab, entry);\n-}\n-\n-static void insert_entry(term_hash tab, hash_entry entry)\n-{\n-  int hash_val;\n-\n-  term_bucket b, new_term_bucket;\n-  hash_val = hash(tab->ub, entry->stamps, entry->length);\n-  b = tab->term_buckets[hash_val];\n-  new_term_bucket = ralloc(tab->rgn, struct term_bucket);\n-\n-  new_term_bucket->entry = entry;\n-  new_term_bucket->next = b;\n-  tab->term_buckets[hash_val] = new_term_bucket;\n-}\n-\n-static void post_insert(term_hash tab) deletes\n-{\n-  if (tab->capacity == ++tab->inserts)\n-    {\n-      rehash(tab);\n-    }\n-}\n-\n-/*  Double the size of the hash table and reinsert all of the elements. */ \n-static void rehash(term_hash tab) deletes\n-{\n-  region old_rgn;\n-  term_bucket * old_term_buckets;\n-  int i;\n-  int old_table_size = tab->capacity;\n-\n-  old_term_buckets = tab->term_buckets;\n-  tab->capacity *= 2;\n-  tab->ub = UB(++tab->size);\n-  old_rgn = tab->rgn;\n-  tab->rgn = newregion();\n-  \n-  \n-  tab->term_buckets = rarrayalloc(tab->rgn, tab->capacity, term_bucket);\n-  for (i = 0; i < old_table_size; i++)\n-    {\n-      if (old_term_buckets[i] != NULL && old_term_buckets[i]->entry != NULL)\n-\treinsert(tab, old_term_buckets[i]);\n-    }\n-\n-  deleteregion(old_rgn);\n-  \n-  \n-}\n-\n-static void reinsert(term_hash tab, term_bucket b)\n-{\n-  term_bucket cur;\n-  scan_term_bucket(b,cur)\n-    insert(tab, cur->entry->e, cur->entry->stamps, cur->entry->length);\n-}\n-\n-static int hash(int ub, stamp stamps[], int len)\n-{\n-  int i, n;\n-\n-  n = 0;\n-  for (i = 0; i < len; i++)\n-    {\n-      n = (n + (primes[i % 15] * abs(stamps[i]))) & ub;\n-    }\n-  return n;\n-}\n-\n-\n-\n-\n-\n-    "}, {"sha": "777adc3fd169a9a0e256e18853b905e6fcd4c188", "filename": "libbanshee/engine/termhash.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Ftermhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Ftermhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Ftermhash.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,48 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef TERMHASH_H\n-#define TERMHASH_H\n-\n-#include \"banshee.h\"\n-#include \"stamp.h\"\n-#include \"bool.h\"\n-\n-typedef struct term_hash *term_hash;\n-\n-term_hash make_term_hash(region r);\n-\n-gen_e term_hash_find(term_hash h, stamp *st,int length);\n-\n-bool term_hash_insert(term_hash h, gen_e e, stamp *st, int length) deletes;\n-\n-void term_hash_delete(term_hash h) deletes;\n-\n-#endif /* TERMHASH_H */"}, {"sha": "545171812bb89ed08c39cade9a7718f68e6b668f", "filename": "libbanshee/engine/ufind.c", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fufind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fufind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fufind.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,177 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <stdio.h>\n-#include \"ufind.h\"\n-#include \"assert.h\"\n-\n-\n-enum uf_type {uf_ecr,uf_link};\n-typedef enum uf_type uf_type;\n-\n-struct uf_element\n-{\n-  uf_type type;\n-  int rank;\n-  void *info;\n-  struct uf_element *link;\n-};\n-\n-struct uf_element *new_uf_element(region r, void *info)\n-{\n-  struct uf_element *result;\n-\n-  result = ralloc(r, struct uf_element);\n-\n-  result->type = uf_ecr;\n-  result->rank = 0;\n-  result->info = info;\n-  result->link = NULL;\n-\n-  return result;\n-}\n-\n-static struct uf_element *find(struct uf_element *e)\n-{\n-\n-  if (e->type == uf_ecr)\n-    return e;\n-  \n-  else if (e->link->type == uf_link)\n-    {\n-      struct uf_element *temp = e->link;\n-\t\n-      e->link = e->link->link;\n-\n-      return find(temp);\n-    }\n-\n-  else\n-    return e->link;\n-}\n-\n-bool uf_union(struct uf_element *a, struct uf_element *b)\n-{\n-  struct uf_element *e1 = find(a);\n-  struct uf_element *e2 = find(b);\n-\n-  if ( e1 == e2 )\n-    return FALSE;\n-\n- else if (e1->rank < e2->rank)\n-    {\n-      e1->type = uf_link;\n-      e1->link = e2;\n-\n-      return TRUE;\n-    }\n-\n-  else if (e1->rank > e2->rank)\n-    {\n-      e2->type = uf_link;\n-      e2->link = e1;\n-\n-      return TRUE;\n-    }\n-  \n-  else \n-    {\n-      e2->rank++;\n-      \n-      e1->type = uf_link;\n-      e1->link = e2;\n-\n-      return TRUE;\n-    }\n-\n-}\n-\n-bool uf_unify(combine_fn_ptr combine,\n-\t      struct uf_element *a, struct uf_element *b)\n-{\n-  struct uf_element *e1 = find(a);\n-  struct uf_element *e2 = find(b);\n-\n-  if ( e1 == e2 )\n-    return FALSE;\n-\n-  else if (e1->rank < e2->rank)\n-    {\n-      e2->info = combine(e2->info,e1->info);\n-      e1->type = uf_link;\n-      e1->link = e2;\n-     \n-      return TRUE;\n-    }\n-\n-  else if (e1->rank > e2->rank)\n-    {\n-      e1->info = combine(e1->info,e2->info);\n-      e2->type = uf_link;\n-      e2->link = e1;\n-\n-      return TRUE;\n-    }\n-  \n-  else \n-    {\n-      e2->info = combine(e2->info, e1->info);\n-\n-      e2->rank++;\n-      e1->type = uf_link;\n-      e1->link = e2;\n-\n-      return TRUE;\n-    }\n-}\n-\n-\n-\n-void *uf_get_info(struct uf_element *e)\n-{\n-  return find(e)->info;\n-}\n-\n-\n-bool uf_eq(struct uf_element *e1,struct uf_element *e2)\n-{\n-  return (find(e1) == find(e2));\n-}\n-\n-void uf_update(struct uf_element *e,uf_info i)\n-{\n-  find(e)->info = i;\n-}\n-\n-\n-\n-\n-\n-"}, {"sha": "5068530114ef75fe7a328c3044ed9d95970b8cb4", "filename": "libbanshee/engine/ufind.h", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fufind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Fufind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Fufind.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,178 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef UFIND_H\n-#define UFIND_H\n-\n-#include <regions.h>\n-#include \"linkage.h\"\n-#include \"bool.h\"\n-\n-EXTERN_C_BEGIN\n-\n-struct uf_element;\n-\n-typedef struct uf_element *uf_element;\n-typedef void *uf_info;\n-\n-typedef uf_info (*combine_fn_ptr)(uf_info,uf_info);\n-\n-struct uf_element *new_uf_element(region r,uf_info i);  \n-uf_info uf_get_info(struct uf_element *); \n-bool uf_unify(combine_fn_ptr,struct uf_element *,struct uf_element *);\n-bool uf_union(struct uf_element *,struct uf_element *);\n-bool uf_eq(struct uf_element *,struct uf_element *);\n-void uf_update(struct uf_element *,uf_info i);\n-\n-#define DECLARE_UFIND(name,type) \\\n-typedef struct name *name; \\\n-typedef type (* name ## _combine_fn_ptr)(type info1,type info2); \\\n-name new_ ## name(region r, type info); \\\n-type name ## _get_info(name); \\\n-bool name ## _unify(name ## _combine_fn_ptr,name e1, name e2); \\\n-bool name ## _union(name e1, name e2); \\\n-bool name ## _eq(name e1, name e2); \\\n-void name ## _update(name e1, type info);\n-\n-#define DEFINE_UFIND(name,type) \\\n-name new_ ## name(region r, type info) \\\n-{ \\\n- return (name)new_uf_element(r,info);\\\n-}\\\n-type name ## _get_info(name elem) \\\n-{ \\\n- return (type)uf_get_info((struct uf_element *)elem);\\\n-} \\\n-bool name ## _unify(name ## _combine_fn_ptr cmb,name e1, name e2) \\\n-{ \\\n- return uf_unify((combine_fn_ptr)cmb,(struct uf_element *)e1,(struct uf_element *)e2); \\\n-} \\\n-bool name ## _union(name e1, name e2) \\\n-{ \\\n- return uf_union((struct uf_element *)e1,(struct uf_element *)e2); \\\n-}\\\n-bool name ## _eq(name e1, name e2) \\\n-{ \\\n- return uf_eq((struct uf_element *)e1,(struct uf_element *)e2); \\\n-} \\\n-void name ##_update(name e1, type info) \\\n-{ \\\n- uf_update((struct uf_element *)e1,(uf_info)info); \\\n-} \\\n-\n-EXTERN_C_END\n-\n-#endif /* UFIND_H */\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "2d723f933434b8f0f2a6a8fa4637086bf26f4af1", "filename": "libbanshee/engine/util.c", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Futil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Futil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Futil.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,194 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <ctype.h>\n-#include <math.h>\n-#include <signal.h>\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <string.h>\n-#include <unistd.h>\n-#include \"buffer.h\"\n-#include \"util.h\"\n-\n-/* Panic with a message */\n-static void vfail(const char *fmt, va_list args) __attribute__((__noreturn__));\n-\n-static void vfail(const char *fmt, va_list args)\n-{\n-  vfprintf(stderr, fmt, args);\n-  fflush(stderr);\n-  fflush(stdout);\n-  abort();\n-  while (1); /* Work around stupid gcc-2.96-85 bug */\n-}\n-\n-/* Panic with a nice message */\n-void __fail(const char *file, unsigned int line,\n-\t    const char *func __attribute__((unused)),\n-\t    const char *fmt, ...)\n-{\n-  va_list args;\n-  va_start(args, fmt);\n-  fprintf(stderr, \"\\n%s:%u \", file, line);\n-  vfail(fmt, args);\n-}\n-\n-#ifndef HAVE_VARIADIC_MACROS\n-/* Panic with a not-quite-as-nice message */\n-void fail(const char *fmt, ...)\n-{\n-  va_list args;\n-  va_start(args, fmt);\n-  vfail(fmt, args);\n-}\n-#endif\n-\n-void failure(const char *message)\n-{\n-  fprintf(stderr,message);\n-  exit(1);\n-}\n-\n-/* Concatenate 2 strings, allocating space in r for the result */\n-char *rstrcat(region r, const char *s1, const char *s2)\n-{\n-  char *result = rarrayalloc(r, strlen(s1)+strlen(s2)+1, char);\n-  result[0] = '\\0';\n-  strcat(result, s1);\n-  strcat(result, s2);\n-  return result;\n-}\n-\n-/* Concatenate n strings, allocating space in r for the result.  The\n-   last argument should be a null pointer. */\n-char *rstrscat(region r, ...)\n-{\n-  char *result;\n-  int len = 0;\n-  const char *s;\n-  va_list args;\n-\n-  va_start(args, r);\n-  while ((s = va_arg(args, const char *)))\n-    len += strlen(s);\n-  result = rarrayalloc(r, len+1, char);\n-  result[0] = '\\0';\n-\n-  va_start(args, r);\n-  while ((s = va_arg(args, const char *)))\n-    strcat(result, s);\n-\n-  return result;\n-}\n-#if 0\n-/* Convert an integer to a string, storing the result in r */\n-const char *inttostr(region r, int i)\n-{\n-  char *result;\n-  int width;\n-\n-  if (i == 0)\n-    width = 1;\n-  else\n-    width = (int) (floor(log10(abs((double) i))) + 1);\n-  if (i<0) width++;\n-\n-  printf(\"i=%d, width=%d\\n\", i, width);\n-  assert(width >0);\n-\n-  result = rarrayalloc(r, width + 1, char);\n-  if (snprintf(result, width + 1, \"%d\", i) == -1) {\n-    printf(\"i=%d, width=%d\\n\", i, width);\n-    fail (\"inttostr width wrong\\n\");\n-  }\n-  return result;\n-}\n-#endif\n-\n-/* sprintf a string, allocating space in r for the result */\n-char *rsprintf(region r, const char *fmt, ...)\n-{\n-  va_list args;\n-\n-  va_start(args, fmt);\n-  return rvsprintf(r, fmt, args);\n-}\n-\n-char *rvsprintf(region r, const char *fmt, va_list args)\n-{\n-  growbuf buf = growbuf_new(r, 100);\n-  gvprintf(buf, fmt, args);\n-  return growbuf_contents(buf);\n-}\n-\n-/* Space for the ASCII representation of a pointer -- 2 hex chars per\n-   byte, plus 3 chars for 0x prefix and trailing \\0 */\n-#define PTR_ASCII_SIZE  ((int) (3 + sizeof(void *)*2))\n-\n-/* Convert a pointer to an ascii string with leading 0x.  Re-uses\n-   internal buffer. */\n-char *ptr_to_ascii(void *ptr) {\n-  static char addr[PTR_ASCII_SIZE];\n-  int nchars;\n-\n-  nchars = snprintf(addr, PTR_ASCII_SIZE, \"%p\", ptr);\n-  if (nchars == -1 || nchars >= PTR_ASCII_SIZE)\n-    fail(\"Unable to convert ptr to ascii (need %d bytes, have %d)\\n\",\n-\t nchars, PTR_ASCII_SIZE);\n-  return addr;\n-}\n-\n-/* Convert a pointer to an integer */\n-long ptr_hash(void *ptr)\n-{\n-  return (long) ptr;\n-}\n-\n-/* Return TRUE iff ptr1 == ptr2 */\n-bool ptr_eq(void *ptr1, void *ptr2)\n-{\n-  return ptr1 == ptr2;\n-}\n-\n-/* Return TRUE iff s1 == s2 */\n-bool str_eq(const char *s1, const char *s2)\n-{\n-  return (strcmp(s1, s2) == 0);\n-}\n-\n-/* A total ordering on pointers.  Returns 0 if ptr1 = ptr2, a value <0\n-   if ptr1 < ptr2, or a value >0 if ptr1 > ptr2. */\n-int ptr_cmp(const void *ptr1, const void *ptr2)\n-{\n-  return (char *) ptr1 - (char *) ptr2;\n-}\n-\n-/* int abs(int a) { if (a < 0) return -a; else return a; } */"}, {"sha": "dea62fe2d4448ab84d02a46aea0d9944750ece5b", "filename": "libbanshee/engine/util.h", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Futil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fengine%2Futil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fengine%2Futil.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,107 +0,0 @@\n-/*\n- * Copyright (c) 2000-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#ifndef UTIL_H\n-#define UTIL_H\n-\n-#include <assert.h>\n-#include <stdarg.h>\n-#include <stdlib.h>\n-#include <regions.h>\n-#include <ansidecl.h>\n-#include \"compiler.h\"\n-#include \"linkage.h\"\n-#include \"bool.h\"\n-\n-\n-EXTERN_C_BEGIN\n-\n-#ifdef HAVE_VARIADIC_MACROS\n-#define fail(args...) __fail(__FILE__, __LINE__, __FUNCTION__, args)\n-#else\n-void fail(const char *fmt, ...);\n-#endif\n-\n-void __fail(const char *file, unsigned int line,\n-\t    const char *func, const char *fmt, ...) __attribute__ ((__noreturn__));\n-\n-\n-/* insist(action) is like assert(action), but action may have\n-   side-effects */\n-#ifdef NDEBUG\n-# define insist(action)  (action)\n-#else\n-# define insist assert\n-#endif\n-\n-#ifdef NDEBUG\n-# define insistnot(action)  (action)\n-#else\n-# define insistnot(action) assert(!(action))\n-#endif\n-\n-void failure(const char *message);\n-\n-/* Concatenate 2 strings, allocating space in r for the result */\n-char *rstrcat(region, const char *, const char *);\n-\n-/* Concatenate n strings, allocating space in r for the result.  The\n-   last argument should be a null pointer. */\n-char *rstrscat(region, ...);\n-\n-/* Convert an integer to a string, storing the result in r */\n-const char *inttostr(region r, int);\n-\n-/* sprintf a string, allocating space in r for the result */\n-char *rsprintf(region r, const char *fmt, ...);\n-char *rvsprintf(region r, const char *fmt, va_list args);\n-\n-/* Convert a pointer to an ascii string with leading 0x.  Re-uses\n-   internal buffer. */\n-char *ptr_to_ascii(void *ptr);\n-\n-/* Convert a pointer to an integer */\n-long ptr_hash(void *ptr);\n-\n-/* Return TRUE iff ptr1 == ptr2 */\n-bool ptr_eq(void *ptr1, void *ptr2);\n-\n-/* Return TRUE iff s1 == s2 */\n-bool str_eq(const char *s1, const char *s2);\n-\n-/* A total ordering on pointers.  Returns 0 if ptr1 = ptr2, a value <0\n-   if ptr1 < ptr2, or a value >0 if ptr1 > ptr2. */\n-int ptr_cmp(const void *ptr1, const void *ptr2);\n-\n-static inline int min(int a, int b) { if (a < b) return a; else return b; }\n-static inline int max(int a, int b) { if (a < b) return b; else return a; }\n-EXTERN_C_END\n-\n-#endif"}, {"sha": "dae6ac0052ff89fdfa90f96b9bd97e7c00173ca1", "filename": "libbanshee/libcompat/Makefile.am", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2FMakefile.am?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,4 +0,0 @@\n-AM_CFLAGS = -I$(srcdir)/../engine -I$(srcdir)/../include -I. -Ddeletes= -Dtraditional= -Dsameregion= -Dparentptr= @ac_libbanshee_warn_cflags@\n-noinst_LIBRARIES = libbansheecompat.a\n-libbansheecompat_a_SOURCES = regions.c radix-tree.c\n-"}, {"sha": "b434ecbcdeb419329284e0d5af9e80b92342fb07", "filename": "libbanshee/libcompat/Makefile.in", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2FMakefile.in?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,379 +0,0 @@\n-# Makefile.in generated by automake 1.8.5 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-SOURCES = $(libbansheecompat_a_SOURCES)\n-\n-srcdir = @srcdir@\n-top_srcdir = @top_srcdir@\n-VPATH = @srcdir@\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-top_builddir = ..\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-INSTALL = @INSTALL@\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-subdir = libcompat\n-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = $(top_builddir)/config.h\n-CONFIG_CLEAN_FILES =\n-LIBRARIES = $(noinst_LIBRARIES)\n-AR = ar\n-ARFLAGS = cru\n-libbansheecompat_a_AR = $(AR) $(ARFLAGS)\n-libbansheecompat_a_LIBADD =\n-am_libbansheecompat_a_OBJECTS = regions.$(OBJEXT) radix-tree.$(OBJEXT)\n-libbansheecompat_a_OBJECTS = $(am_libbansheecompat_a_OBJECTS)\n-DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)\n-depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n-@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/radix-tree.Po \\\n-@AMDEP_TRUE@\t./$(DEPDIR)/regions.Po\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n-SOURCES = $(libbansheecompat_a_SOURCES)\n-DIST_SOURCES = $(libbansheecompat_a_SOURCES)\n-ETAGS = etags\n-CTAGS = ctags\n-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n-ACLOCAL = @ACLOCAL@\n-AMDEP_FALSE = @AMDEP_FALSE@\n-AMDEP_TRUE = @AMDEP_TRUE@\n-AMTAR = @AMTAR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@\n-MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n-MAKEINFO = @MAKEINFO@\n-OBJEXT = @OBJEXT@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_RANLIB = @ac_ct_RANLIB@\n-ac_ct_STRIP = @ac_ct_STRIP@\n-ac_libbanshee_warn_cflags = @ac_libbanshee_warn_cflags@\n-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@\n-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-bindir = @bindir@\n-build_alias = @build_alias@\n-datadir = @datadir@\n-exec_prefix = @exec_prefix@\n-host_alias = @host_alias@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-oldincludedir = @oldincludedir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-sysconfdir = @sysconfdir@\n-target_alias = @target_alias@\n-AM_CFLAGS = -I$(srcdir)/../engine -I$(srcdir)/../include -I. -Ddeletes= -Dtraditional= -Dsameregion= -Dparentptr= @ac_libbanshee_warn_cflags@\n-noinst_LIBRARIES = libbansheecompat.a\n-libbansheecompat_a_SOURCES = regions.c radix-tree.c\n-all: all-am\n-\n-.SUFFIXES:\n-.SUFFIXES: .c .o .obj\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  libcompat/Makefile'; \\\n-\tcd $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --gnu  libcompat/Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-\n-clean-noinstLIBRARIES:\n-\t-test -z \"$(noinst_LIBRARIES)\" || rm -f $(noinst_LIBRARIES)\n-libbansheecompat.a: $(libbansheecompat_a_OBJECTS) $(libbansheecompat_a_DEPENDENCIES) \n-\t-rm -f libbansheecompat.a\n-\t$(libbansheecompat_a_AR) libbansheecompat.a $(libbansheecompat_a_OBJECTS) $(libbansheecompat_a_LIBADD)\n-\t$(RANLIB) libbansheecompat.a\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/radix-tree.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/regions.Po@am__quote@\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\tif $(COMPILE) -MT $@ -MD -MP -MF \"$(DEPDIR)/$*.Tpo\" -c -o $@ $<; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/$*.Tpo\" \"$(DEPDIR)/$*.Po\"; else rm -f \"$(DEPDIR)/$*.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tdepfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\tif $(COMPILE) -MT $@ -MD -MP -MF \"$(DEPDIR)/$*.Tpo\" -c -o $@ `$(CYGPATH_W) '$<'`; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/$*.Tpo\" \"$(DEPDIR)/$*.Po\"; else rm -f \"$(DEPDIR)/$*.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tdepfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n-uninstall-info-am:\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\ttags=; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\tif test -z \"$(ETAGS_ARGS)$$tags$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t    $$tags $$unique; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\ttags=; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$tags$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$tags $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && cd $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) $$here\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\n-distdir: $(DISTFILES)\n-\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n-\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's|.|.|g'`; \\\n-\tlist='$(DISTFILES)'; for file in $$list; do \\\n-\t  case $$file in \\\n-\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-\t    $(top_srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$topsrcdirstrip/|$(top_builddir)/|\"`;; \\\n-\t  esac; \\\n-\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n-\t  dir=`echo \"$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n-\t  if test \"$$dir\" != \"$$file\" && test \"$$dir\" != \".\"; then \\\n-\t    dir=\"/$$dir\"; \\\n-\t    $(mkdir_p) \"$(distdir)$$dir\"; \\\n-\t  else \\\n-\t    dir=''; \\\n-\t  fi; \\\n-\t  if test -d $$d/$$file; then \\\n-\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n-\t      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \\\n-\t    fi; \\\n-\t    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \\\n-\t  else \\\n-\t    test -f $(distdir)/$$file \\\n-\t    || cp -p $$d/$$file $(distdir)/$$file \\\n-\t    || exit 1; \\\n-\t  fi; \\\n-\tdone\n-check-am: all-am\n-check: check-am\n-all-am: Makefile $(LIBRARIES)\n-installdirs:\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-rm -f $(CONFIG_CLEAN_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am\n-\n-distclean: distclean-am\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-tags\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am:\n-\n-install-exec-am:\n-\n-install-info: install-info-am\n-\n-install-man:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am: uninstall-info-am\n-\n-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n-\tclean-noinstLIBRARIES ctags distclean distclean-compile \\\n-\tdistclean-generic distclean-tags distdir dvi dvi-am html \\\n-\thtml-am info info-am install install-am install-data \\\n-\tinstall-data-am install-exec install-exec-am install-info \\\n-\tinstall-info-am install-man install-strip installcheck \\\n-\tinstallcheck-am installdirs maintainer-clean \\\n-\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n-\tmostlyclean-generic pdf pdf-am ps ps-am tags uninstall \\\n-\tuninstall-am uninstall-info-am\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "7f2cfd369b261f62eb18f6c06c47ca290f9f4353", "filename": "libbanshee/libcompat/alloc.c", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Falloc.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,133 +0,0 @@\n-/*\n- * Copyright (c) 1999-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-/* TBD: recover unusued portions of pages for use as individual pages */\n-\n-#include <stddef.h>\n-#include \"regions.h\"\n-\n-static void alloc_block(region r, struct allocator *a, struct ablock *blk,\n-\t\t void **p1, int s1, int a1, void **p2, int s2, int a2,\n-\t\t size_t blksize, int needsclear)\n-{\n-  struct page *newp;\n-  char *mem1, *mem2;\n-  \n-  mem1 = PALIGN(blk->allocfrom, a1);\n-  mem2 = PALIGN(mem1 + s1, a2);\n-\n-  /* Can't use last byte of page (pointers to the byte after an object are\n-     valid) */\n-  if (mem2 + s2 >= blk->base + blksize)\n-    {\n-      if (blksize == RPAGESIZE)\n-\t{\n-\t  newp = alloc_single_page(a->pages);\n-\t  a->pages = newp;\n-\t  blk->allocfrom = (char *)newp + offsetof(struct page, previous);\n-\t  set_region(newp, 1, r);\n-\t}\n-      else\n-\t{\n-\t  newp = alloc_pages(blksize >> RPAGELOG, a->bigpages);\n-\t  a->bigpages = newp;\n-\t  blk->allocfrom = (char *)newp + offsetof(struct page, previous);\n-\t  set_region(newp, blksize >> RPAGELOG, r);\n-\t}\n-      blk->base = (char *)newp;\n-\n-      if (needsclear)\n-\tpreclear(blk->allocfrom, blksize - (blk->allocfrom - (char *)newp));\n-      mem1 = PALIGN(blk->allocfrom, a1);\n-      mem2 = PALIGN(mem1 + s1, a2);\n-    }\n-\n-  ASSERT_INUSE(blk->base, r);\n-  blk->allocfrom = mem2 + s2;\n-\n-  *p1 = mem1;\n-  *p2 = mem2;\n-}\n-\n-void qalloc(region r, struct allocator *a, void **p1, int s1, int a1,\n-\t    void **p2, int s2, int a2, int needsclear)\n-{\n-  struct page *p;\n-  char *mem;\n-  int npages;\n-  int n = ALIGN(s1, a2) + s2; /* Yes, this is correct (see alloc_block) */\n-\n-  if (n <= RPAGESIZE / K)\n-    {\n-      alloc_block(r, a, &a->page, p1, s1, a1, p2, s2, a2, RPAGESIZE,\n-\t\t  needsclear);\n-      return;\n-    }\n-  if (n <= RPAGESIZE)\n-    {\n-      alloc_block(r, a, &a->superpage, p1, s1, a1, p2, s2, a2,\n-\t\t  K * RPAGESIZE, needsclear);\n-      return;\n-    }\n-  if (n <= RPAGESIZE * K)\n-    {\n-      alloc_block(r, a, &a->hyperpage, p1, s1, a1, p2, s2, a2,\n-\t\t  K * K * RPAGESIZE, needsclear);\n-      return;\n-    }\n-\n-  npages = (n + ALIGN(offsetof(struct page, previous), a1) + RPAGESIZE - 1)\n-    >> RPAGELOG;\n-  p = alloc_pages(npages, a->bigpages);\n-  a->bigpages = p;\n-  set_region(p, npages, r);\n-\n-  mem = (char *)p + offsetof(struct page, previous);\n-  *p1 = PALIGN(mem, a1);\n-  *p2 = PALIGN((char *) *p1 + s1, a2);\n-  if (needsclear)\n-    preclear(*p2, s2);\n-}\n-\n-void free_all_pages(region r, struct allocator *a)\n-/* Assumes freepages_lock held */\n-{\n-  struct page *p, *next;\n-\n-  for (p = a->pages; p; p = next)\n-    {\n-      next = p->next;\n-      free_single_page(r, p);\n-    }\n-  for (p = a->bigpages; p; p = next)\n-    {\n-      next = p->next;\n-      free_pages(r, p);\n-    }\n-}"}, {"sha": "9e85e9baef0c6591d5c4210123afe50d954d5ec1", "filename": "libbanshee/libcompat/pages.c", "status": "removed", "additions": 0, "deletions": 459, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fpages.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fpages.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Fpages.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,459 +0,0 @@\n-/*\n- * Copyright (c) 1999-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-#include <limits.h>\n-\n-typedef __rcintptr pageid;\n-\n-#if 0\n-#define FREEPAGE ((region)-1) /* Id of a free page */\n-#else\n-#define FREEPAGE (&zeroregion)\n-#endif\n-#ifdef NMEMDEBUG\n-#define ASSERT_FREE(p) \n-#define ASSERT_INUSE(p, r) \n-#else\n-#define ASSERT_FREE(p) assert(regionof(p) == FREEPAGE)\n-#ifdef DUPLICATES\n-#define ASSERT_INUSE(p, r) assert(regionof(p) == r->base)\n-#else\n-#define ASSERT_INUSE(p, r) assert(regionof(p) == r)\n-#endif\n-#endif\n-\n-/* Page allocator for region-based memory management */\n-/* TBD: special free list for size == K ?? */\n-\n-#define PAGECOUNTBITS (CHAR_BIT * sizeof(pageid) - 1)\n-\n-struct page\n-{\n-  /* Next page in region or in free list */\n-  struct page *next;\n-\n-  /* Doubly linked list of pages sorted by address */\n-  struct page *next_address, *prev_address;\n-\n-  /* number of pages in this allocation unit. Negative for free pages. */\n-  pageid pagecount : PAGECOUNTBITS;\n-\n-  unsigned int free : 1;\n-\n-  /* Only in free pages not in the single_pages list */\n-  struct page *previous;\n-};\n-\n-/* The pages are kept in a single list sorted by address via the\n-   next_address and prev_address fields. The first page's prev_address and\n-   the last page's next_address fields points to pages_byaddress.\n-   page_byaddress.next_address is the first page\n-   page_byaddress.prev_address is the last page\n-\n-   This list is used for coalescing operations.\n-*/\n-static struct page pages_byaddress;\n-\n-struct page *alloc_single_page(struct page *next);\n-void free_single_page(region r, struct page *p);\n-\n-struct page *alloc_pages(int n, struct page *next);\n-void free_pages(region r, struct page *p);\n-\n-\n-/* a list of free individual pages */\n-struct page *single_pages;\n-\n-/* free pages (not including those in single_pages) */\n-struct page *unused_pages;\n-\n-static void init_pages(void)\n-{\n-  pages_byaddress.next_address = &pages_byaddress;\n-  pages_byaddress.prev_address = &pages_byaddress;\n-}\n-\n-static void insertbefore_address(struct page *p, struct page *before)\n-{\n-  p->prev_address = before->prev_address;\n-  p->next_address = before;\n-  before->prev_address = p;\n-  p->prev_address->next_address = p;\n-}\n-\n-static void unlink_address(struct page *p)\n-{\n-  p->prev_address->next_address = p->next_address;\n-  p->next_address->prev_address = p->prev_address;\n-}\n-\n-static void addbyaddress(struct page *p)\n-{\n-  struct page *address_scan;\n-\n-  /* Warning: this is slow. Calls to it should not be frequent (once app\n-     reaches a steady state of memory usage). */\n-\n-  for (address_scan = pages_byaddress.next_address; ;\n-       address_scan = address_scan->next_address)\n-    if (p < address_scan || address_scan == &pages_byaddress)\n-      {\n-\tinsertbefore_address(p, address_scan);\n-\treturn;\n-      }\n-}\n-\n-/* Doubly linked page list management */\n-void addfront(struct page **list, struct page *p)\n-/* Effects: Adds p to the front of doubly-linked list list */\n-{\n-  p->previous = NULL;\n-  p->next = *list;\n-  if (*list) (*list)->previous = p;\n-  *list = p;\n-}\n-\n-void unlink_page(struct page **list, struct page *p)\n-/* Effects: Remove p from its doubly linked list */\n-{\n-  if (p->previous)\n-    p->previous->next = p->next;\n-  else\n-    *list = p->next;\n-  if (p->next)\n-    p->next->previous = p->previous;\n-}\n-\n-void *region_get_mem(size_t s)\n-{\n-  void *mem = malloc(s + RPAGESIZE - 1);\n-\n-  return (void *)ALIGN((__rcintptr)mem, RPAGESIZE);\n-}\n-\n-/* Page to region map management */\n-/* ----------------------------- */\n-\n-RADIX_TREE(__rcregionmap);\n-\n-static void set_page_region(pageid pagenb, region r)\n-{\n-  radix_tree_delete (&__rcregionmap, pagenb);\n-  radix_tree_insert (&__rcregionmap, pagenb, r);\n-}\n-\n-#define page_region(pagenb) (radix_tree_lookup (&__rcregionmap, (pagenb)))\n-\n-void set_region(struct page *p, int npages, region r)\n-{\n-  pageid pnb = PAGENB(p);\n-\n-  while (npages-- > 0) \n-    set_page_region(pnb++, r);\n-}\n-\n-/* Mark the memory range from 'from' (inclusive) to 'to' (exclusive)\n-   as belonging to region with id 'rid' */\n-void set_region_range(void *from, void *to, region r)\n-{\n-  pageid first = PAGENB(from), last = PAGENB((pageid)to - 1);\n-\n-  while (first <= last)\n-    set_page_region(first++, r);\n-}\n-\n-/* Multi-page allocation management */\n-/* -------------------------------- */\n-\n-struct page *alloc_new(int n, struct page *next)\n-/* Assumes freepages_lock held */\n-{\n-  struct page *newp = region_get_mem(n << RPAGELOG);\n-\n-  if (!newp)\n-    {\n-      if (nomem_h)\n-\tnomem_h();\n-      abort();\n-    }\n-  assert(!((long)newp & (RPAGESIZE - 1)));\n-\n-  newp->next = next;\n-  newp->pagecount = n;\n-  newp->free = 0;\n-  addbyaddress(newp);\n-#ifndef NMEMDEBUG\n-  {\n-    pageid i, pnb = PAGENB(newp);\n-\n-    for (i = pnb; i < pnb + n; i++)\n-      set_page_region(i, FREEPAGE);\n-  }\n-#endif\n-\n-  return newp;\n-}\n-\n-struct page *alloc_split(struct page *split, int n, struct page *next)\n-/* Assumes freepages_lock held */\n-{\n-#ifndef NMEMDEBUG\n-  /* These pages had better be free */\n-  pageid i, pnb = PAGENB(split);\n-\n-  assert(split->pagecount >= n);\n-  for (i = pnb; i < pnb + split->pagecount; i++)\n-    assert(page_region(i) == FREEPAGE);\n-#endif\n-  if (split->pagecount > n)\n-    {\n-      struct page *splitoff;\n-\n-      /* Keep first part of block */\n-      split->pagecount -= n;\n-      /* Return latter part of block */\n-      splitoff = split;\n-      split = (struct page *)((char *)split + (split->pagecount << RPAGELOG));\n-\n-      /* Update the by adress list */\n-      insertbefore_address(split, splitoff->next_address);\n-    }\n-  else\n-    {\n-      /* remove split from list */\n-      unlink_page(&unused_pages, split);\n-    }\n-  split->next = next;\n-  split->pagecount = n;\n-  split->free = 0;\n-\n-  return split;\n-}\n-\n-struct page *alloc_pages(int n, struct page *next)\n-{\n-  struct page *best;\n-  int bestn;\n-  struct page *scan;\n-\n-  assert(n >= K);\n-\n-  scan = unused_pages;\n-  /* Find first fit */\n-  for (;;)\n-    {\n-      if (!scan)\n-\treturn alloc_new(n, next);\n-\n-      if (scan->pagecount >= n) break;\n-      scan = scan->next;\n-    }\n-\n-  /* Now find best fit */\n-  best = scan;\n-  bestn = scan->pagecount;\n-  for (;;)\n-    {\n-      scan = scan->next;\n-      if (!scan)\n-\treturn alloc_split(best, n, next);\n-\n-      if (scan->pagecount >=n && scan->pagecount < bestn)\n-\t{\n-\t  best = scan;\n-\t  bestn = scan->pagecount;\n-\t}\n-    }\n-}\n-\n-static void coalesce(struct page *p)\n-{\n-  struct page *prev = p->prev_address, *next;\n-\n-  p->free = 1;\n-\n-  /* Coalesce with predecessor ? */\n-  if (prev->free && (char *)prev + (prev->pagecount << RPAGELOG) == (char *)p)\n-    {\n-      prev->pagecount += p->pagecount;\n-      unlink_address(p);\n-      p = prev;\n-    }\n-  else /* No, add to free pages list */\n-    addfront(&unused_pages, p);\n-\n-  next = p->next_address;\n-  /* Coalesce with successor ? */\n-  if (next->free && (char *)p + (p->pagecount << RPAGELOG) == (char *)next)\n-    {\n-      unlink_page(&unused_pages, next);\n-      p->pagecount += next->pagecount;\n-      unlink_address(next);\n-    }\n-}\n-\n-void free_pages(region r, struct page *p)\n-/* Assumes freepages_lock held */\n-{\n-#ifndef NMEMDEBUG\n-  pageid i, pnb = PAGENB(p);\n-\n-  for (i = pnb; i < pnb + p->pagecount; i++)\n-    {\n-      assert(page_region(i) == r);\n-      set_page_region(i, FREEPAGE);\n-    }\n-#endif\n-\n-  coalesce(p);\n-}\n-\n-\n-/* Single page management */\n-/* ---------------------- */\n-\n-static int single_page_count;\n-\n-static void add_single_pages(struct page *base)\n-/* Effects: Adds pages at base to the single_pages list */\n-{\n-  pageid n = base->pagecount;\n-  struct page *prev = base->prev_address, *basenext = base->next_address,\n-    *next;\n-\n-  single_page_count += n;\n-\n-  for (;;)\n-    {\n-      ASSERT_FREE(base);\n-      base->free = 0; /* Not free so that coalesce won't steal these back */\n-      base->prev_address = prev;\n-      prev = base;\n-      base->next = single_pages;\n-      single_pages = base;\n-      if (--n == 0)\n-\tbreak;\n-      next = (struct page *)((char *)base + RPAGESIZE);\n-      base->next_address = next;\n-      base = next;\n-    }\n-  base->next_address = basenext;\n-  basenext->prev_address = base;\n-}\n-\n-void scavenge_single_pages(int n)\n-{\n-  /* Add n pages to the single_pages list */\n-  struct page *scan, *best;\n-  __rcintptr bestn;\n-\n-  /* Take any group in unused_pages that is <= n or < K.\n-     Remember smallest entry > n too. This is sortof equivalent to\n-     a best fit where we allow partial allocations to make up a whole */\n-  best = NULL;\n-  bestn = (__rcintptr)1 << (sizeof(__rcintptr) * CHAR_BIT - 2);\n-  scan = unused_pages;\n-  while (scan)\n-    {\n-      /* The pages < K can't be used for anything but single pages so we\n-\t might as well grab them even if they are a little too big */\n-      if (scan->pagecount <= n || scan->pagecount < K)\n-\t{\n-\t  struct page *adding = scan;\n-\n-\t  scan = scan->next;\n-\t  n -= adding->pagecount;\n-\t  unlink_page(&unused_pages, adding);\n-\t  add_single_pages(adding);\n-\t  if (n <= 0) return;\n-\t}\n-      else\n-\t{\n-\t  if (scan->pagecount < bestn)\n-\t    {\n-\t      bestn = scan->pagecount;\n-\t      best = scan;\n-\t    }\n-\t  scan = scan->next;\n-\t}\n-    }\n-  /* Still not enough. Split the best block if there is one, allocate\n-     new pages otherwise */\n-  if (!best)\n-    add_single_pages(alloc_new(n, NULL));\n-  else if (best->pagecount - n < K)\n-    {\n-      unlink_page(&unused_pages, best);\n-      add_single_pages(best);\n-    }\n-  else\n-    add_single_pages(alloc_split(best, n, NULL));\n-}\n-\n-struct page *alloc_single_page(struct page *next)\n-{\n-  struct page *p;\n-\n-  if (!single_pages)\n-    {\n-      scavenge_single_pages(PAGE_GROUP_SIZE);\n-    }\n-  ASSERT_FREE(single_pages);\n-  p = single_pages;\n-  single_pages = p->next;\n-  p->next = next;\n-\n-  single_page_count--;\n-\n-  return p;\n-}\n-\n-void free_single_page(region r, struct page *p)\n-/* Assumes freepages_lock held */\n-{\n-#ifndef NMEMDEBUG\n-  ASSERT_INUSE(p, r);\n-  set_page_region(PAGENB(p), FREEPAGE);\n-#endif\n-\n-  /* Once free list is big enough just coalesce the pages.\n-     The actual threshold to use might merit further study (something\n-     adaptive ? e.g., proportional to allocated single pages) */\n-  if (single_page_count > PAGE_GROUP_SIZE * 2)\n-    {\n-      p->pagecount = 1;\n-      coalesce(p);\n-    }\n-  else\n-    {\n-      p->next = single_pages;\n-      single_pages = p;\n-      single_page_count++;\n-    }\n-}"}, {"sha": "0a30a55e41e529a5ce62f424e4e7d198b0910856", "filename": "libbanshee/libcompat/profile.c", "status": "removed", "additions": 0, "deletions": 521, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Fprofile.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,521 +0,0 @@\n-/*\n- * Copyright (c) 1999-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-\n-#include <assert.h>\n-#include <string.h>\n-#include <unistd.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-#include <signal.h>\n-#undef REGION_PROFILE\n-#include \"regions.h\"\n-#include \"profile.h\"\n-\n-typedef struct Alloc_info\n-{\n-  struct Alloc_info *next;\n-  char *file;\n-  int line;\n-  unsigned long size;\n-  unsigned long calls;\n-} *ainfo;\n-\n-static ainfo ainfos = NULL;\n-static region profile_region = NULL;\n-\n-/* perror(s) then exit */\n-void pfail(const char *s)\n-{\n-  perror(s);\n-  exit(EXIT_FAILURE);\n-}\n-\n-/**************************************************************************\n- *                                                                        *\n- * Log information about an allocation -- generic                         *\n- *                                                                        *\n- **************************************************************************/\n-\n-static int registered_exit = 0;\n-\n-static ainfo find_ainfo(char *file, int line)\n-{\n-  ainfo ai;\n-\n-  for (ai = ainfos; ai; ai = ai->next)\n-    if (line == ai->line && !strcmp(file, ai->file))\n-      return ai;\n-\n-  if (!registered_exit)\n-    {\n-      if (atexit(profile))\n-\tfprintf(stderr, \"Registration of profile at exit failed\\n\");\n-      registered_exit = 1;\n-    }\n-\n-  if (!profile_region)\n-    profile_region = newregion();\n-  ai = ralloc(profile_region, struct Alloc_info);\n-  ai->file = file;\n-  ai->line = line;\n-  ai->size = 0;\n-  ai->calls = 0;\n-  ai->next = ainfos;\n-  ainfos = ai;\n-  return ai;\n-}\n-\n-/**************************************************************************\n- *                                                                        *\n- * Log information about an allocation -- GCC                             *\n- *                                                                        *\n- * WARNING:  This code uses __builtin_return_address, a non-portable      *\n- * feature of gcc, to trace the call chain back.   You'll also get ugly   *\n- * output unless the addr2line (in GNU binutils) is installed.            *\n- *                                                                        *\n- * ANOTHER WARNING:  The depths hard-coded in find_cinfo are only correct *\n- * if find_cinfo is inlined.  Ack!                                        *\n- *                                                                        *\n- **************************************************************************/\n-\n-#define REGION_PROFILE_DEPTH 2\n-#undef TRACE_STACK\n-#if defined(__GNUC__) && defined(__OPTIMIZE__) && REGION_PROFILE_DEPTH > 1\n-#define TRACE_STACK\n-#endif\n-\n-#ifdef TRACE_STACK\n-\n-#if REGION_PROFILE_DEPTH > 6\n-#error \"REGION_PROFILE_DEPTH must be less than 6.  See find_cinfo().\"\n-#endif\n-\n-typedef struct Call_info\n-{\n-  struct Call_info *next;\n-  void **stack;         /* Array holding the call chain */\n-  unsigned long size;\n-  unsigned long calls;\n-} *cinfo;\n-\n-static cinfo cinfos = NULL;\n-\n-/* Find the current call chain and return a pointer to our status for\n-   it, or allocate a new entry if there is none. */\n-static cinfo find_cinfo(void)\n-{\n-  void *calls[REGION_PROFILE_DEPTH];\n-  int i;\n-  cinfo ci;\n-\n-  /* Compute the call chain.  This is an awful hack. */\n-  i = 0;\n-  if (i < REGION_PROFILE_DEPTH)\n-    calls[i++] = __builtin_return_address(1);\n-  if (i < REGION_PROFILE_DEPTH)\n-    calls[i++] = __builtin_return_address(2);\n-  if (i < REGION_PROFILE_DEPTH)\n-    calls[i++] = __builtin_return_address(3);\n-  if (i < REGION_PROFILE_DEPTH)\n-    calls[i++] = __builtin_return_address(4);\n-  if (i < REGION_PROFILE_DEPTH)\n-    calls[i++] = __builtin_return_address(5);\n-  if (i < REGION_PROFILE_DEPTH)\n-    calls[i++] = __builtin_return_address(6);\n-  /* Add more if you want a higher call-depth (why would you?) */\n-\n-  /* Find it */\n-  for (ci = cinfos; ci; ci = ci->next)\n-    if (!memcmp(calls, ci->stack, REGION_PROFILE_DEPTH*sizeof(void *)))\n-      return ci;\n-\n-  if (!profile_region)\n-    profile_region = newregion();\n-  ci = ralloc(profile_region, struct Call_info);\n-  ci->stack = rarrayalloc(profile_region, REGION_PROFILE_DEPTH, void *);\n-  memcpy(ci->stack, calls, REGION_PROFILE_DEPTH*sizeof(void *));\n-  ci->size = 0;\n-  ci->calls = 0;\n-  ci->next = cinfos;\n-  cinfos = ci;\n-  return ci;\n-  \n-}\n-#endif\n-\n-static void add_alloc(char *file, int line, int size)\n-{\n-  ainfo ai = find_ainfo(file, line);\n-  ai->calls++;\n-  ai->size += size;\n-#ifdef TRACE_STACK\n-  {\n-    cinfo ci;\n-\n-    ci = find_cinfo();\n-    ci->calls++;\n-    ci->size += size;\n-  }\n-#endif\n-}\n-\n-/**************************************************************************\n- *                                                                        *\n- * Intercept and log calls to region library                              *\n- *                                                                        *\n- **************************************************************************/\n-\n-void *profile_typed_ralloc(region r, size_t size, type_t type, char *file,\n-\t\t\t   int line)\n-{\n-  add_alloc(file, line, size);\n-  return typed_ralloc(r, size, type);\n-}\n-\n-void *profile_typed_rarrayalloc(region r, size_t n, size_t size, type_t type,\n-\t\t\t\tchar *file, int line)\n-{\n-  add_alloc(file, line, n*size);\n-  return typed_rarrayalloc(r, n, size, type);\n-}\n-\n-void *profile_typed_rarrayextend(region r, void *old, size_t n, size_t size,\n-\t\t\t\t type_t type, char *file, int line)\n-{\n-  add_alloc(file, line, n*size); /* XXX: Fix */\n-  return typed_rarrayextend(r, old, n, size, type);\n-}\n-\n-char *profile_rstralloc(region r, size_t size, char *file, int line)\n-{\n-  add_alloc(file, line, size);\n-  return rstralloc(r, size);\n-}\n-\n-char *profile_rstralloc0(region r, size_t size, char *file, int line)\n-{\n-  add_alloc(file, line, size);\n-  return rstralloc0(r, size);\n-}\n-\n-char *profile_rstrdup(region r, const char *s, char *file, int line)\n-{\n-  add_alloc(file, line, strlen(s));\n-  return rstrdup(r, s);\n-}\n-\n-char *profile_rstrextend(region r, const char *old, size_t newsize,\n-\t\t\t char *file, int line)\n-{\n-  add_alloc(file, line, newsize); /* XXX: Fix */\n-  return rstrextend(r, old, newsize);\n-}\n-\n-char *profile_rstrextend0(region r, const char *old, size_t newsize,\n-\t\t\t  char *file, int line)\n-{\n-  add_alloc(file, line, newsize); /* XXX: Fix */\n-  return rstrextend0(r, old, newsize);\n-}\n-\n-/**************************************************************************\n- *                                                                        *\n- * Display results -- generic                                             *\n- *                                                                        *\n- **************************************************************************/\n-\n-static FILE *out = NULL;\n-\n-/* Generic list -- used for generic sorting.  Note that next field is\n-   at the top. */\n-typedef struct List\n-{\n-  struct List *next;\n-} *list;\n-\n-/* Sort a list.  cmp should sort in reverse order. */\n-static list sort_list(list l, int (*cmp)(const void *, const void *))\n-{\n-  list cur, result;\n-  list *sorted;\n-  int i, length;\n-  region temp_region;\n-\n-  /* Compute length of list */\n-  for (cur = l, length = 0; cur; cur = cur->next, length++);\n-\n-  temp_region = newregion();\n-  sorted = rarrayalloc(temp_region, length, list *);\n-  for (cur = l, i = 0; cur; cur = cur->next)\n-    sorted[i++] = cur;\n-  qsort(sorted, length, sizeof(list *), cmp);\n-\n-  result = NULL;\n-  for (i = 0; i < length; i++)\n-    {\n-      cur = result;\n-      result = sorted[i];\n-      result->next = cur;\n-    }\n-  deleteregion(temp_region);\n-  return result;\n-}\n-\n-\n-typedef struct File_info\n-{\n-  struct File_info *next;\n-  char *file;\n-  unsigned long size;\n-  unsigned long calls;\n-  unsigned long sites;\n-} *finfo;\n-\n-static finfo finfos = NULL;\n-\n-static int finfo_cmp(const void *a, const void *b)\n-{\n-  finfo *afi = (finfo *) a;\n-  finfo *bfi = (finfo *) b;\n-  return (*afi)->size - (*bfi)->size;  /* Reverse order */\n-}\n-\n-static void print_finfos(void)\n-{\n-  finfo fi;\n-  unsigned long size, sites, calls;\n-\n-  finfos = (finfo) sort_list((list) finfos, finfo_cmp);\n-  size = sites = calls = 0;\n-  fprintf(out, \"        Bytes | Sites |    Calls | File\\n\");\n-  fprintf(out, \"  ------------+-------+----------+---------------------\\n\");\n-  for (fi = finfos; fi; fi = fi->next)\n-    {\n-      size += fi->size;\n-      sites += fi->sites;\n-      calls += fi->calls;\n-      fprintf(out, \" %12lu | %5lu | %8lu | %s\\n\",\n-\t      fi->size, fi->sites, fi->calls, fi->file);\n-    }\n-  fprintf(out, \"  ------------+-------+----------+---------------------\\n\");\n-    fprintf(out, \" %12lu | %5lu | %8lu | Total\\n\",\n-\t    size, sites, calls);\n-\n-}\n-\n-static int ainfo_cmp(const void *a, const void *b)\n-{\n-  ainfo *afi = (ainfo *) a;\n-  ainfo *bfi = (ainfo *) b;\n-  return (*afi)->size - (*bfi)->size;  /* Reverse order */\n-}\n-\n-static void print_ainfos(void)\n-{\n-  ainfo ai;\n-\n-  unsigned long size, calls;\n-\n-  ainfos = (ainfo) sort_list((list) ainfos, ainfo_cmp);\n-  size = calls = 0;\n-  fprintf(out, \"        Bytes |    Calls | Site\\n\");\n-  fprintf(out, \"  ------------+----------+---------------------\\n\");\n-  for (ai = ainfos; ai; ai = ai->next)\n-    {\n-      size += ai->size;\n-      calls += ai->calls;\n-      fprintf(out, \" %12lu | %8lu | %s:%d\\n\",\n-\t      ai->size, ai->calls, ai->file, ai->line);\n-    }\n-  fprintf(out, \"  ------------+----------+---------------------\\n\");\n-    fprintf(out, \" %12lu | %8lu | Total\\n\",\n-\t    size, calls);\n-}\n-\n-static finfo find_finfo(char *file)\n-{\n-  finfo fi;\n-\n-  for (fi = finfos; fi; fi = fi->next)\n-    if (!strcmp(file, fi->file))\n-      return fi;\n-\n-  fi = ralloc(profile_region, struct File_info);\n-  fi->file = file;\n-  fi->size = 0;\n-  fi->calls = 0;\n-  fi->sites = 0;\n-  fi->next = finfos;\n-  finfos = fi;\n-  return fi;\n-}\n-\n-static void gather_finfo(void)\n-{\n-  ainfo ai;\n-\n-  for (ai = ainfos; ai; ai = ai->next)\n-    {\n-      finfo fi = find_finfo(ai->file);\n-      fi->size += ai->size;\n-      fi->calls += ai->calls;\n-      fi->sites++;\n-    }\n-}\n-\n-/**************************************************************************\n- *                                                                        *\n- * Display results -- GCC                                                 *\n- *                                                                        *\n- **************************************************************************/\n-\n-#ifdef TRACE_STACK\n-\n-pid_t child_pid = 0;\n-int child_in[2], child_out[2]; /* pipes to child process */\n-\n-static void start_prettiness(void)\n-{\n-  if (pipe(child_in) || pipe(child_out))\n-    pfail(\"Unable to open pipe to child process\");\n-  if (!(child_pid = fork()))\n-    {\n-      /* Child process */\n-      pid_t parent_pid;\n-      char filename[64];\n-\n-      if (dup2(child_in[0], STDIN_FILENO) == -1)\n-\tpfail(\"Unable to open pipe from parent\");\n-      close(child_in[0]);\n-      close(child_in[1]);\n-      if (dup2(child_out[1], STDOUT_FILENO) == -1)\n-\tpfail(\"Unable to open pipe to parent\");\n-      close(child_out[0]);\n-      close(child_out[1]);\n-\n-      parent_pid = getppid();\n-      snprintf(filename, 64, \"/proc/%d/exe\", parent_pid);\n-      filename[63] = '\\0';\n-      execlp(\"addr2line\", \"addr2line\", \"-s\", \"-e\", filename, 0);\n-      fprintf(stderr, \"Unable to fork addr2line\\n\");\n-      exit(EXIT_FAILURE);\n-    }\n-  else\n-    {\n-      close(child_in[0]);\n-      close(child_out[1]);\n-    }\n-}\n-\n-/* Turn p into a file:line string */\n-static char *prettify(void *p)\n-{\n-#define BUFSIZE 1024\n-  static char buf[BUFSIZE];\n-  int size;\n-\n-  /*printf(\"To child: %p\\n\", p);*/\n-  size = snprintf(buf, BUFSIZE, \"%p\\n\", p);\n-  write(child_in[1], buf, size);\n-  size = read(child_out[0], buf, BUFSIZE - 1);\n-  if (!size)\n-    pfail(\"Unable to read from child process\");\n-  buf[size-1] = '\\0'; /* Kill \\n */\n-  /*printf(\"Read: [%s]\\n\", buf);*/\n-  return buf;\n-}\n-\n-static void end_prettiness(void)\n-{\n-  if (child_pid)\n-    kill(child_pid, SIGHUP);\n-}\n-\n-static int cinfo_cmp(const void *a, const void *b)\n-{\n-  cinfo *aci = (cinfo *) a;\n-  cinfo *bci = (cinfo *) b;\n-  return (*aci)->size - (*bci)->size;  /* Reverse order */\n-}\n-\n-/* Print the call chain information out to a file. */\n-static void print_cinfos(void)\n-{\n-  cinfo ci;\n-  unsigned long size, calls;\n-  int i;\n-\n-  cinfos = (cinfo) sort_list((list) cinfos, cinfo_cmp);\n-  size = calls = 0;\n-  start_prettiness();\n-  fprintf(out, \"        Bytes |    Calls | Call Stack\\n\");\n-  fprintf(out, \"  ------------+----------+---------------------\\n\");\n-  for (ci = cinfos; ci; ci = ci->next)\n-    {\n-      size += ci->size;\n-      calls += ci->calls;\n-      fprintf(out, \" %12lu | %8lu | \", ci->size, ci->calls);\n-      for (i = 0; i < REGION_PROFILE_DEPTH; i++)\n-\tfprintf(out, \"%s \", prettify(ci->stack[i]));\n-      fprintf(out, \"\\n\");\n-    }\n-  fprintf(out, \"  ------------+----------+---------------------\\n\");\n-    fprintf(out, \" %12lu | %8lu | Total\\n\",\n-\t    size, calls);\n-    end_prettiness();\n-}\n-#endif\n-\n-\n-void profile(void)\n-{\n-  if (profile_region == NULL)\n-    return;\n-\n-  gather_finfo();\n-\n-  if (!(out = fopen(\"profile.out\", \"w\")))\n-    pfail(\"Unable to open profile.out\");\n-\n-  fprintf(out, \"---------------------------\\n\");\n-  fprintf(out, \"Region Library Memory Usage\\n\");\n-  fprintf(out, \"---------------------------\\n\\n\");\n-\n-  print_finfos();\n-  fprintf(out, \"\\n\");\n-  print_ainfos();\n-#ifdef TRACE_STACK\n-  fprintf(out, \"\\n\");\n-  print_cinfos();\n-#endif\n-\n-  fclose(out);\n-}"}, {"sha": "b07034e21913f4f5444af6d9ab4d4d0c2020401a", "filename": "libbanshee/libcompat/profile.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Fprofile.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,59 +0,0 @@\n-/*\n- * Copyright (c) 1999-2001\n- *      The Regents of the University of California.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- */\n-#ifndef PROFILE_H\n-#define PROFILE_H\n-\n-/* Should only be included in regions.h and profile.c */\n-\n-void *profile_typed_ralloc(region r, size_t size, type_t type, char *file, int line);\n-void *profile_typed_rarrayalloc(region r, size_t n, size_t size, type_t type, char *file, int line);\n-void *profile_typed_rarrayextend(region r, void *old, size_t n, size_t size, type_t type, char *file, int line);\n-char *profile_rstralloc(region r, size_t size, char *file, int line);\n-char *profile_rstralloc0(region r, size_t size, char *file, int line);\n-char *profile_rstrdup(region r, const char *s, char *file, int line);\n-char *profile_rstrextend(region r, const char *old, size_t newsize, char *file, int line);\n-char *profile_rstrextend0(region r, const char *old, size_t newsize, char *file, int line);\n-\n-#ifdef REGION_PROFILE\n-#define typed_ralloc(r, size, type) profile_typed_ralloc(r, size, type, __FILE__, __LINE__)\n-#define typed_rarrayalloc(r, n, size, type) profile_typed_rarrayalloc(r, n, size, type, __FILE__, __LINE__)\n-#define typed_rarrayextend(r, old, n, size, type) profile_typed_rarrayextend(r, old, n, size, type, __FILE__, __LINE__)\n-\n-#define rstralloc(r, size) profile_rstralloc(r, size, __FILE__, __LINE__)\n-#define rstralloc0(r, size) profile_rstralloc0(r, size, __FILE__, __LINE__)\n-#define rstrdup(r, s) profile_rstrdup(r, s, __FILE__, __LINE__)\n-\n-#define rstrextend(r, old, newsize) profile_rstrextend(r, old, newsize, __FILE__, __LINE__)\n-#define rstrextend0(r, old, newsize) profile_rstrextend0(r, old, newsize, __FILE__, __LINE__)\n-#endif\n-\n-void profile(void);\n-\n-#endif"}, {"sha": "18f8929ad2dae3abf9e2cf0bf3f70da95bdb40ce", "filename": "libbanshee/libcompat/radix-tree.c", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fradix-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fradix-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Fradix-tree.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,364 +0,0 @@\n-/*\n- * Modified to work in GCC in 2003 by Daniel Berlin \n- * Copyright (C) 2001 Momchil Velikov\n- * Portions Copyright (C) 2001 Christoph Hellwig\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License as\n- * published by the Free Software Foundation; either version 2, or (at\n- * your option) any later version.\n- * \n- * This program is distributed in the hope that it will be useful, but\n- * WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * General Public License for more details.\n- * \n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n- */\n-#include <unistd.h>\n-#include <stdio.h>\n-#include <errno.h>\n-#include <stdlib.h>\n-#include  \"radix-tree.h\"\n-#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))\n-/*\n- * Radix tree node definition.\n- */\n-#define RADIX_TREE_MAP_SHIFT  6\n-#define RADIX_TREE_MAP_SIZE  (1UL << RADIX_TREE_MAP_SHIFT)\n-#define RADIX_TREE_MAP_MASK  (RADIX_TREE_MAP_SIZE-1)\n-\n-struct radix_tree_node {\n-  unsigned int\tcount;\n-  void\t\t*slots[RADIX_TREE_MAP_SIZE];\n-};\n-\n-struct radix_tree_path {\n-  struct radix_tree_node *node, **slot;\n-};\n-\n-#define RADIX_TREE_INDEX_BITS  (8 /* CHAR_BIT */ * sizeof(unsigned long))\n-#define RADIX_TREE_MAX_PATH (RADIX_TREE_INDEX_BITS/RADIX_TREE_MAP_SHIFT + 2)\n-\n-static unsigned long height_to_maxindex[RADIX_TREE_MAX_PATH];\n-\n-\n-/*\n- * This assumes that the caller has performed appropriate preallocation, and\n- * that the caller has pinned this thread of control to the current CPU.\n- */\n-static struct radix_tree_node *\n-radix_tree_node_alloc(struct radix_tree_root *root)\n-{\n-  struct radix_tree_node *ret;\n-  \n-  ret = (struct radix_tree_node *)\n-    calloc (1, sizeof (struct radix_tree_node));\n-  if (!ret)\n-    abort ();\n-  return ret;\n-}\n-\n-static inline void\n-radix_tree_node_free(struct radix_tree_node *node)\n-{\n-  free (node);\n-}\n-\n-\n-/*\n- *\tReturn the maximum key which can be store into a\n- *\tradix tree with height HEIGHT.\n- */\n-static inline unsigned long radix_tree_maxindex(unsigned int height)\n-{\n-  return height_to_maxindex[height];\n-}\n-\n-/*\n- *\tExtend a radix tree so it can store key @index.\n- */\n-static int radix_tree_extend(struct radix_tree_root *root, unsigned long index)\n-{\n-  struct radix_tree_node *node;\n-  unsigned int height;\n-  \n-  /* Figure out what the height should be.  */\n-  height = root->height + 1;\n-  while (index > radix_tree_maxindex(height))\n-    height++;\n-  \n-  if (root->rnode) {\n-    do {\n-      if (!(node = radix_tree_node_alloc(root)))\n-\treturn -ENOMEM;\n-      \n-      /* Increase the height.  */\n-      node->slots[0] = root->rnode;\n-      node->count = 1;\n-      root->rnode = node;\n-      root->height++;\n-    } while (height > root->height);\n-  } else \n-    root->height = height;\n-  \n-  return 0;\n-}\n-\n-/**\n- *\tradix_tree_insert    -    insert into a radix tree\n- *\t@root:\t\tradix tree root\n- *\t@index:\t\tindex key\n- *\t@item:\t\titem to insert\n- *\n- *\tInsert an item into the radix tree at position @index.\n- */\n-int radix_tree_insert(struct radix_tree_root *root, unsigned long index,\n-\t\t      void *item)\n-{\n-  struct radix_tree_node *node = NULL, *tmp, **slot;\n-  unsigned int height, shift;\n-  int error;\n-  \n-  /* Make sure the tree is high enough.  */\n-  if (index > radix_tree_maxindex(root->height)) {\n-    error = radix_tree_extend(root, index);\n-    if (error)\n-      return error;\n-  }\n-  \n-  slot = &root->rnode;\n-  height = root->height;\n-  shift = (height-1) * RADIX_TREE_MAP_SHIFT;\n-  \n-  while (height > 0) {\n-    if (*slot == NULL) {\n-      /* Have to add a child node.  */\n-      if (!(tmp = radix_tree_node_alloc(root)))\n-\treturn -ENOMEM;\n-      *slot = tmp;\n-      if (node)\n-\tnode->count++;\n-    }\n-    \n-    /* Go a level down.  */\n-    node = *slot;\n-    slot = (struct radix_tree_node **)\n-      (node->slots + ((index >> shift) & RADIX_TREE_MAP_MASK));\n-    shift -= RADIX_TREE_MAP_SHIFT;\n-    height--;\n-  }\n-  \n-  if (*slot != NULL)\n-    return -EEXIST;\n-  if (node)\n-    node->count++;\n-  \n-  *slot = item;\n-  return 0;\n-}\n-\n-/**\n- *\tradix_tree_lookup    -    perform lookup operation on a radix tree\n- *\t@root:\t\tradix tree root\n- *\t@index:\t\tindex key\n- *\n- *\tLookup them item at the position @index in the radix tree @root.\n- */\n-void *radix_tree_lookup(struct radix_tree_root *root, unsigned long index)\n-{\n-  unsigned int height, shift;\n-  struct radix_tree_node **slot;\n-  \n-  height = root->height;\n-  if (index > radix_tree_maxindex(height))\n-    return NULL;\n-  \n-  shift = (height-1) * RADIX_TREE_MAP_SHIFT;\n-  slot = &root->rnode;\n-  \n-  while (height > 0) {\n-    if (*slot == NULL)\n-      return NULL;\n-    \n-    slot = (struct radix_tree_node **)\n-      ((*slot)->slots + ((index >> shift) & RADIX_TREE_MAP_MASK));\n-    shift -= RADIX_TREE_MAP_SHIFT;\n-    height--;\n-  }\n-  \n-  return (void *) *slot;\n-}\n-\n-static /* inline */ unsigned int\n-__lookup(struct radix_tree_root *root, void **results, unsigned long index,\n-\t unsigned int max_items, unsigned long *next_index)\n-{\n-  unsigned int nr_found = 0;\n-  unsigned int shift;\n-  unsigned int height = root->height;\n-  struct radix_tree_node *slot;\n-  \n-  shift = (height-1) * RADIX_TREE_MAP_SHIFT;\n-  slot = root->rnode;\n-  \n-  while (height > 0) {\n-    unsigned long i = (index >> shift) & RADIX_TREE_MAP_MASK;\n-    \n-    for ( ; i < RADIX_TREE_MAP_SIZE; i++) {\n-      if (slot->slots[i] != NULL)\n-\tbreak;\n-      index &= ~((1 << shift) - 1);\n-      index += 1 << shift;\n-      if (index == 0)\n-\tgoto out;\t/* 32-bit wraparound */\n-    }\n-    if (i == RADIX_TREE_MAP_SIZE)\n-      goto out;\n-    height--;\n-    if (height == 0) {\t/* Bottom level: grab some items */\n-      unsigned long j = index & RADIX_TREE_MAP_MASK;\n-      \n-      for ( ; j < RADIX_TREE_MAP_SIZE; j++) {\n-\tindex++;\n-\tif (slot->slots[j]) {\n-\t  results[nr_found++] = slot->slots[j];\n-\t  if (nr_found == max_items)\n-\t    goto out;\n-\t}\n-      }\n-    }\n-    shift -= RADIX_TREE_MAP_SHIFT;\n-    slot = slot->slots[i];\n-  }\n- out:\n-  *next_index = index;\n-  return nr_found;\n-}\n-\n-/**\n- *\tradix_tree_gang_lookup - perform multiple lookup on a radix tree\n- *\t@root:\t\tradix tree root\n- *\t@results:\twhere the results of the lookup are placed\n- *\t@first_index:\tstart the lookup from this key\n- *\t@max_items:\tplace up to this many items at *results\n- *\n- *\tPerforms an index-ascending scan of the tree for present items.  Places\n- *\tthem at *@results and returns the number of items which were placed at\n- *\t*@results.\n- *\n- *\tThe implementation is naive.\n- */\n-unsigned int\n-radix_tree_gang_lookup(struct radix_tree_root *root, void **results,\n-\t\t       unsigned long first_index, unsigned int max_items)\n-{\n-  const unsigned long max_index = radix_tree_maxindex(root->height);\n-  unsigned long cur_index = first_index;\n-  unsigned int ret = 0;\n-  \n-  if (root->rnode == NULL)\n-    goto out;\n-  if (max_index == 0) {\t\t\t/* Bah.  Special case */\n-    if (first_index == 0) {\n-      if (max_items > 0) {\n-\t*results = root->rnode;\n-\tret = 1;\n-      }\n-    }\n-    goto out;\n-  }\n-  while (ret < max_items) {\n-    unsigned int nr_found;\n-    unsigned long next_index;\t/* Index of next search */\n-    \n-    if (cur_index > max_index)\n-      break;\n-    nr_found = __lookup(root, results + ret, cur_index,\n-\t\t\tmax_items - ret, &next_index);\n-    ret += nr_found;\n-    if (next_index == 0)\n-      break;\n-    cur_index = next_index;\n-  }\n- out:\n-  return ret;\n-}\n-\n-/**\n- *\tradix_tree_delete    -    delete an item from a radix tree\n- *\t@root:\t\tradix tree root\n- *\t@index:\t\tindex key\n- *\n- *\tRemove the item at @index from the radix tree rooted at @root.\n- *\n- *\tReturns the address of the deleted item, or NULL if it was not present.\n- */\n-void *radix_tree_delete(struct radix_tree_root *root, unsigned long index)\n-{\n-  struct radix_tree_path path[RADIX_TREE_MAX_PATH], *pathp = path;\n-  unsigned int height, shift;\n-  void *ret = NULL;\n-  \n-  height = root->height;\n-  if (index > radix_tree_maxindex(height))\n-    goto out;\n-  \n-  shift = (height-1) * RADIX_TREE_MAP_SHIFT;\n-  pathp->node = NULL;\n-  pathp->slot = &root->rnode;\n-  \n-  while (height > 0) {\n-    if (*pathp->slot == NULL)\n-      goto out;\n-    \n-    pathp[1].node = *pathp[0].slot;\n-    pathp[1].slot = (struct radix_tree_node **)\n-      (pathp[1].node->slots + ((index >> shift) & RADIX_TREE_MAP_MASK));\n-    pathp++;\n-    shift -= RADIX_TREE_MAP_SHIFT;\n-    height--;\n-  }\n-  \n-  ret = *pathp[0].slot;\n-  if (ret == NULL)\n-    goto out;\n-  \n-  *pathp[0].slot = NULL;\n-  while (pathp[0].node && --pathp[0].node->count == 0) {\n-    pathp--;\n-    *pathp[0].slot = NULL;\n-    radix_tree_node_free(pathp[1].node);\n-  }\n-  \n-  if (root->rnode == NULL)\n-    root->height = 0;  /* Empty tree, we can reset the height */\n- out:\n-  return ret;\n-}\n-\n-\n-static unsigned long __maxindex(unsigned int height)\n-{\n-  unsigned int tmp = height * RADIX_TREE_MAP_SHIFT;\n-  unsigned long index = (~0UL >> (RADIX_TREE_INDEX_BITS - tmp - 1)) >> 1;\n-  \n-  if (tmp >= RADIX_TREE_INDEX_BITS)\n-    index = ~0UL;\n-  return index;\n-}\n-\n-static void radix_tree_init_maxindex(void)\n-{\n-  unsigned int i;\n-  \n-  for (i = 0; i < ARRAY_SIZE(height_to_maxindex); i++)\n-    height_to_maxindex[i] = __maxindex(i);\n-}\n-\n-void radix_tree_init(void)\n-{\n-  radix_tree_init_maxindex();\n-}"}, {"sha": "a6b6dc185a30e8e54846148a1b509ff5bb1cd1f2", "filename": "libbanshee/libcompat/radix-tree.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fradix-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fradix-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Fradix-tree.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb", "patch": "@@ -1,51 +0,0 @@\n-/*\n- * Copyright (C) 2001 Momchil Velikov\n- * Portions Copyright (C) 2001 Christoph Hellwig\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License as\n- * published by the Free Software Foundation; either version 2, or (at\n- * your option) any later version.\n- * \n- * This program is distributed in the hope that it will be useful, but\n- * WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * General Public License for more details.\n- * \n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n- */\n-#ifndef _LINUX_RADIX_TREE_H\n-#define _LINUX_RADIX_TREE_H\n-\n-\n-struct radix_tree_node;\n-\n-struct radix_tree_root {\n-  unsigned int\t\theight;\n-  struct radix_tree_node\t*rnode;\n-};\n-\n-#define RADIX_TREE_INIT()\t{0, NULL}\n-\n-#define RADIX_TREE(name) \\\n-  struct radix_tree_root name = RADIX_TREE_INIT()\n-\n-#define INIT_RADIX_TREE(root)\t\t\\\n-do {\t\t\t\t\t\\\n-\t(root)->height = 0;\t\t\\\n-\t(root)->rnode = NULL;\t\t\\\n-} while (0)\n-\n-extern int radix_tree_insert(struct radix_tree_root *, unsigned long, void *);\n-extern void *radix_tree_lookup(struct radix_tree_root *, unsigned long);\n-extern void *radix_tree_delete(struct radix_tree_root *, unsigned long);\n-extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root, \n-\t\t\t\t\t   void **results, \n-\t\t\t\t\t   unsigned long first_index,\n-\t\t\t\t\t   unsigned int max_items);\n-extern void radix_tree_init(void);\n-\n-\n-#endif /* _LINUX_RADIX_TREE_H */"}, {"sha": "6426fd68d1ea681bd64f2fc24cac810ae616645a", "filename": "libbanshee/libcompat/regions.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fregions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fregions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Fregions.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "9f0231ddd826ffabba5ab8d21abf4147dd5c3a31", "filename": "libbanshee/libcompat/regions.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fregions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Flibcompat%2Fregions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Flibcompat%2Fregions.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "7f6e8c6cafc3768f0fc55e7758db7f5aa49c4976", "filename": "libbanshee/points-to/Makefile.am", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fpoints-to%2FMakefile.am?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "edc055137451223215ce72d0bc071864a14a7f5c", "filename": "libbanshee/points-to/Makefile.in", "status": "removed", "additions": 0, "deletions": 377, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fpoints-to%2FMakefile.in?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "9268a516ee872b4e76c1d2878c45e5db1149be91", "filename": "libbanshee/points-to/andersen_terms.c", "status": "removed", "additions": 0, "deletions": 1363, "changes": 1363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fpoints-to%2Fandersen_terms.c?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "b893c57349674add57a3c70e82124a386829fe82", "filename": "libbanshee/points-to/andersen_terms.h", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fpoints-to%2Fandersen_terms.h?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "244f643f908a43c94e1ba8d55896c9d29026ad12", "filename": "libbanshee/points-to/andersen_terms.spec", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms.spec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms.spec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fpoints-to%2Fandersen_terms.spec?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}, {"sha": "0984e001e5b66c60c405f9dc2bd2feae3bc98f05", "filename": "libbanshee/points-to/andersen_terms_st.spec", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms_st.spec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a404bd99198779b2115d99ab84535a5b7fd9fb/libbanshee%2Fpoints-to%2Fandersen_terms_st.spec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbanshee%2Fpoints-to%2Fandersen_terms_st.spec?ref=c1a404bd99198779b2115d99ab84535a5b7fd9fb"}]}