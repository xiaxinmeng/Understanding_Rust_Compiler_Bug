{"sha": "c5d1f058528f7d400211b010d8a48201611688b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkMWYwNTg1MjhmN2Q0MDAyMTFiMDEwZDhhNDgyMDE2MTE2ODhiOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-07-06T13:26:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-07-06T13:26:28Z"}, "message": "lto-streamer.c (write_symbol_vec): Rename to ...\n\n\n\t* lto-streamer.c (write_symbol_vec): Rename to ...\n\t(write_symbol) ... this one; write only symbol given and when\n\tpresent in cache. Sanity check that what is defined is present\n\tin cgraph/varpool with body/finalized decl.\n\t(write_symbols_of_kind): Remove.\n\t(produce_symtab): Take outputblock and sets; use cgraph/varpool/alias\n\tpairs to produce symtab.\n\t(produce_asm_for_decls): Update call of produce_symtab; don't do so\n\twhen doing WPA streaming.\n\nFrom-SVN: r161868", "tree": {"sha": "68d780d02870aafdee6c0a31a283f9ed7469baff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68d780d02870aafdee6c0a31a283f9ed7469baff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d1f058528f7d400211b010d8a48201611688b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d1f058528f7d400211b010d8a48201611688b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d1f058528f7d400211b010d8a48201611688b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d1f058528f7d400211b010d8a48201611688b8/comments", "author": null, "committer": null, "parents": [{"sha": "d414dde979f412075132fae7d1c4a242850db642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d414dde979f412075132fae7d1c4a242850db642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d414dde979f412075132fae7d1c4a242850db642"}], "stats": {"total": 278, "additions": 148, "deletions": 130}, "files": [{"sha": "7c3c3f128523afa8fb6817b9121449cbc8a4d0bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d1f058528f7d400211b010d8a48201611688b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d1f058528f7d400211b010d8a48201611688b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5d1f058528f7d400211b010d8a48201611688b8", "patch": "@@ -1,3 +1,15 @@\n+2010-07-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-streamer.c (write_symbol_vec): Rename to ...\n+\t(write_symbol) ... this one; write only symbol given and when\n+\tpresent in cache. Sanity check that what is defined is present\n+\tin cgraph/varpool with body/finalized decl.\n+\t(write_symbols_of_kind): Remove.\n+\t(produce_symtab): Take outputblock and sets; use cgraph/varpool/alias\n+\tpairs to produce symtab.\n+\t(produce_asm_for_decls): Update call of produce_symtab; don't do so\n+\twhen doing WPA streaming.\n+\n 2010-07-05  Jan Hubicka  <jh@suse.cz>\n \n \t* gimple-fold.c (gimple_fold_obj_type_ref_known_binfo): Check that"}, {"sha": "5bf82822a903f405abea2b47b1ec59cbe0d36823", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d1f058528f7d400211b010d8a48201611688b8/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d1f058528f7d400211b010d8a48201611688b8/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c5d1f058528f7d400211b010d8a48201611688b8", "patch": "@@ -1368,7 +1368,7 @@ gimple_fold_obj_type_ref_known_binfo (HOST_WIDE_INT token, tree known_binfo)\n      devirtualize.  This can happen in WHOPR when the actual method\n      ends up in other partition, because we found devirtualization\n      possibility too late.  */\n-  if ((!node || !node->analyzed)\n+  if ((!node || (!node->analyzed && !node->in_other_partition))\n       && (!TREE_PUBLIC (fndecl) || DECL_COMDAT (fndecl)))\n     return NULL;\n   return build_fold_addr_expr (fndecl);"}, {"sha": "5ef7b126c6c8a5ccc986fb4419436ccad46c2347", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 135, "deletions": 129, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d1f058528f7d400211b010d8a48201611688b8/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d1f058528f7d400211b010d8a48201611688b8/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=c5d1f058528f7d400211b010d8a48201611688b8", "patch": "@@ -2266,155 +2266,159 @@ lto_out_decl_state_written_size (struct lto_out_decl_state *state)\n }\n \n \n-/* Helper function of write_symbols_of_kind.  CACHE is the streamer\n-   cache with all the pickled nodes.  STREAM is the stream where to\n-   write the table.  V is a vector with the DECLs that should be on\n-   the table.  SEEN is a bitmap of symbols written so far.  */\n-\n-static void\n-write_symbol_vec (struct lto_streamer_cache_d *cache,\n-\t\t  struct lto_output_stream *stream,\n-\t\t  VEC(tree,heap) *v, bitmap seen)\n-{\n-  tree t;\n-  int index;\n+/* Write symbol T into STREAM in CACHE. SEEN specify symbols we wrote so\n+   far.  */\n+\n+static void\n+write_symbol (struct lto_streamer_cache_d *cache,\n+\t      struct lto_output_stream *stream,\n+\t      tree t, bitmap seen, bool alias)\n+{\n+  const char *name;\n+  enum gcc_plugin_symbol_kind kind;\n+  enum gcc_plugin_symbol_visibility visibility;\n+  int slot_num;\n+  uint64_t size;\n+  const char *comdat;\n+\n+  /* None of the following kinds of symbols are needed in the\n+     symbol table.  */\n+  if (!TREE_PUBLIC (t)\n+      || is_builtin_fn (t)\n+      || DECL_ABSTRACT (t)\n+      || TREE_CODE (t) == RESULT_DECL)\n+    return;\n+\n+  gcc_assert (TREE_CODE (t) == VAR_DECL\n+\t      || TREE_CODE (t) == FUNCTION_DECL);\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));\n+\n+  /* FIXME lto: this is from assemble_name_raw in varasm.c. For some\n+     architectures we might have to do the same name manipulations that\n+     ASM_OUTPUT_LABELREF does. */\n+  if (name[0] == '*')\n+    name = &name[1];\n+\n+  lto_streamer_cache_lookup (cache, t, &slot_num);\n+  gcc_assert (slot_num >= 0);\n+\n+  /* Avoid duplicate symbols. */\n+  if (bitmap_bit_p (seen, slot_num))\n+    return;\n+  else\n+    bitmap_set_bit (seen, slot_num);\n \n-  for (index = 0; VEC_iterate(tree, v, index, t); index++)\n+  if (DECL_EXTERNAL (t))\n     {\n-      const char *name;\n-      enum gcc_plugin_symbol_kind kind;\n-      enum gcc_plugin_symbol_visibility visibility;\n-      int slot_num;\n-      uint64_t size;\n-      const char *comdat;\n-\n-      /* None of the following kinds of symbols are needed in the\n-\t symbol table.  */\n-      if (!TREE_PUBLIC (t)\n-\t  || is_builtin_fn (t)\n-\t  || DECL_ABSTRACT (t)\n-\t  || TREE_CODE (t) == RESULT_DECL)\n-\tcontinue;\n-\n-      gcc_assert (TREE_CODE (t) == VAR_DECL\n-\t\t  || TREE_CODE (t) == FUNCTION_DECL);\n-\n-      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));\n-\n-      /* FIXME lto: this is from assemble_name_raw in varasm.c. For some\n-\t architectures we might have to do the same name manipulations that\n-\t ASM_OUTPUT_LABELREF does. */\n-      if (name[0] == '*')\n-\tname = &name[1];\n-\n-      lto_streamer_cache_lookup (cache, t, &slot_num);\n-      gcc_assert (slot_num >= 0);\n-\n-      /* Avoid duplicate symbols. */\n-      if (bitmap_bit_p (seen, slot_num))\n-\tcontinue;\n-      else\n-        bitmap_set_bit (seen, slot_num);\n-\n-      if (DECL_EXTERNAL (t))\n-\t{\n-\t  if (DECL_WEAK (t))\n-\t    kind = GCCPK_WEAKUNDEF;\n-\t  else\n-\t    kind = GCCPK_UNDEF;\n-\t}\n-      else\n-\t{\n-\t  if (DECL_WEAK (t))\n-\t    kind = GCCPK_WEAKDEF;\n-\t  else if (DECL_COMMON (t))\n-\t    kind = GCCPK_COMMON;\n-\t  else\n-\t    kind = GCCPK_DEF;\n-\t}\n-\n-      switch (DECL_VISIBILITY(t))\n-\t{\n-\tcase VISIBILITY_DEFAULT:\n-\t  visibility = GCCPV_DEFAULT;\n-\t  break;\n-\tcase VISIBILITY_PROTECTED:\n-\t  visibility = GCCPV_PROTECTED;\n-\t  break;\n-\tcase VISIBILITY_HIDDEN:\n-\t  visibility = GCCPV_HIDDEN;\n-\t  break;\n-\tcase VISIBILITY_INTERNAL:\n-\t  visibility = GCCPV_INTERNAL;\n-\t  break;\n-\t}\n-\n-      if (kind == GCCPK_COMMON\n-\t  && DECL_SIZE (t)\n-\t  && TREE_CODE (DECL_SIZE (t)) == INTEGER_CST)\n-\tsize = (((uint64_t) TREE_INT_CST_HIGH (DECL_SIZE (t))) << 32)\n-\t  | TREE_INT_CST_LOW (DECL_SIZE (t));\n+      if (DECL_WEAK (t))\n+\tkind = GCCPK_WEAKUNDEF;\n       else\n-\tsize = 0;\n-\n-      if (DECL_ONE_ONLY (t))\n-\tcomdat = IDENTIFIER_POINTER (DECL_COMDAT_GROUP (t));\n+\tkind = GCCPK_UNDEF;\n+    }\n+  else\n+    {\n+      if (DECL_WEAK (t))\n+\tkind = GCCPK_WEAKDEF;\n+      else if (DECL_COMMON (t))\n+\tkind = GCCPK_COMMON;\n       else\n-\tcomdat = \"\";\n-\n-      lto_output_data_stream (stream, name, strlen (name) + 1);\n-      lto_output_data_stream (stream, comdat, strlen (comdat) + 1);\n-      lto_output_data_stream (stream, &kind, 1);\n-      lto_output_data_stream (stream, &visibility, 1);\n-      lto_output_data_stream (stream, &size, 8);\n-      lto_output_data_stream (stream, &slot_num, 4);\n+\tkind = GCCPK_DEF;\n+\n+      /* When something is defined, it should have a node attached.\n+\t FIXME: For fortran this is still not the case since wrapup global\n+\t decls is done after streaming.  */\n+      gcc_assert (alias || TREE_CODE (t) != FUNCTION_DECL\n+\t\t  || (cgraph_get_node (t)\n+\t\t      && cgraph_get_node (t)->analyzed));\n     }\n-}\n-\n \n-/* Write IL symbols of KIND.  CACHE is the streamer cache with all the\n-   pickled nodes.  SEEN is a bitmap of symbols written so far.  */\n-\n-static void\n-write_symbols_of_kind (lto_decl_stream_e_t kind,\n-\t\t       struct lto_streamer_cache_d *cache, bitmap seen)\n-{\n-  struct lto_out_decl_state *out_state;\n-  struct lto_output_stream stream;\n-  unsigned num_fns =\n-    VEC_length (lto_out_decl_state_ptr, lto_function_decl_states);\n-  unsigned idx;\n-\n-  memset (&stream, 0, sizeof (stream));\n-  out_state = lto_get_out_decl_state ();\n-  write_symbol_vec (cache, &stream, out_state->streams[kind].trees, seen);\n-\n-  for (idx = 0; idx < num_fns; idx++)\n+  switch (DECL_VISIBILITY(t))\n     {\n-      out_state =\n-\tVEC_index (lto_out_decl_state_ptr, lto_function_decl_states, idx);\n-      write_symbol_vec (cache, &stream, out_state->streams[kind].trees, seen);\n+    case VISIBILITY_DEFAULT:\n+      visibility = GCCPV_DEFAULT;\n+      break;\n+    case VISIBILITY_PROTECTED:\n+      visibility = GCCPV_PROTECTED;\n+      break;\n+    case VISIBILITY_HIDDEN:\n+      visibility = GCCPV_HIDDEN;\n+      break;\n+    case VISIBILITY_INTERNAL:\n+      visibility = GCCPV_INTERNAL;\n+      break;\n     }\n \n-  lto_write_stream (&stream);\n+  if (kind == GCCPK_COMMON\n+      && DECL_SIZE (t)\n+      && TREE_CODE (DECL_SIZE (t)) == INTEGER_CST)\n+    size = (((uint64_t) TREE_INT_CST_HIGH (DECL_SIZE (t))) << 32)\n+      | TREE_INT_CST_LOW (DECL_SIZE (t));\n+  else\n+    size = 0;\n+\n+  if (DECL_ONE_ONLY (t))\n+    comdat = IDENTIFIER_POINTER (DECL_COMDAT_GROUP (t));\n+  else\n+    comdat = \"\";\n+\n+  lto_output_data_stream (stream, name, strlen (name) + 1);\n+  lto_output_data_stream (stream, comdat, strlen (comdat) + 1);\n+  lto_output_data_stream (stream, &kind, 1);\n+  lto_output_data_stream (stream, &visibility, 1);\n+  lto_output_data_stream (stream, &size, 8);\n+  lto_output_data_stream (stream, &slot_num, 4);\n }\n \n \n-/* Write an IL symbol table.  CACHE is the streamer cache with all the\n-   pickled nodes.  */\n+/* Write an IL symbol table to OB.\n+   SET and VSET are cgraph/varpool node sets we are outputting.  */\n \n static void\n-produce_symtab (struct lto_streamer_cache_d *cache)\n+produce_symtab (struct output_block *ob,\n+\t        cgraph_node_set set, varpool_node_set vset)\n {\n+  struct lto_streamer_cache_d *cache = ob->writer_cache;\n   char *section_name = lto_get_section_name (LTO_section_symtab, NULL);\n   bitmap seen;\n+  struct cgraph_node *node, *alias;\n+  struct varpool_node *vnode, *valias;\n+  struct lto_output_stream stream;\n+  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n+  lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n+  int i;\n+  alias_pair *p;\n \n   lto_begin_section (section_name, false);\n   free (section_name);\n \n   seen = lto_bitmap_alloc ();\n-  write_symbols_of_kind (LTO_DECL_STREAM_FN_DECL, cache, seen);\n-  write_symbols_of_kind (LTO_DECL_STREAM_VAR_DECL, cache, seen);\n+  memset (&stream, 0, sizeof (stream));\n+\n+  /* Write all functions.  */\n+  for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+    {\n+      node = lto_cgraph_encoder_deref (encoder, i);\n+      write_symbol (cache, &stream, node->decl, seen, false);\n+      for (alias = node->same_body; alias; alias = alias->next)\n+        write_symbol (cache, &stream, alias->decl, seen, true);\n+    }\n+\n+  /* Write all variables.  */\n+  for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n+    {\n+      vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n+      write_symbol (cache, &stream, vnode->decl, seen, false);\n+      for (valias = vnode->extra_name; valias; valias = valias->next)\n+        write_symbol (cache, &stream, valias->decl, seen, true);\n+    }\n+\n+  /* Write all aliases.  */\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+    if (output_alias_pair_p (p, set, vset))\n+      write_symbol (cache, &stream, p->decl, seen, true);\n+\n+  lto_write_stream (&stream);\n   lto_bitmap_free (seen);\n \n   lto_end_section ();\n@@ -2517,8 +2521,10 @@ produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n \n   lto_end_section ();\n \n-  /* Write the symbol table. */\n-  produce_symtab (ob->writer_cache);\n+  /* Write the symbol table.  It is used by linker to determine dependencies\n+     and thus we can skip it for WPA.  */\n+  if (!flag_wpa)\n+    produce_symtab (ob, set, vset);\n \n   /* Write command line opts.  */\n   lto_write_options ();"}]}