{"sha": "f7d86b5ca830ca95899ec5e1585359f9baf19238", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdkODZiNWNhODMwY2E5NTg5OWVjNWUxNTg1MzU5ZjliYWYxOTIzOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-12-11T19:50:43Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-12-11T19:50:43Z"}, "message": "builtins.c (compute_objsize): Add an argument and set it to offset into destination.\n\n\ngcc/ChangeLog:\n\n\t* builtins.c (compute_objsize): Add an argument and set it to offset\n\tinto destination.\n\t* builtins.h (compute_objsize): Add an argument.\n\t* tree-object-size.c (addr_object_size): Add an argument and set it\n\tto offset into destination.\n\t(compute_builtin_object_size): Same.\n\t* tree-object-size.h (compute_builtin_object_size): Add an argument.\n\t* tree-ssa-strlen.c (get_addr_stridx): Add an argument and set it\n\tto offset into destination.\n\t(maybe_warn_overflow): New function.\n\t(handle_store): Call maybe_warn_overflow to issue warnings.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/Wstringop-overflow-2.c: Adjust text of expected messages.\n\t* g++.dg/warn/Wstringop-overflow-3.C: Same.\n\t* gcc.dg/Wstringop-overflow-17.c: Same.\n\nFrom-SVN: r279248", "tree": {"sha": "2ccb64ec581e259d048fcc8de48cee51fbf37494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ccb64ec581e259d048fcc8de48cee51fbf37494"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7d86b5ca830ca95899ec5e1585359f9baf19238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d86b5ca830ca95899ec5e1585359f9baf19238", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d86b5ca830ca95899ec5e1585359f9baf19238", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d86b5ca830ca95899ec5e1585359f9baf19238/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7f5b4eddd8b11383074876e45863ae6b92a1357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7f5b4eddd8b11383074876e45863ae6b92a1357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7f5b4eddd8b11383074876e45863ae6b92a1357"}], "stats": {"total": 588, "additions": 477, "deletions": 111}, "files": [{"sha": "88abb6d5ef3fc299f581da318b4a40e288052419", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -1,3 +1,17 @@\n+2019-12-11  Martin Sebor  <msebor@redhat.com>\n+\n+\t* builtins.c (compute_objsize): Add an argument and set it to offset\n+\tinto destination.\n+\t* builtins.h (compute_objsize): Add an argument.\n+\t* tree-object-size.c (addr_object_size): Add an argument and set it\n+\tto offset into destination.\n+\t(compute_builtin_object_size): Same.\n+\t* tree-object-size.h (compute_builtin_object_size): Add an argument.\n+\t* tree-ssa-strlen.c (get_addr_stridx): Add an argument and set it\n+\tto offset into destination.\n+\t(maybe_warn_overflow): New function.\n+\t(handle_store): Call maybe_warn_overflow to issue warnings.\n+\n 2019-12-11  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* config/msp430/msp430.h (STARTFILE_SPEC) [!fexceptions]: Use"}, {"sha": "4c08214ba2933b20e209728706aacbc9d47e59b5", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -3817,7 +3817,7 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n   /* Only the two least significant bits are meaningful.  */\n   ostype &= 3;\n \n-  if (compute_builtin_object_size (dest, ostype, &size, pdecl))\n+  if (compute_builtin_object_size (dest, ostype, &size, pdecl, poff))\n     return build_int_cst (sizetype, size);\n \n   if (TREE_CODE (dest) == SSA_NAME)\n@@ -3924,7 +3924,7 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t  if (integer_zerop (size)\n \t      && *pdecl && DECL_P (*pdecl)\n \t      && *poff && integer_zerop (*poff))\n-\t    return integer_zero_node;\n+\t    return size_zero_node;\n \n \t  /* A valid offset into a declared object cannot be negative.  */\n \t  if (tree_int_cst_sgn (*poff) < 0)"}, {"sha": "485659228159dc87a082a469e8bb07c2a61f13ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -20,6 +20,12 @@\n \tPR c++/92878 - Parenthesized init of aggregates in new-expression.\n \t* g++.dg/cpp2a/paren-init20.C: New test.\n \n+2019-12-11  Martin Sebor  <msebor@redhat.com>\n+\n+\t* c-c++-common/Wstringop-overflow-2.c: Adjust text of expected messages.\n+\t* g++.dg/warn/Wstringop-overflow-3.C: Same.\n+\t* gcc.dg/Wstringop-overflow-17.c: Same.\n+\n 2019-12-11  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/79221"}, {"sha": "7c7932e3cf0046f3518e7bd9bcc9200ee3336726", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -10,7 +10,7 @@ void sink (void*);\n struct Ax\n {\n   char n;\n-  char a[];                     // { dg-message \"destination object declared here\" }\n+  char a[];                     // { dg-message \"declared here\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -91,7 +91,7 @@ void gaxx (void)\n struct A0\n {\n   char n;\n-  char a[0];                    // { dg-message \"destination object declared here\" }\n+  char a[0];                    // { dg-message \"declared here\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -158,7 +158,7 @@ void ga0x (void)\n struct A1\n {\n   char n;\n-  char a[1];                    // { dg-message \"destination object declared here\" }\n+  char a[1];                    // { dg-message \"declared here\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -256,7 +256,7 @@ void ga1x (void)\n struct A1i\n {\n   char n;\n-  char a[1];                    // { dg-message \"destination object declared here\" }\n+  char a[1];                    // { dg-message \"declared here\" }\n   char x;\n };\n "}, {"sha": "db67136b5e7915d55032a6d66d9517a5b5da0cd8", "filename": "gcc/testsuite/g++.dg/warn/Wstringop-overflow-3.C", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -3,20 +3,22 @@\n    { dg-do compile }\n    { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n \n+#define NOIPA __attribute__ ((noipa))\n+\n void sink (void*);\n \n // Exercise flexible array members.\n \n struct Ax\n {\n   char n;\n-  char a[];                     // { dg-message \"destination object declared here\" }\n+  char a[];                     // { dg-message \"at offset \\[0-2\\] to object 'Ax::a' declared here\" }\n };\n \n // Verify warning for a definition with no initializer.\n Ax ax_;\n \n-void gax_ ()\n+NOIPA void gax_ ()\n {\n   ax_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   ax_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -27,7 +29,7 @@ void gax_ ()\n // initialize the flexible array member.\n Ax ax0 = { 0 };\n \n-void gax0 ()\n+NOIPA void gax0 ()\n {\n   ax0.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   ax0.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -38,7 +40,7 @@ void gax0 ()\n // initializes the flexible array member to empty.\n Ax ax0_ = { 0, { } };\n \n-void gax0_ ()\n+NOIPA void gax0_ ()\n {\n   ax0_.a[0] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   ax0_.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -49,7 +51,7 @@ void gax0_ ()\n // an initializer.\n Ax ax1 = { 1, { 0 } };\n \n-void gax1 ()\n+NOIPA void gax1 ()\n {\n   ax1.a[0] = 0;\n   ax1.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -58,7 +60,7 @@ void gax1 ()\n \n Ax ax2 = { 2, { 1, 0 } };\n \n-void gax2 ()\n+NOIPA void gax2 ()\n {\n   ax2.a[0] = 0;\n   ax2.a[1] = 0;\n@@ -67,7 +69,7 @@ void gax2 ()\n \n \n // Verify no warning for an unknown struct object.\n-void gaxp (Ax *p)\n+NOIPA void gaxp (Ax *p)\n {\n   p->a[0] = 0;\n   p->a[3] = 0;\n@@ -79,7 +81,7 @@ void gaxp (Ax *p)\n // initialized to any number of elements.\n extern Ax axx;\n \n-void gaxx ()\n+NOIPA void gaxx ()\n {\n   axx.a[0] = 0;\n   axx.a[3] = 0;\n@@ -91,13 +93,13 @@ void gaxx ()\n struct A0\n {\n   char n;\n-  char a[0];                    // { dg-message \"destination object declared here\" }\n+  char a[0];                    // { dg-message \"at offset \\[0-2\\] to object 'A0::a' with size 0 declared here\" }\n };\n \n // Verify warning for a definition with no initializer.\n A0 a0_;\n \n-void ga0_ ()\n+NOIPA void ga0_ ()\n {\n   a0_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a0_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -108,7 +110,7 @@ void ga0_ ()\n // initialize the flexible array member.\n A0 a00 = { 0 };\n \n-void ga00 ()\n+NOIPA void ga00 ()\n {\n   a00.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a00.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -119,7 +121,7 @@ void ga00 ()\n // initializes the flexible array member to empty.\n A0 a00_ = { 0, { } };\n \n-void ga00_ ()\n+NOIPA void ga00_ ()\n {\n   a00_.a[0] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a00_.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -133,7 +135,7 @@ void ga00_ ()\n \n \n // Verify no warning for an unknown struct object.\n-void ga0p (A0 *p)\n+NOIPA void ga0p (A0 *p)\n {\n   p->a[0] = 0;\n   p->a[3] = 0;\n@@ -145,7 +147,7 @@ void ga0p (A0 *p)\n // flexible array member) may not be initialized.\n extern A0 a0x;\n \n-void ga0x ()\n+NOIPA void ga0x ()\n {\n   a0x.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a0x.a[3] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -158,13 +160,13 @@ void ga0x ()\n struct A1\n {\n   char n;\n-  char a[1];                    // { dg-message \"destination object declared here\" }\n+  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1::a' with size 1 declared here\" }\n };\n \n // Verify warning for a definition with no initializer.\n A1 a1_;\n \n-void ga1_ ()\n+NOIPA void ga1_ ()\n {\n   a1_.a[0] = 0;\n   a1_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -175,7 +177,7 @@ void ga1_ ()\n // initialize the one-element array member.\n A1 a1__ = { 0 };\n \n-void ga1__ ()\n+NOIPA void ga1__ ()\n {\n   a1__.a[0] = 0;\n   a1__.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -186,7 +188,7 @@ void ga1__ ()\n // initializes the one-element array member to empty.\n A1 a1_0 = { 0, { } };\n \n-void ga1_0_ ()\n+NOIPA void ga1_0_ ()\n {\n   a1_0.a[0] = 0;\n   a1_0.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -197,7 +199,7 @@ void ga1_0_ ()\n // initializes the one-element array member.\n A1 a1_1 = { 0, { 1 } };\n \n-void ga1_1 ()\n+NOIPA void ga1_1 ()\n {\n   a1_1.a[0] = 0;\n   a1_1.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -206,7 +208,7 @@ void ga1_1 ()\n \n \n // Verify no warning for an unknown struct object.\n-void ga1p (A1 *p)\n+NOIPA void ga1p (A1 *p)\n {\n   p->a[0] = 0;\n   p->a[3] = 0;\n@@ -219,7 +221,7 @@ void ga1p (A1 *p)\n // a single element.\n extern A1 a1x;\n \n-void ga1x ()\n+NOIPA void ga1x ()\n {\n   a1x.a[0] = 0;\n   a1x.a[3] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -232,14 +234,14 @@ void ga1x ()\n struct A1i\n {\n   char n;\n-  char a[1];                    // { dg-message \"destination object declared here\" }\n+  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1i::a' with size 1 declared here\" }\n   char x;\n };\n \n // Verify warning for a definition with no initializer.\n A1i a1i_;\n \n-void ga1i_ ()\n+NOIPA void ga1i_ ()\n {\n   a1i_.a[0] = 0;\n   a1i_.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -250,7 +252,7 @@ void ga1i_ ()\n // initialize the one-element array member.\n A1i a1i__ = { 0 };\n \n-void ga1i__ ()\n+NOIPA void ga1i__ ()\n {\n   a1i__.a[0] = 0;\n   a1i__.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -261,7 +263,7 @@ void ga1i__ ()\n // initializes the one-element array member to empty.\n A1 a1i_0 = { 0, { } };\n \n-void ga1i_0_ ()\n+NOIPA void ga1i_0_ ()\n {\n   a1i_0.a[0] = 0;\n   a1i_0.a[1] = 0;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -272,7 +274,7 @@ void ga1i_0_ ()\n // initializes the one-element array member.\n A1 a1i_1 = { 0, { 1 } };\n \n-void ga1i_1 ()\n+NOIPA void ga1i_1 ()\n {\n   a1i_1.a[0] = 0;\n   a1i_1.a[1] = 0;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -281,7 +283,7 @@ void ga1i_1 ()\n \n \n // Verify no warning for an unknown struct object.\n-void ga1ip (A1i *p)\n+NOIPA void ga1ip (A1i *p)\n {\n   p->a[0] = 0;\n   p->a[3] = 0;                  // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -292,7 +294,7 @@ void ga1ip (A1i *p)\n // Verify no warning for an extern struct object.\n extern A1i a1ix;\n \n-void ga1ix ()\n+NOIPA void ga1ix ()\n {\n   a1ix.a[0] = 0;\n   a1ix.a[3] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -305,7 +307,7 @@ void ga1ix ()\n struct Bx\n {\n   char n;\n-  char a[];                     // { dg-message \"destination object declared here\" }\n+  char a[];                     // { dg-message \"at offset 0 to object 'Bx::a' declared here\" }\n \n   // Verify the warning for a constant.\n   Bx () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -315,13 +317,13 @@ struct Bx\n   Bx (int i) { a[i] = 0; }      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n \n-void gbx (void)\n+NOIPA void gbx (void)\n {\n   struct Bx bx;\n   sink (&bx);\n }\n \n-void gbxi (int i)\n+NOIPA void gbxi (int i)\n {\n   struct Bx bxi (i);\n   sink (&bxi);\n@@ -330,13 +332,13 @@ void gbxi (int i)\n struct B0\n {\n   char n;\n-  char a[0];                    // { dg-message \"destination object declared here\" }\n+  char a[0];                    // { dg-message \"at offset 0 to object 'B0::a' with size 0 declared here\" }\n \n   B0 () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n \n \n-void gb0 (void)\n+NOIPA void gb0 (void)\n {\n   struct B0 b0;\n   sink (&b0);\n@@ -346,12 +348,12 @@ void gb0 (void)\n struct B1\n {\n   char n;\n-  char a[1];                    // { dg-message \"destination object declared here\" }\n+  char a[1];                    // { dg-message \"at offset 1 to object 'B1::a' with size 1 declared here\" }\n \n   B1 () { a[1] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n \n-void gb1 (void)\n+NOIPA void gb1 (void)\n {\n   struct B1 b1;\n   sink (&b1);\n@@ -360,12 +362,12 @@ void gb1 (void)\n \n struct B123\n {\n-  char a[123];                  // { dg-message \"destination object declared here\" }\n+  char a[123];                  // { dg-message \"at offset 123 to object 'B123::a' with size 123 declared here\" }\n \n   B123 () { a[123] = 0; }       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n \n-void gb123 (void)\n+NOIPA void gb123 (void)\n {\n   struct B123 b123;\n   sink (&b123);\n@@ -374,12 +376,12 @@ void gb123 (void)\n \n struct B234\n {\n-  char a[234];                  // { dg-message \"destination object declared here\" }\n+  char a[234];                  // { dg-message \"at offset 234 to object 'B234::a' with size 234 declared here\" }\n \n   B234 (int i) { a[i] = 0; }    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n \n-void g234 (void)\n+NOIPA void g234 (void)\n {\n   struct B234 b234 (234);\n   sink (&b234);"}, {"sha": "b903f6eca0b6430b0de2c8da2fa07969fc03fc80", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-17.c?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -13,7 +13,7 @@ void sink (void*);\n \n void call_copy_n (const char *s)\n {\n-  char a[3];        // { dg-message \"destination object declared here\" }\n+  char a[3];        // { dg-message \"declared here\" }\n   copy_n (a, \"1234567\", 7);\n   sink (a);\n }"}, {"sha": "d591c36dea3453ceb76b7136700e0cba24f1816e", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -55,7 +55,7 @@ static const unsigned HOST_WIDE_INT unknown[4] = {\n static tree compute_object_offset (const_tree, const_tree);\n static bool addr_object_size (struct object_size_info *,\n \t\t\t      const_tree, int, unsigned HOST_WIDE_INT *,\n-\t\t\t      tree * = NULL);\n+\t\t\t      tree * = NULL, tree * = NULL);\n static unsigned HOST_WIDE_INT alloc_object_size (const gcall *, int);\n static tree pass_through_call (const gcall *);\n static void collect_object_sizes_for (struct object_size_info *, tree);\n@@ -174,13 +174,15 @@ compute_object_offset (const_tree expr, const_tree var)\n static bool\n addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t\t  int object_size_type, unsigned HOST_WIDE_INT *psize,\n-\t\t  tree *pdecl /* = NULL */)\n+\t\t  tree *pdecl /* = NULL */, tree *poff /* = NULL */)\n {\n   tree pt_var, pt_var_size = NULL_TREE, var_size, bytes;\n \n-  tree dummy;\n+  tree dummy_decl, dummy_off = size_zero_node;\n   if (!pdecl)\n-    pdecl = &dummy;\n+    pdecl = &dummy_decl;\n+  if (!poff)\n+    poff = &dummy_off;\n \n   gcc_assert (TREE_CODE (ptr) == ADDR_EXPR);\n \n@@ -201,7 +203,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t  || TREE_CODE (TREE_OPERAND (pt_var, 0)) != SSA_NAME)\n \t{\n \t  compute_builtin_object_size (TREE_OPERAND (pt_var, 0),\n-\t\t\t\t       object_size_type & ~1, &sz, pdecl);\n+\t\t\t\t       object_size_type & ~1, &sz, pdecl, poff);\n \t}\n       else\n \t{\n@@ -376,6 +378,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t    bytes = size_zero_node;\n \t  else\n \t    bytes = size_binop (MINUS_EXPR, var_size, bytes);\n+\t  *poff = bytes;\n \t}\n       if (var != pt_var\n \t  && pt_var_size\n@@ -390,6 +393,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t\tbytes2 = size_zero_node;\n \t      else\n \t\tbytes2 = size_binop (MINUS_EXPR, pt_var_size, bytes2);\n+\t      *poff = size_binop (PLUS_EXPR, *poff, bytes2);\n \t      bytes = size_binop (MIN_EXPR, bytes, bytes2);\n \t    }\n \t}\n@@ -496,10 +500,16 @@ pass_through_call (const gcall *call)\n bool\n compute_builtin_object_size (tree ptr, int object_size_type,\n \t\t\t     unsigned HOST_WIDE_INT *psize,\n-\t\t\t     tree *pdecl /* = NULL */)\n+\t\t\t     tree *pdecl /* = NULL */, tree *poff /* = NULL */)\n {\n   gcc_assert (object_size_type >= 0 && object_size_type <= 3);\n \n+  tree dummy_decl, dummy_off = size_zero_node;\n+  if (!pdecl)\n+    pdecl = &dummy_decl;\n+  if (!poff)\n+    poff = &dummy_off;\n+\n   /* Set to unknown and overwrite just before returning if the size\n      could be determined.  */\n   *psize = unknown[object_size_type];\n@@ -508,7 +518,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n     init_offset_limit ();\n \n   if (TREE_CODE (ptr) == ADDR_EXPR)\n-    return addr_object_size (NULL, ptr, object_size_type, psize, pdecl);\n+    return addr_object_size (NULL, ptr, object_size_type, psize, pdecl, poff);\n \n   if (TREE_CODE (ptr) != SSA_NAME\n       || !POINTER_TYPE_P (TREE_TYPE (ptr)))\n@@ -533,11 +543,12 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \n \t      if (tree_fits_shwi_p (offset)\n \t\t  && compute_builtin_object_size (ptr, object_size_type,\n-\t\t\t\t\t\t  psize, pdecl))\n+\t\t\t\t\t\t  psize, pdecl, poff))\n \t\t{\n \t\t  /* Return zero when the offset is out of bounds.  */\n \t\t  unsigned HOST_WIDE_INT off = tree_to_shwi (offset);\n \t\t  *psize = off < *psize ? *psize - off : 0;\n+\t\t  *poff = offset;\n \t\t  return true;\n \t\t}\n \t    }"}, {"sha": "d6c7b49068669d0f72577d7099f19e671abdc569", "filename": "gcc/tree-object-size.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftree-object-size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftree-object-size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.h?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -23,6 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n extern void init_object_sizes (void);\n extern void fini_object_sizes (void);\n extern bool compute_builtin_object_size (tree, int, unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t tree * = NULL);\n+\t\t\t\t\t tree * = NULL, tree * = NULL);\n \n #endif  // GCC_TREE_OBJECT_SIZE_H"}, {"sha": "212ac7152bf5a5266a64384ccb8efd5fff074166", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 389, "deletions": 56, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d86b5ca830ca95899ec5e1585359f9baf19238/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=f7d86b5ca830ca95899ec5e1585359f9baf19238", "patch": "@@ -188,6 +188,49 @@ struct laststmt_struct\n static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n static void handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *);\n \n+/* Sets MINMAX to either the constant value or the range VAL is in\n+   and returns true on success.  When nonnull, uses RVALS to get\n+   VAL's range.  Otherwise uses get_range_info.  */\n+\n+static bool\n+get_range (tree val, wide_int minmax[2], const vr_values *rvals = NULL)\n+{\n+  if (tree_fits_uhwi_p (val))\n+    {\n+      minmax[0] = minmax[1] = wi::to_wide (val);\n+      return true;\n+    }\n+\n+  if (TREE_CODE (val) != SSA_NAME)\n+    return false;\n+\n+  if (rvals)\n+    {\n+      /* The range below may be \"inaccurate\" if a constant has been\n+\t substituted earlier for VAL by this pass that hasn't been\n+\t propagated through the CFG.  This shoud be fixed by the new\n+\t on-demand VRP if/when it becomes available (hopefully in\n+\t GCC 11).  */\n+      const value_range *vr\n+\t= (CONST_CAST (class vr_values *, rvals)->get_value_range (val));\n+      value_range_kind rng = vr->kind ();\n+      if (rng != VR_RANGE || !range_int_cst_p (vr))\n+\treturn false;\n+\n+      minmax[0] = wi::to_wide (vr->min ());\n+      minmax[1] = wi::to_wide (vr->max ());\n+      return true;\n+    }\n+\n+  value_range_kind rng = get_range_info (val, minmax, minmax + 1);\n+  if (rng == VR_RANGE)\n+    return true;\n+\n+  /* Do not handle anti-ranges and instead make use of the on-demand\n+     VRP if/when it becomes available (hopefully in GCC 11).  */\n+  return false;\n+}\n+\n /* Return:\n \n    *  +1  if SI is known to start with more than OFF nonzero characters.\n@@ -333,24 +376,32 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n   return 0;\n }\n \n-/* Return string index for EXP.  */\n+/* Returns string index for EXP.  When EXP is an SSA_NAME that refers\n+   to a known strinfo with an offset and OFFRNG is non-null, sets\n+   both elements of the OFFRNG array to the range of the offset and\n+   returns the index of the known strinfo.  In this case the result\n+   must not be used in for functions that modify the string.  */\n \n static int\n-get_stridx (tree exp)\n+get_stridx (tree exp, wide_int offrng[2] = NULL)\n {\n+  if (offrng)\n+    offrng[0] = offrng[1] = wi::zero (TYPE_PRECISION (sizetype));\n+\n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n       if (ssa_ver_to_stridx[SSA_NAME_VERSION (exp)])\n \treturn ssa_ver_to_stridx[SSA_NAME_VERSION (exp)];\n \n       tree e = exp;\n+      int last_idx = 0;\n       HOST_WIDE_INT offset = 0;\n       /* Follow a chain of at most 5 assignments.  */\n       for (int i = 0; i < 5; i++)\n \t{\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (e);\n \t  if (!is_gimple_assign (def_stmt))\n-\t    return 0;\n+\t    return last_idx;\n \n \t  tree_code rhs_code = gimple_assign_rhs_code (def_stmt);\n \t  tree ptr, off;\n@@ -402,25 +453,69 @@ get_stridx (tree exp)\n \t  else\n \t    return 0;\n \n-\t  if (TREE_CODE (ptr) != SSA_NAME\n-\t      || !tree_fits_shwi_p (off))\n+\t  if (TREE_CODE (ptr) != SSA_NAME)\n \t    return 0;\n+\n+\t  if (!tree_fits_shwi_p (off))\n+\t    {\n+\t      if (int idx = ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)])\n+\t\tif (offrng)\n+\t\t  {\n+\t\t    /* Only when requested by setting OFFRNG to non-null,\n+\t\t       return the index corresponding to the SSA_NAME.\n+\t\t       Do this irrespective of the whether the offset\n+\t\t       is known.  */\n+\t\t    if (get_range (off, offrng))\n+\t\t      {\n+\t\t\t/* When the offset range is known, increment it\n+\t\t\t   it by the constant offset computed in prior\n+\t\t\t   iterations and store it in the OFFRNG array.  */\n+ \t\t\toffrng[0] += offset;\n+\t\t\toffrng[1] += offset;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t/* When the offset range cannot be determined\n+\t\t\t   store [0, SIZE_MAX] and let the caller decide\n+\t\t\t   if the offset matters.  */\n+\t\t\toffrng[1] = wi::to_wide (TYPE_MAX_VALUE (sizetype));\n+\t\t\toffrng[0] = wi::zero (offrng[1].get_precision ());\n+\t\t      }\n+\t\t    return idx;\n+\t\t  }\n+\t      return 0;\n+\t    }\n+\n \t  HOST_WIDE_INT this_off = tree_to_shwi (off);\n+\t  if (offrng)\n+\t    {\n+\t      offrng[0] += wi::shwi (this_off, offrng->get_precision ());\n+\t      offrng[1] += offrng[0];\n+\t    }\n+\n \t  if (this_off < 0)\n-\t    return 0;\n+\t    return last_idx;\n+\n \t  offset = (unsigned HOST_WIDE_INT) offset + this_off;\n \t  if (offset < 0)\n-\t    return 0;\n-\t  if (ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)])\n+\t    return last_idx;\n+\n+\t  if (int idx = ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)])\n \t    {\n-\t      strinfo *si\n-\t        = get_strinfo (ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)]);\n-\t      if (si && compare_nonzero_chars (si, offset) >= 0)\n-\t        return get_stridx_plus_constant (si, offset, exp);\n+\t      strinfo *si = get_strinfo (idx);\n+\t      if (si)\n+\t\t{\n+\t\t  if (compare_nonzero_chars (si, offset) >= 0)\n+\t\t    return get_stridx_plus_constant (si, offset, exp);\n+\n+\t\t  if (offrng)\n+\t\t    last_idx = idx;\n+\t\t}\n \t    }\n \t  e = ptr;\n \t}\n-      return 0;\n+\n+      return last_idx;\n     }\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n@@ -1762,6 +1857,279 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n   return set_strlen_range (lhs, min, max, bound);\n }\n \n+/* Diagnose buffer overflow by a STMT writing LEN + PLUS_ONE bytes,\n+   into an object designated by the LHS of STMT otherise.  */\n+\n+static void\n+maybe_warn_overflow (gimple *stmt, tree len,\n+\t\t     const vr_values *rvals = NULL,\n+\t\t     strinfo *si = NULL, bool plus_one = false)\n+{\n+  if (!len || gimple_no_warning_p (stmt))\n+    return;\n+\n+  tree writefn = NULL_TREE;\n+  tree destdecl = NULL_TREE;\n+  tree destsize = NULL_TREE;\n+  tree dest = NULL_TREE;\n+\n+  /* The offset into the destination object set by compute_objsize\n+     but already reflected in DESTSIZE.  */\n+  tree destoff = NULL_TREE;\n+\n+  if (is_gimple_assign (stmt))\n+    {\n+      dest = gimple_assign_lhs (stmt);\n+      if (TREE_NO_WARNING (dest))\n+\treturn;\n+\n+      /* For assignments try to determine the size of the destination\n+\t first.  Set DESTOFF to the the offset on success.  */\n+      tree off = size_zero_node;\n+      destsize = compute_objsize (dest, 1, &destdecl, &off);\n+      if (destsize)\n+\tdestoff = off;\n+    }\n+  else if (is_gimple_call (stmt))\n+    {\n+      writefn = gimple_call_fndecl (stmt);\n+      dest = gimple_call_arg (stmt, 0);\n+    }\n+\n+  /* The offset into the destination object computed below and not\n+     reflected in DESTSIZE.  Either DESTOFF is set above or OFFRNG\n+     below.  */\n+  wide_int offrng[2];\n+  offrng[0] = wi::zero (TYPE_PRECISION (sizetype));\n+  offrng[1] = offrng[0];\n+\n+  if (!destsize && !si && dest)\n+    {\n+      /* For both assignments and calls, if no destination STRINFO was\n+\t provided, try to get it from the DEST.  */\n+      tree ref = dest;\n+      tree off = NULL_TREE;\n+      if (TREE_CODE (ref) == ARRAY_REF)\n+\t{\n+\t  /* Handle stores to VLAs (represented as\n+\t     ARRAY_REF (MEM_REF (vlaptr, 0), N].  */\n+\t  off = TREE_OPERAND (ref, 1);\n+\t  ref = TREE_OPERAND (ref, 0);\n+\t}\n+\n+      if (TREE_CODE (ref) == MEM_REF)\n+\t{\n+\t  tree mem_off = TREE_OPERAND (ref, 1);\n+\t  if (off)\n+\t    {\n+\t      if (!integer_zerop (mem_off))\n+\t\treturn;\n+\t    }\n+\t  else\n+\t    off = mem_off;\n+\t  ref = TREE_OPERAND (ref, 0);\n+\t}\n+\n+      if (int idx = get_stridx (ref, offrng))\n+\t{\n+\t  si = get_strinfo (idx);\n+\t  if (off && TREE_CODE (off) == INTEGER_CST)\n+\t    {\n+\t      wide_int wioff = wi::to_wide (off, offrng->get_precision ());\n+\t      offrng[0] += wioff;\n+\t      offrng[1] += wioff;\n+\t    }\n+\t}\n+      else\n+\treturn;\n+    }\n+\n+  /* Return early if the DESTSIZE size expression is the same as LEN\n+     and the offset into the destination is zero.  This might happen\n+     in the case of a pair of malloc and memset calls to allocate\n+     an object and clear it as if by calloc.  */\n+  if (destsize == len && !plus_one && offrng[0] == 0 && offrng[0] == offrng[1])\n+    return;\n+\n+  wide_int lenrng[2];\n+  if (!get_range (len, lenrng, rvals))\n+    return;\n+\n+  if (plus_one)\n+    {\n+      lenrng[0] += 1;\n+      lenrng[1] += 1;\n+    }\n+\n+  /* Compute the range of sizes of the destination object.  The range\n+     is constant for declared objects but may be a range for allocated\n+     objects.  */\n+  wide_int sizrng[2];\n+  if (!destsize || !get_range (destsize, sizrng, rvals))\n+    {\n+      /* On failure, rather than bailing outright, use the maximum range\n+\t so that overflow in allocated objects whose size depends on\n+\t the strlen of the source can still be diagnosed below.  */\n+      sizrng[0] = wi::zero (lenrng->get_precision ());\n+      sizrng[1] = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n+    }\n+\n+  /* The size of the remaining space in the destination computed as\n+     the size of the latter minus the offset into it.  */\n+  wide_int spcrng[2] = { sizrng[0], sizrng[1] };\n+  if (wi::sign_mask (offrng[0]))\n+    {\n+      /* FIXME: Handle negative offsets into allocated objects.  */\n+      if (destdecl)\n+\tspcrng[0] = spcrng[1] = wi::zero (spcrng->get_precision ());\n+      else\n+\treturn;\n+    }\n+  else\n+    {\n+      spcrng[0] -= wi::ltu_p (offrng[0], spcrng[0]) ? offrng[0] : spcrng[0];\n+      spcrng[1] -= wi::ltu_p (offrng[0], spcrng[1]) ? offrng[0] : spcrng[1];\n+    }\n+\n+  if (wi::leu_p (lenrng[0], spcrng[0]))\n+    return;\n+\n+  if (lenrng[0] == spcrng[1]\n+      && (len != destsize\n+\t  || !si || !is_strlen_related_p (si->ptr, len)))\n+    return;\n+\n+  location_t loc = gimple_nonartificial_location (stmt);\n+  if (loc == UNKNOWN_LOCATION && dest && EXPR_HAS_LOCATION (dest))\n+    loc = tree_nonartificial_location (dest);\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  bool warned = false;\n+  if (wi::leu_p (lenrng[0], spcrng[1]))\n+    {\n+      if (len != destsize\n+\t  && (!si || !is_strlen_related_p (si->ptr, len)))\n+\treturn;\n+\n+      warned = (writefn\n+\t\t? warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t      \"%G%qD writing one too many bytes into a region \"\n+\t\t\t      \"of a size that depends on %<strlen%>\",\n+\t\t\t      stmt, writefn)\n+\t\t: warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t      \"%Gwriting one too many bytes into a region \"\n+\t\t\t      \"of a size that depends on %<strlen%>\",\n+\t\t\t      stmt));\n+    }\n+  else if (lenrng[0] == lenrng[1])\n+    {\n+      if (spcrng[0] == spcrng[1])\n+\twarned = (writefn\n+\t\t  ? warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t\t       lenrng[0].to_uhwi (),\n+\t\t\t       \"%G%qD writing %wu byte into a region \"\n+\t\t\t       \"of size %wu\",\n+\t\t\t       \"%G%qD writing %wu bytes into a region \"\n+\t\t\t       \"of size %wu\",\n+\t\t\t       stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t       spcrng[0].to_uhwi ())\n+\t\t  : warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t\t       lenrng[0].to_uhwi (),\n+\t\t\t       \"%Gwriting %wu byte into a region \"\n+\t\t\t       \"of size %wu\",\n+\t\t\t       \"%Gwriting %wu bytes into a region \"\n+\t\t\t       \"of size %wu\",\n+\t\t\t       stmt, lenrng[0].to_uhwi (),\n+\t\t\t       spcrng[0].to_uhwi ()));\n+      else\n+\twarned = (writefn\n+\t\t  ? warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t\t       lenrng[0].to_uhwi (),\n+\t\t\t       \"%G%qD writing %wu byte into a region \"\n+\t\t\t       \"of size between %wu and %wu\",\n+\t\t\t       \"%G%qD writing %wu bytes into a region \"\n+\t\t\t       \"of size between %wu and %wu\",\n+\t\t\t       stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t       spcrng[0].to_uhwi (), spcrng[1].to_uhwi ())\n+\t\t  : warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t\t       lenrng[0].to_uhwi (),\n+\t\t\t       \"%Gwriting %wu byte into a region \"\n+\t\t\t       \"of size between %wu and %wu\",\n+\t\t\t       \"%Gwriting %wu bytes into a region \"\n+\t\t\t       \"of size between %wu and %wu\",\n+\t\t\t       stmt, lenrng[0].to_uhwi (),\n+\t\t\t       spcrng[0].to_uhwi (), spcrng[1].to_uhwi ()));\n+    }\n+  else if (spcrng[0] == spcrng[1])\n+    warned = (writefn\n+\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%G%qD writing between %wu and %wu bytes \"\n+\t\t\t    \"into a region of size %wu\",\n+\t\t\t    stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t    lenrng[1].to_uhwi (),\n+\t\t\t    spcrng[0].to_uhwi ())\n+\t      : warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%Gwriting between %wu and %wu bytes \"\n+\t\t\t    \"into a region of size %wu\",\n+\t\t\t    stmt, lenrng[0].to_uhwi (),\n+\t\t\t    lenrng[1].to_uhwi (),\n+\t\t\t    spcrng[0].to_uhwi ()));\n+  else\n+    warned = (writefn\n+\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%G%qD writing between %wu and %wu bytes \"\n+\t\t\t    \"into a region of size between %wu and %wu\",\n+\t\t\t    stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t    lenrng[1].to_uhwi (),\n+\t\t\t    spcrng[0].to_uhwi (), spcrng[1].to_uhwi ())\n+\t      : warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%Gwriting between %wu and %wu bytes \"\n+\t\t\t    \"into a region of size between %wu and %wu\",\n+\t\t\t    stmt, lenrng[0].to_uhwi (),\n+\t\t\t    lenrng[1].to_uhwi (),\n+\t\t\t    spcrng[0].to_uhwi (), spcrng[1].to_uhwi ()));\n+\n+  if (!warned)\n+    return;\n+\n+  /* If DESTOFF is not null, use it to format the offset value/range.  */\n+  if (destoff)\n+    get_range (destoff, offrng);\n+\n+  /* Format the offset to keep the number of inform calls from growing\n+     out of control.  */\n+  char offstr[64];\n+  if (offrng[0] == offrng[1])\n+    sprintf (offstr, \"%lli\", (long long) offrng[0].to_shwi ());\n+  else\n+    sprintf (offstr, \"[%lli, %lli]\",\n+\t     (long long) offrng[0].to_shwi (), (long long) offrng[1].to_shwi ());\n+\n+  if (destdecl)\n+    {\n+      if (tree size = DECL_SIZE_UNIT (destdecl))\n+\tinform (DECL_SOURCE_LOCATION (destdecl),\n+\t\t\"at offset %s to object %qD with size %E declared here\",\n+\t\toffstr, destdecl, size);\n+      else\n+\tinform (DECL_SOURCE_LOCATION (destdecl),\n+\t\t\"at offset %s to object %qD declared here\",\n+\t\toffstr, destdecl);\n+      return;\n+    }\n+}\n+\n+/* Convenience wrapper for the above.  */\n+\n+static inline void\n+maybe_warn_overflow (gimple *stmt, unsigned HOST_WIDE_INT len,\n+\t\t     const vr_values *rvals = NULL,\n+\t\t     strinfo *si = NULL, bool plus_one = false)\n+{\n+  maybe_warn_overflow (stmt, build_int_cst (size_type_node, len), rvals,\n+\t\t       si, plus_one);\n+}\n+\n /* Handle a strlen call.  If strlen of the argument is known, replace\n    the strlen call with the known value, otherwise remember that strlen\n    of the argument is stored in the lhs SSA_NAME.  */\n@@ -4333,6 +4701,13 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write, const vr_values *rval\n \t  else if (si == NULL || compare_nonzero_chars (si, offset, rvals) < 0)\n \t    {\n \t      *zero_write = initializer_zerop (rhs);\n+\n+\t      bool dummy;\n+\t      unsigned lenrange[] = { UINT_MAX, 0, 0 };\n+\t      if (count_nonzero_bytes (rhs, lenrange, &dummy, &dummy, &dummy,\n+\t\t\t\t       rvals))\n+\t\tmaybe_warn_overflow (stmt, lenrange[2], rvals);\n+\n \t      return true;\n \t    }\n \t}\n@@ -4371,49 +4746,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write, const vr_values *rval\n       storing_nonzero_p = lenrange[1] > 0;\n       *zero_write = storing_all_zeros_p;\n \n-      /* Avoid issuing multiple warnings for the same LHS or statement.\n-\t For example, -Warray-bounds may have already been issued for\n-\t an out-of-bounds subscript.  */\n-      if (!TREE_NO_WARNING (lhs) && !gimple_no_warning_p (stmt))\n-\t{\n-\t  /* Set to the declaration referenced by LHS (if known).  */\n-\t  tree decl = NULL_TREE;\n-\t  if (tree dstsize = compute_objsize (lhs, 1, &decl))\n-\t    if (compare_tree_int (dstsize, lenrange[2]) < 0)\n-\t      {\n-\t\t/* Fall back on the LHS location if the statement\n-\t\t   doesn't have one.  */\n-\t\tlocation_t loc = gimple_nonartificial_location (stmt);\n-\t\tif (loc == UNKNOWN_LOCATION && EXPR_HAS_LOCATION (lhs))\n-\t\t  loc = tree_nonartificial_location (lhs);\n-\t\tloc = expansion_point_location_if_in_system_header (loc);\n-\t\tif (warning_n (loc, OPT_Wstringop_overflow_,\n-\t\t\t       lenrange[2],\n-\t\t\t       \"%Gwriting %u byte into a region of size %E\",\n-\t\t\t       \"%Gwriting %u bytes into a region of size %E\",\n-\t\t\t       stmt, lenrange[2], dstsize))\n-\t\t  {\n-\t\t    if (decl)\n-\t\t      {\n-\t\t\tif (TREE_CODE (decl) == SSA_NAME)\n-\t\t\t  {\n-\t\t\t    gimple *stmt = SSA_NAME_DEF_STMT (decl);\n-\t\t\t    if (is_gimple_call (stmt))\n-\t\t\t      {\n-\t\t\t\ttree allocfn = gimple_call_fndecl (stmt);\n-\t\t\t\tinform (gimple_location (stmt),\n-\t\t\t\t\t\"destination region allocated by %qD \"\n-\t\t\t\t\t\"here\", allocfn);\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  inform (DECL_SOURCE_LOCATION (decl),\n-\t\t\t\t  \"destination object declared here\");\n-\t\t      }\n-\t\t    gimple_set_no_warning (stmt, true);\n-\t\t  }\n-\t      }\n-\t}\n+      maybe_warn_overflow (stmt, lenrange[2], rvals);\n     }\n   else\n     {"}]}