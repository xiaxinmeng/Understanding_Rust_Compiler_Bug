{"sha": "7590cfd0ca7288f014694f23aa696e55f2e1806e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU5MGNmZDBjYTcyODhmMDE0Njk0ZjIzYWE2OTZlNTVmMmUxODA2ZQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2002-03-24T16:09:04Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-03-24T16:09:04Z"}, "message": "m68hc11.c (m68hc11_autoinc_compatible_p): New function.\n\n\t* config/m68hc11/m68hc11.c (m68hc11_autoinc_compatible_p): New function.\n\t(m68hc11_split_move): Call it to see if the source and destination\n\toperands use the same direction auto inc/dec mode, otherwise make the\n\tsource an offsetable operand and generate an add.\n\nFrom-SVN: r51264", "tree": {"sha": "2a9aa11e3b24957a1153d6ecabc5ce3550b07099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a9aa11e3b24957a1153d6ecabc5ce3550b07099"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7590cfd0ca7288f014694f23aa696e55f2e1806e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7590cfd0ca7288f014694f23aa696e55f2e1806e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7590cfd0ca7288f014694f23aa696e55f2e1806e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7590cfd0ca7288f014694f23aa696e55f2e1806e/comments", "author": null, "committer": null, "parents": [{"sha": "2e3d348133d3ce6bf9b3952bbe094c1e9d32c02f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3d348133d3ce6bf9b3952bbe094c1e9d32c02f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3d348133d3ce6bf9b3952bbe094c1e9d32c02f"}], "stats": {"total": 64, "additions": 64, "deletions": 0}, "files": [{"sha": "b9cec29d092333dea6df7f4fae1277e2ca946ceb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7590cfd0ca7288f014694f23aa696e55f2e1806e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7590cfd0ca7288f014694f23aa696e55f2e1806e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7590cfd0ca7288f014694f23aa696e55f2e1806e", "patch": "@@ -1,3 +1,10 @@\n+2002-03-24  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.c (m68hc11_autoinc_compatible_p): New function.\n+\t(m68hc11_split_move): Call it to see if the source and destination\n+\toperands use the same direction auto inc/dec mode, otherwise make the\n+\tsource an offsetable operand and generate an add.\n+\n 2002-03-24  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.md (\"*subsi3_zero_extendhi\"): Allow address"}, {"sha": "f3c6a950f80e025fc88f82116cefcdffe11d2d28", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7590cfd0ca7288f014694f23aa696e55f2e1806e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7590cfd0ca7288f014694f23aa696e55f2e1806e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=7590cfd0ca7288f014694f23aa696e55f2e1806e", "patch": "@@ -2683,6 +2683,39 @@ m68hc11_expand_compare_and_branch (code, op0, op1, label)\n   return 0;\n }\n \n+/* Return 1 if the TO and FROM operands contain compatible address\n+   increment and decrement modes for a split_move.  One of the two\n+   operands must not use an autoinc mode or both must go in the\n+   same direction.  */\n+static int\n+m68hc11_autoinc_compatible_p (to, from)\n+     rtx to, from;\n+{\n+  enum { INCOP, DECOP } type_to, type_from;\n+\n+  /* If one of them is not a MEM, it is ok.  */\n+  if (GET_CODE (to) != MEM || GET_CODE (from) != MEM)\n+    return 1;\n+\n+  to = XEXP (to, 0);\n+  from = XEXP (from, 0);\n+\n+  if (GET_CODE (to) == PRE_INC || GET_CODE (to) == POST_INC)\n+    type_to = INCOP;\n+  else if (GET_CODE (to) == PRE_DEC || GET_CODE (to) == POST_DEC)\n+    type_to = DECOP;\n+  else\n+    return 1;\n+  \n+  if (GET_CODE (from) == PRE_INC || GET_CODE (from) == POST_INC)\n+    type_from = INCOP;\n+  else if (GET_CODE (from) == PRE_DEC || GET_CODE (from) == POST_DEC)\n+    type_from = DECOP;\n+  else\n+    return 1;\n+\n+  return type_to == type_from;\n+}\n \n /* Split a DI, SI or HI move into several smaller move operations.\n    The scratch register 'scratch' is used as a temporary to load\n@@ -2704,6 +2737,30 @@ m68hc11_split_move (to, from, scratch)\n   else\n     mode = QImode;\n \n+  /* If the TO and FROM contain autoinc modes that are not compatible\n+     together (one pop and the other a push), we must change one to\n+     an offsetable operand and generate an appropriate add at the end.  */\n+  if (TARGET_M6812 && m68hc11_autoinc_compatible_p (to, from) == 0)\n+    {\n+      rtx reg;\n+      int code;\n+\n+      /* Decide to change the source.  */\n+      code = GET_CODE (XEXP (from, 0));\n+      reg = XEXP (XEXP (from, 0), 0);\n+      offset = GET_MODE_SIZE (GET_MODE (from));\n+      if (code == PRE_DEC || code == POST_DEC)\n+        offset = -offset;\n+\n+      if (code == PRE_DEC || code == PRE_INC)\n+        emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+      m68hc11_split_move (to, gen_rtx_MEM (GET_MODE (from), reg), scratch);\n+      if (code == POST_DEC || code == POST_INC)\n+        emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+\n+      return;\n+    }\n+\n   if (TARGET_M6812\n       && IS_STACK_PUSH (to)\n       && reg_mentioned_p (gen_rtx (REG, HImode, HARD_SP_REGNUM), from))"}]}