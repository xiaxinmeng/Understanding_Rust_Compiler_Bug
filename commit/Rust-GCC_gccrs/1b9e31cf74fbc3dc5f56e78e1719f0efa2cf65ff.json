{"sha": "1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI5ZTMxY2Y3NGZiYzNkYzVmNTZlNzhlMTcxOWYwZWZhMmNmNjVmZg==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2016-09-23T09:00:34Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2016-09-23T09:00:34Z"}, "message": "[PATCH 3/17][Testsuite] Add ARM support for ARMv8.2-A with FP16 arithmetic instructions.\n\ngcc/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* doc/sourcebuild.texi (ARM-specific attributes): Add anchor for\n\tarm_v8_1a_neon_ok.  Add entries for arm_v8_2a_fp16_scalar_ok,\n\tarm_v8_2a_fp16_scalar_hw, arm_v8_2a_fp16_neon_ok and\n\tarm_v8_2a_fp16_neon_hw.\n\t(Add options): Add entries for arm_v8_1a_neon, arm_v8_2a_scalar,\n\tarm_v8_2a_neon.\n\ntestsuite/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* lib/target-supports.exp (add_options_for_arm_v8_2a_fp16_scalar):\n\tNew.\n\t(add_options_for_arm_v8_2a_fp16_neon): New.\n\t(check_effective_target_arm_arch_v8_2a_ok): Auto-generate.\n\t(add_options_for_arm_arch_v8_2a): Auto-generate.\n\t(check_effective_target_arm_arch_v8_2a_multilib): Auto-generate.\n\t(check_effective_target_arm_v8_2a_fp16_scalar_ok_nocache): New.\n\t(check_effective_target_arm_v8_2a_fp16_scalar_ok): New.\n\t(check_effective_target_arm_v8_2a_fp16_neon_ok_nocache): New.\n\t(check_effective_target_arm_v8_2a_fp16_neon_ok): New.\n\t(check_effective_target_arm_v8_2a_fp16_scalar_hw): New.\n\t(check_effective_target_arm_v8_2a_fp16_neon_hw): New.\n\nFrom-SVN: r240401", "tree": {"sha": "122c773e5007392f84d24957bce636973a7ce38d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/122c773e5007392f84d24957bce636973a7ce38d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/comments", "author": null, "committer": null, "parents": [{"sha": "a5b42ee71336cfe55e42c50e2379be21c347b97a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b42ee71336cfe55e42c50e2379be21c347b97a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b42ee71336cfe55e42c50e2379be21c347b97a"}], "stats": {"total": 207, "additions": 207, "deletions": 0}, "files": [{"sha": "3e440959e48217d00447d045013da1c9af2cc674", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "patch": "@@ -1,3 +1,12 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* doc/sourcebuild.texi (ARM-specific attributes): Add anchor for\n+\tarm_v8_1a_neon_ok.  Add entries for arm_v8_2a_fp16_scalar_ok,\n+\tarm_v8_2a_fp16_scalar_hw, arm_v8_2a_fp16_neon_ok and\n+\tarm_v8_2a_fp16_neon_hw.\n+\t(Add options): Add entries for arm_v8_1a_neon, arm_v8_2a_scalar,\n+\tarm_v8_2a_neon.\n+\n 2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* doc/sourcebuild.texi (ARM-specific attributes): Add entries for"}, {"sha": "07c75e2847ae37ec22ce1f6483c3d201ac001725", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "patch": "@@ -1629,6 +1629,7 @@ ARM target supports @code{-mfpu=neon-fp-armv8 -mfloat-abi=softfp}.\n Some multilibs may be incompatible with these options.\n \n @item arm_v8_1a_neon_ok\n+@anchor{arm_v8_1a_neon_ok}\n ARM target supports options to generate ARMv8.1 Adv.SIMD instructions.\n Some multilibs may be incompatible with these options.\n \n@@ -1640,6 +1641,28 @@ arm_v8_1a_neon_ok.\n @item arm_acq_rel\n ARM target supports acquire-release instructions.\n \n+@item arm_v8_2a_fp16_scalar_ok\n+@anchor{arm_v8_2a_fp16_scalar_ok}\n+ARM target supports options to generate instructions for ARMv8.2 and\n+scalar instructions from the FP16 extension.  Some multilibs may be\n+incompatible with these options.\n+\n+@item arm_v8_2a_fp16_scalar_hw\n+ARM target supports executing instructions for ARMv8.2 and scalar\n+instructions from the FP16 extension.  Some multilibs may be\n+incompatible with these options.  Implies arm_v8_2a_fp16_neon_ok.\n+\n+@item arm_v8_2a_fp16_neon_ok\n+@anchor{arm_v8_2a_fp16_neon_ok}\n+ARM target supports options to generate instructions from ARMv8.2 with\n+the FP16 extension.  Some multilibs may be incompatible with these\n+options.  Implies arm_v8_2a_fp16_scalar_ok.\n+\n+@item arm_v8_2a_fp16_neon_hw\n+ARM target supports executing instructions from ARMv8.2 with the FP16\n+extension.  Some multilibs may be incompatible with these options.\n+Implies arm_v8_2a_fp16_neon_ok and arm_v8_2a_fp16_scalar_hw.\n+\n @item arm_prefer_ldrd_strd\n ARM target prefers @code{LDRD} and @code{STRD} instructions over\n @code{LDM} and @code{STM} instructions.\n@@ -2154,6 +2177,23 @@ the @ref{arm_neon_fp16_ok,,arm_neon_fp16_ok effective target keyword}.\n arm vfp3 floating point support; see\n the @ref{arm_vfp3_ok,,arm_vfp3_ok effective target keyword}.\n \n+@item arm_v8_1a_neon\n+Add options for ARMv8.1 with Adv.SIMD support, if this is supported\n+by the target; see the @ref{arm_v8_1a_neon_ok,,arm_v8_1a_neon_ok}\n+effective target keyword.\n+\n+@item arm_v8_2a_fp16_scalar\n+Add options for ARMv8.2 with scalar FP16 support, if this is\n+supported by the target; see the\n+@ref{arm_v8_2a_fp16_scalar_ok,,arm_v8_2a_fp16_scalar_ok} effective\n+target keyword.\n+\n+@item arm_v8_2a_fp16_neon\n+Add options for ARMv8.2 with Adv.SIMD FP16 support, if this is\n+supported by the target; see the\n+@ref{arm_v8_2a_fp16_neon_ok,,arm_v8_2a_fp16_neon_ok} effective target\n+keyword.\n+\n @item bind_pic_locally\n Add the target-specific flags needed to enable functions to bind\n locally when using pic/PIC passes in the testsuite."}, {"sha": "c60fdf2b1dd0dc0376f49bed559f3ec3642cfa59", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "patch": "@@ -1,3 +1,18 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* lib/target-supports.exp (add_options_for_arm_v8_2a_fp16_scalar):\n+\tNew.\n+\t(add_options_for_arm_v8_2a_fp16_neon): New.\n+\t(check_effective_target_arm_arch_v8_2a_ok): Auto-generate.\n+\t(add_options_for_arm_arch_v8_2a): Auto-generate.\n+\t(check_effective_target_arm_arch_v8_2a_multilib): Auto-generate.\n+\t(check_effective_target_arm_v8_2a_fp16_scalar_ok_nocache): New.\n+\t(check_effective_target_arm_v8_2a_fp16_scalar_ok): New.\n+\t(check_effective_target_arm_v8_2a_fp16_neon_ok_nocache): New.\n+\t(check_effective_target_arm_v8_2a_fp16_neon_ok): New.\n+\t(check_effective_target_arm_v8_2a_fp16_scalar_hw): New.\n+\t(check_effective_target_arm_v8_2a_fp16_neon_hw): New.\n+\n 2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* g++.dg/ext/arm-fp16/arm-fp16-ops-3.C: Use"}, {"sha": "3d11e28955941428cd20f692d51d98752506946d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=1b9e31cf74fbc3dc5f56e78e1719f0efa2cf65ff", "patch": "@@ -3215,6 +3215,28 @@ proc add_options_for_arm_v8_1a_neon { flags } {\n     return \"$flags $et_arm_v8_1a_neon_flags -march=armv8.1-a\"\n }\n \n+# Add the options needed for ARMv8.2 with the scalar FP16 extension.\n+# Also adds the ARMv8 FP options for ARM.\n+\n+proc add_options_for_arm_v8_2a_fp16_scalar { flags } {\n+    if { ! [check_effective_target_arm_v8_2a_fp16_scalar_ok] } {\n+\treturn \"$flags\"\n+    }\n+    global et_arm_v8_2a_fp16_scalar_flags\n+    return \"$flags $et_arm_v8_2a_fp16_scalar_flags\"\n+}\n+\n+# Add the options needed for ARMv8.2 with the FP16 extension.  Also adds\n+# the ARMv8 NEON options for ARM.\n+\n+proc add_options_for_arm_v8_2a_fp16_neon { flags } {\n+    if { ! [check_effective_target_arm_v8_2a_fp16_neon_ok] } {\n+\treturn \"$flags\"\n+    }\n+    global et_arm_v8_2a_fp16_neon_flags\n+    return \"$flags $et_arm_v8_2a_fp16_neon_flags\"\n+}\n+\n proc add_options_for_arm_crc { flags } {\n     if { ! [check_effective_target_arm_crc_ok] } {\n         return \"$flags\"\n@@ -3615,6 +3637,7 @@ foreach { armfunc armflag armdef } { v4 \"-march=armv4 -marm\" __ARM_ARCH_4__\n \t\t\t\t     v7em \"-march=armv7e-m -mthumb\" __ARM_ARCH_7EM__\n \t\t\t\t     v8a \"-march=armv8-a\" __ARM_ARCH_8A__\n \t\t\t\t     v8_1a \"-march=armv8.1a\" __ARM_ARCH_8A__\n+\t\t\t\t     v8_2a \"-march=armv8.2a\" __ARM_ARCH_8A__\n \t\t\t\t     v8m_base \"-march=armv8-m.base -mthumb\" __ARM_ARCH_8M_BASE__\n \t\t\t\t     v8m_main \"-march=armv8-m.main -mthumb\" __ARM_ARCH_8M_MAIN__ } {\n     eval [string map [list FUNC $armfunc FLAG $armflag DEF $armdef ] {\n@@ -3860,6 +3883,76 @@ proc check_effective_target_arm_v8_1a_neon_ok { } {\n \t\tcheck_effective_target_arm_v8_1a_neon_ok_nocache]\n }\n \n+# Return 1 if the target supports ARMv8.2 scalar FP16 arithmetic\n+# instructions, 0 otherwise.  The test is valid for ARM.  Record the\n+# command line options needed.\n+\n+proc check_effective_target_arm_v8_2a_fp16_scalar_ok_nocache { } {\n+    global et_arm_v8_2a_fp16_scalar_flags\n+    set et_arm_v8_2a_fp16_scalar_flags \"\"\n+\n+    if { ![istarget arm*-*-*] } {\n+\treturn 0;\n+    }\n+\n+    # Iterate through sets of options to find the compiler flags that\n+    # need to be added to the -march option.\n+    foreach flags {\"\" \"-mfpu=fp-armv8\" \"-mfloat-abi=softfp\" \\\n+\t\t       \"-mfpu=fp-armv8 -mfloat-abi=softfp\"} {\n+\tif { [check_no_compiler_messages_nocache \\\n+\t\t  arm_v8_2a_fp16_scalar_ok object {\n+\t    #if !defined (__ARM_FEATURE_FP16_SCALAR_ARITHMETIC)\n+\t    #error \"__ARM_FEATURE_FP16_SCALAR_ARITHMETIC not defined\"\n+\t    #endif\n+\t} \"$flags -march=armv8.2-a+fp16\"] } {\n+\t    set et_arm_v8_2a_fp16_scalar_flags \"$flags -march=armv8.2-a+fp16\"\n+\t    return 1\n+\t}\n+    }\n+\n+    return 0;\n+}\n+\n+proc check_effective_target_arm_v8_2a_fp16_scalar_ok { } {\n+    return [check_cached_effective_target arm_v8_2a_fp16_scalar_ok \\\n+\t\tcheck_effective_target_arm_v8_2a_fp16_scalar_ok_nocache]\n+}\n+\n+# Return 1 if the target supports ARMv8.2 Adv.SIMD FP16 arithmetic\n+# instructions, 0 otherwise.  The test is valid for ARM.  Record the\n+# command line options needed.\n+\n+proc check_effective_target_arm_v8_2a_fp16_neon_ok_nocache { } {\n+    global et_arm_v8_2a_fp16_neon_flags\n+    set et_arm_v8_2a_fp16_neon_flags \"\"\n+\n+    if { ![istarget arm*-*-*] } {\n+\treturn 0;\n+    }\n+\n+    # Iterate through sets of options to find the compiler flags that\n+    # need to be added to the -march option.\n+    foreach flags {\"\" \"-mfpu=neon-fp-armv8\" \"-mfloat-abi=softfp\" \\\n+\t\t       \"-mfpu=neon-fp-armv8 -mfloat-abi=softfp\"} {\n+\tif { [check_no_compiler_messages_nocache \\\n+\t\t  arm_v8_2a_fp16_neon_ok object {\n+\t    #if !defined (__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)\n+\t    #error \"__ARM_FEATURE_FP16_VECTOR_ARITHMETIC not defined\"\n+\t    #endif\n+\t} \"$flags -march=armv8.2-a+fp16\"] } {\n+\t    set et_arm_v8_2a_fp16_neon_flags \"$flags -march=armv8.2-a+fp16\"\n+\t    return 1\n+\t}\n+    }\n+\n+    return 0;\n+}\n+\n+proc check_effective_target_arm_v8_2a_fp16_neon_ok { } {\n+    return [check_cached_effective_target arm_v8_2a_fp16_neon_ok \\\n+\t\tcheck_effective_target_arm_v8_2a_fp16_neon_ok_nocache]\n+}\n+\n # Return 1 if the target supports executing ARMv8 NEON instructions, 0\n # otherwise.\n \n@@ -3922,6 +4015,56 @@ proc check_effective_target_arm_v8_1a_neon_hw { } {\n     } [add_options_for_arm_v8_1a_neon \"\"]]\n }\n \n+# Return 1 if the target supports executing instructions floating point\n+# instructions from ARMv8.2 with the FP16 extension, 0 otherwise.  The\n+# test is valid for ARM.\n+\n+proc check_effective_target_arm_v8_2a_fp16_scalar_hw { } {\n+    if { ![check_effective_target_arm_v8_2a_fp16_scalar_ok] } {\n+\treturn 0;\n+    }\n+    return [check_runtime arm_v8_2a_fp16_scalar_hw_available {\n+\tint\n+\tmain (void)\n+\t{\n+\t  __fp16 a = 1.0;\n+\t  __fp16 result;\n+\n+\t  asm (\"vabs.f16 %0, %1\"\n+\t       : \"=w\"(result)\n+\t       : \"w\"(a)\n+\t       : /* No clobbers.  */);\n+\n+\t  return (result == 1.0) ? 0 : 1;\n+\t}\n+    } [add_options_for_arm_v8_2a_fp16_scalar \"\"]]\n+}\n+\n+# Return 1 if the target supports executing instructions Adv.SIMD\n+# instructions from ARMv8.2 with the FP16 extension, 0 otherwise.  The\n+# test is valid for ARM.\n+\n+proc check_effective_target_arm_v8_2a_fp16_neon_hw { } {\n+    if { ![check_effective_target_arm_v8_2a_fp16_neon_ok] } {\n+\treturn 0;\n+    }\n+    return [check_runtime arm_v8_2a_fp16_neon_hw_available {\n+\tint\n+\tmain (void)\n+\t{\n+\t  __simd64_float16_t a = {1.0, -1.0, 1.0, -1.0};\n+\t  __simd64_float16_t result;\n+\n+\t  asm (\"vabs.f16 %P0, %P1\"\n+\t       : \"=w\"(result)\n+\t       : \"w\"(a)\n+\t       : /* No clobbers.  */);\n+\n+\t  return (result[0] == 1.0) ? 0 : 1;\n+\t}\n+    } [add_options_for_arm_v8_2a_fp16_neon \"\"]]\n+}\n+\n # Return 1 if this is a ARM target with NEON enabled.\n \n proc check_effective_target_arm_neon { } {"}]}