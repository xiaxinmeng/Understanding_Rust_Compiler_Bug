{"sha": "cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZhNDM0ZjZkMmM0ZWMzM2QyOWYyNDdhYWI2YjliOTQyMWI1YTYyZg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T18:36:35Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T18:36:35Z"}, "message": "lra: use rtx_insn\n\ngcc/\n\t* lra-int.h (struct lra_insn_recog_data): Strengthen field \"insn\"\n\tfrom rtx to rtx_insn *.\n\t(lra_push_insn): Likewise for 1st param.\n\t(lra_push_insn_and_update_insn_regno_info): Likewise.\n\t(lra_pop_insn): Likewise for return type.\n\t(lra_invalidate_insn_data): Likewise for 1st param.\n\t(lra_set_insn_deleted): Likewise.\n\t(lra_delete_dead_insn): Likewise.\n\t(lra_process_new_insns): Likewise for first 3 params.\n\t(lra_set_insn_recog_data): Likewise for 1st param.\n\t(lra_update_insn_recog_data): Likewise.\n\t(lra_set_used_insn_alternative): Likewise.\n\t(lra_invalidate_insn_regno_info): Likewise.\n\t(lra_update_insn_regno_info): Likewise.\n\t(lra_former_scratch_operand_p): Likewise.\n\t(lra_eliminate_regs_1): Likewise.\n\t(lra_get_insn_recog_data): Likewise.\n\n\t* lra-assigns.c (assign_by_spills): Strengthen local \"insn\" from\n\trtx to rtx_insn *.\n\n\t* lra-coalesce.c (move_freq_compare_func): Likewise for locals\n\t\"mv1\" and \"mv2\".\n\t(substitute_within_insn): New.\n\t(lra_coalesce): Strengthen locals \"mv\", \"insn\", \"next\" from rtx to\n\trtx_insn *.  Strengthen sorted_moves from rtx * to rxt_insn **.\n\tReplace call to \"substitute\" with call to substitute_within_insn.\n\n\t* lra-constraints.c (curr_insn): Strengthen from rtx to\n\trtx_insn *.\n\t(get_equiv_with_elimination): Likewise for param \"insn\".\n\t(match_reload): Strengthen params \"before\" and \"after\" from rtx *\n\tto rtx_insn **.\n\t(emit_spill_move): Likewise for return type.  Add a checked cast\n\tto rtx_insn * on result of gen_move_insn for now.\n\t(check_and_process_move): Likewise for local \"before\".  Replace\n\tNULL_RTX with NULL when referring to insns.\n\t(process_addr_reg): Strengthen params \"before\" and \"after\" from\n\trtx * to rtx_insn **.\n\t(insert_move_for_subreg): Likewise.\n\t(simplify_operand_subreg): Strengthen locals \"before\" and \"after\"\n\tfrom rtx to rtx_insn *.\n\t(process_address_1): Strengthen params \"before\" and \"after\" from\n\trtx * to rtx_insn **.  Strengthen locals \"insns\", \"last_insn\" from\n\trtx to rtx_insn *.\n\t(process_address): Strengthen params \"before\" and \"after\" from\n\trtx * to rtx_insn **.\n\t(emit_inc): Strengthen local \"last\" from rtx to rtx_insn *.\n\t(curr_insn_transform): Strengthen locals \"before\" and \"after\"\n\tfrom rtx to rtx_insn *.  Replace NULL_RTX with NULL when referring\n\tto insns.\n\t(loc_equivalence_callback): Update cast of \"data\", changing\n\tresulting type from rtx to rtx_insn *.\n\t(substitute_pseudo_within_insn): New.\n\t(inherit_reload_reg): Strengthen param \"insn\" from rtx to\n\trtx_insn *; likewise for local \"new_insns\".  Replace NULL_RTX with\n\tNULL when referring to insns.  Add a checked cast to rtx_insn *\n\twhen using usage_insn to invoke lra_update_insn_regno_info.\n\t(split_reg): Strengthen param \"insn\" from rtx to rtx_insn *;\n\tlikewise for locals \"restore\", \"save\".  Add checked casts to\n\trtx_insn * when using usage_insn to invoke\n\tlra_update_insn_regno_info and lra_process_new_insns.  Replace\n\tNULL_RTX with NULL when referring to insns.\n\t(split_if_necessary): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(update_ebb_live_info): Likewise for params \"head\", \"tail\" and local\n\t\"prev_insn\".\n\t(get_last_insertion_point): Likewise for return type and local \"insn\".\n\t(get_live_on_other_edges): Likewise for local \"last\".\n\t(inherit_in_ebb): Likewise for params \"head\", \"tail\" and locals\n\t\"prev_insn\", \"next_insn\", \"restore\".\n\t(remove_inheritance_pseudos): Likewise for local \"prev_insn\".\n\t(undo_optional_reloads): Likewise for local \"insn\".\n\n\t* lra-eliminations.c (lra_eliminate_regs_1): Likewise for param\n\t\"insn\".\n\t(lra_eliminate_regs): Replace NULL_RTX with NULL when referring to\n\tinsns.\n\t(eliminate_regs_in_insn): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(spill_pseudos): Likewise for local \"insn\".\n\t(init_elimination): Likewise.\n\t(process_insn_for_elimination): Likewise for param \"insn\".\n\n\t* lra-lives.c (curr_insn): Likewise.;\n\n\t* lra-spills.c (assign_spill_hard_regs): Likewise for local \"insn\".\n\t(remove_pseudos): Likewise for param \"insn\".\n\t(spill_pseudos): Likewise for local \"insn\".\n\t(lra_final_code_change): Likewise for locals \"insn\", \"curr\".\n\n\t* lra.c (lra_invalidate_insn_data): Likewise for param \"insn\".\n\t(lra_set_insn_deleted): Likewise.\n\t(lra_delete_dead_insn): Likewise, and for local \"prev\".\n\t(new_insn_reg): Likewise for param \"insn\".\n\t(lra_set_insn_recog_data): Likewise.\n\t(lra_update_insn_recog_data): Likewise.\n\t(lra_set_used_insn_alternative): Likewise.\n\t(get_insn_freq): Likewise.\n\t(invalidate_insn_data_regno_info): Likewise.\n\t(lra_invalidate_insn_regno_info): Likewise.\n\t(lra_update_insn_regno_info): Likewise.\n\t(lra_constraint_insn_stack): Strengthen from vec<rtx> to\n\tvec<rtx_insn *>.\n\t(lra_push_insn_1): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(lra_push_insn): Likewise.\n\t(lra_push_insn_and_update_insn_regno_info): Likewise.\n\t(lra_pop_insn): Likewise for return type and local \"insn\".\n\t(push_insns): Likewise for params \"from\", \"to\", and local \"insn\".\n\t(setup_sp_offset): Likewise for params \"from\", \"last\" and locals\n\t\"before\", \"insn\".\n\t(lra_process_new_insns): Likewise for params \"insn\", \"before\",\n\t\"after\" and local \"last\".\n\t(struct sloc): Likewise for field \"insn\".\n\t(lra_former_scratch_operand_p): Likewise for param \"insn\".\n\t(remove_scratches): Likewise for locals \"insn\", \"last\".\n\t(check_rtl): Likewise for local \"insn\".\n\t(add_auto_inc_notes): Likewise for param \"insn\".\n\t(update_inc_notes): Likewise for local \"insn\".\n\t(lra): Replace NULL_RTX with NULL when referring to insn.\n\nFrom-SVN: r214348", "tree": {"sha": "04f6cbf5b4fcd0a0254eb6bc03edb6b0f5113408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f6cbf5b4fcd0a0254eb6bc03edb6b0f5113408"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e967cc2f9a32c2c43fe80e657b8ae271b53f87d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e967cc2f9a32c2c43fe80e657b8ae271b53f87d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e967cc2f9a32c2c43fe80e657b8ae271b53f87d3"}], "stats": {"total": 406, "additions": 286, "deletions": 120}, "files": [{"sha": "2ce152fe6d0307c6206cb579efa8056aec16f089", "filename": "gcc/ChangeLog", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -1,3 +1,127 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* lra-int.h (struct lra_insn_recog_data): Strengthen field \"insn\"\n+\tfrom rtx to rtx_insn *.\n+\t(lra_push_insn): Likewise for 1st param.\n+\t(lra_push_insn_and_update_insn_regno_info): Likewise.\n+\t(lra_pop_insn): Likewise for return type.\n+\t(lra_invalidate_insn_data): Likewise for 1st param.\n+\t(lra_set_insn_deleted): Likewise.\n+\t(lra_delete_dead_insn): Likewise.\n+\t(lra_process_new_insns): Likewise for first 3 params.\n+\t(lra_set_insn_recog_data): Likewise for 1st param.\n+\t(lra_update_insn_recog_data): Likewise.\n+\t(lra_set_used_insn_alternative): Likewise.\n+\t(lra_invalidate_insn_regno_info): Likewise.\n+\t(lra_update_insn_regno_info): Likewise.\n+\t(lra_former_scratch_operand_p): Likewise.\n+\t(lra_eliminate_regs_1): Likewise.\n+\t(lra_get_insn_recog_data): Likewise.\n+\n+\t* lra-assigns.c (assign_by_spills): Strengthen local \"insn\" from\n+\trtx to rtx_insn *.\n+\n+\t* lra-coalesce.c (move_freq_compare_func): Likewise for locals\n+\t\"mv1\" and \"mv2\".\n+\t(substitute_within_insn): New.\n+\t(lra_coalesce): Strengthen locals \"mv\", \"insn\", \"next\" from rtx to\n+\trtx_insn *.  Strengthen sorted_moves from rtx * to rxt_insn **.\n+\tReplace call to \"substitute\" with call to substitute_within_insn.\n+\n+\t* lra-constraints.c (curr_insn): Strengthen from rtx to\n+\trtx_insn *.\n+\t(get_equiv_with_elimination): Likewise for param \"insn\".\n+\t(match_reload): Strengthen params \"before\" and \"after\" from rtx *\n+\tto rtx_insn **.\n+\t(emit_spill_move): Likewise for return type.  Add a checked cast\n+\tto rtx_insn * on result of gen_move_insn for now.\n+\t(check_and_process_move): Likewise for local \"before\".  Replace\n+\tNULL_RTX with NULL when referring to insns.\n+\t(process_addr_reg): Strengthen params \"before\" and \"after\" from\n+\trtx * to rtx_insn **.\n+\t(insert_move_for_subreg): Likewise.\n+\t(simplify_operand_subreg): Strengthen locals \"before\" and \"after\"\n+\tfrom rtx to rtx_insn *.\n+\t(process_address_1): Strengthen params \"before\" and \"after\" from\n+\trtx * to rtx_insn **.  Strengthen locals \"insns\", \"last_insn\" from\n+\trtx to rtx_insn *.\n+\t(process_address): Strengthen params \"before\" and \"after\" from\n+\trtx * to rtx_insn **.\n+\t(emit_inc): Strengthen local \"last\" from rtx to rtx_insn *.\n+\t(curr_insn_transform): Strengthen locals \"before\" and \"after\"\n+\tfrom rtx to rtx_insn *.  Replace NULL_RTX with NULL when referring\n+\tto insns.\n+\t(loc_equivalence_callback): Update cast of \"data\", changing\n+\tresulting type from rtx to rtx_insn *.\n+\t(substitute_pseudo_within_insn): New.\n+\t(inherit_reload_reg): Strengthen param \"insn\" from rtx to\n+\trtx_insn *; likewise for local \"new_insns\".  Replace NULL_RTX with\n+\tNULL when referring to insns.  Add a checked cast to rtx_insn *\n+\twhen using usage_insn to invoke lra_update_insn_regno_info.\n+\t(split_reg): Strengthen param \"insn\" from rtx to rtx_insn *;\n+\tlikewise for locals \"restore\", \"save\".  Add checked casts to\n+\trtx_insn * when using usage_insn to invoke\n+\tlra_update_insn_regno_info and lra_process_new_insns.  Replace\n+\tNULL_RTX with NULL when referring to insns.\n+\t(split_if_necessary): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(update_ebb_live_info): Likewise for params \"head\", \"tail\" and local\n+\t\"prev_insn\".\n+\t(get_last_insertion_point): Likewise for return type and local \"insn\".\n+\t(get_live_on_other_edges): Likewise for local \"last\".\n+\t(inherit_in_ebb): Likewise for params \"head\", \"tail\" and locals\n+\t\"prev_insn\", \"next_insn\", \"restore\".\n+\t(remove_inheritance_pseudos): Likewise for local \"prev_insn\".\n+\t(undo_optional_reloads): Likewise for local \"insn\".\n+\n+\t* lra-eliminations.c (lra_eliminate_regs_1): Likewise for param\n+\t\"insn\".\n+\t(lra_eliminate_regs): Replace NULL_RTX with NULL when referring to\n+\tinsns.\n+\t(eliminate_regs_in_insn): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(spill_pseudos): Likewise for local \"insn\".\n+\t(init_elimination): Likewise.\n+\t(process_insn_for_elimination): Likewise for param \"insn\".\n+\n+\t* lra-lives.c (curr_insn): Likewise.;\n+\n+\t* lra-spills.c (assign_spill_hard_regs): Likewise for local \"insn\".\n+\t(remove_pseudos): Likewise for param \"insn\".\n+\t(spill_pseudos): Likewise for local \"insn\".\n+\t(lra_final_code_change): Likewise for locals \"insn\", \"curr\".\n+\n+\t* lra.c (lra_invalidate_insn_data): Likewise for param \"insn\".\n+\t(lra_set_insn_deleted): Likewise.\n+\t(lra_delete_dead_insn): Likewise, and for local \"prev\".\n+\t(new_insn_reg): Likewise for param \"insn\".\n+\t(lra_set_insn_recog_data): Likewise.\n+\t(lra_update_insn_recog_data): Likewise.\n+\t(lra_set_used_insn_alternative): Likewise.\n+\t(get_insn_freq): Likewise.\n+\t(invalidate_insn_data_regno_info): Likewise.\n+\t(lra_invalidate_insn_regno_info): Likewise.\n+\t(lra_update_insn_regno_info): Likewise.\n+\t(lra_constraint_insn_stack): Strengthen from vec<rtx> to\n+\tvec<rtx_insn *>.\n+\t(lra_push_insn_1): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(lra_push_insn): Likewise.\n+\t(lra_push_insn_and_update_insn_regno_info): Likewise.\n+\t(lra_pop_insn): Likewise for return type and local \"insn\".\n+\t(push_insns): Likewise for params \"from\", \"to\", and local \"insn\".\n+\t(setup_sp_offset): Likewise for params \"from\", \"last\" and locals\n+\t\"before\", \"insn\".\n+\t(lra_process_new_insns): Likewise for params \"insn\", \"before\",\n+\t\"after\" and local \"last\".\n+\t(struct sloc): Likewise for field \"insn\".\n+\t(lra_former_scratch_operand_p): Likewise for param \"insn\".\n+\t(remove_scratches): Likewise for locals \"insn\", \"last\".\n+\t(check_rtl): Likewise for local \"insn\".\n+\t(add_auto_inc_notes): Likewise for param \"insn\".\n+\t(update_inc_notes): Likewise for local \"insn\".\n+\t(lra): Replace NULL_RTX with NULL when referring to insn.\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* lower-subreg.c (simple_move): Strengthen param \"insn\" from rtx"}, {"sha": "88e0b1d2e49d43abb189045b5f6b936b59492434", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -1221,7 +1221,7 @@ static void\n assign_by_spills (void)\n {\n   int i, n, nfails, iter, regno, hard_regno, cost, restore_regno;\n-  rtx insn;\n+  rtx_insn *insn;\n   bitmap_head changed_insns, do_not_assign_nonreload_pseudos;\n   unsigned int u, conflict_regno;\n   bitmap_iterator bi;"}, {"sha": "70e74f384c67b2eaab8a5bd80b1dfb5b7f8a7eae", "filename": "gcc/lra-coalesce.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-coalesce.c?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -75,8 +75,8 @@ static int *first_coalesced_pseudo, *next_coalesced_pseudo;\n static int\n move_freq_compare_func (const void *v1p, const void *v2p)\n {\n-  rtx mv1 = *(const rtx *) v1p;\n-  rtx mv2 = *(const rtx *) v2p;\n+  rtx_insn *mv1 = *(rtx_insn * const *) v1p;\n+  rtx_insn *mv2 = *(rtx_insn * const *) v2p;\n   int pri1, pri2;\n \n   pri1 = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (mv1));\n@@ -168,6 +168,16 @@ substitute (rtx *loc)\n   return res;\n }\n \n+/* Specialize \"substitute\" for use on an insn.  This can't change\n+   the insn ptr, just the contents of the insn.  */\n+\n+static bool\n+substitute_within_insn (rtx_insn *insn)\n+{\n+  rtx loc = insn;\n+  return substitute (&loc);\n+}\n+\n /* The current iteration (1, 2, ...) of the coalescing pass.  */\n int lra_coalesce_iter;\n \n@@ -219,7 +229,8 @@ bool\n lra_coalesce (void)\n {\n   basic_block bb;\n-  rtx mv, set, insn, next, *sorted_moves;\n+  rtx_insn *mv, *insn, *next, **sorted_moves;\n+  rtx set;\n   int i, mv_num, sregno, dregno;\n   unsigned int regno;\n   int coalesced_moves;\n@@ -238,7 +249,7 @@ lra_coalesce (void)\n   next_coalesced_pseudo = XNEWVEC (int, max_regno);\n   for (i = 0; i < max_regno; i++)\n     first_coalesced_pseudo[i] = next_coalesced_pseudo[i] = i;\n-  sorted_moves = XNEWVEC (rtx, get_max_uid ());\n+  sorted_moves = XNEWVEC (rtx_insn *, get_max_uid ());\n   mv_num = 0;\n   /* Collect moves.  */\n   coalesced_moves = 0;\n@@ -308,7 +319,7 @@ lra_coalesce (void)\n \tif (INSN_P (insn)\n \t    && bitmap_bit_p (&involved_insns_bitmap, INSN_UID (insn)))\n \t  {\n-\t    if (! substitute (&insn))\n+\t    if (! substitute_within_insn (insn))\n \t      continue;\n \t    lra_update_insn_regno_info (insn);\n \t    if ((set = single_set (insn)) != NULL_RTX && set_noop_p (set))"}, {"sha": "6e6f04bf07d3f186e1518f7a7ae891fd5b63c233", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 76, "deletions": 52, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -138,7 +138,7 @@ static int bb_reload_num;\n /* The current insn being processed and corresponding its single set\n    (NULL otherwise), its data (basic block, the insn data, the insn\n    static data, and the mode of each operand).  */\n-static rtx curr_insn;\n+static rtx_insn *curr_insn;\n static rtx curr_insn_set;\n static basic_block curr_bb;\n static lra_insn_recog_data_t curr_id;\n@@ -491,7 +491,7 @@ get_equiv (rtx x)\n    return that value after elimination for INSN, otherwise return\n    X.  */\n static rtx\n-get_equiv_with_elimination (rtx x, rtx insn)\n+get_equiv_with_elimination (rtx x, rtx_insn *insn)\n {\n   rtx res = get_equiv (x);\n \n@@ -834,7 +834,7 @@ narrow_reload_pseudo_class (rtx reg, enum reg_class cl)\n    matched input operands INS.  */\n static void\n match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n-\t      rtx *before, rtx *after)\n+\t      rtx_insn **before, rtx_insn **after)\n {\n   int i, in;\n   rtx new_in_reg, new_out_reg, reg, clobber;\n@@ -1003,7 +1003,7 @@ get_op_class (rtx op)\n /* Return generated insn mem_pseudo:=val if TO_P or val:=mem_pseudo\n    otherwise.  If modes of MEM_PSEUDO and VAL are different, use\n    SUBREG for VAL to make them equal.  */\n-static rtx\n+static rtx_insn *\n emit_spill_move (bool to_p, rtx mem_pseudo, rtx val)\n {\n   if (GET_MODE (mem_pseudo) != GET_MODE (val))\n@@ -1024,9 +1024,9 @@ emit_spill_move (bool to_p, rtx mem_pseudo, rtx val)\n \t  LRA_SUBREG_P (mem_pseudo) = 1;\n \t}\n     }\n-  return (to_p\n-\t  ? gen_move_insn (mem_pseudo, val)\n-\t  : gen_move_insn (val, mem_pseudo));\n+  return as_a <rtx_insn *> (to_p\n+\t\t\t    ? gen_move_insn (mem_pseudo, val)\n+\t\t\t    : gen_move_insn (val, mem_pseudo));\n }\n \n /* Process a special case insn (register move), return true if we\n@@ -1038,7 +1038,8 @@ static bool\n check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n {\n   int sregno, dregno;\n-  rtx dest, src, dreg, sreg, old_sreg, new_reg, before, scratch_reg;\n+  rtx dest, src, dreg, sreg, old_sreg, new_reg, scratch_reg;\n+  rtx_insn *before;\n   enum reg_class dclass, sclass, secondary_class;\n   enum machine_mode sreg_mode;\n   secondary_reload_info sri;\n@@ -1164,7 +1165,7 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n     }\n   before = get_insns ();\n   end_sequence ();\n-  lra_process_new_insns (curr_insn, before, NULL_RTX, \"Inserting the move\");\n+  lra_process_new_insns (curr_insn, before, NULL, \"Inserting the move\");\n   if (new_reg != NULL_RTX)\n     {\n       if (GET_CODE (src) == SUBREG)\n@@ -1238,7 +1239,8 @@ static int curr_swapped;\n    automodified value; handle that case by adding the required output\n    reloads to list AFTER.  Return true if the RTL was changed.  */\n static bool\n-process_addr_reg (rtx *loc, rtx *before, rtx *after, enum reg_class cl)\n+process_addr_reg (rtx *loc, rtx_insn **before, rtx_insn **after,\n+\t\t  enum reg_class cl)\n {\n   int regno;\n   enum reg_class rclass, new_class;\n@@ -1314,7 +1316,8 @@ process_addr_reg (rtx *loc, rtx *before, rtx *after, enum reg_class cl)\n    the insn to be inserted after curr insn.  ORIGREG and NEWREG\n    are the original reg and new reg for reload.  */\n static void\n-insert_move_for_subreg (rtx *before, rtx *after, rtx origreg, rtx newreg)\n+insert_move_for_subreg (rtx_insn **before, rtx_insn **after, rtx origreg,\n+\t\t\trtx newreg)\n {\n   if (before)\n     {\n@@ -1342,14 +1345,14 @@ static bool\n simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n {\n   int hard_regno;\n-  rtx before, after;\n+  rtx_insn *before, *after;\n   enum machine_mode mode;\n   rtx reg, new_reg;\n   rtx operand = *curr_id->operand_loc[nop];\n   enum reg_class regclass;\n   enum op_type type;\n \n-  before = after = NULL_RTX;\n+  before = after = NULL;\n \n   if (GET_CODE (operand) != SUBREG)\n     return false;\n@@ -2753,7 +2756,7 @@ equiv_address_substitution (struct address_info *ad)\n    To do all necessary transformations use function\n    process_address.  */\n static bool\n-process_address_1 (int nop, rtx *before, rtx *after)\n+process_address_1 (int nop, rtx_insn **before, rtx_insn **after)\n {\n   struct address_info ad;\n   rtx new_reg;\n@@ -2890,7 +2893,8 @@ process_address_1 (int nop, rtx *before, rtx *after)\n     {\n       int regno;\n       enum reg_class cl;\n-      rtx set, insns, last_insn;\n+      rtx set;\n+      rtx_insn *insns, *last_insn;\n       /* Try to reload base into register only if the base is invalid\n          for the address but with valid offset, case (4) above.  */\n       start_sequence ();\n@@ -2967,7 +2971,7 @@ process_address_1 (int nop, rtx *before, rtx *after)\n /* Do address reloads until it is necessary.  Use process_address_1 as\n    a helper function.  Return true for any RTL changes.  */\n static bool\n-process_address (int nop, rtx *before, rtx *after)\n+process_address (int nop, rtx_insn **before, rtx_insn **after)\n {\n   bool res = false;\n \n@@ -2994,7 +2998,7 @@ emit_inc (enum reg_class new_rclass, rtx in, rtx value, int inc_amount)\n   /* Nonzero if increment after copying.  */\n   int post = (GET_CODE (value) == POST_DEC || GET_CODE (value) == POST_INC\n \t      || GET_CODE (value) == POST_MODIFY);\n-  rtx last;\n+  rtx_insn *last;\n   rtx inc;\n   rtx add_insn;\n   int code;\n@@ -3154,7 +3158,7 @@ curr_insn_transform (void)\n   int commutative;\n   signed char goal_alt_matched[MAX_RECOG_OPERANDS][MAX_RECOG_OPERANDS];\n   signed char match_inputs[MAX_RECOG_OPERANDS + 1];\n-  rtx before, after;\n+  rtx_insn *before, *after;\n   bool alt_p = false;\n   /* Flag that the insn has been changed through a transformation.  */\n   bool change_p;\n@@ -3252,7 +3256,7 @@ curr_insn_transform (void)\n \n   /* Reload address registers and displacements.  We do it before\n      finding an alternative because of memory constraints.  */\n-  before = after = NULL_RTX;\n+  before = after = NULL;\n   for (i = 0; i < n_operands; i++)\n     if (! curr_static_id->operand[i].is_operator\n \t&& process_address (i, &before, &after))\n@@ -3371,7 +3375,7 @@ curr_insn_transform (void)\n \t     secondary memory moves we can not reuse the original\n \t     insn.  */\n \t  after = emit_spill_move (false, new_reg, dest);\n-\t  lra_process_new_insns (curr_insn, NULL_RTX, after,\n+\t  lra_process_new_insns (curr_insn, NULL, after,\n \t\t\t\t \"Inserting the sec. move\");\n \t  /* We may have non null BEFORE here (e.g. after address\n \t     processing.  */\n@@ -3380,14 +3384,14 @@ curr_insn_transform (void)\n \t  emit_insn (before);\n \t  before = get_insns ();\n \t  end_sequence ();\n-\t  lra_process_new_insns (curr_insn, before, NULL_RTX, \"Changing on\");\n+\t  lra_process_new_insns (curr_insn, before, NULL, \"Changing on\");\n \t  lra_set_insn_deleted (curr_insn);\n \t}\n       else if (dest == rld)\n         {\n \t  *curr_id->operand_loc[0] = new_reg;\n \t  after = emit_spill_move (false, new_reg, dest);\n-\t  lra_process_new_insns (curr_insn, NULL_RTX, after,\n+\t  lra_process_new_insns (curr_insn, NULL, after,\n \t\t\t\t \"Inserting the sec. move\");\n \t}\n       else\n@@ -3399,7 +3403,7 @@ curr_insn_transform (void)\n \t  emit_insn (before);\n \t  before = get_insns ();\n \t  end_sequence ();\n-\t  lra_process_new_insns (curr_insn, before, NULL_RTX,\n+\t  lra_process_new_insns (curr_insn, before, NULL,\n \t\t\t\t \"Inserting the sec. move\");\n \t}\n       lra_update_insn_regno_info (curr_insn);\n@@ -3848,7 +3852,7 @@ loc_equivalence_callback (rtx loc, const_rtx, void *data)\n     return NULL_RTX;\n \n   rtx subst = (data == NULL\n-\t       ? get_equiv (loc) : get_equiv_with_elimination (loc, (rtx) data));\n+\t       ? get_equiv (loc) : get_equiv_with_elimination (loc, (rtx_insn *) data));\n   if (subst != loc)\n     return subst;\n \n@@ -4376,6 +4380,16 @@ substitute_pseudo (rtx *loc, int old_regno, rtx new_reg)\n   return result;\n }\n \n+/* Call substitute_pseudo within an insn.  This won't update the insn ptr,\n+   just the contents of the insn.  */\n+\n+static bool\n+substitute_pseudo_within_insn (rtx_insn *insn, int old_regno, rtx new_reg)\n+{\n+  rtx loc = insn;\n+  return substitute_pseudo (&loc, old_regno, new_reg);\n+}\n+\n /* Return first non-debug insn in list USAGE_INSNS.  */\n static rtx\n skip_usage_debug_insns (rtx usage_insns)\n@@ -4447,14 +4461,15 @@ static bitmap_head check_only_regs;\n    class of ORIGINAL REGNO.  */\n static bool\n inherit_reload_reg (bool def_p, int original_regno,\n-\t\t    enum reg_class cl, rtx insn, rtx next_usage_insns)\n+\t\t    enum reg_class cl, rtx_insn *insn, rtx next_usage_insns)\n {\n   if (optimize_function_for_size_p (cfun))\n     return false;\n \n   enum reg_class rclass = lra_get_allocno_class (original_regno);\n   rtx original_reg = regno_reg_rtx[original_regno];\n-  rtx new_reg, new_insns, usage_insn;\n+  rtx new_reg, usage_insn;\n+  rtx_insn *new_insns;\n \n   lra_assert (! usage_insns[original_regno].after_p);\n   if (lra_dump_file != NULL)\n@@ -4535,7 +4550,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t}\n       return false;\n     }\n-  substitute_pseudo (&insn, original_regno, new_reg);\n+  substitute_pseudo_within_insn (insn, original_regno, new_reg);\n   lra_update_insn_regno_info (insn);\n   if (! def_p)\n     /* We now have a new usage insn for original regno.  */\n@@ -4548,10 +4563,10 @@ inherit_reload_reg (bool def_p, int original_regno,\n   bitmap_set_bit (&check_only_regs, original_regno);\n   bitmap_set_bit (&lra_inheritance_pseudos, REGNO (new_reg));\n   if (def_p)\n-    lra_process_new_insns (insn, NULL_RTX, new_insns,\n+    lra_process_new_insns (insn, NULL, new_insns,\n \t\t\t   \"Add original<-inheritance\");\n   else\n-    lra_process_new_insns (insn, new_insns, NULL_RTX,\n+    lra_process_new_insns (insn, new_insns, NULL,\n \t\t\t   \"Add inheritance<-original\");\n   while (next_usage_insns != NULL_RTX)\n     {\n@@ -4568,7 +4583,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t  next_usage_insns = XEXP (next_usage_insns, 1);\n \t}\n       substitute_pseudo (&usage_insn, original_regno, new_reg);\n-      lra_update_insn_regno_info (usage_insn);\n+      lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));\n       if (lra_dump_file != NULL)\n \t{\n \t  fprintf (lra_dump_file,\n@@ -4719,12 +4734,14 @@ choose_split_class (enum reg_class allocno_class,\n    if BEFORE_P is true.\t Return true if we succeed in such\n    transformation.  */\n static bool\n-split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n+split_reg (bool before_p, int original_regno, rtx_insn *insn,\n+\t   rtx next_usage_insns)\n {\n   enum reg_class rclass;\n   rtx original_reg;\n   int hard_regno, nregs;\n-  rtx new_reg, save, restore, usage_insn;\n+  rtx new_reg, usage_insn;\n+  rtx_insn *restore, *save;\n   bool after_p;\n   bool call_save_p;\n \n@@ -4830,7 +4847,7 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n       lra_assert (DEBUG_INSN_P (usage_insn));\n       next_usage_insns = XEXP (next_usage_insns, 1);\n       substitute_pseudo (&usage_insn, original_regno, new_reg);\n-      lra_update_insn_regno_info (usage_insn);\n+      lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));\n       if (lra_dump_file != NULL)\n \t{\n \t  fprintf (lra_dump_file, \"    Split reuse change %d->%d:\\n\",\n@@ -4840,12 +4857,13 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n     }\n   lra_assert (NOTE_P (usage_insn) || NONDEBUG_INSN_P (usage_insn));\n   lra_assert (usage_insn != insn || (after_p && before_p));\n-  lra_process_new_insns (usage_insn, after_p ? NULL_RTX : restore,\n-\t\t\t after_p ? restore : NULL_RTX,\n+  lra_process_new_insns (as_a <rtx_insn *> (usage_insn),\n+\t\t\t after_p ? NULL : restore,\n+\t\t\t after_p ? restore : NULL,\n \t\t\t call_save_p\n \t\t\t ?  \"Add reg<-save\" : \"Add reg<-split\");\n-  lra_process_new_insns (insn, before_p ? save : NULL_RTX,\n-\t\t\t before_p ? NULL_RTX : save,\n+  lra_process_new_insns (insn, before_p ? save : NULL,\n+\t\t\t before_p ? NULL : save,\n \t\t\t call_save_p\n \t\t\t ?  \"Add save<-reg\" : \"Add split<-reg\");\n   if (nregs > 1)\n@@ -4871,7 +4889,7 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n static bool\n split_if_necessary (int regno, enum machine_mode mode,\n \t\t    HARD_REG_SET potential_reload_hard_regs,\n-\t\t    bool before_p, rtx insn, int max_uid)\n+\t\t    bool before_p, rtx_insn *insn, int max_uid)\n {\n   bool res = false;\n   int i, nregs = 1;\n@@ -4901,12 +4919,13 @@ static bitmap_head live_regs;\n    inheritance/split transformation.  The function removes dead moves\n    too.\t */\n static void\n-update_ebb_live_info (rtx head, rtx tail)\n+update_ebb_live_info (rtx_insn *head, rtx_insn *tail)\n {\n   unsigned int j;\n   int i, regno;\n   bool live_p;\n-  rtx prev_insn, set;\n+  rtx_insn *prev_insn;\n+  rtx set;\n   bool remove_p;\n   basic_block last_bb, prev_bb, curr_bb;\n   bitmap_iterator bi;\n@@ -5041,10 +5060,10 @@ add_to_inherit (int regno, rtx insns)\n \n /* Return the last non-debug insn in basic block BB, or the block begin\n    note if none.  */\n-static rtx\n+static rtx_insn *\n get_last_insertion_point (basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (NONDEBUG_INSN_P (insn) || NOTE_INSN_BASIC_BLOCK_P (insn))\n@@ -5057,7 +5076,7 @@ get_last_insertion_point (basic_block bb)\n static void\n get_live_on_other_edges (basic_block from, basic_block to, bitmap res)\n {\n-  rtx last;\n+  rtx_insn *last;\n   struct lra_insn_reg *reg;\n   edge e;\n   edge_iterator ei;\n@@ -5101,11 +5120,12 @@ static const int max_small_class_regs_num = 2;\n    splitting even more but it is to expensive and the current approach\n    works well enough.  */\n static bool\n-inherit_in_ebb (rtx head, rtx tail)\n+inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n {\n   int i, src_regno, dst_regno, nregs;\n   bool change_p, succ_p, update_reloads_num_p;\n-  rtx prev_insn, next_usage_insns, set, last_insn;\n+  rtx_insn *prev_insn, *last_insn;\n+  rtx next_usage_insns, set;\n   enum reg_class cl;\n   struct lra_insn_reg *reg;\n   basic_block last_processed_bb, curr_bb = NULL;\n@@ -5305,7 +5325,8 @@ inherit_in_ebb (rtx head, rtx tail)\n \t      change_p = true;\n \t  if (CALL_P (curr_insn))\n \t    {\n-\t      rtx cheap, pat, dest, restore;\n+\t      rtx cheap, pat, dest;\n+\t      rtx_insn *restore;\n \t      int regno, hard_regno;\n \n \t      calls_num++;\n@@ -5604,7 +5625,8 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n {\n   basic_block bb;\n   int regno, sregno, prev_sregno, dregno, restore_regno;\n-  rtx set, prev_set, prev_insn;\n+  rtx set, prev_set;\n+  rtx_insn *prev_insn;\n   bool change_p, done_p;\n \n   change_p = ! bitmap_empty_p (remove_pseudos);\n@@ -5738,8 +5760,8 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t\t    {\n \t\t      if (change_p && bitmap_bit_p (remove_pseudos, regno))\n \t\t\t{\n-\t\t\t  substitute_pseudo (&curr_insn, regno,\n-\t\t\t\t\t     regno_reg_rtx[restore_regno]);\n+\t\t\t  substitute_pseudo_within_insn (\n+\t\t\t    curr_insn, regno, regno_reg_rtx[restore_regno]);\n \t\t\t  restored_regs_p = true;\n \t\t\t}\n \t\t      else\n@@ -5780,7 +5802,8 @@ undo_optional_reloads (void)\n   bool change_p, keep_p;\n   unsigned int regno, uid;\n   bitmap_iterator bi, bi2;\n-  rtx insn, set, src, dest;\n+  rtx_insn *insn;\n+  rtx set, src, dest;\n   bitmap_head removed_optional_reload_pseudos, insn_bitmap;\n \n   bitmap_initialize (&removed_optional_reload_pseudos, &reg_obstack);\n@@ -5861,8 +5884,9 @@ undo_optional_reloads (void)\n \t\t we remove the inheritance pseudo and the optional\n \t\t reload.  */\n \t    }\n-\t  substitute_pseudo (&insn, regno,\n-\t\t\t     regno_reg_rtx[lra_reg_info[regno].restore_regno]);\n+\t  substitute_pseudo_within_insn (\n+\t    insn, regno,\n+\t    regno_reg_rtx[lra_reg_info[regno].restore_regno]);\n \t  lra_update_insn_regno_info (insn);\n \t  if (lra_dump_file != NULL)\n \t    {"}, {"sha": "2113a88270041cadc218c861885b334289567a69", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -302,7 +302,7 @@ get_elimination (rtx reg)\n    If we make full substitution to SP for non-null INSN, add the insn\n    sp offset.  */\n rtx\n-lra_eliminate_regs_1 (rtx insn, rtx x, enum machine_mode mem_mode,\n+lra_eliminate_regs_1 (rtx_insn *insn, rtx x, enum machine_mode mem_mode,\n \t\t      bool subst_p, bool update_p, bool full_p)\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -657,7 +657,7 @@ rtx\n lra_eliminate_regs (rtx x, enum machine_mode mem_mode,\n \t\t    rtx insn ATTRIBUTE_UNUSED)\n {\n-  return lra_eliminate_regs_1 (NULL_RTX, x, mem_mode, true, false, true);\n+  return lra_eliminate_regs_1 (NULL, x, mem_mode, true, false, true);\n }\n \n /* Stack pointer offset before the current insn relative to one at the\n@@ -848,7 +848,7 @@ remove_reg_equal_offset_note (rtx insn, rtx what)\n    previously used) in future.  */\n \n static void\n-eliminate_regs_in_insn (rtx insn, bool replace_p, bool first_p)\n+eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p)\n {\n   int icode = recog_memoized (insn);\n   rtx old_set = single_set (insn);\n@@ -1086,7 +1086,7 @@ spill_pseudos (HARD_REG_SET set)\n {\n   int i;\n   bitmap_head to_process;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (hard_reg_set_empty_p (set))\n     return;\n@@ -1290,7 +1290,7 @@ init_elimination (void)\n {\n   bool stop_to_sp_elimination_p;\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   struct elim_table *ep;\n \n   init_elim_table ();\n@@ -1339,7 +1339,7 @@ lra_eliminate_reg_if_possible (rtx *loc)\n    the insn for subsequent processing in the constraint pass, update\n    the insn info.  */\n static void\n-process_insn_for_elimination (rtx insn, bool final_p, bool first_p)\n+process_insn_for_elimination (rtx_insn *insn, bool final_p, bool first_p)\n {\n   eliminate_regs_in_insn (insn, final_p, first_p);\n   if (! final_p)"}, {"sha": "5afc68c6f11fb123a6525d64982f5f25922d6978", "filename": "gcc/lra-int.h", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -218,7 +218,7 @@ struct lra_insn_recog_data\n   /* SP offset before the insn relative to one at the func start.  */\n   HOST_WIDE_INT sp_offset;\n   /* The insn itself.  */\n-  rtx insn;\n+  rtx_insn *insn;\n   /* Common data for insns with the same ICODE.  Asm insns (their\n      ICODE is negative) do not share such structures.  */\n   struct lra_static_insn_data *insn_static_data;\n@@ -280,38 +280,39 @@ extern lra_insn_recog_data_t *lra_insn_recog_data;\n \n extern int lra_curr_reload_num;\n \n-extern void lra_push_insn (rtx);\n+extern void lra_push_insn (rtx_insn *);\n extern void lra_push_insn_by_uid (unsigned int);\n-extern void lra_push_insn_and_update_insn_regno_info (rtx);\n-extern rtx lra_pop_insn (void);\n+extern void lra_push_insn_and_update_insn_regno_info (rtx_insn *);\n+extern rtx_insn *lra_pop_insn (void);\n extern unsigned int lra_insn_stack_length (void);\n \n extern rtx lra_create_new_reg_with_unique_value (enum machine_mode, rtx,\n \t\t\t\t\t\t enum reg_class, const char *);\n extern void lra_set_regno_unique_value (int);\n-extern void lra_invalidate_insn_data (rtx);\n-extern void lra_set_insn_deleted (rtx);\n-extern void lra_delete_dead_insn (rtx);\n+extern void lra_invalidate_insn_data (rtx_insn *);\n+extern void lra_set_insn_deleted (rtx_insn *);\n+extern void lra_delete_dead_insn (rtx_insn *);\n extern void lra_emit_add (rtx, rtx, rtx);\n extern void lra_emit_move (rtx, rtx);\n extern void lra_update_dups (lra_insn_recog_data_t, signed char *);\n \n-extern void lra_process_new_insns (rtx, rtx, rtx, const char *);\n+extern void lra_process_new_insns (rtx_insn *, rtx_insn *, rtx_insn *,\n+\t\t\t\t   const char *);\n \n-extern lra_insn_recog_data_t lra_set_insn_recog_data (rtx);\n-extern lra_insn_recog_data_t lra_update_insn_recog_data (rtx);\n-extern void lra_set_used_insn_alternative (rtx, int);\n+extern lra_insn_recog_data_t lra_set_insn_recog_data (rtx_insn *);\n+extern lra_insn_recog_data_t lra_update_insn_recog_data (rtx_insn *);\n+extern void lra_set_used_insn_alternative (rtx_insn *, int);\n extern void lra_set_used_insn_alternative_by_uid (int, int);\n \n-extern void lra_invalidate_insn_regno_info (rtx);\n-extern void lra_update_insn_regno_info (rtx);\n+extern void lra_invalidate_insn_regno_info (rtx_insn *);\n+extern void lra_update_insn_regno_info (rtx_insn *);\n extern struct lra_insn_reg *lra_get_insn_regs (int);\n \n extern void lra_free_copies (void);\n extern void lra_create_copy (int, int, int);\n extern lra_copy_t lra_get_copy (int);\n extern bool lra_former_scratch_p (int);\n-extern bool lra_former_scratch_operand_p (rtx, int);\n+extern bool lra_former_scratch_operand_p (rtx_insn *, int);\n \n extern int lra_new_regno_start;\n extern int lra_constraint_new_regno_start;\n@@ -384,7 +385,8 @@ extern void lra_final_code_change (void);\n \n extern void lra_debug_elim_table (void);\n extern int lra_get_elimination_hard_regno (int);\n-extern rtx lra_eliminate_regs_1 (rtx, rtx, enum machine_mode, bool, bool, bool);\n+extern rtx lra_eliminate_regs_1 (rtx_insn *, rtx, enum machine_mode, bool,\n+\t\t\t\t bool, bool);\n extern void lra_eliminate (bool, bool);\n \n extern void lra_eliminate_reg_if_possible (rtx *);\n@@ -450,7 +452,7 @@ lra_update_operator_dups (lra_insn_recog_data_t id)\n \n /* Return info about INSN.  Set up the info if it is not done yet.  */\n static inline lra_insn_recog_data_t\n-lra_get_insn_recog_data (rtx insn)\n+lra_get_insn_recog_data (rtx_insn *insn)\n {\n   lra_insn_recog_data_t data;\n   unsigned int uid = INSN_UID (insn);"}, {"sha": "f34517d502fe860c85e28dba7a75ceea51718aec", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -358,7 +358,7 @@ mark_regno_dead (int regno, enum machine_mode mode, int point)\n }\n \n /* Insn currently scanned.  */\n-static rtx curr_insn;\n+static rtx_insn *curr_insn;\n /* The insn data.  */\n static lra_insn_recog_data_t curr_id;\n /* The insn static data.  */"}, {"sha": "a6fb65bf75fe9353c628f60ddbc679f311e2cad5", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -256,7 +256,8 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n   enum reg_class rclass, spill_class;\n   enum machine_mode mode;\n   lra_live_range_t r;\n-  rtx insn, set;\n+  rtx_insn *insn;\n+  rtx set;\n   basic_block bb;\n   HARD_REG_SET conflict_hard_regs;\n   bitmap_head ok_insn_bitmap;\n@@ -411,7 +412,7 @@ assign_stack_slot_num_and_sort_pseudos (int *pseudo_regnos, int n)\n    corresponding memory or spilled hard reg.  Ignore spilled pseudos\n    created from the scratches.\t*/\n static void\n-remove_pseudos (rtx *loc, rtx insn)\n+remove_pseudos (rtx *loc, rtx_insn *insn)\n {\n   int i;\n   rtx hard_reg;\n@@ -463,7 +464,7 @@ static void\n spill_pseudos (void)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   int i;\n   bitmap_head spilled_pseudos, changed_insns;\n \n@@ -679,7 +680,7 @@ lra_final_code_change (void)\n {\n   int i, hard_regno;\n   basic_block bb;\n-  rtx insn, curr;\n+  rtx_insn *insn, *curr;\n   int max_regno = max_reg_num ();\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)"}, {"sha": "b8b09689f1908b58c0b119000e9e4a9f5472910b", "filename": "gcc/lra.c", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=cfa434f6d2c4ec33d29f247aab6b9b9421b5a62f", "patch": "@@ -125,8 +125,9 @@ HARD_REG_SET lra_no_alloc_regs;\n static int get_new_reg_value (void);\n static void expand_reg_info (void);\n static void invalidate_insn_recog_data (int);\n-static int get_insn_freq (rtx);\n-static void invalidate_insn_data_regno_info (lra_insn_recog_data_t, rtx, int);\n+static int get_insn_freq (rtx_insn *);\n+static void invalidate_insn_data_regno_info (lra_insn_recog_data_t,\n+\t\t\t\t\t     rtx_insn *, int);\n \n /* Expand all regno related info needed for LRA.  */\n static void\n@@ -210,7 +211,7 @@ lra_set_regno_unique_value (int regno)\n /* Invalidate INSN related info used by LRA.  The info should never be\n    used after that.  */\n void\n-lra_invalidate_insn_data (rtx insn)\n+lra_invalidate_insn_data (rtx_insn *insn)\n {\n   lra_invalidate_insn_regno_info (insn);\n   invalidate_insn_recog_data (INSN_UID (insn));\n@@ -219,7 +220,7 @@ lra_invalidate_insn_data (rtx insn)\n /* Mark INSN deleted and invalidate the insn related info used by\n    LRA.\t */\n void\n-lra_set_insn_deleted (rtx insn)\n+lra_set_insn_deleted (rtx_insn *insn)\n {\n   lra_invalidate_insn_data (insn);\n   SET_INSN_DELETED (insn);\n@@ -228,9 +229,9 @@ lra_set_insn_deleted (rtx insn)\n /* Delete an unneeded INSN and any previous insns who sole purpose is\n    loading data that is dead in INSN.  */\n void\n-lra_delete_dead_insn (rtx insn)\n+lra_delete_dead_insn (rtx_insn *insn)\n {\n-  rtx prev = prev_real_insn (insn);\n+  rtx_insn *prev = prev_real_insn (insn);\n   rtx prev_dest;\n \n   /* If the previous insn sets a register that dies in our insn,\n@@ -503,7 +504,8 @@ init_insn_regs (void)\n    in the insn (EARLY_CLOBBER), and reference to the next insn reg\n    info (NEXT).\t */\n static struct lra_insn_reg *\n-new_insn_reg (rtx insn, int regno, enum op_type type, enum machine_mode mode,\n+new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n+\t      enum machine_mode mode,\n \t      bool subreg_p, bool early_clobber, struct lra_insn_reg *next)\n {\n   struct lra_insn_reg *ir;\n@@ -886,7 +888,7 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n /* Set up and return info about INSN.  Set up the info if it is not set up\n    yet.\t */\n lra_insn_recog_data_t\n-lra_set_insn_recog_data (rtx insn)\n+lra_set_insn_recog_data (rtx_insn *insn)\n {\n   lra_insn_recog_data_t data;\n   int i, n, icode;\n@@ -1123,7 +1125,7 @@ invalidate_insn_recog_data (int uid)\n /* Update all the insn info about INSN.\t It is usually called when\n    something in the insn was changed.  Return the updated info.\t */\n lra_insn_recog_data_t\n-lra_update_insn_recog_data (rtx insn)\n+lra_update_insn_recog_data (rtx_insn *insn)\n {\n   lra_insn_recog_data_t data;\n   int n;\n@@ -1227,7 +1229,7 @@ lra_update_insn_recog_data (rtx insn)\n \n /* Set up that INSN is using alternative ALT now.  */\n void\n-lra_set_used_insn_alternative (rtx insn, int alt)\n+lra_set_used_insn_alternative (rtx_insn *insn, int alt)\n {\n   lra_insn_recog_data_t data;\n \n@@ -1521,7 +1523,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n \n /* Return execution frequency of INSN.\t*/\n static int\n-get_insn_freq (rtx insn)\n+get_insn_freq (rtx_insn *insn)\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n@@ -1532,7 +1534,7 @@ get_insn_freq (rtx insn)\n /* Invalidate all reg info of INSN with DATA and execution frequency\n    FREQ.  Update common info about the invalidated registers.  */\n static void\n-invalidate_insn_data_regno_info (lra_insn_recog_data_t data, rtx insn,\n+invalidate_insn_data_regno_info (lra_insn_recog_data_t data, rtx_insn *insn,\n \t\t\t\t int freq)\n {\n   int uid;\n@@ -1561,7 +1563,7 @@ invalidate_insn_data_regno_info (lra_insn_recog_data_t data, rtx insn,\n /* Invalidate all reg info of INSN.  Update common info about the\n    invalidated registers.  */\n void\n-lra_invalidate_insn_regno_info (rtx insn)\n+lra_invalidate_insn_regno_info (rtx_insn *insn)\n {\n   invalidate_insn_data_regno_info (lra_get_insn_recog_data (insn), insn,\n \t\t\t\t   get_insn_freq (insn));\n@@ -1586,7 +1588,7 @@ setup_insn_reg_info (lra_insn_recog_data_t data, int freq)\n /* Set up insn reg info of INSN.  Update common reg info from reg info\n    of INSN.  */\n void\n-lra_update_insn_regno_info (rtx insn)\n+lra_update_insn_regno_info (rtx_insn *insn)\n {\n   int i, uid, freq;\n   lra_insn_recog_data_t data;\n@@ -1630,13 +1632,13 @@ lra_get_insn_regs (int uid)\n static sbitmap lra_constraint_insn_stack_bitmap;\n \n /* The stack itself.  */\n-vec<rtx> lra_constraint_insn_stack;\n+vec<rtx_insn *> lra_constraint_insn_stack;\n \n /* Put INSN on the stack.  If ALWAYS_UPDATE is true, always update the reg\n    info for INSN, otherwise only update it if INSN is not already on the\n    stack.  */\n static inline void\n-lra_push_insn_1 (rtx insn, bool always_update)\n+lra_push_insn_1 (rtx_insn *insn, bool always_update)\n {\n   unsigned int uid = INSN_UID (insn);\n   if (always_update)\n@@ -1654,14 +1656,14 @@ lra_push_insn_1 (rtx insn, bool always_update)\n \n /* Put INSN on the stack.  */\n void\n-lra_push_insn (rtx insn)\n+lra_push_insn (rtx_insn *insn)\n {\n   lra_push_insn_1 (insn, false);\n }\n \n /* Put INSN on the stack and update its reg info.  */\n void\n-lra_push_insn_and_update_insn_regno_info (rtx insn)\n+lra_push_insn_and_update_insn_regno_info (rtx_insn *insn)\n {\n   lra_push_insn_1 (insn, true);\n }\n@@ -1674,10 +1676,10 @@ lra_push_insn_by_uid (unsigned int uid)\n }\n \n /* Take the last-inserted insns off the stack and return it.  */\n-rtx\n+rtx_insn *\n lra_pop_insn (void)\n {\n-  rtx insn = lra_constraint_insn_stack.pop ();\n+  rtx_insn *insn = lra_constraint_insn_stack.pop ();\n   bitmap_clear_bit (lra_constraint_insn_stack_bitmap, INSN_UID (insn));\n   return insn;\n }\n@@ -1691,9 +1693,9 @@ lra_insn_stack_length (void)\n \n /* Push insns FROM to TO (excluding it) going in reverse order.\t */\n static void\n-push_insns (rtx from, rtx to)\n+push_insns (rtx_insn *from, rtx_insn *to)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (from == NULL_RTX)\n     return;\n@@ -1706,23 +1708,24 @@ push_insns (rtx from, rtx to)\n    taken from the next BB insn after LAST or zero if there in such\n    insn.  */\n static void\n-setup_sp_offset (rtx from, rtx last)\n+setup_sp_offset (rtx_insn *from, rtx_insn *last)\n {\n-  rtx before = next_nonnote_insn_bb (last);\n+  rtx_insn *before = next_nonnote_insn_bb (last);\n   HOST_WIDE_INT offset = (before == NULL_RTX || ! INSN_P (before)\n \t\t\t  ? 0 : lra_get_insn_recog_data (before)->sp_offset);\n \n-  for (rtx insn = from; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n+  for (rtx_insn *insn = from; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n     lra_get_insn_recog_data (insn)->sp_offset = offset;\n }\n \n /* Emit insns BEFORE before INSN and insns AFTER after INSN.  Put the\n    insns onto the stack.  Print about emitting the insns with\n    TITLE.  */\n void\n-lra_process_new_insns (rtx insn, rtx before, rtx after, const char *title)\n+lra_process_new_insns (rtx_insn *insn, rtx_insn *before, rtx_insn *after,\n+\t\t       const char *title)\n {\n-  rtx last;\n+  rtx_insn *last;\n \n   if (before == NULL_RTX && after == NULL_RTX)\n     return;\n@@ -1772,7 +1775,7 @@ lra_process_new_insns (rtx insn, rtx before, rtx after, const char *title)\n /* Description of location of a former scratch operand.\t */\n struct sloc\n {\n-  rtx insn; /* Insn where the scratch was.  */\n+  rtx_insn *insn; /* Insn where the scratch was.  */\n   int nop;  /* Number of the operand which was a scratch.  */\n };\n \n@@ -1796,7 +1799,7 @@ lra_former_scratch_p (int regno)\n \n /* Return true if the operand NOP of INSN is a former scratch.\t*/\n bool\n-lra_former_scratch_operand_p (rtx insn, int nop)\n+lra_former_scratch_operand_p (rtx_insn *insn, int nop)\n {\n   return bitmap_bit_p (&scratch_operand_bitmap,\n \t\t       INSN_UID (insn) * MAX_RECOG_OPERANDS + nop) != 0;\n@@ -1809,7 +1812,8 @@ remove_scratches (void)\n   int i;\n   bool insn_changed_p;\n   basic_block bb;\n-  rtx insn, reg;\n+  rtx_insn *insn;\n+  rtx reg;\n   sloc_t loc;\n   lra_insn_recog_data_t id;\n   struct lra_static_insn_data *static_id;\n@@ -1860,7 +1864,7 @@ restore_scratches (void)\n   int regno;\n   unsigned i;\n   sloc_t loc;\n-  rtx last = NULL_RTX;\n+  rtx_insn *last = NULL;\n   lra_insn_recog_data_t id = NULL;\n \n   for (i = 0; scratches.iterate (i, &loc); i++)\n@@ -1903,7 +1907,7 @@ static void\n check_rtl (bool final_p)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   lra_assert (! final_p || reload_completed);\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -1985,7 +1989,7 @@ has_nonexceptional_receiver (void)\n \n /* Process recursively X of INSN and add REG_INC notes if necessary.  */\n static void\n-add_auto_inc_notes (rtx insn, rtx x)\n+add_auto_inc_notes (rtx_insn *insn, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n@@ -2020,7 +2024,7 @@ update_inc_notes (void)\n {\n   rtx *pnote;\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_BB_INSNS (bb, insn)\n@@ -2165,7 +2169,7 @@ lra (FILE *f)\n   lra_live_ranges_init ();\n   lra_constraints_init ();\n   lra_curr_reload_num = 0;\n-  push_insns (get_last_insn (), NULL_RTX);\n+  push_insns (get_last_insn (), NULL);\n   /* It is needed for the 1st coalescing.  */\n   lra_constraint_new_insn_uid_start = get_max_uid ();\n   bitmap_initialize (&lra_inheritance_pseudos, &reg_obstack);"}]}