{"sha": "c85158dec62c8293382c1d311dd6e71dcbf08e32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg1MTU4ZGVjNjJjODI5MzM4MmMxZDMxMWRkNmU3MWRjYmYwOGUzMg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2015-11-03T18:53:19Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2015-11-03T18:53:19Z"}, "message": "re PR c/67882 (surprising offsetof result on an invalid array member without diagnostic)\n\nPR c++-common/67882\n\n\t* c-family/c-common.h (fold_offsetof_1): Add argument.\n\t* c-family/c-common.c (fold_offsetof_1): Diagnose more invalid\n\toffsetof expressions that reference elements past the end of\n\tan array.\n\n        * c-c++-common/builtin-offsetof-2.c: New test.\n\nFrom-SVN: r229717", "tree": {"sha": "401facc539421f9aa5dc9e0dcaff8a9691d3412e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/401facc539421f9aa5dc9e0dcaff8a9691d3412e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c85158dec62c8293382c1d311dd6e71dcbf08e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85158dec62c8293382c1d311dd6e71dcbf08e32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85158dec62c8293382c1d311dd6e71dcbf08e32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85158dec62c8293382c1d311dd6e71dcbf08e32/comments", "author": null, "committer": null, "parents": [{"sha": "aa3d33850faf4de0a1a2b142cefa35326a0d5c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa3d33850faf4de0a1a2b142cefa35326a0d5c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa3d33850faf4de0a1a2b142cefa35326a0d5c0b"}], "stats": {"total": 247, "additions": 239, "deletions": 8}, "files": [{"sha": "32a13c07689d3b7accfa06a272adb7cb05c09af0", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c85158dec62c8293382c1d311dd6e71dcbf08e32", "patch": "@@ -1,3 +1,11 @@\n+2015-11-03  Bernd Schmidt <bschmidt@redhat.com>\n+\n+\tPR c++-common/67882\n+\t* c-family/c-common.h (fold_offsetof_1): Add argument.\n+\t* c-family/c-common.c (fold_offsetof_1): Diagnose more invalid\n+\toffsetof expressions that reference elements past the end of\n+\tan array.\n+\n 2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>\n "}, {"sha": "de5f8b6cbdf6b50a1ca4508c432feec6af7a0262", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c85158dec62c8293382c1d311dd6e71dcbf08e32", "patch": "@@ -10631,11 +10631,11 @@ c_common_to_target_charset (HOST_WIDE_INT c)\n    traditional rendering of offsetof as a macro.  Return the folded result.  */\n \n tree\n-fold_offsetof_1 (tree expr)\n+fold_offsetof_1 (tree expr, enum tree_code ctx)\n {\n   tree base, off, t;\n-\n-  switch (TREE_CODE (expr))\n+  tree_code code = TREE_CODE (expr);\n+  switch (code)\n     {\n     case ERROR_MARK:\n       return expr;\n@@ -10659,7 +10659,7 @@ fold_offsetof_1 (tree expr)\n       return TREE_OPERAND (expr, 0);\n \n     case COMPONENT_REF:\n-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0));\n+      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);\n       if (base == error_mark_node)\n \treturn base;\n \n@@ -10676,7 +10676,7 @@ fold_offsetof_1 (tree expr)\n       break;\n \n     case ARRAY_REF:\n-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0));\n+      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);\n       if (base == error_mark_node)\n \treturn base;\n \n@@ -10691,8 +10691,9 @@ fold_offsetof_1 (tree expr)\n \t      && !tree_int_cst_equal (upbound,\n \t\t\t\t      TYPE_MAX_VALUE (TREE_TYPE (upbound))))\n \t    {\n-\t      upbound = size_binop (PLUS_EXPR, upbound,\n-\t\t\t\t    build_int_cst (TREE_TYPE (upbound), 1));\n+\t      if (ctx != ARRAY_REF && ctx != COMPONENT_REF)\n+\t        upbound = size_binop (PLUS_EXPR, upbound,\n+\t\t\t\t      build_int_cst (TREE_TYPE (upbound), 1));\n \t      if (tree_int_cst_lt (upbound, t))\n \t\t{\n \t\t  tree v;"}, {"sha": "0da4b2e87c893a99c21ea90c08df666d072c594c", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=c85158dec62c8293382c1d311dd6e71dcbf08e32", "patch": "@@ -1029,7 +1029,7 @@ extern bool c_dump_tree (void *, tree);\n \n extern void verify_sequence_points (tree);\n \n-extern tree fold_offsetof_1 (tree);\n+extern tree fold_offsetof_1 (tree, tree_code ctx = ERROR_MARK);\n extern tree fold_offsetof (tree);\n \n /* Places where an lvalue, or modifiable lvalue, may be required."}, {"sha": "708b9d4381f2434739154ec9c1bc08b50a72e5e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c85158dec62c8293382c1d311dd6e71dcbf08e32", "patch": "@@ -1,3 +1,8 @@\n+2015-11-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++-common/67882\n+\t* c-c++-common/builtin-offsetof-2.c: New test.\n+\n 2015-11-03  Dominique d'Humieres <dominiq@lps.ens.fr>\n \n \tPR fortran/67982"}, {"sha": "f943dde05f705446810c38f0f8e55163f7fd313c", "filename": "gcc/testsuite/c-c++-common/builtin-offsetof-2.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-offsetof-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85158dec62c8293382c1d311dd6e71dcbf08e32/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-offsetof-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-offsetof-2.c?ref=c85158dec62c8293382c1d311dd6e71dcbf08e32", "patch": "@@ -0,0 +1,217 @@\n+// { dg-options \"-Warray-bounds\" }\n+// { dg-do compile }\n+\n+// Test case exercising pr c/67882 - surprising offsetof result\n+//   on an invalid array member without diagnostic.\n+\n+typedef struct A1 {\n+  char a1[1];\n+  char c;\n+} A1;\n+\n+typedef struct A1_x_2 {\n+  char a1[1];\n+  char a[][2];\n+} A1_x_2;\n+\n+typedef struct A1_1_x {\n+  char a1_1[1][1];\n+  char a[];\n+} A1_1_x;\n+\n+typedef struct Ax_2_3 {\n+  int i;\n+  char a_x_2_3[][2][3];\n+} Ax_2_3;\n+\n+typedef struct A1_1 {\n+  char a1_1[1][1];\n+  char c;\n+} A1_1;\n+\n+typedef struct B {\n+  A1_1 a2_3[2][3];\n+  char a1_1[3][5];\n+  char a[];\n+} B;\n+\n+// Structures with members that contain flexible array members are\n+// an extension accepted by GCC.\n+typedef struct C {\n+  A1_1_x a5_7 [5][7];\n+  int a;\n+} C;\n+\n+// Structs with a \"fake\" flexible array member (a GCC extension).\n+typedef struct FA0 {\n+  int i;\n+  char a0 [0];\n+} FA0;\n+\n+typedef struct FA1 {\n+  int i;\n+  char a1 [1];\n+} FA1;\n+\n+typedef struct FA3 {\n+  int i;\n+  char a3 [3];\n+} FA3;\n+\n+// A \"fake\" multidimensional flexible array member.\n+typedef struct FA5_7 {\n+  int i;\n+  char a5_7 [5][7];\n+} FA5_7;\n+\n+static void test (void)\n+{\n+  // Verify that offsetof references to array elements past the end of\n+  // the array member are diagnosed.  As an extension, permit references\n+  // to the element just past-the-end of the array.\n+\n+  int a[] = {\n+    __builtin_offsetof (A1, a1),                 // valid\n+    __builtin_offsetof (A1, a1 [0]),             // valid\n+\n+    // The following expression is valid because it forms the equivalent\n+    // of an address pointing just past the last element of the array.\n+    __builtin_offsetof (A1, a1 [1]),             // valid\n+\n+    __builtin_offsetof (A1, a1 [2]),             // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (A1_x_2, a1),             // valid\n+    __builtin_offsetof (A1_x_2, a1 [0]),         // valid\n+    __builtin_offsetof (A1_x_2, a1 [1]),         // valid\n+    __builtin_offsetof (A1_x_2, a1 [2]),         // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (A1_x_2, a),              // valid\n+    __builtin_offsetof (A1_x_2, a [0]),          // valid\n+    __builtin_offsetof (A1_x_2, a [1]),          // valid\n+    __builtin_offsetof (A1_x_2, a [99]),         // valid\n+\n+    __builtin_offsetof (A1_x_2, a),              // valid\n+    __builtin_offsetof (A1_x_2, a [0][0]),       // valid\n+    __builtin_offsetof (A1_x_2, a [0][1]),       // valid\n+\n+    // The following expression is valid because it forms the equivalent\n+    // of an address pointing just past the last element of the first\n+    // array.\n+    __builtin_offsetof (A1_x_2, a [0][2]),       // valid\n+\n+    // Unlike the case above, this is invalid since it refers to an element\n+    // past one one just-past-the-end in A[][2].\n+    __builtin_offsetof (A1_x_2, a [0][3]),       // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (A1_x_2, a [1][0]),       // valid\n+    __builtin_offsetof (A1_x_2, a [1][1]),       // valid\n+    __builtin_offsetof (A1_x_2, a [1][2]),       // valid\n+    __builtin_offsetof (A1_x_2, a [99][0]),      // valid\n+    __builtin_offsetof (A1_x_2, a [99][1]),      // valid\n+    __builtin_offsetof (A1_x_2, a [99][2]),      // valid\n+\n+    __builtin_offsetof (A1_1_x, a),              // valid\n+    __builtin_offsetof (A1_1_x, a [0]),          // valid\n+    __builtin_offsetof (A1_1_x, a [1]),          // valid\n+    __builtin_offsetof (A1_1_x, a [99]),         // valid\n+\n+    __builtin_offsetof (A1_1_x, a1_1 [0][0]),    // valid\n+    __builtin_offsetof (A1_1_x, a1_1 [0][1]),    // valid\n+    __builtin_offsetof (A1_1_x, a1_1 [0][2]),    // { dg-warning \"index\" }\n+    __builtin_offsetof (A1_1_x, a1_1 [1][0]),    // { dg-warning \"index\" }\n+    __builtin_offsetof (A1_1_x, a1_1 [1][1]),    // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (Ax_2_3, a_x_2_3 [0][1][3]),  // valid\n+    __builtin_offsetof (Ax_2_3, a_x_2_3 [0][1][4]),  // { dg-warning \"index\" }\n+    __builtin_offsetof (Ax_2_3, a_x_2_3 [0][2]),     // valid\n+    __builtin_offsetof (Ax_2_3, a_x_2_3 [0][2][0]),  // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (B, a2_3 [0][0].c),           // valid\n+    __builtin_offsetof (B, a2_3 [0][0].a1_1 [0][0]), // valid\n+    __builtin_offsetof (B, a2_3 [1][3]),             // valid\n+    __builtin_offsetof (B, a2_3 [1][4]),             // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [0][0].a1_1 [0][1]), // valid\n+    __builtin_offsetof (B, a2_3 [0][0].a1_1 [0][2]), // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (B, a2_3 [0][0].a1_1 [1][0]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [0][0].a1_1 [1][1]), // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (B, a2_3 [1][2].a1_1 [0][0]), // valid\n+\n+    // Forming an offset to the just-past-end element is valid.\n+    __builtin_offsetof (B, a2_3 [1][2].a1_1 [0][1]), // valid\n+    __builtin_offsetof (B, a2_3 [1][2].a1_1 [1][0]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [1][2].a1_1 [1][1]), // { dg-warning \"index\" }\n+\n+    // Forming an offset to the just-past-end element is valid.\n+    __builtin_offsetof (B, a2_3 [1][3]),             // valid\n+    // ...but these are diagnosed because they dereference a just-past-the-end\n+    // element.\n+    __builtin_offsetof (B, a2_3 [1][3].a1_1 [0][0]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [1][3].a1_1 [0][0]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [1][3].a1_1 [0][1]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [1][3].a1_1 [1][0]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [1][3].a1_1 [1][1]), // { dg-warning \"index\" }\n+\n+    // Analogous to the case above, these are both diagnosed because they\n+    // dereference just-past-the-end elements of the a2_3 array.\n+    __builtin_offsetof (B, a2_3 [1][3].c),       // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [1][3].c),       // { dg-warning \"index\" }\n+\n+    // The following are all invalid because of the reference to a2_3[2].\n+    __builtin_offsetof (B, a2_3 [2][0].a1_1 [0][0]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [2][0].a1_1 [0][1]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [2][0].a1_1 [1][0]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [2][0].a1_1 [1][1]), // { dg-warning \"index\" }\n+    __builtin_offsetof (B, a2_3 [2][0].c),           // { dg-warning \"index\" }\n+\n+    __builtin_offsetof (C, a5_7 [4][6]),\n+    __builtin_offsetof (C, a5_7 [4][6].a),\n+    __builtin_offsetof (C, a5_7 [4][6].a [0]),\n+    __builtin_offsetof (C, a5_7 [4][6].a [99]),\n+\n+    __builtin_offsetof (C, a5_7 [4][7]),             // valid\n+    // Diagnose the following even though the object whose offset is\n+    // computed is a flexible array member.\n+    __builtin_offsetof (C, a5_7 [4][7].a),           // { dg-warning \"index\" }\n+    __builtin_offsetof (C, a5_7 [4][7].a [0]),       // { dg-warning \"index\" }\n+    __builtin_offsetof (C, a5_7 [4][7].a [99]),      // { dg-warning \"index\" }\n+\n+    // Verify that no diagnostic is issued for offsetof expressions\n+    // involving structs where the array has a rank of 1 and is the last\n+    // member (e.g., those are treated as flexible array members).\n+    __builtin_offsetof (FA0, a0 [0]),\n+    __builtin_offsetof (FA0, a0 [1]),\n+    __builtin_offsetof (FA0, a0 [99]),\n+\n+    __builtin_offsetof (FA1, a1 [0]),\n+    __builtin_offsetof (FA1, a1 [1]),\n+    __builtin_offsetof (FA1, a1 [99]),\n+\n+    __builtin_offsetof (FA3, a3 [0]),\n+    __builtin_offsetof (FA3, a3 [3]),\n+    __builtin_offsetof (FA3, a3 [99]),\n+\n+    __builtin_offsetof (FA5_7, a5_7 [0][0]),\n+\n+    // Unlike one-dimensional arrays, verify that out-of-bounds references\n+    // to \"fake\" flexible arrays with rank of 2 and greater are diagnosed.\n+\n+    // The following are valid because they compute the offset of just past\n+    // the end of each of the a5_7[0] and a5_7[1] arrays.\n+    __builtin_offsetof (FA5_7, a5_7 [0][7]),         // valid\n+    __builtin_offsetof (FA5_7, a5_7 [1][7]),         // valid\n+\n+    // The following two are accepted as an extesion (because a5_7 is\n+    // treated as a flexible array member).\n+    __builtin_offsetof (FA5_7, a5_7 [5][0]),         // extension\n+    __builtin_offsetof (FA5_7, a5_7 [5][7]),         // extension\n+\n+    // The following are invalid since in both cases they denote an element\n+    // that's beyond just-past-the-end of the array.\n+    __builtin_offsetof (FA5_7, a5_7 [0][8]),        // { dg-warning \"index\" }\n+    __builtin_offsetof (FA5_7, a5_7 [6][8])         // { dg-warning \"index\" }\n+  };\n+\n+  (void)&a;\n+}"}]}