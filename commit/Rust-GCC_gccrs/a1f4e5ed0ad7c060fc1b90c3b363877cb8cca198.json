{"sha": "a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFmNGU1ZWQwYWQ3YzA2MGZjMWI5MGMzYjM2Mzg3N2NiOGNjYTE5OA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-09-05T00:00:55Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-09-05T00:00:55Z"}, "message": "SimpleDateFormat.java: Re-merged with Classpath.\n\n\t* java/text/SimpleDateFormat.java: Re-merged with Classpath.\n\t* gnu/gcj/text/LocaleData.java, gnu/gcj/text/LocaleData_en.java,\n\tgnu/gcj/text/LocaleData_en_US.java: Removed.\n\t* java/text/DateFormatSymbols.java (clone): Use Classpath\n\timplementation.\n\t(equals): Simplified.\n\t(DateFormatSymbols): Look in gnu.java.locale for information.\n\t(DateFormatSymbols(DateFormatSymbols)): Removed.\n\t(safeGetResource): Removed.\n\t(DateFormatSymbols): Throws MissingResourceException.\n\t(ampmsDefault, erasDefault, localPatternCharsDefault,\n\tmonthsDefault, shortMonthsDefault, shortWeekdaysDefault,\n\tweekdaysDefault, zoneStringsDefault): Removed.\n\t* java/text/Collator.java (getAvailableLocales): Use modified\n\tClasspath implementation.\n\t(getInstance): Look in gnu.java.locale for information.\n\t(clone): Rewrote.\n\t* java/text/MessageFormat.java: Reindented.\n\t(clone): Rewrote.\n\t* java/text/FieldPosition.java: Merged with Classpath.\n\t* java/text/ParsePosition.java: Merged with Classpath.\n\t* java/text/Format.java: Merged with Classpath.\n\t* java/text/StringCharacterIterator.java\n\t(StringCharacterIterator(StringCharacterIterator,int,int)): New\n\tconstructor from Classpath.\n\t* java/text/Annotation.java,\n\tjava/text/AttributedCharacterIterator.java,\n\tjava/text/AttributedString.java,\n\tjava/text/AttributedStringIterator.java: New from Classpath.\n\t* java/text/CharacterIterator.java: Copied from Classpath.\n\t* java/text/ChoiceFormat.java: Reindented.\n\t(clone): Removed.\n\t* gnu/java/text/BaseBreakIterator.java,\n\tgnu/java/text/CharacterBreakIterator.java,\n\tgnu/java/text/LineBreakIterator.java,\n\tgnu/java/text/LocaleData_en.java,\n\tgnu/java/text/LocaleData_en_US.java,\n\tgnu/java/text/SentenceBreakIterator.java,\n\tgnu/java/text/WordBreakIterator.java: Renamed from gnu/gcj/text/*.\n\t* gnu/gcj/text/BaseBreakIterator.java (last): Advance past final\n\tcharacter.\n\t* java/text/BreakIterator.java (getAvailableLocales): Use\n\tClasspath implementation.\n\t(getInstance): Look in gnu.java.locale for information.\n\t(getCharacterInstance, getLineInstance, getSentenceInstance,\n\tgetWordInstance): Look in gnu.java.text for implementations.\n\t* java/text/DecimalFormatSymbols.java: Reindented\n\t(clone): Use Classpath implementation.\n\t(DecimalFormatSymbols(DecimalFormatSymbols)): Removed.\n\t(DecimalFormatSymbols(Locale)): Look in gnu.java.locale for\n\tinformation.\n\t* java/text/DateFormat.java: Merged with Classpath.\n\t(getAvailableLocales): Use Classpath implementation.\n\t(format(Object,StringBuffer,FieldPosition)): Minor cleanup.\n\t(computeInstance): Look in gnu.java.locale for information.\n\t* java/text/NumberFormat.java: Reindented.\n\t(computeInstance): Look in gnu.java.locale for information.\n\t(getAvailableLocales): Use implementation from Classpath.\n\t(setMaximumIntegerDigits): Likewise.\n\t(setMinimumIntegerDigits): Likewise.\n\t(setMaximumFractionDigits): Likewise.\n\t(clone): Removed.\n\t* java/text/DecimalFormat.java: Reindented.\n\t* gnu/java/locale/LocaleInformation_en.java: Copied from Classpath.\n\t* gnu/java/locale/LocaleInformation_en_US.java: Copied from Classpath.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (ordinary_java_source_files): Added all new files.\n\t(ordinary_java_source_files): Renamed or removed gnu/gcj/text/*.\n\t* java/security/spec/AlgorithmParameterSpec.java,\n\tjava/security/spec/KeySpec.java: Re-merged with Classpath.\n\nFrom-SVN: r45390", "tree": {"sha": "e84d2d5f42b8908733b2858f19c7f95e32335a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e84d2d5f42b8908733b2858f19c7f95e32335a86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/comments", "author": null, "committer": null, "parents": [{"sha": "45932d27fb140524de00d4a08efea4cf75dd7ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45932d27fb140524de00d4a08efea4cf75dd7ca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45932d27fb140524de00d4a08efea4cf75dd7ca0"}], "stats": {"total": 8251, "additions": 5757, "deletions": 2494}, "files": [{"sha": "1a542aaa22f2b14ca350998949d0f57a5b8bfe8b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,5 +1,76 @@\n 2001-09-04  Tom Tromey  <tromey@redhat.com>\n \n+\t* java/text/SimpleDateFormat.java: Re-merged with Classpath.\n+\t* gnu/gcj/text/LocaleData.java, gnu/gcj/text/LocaleData_en.java,\n+\tgnu/gcj/text/LocaleData_en_US.java: Removed.\n+\t* java/text/DateFormatSymbols.java (clone): Use Classpath\n+\timplementation.\n+\t(equals): Simplified.\n+\t(DateFormatSymbols): Look in gnu.java.locale for information.\n+\t(DateFormatSymbols(DateFormatSymbols)): Removed.\n+\t(safeGetResource): Removed.\n+\t(DateFormatSymbols): Throws MissingResourceException.\n+\t(ampmsDefault, erasDefault, localPatternCharsDefault,\n+\tmonthsDefault, shortMonthsDefault, shortWeekdaysDefault,\n+\tweekdaysDefault, zoneStringsDefault): Removed.\n+\t* java/text/Collator.java (getAvailableLocales): Use modified\n+\tClasspath implementation.\n+\t(getInstance): Look in gnu.java.locale for information.\n+\t(clone): Rewrote.\n+\t* java/text/MessageFormat.java: Reindented.\n+\t(clone): Rewrote.\n+\t* java/text/FieldPosition.java: Merged with Classpath.\n+\t* java/text/ParsePosition.java: Merged with Classpath.\n+\t* java/text/Format.java: Merged with Classpath.\n+\t* java/text/StringCharacterIterator.java\n+\t(StringCharacterIterator(StringCharacterIterator,int,int)): New\n+\tconstructor from Classpath.\n+\t* java/text/Annotation.java,\n+\tjava/text/AttributedCharacterIterator.java,\n+\tjava/text/AttributedString.java,\n+\tjava/text/AttributedStringIterator.java: New from Classpath.\n+\t* java/text/CharacterIterator.java: Copied from Classpath.\n+\t* java/text/ChoiceFormat.java: Reindented.\n+\t(clone): Removed.\n+\t* gnu/java/text/BaseBreakIterator.java,\n+\tgnu/java/text/CharacterBreakIterator.java,\n+\tgnu/java/text/LineBreakIterator.java,\n+\tgnu/java/text/LocaleData_en.java,\n+\tgnu/java/text/LocaleData_en_US.java,\n+\tgnu/java/text/SentenceBreakIterator.java,\n+\tgnu/java/text/WordBreakIterator.java: Renamed from gnu/gcj/text/*.\n+\t* gnu/gcj/text/BaseBreakIterator.java (last): Advance past final\n+\tcharacter.\n+\t* java/text/BreakIterator.java (getAvailableLocales): Use\n+\tClasspath implementation.\n+\t(getInstance): Look in gnu.java.locale for information.\n+\t(getCharacterInstance, getLineInstance, getSentenceInstance,\n+\tgetWordInstance): Look in gnu.java.text for implementations.\n+\t* java/text/DecimalFormatSymbols.java: Reindented\n+\t(clone): Use Classpath implementation.\n+\t(DecimalFormatSymbols(DecimalFormatSymbols)): Removed.\n+\t(DecimalFormatSymbols(Locale)): Look in gnu.java.locale for\n+\tinformation.\n+\t* java/text/DateFormat.java: Merged with Classpath.\n+\t(getAvailableLocales): Use Classpath implementation.\n+\t(format(Object,StringBuffer,FieldPosition)): Minor cleanup.\n+\t(computeInstance): Look in gnu.java.locale for information.\n+\t* java/text/NumberFormat.java: Reindented.\n+\t(computeInstance): Look in gnu.java.locale for information.\n+\t(getAvailableLocales): Use implementation from Classpath.\n+\t(setMaximumIntegerDigits): Likewise.\n+\t(setMinimumIntegerDigits): Likewise.\n+\t(setMaximumFractionDigits): Likewise.\n+\t(clone): Removed.\n+\t* java/text/DecimalFormat.java: Reindented.\n+\t* gnu/java/locale/LocaleInformation_en.java: Copied from Classpath.\n+\t* gnu/java/locale/LocaleInformation_en_US.java: Copied from Classpath.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (ordinary_java_source_files): Added all new files.\n+\t(ordinary_java_source_files): Renamed or removed gnu/gcj/text/*.\n+\t* java/security/spec/AlgorithmParameterSpec.java,\n+\tjava/security/spec/KeySpec.java: Re-merged with Classpath.\n+\n \tFix for PR libgcj/4213:\n \t* Makefile.am (ordinary_java_source_files): Added new file.\n \t* gnu/gcj/text/LocaleData.java: New file."}, {"sha": "65748dd684c8f4e80973061c78bbcc4a21e83fcc", "filename": "libjava/Makefile.am", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1123,14 +1123,6 @@ gnu/gcj/protocol/jar/Handler.java \\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FirstThread.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/text/BaseBreakIterator.java \\\n-gnu/gcj/text/CharacterBreakIterator.java \\\n-gnu/gcj/text/LineBreakIterator.java \\\n-gnu/gcj/text/LocaleData.java\t\\\n-gnu/gcj/text/LocaleData_en.java\t\\\n-gnu/gcj/text/LocaleData_en_US.java \\\n-gnu/gcj/text/SentenceBreakIterator.java\t\\\n-gnu/gcj/text/WordBreakIterator.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n@@ -1141,10 +1133,20 @@ gnu/java/locale/Calendar.java \\\n gnu/java/locale/Calendar_de.java \\\n gnu/java/locale/Calendar_en.java \\\n gnu/java/locale/Calendar_nl.java \\\n+gnu/java/locale/LocaleInformation.java \\\n+gnu/java/locale/LocaleInformation_de.java \\\n+gnu/java/locale/LocaleInformation_en.java \\\n+gnu/java/locale/LocaleInformation_en_US.java \\\n+gnu/java/locale/LocaleInformation_nl.java \\\n gnu/java/security/provider/DefaultPolicy.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/text/BaseBreakIterator.java \\\n+gnu/java/text/CharacterBreakIterator.java \\\n+gnu/java/text/LineBreakIterator.java \\\n+gnu/java/text/SentenceBreakIterator.java\t\\\n+gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n java/lang/ref/PhantomReference.java \\\n java/lang/ref/Reference.java \\\n@@ -1333,6 +1335,10 @@ java/sql/Struct.java\t\\\n java/sql/Time.java \\\n java/sql/Timestamp.java\t\\\n java/sql/Types.java \\\n+java/text/Annotation.java \\\n+java/text/AttributedCharacterIterator.java \\\n+java/text/AttributedString.java\t\\\n+java/text/AttributedStringIterator.java\t\\\n java/text/BreakIterator.java \\\n java/text/CharacterIterator.java \\\n java/text/ChoiceFormat.java \\"}, {"sha": "ff899e7a7470a50a23e214a2059a5f878c4a15f4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -873,14 +873,6 @@ gnu/gcj/protocol/jar/Handler.java \\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FirstThread.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/text/BaseBreakIterator.java \\\n-gnu/gcj/text/CharacterBreakIterator.java \\\n-gnu/gcj/text/LineBreakIterator.java \\\n-gnu/gcj/text/LocaleData.java\t\\\n-gnu/gcj/text/LocaleData_en.java\t\\\n-gnu/gcj/text/LocaleData_en_US.java \\\n-gnu/gcj/text/SentenceBreakIterator.java\t\\\n-gnu/gcj/text/WordBreakIterator.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n@@ -891,10 +883,20 @@ gnu/java/locale/Calendar.java \\\n gnu/java/locale/Calendar_de.java \\\n gnu/java/locale/Calendar_en.java \\\n gnu/java/locale/Calendar_nl.java \\\n+gnu/java/locale/LocaleInformation.java \\\n+gnu/java/locale/LocaleInformation_de.java \\\n+gnu/java/locale/LocaleInformation_en.java \\\n+gnu/java/locale/LocaleInformation_en_US.java \\\n+gnu/java/locale/LocaleInformation_nl.java \\\n gnu/java/security/provider/DefaultPolicy.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/text/BaseBreakIterator.java \\\n+gnu/java/text/CharacterBreakIterator.java \\\n+gnu/java/text/LineBreakIterator.java \\\n+gnu/java/text/SentenceBreakIterator.java\t\\\n+gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n java/lang/ref/PhantomReference.java \\\n java/lang/ref/Reference.java \\\n@@ -1083,6 +1085,10 @@ java/sql/Struct.java\t\\\n java/sql/Time.java \\\n java/sql/Timestamp.java\t\\\n java/sql/Types.java \\\n+java/text/Annotation.java \\\n+java/text/AttributedCharacterIterator.java \\\n+java/text/AttributedString.java\t\\\n+java/text/AttributedStringIterator.java\t\\\n java/text/BreakIterator.java \\\n java/text/CharacterIterator.java \\\n java/text/ChoiceFormat.java \\\n@@ -1491,14 +1497,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/protocol/jar/Handler.P \\\n .deps/gnu/gcj/runtime/FileDeleter.P .deps/gnu/gcj/runtime/FirstThread.P \\\n .deps/gnu/gcj/runtime/VMClassLoader.P \\\n-.deps/gnu/gcj/runtime/natFirstThread.P \\\n-.deps/gnu/gcj/text/BaseBreakIterator.P \\\n-.deps/gnu/gcj/text/CharacterBreakIterator.P \\\n-.deps/gnu/gcj/text/LineBreakIterator.P .deps/gnu/gcj/text/LocaleData.P \\\n-.deps/gnu/gcj/text/LocaleData_en.P \\\n-.deps/gnu/gcj/text/LocaleData_en_US.P \\\n-.deps/gnu/gcj/text/SentenceBreakIterator.P \\\n-.deps/gnu/gcj/text/WordBreakIterator.P .deps/gnu/gcj/xlib/Clip.P \\\n+.deps/gnu/gcj/runtime/natFirstThread.P .deps/gnu/gcj/xlib/Clip.P \\\n .deps/gnu/gcj/xlib/Colormap.P .deps/gnu/gcj/xlib/Display.P \\\n .deps/gnu/gcj/xlib/Drawable.P .deps/gnu/gcj/xlib/Font.P \\\n .deps/gnu/gcj/xlib/GC.P .deps/gnu/gcj/xlib/Pixmap.P \\\n@@ -1543,6 +1542,11 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/lang/reflect/TypeSignature.P \\\n .deps/gnu/java/locale/Calendar.P .deps/gnu/java/locale/Calendar_de.P \\\n .deps/gnu/java/locale/Calendar_en.P .deps/gnu/java/locale/Calendar_nl.P \\\n+.deps/gnu/java/locale/LocaleInformation.P \\\n+.deps/gnu/java/locale/LocaleInformation_de.P \\\n+.deps/gnu/java/locale/LocaleInformation_en.P \\\n+.deps/gnu/java/locale/LocaleInformation_en_US.P \\\n+.deps/gnu/java/locale/LocaleInformation_nl.P \\\n .deps/gnu/java/rmi/dgc/DGCImpl.P .deps/gnu/java/rmi/dgc/DGCImpl_Skel.P \\\n .deps/gnu/java/rmi/dgc/DGCImpl_Stub.P \\\n .deps/gnu/java/rmi/registry/RegistryImpl.P \\\n@@ -1565,6 +1569,11 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/security/provider/Gnu.P \\\n .deps/gnu/java/security/provider/SHA.P \\\n .deps/gnu/java/security/provider/SHA1PRNG.P \\\n+.deps/gnu/java/text/BaseBreakIterator.P \\\n+.deps/gnu/java/text/CharacterBreakIterator.P \\\n+.deps/gnu/java/text/LineBreakIterator.P \\\n+.deps/gnu/java/text/SentenceBreakIterator.P \\\n+.deps/gnu/java/text/WordBreakIterator.P \\\n .deps/gnu/java/util/DoubleEnumeration.P .deps/interpret.P \\\n .deps/java/applet/Applet.P .deps/java/applet/AppletContext.P \\\n .deps/java/applet/AppletStub.P .deps/java/applet/AudioClip.P \\\n@@ -2024,6 +2033,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/sql/SQLOutput.P .deps/java/sql/SQLWarning.P \\\n .deps/java/sql/Statement.P .deps/java/sql/Struct.P \\\n .deps/java/sql/Time.P .deps/java/sql/Timestamp.P .deps/java/sql/Types.P \\\n+.deps/java/text/Annotation.P \\\n+.deps/java/text/AttributedCharacterIterator.P \\\n+.deps/java/text/AttributedString.P \\\n+.deps/java/text/AttributedStringIterator.P \\\n .deps/java/text/BreakIterator.P .deps/java/text/CharacterIterator.P \\\n .deps/java/text/ChoiceFormat.P \\\n .deps/java/text/CollationElementIterator.P \\"}, {"sha": "8c20d46d47cb1a20ee07b4b686b23d73e7fce339", "filename": "libjava/gnu/gcj/text/BaseBreakIterator.java", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FBaseBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FBaseBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FBaseBreakIterator.java?ref=45932d27fb140524de00d4a08efea4cf75dd7ca0", "patch": "@@ -1,82 +0,0 @@\n-// Base class for default BreakIterators.\n-\n-/* Copyright (C) 1999  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n-\n-import java.text.BreakIterator;\n-import java.text.CharacterIterator;\n-\n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date March 22, 1999\n- */\n-\n-public abstract class BaseBreakIterator extends BreakIterator\n-{\n-  public int current ()\n-  {\n-    return iter.getIndex();\n-  }\n-\n-  public int first ()\n-  {\n-    iter.first();\n-    return iter.getBeginIndex();\n-  }\n-\n-  public int following (int pos)\n-  {\n-    int save = iter.getIndex();\n-    iter.setIndex(pos);\n-    int r = next ();\n-    iter.setIndex(save);\n-    return r;\n-  }\n-\n-  public CharacterIterator getText ()\n-  {\n-    return iter;\n-  }\n-\n-  public int last ()\n-  {\n-    iter.last();\n-    return iter.getEndIndex();\n-  }\n-\n-  public int next (int n)\n-  {\n-    int r = iter.getIndex ();\n-    if (n > 0)\n-      {\n-\twhile (n > 0 && r != DONE)\n-\t  {\n-\t    r = next ();\n-\t    --n;\n-\t  }\n-      }\n-    else if (n < 0)\n-      {\n-\twhile (n < 0 && r != DONE)\n-\t  {\n-\t    r = previous ();\n-\t    ++n;\n-\t  }\n-      }\n-    return r;\n-  }\n-\n-  public void setText (CharacterIterator newText)\n-  {\n-    iter = newText;\n-  }\n-\n-  protected CharacterIterator iter;\n-}"}, {"sha": "fc273b9c43f7a28a9aa889e1b37bde3cd9f6e78a", "filename": "libjava/gnu/gcj/text/LocaleData.java", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData.java?ref=45932d27fb140524de00d4a08efea4cf75dd7ca0", "patch": "@@ -1,25 +0,0 @@\n-// Generic locale data for java.text.\n-\n-/* Copyright (C) 2001  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n-\n-import java.util.ListResourceBundle;\n-\n-public class LocaleData extends ListResourceBundle\n-{\n-  private static final Object[][] contents =\n-  {\n-  };\n-\n-  protected Object[][] getContents ()\n-  {\n-    return contents;\n-  }\n-}"}, {"sha": "c24c1121335e5d1a31d4f80e683d1202dc5db75d", "filename": "libjava/gnu/gcj/text/LocaleData_en.java", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java?ref=45932d27fb140524de00d4a08efea4cf75dd7ca0", "patch": "@@ -1,92 +0,0 @@\n-// Generic English locale data for java.text.\n-\n-/* Copyright (C) 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n-\n-import java.util.ListResourceBundle;\n-\n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date March 4, 1999\n- */\n-\n-public final class LocaleData_en extends ListResourceBundle\n-{\n-  // These are for DateFormatSymbols.\n-  static final String[] ampmsDefault = {\"AM\", \"PM\" };\n-  static final String[] erasDefault = {\"BC\", \"AD\" };\n-  static final String localPatternCharsDefault = \"GyMdkHmsSEDFwWahKz\";\n-  static final String[] monthsDefault = {\n-    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n-    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\"\n-  };\n-  static final String[] shortMonthsDefault = {\n-    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n-    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\"\n-  };\n-  static final String[] shortWeekdaysDefault = {\n-    \"\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n-  };\n-  static final String[] weekdaysDefault = {\n-    \"\", \"Sunday\", \"Monday\", \"Tuesday\",\n-    \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n-  };\n-\n-  private static final Object[][] contents =\n-  {\n-    // These are for DecimalFormatSymbols.\n-    { \"decimalSeparator\", \".\" },\n-    { \"digit\", \"#\" },\n-    { \"exponential\", \"E\" },\n-    { \"groupingSeparator\", \",\" },\n-    { \"infinity\", \"\\u221e\" },\n-    { \"minusSign\", \"-\" },\n-    { \"monetarySeparator\", \".\" },\n-    { \"NaN\", \"\\ufffd\" },\n-    { \"patternSeparator\", \";\" },\n-    { \"percent\", \"%\" },\n-    { \"perMill\", \"\\u2030\" },\n-    { \"zeroDigit\", \"0\" },\n-\n-    // These are for NumberFormat.\n-    { \"numberFormat\", \"#,##0.###\" },\n-    { \"percentFormat\", \"#,##0%\" },\n-\n-    // These are for DateFormatSymbols.\n-    { \"ampm\", ampmsDefault },\n-    { \"eras\", erasDefault },\n-    { \"datePatternChars\", localPatternCharsDefault },\n-    { \"months\", monthsDefault },\n-    { \"shortMonths\", shortMonthsDefault },\n-    { \"shortWeekdays\", shortWeekdaysDefault },\n-    { \"weekdays\", weekdaysDefault },\n-\n-    // These are for DateFormat.\n-    { \"shortDateFormat\", \"M/d/yy\" },\t      // Java's Y2K bug.\n-    { \"mediumDateFormat\", \"d-MMM-yy\" },\n-    { \"longDateFormat\", \"MMMM d, yyyy\" },\n-    { \"fullDateFormat\", \"EEEE MMMM d, yyyy G\" },\n-    { \"shortTimeFormat\", \"h:mm a\" },\n-    { \"mediumTimeFormat\", \"h:mm:ss a\" },\n-    { \"longTimeFormat\", \"h:mm:ss a z\" },\n-    { \"fullTimeFormat\", \"h:mm:ss;S 'o''clock' a z\" },\n-\n-    // For RuleBasedCollator.\n-    // FIXME: this is nowhere near complete.\n-    // In particular we must mark accents as ignorable,\n-    // and probably other things as well.\n-    { \"collatorRule\", \"< 0 < 1 < 2 < 3 < 4 < 5 < 6 < 7 < 8 < 9 < a,A < b,B < c,C < d,D < e,E < f,F < g,G < h,H < i,I < j,J < k,K < l,L < m,M < n,N < o,O < p,P < q,Q < r,R < s,S < t,T < u,U < v,V < w,W < x,X < y,Y < z,Z\" }\n-  };\n-\n-  protected Object[][] getContents ()\n-    {\n-      return contents;\n-    }\n-}"}, {"sha": "eb5d4f14be164b87dcfbf826f9088794a783ced8", "filename": "libjava/gnu/gcj/text/LocaleData_en_US.java", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en_US.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45932d27fb140524de00d4a08efea4cf75dd7ca0/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en_US.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en_US.java?ref=45932d27fb140524de00d4a08efea4cf75dd7ca0", "patch": "@@ -1,81 +0,0 @@\n-// US English locale data for java.text.\n-\n-/* Copyright (C) 1999  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n-\n-import java.util.ListResourceBundle;\n-\n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date March 4, 1999\n- */\n-\n-public final class LocaleData_en_US extends ListResourceBundle\n-{\n-  // These are for DateFormatSymbols.\n-  static String[][] zoneStringsDefault = {\n-    { \"GMT\", \"Greenwich Mean Time\", \"GMT\",\n-      /**/   \"Greenwich Mean Time\", \"GMT\", \"GMT\" },\n-    { \"PST\", \"Pacific Standard Time\", \"PST\",\n-      /**/   \"Pacific Daylight Time\", \"PDT\", \"San Francisco\" },\n-    { \"MST\", \"Mountain Standard Time\", \"MST\",\n-      /**/   \"Mountain Daylight Time\", \"MDT\", \"Denver\" },\n-    { \"PNT\", \"Mountain Standard Time\", \"MST\",\n-      /**/   \"Mountain Standard Time\", \"MST\", \"Phoenix\" },\n-    { \"CST\", \"Central Standard Time\", \"CST\",\n-      /**/   \"Central Daylight Time\", \"CDT\", \"Chicago\" },\n-    { \"EST\", \"Eastern Standard Time\", \"EST\",\n-      /**/   \"Eastern Daylight Time\", \"EDT\", \"Boston\" },\n-    { \"IET\", \"Eastern Standard Time\", \"EST\",\n-      /**/   \"Eastern Standard Time\", \"EST\", \"Indianapolis\" },\n-    { \"PRT\", \"Atlantic Standard Time\", \"AST\",\n-      /**/   \"Atlantic Daylight Time\", \"ADT\", \"Halifax\" },\n-    { \"CNT\", \"Newfoundland Standard Time\", \"NST\",\n-      /**/   \"Newfoundland Daylight Time\", \"NDT\", \"St. Johns\" },\n-    { \"ECT\", \"Central European Standard Time\", \"CET\",\n-      /**/   \"Central European Daylight Time\", \"CEST\", \"Paris\" },\n-    { \"CTT\", \"China Standard Time\", \"CST\",\n-      /**/   \"China Standard Time\", \"CST\", \"Shanghai\" },\n-    { \"JST\", \"Japan Standard Time\", \"JST\",\n-      /**/   \"Japan Standard Time\", \"JST\", \"Tokyo\" },\n-    { \"HST\", \"Hawaii Standard Time\", \"HST\",\n-      /**/   \"Hawaii Standard Time\", \"HST\", \"Honolulu\" },\n-    { \"AST\", \"Alaska Standard Time\", \"AKST\",\n-      /**/   \"Alaska Daylight Time\", \"AKDT\", \"Anchorage\" }\n-  };\n-\n-  private static final Object[][] contents =\n-  {\n-    // These are for DecimalFormatSymbols.\n-    { \"currency\", \"$\" },\n-    { \"intlCurrencySymbol\", \"$\" },\t      // FIXME?\n-\n-    // These are for NumberFormat.\n-    { \"currencyFormat\", \"$#,##0.00;($#,##0.00)\" },\n-\n-    // These are for DateFormatSymbols.\n-    { \"zoneStrings\", zoneStringsDefault },\n-\n-    // These are for DateFormat.\n-    { \"shortDateFormat\", \"M/d/yy\" },\t      // Java's Y2K bug.\n-    { \"mediumDateFormat\", \"d-MMM-yy\" },\n-    { \"longDateFormat\", \"MMMM d, yyyy\" },\n-    { \"fullDateFormat\", \"EEEE MMMM d, yyyy G\" },\n-    { \"shortTimeFormat\", \"h:mm a\" },\n-    { \"mediumTimeFormat\", \"h:mm:ss a\" },\n-    { \"longTimeFormat\", \"h:mm:ss a z\" },\n-    { \"fullTimeFormat\", \"h:mm:ss;S 'o''clock' a z\" }\n-  };\n-\n-  protected Object[][] getContents ()\n-    {\n-      return contents;\n-    }\n-}"}, {"sha": "208f2c50b1bd3894d6ecf34f84095435c418b45c", "filename": "libjava/gnu/java/locale/LocaleInformation_de.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_de.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_de.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_de.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,5 +1,5 @@\n /* LocaleInformation_de.java -- German locale data\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -47,7 +47,7 @@ public class LocaleInformation_de extends ListResourceBundle\n   * proper format.\n   */\n private static final String collation_rules = \n-  \"-<0,1<2<3<4<5<6<7<8<9<A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<j,K\" +\n+  \"<0<1<2<3<4<5<6<7<8<9<A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<k,K\" +\n   \"<l,L<m,M<n,N<o,O<p,P<q,Q<r,R<s,S<t,T<u,U<v,V<w,W<x,X<y,Y,z<Z\" + \n   \"&ae,\\u00e4&Ae,\\u00c4&oe,\\u00f6&Oe,\\u00d6&ue,\\u00fc&Ue,\\u00dc&ss,\\u00df\";\n "}, {"sha": "61e351dba4aacfa18f3ad9e17aad6b1e63f77591", "filename": "libjava/gnu/java/locale/LocaleInformation_en.java", "status": "modified", "additions": 115, "deletions": 293, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,5 +1,5 @@\n /* LocaleInformation_en.java -- US English locale data\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -32,301 +32,123 @@\n import java.util.Date;\n \n /**\n-  * This class contains locale data for the US English locale\n-  */\n-\n+ * This class contains locale data for English.\n+ */\n public class LocaleInformation_en extends ListResourceBundle\n {\n \n-/*\n- * This area is used for defining object values\n- */\n-\n-/**\n-  * This is the set of collation rules used by java.text.RuleBasedCollator \n-  * to sort strings properly.  See the documentation of that class for the \n-  * proper format.\n-  */\n-private static final String collation_rules = \n-  \"-<0,1<2<3<4<5<6<7<8<9A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<j,K\" +\n+  /*\n+   * This area is used for defining object values\n+   */\n+\n+  /**\n+   * This is the set of collation rules used by java.text.RuleBasedCollator \n+   * to sort strings properly.  See the documentation of that class for the \n+   * proper format.\n+   */\n+  // FIXME: this is nowhere near complete.\n+  // In particular we must mark accents as ignorable,\n+  // and probably other things as well.\n+  private static final String collation_rules = \n+  \"<0<1<2<3<4<5<6<7<8<9<A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<k,K\" +\n   \"<l,L<m,M<n,N<o,O<p,P<q,Q<r,R<s,S<t,T<u,U<v,V<w,W<x,X<y,Y,z<Z\";\n \n-/*\n- * For the followings lists, strings that are subsets of other break strigns\n- * must be listed first.  For example, if \"\\r\" and \"\\r\\n\" are sequences,\n- * the \"\\r\" must be first or it will never be used.\n- */\n-\n-/**\n-  * This is the list of word separator characters used by \n-  * java.text.BreakIterator \n-  */\n-private static final String[] word_breaks = { \" \", \"\\t\", \"\\r\\n\", \"\\n\" }; \n-\n-/**\n-  * This is the list of sentence break sequences used by \n-  * java.text.BreakIterator\n-  */\n-private static final String[] sentence_breaks = { \". \" };\n-\n-/**\n-  * This is the list of potential line break locations.\n-  */\n-private static final String[] line_breaks = { \"\\t\", \"-\", \"\\r\\n\", \n-  \"\\n\", \".  \", \". \", \".\",  \"?  \", \"? \", \"?\",  \"!  \", \"! \", \"!\", \", \", \" \" };\n-\n-/**\n-  * This is the list of months, fully spelled out\n-  */\n-private static final String[] months = { \"January\", \"February\", \"March\", \n-  \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\",\n-  \"November\", \"December\", null };\n-\n-/**\n-  * This is the list of abbreviated month names\n-  */\n-private static final String[] shortMonths = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n-  \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", null };\n-\n-/**\n-  * This is the list of weekdays, fully spelled out\n-  */\n-private static final String[] weekdays = { null, \"Sunday\", \"Monday\", \"Tuesday\",\n-  \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\n-\n-/**\n-  * This is the list of abbreviated weekdays\n-  */\n-private static final String[] shortWeekdays = { null, \"Sun\", \"Mon\", \"Tue\", \"Wed\",\n-  \"Thu\", \"Fri\", \"Sat\" };\n-\n-/**\n-  * This is the list of AM/PM strings\n-  */\n-private static final String[] ampms = { \"AM\", \"PM\" };\n-\n-/**\n-  * This is the list of era identifiers\n-  */\n-private static final String[] eras = { \"BC\", \"AD\" };\n-\n-/**\n-  * This is the list of timezone strings.  The JDK appears to include a\n-  * city name as the sixth element.\n-  */\n-private static final String[][] zoneStrings =\n-{\n-  { \"EST6EDT\", \"Eastern Standard Time\", \"EST\", \"Eastern Daylight Time\", \"EDT\",\n-    \"New York\" },\n-  { \"EST6\", \"Eastern Standard Time\", \"EST\", \"Eastern Standard Time\", \"EST\",\n-    \"Indianapolis\" },\n-  { \"CST6CDT\", \"Central Standard Time\", \"CST\", \"Central Daylight Time\", \"CDT\",\n-    \"Chicago\" },\n-  { \"MST6MDT\", \"Mountain Standard Time\", \"MST\", \"Mountain Daylight Time\", \n-    \"MDT\", \"Denver\" },\n-  { \"MST6\", \"Mountain Standard Time\", \"MST\", \"Mountain Standard Time\", \"MST\",\n-    \"Phoenix\" },\n-  { \"PST6PDT\", \"Pacific Standard Time\", \"PDT\", \"Pacific Daylight Time\", \"PDT\",\n-    \"San Francisco\" },\n-  { \"AST6ADT\", \"Alaska Standard Time\", \"AST\", \"Alaska Daylight Time\", \"ADT\",\n-    \"Anchorage\" },\n-  { \"HST6HDT\", \"Hawaii Standard Time\", \"HST\", \"Hawaii Daylight Time\", \"HDT\",\n-    \"Honolulu\" },\n-  // European time zones.  The city names are a little bit random.\n-  { \"WET\", \"Western European Time\", \"WET\", \"Western European Savings Time\", \"WEST\", \"London\" },\n-  { \"CET\", \"Central European Time\", \"CET\", \"Central European Savings Time\", \"CEST\", \"Berlin\" },\n-  { \"EET\", \"Eastern European Time\", \"EET\", \"Eastern European Savings Time\", \"EEST\", \"Istanbul\" },\n-};\n-\n-/**\n-  * This is the list of pattern characters for formatting dates\n-  */\n-private static final String localPatternChars = \"GyMdkHmsSEDFwWahKz\"; // Not a mistake!\n-\n-/**\n-  * This is the DateFormat.SHORT date format\n-  */\n-private static final String shortDateFormat = \"M/d/yy\";\n-\n-/**\n-  * This is the DateFormat.MEDIUM format\n-  */\n-private static final String mediumDateFormat = \"dd-MMM-yy\";\n-\n-/**\n-  * This is the DateFormat.LONG format\n-  */\n-private static final String longDateFormat = \"MMMM d, yyyy\";\n-\n-/**\n-  * This is the DateFormat.FULL format\n-  */\n-private static final String fullDateFormat = \"EEEE, MMMM d, yyyy\";\n-\n-/**\n-  * This is the DateFormat.DEFAULT format\n-  */\n-private static final String defaultDateFormat = \"dd-MMM-yy\";\n-\n-/**\n-  * This is the DateFormat.SHORT format\n-  */\n-private static final String shortTimeFormat = \"h:mm a\";\n-\n-/**\n-  * This is the DateFormat.MEDIUM format\n-  */\n-private static final String mediumTimeFormat = \"h:mm:ss a\";\n-\n-/**\n-  * This is the DateFormat.LONG format\n-  */\n-private static final String longTimeFormat = \"h:mm:ss a z\";\n-\n-/**\n-  * This is the DateFormat.FULL format\n-  */\n-private static final String fullTimeFormat = \"h:mm:ss 'o''clock' a z\";\n-\n-/**\n-  * This is the DateFormat.DEFAULT format\n-  */\n-private static final String defaultTimeFormat = \"h:mm:ss a\";\n-\n-/**\n-  * This is the currency symbol\n-  */\n-private static final String currencySymbol = \"$\";\n-\n-/**\n-  * This is the international currency symbol. \n-  */\n-private static final String intlCurrencySymbol = \"US$\";\n-\n-/**\n-  * This is the decimal point.\n-  */\n-private static final String decimalSeparator = \".\";\n-\n-/**\n-  * This is the exponential symbol\n-  */\n-private static final String exponential = \"E\";\n-\n-/**\n-  * This is the char used for digits in format strings\n-  */\n-private static final String digit = \"#\";\n-\n-/**\n-  * This is the grouping separator symbols\n-  */\n-private static final String groupingSeparator = \",\";\n-\n-/**\n-  * This is the symbols for infinity\n-  */\n-private static final String infinity = \"\\u221e\";\n-\n-/**\n-  * This is the symbol for the not a number value\n-  */\n-private static final String NaN = \"\\ufffd\";\n-\n-/**\n-  * This is the minus sign symbol.\n-  */\n-private static final String minusSign = \"-\";\n-\n-/**\n-  * This is the decimal separator in monetary values.\n-  */\n-private static final String monetarySeparator = \".\";\n-\n-/**\n-  * This is the separator between positive and negative subpatterns.\n-  */\n-private static final String patternSeparator = \";\";\n-\n-/**\n-  * This is the percent sign\n-  */\n-private static final String percent = \"%\";\n-\n-/**\n-  * This is the per mille sign\n-  */\n-private static final String perMill = \"\\u2030\";\n-\n-/**\n-  * This is the character for zero.\n-  */\n-private static final String zeroDigit = \"0\";\n-\n-/*************************************************************************/\n-\n-/**\n-  * This is the object array used to hold the keys and values\n-  * for this bundle\n-  */\n-\n-private static final Object[][] contents =\n-{\n-  // For RuleBasedCollator\n-  { \"collation_rules\", collation_rules },\n-  // For BreakIterator\n-  { \"word_breaks\", word_breaks },\n-  { \"sentence_breaks\", sentence_breaks },\n-  { \"line_breaks\", line_breaks },\n-  // For SimpleDateFormat/DateFormatSymbols\n-  { \"months\", months },\n-  { \"shortMonths\", shortMonths },\n-  { \"weekdays\", weekdays },\n-  { \"shortWeekdays\", shortWeekdays },\n-  { \"ampms\", ampms },\n-  { \"eras\", eras },\n-  { \"zoneStrings\", zoneStrings },\n-  { \"localPatternChars\", localPatternChars },\n-  { \"shortDateFormat\", shortDateFormat },\n-  { \"mediumDateFormat\", mediumDateFormat },\n-  { \"longDateFormat\", longDateFormat },\n-  { \"fullDateFormat\", fullDateFormat },\n-  { \"defaultDateFormat\", defaultDateFormat },\n-  { \"shortTimeFormat\", shortTimeFormat },\n-  { \"mediumTimeFormat\", mediumTimeFormat },\n-  { \"longTimeFormat\", longTimeFormat },\n-  { \"fullTimeFormat\", fullTimeFormat },\n-  { \"defaultTimeFormat\", defaultTimeFormat },\n-  // For DecimalFormat/DecimalFormatSymbols\n-  { \"currencySymbol\", currencySymbol },\n-  { \"intlCurrencySymbol\", intlCurrencySymbol },\n-  { \"decimalSeparator\", decimalSeparator },\n-  { \"digit\", digit },\n-  { \"exponential\", exponential },\n-  { \"groupingSeparator\", groupingSeparator },\n-  { \"infinity\", infinity },\n-  { \"NaN\", NaN },\n-  { \"minusSign\", minusSign },\n-  { \"monetarySeparator\", monetarySeparator },\n-  { \"patternSeparator\", patternSeparator },\n-  { \"percent\", percent },\n-  { \"perMill\", perMill },\n-  { \"zeroDigit\", zeroDigit },\n-};\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method returns the object array of key, value pairs containing\n-  * the data for this bundle.\n-  *\n-  * @return The key, value information.\n-  */\n-public Object[][]\n-getContents()\n-{\n-  return(contents);\n+  /**\n+   * This is the list of months, fully spelled out\n+   */\n+  private static final String[] months =\n+  {\n+    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n+    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", null\n+  };\n+\n+  /**\n+   * This is the list of abbreviated month names\n+   */\n+  private static final String[] shortMonths =\n+  {\n+    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n+    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", null\n+  };\n+\n+  /**\n+   * This is the list of weekdays, fully spelled out\n+   */\n+  private static final String[] weekdays =\n+  {\n+    null, \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n+    \"Thursday\", \"Friday\", \"Saturday\"\n+  };\n+\n+  /**\n+   * This is the list of abbreviated weekdays\n+   */\n+  private static final String[] shortWeekdays =\n+  {\n+    null, \"Sun\", \"Mon\", \"Tue\", \"Wed\",\n+    \"Thu\", \"Fri\", \"Sat\"\n+  };\n+\n+  /**\n+   * This is the list of AM/PM strings\n+   */\n+  private static final String[] ampms = { \"AM\", \"PM\" };\n+\n+  /**\n+   * This is the list of era identifiers\n+   */\n+  private static final String[] eras = { \"BC\", \"AD\" };\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This is the object array used to hold the keys and values\n+   * for this bundle\n+   */\n+\n+  private static final Object[][] contents =\n+  {\n+    // For RuleBasedCollator\n+    { \"collation_rules\", collation_rules },\n+\n+    // For SimpleDateFormat/DateFormatSymbols\n+    { \"months\", months },\n+    { \"shortMonths\", shortMonths },\n+    { \"weekdays\", weekdays },\n+    { \"shortWeekdays\", shortWeekdays },\n+    { \"ampms\", ampms },\n+    { \"eras\", eras },\n+    { \"localPatternChars\", \"GyMdkHmsSEDFwWahKz\" },\n+\n+    // For DecimalFormat/DecimalFormatSymbols\n+    { \"decimalSeparator\", \".\" },\n+    { \"digit\", \"#\" },\n+    { \"exponential\", \"E\" },\n+    { \"groupingSeparator\", \",\" },\n+    { \"infinity\", \"\\u221e\" },\n+    { \"NaN\", \"\\ufffd\" },\n+    { \"minusSign\", \"-\" },\n+    { \"monetarySeparator\", \".\" },\n+    { \"patternSeparator\", \";\" },\n+    { \"percent\", \"%\" },\n+    { \"perMill\", \"\\u2030\" },\n+    { \"zeroDigit\", \"0\" },\n+\n+    // For NumberFormat.\n+    { \"numberFormat\", \"#,##0.###\" },\n+    { \"percentFormat\", \"#,##0%\" },\n+  };\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the object array of key, value pairs containing\n+   * the data for this bundle.\n+   *\n+   * @return The key, value information.\n+   */\n+  public Object[][] getContents ()\n+  {\n+    return contents;\n+  }\n }\n-\n-} // class LocaleInformation_en\n-"}, {"sha": "1278ccd572e93952a7c4d5934f3e4dad81718b83", "filename": "libjava/gnu/java/locale/LocaleInformation_en_US.java", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en_US.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en_US.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en_US.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -0,0 +1,112 @@\n+/* LocaleInformation_en.java -- US English locale data\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+/**\n+ * This class contains locale data for English in the US.\n+ */\n+public class LocaleInformation_en_US extends ListResourceBundle\n+{\n+  // These are for DateFormatSymbols.\n+  private static final String[][] zoneStrings =\n+  {\n+    { \"GMT\", \"Greenwich Mean Time\", \"GMT\",\n+      /**/   \"Greenwich Mean Time\", \"GMT\", \"GMT\" },\n+    { \"PST\", \"Pacific Standard Time\", \"PST\",\n+      /**/   \"Pacific Daylight Time\", \"PDT\", \"San Francisco\" },\n+    { \"MST\", \"Mountain Standard Time\", \"MST\",\n+      /**/   \"Mountain Daylight Time\", \"MDT\", \"Denver\" },\n+    { \"PNT\", \"Mountain Standard Time\", \"MST\",\n+      /**/   \"Mountain Standard Time\", \"MST\", \"Phoenix\" },\n+    { \"CST\", \"Central Standard Time\", \"CST\",\n+      /**/   \"Central Daylight Time\", \"CDT\", \"Chicago\" },\n+    { \"EST\", \"Eastern Standard Time\", \"EST\",\n+      /**/   \"Eastern Daylight Time\", \"EDT\", \"Boston\" },\n+    { \"IET\", \"Eastern Standard Time\", \"EST\",\n+      /**/   \"Eastern Standard Time\", \"EST\", \"Indianapolis\" },\n+    { \"PRT\", \"Atlantic Standard Time\", \"AST\",\n+      /**/   \"Atlantic Daylight Time\", \"ADT\", \"Halifax\" },\n+    { \"CNT\", \"Newfoundland Standard Time\", \"NST\",\n+      /**/   \"Newfoundland Daylight Time\", \"NDT\", \"St. Johns\" },\n+    { \"ECT\", \"Central European Standard Time\", \"CET\",\n+      /**/   \"Central European Daylight Time\", \"CEST\", \"Paris\" },\n+    { \"CTT\", \"China Standard Time\", \"CST\",\n+      /**/   \"China Standard Time\", \"CST\", \"Shanghai\" },\n+    { \"JST\", \"Japan Standard Time\", \"JST\",\n+      /**/   \"Japan Standard Time\", \"JST\", \"Tokyo\" },\n+    { \"HST\", \"Hawaii Standard Time\", \"HST\",\n+      /**/   \"Hawaii Standard Time\", \"HST\", \"Honolulu\" },\n+    { \"AST\", \"Alaska Standard Time\", \"AKST\",\n+      /**/   \"Alaska Daylight Time\", \"AKDT\", \"Anchorage\" }\n+  };\n+\n+  /**\n+   * This is the object array used to hold the keys and values\n+   * for this bundle\n+   */\n+\n+  private static final Object[][] contents =\n+  {\n+    // For SimpleDateFormat/DateFormatSymbols\n+    { \"zoneStrings\", zoneStrings },\n+    { \"shortDateFormat\", \"M/d/yy\" },\t      // Java's Y2K bug.\n+    { \"mediumDateFormat\", \"d-MMM-yy\" },\n+    { \"longDateFormat\", \"MMMM d, yyyy\" },\n+    { \"defaultDateFormat\", \"d-MMMM-yy\" },\n+    { \"fullDateFormat\", \"EEEE MMMM d, yyyy G\" },\n+    { \"shortTimeFormat\", \"h:mm a\" },\n+    { \"mediumTimeFormat\", \"h:mm:ss a\" },\n+    { \"longTimeFormat\", \"h:mm:ss a z\" },\n+    { \"fullTimeFormat\", \"h:mm:ss;S 'o''clock' a z\" },\n+    { \"defaultTimeFormat\", \"h:mm:ss a\" },\n+\n+    // For DecimalFormat/DecimalFormatSymbols\n+    { \"currencySymbol\", \"$\" },\n+    { \"intlCurrencySymbol\", \"US$\" },\n+\n+    // For NumberFormat.\n+    { \"currencyFormat\", \"$#,##0.00;($#,##0.00)\" }\n+  };\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the object array of key, value pairs containing\n+   * the data for this bundle.\n+   *\n+   * @return The key, value information.\n+   */\n+  public Object[][] getContents ()\n+  {\n+    return contents;\n+  }\n+}"}, {"sha": "43cdeb277ece0f018a3ea20658b06b81d601b90a", "filename": "libjava/gnu/java/locale/LocaleInformation_nl.java", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_nl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_nl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_nl.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,5 +1,5 @@\n /* LocaleInformation_nl.java -- Dutch locale data\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -50,39 +50,9 @@ public class LocaleInformation_nl extends ListResourceBundle\n   * This is the same rule as used in the English locale.\n   */\n private static final String collation_rules = \n-  \"-<0,1<2<3<4<5<6<7<8<9A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<j,K\" +\n+  \"<0<1<2<3<4<5<6<7<8<9<A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<k,K\" +\n   \"<l,L<m,M<n,N<o,O<p,P<q,Q<r,R<s,S<t,T<u,U<v,V<w,W<x,X<y,Y,z<Z\";\n \n-/*\n- * For the followings lists, strings that are subsets of other break strings\n- * must be listed first.  For example, if \"\\r\" and \"\\r\\n\" are sequences,\n- * the \"\\r\" must be first or it will never be used.\n- */\n-\n-/**\n-  * This is the list of word separator characters used by \n-  * java.text.BreakIterator \n-  * <p>\n-  * This is the same list as used in the English local\n-  */\n-private static final String[] word_breaks = { \" \", \"\\t\", \"\\r\\n\", \"\\n\" }; \n-\n-/**\n-  * This is the list of sentence break sequences used by \n-  * java.text.BreakIterator\n-  * <p>\n-  * This is the same list as used in the English local\n-  */\n-private static final String[] sentence_breaks = { \". \" };\n-\n-/**\n-  * This is the list of potential line break locations.\n-  * <p>\n-  * This is the same list as used in the English local\n-  */\n-private static final String[] line_breaks = { \"\\t\", \"-\", \"\\r\\n\", \n-  \"\\n\", \".  \", \". \", \".\",  \"?  \", \"? \", \"?\",  \"!  \", \"! \", \"!\", \", \", \" \" };\n-\n /**\n   * This is the list of months, fully spelled out\n   */\n@@ -281,10 +251,6 @@ public class LocaleInformation_nl extends ListResourceBundle\n {\n   // For RuleBasedCollator\n   { \"collation_rules\", collation_rules },\n-  // For BreakIterator\n-  { \"word_breaks\", word_breaks },\n-  { \"sentence_breaks\", sentence_breaks },\n-  { \"line_breaks\", line_breaks },\n   // For SimpleDateFormat/DateFormatSymbols\n   { \"months\", months },\n   { \"shortMonths\", shortMonths },"}, {"sha": "3220253075d732fb3c7a7973106b78e2ade24161", "filename": "libjava/gnu/java/text/BaseBreakIterator.java", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FBaseBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FBaseBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FBaseBreakIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -0,0 +1,101 @@\n+/* BaseBreakIterator.java -- Base class for default BreakIterators\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.text;\n+\n+import java.text.BreakIterator;\n+import java.text.CharacterIterator;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 22, 1999\n+ */\n+\n+public abstract class BaseBreakIterator extends BreakIterator\n+{\n+  public int current ()\n+  {\n+    return iter.getIndex();\n+  }\n+\n+  public int first ()\n+  {\n+    iter.first();\n+    return iter.getBeginIndex();\n+  }\n+\n+  public int following (int pos)\n+  {\n+    int save = iter.getIndex();\n+    iter.setIndex(pos);\n+    int r = next ();\n+    iter.setIndex(save);\n+    return r;\n+  }\n+\n+  public CharacterIterator getText ()\n+  {\n+    return iter;\n+  }\n+\n+  public int last ()\n+  {\n+    iter.last();\n+    // Go past the last character.\n+    iter.next();\n+    return iter.getEndIndex();\n+  }\n+\n+  public int next (int n)\n+  {\n+    int r = iter.getIndex ();\n+    if (n > 0)\n+      {\n+\twhile (n > 0 && r != DONE)\n+\t  {\n+\t    r = next ();\n+\t    --n;\n+\t  }\n+      }\n+    else if (n < 0)\n+      {\n+\twhile (n < 0 && r != DONE)\n+\t  {\n+\t    r = previous ();\n+\t    ++n;\n+\t  }\n+      }\n+    return r;\n+  }\n+\n+  public void setText (CharacterIterator newText)\n+  {\n+    iter = newText;\n+  }\n+\n+  protected CharacterIterator iter;\n+}"}, {"sha": "68207ced873cee34e082b79f2de9184aa9cd25ac", "filename": "libjava/gnu/java/text/CharacterBreakIterator.java", "status": "renamed", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FCharacterBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FCharacterBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FCharacterBreakIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,14 +1,31 @@\n-// Default character BreakIterator.\n-\n-/* Copyright (C) 1999  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n+/* CharacterBreakIterator.java - Default character BreakIterator.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.text;\n \n import java.text.BreakIterator;\n import java.text.CharacterIterator;", "previous_filename": "libjava/gnu/gcj/text/CharacterBreakIterator.java"}, {"sha": "14c1b70e4cbb9d9cc63b070f9ff6db9f820d316f", "filename": "libjava/gnu/java/text/LineBreakIterator.java", "status": "renamed", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FLineBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FLineBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FLineBreakIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,14 +1,31 @@\n-// Default word BreakIterator.\n-\n-/* Copyright (C) 1999  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n+/* LineBreakIterator.java - Default word BreakIterator.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.text;\n \n import java.text.BreakIterator;\n import java.text.CharacterIterator;", "previous_filename": "libjava/gnu/gcj/text/LineBreakIterator.java"}, {"sha": "9f9e81608ec49a5f38340772868c81622ab731ea", "filename": "libjava/gnu/java/text/SentenceBreakIterator.java", "status": "renamed", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FSentenceBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FSentenceBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FSentenceBreakIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,14 +1,31 @@\n-// Default sentence BreakIterator.\n-\n-/* Copyright (C) 1999  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n+/* SentenceBreakIterator.java - Default sentence BreakIterator.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.text;\n \n import java.text.BreakIterator;\n import java.text.CharacterIterator;", "previous_filename": "libjava/gnu/gcj/text/SentenceBreakIterator.java"}, {"sha": "5cf50147b0c86b0648a75528fbeb63c3fe77a893", "filename": "libjava/gnu/java/text/WordBreakIterator.java", "status": "renamed", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FWordBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fgnu%2Fjava%2Ftext%2FWordBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FWordBreakIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,14 +1,31 @@\n-// Default word BreakIterator.\n-\n-/* Copyright (C) 1999  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.text;\n+/* WordBreakIterator.java - Default word BreakIterator.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.text;\n \n import java.text.BreakIterator;\n import java.text.CharacterIterator;", "previous_filename": "libjava/gnu/gcj/text/WordBreakIterator.java"}, {"sha": "8e04a769fb4f6495fb2e0d77c66a8d36e5162750", "filename": "libjava/java/text/Annotation.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAnnotation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAnnotation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FAnnotation.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -0,0 +1,102 @@\n+/* Annotation.java -- Wrapper for a text attribute object\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.text;\n+\n+/**\n+  * This class is used as a wrapper for a text attribute object.  Annotation\n+  * objects are associated with a specific range of text.  Changing either\n+  * the text range or the underlying text invalidates the object.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class Annotation\n+{\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * This is the attribute object being wrappered\n+  */\n+private Object attrib;\n+\n+/*************************************************************************/\n+\n+/**\n+  * Constructors\n+  */\n+\n+/**\n+  * This method initializes a new instance of <code>Annotation</code> to\n+  * wrapper the specified text attribute object.\n+  *\n+  * @param attrib The text attribute <code>Object</code> to wrapper.\n+  */\n+public\n+Annotation(Object attrib)\n+{\n+  this.attrib = attrib;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * This method returns the text attribute object this <code>Annotation</code>\n+  * instance is wrappering.\n+  *\n+  * @return The text attribute object for this <code>Annotation</code>.\n+  */\n+public Object\n+getValue()\n+{\n+  return(attrib);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a <code>String</code> representation of this\n+  * object.\n+  *\n+  * @return This object as a <code>String</code>.\n+  */\n+public String\n+toString()\n+{\n+  return(getClass().getName() + \"[value=\" + attrib.toString() + \"]\");\n+}\n+\n+} // class Annotation\n+"}, {"sha": "379181e7c09419830bda180412d1ba7630bb5d57", "filename": "libjava/java/text/AttributedCharacterIterator.java", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAttributedCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAttributedCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FAttributedCharacterIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -0,0 +1,333 @@\n+/* AttributedCharacterIterator.java -- Iterate over attributes\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.text;\n+\n+import java.io.Serializable;\n+import java.io.InvalidObjectException;\n+import java.util.Set;\n+import java.util.Map;\n+\n+/**\n+  * This interface extends the <code>CharacterIterator</code> interface\n+  * in order to support iteration over character attributes as well as\n+  * over the characters themselves.\n+  * <p>\n+  * In addition to attributes of specific characters, this interface\n+  * supports the concept of the \"attribute run\", which is an attribute\n+  * that is defined for a particular value across an entire range of\n+  * characters or which is undefined over a range of characters.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface AttributedCharacterIterator extends CharacterIterator\n+{\n+\n+/*\n+ * Inner Classes\n+ */\n+\n+/**\n+  * This class defines attribute keys that are used as text attributes.\n+  */\n+public static class Attribute implements Serializable\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Static Variables\n+ */\n+\n+/**\n+  * This is the attribute for the language of the text.  The value of\n+  * attributes of this key type are instances of <code>Locale</code>.\n+  */\n+public static final Attribute LANGUAGE = new Attribute(\"LANGUAGE\");\n+\n+/**\n+  * This is the attribute for the reading form of text.  This is used\n+  * for storing pronunciation along with the written text for languages\n+  * which need it.  The value of attributes of this key type are\n+  * instances of <code>Annotation</code> which wrappers a <code>String</code>.\n+  */\n+public static final Attribute READING = new Attribute(\"READING\");\n+\n+/**\n+  * This is the attribute for input method segments.  The value of attributes\n+  * of this key type are instances of <code>Annotation</code> which wrapper\n+  * a <code>String</code>.\n+  */\n+public static final Attribute INPUT_METHOD_SEGMENT =    \n+                                  new Attribute(\"INPUT_METHOD_SEGMENT\");\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * This is the name of the attribute key\n+  * @serial\n+  */\n+private String name;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This method initializes a new instance of this class with the specified\n+  * name.\n+  *\n+  * @param name The name of this attribute key.\n+  */\n+protected\n+Attribute(String name)\n+{\n+  this.name = name;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method returns the name of this attribute.\n+  *\n+  * @return The attribute name\n+  */\n+protected String\n+getName()\n+{\n+  return(name);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method resolves an instance of <code>AttributedCharacterIterator.Attribute</code>\n+  * that is being deserialized to one of the three pre-defined attribute\n+  * constants.  It does this by comparing the names of the attributes.  The\n+  * constant that the deserialized object resolves to is returned.\n+  *\n+  * @return The resolved contant value\n+  *\n+  * @exception InvalidObjectException If the object being deserialized cannot be resolved.\n+  */\n+protected Object\n+readResolve() throws InvalidObjectException\n+{\n+  if (this.equals(READING))\n+    return(READING);\n+\n+  if (this.equals(LANGUAGE))\n+    return(LANGUAGE);\n+\n+  if (this.equals(INPUT_METHOD_SEGMENT))\n+    return(INPUT_METHOD_SEGMENT);\n+\n+  throw new InvalidObjectException(\"Can't resolve Attribute: \" + getName());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method tests this object for equality against the specified object.\n+  * The two objects will be considered equal if and only if:\n+  * <ul>\n+  * <li>The specified object is not <code>null</code>.\n+  * <li>The specified object is an instance of <code>AttributedCharacterIterator.Attribute</code>.\n+  * <li>The specified object has the same attribute name as this object.\n+  * </ul>\n+  *\n+  * @param The <code>Object</code> to test for equality against this object.\n+  *\n+  * @return <code>true</code> if the specified object is equal to this one, <code>false</code> otherwise.\n+  */\n+public final boolean\n+equals(Object obj)\n+{\n+  if (obj == this)\n+    return(true);\n+  else \n+    return(false);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a hash value for this object.\n+  *\n+  * @return A hash value for this object.\n+  */\n+public final int\n+hashCode()\n+{\n+  return(super.hashCode());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a <code>String</code> representation of this object.\n+  *\n+  * @return A <code>String</code> representation of this object.\n+  */\n+public String\n+toString()\n+{\n+  return(getClass().getName() + \"(\" + getName() + \")\");\n+}\n+\n+} // Inner class Attribute\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method returns a list of all keys that are defined for the \n+  * text range.  This can be an empty list if no attributes are defined.\n+  *\n+  * @return A list of keys \n+  */\n+public abstract Set\n+getAllAttributeKeys();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a <code>Map</code> of the attributed defined for\n+  * the current character.\n+  *\n+  * @return A <code>Map</code> of the attributes for the current character.\n+  */\n+public abstract Map\n+getAttributes();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the value of the specified attribute for the\n+  * current character.  If the attribute is not defined for the current\n+  * character, <code>null</code> is returned.\n+  *\n+  * @param attrib The attribute to retrieve the value of.\n+  *\n+  * @return The value of the specified attribute\n+  */\n+public abstract Object\n+getAttribute(AttributedCharacterIterator.Attribute attrib);\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the index of the first character in the run that\n+  * contains all attributes defined for the current character.\n+  *\n+  * @return The start index of the run\n+  */\n+public abstract int\n+getRunStart();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the index of the first character in the run that\n+  * contains all attributes in the specified <code>Set</code> defined for\n+  * the current character.\n+  *\n+  * @param attribs The <code>Set</code> of attributes.\n+  *\n+  * @return The start index of the run.\n+  */\n+public abstract int\n+getRunStart(Set attribs);\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the index of the first character in the run that\n+  * contains the specified attribute defined for the current character.\n+  *\n+  * @param attrib The attribute.\n+  *\n+  * @return The start index of the run.\n+  */\n+public abstract int\n+getRunStart(AttributedCharacterIterator.Attribute attrib);\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the index of the character after the end of the run\n+  * that contains all attributed defined for the current character.\n+  *\n+  * @return The end index of the run.\n+  */\n+public abstract int\n+getRunLimit();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the index of the character after the end of the run\n+  * that contains all attributes in the specified <code>Set</code> defined\n+  * for the current character.\n+  *\n+  * @param attribs The <code>Set</code> of attributes.\n+  *\n+  * @return The end index of the run.\n+  */\n+public abstract int\n+getRunLimit(Set attribs);\n+\n+/*************************************************************************/\n+\n+/**\n+  * This methods returns the index of the character after the end of the run\n+  * that contains the specified attribute defined for the current character.\n+  *\n+  * @param attrib The attribute.\n+  * \n+  * @return The end index of the run.\n+  */\n+public abstract int\n+getRunLimit(AttributedCharacterIterator.Attribute attrib);\n+\n+} // interface AttributedCharacterIterator\n+"}, {"sha": "cc664dece787d9bc850d9f04efed41747d42411b", "filename": "libjava/java/text/AttributedString.java", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAttributedString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAttributedString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FAttributedString.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -0,0 +1,431 @@\n+/* AttributedString.java -- Models text with attributes\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.text;\n+\n+import java.util.Iterator;\n+import java.util.Hashtable;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+  * This class models a <code>String</code> with attributes over various\n+  * subranges of the string.  It allows applications to access this \n+  * information via the <code>AttributedCharcterIterator</code> interface.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class AttributedString\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Inner Classes\n+ */\n+\n+/**\n+  * This class contains the attributes and ranges of text over which\n+  * that attributes apply.\n+  */\n+final class AttributeRange\n+{\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * A Map of the attributes\n+  */\n+Map attribs;\n+\n+/**\n+  * The beginning index of the attributes\n+  */\n+int begin_index;\n+\n+/**\n+  * The ending index of the attributes\n+  */\n+int end_index;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+AttributeRange(Map attribs, int begin_index, int end_index)\n+{\n+  this.attribs = attribs;\n+  this.begin_index = begin_index;\n+  this.end_index = end_index;\n+}\n+\n+} // Inner class AttributeRange\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * This object holds the string we are representing.\n+  */\n+private StringCharacterIterator sci;\n+\n+/**\n+  * This is the attribute information \n+  */\n+private AttributeRange[] attribs;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This method initializes a new instance of <code>AttributedString</code>\n+  * that represents the specified <code>String</code> with no attributes.\n+  *\n+  * @param str The <code>String</code> to be attributed.\n+  */\n+public\n+AttributedString(String str)\n+{\n+  sci = new StringCharacterIterator(str);\n+  attribs = new AttributeRange[0];\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new instance of <code>AttributedString</code>\n+  * that represents that specified <code>String</code> with the specified\n+  * attributes over the entire length of the <code>String</code>.\n+  *\n+  * @param str The <code>String</code> to be attributed.\n+  * @param attributes The attribute list.\n+  */\n+public\n+AttributedString(String str, Map attributes)\n+{\n+  this(str);\n+\n+  attribs = new AttributeRange[1];\n+  attribs[0] = new AttributeRange(attributes, 0, str.length());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new instance of <code>AttributedString</code>\n+  * that will use the text and attribute information from the specified\n+  * <code>AttributedCharacterIterator</code>.\n+  *\n+  * @param aci The <code>AttributedCharacterIterator</code> containing the text and attribute information.\n+  */\n+public\n+AttributedString(AttributedCharacterIterator aci)\n+{\n+  this(aci, aci.getBeginIndex(), aci.getEndIndex(), null);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new instance of <code>AttributedString</code>\n+  * that will use the text and attribute information from the specified\n+  * subrange of the specified <code>AttributedCharacterIterator</code>.\n+  *\n+  * @param aci The <code>AttributedCharacterIterator</code> containing the text and attribute information.\n+  * @param begin_index The beginning index of the text subrange.\n+  * @param end_index The ending index of the text subrange.\n+  */\n+public\n+AttributedString(AttributedCharacterIterator aci, int begin_index,\n+                 int end_index)\n+{\n+  this(aci, begin_index, end_index, null);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new instance of <code>AttributedString</code>\n+  * that will use the text and attribute information from the specified\n+  * subrange of the specified <code>AttributedCharacterIterator</code>.\n+  * Only attributes from the source iterator that are present in the\n+  * specified array of attributes will be included in the attribute list\n+  * for this object.\n+  *\n+  * @param aci The <code>AttributedCharacterIterator</code> containing the text and attribute information.\n+  * @param begin_index The beginning index of the text subrange.\n+  * @param end_index The ending index of the text subrange.\n+  * @param attributes A list of attributes to include from the iterator, or <code>null</code> to include all attributes.\n+  */\n+public\n+AttributedString(AttributedCharacterIterator aci, int begin_index, \n+                 int end_index, AttributedCharacterIterator.Attribute[] attributes)\n+{\n+  // Validate some arguments\n+  if ((begin_index < 0) || (end_index < begin_index))\n+    throw new IllegalArgumentException(\"Bad index values\");\n+\n+  StringBuffer sb = new StringBuffer(\"\");\n+\n+  // Get the valid attribute list\n+  Set all_attribs = aci.getAllAttributeKeys();\n+  if (attributes != null)\n+    {\n+      Set valid_attribs = new HashSet();\n+      Iterator iter = all_attribs.iterator();\n+      while (iter.hasNext())\n+        {\n+          Object obj = iter.next();\n+\n+          int i;\n+          for (i = 0; i < attributes.length; i++)\n+            if (obj.equals(attributes[0]))\n+              break;\n+\n+          if (i == attributes.length)\n+            continue;\n+\n+          valid_attribs.add(obj);\n+        }\n+\n+      all_attribs = valid_attribs;\n+    } \n+\n+  // Loop through and extract the attributes\n+  char c = aci.setIndex(begin_index);\n+\n+  do\n+    { \n+      sb.append(c);\n+\n+      Iterator iter = all_attribs.iterator();\n+      while(iter.hasNext())\n+        {\n+          Object obj = iter.next();\n+\n+          // What should we do if this is not true?\n+          if (!(obj instanceof AttributedCharacterIterator.Attribute))\n+            continue;\n+\n+          AttributedCharacterIterator.Attribute attrib = \n+            (AttributedCharacterIterator.Attribute)obj;\n+\n+          // Make sure the attribute is defined.\n+          int rl = aci.getRunLimit(attrib);\n+          if (rl == -1)\n+            continue;\n+          if (rl > end_index)\n+            rl = end_index;\n+          rl -= begin_index;\n+\n+          // Check to see if we already processed this one\n+          int rs = aci.getRunStart(attrib);\n+          if ((rs < aci.getIndex()) && (aci.getIndex() != begin_index))\n+            continue;\n+\n+          // If the attribute run starts before the beginning index, we\n+          // need to junk it if it is an Annotation.\n+          Object attrib_obj = aci.getAttribute(attrib);\n+          if (rs < begin_index)\n+            {\n+              if (attrib_obj instanceof Annotation)\n+                 continue;\n+\n+              rs = begin_index;\n+            }\n+          else\n+            {\n+              rs -= begin_index;\n+            }\n+\n+          // Create a map object.  Yes this will only contain one attribute\n+          Map new_map = new Hashtable();\n+          new_map.put(attrib, attrib_obj);\n+\n+          // Add it to the attribute list.  Yes this is a bad way to do things.\n+          AttributeRange[] new_list = new AttributeRange[attribs.length + 1];\n+          System.arraycopy(attribs, 0, new_list, 0, attribs.length);\n+          attribs = new_list;\n+          attribs[attribs.length - 1] = new AttributeRange(new_map, rs, rl);\n+        }\n+\n+      c = aci.next();\n+    }\n+  while(c != CharacterIterator.DONE);\n+\n+  sci = new StringCharacterIterator(sb.toString());\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method adds a new attribute that will cover the entire string.\n+  *\n+  * @param attrib The attribute to add.\n+  * @param value The value of the attribute.\n+  */\n+public void\n+addAttribute(AttributedCharacterIterator.Attribute attrib, Object value)\n+{\n+  addAttribute(attrib, value, 0, sci.getEndIndex() - 1);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method adds a new attribute that will cover the specified subrange\n+  * of the string.\n+  *\n+  * @param attrib The attribute to add.\n+  * @param value The value of the attribute.\n+  * @param begin_index The beginning index of the subrange.\n+  * @param end_index The ending index of the subrange.\n+  *\n+  * @exception IllegalArgumentException If attribute is <code>null</code> or the subrange is not valid.\n+  */\n+public void\n+addAttribute(AttributedCharacterIterator.Attribute attrib, Object value,\n+             int begin_index, int end_index)\n+{\n+  if (attrib == null)\n+    throw new IllegalArgumentException(\"null attribute\");\n+\n+  Hashtable ht = new Hashtable();\n+  ht.put(attrib, value);\n+\n+  addAttributes(ht, begin_index, end_index);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method adds all of the attributes in the specified list to the\n+  * specified subrange of the string.\n+  *\n+  * @param attributes The list of attributes.\n+  * @param begin_index The beginning index.\n+  * @param end_index The ending index\n+  *\n+  * @param IllegalArgumentException If the list is <code>null</code> or the subrange is not valid.\n+  */\n+public void\n+addAttributes(Map attributes, int begin_index, int end_index)\n+{\n+  if (attributes == null)\n+    throw new IllegalArgumentException(\"null attribute\");\n+\n+  if ((begin_index < 0) || (end_index > sci.getEndIndex()) ||\n+      (end_index < begin_index))\n+    throw new IllegalArgumentException(\"bad range\");\n+\n+  AttributeRange[] new_list = new AttributeRange[attribs.length + 1];\n+  System.arraycopy(attribs, 0, new_list, 0, attribs.length);\n+  attribs = new_list;\n+  attribs[attribs.length - 1] = new AttributeRange(attributes, begin_index, \n+                                                   end_index);\n+} \n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns an <code>AttributedCharacterIterator</code> that \n+  * will iterate over the entire string.\n+  *\n+  * @return An <code>AttributedCharacterIterator</code> for the entire string.\n+  */\n+public AttributedCharacterIterator\n+getIterator()\n+{\n+  return(new AttributedStringIterator(sci, attribs, 0, sci.getEndIndex() - 1,\n+                                      null));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns an <code>AttributedCharacterIterator</code> that\n+  * will iterate over the entire string.  This iterator will return information\n+  * about the list of attributes in the specified array.  Attributes not in\n+  * the array may or may not be returned by the iterator.  If the specified\n+  * array is <code>null</code>, all attributes will be returned.\n+  *\n+  * @param attributes A list of attributes to include in the returned iterator.\n+  *\n+  * @return An <code>AttributedCharacterIterator</code> for this string.\n+  */\n+public AttributedCharacterIterator\n+getIterator(AttributedCharacterIterator.Attribute[] attributes)\n+{\n+  return(getIterator(attributes, 0, sci.getEndIndex() - 1));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns an <code>AttributedCharacterIterator</code> that\n+  * will iterate over the specified subrange.  This iterator will return information\n+  * about the list of attributes in the specified array.  Attributes not in\n+  * the array may or may not be returned by the iterator.  If the specified\n+  * array is <code>null</code>, all attributes will be returned.  \n+  *\n+  * @param attributes A list of attributes to include in the returned iterator.\n+  * @param begin_index The beginning index of the subrange.\n+  * @param end_index The ending index of the subrange.\n+  *\n+  * @return An <code>AttributedCharacterIterator</code> for this string.\n+  */\n+public AttributedCharacterIterator\n+getIterator(AttributedCharacterIterator.Attribute[] attributes, \n+            int begin_index, int end_index)\n+{\n+  if ((begin_index < 0) || (end_index > sci.getEndIndex()) ||\n+      (end_index < begin_index))\n+    throw new IllegalArgumentException(\"bad range\");\n+\n+  return(new AttributedStringIterator(sci, attribs, begin_index, end_index,\n+                                      attributes));\n+}\n+\n+} // class AttributedString\n+"}, {"sha": "4d0e4e66655405a4be1d8a8f7d07f79a953704ee", "filename": "libjava/java/text/AttributedStringIterator.java", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAttributedStringIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FAttributedStringIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FAttributedStringIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -0,0 +1,351 @@\n+/* AttributedStringIterator.java -- Class to iterate over AttributedString\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.text;\n+\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+  * This class implements the AttributedCharacterIterator interface.  It\n+  * is used by AttributedString.getIterator().\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+class AttributedStringIterator implements AttributedCharacterIterator\n+{\n+\n+/*************************************************************************/\n+\n+/**\n+  * Instance Variables\n+  */\n+\n+/**\n+  * The character iterator containing the text\n+  */\n+private CharacterIterator ci;\n+\n+/**\n+  * The list of attributes and ranges\n+  */\n+private AttributedString.AttributeRange[] attribs;\n+\n+/**\n+  * The list of attributes that the user is interested in.  We may,\n+  * at our option, not return any other attributes.\n+  */\n+private AttributedCharacterIterator.Attribute[] restricts;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+AttributedStringIterator(StringCharacterIterator sci, \n+                         AttributedString.AttributeRange[] attribs,\n+                         int begin_index, int end_index,\n+                         AttributedCharacterIterator.Attribute[] restricts)\n+{\n+  this.ci = new StringCharacterIterator(sci, begin_index, end_index);\n+  this.attribs = attribs;\n+  this.restricts = restricts;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+// First we have a bunch of stupid redirects.  If StringCharacterIterator\n+// weren't final, I just would have extended that for this class.  Alas, no.\n+\n+public Object\n+clone()\n+{\n+  return(ci.clone());\n+}\n+\n+public char\n+current()\n+{\n+  return(ci.current());\n+}\n+\n+public char\n+next()\n+{\n+  return(ci.next());\n+}\n+\n+public char\n+previous()\n+{\n+  return(ci.previous());\n+}\n+\n+public char\n+first()\n+{\n+  return(ci.first());\n+}\n+\n+public char\n+last()\n+{\n+  return(ci.last());\n+}\n+\n+public int\n+getIndex()\n+{\n+  return(ci.getIndex());\n+}\n+\n+public char\n+setIndex(int index)\n+{\n+  return(ci.setIndex(index));\n+}\n+\n+public int\n+getBeginIndex()\n+{\n+  return(ci.getBeginIndex());\n+}\n+\n+public int\n+getEndIndex()\n+{\n+  return(ci.getEndIndex());\n+}\n+\n+/*\n+ * Here is where the AttributedCharacterIterator methods start.\n+ */ \n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a list of all the attribute keys that are defined anywhere\n+  * on this string.\n+  */\n+public Set\n+getAllAttributeKeys()\n+{\n+  HashSet s = new HashSet();\n+  if (attribs == null)\n+    return(s);\n+\n+  for (int i = 0; i < attribs.length; i++)\n+    {\n+      Set key_set = attribs[i].attribs.keySet();\n+      Iterator iter = key_set.iterator();\n+      while (iter.hasNext())\n+        {\n+          s.add(iter.next());\n+        }\n+    }\n+\n+  return(s);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Various methods that determine how far the run extends for various\n+  * attribute combinations.\n+  */\n+\n+public int\n+getRunLimit()\n+{\n+  return(getRunLimit(getAttributes().keySet()));\n+}\n+\n+public int\n+getRunLimit(AttributedCharacterIterator.Attribute attrib)\n+{\n+  HashSet s = new HashSet();\n+  s.add(attrib);\n+\n+  return(getRunLimit(s));\n+}\n+\n+public synchronized int\n+getRunLimit(Set attribute_set)\n+{\n+  int orig_index = ci.getIndex();\n+  int run_limit;\n+\n+  do  \n+    {\n+      run_limit = ci.getIndex();\n+\n+      Map attribute_map = getAttributes();\n+\n+      boolean found = false;\n+      Iterator iter = attribute_set.iterator();\n+      while(iter.hasNext()) \n+        if (!attribute_map.containsKey(iter.next()))\n+          {\n+            found = true;\n+            break;\n+          }\n+\n+      if (found)\n+        break;\n+    }\n+  while (ci.next() != CharacterIterator.DONE);\n+\n+  boolean hit_end = (ci.previous() == CharacterIterator.DONE);\n+\n+  ci.setIndex(orig_index);\n+\n+  if (run_limit == orig_index)\n+    return(-1); // No characters match the given attributes\n+//  else if (!hit_end)\n+//    --run_limit;\n+\n+  return(run_limit); \n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Various methods that determine where the run begins for various\n+  * attribute combinations.\n+  */\n+\n+public int\n+getRunStart()\n+{\n+  return(getRunStart(getAttributes().keySet()));\n+}\n+\n+public int\n+getRunStart(AttributedCharacterIterator.Attribute attrib)\n+{\n+  HashSet s = new HashSet();\n+  s.add(attrib);\n+\n+  return(getRunStart(s));\n+}\n+\n+public int\n+getRunStart(Set attribute_set)\n+{\n+  int orig_index = ci.getIndex();\n+  int run_start;\n+\n+  do  \n+    {\n+      run_start = ci.getIndex();\n+\n+      Map attribute_map = getAttributes();\n+\n+      Iterator iter = attribute_set.iterator();\n+      while(iter.hasNext())\n+        if (!attribute_map.containsKey(iter.next()))\n+          break;\n+\n+      if (iter.hasNext())\n+        break;\n+    }\n+  while (ci.previous() != CharacterIterator.DONE);\n+\n+  boolean hit_beginning = (ci.previous() == CharacterIterator.DONE);\n+\n+  ci.setIndex(orig_index);\n+\n+  if (run_start == orig_index)\n+    return(-1); // No characters match the given attributes\n+  else if (!hit_beginning)\n+    ++run_start;\n+\n+  return(run_start); \n+}\n+\n+/*************************************************************************/\n+\n+public Object\n+getAttribute(AttributedCharacterIterator.Attribute attrib)\n+{\n+  if (attribs == null)\n+    return(null);\n+\n+  for (int i = 0; i < attribs.length; i++)\n+    {\n+      Set key_set = attribs[i].attribs.keySet();\n+      Iterator iter = key_set.iterator();\n+      while (iter.hasNext())\n+        {\n+          Object obj = iter.next();\n+\n+          // Check for attribute match and range match\n+          if (obj.equals(attrib))\n+            if ((ci.getIndex() >= attribs[i].begin_index) &&\n+                (ci.getIndex() <= attribs[i].end_index))\n+              return(attribs[i].attribs.get(obj));\n+        }\n+    }\n+\n+  return(null);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Return a list of all the attributes and values defined for this\n+  * character\n+  */\n+public Map\n+getAttributes()\n+{\n+  HashMap m = new HashMap();\n+  if (attribs == null)\n+    return(m);\n+  \n+  for (int i = 0; i < attribs.length; i++)\n+    {\n+       if ((ci.getIndex() >= attribs[i].begin_index) &&\n+           (ci.getIndex() <= attribs[i].end_index))\n+         m.putAll(attribs[i].attribs);\n+    }\n+\n+  return(m);\n+}\n+\n+} // class AttributedStringIterator\n+"}, {"sha": "907e07d5130dfa7689c4bd197869a658c3018e85", "filename": "libjava/java/text/BreakIterator.java", "status": "modified", "additions": 199, "deletions": 14, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FBreakIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,12 +1,29 @@\n-// BreakIterator.java - Iterate over logical breaks in text.\n+/* BreakIterator.java -- Breaks text into elements\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n@@ -15,31 +32,75 @@\n import java.util.ResourceBundle;\n \n /**\n+ * This class iterates over text elements such as words, lines, sentences,\n+ * and characters.  It can only iterate over one of these text elements at\n+ * a time.  An instance of this class configured for the desired iteration\n+ * type is created by calling one of the static factory methods, not\n+ * by directly calling a constructor.\n+ *\n  * @author Tom Tromey <tromey@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date March 19, 1999\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct to 1.1.\n  */\n-\n public abstract class BreakIterator implements Cloneable\n {\n+  /**\n+   * This value is returned by the <code>next()</code> and\n+   * <code>previous</code> in order to indicate that the end of the\n+   * text has been reached.\n+   */\n   // The value was discovered by writing a test program.\n   public static final int DONE = -1;\n \n+  /**\n+   * This method initializes a new instance of <code>BreakIterator</code>.\n+   * This protected constructor is available to subclasses as a default\n+   * no-arg superclass constructor.\n+   */\n   protected BreakIterator ()\n   {\n   }\n \n+  /**\n+   * This method returns the index of the current text element boundary.\n+   *\n+   * @return The current text boundary.\n+   */\n   public abstract int current ();\n+\n+  /**\n+   * This method returns the first text element boundary in the text being\n+   * iterated over.\n+   *\n+   * @return The first text boundary.\n+   */\n   public abstract int first ();\n+\n+  /**\n+   * This methdod returns the offset of the text element boundary following\n+   * the specified offset.\n+   *\n+   * @param offset The text index from which to find the next text boundary.\n+   *\n+   * @param The next text boundary following the specified index.\n+   */\n   public abstract int following (int pos);\n \n+  /**\n+   * This method returns a list of locales for which instances of\n+   * <code>BreakIterator</code> are available.\n+   *\n+   * @return A list of available locales\n+   */\n   public static synchronized Locale[] getAvailableLocales ()\n   {\n-    // FIXME.\n-    return null;\n+    Locale[] l = new Locale[1];\n+    l[0] = Locale.US;\n+    return l;\n   }\n \n   private static BreakIterator getInstance (String type, Locale loc)\n@@ -48,7 +109,8 @@ private static BreakIterator getInstance (String type, Locale loc)\n     try\n       {\n \tResourceBundle res\n-\t  = ResourceBundle.getBundle(\"gnu.gcj.text.LocaleData\", loc);\n+\t  = ResourceBundle.getBundle(\"gnu.java.locale.LocaleInformation\",\n+\t\t\t\t     loc);\n \tclassName = res.getString(type);\n       }\n     catch (MissingResourceException x)\n@@ -74,71 +136,177 @@ private static BreakIterator getInstance (String type, Locale loc)\n       }\n   }\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over characters as defined in the default locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getCharacterInstance ()\n   {\n     return getCharacterInstance (Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over characters as defined in the specified locale.  If the\n+   * desired locale is not available, the default locale is used.\n+   *\n+   * @param locale The desired locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getCharacterInstance (Locale loc)\n   {\n     BreakIterator r = getInstance (\"CharacterIterator\", loc);\n     if (r == null)\n-      r = new gnu.gcj.text.CharacterBreakIterator ();\n+      r = new gnu.java.text.CharacterBreakIterator ();\n     return r;\n   }\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over line breaks as defined in the default locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getLineInstance ()\n   {\n     return getLineInstance (Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over line breaks as defined in the specified locale.  If the\n+   * desired locale is not available, the default locale is used.\n+   *\n+   * @param locale The desired locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getLineInstance (Locale loc)\n   {\n     BreakIterator r = getInstance (\"LineIterator\", loc);\n     if (r == null)\n-      r = new gnu.gcj.text.LineBreakIterator ();\n+      r = new gnu.java.text.LineBreakIterator ();\n     return r;\n   }\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over sentences as defined in the default locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getSentenceInstance ()\n   {\n     return getSentenceInstance (Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over sentences as defined in the specified locale.  If the\n+   * desired locale is not available, the default locale is used.\n+   *\n+   * @param locale The desired locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getSentenceInstance (Locale loc)\n   {\n     BreakIterator r = getInstance (\"SentenceIterator\", loc);\n     if (r == null)\n-      r = new gnu.gcj.text.SentenceBreakIterator ();\n+      r = new gnu.java.text.SentenceBreakIterator ();\n     return r;\n   }\n \n+  /**\n+   * This method returns the text this object is iterating over as a\n+   * <code>CharacterIterator</code>.\n+   *\n+   * @param The text being iterated over.\n+   */\n   public abstract CharacterIterator getText ();\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over words as defined in the default locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getWordInstance ()\n   {\n     return getWordInstance (Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>BreakIterator</code> that will\n+   * iterate over words as defined in the specified locale.  If the\n+   * desired locale is not available, the default locale is used.\n+   *\n+   * @param locale The desired locale.\n+   *\n+   * @return A <code>BreakIterator</code> instance for the default locale.\n+   */\n   public static BreakIterator getWordInstance (Locale loc)\n   {\n     BreakIterator r = getInstance (\"WordIterator\", loc);\n     if (r == null)\n-      r = new gnu.gcj.text.WordBreakIterator ();\n+      r = new gnu.java.text.WordBreakIterator ();\n     return r;\n   }\n \n+  /**\n+   * This method tests whether or not the specified position is a text\n+   * element boundary.\n+   *\n+   * @param offset The text position to test.\n+   *\n+   * @return <code>true</code> if the position is a boundary,\n+   * <code>false</code> otherwise. \n+   */\n   public boolean isBoundary (int pos)\n   {\n     if (pos == 0)\n       return true;\n     return following (pos - 1) == pos;\n   }\n \n+  /**\n+   * This method returns the last text element boundary in the text being\n+   * iterated over.\n+   *\n+   * @return The last text boundary.\n+   */\n   public abstract int last ();\n+\n+  /**\n+   * This method returns the text element boundary following the current\n+   * text position.\n+   *\n+   * @return The next text boundary.\n+   */\n   public abstract int next ();\n+\n+  /**\n+   * This method returns the n'th text element boundary following the current\n+   * text position.\n+   *\n+   * @param n The number of text element boundaries to skip.\n+   *\n+   * @return The next text boundary.\n+   */\n   public abstract int next (int n);\n \n+  /**\n+   * This methdod returns the offset of the text element boundary preceding\n+   * the specified offset.\n+   *\n+   * @param offset The text index from which to find the preceding\n+   *               text boundary. \n+   *\n+   * @returns The next text boundary preceding the specified index.\n+   */\n   public int preceding (int pos)\n   {\n     if (following (pos) == DONE)\n@@ -148,12 +316,29 @@ public int preceding (int pos)\n     return current ();\n   }\n \n+  /**\n+   * This method returns the text element boundary preceding the current\n+   * text position.\n+   *\n+   * @return The previous text boundary.\n+   */\n   public abstract int previous ();\n \n+  /**\n+   * This method sets the text string to iterate over.\n+   *\n+   * @param str The <code>String</code> to iterate over.\n+   */\n   public void setText (String newText)\n   {\n     setText (new StringCharacterIterator (newText));\n   }\n \n+  /**\n+   * This method sets the text to iterate over from the specified\n+   * <code>CharacterIterator</code>.\n+   * \n+   * @param ci The desired <code>CharacterIterator</code>.\n+   */\n   public abstract void setText (CharacterIterator newText);\n }"}, {"sha": "5ab797410451141abca039b1676ebfe9185fea9e", "filename": "libjava/java/text/CharacterIterator.java", "status": "modified", "additions": 148, "deletions": 21, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCharacterIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,36 +1,163 @@\n-// CharacterIterator.java - Protocol for iterating over Unicode characters.\n+/* CharacterIterator.java -- Iterate over a character range\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date February 22, 1999\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct to 1.1.\n- */\n-\n+  * This interface defines a mechanism for iterating over a range of\n+  * characters.  For a given range of text, a beginning and ending index,\n+  * as well as a current index are defined.  These values can be queried\n+  * by the methods in this interface.  Additionally, various methods allow\n+  * the index to be set. \n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n public interface CharacterIterator extends Cloneable\n {\n-  public abstract Object clone ();\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Static Variables\n+   */\n+\n+  /**\n+   * This is a special constant value that is returned when the beginning or\n+   * end of the character range has been reached.\n+   */\n+  public static final char DONE = '\\uFFFF';\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Methods\n+   */\n+\n+  /**\n+   * This method returns the character at the current index position\n+   *\n+   * @return The character at the current index position.\n+   */\n   public abstract char current ();\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method increments the current index and then returns the character\n+   * at the new index value.  If the index is already at <code>getEndIndex() - 1</code>,\n+   * it will not be incremented.\n+   *\n+   * @return The character at the position of the incremented index value, or <code>DONE</code> if the index has reached getEndIndex() - 1\n+   */\n+  public abstract char next ();\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method decrements the current index and then returns the character\n+   * at the new index value.  If the index value is already at the beginning\n+   * index, it will not be decremented.\n+   *\n+   * @return The character at the position of the decremented index value, or <code>DONE</code> if index was already equal to the beginning index value.\n+   */\n+  public abstract char previous ();\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method sets the index value to the beginning of the range and returns\n+   * the character there.\n+   *\n+   * @return The character at the beginning of the range, or <code>DONE</code> if the range is empty.\n+   */\n   public abstract char first ();\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method sets the index value to <code>getEndIndex() - 1</code> and\n+   * returns the character there.  If the range is empty, then the index value\n+   * will be set equal to the beginning index.\n+   *\n+   * @return The character at the end of the range, or <code>DONE</code> if the range is empty.\n+   */\n+  public abstract char last ();  \n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the current value of the index.\n+   *\n+   * @return The current index value\n+   */\n+  public abstract int getIndex ();\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method sets the value of the index to the specified value, then\n+   * returns the character at that position.\n+   *\n+   * @param index The new index value.\n+   *\n+   * @return The character at the new index value or <code>DONE</code> if the index value is equal to <code>getEndIndex</code>.\n+   */\n+  public abstract char setIndex (int index) throws IllegalArgumentException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the character position of the first character in the\n+   * range.\n+   *\n+   * @return The index of the first character in the range.\n+   */\n   public abstract int getBeginIndex ();\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the character position of the end of the text range.\n+   * This will actually be the index of the first character following the\n+   * end of the range.  In the event the text range is empty, this will be\n+   * equal to the first character in the range.\n+   *\n+   * @return The index of the end of the range.\n+   */\n   public abstract int getEndIndex ();\n-  public abstract int getIndex ();\n-  public abstract char last ();\n-  public abstract char next ();\n-  public abstract char previous ();\n-  public abstract char setIndex (int idx);\n \n-  public static final char DONE = '\\uffff';\n+  /*************************************************************************/\n+\n+  /**\n+   * This method creates a copy of this <code>CharacterIterator</code>.\n+   *\n+   * @return A copy of this <code>CharacterIterator</code>.\n+   */\n+  public abstract Object clone ();\n }"}, {"sha": "8e2d920bbcfcd7a391cf890a38346673187cdf2e", "filename": "libjava/java/text/ChoiceFormat.java", "status": "modified", "additions": 439, "deletions": 258, "changes": 697, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FChoiceFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FChoiceFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FChoiceFormat.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,306 +1,487 @@\n-// ChoiceFormat.java - Formatter for `switch'-like string substitution.\n+/* ChoiceFormat.java -- Format over a range of numbers\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n import java.util.Vector;\n \n /**\n+ * This class allows a format to be specified based on a range of numbers.\n+ * To use this class, first specify two lists of formats and range terminators.\n+ * These lists must be arrays of equal length.  The format of index \n+ * <code>i</code> will be selected for value <code>X</code> if \n+ * <code>terminator[i] <= X < limit[i + 1]</code>.  If the value X is not\n+ * included in any range, then either the first or last format will be \n+ * used depending on whether the value X falls outside the range.\n+ * <p>\n+ * This sounds complicated, but that is because I did a poor job of\n+ * explaining it.  Consider the following example:\n+ * <p>\n+ * <pre>\n+ * terminators = { 1, ChoiceFormat.nextDouble(1) }\n+ * formats = { \"file\", \"files\" }\n+ * </pre>\n+ * <p>\n+ * In this case if the actual number tested is one or less, then the word\n+ * \"file\" is used as the format value.  If the number tested is greater than\n+ * one, then \"files\" is used.  This allows plurals to be handled\n+ * gracefully.  Note the use of the method <code>nextDouble</code>.  This\n+ * method selects the next highest double number than its argument.  This\n+ * effectively makes any double greater than 1.0 cause the \"files\" string\n+ * to be selected.  (Note that all terminator values are specified as\n+ * doubles.\n+ * <p>\n+ * Note that in order for this class to work properly, the range terminator\n+ * array must be sorted in ascending order and the format string array\n+ * must be the same length as the terminator array.\n+ *\n  * @author Tom Tromey <tromey@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date March 9, 1999\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 from http://www.javasoft.com.\n  * Status:  Believed complete and correct to 1.1.\n  */\n-\n public class ChoiceFormat extends NumberFormat\n {\n-  // Note: we assume the same kind of quoting rules apply here.\n-  // This isn't explicitly documented.  But for instance we accept\n-  // '#' as a literal hash in a format string.\n+  /**\n+   * This method sets new range terminators and format strings for this\n+   * object based on the specified pattern. This pattern is of the form \n+   * \"term#string|term#string...\".  For example \"1#Sunday|2#Monday|#Tuesday\".\n+   *\n+   * @param pattern The pattern of terminators and format strings.\n+   *\n+   * @exception IllegalArgumentException If the pattern is not valid\n+   */\n   public void applyPattern (String newPattern)\n-    {\n-      int index = 0, max = newPattern.length();\n-      Vector stringVec = new Vector ();\n-      Vector limitVec = new Vector ();\n-      StringBuffer buf = new StringBuffer ();\n-\n-      while (true)\n-\t{\n-\t  // Find end of double.\n-\t  int dstart = index;\n-\t  while (index < max)\n-\t    {\n-\t      char c = newPattern.charAt(index);\n-\t      if (c == '#' || c == '\\u2064' || c == '<')\n-\t\tbreak;\n-\t      ++index;\n-\t    }\n-\n-\t  if (index == max)\n-\t    throw new IllegalArgumentException (\"unexpected end of text\");\n-\t  Double d = new Double (newPattern.substring(dstart, index));\n-\n-\t  if (newPattern.charAt(index) == '<')\n-\t    d = new Double (nextDouble (d.doubleValue()));\n-\n-\t  limitVec.addElement(d);\n-\n-\t  // Scan text.\n-\t  ++index;\n-\t  buf.setLength(0);\n-\t  while (index < max)\n-\t    {\n-\t      char c = newPattern.charAt(index);\n-\t      if (c == '\\'' && index < max + 1\n-\t\t  && newPattern.charAt(index + 1) == '\\'')\n-\t\t{\n-\t\t  buf.append(c);\n-\t\t  ++index;\n-\t\t}\n-\t      else if (c == '\\'' && index < max + 2)\n-\t\t{\n-\t\t  buf.append(newPattern.charAt(index + 1));\n-\t\t  index += 2;\n-\t\t}\n-\t      else if (c == '|')\n-\t\tbreak;\n-\t      else\n+  {\n+    // Note: we assume the same kind of quoting rules apply here.\n+    // This isn't explicitly documented.  But for instance we accept\n+    // '#' as a literal hash in a format string.\n+    int index = 0, max = newPattern.length();\n+    Vector stringVec = new Vector ();\n+    Vector limitVec = new Vector ();\n+    StringBuffer buf = new StringBuffer ();\n+    \n+    while (true)\n+      {\n+\t// Find end of double.\n+\tint dstart = index;\n+\twhile (index < max)\n+\t  {\n+\t    char c = newPattern.charAt(index);\n+\t    if (c == '#' || c == '\\u2064' || c == '<')\n+\t      break;\n+\t    ++index;\n+\t  }\n+\t\n+\tif (index == max)\n+\t  throw new IllegalArgumentException (\"unexpected end of text\");\n+\tDouble d = new Double (newPattern.substring(dstart, index));\n+\n+\tif (newPattern.charAt(index) == '<')\n+\t  d = new Double (nextDouble (d.doubleValue()));\n+\n+\tlimitVec.addElement(d);\n+\n+\t// Scan text.\n+\t++index;\n+\tbuf.setLength(0);\n+\twhile (index < max)\n+\t  {\n+\t    char c = newPattern.charAt(index);\n+\t    if (c == '\\'' && index < max + 1\n+\t\t&& newPattern.charAt(index + 1) == '\\'')\n+\t      {\n \t\tbuf.append(c);\n-\t      ++index;\n-\t    }\n-\n-\t  stringVec.addElement(buf.toString());\n-\t  if (index == max)\n-\t    break;\n-\t  ++index;\n-\t}\n-\n-      choiceFormats = new String[stringVec.size()];\n-      stringVec.copyInto(choiceFormats);\n-\n-      choiceLimits = new double[limitVec.size()];\n-      for (int i = 0; i < choiceLimits.length; ++i)\n-\t{\n-\t  Double d = (Double) limitVec.elementAt(i);\n-\t  choiceLimits[i] = d.doubleValue();\n-\t}\n-    }\n-\n+\t\t++index;\n+\t      }\n+\t    else if (c == '\\'' && index < max + 2)\n+\t      {\n+\t\tbuf.append(newPattern.charAt(index + 1));\n+\t\tindex += 2;\n+\t      }\n+\t    else if (c == '|')\n+\t      break;\n+\t    else\n+\t      buf.append(c);\n+\t    ++index;\n+\t  }\n+\n+\tstringVec.addElement(buf.toString());\n+\tif (index == max)\n+\t  break;\n+\t++index;\n+      }\n+\n+    choiceFormats = new String[stringVec.size()];\n+    stringVec.copyInto(choiceFormats);\n+\n+    choiceLimits = new double[limitVec.size()];\n+    for (int i = 0; i < choiceLimits.length; ++i)\n+      {\n+\tDouble d = (Double) limitVec.elementAt(i);\n+\tchoiceLimits[i] = d.doubleValue();\n+      }\n+  }\n+\n+  /**\n+   * This method initializes a new instance of <code>ChoiceFormat</code> that\n+   * generates its range terminator and format string arrays from the\n+   * specified pattern.  This pattern is of the form \n+   * \"term#string|term#string...\".  For example \"1#Sunday|2#Monday|#Tuesday\".\n+   * This is the same pattern type used by the <code>applyPattern</code>\n+   * method.\n+   *\n+   * @param pattern The pattern of terminators and format strings.\n+   *\n+   * @exception IllegalArgumentException If the pattern is not valid\n+   */\n   public ChoiceFormat (String newPattern)\n-    {\n-      super ();\n-      applyPattern (newPattern);\n-    }\n-\n+  {\n+    super ();\n+    applyPattern (newPattern);\n+  }\n+\n+  /**\n+   * This method initializes a new instance of <code>ChoiceFormat</code> that\n+   * will use the specified range terminators and format strings.\n+   *\n+   * @param choiceLimits The array of range terminators\n+   * @param choiceFormats The array of format strings\n+   */\n   public ChoiceFormat (double[] choiceLimits, String[] choiceFormats)\n-    {\n-      super ();\n-      setChoices (choiceLimits, choiceFormats);\n-    }\n-\n-  public Object clone ()\n-    {\n-      return new ChoiceFormat (choiceLimits, choiceFormats);\n-    }\n-\n+  {\n+    super ();\n+    setChoices (choiceLimits, choiceFormats);\n+  }\n+\n+  /**\n+   * This method tests this object for equality with the specified \n+   * object.  This will be true if and only if:\n+   * <ul>\n+   * <li>The specified object is not <code>null</code>.\n+   * <li>The specified object is an instance of <code>ChoiceFormat</code>.\n+   * <li>The termination ranges and format strings are identical to\n+   *     this object's. \n+   * </ul>\n+   *\n+   * @param obj The object to test for equality against.\n+   *\n+   * @return <code>true</code> if the specified object is equal to\n+   * this one, <code>false</code> otherwise. \n+   */\n   public boolean equals (Object obj)\n-    {\n-      if (! (obj instanceof ChoiceFormat))\n-\treturn false;\n-      ChoiceFormat cf = (ChoiceFormat) obj;\n-      if (choiceLimits.length != cf.choiceLimits.length)\n-\treturn false;\n-      for (int i = choiceLimits.length - 1; i >= 0; --i)\n-\t{\n-\t  if (choiceLimits[i] != cf.choiceLimits[i]\n-\t      || !choiceFormats[i].equals(cf.choiceFormats[i]))\n-\t    return false;\n-\t}\n-      return true;\n-    }\n-\n+  {\n+    if (! (obj instanceof ChoiceFormat))\n+      return false;\n+    ChoiceFormat cf = (ChoiceFormat) obj;\n+    if (choiceLimits.length != cf.choiceLimits.length)\n+      return false;\n+    for (int i = choiceLimits.length - 1; i >= 0; --i)\n+      {\n+\tif (choiceLimits[i] != cf.choiceLimits[i]\n+\t    || !choiceFormats[i].equals(cf.choiceFormats[i]))\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n+  /**\n+   * This method appends the appropriate format string to the specified\n+   * <code>StringBuffer</code> based on the supplied <code>long</code>\n+   * argument.\n+   *\n+   * @param number The number used for determine (based on the range\n+   *               terminators) which format string to append. \n+   * @param sb The <code>StringBuffer</code> to append the format string to.\n+   * @param status Unused.\n+   *\n+   * @return The <code>StringBuffer</code> with the format string appended.\n+   */\n   public StringBuffer format (long num, StringBuffer appendBuf,\n \t\t\t      FieldPosition pos)\n-    {\n-      return format ((double) num, appendBuf, pos);\n-    }\n-\n+  {\n+    return format ((double) num, appendBuf, pos);\n+  }\n+\n+  /**\n+   * This method appends the appropriate format string to the specified\n+   * <code>StringBuffer</code> based on the supplied <code>double</code>\n+   * argument.\n+   *\n+   * @param number The number used for determine (based on the range\n+   *               terminators) which format string to append. \n+   * @param sb The <code>StringBuffer</code> to append the format string to.\n+   * @param status Unused.\n+   *\n+   * @return The <code>StringBuffer</code> with the format string appended.\n+   */\n   public StringBuffer format (double num, StringBuffer appendBuf,\n \t\t\t      FieldPosition pos)\n-    {\n-      if (choiceLimits.length == 0)\n-\treturn appendBuf;\n-\n-      int index =  0;\n-      if (! Double.isNaN(num) && num >= choiceLimits[0])\n-\t{\n-\t  for (; index < choiceLimits.length - 1; ++index)\n-\t    {\n-\t      if (choiceLimits[index] <= num\n-\t\t  && index != choiceLimits.length - 2\n-\t\t  && num < choiceLimits[index + 1])\n-\t\tbreak;\n-\t    }\n-\t}\n-\n-      return appendBuf.append(choiceFormats[index]);\n-    }\n-\n+  {\n+    if (choiceLimits.length == 0)\n+      return appendBuf;\n+\n+    int index =  0;\n+    if (! Double.isNaN(num) && num >= choiceLimits[0])\n+      {\n+\tfor (; index < choiceLimits.length - 1; ++index)\n+\t  {\n+\t    if (choiceLimits[index] <= num\n+\t\t&& index != choiceLimits.length - 2\n+\t\t&& num < choiceLimits[index + 1])\n+\t      break;\n+\t  }\n+      }\n+\n+    return appendBuf.append(choiceFormats[index]);\n+  }\n+\n+  /**\n+   * This method returns the list of format strings in use.\n+   *\n+   * @return The list of format objects.\n+   */\n   public Object[] getFormats ()\n-    {\n-      return (Object[]) choiceFormats.clone();\n-    }\n-\n+  {\n+    return (Object[]) choiceFormats.clone();\n+  }\n+\n+  /**\n+   * This method returns the list of range terminators in use.\n+   *\n+   * @return The list of range terminators.\n+   */\n   public double[] getLimits ()\n-    {\n-      return (double[]) choiceLimits.clone();\n-    }\n-\n+  {\n+    return (double[]) choiceLimits.clone();\n+  }\n+\n+  /**\n+   * This method returns a hash value for this object\n+   * \n+   * @return A hash value for this object.\n+   */\n   public int hashCode ()\n-    {\n-      int hash = 0;\n-      for (int i = 0; i < choiceLimits.length; ++i)\n-\t{\n-\t  long v = Double.doubleToLongBits(choiceLimits[i]);\n-\t  hash ^= (v ^ (v >>> 32));\n-\t  hash ^= choiceFormats[i].hashCode();\n-\t}\n-      return hash;\n-    }\n-\n+  {\n+    int hash = 0;\n+    for (int i = 0; i < choiceLimits.length; ++i)\n+      {\n+\tlong v = Double.doubleToLongBits(choiceLimits[i]);\n+\thash ^= (v ^ (v >>> 32));\n+\thash ^= choiceFormats[i].hashCode();\n+      }\n+    return hash;\n+  }\n+\n+  /**\n+   * This method returns the lowest possible double greater than the \n+   * specified double.  If the specified double value is equal to\n+   * <code>Double.NaN</code> then that is the value returned.\n+   *\n+   * @param d The specified double\n+   *\n+   * @return The lowest double value greater than the specified double.\n+   */\n   public static final double nextDouble (double d)\n-    {\n-      return nextDouble (d, true);\n-    }\n-\n+  {\n+    return nextDouble (d, true);\n+  }\n+\n+  /**\n+   * This method returns a double that is either the next highest double\n+   * or next lowest double compared to the specified double depending on the\n+   * value of the passed boolean parameter.  If the boolean parameter is\n+   * <code>true</code>, then the lowest possible double greater than the \n+   * specified double will be returned.  Otherwise the highest possible\n+   * double less than the specified double will be returned.\n+   *\n+   * @param d The specified double\n+   * @param positive <code>true</code> to return the next highest\n+   *                 double, <code>false</code> otherwise. \n+   *\n+   * @return The next highest or lowest double value.\n+   */\n   public static double nextDouble (double d, boolean next)\n-    {\n-      if (Double.isInfinite(d) || Double.isNaN(d))\n-\treturn d;\n+  {\n+    if (Double.isInfinite(d) || Double.isNaN(d))\n+      return d;\n \n-      long bits = Double.doubleToLongBits(d);\n+    long bits = Double.doubleToLongBits(d);\n \n-      long mantMask = (1L << mantissaBits) - 1;\n-      long mantissa = bits & mantMask;\n+    long mantMask = (1L << mantissaBits) - 1;\n+    long mantissa = bits & mantMask;\n \n-      long expMask = (1L << exponentBits) - 1;\n-      long exponent = (bits >>> mantissaBits) & expMask;\n+    long expMask = (1L << exponentBits) - 1;\n+    long exponent = (bits >>> mantissaBits) & expMask;\n \n-      if (next ^ (bits < 0)) // Increment magnitude\n-\t{\n-\t  if (mantissa == (1L << mantissaBits) - 1)\n-\t    {\n-\t      mantissa = 0L;\n-\t      exponent++;\n+    if (next ^ (bits < 0)) // Increment magnitude\n+      {\n+\tif (mantissa == (1L << mantissaBits) - 1)\n+\t  {\n+\t    mantissa = 0L;\n+\t    exponent++;\n \t     \n-\t      // Check for absolute overflow.\n-\t      if (exponent >= (1L << mantissaBits))\n-\t\treturn (bits > 0) ? Double.POSITIVE_INFINITY \n-\t\t  : Double.NEGATIVE_INFINITY;\t\t      \n-\t    }\n-\t  else\n-\t    mantissa++;\n-\t}\n-      else // Decrement magnitude\n-\t{\n-\t  if (exponent == 0L && mantissa == 0L)\n-\t    {\n-\t      // The only case where there is a change of sign\n-\t      return next ? Double.MIN_VALUE : -Double.MIN_VALUE;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (mantissa == 0L)\n-\t\t{\n-\t\t  mantissa = (1L << mantissaBits) - 1;\n-\t\t  exponent--;\n-\t\t}\n-\t      else\n-\t\tmantissa--;\n-\t    }\n-\t}\n-\n-      long result = bits < 0 ? 1 : 0;\n-      result = (result << exponentBits) | exponent;\n-      result = (result << mantissaBits) | mantissa;\n-      return Double.longBitsToDouble(result);\n-    }\n-\n+\t    // Check for absolute overflow.\n+\t    if (exponent >= (1L << mantissaBits))\n+\t      return (bits > 0) ? Double.POSITIVE_INFINITY \n+\t\t: Double.NEGATIVE_INFINITY;\t\t      \n+\t  }\n+\telse\n+\t  mantissa++;\n+      }\n+    else // Decrement magnitude\n+      {\n+\tif (exponent == 0L && mantissa == 0L)\n+\t  {\n+\t    // The only case where there is a change of sign\n+\t    return next ? Double.MIN_VALUE : -Double.MIN_VALUE;\n+\t  }\n+\telse\n+\t  {\n+\t    if (mantissa == 0L)\n+\t      {\n+\t\tmantissa = (1L << mantissaBits) - 1;\n+\t\texponent--;\n+\t      }\n+\t    else\n+\t      mantissa--;\n+\t  }\n+      }\n+\n+    long result = bits < 0 ? 1 : 0;\n+    result = (result << exponentBits) | exponent;\n+    result = (result << mantissaBits) | mantissa;\n+    return Double.longBitsToDouble(result);\n+  }\n+\n+  /**\n+   * I'm not sure what this method is really supposed to do, as it is\n+   * not documented.\n+   */\n   public Number parse (String sourceStr, ParsePosition pos)\n-    {\n-      int index = pos.getIndex();\n-      for (int i = 0; i < choiceLimits.length; ++i)\n-\t{\n-\t  if (sourceStr.startsWith(choiceFormats[i], index))\n-\t    {\n-\t      pos.setIndex(index + choiceFormats[i].length());\n-\t      return new Double (choiceLimits[i]);\n-\t    }\n-\t}\n-      pos.setErrorIndex(index);\n-      return new Double (Double.NaN);\n-    }\n-\n+  {\n+    int index = pos.getIndex();\n+    for (int i = 0; i < choiceLimits.length; ++i)\n+      {\n+\tif (sourceStr.startsWith(choiceFormats[i], index))\n+\t  {\n+\t    pos.setIndex(index + choiceFormats[i].length());\n+\t    return new Double (choiceLimits[i]);\n+\t  }\n+      }\n+    pos.setErrorIndex(index);\n+    return new Double (Double.NaN);\n+  }\n+\n+  /**\n+   * This method returns the highest possible double less than the \n+   * specified double.  If the specified double value is equal to\n+   * <code>Double.NaN</code> then that is the value returned.\n+   *\n+   * @param d The specified double\n+   *\n+   * @return The highest double value less than the specified double.\n+   */\n   public static final double previousDouble (double d)\n-    {\n-      return nextDouble (d, false);\n-    }\n-\n+  {\n+    return nextDouble (d, false);\n+  }\n+\n+  /**\n+   * This method sets new range terminators and format strings for this\n+   * object.\n+   *\n+   * @param choiceLimits The new range terminators\n+   * @param choiceFormats The new choice formats\n+   */\n   public void setChoices (double[] choiceLimits, String[] choiceFormats)\n-    {\n-      if (choiceLimits == null || choiceFormats == null)\n-\tthrow new NullPointerException ();\n-      if (choiceLimits.length != choiceFormats.length)\n-\tthrow new IllegalArgumentException ();\n-      this.choiceFormats = (String[]) choiceFormats.clone();\n-      this.choiceLimits = (double[]) choiceLimits.clone();\n-    }\n+  {\n+    if (choiceLimits == null || choiceFormats == null)\n+      throw new NullPointerException ();\n+    if (choiceLimits.length != choiceFormats.length)\n+      throw new IllegalArgumentException ();\n+    this.choiceFormats = (String[]) choiceFormats.clone();\n+    this.choiceLimits = (double[]) choiceLimits.clone();\n+  }\n \n   private final void quoteString (StringBuffer dest, String text)\n-    {\n-      int max = text.length();\n-      for (int i = 0; i < max; ++i)\n-\t{\n-\t  char c = text.charAt(i);\n-\t  if (c == '\\'')\n-\t    {\n-\t      dest.append(c);\n-\t      dest.append(c);\n-\t    }\n-\t  else if (c == '#' || c == '|' || c == '\\u2064' || c == '<')\n-\t    {\n-\t      dest.append('\\'');\n-\t      dest.append(c);\n-\t      dest.append('\\'');\n-\t    }\n-\t  else\n+  {\n+    int max = text.length();\n+    for (int i = 0; i < max; ++i)\n+      {\n+\tchar c = text.charAt(i);\n+\tif (c == '\\'')\n+\t  {\n \t    dest.append(c);\n-\t}\n-    }\n-\n+\t    dest.append(c);\n+\t  }\n+\telse if (c == '#' || c == '|' || c == '\\u2064' || c == '<')\n+\t  {\n+\t    dest.append('\\'');\n+\t    dest.append(c);\n+\t    dest.append('\\'');\n+\t  }\n+\telse\n+\t  dest.append(c);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the range terminator list and format string list\n+   * as a <code>String</code> suitable for using with the \n+   * <code>applyPattern</code> method.\n+   *\n+   * @return A pattern string for this object\n+   */\n   public String toPattern ()\n-    {\n-      StringBuffer result = new StringBuffer ();\n-      for (int i = 0; i < choiceLimits.length; ++i)\n-\t{\n-\t  result.append(choiceLimits[i]);\n-\t  result.append('#');\n-\t  quoteString (result, choiceFormats[i]);\n-\t}\n-      return result.toString();\n-    }\n-\n-  // Formats and limits.\n+  {\n+    StringBuffer result = new StringBuffer ();\n+    for (int i = 0; i < choiceLimits.length; ++i)\n+      {\n+\tresult.append(choiceLimits[i]);\n+\tresult.append('#');\n+\tquoteString (result, choiceFormats[i]);\n+      }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * This is the list of format strings.  Note that this variable is\n+   * specified by the serialization spec of this class.\n+   */\n   private String[] choiceFormats;\n+\n+  /**\n+   * This is the list of range terminator values.  Note that this variable is\n+   * specified by the serialization spec of this class.\n+   */\n   private double[] choiceLimits;\n \n   // Number of mantissa bits in double."}, {"sha": "51a053dcf18fead3a304e9c2fc5589844fd9687c", "filename": "libjava/java/text/Collator.java", "status": "modified", "additions": 260, "deletions": 17, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCollator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,12 +1,29 @@\n-// Collator.java - Locale-sensitive string comparison.\n+/* Collator.java -- Perform locale dependent String comparisons.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n@@ -16,38 +33,157 @@\n import java.util.Comparator;\n \n /**\n+ * This class is the abstract superclass of classes which perform \n+ * locale dependent <code>String</code> comparisons.  A caller requests\n+ * an instance of <code>Collator</code> for a particular locale using\n+ * the <code>getInstance()</code> static method in this class.  That method\n+ * will return a locale specific subclass of <code>Collator</code> which\n+ * can be used to perform <code>String</code> comparisons for that locale.\n+ * If a subclass of <code>Collator</code> cannot be located for a particular\n+ * locale, a default instance for the current locale will be returned.  \n+ *\n+ * In addition to setting the correct locale, there are two additional\n+ * settings that can be adjusted to affect <code>String</code> comparisons:\n+ * strength and decomposition.  The strength value determines the level\n+ * of signficance of character differences required for them to sort\n+ * differently.  (For example, whether or not capital letters are considered\n+ * different from lower case letters).  The decomposition value affects how\n+ * variants of the same character are treated for sorting purposes.  (For\n+ * example, whether or not an accent is signficant or not).  These settings\n+ * are described in detail in the documentation for the methods and values\n+ * that are related to them.\n+ *\n  * @author Tom Tromey <tromey@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date March 18, 1999\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 from http://www.javasoft.com.\n  * Status: Mostly complete, but parts stubbed out.  Look for FIXME.\n  */\n-\n public abstract class Collator implements Comparator, Cloneable\n {\n-  public static final int NO_DECOMPOSITION = 0;\n-  public static final int CANONICAL_DECOMPOSITION = 1;\n-  public static final int FULL_DECOMPOSITION = 2;\n-\n+  /**\n+   * This constant is a strength value which indicates that only primary\n+   * differences between characters will be considered signficant.  As an\n+   * example, two completely different English letters such as 'a' and 'b'\n+   * are considered to have a primary difference.\n+   */\n   public static final int PRIMARY = 0;\n+  \n+  /**\n+   * This constant is a strength value which indicates that only secondary\n+   * or primary differences between characters will be considered\n+   * significant.  An example of a secondary difference between characters\n+   * are instances of the same letter with different accented forms.\n+   */\n   public static final int SECONDARY = 1;\n+  \n+  /**\n+   * This constant is a strength value which indicates that tertiary,\n+   * secondary, and primary differences will be considered during sorting.\n+   * An example of a tertiary difference is capitalization of a given letter.\n+   * This is the default value for the strength setting.\n+   */\n   public static final int TERTIARY = 2;\n+  \n+  /**\n+   * This constant is a strength value which indicates that any difference\n+   * at all between character values are considered significant.\n+   */\n   public static final int IDENTICAL = 3;\n+  \n+  /**\n+   * This constant indicates that accented characters won't be decomposed\n+   * when performing comparisons.  This will yield the fastest results, but\n+   * will only work correctly in call cases for languages which do not\n+   * use accents such as English.\n+   */\n+  public static final int NO_DECOMPOSITION = 0;\n+  \n+  /**\n+   * This constant indicates that only characters which are canonical variants\n+   * in Unicode 2.0 will be decomposed prior to performing comparisons.  This\n+   * will cause accented languages to be sorted correctly.  This is the\n+   * default decomposition value.\n+   */\n+  public static final int CANONICAL_DECOMPOSITION = 1;\n+  \n+  /**\n+   * This constant indicates that both canonical variants and compatibility\n+   * variants in Unicode 2.0 will be decomposed prior to performing\n+   * comparisons.  This is the slowest mode, but is required to get the\n+   * correct sorting for certain languages with certain special formats.\n+   */\n+  public static final int FULL_DECOMPOSITION = 2;\n \n+  /**\n+   * This method initializes a new instance of <code>Collator</code> to have\n+   * the default strength (TERTIARY) and decomposition \n+   * (CANONICAL_DECOMPOSITION) settings.  This constructor is protected and\n+   * is for use by subclasses only.  Non-subclass callers should use the\n+   * static <code>getInstance()</code> methods of this class to instantiate\n+   * <code>Collation</code> objects for the desired locale.\n+   */\n   protected Collator ()\n   {\n     strength = TERTIARY;\n     decmp = CANONICAL_DECOMPOSITION;\n   }\n \n+  /**\n+   * This method compares the two <code>String</code>'s and returns an\n+   * integer indicating whether or not the first argument is less than,\n+   * equal to, or greater than the second argument.  The comparison is\n+   * performed according to the rules of the locale for this \n+   * <code>Collator</code> and the strength and decomposition rules in\n+   * effect.\n+   *\n+   * @param str1 The first object to compare\n+   * @param str2 The second object to compare\n+   *\n+   * @return A negative integer if str1 < str2, 0 if str1 == str2, or\n+   * a positive integer if str1 > str2. \n+   */\n   public abstract int compare (String source, String target);\n \n+  /**\n+   * This method compares the two <code>Object</code>'s and returns an\n+   * integer indicating whether or not the first argument is less than,\n+   * equal to, or greater than the second argument.  These two objects\n+   * must be <code>String</code>'s or an exception will be thrown.\n+   *\n+   * @param obj1 The first object to compare\n+   * @param obj2 The second object to compare\n+   *\n+   * @return A negative integer if obj1 < obj2, 0 if obj1 == obj2, or\n+   * a positive integer if obj1 > obj2. \n+   *\n+   * @exception ClassCastException If the arguments are not instances\n+   * of <code>String</code>. \n+   */\n   public int compare (Object o1, Object o2)\n   {\n     return compare ((String) o1, (String) o2);\n   }\n \n+  /**\n+   * This method tests the specified object for equality against this\n+   * object.  This will be true if and only if the following conditions are\n+   * met:\n+   * <ul>\n+   * <li>The specified object is not <code>null</code>.\n+   * <li>The specified object is an instance of <code>Collator</code>.\n+   * <li>The specified object has the same strength and decomposition\n+   * settings as this object.\n+   * </ul>\n+   *\n+   * @param obj The <code>Object</code> to test for equality against\n+   *            this object. \n+   *\n+   * @return <code>true</code> if the specified object is equal to\n+   * this one, <code>false</code> otherwise.\n+   */\n   public boolean equals (Object obj)\n   {\n     if (! (obj instanceof Collator))\n@@ -56,42 +192,108 @@ public boolean equals (Object obj)\n     return decmp == c.decmp && strength == c.strength;\n   }\n \n+  /**\n+   * This method tests whether the specified <code>String</code>'s are equal\n+   * according to the collation rules for the locale of this object and\n+   * the current strength and decomposition settings.\n+   *\n+   * @param str1 The first <code>String</code> to compare\n+   * @param str2 The second <code>String</code> to compare\n+   *\n+   * @return <code>true</code> if the two strings are equal,\n+   * <code>false</code> otherwise. \n+   */\n   public boolean equals (String source, String target)\n   {\n     return compare (source, target) == 0;\n   }\n \n+  /**\n+   * This method returns a copy of this <code>Collator</code> object.\n+   *\n+   * @return A duplicate of this object.\n+   */\n   public Object clone ()\n   {\n-    return super.clone ();\n+    try\n+      {\n+\treturn super.clone ();\n+      }\n+    catch (CloneNotSupportedException _)\n+      {\n+\treturn null;\n+      }\n   }\n \n+  /**\n+   * This method returns an array of <code>Locale</code> objects which is\n+   * the list of locales for which <code>Collator</code> objects exist.\n+   *\n+   * @return The list of locales for which <code>Collator</code>'s exist.\n+   */\n   public static synchronized Locale[] getAvailableLocales ()\n   {\n-    // FIXME.\n-    return null;\n+    // FIXME\n+    Locale[] l = new Locale[1];\n+    l[0] = Locale.US;\n+    return l;\n   }\n \n+  /**\n+   * This method transforms the specified <code>String</code> into a\n+   * <code>CollationKey</code> for faster comparisons.  This is useful when\n+   * comparisons against a string might be performed multiple times, such\n+   * as during a sort operation.\n+   *\n+   * @param str The <code>String</code> to convert.\n+   *\n+   * @return A <code>CollationKey</code> for the specified <code>String</code>.\n+   */\n   public abstract CollationKey getCollationKey (String source);\n \n+  /**\n+   * This method returns the current decomposition setting for this\n+   * object.  This * will be one of NO_DECOMPOSITION,\n+   * CANONICAL_DECOMPOSITION, or * FULL_DECOMPOSITION.  See the\n+   * documentation for those constants for an * explanation of this\n+   * setting.\n+   *\n+   * @return The current decomposition setting.\n+   */\n   public synchronized int getDecomposition ()\n   {\n     return decmp;\n   }\n \n+  /**\n+   * This method returns an instance of <code>Collator</code> for the\n+   * default locale.\n+   *\n+   * @return A <code>Collator</code> for the default locale.\n+   */\n   public static Collator getInstance ()\n   {\n     return getInstance (Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>Collator</code> for the\n+   * specified locale.  If no <code>Collator</code> exists for the desired\n+   * locale, a <code>Collator</code> for the default locale will be returned.\n+   *\n+   * @param locale The desired localed to load a <code>Collator</code> for.\n+   *\n+   * @return A <code>Collator</code> for the requested locale\n+   */\n   public static Collator getInstance (Locale loc)\n   {\n     ResourceBundle res;\n     String pattern;\n     try\n       {\n-\tres = ResourceBundle.getBundle(\"gnu.gcj.text.LocaleData\", loc);\n-\tpattern = res.getString(\"collatorRule\");\n+\tres = ResourceBundle.getBundle(\"gnu.java.locale.LocaleInformation\",\n+\t\t\t\t       loc);\n+\tpattern = res.getString(\"collation_rules\");\n       }\n     catch (MissingResourceException x)\n       {\n@@ -107,13 +309,37 @@ public static Collator getInstance (Locale loc)\n       }\n   }\n \n+  /**\n+   * This method returns the current strength setting for this object.  This\n+   * will be one of PRIMARY, SECONDARY, TERTIARY, or IDENTICAL.  See the\n+   * documentation for those constants for an explanation of this setting.\n+   *\n+   * @return The current strength setting.\n+   */\n   public synchronized int getStrength ()\n   {\n     return strength;\n   }\n \n+  /**\n+   * This method returns a hash code value for this object.\n+   *\n+   * @return A hash value for this object.\n+   */\n   public abstract int hashCode ();\n \n+  /**\n+   * This method sets the decomposition setting for this object to the\n+   * specified value.  This must be one of NO_DECOMPOSITION,\n+   * CANONICAL_DECOMPOSITION, or FULL_DECOMPOSITION.  Otherwise an\n+   * exception will be thrown.  See the documentation for those\n+   * contants for an explanation of this setting.\n+   *\n+   * @param decmp The new decomposition setting.\n+   *\n+   * @exception IllegalArgumentException If the requested\n+   * decomposition setting is not valid.\n+   */\n   public synchronized void setDecomposition (int mode)\n   {\n     if (mode != NO_DECOMPOSITION\n@@ -123,6 +349,17 @@ public synchronized void setDecomposition (int mode)\n     decmp = mode;\n   }\n \n+  /**\n+   * This method sets the strength setting for this object to the specified\n+   * value.  This must be one of PRIMARY, SECONDARY, TERTIARY, or IDENTICAL.\n+   * Otherwise an exception is thrown. See the documentation for these\n+   * constants for an explanation of this setting.\n+   * \n+   * @param strength The new strength setting.\n+   *\n+   * @exception IllegalArgumentException If the requested strength\n+   * setting value is not valid.\n+   */\n   public synchronized void setStrength (int strength)\n   {\n     if (strength != PRIMARY && strength != SECONDARY\n@@ -134,7 +371,13 @@ public synchronized void setStrength (int strength)\n   // Decompose a single character and append results to the buffer.\n   native final void decomposeCharacter (char c, StringBuffer buf);\n \n-  // These names are fixed by the serialization spec.\n+  /**\n+   * This is the current collation decomposition setting.\n+   */\n   int decmp;\n+\n+  /**\n+   * This is the current collation strength setting.\n+   */\n   int strength;\n }"}, {"sha": "0e84f87ac3363a51d531069a386c08cc81c00af2", "filename": "libjava/java/text/DateFormat.java", "status": "modified", "additions": 289, "deletions": 33, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormat.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,10 +1,29 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* DateFormat.java -- Class for formatting/parsing date/times\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n@@ -25,35 +44,60 @@ public abstract class DateFormat extends Format implements Cloneable\n   protected NumberFormat numberFormat;\n \n   // (Values determined using a test program.)\n-  public final static int FULL = 0;\n-  public final static int LONG = 1;\n-  public final static int MEDIUM = 2;\n-  public final static int SHORT = 3;\n-  public final static int DEFAULT = MEDIUM;\n-\n-  public final static int ERA_FIELD = 0;\n-  public final static int YEAR_FIELD = 1;\n-  public final static int MONTH_FIELD = 2;\n-  public final static int DATE_FIELD = 3;\n-  public final static int HOUR_OF_DAY1_FIELD = 4;\n-  public final static int HOUR_OF_DAY0_FIELD = 5;\n-  public final static int MINUTE_FIELD = 6;\n-  public final static int SECOND_FIELD = 7;\n-  public final static int MILLISECOND_FIELD = 8;\n-  public final static int DAY_OF_WEEK_FIELD = 9;\n-  public final static int DAY_OF_YEAR_FIELD = 10;\n-  public final static int DAY_OF_WEEK_IN_MONTH_FIELD = 11;\n-  public final static int WEEK_OF_YEAR_FIELD = 12;\n-  public final static int WEEK_OF_MONTH_FIELD = 13;\n-  public final static int AM_PM_FIELD = 14;\n-  public final static int HOUR1_FIELD = 15;\n-  public final static int HOUR0_FIELD = 16;\n-  public final static int TIMEZONE_FIELD = 17;\n-\n+  public static final int FULL = 0;\n+  public static final int LONG = 1;\n+  public static final int MEDIUM = 2;\n+  public static final int SHORT = 3;\n+  public static final int DEFAULT = MEDIUM;\n+\n+  /* These constants need to have these exact values.  They\n+   * correspond to index positions within the localPatternChars\n+   * string for a given locale.  For example, the US locale uses\n+   * the string \"GyMdkHmsSEDFwWahKz\", where 'G' is the character\n+   * for era, 'y' for year, and so on down to 'z' for time zone.\n+   */\n+  public static final int ERA_FIELD = 0;\n+  public static final int YEAR_FIELD = 1;\n+  public static final int MONTH_FIELD = 2;\n+  public static final int DATE_FIELD = 3;\n+  public static final int HOUR_OF_DAY1_FIELD = 4;\n+  public static final int HOUR_OF_DAY0_FIELD = 5;\n+  public static final int MINUTE_FIELD = 6;\n+  public static final int SECOND_FIELD = 7;\n+  public static final int MILLISECOND_FIELD = 8;\n+  public static final int DAY_OF_WEEK_FIELD = 9;\n+  public static final int DAY_OF_YEAR_FIELD = 10;\n+  public static final int DAY_OF_WEEK_IN_MONTH_FIELD = 11;\n+  public static final int WEEK_OF_YEAR_FIELD = 12;\n+  public static final int WEEK_OF_MONTH_FIELD = 13;\n+  public static final int AM_PM_FIELD = 14;\n+  public static final int HOUR1_FIELD = 15;\n+  public static final int HOUR0_FIELD = 16;\n+  public static final int TIMEZONE_FIELD = 17;\n+\n+  /**\n+   * This method initializes a new instance of <code>DateFormat</code>.\n+   */\n   protected DateFormat ()\n   {\n   }\n \n+  /**\n+   * This method tests this object for equality against the specified object.\n+   * The two objects will be considered equal if an only if the specified\n+   * object:\n+   * <P>\n+   * <ul>\n+   * <li>Is not <code>null</code>.\n+   * <li>Is an instance of <code>DateFormat</code>.\n+   * <li>Has the same calendar and numberFormat field values as this object.\n+   * </ul>\n+   *\n+   * @param obj The object to test for equality against.\n+   * \n+   * @return <code>true</code> if the specified object is equal to this object,\n+   * <code>false</code> otherwise.\n+   */\n   public boolean equals (Object obj)\n   {\n     if (! (obj instanceof DateFormat))\n@@ -62,35 +106,89 @@ public boolean equals (Object obj)\n     return calendar.equals(d.calendar) && numberFormat.equals(d.numberFormat);\n   }\n \n+  /**\n+   * This method returns a copy of this object.\n+   *\n+   * @return A copy of this object.\n+   */\n   public Object clone ()\n   {\n     // We know the superclass just call's Object's generic cloner.\n     return super.clone ();\n   }\n \n+  /**\n+   * This method formats the specified <code>Object</code> into a date string\n+   * and appends it to the specified <code>StringBuffer</code>.\n+   * The specified object must be an instance of <code>Number</code> or\n+   * <code>Date</code> or an <code>IllegalArgumentException</code> will be\n+   * thrown.\n+   *\n+   * @param obj The <code>Object</code> to format.\n+   * @param toAppendTo The <code>StringBuffer</code> to append the resultant\n+   * <code>String</code> to.\n+   * @param fieldPosition Is updated to the start and end index of the\n+   * specified field.\n+   *\n+   * @return The <code>StringBuffer</code> supplied on input, with the\n+   * formatted date/time appended.\n+   */\n   public final StringBuffer format (Object obj,\n \t\t\t\t    StringBuffer buf, FieldPosition pos)\n   {\n     if (obj instanceof Number)\n-      return format (new Date(((Number) obj).longValue()), buf, pos);\n+      obj = new Date(((Number) obj).longValue());\n     return format ((Date) obj, buf, pos);\n   }\n \n+  /**  \n+    * Formats the date argument according to the pattern specified. \n+    *\n+    * @param date The formatted date.\n+    */\n   public final String format (Date date)\n   {\n     StringBuffer sb = new StringBuffer ();\n     format (date, sb, new FieldPosition (MONTH_FIELD));\n     return sb.toString();\n   }\n \n+  /**\n+   * This method formats a <code>Date</code> into a string and appends it\n+   * to the specified <code>StringBuffer</code>.\n+   *\n+   * @param date The <code>Date</code> value to format.\n+   * @param toAppendTo The <code>StringBuffer</code> to append the resultant\n+   * <code>String</code> to.\n+   * @param fieldPosition Is updated to the start and end index of the\n+   * specified field.\n+   *\n+   * @return The <code>StringBuffer</code> supplied on input, with the\n+   * formatted date/time appended.\n+   */\n   public abstract StringBuffer format (Date date,\n \t\t\t\t       StringBuffer buf, FieldPosition pos);\n \n+  /**\n+   * This method returns a list of available locales supported by this\n+   * class.\n+   */\n   public static Locale[] getAvailableLocales ()\n   {\n-    return null;\t\t// FIXME\n+    // FIXME\n+    Locale[] l = new Locale[1];\n+    l[0] = Locale.US;\n+    return l;\n   }\n \n+  /**\n+    * This method returns the <code>Calendar</code> object being used by\n+    * this object to parse/format datetimes.\n+    *\n+    * @return The <code>Calendar</code> being used by this object.\n+    *\n+    * @see java.util.Calendar\n+    */\n   public Calendar getCalendar ()\n   {\n     return calendar;\n@@ -112,7 +210,8 @@ private static final DateFormat computeInstance (int dateStyle,\n     ResourceBundle res;\n     try\n       {\n-\tres = ResourceBundle.getBundle(\"gnu.gcj.text.LocaleData\", loc);\n+\tres = ResourceBundle.getBundle(\"gnu.java.locale.LocaleInformation\",\n+\t\t\t\t       loc);\n       }\n     catch (MissingResourceException x)\n       {\n@@ -199,70 +298,162 @@ private static final DateFormat computeInstance (int dateStyle,\n     return new SimpleDateFormat (pattern, loc);\n   }\n \n+ /**\n+   * This method returns an instance of <code>DateFormat</code> that will\n+   * format using the default formatting style for dates.\n+   *\n+   * @return A new <code>DateFormat</code> instance.\n+   */\n   public static final DateFormat getDateInstance ()\n   {\n     return getDateInstance (DEFAULT, Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>DateFormat</code> that will\n+   * format using the specified formatting style for dates.\n+   *\n+   * @param style The type of formatting to perform. \n+   * \n+   * @return A new <code>DateFormat</code> instance.\n+   */\n   public static final DateFormat getDateInstance (int style)\n   {\n     return getDateInstance (style, Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>DateFormat</code> that will\n+   * format using the specified formatting style for dates.  The specified\n+   * localed will be used in place of the default.\n+   *\n+   * @param style The type of formatting to perform. \n+   * @param aLocale The desired locale.\n+   * \n+   * @return A new <code>DateFormat</code> instance.\n+   */\n   public static final DateFormat getDateInstance (int style, Locale loc)\n   {\n     return computeInstance (style, loc, true, false);\n   }\n \n+  /**\n+   * This method returns a new instance of <code>DateFormat</code> that\n+   * formats both dates and times using the <code>SHORT</code> style.\n+   *\n+   * @return A new <code>DateFormat</code>instance.\n+   */\n   public static final DateFormat getDateTimeInstance ()\n   {\n     return getDateTimeInstance (DEFAULT, DEFAULT, Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns a new instance of <code>DateFormat</code> that\n+   * formats both dates and times using the <code>DEFAULT</code> style.\n+   *\n+   * @return A new <code>DateFormat</code>instance.\n+   */\n   public static final DateFormat getDateTimeInstance (int dateStyle, \n \t\t\t\t\t\t      int timeStyle)\n   {\n     return getDateTimeInstance (dateStyle, timeStyle, Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns a new instance of <code>DateFormat</code> that\n+   * formats both dates and times using the specified styles.\n+   * \n+   * @param dateStyle The desired style for date formatting.\n+   * @param timeStyle The desired style for time formatting\n+   *\n+   * @return A new <code>DateFormat</code>instance.\n+   */\n   public static final DateFormat getDateTimeInstance (int dateStyle, \n \t\t\t\t\t\t      int timeStyle, \n \t\t\t\t\t\t      Locale loc)\n   {\n     return computeInstance (dateStyle, timeStyle, loc, true, true);\n   }\n \n+  /**\n+   * This method returns a new instance of <code>DateFormat</code> that\n+   * formats both dates and times using the <code>SHORT</code> style.\n+   *\n+   * @return A new <code>DateFormat</code>instance.\n+   */\n   public static final DateFormat getInstance ()\n   {\n     // JCL book says SHORT.\n     return getDateTimeInstance (SHORT, SHORT, Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns the <code>NumberFormat</code> object being used\n+   * by this object to parse/format time values.\n+   *\n+   * @return The <code>NumberFormat</code> in use by this object.\n+   */\n   public NumberFormat getNumberFormat ()\n   {\n     return numberFormat;\n   }\n \n+ /**\n+   * This method returns an instance of <code>DateFormat</code> that will\n+   * format using the default formatting style for times.\n+   *\n+   * @return A new <code>DateFormat</code> instance.\n+   */\n   public static final DateFormat getTimeInstance ()\n   {\n     return getTimeInstance (DEFAULT, Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>DateFormat</code> that will\n+   * format using the specified formatting style for times.\n+   *\n+   * @param style The type of formatting to perform. \n+   * \n+   * @return A new <code>DateFormat</code> instance.\n+   */\n   public static final DateFormat getTimeInstance (int style)\n   {\n     return getTimeInstance (style, Locale.getDefault());\n   }\n \n+  /**\n+   * This method returns an instance of <code>DateFormat</code> that will\n+   * format using the specified formatting style for times.  The specified\n+   * localed will be used in place of the default.\n+   *\n+   * @param style The type of formatting to perform. \n+   * @param aLocale The desired locale.\n+   * \n+   * @return A new <code>DateFormat</code> instance.\n+   */\n   public static final DateFormat getTimeInstance (int style, Locale loc)\n   {\n     return computeInstance (style, loc, false, true);\n   }\n \n+  /**\n+   * This method returns the <code>TimeZone</code> object being used by\n+   * this instance.\n+   *\n+   * @return The time zone in use.\n+   */\n   public TimeZone getTimeZone ()\n   {\n     return calendar.getTimeZone();\n   }\n \n+  /**\n+   * This method returns a hash value for this object.\n+   * \n+   * @return A hash value for this object.\n+   */\n   public int hashCode ()\n   {\n     int hash = calendar.hashCode();\n@@ -271,11 +462,25 @@ public int hashCode ()\n     return hash;\n   }\n \n+  /**\n+   * This method indicates whether or not the parsing of date and time\n+   * values should be done in a lenient value.\n+   *\n+   * @return <code>true</code> if date/time parsing is lenient,\n+   * <code>false</code> otherwise.\n+   */\n   public boolean isLenient ()\n   {\n     return calendar.isLenient();\n   }\n \n+  /**\n+   * This method parses the specified date/time string.\n+   *\n+   * @return The resultant date.\n+   *\n+   * @exception ParseException If the specified string cannot be parsed.\n+   */\n   public Date parse (String source) throws ParseException\n   {\n     ParsePosition pos = new ParsePosition(0);\n@@ -290,28 +495,79 @@ public Date parse (String source) throws ParseException\n     return result;\n   }\n \n+  /** \n+   * This method parses the specified <code>String</code> into a \n+   * <code>Date</code>.  The <code>pos</code> argument contains the\n+   * starting parse position on method entry and the ending parse\n+   * position on method exit.\n+   *\n+   * @param text The string to parse.\n+   * @param pos The starting parse position in entry, the ending parse\n+   * position on exit.\n+   *\n+   * @return The parsed date, or <code>null</code> if the string cannot\n+   * be parsed.\n+   */\n   public abstract Date parse (String source, ParsePosition pos);\n \n+  /**\n+   * This method is identical to <code>parse(String, ParsePosition)</code>,\n+   * but returns its result as an <code>Object</code> instead of a\n+   * <code>Date</code>.\n+   * \n+   * @param source The string to parse.\n+   * @param pos The starting parse position in entry, the ending parse\n+   * position on exit.\n+   *\n+   * @return The parsed date, or <code>null</code> if the string cannot\n+   * be parsed.\n+   */\n   public Object parseObject (String source, ParsePosition pos)\n   {\n     return parse(source, pos);\n   }\n \n+  /**\n+   * This method specified the <code>Calendar</code> that should be used \n+   * by this object to parse/format datetimes.\n+   *\n+   * @param The new <code>Calendar</code> for this object.\n+   *\n+   * @see java.util.Calendar\n+   */\n   public void setCalendar (Calendar calendar)\n   {\n     this.calendar = calendar;\n   }\n \n+  /**\n+   * This method specifies whether or not this object should be lenient in \n+   * the syntax it accepts while parsing date/time values.\n+   *\n+   * @param lenient <code>true</code> if parsing should be lenient,\n+   * <code>false</code> otherwise.\n+   */\n   public void setLenient (boolean lenient)\n   {\n     calendar.setLenient(lenient);\n   }\n \n+  /**\n+   * This method specifies the <code>NumberFormat</code> object that should\n+   * be used by this object to parse/format times.\n+   *\n+   * @param The <code>NumberFormat</code> in use by this object.\n+   */\n   public void setNumberFormat (NumberFormat numberFormat)\n   {\n     this.numberFormat = numberFormat;\n   }\n \n+  /**\n+   * This method sets the time zone that should be used by this object.\n+   *\n+   * @param The new time zone.\n+   */\n   public void setTimeZone (TimeZone timeZone)\n   {\n     calendar.setTimeZone(timeZone);"}, {"sha": "4f45a4dbfbdda951f522111b346807edcdb49772", "filename": "libjava/java/text/DateFormatSymbols.java", "status": "modified", "additions": 262, "deletions": 119, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -13,16 +13,15 @@\n import java.util.ResourceBundle;\n \n /**\n+ * This class acts as container for locale specific date/time formatting\n+ * information such as the days of the week and the months of the year.\n  * @author Per Bothner <bothner@cygnus.com>\n  * @date October 24, 1998.\n  */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3.\n  * Status:  Believed complete and correct.\n  */\n-\n-public class DateFormatSymbols extends Object\n-  implements java.io.Serializable, Cloneable\n+public class DateFormatSymbols implements java.io.Serializable, Cloneable\n {\n   String[] ampms;\n   String[] eras;\n@@ -36,63 +35,9 @@ public class DateFormatSymbols extends Object\n   private static final long serialVersionUID = -5987973545549424702L;\n \n   // The order of these prefixes must be the same as in DateFormat\n-  // FIXME: XXX: Note that this differs from the Classpath implemention\n-  // in that there is no \"default\" entry; that is due to differing\n-  // implementations where DateFormat.DEFAULT is MEDIUM here but 4 in\n-  // Classpath (the JCL says it should be MEDIUM).  That will need to be \n-  // resolved in the merge.\n-  private static final String[] formatPrefixes = { \"full\", \"long\", \"medium\", \"short\" };\n-\n-  private static final String[] ampmsDefault = {\"AM\", \"PM\" };\n-  private static final String[] erasDefault = {\"BC\", \"AD\" };\n-  // localPatternCharsDefault is used by SimpleDateFormat.\n-  private static final String localPatternCharsDefault\n-    = \"GyMdkHmsSEDFwWahKz\";\n-  private static final String[] monthsDefault = {\n-    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n-    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\"\n-  };\n-  private static final String[] shortMonthsDefault = {\n-    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n-    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\"\n-  };\n-  private static final String[] shortWeekdaysDefault = {\n-    \"\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n-  };\n-  private static final String[] weekdaysDefault = {\n-    \"\", \"Sunday\", \"Monday\", \"Tuesday\",\n-    \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n-  };\n-\n-  private static String[][] zoneStringsDefault = {\n-    { \"GMT\", \"Greenwich Mean Time\", \"GMT\",\n-      /**/   \"Greenwich Mean Time\", \"GMT\", \"GMT\" },\n-    { \"PST\", \"Pacific Standard Time\", \"PST\",\n-      /**/   \"Pacific Daylight Time\", \"PDT\", \"San Francisco\" },\n-    { \"MST\", \"Mountain Standard Time\", \"MST\",\n-      /**/   \"Mountain Daylight Time\", \"MDT\", \"Denver\" },\n-    { \"PNT\", \"Mountain Standard Time\", \"MST\",\n-      /**/   \"Mountain Standard Time\", \"MST\", \"Phoenix\" },\n-    { \"CST\", \"Central Standard Time\", \"CST\",\n-      /**/   \"Central Daylight Time\", \"CDT\", \"Chicago\" },\n-    { \"EST\", \"Eastern Standard Time\", \"EST\",\n-      /**/   \"Eastern Daylight Time\", \"EDT\", \"Boston\" },\n-    { \"IET\", \"Eastern Standard Time\", \"EST\",\n-      /**/   \"Eastern Standard Time\", \"EST\", \"Indianapolis\" },\n-    { \"PRT\", \"Atlantic Standard Time\", \"AST\",\n-      /**/   \"Atlantic Daylight Time\", \"ADT\", \"Halifax\" },\n-    { \"CNT\", \"Newfoundland Standard Time\", \"NST\",\n-      /**/   \"Newfoundland Daylight Time\", \"NDT\", \"St. Johns\" },\n-    { \"ECT\", \"Central European Standard Time\", \"CET\",\n-      /**/   \"Central European Daylight Time\", \"CEST\", \"Paris\" },\n-    { \"CTT\", \"China Standard Time\", \"CST\",\n-      /**/   \"China Standard Time\", \"CST\", \"Shanghai\" },\n-    { \"JST\", \"Japan Standard Time\", \"JST\",\n-      /**/   \"Japan Standard Time\", \"JST\", \"Tokyo\" },\n-    { \"HST\", \"Hawaii Standard Time\", \"HST\",\n-      /**/   \"Hawaii Standard Time\", \"HST\", \"Honolulu\" },\n-    { \"AST\", \"Alaska Standard Time\", \"AKST\",\n-      /**/   \"Alaska Daylight Time\", \"AKDT\", \"Anchorage\" }\n+  private static final String[] formatPrefixes =\n+  {\n+    \"full\", \"long\", \"medium\", \"short\"\n   };\n \n   // These are each arrays with a value for SHORT, MEDIUM, LONG, FULL,\n@@ -113,146 +58,312 @@ private String[] formatsForKey(ResourceBundle res, String key)\n     return values;\n   }\n \n-  private final Object safeGetResource (ResourceBundle res,\n-\t\t\t\t\tString key, Object def)\n-  {\n-    if (res != null)\n-      {\n-\ttry\n-\t  {\n-\t    return res.getObject(key);\n-\t  }\n-\tcatch (MissingResourceException x)\n-\t  {\n-\t  }\n-      }\n-    return def;\n-  }\n-\n-  public DateFormatSymbols (Locale locale)\n+  /**\n+   * This method initializes a new instance of <code>DateFormatSymbols</code>\n+   * by loading the date format information for the specified locale.\n+   *\n+   * @param locale The locale for which date formatting symbols should\n+   *               be loaded. \n+   */\n+  public DateFormatSymbols (Locale locale) throws MissingResourceException\n   {\n-    ResourceBundle res;\n-    try\n-      {\n-\tres = ResourceBundle.getBundle(\"gnu.gcj.text.LocaleData\", locale);\n-      }\n-    catch (MissingResourceException x)\n-      {\n-\tres = null;\n-      }\n-    ampms = (String[]) safeGetResource (res, \"ampm\", ampmsDefault);\n-    eras = (String[]) safeGetResource (res, \"eras\", erasDefault);\n-    localPatternChars = (String) safeGetResource (res, \"datePatternChars\",\n-\t\t\t\t\t\t  localPatternCharsDefault);\n-    months = (String[]) safeGetResource (res, \"months\", monthsDefault);\n-    shortMonths = (String[]) safeGetResource (res, \"shortMonths\",\n-\t\t\t\t\t      shortMonthsDefault);\n-    shortWeekdays = (String[]) safeGetResource (res, \"shortWeekdays\",\n-\t\t\t\t\t\tshortWeekdaysDefault);\n-    weekdays = (String[]) safeGetResource (res, \"weekdays\", weekdaysDefault);\n-    zoneStrings = (String[][]) safeGetResource (res, \"zoneStrings\",\n-\t\t\t\t\t\tzoneStringsDefault);\n+    ResourceBundle res\n+      = ResourceBundle.getBundle(\"gnu.java.locale.LocaleInformation\", locale);\n+\n+    ampms = res.getStringArray (\"ampms\");\n+    eras = res.getStringArray (\"eras\");\n+    localPatternChars = res.getString (\"localPatternChars\");\n+    months = res.getStringArray (\"months\");\n+    shortMonths = res.getStringArray (\"shortMonths\");\n+    shortWeekdays = res.getStringArray (\"shortWeekdays\");\n+    weekdays = res.getStringArray (\"weekdays\");\n+    zoneStrings = (String[][]) res.getObject (\"zoneStrings\");\n \n     dateFormats = formatsForKey(res, \"DateFormat\");\n     timeFormats = formatsForKey(res, \"TimeFormat\");\n   }\n \n-  public DateFormatSymbols ()\n+  /**\n+   * This method loads the format symbol information for the default\n+   * locale.\n+   */\n+  public DateFormatSymbols () throws MissingResourceException\n   {\n     this (Locale.getDefault());\n   }\n \n-  // Copy constructor.\n-  private DateFormatSymbols (DateFormatSymbols old)\n-  {\n-    ampms = old.ampms;\n-    eras = old.eras;\n-    localPatternChars = old.localPatternChars;\n-    months = old.months;\n-    shortMonths = old.shortMonths;\n-    shortWeekdays = old.shortWeekdays;\n-    weekdays = old.weekdays;\n-    zoneStrings = old.zoneStrings;\n-    dateFormats = old.dateFormats;\n-    timeFormats = old.timeFormats;\n-  }\n-\n+  /**\n+   * This method returns the list of strings used for displaying AM or PM.\n+   * This is a two element <code>String</code> array indexed by\n+   * <code>Calendar.AM</code> and <code>Calendar.PM</code>\n+   *\n+   * @return The list of AM/PM display strings.\n+   */\n   public String[] getAmPmStrings()\n   {\n     return ampms;\n   }\n \n+  /**\n+    * This method returns the list of strings used for displaying eras\n+    * (e.g., \"BC\" and \"AD\").  This is a two element <code>String</code>\n+    * array indexed by <code>Calendar.BC</code> and <code>Calendar.AD</code>.\n+    *\n+    * @return The list of era disply strings.\n+    */\n   public String[] getEras()\n   {\n     return eras;\n   }\n \n-\n+  /**\n+    * This method returns the pattern character information for this\n+    * object.  This is an 18 character string that contains the characters\n+    * that are used in creating the date formatting strings in \n+    * <code>SimpleDateFormat</code>.   The following are the character\n+    * positions in the string and which format character they correspond\n+    * to (the character in parentheses is the default value in the US English\n+    * locale):\n+    * <p>\n+    * <ul>\n+    * <li>0 - era (G)\n+    * <li>1 - year (y)\n+    * <li>2 - month (M)\n+    * <li 3 - day of month (d)\n+    * <li>4 - hour out of 12, from 1-12 (h)\n+    * <li>5 - hour out of 24, from 0-23 (H)\n+    * <li>6 - minute (m)\n+    * <li>7 - second (s)\n+    * <li>8 - millisecond (S)\n+    * <li>9 - date of week (E)\n+    * <li>10 - date of year (D)\n+    * <li>11 - day of week in month, eg. \"4th Thur in Nov\" (F)\n+    * <li>12 - week in year (w)\n+    * <li>13 - week in month (W)\n+    * <li>14 - am/pm (a)\n+    * <li>15 - hour out of 24, from 1-24 (k)\n+    * <li>16 - hour out of 12, from 0-11 (K)\n+    * <li>17 - time zone (z)\n+    * </ul>\n+    *\n+    * @return The format patter characters\n+    */\n   public String getLocalPatternChars()\n   {\n     return localPatternChars;\n   }\n \n+  /**\n+   * This method returns the list of strings used for displaying month\n+   * names (e.g., \"January\" and \"February\").  This is a thirteen element\n+   * string array indexed by <code>Calendar.JANUARY</code> through\n+   * <code>Calendar.UNDECEMBER</code>.  Note that there are thirteen\n+   * elements because some calendars have thriteen months.\n+   *\n+   * @return The list of month display strings.\n+   */\n   public String[] getMonths ()\n   {\n     return months;\n   }\n \n+  /**\n+   * This method returns the list of strings used for displaying abbreviated\n+   * month names (e.g., \"Jan\" and \"Feb\").  This is a thirteen element\n+   * <code>String</code> array indexed by <code>Calendar.JANUARY</code>\n+   * through <code>Calendar.UNDECEMBER</code>.  Note that there are thirteen\n+   * elements because some calendars have thirteen months.\n+   *\n+   * @return The list of abbreviated month display strings.\n+   */\n   public String[] getShortMonths ()\n   {\n     return shortMonths;\n   }\n \n+  /**\n+   * This method returns the list of strings used for displaying abbreviated \n+   * weekday names (e.g., \"Sun\" and \"Mon\").  This is an eight element\n+   * <code>String</code> array indexed by <code>Calendar.SUNDAY</code>\n+   * through <code>Calendar.SATURDAY</code>.  Note that the first element\n+   * of this array is ignored.\n+   *\n+   * @return This list of abbreviated weekday display strings.\n+   */\n   public String[] getShortWeekdays ()\n   {\n     return shortWeekdays;\n   }\n \n+  /**\n+   * This method returns the list of strings used for displaying weekday\n+   * names (e.g., \"Sunday\" and \"Monday\").  This is an eight element\n+   * <code>String</code> array indexed by <code>Calendar.SUNDAY</code>\n+   * through <code>Calendar.SATURDAY</code>.  Note that the first element\n+   * of this array is ignored.\n+   *\n+   * @return This list of weekday display strings.\n+   */\n   public String[] getWeekdays ()\n   {\n     return weekdays;\n   }\n \n+  /**\n+   * This method returns this list of localized timezone display strings.\n+   * This is a two dimensional <code>String</code> array where each row in\n+   * the array contains five values:\n+   * <P>\n+   * <ul>\n+   * <li>0 - The non-localized time zone id string.\n+   * <li>1 - The long name of the time zone (standard time).\n+   * <li>2 - The short name of the time zone (standard time).\n+   * <li>3 - The long name of the time zone (daylight savings time).\n+   * <li>4 - the short name of the time zone (daylight savings time).\n+   *\n+   * @return The list of time zone display strings.\n+   */\n   public String[] [] getZoneStrings ()\n   {\n     return zoneStrings;\n   }\n \n+  /**\n+   * This method sets the list of strings used to display AM/PM values to\n+   * the specified list.\n+   * This is a two element <code>String</code> array indexed by\n+   * <code>Calendar.AM</code> and <code>Calendar.PM</code>\n+   *\n+   * @param ampms The new list of AM/PM display strings.\n+   */\n   public void setAmPmStrings (String[] value)\n   {\n     ampms = value;\n   }\n \n+  /**\n+   * This method sets the list of strings used to display time eras to\n+   * to the specified list.\n+   * This is a two element <code>String</code>\n+   * array indexed by <code>Calendar.BC</code> and <code>Calendar.AD</code>.\n+   *\n+   * @param eras The new list of era disply strings.\n+   */\n   public void setEras (String[] value)\n   {\n     eras = value;\n   }\n \n+  /**\n+    * This method sets the list of characters used to specific date/time\n+    * formatting strings.\n+    * This is an 18 character string that contains the characters\n+    * that are used in creating the date formatting strings in \n+    * <code>SimpleDateFormat</code>.   The following are the character\n+    * positions in the string and which format character they correspond\n+    * to (the character in parentheses is the default value in the US English\n+    * locale):\n+    * <p>\n+    * <ul>\n+    * <li>0 - era (G)\n+    * <li>1 - year (y)\n+    * <li>2 - month (M)\n+    * <li 3 - day of month (d)\n+    * <li>4 - hour out of 12, from 1-12 (h)\n+    * <li>5 - hour out of 24, from 0-23 (H)\n+    * <li>6 - minute (m)\n+    * <li>7 - second (s)\n+    * <li>8 - millisecond (S)\n+    * <li>9 - date of week (E)\n+    * <li>10 - date of year (D)\n+    * <li>11 - day of week in month, eg. \"4th Thur in Nov\" (F)\n+    * <li>12 - week in year (w)\n+    * <li>13 - week in month (W)\n+    * <li>14 - am/pm (a)\n+    * <li>15 - hour out of 24, from 1-24 (k)\n+    * <li>16 - hour out of 12, from 0-11 (K)\n+    * <li>17 - time zone (z)\n+    * </ul>\n+    *\n+    * @param localPatternChars The new format patter characters\n+    */\n   public void setLocalPatternChars (String value)\n   {\n     localPatternChars = value;\n   }\n \n+  /**\n+    * This method sets the list of strings used to display month names.\n+    * This is a thirteen element\n+    * string array indexed by <code>Calendar.JANUARY</code> through\n+    * <code>Calendar.UNDECEMBER</code>.  Note that there are thirteen\n+    * elements because some calendars have thriteen months.\n+    *\n+    * @param months The list of month display strings.\n+    */\n   public void setMonths (String[] value)\n   {\n     months = value;\n   }\n \n+  /**\n+   * This method sets the list of strings used to display abbreviated month\n+   * names.\n+   * This is a thirteen element\n+   * <code>String</code> array indexed by <code>Calendar.JANUARY</code>\n+   * through <code>Calendar.UNDECEMBER</code>.  Note that there are thirteen\n+   * elements because some calendars have thirteen months.\n+   *\n+   * @param shortMonths The new list of abbreviated month display strings.\n+   */\n   public void setShortMonths (String[] value)\n   {\n     shortMonths = value;\n   }\n \n+  /**\n+   * This method sets the list of strings used to display abbreviated\n+   * weekday names.\n+   * This is an eight element\n+   * <code>String</code> array indexed by <code>Calendar.SUNDAY</code>\n+   * through <code>Calendar.SATURDAY</code>.  Note that the first element\n+   * of this array is ignored.\n+   *\n+   * @param shortWeekdays This list of abbreviated weekday display strings.\n+   */\n   public void setShortWeekdays (String[] value)\n   {\n     shortWeekdays = value;\n   }\n \n+  /**\n+   * This method sets the list of strings used to display weekday names.\n+   * This is an eight element\n+   * <code>String</code> array indexed by <code>Calendar.SUNDAY</code>\n+   * through <code>Calendar.SATURDAY</code>.  Note that the first element\n+   * of this array is ignored.\n+   *\n+   * @param weekdays This list of weekday display strings.\n+   */\n   public void setWeekdays (String[] value)\n   {\n     weekdays = value;\n   }\n \n+  /**\n+   * This method sets the list of display strings for time zones.\n+   * This is a two dimensional <code>String</code> array where each row in\n+   * the array contains five values:\n+   * <P>\n+   * <ul>\n+   * <li>0 - The non-localized time zone id string.\n+   * <li>1 - The long name of the time zone (standard time).\n+   * <li>2 - The short name of the time zone (standard time).\n+   * <li>3 - The long name of the time zone (daylight savings time).\n+   * <li>4 - the short name of the time zone (daylight savings time).\n+   *\n+   * @return The list of time zone display strings.\n+   */\n   public void setZoneStrings (String[][] value)\n   {\n     zoneStrings = value;\n@@ -292,9 +403,24 @@ private static int hashCode (Object x)\n     return hash;\n   }\n \n+  /**\n+   * This method tests a specified object for equality against this object.\n+   * This will be true if and only if the specified object:\n+   * <p>\n+   * <ul>\n+   * <li> Is not <code>null</code>.\n+   * <li> Is an instance of <code>DateFormatSymbols</code>.\n+   * <li> Contains identical formatting symbols to this object.\n+   * </ul>\n+   * \n+   * @param obj The <code>Object</code> to test for equality against.\n+   *\n+   * @return <code>true</code> if the specified object is equal to this one,\n+   * </code>false</code> otherwise.\n+   */\n   public boolean equals (Object obj)\n   {\n-    if (obj == null || ! (obj instanceof DateFormatSymbols))\n+    if (! (obj instanceof DateFormatSymbols))\n       return false;\n     DateFormatSymbols other = (DateFormatSymbols) obj;\n     return (equals(ampms, other.ampms)\n@@ -307,11 +433,28 @@ && equals(weekdays, other.weekdays)\n \t    && equals(zoneStrings, other.zoneStrings));\n   }\n \n+  /**\n+   * Returns a new copy of this object.\n+   *\n+   * @param A copy of this object\n+   */\n   public Object clone ()\n   {\n-    return new DateFormatSymbols (this);\n+    try\n+      {\n+        return super.clone ();\n+      } \n+    catch (CloneNotSupportedException e) \n+      {\n+        return null;\n+      }\n   }\n \n+  /**\n+   * This method returns a hash value for this object.\n+   *\n+   * @return A hash value for this object.\n+   */\n   public int hashCode ()\n   {\n     return (hashCode(ampms)"}, {"sha": "f6b7223ed04a5e332599107b26a5cbe0727badd9", "filename": "libjava/java/text/DecimalFormat.java", "status": "modified", "additions": 858, "deletions": 843, "changes": 1701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormat.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,12 +1,28 @@\n-// DecimalFormat.java - Localized number formatting.\n-\n-/* Copyright (C) 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+/* DecimalFormat.java -- Formats and parses numbers\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.text;\n \n@@ -26,948 +42,947 @@\n  * Note however that the docs are very unclear about how format parsing\n  * should work.  No doubt there are problems here.\n  */\n-\n public class DecimalFormat extends NumberFormat\n {\n   // This is a helper for applyPatternWithSymbols.  It reads a prefix\n   // or a suffix.  It can cause some side-effects.\n   private final int scanFix (String pattern, int index, StringBuffer buf,\n \t\t\t     String patChars, DecimalFormatSymbols syms,\n \t\t\t     boolean is_suffix)\n-    {\n-      int len = pattern.length();\n-      buf.setLength(0);\n-      boolean multiplierSet = false;\n-      while (index < len)\n-\t{\n-\t  char c = pattern.charAt(index);\n-\t  if (c == '\\'' && index + 1 < len\n-\t      && pattern.charAt(index + 1) == '\\'')\n-\t    {\n-\t      buf.append(c);\n-\t      ++index;\n-\t    }\n-\t  else if (c == '\\'' && index + 2 < len\n-\t\t   && pattern.charAt(index + 2) == '\\'')\n-\t    {\n-\t      buf.append(pattern.charAt(index + 1));\n-\t      index += 2;\n-\t    }\n-\t  else if (c == '\\u00a4')\n-\t    {\n-\t      if (index + 1 < len && pattern.charAt(index + 1) == '\\u00a4')\n-\t\t{\n-\t\t  buf.append(syms.getInternationalCurrencySymbol());\n-\t\t  ++index;\n-\t\t}\n-\t      else\n-\t\tbuf.append(syms.getCurrencySymbol());\n-\t    }\n-\t  else if (is_suffix && c == syms.getPercent())\n-\t    {\n-\t      if (multiplierSet)\n-\t\tthrow new IllegalArgumentException (\"multiplier already set \" +\n-\t\t\t\t\t\t    \"- index: \" + index);\n-\t      multiplierSet = true;\n-\t      multiplier = 100;\n-\t      buf.append(c);\n-\t    }\n-\t  else if (is_suffix && c == syms.getPerMill())\n-\t    {\n-\t      if (multiplierSet)\n-\t\tthrow new IllegalArgumentException (\"multiplier already set \" +\n-\t\t\t\t\t\t    \"- index: \" + index);\n-\t      multiplierSet = true;\n-\t      multiplier = 1000;\n-\t      buf.append(c);\n-\t    }\n-\t  else if (patChars.indexOf(c) != -1)\n-\t    {\n-\t      // This is a pattern character.\n-\t      break;\n-\t    }\n-\t  else\n+  {\n+    int len = pattern.length();\n+    buf.setLength(0);\n+    boolean multiplierSet = false;\n+    while (index < len)\n+      {\n+\tchar c = pattern.charAt(index);\n+\tif (c == '\\'' && index + 1 < len\n+\t    && pattern.charAt(index + 1) == '\\'')\n+\t  {\n \t    buf.append(c);\n-\t  ++index;\n-\t}\n+\t    ++index;\n+\t  }\n+\telse if (c == '\\'' && index + 2 < len\n+\t\t && pattern.charAt(index + 2) == '\\'')\n+\t  {\n+\t    buf.append(pattern.charAt(index + 1));\n+\t    index += 2;\n+\t  }\n+\telse if (c == '\\u00a4')\n+\t  {\n+\t    if (index + 1 < len && pattern.charAt(index + 1) == '\\u00a4')\n+\t      {\n+\t\tbuf.append(syms.getInternationalCurrencySymbol());\n+\t\t++index;\n+\t      }\n+\t    else\n+\t      buf.append(syms.getCurrencySymbol());\n+\t  }\n+\telse if (is_suffix && c == syms.getPercent())\n+\t  {\n+\t    if (multiplierSet)\n+\t      throw new IllegalArgumentException (\"multiplier already set \" +\n+\t\t\t\t\t\t  \"- index: \" + index);\n+\t    multiplierSet = true;\n+\t    multiplier = 100;\n+\t    buf.append(c);\n+\t  }\n+\telse if (is_suffix && c == syms.getPerMill())\n+\t  {\n+\t    if (multiplierSet)\n+\t      throw new IllegalArgumentException (\"multiplier already set \" +\n+\t\t\t\t\t\t  \"- index: \" + index);\n+\t    multiplierSet = true;\n+\t    multiplier = 1000;\n+\t    buf.append(c);\n+\t  }\n+\telse if (patChars.indexOf(c) != -1)\n+\t  {\n+\t    // This is a pattern character.\n+\t    break;\n+\t  }\n+\telse\n+\t  buf.append(c);\n+\t++index;\n+      }\n \n-      return index;\n-    }\n+    return index;\n+  }\n \n   // A helper which reads a number format.\n   private final int scanFormat (String pattern, int index,\n \t\t\t\tString patChars, DecimalFormatSymbols syms,\n \t\t\t\tboolean is_positive)\n-    {\n-      int max = pattern.length();\n-\n-      int countSinceGroup = 0;\n-      int zeroCount = 0;\n-      boolean saw_group = false;\n-\n-      //\n-      // Scan integer part.\n-      //\n-      while (index < max)\n-\t{\n-\t  char c = pattern.charAt(index);\n-\n-\t  if (c == syms.getDigit())\n-\t    {\n-\t      if (zeroCount > 0)\n-\t\tthrow new IllegalArgumentException (\"digit mark following \" +\n-\t\t\t\t\t\t    \"zero - index: \" + index);\n-\t      ++countSinceGroup;\n-\t    }\n-\t  else if (c == syms.getZeroDigit())\n-\t    {\n-\t      ++zeroCount;\n-\t      ++countSinceGroup;\n-\t    }\n-\t  else if (c == syms.getGroupingSeparator())\n-\t    {\n-\t      countSinceGroup = 0;\n-\t      saw_group = true;\n-\t    }\n-\t  else\n-\t    break;\n+  {\n+    int max = pattern.length();\n \n-\t  ++index;\n-\t}\n-\n-      // We can only side-effect when parsing the positive format.\n-      if (is_positive)\n-\t{\n-\t  groupingUsed = saw_group;\n-\t  groupingSize = (byte) countSinceGroup;\n-\t  minimumIntegerDigits = zeroCount;\n-\t}\n-\n-      // Early termination.\n-      if (index == max || pattern.charAt(index) == syms.getGroupingSeparator())\n-\t{\n-\t  if (is_positive)\n-\t    decimalSeparatorAlwaysShown = false;\n-\t  return index;\n-\t}\n-\n-      if (pattern.charAt(index) == syms.getDecimalSeparator())\n-\t{\n-\t  ++index;\n-\n-\t  //\n-\t  // Scan fractional part.\n-\t  //\n-\t  int hashCount = 0;\n-\t  zeroCount = 0;\n-\t  while (index < max)\n-\t    {\n-\t      char c = pattern.charAt(index);\n-\t      if (c == syms.getZeroDigit())\n-\t\t{\n-\t\t  if (hashCount > 0)\n-\t\t    throw new IllegalArgumentException (\"zero mark \" +\n-\t\t\t\t\t\"following digit - index: \" + index);\n-\t\t  ++zeroCount;\n-\t\t}\n-\t      else if (c == syms.getDigit())\n-\t\t{\n-\t\t  ++hashCount;\n-\t\t}\n-\t      else if (c != syms.getExponential()\n-\t\t       && c != syms.getPatternSeparator()\n-\t\t       && patChars.indexOf(c) != -1)\n-\t\tthrow new IllegalArgumentException (\"unexpected special \" +\n-\t\t\t\t\t\t\"character - index: \" + index);\n-\t      else\n-\t\tbreak;\n-\n-\t      ++index;\n-\t    }\n-\n-\t  if (is_positive)\n-\t    {\n-\t      maximumFractionDigits = hashCount + zeroCount;\n-\t      minimumFractionDigits = zeroCount;\n-\t    }\n-\n-\t  if (index == max)\n-\t    return index;\n-\t}\n-\n-      if (pattern.charAt(index) == syms.getExponential())\n-\t{\n-\t  //\n-\t  // Scan exponential format.\n-\t  //\n-\t  zeroCount = 0;\n-\t  ++index;\n-\t  while (index < max)\n-\t    {\n-\t      char c = pattern.charAt(index);\n-\t      if (c == syms.getZeroDigit())\n+    int countSinceGroup = 0;\n+    int zeroCount = 0;\n+    boolean saw_group = false;\n+\n+    //\n+    // Scan integer part.\n+    //\n+    while (index < max)\n+      {\n+\tchar c = pattern.charAt(index);\n+\n+\tif (c == syms.getDigit())\n+\t  {\n+\t    if (zeroCount > 0)\n+\t      throw new IllegalArgumentException (\"digit mark following \" +\n+\t\t\t\t\t\t  \"zero - index: \" + index);\n+\t    ++countSinceGroup;\n+\t  }\n+\telse if (c == syms.getZeroDigit())\n+\t  {\n+\t    ++zeroCount;\n+\t    ++countSinceGroup;\n+\t  }\n+\telse if (c == syms.getGroupingSeparator())\n+\t  {\n+\t    countSinceGroup = 0;\n+\t    saw_group = true;\n+\t  }\n+\telse\n+\t  break;\n+\n+\t++index;\n+      }\n+\n+    // We can only side-effect when parsing the positive format.\n+    if (is_positive)\n+      {\n+\tgroupingUsed = saw_group;\n+\tgroupingSize = (byte) countSinceGroup;\n+\tminimumIntegerDigits = zeroCount;\n+      }\n+\n+    // Early termination.\n+    if (index == max || pattern.charAt(index) == syms.getGroupingSeparator())\n+      {\n+\tif (is_positive)\n+\t  decimalSeparatorAlwaysShown = false;\n+\treturn index;\n+      }\n+\n+    if (pattern.charAt(index) == syms.getDecimalSeparator())\n+      {\n+\t++index;\n+\n+\t//\n+\t// Scan fractional part.\n+\t//\n+\tint hashCount = 0;\n+\tzeroCount = 0;\n+\twhile (index < max)\n+\t  {\n+\t    char c = pattern.charAt(index);\n+\t    if (c == syms.getZeroDigit())\n+\t      {\n+\t\tif (hashCount > 0)\n+\t\t  throw new IllegalArgumentException (\"zero mark \" +\n+\t\t\t\t\t\t      \"following digit - index: \" + index);\n \t\t++zeroCount;\n-\t      else if (c == syms.getDigit())\n-\t\t{\n-\t\t  if (zeroCount > 0)\n-\t\t    throw new\n-\t\t      IllegalArgumentException (\"digit mark following zero \" +\n-\t\t\t\t\t\t\"in exponent - index: \" +\n-\t\t\t\t\t\tindex);\n-\t\t}\n-\t      else if (patChars.indexOf(c) != -1)\n-\t\tthrow new IllegalArgumentException (\"unexpected special \" +\n-\t\t\t\t\t\t    \"character - index: \" +\n-\t\t\t\t\t\t    index);\n-\t      else\n-\t\tbreak;\n-\n-\t      ++index;\n-\t    }\n-\n-\t  if (is_positive)\n-\t    {\n-\t      useExponentialNotation = true;\n-\t      minExponentDigits = (byte) zeroCount;\n-\t    }\n-\t}\n-\n-      return index;\n-    }\n+\t      }\n+\t    else if (c == syms.getDigit())\n+\t      {\n+\t\t++hashCount;\n+\t      }\n+\t    else if (c != syms.getExponential()\n+\t\t     && c != syms.getPatternSeparator()\n+\t\t     && patChars.indexOf(c) != -1)\n+\t      throw new IllegalArgumentException (\"unexpected special \" +\n+\t\t\t\t\t\t  \"character - index: \" + index);\n+\t    else\n+\t      break;\n+\n+\t    ++index;\n+\t  }\n+\n+\tif (is_positive)\n+\t  {\n+\t    maximumFractionDigits = hashCount + zeroCount;\n+\t    minimumFractionDigits = zeroCount;\n+\t  }\n+\n+\tif (index == max)\n+\t  return index;\n+      }\n+\n+    if (pattern.charAt(index) == syms.getExponential())\n+      {\n+\t//\n+\t// Scan exponential format.\n+\t//\n+\tzeroCount = 0;\n+\t++index;\n+\twhile (index < max)\n+\t  {\n+\t    char c = pattern.charAt(index);\n+\t    if (c == syms.getZeroDigit())\n+\t      ++zeroCount;\n+\t    else if (c == syms.getDigit())\n+\t      {\n+\t\tif (zeroCount > 0)\n+\t\t  throw new\n+\t\t    IllegalArgumentException (\"digit mark following zero \" +\n+\t\t\t\t\t      \"in exponent - index: \" +\n+\t\t\t\t\t      index);\n+\t      }\n+\t    else if (patChars.indexOf(c) != -1)\n+\t      throw new IllegalArgumentException (\"unexpected special \" +\n+\t\t\t\t\t\t  \"character - index: \" +\n+\t\t\t\t\t\t  index);\n+\t    else\n+\t      break;\n+\n+\t    ++index;\n+\t  }\n+\n+\tif (is_positive)\n+\t  {\n+\t    useExponentialNotation = true;\n+\t    minExponentDigits = (byte) zeroCount;\n+\t  }\n+      }\n+\n+    return index;\n+  }\n \n   // This helper function creates a string consisting of all the\n   // characters which can appear in a pattern and must be quoted.\n   private final String patternChars (DecimalFormatSymbols syms)\n-    {\n-      StringBuffer buf = new StringBuffer ();\n-      buf.append(syms.getDecimalSeparator());\n-      buf.append(syms.getDigit());\n-      buf.append(syms.getExponential());\n-      buf.append(syms.getGroupingSeparator());\n-      // Adding this one causes pattern application to fail.\n-      // Of course, omitting is causes toPattern to fail.\n-      // ... but we already have bugs there.  FIXME.\n-      // buf.append(syms.getMinusSign());\n-      buf.append(syms.getPatternSeparator());\n-      buf.append(syms.getPercent());\n-      buf.append(syms.getPerMill());\n-      buf.append(syms.getZeroDigit());\n-      buf.append('\\u00a4');\n-      return buf.toString();\n-    }\n+  {\n+    StringBuffer buf = new StringBuffer ();\n+    buf.append(syms.getDecimalSeparator());\n+    buf.append(syms.getDigit());\n+    buf.append(syms.getExponential());\n+    buf.append(syms.getGroupingSeparator());\n+    // Adding this one causes pattern application to fail.\n+    // Of course, omitting is causes toPattern to fail.\n+    // ... but we already have bugs there.  FIXME.\n+    // buf.append(syms.getMinusSign());\n+    buf.append(syms.getPatternSeparator());\n+    buf.append(syms.getPercent());\n+    buf.append(syms.getPerMill());\n+    buf.append(syms.getZeroDigit());\n+    buf.append('\\u00a4');\n+    return buf.toString();\n+  }\n \n   private final void applyPatternWithSymbols (String pattern,\n \t\t\t\t\t      DecimalFormatSymbols syms)\n-    {\n-      // Initialize to the state the parser expects.\n-      negativePrefix = \"\";\n-      negativeSuffix = \"\";\n-      positivePrefix = \"\";\n-      positiveSuffix = \"\";\n-      decimalSeparatorAlwaysShown = false;\n-      groupingSize = 0;\n-      minExponentDigits = 0;\n-      multiplier = 1;\n-      useExponentialNotation = false;\n-      groupingUsed = false;\n-      maximumFractionDigits = 0;\n-      maximumIntegerDigits = 309;\n-      minimumFractionDigits = 0;\n-      minimumIntegerDigits = 1;\n-\n-      StringBuffer buf = new StringBuffer ();\n-      String patChars = patternChars (syms);\n-\n-      int max = pattern.length();\n-      int index = scanFix (pattern, 0, buf, patChars, syms, false);\n-      positivePrefix = buf.toString();\n-\n-      index = scanFormat (pattern, index, patChars, syms, true);\n-\n-      index = scanFix (pattern, index, buf, patChars, syms, true);\n-      positiveSuffix = buf.toString();\n-\n-      if (index == pattern.length())\n-\t{\n-\t  // No negative info.\n-\t  negativePrefix = null;\n-\t  negativeSuffix = null;\n-\t}\n-      else\n-\t{\n-\t  if (pattern.charAt(index) != syms.getPatternSeparator())\n-\t    throw new IllegalArgumentException (\"separator character \" +\n-\t\t\t\t\t\t\"expected - index: \" + index);\n-\n-\t  index = scanFix (pattern, index + 1, buf, patChars, syms, false);\n-\t  negativePrefix = buf.toString();\n-\n-\t  // We parse the negative format for errors but we don't let\n-\t  // it side-effect this object.\n-\t  index = scanFormat (pattern, index, patChars, syms, false);\n-\n-\t  index = scanFix (pattern, index, buf, patChars, syms, true);\n-\t  negativeSuffix = buf.toString();\n-\n-\t  if (index != pattern.length())\n-\t    throw new IllegalArgumentException (\"end of pattern expected \" +\n-\t\t\t\t\t\t\"- index: \" + index);\n-\t}\n-    }\n+  {\n+    // Initialize to the state the parser expects.\n+    negativePrefix = \"\";\n+    negativeSuffix = \"\";\n+    positivePrefix = \"\";\n+    positiveSuffix = \"\";\n+    decimalSeparatorAlwaysShown = false;\n+    groupingSize = 0;\n+    minExponentDigits = 0;\n+    multiplier = 1;\n+    useExponentialNotation = false;\n+    groupingUsed = false;\n+    maximumFractionDigits = 0;\n+    maximumIntegerDigits = 309;\n+    minimumFractionDigits = 0;\n+    minimumIntegerDigits = 1;\n+\n+    StringBuffer buf = new StringBuffer ();\n+    String patChars = patternChars (syms);\n+\n+    int max = pattern.length();\n+    int index = scanFix (pattern, 0, buf, patChars, syms, false);\n+    positivePrefix = buf.toString();\n+\n+    index = scanFormat (pattern, index, patChars, syms, true);\n+\n+    index = scanFix (pattern, index, buf, patChars, syms, true);\n+    positiveSuffix = buf.toString();\n+\n+    if (index == pattern.length())\n+      {\n+\t// No negative info.\n+\tnegativePrefix = null;\n+\tnegativeSuffix = null;\n+      }\n+    else\n+      {\n+\tif (pattern.charAt(index) != syms.getPatternSeparator())\n+\t  throw new IllegalArgumentException (\"separator character \" +\n+\t\t\t\t\t      \"expected - index: \" + index);\n+\n+\tindex = scanFix (pattern, index + 1, buf, patChars, syms, false);\n+\tnegativePrefix = buf.toString();\n+\n+\t// We parse the negative format for errors but we don't let\n+\t// it side-effect this object.\n+\tindex = scanFormat (pattern, index, patChars, syms, false);\n+\n+\tindex = scanFix (pattern, index, buf, patChars, syms, true);\n+\tnegativeSuffix = buf.toString();\n+\n+\tif (index != pattern.length())\n+\t  throw new IllegalArgumentException (\"end of pattern expected \" +\n+\t\t\t\t\t      \"- index: \" + index);\n+      }\n+  }\n \n   public void applyLocalizedPattern (String pattern)\n-    {\n-      // JCL p. 638 claims this throws a ParseException but p. 629\n-      // contradicts this.  Empirical tests with patterns of \"0,###.0\"\n-      // and \"#.#.#\" corroborate the p. 629 statement that an\n-      // IllegalArgumentException is thrown.\n-      applyPatternWithSymbols (pattern, symbols);\n-    }\n+  {\n+    // JCL p. 638 claims this throws a ParseException but p. 629\n+    // contradicts this.  Empirical tests with patterns of \"0,###.0\"\n+    // and \"#.#.#\" corroborate the p. 629 statement that an\n+    // IllegalArgumentException is thrown.\n+    applyPatternWithSymbols (pattern, symbols);\n+  }\n \n   public void applyPattern (String pattern)\n-    {\n-      // JCL p. 638 claims this throws a ParseException but p. 629\n-      // contradicts this.  Empirical tests with patterns of \"0,###.0\"\n-      // and \"#.#.#\" corroborate the p. 629 statement that an\n-      // IllegalArgumentException is thrown.\n-      applyPatternWithSymbols (pattern, nonLocalizedSymbols);\n-    }\n+  {\n+    // JCL p. 638 claims this throws a ParseException but p. 629\n+    // contradicts this.  Empirical tests with patterns of \"0,###.0\"\n+    // and \"#.#.#\" corroborate the p. 629 statement that an\n+    // IllegalArgumentException is thrown.\n+    applyPatternWithSymbols (pattern, nonLocalizedSymbols);\n+  }\n \n   public Object clone ()\n-    {\n-      return new DecimalFormat (this);\n-    }\n+  {\n+    return new DecimalFormat (this);\n+  }\n \n   private DecimalFormat (DecimalFormat dup)\n-    {\n-      decimalSeparatorAlwaysShown = dup.decimalSeparatorAlwaysShown;\n-      groupingSize = dup.groupingSize;\n-      minExponentDigits = dup.minExponentDigits;\n-      multiplier = dup.multiplier;\n-      negativePrefix = dup.negativePrefix;\n-      negativeSuffix = dup.negativeSuffix;\n-      positivePrefix = dup.positivePrefix;\n-      positiveSuffix = dup.positiveSuffix;\n-      symbols = (DecimalFormatSymbols) dup.symbols.clone();\n-      useExponentialNotation = dup.useExponentialNotation;\n-    }\n+  {\n+    decimalSeparatorAlwaysShown = dup.decimalSeparatorAlwaysShown;\n+    groupingSize = dup.groupingSize;\n+    minExponentDigits = dup.minExponentDigits;\n+    multiplier = dup.multiplier;\n+    negativePrefix = dup.negativePrefix;\n+    negativeSuffix = dup.negativeSuffix;\n+    positivePrefix = dup.positivePrefix;\n+    positiveSuffix = dup.positiveSuffix;\n+    symbols = (DecimalFormatSymbols) dup.symbols.clone();\n+    useExponentialNotation = dup.useExponentialNotation;\n+  }\n \n   public DecimalFormat ()\n-    {\n-      this (\"#,##0.###\");\n-    }\n+  {\n+    this (\"#,##0.###\");\n+  }\n \n   public DecimalFormat (String pattern)\n-    {\n-      this (pattern, new DecimalFormatSymbols ());\n-    }\n+  {\n+    this (pattern, new DecimalFormatSymbols ());\n+  }\n \n   public DecimalFormat (String pattern, DecimalFormatSymbols symbols)\n-    {\n-      this.symbols = symbols;\n-      applyPattern (pattern);\n-    }\n+  {\n+    this.symbols = symbols;\n+    applyPattern (pattern);\n+  }\n \n   private final boolean equals (String s1, String s2)\n-    {\n-      if (s1 == null || s2 == null)\n-\treturn s1 == s2;\n-      return s1.equals(s2);\n-    }\n+  {\n+    if (s1 == null || s2 == null)\n+      return s1 == s2;\n+    return s1.equals(s2);\n+  }\n \n   public boolean equals (Object obj)\n-    {\n-      if (! (obj instanceof DecimalFormat))\n-\treturn false;\n-      DecimalFormat dup = (DecimalFormat) obj;\n-      return (decimalSeparatorAlwaysShown == dup.decimalSeparatorAlwaysShown\n-\t      && groupingSize == dup.groupingSize\n-\t      && minExponentDigits == dup.minExponentDigits\n-\t      && multiplier == dup.multiplier\n-\t      && equals(negativePrefix, dup.negativePrefix)\n-\t      && equals(negativeSuffix, dup.negativeSuffix)\n-\t      && equals(positivePrefix, dup.positivePrefix)\n-\t      && equals(positiveSuffix, dup.positiveSuffix)\n-\t      && symbols.equals(dup.symbols)\n-\t      && useExponentialNotation == dup.useExponentialNotation);\n-    }\n+  {\n+    if (! (obj instanceof DecimalFormat))\n+      return false;\n+    DecimalFormat dup = (DecimalFormat) obj;\n+    return (decimalSeparatorAlwaysShown == dup.decimalSeparatorAlwaysShown\n+\t    && groupingSize == dup.groupingSize\n+\t    && minExponentDigits == dup.minExponentDigits\n+\t    && multiplier == dup.multiplier\n+\t    && equals(negativePrefix, dup.negativePrefix)\n+\t    && equals(negativeSuffix, dup.negativeSuffix)\n+\t    && equals(positivePrefix, dup.positivePrefix)\n+\t    && equals(positiveSuffix, dup.positiveSuffix)\n+\t    && symbols.equals(dup.symbols)\n+\t    && useExponentialNotation == dup.useExponentialNotation);\n+  }\n \n   public StringBuffer format (double number, StringBuffer dest,\n \t\t\t      FieldPosition fieldPos)\n-    {\n-      // A very special case.\n-      if (Double.isNaN(number))\n-\t{\n-\t  dest.append(symbols.getNaN());\n-\t  if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n-\t    {\n-\t      int index = dest.length();\n-\t      fieldPos.setBeginIndex(index - symbols.getNaN().length());\n-\t      fieldPos.setEndIndex(index);\n-\t    }\n-\t  return dest;\n-\t}\n-\n-      boolean is_neg = number < 0;\n-      if (is_neg)\n-\t{\n-\t  if (negativePrefix != null)\n-\t    dest.append(negativePrefix);\n-\t  else\n-\t    {\n-\t      dest.append(symbols.getMinusSign());\n-\t      dest.append(positivePrefix);\n-\t    }\n-\t  number = - number;\n-\t}\n-      else\n-\tdest.append(positivePrefix);\n-\n-      int integerBeginIndex = dest.length();\n-      int integerEndIndex = 0;\n-      if (Double.isInfinite (number))\n-\t{\n-\t  dest.append(symbols.getInfinity());\n-\t  integerEndIndex = dest.length();\n-\t}\n-      else\n-\t{\n-\t  number *= multiplier;\n-\n-\t  // Compute exponent.\n-\t  long exponent = 0;\n-\t  double baseNumber;\n-\t  if (useExponentialNotation)\n-\t    {\n-\t      exponent = (long) (Math.log(number) / Math.log(10));\n-\t      if (minimumIntegerDigits > 0)\n-\t\texponent -= minimumIntegerDigits - 1;\n-\t      baseNumber = (long) (number / Math.pow(10.0, exponent));\n-\t    }\n-\t  else\n-\t    baseNumber = number;\n-\n-\t  // Round to the correct number of digits.\n-\t  baseNumber += 5 * Math.pow(10.0, - maximumFractionDigits - 1);\n-\n-\t  int index = dest.length();\n-\t  double intPart = Math.floor(baseNumber);\n-\t  int count = 0;\n-\t  while (count < maximumIntegerDigits\n-\t\t && (intPart > 0 || count < minimumIntegerDigits))\n-\t    {\n-\t      long dig = (long) (intPart % 10);\n-\t      intPart = Math.floor(intPart / 10);\n-\n-\t      // Append group separator if required.\n-\t      if (groupingUsed && count > 0 && count % groupingSize == 0)\n-\t\tdest.insert(index, symbols.getGroupingSeparator());\n-\n-\t      dest.insert(index, (char) (symbols.getZeroDigit() + dig));\n-\n-\t      ++count;\n-\t    }\n-\n-\t  integerEndIndex = dest.length();\n-\n-\t  int decimal_index = integerEndIndex;\n-\t  int consecutive_zeros = 0;\n-\t  int total_digits = 0;\n-\n-\t  // Strip integer part from NUMBER.\n-\t  double fracPart = baseNumber - Math.floor(baseNumber);\n-\t  for (count = 0;\n-\t       count < maximumFractionDigits\n-\t\t && (fracPart != 0 || count < minimumFractionDigits);\n-\t       ++count)\n-\t    {\n-\t      ++total_digits;\n-\t      fracPart *= 10;\n-\t      long dig = (long) fracPart;\n-\t      if (dig == 0)\n-\t\t++consecutive_zeros;\n-\t      else\n-\t\tconsecutive_zeros = 0;\n-\t      dest.append((char) (symbols.getZeroDigit() + dig));\n-\n-\t      // Strip integer part from FRACPART.\n-\t      fracPart = fracPart - Math.floor (fracPart);\n-\t    }\n-\n-\t  // Strip extraneous trailing `0's.  We can't always detect\n-\t  // these in the loop.\n-\t  int extra_zeros = Math.min (consecutive_zeros,\n-\t\t\t\t      total_digits - minimumFractionDigits);\n-\t  if (extra_zeros > 0)\n-\t    {\n-\t      dest.setLength(dest.length() - extra_zeros);\n-\t      total_digits -= extra_zeros;\n-\t    }\n-\n-\t  // If required, add the decimal symbol.\n-\t  if (decimalSeparatorAlwaysShown\n-\t      || total_digits > 0)\n-\t    {\n-\t      dest.insert(decimal_index, symbols.getDecimalSeparator());\n-\t      if (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)\n-\t\t{\n-\t\t  fieldPos.setBeginIndex(decimal_index + 1);\n-\t\t  fieldPos.setEndIndex(dest.length());\n-\t\t}\n-\t    }\n-\n-\t  // Finally, print the exponent.\n-\t  if (useExponentialNotation)\n-\t    {\n-\t      dest.append(symbols.getExponential());\n-\t      dest.append(exponent < 0 ? '-' : '+');\n-\t      index = dest.length();\n-\t      for (count = 0;\n-\t\t   exponent > 0 || count < minExponentDigits;\n-\t\t   ++count)\n-\t\t{\n-\t\t  long dig = exponent % 10;\n-\t\t  exponent /= 10;\n-\t\t  dest.insert(index, (char) (symbols.getZeroDigit() + dig));\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n-\t{\n-\t  fieldPos.setBeginIndex(integerBeginIndex);\n-\t  fieldPos.setEndIndex(integerEndIndex);\n-\t}\n-\n-      dest.append((is_neg && negativeSuffix != null)\n-\t\t  ? negativeSuffix\n-\t\t  : positiveSuffix);\n-      return dest;\n-    }\n+  {\n+    // A very special case.\n+    if (Double.isNaN(number))\n+      {\n+\tdest.append(symbols.getNaN());\n+\tif (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n+\t  {\n+\t    int index = dest.length();\n+\t    fieldPos.setBeginIndex(index - symbols.getNaN().length());\n+\t    fieldPos.setEndIndex(index);\n+\t  }\n+\treturn dest;\n+      }\n+\n+    boolean is_neg = number < 0;\n+    if (is_neg)\n+      {\n+\tif (negativePrefix != null)\n+\t  dest.append(negativePrefix);\n+\telse\n+\t  {\n+\t    dest.append(symbols.getMinusSign());\n+\t    dest.append(positivePrefix);\n+\t  }\n+\tnumber = - number;\n+      }\n+    else\n+      dest.append(positivePrefix);\n+\n+    int integerBeginIndex = dest.length();\n+    int integerEndIndex = 0;\n+    if (Double.isInfinite (number))\n+      {\n+\tdest.append(symbols.getInfinity());\n+\tintegerEndIndex = dest.length();\n+      }\n+    else\n+      {\n+\tnumber *= multiplier;\n+\n+\t// Compute exponent.\n+\tlong exponent = 0;\n+\tdouble baseNumber;\n+\tif (useExponentialNotation)\n+\t  {\n+\t    exponent = (long) (Math.log(number) / Math.log(10));\n+\t    if (minimumIntegerDigits > 0)\n+\t      exponent -= minimumIntegerDigits - 1;\n+\t    baseNumber = (long) (number / Math.pow(10.0, exponent));\n+\t  }\n+\telse\n+\t  baseNumber = number;\n+\n+\t// Round to the correct number of digits.\n+\tbaseNumber += 5 * Math.pow(10.0, - maximumFractionDigits - 1);\n+\n+\tint index = dest.length();\n+\tdouble intPart = Math.floor(baseNumber);\n+\tint count = 0;\n+\twhile (count < maximumIntegerDigits\n+\t       && (intPart > 0 || count < minimumIntegerDigits))\n+\t  {\n+\t    long dig = (long) (intPart % 10);\n+\t    intPart = Math.floor(intPart / 10);\n+\n+\t    // Append group separator if required.\n+\t    if (groupingUsed && count > 0 && count % groupingSize == 0)\n+\t      dest.insert(index, symbols.getGroupingSeparator());\n+\n+\t    dest.insert(index, (char) (symbols.getZeroDigit() + dig));\n+\n+\t    ++count;\n+\t  }\n+\n+\tintegerEndIndex = dest.length();\n+\n+\tint decimal_index = integerEndIndex;\n+\tint consecutive_zeros = 0;\n+\tint total_digits = 0;\n+\n+\t// Strip integer part from NUMBER.\n+\tdouble fracPart = baseNumber - Math.floor(baseNumber);\n+\tfor (count = 0;\n+\t     count < maximumFractionDigits\n+\t       && (fracPart != 0 || count < minimumFractionDigits);\n+\t     ++count)\n+\t  {\n+\t    ++total_digits;\n+\t    fracPart *= 10;\n+\t    long dig = (long) fracPart;\n+\t    if (dig == 0)\n+\t      ++consecutive_zeros;\n+\t    else\n+\t      consecutive_zeros = 0;\n+\t    dest.append((char) (symbols.getZeroDigit() + dig));\n+\n+\t    // Strip integer part from FRACPART.\n+\t    fracPart = fracPart - Math.floor (fracPart);\n+\t  }\n+\n+\t// Strip extraneous trailing `0's.  We can't always detect\n+\t// these in the loop.\n+\tint extra_zeros = Math.min (consecutive_zeros,\n+\t\t\t\t    total_digits - minimumFractionDigits);\n+\tif (extra_zeros > 0)\n+\t  {\n+\t    dest.setLength(dest.length() - extra_zeros);\n+\t    total_digits -= extra_zeros;\n+\t  }\n+\n+\t// If required, add the decimal symbol.\n+\tif (decimalSeparatorAlwaysShown\n+\t    || total_digits > 0)\n+\t  {\n+\t    dest.insert(decimal_index, symbols.getDecimalSeparator());\n+\t    if (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)\n+\t      {\n+\t\tfieldPos.setBeginIndex(decimal_index + 1);\n+\t\tfieldPos.setEndIndex(dest.length());\n+\t      }\n+\t  }\n+\n+\t// Finally, print the exponent.\n+\tif (useExponentialNotation)\n+\t  {\n+\t    dest.append(symbols.getExponential());\n+\t    dest.append(exponent < 0 ? '-' : '+');\n+\t    index = dest.length();\n+\t    for (count = 0;\n+\t\t exponent > 0 || count < minExponentDigits;\n+\t\t ++count)\n+\t      {\n+\t\tlong dig = exponent % 10;\n+\t\texponent /= 10;\n+\t\tdest.insert(index, (char) (symbols.getZeroDigit() + dig));\n+\t      }\n+\t  }\n+      }\n+\n+    if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n+      {\n+\tfieldPos.setBeginIndex(integerBeginIndex);\n+\tfieldPos.setEndIndex(integerEndIndex);\n+      }\n+\n+    dest.append((is_neg && negativeSuffix != null)\n+\t\t? negativeSuffix\n+\t\t: positiveSuffix);\n+    return dest;\n+  }\n \n   public StringBuffer format (long number, StringBuffer dest,\n \t\t\t      FieldPosition fieldPos)\n-    {\n-      // If using exponential notation, we just format as a double.\n-      if (useExponentialNotation)\n-\treturn format ((double) number, dest, fieldPos);\n-\n-      boolean is_neg = number < 0;\n-      if (is_neg)\n-\t{\n-\t  if (negativePrefix != null)\n-\t    dest.append(negativePrefix);\n-\t  else\n-\t    {\n-\t      dest.append(symbols.getMinusSign());\n-\t      dest.append(positivePrefix);\n-\t    }\n-\t  number = - number;\n-\t}\n-      else\n-\tdest.append(positivePrefix);\n-\n-      int integerBeginIndex = dest.length();\n-      int index = dest.length();\n-      int count = 0;\n-      while (count < maximumIntegerDigits\n-\t     && (number > 0 || count < minimumIntegerDigits))\n-\t{\n-\t  long dig = number % 10;\n-\t  number /= 10;\n-\t  // NUMBER and DIG will be less than 0 if the original number\n-\t  // was the most negative long.\n-\t  if (dig < 0)\n-\t    {\n-\t      dig = - dig;\n-\t      number = - number;\n-\t    }\n-\n-\t  // Append group separator if required.\n-\t  if (groupingUsed && count > 0 && count % groupingSize == 0)\n-\t    dest.insert(index, symbols.getGroupingSeparator());\n-\n-\t  dest.insert(index, (char) (symbols.getZeroDigit() + dig));\n-\n-\t  ++count;\n-\t}\n-\n-      if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n-\t{\n-\t  fieldPos.setBeginIndex(integerBeginIndex);\n-\t  fieldPos.setEndIndex(dest.length());\n-\t}\n-\n-      if (decimalSeparatorAlwaysShown || minimumFractionDigits > 0)\n-\t{\n-\t  dest.append(symbols.getDecimalSeparator());\n-\t  if (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)\n-\t    {\n-\t      fieldPos.setBeginIndex(dest.length());\n-\t      fieldPos.setEndIndex(dest.length() + minimumFractionDigits);\n-\t    }\n-\t}\n-\n-      for (count = 0; count < minimumFractionDigits; ++count)\n-\tdest.append(symbols.getZeroDigit());\n-\n-      dest.append((is_neg && negativeSuffix != null)\n-\t\t  ? negativeSuffix\n-\t\t  : positiveSuffix);\n-      return dest;\n-    }\n+  {\n+    // If using exponential notation, we just format as a double.\n+    if (useExponentialNotation)\n+      return format ((double) number, dest, fieldPos);\n+\n+    boolean is_neg = number < 0;\n+    if (is_neg)\n+      {\n+\tif (negativePrefix != null)\n+\t  dest.append(negativePrefix);\n+\telse\n+\t  {\n+\t    dest.append(symbols.getMinusSign());\n+\t    dest.append(positivePrefix);\n+\t  }\n+\tnumber = - number;\n+      }\n+    else\n+      dest.append(positivePrefix);\n+\n+    int integerBeginIndex = dest.length();\n+    int index = dest.length();\n+    int count = 0;\n+    while (count < maximumIntegerDigits\n+\t   && (number > 0 || count < minimumIntegerDigits))\n+      {\n+\tlong dig = number % 10;\n+\tnumber /= 10;\n+\t// NUMBER and DIG will be less than 0 if the original number\n+\t// was the most negative long.\n+\tif (dig < 0)\n+\t  {\n+\t    dig = - dig;\n+\t    number = - number;\n+\t  }\n+\n+\t// Append group separator if required.\n+\tif (groupingUsed && count > 0 && count % groupingSize == 0)\n+\t  dest.insert(index, symbols.getGroupingSeparator());\n+\n+\tdest.insert(index, (char) (symbols.getZeroDigit() + dig));\n+\n+\t++count;\n+      }\n+\n+    if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n+      {\n+\tfieldPos.setBeginIndex(integerBeginIndex);\n+\tfieldPos.setEndIndex(dest.length());\n+      }\n+\n+    if (decimalSeparatorAlwaysShown || minimumFractionDigits > 0)\n+      {\n+\tdest.append(symbols.getDecimalSeparator());\n+\tif (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)\n+\t  {\n+\t    fieldPos.setBeginIndex(dest.length());\n+\t    fieldPos.setEndIndex(dest.length() + minimumFractionDigits);\n+\t  }\n+      }\n+\n+    for (count = 0; count < minimumFractionDigits; ++count)\n+      dest.append(symbols.getZeroDigit());\n+\n+    dest.append((is_neg && negativeSuffix != null)\n+\t\t? negativeSuffix\n+\t\t: positiveSuffix);\n+    return dest;\n+  }\n \n   public DecimalFormatSymbols getDecimalFormatSymbols ()\n-    {\n-      return symbols;\n-    }\n+  {\n+    return symbols;\n+  }\n \n   public int getGroupingSize ()\n-    {\n-      return groupingSize;\n-    }\n+  {\n+    return groupingSize;\n+  }\n \n   public int getMultiplier ()\n-    {\n-      return multiplier;\n-    }\n+  {\n+    return multiplier;\n+  }\n \n   public String getNegativePrefix ()\n-    {\n-      return negativePrefix;\n-    }\n+  {\n+    return negativePrefix;\n+  }\n \n   public String getNegativeSuffix ()\n-    {\n-      return negativeSuffix;\n-    }\n+  {\n+    return negativeSuffix;\n+  }\n \n   public String getPositivePrefix ()\n-    {\n-      return positivePrefix;\n-    }\n+  {\n+    return positivePrefix;\n+  }\n \n   public String getPositiveSuffix ()\n-    {\n-      return positiveSuffix;\n-    }\n+  {\n+    return positiveSuffix;\n+  }\n \n   public int hashCode ()\n-    {\n-      int hash = (negativeSuffix.hashCode() ^ negativePrefix.hashCode()\n-\t\t  ^positivePrefix.hashCode() ^ positiveSuffix.hashCode());\n-      // FIXME.\n-      return hash;\n-    }\n+  {\n+    int hash = (negativeSuffix.hashCode() ^ negativePrefix.hashCode()\n+\t\t^positivePrefix.hashCode() ^ positiveSuffix.hashCode());\n+    // FIXME.\n+    return hash;\n+  }\n \n   public boolean isDecimalSeparatorAlwaysShown ()\n-    {\n-      return decimalSeparatorAlwaysShown;\n-    }\n+  {\n+    return decimalSeparatorAlwaysShown;\n+  }\n \n   public Number parse (String str, ParsePosition pos)\n-    {\n-      // Our strategy is simple: copy the text into a buffer,\n-      // translating or omitting locale-specific information.  Then\n-      // let Double or Long convert the number for us.\n+  {\n+    // Our strategy is simple: copy the text into a buffer,\n+    // translating or omitting locale-specific information.  Then\n+    // let Double or Long convert the number for us.\n \n-      boolean is_neg = false;\n-      int index = pos.getIndex();\n-      StringBuffer buf = new StringBuffer ();\n+    boolean is_neg = false;\n+    int index = pos.getIndex();\n+    StringBuffer buf = new StringBuffer ();\n \n       // We have to check both prefixes, because one might be empty.\n       // We want to pick the longest prefix that matches.\n-      boolean got_pos = str.startsWith(positivePrefix, index);\n-      String np = (negativePrefix != null\n-\t\t   ? negativePrefix\n-\t\t   : positivePrefix + symbols.getMinusSign());\n-      boolean got_neg = str.startsWith(np, index);\n-\n-      if (got_pos && got_neg)\n-\t{\n-\t  // By checking this way, we preserve ambiguity in the case\n-\t  // where the negative format differs only in suffix.  We\n-\t  // check this again later.\n-\t  if (np.length() > positivePrefix.length())\n-\t    {\n-\t      is_neg = true;\n-\t      index += np.length();\n-\t    }\n-\t  else\n-\t    index += positivePrefix.length();\n-\t}\n-      else if (got_neg)\n-\t{\n-\t  is_neg = true;\n-\t  index += np.length();\n-\t}\n-      else if (got_pos)\n-\tindex += positivePrefix.length();\n-      else\n-\t{\n-\t  pos.setErrorIndex (index);\n-\t  return null;\n-\t}\n-\n-      // FIXME: handle Inf and NaN.\n+    boolean got_pos = str.startsWith(positivePrefix, index);\n+    String np = (negativePrefix != null\n+\t\t ? negativePrefix\n+\t\t : positivePrefix + symbols.getMinusSign());\n+    boolean got_neg = str.startsWith(np, index);\n+\n+    if (got_pos && got_neg)\n+      {\n+\t// By checking this way, we preserve ambiguity in the case\n+\t// where the negative format differs only in suffix.  We\n+\t// check this again later.\n+\tif (np.length() > positivePrefix.length())\n+\t  {\n+\t    is_neg = true;\n+\t    index += np.length();\n+\t  }\n+\telse\n+\t  index += positivePrefix.length();\n+      }\n+    else if (got_neg)\n+      {\n+\tis_neg = true;\n+\tindex += np.length();\n+      }\n+    else if (got_pos)\n+      index += positivePrefix.length();\n+    else\n+      {\n+\tpos.setErrorIndex (index);\n+\treturn null;\n+      }\n+\n+    // FIXME: handle Inf and NaN.\n \n       // FIXME: do we have to respect minimum/maxmimum digit stuff?\n       // What about leading zeros?  What about multiplier?\n \n-      int start_index = index;\n-      int max = str.length();\n-      char zero = symbols.getZeroDigit();\n-      int last_group = -1;\n-      boolean int_part = true;\n-      boolean exp_part = false;\n-      for (; index < max; ++index)\n-\t{\n-\t  char c = str.charAt(index);\n-\n-\t  // FIXME: what about grouping size?\n-\t  if (groupingUsed && c == symbols.getGroupingSeparator())\n-\t    {\n-\t      if (last_group != -1\n-\t\t  && (index - last_group) % groupingSize != 0)\n-\t\t{\n-\t\t  pos.setErrorIndex(index);\n-\t\t  return null;\n-\t\t}\n-\t      last_group = index;\n-\t    }\n-\t  else if (c >= zero && c <= zero + 9)\n-\t    {\n-\t      buf.append((char) (c - zero + '0'));\n-\t      exp_part = false;\n-\t    }\n-\t  else if (parseIntegerOnly)\n-\t    break;\n-\t  else if (c == symbols.getDecimalSeparator())\n-\t    {\n-\t      if (last_group != -1\n-\t\t  && (index - last_group) % groupingSize != 0)\n-\t\t{\n-\t\t  pos.setErrorIndex(index);\n-\t\t  return null;\n-\t\t}\n-\t      buf.append('.');\n-\t      int_part = false;\n-\t    }\n-\t  else if (c == symbols.getExponential())\n-\t    {\n-\t      buf.append('E');\n-\t      int_part = false;\n-\t      exp_part = true;\n-\t    }\n-\t  else if (exp_part\n-\t\t   && (c == '+' || c == '-' || c == symbols.getMinusSign()))\n-\t    {\n-\t      // For exponential notation.\n-\t      buf.append(c);\n-\t    }\n-\t  else\n-\t    break;\n-\t}\n-\n-      if (index == start_index)\n-\t{\n-\t  // Didn't see any digits.\n-\t  pos.setErrorIndex(index);\n-\t  return null;\n-\t}\n-\n-      // Check the suffix.  We must do this before converting the\n-      // buffer to a number to handle the case of a number which is\n-      // the most negative Long.\n-      boolean got_pos_suf = str.startsWith(positiveSuffix, index);\n-      String ns = (negativePrefix == null ? positiveSuffix : negativeSuffix);\n-      boolean got_neg_suf = str.startsWith(ns, index);\n-      if (is_neg)\n-\t{\n-\t  if (! got_neg_suf)\n-\t    {\n-\t      pos.setErrorIndex(index);\n-\t      return null;\n-\t    }\n-\t}\n-      else if (got_pos && got_neg && got_neg_suf)\n-\t{\n-\t  is_neg = true;\n-\t}\n-      else if (got_pos != got_pos_suf && got_neg != got_neg_suf)\n-\t{\n-\t  pos.setErrorIndex(index);\n-\t  return null;\n-\t}\n-\n-      String suffix = is_neg ? ns : positiveSuffix;\n-      if (is_neg)\n-\tbuf.insert(0, '-');\n-\n-      String t = buf.toString();\n-      Number result = null;\n-      try\n-\t{\n-\t  result = new Long (t);\n-\t}\n-      catch (NumberFormatException x1)\n-\t{\n-\t  try\n-\t    {\n-\t      result = new Double (t);\n-\t    }\n-\t  catch (NumberFormatException x2)\n-\t    {\n-\t    }\n-\t}\n-      if (result == null)\n-\t{\n-\t  pos.setErrorIndex(index);\n-\t  return null;\n-\t}\n-\n-      pos.setIndex(index + suffix.length());\n-\n-      return result;\n-    }\n+    int start_index = index;\n+    int max = str.length();\n+    char zero = symbols.getZeroDigit();\n+    int last_group = -1;\n+    boolean int_part = true;\n+    boolean exp_part = false;\n+    for (; index < max; ++index)\n+      {\n+\tchar c = str.charAt(index);\n+\n+\t// FIXME: what about grouping size?\n+\tif (groupingUsed && c == symbols.getGroupingSeparator())\n+\t  {\n+\t    if (last_group != -1\n+\t\t&& (index - last_group) % groupingSize != 0)\n+\t      {\n+\t\tpos.setErrorIndex(index);\n+\t\treturn null;\n+\t      }\n+\t    last_group = index;\n+\t  }\n+\telse if (c >= zero && c <= zero + 9)\n+\t  {\n+\t    buf.append((char) (c - zero + '0'));\n+\t    exp_part = false;\n+\t  }\n+\telse if (parseIntegerOnly)\n+\t  break;\n+\telse if (c == symbols.getDecimalSeparator())\n+\t  {\n+\t    if (last_group != -1\n+\t\t&& (index - last_group) % groupingSize != 0)\n+\t      {\n+\t\tpos.setErrorIndex(index);\n+\t\treturn null;\n+\t      }\n+\t    buf.append('.');\n+\t    int_part = false;\n+\t  }\n+\telse if (c == symbols.getExponential())\n+\t  {\n+\t    buf.append('E');\n+\t    int_part = false;\n+\t    exp_part = true;\n+\t  }\n+\telse if (exp_part\n+\t\t && (c == '+' || c == '-' || c == symbols.getMinusSign()))\n+\t  {\n+\t    // For exponential notation.\n+\t    buf.append(c);\n+\t  }\n+\telse\n+\t  break;\n+      }\n+\n+    if (index == start_index)\n+      {\n+\t// Didn't see any digits.\n+\tpos.setErrorIndex(index);\n+\treturn null;\n+      }\n+\n+    // Check the suffix.  We must do this before converting the\n+    // buffer to a number to handle the case of a number which is\n+    // the most negative Long.\n+    boolean got_pos_suf = str.startsWith(positiveSuffix, index);\n+    String ns = (negativePrefix == null ? positiveSuffix : negativeSuffix);\n+    boolean got_neg_suf = str.startsWith(ns, index);\n+    if (is_neg)\n+      {\n+\tif (! got_neg_suf)\n+\t  {\n+\t    pos.setErrorIndex(index);\n+\t    return null;\n+\t  }\n+      }\n+    else if (got_pos && got_neg && got_neg_suf)\n+      {\n+\tis_neg = true;\n+      }\n+    else if (got_pos != got_pos_suf && got_neg != got_neg_suf)\n+      {\n+\tpos.setErrorIndex(index);\n+\treturn null;\n+      }\n+\n+    String suffix = is_neg ? ns : positiveSuffix;\n+    if (is_neg)\n+      buf.insert(0, '-');\n+\n+    String t = buf.toString();\n+    Number result = null;\n+    try\n+      {\n+\tresult = new Long (t);\n+      }\n+    catch (NumberFormatException x1)\n+      {\n+\ttry\n+\t  {\n+\t    result = new Double (t);\n+\t  }\n+\tcatch (NumberFormatException x2)\n+\t  {\n+\t  }\n+      }\n+    if (result == null)\n+      {\n+\tpos.setErrorIndex(index);\n+\treturn null;\n+      }\n+\n+    pos.setIndex(index + suffix.length());\n+\n+    return result;\n+  }\n \n   public void setDecimalFormatSymbols (DecimalFormatSymbols newSymbols)\n-    {\n-      symbols = newSymbols;\n-    }\n+  {\n+    symbols = newSymbols;\n+  }\n \n   public void setDecimalSeparatorAlwaysShown (boolean newValue)\n-    {\n-      decimalSeparatorAlwaysShown = newValue;\n-    }\n+  {\n+    decimalSeparatorAlwaysShown = newValue;\n+  }\n \n   public void setGroupingSize (int groupSize)\n-    {\n-      groupingSize = (byte) groupSize;\n-    }\n+  {\n+    groupingSize = (byte) groupSize;\n+  }\n \n   public void setMaximumFractionDigits (int newValue)\n-    {\n-      maximumFractionDigits = Math.min(newValue, 340);\n-    }\n+  {\n+    maximumFractionDigits = Math.min(newValue, 340);\n+  }\n \n   public void setMaximumIntegerDigits (int newValue)\n-    {\n-      maximumIntegerDigits = Math.min(newValue, 309);\n-    }\n+  {\n+    maximumIntegerDigits = Math.min(newValue, 309);\n+  }\n \n   public void setMinimumFractionDigits (int newValue)\n-    {\n-      minimumFractionDigits = Math.min(newValue, 340);\n-    }\n+  {\n+    minimumFractionDigits = Math.min(newValue, 340);\n+  }\n \n   public void setMinimumIntegerDigits (int newValue)\n-    {\n-      minimumIntegerDigits = Math.min(newValue, 309);\n-    }\n+  {\n+    minimumIntegerDigits = Math.min(newValue, 309);\n+  }\n \n   public void setMultiplier (int newValue)\n-    {\n-      multiplier = newValue;\n-    }\n+  {\n+    multiplier = newValue;\n+  }\n \n   public void setNegativePrefix (String newValue)\n-    {\n-      negativePrefix = newValue;\n-    }\n+  {\n+    negativePrefix = newValue;\n+  }\n \n   public void setNegativeSuffix (String newValue)\n-    {\n-      negativeSuffix = newValue;\n-    }\n+  {\n+    negativeSuffix = newValue;\n+  }\n \n   public void setPositivePrefix (String newValue)\n-    {\n-      positivePrefix = newValue;\n-    }\n+  {\n+    positivePrefix = newValue;\n+  }\n \n   public void setPositiveSuffix (String newValue)\n-    {\n-      positiveSuffix = newValue;\n-    }\n+  {\n+    positiveSuffix = newValue;\n+  }\n \n   private final void quoteFix (StringBuffer buf, String text, String patChars)\n-    {\n-      int len = text.length();\n-      for (int index = 0; index < len; ++index)\n-\t{\n-\t  char c = text.charAt(index);\n-\t  if (patChars.indexOf(c) != -1)\n-\t    {\n-\t      buf.append('\\'');\n-\t      buf.append(c);\n-\t      buf.append('\\'');\n-\t    }\n-\t  else\n+  {\n+    int len = text.length();\n+    for (int index = 0; index < len; ++index)\n+      {\n+\tchar c = text.charAt(index);\n+\tif (patChars.indexOf(c) != -1)\n+\t  {\n+\t    buf.append('\\'');\n \t    buf.append(c);\n-\t}\n-    }\n+\t    buf.append('\\'');\n+\t  }\n+\telse\n+\t  buf.append(c);\n+      }\n+  }\n \n   private final String computePattern (DecimalFormatSymbols syms)\n-    {\n-      StringBuffer mainPattern = new StringBuffer ();\n-      // We have to at least emit a zero for the minimum number of\n-      // digits.  Past that we need hash marks up to the grouping\n-      // separator (and one beyond).\n-      int total_digits = Math.max(minimumIntegerDigits,\n-\t\t\t\t  groupingUsed ? groupingSize + 1: 0);\n-      for (int i = 0; i < total_digits - minimumIntegerDigits; ++i)\n-\tmainPattern.append(syms.getDigit());\n-      for (int i = total_digits - minimumIntegerDigits; i < total_digits; ++i)\n-\tmainPattern.append(syms.getZeroDigit());\n-      // Inserting the gropuing operator afterwards is easier.\n-      if (groupingUsed)\n-\tmainPattern.insert(mainPattern.length() - groupingSize,\n-\t\t\t   syms.getGroupingSeparator());\n-      // See if we need decimal info.\n-      if (minimumFractionDigits > 0 || maximumFractionDigits > 0\n-\t  || decimalSeparatorAlwaysShown)\n-\tmainPattern.append(syms.getDecimalSeparator());\n-      for (int i = 0; i < minimumFractionDigits; ++i)\n-\tmainPattern.append(syms.getZeroDigit());\n-      for (int i = minimumFractionDigits; i < maximumFractionDigits; ++i)\n-\tmainPattern.append(syms.getDigit());\n-      if (useExponentialNotation)\n-\t{\n-\t  mainPattern.append(syms.getExponential());\n-\t  for (int i = 0; i < minExponentDigits; ++i)\n-\t    mainPattern.append(syms.getZeroDigit());\n-\t  if (minExponentDigits == 0)\n-\t    mainPattern.append(syms.getDigit());\n-\t}\n-\n-      String main = mainPattern.toString();\n-      String patChars = patternChars (syms);\n-      mainPattern.setLength(0);\n-\n-      quoteFix (mainPattern, positivePrefix, patChars);\n-      mainPattern.append(main);\n-      quoteFix (mainPattern, positiveSuffix, patChars);\n-\n-      if (negativePrefix != null)\n-\t{\n-\t  quoteFix (mainPattern, negativePrefix, patChars);\n-\t  mainPattern.append(main);\n-\t  quoteFix (mainPattern, negativeSuffix, patChars);\n-\t}\n-\n-      return mainPattern.toString();\n-    }\n+  {\n+    StringBuffer mainPattern = new StringBuffer ();\n+    // We have to at least emit a zero for the minimum number of\n+    // digits.  Past that we need hash marks up to the grouping\n+    // separator (and one beyond).\n+    int total_digits = Math.max(minimumIntegerDigits,\n+\t\t\t\tgroupingUsed ? groupingSize + 1: 0);\n+    for (int i = 0; i < total_digits - minimumIntegerDigits; ++i)\n+      mainPattern.append(syms.getDigit());\n+    for (int i = total_digits - minimumIntegerDigits; i < total_digits; ++i)\n+      mainPattern.append(syms.getZeroDigit());\n+    // Inserting the gropuing operator afterwards is easier.\n+    if (groupingUsed)\n+      mainPattern.insert(mainPattern.length() - groupingSize,\n+\t\t\t syms.getGroupingSeparator());\n+    // See if we need decimal info.\n+    if (minimumFractionDigits > 0 || maximumFractionDigits > 0\n+\t|| decimalSeparatorAlwaysShown)\n+      mainPattern.append(syms.getDecimalSeparator());\n+    for (int i = 0; i < minimumFractionDigits; ++i)\n+      mainPattern.append(syms.getZeroDigit());\n+    for (int i = minimumFractionDigits; i < maximumFractionDigits; ++i)\n+      mainPattern.append(syms.getDigit());\n+    if (useExponentialNotation)\n+      {\n+\tmainPattern.append(syms.getExponential());\n+\tfor (int i = 0; i < minExponentDigits; ++i)\n+\t  mainPattern.append(syms.getZeroDigit());\n+\tif (minExponentDigits == 0)\n+\t  mainPattern.append(syms.getDigit());\n+      }\n+\n+    String main = mainPattern.toString();\n+    String patChars = patternChars (syms);\n+    mainPattern.setLength(0);\n+\n+    quoteFix (mainPattern, positivePrefix, patChars);\n+    mainPattern.append(main);\n+    quoteFix (mainPattern, positiveSuffix, patChars);\n+\n+    if (negativePrefix != null)\n+      {\n+\tquoteFix (mainPattern, negativePrefix, patChars);\n+\tmainPattern.append(main);\n+\tquoteFix (mainPattern, negativeSuffix, patChars);\n+      }\n+\n+    return mainPattern.toString();\n+  }\n \n   public String toLocalizedPattern ()\n-    {\n-      return computePattern (symbols);\n-    }\n+  {\n+    return computePattern (symbols);\n+  }\n \n   public String toPattern ()\n-    {\n-      return computePattern (nonLocalizedSymbols);\n-    }\n+  {\n+    return computePattern (nonLocalizedSymbols);\n+  }\n \n   // These names are fixed by the serialization spec.\n   private boolean decimalSeparatorAlwaysShown;"}, {"sha": "bc5776a5668ccc3116eb6ba305ed5d52692afa77", "filename": "libjava/java/text/DecimalFormatSymbols.java", "status": "modified", "additions": 443, "deletions": 204, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,12 +1,29 @@\n-// DecimalFormatSymbols.java - Symbols used to format numbers.\n+/* DecimalFormatSymbols.java -- Format symbols used by DecimalFormat\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n@@ -18,302 +35,524 @@\n import java.io.IOException;\n \n /**\n+ * This class is a container for the symbols used by \n+ * <code>DecimalFormat</code> to format numbers and currency.  These are\n+ * normally handled automatically, but an application can override\n+ * values as desired using this class.\n+ *\n  * @author Tom Tromey <tromey@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date February 24, 1999\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 from http://www.javasoft.com.\n  * Status:  Believed complete and correct to 1.2.\n  */\n-\n public final class DecimalFormatSymbols implements Cloneable, Serializable\n {\n   public Object clone ()\n-    {\n-      return new DecimalFormatSymbols (this);\n-    }\n-\n-  private DecimalFormatSymbols (DecimalFormatSymbols orig)\n-    {\n-      this.currencySymbol = orig.currencySymbol;\n-      this.decimalSeparator = orig.decimalSeparator;\n-      this.digit = orig.digit;\n-      this.exponential = orig.exponential;\n-      this.groupingSeparator = orig.groupingSeparator;\n-      this.infinity = orig.infinity;\n-      this.intlCurrencySymbol = orig.intlCurrencySymbol;\n-      this.monetarySeparator = orig.monetarySeparator;\n-      this.minusSign = orig.minusSign;\n-      this.NaN = orig.NaN;\n-      this.patternSeparator = orig.patternSeparator;\n-      this.percent = orig.percent;\n-      this.perMill = orig.perMill;\n-      this.zeroDigit = orig.zeroDigit;\n-    }\n+  {\n+    try\n+      {\n+\treturn super.clone ();\n+      }\n+    catch(CloneNotSupportedException e)\n+      {\n+\treturn null;\n+      }\n+  }\n \n+  /**\n+   * This method initializes a new instance of\n+   * <code>DecimalFormatSymbols</code> for the default locale.\n+   */\n   public DecimalFormatSymbols ()\n-    {\n-      this (Locale.getDefault());\n-    }\n+  {\n+    this (Locale.getDefault());\n+  }\n \n   private final String safeGetString (ResourceBundle bundle,\n \t\t\t\t      String name, String def)\n-    {\n-      if (bundle != null)\n-\t{\n-\t  try\n-\t    {\n-\t      return bundle.getString(name);\n-\t    }\n-\t  catch (MissingResourceException x)\n-\t    {\n-\t    }\n-\t}\n-      return def;\n-    }\n+  {\n+    if (bundle != null)\n+      {\n+\ttry\n+\t  {\n+\t    return bundle.getString(name);\n+\t  }\n+\tcatch (MissingResourceException x)\n+\t  {\n+\t  }\n+      }\n+    return def;\n+  }\n \n   private final char safeGetChar (ResourceBundle bundle,\n \t\t\t\t  String name, char def)\n-    {\n-      String r = null;\n-      if (bundle != null)\n-\t{\n-\t  try\n-\t    {\n-\t      r = bundle.getString(name);\n-\t    }\n-\t  catch (MissingResourceException x)\n-\t    {\n-\t    }\n-\t}\n-      if (r == null || r.length() < 1)\n-\treturn def;\n-      return r.charAt(0);\n-    }\n+  {\n+    String r = null;\n+    if (bundle != null)\n+      {\n+\ttry\n+\t  {\n+\t    r = bundle.getString(name);\n+\t  }\n+\tcatch (MissingResourceException x)\n+\t  {\n+\t  }\n+      }\n+    if (r == null || r.length() < 1)\n+      return def;\n+    return r.charAt(0);\n+  }\n \n+  /**\n+   * This method initializes a new instance of\n+   * <code>DecimalFormatSymbols</code> for the specified locale.\n+   *\n+   * @param locale The local to load symbols for.\n+   */\n   public DecimalFormatSymbols (Locale loc)\n-    {\n-      ResourceBundle res;\n-      try\n-\t{\n-\t  res = ResourceBundle.getBundle(\"gnu.gcj.text.LocaleData\", loc);\n-\t}\n-      catch (MissingResourceException x)\n-\t{\n-\t  res = null;\n-\t}\n-      currencySymbol = safeGetString (res, \"currencySymbol\", \"$\");\n-      decimalSeparator = safeGetChar (res, \"decimalSeparator\", '.');\n-      digit = safeGetChar (res, \"digit\", '#');\n-      exponential = safeGetChar (res, \"exponential\", 'E');\n-      groupingSeparator = safeGetChar (res, \"groupingSeparator\", ',');\n-      infinity = safeGetString (res, \"infinity\", \"\\u221e\");\n-      // FIXME: default?\n-      intlCurrencySymbol = safeGetString (res, \"intlCurrencySymbol\", \"$\");\n-      try\n-        {\n-\t  monetarySeparator = safeGetChar (res, \"monetarySeparator\", '.');\n-\t}\n-      catch (MissingResourceException x)\n-        {\n-\t  monetarySeparator = decimalSeparator;\n-\t}\n-      minusSign = safeGetChar (res, \"minusSign\", '-');\n-      NaN = safeGetString (res, \"NaN\", \"\\ufffd\");\n-      patternSeparator = safeGetChar (res, \"patternSeparator\", ';');\n-      percent = safeGetChar (res, \"percent\", '%');\n-      perMill = safeGetChar (res, \"perMill\", '\\u2030');\n-      zeroDigit = safeGetChar (res, \"zeroDigit\", '0');\n-    }\n+  {\n+    ResourceBundle res;\n+    try\n+      {\n+\tres = ResourceBundle.getBundle(\"gnu.java.locale.LocaleInformation\",\n+\t\t\t\t       loc);\n+      }\n+    catch (MissingResourceException x)\n+      {\n+\tres = null;\n+      }\n+    currencySymbol = safeGetString (res, \"currencySymbol\", \"$\");\n+    decimalSeparator = safeGetChar (res, \"decimalSeparator\", '.');\n+    digit = safeGetChar (res, \"digit\", '#');\n+    exponential = safeGetChar (res, \"exponential\", 'E');\n+    groupingSeparator = safeGetChar (res, \"groupingSeparator\", ',');\n+    infinity = safeGetString (res, \"infinity\", \"\\u221e\");\n+    // FIXME: default?\n+    intlCurrencySymbol = safeGetString (res, \"intlCurrencySymbol\", \"$\");\n+    try\n+      {\n+\tmonetarySeparator = safeGetChar (res, \"monetarySeparator\", '.');\n+      }\n+    catch (MissingResourceException x)\n+      {\n+\tmonetarySeparator = decimalSeparator;\n+      }\n+    minusSign = safeGetChar (res, \"minusSign\", '-');\n+    NaN = safeGetString (res, \"NaN\", \"\\ufffd\");\n+    patternSeparator = safeGetChar (res, \"patternSeparator\", ';');\n+    percent = safeGetChar (res, \"percent\", '%');\n+    perMill = safeGetChar (res, \"perMill\", '\\u2030');\n+    zeroDigit = safeGetChar (res, \"zeroDigit\", '0');\n+  }\n \n+  /**\n+   * This method this this object for equality against the specified object.\n+   * This will be true if and only if the following criteria are met with\n+   * regard to the specified object:\n+   * <p>\n+   * <ul>\n+   * <li>It is not <code>null</code>.\n+   * <li>It is an instance of <code>DecimalFormatSymbols</code>\n+   * <li>All of its symbols are identical to the symbols in this object.\n+   * </ul>\n+   *\n+   * @return <code>true</code> if the specified object is equal to this\n+   * object, <code>false</code> otherwise.\n+   */\n   public boolean equals (Object obj)\n-    {\n-      if (! (obj instanceof DecimalFormatSymbols))\n-\treturn false;\n-      DecimalFormatSymbols dfs = (DecimalFormatSymbols) obj;\n-      return (currencySymbol.equals(dfs.currencySymbol)\n-\t      && decimalSeparator == dfs.decimalSeparator\n-\t      && digit == dfs.digit\n-\t      && exponential == dfs.exponential\n-\t      && groupingSeparator == dfs.groupingSeparator\n-\t      && infinity.equals(dfs.infinity)\n-\t      && intlCurrencySymbol.equals(dfs.intlCurrencySymbol)\n-\t      && minusSign == dfs.minusSign\n-\t      && monetarySeparator == dfs.monetarySeparator\n-\t      && NaN.equals(dfs.NaN)\n-\t      && patternSeparator == dfs.patternSeparator\n-\t      && percent == dfs.percent\n-\t      && perMill == dfs.perMill\n-\t      && zeroDigit == dfs.zeroDigit);\n-    }\n+  {\n+    if (! (obj instanceof DecimalFormatSymbols))\n+      return false;\n+    DecimalFormatSymbols dfs = (DecimalFormatSymbols) obj;\n+    return (currencySymbol.equals(dfs.currencySymbol)\n+\t    && decimalSeparator == dfs.decimalSeparator\n+\t    && digit == dfs.digit\n+\t    && exponential == dfs.exponential\n+\t    && groupingSeparator == dfs.groupingSeparator\n+\t    && infinity.equals(dfs.infinity)\n+\t    && intlCurrencySymbol.equals(dfs.intlCurrencySymbol)\n+\t    && minusSign == dfs.minusSign\n+\t    && monetarySeparator == dfs.monetarySeparator\n+\t    && NaN.equals(dfs.NaN)\n+\t    && patternSeparator == dfs.patternSeparator\n+\t    && percent == dfs.percent\n+\t    && perMill == dfs.perMill\n+\t    && zeroDigit == dfs.zeroDigit);\n+  }\n \n+  /**\n+   * This method returns the currency symbol in local format.  For example,\n+   * \"$\" for Canadian dollars.\n+   *\n+   * @return The currency symbol in local format.\n+   */\n   public String getCurrencySymbol ()\n-    {\n-      return currencySymbol;\n-    }\n+  {\n+    return currencySymbol;\n+  }\n \n+  /**\n+   * This method returns the character used as the decimal point.\n+   *\n+   * @return The character used as the decimal point.\n+   */\n   public char getDecimalSeparator ()\n-    {\n-      return decimalSeparator;\n-    }\n+  {\n+    return decimalSeparator;\n+  }\n \n+  /**\n+   * This method returns the character used to represent a digit in a\n+   * format pattern string.\n+   *\n+   * @return The character used to represent a digit in a format\n+   * pattern string. \n+   */\n   public char getDigit ()\n-    {\n-      return digit;\n-    }\n+  {\n+    return digit;\n+  }\n \n   // This is our own extension.\n   char getExponential ()\n-    {\n-      return exponential;\n-    }\n+  {\n+    return exponential;\n+  }\n \n+  /**\n+   * This method sets the character used to separate groups of digits.  For\n+   * example, the United States uses a comma (,) to separate thousands in\n+   * a number.\n+   *\n+   * @return The character used to separate groups of digits.\n+   */\n   public char getGroupingSeparator ()\n-    {\n-      return groupingSeparator;\n-    }\n+  {\n+    return groupingSeparator;\n+  }\n \n+  /**\n+   * This method returns the character used to represent infinity.\n+   *\n+   * @return The character used to represent infinity.\n+   */\n   public String getInfinity ()\n-    {\n-      return infinity;\n-    }\n+  {\n+    return infinity;\n+  }\n \n+  /**\n+   * This method returns the currency symbol in international format.  For\n+   * example, \"C$\" for Canadian dollars.\n+   *\n+   * @return The currency symbol in international format.\n+   */\n   public String getInternationalCurrencySymbol ()\n-    {\n-      return intlCurrencySymbol;\n-    }\n+  {\n+    return intlCurrencySymbol;\n+  }\n \n+  /**\n+   * This method returns the character used to represent the minus sign.\n+   *\n+   * @return The character used to represent the minus sign.\n+   */\n   public char getMinusSign ()\n-    {\n-      return minusSign;\n-    }\n+  {\n+    return minusSign;\n+  }\n \n+  /**\n+   * This method returns the character used to represent the decimal\n+   * point for currency values.\n+   *\n+   * @return The decimal point character used in currency values.\n+   */\n   public char getMonetaryDecimalSeparator ()\n-    {\n-      return monetarySeparator;\n-    }\n+  {\n+    return monetarySeparator;\n+  }\n \n+  /**\n+   * This method returns the string used to represent the NaN (not a number)\n+   * value.\n+   *\n+   * @return The string used to represent NaN\n+   */\n   public String getNaN ()\n-    {\n-      return NaN;\n-    }\n+  {\n+    return NaN;\n+  }\n \n+  /**\n+   * This method returns the character used to separate positive and negative\n+   * subpatterns in a format pattern.\n+   *\n+   * @return The character used to separate positive and negative subpatterns\n+   * in a format pattern.\n+   */\n   public char getPatternSeparator ()\n-    {\n-      return patternSeparator;\n-    }\n+  {\n+    return patternSeparator;\n+  }\n \n+  /**\n+   * This method returns the character used as the percent sign.\n+   *\n+   * @return The character used as the percent sign.\n+   */\n   public char getPercent ()\n-    {\n-      return percent;\n-    }\n+  {\n+    return percent;\n+  }\n \n+  /**\n+   * This method returns the character used as the per mille character.\n+   *\n+   * @return The per mille character.\n+   */\n   public char getPerMill ()\n-    {\n-      return perMill;\n-    }\n+  {\n+    return perMill;\n+  }\n \n+  /**\n+   * This method returns the character used to represent the digit zero.\n+   *\n+   * @return The character used to represent the digit zero.\n+   */\n   public char getZeroDigit ()\n-    {\n-      return zeroDigit;\n-    }\n+  {\n+    return zeroDigit;\n+  }\n \n+  /**\n+   * This method returns a hash value for this object.\n+   *\n+   * @return A hash value for this object.\n+   */\n   public int hashCode ()\n-    {\n-      // Compute based on zero digit, grouping separator, and decimal\n-      // separator -- JCL book.  This probably isn't a very good hash\n-      // code.\n-      return zeroDigit << 16 + groupingSeparator << 8 + decimalSeparator;\n-    }\n+  {\n+    // Compute based on zero digit, grouping separator, and decimal\n+    // separator -- JCL book.  This probably isn't a very good hash\n+    // code.\n+    return zeroDigit << 16 + groupingSeparator << 8 + decimalSeparator;\n+  }\n \n+  /**\n+   * This method sets the currency symbol to the specified value.\n+   *\n+   * @param currencySymbol The new currency symbol\n+   */\n   public void setCurrencySymbol (String currency)\n-    {\n-      currencySymbol = currency;\n-    }\n+  {\n+    currencySymbol = currency;\n+  }\n \n+  /**\n+   * This method sets the decimal point character to the specified value.\n+   *\n+   * @param decimalSeparator The new decimal point character\n+   */\n   public void setDecimalSeparator (char decimalSep)\n-    {\n-      decimalSeparator = decimalSep;\n-    }\n+  {\n+    decimalSeparator = decimalSep;\n+  }\n \n+  /**\n+   * This method sets the character used to represents a digit in a format\n+   * string to the specified value.\n+   *\n+   * @param digit The character used to represent a digit in a format pattern.\n+   */\n   public void setDigit (char digit)\n-    {\n-      this.digit = digit;\n-    }\n+  {\n+    this.digit = digit;\n+  }\n \n   // This is our own extension.\n   void setExponential (char exp)\n-    {\n-      exponential = exp;\n-    }\n+  {\n+    exponential = exp;\n+  }\n \n+  /**\n+   * This method sets the character used to separate groups of digits.\n+   *\n+   * @param groupingSeparator The character used to separate groups of digits.\n+   */\n   public void setGroupingSeparator (char groupSep)\n-    {\n-      groupingSeparator = groupSep;\n-    }\n+  {\n+    groupingSeparator = groupSep;\n+  }\n \n+  /**\n+   * This method sets the string used to represents infinity.\n+   *\n+   * @param infinity The string used to represent infinity.\n+   */\n   public void setInfinity (String infinity)\n-    {\n-      this.infinity = infinity;\n-    }\n+  {\n+    this.infinity = infinity;\n+  }\n \n+  /**\n+   * This method sets the international currency symbols to the\n+   * specified value. \n+   *\n+   * @param intlCurrencySymbol The new international currency symbol.\n+   */\n   public void setInternationalCurrencySymbol (String currency)\n-    {\n-      intlCurrencySymbol = currency;\n-    }\n+  {\n+    intlCurrencySymbol = currency;\n+  }\n \n+  /**\n+   * This method sets the character used to represent the minus sign.\n+   *\n+   * @param minusSign The character used to represent the minus sign.\n+   */\n   public void setMinusSign (char minusSign)\n-    {\n-      this.minusSign = minusSign;\n-    }\n+  {\n+    this.minusSign = minusSign;\n+  }\n \n+  /**\n+   * This method sets the character used for the decimal point in currency\n+   * values.\n+   *\n+   * @param monetarySeparator The decimal point character used in\n+   *                          currency values. \n+   */\n   public void setMonetaryDecimalSeparator (char decimalSep)\n-    {\n-      monetarySeparator = decimalSep;\n-    }\n+  {\n+    monetarySeparator = decimalSep;\n+  }\n \n+  /**\n+   * This method sets the string used to represent the NaN (not a\n+   * number) value. \n+   *\n+   * @param NaN The string used to represent NaN\n+   */\n   public void setNaN (String nan)\n-    {\n-      NaN = nan;\n-    }\n+  {\n+    NaN = nan;\n+  }\n \n+  /**\n+   * This method sets the character used to separate positive and negative\n+   * subpatterns in a format pattern.\n+   *\n+   * @param patternSeparator The character used to separate positive and\n+   * negative subpatterns in a format pattern.\n+   */\n   public void setPatternSeparator (char patternSep)\n-    {\n-      patternSeparator = patternSep;\n-    }\n+  {\n+    patternSeparator = patternSep;\n+  }\n \n+  /**\n+   * This method sets the character used as the percent sign.\n+   *\n+   * @param percent  The character used as the percent sign.\n+   */\n   public void setPercent (char percent)\n-    {\n-      this.percent = percent;\n-    }\n+  {\n+    this.percent = percent;\n+  }\n \n+  /**\n+   * This method sets the character used as the per mille character.\n+   *\n+   * @param perMill The per mille character.\n+   */\n   public void setPerMill (char perMill)\n-    {\n-      this.perMill = perMill;\n-    }\n+  {\n+    this.perMill = perMill;\n+  }\n \n+  /**\n+   * This method sets the charcter used to represen the digit zero.\n+   *\n+   * @param zeroDigit The character used to represent the digit zero.\n+   */\n   public void setZeroDigit (char zeroDigit)\n-    {\n-      this.zeroDigit = zeroDigit;\n-    }\n+  {\n+    this.zeroDigit = zeroDigit;\n+  }\n \n-  // The names of the instance variables are fixed by the\n-  // serialization spec.\n+  /**\n+   * @serial A string used for the local currency\n+   */\n   private String currencySymbol;\n+  /**\n+   * @serial The <code>char</code> used to separate decimals in a number.\n+   */\n   private char decimalSeparator;\n+  /**\n+   * @serial This is the <code>char</code> used to represent a digit in\n+   * a format specification.\n+   */\n   private char digit;\n+  /**\n+   * @serial This is the <code>char</code> used to represent the exponent\n+   * separator in exponential notation.\n+   */\n   private char exponential;\n+  /**\n+   * @serial This separates groups of thousands in numbers.\n+   */\n   private char groupingSeparator;\n+  /**\n+   * @serial This string represents infinity.\n+   */\n   private String infinity;\n+  /**\n+   * @serial This string represents the local currency in an international\n+   * context, eg, \"C$\" for Canadian dollars.\n+   */\n   private String intlCurrencySymbol;\n+  /**\n+   * @serial This is the character used to represent the minus sign.\n+   */\n   private char minusSign;\n+  /**\n+   * @serial This character is used to separate decimals when formatting\n+   * currency values.\n+   */\n   private char monetarySeparator;\n+  /**\n+   * @serial This string is used the represent the Java NaN value for\n+   * \"not a number\".\n+   */\n   private String NaN;\n+  /**\n+   * @serial This is the character used to separate positive and negative\n+   * subpatterns in a format pattern.\n+   */\n   private char patternSeparator;\n+  /**\n+   * @serial This is the percent symbols\n+   */\n   private char percent;\n+  /**\n+   * @serial This character is used for the mille percent sign.\n+   */\n   private char perMill;\n+  /**\n+   * @serial This value represents the type of object being de-serialized.\n+   * 0 indicates a pre-Java 1.1.6 version, 1 indicates 1.1.6 or later.\n+   */\n   private int serialVersionOnStream = 1;\n+  /**\n+   * @serial This is the character used to represent 0.\n+   */\n   private char zeroDigit;\n+\n   private static final long serialVersionUID = 5772796243397350300L;\n \n   private void readObject(ObjectInputStream stream)"}, {"sha": "57ede5b69d4054d3847cdbbc6a5995d76f54a540", "filename": "libjava/java/text/FieldPosition.java", "status": "modified", "additions": 118, "deletions": 28, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FFieldPosition.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FFieldPosition.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFieldPosition.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,65 +1,155 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* FieldPosition.java -- Keeps track of field positions while formatting\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n /**\n+ * This class is used by the java.text formatting classes to track\n+ * field positions.  A field position is defined by an identifier value\n+ * and begin and end index positions.  The formatting classes in java.text\n+ * typically define constant values for the field identifiers.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Per Bothner <bothner@cygnus.com>\n- * @date October 25, 1998.\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- *\t    Includes JDK 1.2 methods.\n  */\n-\n public class FieldPosition\n {\n-  int field;\n-  int beginIndex;\n-  int endIndex;\n+  /**\n+   * This is the field identifier value.\n+   */\n+  private int field_id;\n+\n+  /**\n+   * This is the beginning index of the field.\n+   */\n+  private int begin;\n+\n+  /**\n+   * This is the ending index of the field.\n+   */\n+  private int end;\n \n-  public FieldPosition (int field)\n+  /**\n+   * This method initializes a new instance of <code>FieldPosition</code> to\n+   * have the specified field id.\n+   *\n+   * @param field_id The field identifier value.\n+   */\n+  public FieldPosition (int field_id)\n   {\n-    this.field = field;\n+    this.field_id = field_id;\n   }\n \n+  /**\n+   * This method returns the field identifier value for this object.\n+   *\n+   * @return The field identifier.\n+   */\n   public int getField ()\n   {\n-    return field;\n+    return field_id;\n   }\n \n+  /**\n+   * This method returns the beginning index for this field.\n+   *\n+   * @return The beginning index.\n+   */\n   public int getBeginIndex ()\n   {\n-    return beginIndex;\n+    return begin;\n   }\n \n-  public int getEndIndex ()\n+  /**\n+   * This method sets the beginning index of this field to the specified value.\n+   *\n+   * @param begin The new beginning index.\n+   */\n+  public void setBeginIndex (int begin)\n   {\n-    return endIndex;\n+    this.begin = begin;\n   }\n \n-  public void setBeginIndex (int index)\n+  /**\n+   * This method returns the ending index for the field.\n+   *\n+   * @return The ending index.\n+   */\n+  public int getEndIndex ()\n   {\n-    beginIndex = index;\n+    return end;\n   }\n \n-  public void setEndIndex (int index)\n+  /**\n+   * This method sets the ending index of this field to the specified value.\n+   *\n+   * @param end The new ending index.\n+   */\n+  public void setEndIndex (int end)\n   {\n-    endIndex = index;\n+    this.end = end;\n   }\n \n+  /**\n+   * This method tests this object for equality against the specified object.\n+   * The objects will be considered equal if and only if:\n+   * <p>\n+   * <ul>\n+   * <li>The specified object is not <code>null</code>.\n+   * <li>The specified object is an instance of <code>FieldPosition</code>.\n+   * <li>The specified object has the same field identifier and beginning\n+   * and ending index as this object.\n+   * </ul>\n+   *\n+   * @param obj The object to test for equality to this object.\n+   *\n+   * @return <code>true</code> if the specified object is equal to\n+   * this object, <code>false</code> otherwise. \n+   */\n   public boolean equals (Object obj)\n   {\n     if (! (obj instanceof FieldPosition))\n       return false;\n-    FieldPosition other = (FieldPosition) obj;\n-    return (field == other.field\n-\t    && beginIndex == other.beginIndex && endIndex == other.endIndex);\n+\n+    FieldPosition fp = (FieldPosition) obj;\n+    return (field_id == fp.field_id\n+\t    && begin == fp.begin\n+\t    && end == fp.end);\n+  }\n+\n+  /**\n+   * This method returns a <code>String</code> representation of this\n+   * object.\n+   *\n+   * @return A <code>String</code> representation of this object.\n+   */\n+  public String toString ()\n+  {\n+    return (getClass ().getName () + \"[field=\" + getField () + \",beginIndex=\"\n+\t    + getBeginIndex () + \",endIndex=\" + getEndIndex () + \"]\");\n   }\n }"}, {"sha": "3aa68c8f3e189b0e836eb858425f2270ec526641", "filename": "libjava/java/text/Format.java", "status": "modified", "additions": 115, "deletions": 23, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFormat.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,44 +1,111 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Format.java -- Abstract superclass for formatting/parsing strings.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n+import java.io.Serializable;\n+\n /**\n+ * This class is the abstract superclass of classes that format and parse\n+ * data to/from <code>Strings</code>.  It is guaranteed that any \n+ * <code>String</code> produced by a concrete subclass of <code>Format</code>\n+ * will be parseable by that same subclass.\n+ * <p>\n+ * In addition to implementing the abstract methods in this class, subclasses\n+ * should provide static factory methods of the form \n+ * <code>getInstance()</code> and <code>getInstance(Locale)</code> if the\n+ * subclass loads different formatting/parsing schemes based on locale.\n+ * These subclasses should also implement a static method called\n+ * <code>getAvailableLocales()</code> which returns an array of \n+ * available locales in the current runtime environment.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Per Bothner <bothner@cygnus.com>\n- * @date October 25, 1998.\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n  */\n-\n-public abstract class Format implements java.io.Serializable, Cloneable\n+public abstract class Format implements Serializable, Cloneable\n {\n+  /**\n+   * This method initializes a new instance of <code>Format</code>.\n+   * It performs no actions, but acts as a default constructor for\n+   * subclasses.\n+   */\n   public Format ()\n   {\n   }\n \n-  public abstract StringBuffer format (Object obj,\n-\t\t\t\t       StringBuffer sbuf, FieldPosition pos);\n-\n-  public final String format (Object obj)\n+  /**\n+   * This method formats an <code>Object</code> into a <code>String</code>.\n+   * \n+   * @param obj The <code>Object</code> to format.\n+   *\n+   * @return The formatted <code>String</code>.\n+   *\n+   * @exception IllegalArgumentException If the <code>Object</code>\n+   * cannot be formatted. \n+   */\n+  public final String format(Object obj) throws IllegalArgumentException\n   {\n-    StringBuffer sbuf = new StringBuffer();\n-    format(obj, sbuf, new FieldPosition(0));\n-    return sbuf.toString();\n+    StringBuffer sb = new StringBuffer ();\n+    format (obj, sb, new FieldPosition (0));\n+    return sb.toString ();\n   }\n \n-  public abstract Object parseObject (String source, ParsePosition pos);\n+  /**\n+   * This method formats an <code>Object</code> into a <code>String</code> and\n+   * appends the <code>String</code> to a <code>StringBuffer</code>.\n+   *\n+   * @param obj The <code>Object</code> to format.\n+   * @param sb The <code>StringBuffer</code> to append to.\n+   * @param pos The desired <code>FieldPosition</code>, which is also\n+   *            updated by this call. \n+   *\n+   * @return The updated <code>StringBuffer</code>.\n+   *\n+   * @exception IllegalArgumentException If the <code>Object</code>\n+   * cannot be formatted. \n+   */\n+  public abstract StringBuffer format (Object obj, StringBuffer sb,\n+\t\t\t\t       FieldPosition pos)\n+    throws IllegalArgumentException;\n \n-  public Object parseObject (String source) throws ParseException\n+  /**\n+   * This method parses a <code>String</code> and converts the parsed \n+   * contents into an <code>Object</code>.\n+   *\n+   * @param str The <code>String to parse.\n+   *\n+   * @return The resulting <code>Object</code>.\n+   *\n+   * @exception ParseException If the <code>String</code> cannot be parsed.\n+   */\n+  public Object parseObject (String str) throws ParseException\n   {\n     ParsePosition pos = new ParsePosition(0);\n-    Object result = parseObject (source, pos);\n+    Object result = parseObject (str, pos);\n     if (result == null)\n       {\n \tint index = pos.getErrorIndex();\n@@ -49,8 +116,33 @@ public Object parseObject (String source) throws ParseException\n     return result;\n   }\n \n+  /**\n+   * This method parses a <code>String</code> and converts the parsed\n+   * contents into an <code>Object</code>. \n+   *\n+   * @param str The <code>String</code> to parse.\n+   * @param pos The starting parse index on input, the ending parse\n+   *            index on output. \n+   *\n+   * @return The parsed <code>Object</code>, or <code>null</code> in\n+   *         case of error.\n+   */\n+  public abstract Object parseObject (String str, ParsePosition pos);\n+\n+  /**\n+   * Creates a copy of this object.\n+   *\n+   * @return The copied <code>Object</code>.\n+   */\n   public Object clone ()\n   {\n-    return super.clone ();\n+    try\n+      {\n+\treturn super.clone ();\n+      }\n+    catch (CloneNotSupportedException e)\n+      {\n+\treturn null;\n+      }\n   }\n }"}, {"sha": "ffe34a68a2f6e77b2cd1bb74aee3fca364070c25", "filename": "libjava/java/text/MessageFormat.java", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FMessageFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FMessageFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FMessageFormat.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,12 +1,29 @@\n-// MessageFormat.java - Localized message formatting.\n+/* MessageFormat.java - Localized message formatting.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/* Copyright (C) 1999, 2001  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n "}, {"sha": "739ca31538eaf7d6999094a4d5f8f0d52633329e", "filename": "libjava/java/text/NumberFormat.java", "status": "modified", "additions": 446, "deletions": 145, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FNumberFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FNumberFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FNumberFormat.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,10 +1,29 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* NumberFormat.java -- Formats and parses numbers\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n@@ -16,50 +35,108 @@\n import java.io.IOException;\n \n /**\n+ * This is the abstract superclass of all classes which format and \n+ * parse numeric values such as decimal numbers, integers, currency values,\n+ * and percentages.  These classes perform their parsing and formatting\n+ * in a locale specific manner, accounting for such items as differing\n+ * currency symbols and thousands separators.\n+ * <p>\n+ * To create an instance of a concrete subclass of <code>NumberFormat</code>,\n+ * do not call a class constructor directly.  Instead, use one of the\n+ * static factory methods in this class such as \n+ * <code>getCurrencyInstance</code>.\n+ * \n  * @author Tom Tromey <tromey@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date March 4, 1999\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 from http://www.javasoft.com.\n  * Status:  Believed complete and correct to 1.2, except getAvailableLocales.\n  */\n-\n public abstract class NumberFormat extends Format implements Cloneable\n {\n+  /**\n+   * This is a constant used to create a <code>FieldPosition</code> object\n+   * that will return the integer portion of a formatted number.\n+   */\n   public static final int INTEGER_FIELD = 0;\n+\n+  /**\n+   * This is a constant used to create a <code>FieldPosition</code> object\n+   * that will return the fractional portion of a formatted number.\n+   */\n   public static final int FRACTION_FIELD = 1;\n \n+  /**\n+   * This method is a specialization of the format method that performs\n+   * a simple formatting of the specified <code>long</code> number.\n+   *\n+   * @param number The <code>long</code> to format.\n+   *\n+   * @return The formatted number\n+   */\n   public final String format (long number)\n-    {\n-      StringBuffer sbuf = new StringBuffer(50);\n-      format (number, sbuf, null);\n-      return sbuf.toString();\n-    }\n+  {\n+    StringBuffer sbuf = new StringBuffer(50);\n+    format (number, sbuf, null);\n+    return sbuf.toString();\n+  }\n \n   public final StringBuffer format (Object obj, StringBuffer sbuf,\n \t\t\t\t    FieldPosition pos)\n-    {\n-      if (obj instanceof Number)\n-        return format(((Number) obj).doubleValue(), sbuf, pos);\n-      else\n-        throw new IllegalArgumentException \n-          (\"Cannot format given Object as a Number\");\n-    }\n+  {\n+    if (obj instanceof Number)\n+      return format(((Number) obj).doubleValue(), sbuf, pos);\n+    else\n+      throw new IllegalArgumentException \n+\t(\"Cannot format given Object as a Number\");\n+  }\n \n+  /**\n+   * This method formats the specified <code>double</code> and appends it to\n+   * a <code>StringBuffer</code>.\n+   * \n+   * @param number The <code>double</code> to format.\n+   * @param sb The <code>StringBuffer</code> to append the formatted number to.\n+   * @param pos The desired <code>FieldPosition</code>.\n+   *\n+   * @return The <code>StringBuffer</code> with the appended number.\n+   */\n   public abstract StringBuffer format (double number,\n \t\t\t\t       StringBuffer sbuf, FieldPosition pos);\n \n+  /**\n+   * This method formats the specified <code>long</code> and appends it to\n+   * a <code>StringBuffer</code>.\n+   * \n+   * @param number The <code>long</code> to format.\n+   * @param sb The <code>StringBuffer</code> to append the formatted number to.\n+   * @param pos The desired <code>FieldPosition</code>.\n+   *\n+   * @return The <code>StringBuffer</code> with the appended number.\n+   */\n   public abstract StringBuffer format (long number,\n \t\t\t\t       StringBuffer sbuf, FieldPosition pos);\n \n-  public Object clone ()\n-  {\n-    // We know the superclass just uses Object's generic cloner.\n-    // Why not just inherit?  Because the online docs specify that\n-    // this method exists for this class.\n-    return super.clone ();\n-  }\n-\n+  /**\n+   * This method tests the specified object for equality against this object.\n+   * This will be <code>true</code> if the following conditions are met:\n+   * <p>\n+   * <ul>\n+   * <li>The specified object is not <code>null</code>.\n+   * <li>The specified object is an instance of <code>NumberFormat</code>.\n+   * </ul>\n+   * <p>\n+   * Since this method does not test much, it is highly advised that \n+   * concrete subclasses override this method.\n+   *\n+   * @param obj The <code>Object</code> to test against equality with\n+   *            this object. \n+   * \n+   * @return <code>true</code> if the specified object is equal to\n+   * this object, <code>false</code> otherwise. \n+   */\n   public boolean equals (Object obj)\n   {\n     if (! (obj instanceof NumberFormat))\n@@ -73,182 +150,406 @@ public boolean equals (Object obj)\n \t    && parseIntegerOnly == nf.parseIntegerOnly);\n   }\n \n+  /**\n+   * This method returns a list of locales for which concrete instances\n+   * of <code>NumberFormat</code> subclasses may be created.\n+   *\n+   * @return The list of available locales.\n+   */\n   public static Locale[] getAvailableLocales ()\n-    {\n-      // FIXME.\n-      return null;\n-    }\n+  {\n+    Locale[] list = new Locale[1];\n+    list[0] = Locale.US;\n+    return list;\n+  }\n \n   private static final NumberFormat computeInstance (Locale loc,\n \t\t\t\t\t\t     String resource,\n \t\t\t\t\t\t     String def)\n-    {\n-      ResourceBundle res;\n-      try\n-\t{\n-\t  res = ResourceBundle.getBundle(\"gnu.gcj.text.LocaleData\", loc);\n-\t}\n-      catch (MissingResourceException x)\n-\t{\n-\t  res = null;\n-\t}\n-      String fmt;\n-      try\n-\t{\n-\t  fmt = res == null ? def : res.getString(resource);\n-\t}\n-      catch (MissingResourceException x)\n-\t{\n-\t  fmt = def;\n-\t}\n-      DecimalFormatSymbols dfs = new DecimalFormatSymbols (loc);\n-      return new DecimalFormat (fmt, dfs);\n-    }\n+  {\n+    ResourceBundle res;\n+    try\n+      {\n+\tres = ResourceBundle.getBundle(\"gnu.java.locale.LocaleInformation\",\n+\t\t\t\t       loc);\n+      }\n+    catch (MissingResourceException x)\n+      {\n+\tres = null;\n+      }\n+    String fmt;\n+    try\n+      {\n+\tfmt = res == null ? def : res.getString(resource);\n+      }\n+    catch (MissingResourceException x)\n+      {\n+\tfmt = def;\n+      }\n+    DecimalFormatSymbols dfs = new DecimalFormatSymbols (loc);\n+    return new DecimalFormat (fmt, dfs);\n+  }\n \n+  /**\n+   * This method returns an instance of <code>NumberFormat</code> suitable\n+   * for formatting and parsing currency values in the default locale.\n+   *\n+   * @return An instance of <code>NumberFormat</code> for handling currencies.\n+   */\n   public static final NumberFormat getCurrencyInstance ()\n-    {\n-      return getCurrencyInstance (Locale.getDefault());\n-    }\n+  {\n+    return getCurrencyInstance (Locale.getDefault());\n+  }\n \n+  /**\n+   * This method returns an instance of <code>NumberFormat</code> suitable\n+   * for formatting and parsing currency values in the specified locale.\n+   *\n+   * @return An instance of <code>NumberFormat</code> for handling currencies.\n+   */\n   public static NumberFormat getCurrencyInstance (Locale loc)\n-    {\n-      return computeInstance (loc, \"currencyFormat\", \"$#,##0.00;($#,##0.00)\");\n-    }\n+  {\n+    return computeInstance (loc, \"currencyFormat\", \"$#,##0.00;($#,##0.00)\");\n+  }\n \n+  /**\n+   * This method returns a default instance for the default locale. This\n+   * will be a concrete subclass of <code>NumberFormat</code>, but the \n+   * actual class returned is dependent on the locale.\n+   *\n+   * @return An instance of the default <code>NumberFormat</code> class.\n+   */\n   public static final NumberFormat getInstance ()\n-    {\n-      return getInstance (Locale.getDefault());\n-    }\n+  {\n+    return getInstance (Locale.getDefault());\n+  }\n \n+  /**\n+   * This method returns a default instance for the specified locale. This\n+   * will be a concrete subclass of <code>NumberFormat</code>, but the \n+   * actual class returned is dependent on the locale.\n+   *\n+   * @param locale The desired locale.\n+   *\n+   * @return An instance of the default <code>NumberFormat</code> class.\n+   */\n   public static NumberFormat getInstance (Locale loc)\n-    {\n-      // For now always return a number instance.\n-      return getNumberInstance (loc);\n-    }\n+  {\n+    // For now always return a number instance.\n+    return getNumberInstance (loc);\n+  }\n \n+  /**\n+   * This method returns the maximum number of digits allowed in the fraction\n+   * portion of a number.\n+   *\n+   * @return The maximum number of digits allowed in the fraction\n+   * portion of a number. \n+   */\n   public int getMaximumFractionDigits ()\n-    {\n-      return maximumFractionDigits;\n-    }\n+  {\n+    return maximumFractionDigits;\n+  }\n \n+  /**\n+   * This method returns the maximum number of digits allowed in the integer\n+   * portion of a number.\n+   *\n+   * @return The maximum number of digits allowed in the integer\n+   * portion of a number. \n+   */\n   public int getMaximumIntegerDigits ()\n-    {\n-      return maximumIntegerDigits;\n-    }\n+  {\n+    return maximumIntegerDigits;\n+  }\n \n+  /**\n+   * This method returns the minimum number of digits allowed in the fraction\n+   * portion of a number.\n+   *\n+   * @return The minimum number of digits allowed in the fraction\n+   * portion of a number. \n+   */\n   public int getMinimumFractionDigits ()\n-    {\n-      return minimumFractionDigits;\n-    }\n+  {\n+    return minimumFractionDigits;\n+  }\n \n+  /**\n+   * This method returns the minimum number of digits allowed in the integer\n+   * portion of a number.\n+   *\n+   * @return The minimum number of digits allowed in the integer\n+   * portion of a number. \n+   */\n   public int getMinimumIntegerDigits ()\n-    {\n-      return minimumIntegerDigits;\n-    }\n+  {\n+    return minimumIntegerDigits;\n+  }\n \n+  /**\n+   * This method returns a default instance for the specified locale. This\n+   * will be a concrete subclass of <code>NumberFormat</code>, but the \n+   * actual class returned is dependent on the locale.\n+   *\n+   * @param locale The desired locale.\n+   *\n+   * @return An instance of the default <code>NumberFormat</code> class.\n+   */\n   public static final NumberFormat getNumberInstance ()\n-    {\n-      return getNumberInstance (Locale.getDefault());\n-    }\n+  {\n+    return getNumberInstance (Locale.getDefault());\n+  }\n \n+  /**\n+   * This method returns a general purpose number formatting and parsing\n+   * class for the default locale.  This will be a concrete subclass of\n+   * <code>NumberFormat</code>, but the actual class returned is dependent\n+   * on the locale.\n+   *\n+   * @return An instance of a generic number formatter for the default locale.\n+   */\n   public static NumberFormat getNumberInstance (Locale loc)\n-    {\n-      return computeInstance (loc, \"numberFormat\", \"#,##0.###\");\n-    }\n+  {\n+    return computeInstance (loc, \"numberFormat\", \"#,##0.###\");\n+  }\n \n+  /**\n+   * This method returns an instance of <code>NumberFormat</code> suitable\n+   * for formatting and parsing percentage values in the default locale.\n+   *\n+   * @return An instance of <code>NumberFormat</code> for handling percentages.\n+   */\n   public static final NumberFormat getPercentInstance ()\n-    {\n-      return getPercentInstance (Locale.getDefault());\n-    }\n+  {\n+    return getPercentInstance (Locale.getDefault());\n+  }\n \n+  /**\n+   * This method returns an instance of <code>NumberFormat</code> suitable\n+   * for formatting and parsing percentage values in the specified locale.\n+   *\n+   * @param locale The desired locale.\n+   *\n+   * @return An instance of <code>NumberFormat</code> for handling percentages.\n+   */\n   public static NumberFormat getPercentInstance (Locale loc)\n-    {\n-      return computeInstance (loc, \"percentFormat\", \"#,##0%\");\n-    }\n+  {\n+    return computeInstance (loc, \"percentFormat\", \"#,##0%\");\n+  }\n \n+  /**\n+   * This method returns a hash value for this object.\n+   *\n+   * @return The hash code.\n+   */\n   public int hashCode ()\n-    {\n-      int hash = super.hashCode();\n-      hash ^= (maximumFractionDigits + maximumIntegerDigits\n-\t       + minimumFractionDigits + minimumIntegerDigits);\n-      if (groupingUsed)\n-\thash ^= 0xf0f0;\n-      if (parseIntegerOnly)\n-\thash ^= 0x0f0f;\n-      return hash;\n-    }\n+  {\n+    int hash = super.hashCode();\n+    hash ^= (maximumFractionDigits + maximumIntegerDigits\n+\t     + minimumFractionDigits + minimumIntegerDigits);\n+    if (groupingUsed)\n+      hash ^= 0xf0f0;\n+    if (parseIntegerOnly)\n+      hash ^= 0x0f0f;\n+    return hash;\n+  }\n \n+  /**\n+   * This method tests whether or not grouping is in use.  Grouping is\n+   * a method of marking separations in numbers, such as thousand separators\n+   * in the US English locale.  The grouping positions and symbols are all\n+   * locale specific.  As an example, with grouping disabled, the number one\n+   * million would appear as \"1000000\".  With grouping enabled, this number\n+   * might appear as \"1,000,000\".  (Both of these assume the US English\n+   * locale).\n+   *\n+   * @return <code>true</code> if grouping is enabled,\n+   * <code>false</code> otherwise. \n+   */\n   public boolean isGroupingUsed ()\n-    {\n-      return groupingUsed;\n-    }\n+  {\n+    return groupingUsed;\n+  }\n \n+  /**\n+   * This method tests whether or not only integer values should be parsed.\n+   * If this class is parsing only integers, parsing stops at the decimal\n+   * point.\n+   *\n+   * @return <code>true</code> if only integers are parsed,\n+   * <code>false</code> otherwise. \n+   */\n   public boolean isParseIntegerOnly ()\n-    {\n-      return parseIntegerOnly;\n-    }\n+  {\n+    return parseIntegerOnly;\n+  }\n \n+  /**\n+   * This is a default constructor for use by subclasses.\n+   */\n   public NumberFormat ()\n-    {\n-    }\n+  {\n+  }\n \n+  /**\n+   * This method parses the specified string into a <code>Number</code>.  This\n+   * will be a <code>Long</code> if possible, otherwise it will be a\n+   * <code>Double</code>.    If no number can be parsed, no exception is\n+   * thrown.  Instead, the parse position remains at its initial index.\n+   *\n+   * @param str The string to parse.\n+   * @param pp The desired <code>ParsePosition</code>.\n+   *\n+   * @return The parsed <code>Number</code>\n+   */\n   public abstract Number parse (String sourceStr, ParsePosition pos);\n \n+  /**\n+   * This method parses the specified string into a <code>Number</code>.  This\n+   * will be a <code>Long</code> if possible, otherwise it will be a\n+   * <code>Double</code>.  If no number can be parsed, an exception will be\n+   * thrown.\n+   *\n+   * @param str The string to parse.\n+   *\n+   * @return The parsed <code>Number</code>\n+   *\n+   * @exception ParseException If no number can be parsed.\n+   */\n   public Number parse (String sourceStr) throws ParseException\n-    {\n-      ParsePosition pp = new ParsePosition (0);\n-      Number r = parse (sourceStr, pp);\n-      if (r == null)\n-\t{\n-\t  int index = pp.getErrorIndex();\n-\t  if (index < 0)\n-\t    index = pp.getIndex();\n-\t  throw new ParseException (\"couldn't parse number\", index);\n-\t}\n-      return r;\n-    }\n+  {\n+    ParsePosition pp = new ParsePosition (0);\n+    Number r = parse (sourceStr, pp);\n+    if (r == null)\n+      {\n+\tint index = pp.getErrorIndex();\n+\tif (index < 0)\n+\t  index = pp.getIndex();\n+\tthrow new ParseException (\"couldn't parse number\", index);\n+      }\n+    return r;\n+  }\n \n+  /**\n+   * This method parses the specified string into an <code>Object</code>.  This\n+   * will be a <code>Long</code> if possible, otherwise it will be a\n+   * <code>Double</code>.    If no number can be parsed, no exception is\n+   * thrown.  Instead, the parse position remains at its initial index.\n+   *\n+   * @param str The string to parse.\n+   * @param pp The desired <code>ParsePosition</code>.\n+  *\n+  * @return The parsed <code>Object</code>\n+  */\n   public final Object parseObject (String sourceStr, ParsePosition pos)\n-    {\n-      return parse (sourceStr, pos);\n-    }\n+  {\n+    return parse (sourceStr, pos);\n+  }\n \n+  /**\n+   * This method sets the grouping behavior of this formatter.  Grouping is\n+   * a method of marking separations in numbers, such as thousand separators\n+   * in the US English locale.  The grouping positions and symbols are all\n+   * locale specific.  As an example, with grouping disabled, the number one\n+   * million would appear as \"1000000\".  With grouping enabled, this number\n+   * might appear as \"1,000,000\".  (Both of these assume the US English\n+   * locale).\n+   *\n+   * @param groupingUsed <code>true</code> to enable grouping,\n+   *                     <code>false</code> to disable it. \n+   */\n   public void setGroupingUsed (boolean newValue)\n-    {\n-      groupingUsed = newValue;\n-    }\n+  {\n+    groupingUsed = newValue;\n+  }\n \n+  /**\n+   * This method sets the maximum number of digits allowed in the fraction\n+   * portion of a number to the specified value.  If this is less than the\n+   * current minimum allowed digits, the minimum allowed digits value will\n+   * be lowered to be equal to the new maximum allowed digits value.\n+   *\n+   * @param maximumFractionDigits The new maximum fraction digits value.\n+   */\n   public void setMaximumFractionDigits (int newValue)\n-    {\n-      maximumFractionDigits = newValue;\n-    }\n+  {\n+    maximumFractionDigits = newValue;\n+    if (getMinimumFractionDigits () > maximumFractionDigits)\n+      setMinimumFractionDigits (maximumFractionDigits);\n+  }\n \n+  /**\n+   * This method sets the maximum number of digits allowed in the integer\n+   * portion of a number to the specified value.  If this is less than the\n+   * current minimum allowed digits, the minimum allowed digits value will\n+   * be lowered to be equal to the new maximum allowed digits value.\n+   *\n+   * @param maximumIntegerDigits The new maximum integer digits value.\n+   */\n   public void setMaximumIntegerDigits (int newValue)\n-    {\n-      maximumIntegerDigits = newValue;\n-    }\n+  {\n+    maximumIntegerDigits = newValue;\n+    if (getMinimumIntegerDigits () > maximumIntegerDigits)\n+      setMinimumIntegerDigits (maximumIntegerDigits);\n+  }\n \n+  /**\n+   * This method sets the minimum number of digits allowed in the fraction\n+   * portion of a number to the specified value.  If this is greater than the\n+   * current maximum allowed digits, the maximum allowed digits value will\n+   * be raised to be equal to the new minimum allowed digits value.\n+   *\n+   * @param minimumFractionDigits The new minimum fraction digits value.\n+   */\n   public void setMinimumFractionDigits (int newValue)\n-    {\n-      minimumFractionDigits = newValue;\n-    }\n+  {\n+    minimumFractionDigits = newValue;\n+    if (getMaximumFractionDigits () < minimumFractionDigits)\n+      setMaximumFractionDigits (minimumFractionDigits);\n+  }\n \n+  /**\n+   * This method sets the minimum number of digits allowed in the integer\n+   * portion of a number to the specified value.  If this is greater than the\n+   * current maximum allowed digits, the maximum allowed digits value will\n+   * be raised to be equal to the new minimum allowed digits value.\n+   *\n+   * @param minimumIntegerDigits The new minimum integer digits value.\n+   */\n   public void setMinimumIntegerDigits (int newValue)\n-    {\n-      minimumIntegerDigits = newValue;\n-    }\n+  {\n+    minimumIntegerDigits = newValue;\n+    if (getMaximumIntegerDigits () < minimumIntegerDigits)\n+      setMaximumIntegerDigits (minimumIntegerDigits);\n+  }\n \n+  /** \n+   * This method sets the parsing behavior of this object to parse only \n+   * integers or not.\n+   *\n+   * @param parseIntegerOnly <code>true</code> to parse only integers,\n+   *                         <code>false</code> otherwise. \n+   */\n   public void setParseIntegerOnly (boolean value)\n-    {\n-      parseIntegerOnly = value;\n-    }\n+  {\n+    parseIntegerOnly = value;\n+  }\n \n+  /**\n+   * This method is a specialization of the format method that performs\n+   * a simple formatting of the specified <code>double</code> number.\n+   *\n+   * @param number The <code>double</code> to format.\n+   *\n+   * @return The formatted number\n+   */\n   public final String format (double number)\n-    {\n-      StringBuffer sbuf = new StringBuffer(50);\n-      format (number, sbuf, null);\n-      return sbuf.toString();\n-    }\n+  {\n+    StringBuffer sbuf = new StringBuffer(50);\n+    format (number, sbuf, null);\n+    return sbuf.toString();\n+  }\n \n   // These field names are fixed by the serialization spec.\n   boolean groupingUsed;"}, {"sha": "765ac4d532f0ecd01d0bea6696e7fa183212e77b", "filename": "libjava/java/text/ParsePosition.java", "status": "modified", "additions": 101, "deletions": 20, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FParsePosition.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FParsePosition.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FParsePosition.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,59 +1,140 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* ParsePosition.java -- Keep track of position while parsing.\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n /**\n+ * This class is used to keep track of the current position during parsing\n+ * operations.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Per Bothner <bothner@cygnus.com>\n- * @date October 25, 1998.\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- *\t    Includes JDK 1.2 methods.\n- */\n-\n public class ParsePosition\n {\n-  int index;\n-  int errorIndex;\n+  /**\n+   * This is the index of the current parse position.\n+   */\n+  private int index;\n \n+  /**\n+   * This is the index of the position where an error occurred during parsing.\n+   */\n+  private int error_index;\n+\n+  /**\n+   * This method initializes a new instance of <code>ParsePosition</code> to\n+   * have the specified initial index value.\n+   *\n+   * @param index The initial parsing index.\n+   */\n   public ParsePosition (int index)\n   {\n     this.index = index;\n-    errorIndex = -1;\n+    error_index = -1;\n   }\n \n+  /**\n+   * This method returns the current parsing index.\n+   *\n+   * @return The current parsing index\n+   */\n   public int getIndex ()\n   {\n     return index;\n   }\n \n+  /**\n+   * This method sets the current parsing index to the specified value.\n+   *\n+   * @param index The new parsing index.\n+   */\n   public void setIndex (int index)\n   {\n     this.index = index;\n   }\n \n+  /**\n+   * This method returns the error index value.  This value defaults to -1\n+   * unless explicitly set to another value.\n+   *\n+   * @return The error index.\n+   */\n   public int getErrorIndex ()\n   {\n-    return errorIndex;\n+    return error_index;\n   }\n \n-  public void setErrorIndex (int ei)\n+  /**\n+   * This method sets the error index to the specified value.\n+   *\n+   * @param error_index The new error index\n+   */\n+  public void setErrorIndex (int error_index)\n   {\n-    errorIndex = ei;\n+    this.error_index = error_index;\n   }\n \n+  /**\n+   * This method tests the specified object for equality with this\n+   * object.  The two objects will be considered equal if and only if\n+   * all of the following conditions are met.\n+   * <p>\n+   * <ul>\n+   * <li>The specified object is not <code>null</code>.\n+   * <li>The specified object is an instance of <code>ParsePosition</code>.\n+   * <li>The specified object has the same index and error index as\n+   *     this object.  \n+   * </ul>\n+   *\n+   * @param obj The <code>Object</code> to test for equality against\n+   *            this object. \n+   *\n+   * @return <code>true</code> if the specified object is equal to\n+   * this object, <code>false</code> otherwise.\n+   */\n   public boolean equals (Object obj)\n   {\n-    if (obj != null || ! (obj instanceof ParsePosition))\n+    if (! (obj instanceof ParsePosition))\n       return false;\n+\n     ParsePosition other = (ParsePosition) obj;\n-    return index == other.index && errorIndex == other.errorIndex;\n+    return index == other.index && error_index == other.error_index;\n+  }\n+\n+  /**\n+   * This method returns a <code>String</code> representation of this\n+   * object.\n+   *\n+   * @return A <code>String</code> that represents this object.\n+   */\n+  public String toString ()\n+  {\n+    return (getClass ().getName () + \"[index=\" + getIndex ()\n+\t    + \",errorIndex=\" + getErrorIndex () + \"]\");\n   }\n }"}, {"sha": "6366082cfd47f59b4d1bf874ce06ae18483ad413", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -207,6 +207,7 @@ public SimpleDateFormat(String pattern, DateFormatSymbols formatData)\n   {\n     super();\n     calendar = new GregorianCalendar();\n+    computeCenturyStart ();\n     tokens = new Vector();\n     this.formatData = formatData;\n     compileFormat(pattern);"}, {"sha": "64af2601df8d7bc9cd6db2e580719f504f966323", "filename": "libjava/java/text/StringCharacterIterator.java", "status": "modified", "additions": 278, "deletions": 82, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java?ref=a1f4e5ed0ad7c060fc1b90c3b363877cb8cca198", "patch": "@@ -1,149 +1,345 @@\n-// StringCharacterIterator.java - Iterate over string of Unicode characters.\n+/* StringCharacterIterator.java -- Iterate over a character range in a string\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n /**\n+ * This class iterates over a range of characters in a <code>String</code>.  \n+ * For a given range of text, a beginning and ending index,\n+ * as well as a current index are defined.  These values can be queried\n+ * by the methods in this interface.  Additionally, various methods allow\n+ * the index to be set. \n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Tom Tromey <tromey@cygnus.com>\n- * @date February 22, 1999\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct to 1.1.\n  */\n-\n public final class StringCharacterIterator implements CharacterIterator\n {\n-  public Object clone ()\n+  /**\n+   * This is the string to iterate over\n+   */\n+  private String text;\n+\n+  /**\n+   * This is the value of the start position of the text range.\n+   */\n+  private int begin;\n+\n+  /**\n+   * This is the value of the ending position of the text range.\n+   */\n+  private int end;\n+\n+  /**\n+   * This is the current value of the scan index.\n+   */\n+  private int index;\n+\n+  /**\n+   * This method initializes a new instance of\n+   * <code>StringCharacterIterator</code> to iterate over the entire\n+   * text of the specified <code>String</code>.  The initial index\n+   * value will be set to the first character in the string.\n+   *\n+   * @param text The <code>String</code> to iterate through.\n+   */\n+  public StringCharacterIterator (String text)\n   {\n-    return (Object) new StringCharacterIterator (text, begin, end, pos);\n+    this (text, 0, text.length (), 0);\n   }\n \n-  public char current ()\n+  /*************************************************************************/\n+\n+  /**\n+   * This method initializes a new instance of\n+   * <code>StringCharacterIterator</code> to iterate over the entire\n+   * text of the specified <code>String</code>.  The initial index\n+   * value will be set to the specified value.\n+   *\n+   * @param text The <code>String</code> to iterate through.\n+   * @param index The initial index position.\n+   */\n+  public StringCharacterIterator (String text, int index)\n   {\n-    // This follows JDK 1.2 semantics and not 1.1 semantics.\n-    // In 1.1 we would throw an exception if begin==end.\n-    return (pos < end) ? text.charAt(pos) : CharacterIterator.DONE;\n+    this (text, 0, text.length (), index);\n   }\n \n-  public boolean equals (Object obj)\n+  /*************************************************************************/\n+\n+  /**\n+   * This method initializes a new instance of\n+   * <code>StringCharacterIterator</code> that iterates over the text\n+   * in a subrange of the specified <code>String</code>.  The\n+   * beginning and end of the range are specified by the caller, as is\n+   * the initial index position.\n+   *\n+   * @param text The <code>String</code> to iterate through.\n+   * @param begin The beginning position in the character range.\n+   * @param end The ending position in the character range.\n+   * @param index The initial index position.\n+   *\n+   * @param IllegalArgumentException If any of the range values are\n+   * invalid.\n+   */\n+  public StringCharacterIterator (String text, int begin, int end, int index)\n   {\n-    if (! (obj instanceof StringCharacterIterator))\n-      return false;\n-    StringCharacterIterator sci = (StringCharacterIterator) obj;\n-    // The spec says \"the same text\".  We take this to mean equals,\n-    // not ==.\n-    return (pos == sci.pos\n-\t    && begin == sci.begin\n-\t    && end == sci.end\n-\t    && text.equals(sci.text));\n+    int len = text.length ();\n+\n+    if ((begin < 0) || (begin > len))\n+      throw new IllegalArgumentException (\"Bad begin position\");\n+\n+    if ((end < begin) || (end > len))\n+      throw new IllegalArgumentException (\"Bad end position\");\n+\n+    if ((index < begin) || (index > end))\n+      throw new IllegalArgumentException (\"Bad initial index position\");\n+\n+    this.text = text;\n+    this.begin = begin;\n+    this.end = end;\n+    this.index = index;\n   }\n \n-  public char first ()\n+  /**\n+   * This is a package level constructor that copies the text out of\n+   * an existing StringCharacterIterator and resets the beginning and\n+   * ending index.\n+   *\n+   * @param scci The StringCharacterIterator to copy the info from\n+   * @param begin The beginning index of the range we are interested in.\n+   * @param end The ending index of the range we are interested in.\n+   */\n+  StringCharacterIterator (StringCharacterIterator sci, int begin, int end)\n   {\n-    pos = begin;\n-    return current ();\n+    this (sci.text, begin, end, begin);\n   }\n \n-  public int getBeginIndex ()\n+  /**\n+   * This method returns the character at the current index position\n+   *\n+   * @return The character at the current index position.\n+   */\n+  public char current ()\n   {\n-    return begin;\n+    return (index < end) ? text.charAt (index) : DONE;\n   }\n \n-  public int getEndIndex ()\n+  /*************************************************************************/\n+\n+  /**\n+   * This method increments the current index and then returns the\n+   * character at the new index value.  If the index is already at\n+   * <code>getEndIndex () - 1</code>, it will not be incremented.\n+   *\n+   * @return The character at the position of the incremented index\n+   * value, or <code>DONE</code> if the index has reached\n+   * getEndIndex () - 1.\n+   */\n+  public char next ()\n   {\n-    return end;\n+    if (index == end)\n+      return DONE;\n+\n+    ++index;\n+    return current ();\n   }\n \n-  public int getIndex ()\n+  /*************************************************************************/\n+\n+  /**\n+   * This method decrements the current index and then returns the\n+   * character at the new index value.  If the index value is already\n+   * at the beginning index, it will not be decremented.\n+   *\n+   * @return The character at the position of the decremented index\n+   * value, or <code>DONE</code> if index was already equal to the\n+   * beginning index value.\n+   */\n+  public char previous ()\n   {\n-    return pos;\n+    if (index == begin)\n+      return DONE;\n+\n+    --index;\n+    return current ();\n   }\n \n-  public int hashCode ()\n+  /*************************************************************************/\n+\n+  /**\n+   * This method sets the index value to the beginning of the range and returns\n+   * the character there.\n+   *\n+   * @return The character at the beginning of the range, or\n+   * <code>DONE</code> if the range is empty. \n+   */\n+  public char first ()\n   {\n-    // FIXME: this is a terrible hash code.  Find a better one.\n-    return text.hashCode() + pos + begin + end;\n+    index = begin;\n+    return current ();\n   }\n \n+  /*************************************************************************/\n+\n+  /**\n+   * This method sets the index value to <code>getEndIndex () - 1</code> and\n+   * returns the character there.  If the range is empty, then the index value\n+   * will be set equal to the beginning index.\n+   *\n+   * @return The character at the end of the range, or\n+   * <code>DONE</code> if the range is empty. \n+   */\n   public char last ()\n   {\n-    pos = end;\n+    if (end == begin)\n+      return DONE;\n+\n+    index = end - 1;\n     return current ();\n   }\n \n-  public char next ()\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the current value of the index.\n+   *\n+   * @return The current index value\n+   */\n+  public int getIndex ()\n   {\n-    if (pos == end)\n-      return CharacterIterator.DONE;\n-    ++pos;\n-    return current ();\n+    return index;\n   }\n \n-  public char previous ()\n+  /*************************************************************************/\n+\n+  /**\n+   * This method sets the value of the index to the specified value, then\n+   * returns the character at that position.\n+   *\n+   * @param index The new index value.\n+   *\n+   * @return The character at the new index value or <code>DONE</code>\n+   * if the index value is equal to <code>getEndIndex</code>. \n+   *\n+   * @exception IllegalArgumentException If the specified index is not valid\n+   */\n+  public char setIndex (int index)\n   {\n-    if (pos == begin)\n-      return CharacterIterator.DONE;\n-    --pos;\n+    if ((index < begin) || (index > end))\n+      throw new IllegalArgumentException (\"Bad index specified\");\n+\n+    this.index = index;\n     return current ();\n   }\n \n-  public char setIndex (int idx)\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the character position of the first character in the\n+   * range.\n+   *\n+   * @return The index of the first character in the range.\n+   */\n+  public int getBeginIndex ()\n   {\n-    // In 1.1 we would throw an error if `idx == end'.\n-    if (idx < begin || idx > end)\n-      throw new IllegalArgumentException ();\n-    pos = idx;\n-    return current ();\n+    return begin;\n   }\n \n-  public StringCharacterIterator (String text)\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns the character position of the end of the text range.\n+   * This will actually be the index of the first character following the\n+   * end of the range.  In the event the text range is empty, this will be\n+   * equal to the first character in the range.\n+   *\n+   * @return The index of the end of the range.\n+   */\n+  public int getEndIndex ()\n   {\n-    this (text, 0, text.length(), 0);\n+    return end;\n   }\n \n-  public StringCharacterIterator (String text, int pos)\n+  /*************************************************************************/\n+\n+  /**\n+   * This method creates a copy of this <code>CharacterIterator</code>.\n+   *\n+   * @return A copy of this <code>CharacterIterator</code>.\n+   */\n+  public Object clone ()\n   {\n-    this (text, 0, text.length(), pos);\n+    return new StringCharacterIterator (text, begin, end, index);\n   }\n \n-  public StringCharacterIterator (String text, int begin, int end, int pos)\n+  /*************************************************************************/\n+\n+  /**\n+   * This method tests this object for equality againt the specified \n+   * object.  This will be true if and only if the specified object:\n+   * <p>\n+   * <ul>\n+   * <li>is not <code>null</code>.\n+   * <li>is an instance of <code>StringCharacterIterator</code>\n+   * <li>has the same text as this object\n+   * <li>has the same beginning, ending, and current index as this object.\n+   * </ul>\n+   *\n+   * @param obj The object to test for equality against.\n+   *\n+   * @return <code>true</code> if the specified object is equal to this\n+   * object, <code>false</code> otherwise.\n+   */\n+  public boolean equals (Object obj)\n   {\n-    if (begin < 0 || begin > end || end > text.length()\n-\t// In 1.1 we would also throw if `pos == end'.\n-\t|| pos < begin || pos > end)\n-      throw new IllegalArgumentException ();\n+    if (! (obj instanceof StringCharacterIterator))\n+      return false;\n \n-    this.text = text;\n-    this.begin = begin;\n-    this.end = end;\n-    this.pos = pos;\n+    StringCharacterIterator sci = (StringCharacterIterator) obj;\n+\n+    return (begin == sci.begin\n+\t    && end == sci.end\n+\t    && index == sci.index\n+\t    && text.equals (sci.text));\n   }\n \n-  // The online 1.2 docs say that this is \"package visible\" in the\n-  // method description, but they also say it is public.  We choose\n-  // the latter for compatibility with the actual implementation.\n+  /*************************************************************************/\n+\n+  /**\n+   * This method allows other classes in java.text to change the value\n+   * of the underlying text being iterated through.\n+   *\n+   * @param text The new <code>String</code> to iterate through.\n+   */\n   public void setText (String text)\n   {\n     this.text = text;\n     this.begin = 0;\n     this.end = text.length ();\n-    this.pos = 0;\n+    this.index = 0;\n   }\n-\n-  // String to iterate over.\n-  private String text;\n-  // Current position.\n-  private int pos;\n-  // Start position in string.\n-  private int begin;\n-  // End position in string.\n-  private int end;\n }"}]}