{"sha": "ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZjNWM2YTk4NDQxZDhlMWFiZTZjZGMwZDJhOTM1OTFlMjExOTFkNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-01-05T05:58:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-01-05T05:58:23Z"}, "message": "c-decl.c (finish_struct): Detect flexible array members used in an inappropriate context.\n\n        * c-decl.c (finish_struct): Detect flexible array members\n        used in an inappropriate context.\n        * c-typeck.c (really_start_incremental_init): Special case\n        constructor_max_index for zero length arrays.\n        (pop_init_level): Allow initialization of flexible array\n        members.  Deprecate initialization of zero length arrays.\n        Don't issue missing initializer warning for flexible array\n        members or zero length arrays.\n        (process_init_element): Don't dereference null DECL_SIZE.\n        * varasm.c (array_size_for_constructor): Return a HOST_WIDE_INT.\n        Don't abort for empty constructors.  Use size_binop\n        (output_constructor): Add commentary regarding zero length\n        array futures.  Abort if we try to initialize an array of\n        unspecified length with a non-empty constructor in the middle\n        of a structure.\n\n        * extend.texi (Zero Length): Update and clarify documentation\n        on static initialization.\n\nFrom-SVN: r38705", "tree": {"sha": "f0375afbbd6220caa4aacf6320495224ac911480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0375afbbd6220caa4aacf6320495224ac911480"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/comments", "author": null, "committer": null, "parents": [{"sha": "00de56c7d0e654b52c23e789dbe3cc32d361a527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00de56c7d0e654b52c23e789dbe3cc32d361a527", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00de56c7d0e654b52c23e789dbe3cc32d361a527"}], "stats": {"total": 234, "additions": 172, "deletions": 62}, "files": [{"sha": "9f5680f0b3eb3b50d5af21b15ddb1add6310ab03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "patch": "@@ -1,3 +1,24 @@\n+2001-01-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-decl.c (finish_struct): Detect flexible array members\n+\tused in an inappropriate context.\n+\t* c-typeck.c (really_start_incremental_init): Special case\n+\tconstructor_max_index for zero length arrays.\n+\t(pop_init_level): Allow initialization of flexible array\n+\tmembers.  Deprecate initialization of zero length arrays.\n+\tDon't issue missing initializer warning for flexible array\n+\tmembers or zero length arrays.\n+\t(process_init_element): Don't dereference null DECL_SIZE.\n+\t* varasm.c (array_size_for_constructor): Return a HOST_WIDE_INT.\n+\tDon't abort for empty constructors.  Use size_binop\n+\t(output_constructor): Add commentary regarding zero length \n+\tarray futures.  Abort if we try to initialize an array of\n+\tunspecified length with a non-empty constructor in the middle\n+\tof a structure.\n+\n+\t* extend.texi (Zero Length): Update and clarify documentation\n+\ton static initialization.\n+\n 2001-01-05  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (c4x_expand_prologue): Don't compile an ISR"}, {"sha": "0a94db0e595e7980ead89d4e5d541b346494b9a6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "patch": "@@ -5200,6 +5200,7 @@ finish_struct (t, fieldlist, attributes)\n {\n   register tree x;\n   int toplevel = global_binding_level == current_binding_level;\n+  int saw_named_field;\n \n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n@@ -5238,6 +5239,7 @@ finish_struct (t, fieldlist, attributes)\n      Store 0 there, except for \": 0\" fields (so we can find them\n      and delete them, below).  */\n \n+  saw_named_field = 0;\n   for (x = fieldlist; x; x = TREE_CHAIN (x))\n     {\n       DECL_CONTEXT (x) = t;\n@@ -5371,6 +5373,22 @@ finish_struct (t, fieldlist, attributes)\n \t}\n \n       DECL_INITIAL (x) = 0;\n+\n+      /* Detect flexible array member in an invalid context.  */\n+      if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n+\t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n+\t  && TYPE_DOMAIN (TREE_TYPE (x)) != NULL_TREE\n+\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (x))) == NULL_TREE)\n+\t{\n+\t  if (TREE_CODE (t) == UNION_TYPE)\n+\t    error_with_decl (x, \"flexible array member in union\");\n+\t  else if (TREE_CHAIN (x) != NULL_TREE)\n+\t    error_with_decl (x, \"flexible array member not at end of struct\");\n+\t  else if (! saw_named_field)\n+\t    error_with_decl (x, \"flexible array member in otherwise empty struct\");\n+\t}\n+      if (DECL_NAME (x))\n+\tsaw_named_field = 1;\n     }\n \n   /* Delete all duplicate fields from the fieldlist */\n@@ -5416,8 +5434,8 @@ finish_struct (t, fieldlist, attributes)\n \tfieldlistp = &TREE_CHAIN (*fieldlistp);\n   }\n \n-  /*  Now we have the truly final field list.\n-      Store it in this type and in the variants.  */\n+  /* Now we have the truly final field list.\n+     Store it in this type and in the variants.  */\n \n   TYPE_FIELDS (t) = fieldlist;\n "}, {"sha": "2868496a53d80adf1d103331d6fcba4f1e244021", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "patch": "@@ -5162,6 +5162,11 @@ really_start_incremental_init (type)\n \t{\n \t  constructor_max_index\n \t    = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n+\n+\t  /* Detect non-empty initializations of zero-length arrays.  */\n+\t  if (constructor_max_index == NULL_TREE)\n+\t    constructor_max_index = build_int_2 (-1, -1);\n+\n \t  constructor_index\n \t    = convert (bitsizetype,\n \t\t       TYPE_MIN_VALUE (TYPE_DOMAIN (constructor_type)));\n@@ -5292,6 +5297,11 @@ push_init_level (implicit)\n \t  constructor_index\n \t    = convert (bitsizetype, \n \t\t       TYPE_MIN_VALUE (TYPE_DOMAIN (constructor_type)));\n+\n+\t  /* ??? For GCC 3.1, remove special case initialization of\n+\t     zero-length array members from pop_init_level and set\n+\t     constructor_max_index such that we get the normal\n+\t     \"excess elements\" warning.  */\n \t}\n       else\n \tconstructor_index = bitsize_zero_node;\n@@ -5337,20 +5347,42 @@ pop_init_level (implicit)\n \n   /* Error for initializing a flexible array member, or a zero-length\n      array member in an inappropriate context.  */\n-  if (constructor_type\n+  if (constructor_type && constructor_fields\n       && TREE_CODE (constructor_type) == ARRAY_TYPE\n       && TYPE_DOMAIN (constructor_type)\n       && ! TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type)))\n     {\n-      if (! TYPE_SIZE (constructor_type))\n-\terror_init (\"initialization of a flexible array member\");\n-      /* Silently discard empty initializations of zero-length arrays.  */\n-      else if (integer_zerop (constructor_unfilled_index))\n-\tconstructor_type = 0;\n-      /* Otherwise we must be initializing a member of a top-level\n-\t structure.  */\n-      else if (constructor_depth != 2)\n-\terror_init (\"initialization of zero-length array inside a nested structure\");\n+      /* Silently discard empty initializations.  The parser will\n+\t already have pedwarned for empty brackets.  */\n+      if (integer_zerop (constructor_unfilled_index))\n+\tconstructor_type = NULL_TREE;\n+      else if (! TYPE_SIZE (constructor_type))\n+\t{\n+\t  if (constructor_depth > 2)\n+\t    error_init (\"initialization of flexible array member in a nested context\");\n+\t  else if (pedantic)\n+\t    pedwarn_init (\"initialization of a flexible array member\");\n+\n+          /* We have already issued an error message for the existance\n+\t     of a flexible array member not at the end of the structure.\n+\t     Discard the initializer so that we do not abort later.  */\n+\t  if (TREE_CHAIN (constructor_fields) != NULL_TREE)\n+\t    constructor_type = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  warning_init (\"deprecated initialization of zero-length array\");\n+\n+          /* We must be initializing the last member of a top-level struct.  */\n+\t  if (TREE_CHAIN (constructor_fields) != NULL_TREE)\n+\t    {\n+\t      error_init (\"initialization of zero-length array before end of structure\");\n+\t      /* Discard the initializer so that we do not abort later.  */\n+\t      constructor_type = NULL_TREE;\n+\t    }\n+\t  else if (constructor_depth > 2)\n+\t    error_init (\"initialization of zero-length array inside a nested context\");\n+\t}\n     }\n \n   /* Warn when some struct elements are implicitly initialized to zero.  */\n@@ -5359,9 +5391,18 @@ pop_init_level (implicit)\n       && TREE_CODE (constructor_type) == RECORD_TYPE\n       && constructor_unfilled_fields)\n     {\n-      push_member_name (constructor_unfilled_fields);\n-      warning_init (\"missing initializer\");\n-      RESTORE_SPELLING_DEPTH (constructor_depth);\n+      /* Do not warn for flexible array members or zero-length arrays.  */\n+      while (constructor_unfilled_fields\n+\t     && (! DECL_SIZE (constructor_unfilled_fields)\n+\t\t || integer_zerop (DECL_SIZE (constructor_unfilled_fields))))\n+\tconstructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n+\n+      if (constructor_unfilled_fields)\n+\t{\n+\t  push_member_name (constructor_unfilled_fields);\n+\t  warning_init (\"missing initializer\");\n+\t  RESTORE_SPELLING_DEPTH (constructor_depth);\n+\t}\n     }\n \n   /* Now output all pending elements.  */\n@@ -6129,10 +6170,11 @@ process_init_element (value)\n \t       directly output as a constructor.  */\n \t    {\n \t      /* For a record, keep track of end position of last field.  */\n-\t      constructor_bit_index\n-\t\t= size_binop (PLUS_EXPR,\n-\t\t\t      bit_position (constructor_fields),\n-\t\t\t      DECL_SIZE (constructor_fields));\n+\t      if (DECL_SIZE (constructor_fields))\n+\t        constructor_bit_index\n+\t\t  = size_binop (PLUS_EXPR,\n+\t\t\t        bit_position (constructor_fields),\n+\t\t\t        DECL_SIZE (constructor_fields));\n \n \t      constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n \t      /* Skip any nameless bit fields.  */"}, {"sha": "7eaf6e9657a6b71dd0d8a06a85bd84c59a64d467", "filename": "gcc/extend.texi", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "patch": "@@ -868,6 +868,7 @@ extension for floating-point constants of type @code{float}.\n @cindex arrays of length zero\n @cindex zero-length arrays\n @cindex length-zero arrays\n+@cindex flexible array members\n \n Zero-length arrays are allowed in GNU C.  They are very useful as the\n last element of a structure which is really a header for a variable-length\n@@ -907,26 +908,52 @@ zero-length arrays anywhere.  You may encounter problems, however,\n defining structures containing only a zero-length array.  Such usage\n is deprecated, and we recommend using zero-length arrays only in\n places in which flexible array members would be allowed.\n+@end itemize\n \n-@item\n-GCC allows static initialization of the zero-length array if the structure\n-is not nested inside another structure.  In addition, for backward\n-compatibility with an earlier versions of gcc, we allow a degenerate empty\n-initialization when nested inside another structure.  I.e.\n+GCC versions before 3.0 allowed zero-length arrays to be statically\n+initialized.  In addition to those cases that were useful, it also\n+allowed initializations in situations that would corrupt later data.\n+Non-empty initialization of zero-length arrays is now deprecated.\n+\n+Instead GCC allows static initialization of flexible array members.\n+This is equivalent to defining a new structure containing the original\n+structure followed by an array of sufficient size to contain the data.\n+I.e. in the following, @code{f1} is constructed as if it were declared\n+like @code{f2}.\n \n @example\n-struct bar @{ struct line a; @};\n+struct f1 @{\n+  int x; int y[];\n+@} f1 = @{ 1, @{ 2, 3, 4 @} @};\n+\n+struct f2 @{\n+  struct f1 f1; int data[3];\n+@} f2 = @{ @{ 1 @}, @{ 2, 3, 4 @} @};\n+@end example\n \n-/* Legal.  */\n-struct line x = @{ 4, @{ 'g', 'o', 'o', 'd' @} @};\n+@noindent\n+The convenience of this extension is that @code{f1} has the desired\n+type, eliminating the need to consistently refer to @code{f2.f1}.\n+\n+This has symmetry with normal static arrays, in that an array of\n+unknown size is also written with @code{[]}.\n \n-/* Illegal.  */\n-struct bar y = @{ @{ 3, @{ 'b', 'a', 'd' @} @} @};\n+Of course, this extension only makes sense if the extra data comes at\n+the end of a top-level object, as otherwise we would be overwriting\n+data at subsequent offsets.  To avoid undue complication and confusion\n+with initialization of deeply nested arrays, we simply disallow any\n+non-empty initialization except when the structure is the top-level\n+object.  For example:\n \n-/* Legal.  */\n-struct bar z = @{ @{ 0, @{ @} @} @};\n+@example\n+struct foo @{ int x; int y[]; @};\n+struct bar @{ struct foo z; @};\n+\n+struct foo a = @{ 1, @{ 2, 3, 4 @} @};        // Legal.\n+struct bar b = @{ @{ 1, @{ 2, 3, 4 @} @} @};    // Illegal.\n+struct bar c = @{ @{ 1, @{ @} @} @};            // Legal.\n+struct foo d[1] = @{ @{ 1 @{ 2, 3, 4 @} @} @};  // Illegal.\n @end example\n-@end itemize\n \n @node Variable Length\n @section Arrays of Variable Length"}, {"sha": "984f40d01cdf535d0c33315e5a3f32b9f41394d0", "filename": "gcc/varasm.c", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ffc5c6a98441d8e1abe6cdc0d2a93591e21191d7", "patch": "@@ -108,7 +108,7 @@ struct varasm_status\n   struct pool_constant *x_first_pool, *x_last_pool;\n \n   /* Current offset in constant pool (does not include any machine-specific\n-     header.  */\n+     header).  */\n   int x_pool_offset;\n \n   /* Chain of all CONST_DOUBLE rtx's constructed for the current function.\n@@ -171,7 +171,7 @@ static void mark_constant_pool\t\tPARAMS ((void));\n static void mark_constants\t\tPARAMS ((rtx));\n static int output_addressed_constants\tPARAMS ((tree));\n static void output_after_function_constants PARAMS ((void));\n-static int array_size_for_constructor\tPARAMS ((tree));\n+static unsigned HOST_WIDE_INT array_size_for_constructor PARAMS ((tree));\n static void output_constructor\t\tPARAMS ((tree, int));\n #ifdef ASM_WEAKEN_LABEL\n static void remove_from_pending_weak_list\tPARAMS ((const char *));\n@@ -4446,19 +4446,12 @@ output_constant (exp, size)\n    arrays of unspecified length.  VAL must be a CONSTRUCTOR of an array\n    type with an unspecified upper bound.  */\n \n-static int\n+static unsigned HOST_WIDE_INT\n array_size_for_constructor (val)\n      tree val;\n {\n   tree max_index, i;\n \n-  if (!val || TREE_CODE (val) != CONSTRUCTOR\n-      || TREE_CODE (TREE_TYPE (val)) != ARRAY_TYPE\n-      || TYPE_DOMAIN (TREE_TYPE (val)) == NULL_TREE\n-      || TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (val))) != NULL_TREE\n-      || TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (val))) == NULL_TREE)\n-    abort ();\n-\n   max_index = NULL_TREE;\n   for (i = CONSTRUCTOR_ELTS (val); i ; i = TREE_CHAIN (i))\n     {\n@@ -4470,20 +4463,17 @@ array_size_for_constructor (val)\n \tmax_index = index;\n     }\n \n-  /* ??? I'm fairly certain if there were no elements, we shouldn't have\n-     created the constructor in the first place.  */\n   if (max_index == NULL_TREE)\n-    abort ();\n+    return 0;\n \n   /* Compute the total number of array elements.  */\n-  i = fold (build (MINUS_EXPR, TREE_TYPE (max_index), max_index, \n-\t\t   TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (val)))));\n-  i = fold (build (PLUS_EXPR, TREE_TYPE (i), i,\n-\t\t   convert (TREE_TYPE (i), integer_one_node)));\n+  i = size_binop (MINUS_EXPR, convert (sizetype, max_index), \n+\t\t  convert (sizetype,\n+\t\t\t   TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (val)))));\n+  i = size_binop (PLUS_EXPR, i, convert (sizetype, integer_one_node));\n \n   /* Multiply by the array element unit size to find number of bytes.  */\n-  i = fold (build (MULT_EXPR, TREE_TYPE (max_index), i,\n-\t\t   TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (val)))));\n+  i = size_binop (MULT_EXPR, i, TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (val))));\n \n   return tree_low_cst (i, 1);\n }\n@@ -4607,18 +4597,30 @@ output_constructor (exp, size)\n \t  /* Determine size this element should occupy.  */\n \t  if (field)\n \t    {\n-\t      /* If the last field is an array with an unspecified upper\n-\t\t bound, the initializer determines the size.  */\n-\t      if (TREE_CHAIN (field) == 0\n-\t\t  && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n-\t\t  && TYPE_DOMAIN (TREE_TYPE (field)) != 0\n-\t\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))) == 0)\n+\t      fieldsize = 0;\n+\n+\t      /* If this is an array with an unspecified upper bound,\n+\t\t the initializer determines the size.  */\n+\t      /* ??? This ought to only checked if DECL_SIZE_UNIT is NULL,\n+\t\t but we cannot do this until the deprecated support for\n+\t\t initializing zero-length array members is removed.  */\n+\t      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n+\t\t  && TYPE_DOMAIN (TREE_TYPE (field))\n+\t\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))\n+\t\t{\n \t\t  fieldsize = array_size_for_constructor (val);\n-\t      else if (DECL_SIZE_UNIT (field)\n-\t\t  && host_integerp (DECL_SIZE_UNIT (field), 1))\n-\t\tfieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);\n-\t      else\n-\t\tfieldsize = 0;\n+\t\t  /* Given a non-empty initialization, this field had\n+\t\t     better be last.  */\n+\t\t  if (fieldsize != 0 && TREE_CHAIN (field) != NULL_TREE)\n+\t\t    abort ();\n+\t\t}\n+\t      else if (DECL_SIZE_UNIT (field))\n+\t\t{\n+\t\t  /* ??? This can't be right.  If the decl size overflows\n+\t\t     a host integer we will silently emit no data.  */\n+\t\t  if (host_integerp (DECL_SIZE_UNIT (field), 1))\n+\t\t    fieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);\n+\t\t}\n \t    }\n \t  else\n \t    fieldsize = int_size_in_bytes (TREE_TYPE (type));"}]}