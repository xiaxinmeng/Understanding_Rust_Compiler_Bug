{"sha": "85f241149328ce8e677cbdfa7fa8592aca155066", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmMjQxMTQ5MzI4Y2U4ZTY3N2NiZGZhN2ZhODU5MmFjYTE1NTA2Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-10-23T17:42:11Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-10-23T17:42:11Z"}, "message": "PR c++/91369 Implement P0784R7 changes to allocation and construction\n\nThis patch is the first part of library support for constexpr\nstd::vector and std::string. This only includes the changes to\nstd::allocator, std::allocator_traits, std::construct_at,\nstd::destroy_at, std::destroy and std::destroy_n.\n\nstd::allocator::allocate and std::allocator::deallocate need to be\nadded so that they can be intercepted by the compiler during constant\nevaluation. Outside of constant evaluation those new member functions\njust forward to the existing implementation in the base class.\n\n\tPR c++/91369 Implement P0784R7 changes to allocation and construction\n\t* include/bits/alloc_traits.h: Include <bits/stl_construct.h>.\n\t(allocator_traits::_S_allocate, allocator_traits::_S_construct)\n\t(allocator_traits::_S_destroy, allocator_traits::_S_max_size)\n\t(allocator_traits::_S_select, allocator_traits::allocate)\n\t(allocator_traits::deallocate, allocator_traits::construct)\n\t(allocator_traits::destroy, allocator_traits::max_size)\n\t(allocator_traits::select_on_container_copy_construction)\n\t(allocator_traits<allocator<T>>): Add constexpr specifier for C++20.\n\t(allocator_traits<allocator<T>>::construct): Use construct_at.\n\t(allocator_traits<allocator<T>>::destroy): Use destroy_at.\n\t(__alloc_on_copy, __alloc_on_move, __alloc_on_swap): Add constexpr\n\tspecifier.\n\t(_Destroy(ForwardIterator, ForwardIterator, Alloc&))\n\t(_Destroy(ForwardIterator, ForwardIterator, allocator<T>&)): Move here\n\tfrom <bits/stl_construct.h>.\n\t* include/bits/allocator.h (allocator::~allocator): Remove for C++20.\n\t(allocator::allocate, allocate::deallocate): Define for C++20 and up.\n\t(operator==, operator!=): Add constexpr specifier for C++20.\n\t* include/bits/stl_construct.h: Don't include <ext/alloc_traits.h>.\n\t(destroy_at): For C++20 add constexpr specifier and support for\n\tdestroying arrays.\n\t(construct_at): Define new function for C++20.\n\t(_Construct): Return result of placement new-expression. For C++11 and\n\tup add constexpr. For C++20 dispatch to std::construct_at during\n\tconstant evaluation.\n\t(_Destroy(pointer)): Add constexpr specifier. For C++20 dispatch to\n\tstd::destroy_at during constant evaluation.\n\t(_Destroy_aux::__destroy, _Destroy_n_aux::__destroy_n): Add constexpr\n\tspecifier for C++20.\n\t(_Destroy(ForwardIterator, ForwardIterator))\n\t(_Destroy(ForwardIterator, Size)): Likewise. Do not elide trivial\n\tdestructors during constant evaluation.\n\t(destroy, destroy_n): Add constexpr specifier for C++20.\n\t(_Destroy(ForwardIterator, ForwardIterator, Alloc&))\n\t(_Destroy(ForwardIterator, ForwardIterator, allocator<T>&)): Move to\n\t<bits/alloc_traits.h>, to remove dependency on allocators.\n\t* include/bits/stl_uninitialized.h: Include <ext/alloc_traits.h>.\n\tInclude <bits/stl_pair.h> instead of <utility>.\n\t* include/ext/alloc_traits.h: Always include <bits/alloc_traits.h>.\n\t(__alloc_traits::construct, __alloc_traits::destroy)\n\t(__alloc_traits::_S_select_on_copy, __alloc_traits::_S_on_swap): Add\n\tconstexpr specifier.\n\t* include/ext/malloc_allocator.h  (operator==, operator!=): Add\n\tconstexpr specifier for C++20.\n\t* include/ext/new_allocator.h (operator==, operator!=): Likewise.\n\t* testsuite/20_util/headers/memory/synopsis.cc: Add constexpr.\n\t* testsuite/20_util/scoped_allocator/69293_neg.cc: Ignore additional\n\terrors due to constexpr function called after failed static_assert.\n\t* testsuite/20_util/specialized_algorithms/construct_at/1.cc: New test.\n\t* testsuite/23_containers/vector/cons/destructible_debug_neg.cc:\n\tIgnore additional errors due to constexpr function called after failed\n\tstatic_assert.\n\t* testsuite/23_containers/vector/cons/destructible_neg.cc: Likewise.\n\nFrom-SVN: r277342", "tree": {"sha": "ea9f06cfdd30d741a5e5c585fcf7737e68a15f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea9f06cfdd30d741a5e5c585fcf7737e68a15f16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f241149328ce8e677cbdfa7fa8592aca155066", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f241149328ce8e677cbdfa7fa8592aca155066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f241149328ce8e677cbdfa7fa8592aca155066", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f241149328ce8e677cbdfa7fa8592aca155066/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0744333e5acfc814c5de9df479f40df1bf31e19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0744333e5acfc814c5de9df479f40df1bf31e19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0744333e5acfc814c5de9df479f40df1bf31e19d"}], "stats": {"total": 454, "additions": 343, "deletions": 111}, "files": [{"sha": "1e98ea3219eb56a1137d731659e0a94e9a2ad4f3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -1,5 +1,60 @@\n 2019-10-23  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR c++/91369 Implement P0784R7 changes to allocation and construction\n+\t* include/bits/alloc_traits.h: Include <bits/stl_construct.h>.\n+\t(allocator_traits::_S_allocate, allocator_traits::_S_construct)\n+\t(allocator_traits::_S_destroy, allocator_traits::_S_max_size)\n+\t(allocator_traits::_S_select, allocator_traits::allocate)\n+\t(allocator_traits::deallocate, allocator_traits::construct)\n+\t(allocator_traits::destroy, allocator_traits::max_size)\n+\t(allocator_traits::select_on_container_copy_construction)\n+\t(allocator_traits<allocator<T>>): Add constexpr specifier for C++20.\n+\t(allocator_traits<allocator<T>>::construct): Use construct_at.\n+\t(allocator_traits<allocator<T>>::destroy): Use destroy_at.\n+\t(__alloc_on_copy, __alloc_on_move, __alloc_on_swap): Add constexpr\n+\tspecifier.\n+\t(_Destroy(ForwardIterator, ForwardIterator, Alloc&))\n+\t(_Destroy(ForwardIterator, ForwardIterator, allocator<T>&)): Move here\n+\tfrom <bits/stl_construct.h>.\n+\t* include/bits/allocator.h (allocator::~allocator): Remove for C++20.\n+\t(allocator::allocate, allocate::deallocate): Define for C++20 and up.\n+\t(operator==, operator!=): Add constexpr specifier for C++20.\n+\t* include/bits/stl_construct.h: Don't include <ext/alloc_traits.h>.\n+\t(destroy_at): For C++20 add constexpr specifier and support for\n+\tdestroying arrays.\n+\t(construct_at): Define new function for C++20.\n+\t(_Construct): Return result of placement new-expression. For C++11 and\n+\tup add constexpr. For C++20 dispatch to std::construct_at during\n+\tconstant evaluation.\n+\t(_Destroy(pointer)): Add constexpr specifier. For C++20 dispatch to\n+\tstd::destroy_at during constant evaluation.\n+\t(_Destroy_aux::__destroy, _Destroy_n_aux::__destroy_n): Add constexpr\n+\tspecifier for C++20.\n+\t(_Destroy(ForwardIterator, ForwardIterator))\n+\t(_Destroy(ForwardIterator, Size)): Likewise. Do not elide trivial\n+\tdestructors during constant evaluation.\n+\t(destroy, destroy_n): Add constexpr specifier for C++20.\n+\t(_Destroy(ForwardIterator, ForwardIterator, Alloc&))\n+\t(_Destroy(ForwardIterator, ForwardIterator, allocator<T>&)): Move to\n+\t<bits/alloc_traits.h>, to remove dependency on allocators.\n+\t* include/bits/stl_uninitialized.h: Include <ext/alloc_traits.h>.\n+\tInclude <bits/stl_pair.h> instead of <utility>.\n+\t* include/ext/alloc_traits.h: Always include <bits/alloc_traits.h>.\n+\t(__alloc_traits::construct, __alloc_traits::destroy)\n+\t(__alloc_traits::_S_select_on_copy, __alloc_traits::_S_on_swap): Add\n+\tconstexpr specifier.\n+\t* include/ext/malloc_allocator.h  (operator==, operator!=): Add\n+\tconstexpr specifier for C++20.\n+\t* include/ext/new_allocator.h (operator==, operator!=): Likewise.\n+\t* testsuite/20_util/headers/memory/synopsis.cc: Add constexpr.\n+\t* testsuite/20_util/scoped_allocator/69293_neg.cc: Ignore additional\n+\terrors due to constexpr function called after failed static_assert.\n+\t* testsuite/20_util/specialized_algorithms/construct_at/1.cc: New test.\n+\t* testsuite/23_containers/vector/cons/destructible_debug_neg.cc:\n+\tIgnore additional errors due to constexpr function called after failed\n+\tstatic_assert.\n+\t* testsuite/23_containers/vector/cons/destructible_neg.cc: Likewise.\n+\n \t* testsuite/20_util/bind/91371.cc: Fix test to compile as C++11.\n \n \t* include/debug/helper_functions.h (__valid_range): Change"}, {"sha": "26d6d26ae48469144291604450ca3ee1dfa80aaa", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 83, "deletions": 42, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -30,18 +30,21 @@\n #ifndef _ALLOC_TRAITS_H\n #define _ALLOC_TRAITS_H 1\n \n-#if __cplusplus >= 201103L\n-\n+#include <bits/stl_construct.h>\n #include <bits/memoryfwd.h>\n-#include <bits/ptr_traits.h>\n-#include <ext/numeric_traits.h>\n-\n-#define __cpp_lib_allocator_traits_is_always_equal 201411\n+#if __cplusplus >= 201103L\n+# include <bits/allocator.h>\n+# include <bits/ptr_traits.h>\n+# include <ext/numeric_traits.h>\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+#if __cplusplus >= 201103L\n+#define __cpp_lib_allocator_traits_is_always_equal 201411\n+\n   struct __allocator_traits_base\n   {\n     template<typename _Tp, typename _Up, typename = void>\n@@ -209,13 +212,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       template<typename _Alloc2>\n-\tstatic auto\n+\tstatic constexpr auto\n \t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)\n \t-> decltype(__a.allocate(__n, __hint))\n \t{ return __a.allocate(__n, __hint); }\n \n       template<typename _Alloc2>\n-\tstatic pointer\n+\tstatic constexpr pointer\n \t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)\n \t{ return __a.allocate(__n); }\n \n@@ -238,41 +241,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  = typename __construct_helper<_Tp, _Args...>::type;\n \n       template<typename _Tp, typename... _Args>\n-\tstatic _Require<__has_construct<_Tp, _Args...>>\n+\tstatic constexpr _Require<__has_construct<_Tp, _Args...>>\n \t_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n \tnoexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))\n \t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n \n       template<typename _Tp, typename... _Args>\n-\tstatic\n+\tstatic constexpr\n \t_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,\n \t\t\t       is_constructible<_Tp, _Args...>>>\n \t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n \tnoexcept(noexcept(::new((void*)__p)\n \t\t\t  _Tp(std::forward<_Args>(__args)...)))\n-\t{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n+\t{ std::_Construct(__p, std::forward<_Args>(__args)...); }\n \n       template<typename _Alloc2, typename _Tp>\n-\tstatic auto\n+\tstatic constexpr auto\n \t_S_destroy(_Alloc2& __a, _Tp* __p, int)\n \tnoexcept(noexcept(__a.destroy(__p)))\n \t-> decltype(__a.destroy(__p))\n \t{ __a.destroy(__p); }\n \n       template<typename _Alloc2, typename _Tp>\n-\tstatic void\n+\tstatic constexpr void\n \t_S_destroy(_Alloc2&, _Tp* __p, ...)\n \tnoexcept(noexcept(__p->~_Tp()))\n-\t{ __p->~_Tp(); }\n+\t{ std::_Destroy(__p); }\n \n       template<typename _Alloc2>\n-\tstatic auto\n+\tstatic constexpr auto\n \t_S_max_size(_Alloc2& __a, int)\n \t-> decltype(__a.max_size())\n \t{ return __a.max_size(); }\n \n       template<typename _Alloc2>\n-\tstatic size_type\n+\tstatic constexpr size_type\n \t_S_max_size(_Alloc2&, ...)\n \t{\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -282,13 +285,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       template<typename _Alloc2>\n-\tstatic auto\n+\tstatic constexpr auto\n \t_S_select(_Alloc2& __a, int)\n \t-> decltype(__a.select_on_container_copy_construction())\n \t{ return __a.select_on_container_copy_construction(); }\n \n       template<typename _Alloc2>\n-\tstatic _Alloc2\n+\tstatic constexpr _Alloc2\n \t_S_select(_Alloc2& __a, ...)\n \t{ return __a; }\n \n@@ -301,7 +304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        *  Calls @c a.allocate(n)\n       */\n-      _GLIBCXX_NODISCARD static pointer\n+      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n       allocate(_Alloc& __a, size_type __n)\n       { return __a.allocate(__n); }\n \n@@ -316,7 +319,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  Returns <tt> a.allocate(n, hint) </tt> if that expression is\n        *  well-formed, otherwise returns @c a.allocate(n)\n       */\n-      _GLIBCXX_NODISCARD static pointer\n+      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n       allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)\n       { return _S_allocate(__a, __n, __hint, 0); }\n \n@@ -328,7 +331,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        *  Calls <tt> a.deallocate(p, n) </tt>\n       */\n-      static void\n+      static _GLIBCXX20_CONSTEXPR void\n       deallocate(_Alloc& __a, pointer __p, size_type __n)\n       { __a.deallocate(__p, __n); }\n \n@@ -344,7 +347,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  arguments @a __args...\n       */\n       template<typename _Tp, typename... _Args>\n-\tstatic auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n+\tstatic _GLIBCXX20_CONSTEXPR auto\n+\tconstruct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n \tnoexcept(noexcept(_S_construct(__a, __p,\n \t\t\t\t       std::forward<_Args>(__args)...)))\n \t-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))\n@@ -359,7 +363,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  otherwise calls @c __p->~_Tp()\n       */\n       template<typename _Tp>\n-\tstatic void destroy(_Alloc& __a, _Tp* __p)\n+\tstatic _GLIBCXX20_CONSTEXPR void\n+\tdestroy(_Alloc& __a, _Tp* __p)\n \tnoexcept(noexcept(_S_destroy(__a, __p, 0)))\n \t{ _S_destroy(__a, __p, 0); }\n \n@@ -371,7 +376,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  Returns @c __a.max_size() if that expression is well-formed,\n        *  otherwise returns @c numeric_limits<size_type>::max()\n       */\n-      static size_type max_size(const _Alloc& __a) noexcept\n+      static _GLIBCXX20_CONSTEXPR size_type\n+      max_size(const _Alloc& __a) noexcept\n       { return _S_max_size(__a, 0); }\n \n       /**\n@@ -382,7 +388,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  Returns @c __rhs.select_on_container_copy_construction() if that\n        *  expression is well-formed, otherwise returns @a __rhs\n       */\n-      static _Alloc\n+      static _GLIBCXX20_CONSTEXPR _Alloc\n       select_on_container_copy_construction(const _Alloc& __rhs)\n       { return _S_select(__rhs, 0); }\n     };\n@@ -440,7 +446,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        *  Calls @c a.allocate(n)\n       */\n-      _GLIBCXX_NODISCARD static pointer\n+      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n       allocate(allocator_type& __a, size_type __n)\n       { return __a.allocate(__n); }\n \n@@ -454,7 +460,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        *  Returns <tt> a.allocate(n, hint) </tt>\n       */\n-      _GLIBCXX_NODISCARD static pointer\n+      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n       allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n       {\n #if __cplusplus <= 201703L\n@@ -472,27 +478,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        *  Calls <tt> a.deallocate(p, n) </tt>\n       */\n-      static void\n+      static _GLIBCXX20_CONSTEXPR void\n       deallocate(allocator_type& __a, pointer __p, size_type __n)\n       { __a.deallocate(__p, __n); }\n \n       /**\n-       *  @brief  Construct an object of type @a _Up\n+       *  @brief  Construct an object of type `_Up`\n        *  @param  __a  An allocator.\n-       *  @param  __p  Pointer to memory of suitable size and alignment for Tp\n+       *  @param  __p  Pointer to memory of suitable size and alignment for\n+       *\t       an object of type `_Up`.\n        *  @param  __args Constructor arguments.\n        *\n-       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>\n+       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`\n+       *  in C++11, C++14 and C++17. Changed in C++20 to call\n+       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.\n       */\n       template<typename _Up, typename... _Args>\n-\tstatic void\n+\tstatic _GLIBCXX20_CONSTEXPR void\n \tconstruct(allocator_type& __a, _Up* __p, _Args&&... __args)\n \tnoexcept(noexcept(::new((void*)__p) _Up(std::forward<_Args>(__args)...)))\n \t{\n #if __cplusplus <= 201703L\n \t  __a.construct(__p, std::forward<_Args>(__args)...);\n #else\n-\t  ::new((void*)__p) _Up(std::forward<_Args>(__args)...);\n+\t  std::construct_at(__p, std::forward<_Args>(__args)...);\n #endif\n \t}\n \n@@ -504,14 +513,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  Calls @c __a.destroy(__p).\n       */\n       template<typename _Up>\n-\tstatic void\n+\tstatic _GLIBCXX20_CONSTEXPR void\n \tdestroy(allocator_type& __a, _Up* __p)\n \tnoexcept(is_nothrow_destructible<_Up>::value)\n \t{\n #if __cplusplus <= 201703L\n \t  __a.destroy(__p);\n #else\n-\t  __p->~_Up();\n+\t  std::destroy_at(__p);\n #endif\n \t}\n \n@@ -520,7 +529,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @param  __a  An allocator.\n        *  @return @c __a.max_size()\n       */\n-      static size_type\n+      static _GLIBCXX20_CONSTEXPR size_type\n       max_size(const allocator_type& __a) noexcept\n       {\n #if __cplusplus <= 201703L\n@@ -535,7 +544,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @param  __rhs  An allocator.\n        *  @return @c __rhs\n       */\n-      static allocator_type\n+      static _GLIBCXX20_CONSTEXPR allocator_type\n       select_on_container_copy_construction(const allocator_type& __rhs)\n       { return __rhs; }\n     };\n@@ -553,7 +562,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n   template<typename _Alloc>\n-    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)\n+    constexpr void\n+    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)\n     {\n       typedef allocator_traits<_Alloc> __traits;\n       typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n@@ -566,7 +576,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Alloc>\n-    inline _Alloc __alloc_on_copy(const _Alloc& __a)\n+    constexpr _Alloc\n+    __alloc_on_copy(const _Alloc& __a)\n     {\n       typedef allocator_traits<_Alloc> __traits;\n       return __traits::select_on_container_copy_construction(__a);\n@@ -583,7 +594,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n   template<typename _Alloc>\n-    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)\n+    constexpr void\n+    __alloc_on_move(_Alloc& __one, _Alloc& __two)\n     {\n       typedef allocator_traits<_Alloc> __traits;\n       typedef typename __traits::propagate_on_container_move_assignment __pocma;\n@@ -609,7 +621,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n   template<typename _Alloc>\n-    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)\n+    constexpr void\n+    __alloc_on_swap(_Alloc& __one, _Alloc& __two)\n     {\n       typedef allocator_traits<_Alloc> __traits;\n       typedef typename __traits::propagate_on_container_swap __pocs;\n@@ -685,8 +698,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Alloc>\n     using _RequireNotAllocator\n       = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;\n+#endif // C++11\n+\n+  /**\n+   * Destroy a range of objects using the supplied allocator.  For\n+   * non-default allocators we do not optimize away invocation of\n+   * destroy() even if _Tp has a trivial destructor.\n+   */\n+\n+  template<typename _ForwardIterator, typename _Allocator>\n+    void\n+    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n+\t     _Allocator& __alloc)\n+    {\n+      for (; __first != __last; ++__first)\n+#if __cplusplus < 201103L\n+\t__alloc.destroy(std::__addressof(*__first));\n+#else\n+\tallocator_traits<_Allocator>::destroy(__alloc,\n+\t\t\t\t\t      std::__addressof(*__first));\n+#endif\n+    }\n+\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline void\n+    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n+\t     allocator<_Tp>&)\n+    {\n+      _Destroy(__first, __last);\n+    }\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n-#endif // C++11\n #endif // _ALLOC_TRAITS_H"}, {"sha": "1a3eb88eded69a461ca2b4bb3f1b8cf2a0fe14d3", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -154,27 +154,56 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_GLIBCXX20_CONSTEXPR\n \tallocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }\n \n+#if __cplusplus <= 201703L\n       ~allocator() _GLIBCXX_NOTHROW { }\n+#endif\n+\n+#if __cplusplus > 201703L\n+      [[nodiscard,__gnu__::__always_inline__]]\n+      constexpr _Tp*\n+      allocate(size_t __n)\n+      {\n+#ifdef __cpp_lib_is_constant_evaluated\n+\tif (std::is_constant_evaluated())\n+\t  return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\n+#endif\n+\treturn __allocator_base<_Tp>::allocate(__n, 0);\n+      }\n+\n+      [[__gnu__::__always_inline__]]\n+      constexpr void\n+      deallocate(_Tp* __p, size_t __n)\n+      {\n+#ifdef __cpp_lib_is_constant_evaluated\n+\tif (std::is_constant_evaluated())\n+\t  {\n+\t    ::operator delete(__p);\n+\t    return;\n+\t  }\n+#endif\n+\t  __allocator_base<_Tp>::deallocate(__p, __n);\n+      }\n+#endif // C++20\n \n-      friend bool\n+      friend _GLIBCXX20_CONSTEXPR bool\n       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n       { return true; }\n \n-      friend bool\n+      friend _GLIBCXX20_CONSTEXPR bool\n       operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n       { return false; }\n \n       // Inherit everything else.\n     };\n \n   template<typename _T1, typename _T2>\n-    inline bool\n+    inline _GLIBCXX20_CONSTEXPR bool\n     operator==(const allocator<_T1>&, const allocator<_T2>&)\n     _GLIBCXX_NOTHROW\n     { return true; }\n \n   template<typename _T1, typename _T2>\n-    inline bool\n+    inline _GLIBCXX20_CONSTEXPR bool\n     operator!=(const allocator<_T1>&, const allocator<_T2>&)\n     _GLIBCXX_NOTHROW\n     { return false; }"}, {"sha": "a16196ffe748466d8ed9c9d4547e2ed336430d23", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "modified", "additions": 77, "deletions": 51, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -58,29 +58,69 @@\n \n #include <new>\n #include <bits/move.h>\n-#include <ext/alloc_traits.h>\n+#include <bits/stl_iterator_base_types.h> // for iterator_traits\n+#include <bits/stl_iterator_base_funcs.h> // for advance\n+\n+/* This file provides the C++17 functions std::destroy_at, std::destroy, and\n+ * std::destroy_n, and the C++20 function std::construct_at.\n+ * It also provides std::_Construct, std::_Destroy,and std::_Destroy_n functions\n+ * which are defined in all standard modes and so can be used in C++98-14 code.\n+ * The _Construct and _Destroy functions will dispatch to construct_at and\n+ * destroy_at during constant evaluation, because calls to those functions are\n+ * intercepted by the compiler to allow use in constant expressions.\n+ */\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+#if __cplusplus >= 201703L\n+  template <typename _Tp>\n+    _GLIBCXX20_CONSTEXPR inline void\n+    destroy_at(_Tp* __location)\n+    {\n+      if constexpr (__cplusplus > 201703L && is_array_v<_Tp>)\n+\t{\n+\t  for (auto& __x : *__location)\n+\t    std::destroy_at(std::__addressof(__x));\n+\t}\n+      else\n+\t__location->~_Tp();\n+    }\n+\n+#if __cplusplus > 201703L\n+  template<typename _Tp, typename... _Args>\n+    constexpr auto\n+    construct_at(_Tp* __location, _Args&&... __args)\n+    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))\n+    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))\n+    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }\n+#endif // C++20\n+#endif// C++17\n+\n   /**\n    * Constructs an object in existing memory by invoking an allocated\n    * object's constructor with an initializer.\n    */\n #if __cplusplus >= 201103L\n-  template<typename _T1, typename... _Args>\n-    inline void\n-    _Construct(_T1* __p, _Args&&... __args)\n-    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }\n+  template<typename _Tp, typename... _Args>\n+    constexpr _Tp*\n+    _Construct(_Tp* __p, _Args&&... __args)\n+    {\n+#if __cplusplus > 201703L\n+      return std::construct_at(__p, std::forward<_Args>(__args)...);\n+#else\n+      return ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);\n+#endif\n+    }\n #else\n   template<typename _T1, typename _T2>\n-    inline void\n+    inline _T1*\n     _Construct(_T1* __p, const _T2& __value)\n     {\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 402. wrong new expression in [some_]allocator::construct\n-      ::new(static_cast<void*>(__p)) _T1(__value);\n+      return ::new(static_cast<void*>(__p)) _T1(__value);\n     }\n #endif\n \n@@ -89,20 +129,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Construct_novalue(_T1* __p)\n     { ::new(static_cast<void*>(__p)) _T1; }\n \n+  template<typename _ForwardIterator>\n+    _GLIBCXX20_CONSTEXPR void\n+    _Destroy(_ForwardIterator __first, _ForwardIterator __last);\n+\n   /**\n    * Destroy the object pointed to by a pointer type.\n    */\n   template<typename _Tp>\n-    inline void\n+    _GLIBCXX_CONSTEXPR inline void\n     _Destroy(_Tp* __pointer)\n-    { __pointer->~_Tp(); }\n+    {\n+#if __cplusplus > 201703L\n+      std::destroy_at(__pointer);\n+#else\n+      __pointer->~_Tp();\n+#endif\n+    }\n \n   template<bool>\n     struct _Destroy_aux\n     {\n       template<typename _ForwardIterator>\n-        static void\n-        __destroy(_ForwardIterator __first, _ForwardIterator __last)\n+\tstatic _GLIBCXX20_CONSTEXPR void\n+\t__destroy(_ForwardIterator __first, _ForwardIterator __last)\n \t{\n \t  for (; __first != __last; ++__first)\n \t    std::_Destroy(std::__addressof(*__first));\n@@ -123,7 +173,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * away, otherwise the objects' destructors must be invoked.\n    */\n   template<typename _ForwardIterator>\n-    inline void\n+    _GLIBCXX20_CONSTEXPR inline void\n     _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type\n@@ -132,6 +182,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // A deleted destructor is trivial, this ensures we reject such types:\n       static_assert(is_destructible<_Value_type>::value,\n \t\t    \"value type is destructible\");\n+#endif\n+#if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated\n+      if (std::is_constant_evaluated())\n+\treturn _Destroy_aux<false>::__destroy(__first, __last);\n #endif\n       std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::\n \t__destroy(__first, __last);\n@@ -141,8 +195,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _Destroy_n_aux\n     {\n       template<typename _ForwardIterator, typename _Size>\n-        static _ForwardIterator\n-        __destroy_n(_ForwardIterator __first, _Size __count)\n+\tstatic _GLIBCXX20_CONSTEXPR _ForwardIterator\n+\t__destroy_n(_ForwardIterator __first, _Size __count)\n \t{\n \t  for (; __count > 0; (void)++__first, --__count)\n \t    std::_Destroy(std::__addressof(*__first));\n@@ -168,7 +222,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * away, otherwise the objects' destructors must be invoked.\n    */\n   template<typename _ForwardIterator, typename _Size>\n-    inline _ForwardIterator\n+    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n     _Destroy_n(_ForwardIterator __first, _Size __count)\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type\n@@ -177,60 +231,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // A deleted destructor is trivial, this ensures we reject such types:\n       static_assert(is_destructible<_Value_type>::value,\n \t\t    \"value type is destructible\");\n+#endif\n+#if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated\n+      if (std::is_constant_evaluated())\n+\treturn _Destroy_n_aux<false>::__destroy_n(__first, __count);\n #endif\n       return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::\n \t__destroy_n(__first, __count);\n     }\n \n-  /**\n-   * Destroy a range of objects using the supplied allocator.  For\n-   * nondefault allocators we do not optimize away invocation of \n-   * destroy() even if _Tp has a trivial destructor.\n-   */\n-\n-  template<typename _ForwardIterator, typename _Allocator>\n-    void\n-    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n-\t     _Allocator& __alloc)\n-    {\n-      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n-      for (; __first != __last; ++__first)\n-\t__traits::destroy(__alloc, std::__addressof(*__first));\n-    }\n-\n-  template<typename _ForwardIterator, typename _Tp>\n-    inline void\n-    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n-\t     allocator<_Tp>&)\n-    {\n-      _Destroy(__first, __last);\n-    }\n-\n-#if __cplusplus > 201402L\n-  template <typename _Tp>\n-    inline void\n-    destroy_at(_Tp* __location)\n-    {\n-      std::_Destroy(__location);\n-    }\n-\n+#if __cplusplus >= 201703L\n   template <typename _ForwardIterator>\n-    inline void\n+    _GLIBCXX20_CONSTEXPR inline void\n     destroy(_ForwardIterator __first, _ForwardIterator __last)\n     {\n       std::_Destroy(__first, __last);\n     }\n \n   template <typename _ForwardIterator, typename _Size>\n-    inline _ForwardIterator\n+    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n     destroy_n(_ForwardIterator __first, _Size __count)\n     {\n       return std::_Destroy_n(__first, __count);\n     }\n-#endif\n+#endif // C++17\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n #endif /* _STL_CONSTRUCT_H */\n-"}, {"sha": "79d27c83d85b9720491d026c19750427f2c12868", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -57,13 +57,15 @@\n #define _STL_UNINITIALIZED_H 1\n \n #if __cplusplus > 201402L\n-#include <utility>\n+#include <bits/stl_pair.h>\n #endif\n \n #if __cplusplus >= 201103L\n #include <type_traits>\n #endif\n \n+#include <ext/alloc_traits.h>\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION"}, {"sha": "052d811ec01f510dce403225af35ca4f1893d945", "filename": "libstdc++-v3/include/ext/alloc_traits.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -31,10 +31,8 @@\n \n #pragma GCC system_header\n \n-#if __cplusplus >= 201103L\n-# include <bits/move.h>\n # include <bits/alloc_traits.h>\n-#else\n+#if __cplusplus < 201103L\n # include <bits/allocator.h>  // for __alloc_swap\n #endif\n \n@@ -78,7 +76,7 @@ template<typename _Alloc, typename = typename _Alloc::value_type>\n   public:\n     // overload construct for non-standard pointer types\n     template<typename _Ptr, typename... _Args>\n-      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type\n+      static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value>\n       construct(_Alloc& __a, _Ptr __p, _Args&&... __args)\n       noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),\n \t\t\t\t\t      std::forward<_Args>(__args)...)))\n@@ -89,15 +87,15 @@ template<typename _Alloc, typename = typename _Alloc::value_type>\n \n     // overload destroy for non-standard pointer types\n     template<typename _Ptr>\n-      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type\n+      static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value>\n       destroy(_Alloc& __a, _Ptr __p)\n       noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))\n       { _Base_type::destroy(__a, std::__to_address(__p)); }\n \n-    static _Alloc _S_select_on_copy(const _Alloc& __a)\n+    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)\n     { return _Base_type::select_on_container_copy_construction(__a); }\n \n-    static void _S_on_swap(_Alloc& __a, _Alloc& __b)\n+    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)\n     { std::__alloc_on_swap(__a, __b); }\n \n     static constexpr bool _S_propagate_on_copy_assign()\n@@ -118,7 +116,7 @@ template<typename _Alloc, typename = typename _Alloc::value_type>\n     template<typename _Tp>\n       struct rebind\n       { typedef typename _Base_type::template rebind_alloc<_Tp> other; };\n-#else\n+#else // ! C++11\n \n     typedef typename _Alloc::pointer                pointer;\n     typedef typename _Alloc::const_pointer          const_pointer;\n@@ -162,7 +160,7 @@ template<typename _Alloc, typename = typename _Alloc::value_type>\n     template<typename _Tp>\n       struct rebind\n       { typedef typename _Alloc::template rebind<_Tp>::other other; };\n-#endif\n+#endif // C++11\n   };\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "a2bbdb38ebcc114e403e195a7666be9e50da3228", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -169,13 +169,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif // ! C++20\n \n       template<typename _Up>\n-\tfriend bool\n+\tfriend _GLIBCXX20_CONSTEXPR bool\n \toperator==(const malloc_allocator&, const malloc_allocator<_Up>&)\n \t_GLIBCXX_NOTHROW\n \t{ return true; }\n \n       template<typename _Up>\n-\tfriend bool\n+\tfriend _GLIBCXX20_CONSTEXPR bool\n \toperator!=(const malloc_allocator&, const malloc_allocator<_Up>&)\n \t_GLIBCXX_NOTHROW\n \t{ return false; }"}, {"sha": "c6358da4cae73bd3c171093a88ab31dad143fa2d", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -168,13 +168,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif // ! C++20\n \n       template<typename _Up>\n-\tfriend bool\n+\tfriend _GLIBCXX20_CONSTEXPR bool\n \toperator==(const new_allocator&, const new_allocator<_Up>&)\n \t_GLIBCXX_NOTHROW\n \t{ return true; }\n \n       template<typename _Up>\n-\tfriend bool\n+\tfriend _GLIBCXX20_CONSTEXPR bool\n \toperator!=(const new_allocator&, const new_allocator<_Up>&)\n \t_GLIBCXX_NOTHROW\n \t{ return false; }"}, {"sha": "579dccd927467f9225a6c70198a16426b9a5d27e", "filename": "libstdc++-v3/testsuite/20_util/headers/memory/synopsis.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fheaders%2Fmemory%2Fsynopsis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fheaders%2Fmemory%2Fsynopsis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fheaders%2Fmemory%2Fsynopsis.cc?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -25,8 +25,14 @@ namespace std {\n   template <class T> class allocator;\n   template <> class allocator<void>;\n   template <class T, class U>\n+#if __cplusplus > 201703L\n+  constexpr\n+#endif\n   bool operator==(const allocator<T>&, const allocator<U>&) throw();\n   template <class T, class U>\n+#if __cplusplus > 201703L\n+  constexpr\n+#endif\n   bool operator!=(const allocator<T>&, const allocator<U>&) throw();\n \n   //  lib.storage.iterator, raw storage iterator:"}, {"sha": "c14ef612c60706b9d4deb12a3e3fca7dc9f77410", "filename": "libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2F69293_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2F69293_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2F69293_neg.cc?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -48,3 +48,6 @@ test01()\n   sa.construct(p);  // this is required to be ill-formed\n   // { dg-error \"failed: .* uses_allocator is true\" \"\" { target *-*-* } 0 }\n }\n+\n+// Needed because of PR c++/92193\n+// { dg-prune-output \"no matching function for call to\" }"}, {"sha": "6485122c61055e346c0b55b1bd64b1641ef0e078", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/construct_at/1.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fconstruct_at%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fconstruct_at%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fconstruct_at%2F1.cc?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+template<typename T, typename... Args>\n+  concept can_construct_at = requires(T* p, Args&&... args)\n+  {\n+    p = std::construct_at(p, std::forward<Args>(args)...);\n+  };\n+\n+static_assert( can_construct_at<int> );\n+static_assert( can_construct_at<int, int> );\n+static_assert( !can_construct_at<int, int, int> );\n+\n+// Not required by C++20:\n+static_assert( noexcept(std::construct_at(std::declval<int*>(), 1)) );\n+\n+void\n+test01()\n+{\n+  int i = -1;\n+  auto p = std::construct_at(&i);\n+  VERIFY( p == &i );\n+  VERIFY( i == 0 );\n+  p = std::construct_at(&i, 42);\n+  VERIFY( p == &i );\n+  VERIFY( i == 42 );\n+}\n+\n+struct X {\n+  X(char&, void*) { }\n+};\n+\n+static_assert( can_construct_at<X, char&, void*> );\n+static_assert( !can_construct_at<X> );\n+static_assert( !can_construct_at<X, char> );\n+static_assert( !can_construct_at<X, char&, const void*> );\n+\n+static_assert( !noexcept(std::construct_at(std::declval<X*>(), std::declval<char&>(), std::declval<void*>())) );\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "905175e5a6f3be264742dded51f49be503a7c658", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/destructible_debug_neg.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fdestructible_debug_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fdestructible_debug_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fdestructible_debug_neg.cc?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -47,3 +47,7 @@ test02()\n \n // In Debug Mode the \"required from here\" errors come from <debug/vector>\n // { dg-error \"required from here\" \"\" { target *-*-* } 163 }\n+\n+// Needed because of PR c++/92193\n+// { dg-prune-output \"deleted function\" }\n+// { dg-prune-output \"private within this context\" }"}, {"sha": "7f3549a7285c221b74d88cf46279a3b8b3382f03", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/destructible_neg.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fdestructible_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f241149328ce8e677cbdfa7fa8592aca155066/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fdestructible_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fdestructible_neg.cc?ref=85f241149328ce8e677cbdfa7fa8592aca155066", "patch": "@@ -43,3 +43,7 @@ test02()\n }\n \n // { dg-error \"value type is destructible\" \"\" { target *-*-* } 0 }\n+\n+// Needed because of PR c++/92193\n+// { dg-prune-output \"deleted function\" }\n+// { dg-prune-output \"private within this context\" }"}]}