{"sha": "82c039077c746cbc331044b48ef9a83754d0de31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjMDM5MDc3Yzc0NmNiYzMzMTA0NGI0OGVmOWE4Mzc1NGQwZGUzMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-01-26T02:03:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-26T02:03:03Z"}, "message": "godump.c (go_define): Improve lexing of macro expansion to only accept expressions which match Go spec.\n\n\t* godump.c (go_define): Improve lexing of macro expansion to only\n\taccept expressions which match Go spec.\n\nFrom-SVN: r169270", "tree": {"sha": "d48780e0f8e34516b817a3891570dcfc38f421e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d48780e0f8e34516b817a3891570dcfc38f421e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82c039077c746cbc331044b48ef9a83754d0de31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c039077c746cbc331044b48ef9a83754d0de31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c039077c746cbc331044b48ef9a83754d0de31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c039077c746cbc331044b48ef9a83754d0de31/comments", "author": null, "committer": null, "parents": [{"sha": "d4dba752b0fb828f33a2ad86b1cf3d4292fd8e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4dba752b0fb828f33a2ad86b1cf3d4292fd8e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4dba752b0fb828f33a2ad86b1cf3d4292fd8e97"}], "stats": {"total": 308, "additions": 248, "deletions": 60}, "files": [{"sha": "c26fb8f1e7b5510e21508e7a795a514b8c06dd0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c039077c746cbc331044b48ef9a83754d0de31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c039077c746cbc331044b48ef9a83754d0de31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82c039077c746cbc331044b48ef9a83754d0de31", "patch": "@@ -1,3 +1,8 @@\n+2011-01-25  Ian Lance Taylor  <iant@google.com>\n+\n+\t* godump.c (go_define): Improve lexing of macro expansion to only\n+\taccept expressions which match Go spec.\n+\n 2011-01-26  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \tPR c++/43601"}, {"sha": "42b8839c2f68fbcb5910757d42563517fc7ea11a", "filename": "gcc/godump.c", "status": "modified", "additions": 243, "deletions": 60, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c039077c746cbc331044b48ef9a83754d0de31/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c039077c746cbc331044b48ef9a83754d0de31/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=82c039077c746cbc331044b48ef9a83754d0de31", "patch": "@@ -79,6 +79,8 @@ go_define (unsigned int lineno, const char *buffer)\n   const char *name_end;\n   char *out_buffer;\n   char *q;\n+  bool saw_operand;\n+  bool need_operand;\n   char *copy;\n   hashval_t hashval;\n   void **slot;\n@@ -115,77 +117,252 @@ go_define (unsigned int lineno, const char *buffer)\n      initial underscore, and let the user undo this as needed.  */\n   out_buffer = XNEWVEC (char, strlen (p) * 2 + 1);\n   q = out_buffer;\n+  saw_operand = false;\n+  need_operand = false;\n   while (*p != '\\0')\n     {\n-      if (ISALPHA (*p) || *p == '_')\n+      switch (*p)\n \t{\n-\t  const char *start;\n-\t  char *n;\n-\n-\t  start = p;\n-\t  while (ISALNUM (*p) || *p == '_')\n-\t    ++p;\n-\t  n = XALLOCAVEC (char, p - start + 1);\n-\t  memcpy (n, start, p - start);\n-\t  n[p - start] = '\\0';\n-\t  slot = htab_find_slot (macro_hash, n, NO_INSERT);\n-\t  if (slot == NULL || *slot == NULL)\n-\t    {\n-\t      /* This is a reference to a name which was not defined\n-\t\t as a macro.  */\n-\t      fprintf (go_dump_file, \"// unknowndefine %s\\n\", buffer);\n-\t      return;\n-\t    }\n+\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+\tcase 'Y': case 'Z':\n+\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+\tcase 'y': case 'z':\n+\tcase '_':\n+\t  {\n+\t    /* The start of an identifier.  Technically we should also\n+\t       worry about UTF-8 identifiers, but they are not a\n+\t       problem for practical uses of -fdump-go-spec so we\n+\t       don't worry about them.  */\n+\t    const char *start;\n+\t    char *n;\n+\n+\t    start = p;\n+\t    while (ISALNUM (*p) || *p == '_')\n+\t      ++p;\n+\t    n = XALLOCAVEC (char, p - start + 1);\n+\t    memcpy (n, start, p - start);\n+\t    n[p - start] = '\\0';\n+\t    slot = htab_find_slot (macro_hash, n, NO_INSERT);\n+\t    if (slot == NULL || *slot == NULL)\n+\t      {\n+\t\t/* This is a reference to a name which was not defined\n+\t\t   as a macro.  */\n+\t\tgoto unknown;\n+\t      }\n \n-\t  *q++ = '_';\n-\t  memcpy (q, start, p - start);\n-\t  q += p - start;\n-\t}\n-      else if (ISDIGIT (*p)\n-\t       || (*p == '.' && ISDIGIT (p[1])))\n-\t{\n-\t  const char *start;\n-\t  bool is_hex;\n+\t    *q++ = '_';\n+\t    memcpy (q, start, p - start);\n+\t    q += p - start;\n+\n+\t    saw_operand = true;\n+\t    need_operand = false;\n+\t  }\n+\t  break;\n+\n+\tcase '.':\n+\t  if (!ISDIGIT (p[1]))\n+\t    goto unknown;\n+\t  /* Fall through.  */\n+\tcase '0': case '1': case '2': case '3': case '4':\n+\tcase '5': case '6': case '7': case '8': case '9':\n+\t  {\n+\t    const char *start;\n+\t    bool is_hex;\n+\n+\t    start = p;\n+\t    is_hex = false;\n+\t    if (*p == '0' && (p[1] == 'x' || p[1] == 'X'))\n+\t      {\n+\t\tp += 2;\n+\t\tis_hex = true;\n+\t      }\n+\t    while (ISDIGIT (*p) || *p == '.' || *p == 'e' || *p == 'E'\n+\t\t   || (is_hex\n+\t\t       && ((*p >= 'a' && *p <= 'f')\n+\t\t\t   || (*p >= 'A' && *p <= 'F'))))\n+\t      ++p;\n+\t    memcpy (q, start, p - start);\n+\t    q += p - start;\n+\t    while (*p == 'u' || *p == 'U' || *p == 'l' || *p == 'L'\n+\t\t   || *p == 'f' || *p == 'F'\n+\t\t   || *p == 'd' || *p == 'D')\n+\t      {\n+\t\t/* Go doesn't use any of these trailing type\n+\t\t   modifiers.  */\n+\t\t++p;\n+\t      }\n+\n+\t    /* We'll pick up the exponent, if any, as an\n+\t       expression.  */\n \n-\t  start = p;\n-\t  is_hex = false;\n-\t  if (*p == '0' && (p[1] == 'x' || p[1] == 'X'))\n+\t    saw_operand = true;\n+\t    need_operand = false;\n+\t  }\n+\t  break;\n+\n+\tcase ' ': case '\\t':\n+\t  *q++ = *p++;\n+\t  break;\n+\n+\tcase '(':\n+\t  /* Always OK, not part of an operand, presumed to start an\n+\t     operand.  */\n+\t  *q++ = *p++;\n+\t  saw_operand = false;\n+\t  need_operand = false;\n+\t  break;\n+\n+\tcase ')':\n+\t  /* OK if we don't need an operand, and presumed to indicate\n+\t     an operand.  */\n+\t  if (need_operand)\n+\t    goto unknown;\n+\t  *q++ = *p++;\n+\t  saw_operand = true;\n+\t  break;\n+\n+\tcase '+': case '-':\n+\t  /* Always OK, but not part of an operand.  */\n+\t  *q++ = *p++;\n+\t  saw_operand = false;\n+\t  break;\n+\n+\tcase '*': case '/': case '%': case '|': case '&': case '^':\n+\t  /* Must be a binary operator.  */\n+\t  if (!saw_operand)\n+\t    goto unknown;\n+\t  *q++ = *p++;\n+\t  saw_operand = false;\n+\t  need_operand = true;\n+\t  break;\n+\n+\tcase '=':\n+\t  *q++ = *p++;\n+\t  if (*p != '=')\n+\t    goto unknown;\n+\t  /* Must be a binary operator.  */\n+\t  if (!saw_operand)\n+\t    goto unknown;\n+\t  *q++ = *p++;\n+\t  saw_operand = false;\n+\t  need_operand = true;\n+\t  break;\n+\n+\tcase '!':\n+\t  *q++ = *p++;\n+\t  if (*p == '=')\n \t    {\n-\t      p += 2;\n-\t      is_hex = true;\n+\t      /* Must be a binary operator.  */\n+\t      if (!saw_operand)\n+\t\tgoto unknown;\n+\t      *q++ = *p++;\n+\t      saw_operand = false;\n+\t      need_operand = true;\n \t    }\n-\t  while (ISDIGIT (*p) || *p == '.' || *p == 'e' || *p == 'E'\n-\t\t || (is_hex\n-\t\t     && ((*p >= 'a' && *p <= 'f')\n-\t\t\t || (*p >= 'A' && *p <= 'F'))))\n-\t    ++p;\n-\t  memcpy (q, start, p - start);\n-\t  q += p - start;\n-\t  while (*p == 'u' || *p == 'U' || *p == 'l' || *p == 'L'\n-\t\t || *p == 'f' || *p == 'F'\n-\t\t || *p == 'd' || *p == 'D')\n+\t  else\n \t    {\n-\t      /* Go doesn't use any of these trailing type\n-\t\t modifiers.  */\n-\t      ++p;\n+\t      /* Must be a unary operator.  */\n+\t      if (saw_operand)\n+\t\tgoto unknown;\n+\t      need_operand = true;\n \t    }\n-\t}\n-      else if (ISSPACE (*p)\n-\t       || *p == '+' || *p == '-'\n-\t       || *p == '*' || *p == '/' || *p == '%'\n-\t       || *p == '|' || *p == '&'\n-\t       || *p == '>' || *p == '<'\n-\t       || *p == '!'\n-\t       || *p == '(' || *p == ')'\n-\t       || *p == '\"' || *p == '\\'')\n-\t*q++ = *p++;\n-      else\n-\t{\n-\t  /* Something we don't recognize.  */\n-\t  fprintf (go_dump_file, \"// unknowndefine %s\\n\", buffer);\n-\t  return;\n+\t  break;\n+\n+\tcase '<': case '>':\n+\t  /* Must be a binary operand, may be << or >> or <= or >=.  */\n+\t  if (!saw_operand)\n+\t    goto unknown;\n+\t  *q++ = *p++;\n+\t  if (*p == *(p - 1) || *p == '=')\n+\t    *q++ = *p++;\n+\t  saw_operand = false;\n+\t  need_operand = true;\n+\t  break;\n+\n+\tcase '~':\n+\t  /* Must be a unary operand, must be translated for Go.  */\n+\t  if (saw_operand)\n+\t    goto unknown;\n+\t  *q++ = '^';\n+\t  p++;\n+\t  need_operand = true;\n+\t  break;\n+\n+\tcase '\"':\n+\tcase '\\'':\n+\t  {\n+\t    char quote = *p;\n+\t    *q++ = *p++;\n+\t    while (*p != quote)\n+\t      {\n+\t\tint c;\n+\n+\t\tif (*p == '\\0')\n+\t\t  goto unknown;\n+\n+\t\tif (*p != '\\\\')\n+\t\t  {\n+\t\t    *q++ = *p++;\n+\t\t    continue;\n+\t\t  }\n+\n+\t\t*q++ = *p++;\n+\t\tswitch (*p)\n+\t\t  {\n+\t\t  case '0': case '1': case '2': case '3':\n+\t\t  case '4': case '5': case '6': case '7':\n+\t\t    c = 0;\n+\t\t    while (*p >= '0' && *p <= '7')\n+\t\t      {\n+\t\t\t*q++ = *p++;\n+\t\t\t++c;\n+\t\t      }\n+\t\t    /* Go octal characters are always 3\n+\t\t       digits.  */\n+\t\t    if (c != 3)\n+\t\t      goto unknown;\n+\t\t    break;\n+\n+\t\t  case 'x':\n+\t\t    *q++ = *p++;\n+\t\t    c = 0;\n+\t\t    while (ISXDIGIT (*p))\n+\t\t      {\n+\t\t\t*q++ = *p++;\n+\t\t\t++c;\n+\t\t      }\n+\t\t    /* Go hex characters are always 2 digits.  */\n+\t\t    if (c != 2)\n+\t\t      goto unknown;\n+\t\t    break;\n+\n+\t\t  case 'a': case 'b': case 'f': case 'n': case 'r':\n+\t\t  case 't': case 'v': case '\\\\': case '\\'': case '\"':\n+\t\t    *q++ = *p++;\n+\t\t    break;\n+\n+\t\t  default:\n+\t\t    goto unknown;\n+\t\t  }\n+\t      }\n+\t    *q++ = *p++;\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  goto unknown;\n \t}\n     }\n+\n+  if (need_operand)\n+    goto unknown;\n+\n   *q = '\\0';\n \n   slot = htab_find_slot_with_hash (macro_hash, copy, hashval, INSERT);\n@@ -194,6 +371,12 @@ go_define (unsigned int lineno, const char *buffer)\n   fprintf (go_dump_file, \"const _%s = %s\\n\", copy, out_buffer);\n \n   XDELETEVEC (out_buffer);\n+  return;\n+\n+ unknown:\n+  fprintf (go_dump_file, \"// unknowndefine %s\\n\", buffer);\n+  XDELETEVEC (out_buffer);\n+  XDELETEVEC (copy);\n }\n \n /* A macro undef.  */"}]}