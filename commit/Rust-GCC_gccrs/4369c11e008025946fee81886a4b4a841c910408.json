{"sha": "4369c11e008025946fee81886a4b4a841c910408", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM2OWMxMWUwMDgwMjU5NDZmZWU4MTg4NmE0YjRhODQxYzkxMDQwOA==", "commit": {"author": {"name": "Tejas Belagod", "email": "tejas.belagod@arm.com", "date": "2013-01-08T17:19:57Z"}, "committer": {"name": "Tejas Belagod", "email": "belagod@gcc.gnu.org", "date": "2013-01-08T17:19:57Z"}, "message": "aarch64-simd.md (vec_init<mode>): New.\n\n2013-01-08  Tejas Belagod  <tejas.belagod@arm.com>\n\n\t* config/aarch64/aarch64-simd.md (vec_init<mode>): New.\n\t* config/aarch64/aarch64-protos.h (aarch64_expand_vector_init): Declare.\n\t* config/aarch64/aarch64.c (aarch64_simd_dup_constant,\n\taarch64_simd_make_constant, aarch64_expand_vector_init): New.\n\nFrom-SVN: r195027", "tree": {"sha": "c3af02e2f57cf5da176faefe1cd85d515a5e8f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3af02e2f57cf5da176faefe1cd85d515a5e8f64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4369c11e008025946fee81886a4b4a841c910408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4369c11e008025946fee81886a4b4a841c910408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4369c11e008025946fee81886a4b4a841c910408", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4369c11e008025946fee81886a4b4a841c910408/comments", "author": {"login": "tejas-belagod-arm", "id": 92718852, "node_id": "U_kgDOBYbHBA", "avatar_url": "https://avatars.githubusercontent.com/u/92718852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tejas-belagod-arm", "html_url": "https://github.com/tejas-belagod-arm", "followers_url": "https://api.github.com/users/tejas-belagod-arm/followers", "following_url": "https://api.github.com/users/tejas-belagod-arm/following{/other_user}", "gists_url": "https://api.github.com/users/tejas-belagod-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/tejas-belagod-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tejas-belagod-arm/subscriptions", "organizations_url": "https://api.github.com/users/tejas-belagod-arm/orgs", "repos_url": "https://api.github.com/users/tejas-belagod-arm/repos", "events_url": "https://api.github.com/users/tejas-belagod-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/tejas-belagod-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aeb7e7c176070bfbdb4817c1992237f2e3e2019d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb7e7c176070bfbdb4817c1992237f2e3e2019d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb7e7c176070bfbdb4817c1992237f2e3e2019d"}], "stats": {"total": 179, "additions": 179, "deletions": 0}, "files": [{"sha": "757ee869a4ea3312d97e97969c5b18a8b706e7cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4369c11e008025946fee81886a4b4a841c910408/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4369c11e008025946fee81886a4b4a841c910408/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4369c11e008025946fee81886a4b4a841c910408", "patch": "@@ -1,3 +1,10 @@\n+2013-01-08  Tejas Belagod  <tejas.belagod@arm.com>\n+\n+\t* config/aarch64/aarch64-simd.md (vec_init<mode>): New. \n+\t* config/aarch64/aarch64-protos.h (aarch64_expand_vector_init): Declare.\n+\t* config/aarch64/aarch64.c (aarch64_simd_dup_constant,\n+\taarch64_simd_make_constant, aarch64_expand_vector_init): New. \n+\n 2013-01-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/55341"}, {"sha": "a29e04ea13c977abacbb5adea3e141d2fa3409d4", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4369c11e008025946fee81886a4b4a841c910408/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4369c11e008025946fee81886a4b4a841c910408/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=4369c11e008025946fee81886a4b4a841c910408", "patch": "@@ -184,6 +184,7 @@ void aarch64_elf_asm_named_section (const char *, unsigned, tree);\n void aarch64_expand_epilogue (bool);\n void aarch64_expand_mov_immediate (rtx, rtx);\n void aarch64_expand_prologue (void);\n+void aarch64_expand_vector_init (rtx, rtx);\n void aarch64_function_profiler (FILE *, int);\n void aarch64_init_cumulative_args (CUMULATIVE_ARGS *, const_tree, rtx,\n \t\t\t\t   const_tree, unsigned);"}, {"sha": "06eafc69c9f0c9fbbee6d33591f9fdeb0b1a4fb2", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4369c11e008025946fee81886a4b4a841c910408/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4369c11e008025946fee81886a4b4a841c910408/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=4369c11e008025946fee81886a4b4a841c910408", "patch": "@@ -3548,3 +3548,14 @@\n   DONE;\n })\n \n+;; Standard pattern name vec_init<mode>.\n+\n+(define_expand \"vec_init<mode>\"\n+  [(match_operand:VALL 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SIMD\"\n+{\n+  aarch64_expand_vector_init (operands[0], operands[1]);\n+  DONE;\n+})\n+"}, {"sha": "d10cfb80e0a928891de12a18c5d6bb8bedda0ee8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4369c11e008025946fee81886a4b4a841c910408/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4369c11e008025946fee81886a4b4a841c910408/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=4369c11e008025946fee81886a4b4a841c910408", "patch": "@@ -6548,6 +6548,166 @@ aarch64_simd_vector_alignment_reachable (const_tree type, bool is_packed)\n   return true;\n }\n \n+/* If VALS is a vector constant that can be loaded into a register\n+   using DUP, generate instructions to do so and return an RTX to\n+   assign to the register.  Otherwise return NULL_RTX.  */\n+static rtx\n+aarch64_simd_dup_constant (rtx vals)\n+{\n+  enum machine_mode mode = GET_MODE (vals);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  bool all_same = true;\n+  rtx x;\n+  int i;\n+\n+  if (GET_CODE (vals) != CONST_VECTOR)\n+    return NULL_RTX;\n+\n+  for (i = 1; i < n_elts; ++i)\n+    {\n+      x = CONST_VECTOR_ELT (vals, i);\n+      if (!rtx_equal_p (x, CONST_VECTOR_ELT (vals, 0)))\n+\tall_same = false;\n+    }\n+\n+  if (!all_same)\n+    return NULL_RTX;\n+\n+  /* We can load this constant by using DUP and a constant in a\n+     single ARM register.  This will be cheaper than a vector\n+     load.  */\n+  x = copy_to_mode_reg (inner_mode, CONST_VECTOR_ELT (vals, 0));\n+  return gen_rtx_VEC_DUPLICATE (mode, x);\n+}\n+\n+\n+/* Generate code to load VALS, which is a PARALLEL containing only\n+   constants (for vec_init) or CONST_VECTOR, efficiently into a\n+   register.  Returns an RTX to copy into the register, or NULL_RTX\n+   for a PARALLEL that can not be converted into a CONST_VECTOR.  */\n+rtx\n+aarch64_simd_make_constant (rtx vals)\n+{\n+  enum machine_mode mode = GET_MODE (vals);\n+  rtx const_dup;\n+  rtx const_vec = NULL_RTX;\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  int n_const = 0;\n+  int i;\n+\n+  if (GET_CODE (vals) == CONST_VECTOR)\n+    const_vec = vals;\n+  else if (GET_CODE (vals) == PARALLEL)\n+    {\n+      /* A CONST_VECTOR must contain only CONST_INTs and\n+\t CONST_DOUBLEs, but CONSTANT_P allows more (e.g. SYMBOL_REF).\n+\t Only store valid constants in a CONST_VECTOR.  */\n+      for (i = 0; i < n_elts; ++i)\n+\t{\n+\t  rtx x = XVECEXP (vals, 0, i);\n+\t  if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n+\t    n_const++;\n+\t}\n+      if (n_const == n_elts)\n+\tconst_vec = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0));\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  if (const_vec != NULL_RTX\n+      && aarch64_simd_immediate_valid_for_move (const_vec, mode, NULL, NULL,\n+\t\t\t\t\t\tNULL, NULL, NULL))\n+    /* Load using MOVI/MVNI.  */\n+    return const_vec;\n+  else if ((const_dup = aarch64_simd_dup_constant (vals)) != NULL_RTX)\n+    /* Loaded using DUP.  */\n+    return const_dup;\n+  else if (const_vec != NULL_RTX)\n+    /* Load from constant pool. We can not take advantage of single-cycle\n+       LD1 because we need a PC-relative addressing mode.  */\n+    return const_vec;\n+  else\n+    /* A PARALLEL containing something not valid inside CONST_VECTOR.\n+       We can not construct an initializer.  */\n+    return NULL_RTX;\n+}\n+\n+void\n+aarch64_expand_vector_init (rtx target, rtx vals)\n+{\n+  enum machine_mode mode = GET_MODE (target);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  int n_var = 0, one_var = -1;\n+  bool all_same = true;\n+  rtx x, mem;\n+  int i;\n+\n+  x = XVECEXP (vals, 0, 0);\n+  if (!CONST_INT_P (x) && !CONST_DOUBLE_P (x))\n+    n_var = 1, one_var = 0;\n+  \n+  for (i = 1; i < n_elts; ++i)\n+    {\n+      x = XVECEXP (vals, 0, i);\n+      if (!CONST_INT_P (x) && !CONST_DOUBLE_P (x))\n+\t++n_var, one_var = i;\n+\n+      if (!rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n+\tall_same = false;\n+    }\n+\n+  if (n_var == 0)\n+    {\n+      rtx constant = aarch64_simd_make_constant (vals);\n+      if (constant != NULL_RTX)\n+\t{\n+\t  emit_move_insn (target, constant);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Splat a single non-constant element if we can.  */\n+  if (all_same)\n+    {\n+      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));\n+      aarch64_emit_move (target, gen_rtx_VEC_DUPLICATE (mode, x));\n+      return;\n+    }\n+\n+  /* One field is non-constant.  Load constant then overwrite varying\n+     field.  This is more efficient than using the stack.  */\n+  if (n_var == 1)\n+    {\n+      rtx copy = copy_rtx (vals);\n+      rtx index = GEN_INT (one_var);\n+      enum insn_code icode;\n+\n+      /* Load constant part of vector, substitute neighboring value for\n+\t varying element.  */\n+      XVECEXP (copy, 0, one_var) = XVECEXP (vals, 0, one_var ^ 1);\n+      aarch64_expand_vector_init (target, copy);\n+\n+      /* Insert variable.  */\n+      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, one_var));\n+      icode = optab_handler (vec_set_optab, mode);\n+      gcc_assert (icode != CODE_FOR_nothing);\n+      emit_insn (GEN_FCN (icode) (target, x, index));\n+      return;\n+    }\n+\n+  /* Construct the vector in memory one field at a time\n+     and load the whole vector.  */\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n+  for (i = 0; i < n_elts; i++)\n+    emit_move_insn (adjust_address_nv (mem, inner_mode,\n+\t\t\t\t    i * GET_MODE_SIZE (inner_mode)),\n+\t\t    XVECEXP (vals, 0, i));\n+  emit_move_insn (target, mem);\n+\n+}\n+\n static unsigned HOST_WIDE_INT\n aarch64_shift_truncation_mask (enum machine_mode mode)\n {"}]}