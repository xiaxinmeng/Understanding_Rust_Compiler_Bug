{"sha": "859ee18fb4c2e7a26567f7ea00d02b717c807b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5ZWUxOGZiNGMyZTdhMjY1NjdmN2VhMDBkMDJiNzE3YzgwN2I1Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2004-10-28T21:00:59Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-10-28T21:00:59Z"}, "message": "re PR debug/18199 (AIX XCOFF debugging broken)\n\n\tPR 18199\n\t* dbxout.c (dbxout_begin_complex_stabs_noforcetext): New function.\n\t(DBX_FINISH_STABS): Add (unused by default) SYM parameter.\n\t(dbxout_finish_complex_stabs): Update to match.\n\t(dbxout_symbol_location): Call emit_pending_bincls_if_required\n\tand FORCE_TEXT before DBX_STATIC_BLOCK_START.  Use\n\tdbxout_begin_complex_stabs_noforcetext.\n\t* xcoffout.h (DBX_FINISH_STABS): Restore special case for\n\tN_GSYM, using new SYM parameter.  Correct logic for special\n\tcases for N_FUN.\n\nFrom-SVN: r89781", "tree": {"sha": "7d9c470d1f05a6fb0bdc636091edfcc634cf66a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d9c470d1f05a6fb0bdc636091edfcc634cf66a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/859ee18fb4c2e7a26567f7ea00d02b717c807b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859ee18fb4c2e7a26567f7ea00d02b717c807b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859ee18fb4c2e7a26567f7ea00d02b717c807b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859ee18fb4c2e7a26567f7ea00d02b717c807b5b/comments", "author": null, "committer": null, "parents": [{"sha": "883a2bff66fbcba913f3c21427a0551d8624dc6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/883a2bff66fbcba913f3c21427a0551d8624dc6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/883a2bff66fbcba913f3c21427a0551d8624dc6b"}], "stats": {"total": 96, "additions": 63, "deletions": 33}, "files": [{"sha": "bb2556900f6fe9e54a6055a57b3c84cf811cc5d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859ee18fb4c2e7a26567f7ea00d02b717c807b5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859ee18fb4c2e7a26567f7ea00d02b717c807b5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=859ee18fb4c2e7a26567f7ea00d02b717c807b5b", "patch": "@@ -1,5 +1,16 @@\n 2004-10-28  Zack Weinberg  <zack@codesourcery.com>\n \n+\tPR 18199\n+\t* dbxout.c (dbxout_begin_complex_stabs_noforcetext): New function.\n+\t(DBX_FINISH_STABS): Add (unused by default) SYM parameter.\n+\t(dbxout_finish_complex_stabs): Update to match.\n+\t(dbxout_symbol_location): Call emit_pending_bincls_if_required\n+\tand FORCE_TEXT before DBX_STATIC_BLOCK_START.  Use\n+\tdbxout_begin_complex_stabs_noforcetext.\n+\t* xcoffout.h (DBX_FINISH_STABS): Restore special case for\n+\tN_GSYM, using new SYM parameter.  Correct logic for special\n+\tcases for N_FUN.\n+\n \t* varasm.c (function_section): If DECL is NULL_TREE, don't try\n \tto do anything else.  Do not call get_insns if cfun or\n \tcfun->emit are NULL."}, {"sha": "7ed47b622f76218ea886c236a66f29fa1a996296", "filename": "gcc/dbxout.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859ee18fb4c2e7a26567f7ea00d02b717c807b5b/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859ee18fb4c2e7a26567f7ea00d02b717c807b5b/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=859ee18fb4c2e7a26567f7ea00d02b717c807b5b", "patch": "@@ -619,6 +619,16 @@ dbxout_begin_complex_stabs (void)\n   gcc_assert (stabstr_last_contin_point == 0);\n }\n \n+/* As above, but do not force text or emit pending bincls.  This is\n+   used by dbxout_symbol_location, which needs to do something else.  */\n+static void\n+dbxout_begin_complex_stabs_noforcetext (void)\n+{\n+  fputs (ASM_STABS_OP, asm_out_file);\n+  putc ('\"', asm_out_file);\n+  gcc_assert (stabstr_last_contin_point == 0);\n+}\n+\n /* Add CHR, a single character, to the string being built.  */\n #define stabstr_C(chr) obstack_1grow (&stabstr_ob, chr)\n \n@@ -786,7 +796,7 @@ stabstr_continue (void)\n    all of the arguments to the .stabs directive after the string.\n    Overridden by xcoffout.h.  CODE is the stabs code for this symbol;\n    LINE is the source line to write into the desc field (in extended\n-   mode).\n+   mode); SYM is the symbol itself.\n \n    ADDR, LABEL, and NUMBER are three different ways to represent the\n    stabs value field.  At most one of these should be nonzero.\n@@ -802,7 +812,8 @@ stabstr_continue (void)\n      register variable).  It represents the value as a decimal integer.  */\n \n #ifndef DBX_FINISH_STABS\n-#define DBX_FINISH_STABS(CODE, LINE, ADDR, LABEL, NUMBER) do {\t\\\n+#define DBX_FINISH_STABS(SYM, CODE, LINE, ADDR, LABEL, NUMBER)\t\\\n+do {\t\t\t\t\t\t\t\t\\\n   int line_ = use_gnu_debug_info_extensions ? LINE : 0;\t\t\\\n \t\t\t\t\t\t\t\t\\\n   dbxout_int (CODE);\t\t\t\t\t\t\\\n@@ -864,7 +875,8 @@ dbxout_finish_complex_stabs (tree sym, STAB_CODE_TYPE code,\n \t  len   -= chunklen + 1;\n \n \t  /* Only put a line number on the last stab in the sequence.  */\n-\t  DBX_FINISH_STABS (code, len == 0 ? line : 0, addr, label, number);\n+\t  DBX_FINISH_STABS (sym, code, len == 0 ? line : 0,\n+\t\t\t    addr, label, number);\n \t  if (len == 0)\n \t    break;\n \n@@ -883,7 +895,7 @@ dbxout_finish_complex_stabs (tree sym, STAB_CODE_TYPE code,\n       str = obstack_finish (&stabstr_ob);\n       \n       fwrite (str, 1, len, asm_out_file);\n-      DBX_FINISH_STABS (code, line, addr, label, number);\n+      DBX_FINISH_STABS (sym, code, line, addr, label, number);\n     }\n   obstack_free (&stabstr_ob, str);\n }\n@@ -2901,12 +2913,14 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n     return 0;\n \n   /* Ok, start a symtab entry and output the variable name.  */\n+  emit_pending_bincls_if_required ();\n+  FORCE_TEXT;\n \n #ifdef DBX_STATIC_BLOCK_START\n   DBX_STATIC_BLOCK_START (asm_out_file, code);\n #endif\n \n-  dbxout_begin_complex_stabs ();\n+  dbxout_begin_complex_stabs_noforcetext ();\n   dbxout_symbol_name (decl, suffix, letter);\n   dbxout_type (type, 0);\n   dbxout_finish_complex_stabs (decl, code, addr, 0, number);"}, {"sha": "a3d2899566989b418fbce1a25c74cc31f51356a5", "filename": "gcc/xcoffout.h", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859ee18fb4c2e7a26567f7ea00d02b717c807b5b/gcc%2Fxcoffout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859ee18fb4c2e7a26567f7ea00d02b717c807b5b/gcc%2Fxcoffout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.h?ref=859ee18fb4c2e7a26567f7ea00d02b717c807b5b", "patch": "@@ -68,34 +68,39 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Define our own finish symbol function, since xcoff stabs have their\n    own different format.  */\n \n-#define DBX_FINISH_STABS(CODE, LINE, ADDR, LABEL, NUMBER) do {\t\\\n-  if (ADDR)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      /* If we are writing a function name, we must ensure that\t\\\n-\t there is no storage-class suffix on the name.  */\t\\\n-      if (CODE == N_FUN && GET_CODE (ADDR) == SYMBOL_REF)\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  const char *_p = XSTR (ADDR, 0);\t\t\t\\\n-\t  if (*_p == '*')\t\t\t\t\t\\\n-\t    fputs (_p+1, asm_out_file);\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\\\n-\t    for (; *_p != '[' && *_p; _p++)\t\t\t\\\n-\t      putc (*_p, asm_out_file);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  if (CODE == N_FUN)\t\t\t\t\t\\\n-\t    putc ('.', asm_out_file);\t\t\t\t\\\n-\t  output_addr_const (asm_out_file, ADDR);\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (LABEL)\t\t\t\t\t\t\\\n-    assemble_name (asm_out_file, LABEL);\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    dbxout_int (NUMBER);\t\t\t\t\t\\\n-  putc (',', asm_out_file);\t\t\t\t\t\\\n-  dbxout_int (stab_to_sclass (CODE));\t\t\t\t\\\n-  fputs (\",0\\n\", asm_out_file);\t\t\t\t\t\\\n+#define DBX_FINISH_STABS(SYM, CODE, LINE, ADDR, LABEL, NUMBER) do {\t\\\n+  if (ADDR)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* If we are writing a function name, we must emit a dot in\t\\\n+\t order to refer to the function code, not its descriptor.  */\t\\\n+      if (CODE == N_FUN)\t\t\t\t\t\t\\\n+\tputc ('.', asm_out_file);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* If we are writing a function name, we must ensure that\t\t\\\n+\t there is no storage-class suffix on the name.  */\t\t\\\n+      if (CODE == N_FUN && GET_CODE (ADDR) == SYMBOL_REF)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  const char *_p = XSTR (ADDR, 0);\t\t\t\t\\\n+\t  if (*_p == '*')\t\t\t\t\t\t\\\n+\t    fputs (_p+1, asm_out_file);\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    for (; *_p != '[' && *_p; _p++)\t\t\t\t\\\n+\t      putc (*_p, asm_out_file);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\toutput_addr_const (asm_out_file, ADDR);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  /* Another special case: N_GSYM always gets the symbol name,\t\t\\\n+     whether or not LABEL or NUMBER are set.  */\t\t\t\\\n+  else if (CODE == N_GSYM)\t\t\t\t\t\t\\\n+    assemble_name (asm_out_file, XSTR (XEXP (DECL_RTL (SYM), 0), 0));\t\\\n+  else if (LABEL)\t\t\t\t\t\t\t\\\n+    assemble_name (asm_out_file, LABEL);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    dbxout_int (NUMBER);\t\t\t\t\t\t\\\n+  putc (',', asm_out_file);\t\t\t\t\t\t\\\n+  dbxout_int (stab_to_sclass (CODE));\t\t\t\t\t\\\n+  fputs (\",0\\n\", asm_out_file);\t\t\t\t\t\t\\\n } while (0)\n \n /* These are IBM XCOFF extensions we need to reference in dbxout.c"}]}