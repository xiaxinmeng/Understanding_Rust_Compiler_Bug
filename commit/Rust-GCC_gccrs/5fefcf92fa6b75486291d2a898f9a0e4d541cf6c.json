{"sha": "5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZlZmNmOTJmYTZiNzU0ODYyOTFkMmE4OThmOWEwZTRkNTQxY2Y2Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-26T13:33:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-26T13:33:24Z"}, "message": "cgraph.c (cgraph_create_node): Set node frequency to normal.\n\n\n\t* cgraph.c (cgraph_create_node): Set node frequency to normal.\n\t(cgraph_clone_node): Copy function frequency.\n\t* cgraph.h (node_frequency): New enum\n\t(struct cgraph_node): Add.\n\t* final.c (rest_of_clean_state): Update.\n\t* lto-cgraph.c (lto_output_node): Output node frequency.\n\t(input_overwrite_node): Input node frequency.\n\t* tre-ssa-loop-ivopts (computation_cost): Update.\n\t* lto-streamer-out.c (output_function): Do not output function frequency.\n\t* predict.c (maybe_hot_frequency_p): Update and handle functions executed once.\n\t(cgraph_maybe_hot_edge_p): Likewise; use cgraph frequency instead of\n\tattribute lookup.\n\t(probably_never_executed_bb_p, optimize_function_for_size_p): Update.\n\t(compute_function_frequency): Set noreturn functions to be executed once.\n\t(choose_function_section): Update.\n\t* lto-streamer-in.c (input_function): Do not input function frequency.\n\t* function.c (allocate_struct_function): Do not initialize function frequency.\n\t* function.h (function_frequency): Remove.\n\t(struct function): Remove function frequency.\n\t* ipa-profile.c (CGRAPH_NODE_FREQUENCY): Remove.\n\t(try_update): Update.\n\t* tree-inline.c (initialize_cfun): Do not update function frequency.\n\t* passes.c (pass_init_dump_file): Update.\n\t* i386.c (ix86_compute_frame_layout): Update.\n\t(ix86_pad_returns): Update.\n\nFrom-SVN: r158732", "tree": {"sha": "23c770f34cffee8dfe268868d96f062a649cf2fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23c770f34cffee8dfe268868d96f062a649cf2fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/comments", "author": null, "committer": null, "parents": [{"sha": "21aac88050970dff5e2632aa355caed48eee894c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21aac88050970dff5e2632aa355caed48eee894c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21aac88050970dff5e2632aa355caed48eee894c"}], "stats": {"total": 148, "additions": 103, "deletions": 45}, "files": [{"sha": "07f762981453b0f5ef8b628a0dc8fb5598b083f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -1,3 +1,31 @@\n+2010-04-26  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_create_node): Set node frequency to normal.\n+\t(cgraph_clone_node): Copy function frequency.\n+\t* cgraph.h (node_frequency): New enum\n+\t(struct cgraph_node): Add.\n+\t* final.c (rest_of_clean_state): Update.\n+\t* lto-cgraph.c (lto_output_node): Output node frequency.\n+\t(input_overwrite_node): Input node frequency.\n+\t* tre-ssa-loop-ivopts (computation_cost): Update.\n+\t* lto-streamer-out.c (output_function): Do not output function frequency.\n+\t* predict.c (maybe_hot_frequency_p): Update and handle functions executed once.\n+\t(cgraph_maybe_hot_edge_p): Likewise; use cgraph frequency instead of\n+\tattribute lookup.\n+\t(probably_never_executed_bb_p, optimize_function_for_size_p): Update.\n+\t(compute_function_frequency): Set noreturn functions to be executed once.\n+\t(choose_function_section): Update.\n+\t* lto-streamer-in.c (input_function): Do not input function frequency.\n+\t* function.c (allocate_struct_function): Do not initialize function frequency.\n+\t* function.h (function_frequency): Remove.\n+\t(struct function): Remove function frequency.\n+\t* ipa-profile.c (CGRAPH_NODE_FREQUENCY): Remove.\n+\t(try_update): Update.\n+\t* tree-inline.c (initialize_cfun): Do not update function frequency.\n+\t* passes.c (pass_init_dump_file): Update.\n+\t* i386.c (ix86_compute_frame_layout): Update.\n+\t(ix86_pad_returns): Update.\n+\n 2010-04-26  Jie Zhang  <jie@codesourcery.com>\n \n \tPR tree-optimization/43833"}, {"sha": "b58d4ee5516d71336dc52153a32d06bf1fb8a3ab", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -453,6 +453,7 @@ cgraph_create_node (void)\n     cgraph_nodes->previous = node;\n   node->previous = NULL;\n   node->global.estimated_growth = INT_MIN;\n+  node->frequency = NODE_FREQUENCY_NORMAL;\n   cgraph_nodes = node;\n   cgraph_n_nodes++;\n   return node;\n@@ -1899,6 +1900,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n   new_node->global = n->global;\n   new_node->rtl = n->rtl;\n   new_node->count = count;\n+  new_node->frequency = n->frequency;\n   new_node->clone = n->clone;\n   new_node->clone.tree_map = 0;\n   if (n->count)"}, {"sha": "9b9bf4d42d71c158b742da62c3d98cc6eac89b1c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -175,6 +175,21 @@ struct GTY(()) cgraph_clone_info\n   bitmap combined_args_to_skip;\n };\n \n+enum node_frequency {\n+  /* This function most likely won't be executed at all.\n+     (set only when profile feedback is available or via function attribute). */\n+  NODE_FREQUENCY_UNLIKELY_EXECUTED,\n+  /* For functions that are known to be executed once (i.e. constructors, destructors\n+     and main function.  */\n+  NODE_FREQUENCY_EXECUTED_ONCE,\n+  /* The default value.  */\n+  NODE_FREQUENCY_NORMAL,\n+  /* Optimize this function hard\n+     (set only when profile feedback is available or via function attribute). */\n+  NODE_FREQUENCY_HOT\n+};\n+\n+\n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n@@ -267,6 +282,9 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* Set for alias and thunk nodes, same_body points to the node they are alias\n      of and they are linked through the next/previous pointers.  */\n   unsigned same_body_alias : 1;\n+  /* How commonly executed the node is.  Initialized during branch\n+     probabilities pass.  */\n+  ENUM_BITFIELD (node_frequency) frequency : 2;\n };\n \n typedef struct cgraph_node *cgraph_node_ptr;"}, {"sha": "d13ab18313da71e5237d1ec54dd22bb93cf3d19b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -8010,6 +8010,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n       && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n     {\n       int count = frame->nregs;\n+      struct cgraph_node *node = cgraph_node (current_function_decl);\n \n       cfun->machine->use_fast_prologue_epilogue_nregs = count;\n       /* The fast prologue uses move instead of push to save registers.  This\n@@ -8024,9 +8025,9 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \t slow to use many of them.  */\n       if (count)\n \tcount = (count - 1) * FAST_PROLOGUE_INSN_COUNT;\n-      if (cfun->function_frequency < FUNCTION_FREQUENCY_NORMAL\n+      if (node->frequency < NODE_FREQUENCY_NORMAL\n \t  || (flag_branch_probabilities\n-\t      && cfun->function_frequency < FUNCTION_FREQUENCY_HOT))\n+\t      && node->frequency < NODE_FREQUENCY_HOT))\n         cfun->machine->use_fast_prologue_epilogue = false;\n       else\n         cfun->machine->use_fast_prologue_epilogue\n@@ -26706,7 +26707,7 @@ ix86_pad_returns (void)\n \t    replace = true;\n \t  /* Empty functions get branch mispredict even when the jump destination\n \t     is not visible to us.  */\n-\t  if (!prev && cfun->function_frequency > FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n+\t  if (!prev && !optimize_function_for_size_p (cfun))\n \t    replace = true;\n \t}\n       if (replace)"}, {"sha": "5011b6c5cacf02b5b38164cd326714ea9acc51ff", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -4374,14 +4374,17 @@ rest_of_clean_state (void)\n       else\n \t{\n \t  const char *aname;\n+\t  struct cgraph_node *node = cgraph_node (current_function_decl);\n \n \t  aname = (IDENTIFIER_POINTER\n \t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n \t  fprintf (final_output, \"\\n;; Function (%s) %s\\n\\n\", aname,\n-\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n+\t     node->frequency == NODE_FREQUENCY_HOT\n \t     ? \" (hot)\"\n-\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n+\t     : node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n \t     ? \" (unlikely executed)\"\n+\t     : node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+\t     ? \" (executed once)\"\n \t     : \"\");\n \n \t  flag_dump_noaddr = flag_dump_unnumbered = 1;"}, {"sha": "949480ca9d0826232432f2dbe05201b592032759", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -4115,8 +4115,6 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n \n   cfun = GGC_CNEW (struct function);\n \n-  cfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n-\n   init_eh_for_function ();\n \n   if (init_machine_status)"}, {"sha": "e5e033847185a4e9491fd02865e0f23eae9fb3a7", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -176,17 +176,6 @@ typedef struct ipa_opt_pass_d *ipa_opt_pass;\n DEF_VEC_P(ipa_opt_pass);\n DEF_VEC_ALLOC_P(ipa_opt_pass,heap);\n \n-enum function_frequency {\n-  /* This function most likely won't be executed at all.\n-     (set only when profile feedback is available or via function attribute). */\n-  FUNCTION_FREQUENCY_UNLIKELY_EXECUTED,\n-  /* The default value.  */\n-  FUNCTION_FREQUENCY_NORMAL,\n-  /* Optimize this function hard\n-     (set only when profile feedback is available or via function attribute). */\n-  FUNCTION_FREQUENCY_HOT\n-};\n-\n struct GTY(()) varasm_status {\n   /* If we're using a per-function constant pool, this is it.  */\n   struct rtx_constant_pool *pool;\n@@ -538,10 +527,6 @@ struct GTY(()) function {\n      function.  */\n   unsigned int va_list_fpr_size : 8;\n \n-  /* How commonly executed the function is.  Initialized during branch\n-     probabilities pass.  */\n-  ENUM_BITFIELD (function_frequency) function_frequency : 2;\n-\n   /* Nonzero if function being compiled can call setjmp.  */\n   unsigned int calls_setjmp : 1;\n "}, {"sha": "6f229681b2c51bc3005269f44064f4ba72b4fc0e", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -286,6 +286,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (bp, node->process, 1);\n   bp_pack_value (bp, node->alias, 1);\n   bp_pack_value (bp, node->finalized_by_frontend, 1);\n+  bp_pack_value (bp, node->frequency, 2);\n   lto_output_bitpack (ob->main_stream, bp);\n   bitpack_delete (bp);\n \n@@ -544,6 +545,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->process = bp_unpack_value (bp, 1);\n   node->alias = bp_unpack_value (bp, 1);\n   node->finalized_by_frontend = bp_unpack_value (bp, 1);\n+  node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n }\n \n "}, {"sha": "4f9fca336fbbcf17c7389b60358237d8fdb16afb", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -1314,7 +1314,6 @@ input_function (tree fn_decl, struct data_in *data_in,\n   fn->has_nonlocal_label = bp_unpack_value (bp, 1);\n   fn->calls_alloca = bp_unpack_value (bp, 1);\n   fn->calls_setjmp = bp_unpack_value (bp, 1);\n-  fn->function_frequency = (enum function_frequency) bp_unpack_value (bp, 2);\n   fn->va_list_fpr_size = bp_unpack_value (bp, 8);\n   fn->va_list_gpr_size = bp_unpack_value (bp, 8);\n   bitpack_delete (bp);"}, {"sha": "e9ae494f3b7fa02f41a6226d12155225ad73821b", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -1866,7 +1866,6 @@ output_function (struct cgraph_node *node)\n   bp_pack_value (bp, fn->has_nonlocal_label, 1);\n   bp_pack_value (bp, fn->calls_alloca, 1);\n   bp_pack_value (bp, fn->calls_setjmp, 1);\n-  bp_pack_value (bp, fn->function_frequency, 2);\n   bp_pack_value (bp, fn->va_list_fpr_size, 8);\n   bp_pack_value (bp, fn->va_list_gpr_size, 8);\n   lto_output_bitpack (ob->main_stream, bp);"}, {"sha": "e503dc64bcc6f27f6235fccb0c07bd5d29f9c009", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -1361,14 +1361,17 @@ pass_init_dump_file (struct opt_pass *pass)\n       if (dump_file && current_function_decl)\n \t{\n \t  const char *dname, *aname;\n+\t  struct cgraph_node *node = cgraph_node (current_function_decl);\n \t  dname = lang_hooks.decl_printable_name (current_function_decl, 2);\n \t  aname = (IDENTIFIER_POINTER\n \t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n \t  fprintf (dump_file, \"\\n;; Function %s (%s)%s\\n\\n\", dname, aname,\n-\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n+\t     node->frequency == NODE_FREQUENCY_HOT\n \t     ? \" (hot)\"\n-\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n+\t     : node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n \t     ? \" (unlikely executed)\"\n+\t     : node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+\t     ? \" (executed once)\"\n \t     : \"\");\n \t}\n       return initializing_dump;"}, {"sha": "29e0e2fcd99720f08018827442d1c5d151e7f8d3", "filename": "gcc/predict.c", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -113,15 +113,19 @@ static const struct predictor_info predictor_info[]= {\n static inline bool\n maybe_hot_frequency_p (int freq)\n {\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n   if (!profile_info || !flag_branch_probabilities)\n     {\n-      if (cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n+      if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n         return false;\n-      if (cfun->function_frequency == FUNCTION_FREQUENCY_HOT)\n+      if (node->frequency == NODE_FREQUENCY_HOT)\n         return true;\n     }\n   if (profile_status == PROFILE_ABSENT)\n     return true;\n+  if (node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+      && freq <= (ENTRY_BLOCK_PTR->frequency * 2 / 3))\n+    return false;\n   if (freq < BB_FREQ_MAX / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION))\n     return false;\n   return true;\n@@ -161,11 +165,16 @@ cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n       && (edge->count\n \t  <= profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n     return false;\n-  if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (edge->callee->decl))\n-      || lookup_attribute (\"cold\", DECL_ATTRIBUTES (edge->caller->decl)))\n+  if (edge->caller->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n+      || edge->callee->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+    return false;\n+  if (optimize_size)\n     return false;\n-  if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (edge->caller->decl)))\n+  if (edge->caller->frequency == NODE_FREQUENCY_HOT)\n     return true;\n+  if (edge->caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+      && edge->frequency < CGRAPH_FREQ_BASE * 3 / 2)\n+    return false;\n   if (flag_guess_branch_prob\n       && edge->frequency <= (CGRAPH_FREQ_BASE\n       \t\t\t     / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n@@ -191,7 +200,7 @@ probably_never_executed_bb_p (const_basic_block bb)\n   if (profile_info && flag_branch_probabilities)\n     return ((bb->count + profile_info->runs / 2) / profile_info->runs) == 0;\n   if ((!profile_info || !flag_branch_probabilities)\n-      && cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n+      && cgraph_node (current_function_decl)->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n     return true;\n   return false;\n }\n@@ -202,8 +211,9 @@ bool\n optimize_function_for_size_p (struct function *fun)\n {\n   return (optimize_size\n-\t  || (fun && (fun->function_frequency\n-\t\t      == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)));\n+\t  || (fun && fun->decl\n+\t      && (cgraph_node (fun->decl)->frequency\n+\t\t  == NODE_FREQUENCY_UNLIKELY_EXECUTED)));\n }\n \n /* Return true when current function should always be optimized for speed.  */\n@@ -2148,34 +2158,44 @@ void\n compute_function_frequency (void)\n {\n   basic_block bb;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n \n   if (!profile_info || !flag_branch_probabilities)\n     {\n+      int flags = flags_from_decl_or_type (current_function_decl);\n       if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (current_function_decl))\n \t  != NULL)\n-        cfun->function_frequency = FUNCTION_FREQUENCY_UNLIKELY_EXECUTED;\n+        node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n       else if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (current_function_decl))\n \t       != NULL)\n-        cfun->function_frequency = FUNCTION_FREQUENCY_HOT;\n+        node->frequency = NODE_FREQUENCY_HOT;\n+      else if (flags & ECF_NORETURN)\n+        node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n+      else if (MAIN_NAME_P (DECL_NAME (current_function_decl)))\n+        node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n+      else if (DECL_STATIC_CONSTRUCTOR (current_function_decl)\n+\t       || DECL_STATIC_DESTRUCTOR (current_function_decl))\n+        node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n       return;\n     }\n-  cfun->function_frequency = FUNCTION_FREQUENCY_UNLIKELY_EXECUTED;\n+  node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n   FOR_EACH_BB (bb)\n     {\n       if (maybe_hot_bb_p (bb))\n \t{\n-\t  cfun->function_frequency = FUNCTION_FREQUENCY_HOT;\n+\t  node->frequency = NODE_FREQUENCY_HOT;\n \t  return;\n \t}\n       if (!probably_never_executed_bb_p (bb))\n-\tcfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n+\tnode->frequency = NODE_FREQUENCY_NORMAL;\n     }\n }\n \n /* Choose appropriate section for the function.  */\n static void\n choose_function_section (void)\n {\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n   if (DECL_SECTION_NAME (current_function_decl)\n       || !targetm.have_named_sections\n       /* Theoretically we can split the gnu.linkonce text section too,\n@@ -2191,10 +2211,10 @@ choose_function_section (void)\n   if (flag_reorder_blocks_and_partition)\n     return;\n \n-  if (cfun->function_frequency == FUNCTION_FREQUENCY_HOT)\n+  if (node->frequency == NODE_FREQUENCY_HOT)\n     DECL_SECTION_NAME (current_function_decl) =\n       build_string (strlen (HOT_TEXT_SECTION_NAME), HOT_TEXT_SECTION_NAME);\n-  if (cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n+  if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n     DECL_SECTION_NAME (current_function_decl) =\n       build_string (strlen (UNLIKELY_EXECUTED_TEXT_SECTION_NAME),\n \t\t    UNLIKELY_EXECUTED_TEXT_SECTION_NAME);"}, {"sha": "0c1293e65171907417469b175293273890179759", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -2014,7 +2014,6 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   cfun->last_verified = src_cfun->last_verified;\n   cfun->va_list_gpr_size = src_cfun->va_list_gpr_size;\n   cfun->va_list_fpr_size = src_cfun->va_list_fpr_size;\n-  cfun->function_frequency = src_cfun->function_frequency;\n   cfun->has_nonlocal_label = src_cfun->has_nonlocal_label;\n   cfun->stdarg = src_cfun->stdarg;\n   cfun->dont_save_pending_sizes_p = src_cfun->dont_save_pending_sizes_p;"}, {"sha": "a7a9e253850f4e88d90e6d4b9d10555c8ab19f74", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fefcf92fa6b75486291d2a898f9a0e4d541cf6c/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5fefcf92fa6b75486291d2a898f9a0e4d541cf6c", "patch": "@@ -2738,17 +2738,18 @@ computation_cost (tree expr, bool speed)\n   unsigned cost;\n   /* Avoid using hard regs in ways which may be unsupported.  */\n   int regno = LAST_VIRTUAL_REGISTER + 1;\n-  enum function_frequency real_frequency = cfun->function_frequency;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  enum node_frequency real_frequency = node->frequency;\n \n-  cfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n+  node->frequency = NODE_FREQUENCY_NORMAL;\n   crtl->maybe_hot_insn_p = speed;\n   walk_tree (&expr, prepare_decl_rtl, &regno, NULL);\n   start_sequence ();\n   rslt = expand_expr (expr, NULL_RTX, TYPE_MODE (type), EXPAND_NORMAL);\n   seq = get_insns ();\n   end_sequence ();\n   default_rtl_profile ();\n-  cfun->function_frequency = real_frequency;\n+  node->frequency = real_frequency;\n \n   cost = seq_cost (seq, speed);\n   if (MEM_P (rslt))"}]}