{"sha": "d79f3032415d02eba50abd0ecc3bac244fc08c26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc5ZjMwMzI0MTVkMDJlYmE1MGFiZDBlY2MzYmFjMjQ0ZmMwOGMyNg==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2009-11-05T14:47:45Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2009-11-05T14:47:45Z"}, "message": "arm.c (arm_fp_model, [...]): Remove.\n\n2009-11-05  Paul Brook  <paul@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm.c (arm_fp_model, arm_fpu_arch, arm_fpu_tune): Remove.\n\t(arm_fpu_desc): New.\n\t(all_fpus): Add FPU details.\n\t(fp_model_for_fpu): Remove.\n\t(arm_override_options): Set and use arm_fpu_desc and arm_fpu_attr.\n\t(arm_output_epilogue, arm_save_coproc_regs): Use TARGET_FPA_EMU2.\n\t(arm_file_start): Use arm_fpu_desc.\n\t* config/arm/arm.h (TARGET_FPA, TARGET_MAVERICK, TARGET_VFP,\n\tTARGET_VFPD32, TARGET_VFP3, TARGET_NEON_FP16, TARGET_NEON): Use\n\tarm_fpu_desc.\n\t(TARGET_FPA_EMU2): Define.\n\t(arm_fp_model, fputype, arm_fpu_tune): Remove.\n\t(vfp_reg_type, arm_fpu_desc): New.\n\t* config/arm/arm.md (attr fpu): Simplify.\n\t* config/arm/fpa.md (movxf_fpa): Use TARGET_FPA_EMU2.\n\t* config/arm/linux-elf.h (FPUTYPE_DEFAULT): Use string value.\n\t* config/arm/bpabi.h (FPUTYPE_DEFAULT): Use string value.\n\t* config/arm/netbsd-elf.h (FPUTYPE_DEFAULT): Use string value.\n\t* config/arm/vxworks.h (FPUTYPE_DEFAULT): Use string value.\n\nFrom-SVN: r153942", "tree": {"sha": "ef7532009030d9fc4d398f2c78dce51faa273663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef7532009030d9fc4d398f2c78dce51faa273663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d79f3032415d02eba50abd0ecc3bac244fc08c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79f3032415d02eba50abd0ecc3bac244fc08c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79f3032415d02eba50abd0ecc3bac244fc08c26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79f3032415d02eba50abd0ecc3bac244fc08c26/comments", "author": null, "committer": null, "parents": [{"sha": "79e22ff8a4524d3f893ed01f508727d59a31a20e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e22ff8a4524d3f893ed01f508727d59a31a20e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e22ff8a4524d3f893ed01f508727d59a31a20e"}], "stats": {"total": 298, "additions": 119, "deletions": 179}, "files": [{"sha": "d7455123d435883811aa4ed651239c9989110a36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -1,3 +1,25 @@\n+2009-11-05  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_fp_model, arm_fpu_arch, arm_fpu_tune): Remove.\n+\t(arm_fpu_desc): New.\n+\t(all_fpus): Add FPU details.\n+\t(fp_model_for_fpu): Remove.\n+\t(arm_override_options): Set and use arm_fpu_desc and arm_fpu_attr.\n+\t(arm_output_epilogue, arm_save_coproc_regs): Use TARGET_FPA_EMU2.\n+\t(arm_file_start): Use arm_fpu_desc.\n+\t* config/arm/arm.h (TARGET_FPA, TARGET_MAVERICK, TARGET_VFP,\n+\tTARGET_VFPD32, TARGET_VFP3, TARGET_NEON_FP16, TARGET_NEON): Use\n+\tarm_fpu_desc.\n+\t(TARGET_FPA_EMU2): Define.\n+\t(arm_fp_model, fputype, arm_fpu_tune): Remove.\n+\t(vfp_reg_type, arm_fpu_desc): New.\n+\t* config/arm/arm.md (attr fpu): Simplify.\n+\t* config/arm/fpa.md (movxf_fpa): Use TARGET_FPA_EMU2.\n+\t* config/arm/linux-elf.h (FPUTYPE_DEFAULT): Use string value.\n+\t* config/arm/bpabi.h (FPUTYPE_DEFAULT): Use string value.\n+\t* config/arm/netbsd-elf.h (FPUTYPE_DEFAULT): Use string value.\n+\t* config/arm/vxworks.h (FPUTYPE_DEFAULT): Use string value.\n+\n 2009-11-05  Michael Matz  <matz@suse.de>\n \n \t* config/i386/i386.c (ix86_builtin_reciprocal): Remove dependency"}, {"sha": "4c7fcb65854bab90e4a2262646f3626ae5392167", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 64, "deletions": 125, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -524,14 +524,11 @@ enum processor_type arm_tune = arm_none;\n /* The default processor used if not overridden by commandline.  */\n static enum processor_type arm_default_cpu = arm_none;\n \n-/* Which floating point model to use.  */\n-enum arm_fp_model arm_fp_model;\n-\n-/* Which floating point hardware is available.  */\n-enum fputype arm_fpu_arch;\n-\n /* Which floating point hardware to schedule for.  */\n-enum fputype arm_fpu_tune;\n+int arm_fpu_attr;\n+\n+/* Which floating popint hardware to use.  */\n+const struct arm_fpu_desc *arm_fpu_desc;\n \n /* Whether to use floating point hardware.  */\n enum float_abi_type arm_float_abi;\n@@ -809,46 +806,21 @@ static struct arm_cpu_select arm_select[] =\n \n char arm_arch_name[] = \"__ARM_ARCH_0UNK__\";\n \n-struct fpu_desc\n-{\n-  const char * name;\n-  enum fputype fpu;\n-};\n-\n-\n /* Available values for -mfpu=.  */\n \n-static const struct fpu_desc all_fpus[] =\n-{\n-  {\"fpa\",\t\tFPUTYPE_FPA},\n-  {\"fpe2\",\t\tFPUTYPE_FPA_EMU2},\n-  {\"fpe3\",\t\tFPUTYPE_FPA_EMU2},\n-  {\"maverick\",\t\tFPUTYPE_MAVERICK},\n-  {\"vfp\",\t\tFPUTYPE_VFP},\n-  {\"vfp3\",\t\tFPUTYPE_VFP3},\n-  {\"vfpv3\",\t\tFPUTYPE_VFP3},\n-  {\"vfpv3-d16\",\t\tFPUTYPE_VFP3D16},\n-  {\"neon\",\t\tFPUTYPE_NEON},\n-  {\"neon-fp16\",\t\tFPUTYPE_NEON_FP16}\n-};\n-\n-\n-/* Floating point models used by the different hardware.\n-   See fputype in arm.h.  */\n-\n-static const enum arm_fp_model fp_model_for_fpu[] =\n-{\n-  /* No FP hardware.  */\n-  ARM_FP_MODEL_UNKNOWN,\t\t/* FPUTYPE_NONE  */\n-  ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA  */\n-  ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA_EMU2  */\n-  ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA_EMU3  */\n-  ARM_FP_MODEL_MAVERICK,\t/* FPUTYPE_MAVERICK  */\n-  ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP  */\n-  ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP3D16  */\n-  ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP3  */\n-  ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_NEON  */\n-  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_NEON_FP16  */\n+static const struct arm_fpu_desc all_fpus[] =\n+{\n+  {\"fpa\",\t\tARM_FP_MODEL_FPA, 0, 0, false, false},\n+  {\"fpe2\",\t\tARM_FP_MODEL_FPA, 2, 0, false, false},\n+  {\"fpe3\",\t\tARM_FP_MODEL_FPA, 3, 0, false, false},\n+  {\"maverick\",\t\tARM_FP_MODEL_MAVERICK, 0, 0, false, false},\n+  {\"vfp\",\t\tARM_FP_MODEL_VFP, 2, VFP_REG_D16, false, false},\n+  {\"vfpv3\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false},\n+  {\"vfpv3-d16\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, false},\n+  {\"neon\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , false},\n+  {\"neon-fp16\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , true },\n+  /* Compatibility aliases.  */\n+  {\"vfp3\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false},\n };\n \n \n@@ -1615,7 +1587,6 @@ arm_override_options (void)\n   if (TARGET_IWMMXT_ABI && !TARGET_IWMMXT)\n     error (\"iwmmxt abi requires an iwmmxt capable cpu\");\n \n-  arm_fp_model = ARM_FP_MODEL_UNKNOWN;\n   if (target_fpu_name == NULL && target_fpe_name != NULL)\n     {\n       if (streq (target_fpe_name, \"2\"))\n@@ -1626,46 +1597,52 @@ arm_override_options (void)\n \terror (\"invalid floating point emulation option: -mfpe=%s\",\n \t       target_fpe_name);\n     }\n-  if (target_fpu_name != NULL)\n-    {\n-      /* The user specified a FPU.  */\n-      for (i = 0; i < ARRAY_SIZE (all_fpus); i++)\n-\t{\n-\t  if (streq (all_fpus[i].name, target_fpu_name))\n-\t    {\n-\t      arm_fpu_arch = all_fpus[i].fpu;\n-\t      arm_fpu_tune = arm_fpu_arch;\n-\t      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];\n-\t      break;\n-\t    }\n-\t}\n-      if (arm_fp_model == ARM_FP_MODEL_UNKNOWN)\n-\terror (\"invalid floating point option: -mfpu=%s\", target_fpu_name);\n-    }\n-  else\n+\n+  if (target_fpu_name == NULL)\n     {\n #ifdef FPUTYPE_DEFAULT\n-      /* Use the default if it is specified for this platform.  */\n-      arm_fpu_arch = FPUTYPE_DEFAULT;\n-      arm_fpu_tune = FPUTYPE_DEFAULT;\n+      target_fpu_name = FPUTYPE_DEFAULT;\n #else\n-      /* Pick one based on CPU type.  */\n-      /* ??? Some targets assume FPA is the default.\n-      if ((insn_flags & FL_VFP) != 0)\n-\tarm_fpu_arch = FPUTYPE_VFP;\n-      else\n-      */\n       if (arm_arch_cirrus)\n-\tarm_fpu_arch = FPUTYPE_MAVERICK;\n+\ttarget_fpu_name = \"maverick\";\n       else\n-\tarm_fpu_arch = FPUTYPE_FPA_EMU2;\n+\ttarget_fpu_name = \"fpe2\";\n #endif\n-      if (tune_flags & FL_CO_PROC && arm_fpu_arch == FPUTYPE_FPA_EMU2)\n-\tarm_fpu_tune = FPUTYPE_FPA;\n+    }\n+\n+  arm_fpu_desc = NULL;\n+  for (i = 0; i < ARRAY_SIZE (all_fpus); i++)\n+    {\n+      if (streq (all_fpus[i].name, target_fpu_name))\n+\t{\n+\t  arm_fpu_desc = &all_fpus[i];\n+\t  break;\n+\t}\n+    }\n+  if (!arm_fpu_desc)\n+    error (\"invalid floating point option: -mfpu=%s\", target_fpu_name);\n+\n+  switch (arm_fpu_desc->model)\n+    {\n+    case ARM_FP_MODEL_FPA:\n+      if (arm_fpu_desc->rev == 2)\n+\tarm_fpu_attr = FPU_FPE2;\n+      else if (arm_fpu_desc->rev == 3)\n+\tarm_fpu_attr = FPU_FPE3;\n       else\n-\tarm_fpu_tune = arm_fpu_arch;\n-      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];\n-      gcc_assert (arm_fp_model != ARM_FP_MODEL_UNKNOWN);\n+\tarm_fpu_attr = FPU_FPA;\n+      break;\n+\n+    case ARM_FP_MODEL_MAVERICK:\n+      arm_fpu_attr = FPU_MAVERICK;\n+      break;\n+\n+    case ARM_FP_MODEL_VFP:\n+      arm_fpu_attr = FPU_VFP;\n+      break;\n+\n+    default:\n+      gcc_unreachable();\n     }\n \n   if (target_float_abi_name != NULL)\n@@ -1687,7 +1664,7 @@ arm_override_options (void)\n     arm_float_abi = TARGET_DEFAULT_FLOAT_ABI;\n \n   if (TARGET_AAPCS_BASED\n-      && (arm_fp_model == ARM_FP_MODEL_FPA))\n+      && (arm_fpu_desc->model == ARM_FP_MODEL_FPA))\n     error (\"FPA is unsupported in the AAPCS\");\n \n   if (TARGET_AAPCS_BASED)\n@@ -1715,7 +1692,7 @@ arm_override_options (void)\n \n   /* If soft-float is specified then don't use FPU.  */\n   if (TARGET_SOFT_FLOAT)\n-    arm_fpu_arch = FPUTYPE_NONE;\n+    arm_fpu_attr = FPU_NONE;\n \n   if (TARGET_AAPCS_BASED)\n     {\n@@ -1742,8 +1719,7 @@ arm_override_options (void)\n   /* For arm2/3 there is no need to do any scheduling if there is only\n      a floating point emulator, or we are doing software floating-point.  */\n   if ((TARGET_SOFT_FLOAT\n-       || arm_fpu_tune == FPUTYPE_FPA_EMU2\n-       || arm_fpu_tune == FPUTYPE_FPA_EMU3)\n+       || (TARGET_FPA && arm_fpu_desc->rev))\n       && (tune_flags & FL_MODE32) == 0)\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n \n@@ -13305,7 +13281,7 @@ arm_output_epilogue (rtx sibling)\n       /* This variable is for the Virtual Frame Pointer, not VFP regs.  */\n       int vfp_offset = offsets->frame;\n \n-      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+      if (TARGET_FPA_EMU2)\n \t{\n \t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n@@ -13528,7 +13504,7 @@ arm_output_epilogue (rtx sibling)\n \t\t\t SP_REGNUM, HARD_FRAME_POINTER_REGNUM);\n \t}\n \n-      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+      if (TARGET_FPA_EMU2)\n \t{\n \t  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n \t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n@@ -14254,7 +14230,7 @@ arm_save_coproc_regs(void)\n \n   /* Save any floating point call-saved registers used by this\n      function.  */\n-  if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+  if (TARGET_FPA_EMU2)\n     {\n       for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \tif (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n@@ -19736,45 +19712,8 @@ arm_file_start (void)\n \t}\n       else\n \t{\n-\t  int set_float_abi_attributes = 0;\n-\t  switch (arm_fpu_arch)\n-\t    {\n-\t    case FPUTYPE_FPA:\n-\t      fpu_name = \"fpa\";\n-\t      break;\n-\t    case FPUTYPE_FPA_EMU2:\n-\t      fpu_name = \"fpe2\";\n-\t      break;\n-\t    case FPUTYPE_FPA_EMU3:\n-\t      fpu_name = \"fpe3\";\n-\t      break;\n-\t    case FPUTYPE_MAVERICK:\n-\t      fpu_name = \"maverick\";\n-\t      break;\n-\t    case FPUTYPE_VFP:\n-\t      fpu_name = \"vfp\";\n-\t      set_float_abi_attributes = 1;\n-\t      break;\n-\t    case FPUTYPE_VFP3D16:\n-\t      fpu_name = \"vfpv3-d16\";\n-\t      set_float_abi_attributes = 1;\n-\t      break;\n-\t    case FPUTYPE_VFP3:\n-\t      fpu_name = \"vfpv3\";\n-\t      set_float_abi_attributes = 1;\n-\t      break;\n-\t    case FPUTYPE_NEON:\n-\t      fpu_name = \"neon\";\n-\t      set_float_abi_attributes = 1;\n-\t      break;\n-\t    case FPUTYPE_NEON_FP16:\n-\t      fpu_name = \"neon-fp16\";\n-\t      set_float_abi_attributes = 1;\n-\t      break;\n-\t    default:\n-\t      abort();\n-\t    }\n-\t  if (set_float_abi_attributes)\n+\t  fpu_name = arm_fpu_desc->name;\n+\t  if (arm_fpu_desc->model == ARM_FP_MODEL_VFP)\n \t    {\n \t      if (TARGET_HARD_FLOAT)\n \t\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 27, 3\\n\");"}, {"sha": "2dfd22df45c0ca54f24b573a2c90e1ba981e587c", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -190,9 +190,9 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_HARD_FLOAT\t\t(arm_float_abi != ARM_FLOAT_ABI_SOFT)\n /* Use hardware floating point calling convention.  */\n #define TARGET_HARD_FLOAT_ABI\t\t(arm_float_abi == ARM_FLOAT_ABI_HARD)\n-#define TARGET_FPA\t\t\t(arm_fp_model == ARM_FP_MODEL_FPA)\n-#define TARGET_MAVERICK\t\t\t(arm_fp_model == ARM_FP_MODEL_MAVERICK)\n-#define TARGET_VFP\t\t\t(arm_fp_model == ARM_FP_MODEL_VFP)\n+#define TARGET_FPA\t\t(arm_fpu_desc->model == ARM_FP_MODEL_FPA)\n+#define TARGET_MAVERICK\t\t(arm_fpu_desc->model == ARM_FP_MODEL_MAVERICK)\n+#define TARGET_VFP\t\t(arm_fpu_desc->model == ARM_FP_MODEL_VFP)\n #define TARGET_IWMMXT\t\t\t(arm_arch_iwmmxt)\n #define TARGET_REALLY_IWMMXT\t\t(TARGET_IWMMXT && TARGET_32BIT)\n #define TARGET_IWMMXT_ABI (TARGET_32BIT && arm_abi == ARM_ABI_IWMMXT)\n@@ -216,34 +216,30 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_THUMB2\t\t\t(TARGET_THUMB && arm_arch_thumb2)\n /* Thumb-1 only.  */\n #define TARGET_THUMB1_ONLY\t\t(TARGET_THUMB1 && !arm_arch_notm)\n+/* FPA emulator without LFM.  */\n+#define TARGET_FPA_EMU2\t\t\t(TARGET_FPA && arm_fpu_desc->rev == 2)\n \n /* The following two macros concern the ability to execute coprocessor\n    instructions for VFPv3 or NEON.  TARGET_VFP3/TARGET_VFPD32 are currently\n    only ever tested when we know we are generating for VFP hardware; we need\n    to be more careful with TARGET_NEON as noted below.  */\n \n /* FPU is has the full VFPv3/NEON register file of 32 D registers.  */\n-#define TARGET_VFPD32 (arm_fp_model == ARM_FP_MODEL_VFP \\\n-\t\t       && (arm_fpu_arch == FPUTYPE_VFP3 \\\n-\t\t\t   || arm_fpu_arch == FPUTYPE_NEON \\\n-\t\t\t   || arm_fpu_arch == FPUTYPE_NEON_FP16))\n+#define TARGET_VFPD32 (TARGET_VFP && arm_fpu_desc->regs == VFP_REG_D32)\n \n /* FPU supports VFPv3 instructions.  */\n-#define TARGET_VFP3 (arm_fp_model == ARM_FP_MODEL_VFP \\\n-\t\t     && (arm_fpu_arch == FPUTYPE_VFP3D16 \\\n-\t\t\t || TARGET_VFPD32))\n+#define TARGET_VFP3 (TARGET_VFP && arm_fpu_desc->rev >= 3)\n \n /* FPU supports NEON/VFP half-precision floating-point.  */\n-#define TARGET_NEON_FP16 (arm_fpu_arch == FPUTYPE_NEON_FP16)\n+#define TARGET_NEON_FP16 \\\n+  (TARGET_VFP && arm_fpu_desc->neon && arm_fpu_desc->fp16)\n \n /* FPU supports Neon instructions.  The setting of this macro gets\n    revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT\n    and TARGET_HARD_FLOAT to ensure that NEON instructions are\n    available.  */\n #define TARGET_NEON (TARGET_32BIT && TARGET_HARD_FLOAT \\\n-\t\t     && arm_fp_model == ARM_FP_MODEL_VFP \\\n-\t\t     && (arm_fpu_arch == FPUTYPE_NEON \\\n-\t\t\t || arm_fpu_arch == FPUTYPE_NEON_FP16))\n+\t\t     && TARGET_VFP && arm_fpu_desc->neon)\n \n /* \"DSP\" multiply instructions, eg. SMULxy.  */\n #define TARGET_DSP_MULTIPLY \\\n@@ -300,42 +296,25 @@ enum arm_fp_model\n   ARM_FP_MODEL_VFP\n };\n \n-extern enum arm_fp_model arm_fp_model;\n-\n-/* Which floating point hardware is available.  Also update\n-   fp_model_for_fpu in arm.c when adding entries to this list.  */\n-enum fputype\n+enum vfp_reg_type\n {\n-  /* No FP hardware.  */\n-  FPUTYPE_NONE,\n-  /* Full FPA support.  */\n-  FPUTYPE_FPA,\n-  /* Emulated FPA hardware, Issue 2 emulator (no LFM/SFM).  */\n-  FPUTYPE_FPA_EMU2,\n-  /* Emulated FPA hardware, Issue 3 emulator.  */\n-  FPUTYPE_FPA_EMU3,\n-  /* Cirrus Maverick floating point co-processor.  */\n-  FPUTYPE_MAVERICK,\n-  /* VFP.  */\n-  FPUTYPE_VFP,\n-  /* VFPv3-D16.  */\n-  FPUTYPE_VFP3D16,\n-  /* VFPv3.  */\n-  FPUTYPE_VFP3,\n-  /* Neon.  */\n-  FPUTYPE_NEON,\n-  /* Neon with half-precision float extensions.  */\n-  FPUTYPE_NEON_FP16\n+  VFP_REG_D16,\n+  VFP_REG_D32,\n+  VFP_REG_SINGLE\n };\n \n-/* Recast the floating point class to be the floating point attribute.  */\n-#define arm_fpu_attr ((enum attr_fpu) arm_fpu_tune)\n-\n-/* What type of floating point to tune for */\n-extern enum fputype arm_fpu_tune;\n-\n-/* What type of floating point instructions are available */\n-extern enum fputype arm_fpu_arch;\n+extern const struct arm_fpu_desc\n+{\n+  const char *name;\n+  enum arm_fp_model model;\n+  int rev;\n+  enum vfp_reg_type regs;\n+  int neon;\n+  int fp16;\n+} *arm_fpu_desc;\n+\n+/* Which floating point hardware to schedule for.  */\n+extern int arm_fpu_attr;\n \n enum float_abi_type\n {"}, {"sha": "52edcbaa17b3457743017238c1dbc55bc608b6ed", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -160,7 +160,7 @@\n ; Floating Point Unit.  If we only have floating point emulation, then there\n ; is no point in scheduling the floating point insns.  (Well, for best\n ; performance we should try and group them together).\n-(define_attr \"fpu\" \"none,fpa,fpe2,fpe3,maverick,vfp,vfpv3d16,vfpv3,neon,neon_fp16\"\n+(define_attr \"fpu\" \"none,fpa,fpe2,fpe3,maverick,vfp\"\n   (const (symbol_ref \"arm_fpu_attr\")))\n \n ; LENGTH of an instruction (in bytes)"}, {"sha": "ba206022b750e07abe9931b7a3568b7d2ecae77d", "filename": "gcc/config/arm/bpabi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Fbpabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Fbpabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fbpabi.h?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -30,7 +30,7 @@\n \n /* Section 4.1 of the AAPCS requires the use of VFP format.  */\n #undef  FPUTYPE_DEFAULT\n-#define FPUTYPE_DEFAULT FPUTYPE_VFP\n+#define FPUTYPE_DEFAULT \"vfp\"\n \n /* TARGET_BIG_ENDIAN_DEFAULT is set in\n    config.gcc for big endian configurations.  */"}, {"sha": "515de43d28bd5efaa86af08cb6622825ede3b703", "filename": "gcc/config/arm/fpa.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Ffpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Ffpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffpa.md?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -599,10 +599,10 @@\n     {\n     default:\n     case 0: return \\\"mvf%?e\\\\t%0, %1\\\";\n-    case 1: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+    case 1: if (TARGET_FPA_EMU2)\n \t      return \\\"ldf%?e\\\\t%0, %1\\\";\n \t    return \\\"lfm%?\\\\t%0, 1, %1\\\";\n-    case 2: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+    case 2: if (TARGET_FPA_EMU2)\n \t      return \\\"stf%?e\\\\t%1, %0\\\";\n \t    return \\\"sfm%?\\\\t%1, 1, %0\\\";\n     }"}, {"sha": "9fdca414e8ef442355e10e2a671cba1774debd90", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -98,7 +98,7 @@\n \n /* NWFPE always understands FPA instructions.  */\n #undef  FPUTYPE_DEFAULT\n-#define FPUTYPE_DEFAULT FPUTYPE_FPA_EMU3\n+#define FPUTYPE_DEFAULT \"fpe3\"\n \n /* Call the function profiler with a given profile label.  */\n #undef  ARM_FUNCTION_PROFILER"}, {"sha": "9cf186b338d3e456f0560efd3f9dc31292c873ce", "filename": "gcc/config/arm/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -153,5 +153,5 @@ do\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n #undef FPUTYPE_DEFAULT\n-#define FPUTYPE_DEFAULT FPUTYPE_VFP\n+#define FPUTYPE_DEFAULT \"vfp\"\n "}, {"sha": "aa7e197bc5dfe627629bfd3a4ac603563d990992", "filename": "gcc/config/arm/vxworks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f3032415d02eba50abd0ecc3bac244fc08c26/gcc%2Fconfig%2Farm%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvxworks.h?ref=d79f3032415d02eba50abd0ecc3bac244fc08c26", "patch": "@@ -97,7 +97,7 @@ along with GCC; see the file COPYING3.  If not see\n /* There is no default multilib.  */\n #undef MULTILIB_DEFAULTS\n \n-#define FPUTYPE_DEFAULT FPUTYPE_VFP\n+#define FPUTYPE_DEFAULT \"vfp\"\n \n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER VXWORKS_FUNCTION_PROFILER"}]}