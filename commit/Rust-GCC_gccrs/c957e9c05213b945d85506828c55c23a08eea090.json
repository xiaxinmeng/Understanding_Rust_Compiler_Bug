{"sha": "c957e9c05213b945d85506828c55c23a08eea090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1N2U5YzA1MjEzYjk0NWQ4NTUwNjgyOGM1NWMyM2EwOGVlYTA5MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-06-02T11:02:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-06-02T11:02:26Z"}, "message": "name-lookup.h (cp_binding_level): Lose namespaces field.\n\n\t* name-lookup.h (cp_binding_level): Lose namespaces field.\n\t* name-lookup.c (add_decl_to_level): Chain namespaces on the names\n\tlist.\n\t(suggest_alternatives_for): Adjust for namespace list.  Do\n\tbreadth-first search.\n\t* decl2.c (collect_source_refs): Namespaces are on the regulr\n\tlist.\n\t(collect_ada_namespace): Likewise.\n\n\t* g++.dg/pr45330.C: Adjust.  Check breadth-firstness.\n\nFrom-SVN: r248821", "tree": {"sha": "403d78b8f25ea4a6278b4ce5e2c98da1d4a2562f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/403d78b8f25ea4a6278b4ce5e2c98da1d4a2562f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c957e9c05213b945d85506828c55c23a08eea090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c957e9c05213b945d85506828c55c23a08eea090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c957e9c05213b945d85506828c55c23a08eea090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c957e9c05213b945d85506828c55c23a08eea090/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "643a9684fadd71e0b89bc737e937e22fe621a4e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643a9684fadd71e0b89bc737e937e22fe621a4e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/643a9684fadd71e0b89bc737e937e22fe621a4e7"}], "stats": {"total": 232, "additions": 118, "deletions": 114}, "files": [{"sha": "f7cb3d5a2f23444a6eaed836bad1767505164904", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c957e9c05213b945d85506828c55c23a08eea090", "patch": "@@ -1,3 +1,14 @@\n+2017-06-02  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* name-lookup.h (cp_binding_level): Lose namespaces field.\n+\t* name-lookup.c (add_decl_to_level): Chain namespaces on the names\n+\tlist.\n+\t(suggest_alternatives_for): Adjust for namespace list.  Do\n+\tbreadth-first search.\n+\t* decl2.c (collect_source_refs): Namespaces are on the regulr\n+\tlist.\n+\t(collect_ada_namespace): Likewise.\n+\n 2017-06-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* typeck.c (cp_build_binary_op): Implement the -Wsizeof_pointer_div"}, {"sha": "16454375ffd4dce874c6343cd91c26ed3420122a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c957e9c05213b945d85506828c55c23a08eea090", "patch": "@@ -4052,21 +4052,14 @@ cpp_check (tree t, cpp_operation op)\n static void \n collect_source_refs (tree namespc) \n {\n-  tree t;\n-\n-  if (!namespc) \n-    return;\n-\n   /* Iterate over names in this name space.  */\n-  for (t = NAMESPACE_LEVEL (namespc)->names; t; t = TREE_CHAIN (t))\n-    if (!DECL_IS_BUILTIN (t) )\n+  for (tree t = NAMESPACE_LEVEL (namespc)->names; t; t = TREE_CHAIN (t))\n+    if (DECL_IS_BUILTIN (t))\n+      ;\n+    else if (TREE_CODE (t) == NAMESPACE_DECL && !DECL_NAMESPACE_ALIAS (t))\n+      collect_source_refs (t);\n+    else\n       collect_source_ref (DECL_SOURCE_FILE (t));\n-  \n-  /* Dump siblings, if any */\n-  collect_source_refs (TREE_CHAIN (namespc));\n-\n-  /* Dump children, if any */\n-  collect_source_refs (NAMESPACE_LEVEL (namespc)->namespaces);\n }\n \n /* Collect decls relevant to SOURCE_FILE from all namespaces recursively,\n@@ -4075,17 +4068,16 @@ collect_source_refs (tree namespc)\n static void\n collect_ada_namespace (tree namespc, const char *source_file)\n {\n-  if (!namespc)\n-    return;\n-\n-  /* Collect decls from this namespace */\n-  collect_ada_nodes (NAMESPACE_LEVEL (namespc)->names, source_file);\n+  tree decl = NAMESPACE_LEVEL (namespc)->names;\n \n-  /* Collect siblings, if any */\n-  collect_ada_namespace (TREE_CHAIN (namespc), source_file);\n+  /* Collect decls from this namespace.  This will skip\n+     NAMESPACE_DECLs (both aliases and regular, it cannot tell).  */\n+  collect_ada_nodes (decl, source_file);\n \n-  /* Collect children, if any */\n-  collect_ada_namespace (NAMESPACE_LEVEL (namespc)->namespaces, source_file);\n+  /* Now scan for namespace children, and dump them.  */\n+  for (; decl; decl = TREE_CHAIN (decl))\n+    if (TREE_CODE (decl) == NAMESPACE_DECL && !DECL_NAMESPACE_ALIAS (decl))\n+      collect_ada_namespace (decl, source_file);\n }\n \n /* Returns true iff there is a definition available for variable or"}, {"sha": "041d51c8494d5376eadeac1bce5f20f005bc9d48", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 78, "deletions": 84, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c957e9c05213b945d85506828c55c23a08eea090", "patch": "@@ -115,38 +115,28 @@ add_decl_to_level (cp_binding_level *b, tree decl)\n {\n   gcc_assert (b->kind != sk_class);\n \n-  if (TREE_CODE (decl) == NAMESPACE_DECL && !DECL_NAMESPACE_ALIAS (decl))\n-    {\n-      /* Inner namespaces get their own chain, to make walking\n-\t simpler.  */\n-      DECL_CHAIN (decl) = b->namespaces;\n-      b->namespaces = decl;\n-    }\n-  else\n-    {\n-      /* Make sure we don't create a circular list.  xref_tag can end\n-\t up pushing the same artificial decl more than once.  We\n-\t should have already detected that in update_binding.  */\n-      gcc_assert (b->names != decl);\n-\n-      /* We build up the list in reverse order, and reverse it later if\n-\t necessary.  */\n-      TREE_CHAIN (decl) = b->names;\n-      b->names = decl;\n-\n-      /* If appropriate, add decl to separate list of statics.  We\n-\t include extern variables because they might turn out to be\n-\t static later.  It's OK for this list to contain a few false\n-\t positives.  */\n-      if (b->kind == sk_namespace)\n-\tif ((VAR_P (decl)\n-\t     && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n-\t    || (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t&& (!TREE_PUBLIC (decl)\n-\t\t    || decl_anon_ns_mem_p (decl)\n-\t\t    || DECL_DECLARED_INLINE_P (decl))))\n-\t  vec_safe_push (static_decls, decl);\n-    }\n+  /* Make sure we don't create a circular list.  xref_tag can end\n+     up pushing the same artificial decl more than once.  We\n+     should have already detected that in update_binding.  */\n+  gcc_assert (b->names != decl);\n+\n+  /* We build up the list in reverse order, and reverse it later if\n+     necessary.  */\n+  TREE_CHAIN (decl) = b->names;\n+  b->names = decl;\n+\n+  /* If appropriate, add decl to separate list of statics.  We\n+     include extern variables because they might turn out to be\n+     static later.  It's OK for this list to contain a few false\n+     positives.  */\n+  if (b->kind == sk_namespace\n+      && ((VAR_P (decl)\n+\t   && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+\t  || (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && (!TREE_PUBLIC (decl)\n+\t\t  || decl_anon_ns_mem_p (decl)\n+\t\t  || DECL_DECLARED_INLINE_P (decl)))))\n+    vec_safe_push (static_decls, decl);\n }\n \n /* Find the binding for NAME in the local binding level B.  */\n@@ -4708,70 +4698,74 @@ suggest_alternatives_for (location_t location, tree name,\n \t\t\t  bool suggest_misspellings)\n {\n   vec<tree> candidates = vNULL;\n-  vec<tree> namespaces_to_search = vNULL;\n-  int max_to_search = PARAM_VALUE (CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP);\n-  int n_searched = 0;\n-  tree t;\n-  unsigned ix;\n-\n-  namespaces_to_search.safe_push (global_namespace);\n+  vec<tree> worklist = vNULL;\n+  unsigned limit = PARAM_VALUE (CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP);\n+  bool limited = false;\n \n-  while (!namespaces_to_search.is_empty ()\n-\t && n_searched < max_to_search)\n+  /* Breadth-first search of namespaces.  Up to limit namespaces\n+     searched (limit zero == unlimited).  */\n+  worklist.safe_push (global_namespace);\n+  for (unsigned ix = 0; ix != worklist.length (); ix++)\n     {\n-      tree scope = namespaces_to_search.pop ();\n-      name_lookup lookup (name, 0);\n-      cp_binding_level *level = NAMESPACE_LEVEL (scope);\n-\n-      n_searched++;\n-\n-      /* Look in this namespace.  */\n-      if (qualified_namespace_lookup (scope, &lookup))\n-\tcandidates.safe_push (lookup.value);\n-\n-      /* Add child namespaces.  */\n-      for (t = level->namespaces; t; t = DECL_CHAIN (t))\n-\tnamespaces_to_search.safe_push (t);\n-    }\n+      tree ns = worklist[ix];\n \n-  /* If we stopped before we could examine all namespaces, inform the\n-     user.  Do this even if we don't have any candidates, since there\n-     might be more candidates further down that we weren't able to\n-     find.  */\n-  if (n_searched >= max_to_search\n-      && !namespaces_to_search.is_empty ())\n-    inform (location,\n-\t    \"maximum limit of %d namespaces searched for %qE\",\n-\t    max_to_search, name);\n-\n-  namespaces_to_search.release ();\n+      if (tree value = ovl_skip_hidden (find_namespace_value (ns, name)))\n+\tcandidates.safe_push (value);\n \n-  /* Nothing useful to report for NAME.  Report on likely misspellings,\n-     or do nothing.  */\n-  if (candidates.is_empty ())\n-    {\n-      if (suggest_misspellings)\n+      if (!limited)\n \t{\n-\t  const char *fuzzy_name = lookup_name_fuzzy (name, FUZZY_LOOKUP_NAME);\n-\t  if (fuzzy_name)\n+\t  /* Look for child namespaces.  We have to do this\n+\t     indirectly because they are chained in reverse order,\n+\t     which is confusing to the user.  */\n+\t  vec<tree> children = vNULL;\n+\n+\t  for (tree decl = NAMESPACE_LEVEL (ns)->names;\n+\t       decl; decl = TREE_CHAIN (decl))\n+\t    if (TREE_CODE (decl) == NAMESPACE_DECL\n+\t\t&& !DECL_NAMESPACE_ALIAS (decl))\n+\t      children.safe_push (decl);\n+\n+\t  while (!limited && !children.is_empty ())\n \t    {\n-\t      gcc_rich_location richloc (location);\n-\t      richloc.add_fixit_replace (fuzzy_name);\n-\t      inform_at_rich_loc (&richloc, \"suggested alternative: %qs\",\n-\t\t\t\t  fuzzy_name);\n+\t      if (worklist.length () == limit)\n+\t\t{\n+\t\t  /* Unconditionally warn that the search was truncated.  */\n+\t\t  inform (location,\n+\t\t\t  \"maximum limit of %d namespaces searched for %qE\",\n+\t\t\t  limit, name);\n+\t\t  limited = true;\n+\t\t}\n+\t      else\n+\t\tworklist.safe_push (children.pop ());\n \t    }\n+\t  children.release ();\n \t}\n-      return;\n     }\n+  worklist.release ();\n \n-  inform_n (location, candidates.length (),\n-\t    \"suggested alternative:\",\n-\t    \"suggested alternatives:\");\n+  if (candidates.length ())\n+    {\n+      inform_n (location, candidates.length (),\n+\t\t\"suggested alternative:\",\n+\t\t\"suggested alternatives:\");\n+      for (unsigned ix = 0; ix != candidates.length (); ix++)\n+\t{\n+\t  tree val = candidates[ix];\n \n-  FOR_EACH_VEC_ELT (candidates, ix, t)\n-    inform (location_of (t), \"  %qE\", t);\n+\t  inform (location_of (val), \"  %qE\", val);\n+\t}\n+      candidates.release ();\n+    }\n+  else if (!suggest_misspellings)\n+    ;\n+  else if (const char *fuzzy = lookup_name_fuzzy (name, FUZZY_LOOKUP_NAME))\n+    {\n+      /* Show a spelling correction.  */\n+      gcc_rich_location richloc (location);\n \n-  candidates.release ();\n+      richloc.add_fixit_replace (fuzzy);\n+      inform_at_rich_loc (&richloc, \"suggested alternative: %qs\", fuzzy);\n+    }\n }\n \n /* Subroutine of maybe_suggest_missing_header for handling unrecognized names"}, {"sha": "2e2075c630dd22763aa3803cf7b0ec32bc79c800", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c957e9c05213b945d85506828c55c23a08eea090", "patch": "@@ -188,9 +188,6 @@ struct GTY(()) cp_binding_level {\n       are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */\n   tree names;\n \n-  /* A chain of NAMESPACE_DECL nodes.  */\n-  tree namespaces;\n-\n   /* A list of USING_DECL nodes.  */\n   tree usings;\n "}, {"sha": "7bb506bc24007508fabd3c86172e858e40ba5565", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c957e9c05213b945d85506828c55c23a08eea090", "patch": "@@ -1,3 +1,7 @@\n+2017-06-02  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/pr45330.C: Adjust.  Check breadth-firstness.\n+\n 2017-06-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/80903"}, {"sha": "54b245be6ec2a2cbd63cfcb8059357fbde4ccca1", "filename": "gcc/testsuite/g++.dg/pr45330.C", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr45330.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c957e9c05213b945d85506828c55c23a08eea090/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr45330.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr45330.C?ref=c957e9c05213b945d85506828c55c23a08eea090", "patch": "@@ -1,17 +1,23 @@\n // { dg-do compile }\n-// Search std, __cxxabiv1, and global namespaces, plus one more.\n-// { dg-options \"--param cxx-max-namespaces-for-diagnostic-help=4\" }\n+// Search std, __cxxabiv1, and global namespaces, plus two more,\n+// breadth first\n \n-#define NSPACE(NAME) namespace NAME { int foo; }\n+// { dg-options \"--param cxx-max-namespaces-for-diagnostic-help=5\" }\n+\n+// ::, std and __cxxabiv1\n \n namespace A\n {\n   int foo;\t\t\t// { dg-message \"A::foo\" \"suggested alternative\" }\n+  namespace A0\n+  {\n+    int foo; // not me\n+  }\n }\n \n namespace B\n {\n-  int foo;\n+  int foo;\t\t\t// { dg-message \"B::foo\" \"suggested alternative\" }\n }\n \n namespace C\n@@ -32,6 +38,6 @@ namespace E\n int bar()\n {\n   return foo;\t\t\t// { dg-error \"was not declared\" }\n-  // { dg-message \"maximum limit of 4 namespaces\" \"maximum limit\" { target *-*-* } .-1 }\n+  // { dg-message \"maximum limit of 5 namespaces\" \"maximum limit\" { target *-*-* } .-1 }\n   // { dg-message \"suggested alternative\" \"suggested alternative\" { target *-*-* } .-2 }\n }"}]}