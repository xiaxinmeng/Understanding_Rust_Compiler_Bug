{"sha": "509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA5ZjQ0OTVlZTRkZWRjMmEyN2Y5ZjhmNzQ5YTA1MDdlZjNmMTkzOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-05-31T19:14:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-05-31T19:14:21Z"}, "message": "cselib.c (promote_debug_loc): Allow l->next non-NULL for cselib_preserve_constants.\n\n\t* cselib.c (promote_debug_loc): Allow l->next non-NULL for\n\tcselib_preserve_constants.\n\t(cselib_lookup_1): If cselib_preserve_constants,\n\ta new VALUE is being created for REG and there is a VALUE for the\n\tsame register in wider mode, add another loc with lowpart SUBREG of\n\tthe wider VALUE.\n\t(cselib_subst_to_values): Handle ENTRY_VALUE.\n\t* var-tracking.c  (replace_expr_with_values): Return NULL for\n\tENTRY_VALUE too.\n\t* dwarf2out.c (convert_descriptor_to_signed): New function.\n\t(mem_loc_descriptor) <case ZERO_EXTEND>: Optimize using DW_OP_and\n\tinstead of two shifts.\n\t(mem_loc_descriptor) <do_shift>: ZERO_EXTEND second argument to\n\tthe right mode if needed.\n\t(mem_loc_descriptor) <case MOD>: For typed ops just use DW_OP_mod.\n\t(mem_loc_descriptor) <case UNSIGNED_FIX>: Use\n\tconvert_descriptor_to_signed.\n\t(mem_loc_descriptor) <case UDIV, CLZ, CTZ, FFS, POPCOUNT, PARITY,\n\tBSWAP, ROTATE, ROTATERT>: Handle these rtls.\n\n\t* gcc.dg/guality/bswaptest.c: New test.\n\t* gcc.dg/guality/clztest.c: New test.\n\t* gcc.dg/guality/ctztest.c: New test.\n\t* gcc.dg/guality/rotatetest.c: New test.\n\nFrom-SVN: r174508", "tree": {"sha": "2f0b491691c28732618def0868a08c868f96b580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f0b491691c28732618def0868a08c868f96b580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7351d8da1bdd94d04d276ce75e11897bbc8e3832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7351d8da1bdd94d04d276ce75e11897bbc8e3832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7351d8da1bdd94d04d276ce75e11897bbc8e3832"}], "stats": {"total": 716, "additions": 686, "deletions": 30}, "files": [{"sha": "ed0fb816550fcc8d972fa8f402bd867b386f0e15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -1,5 +1,25 @@\n 2011-05-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* cselib.c (promote_debug_loc): Allow l->next non-NULL for\n+\tcselib_preserve_constants.\n+\t(cselib_lookup_1): If cselib_preserve_constants,\n+\ta new VALUE is being created for REG and there is a VALUE for the\n+\tsame register in wider mode, add another loc with lowpart SUBREG of\n+\tthe wider VALUE.\n+\t(cselib_subst_to_values): Handle ENTRY_VALUE.\n+\t* var-tracking.c  (replace_expr_with_values): Return NULL for\n+\tENTRY_VALUE too.\n+\t* dwarf2out.c (convert_descriptor_to_signed): New function.\n+\t(mem_loc_descriptor) <case ZERO_EXTEND>: Optimize using DW_OP_and\n+\tinstead of two shifts.\n+\t(mem_loc_descriptor) <do_shift>: ZERO_EXTEND second argument to\n+\tthe right mode if needed.\n+\t(mem_loc_descriptor) <case MOD>: For typed ops just use DW_OP_mod.\n+\t(mem_loc_descriptor) <case UNSIGNED_FIX>: Use\n+\tconvert_descriptor_to_signed.\n+\t(mem_loc_descriptor) <case UDIV, CLZ, CTZ, FFS, POPCOUNT, PARITY,\n+\tBSWAP, ROTATE, ROTATERT>: Handle these rtls.\n+\n \tPR target/48688\n \t* config/i386/i386.md (*lea_general_4): New define_insn_and_split.\n "}, {"sha": "e0697ecfca831ec967bbc613007a2e2d9a75d693", "filename": "gcc/cselib.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -257,7 +257,7 @@ promote_debug_loc (struct elt_loc_list *l)\n     {\n       n_debug_values--;\n       l->setting_insn = cselib_current_insn;\n-      gcc_assert (!l->next);\n+      gcc_assert (!l->next || cselib_preserve_constants);\n     }\n }\n \n@@ -1719,6 +1719,12 @@ cselib_subst_to_values (rtx x, enum machine_mode memmode)\n \t}\n       return e->val_rtx;\n \n+    case ENTRY_VALUE:\n+      e = cselib_lookup (x, GET_MODE (x), 0, memmode);\n+      if (! e)\n+\tbreak;\n+      return e->val_rtx;\n+\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n     case CONST_INT:\n@@ -1843,6 +1849,43 @@ cselib_lookup_1 (rtx x, enum machine_mode mode,\n \t  used_regs[n_used_regs++] = i;\n \t  REG_VALUES (i) = new_elt_list (REG_VALUES (i), NULL);\n \t}\n+      else if (cselib_preserve_constants\n+\t       && GET_MODE_CLASS (mode) == MODE_INT)\n+\t{\n+\t  /* During var-tracking, try harder to find equivalences\n+\t     for SUBREGs.  If a setter sets say a DImode register\n+\t     and user uses that register only in SImode, add a lowpart\n+\t     subreg location.  */\n+\t  struct elt_list *lwider = NULL;\n+\t  l = REG_VALUES (i);\n+\t  if (l && l->elt == NULL)\n+\t    l = l->next;\n+\t  for (; l; l = l->next)\n+\t    if (GET_MODE_CLASS (GET_MODE (l->elt->val_rtx)) == MODE_INT\n+\t\t&& GET_MODE_SIZE (GET_MODE (l->elt->val_rtx))\n+\t\t   > GET_MODE_SIZE (mode)\n+\t\t&& (lwider == NULL\n+\t\t    || GET_MODE_SIZE (GET_MODE (l->elt->val_rtx))\n+\t\t       < GET_MODE_SIZE (GET_MODE (lwider->elt->val_rtx))))\n+\t      {\n+\t\tstruct elt_loc_list *el;\n+\t\tif (i < FIRST_PSEUDO_REGISTER\n+\t\t    && hard_regno_nregs[i][GET_MODE (l->elt->val_rtx)] != 1)\n+\t\t  continue;\n+\t\tfor (el = l->elt->locs; el; el = el->next)\n+\t\t  if (!REG_P (el->loc))\n+\t\t    break;\n+\t\tif (el)\n+\t\t  lwider = l;\n+\t      }\n+\t  if (lwider)\n+\t    {\n+\t      rtx sub = lowpart_subreg (mode, lwider->elt->val_rtx,\n+\t\t\t\t\tGET_MODE (lwider->elt->val_rtx));\n+\t      if (sub)\n+\t\te->locs->next = new_elt_loc_list (e->locs->next, sub);\n+\t    }\n+\t}\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n       slot = cselib_find_slot (x, e->hash, INSERT, memmode);\n       *slot = e;"}, {"sha": "58a622cca1e00504ec3a4c9e2807680023d66c31", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 442, "deletions": 28, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -13824,6 +13824,37 @@ base_type_for_mode (enum machine_mode mode, bool unsignedp)\n   return type_die;\n }\n \n+/* For OP descriptor assumed to be in unsigned MODE, convert it to a signed\n+   type matching MODE, or, if MODE is narrower than DWARF2_ADDR_SIZE, signed\n+   type matching DWARF2_ADDR_SIZE.  Return NULL if the conversion is not\n+   possible.  */\n+\n+static dw_loc_descr_ref\n+convert_descriptor_to_signed (enum machine_mode mode, dw_loc_descr_ref op)\n+{\n+  enum machine_mode outer_mode = mode;\n+  dw_die_ref type_die;\n+  dw_loc_descr_ref cvt;\n+\n+  if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+    {\n+      outer_mode = mode_for_size (DWARF2_ADDR_SIZE * BITS_PER_UNIT,\n+\t\t\t\t  MODE_INT, 0);\n+      if (outer_mode == BLKmode\n+\t  || GET_MODE_SIZE (outer_mode) != DWARF2_ADDR_SIZE)\n+\treturn NULL;\n+    }\n+  type_die = base_type_for_mode (outer_mode, 0);\n+  if (type_die == NULL)\n+    return NULL;\n+  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+  add_loc_descr (&op, cvt);\n+  return op;\n+}\n+\n /* The following routine converts the RTL for a variable or parameter\n    (resident in memory) into an equivalent Dwarf representation of a\n    mechanism for getting the address of that same variable onto the top of a\n@@ -13986,6 +14017,21 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t\t\t\tmem_mode, VAR_INIT_STATUS_INITIALIZED);\n       if (op0 == 0)\n \tbreak;\n+      else if (GET_CODE (rtl) == ZERO_EXTEND\n+\t       && GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE\n+\t       && GET_MODE_BITSIZE (GET_MODE (XEXP (rtl, 0)))\n+\t\t  < HOST_BITS_PER_WIDE_INT\n+\t       /* If DW_OP_const{1,2,4}u won't be used, it is shorter\n+\t\t  to expand zero extend as two shifts instead of\n+\t\t  masking.  */\n+\t       && GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) <= 4)\n+\t{\n+\t  enum machine_mode imode = GET_MODE (XEXP (rtl, 0));\n+\t  mem_loc_result = op0;\n+\t  add_loc_descr (&mem_loc_result,\n+\t\t\t int_loc_descriptor (GET_MODE_MASK (imode)));\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_and, 0, 0));\n+\t}\n       else if (GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE)\n \t{\n \t  int shift = DWARF2_ADDR_SIZE\n@@ -14239,10 +14285,15 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     do_shift:\n       op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-      op1 = mem_loc_descriptor (XEXP (rtl, 1),\n-\t\t\t\tGET_MODE (XEXP (rtl, 1)) == VOIDmode\n-\t\t\t\t? mode : GET_MODE (XEXP (rtl, 1)), mem_mode,\n-\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      {\n+\trtx rtlop1 = XEXP (rtl, 1);\n+\tif (GET_MODE (rtlop1) != VOIDmode\n+\t    && GET_MODE_BITSIZE (GET_MODE (rtlop1))\n+\t       < GET_MODE_BITSIZE (mode))\n+\t  rtlop1 = gen_rtx_ZERO_EXTEND (mode, rtlop1);\n+\top1 = mem_loc_descriptor (rtlop1, mode, mem_mode,\n+\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+      }\n \n       if (op0 == 0 || op1 == 0)\n \tbreak;\n@@ -14279,6 +14330,16 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case MOD:\n+      if (GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE && !dwarf_strict)\n+\t{\n+\t  /* If MODE is wider than DWARF2_ADDR_SIZE, mem_loc_descriptor\n+\t     should return signed typed values and therefore DW_OP_mod\n+\t     won't be unsigned as it defaults for untyped stack values,\n+\t     but signed.  */\n+\t  op = DW_OP_mod;\n+\t  goto do_binop;\n+\t}\n+\n       op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n       op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n@@ -14296,6 +14357,38 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_minus, 0, 0));\n       break;\n \n+    case UDIV:\n+      if (!dwarf_strict && GET_MODE_CLASS (mode) == MODE_INT)\n+\t{\n+\t  dw_die_ref type_die;\n+\t  dw_loc_descr_ref cvt;\n+\n+\t  type_die = base_type_for_mode (mode, 1);\n+\t  if (type_die == NULL)\n+\t    break;\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 == 0 || op1 == 0)\n+\t    break;\n+\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&op0, cvt);\n+\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&op1, cvt);\n+\t  mem_loc_result = op0;\n+\t  add_loc_descr (&mem_loc_result, op1);\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_div, 0, 0));\n+\t  mem_loc_result = convert_descriptor_to_signed (mode, mem_loc_result);\n+\t}\n+      break;\n+\n     case NOT:\n       op = DW_OP_not;\n       goto do_unop;\n@@ -14812,31 +14905,359 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t      && (GET_CODE (rtl) == UNSIGNED_FIX\n \t\t  || GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE))\n \t    {\n-\t      enum machine_mode outer_mode = mode;\n-\t      if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n-\t\t{\n-\t\t  outer_mode = mode_for_size (DWARF2_ADDR_SIZE * BITS_PER_UNIT,\n-\t\t\t\t\t      MODE_INT, 0);\n-\t\t  if (outer_mode == BLKmode\n-\t\t      || GET_MODE_SIZE (outer_mode) != DWARF2_ADDR_SIZE)\n-\t\t    break;\n-\t\t}\n-\t      type_die = base_type_for_mode (outer_mode, 0);\n-\t      if (type_die == NULL)\n+\t      op0 = convert_descriptor_to_signed (mode, op0);\n+\t      if (op0 == NULL)\n \t\tbreak;\n-\t      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t      add_loc_descr (&op0, cvt);\n \t    }\n \t  mem_loc_result = op0;\n \t}\n       break;\n \n-    case COMPARE:\n+    case CLZ:\n+    case CTZ:\n+    case FFS:\n+      /* CLZ (where constV is CLZ_DEFINED_VALUE_AT_ZERO computed value,\n+\t      const0 is DW_OP_lit0 or corresponding typed constant,\n+\t      const1 is DW_OP_lit1 or corresponding typed constant\n+\t      and constMSB is constant with just the MSB bit set\n+\t      for the mode):\n+\t   DW_OP_dup DW_OP_bra <L1> DW_OP_drop constV DW_OP_skip <L4>\n+\t L1: const0 DW_OP_swap\n+\t L2: DW_OP_dup constMSB DW_OP_and DW_OP_bra <L3> const1 DW_OP_shl\n+\t     DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n+\t L3: DW_OP_drop\n+\t L4: DW_OP_nop\n+\n+\t CTZ is similar:\n+\t   DW_OP_dup DW_OP_bra <L1> DW_OP_drop constV DW_OP_skip <L4>\n+\t L1: const0 DW_OP_swap\n+\t L2: DW_OP_dup const1 DW_OP_and DW_OP_bra <L3> const1 DW_OP_shr\n+\t     DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n+\t L3: DW_OP_drop\n+\t L4: DW_OP_nop\n+\n+\t FFS is similar:\n+\t   DW_OP_dup DW_OP_bra <L1> DW_OP_drop const0 DW_OP_skip <L4>\n+\t L1: const1 DW_OP_swap\n+\t L2: DW_OP_dup const1 DW_OP_and DW_OP_bra <L3> const1 DW_OP_shr\n+\t     DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n+\t L3: DW_OP_drop\n+\t L4: DW_OP_nop  */\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE (XEXP (rtl, 0)) == mode\n+\t  && (GET_CODE (rtl) != CLZ\n+\t      || GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT))\n+\t{\n+\t  HOST_WIDE_INT valv;\n+\t  dw_loc_descr_ref l1jump, l1label;\n+\t  dw_loc_descr_ref l2jump, l2label;\n+\t  dw_loc_descr_ref l3jump, l3label;\n+\t  dw_loc_descr_ref l4jump, l4label;\n+\t  rtx msb;\n+\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 == NULL)\n+\t    break;\n+\t  if (GET_CODE (rtl) == CLZ)\n+\t    {\n+\t      if (!CLZ_DEFINED_VALUE_AT_ZERO (mode, valv))\n+\t\tvalv = GET_MODE_BITSIZE (mode);\n+\t    }\n+\t  else if (GET_CODE (rtl) == FFS)\n+\t    valv = 0;\n+\t  else if (!CTZ_DEFINED_VALUE_AT_ZERO (mode, valv))\n+\t    valv = GET_MODE_BITSIZE (mode);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n+\t  l1jump = new_loc_descr (DW_OP_bra, 0, 0);\n+\t  add_loc_descr (&op0, l1jump);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_drop, 0, 0));\n+\t  op1 = mem_loc_descriptor (GEN_INT (valv), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  l4jump = new_loc_descr (DW_OP_skip, 0, 0);\n+\t  add_loc_descr (&op0, l4jump);\n+\t  l1label = mem_loc_descriptor (GET_CODE (rtl) == FFS\n+\t\t\t\t\t? const1_rtx : const0_rtx,\n+\t\t\t\t\tmode, mem_mode,\n+\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\t  if (l1label == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, l1label);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  l2label = new_loc_descr (DW_OP_dup, 0, 0);\n+\t  add_loc_descr (&op0, l2label);\n+\t  if (GET_CODE (rtl) != CLZ)\n+\t    msb = const1_rtx;\n+\t  else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t    msb = GEN_INT ((unsigned HOST_WIDE_INT) 1\n+\t\t\t   << (GET_MODE_BITSIZE (mode) - 1));\n+\t  else\n+\t    msb = immed_double_const (0, (unsigned HOST_WIDE_INT) 1\n+\t\t\t\t\t << (GET_MODE_BITSIZE (mode)\n+\t\t\t\t\t     - HOST_BITS_PER_WIDE_INT - 1),\n+\t\t\t\t      mode);\n+\t  if (GET_CODE (msb) == CONST_INT && INTVAL (msb) < 0)\n+\t    op1 = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32\n+\t\t\t\t ? DW_OP_const4u\n+\t\t\t\t : HOST_BITS_PER_WIDE_INT == 64\n+\t\t\t\t ? DW_OP_const8u : DW_OP_constu,\n+\t\t\t\t INTVAL (msb), 0);\n+\t  else\n+\t    op1 = mem_loc_descriptor (msb, mode, mem_mode,\n+\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t  l3jump = new_loc_descr (DW_OP_bra, 0, 0);\n+\t  add_loc_descr (&op0, l3jump);\n+\t  op1 = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (GET_CODE (rtl) == CLZ\n+\t\t\t\t\t      ? DW_OP_shl : DW_OP_shr, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, 1, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  l2jump = new_loc_descr (DW_OP_skip, 0, 0);\n+\t  add_loc_descr (&op0, l2jump);\n+\t  l3label = new_loc_descr (DW_OP_drop, 0, 0);\n+\t  add_loc_descr (&op0, l3label);\n+\t  l4label = new_loc_descr (DW_OP_nop, 0, 0);\n+\t  add_loc_descr (&op0, l4label);\n+\t  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n+\t  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n+\t  l3jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l3jump->dw_loc_oprnd1.v.val_loc = l3label;\n+\t  l4jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l4jump->dw_loc_oprnd1.v.val_loc = l4label;\n+\t  mem_loc_result = op0;\n+\t}\n+      break;\n+\n+    case POPCOUNT:\n+    case PARITY:\n+      /* POPCOUNT (const0 is DW_OP_lit0 or corresponding typed constant,\n+\t\t   const1 is DW_OP_lit1 or corresponding typed constant):\n+\t     const0 DW_OP_swap\n+\t L1: DW_OP_dup DW_OP_bra <L2> DW_OP_dup DW_OP_rot const1 DW_OP_and\n+\t     DW_OP_plus DW_OP_swap const1 DW_OP_shr DW_OP_skip <L1>\n+\t L2: DW_OP_drop\n+\n+\t PARITY is similar:\n+\t L1: DW_OP_dup DW_OP_bra <L2> DW_OP_dup DW_OP_rot const1 DW_OP_and\n+\t     DW_OP_xor DW_OP_swap const1 DW_OP_shr DW_OP_skip <L1>\n+\t L2: DW_OP_drop  */\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE (XEXP (rtl, 0)) == mode)\n+\t{\n+\t  dw_loc_descr_ref l1jump, l1label;\n+\t  dw_loc_descr_ref l2jump, l2label;\n+\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 == NULL)\n+\t    break;\n+\t  op1 = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  l1label = new_loc_descr (DW_OP_dup, 0, 0);\n+\t  add_loc_descr (&op0, l1label);\n+\t  l2jump = new_loc_descr (DW_OP_bra, 0, 0);\n+\t  add_loc_descr (&op0, l2jump);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_rot, 0, 0));\n+\t  op1 = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (GET_CODE (rtl) == POPCOUNT\n+\t\t\t\t\t      ? DW_OP_plus : DW_OP_xor, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  op1 = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shr, 0, 0));\n+\t  l1jump = new_loc_descr (DW_OP_skip, 0, 0);\n+\t  add_loc_descr (&op0, l1jump);\n+\t  l2label = new_loc_descr (DW_OP_drop, 0, 0);\n+\t  add_loc_descr (&op0, l2label);\n+\t  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n+\t  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n+\t  mem_loc_result = op0;\n+\t}\n+      break;\n+\n+    case BSWAP:\n+      /* BSWAP (constS is initial shift count, either 56 or 24):\n+\t     constS const0\n+\t L1: DW_OP_pick <2> constS DW_OP_pick <3> DW_OP_minus DW_OP_shr\n+\t     const255 DW_OP_and DW_OP_pick <2> DW_OP_shl DW_OP_or\n+\t     DW_OP_swap DW_OP_dup const0 DW_OP_eq DW_OP_bra <L2> const8\n+\t     DW_OP_minus DW_OP_swap DW_OP_skip <L1>\n+\t L2: DW_OP_drop DW_OP_swap DW_OP_drop  */\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && BITS_PER_UNIT == 8\n+\t  && (GET_MODE_BITSIZE (mode) == 32\n+\t      || GET_MODE_BITSIZE (mode) == 64))\n+\t{\n+\t  dw_loc_descr_ref l1jump, l1label;\n+\t  dw_loc_descr_ref l2jump, l2label;\n+\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 == NULL)\n+\t    break;\n+\n+\t  op1 = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),\n+\t\t\t\t    mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  op1 = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  l1label = new_loc_descr (DW_OP_pick, 2, 0);\n+\t  add_loc_descr (&op0, l1label);\n+\t  op1 = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),\n+\t\t\t\t    mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_pick, 3, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_minus, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shr, 0, 0));\n+\t  op1 = mem_loc_descriptor (GEN_INT (255), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op1 == NULL)\n+\t    break;\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_pick, 2, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_or, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n+\t  op1 = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_eq, 0, 0));\n+\t  l2jump = new_loc_descr (DW_OP_bra, 0, 0);\n+\t  add_loc_descr (&op0, l2jump);\n+\t  op1 = mem_loc_descriptor (GEN_INT (8), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_minus, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  l1jump = new_loc_descr (DW_OP_skip, 0, 0);\n+\t  add_loc_descr (&op0, l1jump);\n+\t  l2label = new_loc_descr (DW_OP_drop, 0, 0);\n+\t  add_loc_descr (&op0, l2label);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_drop, 0, 0));\n+\t  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n+\t  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\t  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n+\t  mem_loc_result = op0;\n+\t}\n+      break;\n+\n     case ROTATE:\n     case ROTATERT:\n+      /* ROTATE (constMASK is mode mask, BITSIZE is bitsize of mode):\n+\t     DW_OP_over DW_OP_over DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot\n+\t     [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_neg\n+\t     DW_OP_plus_uconst <BITSIZE> DW_OP_shr DW_OP_or\n+\n+\t ROTATERT is similar:\n+\t     DW_OP_over DW_OP_over DW_OP_neg DW_OP_plus_uconst <BITSIZE>\n+\t     DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot\n+\t     [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_shr DW_OP_or\n+\t */\n+      if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t{\n+\t  rtx rtlop1 = XEXP (rtl, 1);\n+\t  dw_loc_descr_ref mask[2] = { NULL, NULL };\n+\t  int i;\n+\n+\t  if (GET_MODE (rtlop1) != VOIDmode\n+\t      && GET_MODE_BITSIZE (GET_MODE (rtlop1))\n+\t\t < GET_MODE_BITSIZE (mode))\n+\t    rtlop1 = gen_rtx_ZERO_EXTEND (mode, rtlop1);\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  op1 = mem_loc_descriptor (rtlop1, mode, mem_mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 == NULL || op1 == NULL)\n+\t    break;\n+\t  if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+\t    for (i = 0; i < 2; i++)\n+\t      {\n+\t\tif (GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT)\n+\t\t  mask[i] = mem_loc_descriptor (GEN_INT (GET_MODE_MASK (mode)),\n+\t\t\t\t\t\tmode, mem_mode,\n+\t\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\t\telse if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT)\n+\t\t  mask[i] = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32\n+\t\t\t\t\t   ? DW_OP_const4u\n+\t\t\t\t\t   : HOST_BITS_PER_WIDE_INT == 64\n+\t\t\t\t\t   ? DW_OP_const8u : DW_OP_constu,\n+\t\t\t\t\t   GET_MODE_MASK (mode), 0);\n+\t\telse\n+\t\t  mask[i] = NULL;\n+\t\tif (mask[i] == NULL)\n+\t\t  return NULL;\n+\t\tadd_loc_descr (&mask[i], new_loc_descr (DW_OP_and, 0, 0));\n+\t      }\n+\t  add_loc_descr (&op0, op1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_over, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_over, 0, 0));\n+\t  if (GET_CODE (rtl) == ROTATERT)\n+\t    {\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_neg, 0, 0));\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t\t  GET_MODE_BITSIZE (mode), 0));\n+\t    }\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n+\t  if (mask[0] != NULL)\n+\t    add_loc_descr (&op0, mask[0]);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_rot, 0, 0));\n+\t  if (mask[1] != NULL)\n+\t    {\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t      add_loc_descr (&op0, mask[1]);\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n+\t    }\n+\t  if (GET_CODE (rtl) == ROTATE)\n+\t    {\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_neg, 0, 0));\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t\t  GET_MODE_BITSIZE (mode), 0));\n+\t    }\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shr, 0, 0));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_or, 0, 0));\n+\t  mem_loc_result = op0;\n+\t}\n+      break;\n+\n+    case COMPARE:\n     case TRUNCATE:\n       /* In theory, we could implement the above.  */\n       /* DWARF cannot represent the unsigned compare operations\n@@ -14856,7 +15277,6 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case US_ASHIFT:\n     case SS_TRUNCATE:\n     case US_TRUNCATE:\n-    case UDIV:\n     case UNORDERED:\n     case ORDERED:\n     case UNEQ:\n@@ -14870,12 +15290,6 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case SAT_FRACT:\n     case UNSIGNED_SAT_FRACT:\n     case SQRT:\n-    case BSWAP:\n-    case FFS:\n-    case CLZ:\n-    case CTZ:\n-    case POPCOUNT:\n-    case PARITY:\n     case ASM_OPERANDS:\n     case VEC_MERGE:\n     case VEC_SELECT:"}, {"sha": "85c4a371c7403befb9f06cdb1ee059dc25353e55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -1,5 +1,10 @@\n 2011-05-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gcc.dg/guality/bswaptest.c: New test.\n+\t* gcc.dg/guality/clztest.c: New test.\n+\t* gcc.dg/guality/ctztest.c: New test.\n+\t* gcc.dg/guality/rotatetest.c: New test.\n+\n \tPR target/48688\n \t* gcc.target/i386/pr48688.c: New test.\n "}, {"sha": "38b9d981c879eb0bb68180ba4986006574bd35e7", "filename": "gcc/testsuite/gcc.dg/guality/bswaptest.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fbswaptest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fbswaptest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fbswaptest.c?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run { target { x86_64-*-* && lp64 } } } */\n+/* { dg-options \"-g\" } */\n+\n+volatile int vv;\n+\n+__attribute__((noclone, noinline)) long\n+foo (long x)\n+{\n+  long f = __builtin_bswap64 (x);\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 12 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noclone, noinline)) int\n+bar (int x)\n+{\n+  int f = __builtin_bswap32 (x);\n+  int g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 22 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+int\n+main ()\n+{\n+  foo (0x123456789abcde0fUL);\n+  bar (0x12345678);\n+  return 0;\n+}"}, {"sha": "9428be30b87c7e7a1bf9ef40986a7295ff00838e", "filename": "gcc/testsuite/gcc.dg/guality/clztest.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fclztest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fclztest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fclztest.c?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run { target { x86_64-*-* && lp64 } } } */\n+/* { dg-options \"-g\" } */\n+\n+volatile int vv;\n+\n+__attribute__((noinline, noclone)) long\n+foo (long x)\n+{\n+  long f = __builtin_clzl (x);\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 12 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+bar (long x)\n+{\n+  long f = __builtin_clzl (x);\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 22 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+int\n+main ()\n+{\n+  long x = vv;\n+  foo (x + 0x123456UL);\n+  bar (x + 0x7fffffffUL);\n+  return 0;\n+}"}, {"sha": "d243845ec98f4513b47768be5031efbb2e7e64a6", "filename": "gcc/testsuite/gcc.dg/guality/ctztest.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fctztest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fctztest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fctztest.c?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run { target { x86_64-*-* && lp64 } } } */\n+/* { dg-options \"-g\" } */\n+\n+volatile int vv;\n+\n+__attribute__((noinline, noclone)) long\n+foo (long x)\n+{\n+  long f = __builtin_ctzl (x);\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 12 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+bar (long x)\n+{\n+  long f = __builtin_ctzl (x);\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 22 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+int\n+main ()\n+{\n+  long x = vv;\n+  foo (x + 0x1234560UL);\n+  bar (x + 0x7fff8000UL);\n+  return 0;\n+}"}, {"sha": "dff987cbdc93b666390d927a65a211ddbe19d8ab", "filename": "gcc/testsuite/gcc.dg/guality/rotatetest.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Frotatetest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Frotatetest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Frotatetest.c?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-do run { target { x86_64-*-* && lp64 } } } */\n+/* { dg-options \"-g\" } */\n+\n+volatile int vv;\n+\n+__attribute__((noclone, noinline)) long\n+f1 (unsigned long x)\n+{\n+  long f = (x << 12) | (x >> (64 - 12));\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 12 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noclone, noinline)) long\n+f2 (unsigned long x, int y)\n+{\n+  long f = (x << y) | (x >> (64 - y));\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 22 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noclone, noinline)) long\n+f3 (unsigned long x, int y)\n+{\n+  long f = (x >> y) | (x << (64 - y));\n+  long g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 32 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noclone, noinline)) unsigned int\n+f4 (unsigned int x)\n+{\n+  unsigned int f = (x << 12) | (x >> (32 - 12));\n+  unsigned int g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 42 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noclone, noinline)) unsigned int\n+f5 (unsigned int x, int y)\n+{\n+  unsigned int f = (x << y) | (x >> (64 - y));\n+  unsigned int g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 52 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+__attribute__((noclone, noinline)) unsigned int\n+f6 (unsigned int x, int y)\n+{\n+  unsigned int f = (x >> y) | (x << (64 - y));\n+  unsigned int g = f;\n+  asm volatile (\"\" : \"+r\" (f));\n+  vv++;\t\t/* { dg-final { gdb-test 62 \"g\" \"f\" } } */\n+  return f;\n+}\n+\n+int\n+main ()\n+{\n+  f1 (0x123456789abcde0fUL);\n+  f2 (0x123456789abcde0fUL, 18);\n+  f3 (0x123456789abcde0fUL, 17);\n+  f4 (0x12345678);\n+  f5 (0x12345678, 18);\n+  f6 (0x12345678, 17);\n+  return 0;\n+}"}, {"sha": "f761234ed08d5effbdfac63702690397dd5c4a95", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509f4495ee4dedc2a27f9f8f749a0507ef3f1938/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=509f4495ee4dedc2a27f9f8f749a0507ef3f1938", "patch": "@@ -4837,7 +4837,7 @@ get_address_mode (rtx mem)\n static rtx\n replace_expr_with_values (rtx loc)\n {\n-  if (REG_P (loc))\n+  if (REG_P (loc) || GET_CODE (loc) == ENTRY_VALUE)\n     return NULL;\n   else if (MEM_P (loc))\n     {"}]}