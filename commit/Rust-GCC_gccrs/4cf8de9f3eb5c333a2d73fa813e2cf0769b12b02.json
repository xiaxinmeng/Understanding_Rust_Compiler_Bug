{"sha": "4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNmOGRlOWYzZWI1YzMzM2EyZDczZmE4MTNlMmNmMDc2OWIxMmIwMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-13T17:36:33Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-13T17:36:33Z"}, "message": "(exp): Detect signed integer overflow.\n\nReplace `(unsigned)' with `(unsigned long)'.  When\nevaluating << and >>, compute the correct answer without shifting\nby more than HOST_BITS_PER_LONG, or by a negative quantity.\n(integer_overflow, left_shift, right_shift): New functions.\n\nFrom-SVN: r2118", "tree": {"sha": "1c312f669ad21b99b7383b829460e4c96311d1cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c312f669ad21b99b7383b829460e4c96311d1cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02/comments", "author": null, "committer": null, "parents": [{"sha": "0bbb7f4d247de49a2a322c384acddd11337b2e71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbb7f4d247de49a2a322c384acddd11337b2e71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bbb7f4d247de49a2a322c384acddd11337b2e71"}], "stats": {"total": 107, "additions": 88, "deletions": 19}, "files": [{"sha": "5041f4bf0af164800ae2c59f61f4ecc5c31a80e6", "filename": "gcc/cexp.y", "status": "modified", "additions": 88, "deletions": 19, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=4cf8de9f3eb5c333a2d73fa813e2cf0769b12b02", "patch": "@@ -98,6 +98,14 @@ extern int traditional;\n #ifndef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n #endif\n+\n+/* Yield nonzero if adding two numbers with A's and B's signs can yield a\n+   number with SUM's sign, where A, B, and SUM are all C integers.  */\n+#define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n+\n+static void integer_overflow ();\n+static long left_shift ();\n+static long right_shift ();\n %}\n \n %union {\n@@ -147,6 +155,8 @@ exp1\t:\texp\n /* Expressions, not including the comma operator.  */\n exp\t:\t'-' exp    %prec UNARY\n \t\t\t{ $$.value = - $2.value;\n+\t\t\t  if (($$.value & $2.value) < 0 && ! $2.unsignedp)\n+\t\t\t    integer_overflow ();\n \t\t\t  $$.unsignedp = $2.unsignedp; }\n \t|\t'!' exp    %prec UNARY\n \t\t\t{ $$.value = ! $2.value;\n@@ -175,9 +185,15 @@ exp\t:\t'-' exp    %prec UNARY\n exp\t:\texp '*' exp\n \t\t\t{ $$.unsignedp = $1.unsignedp || $3.unsignedp;\n \t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value * $3.value;\n+\t\t\t    $$.value = (unsigned long) $1.value * $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = $1.value * $3.value; }\n+\t\t\t    {\n+\t\t\t      $$.value = $1.value * $3.value;\n+\t\t\t      if ($1.value\n+\t\t\t\t  && ($$.value / $1.value != $3.value\n+\t\t\t\t      || ($$.value & $1.value & $3.value) < 0))\n+\t\t\t\tinteger_overflow ();\n+\t\t\t    } }\n \t|\texp '/' exp\n \t\t\t{ if ($3.value == 0)\n \t\t\t    {\n@@ -186,9 +202,13 @@ exp\t:\texp '*' exp\n \t\t\t    }\n \t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n \t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value / $3.value;\n+\t\t\t    $$.value = (unsigned long) $1.value / $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = $1.value / $3.value; }\n+\t\t\t    {\n+\t\t\t      $$.value = $1.value / $3.value;\n+\t\t\t      if (($$.value & $1.value & $3.value) < 0)\n+\t\t\t\tinteger_overflow ();\n+\t\t\t    } }\n \t|\texp '%' exp\n \t\t\t{ if ($3.value == 0)\n \t\t\t    {\n@@ -197,27 +217,35 @@ exp\t:\texp '*' exp\n \t\t\t    }\n \t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n \t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value % $3.value;\n+\t\t\t    $$.value = (unsigned long) $1.value % $3.value;\n \t\t\t  else\n \t\t\t    $$.value = $1.value % $3.value; }\n \t|\texp '+' exp\n \t\t\t{ $$.value = $1.value + $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n+\t\t\t  if (! $$.unsignedp\n+\t\t\t      && ! possible_sum_sign ($1.value, $3.value,\n+\t\t\t\t\t\t      $$.value))\n+\t\t\t    integer_overflow (); }\n \t|\texp '-' exp\n \t\t\t{ $$.value = $1.value - $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n+\t\t\t  if (! $$.unsignedp\n+\t\t\t      && ! possible_sum_sign ($$.value, $3.value,\n+\t\t\t\t\t\t      $1.value))\n+\t\t\t    integer_overflow (); }\n \t|\texp LSH exp\n \t\t\t{ $$.unsignedp = $1.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value << $3.value;\n+\t\t\t  if ($3.value < 0 && ! $3.unsignedp)\n+\t\t\t    $$.value = right_shift (&$1, -$3.value);\n \t\t\t  else\n-\t\t\t    $$.value = $1.value << $3.value; }\n+\t\t\t    $$.value = left_shift (&$1, $3.value); }\n \t|\texp RSH exp\n \t\t\t{ $$.unsignedp = $1.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value >> $3.value;\n+\t\t\t  if ($3.value < 0 && ! $3.unsignedp)\n+\t\t\t    $$.value = left_shift (&$1, -$3.value);\n \t\t\t  else\n-\t\t\t    $$.value = $1.value >> $3.value; }\n+\t\t\t    $$.value = right_shift (&$1, $3.value); }\n \t|\texp EQUAL exp\n \t\t\t{ $$.value = ($1.value == $3.value);\n \t\t\t  $$.unsignedp = 0; }\n@@ -227,25 +255,25 @@ exp\t:\texp '*' exp\n \t|\texp LEQ exp\n \t\t\t{ $$.unsignedp = 0;\n \t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value <= $3.value;\n+\t\t\t    $$.value = (unsigned long) $1.value <= $3.value;\n \t\t\t  else\n \t\t\t    $$.value = $1.value <= $3.value; }\n \t|\texp GEQ exp\n \t\t\t{ $$.unsignedp = 0;\n \t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value >= $3.value;\n+\t\t\t    $$.value = (unsigned long) $1.value >= $3.value;\n \t\t\t  else\n \t\t\t    $$.value = $1.value >= $3.value; }\n \t|\texp '<' exp\n \t\t\t{ $$.unsignedp = 0;\n \t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value < $3.value;\n+\t\t\t    $$.value = (unsigned long) $1.value < $3.value;\n \t\t\t  else\n \t\t\t    $$.value = $1.value < $3.value; }\n \t|\texp '>' exp\n \t\t\t{ $$.unsignedp = 0;\n \t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value > $3.value;\n+\t\t\t    $$.value = (unsigned long) $1.value > $3.value;\n \t\t\t  else\n \t\t\t    $$.value = $1.value > $3.value; }\n \t|\texp '&' exp\n@@ -548,10 +576,10 @@ yylex ()\n \t  if (lookup (\"__CHAR_UNSIGNED__\", sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n-\t      = result & ((unsigned) ~0 >> (HOST_BITS_PER_INT - num_bits));\n+\t      = result & ((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n \t  else\n \t    yylval.integer.value\n-\t      = result | ~((unsigned) ~0 >> (HOST_BITS_PER_INT - num_bits));\n+\t      = result | ~((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n \t}\n       else\n \t{\n@@ -785,6 +813,47 @@ yyerror (s)\n   error (s);\n   longjmp (parse_return_error, 1);\n }\n+\n+static void\n+integer_overflow ()\n+{\n+  pedwarn (\"integer overflow in preprocessor expression\");\n+}\n+\n+static long\n+left_shift (a, b)\n+     struct constant *a;\n+     unsigned long b;\n+{\n+  if (b >= HOST_BITS_PER_LONG)\n+    {\n+      if (! a->unsignedp && a->value != 0)\n+\tinteger_overflow ();\n+      return 0;\n+    }\n+  else if (a->unsignedp)\n+    return (unsigned long) a->value << b;\n+  else\n+    {\n+      long l = a->value << b;\n+      if (l >> b != a->value)\n+\tinteger_overflow ();\n+      return l;\n+    }\n+}\n+\n+static long\n+right_shift (a, b)\n+     struct constant *a;\n+     unsigned long b;\n+{\n+  if (b >= HOST_BITS_PER_LONG)\n+    return a->unsignedp ? 0 : a->value >> (HOST_BITS_PER_LONG - 1);\n+  else if (a->unsignedp)\n+    return (unsigned long) a->value >> b;\n+  else\n+    return a->value >> b;\n+}\n \f\n /* This page contains the entry point to this file.  */\n "}]}