{"sha": "f68a75df3b44539aca863cf89e1d8eac98ca5010", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY4YTc1ZGYzYjQ0NTM5YWNhODYzY2Y4OWUxZDhlYWM5OGNhNTAxMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-01-07T16:14:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-01-07T16:14:02Z"}, "message": "gimple.h (gss_for_code): Wrap gcc_assert in ENABLE_CHECKING.\n\n2010-01-07  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.h (gss_for_code): Wrap gcc_assert in ENABLE_CHECKING.\n\t(gimple_op): Likewise.\n\t(gimple_op_ptr): Likewise.\n\t(gimple_assign_set_lhs): Remove gcc_assert.\n\t(gimple_assign_set_rhs1): Likewise.\n\t(gimple_assign_set_rhs2): Likewise.\n\t(gimple_call_set_lhs): Likewise.\n\t(gimple_call_set_fn): Likewise.\n\t(gimple_call_set_fndecl): Likewise.\n\t(gimple_call_fndecl): Likewise.\n\t(gimple_call_return_type): Likewise.\n\t(gimple_call_set_chain): Likewise.\n\t(gimple_call_num_args): Likewise.\n\t(gimple_call_set_arg): Likewise.\n\t(gimple_cond_set_code): Likewise.\n\t(gimple_cond_set_lhs): Likewise.\n\t(gimple_cond_set_rhs): Likewise.\n\t(gimple_cond_set_true_label): Likewise.\n\t(gimple_cond_set_false_label): Likewise.\n\t(gimple_label_set_label): Likewise.\n\t(gimple_goto_set_dest): Likewise.\n\t(gimple_debug_bind_get_var): Wrap gcc_assert in ENABLE_CHECKING.\n\t(gimple_debug_bind_get_value): Likewise.\n\t(gimple_debug_bind_get_value_ptr): Likewise.\n\t(gimple_debug_bind_set_var): Likewise.\n\t(gimple_debug_bind_set_value): Likewise.\n\t(gimple_debug_bind_reset_value): Likewise.\n\t(gimple_debug_bind_has_value_p): Likewise.\n\t(gimple_return_retval_ptr): Remove gcc_assert.\n\t(gimple_return_retval): Likewise.\n\t(gimple_return_set_retval): Likewise.\n\t* tree-flow.h (struct gimple_df): Remove nonlocal_all member.\n\t(safe_referenced_var_iterator): Remove.\n\t(FOR_EACH_REFERENCED_VAR_SAFE): Likewise.\n\t* tree-flow-inline.h (gimple_nonlocal_all): Remove.\n\t(fill_referenced_var_vec): Remove.\n\t(first_readonly_imm_use): Remove redundant gcc_assert.\n\t(phi_arg_index_from_use): Combine gcc_asserts.\n\t(move_use_after_head): Wrap gcc_assert in ENABLE_CHECKING.\n\t(first_imm_use_stmt): Remove redundant gcc_assert.\n\t* tree-cfg.c (verify_gimple_call): Verify function and chain\n\toperands.  Verify arguments.\n\t(verify_types_in_gimple_stmt): Verify condition code and labels.\n\nFrom-SVN: r155696", "tree": {"sha": "db0482ed39bfbaeb0587c8d44b2175b07d0fdb8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db0482ed39bfbaeb0587c8d44b2175b07d0fdb8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f68a75df3b44539aca863cf89e1d8eac98ca5010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f68a75df3b44539aca863cf89e1d8eac98ca5010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f68a75df3b44539aca863cf89e1d8eac98ca5010", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f68a75df3b44539aca863cf89e1d8eac98ca5010/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "617531d9dd196e638c1cd9cae76d9d329309b627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617531d9dd196e638c1cd9cae76d9d329309b627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617531d9dd196e638c1cd9cae76d9d329309b627"}], "stats": {"total": 208, "additions": 115, "deletions": 93}, "files": [{"sha": "45f91b98cb2211cd473f174e813e95edad0cbcdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f68a75df3b44539aca863cf89e1d8eac98ca5010", "patch": "@@ -1,3 +1,49 @@\n+2010-01-07  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.h (gss_for_code): Wrap gcc_assert in ENABLE_CHECKING.\n+\t(gimple_op): Likewise.\n+\t(gimple_op_ptr): Likewise.\n+\t(gimple_assign_set_lhs): Remove gcc_assert.\n+\t(gimple_assign_set_rhs1): Likewise.\n+\t(gimple_assign_set_rhs2): Likewise.\n+\t(gimple_call_set_lhs): Likewise.\n+\t(gimple_call_set_fn): Likewise.\n+\t(gimple_call_set_fndecl): Likewise.\n+\t(gimple_call_fndecl): Likewise.\n+\t(gimple_call_return_type): Likewise.\n+\t(gimple_call_set_chain): Likewise.\n+\t(gimple_call_num_args): Likewise.\n+\t(gimple_call_set_arg): Likewise.\n+\t(gimple_cond_set_code): Likewise.\n+\t(gimple_cond_set_lhs): Likewise.\n+\t(gimple_cond_set_rhs): Likewise.\n+\t(gimple_cond_set_true_label): Likewise.\n+\t(gimple_cond_set_false_label): Likewise.\n+\t(gimple_label_set_label): Likewise.\n+\t(gimple_goto_set_dest): Likewise.\n+\t(gimple_debug_bind_get_var): Wrap gcc_assert in ENABLE_CHECKING.\n+\t(gimple_debug_bind_get_value): Likewise.\n+\t(gimple_debug_bind_get_value_ptr): Likewise.\n+\t(gimple_debug_bind_set_var): Likewise.\n+\t(gimple_debug_bind_set_value): Likewise.\n+\t(gimple_debug_bind_reset_value): Likewise.\n+\t(gimple_debug_bind_has_value_p): Likewise.\n+\t(gimple_return_retval_ptr): Remove gcc_assert.\n+\t(gimple_return_retval): Likewise.\n+\t(gimple_return_set_retval): Likewise.\n+\t* tree-flow.h (struct gimple_df): Remove nonlocal_all member.\n+\t(safe_referenced_var_iterator): Remove.\n+\t(FOR_EACH_REFERENCED_VAR_SAFE): Likewise.\n+\t* tree-flow-inline.h (gimple_nonlocal_all): Remove.\n+\t(fill_referenced_var_vec): Remove.\n+\t(first_readonly_imm_use): Remove redundant gcc_assert.\n+\t(phi_arg_index_from_use): Combine gcc_asserts.\n+\t(move_use_after_head): Wrap gcc_assert in ENABLE_CHECKING.\n+\t(first_imm_use_stmt): Remove redundant gcc_assert.\n+\t* tree-cfg.c (verify_gimple_call): Verify function and chain\n+\toperands.  Verify arguments.\n+\t(verify_types_in_gimple_stmt): Verify condition code and labels.\n+\n 2010-01-07  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/42641"}, {"sha": "63779389636c7911b10a7ff1acb5ddb98f986ac1", "filename": "gcc/gimple.h", "status": "modified", "additions": 22, "deletions": 40, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=f68a75df3b44539aca863cf89e1d8eac98ca5010", "patch": "@@ -1061,7 +1061,9 @@ gimple_code (const_gimple g)\n static inline enum gimple_statement_structure_enum\n gss_for_code (enum gimple_code code)\n {\n+#ifdef ENABLE_CHECKING\n   gcc_assert ((unsigned int)code < LAST_AND_UNUSED_GIMPLE_CODE);\n+#endif\n   return gss_for_code_[code];\n }\n \n@@ -1628,7 +1630,9 @@ gimple_op (const_gimple gs, unsigned i)\n {\n   if (gimple_has_ops (gs))\n     {\n+#ifdef ENABLE_CHECKING\n       gcc_assert (i < gimple_num_ops (gs));\n+#endif\n       return gimple_ops (CONST_CAST_GIMPLE (gs))[i];\n     }\n   else\n@@ -1642,7 +1646,9 @@ gimple_op_ptr (const_gimple gs, unsigned i)\n {\n   if (gimple_has_ops (gs))\n     {\n+#ifdef ENABLE_CHECKING\n       gcc_assert (i < gimple_num_ops (gs));\n+#endif\n       return gimple_ops (CONST_CAST_GIMPLE (gs)) + i;\n     }\n   else\n@@ -1706,7 +1712,6 @@ static inline void\n gimple_assign_set_lhs (gimple gs, tree lhs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  gcc_assert (is_gimple_operand (lhs));\n   gimple_set_op (gs, 0, lhs);\n \n   if (lhs && TREE_CODE (lhs) == SSA_NAME)\n@@ -1741,13 +1746,6 @@ gimple_assign_set_rhs1 (gimple gs, tree rhs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n \n-  /* If there are 3 or more operands, the 2 operands on the RHS must be\n-     GIMPLE values.  */\n-  if (gimple_num_ops (gs) >= 3)\n-    gcc_assert (is_gimple_val (rhs));\n-  else\n-    gcc_assert (is_gimple_operand (rhs));\n-\n   gimple_set_op (gs, 1, rhs);\n }\n \n@@ -1785,9 +1783,6 @@ gimple_assign_set_rhs2 (gimple gs, tree rhs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n \n-  /* The 2 operands on the RHS must be GIMPLE values.  */\n-  gcc_assert (is_gimple_val (rhs));\n-\n   gimple_set_op (gs, 2, rhs);\n }\n \n@@ -1901,7 +1896,6 @@ static inline void\n gimple_call_set_lhs (gimple gs, tree lhs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gcc_assert (!lhs || is_gimple_operand (lhs));\n   gimple_set_op (gs, 0, lhs);\n   if (lhs && TREE_CODE (lhs) == SSA_NAME)\n     SSA_NAME_DEF_STMT (lhs) = gs;\n@@ -1936,7 +1930,6 @@ static inline void\n gimple_call_set_fn (gimple gs, tree fn)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gcc_assert (is_gimple_operand (fn));\n   gimple_set_op (gs, 1, fn);\n }\n \n@@ -1947,7 +1940,6 @@ static inline void\n gimple_call_set_fndecl (gimple gs, tree decl)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   gimple_set_op (gs, 1, build_fold_addr_expr_loc (gimple_location (gs), decl));\n }\n \n@@ -1961,10 +1953,7 @@ gimple_call_fndecl (const_gimple gs)\n {\n   tree addr = gimple_call_fn (gs);\n   if (TREE_CODE (addr) == ADDR_EXPR)\n-    {\n-      gcc_assert (TREE_CODE (TREE_OPERAND (addr, 0)) == FUNCTION_DECL);\n-      return TREE_OPERAND (addr, 0);\n-    }\n+    return TREE_OPERAND (addr, 0);\n   return NULL_TREE;\n }\n \n@@ -1978,12 +1967,8 @@ gimple_call_return_type (const_gimple gs)\n   tree type = TREE_TYPE (fn);\n \n   /* See through the pointer.  */\n-  gcc_assert (POINTER_TYPE_P (type));\n   type = TREE_TYPE (type);\n \n-  gcc_assert (TREE_CODE (type) == FUNCTION_TYPE\n-\t      || TREE_CODE (type) == METHOD_TYPE);\n-\n   /* The type returned by a FUNCTION_DECL is the type of its\n      function type.  */\n   return TREE_TYPE (type);\n@@ -2015,9 +2000,7 @@ static inline void\n gimple_call_set_chain (gimple gs, tree chain)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gcc_assert (chain == NULL\n-              || TREE_CODE (chain) == ADDR_EXPR\n-              || SSA_VAR_P (chain));\n+\n   gimple_set_op (gs, 2, chain);\n }\n \n@@ -2030,7 +2013,6 @@ gimple_call_num_args (const_gimple gs)\n   unsigned num_ops;\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n   num_ops = gimple_num_ops (gs);\n-  gcc_assert (num_ops >= 3);\n   return num_ops - 3;\n }\n \n@@ -2062,7 +2044,6 @@ static inline void\n gimple_call_set_arg (gimple gs, unsigned index, tree arg)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gcc_assert (is_gimple_operand (arg));\n   gimple_set_op (gs, index + 3, arg);\n }\n \n@@ -2248,7 +2229,6 @@ static inline void\n gimple_cond_set_code (gimple gs, enum tree_code code)\n {\n   GIMPLE_CHECK (gs, GIMPLE_COND);\n-  gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n   gs->gsbase.subcode = code;\n }\n \n@@ -2279,7 +2259,6 @@ static inline void\n gimple_cond_set_lhs (gimple gs, tree lhs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_COND);\n-  gcc_assert (is_gimple_operand (lhs));\n   gimple_set_op (gs, 0, lhs);\n }\n \n@@ -2311,7 +2290,6 @@ static inline void\n gimple_cond_set_rhs (gimple gs, tree rhs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_COND);\n-  gcc_assert (is_gimple_operand (rhs));\n   gimple_set_op (gs, 1, rhs);\n }\n \n@@ -2334,7 +2312,6 @@ static inline void\n gimple_cond_set_true_label (gimple gs, tree label)\n {\n   GIMPLE_CHECK (gs, GIMPLE_COND);\n-  gcc_assert (!label || TREE_CODE (label) == LABEL_DECL);\n   gimple_set_op (gs, 2, label);\n }\n \n@@ -2346,7 +2323,6 @@ static inline void\n gimple_cond_set_false_label (gimple gs, tree label)\n {\n   GIMPLE_CHECK (gs, GIMPLE_COND);\n-  gcc_assert (!label || TREE_CODE (label) == LABEL_DECL);\n   gimple_set_op (gs, 3, label);\n }\n \n@@ -2477,7 +2453,6 @@ static inline void\n gimple_label_set_label (gimple gs, tree label)\n {\n   GIMPLE_CHECK (gs, GIMPLE_LABEL);\n-  gcc_assert (TREE_CODE (label) == LABEL_DECL);\n   gimple_set_op (gs, 0, label);\n }\n \n@@ -2498,7 +2473,6 @@ static inline void\n gimple_goto_set_dest (gimple gs, tree dest)\n {\n   GIMPLE_CHECK (gs, GIMPLE_GOTO);\n-  gcc_assert (is_gimple_operand (dest));\n   gimple_set_op (gs, 0, dest);\n }\n \n@@ -3292,7 +3266,9 @@ static inline tree\n gimple_debug_bind_get_var (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+#ifdef ENABLE_CHECKING\n   gcc_assert (gimple_debug_bind_p (dbg));\n+#endif\n   return gimple_op (dbg, 0);\n }\n \n@@ -3303,7 +3279,9 @@ static inline tree\n gimple_debug_bind_get_value (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+#ifdef ENABLE_CHECKING\n   gcc_assert (gimple_debug_bind_p (dbg));\n+#endif\n   return gimple_op (dbg, 1);\n }\n \n@@ -3314,7 +3292,9 @@ static inline tree *\n gimple_debug_bind_get_value_ptr (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+#ifdef ENABLE_CHECKING\n   gcc_assert (gimple_debug_bind_p (dbg));\n+#endif\n   return gimple_op_ptr (dbg, 1);\n }\n \n@@ -3324,7 +3304,9 @@ static inline void\n gimple_debug_bind_set_var (gimple dbg, tree var)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+#ifdef ENABLE_CHECKING\n   gcc_assert (gimple_debug_bind_p (dbg));\n+#endif\n   gimple_set_op (dbg, 0, var);\n }\n \n@@ -3335,7 +3317,9 @@ static inline void\n gimple_debug_bind_set_value (gimple dbg, tree value)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+#ifdef ENABLE_CHECKING\n   gcc_assert (gimple_debug_bind_p (dbg));\n+#endif\n   gimple_set_op (dbg, 1, value);\n }\n \n@@ -3350,7 +3334,9 @@ static inline void\n gimple_debug_bind_reset_value (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+#ifdef ENABLE_CHECKING\n   gcc_assert (gimple_debug_bind_p (dbg));\n+#endif\n   gimple_set_op (dbg, 1, GIMPLE_DEBUG_BIND_NOVALUE);\n }\n \n@@ -3361,7 +3347,9 @@ static inline bool\n gimple_debug_bind_has_value_p (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+#ifdef ENABLE_CHECKING\n   gcc_assert (gimple_debug_bind_p (dbg));\n+#endif\n   return gimple_op (dbg, 1) != GIMPLE_DEBUG_BIND_NOVALUE;\n }\n \n@@ -4254,7 +4242,6 @@ static inline tree *\n gimple_return_retval_ptr (const_gimple gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_RETURN);\n-  gcc_assert (gimple_num_ops (gs) == 1);\n   return gimple_op_ptr (gs, 0);\n }\n \n@@ -4264,7 +4251,6 @@ static inline tree\n gimple_return_retval (const_gimple gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_RETURN);\n-  gcc_assert (gimple_num_ops (gs) == 1);\n   return gimple_op (gs, 0);\n }\n \n@@ -4275,10 +4261,6 @@ static inline void\n gimple_return_set_retval (gimple gs, tree retval)\n {\n   GIMPLE_CHECK (gs, GIMPLE_RETURN);\n-  gcc_assert (gimple_num_ops (gs) == 1);\n-  gcc_assert (retval == NULL_TREE\n-              || TREE_CODE (retval) == RESULT_DECL\n-\t      || is_gimple_val (retval));\n   gimple_set_op (gs, 0, retval);\n }\n "}, {"sha": "36e518c98820cc1afd60724b99ccfd2445494634", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f68a75df3b44539aca863cf89e1d8eac98ca5010", "patch": "@@ -2937,6 +2937,15 @@ verify_gimple_call (gimple stmt)\n {\n   tree fn = gimple_call_fn (stmt);\n   tree fntype;\n+  unsigned i;\n+\n+  if (TREE_CODE (fn) != OBJ_TYPE_REF\n+      && !is_gimple_val (fn))\n+    {\n+      error (\"invalid function in gimple call\");\n+      debug_generic_stmt (fn);\n+      return true;\n+    }\n \n   if (!POINTER_TYPE_P (TREE_TYPE  (fn))\n       || (TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != FUNCTION_TYPE\n@@ -2972,6 +2981,14 @@ verify_gimple_call (gimple stmt)\n       return true;\n     }\n \n+  if (gimple_call_chain (stmt)\n+      && !is_gimple_val (gimple_call_chain (stmt)))\n+    {\n+      error (\"invalid static chain in gimple call\");\n+      debug_generic_stmt (gimple_call_chain (stmt));\n+      return true;\n+    }\n+\n   /* If there is a static chain argument, this should not be an indirect\n      call, and the decl should have DECL_STATIC_CHAIN set.  */\n   if (gimple_call_chain (stmt))\n@@ -2993,9 +3010,19 @@ verify_gimple_call (gimple stmt)\n \n   /* ???  The C frontend passes unpromoted arguments in case it\n      didn't see a function declaration before the call.  So for now\n-     leave the call arguments unverified.  Once we gimplify\n+     leave the call arguments mostly unverified.  Once we gimplify\n      unit-at-a-time we have a chance to fix this.  */\n \n+  for (i = 0; i < gimple_call_num_args (stmt); ++i)\n+    {\n+      tree arg = gimple_call_arg (stmt, i);\n+      if (!is_gimple_operand (arg))\n+\t{\n+\t  error (\"invalid argument to gimple call\");\n+\t  debug_generic_expr (arg);\n+\t}\n+    }\n+\n   return false;\n }\n \n@@ -3744,6 +3771,20 @@ verify_types_in_gimple_stmt (gimple stmt)\n       return verify_gimple_call (stmt);\n \n     case GIMPLE_COND:\n+      if (TREE_CODE_CLASS (gimple_cond_code (stmt)) != tcc_comparison)\n+\t{\n+\t  error (\"invalid comparison code in gimple cond\");\n+\t  return true;\n+\t}\n+      if (!(!gimple_cond_true_label (stmt)\n+\t    || TREE_CODE (gimple_cond_true_label (stmt)) == LABEL_DECL)\n+\t  || !(!gimple_cond_false_label (stmt)\n+\t       || TREE_CODE (gimple_cond_false_label (stmt)) == LABEL_DECL))\n+\t{\n+\t  error (\"invalid labels in gimple cond\");\n+\t  return true;\n+\t}\n+\t  \n       return verify_gimple_comparison (boolean_type_node,\n \t\t\t\t       gimple_cond_lhs (stmt),\n \t\t\t\t       gimple_cond_rhs (stmt));"}, {"sha": "bb9cc7d5b847e3960c0b0df5b05ffb4d62167fb3", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=f68a75df3b44539aca863cf89e1d8eac98ca5010", "patch": "@@ -44,15 +44,6 @@ gimple_referenced_vars (const struct function *fun)\n   return fun->gimple_df->referenced_vars;\n }\n \n-/* Artificial variable used to model the effects of nonlocal\n-   variables.  */\n-static inline tree\n-gimple_nonlocal_all (const struct function *fun)\n-{\n-  gcc_assert (fun && fun->gimple_df);\n-  return fun->gimple_df->nonlocal_all;\n-}\n-\n /* Artificial variable used for the virtual operand FUD chain.  */\n static inline tree\n gimple_vop (const struct function *fun)\n@@ -135,18 +126,6 @@ next_referenced_var (referenced_var_iterator *iter)\n   return (tree) next_htab_element (&iter->hti);\n }\n \n-/* Fill up VEC with the variables in the referenced vars hashtable.  */\n-\n-static inline void\n-fill_referenced_var_vec (VEC (tree, heap) **vec)\n-{\n-  referenced_var_iterator rvi;\n-  tree var;\n-  *vec = NULL;\n-  FOR_EACH_REFERENCED_VAR (var, rvi)\n-    VEC_safe_push (tree, heap, *vec, var);\n-}\n-\n /* Return the variable annotation for T, which must be a _DECL node.\n    Return NULL if the variable annotation doesn't already exist.  */\n static inline var_ann_t\n@@ -312,8 +291,6 @@ end_readonly_imm_use_p (const imm_use_iterator *imm)\n static inline use_operand_p\n first_readonly_imm_use (imm_use_iterator *imm, tree var)\n {\n-  gcc_assert (TREE_CODE (var) == SSA_NAME);\n-\n   imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n   imm->imm_use = imm->end_p->next;\n #ifdef ENABLE_CHECKING\n@@ -573,9 +550,9 @@ phi_arg_index_from_use (use_operand_p use)\n #ifdef ENABLE_CHECKING\n   /* Make sure the calculation doesn't have any leftover bytes.  If it does,\n      then imm_use is likely not the first element in phi_arg_d.  */\n-  gcc_assert (\n-\t  (((char *)element - (char *)root) % sizeof (struct phi_arg_d)) == 0);\n-  gcc_assert (index < gimple_phi_capacity (phi));\n+  gcc_assert ((((char *)element - (char *)root)\n+\t       % sizeof (struct phi_arg_d)) == 0\n+\t      && index < gimple_phi_capacity (phi));\n #endif\n \n  return index;\n@@ -1013,7 +990,9 @@ static inline use_operand_p\n move_use_after_head (use_operand_p use_p, use_operand_p head,\n \t\t      use_operand_p last_p)\n {\n+#ifdef ENABLE_CHECKING\n   gcc_assert (USE_FROM_PTR (use_p) == USE_FROM_PTR (head));\n+#endif\n   /* Skip head when we find it.  */\n   if (use_p != head)\n     {\n@@ -1078,8 +1057,6 @@ link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n static inline gimple\n first_imm_use_stmt (imm_use_iterator *imm, tree var)\n {\n-  gcc_assert (TREE_CODE (var) == SSA_NAME);\n-\n   imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n   imm->imm_use = imm->end_p->next;\n   imm->next_imm_name = NULL_USE_OPERAND_P;"}, {"sha": "e39658a78fb490e5c619bfb6b77553749ee4cf21", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68a75df3b44539aca863cf89e1d8eac98ca5010/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f68a75df3b44539aca863cf89e1d8eac98ca5010", "patch": "@@ -53,10 +53,6 @@ struct GTY(()) gimple_df {\n   /* Artificial variable used for the virtual operand FUD chain.  */\n   tree vop;\n \n-  /* Artificial variable used to model the effects of nonlocal\n-     variables.  */\n-  tree nonlocal_all;\n-\n   /* The PTA solution for the ESCAPED artificial variable.  */\n   struct pt_solution escaped;\n \n@@ -339,7 +335,6 @@ typedef struct\n   htab_iterator hti;\n } referenced_var_iterator;\n \n-\n /* This macro loops over all the referenced vars, one at a time, putting the\n    current var in VAR.  Note:  You are not allowed to add referenced variables\n    to the hashtable while using this macro.  Doing so may cause it to behave\n@@ -350,25 +345,6 @@ typedef struct\n        !end_referenced_vars_p (&(ITER)); \\\n        (VAR) = next_referenced_var (&(ITER)))\n \n-\n-typedef struct\n-{\n-  int i;\n-} safe_referenced_var_iterator;\n-\n-/* This macro loops over all the referenced vars, one at a time, putting the\n-   current var in VAR.  You are allowed to add referenced variables during the\n-   execution of this macro, however, the macro will not iterate over them.  It\n-   requires a temporary vector of trees, VEC, whose lifetime is controlled by\n-   the caller.  The purpose of the vector is to temporarily store the\n-   referenced_variables hashtable so that adding referenced variables does not\n-   affect the hashtable.  */\n-\n-#define FOR_EACH_REFERENCED_VAR_SAFE(VAR, VEC, ITER) \\\n-  for ((ITER).i = 0, fill_referenced_var_vec (&(VEC)); \\\n-       VEC_iterate (tree, (VEC), (ITER).i, (VAR)); \\\n-       (ITER).i++)\n-\n extern tree referenced_var_lookup (unsigned int);\n extern bool referenced_var_check_and_insert (tree);\n #define num_referenced_vars htab_elements (gimple_referenced_vars (cfun))"}]}