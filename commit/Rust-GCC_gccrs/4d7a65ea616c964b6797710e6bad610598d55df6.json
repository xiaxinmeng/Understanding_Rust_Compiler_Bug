{"sha": "4d7a65ea616c964b6797710e6bad610598d55df6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ3YTY1ZWE2MTZjOTY0YjY3OTc3MTBlNmJhZDYxMDU5OGQ1NWRmNg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-05-22T20:41:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-05-22T20:41:31Z"}, "message": "re PR tree-optimization/38964 (TBAA side-effects of C++ new still missing)\n\n2009-05-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/38964\n\t* alias.c (write_dependence_p): Do not use TBAA for answering\n\tanti-dependence or output-dependence.\n\t* tree-ssa-structalias.c (set_uids_in_ptset): Remove TBAA pruning\n\tcode.\n\t(emit_pointer_definition): Remove.\n\t(emit_alias_warning): Likewise.\n\t(find_what_var_points_to): Remove TBAA pruning code.\n\t(find_what_p_points_to): Likewise.  Do not warn about strict-aliasing\n\tviolations.\n\t(compute_points_to_sets): Remove code computing the set of\n\tdereferenced pointers.\n\t* tree-data-ref.c (dr_may_alias_p): Properly use the split\n\toracle for querying anti and output dependencies.\n\t* tree-ssa-alias.c (refs_may_alias_p_1): Add argument specifying\n\tif TBAA may be applied.\n\t(refs_anti_dependent_p): New function.\n\t(refs_output_dependent_p): Likewise.\n\t* tree-ssa-alias.h (refs_anti_dependent_p): Declare.\n\t(refs_output_dependent_p): Likewise.\n\n\t* doc/tree-ssa.texi (Memory model): New section.\n\n\ttestsuite/\n\t* g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C: XFAIL.\n\t* gcc.dg/Wstrict-aliasing-converted-assigned.c: Likewise.\n\t* gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c: Likewise.\n\n\t* doc/c-tree.texi (CHANGE_DYNAMIC_TYPE_EXPR): Remove.\n\t* doc/gimple.texi (GIMPLE_CHANGE_DYNAMIC_TYPE): Remove.\n\n\t* cfgexpand.c (expand_gimple_basic_block): Do not handle\n\tGIMPLE_CHANGE_DYNAMIC_TYPE or CHANGE_DYNAMIC_TYPE_EXPR.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t* gimple-low.c (lower_stmt): Likewise.\n\t* gimple-pretty-print.c (dump_gimple_stmt): Likewise.\n\t(dump_gimple_cdt): Remove.\n\t* gimple.c (gss_for_code): Do not handle GIMPLE_CHANGE_DYNAMIC_TYPE.\n\t(gimple_size): Likewise.\n\t(walk_gimple_op): Likewise.\n\t(is_gimple_stmt): Likewise.\n\t(walk_stmt_load_store_addr_ops): Likewise.\n\t(gimple_build_cdt): Remove.\n\t* gimple.def (GIMPLE_CHANGE_DYNAMIC_TYPE): Remove.\n\t* gimple.h (gimple_cdt_new_type): Remove.\n\t(gimple_cdt_new_type_ptr): Likewise.\n\t(gimple_cdt_set_new_type): Likewise.\n\t(gimple_cdt_location): Likewise.\n\t(gimple_cdt_location_ptr): Likewise.\n\t(gimple_cdt_set_location): Likewise.\n\t* gimplify.c (gimplify_expr): Do not handle CHANGE_DYNAMIC_TYPE_EXPR.\n\t* tree-cfg.c (remove_useless_stmts_1): Do not handle\n\tGIMPLE_CHANGE_DYNAMIC_TYPE.\n\t(verify_types_in_gimple_stmt): Likewise.\n\t* tree-inline.c (estimate_num_insns): Likewise.\n\t(expand_call_inline): Do not copy DECL_NO_TBAA_P.\n\t(copy_decl_to_var): Likewise.\n\t(copy_result_decl_to_var): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Do not handle\n\tCHANGE_DYNAMIC_TYPE_EXPR.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree-ssa-structalias.c (struct variable_info): Remove\n\tno_tbaa_pruning member.\n\t(new_var_info): Do not set it based on DECL_NO_TBAA_P.\n\t(unify_nodes): Do not copy it.\n\t(find_func_aliases): Do not handle GIMPLE_CHANGE_DYNAMIC_TYPE.\n\t(dump_solution_for_var): Do not dump no_tbaa_pruning state.\n\t(set_uids_in_ptset): Do not check it.\n\t(find_what_var_points_to): Likewise.\n\t(compute_tbaa_pruning): Remove.\n\t(compute_points_to_sets): Do not call it.\n\t* tree.c (walk_tree_1): Do not handle CHANGE_DYNAMIC_TYPE_EXPR.\n\t* tree.def (CHANGE_DYNAMIC_TYPE_EXPR): Remove.\n\t* tree.h (CHANGE_DYNAMIC_TYPE_NEW_TYPE): Remove.\n\t(CHANGE_DYNAMIC_TYPE_LOCATION): Likewise.\n\t(DECL_NO_TBAA_P): Likewise.\n\t(struct tree_decl_common): Move no_tbaa_flag to unused flags section.\n\t* omp-low.c (copy_var_decl): Do not copy DECL_NO_TBAA_P.\n\t(expand_omp_atomic_pipeline): Do not set it.\n\t* print-tree.c (print_node): Do not dump it.\n\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Remove\n\tredundant check.\n\n\tcp/\n\t* init.c (avoid_placement_new_aliasing): Remove.\n\t(build_new_1): Do not call it.\n\nFrom-SVN: r147805", "tree": {"sha": "591b8d105b3bc5fac1ff8aabd16a58458d55aece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/591b8d105b3bc5fac1ff8aabd16a58458d55aece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d7a65ea616c964b6797710e6bad610598d55df6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d7a65ea616c964b6797710e6bad610598d55df6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d7a65ea616c964b6797710e6bad610598d55df6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d7a65ea616c964b6797710e6bad610598d55df6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83a6ac60c6100cfa605da437391c1fd8b327055a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a6ac60c6100cfa605da437391c1fd8b327055a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a6ac60c6100cfa605da437391c1fd8b327055a"}], "stats": {"total": 911, "additions": 198, "deletions": 713}, "files": [{"sha": "32c00a6102d943abe15a9b0a91122a0b08195a41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1,3 +1,81 @@\n+2009-05-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/38964\n+\t* alias.c (write_dependence_p): Do not use TBAA for answering\n+\tanti-dependence or output-dependence.\n+\t* tree-ssa-structalias.c (set_uids_in_ptset): Remove TBAA pruning\n+\tcode.\n+\t(emit_pointer_definition): Remove.\n+\t(emit_alias_warning): Likewise.\n+\t(find_what_var_points_to): Remove TBAA pruning code.\n+\t(find_what_p_points_to): Likewise.  Do not warn about strict-aliasing\n+\tviolations.\n+\t(compute_points_to_sets): Remove code computing the set of\n+\tdereferenced pointers.\n+\t* tree-data-ref.c (dr_may_alias_p): Properly use the split\n+\toracle for querying anti and output dependencies.\n+\t* tree-ssa-alias.c (refs_may_alias_p_1): Add argument specifying\n+\tif TBAA may be applied.\n+\t(refs_anti_dependent_p): New function.\n+\t(refs_output_dependent_p): Likewise.\n+\t* tree-ssa-alias.h (refs_anti_dependent_p): Declare.\n+\t(refs_output_dependent_p): Likewise.\n+\t* doc/tree-ssa.texi (Memory model): New section.\n+\t* doc/c-tree.texi (CHANGE_DYNAMIC_TYPE_EXPR): Remove.\n+\t* doc/gimple.texi (GIMPLE_CHANGE_DYNAMIC_TYPE): Remove.\n+\t* cfgexpand.c (expand_gimple_basic_block): Do not handle\n+\tGIMPLE_CHANGE_DYNAMIC_TYPE or CHANGE_DYNAMIC_TYPE_EXPR.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* gimple-low.c (lower_stmt): Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_stmt): Likewise.\n+\t(dump_gimple_cdt): Remove.\n+\t* gimple.c (gss_for_code): Do not handle GIMPLE_CHANGE_DYNAMIC_TYPE.\n+\t(gimple_size): Likewise.\n+\t(walk_gimple_op): Likewise.\n+\t(is_gimple_stmt): Likewise.\n+\t(walk_stmt_load_store_addr_ops): Likewise.\n+\t(gimple_build_cdt): Remove.\n+\t* gimple.def (GIMPLE_CHANGE_DYNAMIC_TYPE): Remove.\n+\t* gimple.h (gimple_cdt_new_type): Remove.\n+\t(gimple_cdt_new_type_ptr): Likewise.\n+\t(gimple_cdt_set_new_type): Likewise.\n+\t(gimple_cdt_location): Likewise.\n+\t(gimple_cdt_location_ptr): Likewise.\n+\t(gimple_cdt_set_location): Likewise.\n+\t* gimplify.c (gimplify_expr): Do not handle CHANGE_DYNAMIC_TYPE_EXPR.\n+\t* tree-cfg.c (remove_useless_stmts_1): Do not handle\n+\tGIMPLE_CHANGE_DYNAMIC_TYPE.\n+\t(verify_types_in_gimple_stmt): Likewise.\n+\t* tree-inline.c (estimate_num_insns): Likewise.\n+\t(expand_call_inline): Do not copy DECL_NO_TBAA_P.\n+\t(copy_decl_to_var): Likewise.\n+\t(copy_result_decl_to_var): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Do not handle\n+\tCHANGE_DYNAMIC_TYPE_EXPR.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-ssa-structalias.c (struct variable_info): Remove\n+\tno_tbaa_pruning member.\n+\t(new_var_info): Do not set it based on DECL_NO_TBAA_P.\n+\t(unify_nodes): Do not copy it.\n+\t(find_func_aliases): Do not handle GIMPLE_CHANGE_DYNAMIC_TYPE.\n+\t(dump_solution_for_var): Do not dump no_tbaa_pruning state.\n+\t(set_uids_in_ptset): Do not check it.\n+\t(find_what_var_points_to): Likewise.\n+\t(compute_tbaa_pruning): Remove.\n+\t(compute_points_to_sets): Do not call it.\n+\t* tree.c (walk_tree_1): Do not handle CHANGE_DYNAMIC_TYPE_EXPR.\n+\t* tree.def (CHANGE_DYNAMIC_TYPE_EXPR): Remove.\n+\t* tree.h (CHANGE_DYNAMIC_TYPE_NEW_TYPE): Remove.\n+\t(CHANGE_DYNAMIC_TYPE_LOCATION): Likewise.\n+\t(DECL_NO_TBAA_P): Likewise.\n+\t(struct tree_decl_common): Move no_tbaa_flag to unused flags section.\n+\t* omp-low.c (copy_var_decl): Do not copy DECL_NO_TBAA_P.\n+\t(expand_omp_atomic_pipeline): Do not set it.\n+\t* print-tree.c (print_node): Do not dump it.\n+\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Remove\n+\tredundant check.\n+\n 2009-05-22 Vladimir Makarov <vmakarov@redhat.com>\n \n \tPR target/39856"}, {"sha": "4d42778a64451e7edfa4709447c5e01293237abc", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -2373,9 +2373,6 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n     return 1;\n \n-  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n-    return 0;\n-\n   /* A read from read-only memory can't conflict with read-write memory.  */\n   if (!writep && MEM_READONLY_P (mem))\n     return 0;"}, {"sha": "65a13de8a3d85bda22f4fad8a0d180f57f853f40", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -2100,7 +2100,7 @@ expand_gimple_basic_block (basic_block bb)\n \t\t    return new_bb;\n \t\t}\n \t    }\n-\t  else if (gimple_code (stmt) != GIMPLE_CHANGE_DYNAMIC_TYPE)\n+\t  else\n \t    {\n \t      def_operand_p def_p;\n \t      tree stmt_tree;"}, {"sha": "aeab9a158033b854d571a8f2774bb88aaffd455a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1,3 +1,9 @@\n+2009-05-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/38964\n+\t* init.c (avoid_placement_new_aliasing): Remove.\n+\t(build_new_1): Do not call it.\n+\n 2009-05-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (decl_needed_p): Consider dllexport'd functions needed."}, {"sha": "25cfd52fcdf0f2b41a63b755d0d337c825905986", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1742,55 +1742,6 @@ build_raw_new_expr (VEC(tree,gc) *placement, tree type, tree nelts,\n   return new_expr;\n }\n \n-/* Make sure that there are no aliasing issues with T, a placement new\n-   expression applied to PLACEMENT, by recording the change in dynamic\n-   type.  If placement new is inlined, as it is with libstdc++, and if\n-   the type of the placement new differs from the type of the\n-   placement location itself, then alias analysis may think it is OK\n-   to interchange writes to the location from before the placement new\n-   and from after the placement new.  We have to prevent type-based\n-   alias analysis from applying.  PLACEMENT may be NULL, which means\n-   that we couldn't capture it in a temporary variable, in which case\n-   we use a memory clobber.  */\n-\n-static tree\n-avoid_placement_new_aliasing (tree t, tree placement)\n-{\n-  tree type_change;\n-\n-  if (processing_template_decl)\n-    return t;\n-\n-  /* If we are not using type based aliasing, we don't have to do\n-     anything.  */\n-  if (!flag_strict_aliasing)\n-    return t;\n-\n-  /* If we have a pointer and a location, record the change in dynamic\n-     type.  Otherwise we need a general memory clobber.  */\n-  if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n-      && placement != NULL_TREE\n-      && TREE_CODE (TREE_TYPE (placement)) == POINTER_TYPE)\n-    type_change = build_stmt (CHANGE_DYNAMIC_TYPE_EXPR,\n-\t\t\t      TREE_TYPE (t),\n-\t\t\t      placement);\n-  else\n-    {\n-      /* Build a memory clobber.  */\n-      type_change = build_stmt (ASM_EXPR,\n-\t\t\t\tbuild_string (0, \"\"),\n-\t\t\t\tNULL_TREE,\n-\t\t\t\tNULL_TREE,\n-\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t   build_string (6, \"memory\"),\n-\t\t\t\t\t   NULL_TREE));\n-\n-      ASM_VOLATILE_P (type_change) = 1;\n-    }\n-\n-  return build2 (COMPOUND_EXPR, TREE_TYPE (t), type_change, t);\n-}\n-\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -1826,7 +1777,6 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n   tree cookie_size = NULL_TREE;\n-  bool have_placement;\n   tree placement_first;\n   tree placement_expr = NULL_TREE;\n   /* True if the function we are calling is a placement allocation\n@@ -1894,7 +1844,6 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n   /* If PLACEMENT is a single simple pointer type not passed by\n      reference, prepare to capture it in a temporary variable.  Do\n      this now, since PLACEMENT will change in the calls below.  */\n-  have_placement = !VEC_empty (tree, *placement);\n   placement_first = NULL_TREE;\n   if (VEC_length (tree, *placement) == 1\n       && (TREE_CODE (TREE_TYPE (VEC_index (tree, *placement, 0)))\n@@ -2026,12 +1975,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n   /* In the simple case, we can stop now.  */\n   pointer_type = build_pointer_type (type);\n   if (!cookie_size && !is_initialized)\n-    {\n-      rval = build_nop (pointer_type, alloc_call);\n-      if (have_placement)\n-\trval = avoid_placement_new_aliasing (rval, placement_expr);\n-      return rval;\n-    }\n+    return build_nop (pointer_type, alloc_call);\n \n   /* Store the result of the allocation call in a variable so that we can\n      use it more than once.  */\n@@ -2307,9 +2251,6 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n   /* A new-expression is never an lvalue.  */\n   gcc_assert (!lvalue_p (rval));\n \n-  if (have_placement)\n-    rval = avoid_placement_new_aliasing (rval, placement_expr);\n-\n   return rval;\n }\n "}, {"sha": "35498583ccd39cf515f186456bb6a5ba49bd16e7", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1995,7 +1995,6 @@ This macro returns the attributes on the type @var{type}.\n @tindex TARGET_EXPR\n @tindex AGGR_INIT_EXPR\n @tindex VA_ARG_EXPR\n-@tindex CHANGE_DYNAMIC_TYPE_EXPR\n @tindex OMP_PARALLEL\n @tindex OMP_FOR\n @tindex OMP_SECTIONS\n@@ -2708,13 +2707,6 @@ mechanism.  It represents expressions like @code{va_arg (ap, type)}.\n Its @code{TREE_TYPE} yields the tree representation for @code{type} and\n its sole argument yields the representation for @code{ap}.\n \n-@item CHANGE_DYNAMIC_TYPE_EXPR\n-Indicates the special aliasing required by C++ placement new.  It has\n-two operands: a type and a location.  It means that the dynamic type\n-of the location is changing to be the specified type.  The alias\n-analysis code takes this into account when doing type based alias\n-analysis.\n-\n @item OMP_PARALLEL\n \n Represents @code{#pragma omp parallel [clause1 @dots{} clauseN]}. It"}, {"sha": "a78c52dcafc68c2be2329ae7c1a272fbfe0377e9", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -332,14 +332,13 @@ union gimple_statement_d\n \n The following table briefly describes the GIMPLE instruction set.\n \n-@multitable {@code{GIMPLE_CHANGE_DYNAMIC_TYPE}} {High GIMPLE} {Low GIMPLE}\n+@multitable {@code{GIMPLE_OMP_SECTIONS_SWITCH}} {High GIMPLE} {Low GIMPLE}\n @item Instruction\t\t\t@tab High GIMPLE\t@tab Low GIMPLE\n @item @code{GIMPLE_ASM}\t\t\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_ASSIGN}\t\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_BIND}\t\t@tab x\t\t\t@tab\n @item @code{GIMPLE_CALL}\t\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_CATCH}\t\t@tab x\t\t\t@tab\n-@item @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_COND}\t\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_EH_FILTER}\t\t@tab x\t\t\t@tab\n @item @code{GIMPLE_GOTO}\t\t@tab x\t\t\t@tab x\n@@ -885,7 +884,6 @@ Return a deep copy of statement @code{STMT}.\n * @code{GIMPLE_BIND}::\n * @code{GIMPLE_CALL}::\n * @code{GIMPLE_CATCH}::\n-* @code{GIMPLE_CHANGE_DYNAMIC_TYPE}::\n * @code{GIMPLE_COND}::\n * @code{GIMPLE_EH_FILTER}::\n * @code{GIMPLE_LABEL}::\n@@ -1295,45 +1293,6 @@ Set @code{T} to be the set of types handled by @code{GIMPLE_CATCH} @code{G}.\n Set @code{HANDLER} to be the body of @code{GIMPLE_CATCH} @code{G}. \n @end deftypefn\n \n-@node @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n-@subsection @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n-@cindex @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n-\n-@deftypefn {GIMPLE function} gimple gimple_build_cdt (tree type, tree ptr)\n-Build a @code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement.  @code{TYPE} is the new\n-type for the location @code{PTR}.\n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} tree gimple_cdt_new_type (gimple g)\n-Return the new type set by @code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement\n-@code{G}. \n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} tree *gimple_cdt_new_type_ptr (gimple g)\n-Return a pointer to the new type set by\n-@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. \n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} void gimple_cdt_set_new_type (gimple g, tree new_type)\n-Set @code{NEW_TYPE} to be the type returned by\n-@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. \n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} tree gimple_cdt_location (gimple g)\n-Return the location affected by @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n-statement @code{G}. \n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} tree *gimple_cdt_location_ptr (gimple g)\n-Return a pointer to the location affected by\n-@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. \n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} void gimple_cdt_set_location (gimple g, tree ptr)\n-Set @code{PTR} to be the location affected by @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n-statement @code{G}. \n-@end deftypefn\n-\n \n @node @code{GIMPLE_COND}\n @subsection @code{GIMPLE_COND}"}, {"sha": "ebb85a0576969b308b8390f438ea84fa0c67e2e6", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -41,6 +41,7 @@ passes for GIMPLE@.\n * SSA Operands::  \tSSA names referenced by GIMPLE statements.\n * SSA::                 Static Single Assignment representation.\n * Alias analysis::      Representing aliased loads and stores.\n+* Memory model::        Memory model used by the middle-end.\n @end menu\n \n @node Annotations\n@@ -892,3 +893,31 @@ providing its aliasing VDEF.  The walk stops if asked to.\n \n @end enumerate\n \n+\n+@node Memory model\n+@section Memory model\n+@cindex memory model\n+\n+The memory model used by the middle-end models that of the C/C++\n+languages.  The middle-end has the notion of an effective type\n+of a memory region which is used for type-based alias analysis.\n+\n+The following is a refinement of ISO C99 6.5/6, clarifying the block copy case\n+to follow common sense and extending the concept of a dynamic effective\n+type to objects with a declared type as required for C++.\n+\n+@smallexample\n+The effective type of an object for an access to its stored value is\n+the declared type of the object or the effective type determined by\n+a previous store to it.  If a value is stored into an object through\n+an lvalue having a type that is not a character type, then the\n+type of the lvalue becomes the effective type of the object for that\n+access and for subsequent accesses that do not modify the stored value.\n+If a value is copied into an object using @code{memcpy} or @code{memmove},\n+or is copied as an array of character type, then the effective type\n+of the modified object for that access and for subsequent accesses that\n+do not modify the value is undetermined.  For all other accesses to an\n+object, the effective type of the object is simply the type of the\n+lvalue used for the access.\n+@end smallexample\n+"}, {"sha": "c2524f2ead590ae6246a238ccc6fd9d486a7ffd3", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -9298,13 +9298,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Lowered by gimplify.c.  */\n       gcc_unreachable ();\n \n-    case CHANGE_DYNAMIC_TYPE_EXPR:\n-      /* This is ignored at the RTL level.  The tree level set\n-\t DECL_POINTER_ALIAS_SET of any variable to be 0, which is\n-\t overkill for the RTL layer but is all that we can\n-\t represent.  */\n-      return const0_rtx;\n-\n     case EXC_PTR_EXPR:\n       return get_exception_pointer ();\n "}, {"sha": "42bf9b11ea946d27cff3e2038d01d7fd56354dc4", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -368,7 +368,6 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n     case GIMPLE_PREDICT:\n     case GIMPLE_LABEL:\n     case GIMPLE_SWITCH:\n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n     case GIMPLE_OMP_FOR:\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SECTIONS_SWITCH:"}, {"sha": "ec366f86f4235ead417921c567ed4641e28fdd34", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1324,27 +1324,6 @@ dump_gimple_omp_atomic_store (pretty_printer *buffer, gimple gs, int spc,\n     }\n }\n \n-/* Dump a GIMPLE_CHANGE_DYNAMIC_TYPE statement GS.  BUFFER, SPC and\n-   FLAGS are as in dump_gimple_stmt.  */\n-\n-static void\n-dump_gimple_cdt (pretty_printer *buffer, gimple gs, int spc, int flags)\n-{\n-  if (flags & TDF_RAW)\n-    dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T>\", gs,\n-                     gimple_cdt_new_type (gs), gimple_cdt_location (gs));\n-  else\n-    {\n-      pp_string (buffer, \"<<<change_dynamic_type (\");\n-      dump_generic_node (buffer, gimple_cdt_new_type (gs), spc + 2, flags,\n-                         false);\n-      pp_string (buffer, \") \");\n-      dump_generic_node (buffer, gimple_cdt_location (gs), spc + 2, flags,\n-                         false);\n-      pp_string (buffer, \")>>>\");\n-    }\n-}\n-\n \n /* Dump all the memory operands for statement GS.  BUFFER, SPC and\n    FLAGS are as in dump_gimple_stmt.  */\n@@ -1508,10 +1487,6 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n       dump_gimple_omp_critical (buffer, gs, spc, flags);\n       break;\n \n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n-      dump_gimple_cdt (buffer, gs, spc, flags);\n-      break;\n-\n     case GIMPLE_CATCH:\n       dump_gimple_catch (buffer, gs, spc, flags);\n       break;"}, {"sha": "703236691f7d0d51ff144e4acb17616ec57fae6b", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -102,7 +102,6 @@ gss_for_code (enum gimple_code code)\n     case GIMPLE_COND:\n     case GIMPLE_GOTO:\n     case GIMPLE_LABEL:\n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n     case GIMPLE_SWITCH:\t\t\treturn GSS_WITH_OPS;\n     case GIMPLE_ASM:\t\t\treturn GSS_ASM;\n     case GIMPLE_BIND:\t\t\treturn GSS_BIND;\n@@ -190,8 +189,6 @@ gimple_size (enum gimple_code code)\n       return sizeof (struct gimple_statement_omp_atomic_store);\n     case GIMPLE_WITH_CLEANUP_EXPR:\n       return sizeof (struct gimple_statement_wce);\n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n-      return sizeof (struct gimple_statement_with_ops);\n     case GIMPLE_PREDICT:\n       return sizeof (struct gimple_statement_base);\n     default:\n@@ -1042,20 +1039,6 @@ gimple_build_omp_single (gimple_seq body, tree clauses)\n }\n \n \n-/* Build a GIMPLE_CHANGE_DYNAMIC_TYPE statement.  TYPE is the new type\n-   for the location PTR.  */\n-\n-gimple\n-gimple_build_cdt (tree type, tree ptr)\n-{\n-  gimple p = gimple_build_with_ops (GIMPLE_CHANGE_DYNAMIC_TYPE, ERROR_MARK, 2);\n-  gimple_cdt_set_new_type (p, type);\n-  gimple_cdt_set_location (p, ptr);\n-\n-  return p;\n-}\n-\n-\n /* Build a GIMPLE_OMP_ATOMIC_LOAD statement.  */\n \n gimple\n@@ -1460,16 +1443,6 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n \treturn ret;\n       break;\n \n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n-      ret = walk_tree (gimple_cdt_location_ptr (stmt), callback_op, wi, pset);\n-      if (ret)\n-\treturn ret;\n-\n-      ret = walk_tree (gimple_cdt_new_type_ptr (stmt), callback_op, wi, pset);\n-      if (ret)\n-\treturn ret;\n-      break;\n-\n     case GIMPLE_ASM:\n       ret = walk_gimple_asm (stmt, callback_op, wi);\n       if (ret)\n@@ -2749,7 +2722,6 @@ is_gimple_stmt (tree t)\n     case TRY_FINALLY_EXPR:\n     case EH_FILTER_EXPR:\n     case CATCH_EXPR:\n-    case CHANGE_DYNAMIC_TYPE_EXPR:\n     case ASM_EXPR:\n     case RESX_EXPR:\n     case STATEMENT_LIST:\n@@ -3254,8 +3226,7 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n     }\n   else if (visit_addr\n \t   && (is_gimple_assign (stmt)\n-\t       || gimple_code (stmt) == GIMPLE_COND\n-\t       || gimple_code (stmt) == GIMPLE_CHANGE_DYNAMIC_TYPE))\n+\t       || gimple_code (stmt) == GIMPLE_COND))\n     {\n       for (i = 0; i < gimple_num_ops (stmt); ++i)\n \tif (gimple_op (stmt, i)"}, {"sha": "cee6753d200cc533f30265e6965af87e7d475afc", "filename": "gcc/gimple.def", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -78,17 +78,6 @@ DEFGSCODE(GIMPLE_LABEL, \"gimple_label\", struct gimple_statement_with_ops)\n    They must be CASE_LABEL_EXPR nodes.  */\n DEFGSCODE(GIMPLE_SWITCH, \"gimple_switch\", struct gimple_statement_with_ops)\n \n-/* GIMPLE_CHANGE_DYNAMIC_TYPE indicates a change in the dynamic type\n-   of a memory location.  This has no value and generates no\n-   executable code.  It is only used for type based alias analysis.\n-   This is generated by C++ placement new and it's a direct\n-   translation from CHANGE_DYNAMIC_TYPE_EXPR.  The first operand\n-   (gimple_cdt_new_type) is the new type.  The second operand\n-   (gimple_cdt_location) is the location (pointer) whose type is being\n-   changed.  */\n-DEFGSCODE(GIMPLE_CHANGE_DYNAMIC_TYPE, \"gimple_change_dynamic_type\",\n-\t  struct gimple_statement_with_ops)\n-\n /* IMPORTANT.\n    \n    Do not rearrange the codes between GIMPLE_ASSIGN and GIMPLE_RETURN."}, {"sha": "b16fb545028816e2ee5989293321263021ba99d1", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -4106,69 +4106,6 @@ gimple_nop_p (const_gimple g)\n }\n \n \n-/* Return the new type set by GIMPLE_CHANGE_DYNAMIC_TYPE statement GS.  */\n-\n-static inline tree\n-gimple_cdt_new_type (gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CHANGE_DYNAMIC_TYPE);\n-  return gimple_op (gs, 1);\n-}\n-\n-/* Return a pointer to the new type set by GIMPLE_CHANGE_DYNAMIC_TYPE\n-   statement GS.  */\n-\n-static inline tree *\n-gimple_cdt_new_type_ptr (gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CHANGE_DYNAMIC_TYPE);\n-  return gimple_op_ptr (gs, 1);\n-}\n-\n-/* Set NEW_TYPE to be the type returned by GIMPLE_CHANGE_DYNAMIC_TYPE\n-   statement GS.  */\n-\n-static inline void\n-gimple_cdt_set_new_type (gimple gs, tree new_type)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CHANGE_DYNAMIC_TYPE);\n-  gcc_assert (TREE_CODE_CLASS (TREE_CODE (new_type)) == tcc_type);\n-  gimple_set_op (gs, 1, new_type);\n-}\n-\n-\n-/* Return the location affected by GIMPLE_CHANGE_DYNAMIC_TYPE statement GS.  */\n-\n-static inline tree\n-gimple_cdt_location (gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CHANGE_DYNAMIC_TYPE);\n-  return gimple_op (gs, 0);\n-}\n-\n-\n-/* Return a pointer to the location affected by GIMPLE_CHANGE_DYNAMIC_TYPE\n-   statement GS.  */\n-\n-static inline tree *\n-gimple_cdt_location_ptr (gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CHANGE_DYNAMIC_TYPE);\n-  return gimple_op_ptr (gs, 0);\n-}\n-\n-\n-/* Set PTR to be the location affected by GIMPLE_CHANGE_DYNAMIC_TYPE\n-   statement GS.  */\n-\n-static inline void\n-gimple_cdt_set_location (gimple gs, tree ptr)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CHANGE_DYNAMIC_TYPE);\n-  gimple_set_op (gs, 0, ptr);\n-}\n-\n-\n /* Return the predictor of GIMPLE_PREDICT statement GS.  */\n \n static inline enum br_predictor"}, {"sha": "073fda0005beefe9e289b9f61780ccf1e84c3d43", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -6856,19 +6856,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    break;\n \t  }\n \n-\tcase CHANGE_DYNAMIC_TYPE_EXPR:\n-\t  {\n-\t    gimple cdt;\n-\n-\t    ret = gimplify_expr (&CHANGE_DYNAMIC_TYPE_LOCATION (*expr_p),\n-\t\t\t\t pre_p, post_p, is_gimple_reg, fb_lvalue);\n-\t    cdt = gimple_build_cdt (CHANGE_DYNAMIC_TYPE_NEW_TYPE (*expr_p),\n-\t\t\t\t    CHANGE_DYNAMIC_TYPE_LOCATION (*expr_p));\n-\t    gimplify_seq_add_stmt (pre_p, cdt);\n-\t    ret = GS_ALL_DONE;\n-\t  }\n-\t  break;\n-\n \tcase OBJ_TYPE_REF:\n \t  {\n \t    enum gimplify_status r0, r1;"}, {"sha": "1a4aea9b37ba68bd9a3fe5b8c69ba331f2d86484", "filename": "gcc/omp-low.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -812,7 +812,6 @@ copy_var_decl (tree var, tree name, tree type)\n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (var);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (var);\n   DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (var);\n-  DECL_NO_TBAA_P (copy) = DECL_NO_TBAA_P (var);\n   DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n   DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n   DECL_CONTEXT (copy) = DECL_CONTEXT (var);\n@@ -5010,7 +5009,6 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n \t\t\t\t    false, NULL_TREE, true, GSI_SAME_STMT);\n       stmt = gimple_build_assign (iaddr, iaddr_val);\n       gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n-      DECL_NO_TBAA_P (iaddr) = 1;\n       DECL_POINTER_ALIAS_SET (iaddr) = 0;\n       loadedi = create_tmp_var (itype, NULL);\n       if (gimple_in_ssa_p (cfun))"}, {"sha": "969c6ea4ba705e9ea9566ffb500e2585da420cb0", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -425,8 +425,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t    fputs (\" virtual\", file);\n \t  if (DECL_PRESERVE_P (node))\n \t    fputs (\" preserve\", file);\n-\t  if (DECL_NO_TBAA_P (node))\n-\t    fputs (\" no-tbaa\", file);\n \t  if (DECL_LANG_FLAG_0 (node))\n \t    fputs (\" decl_0\", file);\n \t  if (DECL_LANG_FLAG_1 (node))"}, {"sha": "ed045442dd3e0bd3d892dc8581e7cbe6daac0c8f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1,3 +1,10 @@\n+2009-05-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/38964\n+\t* g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C: XFAIL.\n+\t* gcc.dg/Wstrict-aliasing-converted-assigned.c: Likewise.\n+\t* gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c: Likewise.\n+\n 2009-05-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gcc.dg/dll-6.c: New test."}, {"sha": "8b82874f51de7a039424fce2dda8dcac1717f9e8", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -4,8 +4,8 @@\n \n int foo() {\n   int x;\n-  float& q = reinterpret_cast<float&> (x);  /* { dg-message \"initialized\" } */\n-  q = 1.0; /* { dg-warning \"does break strict-aliasing\" } */\n+  float& q = reinterpret_cast<float&> (x);  /* { dg-message \"initialized\" \"\" { xfail *-*-* } } */\n+  q = 1.0; /* { dg-warning \"does break strict-aliasing\" \"\" { xfail *-*-* } } */\n   return x;\n }\n "}, {"sha": "b77373d56bd1fa067059ee6ba8917d6746e2d2a0", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-converted-assigned.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -9,5 +9,5 @@ int foo()\n   return i;\n }\n \n-/* { dg-message \"does break strict-aliasing\" \"\" { target { *-*-* && lp64 } } 8 } */\n-/* { dg-message \"initialized\" \"\" { target { *-*-* && lp64 } } 8 } */\n+/* { dg-message \"does break strict-aliasing\" \"\" { target { *-*-* && lp64 } xfail *-*-* } 8 } */\n+/* { dg-message \"initialized\" \"\" { target { *-*-* && lp64 } xfail *-*-* } 8 } */"}, {"sha": "b90fb76c28bcb98d38a88c57e72914ea4c85e8fb", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -11,12 +11,12 @@ int foo() {\n   float* r;\n \n   if (flag) {\n-    q = (float*) &x;  /* { dg-message \"initialized\" } */\n+    q = (float*) &x;  /* { dg-message \"initialized\" \"\" { xfail *-*-* } } */\n   } else {\n-    q = (float*) &y;  /* { dg-message \"initialized\" } */\n+    q = (float*) &y;  /* { dg-message \"initialized\" \"\" { xfail *-*-* } } */\n   }\n \n-  *q = 1.0;  /* { dg-warning \"does break strict-aliasing\" } */\n+  *q = 1.0;  /* { dg-warning \"does break strict-aliasing\" \"\" { xfail *-*-* } } */\n \n   return x;\n "}, {"sha": "17cee626cb8e031db60500d5c85988f0bfba5535", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -2045,18 +2045,6 @@ remove_useless_stmts_1 (gimple_stmt_iterator *gsi, struct rus_data *data)\n           }\n           break;\n \n-        case GIMPLE_CHANGE_DYNAMIC_TYPE:\n-\t  /* If we do not optimize remove GIMPLE_CHANGE_DYNAMIC_TYPE as\n-\t     expansion is confused about them and we only remove them\n-\t     during alias computation otherwise.  */\n-\t  if (!optimize)\n-\t    {\n-\t      data->last_was_goto = false;\n-\t      gsi_remove (gsi, false);\n-\t      break;\n-\t    }\n-\t  /* Fallthru.  */\n-\n         default:\n           data->last_was_goto = false;\n           gsi_next (gsi);\n@@ -4038,10 +4026,6 @@ verify_types_in_gimple_stmt (gimple stmt)\n     case GIMPLE_ASM:\n       return false;\n \n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n-      return (!is_gimple_val (gimple_cdt_location (stmt))\n-\t      || !POINTER_TYPE_P (TREE_TYPE (gimple_cdt_location (stmt))));\n-\n     case GIMPLE_PHI:\n       return verify_gimple_phi (stmt);\n "}, {"sha": "583d2c0fd9e6e9686e1287e79dbff83d6881ed85", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1223,7 +1223,17 @@ dr_may_alias_p (const struct data_reference *a, const struct data_reference *b)\n     return false;\n \n   /* Query the alias oracle.  */\n-  if (!refs_may_alias_p (DR_REF (a), DR_REF (b)))\n+  if (!DR_IS_READ (a) && !DR_IS_READ (b))\n+    {\n+      if (!refs_output_dependent_p (DR_REF (a), DR_REF (b)))\n+\treturn false;\n+    }\n+  else if (DR_IS_READ (a) && !DR_IS_READ (b))\n+    {\n+      if (!refs_anti_dependent_p (DR_REF (a), DR_REF (b)))\n+\treturn false;\n+    }\n+  else if (!refs_may_alias_p (DR_REF (a), DR_REF (b)))\n     return false;\n \n   if (!addr_a || !addr_b)"}, {"sha": "1b53288bca34e4785b8426791a08d8b14e5b0814", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -3072,7 +3072,6 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n     case GIMPLE_NOP:\n     case GIMPLE_PHI:\n     case GIMPLE_RETURN:\n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n     case GIMPLE_PREDICT:\n       return 0;\n \n@@ -3429,13 +3428,6 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   /* Declare the return variable for the function.  */\n   retvar = declare_return_variable (id, return_slot, modify_dest, &use_retvar);\n \n-  if (DECL_IS_OPERATOR_NEW (fn))\n-    {\n-      gcc_assert (TREE_CODE (retvar) == VAR_DECL\n-\t\t  && POINTER_TYPE_P (TREE_TYPE (retvar)));\n-      DECL_NO_TBAA_P (retvar) = 1;\n-    }\n-\n   /* Add local vars in this inlined callee to caller.  */\n   t_step = id->src_cfun->local_decls;\n   for (; t_step; t_step = TREE_CHAIN (t_step))\n@@ -4192,7 +4184,6 @@ copy_decl_to_var (tree decl, copy_body_data *id)\n   TREE_READONLY (copy) = TREE_READONLY (decl);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n   DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);\n-  DECL_NO_TBAA_P (copy) = DECL_NO_TBAA_P (decl);\n \n   return copy_decl_for_dup_finish (id, decl, copy);\n }\n@@ -4219,7 +4210,6 @@ copy_result_decl_to_var (tree decl, copy_body_data *id)\n     {\n       TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n       DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);\n-      DECL_NO_TBAA_P (copy) = DECL_NO_TBAA_P (decl);\n     }\n \n   return copy_decl_for_dup_finish (id, decl, copy);"}, {"sha": "af734c118ab72f55117bbba3048be33cb91618b1", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1544,17 +1544,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       is_expr = false;\n       break;\n \n-    case CHANGE_DYNAMIC_TYPE_EXPR:\n-      pp_string (buffer, \"<<<change_dynamic_type (\");\n-      dump_generic_node (buffer, CHANGE_DYNAMIC_TYPE_NEW_TYPE (node), spc + 2,\n-\t\t\t flags, false);\n-      pp_string (buffer, \") \");\n-      dump_generic_node (buffer, CHANGE_DYNAMIC_TYPE_LOCATION (node), spc + 2,\n-\t\t\t flags, false);\n-      pp_string (buffer, \")>>>\");\n-      is_expr = false;\n-      break;\n-\n     case LABEL_EXPR:\n       op0 = TREE_OPERAND (node, 0);\n       /* If this is for break or continue, don't bother printing it.  */"}, {"sha": "ef360ea87d5dc33783ab84a62ecf391d92ceea3c", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -155,10 +155,13 @@ ptr_deref_may_alias_global_p (tree ptr)\n   if (!pi)\n     return true;\n \n+  /* ???  This does not use TBAA to prune globals ptr may not access.  */\n   return pt_solution_includes_global (&pi->pt);\n }\n \n-/* Return true if dereferencing PTR may alias DECL.  */\n+/* Return true if dereferencing PTR may alias DECL.\n+   The caller is responsible for applying TBAA to see if PTR\n+   may access DECL at all.  */\n \n static bool\n ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n@@ -190,7 +193,9 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n   return pt_solution_includes (&pi->pt, decl);\n }\n \n-/* Return true if dereferenced PTR1 and PTR2 may alias.  */\n+/* Return true if dereferenced PTR1 and PTR2 may alias.\n+   The caller is responsible for applying TBAA to see if accesses\n+   through PTR1 and PTR2 may conflict at all.  */\n \n static bool\n ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n@@ -222,6 +227,8 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n   if (!pi1 || !pi2)\n     return true;\n \n+  /* ???  This does not use TBAA to prune decls from the intersection\n+     that not both pointers may access.  */\n   return pt_solutions_intersect (&pi1->pt, &pi2->pt);\n }\n \n@@ -653,13 +660,14 @@ indirect_refs_may_alias_p (tree ref1, tree ptr1,\n /* Return true, if the two memory references REF1 and REF2 may alias.  */\n \n static bool\n-refs_may_alias_p_1 (tree ref1, tree ref2)\n+refs_may_alias_p_1 (tree ref1, tree ref2, bool tbaa_p)\n {\n   tree base1, base2;\n   HOST_WIDE_INT offset1 = 0, offset2 = 0;\n   HOST_WIDE_INT size1 = -1, size2 = -1;\n   HOST_WIDE_INT max_size1 = -1, max_size2 = -1;\n   bool var1_p, var2_p, ind1_p, ind2_p;\n+  alias_set_type set;\n \n   gcc_assert ((SSA_VAR_P (ref1)\n \t       || handled_component_p (ref1)\n@@ -694,7 +702,8 @@ refs_may_alias_p_1 (tree ref1, tree ref2)\n \t\t\t\t  base2, offset2, max_size2);\n \n   /* First defer to TBAA if possible.  */\n-  if (flag_strict_aliasing\n+  if (tbaa_p\n+      && flag_strict_aliasing\n       && !alias_sets_conflict_p (get_alias_set (ref1), get_alias_set (ref2)))\n     return false;\n \n@@ -708,36 +717,54 @@ refs_may_alias_p_1 (tree ref1, tree ref2)\n   /* Dispatch to the pointer-vs-decl or pointer-vs-pointer disambiguators.  */\n   ind1_p = INDIRECT_REF_P (base1);\n   ind2_p = INDIRECT_REF_P (base2);\n+  set = tbaa_p ? -1 : 0;\n   if (var1_p && ind2_p)\n     return indirect_ref_may_alias_decl_p (ref2, TREE_OPERAND (base2, 0),\n-\t\t\t\t\t  offset2, max_size2, -1,\n+\t\t\t\t\t  offset2, max_size2, set,\n \t\t\t\t\t  ref1, base1,\n-\t\t\t\t\t  offset1, max_size1, -1);\n+\t\t\t\t\t  offset1, max_size1, set);\n   else if (ind1_p && var2_p)\n     return indirect_ref_may_alias_decl_p (ref1, TREE_OPERAND (base1, 0),\n-\t\t\t\t\t  offset1, max_size1, -1,\n+\t\t\t\t\t  offset1, max_size1, set,\n \t\t\t\t\t  ref2, base2,\n-\t\t\t\t\t  offset2, max_size2, -1);\n+\t\t\t\t\t  offset2, max_size2, set);\n   else if (ind1_p && ind2_p)\n     return indirect_refs_may_alias_p (ref1, TREE_OPERAND (base1, 0),\n-\t\t\t\t      offset1, max_size1, -1,\n+\t\t\t\t      offset1, max_size1, set,\n \t\t\t\t      ref2, TREE_OPERAND (base2, 0),\n-\t\t\t\t      offset2, max_size2, -1);\n+\t\t\t\t      offset2, max_size2, set);\n \n   gcc_unreachable ();\n }\n \n bool\n refs_may_alias_p (tree ref1, tree ref2)\n {\n-  bool res = refs_may_alias_p_1 (ref1, ref2);\n+  bool res = refs_may_alias_p_1 (ref1, ref2, true);\n   if (res)\n     ++alias_stats.refs_may_alias_p_may_alias;\n   else\n     ++alias_stats.refs_may_alias_p_no_alias;\n   return res;\n }\n \n+/* Returns true if there is a anti-dependence for the STORE that\n+   executes after the LOAD.  */\n+\n+bool\n+refs_anti_dependent_p (tree load, tree store)\n+{\n+  return refs_may_alias_p_1 (load, store, false);\n+}\n+\n+/* Returns true if there is a output dependence for the stores\n+   STORE1 and STORE2.  */\n+\n+bool\n+refs_output_dependent_p (tree store1, tree store2)\n+{\n+  return refs_may_alias_p_1 (store1, store2, false);\n+}\n \n /* If the call CALL may use the memory reference REF return true,\n    otherwise return false.  */"}, {"sha": "a7ffcaa683cbb3db0e59d31dd9ffeb101e1ca055", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -78,6 +78,8 @@ struct GTY(()) pt_solution\n extern enum escape_type is_escape_site (gimple);\n extern bool ptr_deref_may_alias_global_p (tree);\n extern bool refs_may_alias_p (tree, tree);\n+extern bool refs_anti_dependent_p (tree, tree);\n+extern bool refs_output_dependent_p (tree, tree);\n extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p (gimple, tree);\n extern void *walk_non_aliased_vuses (tree, tree,"}, {"sha": "ed221c2f3e08565a0291cc3831ec8a6c05023dba", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -233,20 +233,6 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n       return false;\n     }\n \n-  /* Don't coalesce if the aliasing sets of the types are different.  */\n-  if (POINTER_TYPE_P (TREE_TYPE (root1))\n-      && POINTER_TYPE_P (TREE_TYPE (root2))\n-      && ((get_alias_set (TREE_TYPE (TREE_TYPE (root1)))\n-\t   != get_alias_set (TREE_TYPE (TREE_TYPE (root2))))\n-\t  || (DECL_P (root1) && DECL_P (root2)\n-\t      && DECL_NO_TBAA_P (root1) != DECL_NO_TBAA_P (root2))))\n-    {\n-      if (debug)\n-\tfprintf (debug, \" : 2 different aliasing sets. No coalesce.\\n\");\n-      return false;\n-    }\n-\n-\n   /* Merge the two partitions.  */\n   p3 = partition_union (map->var_partition, p1, p2);\n "}, {"sha": "38f313daa7d71f2147d1f5f991c3d50399fead30", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -295,7 +295,6 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n     case GIMPLE_ASM:\n     case GIMPLE_RESX:\n     case GIMPLE_RETURN:\n-    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n       mark_stmt_necessary (stmt, true);\n       return;\n "}, {"sha": "0f8912421a1ad66bb48ee0c6e4e508de4db6a56c", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1009,9 +1009,6 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n         return;\n       }\n \n-    case CHANGE_DYNAMIC_TYPE_EXPR:\n-      gcc_unreachable ();\n-\n     case FUNCTION_DECL:\n     case LABEL_DECL:\n     case CONST_DECL:"}, {"sha": "aa944364e48cfaf25f52b32ef009115e5e9526fb", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 15, "deletions": 344, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -226,10 +226,6 @@ struct variable_info\n   /* True if this is a heap variable.  */\n   unsigned int is_heap_var:1;\n \n-  /* True if we may not use TBAA to prune references to this\n-     variable.  This is used for C++ placement new.  */\n-  unsigned int no_tbaa_pruning : 1;\n-\n   /* True if this field may contain pointers.  */\n   unsigned int may_have_pointers : 1;\n \n@@ -360,7 +356,6 @@ static varinfo_t\n new_var_info (tree t, unsigned int id, const char *name)\n {\n   varinfo_t ret = (varinfo_t) pool_alloc (variable_info_pool);\n-  tree var;\n \n   ret->id = id;\n   ret->name = name;\n@@ -371,12 +366,6 @@ new_var_info (tree t, unsigned int id, const char *name)\n   ret->is_unknown_size_var = false;\n   ret->is_full_var = false;\n   ret->may_have_pointers = true;\n-  var = t;\n-  if (TREE_CODE (var) == SSA_NAME)\n-    var = SSA_NAME_VAR (var);\n-  ret->no_tbaa_pruning = (DECL_P (var)\n-\t\t\t  && POINTER_TYPE_P (TREE_TYPE (var))\n-\t\t\t  && DECL_NO_TBAA_P (var));\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n   ret->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n   ret->next = NULL;\n@@ -1425,9 +1414,6 @@ unify_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n   merge_graph_nodes (graph, to, from);\n   merge_node_constraints (graph, to, from);\n \n-  if (get_varinfo (from)->no_tbaa_pruning)\n-    get_varinfo (to)->no_tbaa_pruning = true;\n-\n   /* Mark TO as changed if FROM was changed. If TO was already marked\n      as changed, decrease the changed count.  */\n \n@@ -3725,14 +3711,6 @@ find_func_aliases (gimple origt)\n \t    }\n \t}\n     }\n-  else if (gimple_code (t) == GIMPLE_CHANGE_DYNAMIC_TYPE)\n-    {\n-      unsigned int j;\n-\n-      get_constraint_for (gimple_cdt_location (t), &lhsc);\n-      for (j = 0; VEC_iterate (ce_s, lhsc, j, c); ++j)\n-\tget_varinfo (c->var)->no_tbaa_pruning = true;\n-    }\n \n   stmt_escape_type = is_escape_site (t);\n   if (stmt_escape_type == ESCAPE_STORED_IN_GLOBAL)\n@@ -4444,10 +4422,7 @@ dump_solution_for_var (FILE *file, unsigned int var)\n \t{\n \t  fprintf (file, \"%s \", get_varinfo (i)->name);\n \t}\n-      fprintf (file, \"}\");\n-      if (vi->no_tbaa_pruning)\n-\tfprintf (file, \" no-tbaa-pruning\");\n-      fprintf (file, \"\\n\");\n+      fprintf (file, \"}\\n\");\n     }\n }\n \n@@ -4628,19 +4603,13 @@ shared_bitmap_add (bitmap pt_vars)\n }\n \n \n-/* Set bits in INTO corresponding to the variable uids in solution set FROM.\n-   If MEM_ALIAS_SET is not zero, we also use type based alias analysis to\n-   prune the points-to sets with this alias-set.\n-   Returns the number of pruned variables and updates the vars_contains_global\n-   member of *PT .  */\n+/* Set bits in INTO corresponding to the variable uids in solution set FROM.  */\n \n-static unsigned\n-set_uids_in_ptset (bitmap into, bitmap from,\n-\t\t   alias_set_type mem_alias_set, struct pt_solution *pt)\n+static void \n+set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n-  unsigned pruned = 0;\n \n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n@@ -4655,136 +4624,28 @@ set_uids_in_ptset (bitmap into, bitmap from,\n \t  || TREE_CODE (vi->decl) == PARM_DECL\n \t  || TREE_CODE (vi->decl) == RESULT_DECL)\n \t{\n-\t  /* Don't type prune artificial vars or points-to sets\n-\t     for pointers that have not been dereferenced or with\n-\t     type-based pruning disabled.  */\n-\t  if (!vi->is_artificial_var\n-\t      && !vi->no_tbaa_pruning\n-\t      && mem_alias_set != 0)\n-\t    {\n-\t      alias_set_type var_alias_set = get_alias_set (vi->decl);\n-\t      if (mem_alias_set != var_alias_set\n-\t\t  && !alias_set_subset_of (mem_alias_set, var_alias_set))\n-\t\t{\n-\t\t  ++pruned;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n \t  /* Add the decl to the points-to set.  Note that the points-to\n \t     set contains global variables.  */\n \t  bitmap_set_bit (into, DECL_UID (vi->decl));\n \t  if (is_global_var (vi->decl))\n \t    pt->vars_contains_global = true;\n \t}\n     }\n-\n-  return pruned;\n }\n \n \n static bool have_alias_info = false;\n \n-/* Emit a note for the pointer initialization point DEF.  */\n+/* Compute the points-to solution *PT for the variable VI.  */\n \n static void\n-emit_pointer_definition (tree ptr, bitmap visited)\n+find_what_var_points_to (varinfo_t vi, struct pt_solution *pt)\n {\n-  gimple def = SSA_NAME_DEF_STMT (ptr);\n-  if (gimple_code (def) == GIMPLE_PHI)\n-    {\n-      use_operand_p argp;\n-      ssa_op_iter oi;\n-\n-      FOR_EACH_PHI_ARG (argp, def, oi, SSA_OP_USE)\n-\t{\n-\t  tree arg = USE_FROM_PTR (argp);\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      if (bitmap_set_bit (visited, SSA_NAME_VERSION (arg)))\n-\t\temit_pointer_definition (arg, visited);\n-\t    }\n-\t  else\n-\t    inform (0, \"initialized from %qE\", arg);\n-\t}\n-    }\n-  else if (!gimple_nop_p (def))\n-    inform (gimple_location (def), \"initialized from here\");\n-}\n-\n-/* Emit a strict aliasing warning for dereferencing the pointer PTR.  */\n-\n-static void\n-emit_alias_warning (tree ptr)\n-{\n-  gimple use;\n-  imm_use_iterator ui;\n-  bool warned = false;\n-\n-  FOR_EACH_IMM_USE_STMT (use, ui, ptr)\n-    {\n-      tree deref = NULL_TREE;\n-\n-      if (gimple_has_lhs (use))\n-\t{\n-\t  tree lhs = get_base_address (gimple_get_lhs (use));\n-\t  if (lhs\n-\t      && INDIRECT_REF_P (lhs)\n-\t      && TREE_OPERAND (lhs, 0) == ptr)\n-\t    deref = lhs;\n-\t}\n-      if (gimple_assign_single_p (use))\n-\t{\n-\t  tree rhs = get_base_address (gimple_assign_rhs1 (use));\n-\t  if (rhs\n-\t      && INDIRECT_REF_P (rhs)\n-\t      && TREE_OPERAND (rhs, 0) == ptr)\n-\t    deref = rhs;\n-\t}\n-      else if (is_gimple_call (use))\n-\t{\n-\t  unsigned i;\n-\t  for (i = 0; i < gimple_call_num_args (use); ++i)\n-\t    {\n-\t      tree op = get_base_address (gimple_call_arg (use, i));\n-\t      if (op\n-\t\t  && INDIRECT_REF_P (op)\n-\t\t  && TREE_OPERAND (op, 0) == ptr)\n-\t\tderef = op;\n-\t    }\n-\t}\n-      if (deref\n-\t  && !TREE_NO_WARNING (deref))\n-\t{\n-\t  TREE_NO_WARNING (deref) = 1;\n-\t  warned |= warning_at (gimple_location (use), OPT_Wstrict_aliasing,\n-\t\t\t\t\"dereferencing pointer %qD does break \"\n-\t\t\t\t\"strict-aliasing rules\", SSA_NAME_VAR (ptr));\n-\t}\n-    }\n-  if (warned)\n-    {\n-      bitmap visited = BITMAP_ALLOC (NULL);\n-      emit_pointer_definition (ptr, visited);\n-      BITMAP_FREE (visited);\n-    }\n-}\n-\n-/* Compute the points-to solution *PT for the variable VI.\n-   Prunes the points-to set based on TBAA rules if DO_TBAA_PRUNING\n-   is true.  Returns the number of TBAA pruned variables from the\n-   points-to set.  */\n-\n-static unsigned int\n-find_what_var_points_to (varinfo_t vi, struct pt_solution *pt,\n-\t\t\t bool do_tbaa_pruning)\n-{\n-  unsigned int i, pruned;\n+  unsigned int i;\n   bitmap_iterator bi;\n   bitmap finished_solution;\n   bitmap result;\n   tree ptr = vi->decl;\n-  alias_set_type mem_alias_set;\n \n   memset (pt, 0, sizeof (struct pt_solution));\n \n@@ -4821,7 +4682,7 @@ find_what_var_points_to (varinfo_t vi, struct pt_solution *pt,\n   /* Instead of doing extra work, simply do not create\n      elaborate points-to information for pt_anything pointers.  */\n   if (pt->anything)\n-    return 0;\n+    return;\n \n   /* Share the final set of variables when possible.  */\n   finished_solution = BITMAP_GGC_ALLOC ();\n@@ -4830,15 +4691,7 @@ find_what_var_points_to (varinfo_t vi, struct pt_solution *pt,\n   if (TREE_CODE (ptr) == SSA_NAME)\n     ptr = SSA_NAME_VAR (ptr);\n \n-  /* If the pointer decl is marked that no TBAA is to be applied,\n-     do not do tbaa pruning.  */\n-  if (!do_tbaa_pruning\n-      || DECL_NO_TBAA_P (ptr))\n-    mem_alias_set = 0;\n-  else\n-    mem_alias_set = get_deref_alias_set (ptr);\n-  pruned = set_uids_in_ptset (finished_solution, vi->solution,\n-\t\t\t      mem_alias_set, pt);\n+  set_uids_in_ptset (finished_solution, vi->solution, pt);\n   result = shared_bitmap_lookup (finished_solution);\n   if (!result)\n     {\n@@ -4850,18 +4703,14 @@ find_what_var_points_to (varinfo_t vi, struct pt_solution *pt,\n       pt->vars = result;\n       bitmap_clear (finished_solution);\n     }\n-\n-  return pruned;\n }\n \n-/* Given a pointer variable P, fill in its points-to set.  Apply\n-   type-based pruning if IS_DEREFERENCED is true.  */\n+/* Given a pointer variable P, fill in its points-to set.  */\n \n static void\n-find_what_p_points_to (tree p, bool is_dereferenced)\n+find_what_p_points_to (tree p)\n {\n   struct ptr_info_def *pi;\n-  unsigned int pruned;\n   tree lookup_p = p;\n   varinfo_t vi;\n \n@@ -4877,23 +4726,7 @@ find_what_p_points_to (tree p, bool is_dereferenced)\n     return;\n \n   pi = get_ptr_info (p);\n-  pruned = find_what_var_points_to (vi, &pi->pt, is_dereferenced);\n-\n-  if (!(pi->pt.anything || pi->pt.nonlocal || pi->pt.escaped)\n-      && bitmap_empty_p (pi->pt.vars)\n-      && pruned > 0\n-      && is_dereferenced\n-      && warn_strict_aliasing > 0\n-      && !SSA_NAME_IS_DEFAULT_DEF (p))\n-    {\n-      if (dump_file && dump_flags & TDF_DETAILS)\n-\t{\n-\t  fprintf (dump_file, \"alias warning for \");\n-\t  print_generic_expr (dump_file, p, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      emit_alias_warning (p);\n-    }\n+  find_what_var_points_to (vi, &pi->pt);\n }\n \n \n@@ -5372,139 +5205,6 @@ remove_preds_and_fake_succs (constraint_graph_t graph)\n   bitmap_obstack_release (&predbitmap_obstack);\n }\n \n-/* Compute the set of variables we can't TBAA prune.  */\n-\n-static void\n-compute_tbaa_pruning (void)\n-{\n-  unsigned int size = VEC_length (varinfo_t, varmap);\n-  unsigned int i;\n-  bool any;\n-\n-  changed_count = 0;\n-  changed = sbitmap_alloc (size);\n-  sbitmap_zero (changed);\n-\n-  /* Mark all initial no_tbaa_pruning nodes as changed.  */\n-  any = false;\n-  for (i = 0; i < size; ++i)\n-    {\n-      varinfo_t ivi = get_varinfo (i);\n-\n-      if (find (i) == i && ivi->no_tbaa_pruning)\n-\t{\n-\t  any = true;\n-\t  if ((graph->succs[i] && !bitmap_empty_p (graph->succs[i]))\n-\t      || VEC_length (constraint_t, graph->complex[i]) > 0)\n-\t    {\n-\t      SET_BIT (changed, i);\n-\t      ++changed_count;\n-\t    }\n-\t}\n-    }\n-\n-  while (changed_count > 0)\n-    {\n-      struct topo_info *ti = init_topo_info ();\n-      ++stats.iterations;\n-\n-      compute_topo_order (graph, ti);\n-\n-      while (VEC_length (unsigned, ti->topo_order) != 0)\n-\t{\n-\t  bitmap_iterator bi;\n-\n-\t  i = VEC_pop (unsigned, ti->topo_order);\n-\n-\t  /* If this variable is not a representative, skip it.  */\n-\t  if (find (i) != i)\n-\t    continue;\n-\n-\t  /* If the node has changed, we need to process the complex\n-\t     constraints and outgoing edges again.  */\n-\t  if (TEST_BIT (changed, i))\n-\t    {\n-\t      unsigned int j;\n-\t      constraint_t c;\n-\t      VEC(constraint_t,heap) *complex = graph->complex[i];\n-\n-\t      RESET_BIT (changed, i);\n-\t      --changed_count;\n-\n-\t      /* Process the complex copy constraints.  */\n-\t      for (j = 0; VEC_iterate (constraint_t, complex, j, c); ++j)\n-\t\t{\n-\t\t  if (c->lhs.type == SCALAR && c->rhs.type == SCALAR)\n-\t\t    {\n-\t\t      varinfo_t lhsvi = get_varinfo (find (c->lhs.var));\n-\n-\t\t      if (!lhsvi->no_tbaa_pruning)\n-\t\t\t{\n-\t\t\t  lhsvi->no_tbaa_pruning = true;\n-\t\t\t  if (!TEST_BIT (changed, lhsvi->id))\n-\t\t\t    {\n-\t\t\t      SET_BIT (changed, lhsvi->id);\n-\t\t\t      ++changed_count;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\n-\t      /* Propagate to all successors.  */\n-\t      EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[i], 0, j, bi)\n-\t\t{\n-\t\t  unsigned int to = find (j);\n-\t\t  varinfo_t tovi = get_varinfo (to);\n-\n-\t\t  /* Don't propagate to ourselves.  */\n-\t\t  if (to == i)\n-\t\t    continue;\n-\n-\t\t  if (!tovi->no_tbaa_pruning)\n-\t\t    {\n-\t\t      tovi->no_tbaa_pruning = true;\n-\t\t      if (!TEST_BIT (changed, to))\n-\t\t\t{\n-\t\t\t  SET_BIT (changed, to);\n-\t\t\t  ++changed_count;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      free_topo_info (ti);\n-    }\n-\n-  sbitmap_free (changed);\n-\n-  if (any)\n-    {\n-      for (i = 0; i < size; ++i)\n-\t{\n-\t  varinfo_t ivi = get_varinfo (i);\n-\t  varinfo_t ivip = get_varinfo (find (i));\n-\n-\t  if (ivip->no_tbaa_pruning)\n-\t    {\n-\t      tree var = ivi->decl;\n-\n-\t      if (TREE_CODE (var) == SSA_NAME)\n-\t\tvar = SSA_NAME_VAR (var);\n-\n-\t      if (POINTER_TYPE_P (TREE_TYPE (var)))\n-\t\t{\n-\t\t  DECL_NO_TBAA_P (var) = 1;\n-\n-\t\t  /* Tell the RTL layer that this pointer can alias\n-\t\t     anything.  */\n-\t\t  DECL_POINTER_ALIAS_SET (var) = 0;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Initialize the heapvar for statement mapping.  */\n \n static void\n@@ -5534,7 +5234,6 @@ compute_points_to_sets (void)\n   struct scc_info *si;\n   basic_block bb;\n   unsigned i;\n-  sbitmap dereferenced_ptrs;\n \n   timevar_push (TV_TREE_PTA);\n \n@@ -5543,11 +5242,6 @@ compute_points_to_sets (void)\n \n   intra_create_variable_infos ();\n \n-  /* A bitmap of SSA_NAME pointers that are dereferenced.  This is\n-     used to track which points-to sets may be TBAA pruned.  */\n-  dereferenced_ptrs = sbitmap_alloc (num_ssa_names);\n-  sbitmap_zero (dereferenced_ptrs);\n-\n   /* Now walk all statements and derive aliases.  */\n   FOR_EACH_BB (bb)\n     {\n@@ -5564,31 +5258,11 @@ compute_points_to_sets (void)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  use_operand_p use_p;\n-\t  ssa_op_iter iter;\n-\n-\t  /* Mark dereferenced pointers.  This is used by TBAA pruning\n-\t     of the points-to sets and the alias warning machinery.  */\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\t    {\n-\t      unsigned num_uses, num_loads, num_stores;\n-\t      tree op = USE_FROM_PTR (use_p);\n-\n-\t      if (!POINTER_TYPE_P (TREE_TYPE (op)))\n-\t\tcontinue;\n-\n-\t      /* Determine whether OP is a dereferenced pointer.  */\n-\t      count_uses_and_derefs (op, stmt,\n-\t\t\t\t     &num_uses, &num_loads, &num_stores);\n-\t      if (num_loads + num_stores > 0)\n-\t\tSET_BIT (dereferenced_ptrs, SSA_NAME_VERSION (op));\n-\t    }\n \n \t  find_func_aliases (stmt);\n \t}\n     }\n \n-\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n@@ -5642,15 +5316,13 @@ compute_points_to_sets (void)\n \n   solve_graph (graph);\n \n-  compute_tbaa_pruning ();\n-\n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n \n   /* Compute the points-to sets for ESCAPED and CALLUSED used for\n      call-clobber analysis.  */\n-  find_what_var_points_to (var_escaped, &cfun->gimple_df->escaped, false);\n-  find_what_var_points_to (var_callused, &cfun->gimple_df->callused, false);\n+  find_what_var_points_to (var_escaped, &cfun->gimple_df->escaped);\n+  find_what_var_points_to (var_callused, &cfun->gimple_df->callused);\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies\n@@ -5663,9 +5335,8 @@ compute_points_to_sets (void)\n       tree ptr = ssa_name (i);\n       if (ptr\n \t  && POINTER_TYPE_P (TREE_TYPE (ptr)))\n-\tfind_what_p_points_to (ptr, TEST_BIT (dereferenced_ptrs, i));\n+\tfind_what_p_points_to (ptr);\n     }\n-  sbitmap_free (dereferenced_ptrs);\n \n   timevar_pop (TV_TREE_PTA);\n "}, {"sha": "2231b4489506817a04b497e7877cb0e1f4c77970", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -8961,10 +8961,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tWALK_SUBTREE_TAIL (TREE_OPERAND (*tp, len));\n       }\n \n-    case CHANGE_DYNAMIC_TYPE_EXPR:\n-      WALK_SUBTREE (CHANGE_DYNAMIC_TYPE_NEW_TYPE (*tp));\n-      WALK_SUBTREE_TAIL (CHANGE_DYNAMIC_TYPE_LOCATION (*tp));\n-\n     case DECL_EXPR:\n       /* If this is a TYPE_DECL, walk into the fields of the type that it's\n \t defining.  We only want to walk into these fields of a type in this"}, {"sha": "b4828ad9478227951f20f31bdcfd42e338c251bb", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -913,15 +913,6 @@ DEFTREECODE (CATCH_EXPR, \"catch_expr\", tcc_statement, 2)\n    expanding.  */\n DEFTREECODE (EH_FILTER_EXPR, \"eh_filter_expr\", tcc_statement, 2)\n \n-/* Indicates a change in the dynamic type of a memory location.  This\n-   has no value and generates no executable code.  It is only used for\n-   type based alias analysis.  This is generated by C++ placement new.\n-   CHANGE_DYNAMIC_TYPE_NEW_TYPE, the first operand, is the new type.\n-   CHANGE_DYNAMIC_TYPE_LOCATION, the second operand, is the location\n-   whose type is being changed.  */\n-DEFTREECODE (CHANGE_DYNAMIC_TYPE_EXPR, \"change_dynamic_type_expr\",\n-\t     tcc_statement, 2)\n-\n /* Node used for describing a property that is known at compile\n    time.  */\n DEFTREECODE (SCEV_KNOWN, \"scev_known\", tcc_expression, 0)"}, {"sha": "0adf75d953032e8cbb8d8a21dbe007d90544b29d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d7a65ea616c964b6797710e6bad610598d55df6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4d7a65ea616c964b6797710e6bad610598d55df6", "patch": "@@ -1648,12 +1648,6 @@ extern void protected_set_expr_location (tree, location_t);\n #define EH_FILTER_MUST_NOT_THROW(NODE) \\\n   (EH_FILTER_EXPR_CHECK (NODE)->base.static_flag)\n \n-/* CHANGE_DYNAMIC_TYPE_EXPR accessors.  */\n-#define CHANGE_DYNAMIC_TYPE_NEW_TYPE(NODE) \\\n-  TREE_OPERAND (CHANGE_DYNAMIC_TYPE_EXPR_CHECK (NODE), 0)\n-#define CHANGE_DYNAMIC_TYPE_LOCATION(NODE) \\\n-  TREE_OPERAND (CHANGE_DYNAMIC_TYPE_EXPR_CHECK (NODE), 1)\n-\n /* OBJ_TYPE_REF accessors.  */\n #define OBJ_TYPE_REF_EXPR(NODE)\t  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 0)\n #define OBJ_TYPE_REF_OBJECT(NODE) TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 1)\n@@ -2605,11 +2599,6 @@ struct GTY(()) tree_decl_minimal {\n #define DECL_GIMPLE_REG_P(DECL) \\\n   DECL_COMMON_CHECK (DECL)->decl_common.gimple_reg_flag\n \n-/* For a DECL with pointer type, this is set if Type Based Alias\n-   Analysis should not be applied to this DECL.  */\n-#define DECL_NO_TBAA_P(DECL) \\\n-  DECL_COMMON_CHECK (DECL)->decl_common.no_tbaa_flag\n-\n struct GTY(()) tree_decl_common {\n   struct tree_decl_minimal common;\n   tree size;\n@@ -2649,12 +2638,10 @@ struct GTY(()) tree_decl_common {\n   /* Logically, these two would go in a theoretical base shared by var and\n      parm decl. */\n   unsigned gimple_reg_flag : 1;\n-  /* In a DECL with pointer type, set if no TBAA should be done.  */\n-  unsigned no_tbaa_flag : 1;\n   /* In VAR_DECL, PARM_DECL and RESULT_DECL, this is DECL_BY_REFERENCE.  */\n   unsigned decl_by_reference_flag : 1;\n   /* Padding so that 'off_align' can be on a 32-bit boundary.  */\n-  unsigned decl_common_unused : 1;\n+  unsigned decl_common_unused : 2;\n \n   /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */\n   unsigned int off_align : 8;"}]}