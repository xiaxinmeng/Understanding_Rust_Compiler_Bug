{"sha": "09aad82b44b0e51d3561f4e7b411f21b881f46c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlhYWQ4MmI0NGIwZTUxZDM1NjFmNGU3YjQxMWYyMWI4ODFmNDZjMw==", "commit": {"author": {"name": "Trevor Smigiel", "email": "Trevor_Smigiel@playstation.sony.com", "date": "2006-12-01T22:43:18Z"}, "committer": {"name": "Trevor Smigiel", "email": "tsmigiel@gcc.gnu.org", "date": "2006-12-01T22:43:18Z"}, "message": "predicates.md (spu_mov_operand): Add.\n\n        * config/spu/predicates.md (spu_mov_operand): Add.\n        * config/spu/spu.c (spu_expand_extv): Remove unused code.\n        (print_operand_address, print_operand): Handle addresses containing AND.\n        (spu_split_load, spu_split_store): Use updated movti pattern.\n        * config/spu/spu.md: (_mov<mode>, _movdi, _movti): Handle loads and\n        stores in mov patterns for correct operation of reload.\n        (lq, lq_<mode>, stq, stq_<mode>): Remove.\n\nFrom-SVN: r119421", "tree": {"sha": "2ce535230fc537949bcf9a362a37a8461f8fd595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ce535230fc537949bcf9a362a37a8461f8fd595"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09aad82b44b0e51d3561f4e7b411f21b881f46c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09aad82b44b0e51d3561f4e7b411f21b881f46c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09aad82b44b0e51d3561f4e7b411f21b881f46c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09aad82b44b0e51d3561f4e7b411f21b881f46c3/comments", "author": null, "committer": null, "parents": [{"sha": "01c15146e42cb102382bb126dd96cc143c56a575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c15146e42cb102382bb126dd96cc143c56a575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01c15146e42cb102382bb126dd96cc143c56a575"}], "stats": {"total": 148, "additions": 52, "deletions": 96}, "files": [{"sha": "f09a8232772dee550c9a449d9c59aeaec21e6cde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09aad82b44b0e51d3561f4e7b411f21b881f46c3", "patch": "@@ -1,3 +1,13 @@\n+2006-12-01  Trevor Smigiel  <trevor_smigiel@playstation.sony.com>\n+\n+\t* config/spu/predicates.md (spu_mov_operand): Add.\n+\t* config/spu/spu.c (spu_expand_extv): Remove unused code.\n+\t(print_operand_address, print_operand): Handle addresses containing AND.\n+\t(spu_split_load, spu_split_store): Use updated movti pattern.\n+\t* config/spu/spu.md: (_mov<mode>, _movdi, _movti): Handle loads and\n+\tstores in mov patterns for correct operation of reload.\n+\t(lq, lq_<mode>, stq, stq_<mode>): Remove.\n+\n 2006-12-01  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/30021"}, {"sha": "9d343e6b48da77c02b4ee4410346b794b0269a4e", "filename": "gcc/config/spu/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2Fconfig%2Fspu%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2Fconfig%2Fspu%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fpredicates.md?ref=09aad82b44b0e51d3561f4e7b411f21b881f46c3", "patch": "@@ -35,6 +35,10 @@\n   (and (match_operand 0 \"memory_operand\")\n        (match_test \"reload_in_progress || reload_completed || aligned_mem_p (op)\")))\n \n+(define_predicate \"spu_mov_operand\"\n+  (ior (match_operand 0 \"spu_mem_operand\")\n+       (match_operand 0 \"spu_nonmem_operand\")))\n+\n (define_predicate \"call_operand\"\n   (and (match_code \"mem\")\n        (match_test \"(!TARGET_LARGE_MEM && satisfies_constraint_S (op))"}, {"sha": "e62390894cab932a4bd391676cab81b7f214844d", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 17, "deletions": 50, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=09aad82b44b0e51d3561f4e7b411f21b881f46c3", "patch": "@@ -366,52 +366,6 @@ spu_expand_extv (rtx ops[], int unsignedp)\n   dst_mode = GET_MODE (dst);\n   dst_size = GET_MODE_BITSIZE (GET_MODE (dst));\n \n-  if (GET_CODE (ops[1]) == MEM)\n-    {\n-      if (start + width > MEM_ALIGN (ops[1]))\n-\t{\n-\t  rtx addr = gen_reg_rtx (SImode);\n-\t  rtx shl = gen_reg_rtx (SImode);\n-\t  rtx shr = gen_reg_rtx (SImode);\n-\t  rtx w0 = gen_reg_rtx (TImode);\n-\t  rtx w1 = gen_reg_rtx (TImode);\n-\t  rtx a0, a1;\n-\t  src = gen_reg_rtx (TImode);\n-\t  emit_move_insn (addr, copy_rtx (XEXP (ops[1], 0)));\n-\t  a0 = memory_address (TImode, addr);\n-\t  a1 = memory_address (TImode, plus_constant (addr, 16));\n-\t  emit_insn (gen_lq (w0, a0));\n-\t  emit_insn (gen_lq (w1, a1));\n-\t  emit_insn (gen_andsi3 (shl, addr, GEN_INT (15)));\n-\t  emit_insn (gen_iorsi3 (shr, addr, GEN_INT (16)));\n-\t  emit_insn (gen_shlqby_ti (w0, w0, shl));\n-\t  emit_insn (gen_rotqmby_ti (w1, w1, shr));\n-\t  emit_insn (gen_iorti3 (src, w0, w1));\n-\t}\n-      else\n-\t{\n-\t  rtx addr = gen_reg_rtx (SImode);\n-\t  rtx a0;\n-\t  emit_move_insn (addr, copy_rtx (XEXP (ops[1], 0)));\n-\t  a0 = memory_address (TImode, addr);\n-\t  src = gen_reg_rtx (TImode);\n-\t  emit_insn (gen_lq (src, a0));\n-\t  if (MEM_ALIGN (ops[1]) < 128)\n-\t    {\n-\t      rtx t = src;\n-\t      src = gen_reg_rtx (TImode);\n-\t      emit_insn (gen_rotqby_ti (src, t, addr));\n-\t    }\n-\t}\n-      /* Shifts in SImode are faster, use them if we can. */\n-      if (start + width < 32)\n-\t{\n-\t  rtx t = src;\n-\t  src = gen_reg_rtx (SImode);\n-\t  emit_insn (gen_spu_convert (src, t));\n-\t}\n-    }\n-\n   src = adjust_operand (src, &start);\n   src_mode = GET_MODE (src);\n   src_size = GET_MODE_BITSIZE (GET_MODE (src));\n@@ -970,6 +924,11 @@ print_operand_address (FILE * file, register rtx addr)\n   rtx reg;\n   rtx offset;\n \n+  if (GET_CODE (addr) == AND\n+      && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+      && INTVAL (XEXP (addr, 1)) == -16)\n+    addr = XEXP (addr, 0);\n+\n   switch (GET_CODE (addr))\n     {\n     case REG:\n@@ -1254,6 +1213,11 @@ print_operand (FILE * file, rtx x, int code)\n \t  x = XEXP (x, 0);\n \t  xcode = GET_CODE (x);\n \t}\n+      if (xcode == AND)\n+\t{\n+\t  x = XEXP (x, 0);\n+\t  xcode = GET_CODE (x);\n+\t}\n       if (xcode == REG)\n \tfprintf (file, \"d\");\n       else if (xcode == CONST_INT)\n@@ -3300,7 +3264,7 @@ spu_split_load (rtx * ops)\n   addr = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));\n   mem = change_address (ops[1], TImode, addr);\n \n-  emit_insn (gen_lq_ti (load, mem));\n+  emit_insn (gen_movti (load, mem));\n \n   if (rot)\n     emit_insn (gen_rotqby_ti (load, load, rot));\n@@ -3385,6 +3349,8 @@ spu_split_store (rtx * ops)\n \t}\n     }\n \n+  addr = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));\n+\n   scalar = store_with_one_insn_p (ops[0]);\n   if (!scalar)\n     {\n@@ -3393,7 +3359,9 @@ spu_split_store (rtx * ops)\n          possible, and copying the flags will prevent that in certain\n          cases, e.g. consider the volatile flag. */\n \n-      emit_insn (gen_lq (reg, copy_rtx (addr)));\n+      rtx lmem = change_address (ops[0], TImode, copy_rtx (addr));\n+      set_mem_alias_set (lmem, 0);\n+      emit_insn (gen_movti (reg, lmem));\n \n       if (!p0 || reg_align (p0) >= 128)\n \tp0 = stack_pointer_rtx;\n@@ -3428,13 +3396,12 @@ spu_split_store (rtx * ops)\n     emit_insn (gen_shlqby_ti\n \t       (reg, reg, GEN_INT (4 - GET_MODE_SIZE (mode))));\n \n-  addr = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));\n   smem = change_address (ops[0], TImode, addr);\n   /* We can't use the previous alias set because the memory has changed\n      size and can potentially overlap objects of other types.  */\n   set_mem_alias_set (smem, 0);\n \n-  emit_insn (gen_stq_ti (smem, reg));\n+  emit_insn (gen_movti (smem, reg));\n }\n \n /* Return TRUE if X is MEM which is a struct member reference"}, {"sha": "ef47f81e6f66754eac0d048b320489abe30ed66b", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 21, "deletions": 46, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09aad82b44b0e51d3561f4e7b411f21b881f46c3/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=09aad82b44b0e51d3561f4e7b411f21b881f46c3", "patch": "@@ -262,14 +262,16 @@\n ;; move internal\n \n (define_insn \"_mov<mode>\"\n-  [(set (match_operand:MOV 0 \"spu_reg_operand\" \"=r,r,r\")\n-\t(match_operand:MOV 1 \"spu_nonmem_operand\" \"r,A,f\"))]\n-  \"\"\n+  [(set (match_operand:MOV 0 \"spu_nonimm_operand\" \"=r,r,r,r,m\")\n+\t(match_operand:MOV 1 \"spu_mov_operand\" \"r,A,f,m,r\"))]\n+  \"spu_valid_move (operands)\"\n   \"@\n    ori\\t%0,%1,0\n    il%s1\\t%0,%S1\n-   fsmbi\\t%0,%F1\"\n-  [(set_attr \"type\" \"fx2,fx2,shuf\")])\n+   fsmbi\\t%0,%F1\n+   lq%p1\\t%0,%1\n+   stq%p0\\t%1,%0\"\n+  [(set_attr \"type\" \"fx2,fx2,shuf,load,store\")])\n \n (define_insn \"high\"\n   [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n@@ -285,24 +287,28 @@\n   \"iohl\\t%0,%2@l\")\n \n (define_insn \"_movdi\"\n-  [(set (match_operand:DI 0 \"spu_reg_operand\" \"=r,r,r\")\n-\t(match_operand:DI 1 \"spu_nonmem_operand\" \"r,a,f\"))]\n-  \"\"\n+  [(set (match_operand:DI 0 \"spu_nonimm_operand\" \"=r,r,r,r,m\")\n+\t(match_operand:DI 1 \"spu_mov_operand\" \"r,a,f,m,r\"))]\n+  \"spu_valid_move (operands)\"\n   \"@\n    ori\\t%0,%1,0\n    il%d1\\t%0,%D1\n-   fsmbi\\t%0,%G1\"\n-  [(set_attr \"type\" \"fx2,fx2,shuf\")])\n+   fsmbi\\t%0,%G1\n+   lq%p1\\t%0,%1\n+   stq%p0\\t%1,%0\"\n+  [(set_attr \"type\" \"fx2,fx2,shuf,load,store\")])\n \n (define_insn \"_movti\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"=r,r,r\")\n-\t(match_operand:TI 1 \"spu_nonmem_operand\" \"r,U,f\"))]\n-  \"\"\n+  [(set (match_operand:TI 0 \"spu_nonimm_operand\" \"=r,r,r,r,m\")\n+\t(match_operand:TI 1 \"spu_mov_operand\" \"r,U,f,m,r\"))]\n+  \"spu_valid_move (operands)\"\n   \"@\n    ori\\t%0,%1,0\n    il%t1\\t%0,%T1\n-   fsmbi\\t%0,%H1\"\n-  [(set_attr \"type\" \"fx2,fx2,shuf\")])\n+   fsmbi\\t%0,%H1\n+   lq%p1\\t%0,%1\n+   stq%p0\\t%1,%0\"\n+  [(set_attr \"type\" \"fx2,fx2,shuf,load,store\")])\n \n (define_insn_and_split \"load\"\n   [(set (match_operand 0 \"spu_reg_operand\" \"=r\")\n@@ -316,22 +322,6 @@\n \t(match_dup 1))]\n   { spu_split_load(operands); DONE; })\n \n-(define_insn \"lq\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"=r\")\n-\t(mem:TI (and:SI (match_operand:SI 1 \"address_operand\" \"p\")\n-\t\t\t(const_int -16))))]\n-  \"\"\n-  \"lq%p1\\t%0,%a1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"lq_<mode>\"\n-  [(set (match_operand:ALL 0 \"spu_reg_operand\" \"=r\")\n-\t(match_operand:ALL 1 \"spu_mem_operand\" \"m\"))]\n-  \"spu_valid_move (operands)\"\n-  \"lq%p1\\t%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-\n (define_insn_and_split \"store\"\n   [(set (match_operand 0 \"memory_operand\" \"=m\")\n \t(match_operand 1 \"spu_reg_operand\" \"r\"))\n@@ -344,21 +334,6 @@\n \t(match_dup 1))]\n   { spu_split_store(operands); DONE; })\n \n-(define_insn \"stq\"\n-  [(set (mem:TI (and:SI (match_operand:SI 0 \"address_operand\" \"p\")\n-\t\t\t(const_int -16)))\n-\t(match_operand:TI 1 \"spu_reg_operand\" \"r\"))]\n-  \"\"\n-  \"stq%p0\\t%1,%a0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"stq_<mode>\"\n-  [(set (match_operand:ALL 0 \"spu_mem_operand\" \"=m\")\n-\t(match_operand:ALL 1 \"spu_reg_operand\" \"r\"))]\n-  \"spu_valid_move (operands)\"\n-  \"stq%p0\\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n ;; Operand 3 is the number of bytes. 1:b 2:h 4:w 8:d\n (define_insn \"cpat\"\n   [(set (match_operand:TI 0 \"spu_reg_operand\" \"=r,r\")"}]}