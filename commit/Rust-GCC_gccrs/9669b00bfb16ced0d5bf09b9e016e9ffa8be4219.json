{"sha": "9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY2OWIwMGJmYjE2Y2VkMGQ1YmYwOWI5ZTAxNmU5ZmZhOGJlNDIxOQ==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2016-11-22T16:57:29Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2016-11-22T16:57:29Z"}, "message": "OpenMP offloading to NVPTX: middle-end changes\n\n\t* internal-fn.c (expand_GOMP_SIMT_LANE): New.\n\t(expand_GOMP_SIMT_VF): New.\n\t(expand_GOMP_SIMT_LAST_LANE): New.\n\t(expand_GOMP_SIMT_ORDERED_PRED): New.\n\t(expand_GOMP_SIMT_VOTE_ANY): New.\n\t(expand_GOMP_SIMT_XCHG_BFLY): New.\n\t(expand_GOMP_SIMT_XCHG_IDX): New.\n\t* internal-fn.def (GOMP_SIMT_LANE): New.\n\t(GOMP_SIMT_VF): New.\n\t(GOMP_SIMT_LAST_LANE): New.\n\t(GOMP_SIMT_ORDERED_PRED): New.\n\t(GOMP_SIMT_VOTE_ANY): New.\n\t(GOMP_SIMT_XCHG_BFLY): New.\n\t(GOMP_SIMT_XCHG_IDX): New.\n\t* omp-low.c (omp_maybe_offloaded_ctx): New, outlined from...\n\t(create_omp_child_function): ...here.  Set \"omp target entrypoint\"\n\tor \"omp declare target\" attribute based on is_gimple_omp_offloaded.\n\t(omp_max_simt_vf): New.  Use it...\n\t(omp_max_vf): ...here.\n\t(lower_rec_input_clauses): Add reduction lowering for SIMT execution.\n\t(lower_lastprivate_clauses): Likewise, for \"lastprivate\" lowering.\n\t(lower_omp_ordered): Likewise, for \"ordered\" lowering.\n\t(expand_omp_simd): Add SIMT transforms.\n\t(pass_data_lower_omp): Add PROP_gimple_lomp_dev.\n\t(execute_omp_device_lower): New.\n\t(pass_data_omp_device_lower): New.\n\t(pass_omp_device_lower): New pass.\n\t(make_pass_omp_device_lower): New.\n\t* passes.def (pass_omp_device_lower): Position new pass.\n\t* tree-pass.h (PROP_gimple_lomp_dev): Define.\n\t(make_pass_omp_device_lower): Declare.\n\nFrom-SVN: r242710", "tree": {"sha": "36fcb281bf349333f6b5a61f5076bda2cef9590a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36fcb281bf349333f6b5a61f5076bda2cef9590a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9435cd52b3180e6171c0f738fe7e8ffd79dd9b28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9435cd52b3180e6171c0f738fe7e8ffd79dd9b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9435cd52b3180e6171c0f738fe7e8ffd79dd9b28"}], "stats": {"total": 618, "additions": 554, "deletions": 64}, "files": [{"sha": "8ee2622009068e08d57f35ea0dcf23c586d8517e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "patch": "@@ -1,3 +1,37 @@\n+2016-11-22  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* internal-fn.c (expand_GOMP_SIMT_LANE): New.\n+\t(expand_GOMP_SIMT_VF): New.\n+\t(expand_GOMP_SIMT_LAST_LANE): New.\n+\t(expand_GOMP_SIMT_ORDERED_PRED): New.\n+\t(expand_GOMP_SIMT_VOTE_ANY): New.\n+\t(expand_GOMP_SIMT_XCHG_BFLY): New.\n+\t(expand_GOMP_SIMT_XCHG_IDX): New.\n+\t* internal-fn.def (GOMP_SIMT_LANE): New.\n+\t(GOMP_SIMT_VF): New.\n+\t(GOMP_SIMT_LAST_LANE): New.\n+\t(GOMP_SIMT_ORDERED_PRED): New.\n+\t(GOMP_SIMT_VOTE_ANY): New.\n+\t(GOMP_SIMT_XCHG_BFLY): New.\n+\t(GOMP_SIMT_XCHG_IDX): New.\n+\t* omp-low.c (omp_maybe_offloaded_ctx): New, outlined from...\n+\t(create_omp_child_function): ...here.  Set \"omp target entrypoint\"\n+\tor \"omp declare target\" attribute based on is_gimple_omp_offloaded.\n+\t(omp_max_simt_vf): New.  Use it...\n+\t(omp_max_vf): ...here.\n+\t(lower_rec_input_clauses): Add reduction lowering for SIMT execution.\n+\t(lower_lastprivate_clauses): Likewise, for \"lastprivate\" lowering.\n+\t(lower_omp_ordered): Likewise, for \"ordered\" lowering.\n+\t(expand_omp_simd): Add SIMT transforms.\n+\t(pass_data_lower_omp): Add PROP_gimple_lomp_dev.\n+\t(execute_omp_device_lower): New.\n+\t(pass_data_omp_device_lower): New.\n+\t(pass_omp_device_lower): New pass.\n+\t(make_pass_omp_device_lower): New.\n+\t* passes.def (pass_omp_device_lower): Position new pass.\n+\t* tree-pass.h (PROP_gimple_lomp_dev): Define.\n+\t(make_pass_omp_device_lower): Declare.\n+\n 2016-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/78451"}, {"sha": "6cd8522d7c4040c9a28f06d7b711e5d322d12907", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "patch": "@@ -158,6 +158,132 @@ expand_ANNOTATE (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* Lane index on SIMT targets: thread index in the warp on NVPTX.  On targets\n+   without SIMT execution this should be expanded in omp_device_lower pass.  */\n+\n+static void\n+expand_GOMP_SIMT_LANE (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  gcc_assert (targetm.have_omp_simt_lane ());\n+  emit_insn (targetm.gen_omp_simt_lane (target));\n+}\n+\n+/* This should get expanded in omp_device_lower pass.  */\n+\n+static void\n+expand_GOMP_SIMT_VF (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* Lane index of the first SIMT lane that supplies a non-zero argument.\n+   This is a SIMT counterpart to GOMP_SIMD_LAST_LANE, used to represent the\n+   lane that executed the last iteration for handling OpenMP lastprivate.  */\n+\n+static void\n+expand_GOMP_SIMT_LAST_LANE (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx cond = expand_normal (gimple_call_arg (stmt, 0));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  struct expand_operand ops[2];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], cond, mode);\n+  gcc_assert (targetm.have_omp_simt_last_lane ());\n+  expand_insn (targetm.code_for_omp_simt_last_lane, 2, ops);\n+}\n+\n+/* Non-transparent predicate used in SIMT lowering of OpenMP \"ordered\".  */\n+\n+static void\n+expand_GOMP_SIMT_ORDERED_PRED (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx ctr = expand_normal (gimple_call_arg (stmt, 0));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  struct expand_operand ops[2];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], ctr, mode);\n+  gcc_assert (targetm.have_omp_simt_ordered ());\n+  expand_insn (targetm.code_for_omp_simt_ordered, 2, ops);\n+}\n+\n+/* \"Or\" boolean reduction across SIMT lanes: return non-zero in all lanes if\n+   any lane supplies a non-zero argument.  */\n+\n+static void\n+expand_GOMP_SIMT_VOTE_ANY (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx cond = expand_normal (gimple_call_arg (stmt, 0));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  struct expand_operand ops[2];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], cond, mode);\n+  gcc_assert (targetm.have_omp_simt_vote_any ());\n+  expand_insn (targetm.code_for_omp_simt_vote_any, 2, ops);\n+}\n+\n+/* Exchange between SIMT lanes with a \"butterfly\" pattern: source lane index\n+   is destination lane index XOR given offset.  */\n+\n+static void\n+expand_GOMP_SIMT_XCHG_BFLY (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx src = expand_normal (gimple_call_arg (stmt, 0));\n+  rtx idx = expand_normal (gimple_call_arg (stmt, 1));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  struct expand_operand ops[3];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], src, mode);\n+  create_input_operand (&ops[2], idx, SImode);\n+  gcc_assert (targetm.have_omp_simt_xchg_bfly ());\n+  expand_insn (targetm.code_for_omp_simt_xchg_bfly, 3, ops);\n+}\n+\n+/* Exchange between SIMT lanes according to given source lane index.  */\n+\n+static void\n+expand_GOMP_SIMT_XCHG_IDX (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx src = expand_normal (gimple_call_arg (stmt, 0));\n+  rtx idx = expand_normal (gimple_call_arg (stmt, 1));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  struct expand_operand ops[3];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], src, mode);\n+  create_input_operand (&ops[2], idx, SImode);\n+  gcc_assert (targetm.have_omp_simt_xchg_idx ());\n+  expand_insn (targetm.code_for_omp_simt_xchg_idx, 3, ops);\n+}\n+\n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void"}, {"sha": "f055230f7226867bf8615bab93f964ccd8a45d29", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "patch": "@@ -141,6 +141,13 @@ DEF_INTERNAL_INT_FN (FFS, ECF_CONST, ffs, unary)\n DEF_INTERNAL_INT_FN (PARITY, ECF_CONST, parity, unary)\n DEF_INTERNAL_INT_FN (POPCOUNT, ECF_CONST, popcount, unary)\n \n+DEF_INTERNAL_FN (GOMP_SIMT_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_VF, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_LAST_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_ORDERED_PRED, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_VOTE_ANY, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_XCHG_BFLY, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_XCHG_IDX, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_VF, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "6c52bff74baaa373d52aaadb2a0b4691f2d574c7", "filename": "gcc/omp-low.c", "status": "modified", "additions": 384, "deletions": 64, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "patch": "@@ -2427,6 +2427,20 @@ cilk_for_check_loop_diff_type (tree type)\n     }\n }\n \n+/* Return true if CTX may belong to offloaded code: either if current function\n+   is offloaded, or any enclosing context corresponds to a target region.  */\n+\n+static bool\n+omp_maybe_offloaded_ctx (omp_context *ctx)\n+{\n+  if (cgraph_node::get (current_function_decl)->offloadable)\n+    return true;\n+  for (; ctx; ctx = ctx->outer)\n+    if (is_gimple_omp_offloaded (ctx->stmt))\n+      return true;\n+  return false;\n+}\n+\n /* Build a decl for the omp child function.  It'll not contain a body\n    yet, just the bare decl.  */\n \n@@ -2475,28 +2489,24 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   DECL_CONTEXT (decl) = NULL_TREE;\n   DECL_INITIAL (decl) = make_node (BLOCK);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (decl)) = decl;\n-  if (cgraph_node::get (current_function_decl)->offloadable)\n-    cgraph_node::get_create (decl)->offloadable = 1;\n-  else\n+  if (omp_maybe_offloaded_ctx (ctx))\n     {\n-      omp_context *octx;\n-      for (octx = ctx; octx; octx = octx->outer)\n-\tif (is_gimple_omp_offloaded (octx->stmt))\n-\t  {\n-\t    cgraph_node::get_create (decl)->offloadable = 1;\n-\t    if (ENABLE_OFFLOADING)\n-\t      g->have_offload = true;\n-\n-\t    break;\n-\t  }\n+      cgraph_node::get_create (decl)->offloadable = 1;\n+      if (ENABLE_OFFLOADING)\n+\tg->have_offload = true;\n     }\n \n   if (cgraph_node::get_create (decl)->offloadable\n       && !lookup_attribute (\"omp declare target\",\n                            DECL_ATTRIBUTES (current_function_decl)))\n-    DECL_ATTRIBUTES (decl)\n-      = tree_cons (get_identifier (\"omp target entrypoint\"),\n-                   NULL_TREE, DECL_ATTRIBUTES (decl));\n+    {\n+      const char *target_attr = (is_gimple_omp_offloaded (ctx->stmt)\n+\t\t\t\t ? \"omp target entrypoint\"\n+\t\t\t\t : \"omp declare target\");\n+      DECL_ATTRIBUTES (decl)\n+\t= tree_cons (get_identifier (target_attr),\n+\t\t     NULL_TREE, DECL_ATTRIBUTES (decl));\n+    }\n \n   t = build_decl (DECL_SOURCE_LOCATION (decl),\n \t\t  RESULT_DECL, NULL_TREE, void_type_node);\n@@ -4264,6 +4274,25 @@ omp_clause_aligned_alignment (tree clause)\n   return build_int_cst (integer_type_node, al);\n }\n \n+\n+/* Return maximum SIMT width if offloading may target SIMT hardware.  */\n+\n+static int\n+omp_max_simt_vf (void)\n+{\n+  if (!optimize)\n+    return 0;\n+  if (ENABLE_OFFLOADING)\n+    for (const char *c = getenv (\"OFFLOAD_TARGET_NAMES\"); c; )\n+      {\n+\tif (!strncmp (c, \"nvptx\", strlen (\"nvptx\")))\n+\t  return 32;\n+\telse if ((c = strchr (c, ',')))\n+\t  c++;\n+      }\n+  return 0;\n+}\n+\n /* Return maximum possible vectorization factor for the target.  */\n \n static int\n@@ -4277,16 +4306,18 @@ omp_max_vf (void)\n               || global_options_set.x_flag_tree_vectorize)))\n     return 1;\n \n+  int vf = 1;\n   int vs = targetm.vectorize.autovectorize_vector_sizes ();\n   if (vs)\n+    vf = 1 << floor_log2 (vs);\n+  else\n     {\n-      vs = 1 << floor_log2 (vs);\n-      return vs;\n+      machine_mode vqimode = targetm.vectorize.preferred_simd_mode (QImode);\n+      if (GET_MODE_CLASS (vqimode) == MODE_VECTOR_INT)\n+\tvf = GET_MODE_NUNITS (vqimode);\n     }\n-  machine_mode vqimode = targetm.vectorize.preferred_simd_mode (QImode);\n-  if (GET_MODE_CLASS (vqimode) == MODE_VECTOR_INT)\n-    return GET_MODE_NUNITS (vqimode);\n-  return 1;\n+  int svf = omp_max_simt_vf ();\n+  return MAX (vf, svf);\n }\n \n /* Helper function of lower_rec_input_clauses, used for #pragma omp simd\n@@ -4374,10 +4405,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   int pass;\n   bool is_simd = (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n \t\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD);\n+  bool maybe_simt\n+    = is_simd && omp_maybe_offloaded_ctx (ctx) && omp_max_simt_vf () > 1;\n   int max_vf = 0;\n   tree lane = NULL_TREE, idx = NULL_TREE;\n+  tree simt_lane = NULL_TREE;\n   tree ivar = NULL_TREE, lvar = NULL_TREE;\n-  gimple_seq llist[2] = { NULL, NULL };\n+  gimple_seq llist[3] = { };\n \n   copyin_seq = NULL;\n \n@@ -5251,6 +5285,16 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t      gimplify_assign (unshare_expr (ivar), x, &llist[0]);\n \n+\t\t      if (maybe_simt)\n+\t\t\t{\n+\t\t\t  if (!simt_lane)\n+\t\t\t    simt_lane = create_tmp_var (unsigned_type_node);\n+\t\t\t  x = build_call_expr_internal_loc\n+\t\t\t    (UNKNOWN_LOCATION, IFN_GOMP_SIMT_XCHG_BFLY,\n+\t\t\t     TREE_TYPE (ivar), 2, ivar, simt_lane);\n+\t\t\t  x = build2 (code, TREE_TYPE (ivar), ivar, x);\n+\t\t\t  gimplify_assign (ivar, x, &llist[2]);\n+\t\t\t}\n \t\t      x = build2 (code, TREE_TYPE (ref), ref, ivar);\n \t\t      ref = build_outer_var_ref (var, ctx);\n \t\t      gimplify_assign (ref, x, &llist[1]);\n@@ -5303,6 +5347,39 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       g = gimple_build_assign (lane, INTEGER_CST,\n \t\t\t       build_int_cst (unsigned_type_node, 0));\n       gimple_seq_add_stmt (ilist, g);\n+      /* Emit reductions across SIMT lanes in log_2(simt_vf) steps.  */\n+      if (llist[2])\n+\t{\n+\t  tree simt_vf = create_tmp_var (unsigned_type_node);\n+\t  g = gimple_build_call_internal (IFN_GOMP_SIMT_VF, 0);\n+\t  gimple_call_set_lhs (g, simt_vf);\n+\t  gimple_seq_add_stmt (dlist, g);\n+\n+\t  tree t = build_int_cst (unsigned_type_node, 1);\n+\t  g = gimple_build_assign (simt_lane, INTEGER_CST, t);\n+\t  gimple_seq_add_stmt (dlist, g);\n+\n+\t  t = build_int_cst (unsigned_type_node, 0);\n+\t  g = gimple_build_assign (idx, INTEGER_CST, t);\n+\t  gimple_seq_add_stmt (dlist, g);\n+\n+\t  tree body = create_artificial_label (UNKNOWN_LOCATION);\n+\t  tree header = create_artificial_label (UNKNOWN_LOCATION);\n+\t  tree end = create_artificial_label (UNKNOWN_LOCATION);\n+\t  gimple_seq_add_stmt (dlist, gimple_build_goto (header));\n+\t  gimple_seq_add_stmt (dlist, gimple_build_label (body));\n+\n+\t  gimple_seq_add_seq (dlist, llist[2]);\n+\n+\t  g = gimple_build_assign (simt_lane, LSHIFT_EXPR, simt_lane, integer_one_node);\n+\t  gimple_seq_add_stmt (dlist, g);\n+\n+\t  gimple_seq_add_stmt (dlist, gimple_build_label (header));\n+\t  g = gimple_build_cond (LT_EXPR, simt_lane, simt_vf, body, end);\n+\t  gimple_seq_add_stmt (dlist, g);\n+\n+\t  gimple_seq_add_stmt (dlist, gimple_build_label (end));\n+\t}\n       for (int i = 0; i < 2; i++)\n \tif (llist[i])\n \t  {\n@@ -5389,7 +5466,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n {\n   tree x, c, label = NULL, orig_clauses = clauses;\n   bool par_clauses = false;\n-  tree simduid = NULL, lastlane = NULL;\n+  tree simduid = NULL, lastlane = NULL, simtcond = NULL, simtlast = NULL;\n \n   /* Early exit if there are no lastprivate or linear clauses.  */\n   for (; clauses ; clauses = OMP_CLAUSE_CHAIN (clauses))\n@@ -5416,6 +5493,16 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n       par_clauses = true;\n     }\n \n+  bool maybe_simt = false;\n+  if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+      && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n+    {\n+      maybe_simt = omp_maybe_offloaded_ctx (ctx) && omp_max_simt_vf () > 1;\n+      simduid = find_omp_clause (orig_clauses, OMP_CLAUSE__SIMDUID_);\n+      if (simduid)\n+\tsimduid = OMP_CLAUSE__SIMDUID__DECL (simduid);\n+    }\n+\n   if (predicate)\n     {\n       gcond *stmt;\n@@ -5427,20 +5514,27 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n       arm2 = TREE_OPERAND (predicate, 1);\n       gimplify_expr (&arm1, stmt_list, NULL, is_gimple_val, fb_rvalue);\n       gimplify_expr (&arm2, stmt_list, NULL, is_gimple_val, fb_rvalue);\n-      stmt = gimple_build_cond (TREE_CODE (predicate), arm1, arm2,\n-\t\t\t\tlabel_true, label);\n+      if (maybe_simt)\n+\t{\n+\t  c = build2 (TREE_CODE (predicate), boolean_type_node, arm1, arm2);\n+\t  c = fold_convert (integer_type_node, c);\n+\t  simtcond = create_tmp_var (integer_type_node);\n+\t  gimplify_assign (simtcond, c, stmt_list);\n+\t  gcall *g = gimple_build_call_internal (IFN_GOMP_SIMT_VOTE_ANY,\n+\t\t\t\t\t\t 1, simtcond);\n+\t  c = create_tmp_var (integer_type_node);\n+\t  gimple_call_set_lhs (g, c);\n+\t  gimple_seq_add_stmt (stmt_list, g);\n+\t  stmt = gimple_build_cond (NE_EXPR, c, integer_zero_node,\n+\t\t\t\t    label_true, label);\n+\t}\n+      else\n+\tstmt = gimple_build_cond (TREE_CODE (predicate), arm1, arm2,\n+\t\t\t\t  label_true, label);\n       gimple_seq_add_stmt (stmt_list, stmt);\n       gimple_seq_add_stmt (stmt_list, gimple_build_label (label_true));\n     }\n \n-  if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-      && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n-    {\n-      simduid = find_omp_clause (orig_clauses, OMP_CLAUSE__SIMDUID_);\n-      if (simduid)\n-\tsimduid = OMP_CLAUSE__SIMDUID__DECL (simduid);\n-    }\n-\n   for (c = clauses; c ;)\n     {\n       tree var, new_var;\n@@ -5491,6 +5585,24 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t  new_var = build4 (ARRAY_REF, TREE_TYPE (val),\n \t\t\t\t    TREE_OPERAND (val, 0), lastlane,\n \t\t\t\t    NULL_TREE, NULL_TREE);\n+\t\t  if (maybe_simt)\n+\t\t    {\n+\t\t      gcall *g;\n+\t\t      if (simtlast == NULL)\n+\t\t\t{\n+\t\t\t  simtlast = create_tmp_var (unsigned_type_node);\n+\t\t\t  g = gimple_build_call_internal\n+\t\t\t    (IFN_GOMP_SIMT_LAST_LANE, 1, simtcond);\n+\t\t\t  gimple_call_set_lhs (g, simtlast);\n+\t\t\t  gimple_seq_add_stmt (stmt_list, g);\n+\t\t\t}\n+\t\t      x = build_call_expr_internal_loc\n+\t\t\t(UNKNOWN_LOCATION, IFN_GOMP_SIMT_XCHG_IDX,\n+\t\t\t TREE_TYPE (new_var), 2, new_var, simtlast);\n+\t\t      new_var = unshare_expr (new_var);\n+\t\t      gimplify_assign (new_var, x, stmt_list);\n+\t\t      new_var = unshare_expr (new_var);\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -10564,12 +10676,23 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   edge e, ne;\n   tree *counts = NULL;\n   int i;\n+  int safelen_int = INT_MAX;\n   tree safelen = find_omp_clause (gimple_omp_for_clauses (fd->for_stmt),\n \t\t\t\t  OMP_CLAUSE_SAFELEN);\n   tree simduid = find_omp_clause (gimple_omp_for_clauses (fd->for_stmt),\n \t\t\t\t  OMP_CLAUSE__SIMDUID_);\n   tree n1, n2;\n \n+  if (safelen)\n+    {\n+      safelen = OMP_CLAUSE_SAFELEN_EXPR (safelen);\n+      if (TREE_CODE (safelen) != INTEGER_CST)\n+\tsafelen_int = 0;\n+      else if (tree_fits_uhwi_p (safelen) && tree_to_uhwi (safelen) < INT_MAX)\n+\tsafelen_int = tree_to_uhwi (safelen);\n+      if (safelen_int == 1)\n+\tsafelen_int = 0;\n+    }\n   type = TREE_TYPE (fd->loop.v);\n   entry_bb = region->entry;\n   cont_bb = region->cont;\n@@ -10623,20 +10746,53 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n       gcc_assert (innerc);\n       n2 = OMP_CLAUSE_DECL (innerc);\n-      expand_omp_build_assign (&gsi, fd->loop.v,\n-\t\t\t       fold_convert (type, n1));\n+    }\n+  tree step = fd->loop.step;\n+\n+  bool offloaded = cgraph_node::get (current_function_decl)->offloadable;\n+  for (struct omp_region *rgn = region; !offloaded && rgn; rgn = rgn->outer)\n+    offloaded = rgn->type == GIMPLE_OMP_TARGET;\n+  bool is_simt = offloaded && omp_max_simt_vf () > 1 && safelen_int > 1;\n+  tree simt_lane = NULL_TREE, simt_maxlane = NULL_TREE;\n+  if (is_simt)\n+    {\n+      cfun->curr_properties &= ~PROP_gimple_lomp_dev;\n+      simt_lane = create_tmp_var (unsigned_type_node);\n+      gimple *g = gimple_build_call_internal (IFN_GOMP_SIMT_LANE, 0);\n+      gimple_call_set_lhs (g, simt_lane);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      tree offset = fold_build2 (MULT_EXPR, TREE_TYPE (step), step,\n+\t\t\t\t fold_convert (TREE_TYPE (step), simt_lane));\n+      n1 = fold_convert (type, n1);\n+      if (POINTER_TYPE_P (type))\n+\tn1 = fold_build_pointer_plus (n1, offset);\n+      else\n+\tn1 = fold_build2 (PLUS_EXPR, type, n1, fold_convert (type, offset));\n+\n+      /* Collapsed loops not handled for SIMT yet: limit to one lane only.  */\n       if (fd->collapse > 1)\n+\tsimt_maxlane = build_one_cst (unsigned_type_node);\n+      else if (safelen_int < omp_max_simt_vf ())\n+\tsimt_maxlane = build_int_cst (unsigned_type_node, safelen_int);\n+      tree vf\n+\t= build_call_expr_internal_loc (UNKNOWN_LOCATION, IFN_GOMP_SIMT_VF,\n+\t\t\t\t\tunsigned_type_node, 0);\n+      if (simt_maxlane)\n+\tvf = fold_build2 (MIN_EXPR, unsigned_type_node, vf, simt_maxlane);\n+      vf = fold_convert (TREE_TYPE (step), vf);\n+      step = fold_build2 (MULT_EXPR, TREE_TYPE (step), step, vf);\n+    }\n+\n+  expand_omp_build_assign (&gsi, fd->loop.v, fold_convert (type, n1));\n+  if (fd->collapse > 1)\n+    {\n+      if (gimple_omp_for_combined_into_p (fd->for_stmt))\n \t{\n \t  gsi_prev (&gsi);\n \t  expand_omp_for_init_vars (fd, &gsi, counts, NULL, n1);\n \t  gsi_next (&gsi);\n \t}\n-    }\n-  else\n-    {\n-      expand_omp_build_assign (&gsi, fd->loop.v,\n-\t\t\t       fold_convert (type, fd->loop.n1));\n-      if (fd->collapse > 1)\n+      else\n \tfor (i = 0; i < fd->collapse; i++)\n \t  {\n \t    tree itype = TREE_TYPE (fd->loops[i].v);\n@@ -10645,7 +10801,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t    t = fold_convert (TREE_TYPE (fd->loops[i].v), fd->loops[i].n1);\n \t    expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n \t  }\n-      }\n+    }\n \n   /* Remove the GIMPLE_OMP_FOR statement.  */\n   gsi_remove (&gsi, true);\n@@ -10658,9 +10814,9 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n \n       if (POINTER_TYPE_P (type))\n-\tt = fold_build_pointer_plus (fd->loop.v, fd->loop.step);\n+\tt = fold_build_pointer_plus (fd->loop.v, step);\n       else\n-\tt = fold_build2 (PLUS_EXPR, type, fd->loop.v, fd->loop.step);\n+\tt = fold_build2 (PLUS_EXPR, type, fd->loop.v, step);\n       expand_omp_build_assign (&gsi, fd->loop.v, t);\n \n       if (fd->collapse > 1)\n@@ -10734,6 +10890,18 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       gimple_regimplify_operands (cond_stmt, &gsi);\n     }\n \n+  /* Add 'V -= STEP * (SIMT_VF - 1)' after the loop.  */\n+  if (is_simt)\n+    {\n+      gsi = gsi_start_bb (l2_bb);\n+      step = fold_build2 (MINUS_EXPR, TREE_TYPE (step), fd->loop.step, step);\n+      if (POINTER_TYPE_P (type))\n+\tt = fold_build_pointer_plus (fd->loop.v, step);\n+      else\n+\tt = fold_build2 (PLUS_EXPR, type, fd->loop.v, step);\n+      expand_omp_build_assign (&gsi, fd->loop.v, t);\n+    }\n+\n   /* Remove GIMPLE_OMP_RETURN.  */\n   gsi = gsi_last_bb (exit_bb);\n   gsi_remove (&gsi, true);\n@@ -10763,30 +10931,29 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   ne->probability = REG_BR_PROB_BASE / 8;\n \n   set_immediate_dominator (CDI_DOMINATORS, l1_bb, entry_bb);\n-  set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n   set_immediate_dominator (CDI_DOMINATORS, l0_bb, l1_bb);\n \n+  if (simt_maxlane)\n+    {\n+      cond_stmt = gimple_build_cond (LT_EXPR, simt_lane, simt_maxlane,\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+      gsi = gsi_last_bb (entry_bb);\n+      gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n+      make_edge (entry_bb, l2_bb, EDGE_FALSE_VALUE);\n+      FALLTHRU_EDGE (entry_bb)->flags = EDGE_TRUE_VALUE;\n+      FALLTHRU_EDGE (entry_bb)->probability = REG_BR_PROB_BASE * 7 / 8;\n+      BRANCH_EDGE (entry_bb)->probability = REG_BR_PROB_BASE / 8;\n+      l2_dom_bb = entry_bb;\n+    }\n+  set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n+\n   if (!broken_loop)\n     {\n       struct loop *loop = alloc_loop ();\n       loop->header = l1_bb;\n       loop->latch = cont_bb;\n       add_loop (loop, l1_bb->loop_father);\n-      if (safelen == NULL_TREE)\n-\tloop->safelen = INT_MAX;\n-      else\n-\t{\n-\t  safelen = OMP_CLAUSE_SAFELEN_EXPR (safelen);\n-\t  if (TREE_CODE (safelen) != INTEGER_CST)\n-\t    loop->safelen = 0;\n-\t  else if (!tree_fits_uhwi_p (safelen)\n-\t\t   || tree_to_uhwi (safelen) > INT_MAX)\n-\t    loop->safelen = INT_MAX;\n-\t  else\n-\t    loop->safelen = tree_to_uhwi (safelen);\n-\t  if (loop->safelen == 1)\n-\t    loop->safelen = 0;\n-\t}\n+      loop->safelen = safelen_int;\n       if (simduid)\n \t{\n \t  loop->simduid = OMP_CLAUSE__SIMDUID__DECL (simduid);\n@@ -13951,7 +14118,6 @@ expand_omp (struct omp_region *region)\n     }\n }\n \n-\n /* Helper for build_omp_regions.  Scan the dominator tree starting at\n    block BB.  PARENT is the region that contains BB.  If SINGLE_TREE is\n    true, the function ends once a single tree is built (otherwise, whole\n@@ -14834,12 +15000,14 @@ static void\n lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block;\n-  gimple *stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p), *g;\n   gomp_ordered *ord_stmt = as_a <gomp_ordered *> (stmt);\n   gcall *x;\n   gbind *bind;\n   bool simd = find_omp_clause (gimple_omp_ordered_clauses (ord_stmt),\n \t\t\t       OMP_CLAUSE_SIMD);\n+  bool maybe_simt\n+    = simd && omp_maybe_offloaded_ctx (ctx) && omp_max_simt_vf () > 1;\n   bool threads = find_omp_clause (gimple_omp_ordered_clauses (ord_stmt),\n \t\t\t\t  OMP_CLAUSE_THREADS);\n \n@@ -14873,11 +15041,56 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t   0);\n   gimple_bind_add_stmt (bind, x);\n \n+  tree counter = NULL_TREE, test = NULL_TREE, body = NULL_TREE;\n+  if (maybe_simt)\n+    {\n+      counter = create_tmp_var (integer_type_node);\n+      g = gimple_build_call_internal (IFN_GOMP_SIMT_LANE, 0);\n+      gimple_call_set_lhs (g, counter);\n+      gimple_bind_add_stmt (bind, g);\n+\n+      body = create_artificial_label (UNKNOWN_LOCATION);\n+      test = create_artificial_label (UNKNOWN_LOCATION);\n+      gimple_bind_add_stmt (bind, gimple_build_label (body));\n+\n+      tree simt_pred = create_tmp_var (integer_type_node);\n+      g = gimple_build_call_internal (IFN_GOMP_SIMT_ORDERED_PRED, 1, counter);\n+      gimple_call_set_lhs (g, simt_pred);\n+      gimple_bind_add_stmt (bind, g);\n+\n+      tree t = create_artificial_label (UNKNOWN_LOCATION);\n+      g = gimple_build_cond (EQ_EXPR, simt_pred, integer_zero_node, t, test);\n+      gimple_bind_add_stmt (bind, g);\n+\n+      gimple_bind_add_stmt (bind, gimple_build_label (t));\n+    }\n   lower_omp (gimple_omp_body_ptr (stmt), ctx);\n   gimple_omp_set_body (stmt, maybe_catch_exception (gimple_omp_body (stmt)));\n   gimple_bind_add_seq (bind, gimple_omp_body (stmt));\n   gimple_omp_set_body (stmt, NULL);\n \n+  if (maybe_simt)\n+    {\n+      gimple_bind_add_stmt (bind, gimple_build_label (test));\n+      g = gimple_build_assign (counter, MINUS_EXPR, counter, integer_one_node);\n+      gimple_bind_add_stmt (bind, g);\n+\n+      tree c = build2 (GE_EXPR, boolean_type_node, counter, integer_zero_node);\n+      tree nonneg = create_tmp_var (integer_type_node);\n+      gimple_seq tseq = NULL;\n+      gimplify_assign (nonneg, fold_convert (integer_type_node, c), &tseq);\n+      gimple_bind_add_seq (bind, tseq);\n+\n+      g = gimple_build_call_internal (IFN_GOMP_SIMT_VOTE_ANY, 1, nonneg);\n+      gimple_call_set_lhs (g, nonneg);\n+      gimple_bind_add_stmt (bind, g);\n+\n+      tree end = create_artificial_label (UNKNOWN_LOCATION);\n+      g = gimple_build_cond (NE_EXPR, nonneg, integer_zero_node, body, end);\n+      gimple_bind_add_stmt (bind, g);\n+\n+      gimple_bind_add_stmt (bind, gimple_build_label (end));\n+    }\n   if (simd)\n     x = gimple_build_call_internal (IFN_GOMP_SIMD_ORDERED_END, 1,\n \t\t\t\t    build_int_cst (NULL_TREE, threads));\n@@ -17998,7 +18211,7 @@ const pass_data pass_data_lower_omp =\n   OPTGROUP_NONE, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_gimple_any, /* properties_required */\n-  PROP_gimple_lomp, /* properties_provided */\n+  PROP_gimple_lomp | PROP_gimple_lomp_dev, /* properties_provided */\n   0, /* properties_destroyed */\n   0, /* todo_flags_start */\n   0, /* todo_flags_finish */\n@@ -19930,6 +20143,113 @@ make_pass_oacc_device_lower (gcc::context *ctxt)\n {\n   return new pass_oacc_device_lower (ctxt);\n }\n+\f\n+\n+/* Cleanup uses of SIMT placeholder internal functions: on non-SIMT targets,\n+   VF is 1 and LANE is 0; on SIMT targets, VF is folded to a constant, and\n+   LANE is kept to be expanded to RTL later on.  Also cleanup all other SIMT\n+   internal functions on non-SIMT targets, and likewise some SIMD internal\n+   functions on SIMT targets.  */\n+\n+static unsigned int\n+execute_omp_device_lower ()\n+{\n+  int vf = targetm.simt.vf ? targetm.simt.vf () : 1;\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\tif (!is_gimple_call (stmt) || !gimple_call_internal_p (stmt))\n+\t  continue;\n+\ttree lhs = gimple_call_lhs (stmt), rhs = NULL_TREE;\n+\ttree type = lhs ? TREE_TYPE (lhs) : integer_type_node;\n+\tswitch (gimple_call_internal_fn (stmt))\n+\t  {\n+\t  case IFN_GOMP_SIMT_LANE:\n+\t  case IFN_GOMP_SIMT_LAST_LANE:\n+\t    rhs = vf == 1 ? build_zero_cst (type) : NULL_TREE;\n+\t    break;\n+\t  case IFN_GOMP_SIMT_VF:\n+\t    rhs = build_int_cst (type, vf);\n+\t    break;\n+\t  case IFN_GOMP_SIMT_ORDERED_PRED:\n+\t    rhs = vf == 1 ? integer_zero_node : NULL_TREE;\n+\t    if (rhs || !lhs)\n+\t      unlink_stmt_vdef (stmt);\n+\t    break;\n+\t  case IFN_GOMP_SIMT_VOTE_ANY:\n+\t  case IFN_GOMP_SIMT_XCHG_BFLY:\n+\t  case IFN_GOMP_SIMT_XCHG_IDX:\n+\t    rhs = vf == 1 ? gimple_call_arg (stmt, 0) : NULL_TREE;\n+\t    break;\n+\t  case IFN_GOMP_SIMD_LANE:\n+\t  case IFN_GOMP_SIMD_LAST_LANE:\n+\t    rhs = vf != 1 ? build_zero_cst (type) : NULL_TREE;\n+\t    break;\n+\t  case IFN_GOMP_SIMD_VF:\n+\t    rhs = vf != 1 ? build_one_cst (type) : NULL_TREE;\n+\t    break;\n+\t  default:\n+\t    continue;\n+\t  }\n+\tif (lhs && !rhs)\n+\t  continue;\n+\tstmt = lhs ? gimple_build_assign (lhs, rhs) : gimple_build_nop ();\n+\tgsi_replace (&gsi, stmt, false);\n+      }\n+  if (vf != 1)\n+    cfun->has_force_vectorize_loops = false;\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_omp_device_lower =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ompdevlow\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  PROP_gimple_lomp_dev, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_omp_device_lower : public gimple_opt_pass\n+{\n+public:\n+  pass_omp_device_lower (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_omp_device_lower, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *ARG_UNUSED (fun))\n+    {\n+      /* FIXME: this should use PROP_gimple_lomp_dev.  */\n+#ifdef ACCEL_COMPILER\n+      return true;\n+#else\n+      return ENABLE_OFFLOADING && (flag_openmp || in_lto_p);\n+#endif\n+    }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_omp_device_lower ();\n+    }\n+\n+}; // class pass_expand_omp_ssa\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_omp_device_lower (gcc::context *ctxt)\n+{\n+  return new pass_omp_device_lower (ctxt);\n+}\n \n /* \"omp declare target link\" handling pass.  */\n "}, {"sha": "2a470a7de079135f2ac3db64be0ae20b86355980", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "patch": "@@ -183,6 +183,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_fixup_cfg);\n   NEXT_PASS (pass_lower_eh_dispatch);\n   NEXT_PASS (pass_oacc_device_lower);\n+  NEXT_PASS (pass_omp_device_lower);\n   NEXT_PASS (pass_omp_target_link);\n   NEXT_PASS (pass_all_optimizations);\n   PUSH_INSERT_PASSES_WITHIN (pass_all_optimizations)"}, {"sha": "8befebe17b17c99fe3b51e46db0a78f064750dfd", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9669b00bfb16ced0d5bf09b9e016e9ffa8be4219/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=9669b00bfb16ced0d5bf09b9e016e9ffa8be4219", "patch": "@@ -222,6 +222,7 @@ class simple_ipa_opt_pass : public opt_pass\n \t\t\t\t\t\t   of math functions; the\n \t\t\t\t\t\t   current choices have\n \t\t\t\t\t\t   been optimized.  */\n+#define PROP_gimple_lomp_dev\t(1 << 16)\t/* done omp_device_lower */\n \n #define PROP_trees \\\n   (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh | PROP_gimple_lomp)\n@@ -417,6 +418,7 @@ extern gimple_opt_pass *make_pass_expand_omp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_expand_omp_ssa (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_omp_target_link (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_oacc_device_lower (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_omp_device_lower (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_strlen (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fold_builtins (gcc::context *ctxt);"}]}