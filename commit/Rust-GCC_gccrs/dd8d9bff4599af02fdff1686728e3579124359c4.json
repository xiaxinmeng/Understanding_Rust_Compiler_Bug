{"sha": "dd8d9bff4599af02fdff1686728e3579124359c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ4ZDliZmY0NTk5YWYwMmZkZmYxNjg2NzI4ZTM1NzkxMjQzNTljNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-28T00:02:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-28T00:02:39Z"}, "message": "compiler: Rework range over slice.\n\nFrom-SVN: r182697", "tree": {"sha": "15ed01fb24ad3ff3518c91f251292e695370ce2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15ed01fb24ad3ff3518c91f251292e695370ce2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd8d9bff4599af02fdff1686728e3579124359c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd8d9bff4599af02fdff1686728e3579124359c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd8d9bff4599af02fdff1686728e3579124359c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd8d9bff4599af02fdff1686728e3579124359c4/comments", "author": null, "committer": null, "parents": [{"sha": "5090c808a3b6c972287a1668df0182237839cf0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5090c808a3b6c972287a1668df0182237839cf0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5090c808a3b6c972287a1668df0182237839cf0b"}], "stats": {"total": 114, "additions": 112, "deletions": 2}, "files": [{"sha": "f6c0f8254dfb41d934787fbf760b2578b1a31889", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd8d9bff4599af02fdff1686728e3579124359c4/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd8d9bff4599af02fdff1686728e3579124359c4/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=dd8d9bff4599af02fdff1686728e3579124359c4", "patch": "@@ -5260,7 +5260,11 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n   //           original statements\n   //   }\n \n-  if (range_type->array_type() != NULL)\n+  if (range_type->is_slice_type())\n+    this->lower_range_slice(gogo, temp_block, body, range_object, range_temp,\n+\t\t\t    index_temp, value_temp, &init, &cond, &iter_init,\n+\t\t\t    &post);\n+  else if (range_type->array_type() != NULL)\n     this->lower_range_array(gogo, temp_block, body, range_object, range_temp,\n \t\t\t    index_temp, value_temp, &init, &cond, &iter_init,\n \t\t\t    &post);\n@@ -5346,7 +5350,7 @@ For_range_statement::call_builtin(Gogo* gogo, const char* funcname,\n   return Expression::make_call(func, params, false, loc);\n }\n \n-// Lower a for range over an array or slice.\n+// Lower a for range over an array.\n \n void\n For_range_statement::lower_range_array(Gogo* gogo,\n@@ -5438,6 +5442,107 @@ For_range_statement::lower_range_array(Gogo* gogo,\n   *ppost = post;\n }\n \n+// Lower a for range over a slice.\n+\n+void\n+For_range_statement::lower_range_slice(Gogo* gogo,\n+\t\t\t\t       Block* enclosing,\n+\t\t\t\t       Block* body_block,\n+\t\t\t\t       Named_object* range_object,\n+\t\t\t\t       Temporary_statement* range_temp,\n+\t\t\t\t       Temporary_statement* index_temp,\n+\t\t\t\t       Temporary_statement* value_temp,\n+\t\t\t\t       Block** pinit,\n+\t\t\t\t       Expression** pcond,\n+\t\t\t\t       Block** piter_init,\n+\t\t\t\t       Block** ppost)\n+{\n+  Location loc = this->location();\n+\n+  // The loop we generate:\n+  //   for_temp := range\n+  //   len_temp := len(for_temp)\n+  //   for index_temp = 0; index_temp < len_temp; index_temp++ {\n+  //           value_temp = for_temp[index_temp]\n+  //           index = index_temp\n+  //           value = value_temp\n+  //           original body\n+  //   }\n+  //\n+  // Using for_temp means that we don't need to check bounds when\n+  // fetching range_temp[index_temp].\n+\n+  // Set *PINIT to\n+  //   range_temp := range\n+  //   var len_temp int\n+  //   len_temp = len(range_temp)\n+  //   index_temp = 0\n+\n+  Block* init = new Block(enclosing, loc);\n+\n+  Expression* ref = this->make_range_ref(range_object, range_temp, loc);\n+  Temporary_statement* for_temp = Statement::make_temporary(NULL, ref, loc);\n+  init->add_statement(for_temp);\n+\n+  ref = Expression::make_temporary_reference(for_temp, loc);\n+  Expression* len_call = this->call_builtin(gogo, \"len\", ref, loc);\n+  Temporary_statement* len_temp = Statement::make_temporary(index_temp->type(),\n+\t\t\t\t\t\t\t    len_call, loc);\n+  init->add_statement(len_temp);\n+\n+  mpz_t zval;\n+  mpz_init_set_ui(zval, 0UL);\n+  Expression* zexpr = Expression::make_integer(&zval, NULL, loc);\n+  mpz_clear(zval);\n+\n+  Temporary_reference_expression* tref =\n+    Expression::make_temporary_reference(index_temp, loc);\n+  tref->set_is_lvalue();\n+  Statement* s = Statement::make_assignment(tref, zexpr, loc);\n+  init->add_statement(s);\n+\n+  *pinit = init;\n+\n+  // Set *PCOND to\n+  //   index_temp < len_temp\n+\n+  ref = Expression::make_temporary_reference(index_temp, loc);\n+  Expression* ref2 = Expression::make_temporary_reference(len_temp, loc);\n+  Expression* lt = Expression::make_binary(OPERATOR_LT, ref, ref2, loc);\n+\n+  *pcond = lt;\n+\n+  // Set *PITER_INIT to\n+  //   value_temp = range[index_temp]\n+\n+  Block* iter_init = NULL;\n+  if (value_temp != NULL)\n+    {\n+      iter_init = new Block(body_block, loc);\n+\n+      ref = Expression::make_temporary_reference(for_temp, loc);\n+      Expression* ref2 = Expression::make_temporary_reference(index_temp, loc);\n+      Expression* index = Expression::make_index(ref, ref2, NULL, loc);\n+\n+      tref = Expression::make_temporary_reference(value_temp, loc);\n+      tref->set_is_lvalue();\n+      s = Statement::make_assignment(tref, index, loc);\n+\n+      iter_init->add_statement(s);\n+    }\n+  *piter_init = iter_init;\n+\n+  // Set *PPOST to\n+  //   index_temp++\n+\n+  Block* post = new Block(enclosing, loc);\n+  tref = Expression::make_temporary_reference(index_temp, loc);\n+  tref->set_is_lvalue();\n+  s = Statement::make_inc_statement(tref);\n+  post->add_statement(s);\n+  *ppost = post;\n+}\n+\n // Lower a for range over a string.\n \n void"}, {"sha": "016ca189569918afaf6a186c32b26164e9c3093b", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd8d9bff4599af02fdff1686728e3579124359c4/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd8d9bff4599af02fdff1686728e3579124359c4/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=dd8d9bff4599af02fdff1686728e3579124359c4", "patch": "@@ -1161,6 +1161,11 @@ class For_range_statement : public Statement\n \t\t    Temporary_statement*, Temporary_statement*,\n \t\t    Block**, Expression**, Block**, Block**);\n \n+  void\n+  lower_range_slice(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t    Temporary_statement*, Temporary_statement*,\n+\t\t    Block**, Expression**, Block**, Block**);\n+\n   void\n   lower_range_string(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n \t\t     Temporary_statement*, Temporary_statement*,"}]}