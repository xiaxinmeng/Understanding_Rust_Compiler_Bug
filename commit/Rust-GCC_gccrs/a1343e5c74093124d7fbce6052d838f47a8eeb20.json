{"sha": "a1343e5c74093124d7fbce6052d838f47a8eeb20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEzNDNlNWM3NDA5MzEyNGQ3ZmJjZTYwNTJkODM4ZjQ3YThlZWIyMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-30T15:14:33Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-30T20:58:08Z"}, "message": "libstdc++: Use double for unordered container load factors [PR 96958]\n\nThese calculations were changed to use long double nearly ten years ago\nin order to get more precision than float:\nhttps://gcc.gnu.org/pipermail/libstdc++/2011-September/036420.html\n\nHowever, double should be sufficient, whlie being potentially faster\nthan long double, and not requiring soft FP calculations for targets\nwithout native long double support.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/96958\n\t* include/bits/hashtable_policy.h (_Prime_rehash_policy)\n\t(_Power2_rehash_policy): Use double instead of long double.", "tree": {"sha": "e97bbf1e90e45518d94fd278478cf60bde60d08c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e97bbf1e90e45518d94fd278478cf60bde60d08c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1343e5c74093124d7fbce6052d838f47a8eeb20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1343e5c74093124d7fbce6052d838f47a8eeb20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1343e5c74093124d7fbce6052d838f47a8eeb20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1343e5c74093124d7fbce6052d838f47a8eeb20/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1e5d82af819025df9d9a81e8c591690e299924a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e5d82af819025df9d9a81e8c591690e299924a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e5d82af819025df9d9a81e8c591690e299924a"}], "stats": {"total": 12, "additions": 6, "deletions": 6}, "files": [{"sha": "7fed87f1c76b8770090ceec618e9dea0eab3358b", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1343e5c74093124d7fbce6052d838f47a8eeb20/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1343e5c74093124d7fbce6052d838f47a8eeb20/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=a1343e5c74093124d7fbce6052d838f47a8eeb20", "patch": "@@ -458,7 +458,7 @@ namespace __detail\n     // Return a bucket count appropriate for n elements\n     std::size_t\n     _M_bkt_for_elements(std::size_t __n) const\n-    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }\n+    { return __builtin_ceill(__n / (double)_M_max_load_factor); }\n \n     // __n_bkt is current bucket count, __n_elt is current element count,\n     // and __n_ins is number of elements to be inserted.  Do we need to\n@@ -559,15 +559,15 @@ namespace __detail\n \t_M_next_resize = size_t(-1);\n       else\n \t_M_next_resize\n-\t  = __builtin_floorl(__res * (long double)_M_max_load_factor);\n+\t  = __builtin_floorl(__res * (double)_M_max_load_factor);\n \n       return __res;\n     }\n \n     // Return a bucket count appropriate for n elements\n     std::size_t\n     _M_bkt_for_elements(std::size_t __n) const noexcept\n-    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }\n+    { return __builtin_ceill(__n / (double)_M_max_load_factor); }\n \n     // __n_bkt is current bucket count, __n_elt is current element count,\n     // and __n_ins is number of elements to be inserted.  Do we need to\n@@ -582,16 +582,16 @@ namespace __detail\n \t  // If _M_next_resize is 0 it means that we have nothing allocated so\n \t  // far and that we start inserting elements. In this case we start\n \t  // with an initial bucket size of 11.\n-\t  long double __min_bkts\n+\t  double __min_bkts\n \t    = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)\n-\t      / (long double)_M_max_load_factor;\n+\t      / (double)_M_max_load_factor;\n \t  if (__min_bkts >= __n_bkt)\n \t    return { true,\n \t      _M_next_bkt(std::max<std::size_t>(__builtin_floorl(__min_bkts) + 1,\n \t\t\t\t\t\t__n_bkt * _S_growth_factor)) };\n \n \t  _M_next_resize\n-\t    = __builtin_floorl(__n_bkt * (long double)_M_max_load_factor);\n+\t    = __builtin_floorl(__n_bkt * (double)_M_max_load_factor);\n \t  return { false, 0 };\n \t}\n       else"}]}