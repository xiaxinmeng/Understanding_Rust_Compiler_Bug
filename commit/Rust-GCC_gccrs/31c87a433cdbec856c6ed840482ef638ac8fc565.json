{"sha": "31c87a433cdbec856c6ed840482ef638ac8fc565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFjODdhNDMzY2RiZWM4NTZjNmVkODQwNDgyZWY2MzhhYzhmYzU2NQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-01-26T23:07:02Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-26T23:07:02Z"}, "message": "PR middle-end/78703 - fprintf-return-value floating point handling incorrect in locales with a mulltibyte decimal point\n\ngcc/ChangeLog:\n        PR middle-end/78703\n        * gimple-ssa-sprintf.c (adjust_for_width_or_precision): Change\n        to accept adjustment as an array.\n        (get_int_range): New function.\n        (struct directive): Make width and prec arrays.\n        (directive::set_width, directive::set_precision): Call get_int_range.\n        (format_integer, format_floating): Handle width and precision ranges.\n        (format_string, parse_directive): Same.\n\ngcc/testsuite/ChangeLog:\n        PR middle-end/78703\n        * gcc.dg/tree-ssa/builtin-snprintf-warn-1.c: Update\n        * gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: Rename...\n        * gcc.dg/tree-ssa/builtin-sprintf-warn-10.c: ...to this.\n        * gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: New test.\n\nFrom-SVN: r244956", "tree": {"sha": "a8d8e16a309d249b497cdbd3a0a383771dc5dff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8d8e16a309d249b497cdbd3a0a383771dc5dff7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31c87a433cdbec856c6ed840482ef638ac8fc565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c87a433cdbec856c6ed840482ef638ac8fc565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c87a433cdbec856c6ed840482ef638ac8fc565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c87a433cdbec856c6ed840482ef638ac8fc565/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0670cc0eb260ce182c7eb2c0b25bcc0b59a0e68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0670cc0eb260ce182c7eb2c0b25bcc0b59a0e68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0670cc0eb260ce182c7eb2c0b25bcc0b59a0e68"}], "stats": {"total": 1146, "additions": 699, "deletions": 447}, "files": [{"sha": "86c4a0d98466841a2ecbe721affa9c743dbe0ce6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31c87a433cdbec856c6ed840482ef638ac8fc565", "patch": "@@ -1,3 +1,14 @@\n+2017-01-26  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78703\n+\t* gimple-ssa-sprintf.c (adjust_for_width_or_precision): Change\n+\tto accept adjustment as an array.\n+\t(get_int_range): New function.\n+\t(struct directive): Make width and prec arrays.\n+\t(directive::set_width, directive::set_precision): Call get_int_range.\n+\t(format_integer, format_floating): Handle width and precision ranges.\n+\t(format_string, parse_directive): Same.\n+\n 2017-01-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/79129"}, {"sha": "61eafacfb80e084ce78cdd413959843d3d5e58fd", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 253, "deletions": 195, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=31c87a433cdbec856c6ed840482ef638ac8fc565", "patch": "@@ -478,15 +478,15 @@ struct fmtresult\n     range.unlikely = max;\n   }\n \n-  /* Adjust result upward to reflect the value the specified width\n-     or precision is known to have.  */\n-  fmtresult& adjust_for_width_or_precision (HOST_WIDE_INT,\n+  /* Adjust result upward to reflect the RANGE of values the specified\n+     width or precision is known to be in.  */\n+  fmtresult& adjust_for_width_or_precision (const HOST_WIDE_INT[2],\n \t\t\t\t\t    tree = NULL_TREE,\n \t\t\t\t\t    unsigned = 0, unsigned = 0);\n \n   /* Return the maximum number of decimal digits a value of TYPE\n      formats as on output.  */\n-  static unsigned type_max_digits (tree type, int base);\n+  static unsigned type_max_digits (tree, int);\n \n   /* The range a directive's argument is in.  */\n   tree argmin, argmax;\n@@ -504,32 +504,21 @@ struct fmtresult\n   bool nullp;\n };\n \n-/* Adjust result upward to reflect the value SCALAR_ADJUST the specified\n-   width or precision is known to have.  When non-null, TYPE denotes the\n-   type of the directive whose result is being adjusted, BASE gives the\n-   base of the directive (octal, decimal, or hex), and ADJ denotes\n-   the additional adjustment to the LIKELY counter that may need to be\n-   added when SCALAR_ADJUST represents a range.  */\n+/* Adjust result upward to reflect the range ADJUST of values the\n+   specified width or precision is known to be in.  When non-null,\n+   TYPE denotes the type of the directive whose result is being\n+   adjusted, BASE gives the base of the directive (octal, decimal,\n+   or hex), and ADJ denotes the additional adjustment to the LIKELY\n+   counter that may need to be added when ADJUST is a range.  */\n \n fmtresult&\n-fmtresult::adjust_for_width_or_precision (HOST_WIDE_INT scalar_adjust,\n+fmtresult::adjust_for_width_or_precision (const HOST_WIDE_INT adjust[2],\n \t\t\t\t\t  tree type /* = NULL_TREE */,\n \t\t\t\t\t  unsigned base /* = 0 */,\n \t\t\t\t\t  unsigned adj /* = 0 */)\n {\n   bool minadjusted = false;\n \n-  /* Translate SCALAR_ADJUST to a \"fake\" range until width and precision\n-     ranges are handled.  */\n-  HOST_WIDE_INT adjust[2];\n-  if (scalar_adjust == HOST_WIDE_INT_MIN)\n-    {\n-      adjust[0] = -1;\n-      adjust[1] = target_int_max () + 1;\n-    }\n-  else\n-    adjust[0] = adjust[1] = scalar_adjust;\n-\n   /* Adjust the minimum and likely counters.  */\n   if (0 <= adjust[0])\n     {\n@@ -609,7 +598,12 @@ fmtresult::type_max_digits (tree type, int base)\n   return prec * 301 / 1000 + 1;\n }\n \n-/* Description of a format directive.  */\n+static bool\n+get_int_range (tree, tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t       bool, HOST_WIDE_INT);\n+\n+/* Description of a format directive.  A directive is either a plain\n+   string or a conversion specification that starts with '%'.  */\n \n struct directive\n {\n@@ -623,10 +617,11 @@ struct directive\n   /* A bitmap of flags, one for each character.  */\n   unsigned flags[256 / sizeof (int)];\n \n-  /* The specified width, or -1 if not specified.  */\n-  HOST_WIDE_INT width;\n-  /* The specified precision, or -1 if not specified.  */\n-  HOST_WIDE_INT prec;\n+  /* The range of values of the specified width, or -1 if not specified.  */\n+  HOST_WIDE_INT width[2];\n+  /* The range of values of the specified precision, or -1 if not\n+     specified.  */\n+  HOST_WIDE_INT prec[2];\n \n   /* Length modifier.  */\n   format_lengths modifier;\n@@ -666,54 +661,36 @@ struct directive\n       &= ~(1U << (c % (CHAR_BIT * sizeof *flags)));\n   }\n \n-  /* Set the width to VAL.  */\n+  /* Set both bounds of the width range to VAL.  */\n   void set_width (HOST_WIDE_INT val)\n   {\n-    width = val;\n+    width[0] = width[1] = val;\n   }\n \n-  /* Set the width to ARG.  */\n+  /* Set the width range according to ARG, with both bounds being\n+     no less than 0.  For a constant ARG set both bounds to its value\n+     or 0, whichever is greater.  For a non-constant ARG in some range\n+     set width to its range adjusting each bound to -1 if it's less.\n+     For an indeterminate ARG set width to [0, INT_MAX].  */\n   void set_width (tree arg)\n   {\n-    if (tree_fits_shwi_p (arg))\n-      {\n-\twidth = tree_to_shwi (arg);\n-\tif (width < 0)\n-\t  {\n-\t    if (width == HOST_WIDE_INT_MIN)\n-\t      {\n-\t\t/* Avoid undefined behavior due to negating a minimum.\n-\t\t   This case will be diagnosed since it will result in\n-\t\t   more than INT_MAX bytes on output, either by the\n-\t\t   directive itself (when INT_MAX < HOST_WIDE_INT_MAX)\n-\t\t   or by the format function itself.  */\n-\t\twidth = HOST_WIDE_INT_MAX;\n-\t      }\n-\t    else\n-\t      width = -width;\n-\t  }\n-      }\n-    else\n-      width = HOST_WIDE_INT_MIN;\n+    get_int_range (arg, integer_type_node, width, width + 1, true, 0);\n   }\n \n-  /* Set the precision to val.  */\n+  /* Set both bounds of the precision range to VAL.  */\n   void set_precision (HOST_WIDE_INT val)\n   {\n-    prec = val;\n+    prec[0] = prec[1] = val;\n   }\n \n-  /* Set the precision to ARG.  */\n+  /* Set the precision range according to ARG, with both bounds being\n+     no less than -1.  For a constant ARG set both bounds to its value\n+     or -1 whichever is greater.  For a non-constant ARG in some range\n+     set precision to its range adjusting each bound to -1 if it's less.\n+     For an indeterminate ARG set precision to [-1, INT_MAX].  */\n   void set_precision (tree arg)\n   {\n-    if (tree_fits_shwi_p (arg))\n-      {\n-\tprec = tree_to_shwi (arg);\n-\tif (prec < 0)\n-\t  prec = -1;\n-      }\n-    else\n-      prec = HOST_WIDE_INT_MIN;\n+    get_int_range (arg, integer_type_node, prec, prec + 1, false, -1);\n   }\n };\n \n@@ -797,7 +774,7 @@ tree_digits (tree x, int base, HOST_WIDE_INT prec, bool plus, bool prefix)\n }\n \n /* Given the formatting result described by RES and NAVAIL, the number\n-   of available in the destination, return the number of bytes remaining\n+   of available in the destination, return the range of bytes remaining\n    in the destination.  */\n \n static inline result_range\n@@ -816,9 +793,6 @@ bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n      minus the minimum.  */\n   range.max = res.range.min < navail ? navail - res.range.min : 0;\n \n-  /* Given the formatting result described by RES and NAVAIL, the number\n-     of available in the destination, return the minimum number of bytes\n-     remaining in the destination.  */\n   range.likely = res.range.likely < navail ? navail - res.range.likely : 0;\n \n   if (res.range.max < HOST_WIDE_INT_MAX)\n@@ -941,6 +915,96 @@ build_intmax_type_nodes (tree *pintmax, tree *puintmax)\n     }\n }\n \n+/* Determine the range [*PMIN, *PMAX] that the expression ARG of TYPE\n+   is in.  Return true when the range is a subrange of that of TYPE.\n+   Whn ARG is null it is as if it had the full range of TYPE.\n+   When ABSOLUTE is true the range reflects the absolute value of\n+   the argument.  When ABSOLUTE is false, negative bounds of\n+   the determined range are replaced with NEGBOUND.  */\n+\n+static bool\n+get_int_range (tree arg, tree type, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n+\t       bool absolute, HOST_WIDE_INT negbound)\n+{\n+  bool knownrange = false;\n+\n+  if (!arg)\n+    {\n+      *pmin = (TYPE_UNSIGNED (type)\n+\t       ? tree_to_uhwi (TYPE_MIN_VALUE (type))\n+\t       : tree_to_shwi (TYPE_MIN_VALUE (type)));\n+      *pmax = tree_to_uhwi (TYPE_MAX_VALUE (type));\n+    }\n+  else if (TREE_CODE (arg) == INTEGER_CST)\n+    {\n+      /* For a constant argument return its value adjusted as specified\n+\t by NEGATIVE and NEGBOUND and return true to indicate that the\n+\t result is known.  */\n+      *pmin = tree_fits_shwi_p (arg) ? tree_to_shwi (arg) : tree_to_uhwi (arg);\n+      *pmax = *pmin;\n+      knownrange = true;\n+    }\n+  else\n+    {\n+      /* True if the argument's range cannot be determined.  */\n+      bool unknown = true;\n+\n+      type = TREE_TYPE (arg);\n+\n+      if (TREE_CODE (arg) == SSA_NAME\n+\t  && TREE_CODE (type) == INTEGER_TYPE)\n+\t{\n+\t  /* Try to determine the range of values of the integer argument.  */\n+\t  wide_int min, max;\n+\t  enum value_range_type range_type = get_range_info (arg, &min, &max);\n+\t  if (range_type == VR_RANGE)\n+\t    {\n+\t      HOST_WIDE_INT type_min\n+\t\t= (TYPE_UNSIGNED (type)\n+\t\t   ? tree_to_uhwi (TYPE_MIN_VALUE (type))\n+\t\t   : tree_to_shwi (TYPE_MIN_VALUE (type)));\n+\n+\t      HOST_WIDE_INT type_max = tree_to_uhwi (TYPE_MAX_VALUE (type));\n+\n+\t      *pmin = min.to_shwi ();\n+\t      *pmax = max.to_shwi ();\n+\n+\t      /* Return true if the adjusted range is a subrange of\n+\t\t the full range of the argument's type.  */\n+\t      knownrange = type_min < *pmin || *pmax < type_max;\n+\n+\t      unknown = false;\n+\t    }\n+\t}\n+\n+      /* Handle an argument with an unknown range as if none had been\n+\t provided.  */\n+      if (unknown)\n+\treturn get_int_range (NULL_TREE, type, pmin, pmax, absolute, negbound);\n+    }\n+\n+  /* Adjust each bound as specified by ABSOLUTE and NEGBOUND.  */\n+  if (absolute)\n+    {\n+      if (*pmin < 0)\n+\t{\n+\t  if (*pmin == *pmax)\n+\t    *pmin = *pmax = -*pmin;\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT tmp = -*pmin;\n+\t      *pmin = 0;\n+\t      if (*pmax < tmp)\n+\t\t*pmax = tmp;\n+\t    }\n+\t}\n+    }\n+  else if (*pmin < negbound)\n+    *pmin = negbound;\n+\n+  return knownrange;\n+}\n+\n /* With the range [*ARGMIN, *ARGMAX] of an integer directive's actual\n    argument, due to the conversion from either *ARGMIN or *ARGMAX to\n    the type of the directive's formal argument it's possible for both\n@@ -1005,8 +1069,9 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the directive DIR will write on output for the integer argument\n-   ARG when non-null.  ARG may be null (for vararg functions).  */\n+   that the format directive DIR will output for any argument given\n+   the WIDTH and PRECISION (extracted from DIR).  This function is\n+   used when the directive argument or its value isn't known.  */\n \n static fmtresult\n format_integer (const directive &dir, tree arg)\n@@ -1118,11 +1183,9 @@ format_integer (const directive &dir, tree arg)\n     {\n       /* When a constant argument has been provided use its value\n \t rather than type to determine the length of the output.  */\n-\n       fmtresult res;\n \n-      if ((dir.prec == HOST_WIDE_INT_MIN || dir.prec == 0)\n-\t  && integer_zerop (arg))\n+      if ((dir.prec[0] <= 0 && dir.prec[1] >= 0) && integer_zerop (arg))\n \t{\n \t  /* As a special case, a precision of zero with a zero argument\n \t     results in zero bytes except in base 8 when the '#' flag is\n@@ -1132,7 +1195,7 @@ format_integer (const directive &dir, tree arg)\n \t     effect).  This must extend to the case of a specified precision\n \t     with an unknown value because it can be zero.  */\n \t  res.range.min = ((base == 8 && dir.get_flag ('#')) || maybesign);\n-\t  if (res.range.min == 0 && dir.prec == HOST_WIDE_INT_MIN)\n+\t  if (res.range.min == 0 && dir.prec[0] != dir.prec[1])\n \t    {\n \t      res.range.max = 1;\n \t      res.range.likely = 1;\n@@ -1148,17 +1211,13 @@ format_integer (const directive &dir, tree arg)\n \t  /* Convert the argument to the type of the directive.  */\n \t  arg = fold_convert (dirtype, arg);\n \n-\t  res.range.min = tree_digits (arg, base, dir.prec,\n+\t  res.range.min = tree_digits (arg, base, dir.prec[0],\n \t\t\t\t       maybesign, maybebase);\n-\n-\t  /* Set the maximum to INT_MAX when precision is specified\n-\t     but unknown (because it can be as large as that) otherwise\n-\t     to the minimum and have it adjusted below.  */\n-\t  if (dir.prec == HOST_WIDE_INT_MIN)\n-\t    res.range.max = target_int_max ();\n-\t  else\n+\t  if (dir.prec[0] == dir.prec[1])\n \t    res.range.max = res.range.min;\n-\n+\t  else\n+\t    res.range.max = tree_digits (arg, base, dir.prec[1],\n+\t\t\t\t\t maybesign, maybebase);\n \t  res.range.likely = res.range.min;\n \t}\n \n@@ -1170,6 +1229,7 @@ format_integer (const directive &dir, tree arg)\n       /* Bump up the counters again if PRECision is greater still.  */\n       res.adjust_for_width_or_precision (dir.prec, dirtype, base,\n \t\t\t\t\t (sign | maybebase) + (base == 16));\n+\n       return res;\n     }\n   else if (TREE_CODE (TREE_TYPE (arg)) == INTEGER_TYPE\n@@ -1254,7 +1314,7 @@ format_integer (const directive &dir, tree arg)\n \t can output.  When precision may be zero, use zero as the minimum\n \t since it results in no bytes on output (unless width is specified\n \t to be greater than 0).  */\n-      bool zero = dir.prec == 0 || dir.prec == HOST_WIDE_INT_MIN;\n+      bool zero = dir.prec[0] <= 0 && dir.prec[1] >= 0;\n       argmin = build_int_cst (argtype, !zero);\n \n       int typeprec = TYPE_PRECISION (dirtype);\n@@ -1438,16 +1498,15 @@ format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n      round-to-nearest mode.  */\n   mpfr_t x;\n   mpfr_init2 (x, rfmt->p);\n-  mpfr_from_real (x, &rv, GMP_RNDN);\n+  mpfr_from_real (x, &rv, MPFR_RNDN);\n \n   /* Return a value one greater to account for the leading minus sign.  */\n   return 1 + get_mpfr_format_length (x, \"\", prec, spec, 'D');\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the format directive DIR will output for any argument given\n-   the WIDTH and PRECISION (extracted from DIR).  This function is\n-   used when the directive argument or its value isn't known.  */\n+   that the directive DIR will output for any argument.  This function\n+   is used when the directive argument or its value isn't known.  */\n \n static fmtresult\n format_floating (const directive &dir)\n@@ -1493,28 +1552,26 @@ format_floating (const directive &dir)\n     case 'a':\n       {\n \tHOST_WIDE_INT minprec = 6 + !radix /* decimal point */;\n-\tif (dir.prec <= 0)\n+\tif (dir.prec[0] <= 0)\n \t  minprec = 0;\n-\telse if (dir.prec > 0)\n-\t  minprec = dir.prec + !radix /* decimal point */;\n+\telse if (dir.prec[0] > 0)\n+\t  minprec = dir.prec[0] + !radix /* decimal point */;\n \n \tres.range.min = (2 /* 0x */\n \t\t\t + flagmin\n \t\t\t + radix\n \t\t\t + minprec\n \t\t\t + 3 /* p+0 */);\n \n-\tHOST_WIDE_INT maxprec\n-\t  = dir.prec == HOST_WIDE_INT_MIN ? target_int_max () : dir.prec;\n-\tres.range.max = format_floating_max (type, 'a', maxprec);\n+\tres.range.max = format_floating_max (type, 'a', dir.prec[1]);\n \tres.range.likely = res.range.min;\n \n \t/* The unlikely maximum accounts for the longest multibyte\n \t   decimal point character.  */\n-\tif (dir.prec != 0)\n-\t  res.range.unlikely = res.range.max + target_mb_len_max () - 1;\n-\telse\n-\t  res.range.unlikely = res.range.max;\n+\tres.range.unlikely = res.range.max;\n+\tif (dir.prec[0] != dir.prec[1]\n+\t    || dir.prec[0] == -1 || dir.prec[0] > 0)\n+\t  res.range.unlikely += target_mb_len_max () - 1;\n \n \tbreak;\n       }\n@@ -1525,28 +1582,26 @@ format_floating (const directive &dir)\n \t/* The minimum output is \"[-+]1.234567e+00\" regardless\n \t   of the value of the actual argument.  */\n \tHOST_WIDE_INT minprec = 6 + !radix /* decimal point */;\n-\tif (dir.prec == HOST_WIDE_INT_MIN || dir.prec == 0)\n+\tif ((dir.prec[0] < 0 && dir.prec[1] > -1) || dir.prec[0] == 0)\n \t  minprec = 0;\n-\telse if (dir.prec > 0)\n-\t  minprec = dir.prec + !radix /* decimal point */;\n+\telse if (dir.prec[0] > 0)\n+\t  minprec = dir.prec[0] + !radix /* decimal point */;\n \n \tres.range.min = (flagmin\n \t\t\t + radix\n \t\t\t + minprec\n \t\t\t + 2 /* e+ */ + 2);\n-\n \t/* MPFR uses a precision of 16 by default for some reason.\n \t   Set it to the C default of 6.  */\n-\tHOST_WIDE_INT maxprec\n-\t  = (dir.prec == HOST_WIDE_INT_MIN ? target_int_max ()\n-\t     : dir.prec < 0 ? 6 : dir.prec);\n+\tint maxprec = dir.prec[1] < 0 ? 6 : dir.prec[1];\n \tres.range.max = format_floating_max (type, 'e', maxprec);\n \n \tres.range.likely = res.range.min;\n \n \t/* The unlikely maximum accounts for the longest multibyte\n \t   decimal point character.  */\n-\tif (dir.prec != 0)\n+\tif (dir.prec[0] != dir.prec[1]\n+\t    || dir.prec[0] == -1 || dir.prec[0] > 0)\n \t  res.range.unlikely = res.range.max + target_mb_len_max () -1;\n \telse\n \t  res.range.unlikely = res.range.max;\n@@ -1562,25 +1617,22 @@ format_floating (const directive &dir)\n \t   when precision is greater than zero, then the lower bound\n \t   is 2 plus precision (plus flags).  */\n \tHOST_WIDE_INT minprec = 0;\n-\tif (dir.prec == HOST_WIDE_INT_MIN)\n-\t  minprec = 0;\n-\telse if (dir.prec < 0)\n-\t  minprec = 6 + !radix /* decimal point */;\n-\telse if (dir.prec)\n-\t  minprec = dir.prec + !radix /* decimal point */;\n+\tif (dir.prec[0] < 0)\n+\t  minprec = dir.prec[1] < 0 ? 6 + !radix /* decimal point */ : 0;\n+\telse if (dir.prec[0])\n+\t  minprec = dir.prec[0] + !radix /* decimal point */;\n \n \tres.range.min = flagmin + radix + minprec;\n \n \t/* Compute the upper bound for -TYPE_MAX.  */\n-\tHOST_WIDE_INT maxprec\n-\t  = dir.prec == HOST_WIDE_INT_MIN ? target_int_max () : dir.prec;\n-\tres.range.max = format_floating_max (type, 'f', maxprec);\n+\tres.range.max = format_floating_max (type, 'f', dir.prec[1]);\n \n \tres.range.likely = res.range.min;\n \n \t/* The unlikely maximum accounts for the longest multibyte\n \t   decimal point character.  */\n-\tif (dir.prec != 0)\n+\tif (dir.prec[0] != dir.prec[1]\n+\t    || dir.prec[0] == -1 || dir.prec[0] > 0)\n \t  res.range.unlikely = res.range.max + target_mb_len_max () - 1;\n \tbreak;\n       }\n@@ -1593,10 +1645,7 @@ format_floating (const directive &dir)\n \t   the lower bound on the range of bytes (not counting flags\n \t   or width) is 1.  */\n \tres.range.min = flagmin;\n-\n-\tHOST_WIDE_INT maxprec\n-\t  = dir.prec == HOST_WIDE_INT_MIN ? target_int_max () : dir.prec;\n-\tres.range.max = format_floating_max (type, 'g', maxprec);\n+\tres.range.max = format_floating_max (type, 'g', dir.prec[1]);\n \tres.range.likely = res.range.max;\n \n \t/* The unlikely maximum accounts for the longest multibyte\n@@ -1611,21 +1660,20 @@ format_floating (const directive &dir)\n \n   /* Bump up the byte counters if WIDTH is greater.  */\n   res.adjust_for_width_or_precision (dir.width);\n-\n   return res;\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the conversion specification DIR will write on output for the\n-   floating argument ARG.  */\n+   that the directive DIR will write on output for the floating argument\n+   ARG.  */\n \n static fmtresult\n format_floating (const directive &dir, tree arg)\n {\n   if (!arg || TREE_CODE (arg) != REAL_CST)\n     return format_floating (dir);\n \n-  HOST_WIDE_INT prec[] = { dir.prec, dir.prec };\n+  HOST_WIDE_INT prec[] = { dir.prec[0], dir.prec[1] };\n \n   if (TOUPPER (dir.specifier) == 'A')\n     {\n@@ -1724,7 +1772,6 @@ format_floating (const directive &dir, tree arg)\n     }\n \n   res.adjust_for_width_or_precision (dir.width);\n-\n   return res;\n }\n \n@@ -1815,35 +1862,40 @@ format_character (const directive &dir, tree arg)\n \n   if (dir.modifier == FMT_LEN_l)\n     {\n-      unsigned HOST_WIDE_INT val;\n-\n-      if (arg && TREE_CODE (arg) == INTEGER_CST && tree_fits_shwi_p (arg))\n-\tval = tree_to_shwi (arg);\n-      else\n-\tval = HOST_WIDE_INT_MAX;\n-\n       /* A wide character can result in as few as zero bytes.  */\n       res.range.min = 0;\n \n-      if (val == 0)\n-\t{\n-\t  /* The NUL wide character results in no bytes.  */\n-\t  res.range.max = 0;\n-\t  res.range.likely = 0;\n-\t  res.range.unlikely = 0;\n-\t}\n-      else if (0 < val && val < 128)\n+      HOST_WIDE_INT min, max;\n+      if (get_int_range (arg, integer_type_node, &min, &max, false, 0))\n \t{\n-\t  /* A wide character in the ASCII range most likely results\n-\t     in a single byte, and only unlikely in up to MB_LEN_MAX.  */\n-\t  res.range.max = 1;\n-\t  res.range.likely = 1;\n-\t  res.range.unlikely = target_mb_len_max ();\n+\t  if (min == 0 && max == 0)\n+\t    {\n+\t      /* The NUL wide character results in no bytes.  */\n+\t      res.range.max = 0;\n+\t      res.range.likely = 0;\n+\t      res.range.unlikely = 0;\n+\t    }\n+\t  else if (0 < min && min < 128)\n+\t    {\n+\t      /* A wide character in the ASCII range most likely results\n+\t\t in a single byte, and only unlikely in up to MB_LEN_MAX.  */\n+\t      res.range.max = 1;\n+\t      res.range.likely = 1;\n+\t      res.range.unlikely = target_mb_len_max ();\n+\t    }\n+\t  else\n+\t    {\n+\t      /* A wide character outside the ASCII range likely results\n+\t\t in up to two bytes, and only unlikely in up to MB_LEN_MAX.  */\n+\t      res.range.max = target_mb_len_max ();\n+\t      res.range.likely = 2;\n+\t      res.range.unlikely = res.range.max;\n+\t    }\n \t}\n       else\n \t{\n-\t  /* A wide character outside the ASCII range likely results\n-\t     in up to two bytes, and only unlikely in up to MB_LEN_MAX.  */\n+\t  /* An unknown wide character is treated the same as a wide\n+\t     character outside the ASCII range.  */\n \t  res.range.max = target_mb_len_max ();\n \t  res.range.likely = 2;\n \t  res.range.unlikely = res.range.max;\n@@ -1853,7 +1905,7 @@ format_character (const directive &dir, tree arg)\n     {\n       /* A plain '%c' directive.  Its ouput is exactly 1.  */\n       res.range.min = res.range.max = 1;\n-      res.range.likely = res.range.unlikely = res.range.min;\n+      res.range.likely = res.range.unlikely = 1;\n       res.knownrange = true;\n     }\n \n@@ -1862,9 +1914,9 @@ format_character (const directive &dir, tree arg)\n }\n \n /* Return the minimum and maximum number of characters formatted\n-   by the '%c' and '%s' format directives and ther wide character\n-   forms for the argument ARG.  ARG can be null (for functions\n-   such as vsprinf).  */\n+   by the '%s' format directive and its wide character form for\n+   the argument ARG.  ARG can be null (for functions such as\n+   vsprinf).  */\n \n static fmtresult\n format_string (const directive &dir, tree arg)\n@@ -1892,18 +1944,19 @@ format_string (const directive &dir, tree arg)\n \t     2 * wcslen (S).*/\n \t  res.range.likely = res.range.min * 2;\n \n-\t  /* For a wide character string, use precision as the maximum\n-\t     even if precision is greater than the string length since\n-\t     the number of bytes the string converts to may be greater\n-\t     (due to MB_CUR_MAX).  */\n-\t  if (0 <= dir.prec\n-\t      && (unsigned HOST_WIDE_INT)dir.prec < res.range.max)\n+\t  if (0 <= dir.prec[1]\n+\t      && (unsigned HOST_WIDE_INT)dir.prec[1] < res.range.max)\n \t    {\n-\t      res.range.max = dir.prec;\n-\t      res.range.likely = dir.prec;\n-\t      res.range.unlikely = dir.prec;\n+\t      res.range.max = dir.prec[1];\n+\t      res.range.likely = dir.prec[1];\n+\t      res.range.unlikely = dir.prec[1];\n \t    }\n \n+\t  if (dir.prec[0] < 0 && dir.prec[1] > -1)\n+\t    res.range.min = 0;\n+\t  else if (0 <= dir.prec[0])\n+\t    res.range.likely = dir.prec[0];\n+\n \t  /* Even a non-empty wide character string need not convert into\n \t     any bytes.  */\n \t  res.range.min = 0;\n@@ -1912,20 +1965,16 @@ format_string (const directive &dir, tree arg)\n \t{\n \t  res.knownrange = true;\n \n-\t  if (dir.prec == HOST_WIDE_INT_MIN)\n+\t  if (dir.prec[0] < 0 && dir.prec[1] > -1)\n \t    res.range.min = 0;\n-\t  else if ((unsigned HOST_WIDE_INT)dir.prec < res.range.min)\n-\t    {\n-\t      res.range.min = dir.prec;\n-\t      res.range.max = dir.prec;\n-\t      res.range.likely = dir.prec;\n-\t      res.range.unlikely = dir.prec;\n-\t    }\n-\t  else if ((unsigned HOST_WIDE_INT)dir.prec < res.range.max)\n+\t  else if ((unsigned HOST_WIDE_INT)dir.prec[0] < res.range.min)\n+\t    res.range.min = dir.prec[0];\n+\n+\t  if ((unsigned HOST_WIDE_INT)dir.prec[1] < res.range.max)\n \t    {\n-\t      res.range.max = dir.prec;\n-\t      res.range.likely = dir.prec;\n-\t      res.range.unlikely = dir.prec;\n+\t      res.range.max = dir.prec[1];\n+\t      res.range.likely = dir.prec[1];\n+\t      res.range.unlikely = dir.prec[1];\n \t    }\n \t}\n     }\n@@ -1945,20 +1994,20 @@ format_string (const directive &dir, tree arg)\n \t in mode 2, and the maximum is PRECISION or -1 to disable\n \t tracking.  */\n \n-      if (0 <= dir.prec)\n+      if (0 <= dir.prec[0])\n \t{\n \t  if (slen.range.min >= target_int_max ())\n \t    slen.range.min = 0;\n-\t  else if ((unsigned HOST_WIDE_INT)dir.prec < slen.range.min)\n+\t  else if ((unsigned HOST_WIDE_INT)dir.prec[0] < slen.range.min)\n \t    {\n-\t      slen.range.min = dir.prec;\n+\t      slen.range.min = dir.prec[0];\n \t      slen.range.likely = slen.range.min;\n \t    }\n \n-\t  if ((unsigned HOST_WIDE_INT)dir.prec < slen.range.max\n+\t  if ((unsigned HOST_WIDE_INT)dir.prec[1] < slen.range.max\n \t      || slen.range.max >= target_int_max ())\n \t    {\n-\t      slen.range.max = dir.prec;\n+\t      slen.range.max = dir.prec[1];\n \t      slen.range.likely = slen.range.max;\n \t    }\n \t}\n@@ -2357,35 +2406,32 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t  avail_range.min, avail_range.max);\n }\n \n-/* Compute the length of the output resulting from the conversion\n-   specification DIR with the argument ARG in a call described by INFO\n-   and update the overall result of the call in *RES.  The format directive\n-   corresponding to DIR starts at CVTBEG and is CVTLEN characters long.  */\n+/* Compute the length of the output resulting from the directive DIR\n+   in a call described by INFO and update the overall result of the call\n+   in *RES.  Return true if the directive has been handled.  */\n \n static bool\n format_directive (const pass_sprintf_length::call_info &info,\n \t\t  format_result *res, const directive &dir)\n {\n-  const char *cvtbeg = dir.beg;\n-  size_t cvtlen = dir.len;\n-  tree arg = dir.arg;\n-\n   /* Offset of the beginning of the directive from the beginning\n      of the format string.  */\n-  size_t offset = cvtbeg - info.fmtstr;\n+  size_t offset = dir.beg - info.fmtstr;\n+  size_t start = offset;\n+  size_t length = offset + dir.len - !!dir.len;\n \n   /* Create a location for the whole directive from the % to the format\n      specifier.  */\n   substring_loc dirloc (info.fmtloc, TREE_TYPE (info.format),\n-\t\t\toffset, offset, offset + cvtlen - 1);\n+\t\t\toffset, start, length);\n \n   /* Also create a location range for the argument if possible.\n      This doesn't work for integer literals or function calls.  */\n   source_range argrange;\n   source_range *pargrange;\n-  if (arg && CAN_HAVE_LOCATION_P (arg))\n+  if (dir.arg && CAN_HAVE_LOCATION_P (dir.arg))\n     {\n-      argrange = EXPR_LOCATION_RANGE (arg);\n+      argrange = EXPR_LOCATION_RANGE (dir.arg);\n       pargrange = &argrange;\n     }\n   else\n@@ -2396,8 +2442,8 @@ format_directive (const pass_sprintf_length::call_info &info,\n   if (!dir.fmtfunc || res->range.min >= HOST_WIDE_INT_MAX)\n     return false;\n \n-  /* Compute the (approximate) length of the formatted output.  */\n-  fmtresult fmtres = dir.fmtfunc (dir, arg);\n+  /* Compute the range of lengths of the formatted output.  */\n+  fmtresult fmtres = dir.fmtfunc (dir, dir.arg);\n \n   /* Record whether the output of all directives is known to be\n      bounded by some maximum, implying that their arguments are\n@@ -2525,7 +2571,6 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t}\n     }\n \n-  /* Has the minimum directive output length exceeded INT_MAX?  */\n   /* Has the likely and maximum directive output exceeded INT_MAX?  */\n   bool likelyximax = *dir.beg && res->range.likely > target_int_max ();\n   bool maxximax = *dir.beg && res->range.max > target_int_max ();\n@@ -2949,7 +2994,8 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t{\n \t  /* Width specified by a va_list takes on the range [0, -INT_MIN]\n \t     (width is the absolute value of that specified).  */\n-\t  dir.width = HOST_WIDE_INT_MIN;\n+\t  dir.width[0] = 0;\n+\t  dir.width[1] = target_int_max () + 1;\n \t}\n     }\n   else\n@@ -2963,7 +3009,8 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t{\n \t  /* Precision specified by a va_list takes on the range [-1, INT_MAX]\n \t     (unlike width, negative precision is ignored).  */\n-\t  dir.prec = HOST_WIDE_INT_MIN;\n+\t  dir.prec[0] = -1;\n+\t  dir.prec[1] = target_int_max ();\n \t}\n     }\n   else\n@@ -2986,11 +3033,22 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t       dir.dirno, (size_t)(dir.beg - info.fmtstr),\n \t       (int)dir.len, dir.beg);\n       if (star_width)\n-\tfprintf (dump_file, \", width = %lli\", (long long)dir.width);\n+\t{\n+\t  if (dir.width[0] == dir.width[1])\n+\t    fprintf (dump_file, \", width = %lli\", (long long)dir.width[0]);\n+\t  else\n+\t    fprintf (dump_file, \", width in range [%lli, %lli]\",\n+\t\t     (long long)dir.width[0], (long long)dir.width[1]);\n+\t}\n \n       if (star_precision)\n-\tfprintf (dump_file, \", precision = %lli\", (long long)dir.prec);\n-\n+\t{\n+\t  if (dir.prec[0] == dir.prec[1])\n+\t    fprintf (dump_file, \", precision = %lli\", (long long)dir.prec[0]);\n+\t  else\n+\t    fprintf (dump_file, \", precision in range [%lli, %lli]\",\n+\t\t     (long long)dir.prec[0], (long long)dir.prec[1]);\n+\t}\n       fputc ('\\n', dump_file);\n     }\n \n@@ -3019,7 +3077,7 @@ pass_sprintf_length::compute_format_length (call_info &info,\n \t       (unsigned long long)info.objsize, info.fmtstr);\n     }\n \n-  /* Reset the minimum and maximum bytes counters.  */\n+  /* Reset the minimum and maximum byte counters.  */\n   res->range.min = res->range.max = 0;\n \n   /* No directive has been seen yet so the length of output is bounded"}, {"sha": "0bf4dfb01eb002487f9f2c94e5cb1719bb6d0471", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=31c87a433cdbec856c6ed840482ef638ac8fc565", "patch": "@@ -1,3 +1,11 @@\n+2017-01-26  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78703\n+\t* gcc.dg/tree-ssa/builtin-snprintf-warn-1.c: Update\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: Rename...\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-10.c: ...to this.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: New test.\n+\n 2017-01-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/79129"}, {"sha": "3a6586b87685e5ff5bca5e0ff549003f884ec62b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-warn-1.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-1.c?ref=31c87a433cdbec856c6ed840482ef638ac8fc565", "patch": "@@ -4,6 +4,9 @@\n typedef struct\n {\n   char a0[0];\n+  /* Separate a0 from a1 to prevent the former from being substituted\n+     for the latter and causing false positives.  */\n+  int: 8;\n   char a1[1];\n   char a2[2];\n   char a3[3];\n@@ -23,11 +26,13 @@ int value_range (int min, int max)\n \n #define R(min, max)  value_range (min, max)\n \n+extern void sink (void*);\n+\n /* Verify that calls to snprintf whose return value is unused are\n    diagnosed if certain or possible truncation is detected.  */\n \n #define T(size, ...) \\\n-  __builtin_snprintf (buffer (size), size, __VA_ARGS__)\n+  __builtin_snprintf (buffer (size), size, __VA_ARGS__), sink (buffer)\n \n void test_int_retval_unused (void)\n {\n@@ -39,9 +44,20 @@ void test_int_retval_unused (void)\n \n void test_string_retval_unused (const Arrays *ar)\n {\n+  /* At level 1 strings of unknown length are assumed to be empty so\n+     the following is not diagnosed.  */\n   T (1, \"%-s\", ar->a0);\n+  /* A one-byte array can only hold an empty string, so the following\n+     isn't diagnosed.  */\n   T (1, \"%-s\", ar->a1);\n-  T (1, \"%-s\", ar->a2);   /* { dg-warning \"output may be truncated\" } */\n+  /* Unlike the ar->a0 case above, at level 1, the length of an unknown\n+     string that points to an array of known size is assumed to be the\n+     size of the array minus 1.  */\n+  T (1, \"%-s\", ar->a2);      /* { dg-warning \"output may be truncated\" } */\n+  T (1, \"%-s\", ar->a3);      /* { dg-warning \"output may be truncated\" } */\n+  T (1, \"%-s\", ar->a4);      /* { dg-warning \"output may be truncated\" } */\n+  /* Same as the ar->a0 case above.  */\n+  T (1, \"%-s\", ar->ax);\n }\n \n \n@@ -68,6 +84,7 @@ void test_string_retval_used (const Arrays *ar)\n   T (1, \"%-s\", ar->a0);\n   T (1, \"%-s\", ar->a1);\n   T (1, \"%-s\", ar->a2);\n+  T (1, \"%-s\", ar->a3);\n   T (1, \"%-s\", ar->a4);\n   T (1, \"%-s\", \"123\");   /* { dg-warning \"output truncated\" } */\n }"}, {"sha": "5523acd7db176ffc6026e4192a641f540dfa2bf5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-10.c", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-10.c?ref=31c87a433cdbec856c6ed840482ef638ac8fc565", "patch": "@@ -0,0 +1,270 @@\n+/* 78696 - -fprintf-return-value misoptimizes %.Ng where N is greater than 10\n+   Test to verify the correctness of ranges of output computed for floating\n+   point directives.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wformat -Wformat-overflow -ftrack-macro-expansion=0\" } */\n+\n+typedef __builtin_va_list va_list;\n+\n+char dst[1];\n+\n+extern void sink (int, void*);\n+\n+/* Macro to test either width or precision specified by the asterisk\n+   (but not both).  */\n+#define T1(fmt, a)    sink (__builtin_sprintf (dst + 1, fmt, a, x), dst)\n+\n+/* Macro to test both width and precision specified by the asterisk.  */\n+#define T2(fmt, w, p) sink (__builtin_sprintf (dst + 1, fmt, w, p, x), dst)\n+\n+/* Macro to test vsprintf with both width and precision specified by\n+   the asterisk.  */\n+#define T(fmt) sink (__builtin_vsprintf (dst + 1, fmt, va), dst)\n+\n+/* Exercise %a.  */\n+void test_a (int w, int p, double x)\n+{\n+  T1 (\"%.*a\", 0);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%.*a\", 1);     /* { dg-warning \"between 8 and 12 bytes\" } */\n+  T1 (\"%.*a\", 2);     /* { dg-warning \"between 9 and 13 bytes\" } */\n+  T1 (\"%.*a\", 99);    /* { dg-warning \"between 106 and 110 bytes\" } */\n+  T1 (\"%.*a\", 199);   /* { dg-warning \"between 206 and 210 bytes\" } */\n+  T1 (\"%.*a\", 1099);  /* { dg-warning \"between 1106 and 1110 bytes\" } */\n+\n+  T1 (\"%*.a\", 0);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 1);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 3);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 6);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 7);     /* { dg-warning \"between 7 and 10 bytes\" } */\n+\n+  T1 (\"%*.a\", w);     /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T1 (\"%*.0a\", w);    /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T1 (\"%*.1a\", w);    /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n+  T1 (\"%*.2a\", w);    /* { dg-warning \"writing between 9 and 2147483648 bytes\" } */\n+\n+  T1 (\"%.*a\",  p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T1 (\"%1.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T1 (\"%2.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T1 (\"%3.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+\n+  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+}\n+\n+/* Exercise %e.  */\n+void test_e (int w, int p, double x)\n+{\n+  T1 (\"%.*e\", 0);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%.*e\", 1);     /* { dg-warning \"between 7 and 9 bytes\" } */\n+  T1 (\"%.*e\", 2);     /* { dg-warning \"between 8 and 10 bytes\" } */\n+  T1 (\"%.*e\", 99);    /* { dg-warning \"between 105 and 107 bytes\" } */\n+  T1 (\"%.*e\", 199);   /* { dg-warning \"between 205 and 207 bytes\" } */\n+  T1 (\"%.*e\", 1099);  /* { dg-warning \"between 1105 and 1107 bytes\" } */\n+\n+  T1 (\"%*.e\", 0);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 1);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 1);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 3);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 6);     /* { dg-warning \"between 6 and 7 bytes\" } */\n+  T1 (\"%*.e\", 7);     /* { dg-warning \"writing 7 bytes\" } */\n+\n+  T1 (\"%*.e\", w);     /* { dg-warning \"writing between 5 and 2147483648 bytes\" } */\n+  T1 (\"%*.0e\", w);    /* { dg-warning \"writing between 5 and 2147483648 bytes\" } */\n+  T1 (\"%*.1e\", w);    /* { dg-warning \"writing between 7 and 2147483648 bytes\" } */\n+  T1 (\"%*.2e\", w);    /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n+\n+  T1 (\"%.*e\",  p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T1 (\"%1.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T1 (\"%2.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T1 (\"%3.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+\n+  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+}\n+\n+/* Exercise %f.  */\n+void test_f (int w, int p, double x)\n+{\n+  T1 (\"%.*f\", 0);           /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T1 (\"%.*f\", 1);           /* { dg-warning \"between 3 and 312 bytes\" } */\n+  T1 (\"%.*f\", 2);           /* { dg-warning \"between 4 and 313 bytes\" } */\n+  T1 (\"%.*f\", 99);          /* { dg-warning \"between 101 and 410 bytes\" } */\n+  T1 (\"%.*f\", 199);         /* { dg-warning \"between 201 and 510 bytes\" } */\n+  T1 (\"%.*f\", 1099);        /* { dg-warning \"between 1101 and 1410 bytes\" } */\n+\n+  T2 (\"%*.*f\", 0, 0);       /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 1, 0);       /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 2, 0);       /* { dg-warning \"between 2 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 3, 0);       /* { dg-warning \"between 3 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 310, 0);     /* { dg-warning \"writing 310 bytes\" } */\n+  T2 (\"%*.*f\", 311, 0);     /* { dg-warning \"writing 311 bytes\" } */\n+  T2 (\"%*.*f\", 312, 312);   /* { dg-warning \"between 314 and 623 bytes\" } */\n+  T2 (\"%*.*f\", 312, 313);   /* { dg-warning \"between 315 and 624 bytes\" } */\n+\n+  T1 (\"%*.f\", w);           /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n+  T1 (\"%*.0f\", w);          /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n+  T1 (\"%*.1f\", w);          /* { dg-warning \"writing between 3 and 2147483648 bytes\" } */\n+  T1 (\"%*.2f\", w);          /* { dg-warning \"writing between 4 and 2147483648 bytes\" } */\n+\n+  T1 (\"%.*f\",  p);          /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T1 (\"%1.*f\", p);          /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T1 (\"%2.*f\", p);          /* { dg-warning \"writing between 2 and 2147483958 bytes\" } */\n+  T1 (\"%3.*f\", p);          /* { dg-warning \"writing between 3 and 2147483958 bytes\" } */\n+\n+  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+}\n+\n+/* Exercise %g.  The expected output is the lesser of %e and %f.  */\n+void test_g (double x)\n+{\n+  T1 (\"%.*g\", 0);           /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T1 (\"%.*g\", 1);           /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T1 (\"%.*g\", 2);           /* { dg-warning \"between 1 and 9 bytes\" } */\n+  T1 (\"%.*g\", 99);          /* { dg-warning \"between 1 and 106 bytes\" } */\n+  T1 (\"%.*g\", 199);         /* { dg-warning \"between 1 and 206 bytes\" } */\n+  T1 (\"%.*g\", 1099);        /* { dg-warning \"between 1 and 310 bytes\" } */\n+\n+  T2 (\"%*.*g\", 0, 0);       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 1, 0);       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 2, 0);       /* { dg-warning \"between 2 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 3, 0);       /* { dg-warning \"between 3 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 7, 0);       /* { dg-warning \"writing 7 bytes\" } */\n+  T2 (\"%*.*g\", 310, 0);     /* { dg-warning \"writing 310 bytes\" } */\n+  T2 (\"%*.*g\", 311, 0);     /* { dg-warning \"writing 311 bytes\" } */\n+  T2 (\"%*.*g\", 312, 312);   /* { dg-warning \"writing 312 bytes\" } */\n+  T2 (\"%*.*g\", 312, 313);   /* { dg-warning \"writing 312 bytes\" } */\n+  T2 (\"%*.*g\", 333, 999);   /* { dg-warning \"writing 333 bytes\" } */\n+}\n+\n+/* Exercise %a.  */\n+void test_a_va (va_list va)\n+{\n+  T (\"%.0a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%.1a\");       /* { dg-warning \"between 8 and 12 bytes\" } */\n+  T (\"%.2a\");       /* { dg-warning \"between 9 and 13 bytes\" } */\n+  T (\"%.99a\");      /* { dg-warning \"between 106 and 110 bytes\" } */\n+  T (\"%.199a\");     /* { dg-warning \"between 206 and 210 bytes\" } */\n+  T (\"%.1099a\");    /* { dg-warning \"between 1106 and 1110 bytes\" } */\n+\n+  T (\"%0.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%1.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%3.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%6.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%7.a\");       /* { dg-warning \"between 7 and 10 bytes\" } */\n+\n+  T (\"%*.a\");       /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T (\"%*.0a\");      /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T (\"%*.1a\");      /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n+  T (\"%*.2a\");      /* { dg-warning \"writing between 9 and 2147483648 bytes\" } */\n+\n+  T (\"%.*a\");       /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%1.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%2.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%6.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%9.*a\");      /* { dg-warning \"writing between 9 and 2147483658 bytes\" } */\n+\n+  T (\"%*.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+}\n+\n+/* Exercise %e.  */\n+void test_e_va (va_list va)\n+{\n+  T (\"%e\");         /* { dg-warning \"between 12 and 14 bytes\" } */\n+  T (\"%+e\");        /* { dg-warning \"between 13 and 14 bytes\" } */\n+  T (\"% e\");        /* { dg-warning \"between 13 and 14 bytes\" } */\n+  T (\"%#e\");        /* { dg-warning \"between 12 and 14 bytes\" } */\n+  T (\"%#+e\");       /* { dg-warning \"between 13 and 14 bytes\" } */\n+  T (\"%# e\");       /* { dg-warning \"between 13 and 14 bytes\" } */\n+\n+  T (\"%.e\");        /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%.0e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%.1e\");       /* { dg-warning \"between 7 and 9 bytes\" } */\n+  T (\"%.2e\");       /* { dg-warning \"between 8 and 10 bytes\" } */\n+  T (\"%.99e\");      /* { dg-warning \"between 105 and 107 bytes\" } */\n+  T (\"%.199e\");     /* { dg-warning \"between 205 and 207 bytes\" } */\n+  T (\"%.1099e\");    /* { dg-warning \"between 1105 and 1107 bytes\" } */\n+\n+  T (\"%0.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%1.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%1.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%3.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%6.e\");       /* { dg-warning \"between 6 and 7 bytes\" } */\n+  T (\"%7.e\");       /* { dg-warning \"writing 7 bytes\" } */\n+\n+  T (\"%.*e\");       /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T (\"%1.*e\");      /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T (\"%6.*e\");      /* { dg-warning \"writing between 6 and 2147483655 bytes\" } */\n+  T (\"%9.*e\");      /* { dg-warning \"writing between 9 and 2147483655 bytes\" } */\n+\n+  T (\"%*.*e\");      /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+}\n+\n+/* Exercise %f.  */\n+void test_f_va (va_list va)\n+{\n+  T (\"%f\");         /* { dg-warning \"between 8 and 317 bytes\" } */\n+  T (\"%+f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"% f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"%#f\");        /* { dg-warning \"between 8 and 317 bytes\" } */\n+  T (\"%+f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"% f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"%#+f\");       /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"%# f\");       /* { dg-warning \"between 9 and 317 bytes\" } */\n+\n+  T (\"%.f\");        /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%.0f\");       /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%.1f\");       /* { dg-warning \"between 3 and 312 bytes\" } */\n+  T (\"%.2f\");       /* { dg-warning \"between 4 and 313 bytes\" } */\n+  T (\"%.99f\");      /* { dg-warning \"between 101 and 410 bytes\" } */\n+  T (\"%.199f\");     /* { dg-warning \"between 201 and 510 bytes\" } */\n+  T (\"%.1099f\");    /* { dg-warning \"between 1101 and 1410 bytes\" } */\n+\n+  T (\"%0.0f\");      /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%1.0f\");      /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%2.0f\");      /* { dg-warning \"between 2 and 310 bytes\" } */\n+  T (\"%3.0f\");      /* { dg-warning \"between 3 and 310 bytes\" } */\n+  T (\"%310.0f\");    /* { dg-warning \"writing 310 bytes\" } */\n+  T (\"%311.0f\");    /* { dg-warning \"writing 311 bytes\" } */\n+  T (\"%312.312f\");  /* { dg-warning \"between 314 and 623 bytes\" } */\n+  T (\"%312.313f\");  /* { dg-warning \"between 315 and 624 bytes\" } */\n+\n+  T (\"%.*f\");       /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T (\"%1.*f\");      /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T (\"%3.*f\");      /* { dg-warning \"writing between 3 and 2147483958 bytes\" } */\n+\n+  T (\"%*.*f\");      /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+}\n+\n+/* Exercise %g.  The expected output is the lesser of %e and %f.  */\n+void test_g_va (va_list va)\n+{\n+  T (\"%g\");         /* { dg-warning \"between 1 and 13 bytes\" } */\n+  T (\"%+g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n+  T (\"% g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n+  T (\"%#g\");        /* { dg-warning \"between 1 and 13 bytes\" } */\n+  T (\"%#+g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n+  T (\"%# g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n+\n+  T (\"%.g\");        /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%.0g\");       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%.1g\");       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%.2g\");       /* { dg-warning \"between 1 and 9 bytes\" } */\n+  T (\"%.99g\");      /* { dg-warning \"between 1 and 106 bytes\" } */\n+  T (\"%.199g\");     /* { dg-warning \"between 1 and 206 bytes\" } */\n+  T (\"%.1099g\");    /* { dg-warning \"between 1 and 310 bytes\" } */\n+\n+  T (\"%0.0g\");      /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%1.0g\");      /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%2.0g\");      /* { dg-warning \"between 2 and 7 bytes\" } */\n+  T (\"%3.0g\");      /* { dg-warning \"between 3 and 7 bytes\" } */\n+  T (\"%7.0g\");      /* { dg-warning \"writing 7 bytes\" } */\n+  T (\"%310.0g\");    /* { dg-warning \"writing 310 bytes\" } */\n+  T (\"%311.0g\");    /* { dg-warning \"writing 311 bytes\" } */\n+  T (\"%312.312g\");  /* { dg-warning \"writing 312 bytes\" } */\n+  T (\"%312.313g\");  /* { dg-warning \"writing 312 bytes\" } */\n+  T (\"%333.999g\");  /* { dg-warning \"writing 333 bytes\" } */\n+\n+  T (\"%.*g\");       /* { dg-warning \"writing between 1 and 310 bytes\" } */\n+  T (\"%1.*g\");      /* { dg-warning \"writing between 1 and 310 bytes\" } */\n+  T (\"%4.*g\");      /* { dg-warning \"writing between 4 and 310 bytes\" } */\n+\n+  T (\"%*.*g\");      /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n+}"}, {"sha": "59d2927b35d427d8b5966e450e43aa05f5429366", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-9.c", "status": "modified", "additions": 138, "deletions": 250, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c87a433cdbec856c6ed840482ef638ac8fc565/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c?ref=31c87a433cdbec856c6ed840482ef638ac8fc565", "patch": "@@ -1,270 +1,158 @@\n-/* 78696 - -fprintf-return-value misoptimizes %.Ng where N is greater than 10\n-   Test to verify the correctness of ranges of output computed for floating\n-   point directives.\n-   { dg-do compile }\n-   { dg-options \"-O2 -Wformat -Wformat-overflow -ftrack-macro-expansion=0\" } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wformat -Wformat-overflow=2 -ftrack-macro-expansion=0\" } */\n \n-typedef __builtin_va_list va_list;\n+typedef __SIZE_TYPE__ size_t;\n \n-char dst[1];\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n \n-extern void sink (int, void*);\n+#ifndef LINE\n+#  define LINE 0\n+#endif\n \n-/* Macro to test either width or precision specified by the asterisk\n-   (but not both).  */\n-#define T1(fmt, a)    sink (__builtin_sprintf (dst + 1, fmt, a, x), dst)\n+int dummy_sprintf (char*, const char*, ...);\n+void sink (void*);\n \n-/* Macro to test both width and precision specified by the asterisk.  */\n-#define T2(fmt, w, p) sink (__builtin_sprintf (dst + 1, fmt, w, p, x), dst)\n+char buffer[4096];\n+char *ptr;\n \n-/* Macro to test vsprintf with both width and precision specified by\n-   the asterisk.  */\n-#define T(fmt) sink (__builtin_vsprintf (dst + 1, fmt, va), dst)\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define FUNC(f)\t\t\t\t\t\t\t\\\n+  ((!LINE || LINE == __LINE__) ? __builtin_ ## f : dummy_ ## f)\n \n-/* Exercise %a.  */\n-void test_a (int w, int p, double x)\n-{\n-  T1 (\"%.*a\", 0);     /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T1 (\"%.*a\", 1);     /* { dg-warning \"between 8 and 12 bytes\" } */\n-  T1 (\"%.*a\", 2);     /* { dg-warning \"between 9 and 13 bytes\" } */\n-  T1 (\"%.*a\", 99);    /* { dg-warning \"between 106 and 110 bytes\" } */\n-  T1 (\"%.*a\", 199);   /* { dg-warning \"between 206 and 210 bytes\" } */\n-  T1 (\"%.*a\", 1099);  /* { dg-warning \"between 1106 and 1110 bytes\" } */\n-\n-  T1 (\"%*.a\", 0);     /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T1 (\"%*.a\", 1);     /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T1 (\"%*.a\", 3);     /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T1 (\"%*.a\", 6);     /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T1 (\"%*.a\", 7);     /* { dg-warning \"between 7 and 10 bytes\" } */\n-\n-  T1 (\"%*.a\", w);     /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n-  T1 (\"%*.0a\", w);    /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n-  T1 (\"%*.1a\", w);    /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n-  T1 (\"%*.2a\", w);    /* { dg-warning \"writing between 9 and 2147483648 bytes\" } */\n-\n-  T1 (\"%.*a\",  p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-  T1 (\"%1.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-  T1 (\"%2.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-  T1 (\"%3.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-\n-  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-}\n+/* Evaluate to an array of SIZE characters when non-negative, or to\n+   a pointer to an unknown object otherwise.  */\n+#define buffer(size)\t\t\t\t\t\\\n+  ((0 <= size) ? buffer + sizeof buffer - (size) : ptr)\n \n-/* Exercise %e.  */\n-void test_e (int w, int p, double x)\n-{\n-  T1 (\"%.*e\", 0);     /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T1 (\"%.*e\", 1);     /* { dg-warning \"between 7 and 9 bytes\" } */\n-  T1 (\"%.*e\", 2);     /* { dg-warning \"between 8 and 10 bytes\" } */\n-  T1 (\"%.*e\", 99);    /* { dg-warning \"between 105 and 107 bytes\" } */\n-  T1 (\"%.*e\", 199);   /* { dg-warning \"between 205 and 207 bytes\" } */\n-  T1 (\"%.*e\", 1099);  /* { dg-warning \"between 1105 and 1107 bytes\" } */\n-\n-  T1 (\"%*.e\", 0);     /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T1 (\"%*.e\", 1);     /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T1 (\"%*.e\", 1);     /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T1 (\"%*.e\", 3);     /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T1 (\"%*.e\", 6);     /* { dg-warning \"between 6 and 7 bytes\" } */\n-  T1 (\"%*.e\", 7);     /* { dg-warning \"writing 7 bytes\" } */\n-\n-  T1 (\"%*.e\", w);     /* { dg-warning \"writing between 5 and 2147483648 bytes\" } */\n-  T1 (\"%*.0e\", w);    /* { dg-warning \"writing between 5 and 2147483648 bytes\" } */\n-  T1 (\"%*.1e\", w);    /* { dg-warning \"writing between 7 and 2147483648 bytes\" } */\n-  T1 (\"%*.2e\", w);    /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n-\n-  T1 (\"%.*e\",  p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n-  T1 (\"%1.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n-  T1 (\"%2.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n-  T1 (\"%3.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n-\n-  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n-}\n+#define T(bufsize, fmt, ...)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    char *buf = buffer (bufsize);\t\t\t\t\t\\\n+    FUNC (sprintf)(buf, fmt, __VA_ARGS__);\t\t\t\t\\\n+    sink (buf);\t\t\t\t\t\t\t\t\\\n+  } while (0)\n \n-/* Exercise %f.  */\n-void test_f (int w, int p, double x)\n-{\n-  T1 (\"%.*f\", 0);           /* { dg-warning \"between 1 and 310 bytes\" } */\n-  T1 (\"%.*f\", 1);           /* { dg-warning \"between 3 and 312 bytes\" } */\n-  T1 (\"%.*f\", 2);           /* { dg-warning \"between 4 and 313 bytes\" } */\n-  T1 (\"%.*f\", 99);          /* { dg-warning \"between 101 and 410 bytes\" } */\n-  T1 (\"%.*f\", 199);         /* { dg-warning \"between 201 and 510 bytes\" } */\n-  T1 (\"%.*f\", 1099);        /* { dg-warning \"between 1101 and 1410 bytes\" } */\n-\n-  T2 (\"%*.*f\", 0, 0);       /* { dg-warning \"between 1 and 310 bytes\" } */\n-  T2 (\"%*.*f\", 1, 0);       /* { dg-warning \"between 1 and 310 bytes\" } */\n-  T2 (\"%*.*f\", 2, 0);       /* { dg-warning \"between 2 and 310 bytes\" } */\n-  T2 (\"%*.*f\", 3, 0);       /* { dg-warning \"between 3 and 310 bytes\" } */\n-  T2 (\"%*.*f\", 310, 0);     /* { dg-warning \"writing 310 bytes\" } */\n-  T2 (\"%*.*f\", 311, 0);     /* { dg-warning \"writing 311 bytes\" } */\n-  T2 (\"%*.*f\", 312, 312);   /* { dg-warning \"between 314 and 623 bytes\" } */\n-  T2 (\"%*.*f\", 312, 313);   /* { dg-warning \"between 315 and 624 bytes\" } */\n-\n-  T1 (\"%*.f\", w);           /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n-  T1 (\"%*.0f\", w);          /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n-  T1 (\"%*.1f\", w);          /* { dg-warning \"writing between 3 and 2147483648 bytes\" } */\n-  T1 (\"%*.2f\", w);          /* { dg-warning \"writing between 4 and 2147483648 bytes\" } */\n-\n-  T1 (\"%.*f\",  p);          /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n-  T1 (\"%1.*f\", p);          /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n-  T1 (\"%2.*f\", p);          /* { dg-warning \"writing between 2 and 2147483958 bytes\" } */\n-  T1 (\"%3.*f\", p);          /* { dg-warning \"writing between 3 and 2147483958 bytes\" } */\n-\n-  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n-}\n \n-/* Exercise %g.  The expected output is the lesser of %e and %f.  */\n-void test_g (double x)\n-{\n-  T1 (\"%.*g\", 0);           /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T1 (\"%.*g\", 1);           /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T1 (\"%.*g\", 2);           /* { dg-warning \"between 1 and 9 bytes\" } */\n-  T1 (\"%.*g\", 99);          /* { dg-warning \"between 1 and 106 bytes\" } */\n-  T1 (\"%.*g\", 199);         /* { dg-warning \"between 1 and 206 bytes\" } */\n-  T1 (\"%.*g\", 1099);        /* { dg-warning \"between 1 and 310 bytes\" } */\n-\n-  T2 (\"%*.*g\", 0, 0);       /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T2 (\"%*.*g\", 1, 0);       /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T2 (\"%*.*g\", 2, 0);       /* { dg-warning \"between 2 and 7 bytes\" } */\n-  T2 (\"%*.*g\", 3, 0);       /* { dg-warning \"between 3 and 7 bytes\" } */\n-  T2 (\"%*.*g\", 7, 0);       /* { dg-warning \"writing 7 bytes\" } */\n-  T2 (\"%*.*g\", 310, 0);     /* { dg-warning \"writing 310 bytes\" } */\n-  T2 (\"%*.*g\", 311, 0);     /* { dg-warning \"writing 311 bytes\" } */\n-  T2 (\"%*.*g\", 312, 312);   /* { dg-warning \"writing 312 bytes\" } */\n-  T2 (\"%*.*g\", 312, 313);   /* { dg-warning \"writing 312 bytes\" } */\n-  T2 (\"%*.*g\", 333, 999);   /* { dg-warning \"writing 333 bytes\" } */\n-}\n+/* Identity function to verify that the checker figures out the value\n+   of the operand even when it's not constant (i.e., makes use of\n+   inlining and constant propagation information).  */\n \n-/* Exercise %a.  */\n-void test_a_va (va_list va)\n-{\n-  T (\"%.0a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T (\"%.1a\");       /* { dg-warning \"between 8 and 12 bytes\" } */\n-  T (\"%.2a\");       /* { dg-warning \"between 9 and 13 bytes\" } */\n-  T (\"%.99a\");      /* { dg-warning \"between 106 and 110 bytes\" } */\n-  T (\"%.199a\");     /* { dg-warning \"between 206 and 210 bytes\" } */\n-  T (\"%.1099a\");    /* { dg-warning \"between 1106 and 1110 bytes\" } */\n-\n-  T (\"%0.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T (\"%1.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T (\"%3.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T (\"%6.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n-  T (\"%7.a\");       /* { dg-warning \"between 7 and 10 bytes\" } */\n-\n-  T (\"%*.a\");       /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n-  T (\"%*.0a\");      /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n-  T (\"%*.1a\");      /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n-  T (\"%*.2a\");      /* { dg-warning \"writing between 9 and 2147483648 bytes\" } */\n-\n-  T (\"%.*a\");       /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-  T (\"%1.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-  T (\"%2.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-  T (\"%6.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-  T (\"%9.*a\");      /* { dg-warning \"writing between 9 and 2147483658 bytes\" } */\n-\n-  T (\"%*.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n-}\n+int i (int x) { return x; }\n+const char* s (const char *str) { return str; }\n+\n+/* Function to \"generate\" a unique unknown number (as far as GCC can\n+   tell) each time it's called.  It prevents the optimizer from being\n+   able to narrow down the ranges of possible values in test functions\n+   with repeated references to the same variable.  */\n+extern int value (void);\n \n-/* Exercise %e.  */\n-void test_e_va (va_list va)\n+/* Return a value in the range [MIN, MAX].  */\n+int range (int min, int max)\n {\n-  T (\"%e\");         /* { dg-warning \"between 12 and 14 bytes\" } */\n-  T (\"%+e\");        /* { dg-warning \"between 13 and 14 bytes\" } */\n-  T (\"% e\");        /* { dg-warning \"between 13 and 14 bytes\" } */\n-  T (\"%#e\");        /* { dg-warning \"between 12 and 14 bytes\" } */\n-  T (\"%#+e\");       /* { dg-warning \"between 13 and 14 bytes\" } */\n-  T (\"%# e\");       /* { dg-warning \"between 13 and 14 bytes\" } */\n-\n-  T (\"%.e\");        /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T (\"%.0e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T (\"%.1e\");       /* { dg-warning \"between 7 and 9 bytes\" } */\n-  T (\"%.2e\");       /* { dg-warning \"between 8 and 10 bytes\" } */\n-  T (\"%.99e\");      /* { dg-warning \"between 105 and 107 bytes\" } */\n-  T (\"%.199e\");     /* { dg-warning \"between 205 and 207 bytes\" } */\n-  T (\"%.1099e\");    /* { dg-warning \"between 1105 and 1107 bytes\" } */\n-\n-  T (\"%0.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T (\"%1.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T (\"%1.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T (\"%3.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n-  T (\"%6.e\");       /* { dg-warning \"between 6 and 7 bytes\" } */\n-  T (\"%7.e\");       /* { dg-warning \"writing 7 bytes\" } */\n-\n-  T (\"%.*e\");       /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n-  T (\"%1.*e\");      /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n-  T (\"%6.*e\");      /* { dg-warning \"writing between 6 and 2147483655 bytes\" } */\n-  T (\"%9.*e\");      /* { dg-warning \"writing between 9 and 2147483655 bytes\" } */\n-\n-  T (\"%*.*e\");      /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  int val = value ();\n+  return val < min || max < val ? min : val;\n }\n \n-/* Exercise %f.  */\n-void test_f_va (va_list va)\n+#define R(min, max) range (min, max)\n+\n+/* Verify that the checker can detect buffer overflow when the \"%s\"\n+   argument is in a known range of lengths and one or both of which\n+   exceed the size of the destination.  */\n+\n+void test_sprintf_chk_string (const char *s)\n {\n-  T (\"%f\");         /* { dg-warning \"between 8 and 317 bytes\" } */\n-  T (\"%+f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n-  T (\"% f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n-  T (\"%#f\");        /* { dg-warning \"between 8 and 317 bytes\" } */\n-  T (\"%+f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n-  T (\"% f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n-  T (\"%#+f\");       /* { dg-warning \"between 9 and 317 bytes\" } */\n-  T (\"%# f\");       /* { dg-warning \"between 9 and 317 bytes\" } */\n-\n-  T (\"%.f\");        /* { dg-warning \"between 1 and 310 bytes\" } */\n-  T (\"%.0f\");       /* { dg-warning \"between 1 and 310 bytes\" } */\n-  T (\"%.1f\");       /* { dg-warning \"between 3 and 312 bytes\" } */\n-  T (\"%.2f\");       /* { dg-warning \"between 4 and 313 bytes\" } */\n-  T (\"%.99f\");      /* { dg-warning \"between 101 and 410 bytes\" } */\n-  T (\"%.199f\");     /* { dg-warning \"between 201 and 510 bytes\" } */\n-  T (\"%.1099f\");    /* { dg-warning \"between 1101 and 1410 bytes\" } */\n-\n-  T (\"%0.0f\");      /* { dg-warning \"between 1 and 310 bytes\" } */\n-  T (\"%1.0f\");      /* { dg-warning \"between 1 and 310 bytes\" } */\n-  T (\"%2.0f\");      /* { dg-warning \"between 2 and 310 bytes\" } */\n-  T (\"%3.0f\");      /* { dg-warning \"between 3 and 310 bytes\" } */\n-  T (\"%310.0f\");    /* { dg-warning \"writing 310 bytes\" } */\n-  T (\"%311.0f\");    /* { dg-warning \"writing 311 bytes\" } */\n-  T (\"%312.312f\");  /* { dg-warning \"between 314 and 623 bytes\" } */\n-  T (\"%312.313f\");  /* { dg-warning \"between 315 and 624 bytes\" } */\n-\n-  T (\"%.*f\");       /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n-  T (\"%1.*f\");      /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n-  T (\"%3.*f\");      /* { dg-warning \"writing between 3 and 2147483958 bytes\" } */\n-\n-  T (\"%*.*f\");      /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T (1, \"%*s\", R (0, 1), \"\");     /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%*s\", R (-2, -1), \"\");   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (1, \"%*s\", R (-3,  2), \"\");   /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (1, \"%*s\", R (-4,  5), \"\");   /* { dg-warning \"writing up to 5 bytes\" } */\n+\n+  T (1, \"%*s\", R ( -5, 6), \"1\");  /* { dg-warning \"writing between 1 and 6 bytes\" } */\n+  T (1, \"%*s\", R ( -6, 7), \"12\"); /* { dg-warning \"writing between 2 and 7 bytes\" } */\n+\n+  T (1, \"%.*s\", R (0, 1), \"\");\n+  T (1, \"%.*s\", R (0, 1), s);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%.*s\", R (-2, -1), \"\");\n+  T (1, \"%.*s\", R (-2, -1), s);   /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%.*s\", R (-3,  2), \"\");\n+  T (1, \"%.*s\", R (-4,  5), \"\");\n+\n+  T (1, \"%.*s\", R ( -5, 6), \"1\");  /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%.*s\", R ( -6, 7), \"12\"); /* { dg-warning \"writing up to 2 bytes \" } */\n+  T (1, \"%.*s\", R (  1, 7), \"12\"); /* { dg-warning \"writing between 1 and 2 bytes \" } */\n+  T (1, \"%.*s\", R (  2, 7), \"12\"); /* { dg-warning \"writing 2 bytes \" } */\n+\n+  T (1, \"%*.*s\", R (0, 1), R (0, 1), \"\");     /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%*.*s\", R (0, 2), R (0, 1), \"\");     /* { dg-warning \"directive writing up to 2 bytes into a region of size 1\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 1), \"\");     /* { dg-warning \"writing up to 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (0, 1), R (0, 1), \"1\");    /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%*.*s\", R (0, 2), R (0, 1), \"1\");    /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 1), \"1\");    /* { dg-warning \"writing up to 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (0, 1), R (0, 1), \"12\");   /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%*.*s\", R (0, 2), R (0, 1), \"12\");   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 1), \"12\");   /* { dg-warning \"writing up to 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (0, 1), R (0, 1), \"123\");  /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%*.*s\", R (0, 2), R (0, 1), \"123\");  /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 1), \"123\");  /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 1), s);      /* { dg-warning \"writing up to 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (0, 1), R (0, 2), \"123\");  /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 2), R (0, 2), \"123\");  /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 2), \"123\");  /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 2), s);      /* { dg-warning \"writing up to 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (0, 1), R (0, 3), \"123\");  /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 2), R (0, 3), \"123\");  /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 3), \"123\");  /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (1, \"%*.*s\", R (0, 3), R (0, 3), s);      /* { dg-warning \"writing up to 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (1, 1), R (0, 3), \"123\");  /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T (1, \"%*.*s\", R (1, 2), R (0, 3), \"123\");  /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T (1, \"%*.*s\", R (1, 3), R (0, 3), \"123\");  /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T (1, \"%*.*s\", R (1, 3), R (0, 3), s);      /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (1, 1), R (1, 3), \"123\");  /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T (1, \"%*.*s\", R (1, 2), R (1, 3), \"123\");  /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T (1, \"%*.*s\", R (1, 3), R (1, 3), \"123\");  /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T (1, \"%*.*s\", R (1, 3), R (1, 3), s);      /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+\n+  T (1, \"%*.*s\", R (2, 3), R (1, 3), \"123\");  /* { dg-warning \"writing between 2 and 3 bytes\" } */\n+  T (1, \"%*.*s\", R (3, 4), R (1, 3), \"123\");  /* { dg-warning \"writing between 3 and 4 bytes\" } */\n+  T (1, \"%*.*s\", R (4, 5), R (1, 3), \"123\");  /* { dg-warning \"writing between 4 and 5 bytes\" } */\n+  T (1, \"%*.*s\", R (2, 3), R (1, 3), s);      /* { dg-warning \"writing between 2 and 3 bytes\" } */\n }\n \n-/* Exercise %g.  The expected output is the lesser of %e and %f.  */\n-void test_g_va (va_list va)\n+void test_sprintf_chk_int (int w, int p, int i)\n {\n-  T (\"%g\");         /* { dg-warning \"between 1 and 13 bytes\" } */\n-  T (\"%+g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n-  T (\"% g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n-  T (\"%#g\");        /* { dg-warning \"between 1 and 13 bytes\" } */\n-  T (\"%#+g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n-  T (\"%# g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n-\n-  T (\"%.g\");        /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T (\"%.0g\");       /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T (\"%.1g\");       /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T (\"%.2g\");       /* { dg-warning \"between 1 and 9 bytes\" } */\n-  T (\"%.99g\");      /* { dg-warning \"between 1 and 106 bytes\" } */\n-  T (\"%.199g\");     /* { dg-warning \"between 1 and 206 bytes\" } */\n-  T (\"%.1099g\");    /* { dg-warning \"between 1 and 310 bytes\" } */\n-\n-  T (\"%0.0g\");      /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T (\"%1.0g\");      /* { dg-warning \"between 1 and 7 bytes\" } */\n-  T (\"%2.0g\");      /* { dg-warning \"between 2 and 7 bytes\" } */\n-  T (\"%3.0g\");      /* { dg-warning \"between 3 and 7 bytes\" } */\n-  T (\"%7.0g\");      /* { dg-warning \"writing 7 bytes\" } */\n-  T (\"%310.0g\");    /* { dg-warning \"writing 310 bytes\" } */\n-  T (\"%311.0g\");    /* { dg-warning \"writing 311 bytes\" } */\n-  T (\"%312.312g\");  /* { dg-warning \"writing 312 bytes\" } */\n-  T (\"%312.313g\");  /* { dg-warning \"writing 312 bytes\" } */\n-  T (\"%333.999g\");  /* { dg-warning \"writing 333 bytes\" } */\n-\n-  T (\"%.*g\");       /* { dg-warning \"writing between 1 and 310 bytes\" } */\n-  T (\"%1.*g\");      /* { dg-warning \"writing between 1 and 310 bytes\" } */\n-  T (\"%4.*g\");      /* { dg-warning \"writing between 4 and 310 bytes\" } */\n-\n-  T (\"%*.*g\");      /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n+  T (1, \"%*d\", w, 0);             /* { dg-warning \"may write a terminating nul|directive writing between 1 and \\[0-9\\]+ bytes\" } */\n+  T (1, \"%*d\", w, i);             /* { dg-warning \"may write a terminating nul|directive writing between 1 and \\[0-9\\]+ bytes\" } */\n+\n+  T (1, \"%*d\", R (-1, 1), 0);     /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%*d\", R ( 0, 1), 0);     /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%+*d\", R ( 0, 1), 0);    /* { dg-warning \"directive writing 2 bytes\" } */\n+  T (1, \"%+*u\", R ( 0, 1), 0);    /* { dg-warning \"writing a terminating nul\" } */\n+  T (2, \"%*d\", R (-3, -2), 0);     /* { dg-warning \"directive writing between 1 and 3 bytes\" } */\n+  T (2, \"%*d\", R (-3, -1), 0);     /* { dg-warning \"directive writing between 1 and 3 bytes\" } */\n+  T (2, \"%*d\", R (-3,  0), 0);     /* { dg-warning \"directive writing between 1 and 3 bytes\" } */\n+  T (2, \"%*d\", R (-2, -1), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (2, \"%*d\", R (-2,  2), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (2, \"%*d\", R (-1,  2), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (2, \"%*d\", R ( 0,  2), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (2, \"%*d\", R ( 1,  2), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+\n+  T (1, \"%.*d\", p, 0);             /* { dg-warning \"may write a terminating nul|directive writing up to \\[0-9\\]+ bytes\" } */\n+  T (1, \"%.*d\", p, i);             /* { dg-warning \"may write a terminating nul||directive writing up to \\[0-9\\]+ bytes\" } */\n+  T (1, \"%.*d\", R (INT_MIN, -1), 0);     /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%.*d\", R (INT_MIN,  0), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%.*d\", R (-2, -1), 0);     /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%.*d\", R (-1,  1), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%.*d\", R ( 0,  1), 0);     /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%.*d\", R ( 0,  2), 0);     /* { dg-warning \"directive writing up to 2 bytes\" } */\n+  T (1, \"%.*d\", R ( 0,  INT_MAX - 1), 0);     /* { dg-warning \"directive writing up to \\[0-9\\]+ bytes\" } */\n+  T (1, \"%.*d\", R ( 1,  INT_MAX - 1), 0);     /* { dg-warning \"directive writing between 1 and \\[0-9\\]+ bytes\" } */\n }\n+\n+/* { dg-prune-output \"flag used with .%.. gnu_printf format\" } */"}]}