{"sha": "3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZjYjlkMWJmYTdhMDg1N2Q1NTA1NTNmYzY0YzVmZDI0M2NiYmEwMA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-05-18T23:45:21Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-05-18T23:45:21Z"}, "message": "tree.h (build_call_list): Remove.\n\ngcc/\n\t* tree.h (build_call_list): Remove.\n\t* tree.c (build_call_list): Remove.\n\ngcc/ada/\n\t* gcc-interface/trans.c (call_to_gnu): Use build_call_vec instead of\n\tbuild_call_list.\n\t* gcc-interface/utils.c (build_function_stub): Likewise.\n\ngcc/cp/\n\t* tree.c (build_min_non_dep_call_vec): Update comment.\n\ngcc/java/\n\t* expr.c (expand_java_multianewarray): Use build_call_vec instead of\n\tbuild_call_list.\n\t(pop_arguments): Return a VEC instead of a tree.  Take a method type\n\trather than a list of argument types.\n\t(rewrite_rule): Change signature. of rewrite_arglist member.\n\t(rewrite_arglist_getcaller): Update signature.\n\t(rewrite_arglist_getclass): Likewise.\n\t(maybe_rewrite_invocation): Update for rewrite_arglist change.\n\t(build_known_method_ref): Take a VEC instead of a tree.\n\t(invoke_build_dtable): Likewise.\n\t(expand_invoke): Update calls to pop_arguments.  Use build_call_vec\n\tinstead of build_call_list.\n\t(build_jni_stub): Use build_call_vec instead of build_call_list.\n\t* java-tree.h (maybe_rewrite_invocation): Update declaration.\n\t(build_known_method_ref): Likewise.\n\t(invoke_build_dtable): Likewise.\n\nFrom-SVN: r159548", "tree": {"sha": "9e6af464028821f05a03a3b6235b73e9a831f730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e6af464028821f05a03a3b6235b73e9a831f730"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/comments", "author": null, "committer": null, "parents": [{"sha": "58efc3ac598a5051d9a6ebafa7ed8bd43a0c81ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58efc3ac598a5051d9a6ebafa7ed8bd43a0c81ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58efc3ac598a5051d9a6ebafa7ed8bd43a0c81ac"}], "stats": {"total": 233, "additions": 129, "deletions": 104}, "files": [{"sha": "727b024020d97e4e773ff4fd5adbbdc479b5cc89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -1,3 +1,8 @@\n+2010-05-18  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* tree.h (build_call_list): Remove.\n+\t* tree.c (build_call_list): Remove.\n+\n 2010-05-18  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-reference.c (propagate): Walk all nodes in the cleanup stage."}, {"sha": "822790b91e292b76f4de5e9f75dcf09f3041f7ac", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -1,3 +1,9 @@\n+2010-05-18  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/trans.c (call_to_gnu): Use build_call_vec instead of\n+\tbuild_call_list.\n+\t* gcc-interface/utils.c (build_function_stub): Likewise.\n+\n 2010-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* gcc-interface/misc.c (gnat_handle_option): Remove special logic"}, {"sha": "13e9d1a51aca81f2ba134791d810cd07358c6811", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -2623,7 +2623,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   tree gnu_subprog_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_subprog);\n   Entity_Id gnat_formal;\n   Node_Id gnat_actual;\n-  tree gnu_actual_list = NULL_TREE;\n+  VEC(tree,gc) *gnu_actual_vec = NULL;\n   tree gnu_name_list = NULL_TREE;\n   tree gnu_before_list = NULL_TREE;\n   tree gnu_after_list = NULL_TREE;\n@@ -2973,11 +2973,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    gnu_actual = convert (DECL_ARG_TYPE (gnu_formal), gnu_actual);\n \t}\n \n-      gnu_actual_list = tree_cons (NULL_TREE, gnu_actual, gnu_actual_list);\n+      VEC_safe_push (tree, gc, gnu_actual_vec, gnu_actual);\n     }\n \n-  gnu_call = build_call_list (TREE_TYPE (gnu_subprog_type), gnu_subprog_addr,\n-\t\t\t      nreverse (gnu_actual_list));\n+  gnu_call = build_call_vec (TREE_TYPE (gnu_subprog_type), gnu_subprog_addr,\n+                             gnu_actual_vec);\n   set_expr_location_from_node (gnu_call, gnat_node);\n \n   /* If it's a function call, the result is the call expression unless a target"}, {"sha": "27c931a83ade356136d043b817a79072ff79ed37", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -3245,12 +3245,12 @@ void\n build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n {\n   tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n-  tree gnu_stub_param, gnu_param_list, gnu_arg_types, gnu_param;\n+  tree gnu_stub_param, gnu_arg_types, gnu_param;\n   tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n   tree gnu_body;\n+  VEC(tree,gc) *gnu_param_vec = NULL;\n \n   gnu_subprog_type = TREE_TYPE (gnu_subprog);\n-  gnu_param_list = NULL_TREE;\n \n   begin_subprog_body (gnu_stub_decl);\n   gnat_pushlevel ();\n@@ -3274,17 +3274,16 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n       else\n \tgnu_param = gnu_stub_param;\n \n-      gnu_param_list = tree_cons (NULL_TREE, gnu_param, gnu_param_list);\n+      VEC_safe_push (tree, gc, gnu_param_vec, gnu_param);\n     }\n \n   gnu_body = end_stmt_group ();\n \n   /* Invoke the internal subprogram.  */\n   gnu_subprog_addr = build1 (ADDR_EXPR, build_pointer_type (gnu_subprog_type),\n \t\t\t     gnu_subprog);\n-  gnu_subprog_call = build_call_list (TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t      gnu_subprog_addr,\n-\t\t\t\t      nreverse (gnu_param_list));\n+  gnu_subprog_call = build_call_vec (TREE_TYPE (gnu_subprog_type),\n+                                     gnu_subprog_addr, gnu_param_vec);\n \n   /* Propagate the return value, if any.  */\n   if (VOID_TYPE_P (TREE_TYPE (gnu_subprog_type)))"}, {"sha": "0d927c9ed2625be48d1fe015eb69362f3a451ac8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -1,3 +1,7 @@\n+2010-05-18  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* tree.c (build_min_non_dep_call_vec): Update comment.\n+\n 2010-05-17  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (struct z_candidate): Add explicit_targs field."}, {"sha": "bfe65b8418f1f09bcd05645b335f802953827593", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -1905,9 +1905,9 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n   return t;\n }\n \n-/* Similar to `build_call_list', but for template definitions of non-dependent\n-   expressions. NON_DEP is the non-dependent expression that has been\n-   built.  */\n+/* Similar to `build_nt_call_vec', but for template definitions of\n+   non-dependent expressions. NON_DEP is the non-dependent expression\n+   that has been built.  */\n \n tree\n build_min_non_dep_call_vec (tree non_dep, tree fn, VEC(tree,gc) *argvec)"}, {"sha": "3a0afa2ed9c9fbc283aed18cd78a6cee1f20909d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -1,3 +1,22 @@\n+2010-05-18  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* expr.c (expand_java_multianewarray): Use build_call_vec instead of\n+\tbuild_call_list.\n+\t(pop_arguments): Return a VEC instead of a tree.  Take a method type\n+\trather than a list of argument types.\n+\t(rewrite_rule): Change signature. of rewrite_arglist member.\n+\t(rewrite_arglist_getcaller): Update signature.\n+\t(rewrite_arglist_getclass): Likewise.\n+\t(maybe_rewrite_invocation): Update for rewrite_arglist change.\n+\t(build_known_method_ref): Take a VEC instead of a tree.\n+\t(invoke_build_dtable): Likewise.\n+\t(expand_invoke): Update calls to pop_arguments.  Use build_call_vec\n+\tinstead of build_call_list.\n+\t(build_jni_stub): Use build_call_vec instead of build_call_list.\n+\t* java-tree.h (maybe_rewrite_invocation): Update declaration.\n+\t(build_known_method_ref): Likewise.\n+\t(invoke_build_dtable): Likewise.\n+\n 2010-05-14  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR 44103"}, {"sha": "5eacd646fe4afbc4457151b45ce1a2b848ff8ce2", "filename": "gcc/java/expr.c", "status": "modified", "additions": 80, "deletions": 66, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -75,7 +75,7 @@ static void expand_cond (enum tree_code, tree, int);\n static void expand_java_goto (int);\n static tree expand_java_switch (tree, int);\n static void expand_java_add_case (tree, int, int);\n-static tree pop_arguments (tree); \n+static VEC(tree,gc) *pop_arguments (tree); \n static void expand_invoke (int, int, int); \n static void expand_java_field_op (int, int, int); \n static void java_push_constant_from_pool (struct JCF *, int); \n@@ -1128,20 +1128,21 @@ static void\n expand_java_multianewarray (tree class_type, int ndim)\n {\n   int i;\n-  tree args = build_tree_list( NULL_TREE, null_pointer_node );\n+  VEC(tree,gc) *args = NULL;\n \n-  for( i = 0; i < ndim; i++ )\n-    args = tree_cons (NULL_TREE, pop_value (int_type_node), args);\n+  VEC_safe_grow (tree, gc, args, 3 + ndim);\n \n-  args = tree_cons (NULL_TREE,\n-\t\t    build_class_ref (class_type),\n-\t\t    tree_cons (NULL_TREE, \n-\t\t\t       build_int_cst (NULL_TREE, ndim),\n-\t\t\t       args));\n+  VEC_replace (tree, args, 0, build_class_ref (class_type));\n+  VEC_replace (tree, args, 1, build_int_cst (NULL_TREE, ndim));\n \n-  push_value (build_call_list (promote_type (class_type),\n-\t\t\t       build_address_of (soft_multianewarray_node),\n-\t\t\t       args));\n+  for(i = ndim - 1; i >= 0; i-- )\n+    VEC_replace (tree, args, (unsigned)(2 + i), pop_value (int_type_node));\n+\n+  VEC_replace (tree, args, 2 + ndim, null_pointer_node);\n+\n+  push_value (build_call_vec (promote_type (class_type),\n+                              build_address_of (soft_multianewarray_node),\n+                              args));\n }\n \n /*  ARRAY[INDEX] <- RHS. build_java_check_indexed_type makes sure that\n@@ -1931,16 +1932,28 @@ expand_java_add_case (tree switch_expr, int match, int target_pc)\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n }\n \n-static tree\n-pop_arguments (tree arg_types)\n+static VEC(tree,gc) *\n+pop_arguments (tree method_type)\n {\n-  if (arg_types == end_params_node)\n-    return NULL_TREE;\n-  if (TREE_CODE (arg_types) == TREE_LIST)\n+  function_args_iterator fnai;\n+  tree type;\n+  VEC(tree,gc) *args = NULL;\n+  int arity;\n+\n+  FOREACH_FUNCTION_ARGS (method_type, type, fnai)\n+    {\n+      /* XXX: leaky abstraction.  */\n+      if (type == void_type_node)\n+        break;\n+\n+      VEC_safe_push (tree, gc, args, type);\n+    }\n+\n+  arity = VEC_length (tree, typestack);\n+\n+  while (arity--)\n     {\n-      tree tail = pop_arguments (TREE_CHAIN (arg_types));\n-      tree type = TREE_VALUE (arg_types);\n-      tree arg = pop_value (type);\n+      tree arg = pop_value (VEC_index (tree, args, arity));\n \n       /* We simply cast each argument to its proper type.  This is\n \t needed since we lose type information coming out of the\n@@ -1952,9 +1965,11 @@ pop_arguments (tree arg_types)\n \t       && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n \t       && INTEGRAL_TYPE_P (type))\n \targ = convert (integer_type_node, arg);\n-      return tree_cons (NULL_TREE, arg, tail);\n+\n+      VEC_replace (tree, args, arity, arg);\n     }\n-  gcc_unreachable ();\n+\n+  return args;\n }\n \n /* Attach to PTR (a block) the declaration found in ENTRY. */\n@@ -2079,34 +2094,30 @@ typedef struct\n   const char *new_classname;\n   const char *new_signature;\n   int flags;\n-  tree (*rewrite_arglist) (tree arglist);\n+  void (*rewrite_arglist) (VEC(tree,gc) **);\n } rewrite_rule;\n \n /* Add __builtin_return_address(0) to the end of an arglist.  */\n \n \n-static tree \n-rewrite_arglist_getcaller (tree arglist)\n+static void\n+rewrite_arglist_getcaller (VEC(tree,gc) **arglist)\n {\n   tree retaddr \n     = build_call_expr (built_in_decls[BUILT_IN_RETURN_ADDRESS],\n \t\t       1, integer_zero_node);\n \n   DECL_UNINLINABLE (current_function_decl) = 1;\n-  \n-  return chainon (arglist, \n-\t\t  tree_cons (NULL_TREE, retaddr, \n-\t\t\t     NULL_TREE));\n+\n+  VEC_safe_push (tree, gc, *arglist, retaddr);\n }\n \n /* Add this.class to the end of an arglist.  */\n \n-static tree \n-rewrite_arglist_getclass (tree arglist)\n+static void\n+rewrite_arglist_getclass (VEC(tree,gc) **arglist)\n {\n-  return chainon (arglist, \n-\t\t  tree_cons (NULL_TREE, build_class_ref (output_class),\n-\t\t\t     NULL_TREE));\n+  VEC_safe_push (tree, gc, *arglist, build_class_ref (output_class));\n }\n \n static rewrite_rule rules[] =\n@@ -2157,7 +2168,7 @@ special_method_p (tree candidate_method)\n    method, update SPECIAL.*/\n \n void\n-maybe_rewrite_invocation (tree *method_p, tree *arg_list_p, \n+maybe_rewrite_invocation (tree *method_p, VEC(tree,gc) **arg_list_p, \n \t\t\t  tree *method_signature_p, tree *special)\n {\n   tree context = DECL_NAME (TYPE_NAME (DECL_CONTEXT (*method_p)));\n@@ -2190,7 +2201,7 @@ maybe_rewrite_invocation (tree *method_p, tree *arg_list_p,\n \t      *method_p = maybe_method;\n \t      gcc_assert (*method_p);\n \t      if (p->rewrite_arglist)\n-\t\t*arg_list_p = p->rewrite_arglist (*arg_list_p);\n+\t\tp->rewrite_arglist (arg_list_p);\n \t      *method_signature_p = get_identifier (p->new_signature);\n \t      *special = integer_one_node;\n \n@@ -2205,7 +2216,7 @@ maybe_rewrite_invocation (tree *method_p, tree *arg_list_p,\n tree\n build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t\t\ttree self_type, tree method_signature ATTRIBUTE_UNUSED,\n-\t\t\ttree arg_list ATTRIBUTE_UNUSED, tree special)\n+\t\t\tVEC(tree,gc) *arg_list ATTRIBUTE_UNUSED, tree special)\n {\n   tree func;\n   if (is_compiled_class (self_type))\n@@ -2282,18 +2293,19 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n }\n \n tree\n-invoke_build_dtable (int is_invoke_interface, tree arg_list)\n+invoke_build_dtable (int is_invoke_interface, VEC(tree,gc) *arg_list)\n {\n   tree dtable, objectref;\n+  tree saved = save_expr (VEC_index (tree, arg_list, 0));\n \n-  TREE_VALUE (arg_list) = save_expr (TREE_VALUE (arg_list));\n+  VEC_replace (tree, arg_list, 0, saved);\n \n   /* If we're dealing with interfaces and if the objectref\n      argument is an array then get the dispatch table of the class\n      Object rather than the one from the objectref.  */\n   objectref = (is_invoke_interface \n-\t       && is_array_type_p (TREE_TYPE (TREE_VALUE (arg_list)))\n-\t       ? build_class_ref (object_type_node) : TREE_VALUE (arg_list));\n+\t       && is_array_type_p (TREE_TYPE (saved))\n+\t       ? build_class_ref (object_type_node) : saved);\n \n   if (dtable_ident == NULL_TREE)\n     dtable_ident = get_identifier (\"vtable\");\n@@ -2461,7 +2473,8 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n                           method_ref_index));\n   const char *const self_name\n     = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n-  tree call, func, method, arg_list, method_type;\n+  tree call, func, method, method_type;\n+  VEC(tree,gc) *arg_list;\n   tree check = NULL_TREE;\n \n   tree special = NULL_TREE;\n@@ -2568,7 +2581,7 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n \t just pop the arguments, push a properly-typed zero, and\n \t continue.  */\n       method_type = get_type_from_signature (method_signature);\n-      pop_arguments (TYPE_ARG_TYPES (method_type));\n+      pop_arguments (method_type);\n       if (opcode != OPCODE_invokestatic) \n \tpop_type (self_type);\n       method_type = promote_type (TREE_TYPE (method_type));\n@@ -2577,7 +2590,7 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n     }\n \n   method_type = TREE_TYPE (method);\n-  arg_list = pop_arguments (TYPE_ARG_TYPES (method_type));\n+  arg_list = pop_arguments (method_type);\n   flush_quick_stack ();\n \n   maybe_rewrite_invocation (&method, &arg_list, &method_signature,\n@@ -2602,8 +2615,8 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n \t We do omit the check if we're calling <init>.  */\n       /* We use a SAVE_EXPR here to make sure we only evaluate\n \t the new `self' expression once.  */\n-      tree save_arg = save_expr (TREE_VALUE (arg_list));\n-      TREE_VALUE (arg_list) = save_arg;\n+      tree save_arg = save_expr (VEC_index (tree, arg_list, 0));\n+      VEC_replace (tree, arg_list, 0, save_arg);\n       check = java_check_reference (save_arg, ! DECL_INIT_P (method));\n       func = build_known_method_ref (method, method_type, self_type,\n \t\t\t\t     method_signature, arg_list, special);\n@@ -2623,7 +2636,7 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n   else\n     func = build1 (NOP_EXPR, build_pointer_type (method_type), func);\n \n-  call = build_call_list (TREE_TYPE (method_type), func, arg_list);\n+  call = build_call_vec (TREE_TYPE (method_type), func, arg_list);\n   TREE_SIDE_EFFECTS (call) = 1;\n   call = check_for_builtin (method, call);\n \n@@ -2648,14 +2661,14 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n tree\n build_jni_stub (tree method)\n {\n-  tree jnifunc, call, args, body, method_sig, arg_types;\n+  tree jnifunc, call, body, method_sig, arg_types;\n   tree jniarg0, jniarg1, jniarg2, jniarg3;\n   tree jni_func_type, tem;\n   tree env_var, res_var = NULL_TREE, block;\n   tree method_args;\n   tree meth_var;\n   tree bind;\n-\n+  VEC(tree,gc) *args = NULL;\n   int args_size = 0;\n \n   tree klass = DECL_CONTEXT (method);\n@@ -2689,10 +2702,22 @@ build_jni_stub (tree method)\n \t\t\t\t  build_address_of (soft_getjnienvnewframe_node),\n \t\t\t\t  1, klass));\n \n+  /* The JNIEnv structure is the first argument to the JNI function.  */\n+  args_size += int_size_in_bytes (TREE_TYPE (env_var));\n+  VEC_safe_push (tree, gc, args, env_var);\n+\n+  /* For a static method the second argument is the class.  For a\n+     non-static method the second argument is `this'; that is already\n+     available in the argument list.  */\n+  if (METHOD_STATIC (method))\n+    {\n+      args_size += int_size_in_bytes (TREE_TYPE (klass));\n+      VEC_safe_push (tree, gc, args, klass);\n+    }\n+\n   /* All the arguments to this method become arguments to the\n      underlying JNI function.  If we had to wrap object arguments in a\n      special way, we would do that here.  */\n-  args = NULL_TREE;\n   for (tem = method_args; tem != NULL_TREE; tem = TREE_CHAIN (tem))\n     {\n       int arg_bits = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (tem)));\n@@ -2702,24 +2727,14 @@ build_jni_stub (tree method)\n #endif\n       args_size += (arg_bits / BITS_PER_UNIT);\n \n-      args = tree_cons (NULL_TREE, tem, args);\n+      VEC_safe_push (tree, gc, args, tem);\n     }\n-  args = nreverse (args);\n   arg_types = TYPE_ARG_TYPES (TREE_TYPE (method));\n \n-  /* For a static method the second argument is the class.  For a\n-     non-static method the second argument is `this'; that is already\n-     available in the argument list.  */\n+  /* Argument types for static methods and the JNIEnv structure.\n+     FIXME: Write and use build_function_type_vec to avoid this.  */\n   if (METHOD_STATIC (method))\n-    {\n-      args_size += int_size_in_bytes (TREE_TYPE (klass));\n-      args = tree_cons (NULL_TREE, klass, args);\n-      arg_types = tree_cons (NULL_TREE, object_ptr_type_node, arg_types);\n-    }\n-\n-  /* The JNIEnv structure is the first argument to the JNI function.  */\n-  args_size += int_size_in_bytes (TREE_TYPE (env_var));\n-  args = tree_cons (NULL_TREE, env_var, args);\n+    arg_types = tree_cons (NULL_TREE, object_ptr_type_node, arg_types);\n   arg_types = tree_cons (NULL_TREE, ptr_type_node, arg_types);\n \n   /* We call _Jv_LookupJNIMethod to find the actual underlying\n@@ -2774,8 +2789,7 @@ build_jni_stub (tree method)\n \n   /* Now we make the actual JNI call via the resulting function\n      pointer.    */\n-  call = build_call_list (TREE_TYPE (TREE_TYPE (method)),\n-\t\t\t  jnifunc, args);\n+  call = build_call_vec (TREE_TYPE (TREE_TYPE (method)), jnifunc, args);\n \n   /* If the JNI call returned a result, capture it here.  If we had to\n      unwrap JNI object results, we would do that here.  */"}, {"sha": "fad667d5f4934021878aabd1483712c8eb7c570f", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -1067,14 +1067,14 @@ extern void initialize_builtins (void);\n \n extern tree lookup_name (tree);\n extern bool special_method_p (tree);\n-extern void maybe_rewrite_invocation (tree *, tree *, tree *, tree *);\n-extern tree build_known_method_ref (tree, tree, tree, tree, tree, tree);\n+extern void maybe_rewrite_invocation (tree *, VEC(tree,gc) **, tree *, tree *);\n+extern tree build_known_method_ref (tree, tree, tree, tree, VEC(tree,gc) *, tree);\n extern tree build_class_init (tree, tree);\n extern int attach_init_test_initialization_flags (void **, void *);\n extern tree build_invokevirtual (tree, tree, tree);\n extern tree build_invokeinterface (tree, tree);\n extern tree build_jni_stub (tree);\n-extern tree invoke_build_dtable (int, tree);\n+extern tree invoke_build_dtable (int, VEC(tree,gc) *);\n extern tree build_field_ref (tree, tree, tree);\n extern tree java_modify_addr_for_volatile (tree);\n extern void pushdecl_force_head (tree);"}, {"sha": "9374bfa215d5bf6f286ed6f8f3c31bf5de928f60", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -9486,27 +9486,6 @@ build_vl_exp_stat (enum tree_code code, int len MEM_STAT_DECL)\n   return t;\n }\n \n-\n-/* Build a CALL_EXPR of class tcc_vl_exp with the indicated RETURN_TYPE\n-   and FN and a null static chain slot.  ARGLIST is a TREE_LIST of the\n-   arguments.  */\n-\n-tree\n-build_call_list (tree return_type, tree fn, tree arglist)\n-{\n-  tree t;\n-  int i;\n-\n-  t = build_vl_exp (CALL_EXPR, list_length (arglist) + 3);\n-  TREE_TYPE (t) = return_type;\n-  CALL_EXPR_FN (t) = fn;\n-  CALL_EXPR_STATIC_CHAIN (t) = NULL_TREE;\n-  for (i = 0; arglist; arglist = TREE_CHAIN (arglist), i++)\n-    CALL_EXPR_ARG (t, i) = TREE_VALUE (arglist);\n-  process_call_operands (t);\n-  return t;\n-}\n-\n /* Build a CALL_EXPR of class tcc_vl_exp with the indicated RETURN_TYPE and\n    FN and a null static chain slot.  NARGS is the number of call arguments\n    which are specified as \"...\" arguments.  */"}, {"sha": "0f099587c028c4cb0c4ab6d9f0b9d22e9a624345", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcb9d1bfa7a0857d550553fc64c5fd243cbba00/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3fcb9d1bfa7a0857d550553fc64c5fd243cbba00", "patch": "@@ -4038,7 +4038,6 @@ extern tree build_omp_clause (location_t, enum omp_clause_code);\n extern tree build_vl_exp_stat (enum tree_code, int MEM_STAT_DECL);\n #define build_vl_exp(c,n) build_vl_exp_stat (c,n MEM_STAT_INFO)\n \n-extern tree build_call_list (tree, tree, tree);\n extern tree build_call_nary (tree, tree, int, ...);\n extern tree build_call_valist (tree, tree, int, va_list);\n #define build_call_array(T1,T2,N,T3)\\"}]}