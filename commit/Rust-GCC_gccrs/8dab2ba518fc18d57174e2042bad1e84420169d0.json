{"sha": "8dab2ba518fc18d57174e2042bad1e84420169d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRhYjJiYTUxOGZjMThkNTcxNzRlMjA0MmJhZDFlODQ0MjAxNjlkMA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-09-21T08:21:57Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-09-21T08:21:57Z"}, "message": "re PR target/50449 ([avr] Loading some 32-bit constants not optimal)\n\n\tPR target/50449\n\tPR target/50465\n\t* config/avr/avr.md (adjust_len): New insn attribute.\n\t(*reload_insi, *reload_insf): Use it.\n\t(*movsi, *movsf): Use new interface of output_movsisf.\n\t* config/avr/avr-protos.h (output_movsisf): Change prototype.\n\t* config/avr/avr.c (output_movsisf): Ditto.\n\t(adjust_insn_length): Use insn attribute \"adjust_len\" to adjust\n\tlengths of insns *reload_insi, *reload_insf.\n\t(output_reload_insisf_1): New static function.\n\t(output_reload_insisf): Use it.\n\nFrom-SVN: r179037", "tree": {"sha": "53c3150b00f955f3c54c3838a65b07336b394414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53c3150b00f955f3c54c3838a65b07336b394414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dab2ba518fc18d57174e2042bad1e84420169d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dab2ba518fc18d57174e2042bad1e84420169d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dab2ba518fc18d57174e2042bad1e84420169d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dab2ba518fc18d57174e2042bad1e84420169d0/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3653988e4640f61223336d5e12c178329d659a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3653988e4640f61223336d5e12c178329d659a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3653988e4640f61223336d5e12c178329d659a13"}], "stats": {"total": 221, "additions": 183, "deletions": 38}, "files": [{"sha": "663319d92f0c2c274c52fb9d8c746529429f476b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dab2ba518fc18d57174e2042bad1e84420169d0", "patch": "@@ -1,3 +1,17 @@\n+2011-09-21  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50449\n+\tPR target/50465\n+\t* config/avr/avr.md (adjust_len): New insn attribute.\n+\t(*reload_insi, *reload_insf): Use it.\n+\t(*movsi, *movsf): Use new interface of output_movsisf.\n+\t* config/avr/avr-protos.h (output_movsisf): Change prototype.\n+\t* config/avr/avr.c (output_movsisf): Ditto.\n+\t(adjust_insn_length): Use insn attribute \"adjust_len\" to adjust\n+\tlengths of insns *reload_insi, *reload_insf.\n+\t(output_reload_insisf_1): New static function.\n+\t(output_reload_insisf): Use it.\n+\n 2011-09-21  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/sparc.c (def_builtin): Change from macro into function."}, {"sha": "6a0b40cbf7c25646ca78bdd57eda1c44ad397f22", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=8dab2ba518fc18d57174e2042bad1e84420169d0", "patch": "@@ -56,7 +56,7 @@ extern const char *out_movhi_r_mr (rtx insn, rtx op[], int *l);\n extern const char *out_movhi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_r_mr (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_mr_r (rtx insn, rtx op[], int *l);\n-extern const char *output_movsisf (rtx insn, rtx operands[], rtx clobber, int *l);\n+extern const char *output_movsisf (rtx insn, rtx operands[], int *l);\n extern const char *out_tstsi (rtx insn, rtx src, int *l);\n extern const char *out_tsthi (rtx insn, rtx src, int *l);\n extern const char *ret_cond_branch (rtx x, int len, int reverse);"}, {"sha": "7b11ca9519cafa66715bbea00814e5ec2a177c6d", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 153, "deletions": 35, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=8dab2ba518fc18d57174e2042bad1e84420169d0", "patch": "@@ -1819,7 +1819,7 @@ avr_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \n       for (regno = cum->regno; regno < cum->regno + bytes; regno++)\n         if (fixed_regs[regno])\n-          error (\"Register %s is needed to pass a parameter but is fixed\",\n+          warning (0,\"Register %s is needed to pass a parameter but is fixed\",\n                  reg_names[regno]);\n     }\n       \n@@ -2673,7 +2673,7 @@ out_movsi_mr_r (rtx insn, rtx op[], int *l)\n }\n \n const char *\n-output_movsisf (rtx insn, rtx operands[], rtx clobber_reg, int *l)\n+output_movsisf (rtx insn, rtx operands[], int *l)\n {\n   int dummy;\n   rtx dest = operands[0];\n@@ -2719,7 +2719,7 @@ output_movsisf (rtx insn, rtx operands[], rtx clobber_reg, int *l)\n       else if (CONST_INT_P (src)\n                || CONST_DOUBLE_P (src))\n         {\n-          return output_reload_insisf (insn, operands, clobber_reg, real_l);\n+          return output_reload_insisf (insn, operands, NULL_RTX, real_l);\n         }\n       else if (CONSTANT_P (src))\n \t{\n@@ -4616,8 +4616,56 @@ avr_rotate_bytes (rtx operands[])\n int\n adjust_insn_length (rtx insn, int len)\n {\n-  rtx patt = PATTERN (insn);\n-  rtx set;\n+  rtx patt, set;\n+  enum attr_adjust_len adjust_len;\n+\n+  /* Some complex insns don't need length adjustment and therefore\n+     the length need not/must not be adjusted for these insns.\n+     It is easier to state this in an insn attribute \"adjust_len\" than\n+     to clutter up code here...  */\n+  \n+  if (-1 == recog_memoized (insn))\n+    {\n+      return len;\n+    }\n+\n+  /* Read from insn attribute \"adjust_len\" if/how length is to be adjusted.  */\n+\n+  adjust_len = get_attr_adjust_len (insn);\n+\n+  if (adjust_len != ADJUST_LEN_YES)\n+    {\n+      rtx *op = recog_data.operand;\n+      \n+      if (adjust_len == ADJUST_LEN_NO)\n+        {\n+          /* Nothing to adjust: The length from attribute \"length\" is fine.  */\n+          \n+          return len;\n+        }\n+\n+      /* Extract insn's operands.  */\n+      \n+      extract_constrain_insn_cached (insn);\n+\n+      /* Dispatch to right function.  */\n+      \n+      switch (adjust_len)\n+        {\n+        case ADJUST_LEN_RELOAD_IN32:\n+          output_reload_insisf (insn, op, op[2], &len);\n+          break;\n+          \n+        default:\n+          gcc_unreachable();\n+        }\n+      \n+      return len;\n+    } /* adjust_length != ADJUST_LEN_YES */\n+\n+  /* adjust_len == \"yes\": Analyse insn by hand.  */\n+  \n+  patt = PATTERN (insn);\n \n   if (GET_CODE (patt) == SET)\n     {\n@@ -4637,7 +4685,7 @@ adjust_insn_length (rtx insn, int len)\n \t      break;\n \t    case SImode:\n \t    case SFmode:\n-\t      output_movsisf (insn, op, NULL_RTX, &len);\n+\t      output_movsisf (insn, op, &len);\n \t      break;\n \t    default:\n \t      break;\n@@ -4708,7 +4756,8 @@ adjust_insn_length (rtx insn, int len)\n \t      break;\n \t    case SImode:\n \t    case SFmode:\n-\t      output_reload_insisf (insn, op, XEXP (op[2], 0), &len);\n+\t      /* Handled by ADJUST_LEN_RELOAD_INSISF above.  */\n+\t      gcc_unreachable();\n \t      break;\n \t    default:\n \t      break;\n@@ -6698,21 +6747,17 @@ output_reload_inhi (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)\n }\n \n \n-/* Reload a SI or SF compile time constant (OP[1]) into a GPR (OP[0]).\n-   CLOBBER_REG is a QI clobber reg needed to move vast majority of consts\n-   into a NO_LD_REGS.  If CLOBBER_REG is NULL_RTX we either don't need a\n-   clobber reg or have to cook one up.\n-\n-   LEN == NULL: Output instructions.\n-   \n-   LEN != NULL: Output nothing.  Increment *LEN by number of words occupied\n-                by the insns printed.\n-\n-   Return \"\".  */\n+/* A helper for `output_reload_insisf'.  */\n+/* Set 32-bit register OP[0] to compile-time constant OP[1].\n+   CLOBBER_REG is a QI clobber register or NULL_RTX.\n+   LEN == NULL: output instructions.\n+   LEN != NULL: set *LEN to the length of the instruction sequence\n+                (in words) printed with LEN = NULL.\n+   If CLEAR_P is true, OP[0] had been cleard to Zero already.\n+   If CLEAR_P is false, nothing is known about OP[0].  */\n \n-const char *\n-output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n-                      rtx *op, rtx clobber_reg, int *len)\n+static void\n+output_reload_insisf_1 (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n {\n   rtx src = op[1];\n   rtx dest = op[0];\n@@ -6787,7 +6832,12 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n \n           if (INTVAL (lo16) == INTVAL (hi16))\n             {\n-              avr_asm_len (\"movw %C0,%A0\", &op[0], len, 1);\n+              if (0 != INTVAL (lo16)\n+                  || !clear_p)\n+                {\n+                  avr_asm_len (\"movw %C0,%A0\", &op[0], len, 1);\n+                }\n+              \n               break;\n             }\n         }\n@@ -6797,7 +6847,9 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n       \n       if (ival[n] == 0)\n         {\n-          avr_asm_len (\"clr %0\", &xdest[n], len, 1);\n+          if (!clear_p)\n+            avr_asm_len (\"clr %0\", &xdest[n], len, 1);\n+          \n           continue;\n         }\n \n@@ -6837,8 +6889,18 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n       \n       if (-1 == ival[n])\n         {\n-          avr_asm_len (\"clr %0\" CR_TAB\n-                       \"dec %0\", &xdest[n], len, 2);\n+          if (!clear_p)\n+            avr_asm_len (\"clr %0\", &xdest[n], len, 1);\n+          \n+          avr_asm_len (\"dec %0\", &xdest[n], len, 1);\n+          continue;\n+        }\n+      else if (1 == ival[n])\n+        {\n+          if (!clear_p)\n+            avr_asm_len (\"clr %0\", &xdest[n], len, 1);\n+          \n+          avr_asm_len (\"inc %0\", &xdest[n], len, 1);\n           continue;\n         }\n \n@@ -6848,13 +6910,6 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n       if (NULL_RTX == clobber_reg\n           && single_one_operand (xval, QImode))\n         {\n-          if (1 == ival[n])\n-            {\n-              avr_asm_len (\"clr %0\" CR_TAB\n-                           \"inc %0\", &xdest[n], len, 2);\n-              continue;\n-            }\n-          \n           xop[0] = xdest[n];\n           xop[1] = GEN_INT (exact_log2 (ival[n] & GET_MODE_MASK (QImode)));\n \n@@ -6866,8 +6921,10 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n               avr_asm_len (\"set\", xop, len, 1);\n             }\n \n-          avr_asm_len (\"clr %0\" CR_TAB\n-                       \"bld %0,%1\", xop, len, 2);\n+          if (!clear_p)\n+            avr_asm_len (\"clr %0\", xop, len, 1);\n+          \n+          avr_asm_len (\"bld %0,%1\", xop, len, 1);\n           continue;\n         }\n \n@@ -6890,7 +6947,68 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n     {\n       avr_asm_len (\"mov %0,__tmp_reg__\", &clobber_reg, len, 1);\n     }\n-  \n+}\n+\n+\n+/* Reload a SI or SF compile time constant OP[1] into the register OP[0].\n+   CLOBBER_REG is a QI clobber reg needed to move vast majority of consts\n+   into a NO_LD_REGS register.  If CLOBBER_REG is NULL_RTX we either don't\n+   need a clobber reg or have to cook one up.\n+\n+   LEN == NULL: Output instructions.\n+   \n+   LEN != NULL: Output nothing.  Increment *LEN by number of words occupied\n+                by the insns printed.\n+\n+   Return \"\".  */\n+\n+const char *\n+output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n+                      rtx *op, rtx clobber_reg, int *len)\n+{\n+  gcc_assert (REG_P (op[0])\n+              && CONSTANT_P (op[1]));\n+\n+  if (AVR_HAVE_MOVW\n+      && !test_hard_reg_class (LD_REGS, op[0]))\n+    {\n+      int len_clr, len_noclr;\n+      \n+      /* In some cases it is better to clear the destination beforehand, e.g.\n+\n+             CLR R2   CLR R3   MOVW R4,R2   INC R2\n+\n+         is shorther than\n+\n+             CLR R2   INC R2   CLR  R3      CLR R4   CLR R5\n+\n+         We find it too tedious to work that out in the print function.\n+         Instead, we call the print function twice to get the lengths of\n+         both methods and use the shortest one.  */\n+         \n+      output_reload_insisf_1 (op, clobber_reg, &len_clr, true);\n+      output_reload_insisf_1 (op, clobber_reg, &len_noclr, false);\n+      \n+      if (len_noclr - len_clr == 4)\n+        {\n+          /* Default needs 4 CLR instructions: clear register beforehand.  */\n+          \n+          avr_asm_len (\"clr %A0\" CR_TAB\n+                       \"clr %B0\" CR_TAB\n+                       \"movw %C0,%A0\", &op[0], len, 3);\n+          \n+          output_reload_insisf_1 (op, clobber_reg, len, true);\n+          \n+          if (len)\n+            *len += 3;\n+\n+          return \"\";\n+        }\n+    }\n+\n+  /* Default: destination not pre-cleared.  */\n+\n+  output_reload_insisf_1 (op, clobber_reg, len, false);\n   return \"\";\n }\n "}, {"sha": "a1fcecbb04dcb0194ec3feb7aee63ebef1555a70", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dab2ba518fc18d57174e2042bad1e84420169d0/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=8dab2ba518fc18d57174e2042bad1e84420169d0", "patch": "@@ -128,6 +128,17 @@\n \t\t       (const_int 2))]\n         (const_int 2)))\n \n+;; Lengths of several insns are adjusted in avr.c:adjust_insn_length().\n+;; Following insn attribute tells if and how the adjustment has to be\n+;; done:\n+;;     no     No adjustment needed; attribute \"length\" is fine.\n+;;     yes    Analyse pattern in adjust_insn_length by hand.\n+;; Otherwise do special processing depending on the attribute.\n+\n+(define_attr \"adjust_len\"\n+  \"yes,no,reload_in32\"\n+  (const_string \"yes\"))\n+\n ;; Define mode iterators\n (define_mode_iterator QIHI  [(QI \"\") (HI \"\")])\n (define_mode_iterator QIHI2 [(QI \"\") (HI \"\")])\n@@ -457,6 +468,7 @@\n     return output_reload_insisf (insn, operands, operands[2], NULL);\n   }\n   [(set_attr \"length\" \"8\")\n+   (set_attr \"adjust_len\" \"reload_in32\")\n    (set_attr \"cc\" \"clobber\")])\n \n \n@@ -466,7 +478,7 @@\n   \"(register_operand (operands[0],SImode)\n     || register_operand (operands[1],SImode) || const0_rtx == operands[1])\"\n   {\n-    return output_movsisf (insn, operands, NULL_RTX, NULL);\n+    return output_movsisf (insn, operands, NULL);\n   }\n   [(set_attr \"length\" \"4,4,8,9,4,10\")\n    (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n@@ -495,7 +507,7 @@\n    || register_operand (operands[1], SFmode)\n    || operands[1] == CONST0_RTX (SFmode)\"\n   {\n-    return output_movsisf (insn, operands, NULL_RTX, NULL);\n+    return output_movsisf (insn, operands, NULL);\n   }\n   [(set_attr \"length\" \"4,4,8,9,4,10\")\n    (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n@@ -521,6 +533,7 @@\n     return output_reload_insisf (insn, operands, operands[2], NULL);\n   }\n   [(set_attr \"length\" \"8\")\n+   (set_attr \"adjust_len\" \"reload_in32\")\n    (set_attr \"cc\" \"clobber\")])\n \n ;;========================================================================="}]}