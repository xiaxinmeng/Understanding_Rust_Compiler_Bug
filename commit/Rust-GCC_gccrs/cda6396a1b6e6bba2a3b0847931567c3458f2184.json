{"sha": "cda6396a1b6e6bba2a3b0847931567c3458f2184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RhNjM5NmExYjZlNmJiYTJhM2IwODQ3OTMxNTY3YzM0NThmMjE4NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-05-15T18:06:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-05-15T18:06:57Z"}, "message": "PR c++/93286 - ICE with __is_constructible and variadic template.\n\nMy GCC 10 patch for 93286 fixed the missing piece in tsubst's handling of\nlists vs. that in tsubst_copy_and_build, but it would be better to share the\ncode between them.\n\ngcc/cp/ChangeLog\n2020-05-15  Jason Merrill  <jason@redhat.com>\n\n\tPR c++/93286 - ICE with __is_constructible and variadic template.\n\t* pt.c (tsubst_tree_list): New.\n\t(tsubst, tsubst_copy_and_build): Use it.\n\t* decl2.c (is_late_template_attribute): Handle error_mark_node args.", "tree": {"sha": "0886bfbae0e65f66cf1fa84dae41a69a1e0a11d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0886bfbae0e65f66cf1fa84dae41a69a1e0a11d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cda6396a1b6e6bba2a3b0847931567c3458f2184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda6396a1b6e6bba2a3b0847931567c3458f2184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda6396a1b6e6bba2a3b0847931567c3458f2184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda6396a1b6e6bba2a3b0847931567c3458f2184/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c1a5d8b71e29b71e0bc1004480c12c5fc427cb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c1a5d8b71e29b71e0bc1004480c12c5fc427cb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c1a5d8b71e29b71e0bc1004480c12c5fc427cb7"}], "stats": {"total": 284, "additions": 101, "deletions": 183}, "files": [{"sha": "732be07c9c0243b6bac8b803c42810d6a09142df", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cda6396a1b6e6bba2a3b0847931567c3458f2184", "patch": "@@ -1,3 +1,10 @@\n+2020-05-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/93286 - ICE with __is_constructible and variadic template.\n+\t* pt.c (tsubst_tree_list): New.\n+\t(tsubst, tsubst_copy_and_build): Use it.\n+\t* decl2.c (is_late_template_attribute): Handle error_mark_node args.\n+\n 2020-05-15  Nathan Sidwell  <nathan@acm.org>\n \n \t* pt.c (template_args_equal): Fix thinkos in previous 'cleanup'."}, {"sha": "3f7ded4798fbf5fa8ee25b2c402dd157ca339a15", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cda6396a1b6e6bba2a3b0847931567c3458f2184", "patch": "@@ -6953,7 +6953,7 @@ extern tree tsubst_default_argument\t\t(tree, int, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree tsubst (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t,\n-\t\t\t\t\t\t tree, bool, bool);\n+\t\t\t\t\t\t tree, bool = false, bool = false);\n extern tree tsubst_expr                         (tree, tree, tsubst_flags_t,\n                                                  tree, bool);\n extern tree tsubst_pack_expansion\t\t(tree, tree, tsubst_flags_t, tree);"}, {"sha": "449c86c66c9f4769e03c5501e20bfa645f3f4087", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cda6396a1b6e6bba2a3b0847931567c3458f2184", "patch": "@@ -1173,6 +1173,9 @@ is_late_template_attribute (tree attr, tree decl)\n       && is_attribute_p (\"omp declare simd\", name))\n     return true;\n \n+  if (args == error_mark_node)\n+    return false;\n+\n   /* An attribute pack is clearly dependent.  */\n   if (args && PACK_EXPANSION_P (args))\n     return true;"}, {"sha": "cad5b217f3c365a1594f9b472fec743b89bd8492", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 90, "deletions": 182, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda6396a1b6e6bba2a3b0847931567c3458f2184/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cda6396a1b6e6bba2a3b0847931567c3458f2184", "patch": "@@ -15044,6 +15044,94 @@ tsubst_exception_specification (tree fntype,\n   return new_specs;\n }\n \n+/* Substitute through a TREE_LIST of types or expressions, handling pack\n+   expansions.  */\n+\n+tree\n+tsubst_tree_list (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  if (t == void_list_node)\n+    return t;\n+\n+  tree purpose = TREE_PURPOSE (t);\n+  tree purposevec = NULL_TREE;\n+  if (!purpose)\n+    ;\n+  else if (PACK_EXPANSION_P (purpose))\n+    {\n+      purpose = tsubst_pack_expansion (purpose, args, complain, in_decl);\n+      if (TREE_CODE (purpose) == TREE_VEC)\n+\tpurposevec = purpose;\n+    }\n+  else if (TYPE_P (purpose))\n+    purpose = tsubst (purpose, args, complain, in_decl);\n+  else\n+    purpose = tsubst_copy_and_build (purpose, args, complain, in_decl);\n+  if (purpose == error_mark_node || purposevec == error_mark_node)\n+    return error_mark_node;\n+\n+  tree value = TREE_VALUE (t);\n+  tree valuevec = NULL_TREE;\n+  if (!value)\n+    ;\n+  else if (PACK_EXPANSION_P (value))\n+    {\n+      value = tsubst_pack_expansion (value, args, complain, in_decl);\n+      if (TREE_CODE (value) == TREE_VEC)\n+\tvaluevec = value;\n+    }\n+  else if (TYPE_P (value))\n+    value = tsubst (value, args, complain, in_decl);\n+  else\n+    value = tsubst_copy_and_build (value, args, complain, in_decl);\n+  if (value == error_mark_node || valuevec == error_mark_node)\n+    return error_mark_node;\n+\n+  tree chain = TREE_CHAIN (t);\n+  if (!chain)\n+    ;\n+  else if (TREE_CODE (chain) == TREE_LIST)\n+    chain = tsubst_tree_list (chain, args, complain, in_decl);\n+  else if (TYPE_P (chain))\n+    chain = tsubst (chain, args, complain, in_decl);\n+  else\n+    chain = tsubst_copy_and_build (chain, args, complain, in_decl);\n+  if (chain == error_mark_node)\n+    return error_mark_node;\n+\n+  if (purpose == TREE_PURPOSE (t)\n+      && value == TREE_VALUE (t)\n+      && chain == TREE_CHAIN (t))\n+    return t;\n+\n+  int len;\n+  /* Determine the number of arguments.  */\n+  if (purposevec)\n+    {\n+      len = TREE_VEC_LENGTH (purposevec);\n+      gcc_assert (!valuevec || len == TREE_VEC_LENGTH (valuevec));\n+    }\n+  else if (valuevec)\n+    len = TREE_VEC_LENGTH (valuevec);\n+  else\n+    len = 1;\n+\n+  for (int i = len; i-- > 0; )\n+    {\n+      if (purposevec)\n+\tpurpose = TREE_VEC_ELT (purposevec, i);\n+      if (valuevec)\n+\tvalue = TREE_VEC_ELT (valuevec, i);\n+\n+      if (value && TYPE_P (value))\n+\tchain = hash_tree_cons (purpose, value, chain);\n+      else\n+\tchain = tree_cons (purpose, value, chain);\n+    }\n+\n+  return chain;\n+}\n+\n /* Take the tree structure T and replace template parameters used\n    therein with the argument vector ARGS.  IN_DECL is an associated\n    decl for diagnostics.  If an error occurs, returns ERROR_MARK_NODE.\n@@ -15463,104 +15551,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       }\n \n     case TREE_LIST:\n-      {\n-\ttree purpose, value, chain;\n-\n-\tif (t == void_list_node)\n-\t  return t;\n-\n-\tif ((TREE_PURPOSE (t) && PACK_EXPANSION_P (TREE_PURPOSE (t)))\n-\t    || (TREE_VALUE (t) && PACK_EXPANSION_P (TREE_VALUE (t))))\n-\t  {\n-\t    /* We have pack expansions, so expand those and\n-\t       create a new list out of it.  */\n-\n-\t    /* Expand the argument expressions.  */\n-\t    tree purposevec = NULL_TREE;\n-\t    if (TREE_PURPOSE (t))\n-\t      purposevec = tsubst_pack_expansion (TREE_PURPOSE (t), args,\n-\t\t\t\t\t\t  complain, in_decl);\n-\t    if (purposevec == error_mark_node)\n-\t      return error_mark_node;\n-\n-\t    tree valuevec = NULL_TREE;\n-\t    if (TREE_VALUE (t))\n-\t      valuevec = tsubst_pack_expansion (TREE_VALUE (t), args,\n-\t\t\t\t\t\tcomplain, in_decl);\n-\t    if (valuevec == error_mark_node)\n-\t      return error_mark_node;\n-\n-\t    /* Build the rest of the list.  */\n-\t    tree chain = TREE_CHAIN (t);\n-\t    if (chain && chain != void_type_node)\n-\t      chain = tsubst (chain, args, complain, in_decl);\n-\t    if (chain == error_mark_node)\n-\t      return error_mark_node;\n-\n-\t    /* Determine the number of arguments.  */\n-\t    int len = -1;\n-\t    if (purposevec && TREE_CODE (purposevec) == TREE_VEC)\n-\t      {\n-\t\tlen = TREE_VEC_LENGTH (purposevec);\n-\t\tgcc_assert (!valuevec || len == TREE_VEC_LENGTH (valuevec));\n-\t      }\n-\t    else if (TREE_CODE (valuevec) == TREE_VEC)\n-\t      len = TREE_VEC_LENGTH (valuevec);\n-\t    else\n-\t      {\n-\t\t/* Since we only performed a partial substitution into\n-\t\t   the argument pack, we only RETURN (a single list\n-\t\t   node.  */\n-\t\tif (purposevec == TREE_PURPOSE (t)\n-\t\t    && valuevec == TREE_VALUE (t)\n-\t\t    && chain == TREE_CHAIN (t))\n-\t\t  return t;\n-\n-\t\treturn tree_cons (purposevec, valuevec, chain);\n-\t      }\n-\n-\t    /* Convert the argument vectors into a TREE_LIST.  */\n-\t    for (int i = len; i-- > 0; )\n-\t      {\n-\t\tpurpose = (purposevec ? TREE_VEC_ELT (purposevec, i)\n-\t\t\t   : NULL_TREE);\n-\t\tvalue = (valuevec ? TREE_VEC_ELT (valuevec, i)\n-\t\t\t : NULL_TREE);\n-\n-\t\t/* Build the list (backwards).  */\n-\t\tchain = hash_tree_cons (purpose, value, chain);\n-\t      }\n-\n-\t    return chain;\n-\t  }\n-\n-\tpurpose = TREE_PURPOSE (t);\n-\tif (purpose)\n-\t  {\n-\t    purpose = tsubst (purpose, args, complain, in_decl);\n-\t    if (purpose == error_mark_node)\n-\t      return error_mark_node;\n-\t  }\n-\tvalue = TREE_VALUE (t);\n-\tif (value)\n-\t  {\n-\t    value = tsubst (value, args, complain, in_decl);\n-\t    if (value == error_mark_node)\n-\t      return error_mark_node;\n-\t  }\n-\tchain = TREE_CHAIN (t);\n-\tif (chain && chain != void_type_node)\n-\t  {\n-\t    chain = tsubst (chain, args, complain, in_decl);\n-\t    if (chain == error_mark_node)\n-\t      return error_mark_node;\n-\t  }\n-\tif (purpose == TREE_PURPOSE (t)\n-\t    && value == TREE_VALUE (t)\n-\t    && chain == TREE_CHAIN (t))\n-\t  return t;\n-\treturn hash_tree_cons (purpose, value, chain);\n-      }\n+      return tsubst_tree_list (t, args, complain, in_decl);\n \n     case TREE_BINFO:\n       /* We should never be tsubsting a binfo.  */\n@@ -20078,90 +20069,7 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case TREE_LIST:\n-      {\n-\ttree purpose, value, chain;\n-\n-\tif (t == void_list_node)\n-\t  RETURN (t);\n-\n-        if ((TREE_PURPOSE (t) && PACK_EXPANSION_P (TREE_PURPOSE (t)))\n-            || (TREE_VALUE (t) && PACK_EXPANSION_P (TREE_VALUE (t))))\n-          {\n-            /* We have pack expansions, so expand those and\n-               create a new list out of it.  */\n-            tree purposevec = NULL_TREE;\n-            tree valuevec = NULL_TREE;\n-            tree chain;\n-            int i, len = -1;\n-\n-            /* Expand the argument expressions.  */\n-            if (TREE_PURPOSE (t))\n-              purposevec = tsubst_pack_expansion (TREE_PURPOSE (t), args,\n-                                                 complain, in_decl);\n-            if (TREE_VALUE (t))\n-              valuevec = tsubst_pack_expansion (TREE_VALUE (t), args,\n-                                               complain, in_decl);\n-\n-            /* Build the rest of the list.  */\n-            chain = TREE_CHAIN (t);\n-            if (chain && chain != void_type_node)\n-              chain = RECUR (chain);\n-\n-            /* Determine the number of arguments.  */\n-            if (purposevec && TREE_CODE (purposevec) == TREE_VEC)\n-              {\n-                len = TREE_VEC_LENGTH (purposevec);\n-                gcc_assert (!valuevec || len == TREE_VEC_LENGTH (valuevec));\n-              }\n-            else if (TREE_CODE (valuevec) == TREE_VEC)\n-              len = TREE_VEC_LENGTH (valuevec);\n-            else\n-              {\n-                /* Since we only performed a partial substitution into\n-                   the argument pack, we only RETURN (a single list\n-                   node.  */\n-                if (purposevec == TREE_PURPOSE (t)\n-                    && valuevec == TREE_VALUE (t)\n-                    && chain == TREE_CHAIN (t))\n-                  RETURN (t);\n-\n-                RETURN (tree_cons (purposevec, valuevec, chain));\n-              }\n-\n-            /* Convert the argument vectors into a TREE_LIST */\n-            i = len;\n-            while (i > 0)\n-              {\n-                /* Grab the Ith values.  */\n-                i--;\n-                purpose = purposevec ? TREE_VEC_ELT (purposevec, i) \n-\t\t                     : NULL_TREE;\n-                value \n-\t\t  = valuevec ? convert_from_reference (TREE_VEC_ELT (valuevec, i))\n-                             : NULL_TREE;\n-\n-                /* Build the list (backwards).  */\n-                chain = tree_cons (purpose, value, chain);\n-              }\n-\n-            RETURN (chain);\n-          }\n-\n-\tpurpose = TREE_PURPOSE (t);\n-\tif (purpose)\n-\t  purpose = RECUR (purpose);\n-\tvalue = TREE_VALUE (t);\n-\tif (value)\n-\t  value = RECUR (value);\n-\tchain = TREE_CHAIN (t);\n-\tif (chain && chain != void_type_node)\n-\t  chain = RECUR (chain);\n-\tif (purpose == TREE_PURPOSE (t)\n-\t    && value == TREE_VALUE (t)\n-\t    && chain == TREE_CHAIN (t))\n-\t  RETURN (t);\n-\tRETURN (tree_cons (purpose, value, chain));\n-      }\n+      RETURN (tsubst_tree_list (t, args, complain, in_decl));\n \n     case COMPONENT_REF:\n       {"}]}