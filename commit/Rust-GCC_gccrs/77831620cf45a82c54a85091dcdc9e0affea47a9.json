{"sha": "77831620cf45a82c54a85091dcdc9e0affea47a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc4MzE2MjBjZjQ1YTgyYzU0YTg1MDkxZGNkYzllMGFmZmVhNDdhOQ==", "commit": {"author": {"name": "Cary Coutant", "email": "ccoutant@google.com", "date": "2009-10-08T21:00:04Z"}, "committer": {"name": "Cary Coutant", "email": "ccoutant@gcc.gnu.org", "date": "2009-10-08T21:00:04Z"}, "message": "Add support for debugging with ICF (Identical Code Folding).\n\ngcc/ChangeLog:\n\tAdd support for debugging with ICF (Identical Code Folding).\n\t* calls.c (debug.h): New #include.\n\t(emit_call_1): Call virtual_call_token debug hook.\n\t* common.opt (-fenable-icf-debug): New option.\n\t* dwarf2out.c (dwarf2_debug_hooks): Add entries for new hooks (two\n\tlocations in the source).\n\t(poc_label_num): New variable.\n\t(dcall_entry, vcall_entry): New typedefs.\n\t(dcall_table, vcall_table): New variables.\n\t(struct vcall_insn): New type.\n\t(vcall_insn_table): New variable.\n\t(DEBUG_DCALL_SECTION, DEBUG_VCALL_SECTION): New macros.\n\t(size_of_dcall_table): New function.\n\t(output_dcall_table): New function.\n\t(size_of_vcall_table): New function.\n\t(output_vcall_table): New function.\n\t(dwarf2out_direct_call): New function.\n\t(vcall_insn_table_hash): New function.\n\t(vcall_insn_table_eq): New function.\n\t(dwarf2out_virtual_call_token): New function.\n\t(dwarf2out_virtual_call): New function.\n\t(dwarf2out_init): Allocate new tables and sections.\n\t(prune_unused_types): Mark DIEs referenced from direct call table.\n\t(dwarf2out_finish): Output direct and virtual call tables.\n\t* final.c (final_scan_insn): Call direct_call and virtual_call\n\tdebug hooks.\n\t* debug.h (struct gcc_debug_hooks): Add direct_call,\n\tvirtual_call_token, virtual_call hooks.\n\t(debug_nothing_uid): New function.\n\t* debug.c (do_nothing_debug_hooks): Add dummy entries for new hooks.\n\t(debug_nothing_uid): New function.\n\t* dbxout.c (dbx_debug_hooks): Add dummy entries for new hooks.\n\t* sdbout.c (sdb_debug_hooks): Likewise.\n\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n\t* doc/invoke.texi (-fenable-icf-debug): New option.\n\ngcc/testsuite/ChangeLog:\n\tAdd support for debugging with ICF (Identical Code Folding).\n\t* g++.dg/debug/dwarf2/icf.C: New test.\n\nFrom-SVN: r152577", "tree": {"sha": "d4e268cc74aaa313626c0a3a838960f89e919d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4e268cc74aaa313626c0a3a838960f89e919d48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77831620cf45a82c54a85091dcdc9e0affea47a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77831620cf45a82c54a85091dcdc9e0affea47a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77831620cf45a82c54a85091dcdc9e0affea47a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77831620cf45a82c54a85091dcdc9e0affea47a9/comments", "author": null, "committer": null, "parents": [{"sha": "968e57283eda9b6f9eb513b0e8572c8a9efaa79f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/968e57283eda9b6f9eb513b0e8572c8a9efaa79f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/968e57283eda9b6f9eb513b0e8572c8a9efaa79f"}], "stats": {"total": 473, "additions": 473, "deletions": 0}, "files": [{"sha": "370fcac7bf9bc6faa658a690469f9dd699c344a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -1,3 +1,41 @@\n+2009-10-08  Cary Coutant  <ccoutant@google.com>\n+\n+\tAdd support for debugging with ICF (Identical Code Folding).\n+\t* calls.c (debug.h): New #include.\n+\t(emit_call_1): Call virtual_call_token debug hook.\n+\t* common.opt (-fenable-icf-debug): New option.\n+\t* dwarf2out.c (dwarf2_debug_hooks): Add entries for new hooks (two\n+\tlocations in the source).\n+\t(poc_label_num): New variable.\n+\t(dcall_entry, vcall_entry): New typedefs.\n+\t(dcall_table, vcall_table): New variables.\n+\t(struct vcall_insn): New type.\n+\t(vcall_insn_table): New variable.\n+\t(DEBUG_DCALL_SECTION, DEBUG_VCALL_SECTION): New macros.\n+\t(size_of_dcall_table): New function.\n+\t(output_dcall_table): New function.\n+\t(size_of_vcall_table): New function.\n+\t(output_vcall_table): New function.\n+\t(dwarf2out_direct_call): New function.\n+\t(vcall_insn_table_hash): New function.\n+\t(vcall_insn_table_eq): New function.\n+\t(dwarf2out_virtual_call_token): New function.\n+\t(dwarf2out_virtual_call): New function.\n+\t(dwarf2out_init): Allocate new tables and sections.\n+\t(prune_unused_types): Mark DIEs referenced from direct call table.\n+\t(dwarf2out_finish): Output direct and virtual call tables.\n+\t* final.c (final_scan_insn): Call direct_call and virtual_call\n+\tdebug hooks.\n+\t* debug.h (struct gcc_debug_hooks): Add direct_call,\n+\tvirtual_call_token, virtual_call hooks.\n+\t(debug_nothing_uid): New function.\n+\t* debug.c (do_nothing_debug_hooks): Add dummy entries for new hooks.\n+\t(debug_nothing_uid): New function.\n+\t* dbxout.c (dbx_debug_hooks): Add dummy entries for new hooks.\n+\t* sdbout.c (sdb_debug_hooks): Likewise.\n+\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n+\t* doc/invoke.texi (-fenable-icf-debug): New option.\n+\n 2009-10-08  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/41353"}, {"sha": "49e576e94c5d4c9fa6e6469080a208397c9cc08f", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sbitmap.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n+#include \"debug.h\"\n #include \"cgraph.h\"\n #include \"except.h\"\n #include \"dbgcnt.h\"\n@@ -394,6 +395,11 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \n   SIBLING_CALL_P (call_insn) = ((ecf_flags & ECF_SIBCALL) != 0);\n \n+  /* Record debug information for virtual calls.  */\n+  if (flag_enable_icf_debug && fndecl == NULL)\n+    (*debug_hooks->virtual_call_token) (CALL_EXPR_FN (fntree),\n+                                        INSN_UID (call_insn));\n+\n   /* Restore this now, so that we do defer pops for this call's args\n      if the context of the call as a whole permits.  */\n   inhibit_defer_pop = old_inhibit_defer_pop;"}, {"sha": "dd2d8155c5e921938d31982e72598e03f57d47af", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -502,6 +502,10 @@ femit-class-debug-always\n Common Report Var(flag_emit_class_debug_always) Init(0)\n Do not suppress C++ class debug information.\n \n+fenable-icf-debug\n+Common Report Var(flag_enable_icf_debug)\n+Generate debug information to support Identical Code Folding (ICF)\n+\n fexceptions\n Common Report Var(flag_exceptions) Optimization\n Enable exception handling"}, {"sha": "d09087a2f2caacdce262a341dca3646ce7f1b7a1", "filename": "gcc/dbxout.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -373,6 +373,9 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   dbxout_handle_pch,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n   debug_nothing_void,                    /* switch_text_section */\n+  debug_nothing_tree,\t\t         /* direct_call */\n+  debug_nothing_tree_int,\t\t /* virtual_call_token */\n+  debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0                                      /* start_end_main_source_file */\n };\n@@ -406,6 +409,9 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   dbxout_handle_pch,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n   debug_nothing_void,                    /* switch_text_section */\n+  debug_nothing_tree,\t\t         /* direct_call */\n+  debug_nothing_tree_int,\t\t /* virtual_call_token */\n+  debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t         /* set_name */\n   0                                      /* start_end_main_source_file */\n };"}, {"sha": "8035c43ca4abf5811736eb21014f3496de2e9362", "filename": "gcc/debug.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -50,6 +50,9 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_int,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n   debug_nothing_void,                    /* switch_text_section */\n+  debug_nothing_tree,\t\t         /* direct_call */\n+  debug_nothing_tree_int,\t         /* virtual_call_token */\n+  debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0                                      /* start_end_main_source_file */\n };\n@@ -127,3 +130,8 @@ debug_nothing_tree_int (tree decl ATTRIBUTE_UNUSED,\n \t\t\tint local ATTRIBUTE_UNUSED)\n {\n }\n+\n+void\n+debug_nothing_uid (int uid ATTRIBUTE_UNUSED)\n+{\n+}"}, {"sha": "4009cd6a93b933d41dd02c6a28b47797ea210362", "filename": "gcc/debug.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -126,6 +126,25 @@ struct gcc_debug_hooks\n      text sections.  */\n   void (* switch_text_section) (void);\n \n+  /* Records a direct call to the function DECL, noting the point of call\n+     and the debug info for the function.  Called from final_scan_insn\n+     when ICF debugging is enabled.  */\n+  void (* direct_call) (tree decl);\n+\n+  /* Records the OBJ_TYPE_REF_TOKEN for a virtual call through ADDR, which\n+     for C++ is the vtable slot index, noting the INSN_UID for the call\n+     instruction.  Called from calls.c:emit_call_1 when ICF debugging is\n+     enabled.  It's necessary to do this during lowering because the\n+     call instruction and the OBJ_TYPE_REF become separated after that\n+     point.  */\n+  void (* virtual_call_token) (tree addr, int insn_uid);\n+\n+  /* Records a virtual call given INSN_UID, which is the UID of the call\n+     instruction.  The UID is then mapped to the vtable slot index noted\n+     during the lowering phase.  Called from final_scan_insn when ICF\n+     debugging is enabled.  */\n+  void (* virtual_call) (int insn_uid);\n+\n   /* Called from grokdeclarator.  Replaces the anonymous name with the\n      type name.  */\n   void (* set_name) (tree, tree);\n@@ -151,6 +170,7 @@ extern void debug_nothing_tree_int (tree, int);\n extern void debug_nothing_tree_tree_tree_bool (tree, tree, tree, bool);\n extern bool debug_true_const_tree (const_tree);\n extern void debug_nothing_rtx (rtx);\n+extern void debug_nothing_uid (int);\n \n /* Hooks for various debug formats.  */\n extern const struct gcc_debug_hooks do_nothing_debug_hooks;"}, {"sha": "da7afeaba1e9bb7f4359f66866a0b65f3c7f15be", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -307,6 +307,7 @@ Objective-C and Objective-C++ Dialects}.\n -fcompare-debug@r{[}=@var{opts}@r{]}  -fcompare-debug-second @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n -feliminate-unused-debug-symbols -femit-class-debug-always @gol\n+-fenable-icf-debug @gol\n -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol\n@@ -4609,6 +4610,11 @@ The default is @samp{-femit-struct-debug-detailed=all}.\n \n This option works only with DWARF 2.\n \n+@item -fenable-icf-debug\n+@opindex fenable-icf-debug\n+Generate additional debug information to support identical code folding (ICF).\n+This option only works with DWARF version 2 or higher.\n+\n @item -fno-merge-debug-strings\n @opindex fmerge-debug-strings\n @opindex fno-merge-debug-strings"}, {"sha": "27f2c458ca0bd21d1136da557e9b220cec55bde1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -224,6 +224,8 @@ static GTY(()) section *debug_line_section;\n static GTY(()) section *debug_loc_section;\n static GTY(()) section *debug_pubnames_section;\n static GTY(()) section *debug_pubtypes_section;\n+static GTY(()) section *debug_dcall_section;\n+static GTY(()) section *debug_vcall_section;\n static GTY(()) section *debug_str_section;\n static GTY(()) section *debug_ranges_section;\n static GTY(()) section *debug_frame_section;\n@@ -5413,6 +5415,9 @@ static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,\n \t\t\t\t\t\t dw_die_ref);\n static void dwarf2out_abstract_function (tree);\n static void dwarf2out_var_location (rtx);\n+static void dwarf2out_direct_call (tree);\n+static void dwarf2out_virtual_call_token (tree, int);\n+static void dwarf2out_virtual_call (int);\n static void dwarf2out_begin_function (tree);\n static void dwarf2out_set_name (tree, tree);\n \n@@ -5448,6 +5453,9 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   debug_nothing_int,\t\t/* handle_pch */\n   dwarf2out_var_location,\n   dwarf2out_switch_text_section,\n+  dwarf2out_direct_call,\n+  dwarf2out_virtual_call_token,\n+  dwarf2out_virtual_call,\n   dwarf2out_set_name,\n   1                             /* start_end_main_source_file */\n };\n@@ -5828,6 +5836,45 @@ static GTY(()) bool have_location_lists;\n /* Unique label counter.  */\n static GTY(()) unsigned int loclabel_num;\n \n+/* Unique label counter for point-of-call tables.  */\n+static GTY(()) unsigned int poc_label_num;\n+\n+/* The direct call table structure.  */\n+\n+typedef struct GTY(()) dcall_struct {\n+  unsigned int poc_label_num;\n+  tree poc_decl;\n+  dw_die_ref targ_die;\n+}\n+dcall_entry;\n+\n+DEF_VEC_O(dcall_entry);\n+DEF_VEC_ALLOC_O(dcall_entry, gc);\n+\n+/* The virtual call table structure.  */\n+\n+typedef struct GTY(()) vcall_struct {\n+  unsigned int poc_label_num;\n+  unsigned int vtable_slot;\n+}\n+vcall_entry;\n+\n+DEF_VEC_O(vcall_entry);\n+DEF_VEC_ALLOC_O(vcall_entry, gc);\n+\n+/* Pointers to the direct and virtual call tables.  */\n+static GTY (()) VEC (dcall_entry, gc) * dcall_table = NULL;\n+static GTY (()) VEC (vcall_entry, gc) * vcall_table = NULL;\n+\n+/* A hash table to map INSN_UIDs to vtable slot indexes.  */\n+\n+struct GTY (()) vcall_insn {\n+  int insn_uid;\n+  unsigned int vtable_slot;\n+};\n+\n+static GTY ((param_is (struct vcall_insn))) htab_t vcall_insn_table;\n+\n #ifdef DWARF2_DEBUGGING_INFO\n /* Record whether the function being analyzed contains inlined functions.  */\n static int current_function_has_inlines;\n@@ -6165,6 +6212,12 @@ static void gen_remaining_tmpl_value_param_die_attribute (void);\n #ifndef DEBUG_PUBTYPES_SECTION\n #define DEBUG_PUBTYPES_SECTION\t\".debug_pubtypes\"\n #endif\n+#ifndef DEBUG_DCALL_SECTION\n+#define DEBUG_DCALL_SECTION\t\".debug_dcall\"\n+#endif\n+#ifndef DEBUG_VCALL_SECTION\n+#define DEBUG_VCALL_SECTION\t\".debug_vcall\"\n+#endif\n #ifndef DEBUG_STR_SECTION\n #define DEBUG_STR_SECTION\t\".debug_str\"\n #endif\n@@ -11684,6 +11737,129 @@ output_line_info (void)\n   /* Output the marker for the end of the line number info.  */\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n }\n+\n+/* Return the size of the .debug_dcall table for the compilation unit.  */\n+\n+static unsigned long\n+size_of_dcall_table (void)\n+{\n+  unsigned long size;\n+  unsigned int i;\n+  dcall_entry *p;\n+  tree last_poc_decl = NULL;\n+\n+  /* Header:  version + debug info section pointer + pointer size.  */\n+  size = 2 + DWARF_OFFSET_SIZE + 1;\n+\n+  /* Each entry:  code label + DIE offset.  */\n+  for (i = 0; VEC_iterate (dcall_entry, dcall_table, i, p); i++)\n+    {\n+      gcc_assert (p->targ_die != NULL);\n+      /* Insert a \"from\" entry when the point-of-call DIE offset changes.  */\n+      if (p->poc_decl != last_poc_decl)\n+        {\n+          dw_die_ref poc_die = lookup_decl_die (p->poc_decl);\n+          gcc_assert (poc_die);\n+          last_poc_decl = p->poc_decl;\n+          if (poc_die)\n+            size += (DWARF_OFFSET_SIZE\n+                     + size_of_uleb128 (poc_die->die_offset));\n+        }\n+      size += DWARF_OFFSET_SIZE + size_of_uleb128 (p->targ_die->die_offset);\n+    }\n+\n+  return size;\n+}\n+\n+/* Output the direct call table used to disambiguate PC values when\n+   identical function have been merged.  */\n+\n+static void\n+output_dcall_table (void)\n+{\n+  unsigned i;\n+  unsigned long dcall_length = size_of_dcall_table ();\n+  dcall_entry *p;\n+  char poc_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  tree last_poc_decl = NULL;\n+\n+  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+    dw2_asm_output_data (4, 0xffffffff,\n+      \"Initial length escape value indicating 64-bit DWARF extension\");\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, dcall_length,\n+\t\t       \"Length of Direct Call Table\");\n+  dw2_asm_output_data (2, 4, \"Version number\");\n+  dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n+\t\t\t debug_info_section,\n+\t\t\t \"Offset of Compilation Unit Info\");\n+  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n+\n+  for (i = 0; VEC_iterate (dcall_entry, dcall_table, i, p); i++)\n+    {\n+      /* Insert a \"from\" entry when the point-of-call DIE offset changes.  */\n+      if (p->poc_decl != last_poc_decl)\n+        {\n+          dw_die_ref poc_die = lookup_decl_die (p->poc_decl);\n+          last_poc_decl = p->poc_decl;\n+          if (poc_die)\n+            {\n+              dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, \"New caller\");\n+              dw2_asm_output_data_uleb128 (poc_die->die_offset,\n+                                           \"Caller DIE offset\");\n+            }\n+        }\n+      ASM_GENERATE_INTERNAL_LABEL (poc_label, \"LPOC\", p->poc_label_num);\n+      dw2_asm_output_addr (DWARF_OFFSET_SIZE, poc_label, \"Point of call\");\n+      dw2_asm_output_data_uleb128 (p->targ_die->die_offset,\n+                                   \"Callee DIE offset\");\n+    }\n+}\n+\f\n+/* Return the size of the .debug_vcall table for the compilation unit.  */\n+\n+static unsigned long\n+size_of_vcall_table (void)\n+{\n+  unsigned long size;\n+  unsigned int i;\n+  vcall_entry *p;\n+\n+  /* Header:  version + pointer size.  */\n+  size = 2 + 1;\n+\n+  /* Each entry:  code label + vtable slot index.  */\n+  for (i = 0; VEC_iterate (vcall_entry, vcall_table, i, p); i++)\n+    size += DWARF_OFFSET_SIZE + size_of_uleb128 (p->vtable_slot);\n+\n+  return size;\n+}\n+\n+/* Output the virtual call table used to disambiguate PC values when\n+   identical function have been merged.  */\n+\n+static void\n+output_vcall_table (void)\n+{\n+  unsigned i;\n+  unsigned long vcall_length = size_of_vcall_table ();\n+  vcall_entry *p;\n+  char poc_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+    dw2_asm_output_data (4, 0xffffffff,\n+      \"Initial length escape value indicating 64-bit DWARF extension\");\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, vcall_length,\n+\t\t       \"Length of Virtual Call Table\");\n+  dw2_asm_output_data (2, 4, \"Version number\");\n+  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n+\n+  for (i = 0; VEC_iterate (vcall_entry, vcall_table, i, p); i++)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (poc_label, \"LPOC\", p->poc_label_num);\n+      dw2_asm_output_addr (DWARF_OFFSET_SIZE, poc_label, \"Point of call\");\n+      dw2_asm_output_data_uleb128 (p->vtable_slot, \"Vtable slot\");\n+    }\n+}\n \f\n /* Given a pointer to a tree node for some base type, return a pointer to\n    a DIE that describes the given type.\n@@ -19709,6 +19885,103 @@ dwarf2out_set_name (tree decl, tree name)\n     add_name_attribute (die, dwarf2_name (name, 0));\n }\n \n+/* Called by the final INSN scan whenever we see a direct function call.\n+   Make an entry into the direct call table, recording the point of call\n+   and a reference to the target function's debug entry.  */\n+\n+static void\n+dwarf2out_direct_call (tree targ)\n+{\n+  dcall_entry e;\n+  tree origin = decl_ultimate_origin (targ);\n+\n+  /* If this is a clone, use the abstract origin as the target.  */\n+  if (origin)\n+    targ = origin;\n+\n+  e.poc_label_num = poc_label_num++;\n+  e.poc_decl = current_function_decl;\n+  e.targ_die = force_decl_die (targ);\n+  VEC_safe_push (dcall_entry, gc, dcall_table, &e);\n+\n+  /* Drop a label at the return point to mark the point of call.  */\n+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LPOC\", e.poc_label_num);\n+}\n+\n+/* Returns a hash value for X (which really is a struct vcall_insn).  */\n+\n+static hashval_t\n+vcall_insn_table_hash (const void *x)\n+{\n+  return (hashval_t) ((const struct vcall_insn *) x)->insn_uid;\n+}\n+\n+/* Return nonzero if insn_uid of struct vcall_insn *X is the same as\n+   insnd_uid of *Y.  */\n+\n+static int\n+vcall_insn_table_eq (const void *x, const void *y)\n+{\n+  return (((const struct vcall_insn *) x)->insn_uid\n+          == ((const struct vcall_insn *) y)->insn_uid);\n+}\n+\n+/* Called when lowering indirect calls to RTL.  We make a note of INSN_UID\n+   and the OBJ_TYPE_REF_TOKEN from ADDR.  For C++ virtual calls, the token\n+   is the vtable slot index that we will need to put in the virtual call\n+   table later.  */\n+\n+static void\n+dwarf2out_virtual_call_token (tree addr, int insn_uid)\n+{\n+  if (is_cxx() && TREE_CODE (addr) == OBJ_TYPE_REF)\n+    {\n+      tree token = OBJ_TYPE_REF_TOKEN (addr);\n+      if (TREE_CODE (token) == INTEGER_CST)\n+        {\n+          struct vcall_insn *item = GGC_NEW (struct vcall_insn);\n+          struct vcall_insn **slot;\n+\n+          gcc_assert (item);\n+          item->insn_uid = insn_uid;\n+          item->vtable_slot = TREE_INT_CST_LOW (token);\n+          slot = (struct vcall_insn **)\n+              htab_find_slot_with_hash (vcall_insn_table, &item,\n+                                        (hashval_t) insn_uid, INSERT);\n+          *slot = item;\n+        }\n+    }\n+}\n+\n+/* Called by the final INSN scan whenever we see a virtual function call.\n+   Make an entry into the virtual call table, recording the point of call\n+   and the slot index of the vtable entry used to call the virtual member\n+   function.  The slot index was associated with the INSN_UID during the\n+   lowering to RTL.  */\n+\n+static void\n+dwarf2out_virtual_call (int insn_uid)\n+{\n+  vcall_entry e;\n+  struct vcall_insn item;\n+  struct vcall_insn *p;\n+\n+  item.insn_uid = insn_uid;\n+  item.vtable_slot = 0;\n+  p = (struct vcall_insn *) htab_find_with_hash (vcall_insn_table,\n+                                                 (void *) &item,\n+                                                 (hashval_t) insn_uid);\n+  if (p == NULL)\n+    return;\n+\n+  e.poc_label_num = poc_label_num++;\n+  e.vtable_slot = p->vtable_slot;\n+  VEC_safe_push (vcall_entry, gc, vcall_table, &e);\n+\n+  /* Drop a label at the return point to mark the point of call.  */\n+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LPOC\", e.poc_label_num);\n+}\n+\n /* Called by the final INSN scan whenever we see a var location.  We\n    use it to drop labels in the right places, and throw the location in\n    our lookup table.  */\n@@ -19997,6 +20270,10 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   pubname_table = VEC_alloc (pubname_entry, gc, 32);\n   pubtype_table = VEC_alloc (pubname_entry, gc, 32);\n \n+  /* Allocate the table that maps insn UIDs to vtable slot indexes.  */\n+  vcall_insn_table = htab_create_ggc (10, vcall_insn_table_hash,\n+                                      vcall_insn_table_eq, NULL);\n+\n   /* Generate the initial DIE for the .debug section.  Note that the (string)\n      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE\n      will (typically) be a relative pathname and that this pathname should be\n@@ -20025,6 +20302,10 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \t\t\t\t\tSECTION_DEBUG, NULL);\n   debug_pubtypes_section = get_section (DEBUG_PUBTYPES_SECTION,\n \t\t\t\t\tSECTION_DEBUG, NULL);\n+  debug_dcall_section = get_section (DEBUG_DCALL_SECTION,\n+\t\t\t             SECTION_DEBUG, NULL);\n+  debug_vcall_section = get_section (DEBUG_VCALL_SECTION,\n+\t\t\t\t     SECTION_DEBUG, NULL);\n   debug_str_section = get_section (DEBUG_STR_SECTION,\n \t\t\t\t   DEBUG_STR_SECTION_FLAGS, NULL);\n   debug_ranges_section = get_section (DEBUG_RANGES_SECTION,\n@@ -20399,6 +20680,7 @@ prune_unused_types (void)\n   limbo_die_node *node;\n   comdat_type_node *ctnode;\n   pubname_ref pub;\n+  dcall_entry *dcall;\n \n #if ENABLE_ASSERT_CHECKING\n   /* All the marks should already be clear.  */\n@@ -20429,6 +20711,10 @@ prune_unused_types (void)\n   for (i = 0; i < arange_table_in_use; i++)\n     prune_unused_types_mark (arange_table[i], 1);\n \n+  /* Mark nodes referenced from the direct call table.  */\n+  for (i = 0; VEC_iterate (dcall_entry, dcall_table, i, dcall); i++)\n+    prune_unused_types_mark (dcall->targ_die, 1);\n+\n   /* Get rid of nodes that aren't marked; and update the string counts.  */\n   if (debug_str_hash && debug_str_hash_forced)\n     htab_traverse (debug_str_hash, prune_indirect_string, NULL);\n@@ -20890,6 +21176,18 @@ dwarf2out_finish (const char *filename)\n       output_pubnames (pubtype_table);\n     }\n \n+  /* Output direct and virtual call tables if necessary.  */\n+  if (!VEC_empty (dcall_entry, dcall_table))\n+    {\n+      switch_to_section (debug_dcall_section);\n+      output_dcall_table ();\n+    }\n+  if (!VEC_empty (vcall_entry, vcall_table))\n+    {\n+      switch_to_section (debug_vcall_section);\n+      output_vcall_table ();\n+    }\n+\n   /* Output the address range information.  We only put functions in the arange\n      table, so don't write it out if we don't have any.  */\n   if (fde_table_in_use)\n@@ -20960,6 +21258,9 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   0,\t\t/* handle_pch */\n   0,\t\t/* var_location */\n   0,\t\t/* switch_text_section */\n+  0,\t\t/* direct_call */\n+  0,\t\t/* virtual_call_token */\n+  0,\t\t/* virtual_call */\n   0,\t\t/* set_name */\n   0\t\t/* start_end_main_source_file */\n };"}, {"sha": "b8f5e513817904a17fe9e6b8a16c33a837d6ad7f", "filename": "gcc/final.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -2684,6 +2684,26 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t/* Output assembler code from the template.  */\n \toutput_asm_insn (templ, recog_data.operand);\n \n+\t/* Record point-of-call information for ICF debugging.  */\n+\tif (flag_enable_icf_debug && CALL_P (insn))\n+\t  {\n+\t    rtx x = call_from_call_insn (insn);\n+\t    x = XEXP (x, 0);\n+\t    if (x && MEM_P (x))\n+\t      {\n+\t        if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n+\t          {\n+\t\t    tree t;\n+\t\t    x = XEXP (x, 0);\n+\t\t    t = SYMBOL_REF_DECL (x);\n+\t\t    if (t)\n+\t\t      (*debug_hooks->direct_call) (t);\n+\t          }\n+\t        else\n+\t          (*debug_hooks->virtual_call) (INSN_UID (insn));\n+\t      }\n+\t  }\n+\n \t/* Some target machines need to postscan each insn after\n \t   it is output.  */\n \tif (targetm.asm_out.final_postscan_insn)"}, {"sha": "0553740b968c5b0f4a797a8bd979f6163ef51357", "filename": "gcc/sdbout.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -337,6 +337,9 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   debug_nothing_int,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n   debug_nothing_void,                    /* switch_text_section */\n+  debug_nothing_tree,\t\t         /* direct_call */\n+  debug_nothing_tree_int,\t\t /* virtual_call_token */\n+  debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0                                      /* start_end_main_source_file */\n };\n@@ -1725,6 +1728,9 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   0,\t\t/* handle_pch */\n   0,\t\t/* var_location */\n   0,\t\t/* switch_text_section */\n+  0,\t\t/* direct_call */\n+  0,\t\t/* virtual_call_token */\n+  0,\t\t/* virtual_call */\n   0,\t\t/* set_name */\n   0\t\t/* start_end_main_source_file */\n };"}, {"sha": "65e739fe7121d1fd525466051a3a2e806065f34c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -1,3 +1,8 @@\n+2009-10-08  Cary Coutant  <ccoutant@google.com>\n+\n+\tAdd support for debugging with ICF (Identical Code Folding).\n+\t* g++.dg/debug/dwarf2/icf.C: New test.\n+\n 2009-10-08  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/truncate-6.c: New test."}, {"sha": "627b8347797a3cff22f9d195d7e61626fff7cabe", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/icf.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ficf.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ficf.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ficf.C?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -0,0 +1,50 @@\n+// Test support for ICF debugging. \n+// { dg-do compile }\n+// { dg-options \"-O0 -gdwarf-2 -fenable-icf-debug -dA\" }\n+\n+class A\n+{\n+ public:\n+  A();\n+  virtual void work();\n+  virtual int p();\n+ private:\n+  int i;\n+};\n+\n+class B\n+{\n+ public:\n+  B();\n+  ~B();\n+  void work(const A* a);\n+ private:\n+  int j;\n+};\n+\n+int\n+test1(A* a)\n+{\n+  a->work();\n+}\n+\n+int\n+test2(A* a)\n+{\n+  if (a->p())\n+    {\n+      B b;\n+      b.work(a);\n+    }\n+}\n+\n+// Verify that we get .debug_dcall and .debug_vcall tables generated\n+// and that we see entries for both virtual calls. \n+// { dg-final { scan-assembler \"\\\\.section.*\\.debug_dcall\" } }\n+// { dg-final { scan-assembler \"\\\\.section.*\\.debug_vcall\" } }\n+// { dg-final { scan-assembler \"New caller\" } }\n+// { dg-final { scan-assembler \"Caller DIE offset\" } }\n+// { dg-final { scan-assembler \"Point of call\" } }\n+// { dg-final { scan-assembler \"Callee DIE offset\" } }\n+// { dg-final { scan-assembler \"0x0.*Vtable slot\" } }\n+// { dg-final { scan-assembler \"0x1.*Vtable slot\" } }"}, {"sha": "0fab5e73ae20ad5cf676d9d5a7910e9afd1a96f6", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77831620cf45a82c54a85091dcdc9e0affea47a9/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=77831620cf45a82c54a85091dcdc9e0affea47a9", "patch": "@@ -213,6 +213,9 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    debug_nothing_int,\t\t  /* handle_pch */\n    debug_nothing_rtx,\t\t  /* var_location */\n    debug_nothing_void,            /* switch_text_section */\n+   debug_nothing_tree,\t\t  /* direct_call */\n+   debug_nothing_tree_int,\t  /* virtual_call_token */\n+   debug_nothing_uid,\t\t  /* virtual_call */\n    debug_nothing_tree_tree,\t  /* set_name */\n    0                              /* start_end_main_source_file */\n };"}]}