{"sha": "cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwYjJkMzYxZGY4MmM4NDhkYzdlMWMzMDc4NjUxYmIwNjI0YzNjNg==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2019-01-18T10:32:40Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2019-01-18T10:32:40Z"}, "message": "[AArch64] Add support for system register based stack protector canary access\n\n2019-01-18  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n        * config/aarch64/aarch64-opts.h (enum stack_protector_guard): New\n        * config/aarch64/aarch64.c (aarch64_override_options_internal): Handle\n        and put in error checks for stack protector guard options.\n        (aarch64_stack_protect_guard): New.\n        (TARGET_STACK_PROTECT_GUARD): Define.\n        * config/aarch64/aarch64.md (UNSPEC_SSP_SYSREG): New.\n        (reg_stack_protect_address<mode>): New.\n        (stack_protect_set): Adjust for SSP_GLOBAL.\n        (stack_protect_test): Likewise.\n        * config/aarch64/aarch64.opt (-mstack-protector-guard-reg): New.\n        (-mstack-protector-guard): Likewise.\n        (-mstack-protector-guard-offset): Likewise.\n\nFrom-SVN: r268068", "tree": {"sha": "9bf64856b6da788ce37851a53348ede044c34ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bf64856b6da788ce37851a53348ede044c34ba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/comments", "author": null, "committer": null, "parents": [{"sha": "d0bf921f6a0b8ffdad74fa5eb5ddf2e70a9acfd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0bf921f6a0b8ffdad74fa5eb5ddf2e70a9acfd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0bf921f6a0b8ffdad74fa5eb5ddf2e70a9acfd6"}], "stats": {"total": 206, "additions": 201, "deletions": 5}, "files": [{"sha": "6dbff4b08213540f20efc31a9391c9f372ad10cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "patch": "@@ -1,3 +1,18 @@\n+2019-01-18  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+        * config/aarch64/aarch64-opts.h (enum stack_protector_guard): New\n+        * config/aarch64/aarch64.c (aarch64_override_options_internal): Handle\n+        and put in error checks for stack protector guard options.\n+        (aarch64_stack_protect_guard): New.\n+        (TARGET_STACK_PROTECT_GUARD): Define.\n+        * config/aarch64/aarch64.md (UNSPEC_SSP_SYSREG): New.\n+        (reg_stack_protect_address<mode>): New.\n+        (stack_protect_set): Adjust for SSP_GLOBAL.\n+        (stack_protect_test): Likewise.\n+        * config/aarch64/aarch64.opt (-mstack-protector-guard-reg): New.\n+        (-mstack-protector-guard): Likewise.\n+        (-mstack-protector-guard-offset): Likewise.\n+\n 2019-01-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/86214"}, {"sha": "4b07d296a115933d9da87272dd65e90cd90bd10f", "filename": "gcc/config/aarch64/aarch64-opts.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h?ref=cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "patch": "@@ -92,4 +92,10 @@ enum aarch64_sve_vector_bits_enum {\n   SVE_2048 = 2048\n };\n \n+/* Where to get the canary for the stack protector.  */\n+enum stack_protector_guard {\n+  SSP_SYSREG,\t\t\t/* per-thread canary in special system register */\n+  SSP_GLOBAL\t\t\t/* global canary */\n+};\n+\n #endif"}, {"sha": "e13badaf6cf90cc9c9d121db86ac5161277d8c3f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "patch": "@@ -11409,6 +11409,41 @@ aarch64_override_options_internal (struct gcc_options *opts)\n   if (opts->x_flag_strict_volatile_bitfields < 0 && abi_version_at_least (2))\n     opts->x_flag_strict_volatile_bitfields = 1;\n \n+  if (aarch64_stack_protector_guard == SSP_GLOBAL\n+      && opts->x_aarch64_stack_protector_guard_offset_str)\n+    {\n+      error (\"incompatible options -mstack-protector-guard=global and\"\n+\t     \"-mstack-protector-guard-offset=%qs\",\n+\t     aarch64_stack_protector_guard_offset_str);\n+    }\n+\n+  if (aarch64_stack_protector_guard == SSP_SYSREG\n+      && !(opts->x_aarch64_stack_protector_guard_offset_str\n+\t   && opts->x_aarch64_stack_protector_guard_reg_str))\n+    {\n+      error (\"both -mstack-protector-guard-offset and \"\n+\t     \"-mstack-protector-guard-reg must be used \"\n+\t     \"with -mstack-protector-guard=sysreg\");\n+    }\n+\n+  if (opts->x_aarch64_stack_protector_guard_reg_str)\n+    {\n+      if (strlen (opts->x_aarch64_stack_protector_guard_reg_str) > 100)\n+\t  error (\"specify a system register with a small string length.\");\n+    }\n+\n+  if (opts->x_aarch64_stack_protector_guard_offset_str)\n+    {\n+      char *end;\n+      const char *str = aarch64_stack_protector_guard_offset_str;\n+      errno = 0;\n+      long offs = strtol (aarch64_stack_protector_guard_offset_str, &end, 0);\n+      if (!*str || *end || errno)\n+\terror (\"%qs is not a valid offset in %qs\", str,\n+\t       \"-mstack-protector-guard-offset=\");\n+      aarch64_stack_protector_guard_offset = offs;\n+    }\n+\n   initialize_aarch64_code_model (opts);\n   initialize_aarch64_tls_size (opts);\n \n@@ -18671,8 +18706,24 @@ aarch64_run_selftests (void)\n \n } // namespace selftest\n \n+/* Implement TARGET_STACK_PROTECT_GUARD. In case of a\n+   global variable based guard use the default else\n+   return a null tree.  */\n+static tree\n+aarch64_stack_protect_guard (void)\n+{\n+  if (aarch64_stack_protector_guard == SSP_GLOBAL)\n+    return default_stack_protect_guard ();\n+\n+  return NULL_TREE;\n+}\n+\n+\n #endif /* #if CHECKING_P */\n \n+#undef TARGET_STACK_PROTECT_GUARD\n+#define TARGET_STACK_PROTECT_GUARD aarch64_stack_protect_guard\n+\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST aarch64_address_cost\n "}, {"sha": "b7f6fe0f1354f7aa19076a946ed2c633b9b9b8da", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "patch": "@@ -201,6 +201,7 @@\n     UNSPEC_UCVTF\n     UNSPEC_USHL_2S\n     UNSPEC_VSTRUCTDUMMY\n+    UNSPEC_SSP_SYSREG\n     UNSPEC_SP_SET\n     UNSPEC_SP_TEST\n     UNSPEC_RSQRT\n@@ -6774,13 +6775,46 @@\n   \"\"\n {\n   machine_mode mode = GET_MODE (operands[0]);\n+  if (aarch64_stack_protector_guard != SSP_GLOBAL)\n+  {\n+    /* Generate access through the system register.  */\n+    rtx tmp_reg = gen_reg_rtx (mode);\n+    if (mode == DImode)\n+    {\n+        emit_insn (gen_reg_stack_protect_address_di (tmp_reg));\n+        emit_insn (gen_adddi3 (tmp_reg, tmp_reg,\n+\t\t\t       GEN_INT (aarch64_stack_protector_guard_offset)));\n+    }\n+    else\n+    {\n+\temit_insn (gen_reg_stack_protect_address_si (tmp_reg));\n+\temit_insn (gen_addsi3 (tmp_reg, tmp_reg,\n+\t\t\t       GEN_INT (aarch64_stack_protector_guard_offset)));\n \n+    }\n+    operands[1] = gen_rtx_MEM (mode, tmp_reg);\n+  }\n+  \n   emit_insn ((mode == DImode\n \t      ? gen_stack_protect_set_di\n \t      : gen_stack_protect_set_si) (operands[0], operands[1]));\n   DONE;\n })\n \n+(define_insn \"reg_stack_protect_address_<mode>\"\n+ [(set (match_operand:PTR 0 \"register_operand\" \"=r\")\n+       (unspec:PTR [(const_int 0)]\n+\tUNSPEC_SSP_SYSREG))]\n+ \"aarch64_stack_protector_guard != SSP_GLOBAL\"\n+ {\n+   char buf[150];\n+   snprintf (buf, 150, \"mrs\\\\t%%<w>0, %s\",\n+\t    aarch64_stack_protector_guard_reg_str);\n+   output_asm_insn (buf, operands);\n+   return \"\";\n+ }\n+ [(set_attr \"type\" \"mrs\")])\n+\n (define_insn \"stack_protect_set_<mode>\"\n   [(set (match_operand:PTR 0 \"memory_operand\" \"=m\")\n \t(unspec:PTR [(match_operand:PTR 1 \"memory_operand\" \"m\")]\n@@ -6801,12 +6835,34 @@\n   machine_mode mode = GET_MODE (operands[0]);\n \n   result = gen_reg_rtx(mode);\n+  if (aarch64_stack_protector_guard != SSP_GLOBAL)\n+  {\n+    /* Generate access through the system register. The\n+       sequence we want here is the access\n+       of the stack offset to come with\n+       mrs scratch_reg, <system_register>\n+       add scratch_reg, scratch_reg, :lo12:offset. */\n+    rtx tmp_reg = gen_reg_rtx (mode);\n+    if (mode == DImode)\n+    {\n+       emit_insn (gen_reg_stack_protect_address_di (tmp_reg));\n+       emit_insn (gen_adddi3 (tmp_reg, tmp_reg,\n+       \t\t              GEN_INT (aarch64_stack_protector_guard_offset)));\n+    }\n+    else\n+    {\n+\temit_insn (gen_reg_stack_protect_address_si (tmp_reg));\n+\temit_insn (gen_addsi3 (tmp_reg, tmp_reg,\n+\t\t\t       GEN_INT (aarch64_stack_protector_guard_offset)));\n \n+    }\n+    operands[1] = gen_rtx_MEM (mode, tmp_reg);\n+  }\n   emit_insn ((mode == DImode\n-\t      ? gen_stack_protect_test_di\n-\t      : gen_stack_protect_test_si) (result,\n-\t\t\t\t\t    operands[0],\n-\t\t\t\t\t    operands[1]));\n+\t\t  ? gen_stack_protect_test_di\n+\t\t  : gen_stack_protect_test_si) (result,\n+\t\t\t\t\t        operands[0],\n+\t\t\t\t\t        operands[1]));\n \n   if (mode == DImode)\n     emit_jump_insn (gen_cbranchdi4 (gen_rtx_EQ (VOIDmode, result, const0_rtx),"}, {"sha": "5a1e687091cc3265bbaa5993251a8da0650abc40", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "patch": "@@ -225,3 +225,33 @@ Enables verbose cost model dumping in the debug dump files.\n mtrack-speculation\n Target Var(aarch64_track_speculation)\n Generate code to track when the CPU might be speculating incorrectly.\n+\n+mstack-protector-guard=\n+Target RejectNegative Joined Enum(stack_protector_guard) Var(aarch64_stack_protector_guard) Init(SSP_GLOBAL)\n+Use given stack-protector guard.\n+\n+Enum\n+Name(stack_protector_guard) Type(enum stack_protector_guard)\n+Valid arguments to -mstack-protector-guard=:\n+\n+EnumValue\n+Enum(stack_protector_guard) String(sysreg) Value(SSP_SYSREG)\n+\n+EnumValue\n+Enum(stack_protector_guard) String(global) Value(SSP_GLOBAL)\n+\n+mstack-protector-guard-reg=\n+Target Joined RejectNegative String Var(aarch64_stack_protector_guard_reg_str)\n+Use the system register specified on the command line as the stack protector\n+guard register. This option is for use with fstack-protector-strong and\n+not for use in user-land code.\n+\n+mstack-protector-guard-offset=\n+Target Joined RejectNegative String Var(aarch64_stack_protector_guard_offset_str)\n+Use an immediate to offset from the stack protector guard register, sp_el0.\n+This option is for use with fstack-protector-strong and not for use in\n+user-land code.\n+\n+TargetVariable\n+long aarch64_stack_protector_guard_offset = 0\n+"}, {"sha": "9997dcb7bb22f895780f8faf335083a066b32218", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0b2d361df82c848dc7e1c3078651bb0624c3c6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cd0b2d361df82c848dc7e1c3078651bb0624c3c6", "patch": "@@ -633,7 +633,9 @@ Objective-C and Objective-C++ Dialects}.\n -msign-return-address=@var{scope} @gol\n -mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}] @gol\n -march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}  @gol\n--moverride=@var{string}  -mverbose-cost-dump  -mtrack-speculation} \n+-moverride=@var{string}  -mverbose-cost-dump @gol\n+-mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{sysreg} @gol\n+-mstack-protector-guard-offset=@var{offset} -mtrack-speculation }\n \n @emph{Adapteva Epiphany Options}\n @gccoptlist{-mhalf-reg-file  -mprefer-short-insn-regs @gol\n@@ -15606,6 +15608,42 @@ object boundary as described in the architecture specification.\n Omit or keep the frame pointer in leaf functions.  The former behavior is the\n default.\n \n+@item -mstack-protector-guard=@var{guard}\n+@itemx -mstack-protector-guard-reg=@var{reg}\n+@itemx -mstack-protector-guard-offset=@var{offset}\n+@opindex mstack-protector-guard\n+@opindex mstack-protector-guard-reg\n+@opindex mstack-protector-guard-offset\n+Generate stack protection code using canary at @var{guard}.  Supported\n+locations are @samp{global} for a global canary or @samp{sysreg} for a\n+canary in an appropriate system register.\n+\n+With the latter choice the options\n+@option{-mstack-protector-guard-reg=@var{reg}} and\n+@option{-mstack-protector-guard-offset=@var{offset}} furthermore specify\n+which system register to use as base register for reading the canary,\n+and from what offset from that base register. There is no default\n+register or offset as this is entirely for use within the Linux\n+kernel.\n+\n+@item -mstack-protector-guard=@var{guard}\n+@itemx -mstack-protector-guard-reg=@var{reg}\n+@itemx -mstack-protector-guard-offset=@var{offset}\n+@opindex mstack-protector-guard\n+@opindex mstack-protector-guard-reg\n+@opindex mstack-protector-guard-offset\n+Generate stack protection code using canary at @var{guard}.  Supported\n+locations are @samp{global} for a global canary or @samp{sysreg} for a\n+canary in an appropriate system register.\n+\n+With the latter choice the options\n+@option{-mstack-protector-guard-reg=@var{reg}} and\n+@option{-mstack-protector-guard-offset=@var{offset}} furthermore specify\n+which system register to use as base register for reading the canary,\n+and from what offset from that base register. There is no default\n+register or offset as this is entirely for use within the Linux\n+kernel.\n+\n @item -mtls-dialect=desc\n @opindex mtls-dialect=desc\n Use TLS descriptors as the thread-local storage mechanism for dynamic accesses"}]}