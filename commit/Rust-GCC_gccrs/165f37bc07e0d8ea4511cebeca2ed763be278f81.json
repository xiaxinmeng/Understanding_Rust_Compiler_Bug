{"sha": "165f37bc07e0d8ea4511cebeca2ed763be278f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY1ZjM3YmMwN2UwZDhlYTQ1MTFjZWJlY2EyZWQ3NjNiZTI3OGY4MQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-03-23T07:01:24Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-03-23T07:01:24Z"}, "message": "[multiple changes]\n\n2000-03-22  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (check_abstract_method_definitions): New local\n\t`end_type_reached'. Make sure we also consider `end_type'.\n\t(java_check_abstract_method_definitions): Make sure we also\n\teventually consider `java.lang.Object'.\n\t(maybe_use_access_method): Don't use access method if not a pure\n\tinner class or if the method's context is right.\n\t(find_applicable_accessible_methods_list): New static\n\t`object_done'. Don't search abstract classes as interfaces. Fixed\n\tindentation. Fixed the `java.lang.Object' only search. Search class'\n\tinterface(s) first, fully search enclosing contexts.\n\t(find_most_specific_methods_list): Pick closest candidates when\n\tthey're all abstract.\n\n2000-03-17  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (check_method_types_complete): New function.\n\t(create_class): Reset anonymous class counter only when seeing an\n\tnon inner classe.\n\t(java_complete_class): JDEP_METHOD: Don't recompute signature\n\tif incomplete.\n\n2000-03-17  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* class.c (build_static_ref): Fixed indentation in comment.\n\t* java-tree.def (TRY_EXPR): Fixed typo in name.\n\t(CLASS_LITERAL): Likewise.\n\t* java-tree.h: (TYPE_DOT_CLASS): New macro.\n\t(struct lang_type): New field `dot_class'.\n\t* jcf-write.c (generate_bytecode_insns): Fixed error message.\n\t(generate_classfile): Method `class$' is synthetic.\n\t* parse.y (build_do_class_method): New function.\n\t(build_dot_class_method_invocation): Likewise.\n\t(java_complete_expand_methods): Expand TYPE_DOT_CLASS if necessary.\n\t(resolve_qualified_expression_name): Handle CLASS_LITERAL.\n\t(qualify_ambiguous_name): Likewise.\n\t(patch_incomplete_class_ref): Invoke synthetic method if necessary.\n\t(build_try_statement): Fixed leading comment.\n\n2000-03-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.h (INNER_ENCLOSING_SCOPE_CHECK): Disregard anonymous\n\tclasses.\n\t* parse.y (patch_method_invocation): Handle anonymous classes\n\tcreation in static context.\n\n2000-03-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.h (INNER_ENCLOSING_SCOPE_CHECK): New macro.\n\t* parse.y (resolve_qualified_expression_name): Use it.\n\t(patch_method_invocation): Likewise.\n\n2000-03-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (register_incomplete_type): JDEP_ENCLOSING set\n\tdepending on the type of dependency which dictates what the\n\tcurrent class is.\n\t(unresolved_type_p): Resolved types limited to the current class.\n\n(For details, see: http://gcc.gnu.org/ml/gcc-patches/2000-03/msg00790.html)\n\nFrom-SVN: r32701", "tree": {"sha": "adf1ca92ac2684768b4f5b55b6b09d452804b8b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf1ca92ac2684768b4f5b55b6b09d452804b8b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/165f37bc07e0d8ea4511cebeca2ed763be278f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165f37bc07e0d8ea4511cebeca2ed763be278f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/165f37bc07e0d8ea4511cebeca2ed763be278f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165f37bc07e0d8ea4511cebeca2ed763be278f81/comments", "author": null, "committer": null, "parents": [{"sha": "e4a3c2f682062d253798e0c177fbd400f5f70d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a3c2f682062d253798e0c177fbd400f5f70d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4a3c2f682062d253798e0c177fbd400f5f70d60"}], "stats": {"total": 1738, "additions": 1158, "deletions": 580}, "files": [{"sha": "09927d9c24f5559059e752e0519e237b7d71e852", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81", "patch": "@@ -1,3 +1,18 @@\n+2000-03-22  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (check_abstract_method_definitions): New local\n+\t`end_type_reached'. Make sure we also consider `end_type'.\n+\t(java_check_abstract_method_definitions): Make sure we also\n+\teventually consider `java.lang.Object'.\n+\t(maybe_use_access_method): Don't use access method if not a pure\n+\tinner class or if the method's context is right.\n+\t(find_applicable_accessible_methods_list): New static\n+\t`object_done'. Don't search abstract classes as interfaces. Fixed\n+\tindentation. Fixed the `java.lang.Object' only search. Search class'\n+\tinterface(s) first, fully search enclosing contexts. \n+\t(find_most_specific_methods_list): Pick closest candidates when\n+\tthey're all abstract.\n+\n Mon Mar 20 08:58:51 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* jcf-write.c (generate_bytecode_insns): TRY_FINALLY_EXPR:\n@@ -8,6 +23,31 @@ Mon Mar 20 08:58:51 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* except.c (emit_handlers): Clear catch_clauses_last.\n \n+2000-03-17  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (check_method_types_complete): New function.\n+\t(create_class): Reset anonymous class counter only when seeing an\n+\tnon inner classe.\n+\t(java_complete_class): JDEP_METHOD: Don't recompute signature\n+\tif incomplete.\n+\n+2000-03-17  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (build_static_ref): Fixed indentation in comment.\n+\t* java-tree.def (TRY_EXPR): Fixed typo in name.\n+\t(CLASS_LITERAL): Likewise.\n+\t* java-tree.h: (TYPE_DOT_CLASS): New macro.\n+\t(struct lang_type): New field `dot_class'.\n+\t* jcf-write.c (generate_bytecode_insns): Fixed error message.\n+\t(generate_classfile): Method `class$' is synthetic.\n+\t* parse.y (build_do_class_method): New function.\n+\t(build_dot_class_method_invocation): Likewise.\n+\t(java_complete_expand_methods): Expand TYPE_DOT_CLASS if necessary.\n+\t(resolve_qualified_expression_name): Handle CLASS_LITERAL.\n+\t(qualify_ambiguous_name): Likewise.\n+\t(patch_incomplete_class_ref): Invoke synthetic method if necessary.\n+\t(build_try_statement): Fixed leading comment.\n+\n Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* class.c (make_field_value): Properly handle sizes.\n@@ -35,6 +75,26 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* lang.c (lang_decode_option): Enable -Wunused when -Wall given.\n \n+2000-03-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.h (INNER_ENCLOSING_SCOPE_CHECK): Disregard anonymous\n+\tclasses.\n+\t* parse.y (patch_method_invocation): Handle anonymous classes\n+\tcreation in static context.\n+\n+2000-03-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.h (INNER_ENCLOSING_SCOPE_CHECK): New macro.\n+\t* parse.y (resolve_qualified_expression_name): Use it.\n+\t(patch_method_invocation): Likewise.\n+\n+2000-03-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (register_incomplete_type): JDEP_ENCLOSING set\n+\tdepending on the type of dependency which dictates what the\n+\tcurrent class is.\n+\t(unresolved_type_p): Resolved types limited to the current class.\n+\n 2000-03-15  Tom Tromey  <tromey@cygnus.com>\n \n \t* decl.c (init_decl_processing): Set type of `sync_info' to be"}, {"sha": "6252d376eb01ac3f2200227875f27ecd77003622", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81", "patch": "@@ -967,8 +967,7 @@ build_static_field_ref (fdecl)\n   else\n     {\n       /* Compile as:\n-       * *(FTYPE*)build_class_ref(FCLASS)->fields[INDEX].info.addr\n-       */\n+       * *(FTYPE*)build_class_ref(FCLASS)->fields[INDEX].info.addr */\n       static tree fields_ident = NULL_TREE;\n       static tree info_ident = NULL_TREE;\n       tree ref = build_class_ref (fclass);"}, {"sha": "aad5524e04477006f96612d625f03f01c4586648", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81", "patch": "@@ -50,7 +50,7 @@ DEFTREECODE (DEFAULT_EXPR, \"default\", 'x', 0)\n /* Try expression\n    Operand 0 is the tried block,\n    Operand 1 contains chained catch nodes. */\n-DEFTREECODE (TRY_EXPR, \"try-catch-finally\", 'e', 2)\n+DEFTREECODE (TRY_EXPR, \"try-catch\", 'e', 2)\n \n /* Catch clause.\n    Operand 0 is the catch clause block, which contains the declaration of\n@@ -86,7 +86,7 @@ DEFTREECODE (NEW_ARRAY_INIT, \"new_array_init\", '1', 1)\n /* Class literal.\n    Operand 0 is the name of the class we're trying to build a\n    reference from.  */\n-DEFTREECODE (CLASS_LITERAL, \"class_litteral\", '1', 1)\n+DEFTREECODE (CLASS_LITERAL, \"class_literal\", '1', 1)\n \n /* Instance initializer.\n    Operand 0 contains the intance initializer statement. This tree node"}, {"sha": "5aaceee2c0148d2a9f312e745d77304a266248b0", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81", "patch": "@@ -547,6 +547,9 @@ struct lang_decl_var\n #define TYPE_FINIT_STMT_LIST(T)  (TYPE_LANG_SPECIFIC(T)->finit_stmt_list)\n #define TYPE_CLINIT_STMT_LIST(T) (TYPE_LANG_SPECIFIC(T)->clinit_stmt_list)\n #define TYPE_II_STMT_LIST(T)     (TYPE_LANG_SPECIFIC(T)->ii_block)\n+/* The decl of the synthetic method `class$' used to handle `.class'\n+   for non primitive types when compiling to bytecode. */\n+#define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC(T)->dot_class)\n \n struct lang_type\n {\n@@ -557,6 +560,10 @@ struct lang_type\n   tree finit_stmt_list;\t\t/* List of statements $finit$ will use */\n   tree clinit_stmt_list;\t/* List of statements <clinit> will use  */\n   tree ii_block;\t\t/* Instance initializer block */\n+  tree dot_class;\t\t/* The decl of the `class$' function that\n+\t\t\t\t   needs to be invoked and generated when\n+\t\t\t\t   compiling to bytecode to implement\n+\t\t\t\t   <non_primitive_type>.class */\n };\n \n #ifdef JAVA_USE_HANDLES"}, {"sha": "f2df8c3e276c31abefdb894f77b088fa776240ad", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81", "patch": "@@ -2569,7 +2569,7 @@ generate_bytecode_insns (exp, target, state)\n       /* fall through */\n     notimpl:\n     default:\n-      error(\"internal error - tree code not implemented: %s\",\n+      error(\"internal error in generate_bytecode_insn - tree code not implemented: %s\",\n \t    tree_code_name [(int) TREE_CODE (exp)]);\n     }\n }\n@@ -2911,7 +2911,8 @@ generate_classfile (clas, state)\n \n       /* Make room for the Synthetic attribute (of zero length.)  */\n       if (DECL_FINIT_P (part) \n-\t  || OUTER_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (part)))\n+\t  || OUTER_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (part))\n+\t  || TYPE_DOT_CLASS (clas) == part)\n \t{\n \t  i++;\n \t  synthetic_p = 1;"}, {"sha": "7293d89d4a5ef4cc1370efe28f497915b9970f63", "filename": "gcc/java/parse.c", "status": "modified", "additions": 752, "deletions": 502, "changes": 1254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81"}, {"sha": "bea4b70a089539447288cd20cd0d4435728ac757", "filename": "gcc/java/parse.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81", "patch": "@@ -823,6 +823,17 @@ struct parser_ctxt {\n                                      TREE_VALUE (GET_ENCLOSING_CPC ()) :      \\\n \t\t\t\t     NULL_TREE)\n \n+/* Make sure that innerclass T sits in an appropriate enclosing\n+   context.  */\n+#define INNER_ENCLOSING_SCOPE_CHECK(T)\t\t\t\t\t\\\n+  (INNER_CLASS_TYPE_P ((T)) && !ANONYMOUS_CLASS_P ((T))\t\t\t\\\n+   /* We have a this and it's not the right one */\t\t\t\\\n+   && ((current_this\t\t\t\t\t\t\t\\\n+\t&& (DECL_CONTEXT (TYPE_NAME ((T)))\t\t\t\t\\\n+\t    != TYPE_NAME (TREE_TYPE (TREE_TYPE (current_this)))))\t\\\n+       /* We don't have a this. */\t\t\t\t\t\\\n+       || !current_this))\n+\n /* Push macro. First argument to PUSH_CPC is a DECL_TYPE, second\n    argument is the unqualified currently parsed class name.  */\n #define PUSH_CPC(C,R) { \t\t\t\t\t\\"}, {"sha": "985e3708a655f6e1d2faea4d25eedb649b6f49e9", "filename": "gcc/java/parse.y", "status": "modified", "additions": 322, "deletions": 72, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f37bc07e0d8ea4511cebeca2ed763be278f81/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=165f37bc07e0d8ea4511cebeca2ed763be278f81", "patch": "@@ -238,6 +238,7 @@ static void start_artificial_method_body PARAMS ((tree));\n static void end_artificial_method_body PARAMS ((tree));\n static int check_method_redefinition PARAMS ((tree, tree));\n static int reset_method_name PARAMS ((tree));\n+static int check_method_types_complete PARAMS ((tree));\n static void java_check_regular_methods PARAMS ((tree));\n static void java_check_abstract_methods PARAMS ((tree));\n static tree maybe_build_primttype_type_ref PARAMS ((tree, tree));\n@@ -314,6 +315,9 @@ static tree create_anonymous_class PARAMS ((int, tree));\n static void patch_anonymous_class PARAMS ((tree, tree, tree));\n static void add_inner_class_fields PARAMS ((tree, tree));\n \n+static tree build_dot_class_method PARAMS ((tree));\n+static tree build_dot_class_method_invocation PARAMS ((tree));\n+\n /* Number of error found so far. */\n int java_error_count; \n /* Number of warning found so far. */\n@@ -3832,8 +3836,8 @@ create_class (flags, id, super, interfaces)\n   /* Eventually sets the @deprecated tag flag */\n   CHECK_DEPRECATED (decl);\n \n-  /* Reset the anonymous class counter when declaring a toplevel class */\n-  if (TOPLEVEL_CLASS_DECL_P (decl))\n+  /* Reset the anonymous class counter when declaring non inner classes */\n+  if (!INNER_CLASS_DECL_P (decl))\n     anonymous_class_counter = 1;\n \n   return decl;\n@@ -4702,9 +4706,16 @@ unresolved_type_p (wfl, returned)\n {\n   if (TREE_CODE (wfl) == EXPR_WITH_FILE_LOCATION)\n     {\n-      tree decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (wfl));\n       if (returned)\n-\t*returned = (decl ? TREE_TYPE (decl) : NULL_TREE);\n+\t{\n+\t  tree decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (wfl));\n+\t  if (decl && current_class && (decl == TYPE_NAME (current_class)))\n+\t    *returned = TREE_TYPE (decl);\n+\t  else if (GET_CPC_UN () == EXPR_WFL_NODE (wfl))\n+\t    *returned = TREE_TYPE (GET_CPC ());\n+\t  else\n+\t    *returned = NULL_TREE;\n+\t}\n       return 1;\n     }\n   if (returned)\n@@ -4883,7 +4894,10 @@ register_incomplete_type (kind, wfl, decl, ptr)\n   JDEP_WFL (new) = wfl;\n   JDEP_CHAIN (new) = NULL;\n   JDEP_MISC (new) = NULL_TREE;\n-  if(!(JDEP_ENCLOSING (new) = GET_ENCLOSING_CPC_CONTEXT ()))\n+  if ((kind == JDEP_SUPER || kind == JDEP_INTERFACE)\n+      && GET_ENCLOSING_CPC ())\n+    JDEP_ENCLOSING (new) = TREE_VALUE (GET_ENCLOSING_CPC ());\n+  else\n     JDEP_ENCLOSING (new) = GET_CPC ();\n   JDEP_GET_PATCH (new) = (tree *)NULL;\n \n@@ -5228,9 +5242,14 @@ java_complete_class ()\n \t\t{\n \t\t  tree mdecl = JDEP_DECL (dep), signature;\n \t\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t\t  /* Recompute and reset the signature */\n-\t\t  signature = build_java_signature (TREE_TYPE (mdecl));\n-\t\t  set_java_signature (TREE_TYPE (mdecl), signature);\n+\t\t  /* Recompute and reset the signature, check first that\n+\t\t     all types are now defined. If they're not,\n+\t\t     dont build the signature. */\n+\t\t  if (check_method_types_complete (mdecl))\n+\t\t    {\n+\t\t      signature = build_java_signature (TREE_TYPE (mdecl));\n+\t\t      set_java_signature (TREE_TYPE (mdecl), signature);\n+\t\t    }\n \t\t  pop_obstacks ();\n \t\t}\n \t      else\n@@ -5698,6 +5717,7 @@ check_abstract_method_definitions (do_interface, class_decl, type)\n     {\n       tree other_super, other_method, method_sig, method_name;\n       int found = 0;\n+      int end_type_reached = 0;\n       \n       if (!METHOD_ABSTRACT (method) || METHOD_FINAL (method))\n \tcontinue;\n@@ -5711,27 +5731,31 @@ check_abstract_method_definitions (do_interface, class_decl, type)\n       if (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION)\n \tmethod_name = EXPR_WFL_NODE (method_name);\n \n-      for (other_super = class; other_super != end_type; \n-\t   other_super = CLASSTYPE_SUPER (other_super))\n-\t{\n-\t  for (other_method = TYPE_METHODS (other_super); other_method;\n-\t       other_method = TREE_CHAIN (other_method))\n-\t    {\n-\t      tree s = build_java_signature (TREE_TYPE (other_method));\n-\t      tree other_name = DECL_NAME (other_method);\n-\n-\t      if (TREE_CODE (other_name) == EXPR_WITH_FILE_LOCATION)\n-\t\tother_name = EXPR_WFL_NODE (other_name);\n-\t      if (!DECL_CLINIT_P (other_method)\n-\t\t  && !DECL_CONSTRUCTOR_P (other_method)\n-\t\t  && method_name == other_name && method_sig == s)\n-\t\t{\n-\t\t  found = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      \n+      other_super = class;\n+      do {\n+\tif (other_super == end_type)\n+\t  end_type_reached = 1;\n+\t\n+\t/* Method search */\n+\tfor (other_method = TYPE_METHODS (other_super); other_method;\n+            other_method = TREE_CHAIN (other_method))\n+\t  {\n+\t    tree s = build_java_signature (TREE_TYPE (other_method));\n+\t    tree other_name = DECL_NAME (other_method);\n+\t    \n+\t    if (TREE_CODE (other_name) == EXPR_WITH_FILE_LOCATION)\n+\t      other_name = EXPR_WFL_NODE (other_name);\n+\t    if (!DECL_CLINIT_P (other_method)\n+\t\t&& !DECL_CONSTRUCTOR_P (other_method)\n+\t\t&& method_name == other_name && method_sig == s)\n+             {\n+               found = 1;\n+               break;\n+             }\n+\t  }\n+\tother_super = CLASSTYPE_SUPER (other_super);\n+      } while (!end_type_reached);\n+ \n       /* Report that abstract METHOD didn't find an implementation\n \t that CLASS can use. */\n       if (!found)\n@@ -5781,14 +5805,11 @@ java_check_abstract_method_definitions (class_decl)\n     return;\n \n   /* Check for inherited types */\n-  for (super = CLASSTYPE_SUPER (class); super != object_type_node; \n-       super = CLASSTYPE_SUPER (super))\n-    {\n-      if (!CLASS_ABSTRACT (TYPE_NAME (super)))\n-\tcontinue;\n-\n-      check_abstract_method_definitions (0, class_decl, super);\n-    }\n+  super = class;\n+  do {\n+    super = CLASSTYPE_SUPER (super);\n+    check_abstract_method_definitions (0, class_decl, super);\n+  } while (super != object_type_node);\n \n   /* Check for implemented interfaces. */\n   vector = TYPE_BINFO_BASETYPES (class);\n@@ -5799,6 +5820,30 @@ java_check_abstract_method_definitions (class_decl)\n     }\n }\n \n+/* Check all the types method DECL uses and return 1 if all of them\n+   are now complete, 0 otherwise. This is used to check whether its\n+   safe to build a method signature or not.  */\n+\n+static int\n+check_method_types_complete (decl)\n+     tree decl;\n+{\n+  tree type = TREE_TYPE (decl);\n+  tree args;\n+\n+  if (!INCOMPLETE_TYPE_P (TREE_TYPE (type)))\n+    return 0;\n+  \n+  args = TYPE_ARG_TYPES (type);\n+  if (TREE_CODE (type) == METHOD_TYPE)\n+    args = TREE_CHAIN (args);\n+  for (; args != end_params_node; args = TREE_CHAIN (args))\n+    if (INCOMPLETE_TYPE_P (TREE_VALUE (args)))\n+      return 0;\n+\n+  return 1;\n+}\n+\n /* Check all the methods of CLASS_DECL. Methods are first completed\n    then checked according to regular method existance rules.  If no\n    constructor for CLASS_DECL were encountered, then build its\n@@ -7227,6 +7272,10 @@ java_complete_expand_methods (class_decl)\n       ctxp->explicit_constructor_p = 0;\n     }\n   \n+  /* We might have generated a class$ that we now want to expand */\n+  if (TYPE_DOT_CLASS (current_class))\n+    java_complete_expand_method (TYPE_DOT_CLASS (current_class));\n+\n   /* Now verify constructor circularity (stop after the first one we\n      prove wrong.) */\n   if (!CLASS_INTERFACE (class_decl))\n@@ -7893,6 +7942,129 @@ build_thisn_assign ()\n }\n \n \f\n+/* Building the synthetic `class$' used to implement the `.class' 1.1\n+   extension for non primitive types. This method looks like:\n+\n+    static Class class$(String type) throws NoClassDefFoundError\n+    {\n+      try {return (java.lang.Class.forName (String));}\n+      catch (ClassNotFoundException e) {\n+        throw new NoClassDefFoundError(e.getMessage());}\n+    } */\n+\n+static tree\n+build_dot_class_method (class)\n+     tree class;\n+{\n+#define BWF(S) build_wfl_node (get_identifier ((S)))\n+#define MQN(X,Y) make_qualified_name ((X), (Y), 0)\n+  tree args, tmp, saved_current_function_decl, mdecl;\n+  tree stmt, throw_stmt, catch, catch_block, try_block;\n+  tree catch_clause_param;\n+  tree class_not_found_exception, no_class_def_found_error;\n+\n+  static tree get_message_wfl, type_parm_wfl;\n+\n+  if (!get_message_wfl)\n+    {\n+      get_message_wfl = build_wfl_node (get_identifier (\"getMessage\"));\n+      type_parm_wfl = build_wfl_node (get_identifier (\"type$\"));\n+    }\n+\n+  /* Build the arguments */\n+  args = build_tree_list (get_identifier (\"type$\"),\n+\t\t\t  build_pointer_type (string_type_node));\n+  TREE_CHAIN (args) = end_params_node;\n+\n+  /* Build the qualified name java.lang.Class.forName */\n+  tmp = MQN (MQN (MQN (BWF (\"java\"), \n+\t\t       BWF (\"lang\")), BWF (\"Class\")), BWF (\"forName\"));\n+\n+  /* For things we have to catch and throw */\n+  class_not_found_exception = \n+    lookup_class (get_identifier (\"java.lang.ClassNotFoundException\"));\n+  no_class_def_found_error = \n+    lookup_class (get_identifier (\"java.lang.NoClassDefFoundError\"));\n+  load_class (class_not_found_exception, 1);\n+  load_class (no_class_def_found_error, 1);\n+\n+  /* Create the \"class$\" function */\n+  mdecl = create_artificial_method (class, ACC_STATIC, \n+\t\t\t\t    build_pointer_type (class_type_node),\n+\t\t\t\t    get_identifier (\"class$\"), args);\n+  DECL_FUNCTION_THROWS (mdecl) = build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t  no_class_def_found_error);\n+  \n+  /* We start by building the try block. We need to build:\n+       return (java.lang.Class.forName (type)); */\n+  stmt = build_method_invocation (tmp, \n+\t\t\t\t  build_tree_list (NULL_TREE, type_parm_wfl));\n+  stmt = build_return (0, stmt);\n+  /* Put it in a block. That's the try block */\n+  try_block = build_expr_block (stmt, NULL_TREE);\n+\n+  /* Now onto the catch block. We start by building the expression\n+     throwing a new exception: \n+       throw new NoClassDefFoundError (_.getMessage); */\n+  throw_stmt = make_qualified_name (build_wfl_node (wpv_id), \n+\t\t\t\t    get_message_wfl, 0);\n+  throw_stmt = build_method_invocation (throw_stmt, NULL_TREE);\n+  \n+  /* Build new NoClassDefFoundError (_.getMessage) */\n+  throw_stmt = build_new_invocation \n+    (build_wfl_node (get_identifier (\"NoClassDefFoundError\")),\n+     build_tree_list (build_pointer_type (string_type_node), throw_stmt));\n+\n+  /* Build the throw, (it's too early to use BUILD_THROW) */\n+  throw_stmt = build1 (THROW_EXPR, NULL_TREE, throw_stmt);\n+\n+  /* Build the catch block to encapsulate all this. We begin by\n+     building an decl for the catch clause parameter and link it to\n+     newly created block, the catch block. */\n+  catch_clause_param = \n+    build_decl (VAR_DECL, wpv_id, \n+\t\tbuild_pointer_type (class_not_found_exception));\n+  catch_block = build_expr_block (NULL_TREE, catch_clause_param);\n+  \n+  /* We initialize the variable with the exception handler. */\n+  catch = build (MODIFY_EXPR, NULL_TREE, catch_clause_param,\n+\t\t soft_exceptioninfo_call_node);\n+  add_stmt_to_block (catch_block, NULL_TREE, catch);\n+\n+  /* We add the statement throwing the new exception */\n+  add_stmt_to_block (catch_block, NULL_TREE, throw_stmt);\n+\n+  /* Build a catch expression for all this */\n+  catch_block = build1 (CATCH_EXPR, NULL_TREE, catch_block);\n+\n+  /* Build the try/catch sequence */\n+  stmt = build_try_statement (0, try_block, catch_block);\n+\n+  fix_method_argument_names (args, mdecl);\n+  layout_class_method (class, NULL_TREE, mdecl, NULL_TREE);\n+  saved_current_function_decl = current_function_decl;\n+  start_artificial_method_body (mdecl);\n+  java_method_add_stmt (mdecl, stmt);\n+  end_artificial_method_body (mdecl);\n+  current_function_decl = saved_current_function_decl;\n+  TYPE_DOT_CLASS (class) = mdecl;\n+\n+  return mdecl;\n+}\n+\n+static tree\n+build_dot_class_method_invocation (name)\n+     tree name;\n+{\n+  tree s = make_node (STRING_CST);\n+  TREE_STRING_LENGTH (s) = IDENTIFIER_LENGTH (name);\n+  TREE_STRING_POINTER (s) = obstack_alloc (expression_obstack,\n+\t\t\t\t\t   TREE_STRING_LENGTH (s)+1);\n+  strcpy (TREE_STRING_POINTER (s), IDENTIFIER_POINTER (name));\n+  return build_method_invocation (build_wfl_node (get_identifier (\"class$\")),\n+\t\t\t\t  build_tree_list (NULL_TREE, s));\n+}\n+\n /* This section of the code deals with constructor.  */\n \n /* Craft a body for default constructor. Patch existing constructor\n@@ -8503,13 +8675,13 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  /* If we're creating an inner class instance, check for that\n \t     an enclosing instance is in scope */\n \t  if (TREE_CODE (qual_wfl) == NEW_CLASS_EXPR\n-\t      && INNER_CLASS_TYPE_P (type) && current_this\n-\t      && (DECL_CONTEXT (TYPE_NAME (type)) \n-\t\t  != TYPE_NAME (TREE_TYPE (TREE_TYPE (current_this)))))\n+\t      && INNER_ENCLOSING_SCOPE_CHECK (type))\n \t    {\n \t      parse_error_context \n-\t\t(qual_wfl, \"No enclosing instance for inner class `%s' is in scope; an explicit one must be provided when creating this inner class\", \n-\t\t lang_printable_name (type, 0));\n+\t\t(qual_wfl, \"No enclosing instance for inner class `%s' is in scope%s\",\n+\t\t lang_printable_name (type, 0),\n+\t\t (!current_this ? \"\" :\n+\t\t  \"; an explicit one must be provided when creating this inner class\"));\n \t      RESTORE_THIS_AND_CURRENT_CLASS;\n \t      return 1;\n \t    }\n@@ -8590,6 +8762,13 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  *type_found = type = TREE_TYPE (decl);\n \t  break;\n \n+\tcase CLASS_LITERAL:\n+\t  if ((decl = java_complete_tree (qual_wfl)) == error_mark_node)\n+\t    return 1;\n+\t  *where_found = QUAL_RESOLUTION (q) = decl;\n+\t  *type_found = type = TREE_TYPE (decl);\n+\t  break;\n+\n \tdefault:\n \t  /* Fix for -Wall Just go to the next statement. Don't\n              continue */\n@@ -9206,6 +9385,19 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t\t\t\t\t     class_to_search, primary))\n \tPATCH_METHOD_RETURN_ERROR ();\n \n+      /* Check for inner classes creation from illegal contexts */\n+      if (lc && (INNER_CLASS_TYPE_P (class_to_search)\n+\t\t && !CLASS_STATIC (TYPE_NAME (class_to_search)))\n+\t  && INNER_ENCLOSING_SCOPE_CHECK (class_to_search))\n+\t{\n+\t  parse_error_context \n+\t    (wfl, \"No enclosing instance for inner class `%s' is in scope%s\",\n+\t     lang_printable_name (class_to_search, 0),\n+\t     (!current_this ? \"\" :\n+\t      \"; an explicit one must be provided when creating this inner class\"));\n+\t  PATCH_METHOD_RETURN_ERROR ();\n+\t}\n+\n       /* Non static methods are called with the current object extra\n \t argument. If patch a `new TYPE()', the argument is the value\n \t returned by the object allocator. If method is resolved as a\n@@ -9281,7 +9473,10 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \targs = nreverse (args);\n       \n       /* Secretely pass the current_this/primary as a second argument */\n-      args = tree_cons (NULL_TREE, (primary ? primary : current_this), args);\n+      if (primary || current_this)\n+\targs = tree_cons (NULL_TREE, (primary ? primary : current_this), args);\n+      else\n+\targs = tree_cons (NULL_TREE, integer_zero_node, args);\n     }\n \n   is_static_flag = METHOD_STATIC (list);\n@@ -9367,7 +9562,9 @@ maybe_use_access_method (is_super_init, mdecl, this_arg)\n   int non_static_context = !METHOD_STATIC (md);\n \n   if (is_super_init \n-      || !INNER_CLASS_TYPE_P (current_class) || DECL_FINIT_P (md))\n+      || DECL_CONTEXT (md) == current_class\n+      || !PURE_INNER_CLASS_TYPE_P (current_class) \n+      || DECL_FINIT_P (md))\n     return 0;\n   \n   /* If we're calling a method found in an enclosing class, generate\n@@ -9629,6 +9826,7 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n      int lc;\n      tree class, name, arglist;\n {\n+  static int object_done = 0;\n   tree list = NULL_TREE, all_list = NULL_TREE;\n \n   if (!CLASS_LOADED_P (class) && !CLASS_FROM_SOURCE_P (class))\n@@ -9638,15 +9836,15 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     }\n \n   /* Search interfaces */\n-  if (CLASS_INTERFACE (TYPE_NAME (class))\n-      || CLASS_ABSTRACT (TYPE_NAME (class)))\n+  if (CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n       static tree searched_interfaces = NULL_TREE;\n       static int search_not_done = 0;\n       int i, n;\n       tree basetype_vec = TYPE_BINFO_BASETYPES (class);\n \n-      /* Have we searched this interface already? */\n+      /* Have we searched this interface already? We shoud use a hash\n+         table, FIXME */\n       if (searched_interfaces)\n \t{  \n \t  tree current;  \n@@ -9657,56 +9855,80 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t}\n       searched_interfaces = tree_cons (NULL_TREE, class, searched_interfaces);\n \n-      search_applicable_methods_list \n-\t(lc, TYPE_METHODS (class), name, arglist, &list, &all_list);\n-\n+      search_applicable_methods_list (lc, TYPE_METHODS (class), \n+\t\t\t\t      name, arglist, &list, &all_list);\n       n = TREE_VEC_LENGTH (basetype_vec);\n-      for (i = 0; i < n; i++)\n+      for (i = 1; i < n; i++)\n \t{\n \t  tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n \t  tree rlist;\n \n-\t  /* Skip java.lang.Object (we'll search it once later.) */\n-\t  if (t == object_type_node)\n-\t    continue;\n-\t  \n \t  search_not_done++;\n \t  rlist = find_applicable_accessible_methods_list (lc,  t, name, \n \t\t\t\t\t\t\t   arglist);\n-\t  all_list = chainon (rlist, (list ? list : all_list)); \n+\t  list = chainon (rlist, list);\n \t  search_not_done--;\n \t}\n \n       /* We're done. Reset the searched interfaces list and finally search\n          java.lang.Object */\n       if (!search_not_done)\n \t{  \n+\t  if (!object_done)\n+\t    search_applicable_methods_list (lc, \n+\t\t\t\t\t    TYPE_METHODS (object_type_node),\n+\t\t\t\t\t    name, arglist, &list, &all_list);\n \t  searched_interfaces = NULL_TREE;  \n-\t  search_applicable_methods_list (lc, TYPE_METHODS (object_type_node),\n-\t\t\t\t\t  name, arglist, &list, &all_list);\n \t}\n     }\n   /* Search classes */\n   else\n     {\n-      tree saved_class = class;\n+      tree sc = class;\n+      int seen_inner_class = 0;\n       search_applicable_methods_list (lc, TYPE_METHODS (class), \n \t\t\t\t      name, arglist, &list, &all_list);\n \n+      /* We must search all interfaces of this class */\n+      if (!lc)\n+      {\n+\ttree basetype_vec = TYPE_BINFO_BASETYPES (sc);\n+\tint n = TREE_VEC_LENGTH (basetype_vec), i;\n+\tobject_done = 1;\n+\tfor (i = 1; i < n; i++)\n+\t  {\n+\t    tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n+\t    tree rlist;\n+\t    if (t != object_type_node)\n+\t      rlist = find_applicable_accessible_methods_list (lc, t,\n+\t\t\t\t\t\t\t       name, arglist);\n+\t    list = chainon (rlist, list);\n+\t  }\n+\tobject_done = 0;\n+      }\n+\n       /* Search enclosing context of inner classes before looking\n          ancestors up. */\n       while (!lc && INNER_CLASS_TYPE_P (class))\n \t{\n+\t  tree rlist;\n+\t  seen_inner_class = 1;\n \t  class = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (class)));\n-\t  search_applicable_methods_list (lc, TYPE_METHODS (class),\n-\t\t\t\t\t  name, arglist, &list, &all_list);\n+\t  rlist = find_applicable_accessible_methods_list (lc, class, \n+\t\t\t\t\t\t\t   name, arglist);\n+\t  list = chainon (rlist, list);\n \t}\n-      \n-      for (class = saved_class, class = (lc ? NULL_TREE : \n-\t\t\t\t\t CLASSTYPE_SUPER (class)); class;\n-\t   class = CLASSTYPE_SUPER (class))\n-\tsearch_applicable_methods_list \n-\t  (lc, TYPE_METHODS (class), name, arglist, &list, &all_list);\n+\n+      if (!lc && seen_inner_class \n+\t  && TREE_TYPE (DECL_CONTEXT (TYPE_NAME (sc))) == CLASSTYPE_SUPER (sc))\n+\tclass = CLASSTYPE_SUPER (sc);\n+      else\n+\tclass = sc;\n+\n+      for (class = (lc ? NULL_TREE : CLASSTYPE_SUPER (class)); \n+        class; class = CLASSTYPE_SUPER (class))\n+       search_applicable_methods_list (lc, TYPE_METHODS (class), \n+                                       name, arglist, &list, &all_list);\n     }\n \n   /* Either return the list obtained or all selected (but\n@@ -9782,16 +10004,31 @@ find_most_specific_methods_list (list)\n     if (DECL_SPECIFIC_COUNT (TREE_VALUE (current)) == max)\n       new_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n \n+  /* If we have several and they're all abstract, just pick the\n+     closest one. */\n+\n+  if (new_list && TREE_CHAIN (new_list))\n+    {\n+      tree c;\n+      for (c = new_list; c && METHOD_ABSTRACT (TREE_VALUE (c)); \n+\t   c = TREE_CHAIN (c))\n+        ;\n+      if (!c)\n+\t{\n+\t  new_list = nreverse (new_list);\n+\t  TREE_CHAIN (new_list) = NULL_TREE;\n+\t}\n+    }\n+\n   /* If we can't find one, lower expectations and try to gather multiple\n      maximally specific methods */\n-  while (!new_list)\n+  while (!new_list && max)\n     {\n       while (--max > 0)\n \t{\n \t  if (DECL_SPECIFIC_COUNT (TREE_VALUE (current)) == max)\n \t    new_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n \t}\n-      return new_list;\n     }\n \n   return new_list;\n@@ -9898,6 +10135,10 @@ qualify_ambiguous_name (id)\n \tqual = TREE_CHAIN (qual);\n \tqual_wfl = QUAL_WFL (qual);\n \tbreak;\n+      case CLASS_LITERAL:\n+\tqual = TREE_CHAIN (qual);\n+\tqual_wfl = QUAL_WFL (qual);\n+      break;\n       default:\n \t/* Fix for -Wall. Just break doing nothing */\n \tbreak;\n@@ -11067,7 +11308,6 @@ build_this_super_qualified_invocation (use_this, name, args, lloc, rloc)\n      int use_this;\n      tree name, args;\n      int lloc, rloc;\n-\n {\n   tree invok;\n   tree wfl = \n@@ -12478,7 +12718,17 @@ patch_incomplete_class_ref (node)\n   if (!(ref_type = resolve_type_during_patch (type)))\n     return error_mark_node;\n \n-  return build_class_ref (ref_type);\n+  if (!flag_emit_class_files || JPRIMITIVE_TYPE_P (ref_type))\n+    return build_class_ref (ref_type);\n+\n+  /* If we're emitting class files and we have to deal with non\n+     primitive types, we invoke (and consider generating) the\n+     synthetic static method `class$'. */\n+  if (!TYPE_DOT_CLASS (current_class))\n+      build_dot_class_method (current_class);\n+  ref_type = \n+    build_dot_class_method_invocation (DECL_NAME (TYPE_NAME (ref_type)));\n+  return java_complete_tree (ref_type);\n }\n \n /* 15.14 Unary operators. We return error_mark_node in case of error,\n@@ -13722,7 +13972,7 @@ patch_switch_statement (node)\n   return node;\n }\n \n-/* 14.18 The try statement */\n+/* 14.18 The try/catch statements */\n \n static tree\n build_try_statement (location, try_block, catches)"}]}