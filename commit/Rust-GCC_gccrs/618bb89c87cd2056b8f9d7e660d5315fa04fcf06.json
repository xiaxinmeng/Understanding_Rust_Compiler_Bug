{"sha": "618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE4YmI4OWM4N2NkMjA1NmI4ZjlkN2U2NjBkNTMxNWZhMDRmY2YwNg==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-22T13:55:05Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-22T13:55:05Z"}, "message": "re PR tree-optimization/18536 (ICE: in emit_move_insn, at expr.c:2590 with -ftree-vectorize -msse2)\n\n        PR tree-opt/18536\n        * tree-vectorizer.c (make_loop_iterate_ntimes): Use type of niters when\n        creating iv instead of integer_type.\n        (vect_build_loop_niters): Remove redundant code.\n        (vect_transform_loop_bound): Removed (duplicates functionality of\n        make_loop_iterate_ntimes.\n        (vect_gen_niters_for_prolog_loop): Add documentation. Call\n        lang_hooks.types.type_for_size to create a type of the required size.\n        Use that type instead of integer_type. Remove redundant code.\n        (vect_update_niters_after_peeling): Use type of niters instead of\n        integer_type.\n        (vect_transform_loop): Unify handling of known and unknown loop bound\n        cases. Call make_loop_iterate_ntimes instead of\n        vect_transform_loop_bound.\n\nFrom-SVN: r91014", "tree": {"sha": "f0a4fe27b2ccebe5c598579e4d246b982b234f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0a4fe27b2ccebe5c598579e4d246b982b234f08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/comments", "author": null, "committer": null, "parents": [{"sha": "9633a6ac6235a42022196978090aa3363b017078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9633a6ac6235a42022196978090aa3363b017078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9633a6ac6235a42022196978090aa3363b017078"}], "stats": {"total": 195, "additions": 111, "deletions": 84}, "files": [{"sha": "df0dfa73d638e08df8977eb23e76cf859503d07d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "patch": "@@ -1,3 +1,20 @@\n+2004-11-22  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\tPR tree-opt/18536\n+\t* tree-vectorizer.c (make_loop_iterate_ntimes): Use type of niters when\n+\tcreating iv instead of integer_type.\n+\t(vect_build_loop_niters): Remove redundant code.\n+\t(vect_transform_loop_bound): Removed (duplicates functionality of\n+\tmake_loop_iterate_ntimes.\n+\t(vect_gen_niters_for_prolog_loop): Add documentation. Call\n+\tlang_hooks.types.type_for_size to create a type of the required size.\n+\tUse that type instead of integer_type. Remove redundant code.\n+\t(vect_update_niters_after_peeling): Use type of niters instead of\n+\tinteger_type.\n+\t(vect_transform_loop): Unify handling of known and unknown loop bound\n+\tcases. Call make_loop_iterate_ntimes instead of \n+\tvect_transform_loop_bound.\n+\n 2004-11-22  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR target/18217"}, {"sha": "3d9d53a44980988ac5bbd9e96f68ea2b89aee87e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "patch": "@@ -1,3 +1,8 @@\n+2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\tPR tree-opt/18536\n+\t* gcc.dg/vect/pr18536.c: New test.\n+\n 2004-11-22  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/18354"}, {"sha": "cd9d7bb1a4fd048989eac3b3593c6c4847651cbe", "filename": "gcc/testsuite/gcc.dg/vect/pr18536.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr18536.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr18536.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr18536.c?ref=618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+int main1 (short a, short *b)\n+{\n+  while (++a < 4) *b++ = 2;\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i = 0;\n+  short x[N];\n+\n+  check_vect ();\n+\n+  main1 (0, x);\n+\n+  /* check results:  */\n+  while (++i < 4)\n+    {\n+      if (x[i-1] != 2)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "b94ffa4f25a9a1635309e99572d20bac05591f33", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 55, "deletions": 84, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618bb89c87cd2056b8f9d7e660d5315fa04fcf06/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=618bb89c87cd2056b8f9d7e660d5315fa04fcf06", "patch": "@@ -145,6 +145,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n+#include \"langhooks.h\"\n \n \n /*************************************************************************\n@@ -196,7 +197,6 @@ static bool vect_analyze_operations (loop_vec_info);\n \n /* Main code transformation functions.  */\n static void vect_transform_loop (loop_vec_info, struct loops *);\n-static void vect_transform_loop_bound (loop_vec_info, tree niters);\n static bool vect_transform_stmt (tree, block_stmt_iterator *);\n static bool vectorizable_load (tree, block_stmt_iterator *, tree *);\n static bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n@@ -664,10 +664,12 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   block_stmt_iterator loop_exit_bsi = bsi_last (exit_edge->src);\n   tree begin_label = tree_block_label (loop->latch);\n   tree exit_label = tree_block_label (loop->single_exit->dest);\n+  tree init = build_int_cst (TREE_TYPE (niters), 0);\n+  tree step = build_int_cst (TREE_TYPE (niters), 1);\n \n   orig_cond = get_loop_exit_condition (loop);\n   gcc_assert (orig_cond);\n-  create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop,\n+  create_iv (init, step, NULL_TREE, loop,\n              &loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n   \n   /* CREATE_IV uses BSI_INSERT with TSI_NEW_STMT, so we want to get\n@@ -2744,20 +2746,11 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n   edge pe;\n   basic_block new_bb = NULL;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree ni = unshare_expr (LOOP_VINFO_NITERS(loop_vinfo));\n+  tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n \n   var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n   add_referenced_tmp_var (var);\n-  if (TREE_CODE (ni) == INTEGER_CST)\n-    {\n-      /* This case is generated when treating a known loop bound \n-\t indivisible by VF. Here we cannot use force_gimple_operand.  */\n-      stmt = build (MODIFY_EXPR, void_type_node, var, ni);\n-      ni_name = make_ssa_name (var, stmt);\n-      TREE_OPERAND (stmt, 0) = ni_name;\n-    }\n-  else\n-    ni_name = force_gimple_operand (ni, &stmt, false, var);\n+  ni_name = force_gimple_operand (ni, &stmt, false, var);\n \n   pe = loop_preheader_edge (loop);\n   if (stmt)\n@@ -2874,45 +2867,6 @@ vect_build_symbol_bound (tree n, int vf, struct loop * loop)\n }\n \n \n-/* Function vect_transform_loop_bound.\n-\n-   Create a new exit condition for the loop.  */\n-\n-static void\n-vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n-{\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree orig_cond_expr;\n-  HOST_WIDE_INT old_N = 0;\n-  int vf;\n-  tree new_loop_bound;\n-  bool symbol_niters;\n-  tree lb_type;\n-\n-  symbol_niters = !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo);\n-\n-  if (!symbol_niters)\n-    old_N = LOOP_VINFO_INT_NITERS (loop_vinfo);\n-\n-  vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-\n-  orig_cond_expr = LOOP_VINFO_EXIT_COND (loop_vinfo);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (orig_cond_expr);\n-#endif\n-\n-  /* new loop exit test:  */\n-  lb_type = TREE_TYPE (TREE_OPERAND (COND_EXPR_COND (orig_cond_expr), 1));\n-  if (!symbol_niters)\n-    new_loop_bound = \n-\tfold_convert (lb_type, build_int_cst (unsigned_type_node, old_N/vf));\n-  else\n-    new_loop_bound = niters;\n-\n-  slpeel_make_loop_iterate_ntimes (loop, new_loop_bound);\n-}\n-\n-\n /*   Function vect_update_ivs_after_vectorizer.\n \n      \"Advance\" the induction variables of LOOP to the value they should take\n@@ -3094,13 +3048,23 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n /* Function vect_gen_niters_for_prolog_loop\n \n    Set the number of iterations for the loop represented by LOOP_VINFO\n-   to the minimum between NITERS (the original iteration count of the loop)\n+   to the minimum between LOOP_NITERS (the original iteration count of the loop)\n    and the misalignment of DR - the first data reference recorded in\n    LOOP_VINFO_UNALIGNED_DR (LOOP_VINFO).  As a result, after the execution of \n-   this loop, the data reference DR will refer to an aligned location.  */\n+   this loop, the data reference DR will refer to an aligned location.\n+\n+   The following computation is generated:\n+\n+   compute address misalignment in bytes:\n+   addr_mis = addr & (vectype_size - 1)\n+\n+   prolog_niters = min ( LOOP_NITERS , (VF - addr_mis/elem_size)&(VF-1) )\n+   \n+   (elem_size = element type size; an element is the scalar element \n+\twhose type is the inner type of the vectype)  */\n \n static tree \n-vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree niters)\n+vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n@@ -3111,39 +3075,43 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree niters)\n   basic_block new_bb;\n   tree dr_stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n-  tree start_addr, byte_miss_align, elem_miss_align;\n-  int vec_type_align = \n-    GET_MODE_ALIGNMENT (TYPE_MODE (STMT_VINFO_VECTYPE (stmt_info))) \n-\t\t\t\t\t\t\t/ BITS_PER_UNIT;\n-  tree tmp1, tmp2;\n-  tree new_stmt_list = NULL_TREE;\n-\n-  start_addr = vect_create_addr_base_for_vector_ref (dr_stmt,\n-\t\t\t\t\t\t     &new_stmt_list, NULL_TREE);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n+  tree elem_misalign;\n+  tree byte_misalign;\n+  tree new_stmts = NULL_TREE;\n+  tree start_addr = \n+\tvect_create_addr_base_for_vector_ref (dr_stmt, &new_stmts, NULL_TREE);\n+  tree ptr_type = TREE_TYPE (start_addr);\n+  tree size = TYPE_SIZE (ptr_type);\n+  tree type = lang_hooks.types.type_for_size (TREE_INT_CST_LOW (size), 1);\n+  tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);\n+  tree vf_minus_1 = build_int_cst (unsigned_type_node, vf - 1);\n+  tree niters_type = TREE_TYPE (loop_niters);\n+  tree elem_size_log = \n+\tbuild_int_cst (unsigned_type_node, exact_log2 (vectype_align/vf));\n+  tree vf_tree = build_int_cst (unsigned_type_node, vf);\n \n   pe = loop_preheader_edge (loop); \n-  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt_list); \n+  new_bb = bsi_insert_on_edge_immediate (pe, new_stmts); \n   if (new_bb)\n     add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n \n-  byte_miss_align = \n-\tbuild (BIT_AND_EXPR, integer_type_node, start_addr, \n-\t\t  build (MINUS_EXPR, integer_type_node, \n-\t\t\t build_int_cst (unsigned_type_node,\n-\t\t\t\t\tvec_type_align), integer_one_node));\n-  tmp1 = build_int_cst (unsigned_type_node, vec_type_align/vf);\n-  elem_miss_align = build (FLOOR_DIV_EXPR, integer_type_node, \n-\t\t\t   byte_miss_align, tmp1); \n+  /* Create:  byte_misalign = addr & (vectype_size - 1)  */\n+  byte_misalign = build2 (BIT_AND_EXPR, type, start_addr, vectype_size_minus_1);\n+\n+  /* Create:  elem_misalign = byte_misalign / element_size  */\n+  elem_misalign = \n+\tbuild2 (RSHIFT_EXPR, unsigned_type_node, byte_misalign, elem_size_log);\n   \n-  tmp2 = \n-\tbuild (BIT_AND_EXPR, integer_type_node,\n-\t  build (MINUS_EXPR, integer_type_node, \n-\t\tbuild_int_cst (unsigned_type_node, vf), elem_miss_align),\n-\t  build (MINUS_EXPR, integer_type_node, \n-\t\tbuild_int_cst (unsigned_type_node, vf), integer_one_node)); \n-\n-  iters = build2 (MIN_EXPR, TREE_TYPE (tmp2), tmp2, niters);\n-  var = create_tmp_var (TREE_TYPE (iters), \"iters\");\n+  /* Create:  (niters_type) (VF - elem_misalign)&(VF - 1)  */\n+  iters = build2 (MINUS_EXPR, unsigned_type_node, vf_tree, elem_misalign);\n+  iters = build2 (BIT_AND_EXPR, unsigned_type_node, iters, vf_minus_1);\n+  iters = fold_convert (niters_type, iters);\n+\n+  /* Create:  prolog_loop_niters = min (iters, loop_niters) */\n+  iters = build2 (MIN_EXPR, niters_type, iters, loop_niters);\n+  var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n   add_referenced_tmp_var (var);\n   iters_name = force_gimple_operand (iters, &stmt, false, var);\n \n@@ -3252,7 +3220,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   /* Update number of times loop executes.  */\n   n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n   LOOP_VINFO_NITERS (loop_vinfo) =\n-    build (MINUS_EXPR, integer_type_node, n_iters, niters_of_prolog_loop);\n+    build2 (MINUS_EXPR, TREE_TYPE (n_iters), n_iters, niters_of_prolog_loop);\n \n   /* Update the init conditions of the access functions of all data refs.  */\n   vect_update_inits_of_drs (loop_vinfo, niters_of_prolog_loop);\n@@ -3304,6 +3272,9 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n       || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n           && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0))\n     vect_do_peeling_for_loop_bound (loop_vinfo, &ratio, loops);\n+  else\n+    ratio = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n+\t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);\n \n   /* 1) Make sure the loop header has exactly two entries\n      2) Make sure we have a preheader basic block.  */\n@@ -3366,7 +3337,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */\n \n-  vect_transform_loop_bound (loop_vinfo, ratio);\n+  slpeel_make_loop_iterate_ntimes (loop, ratio);\n \n   if (vect_debug_details (loop))\n     fprintf (dump_file,\"Success! loop vectorized.\");"}]}