{"sha": "61baec412d978857ae8c34e7e41c532fbeb9921a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFiYWVjNDEyZDk3ODg1N2FlOGMzNGU3ZTQxYzUzMmZiZWI5OTIxYQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-09-13T16:55:38Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-09-13T16:55:38Z"}, "message": "tree-ssa-loop-im.c: remove typedefs that hide pointerness\n\ngcc/ChangeLog:\n\n2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* tree-ssa-loop-im.c (mem_ref_loc_p): Remove typedef.\n\t(mem_ref_p): Likewise.\n\t(outermost_indep_loop): Adjust.\n\t(mem_ref_in_stmt): Likewise.\n\t(determine_max_movement): Likewise.\n\t(mem_ref_alloc): Likewise.\n\t(record_mem_ref_loc): Likewise.\n\t(set_ref_stored_in_loop): Likewise.\n\t(mark_ref_stored): Likewise.\n\t(gather_mem_refs_stmt): Likewise.\n\t(mem_refs_may_alias_p): Likewise.\n\t(for_all_locs_in_loop): Likewise.\n\t(struct rewrite_mem_ref_loc): Likewise.\n\t(rewrite_mem_refs): Likewise.\n\t(struct first_mem_ref_loc_1): Likewise.\n\t(first_mem_ref_loc): Likewise.\n\t(struct sm_set_flag_if_changed): Likewise.\n\t(execute_sm_if_changed_flag_set): Likewise.\n\t(execute_sm): Likewise.\n\t(hoist_memory_references):\n\t(struct ref_always_accessed): Likewise.\n\t(ref_always_accessed_p): Likewise.\n\t(refs_independent_p): Likewise.\n\t(record_dep_loop): Likewise.\n\t(ref_indep_loop_p_1): Likewise.\n\t(ref_indep_loop_p_2): Likewise.\n\t(ref_indep_loop_p): Likewise.\n\t(can_sm_ref_p): Likewise.\n\t(find_refs_for_sm): Likewise.\n\t(tree_ssa_lim_finalize): Likewise.\n\nFrom-SVN: r227727", "tree": {"sha": "b22264e8959c924e3c1dcb56ed7d0fd257b0a78b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b22264e8959c924e3c1dcb56ed7d0fd257b0a78b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61baec412d978857ae8c34e7e41c532fbeb9921a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61baec412d978857ae8c34e7e41c532fbeb9921a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61baec412d978857ae8c34e7e41c532fbeb9921a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61baec412d978857ae8c34e7e41c532fbeb9921a/comments", "author": null, "committer": null, "parents": [{"sha": "c49fc88d24eb020835c30950c073f7836557d559", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49fc88d24eb020835c30950c073f7836557d559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49fc88d24eb020835c30950c073f7836557d559"}], "stats": {"total": 131, "additions": 82, "deletions": 49}, "files": [{"sha": "587af497dd5b17edcb66f7afab472cdb476cc312", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61baec412d978857ae8c34e7e41c532fbeb9921a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61baec412d978857ae8c34e7e41c532fbeb9921a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61baec412d978857ae8c34e7e41c532fbeb9921a", "patch": "@@ -1,3 +1,36 @@\n+2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* tree-ssa-loop-im.c (mem_ref_loc_p): Remove typedef.\n+\t(mem_ref_p): Likewise.\n+\t(outermost_indep_loop): Adjust.\n+\t(mem_ref_in_stmt): Likewise.\n+\t(determine_max_movement): Likewise.\n+\t(mem_ref_alloc): Likewise.\n+\t(record_mem_ref_loc): Likewise.\n+\t(set_ref_stored_in_loop): Likewise.\n+\t(mark_ref_stored): Likewise.\n+\t(gather_mem_refs_stmt): Likewise.\n+\t(mem_refs_may_alias_p): Likewise.\n+\t(for_all_locs_in_loop): Likewise.\n+\t(struct rewrite_mem_ref_loc): Likewise.\n+\t(rewrite_mem_refs): Likewise.\n+\t(struct first_mem_ref_loc_1): Likewise.\n+\t(first_mem_ref_loc): Likewise.\n+\t(struct sm_set_flag_if_changed): Likewise.\n+\t(execute_sm_if_changed_flag_set): Likewise.\n+\t(execute_sm): Likewise.\n+\t(hoist_memory_references):\n+\t(struct ref_always_accessed): Likewise.\n+\t(ref_always_accessed_p): Likewise.\n+\t(refs_independent_p): Likewise.\n+\t(record_dep_loop): Likewise.\n+\t(ref_indep_loop_p_1): Likewise.\n+\t(ref_indep_loop_p_2): Likewise.\n+\t(ref_indep_loop_p): Likewise.\n+\t(can_sm_ref_p): Likewise.\n+\t(find_refs_for_sm): Likewise.\n+\t(tree_ssa_lim_finalize): Likewise.\n+\n 2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* dwarf2out.c (dw_attr_ref): Remove typedef."}, {"sha": "f1d4a8ce15cc08428fab27bcb4b233b9e0f0e29f", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61baec412d978857ae8c34e7e41c532fbeb9921a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61baec412d978857ae8c34e7e41c532fbeb9921a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=61baec412d978857ae8c34e7e41c532fbeb9921a", "patch": "@@ -102,16 +102,16 @@ static hash_map<gimple, lim_aux_data *> *lim_aux_data_map;\n \n /* Description of a memory reference location.  */\n \n-typedef struct mem_ref_loc\n+struct mem_ref_loc\n {\n   tree *ref;\t\t\t/* The reference itself.  */\n   gimple stmt;\t\t\t/* The statement in that it occurs.  */\n-} *mem_ref_loc_p;\n+};\n \n \n /* Description of a memory reference.  */\n \n-typedef struct im_mem_ref\n+struct im_mem_ref\n {\n   unsigned id;\t\t\t/* ID assigned to the memory reference\n \t\t\t\t   (its index in memory_accesses.refs_list)  */\n@@ -138,7 +138,7 @@ typedef struct im_mem_ref\n \t\t\t\t   If it is only loaded, then it is independent\n \t\t\t\t     on all stores in the loop.  */\n   bitmap_head dep_loop;\t\t/* The complement of INDEP_LOOP.  */\n-} *mem_ref_p;\n+};\n \n /* We use two bits per loop in the ref->{in,}dep_loop bitmaps, the first\n    to record (in)dependence against stores in the loop and its subloops, the\n@@ -181,7 +181,7 @@ static struct\n   hash_table<mem_ref_hasher> *refs;\n \n   /* The list of memory references.  */\n-  vec<mem_ref_p> refs_list;\n+  vec<im_mem_ref *> refs_list;\n \n   /* The set of memory references accessed in each loop.  */\n   vec<bitmap_head> refs_in_loop;\n@@ -200,7 +200,7 @@ static struct\n static bitmap_obstack lim_bitmap_obstack;\n static obstack mem_ref_obstack;\n \n-static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n+static bool ref_indep_loop_p (struct loop *, im_mem_ref *);\n \n /* Minimum cost of an expensive expression.  */\n #define LIM_EXPENSIVE ((unsigned) PARAM_VALUE (PARAM_LIM_EXPENSIVE))\n@@ -537,7 +537,7 @@ stmt_cost (gimple stmt)\n    instead.  */\n \n static struct loop *\n-outermost_indep_loop (struct loop *outer, struct loop *loop, mem_ref_p ref)\n+outermost_indep_loop (struct loop *outer, struct loop *loop, im_mem_ref *ref)\n {\n   struct loop *aloop;\n \n@@ -590,13 +590,13 @@ simple_mem_ref_in_stmt (gimple stmt, bool *is_store)\n \n /* Returns the memory reference contained in STMT.  */\n \n-static mem_ref_p\n+static im_mem_ref *\n mem_ref_in_stmt (gimple stmt)\n {\n   bool store;\n   tree *mem = simple_mem_ref_in_stmt (stmt, &store);\n   hashval_t hash;\n-  mem_ref_p ref;\n+  im_mem_ref *ref;\n \n   if (!mem)\n     return NULL;\n@@ -790,7 +790,7 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n \n   if (gimple_vuse (stmt))\n     {\n-      mem_ref_p ref = mem_ref_in_stmt (stmt);\n+      im_mem_ref *ref = mem_ref_in_stmt (stmt);\n \n       if (ref)\n \t{\n@@ -1420,10 +1420,10 @@ memref_free (struct im_mem_ref *mem)\n /* Allocates and returns a memory reference description for MEM whose hash\n    value is HASH and id is ID.  */\n \n-static mem_ref_p\n+static im_mem_ref *\n mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n {\n-  mem_ref_p ref = XOBNEW (&mem_ref_obstack, struct im_mem_ref);\n+  im_mem_ref *ref = XOBNEW (&mem_ref_obstack, struct im_mem_ref);\n   ao_ref_init (&ref->mem, mem);\n   ref->id = id;\n   ref->hash = hash;\n@@ -1439,7 +1439,7 @@ mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n    description REF.  The reference occurs in statement STMT.  */\n \n static void\n-record_mem_ref_loc (mem_ref_p ref, gimple stmt, tree *loc)\n+record_mem_ref_loc (im_mem_ref *ref, gimple stmt, tree *loc)\n {\n   mem_ref_loc aref;\n   aref.stmt = stmt;\n@@ -1451,7 +1451,7 @@ record_mem_ref_loc (mem_ref_p ref, gimple stmt, tree *loc)\n    necessary.  Return whether a bit was changed.  */\n \n static bool\n-set_ref_stored_in_loop (mem_ref_p ref, struct loop *loop)\n+set_ref_stored_in_loop (im_mem_ref *ref, struct loop *loop)\n {\n   if (!ref->stored)\n     ref->stored = BITMAP_ALLOC (&lim_bitmap_obstack);\n@@ -1461,7 +1461,7 @@ set_ref_stored_in_loop (mem_ref_p ref, struct loop *loop)\n /* Marks reference REF as stored in LOOP.  */\n \n static void\n-mark_ref_stored (mem_ref_p ref, struct loop *loop)\n+mark_ref_stored (im_mem_ref *ref, struct loop *loop)\n {\n   while (loop != current_loops->tree_root\n \t && set_ref_stored_in_loop (ref, loop))\n@@ -1479,7 +1479,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n   tree *mem = NULL;\n   hashval_t hash;\n   im_mem_ref **slot;\n-  mem_ref_p ref;\n+  im_mem_ref *ref;\n   bool is_stored;\n   unsigned id;\n \n@@ -1505,7 +1505,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n       slot = memory_accesses.refs->find_slot_with_hash (*mem, hash, INSERT);\n       if (*slot)\n \t{\n-\t  ref = (mem_ref_p) *slot;\n+\t  ref = *slot;\n \t  id = ref->id;\n \t}\n       else\n@@ -1625,7 +1625,7 @@ analyze_memory_references (void)\n    tree_to_aff_combination_expand.  */\n \n static bool\n-mem_refs_may_alias_p (mem_ref_p mem1, mem_ref_p mem2,\n+mem_refs_may_alias_p (im_mem_ref *mem1, im_mem_ref *mem2,\n \t\t      hash_map<tree, name_expansion *> **ttae_cache)\n {\n   /* Perform BASE + OFFSET analysis -- if MEM1 and MEM2 are based on the same\n@@ -1679,10 +1679,10 @@ find_ref_loc_in_loop_cmp (const void *loop_, const void *loc_)\n \n template <typename FN>\n static bool\n-for_all_locs_in_loop (struct loop *loop, mem_ref_p ref, FN fn)\n+for_all_locs_in_loop (struct loop *loop, im_mem_ref *ref, FN fn)\n {\n   unsigned i;\n-  mem_ref_loc_p loc;\n+  mem_ref_loc *loc;\n \n   /* Search for the cluster of locs in the accesses_in_loop vector\n      which is sorted after postorder index of the loop father.  */\n@@ -1696,7 +1696,7 @@ for_all_locs_in_loop (struct loop *loop, mem_ref_p ref, FN fn)\n   while (i > 0)\n     {\n       --i;\n-      mem_ref_loc_p l = &ref->accesses_in_loop[i];\n+      mem_ref_loc *l = &ref->accesses_in_loop[i];\n       if (!flow_bb_inside_loop_p (loop, gimple_bb (l->stmt)))\n \tbreak;\n       if (fn (l))\n@@ -1705,7 +1705,7 @@ for_all_locs_in_loop (struct loop *loop, mem_ref_p ref, FN fn)\n   for (i = loc - ref->accesses_in_loop.address ();\n        i < ref->accesses_in_loop.length (); ++i)\n     {\n-      mem_ref_loc_p l = &ref->accesses_in_loop[i];\n+      mem_ref_loc *l = &ref->accesses_in_loop[i];\n       if (!flow_bb_inside_loop_p (loop, gimple_bb (l->stmt)))\n \tbreak;\n       if (fn (l))\n@@ -1720,12 +1720,12 @@ for_all_locs_in_loop (struct loop *loop, mem_ref_p ref, FN fn)\n struct rewrite_mem_ref_loc\n {\n   rewrite_mem_ref_loc (tree tmp_var_) : tmp_var (tmp_var_) {}\n-  bool operator () (mem_ref_loc_p loc);\n+  bool operator () (mem_ref_loc *loc);\n   tree tmp_var;\n };\n \n bool\n-rewrite_mem_ref_loc::operator () (mem_ref_loc_p loc)\n+rewrite_mem_ref_loc::operator () (mem_ref_loc *loc)\n {\n   *loc->ref = tmp_var;\n   update_stmt (loc->stmt);\n@@ -1735,7 +1735,7 @@ rewrite_mem_ref_loc::operator () (mem_ref_loc_p loc)\n /* Rewrites all references to REF in LOOP by variable TMP_VAR.  */\n \n static void\n-rewrite_mem_refs (struct loop *loop, mem_ref_p ref, tree tmp_var)\n+rewrite_mem_refs (struct loop *loop, im_mem_ref *ref, tree tmp_var)\n {\n   for_all_locs_in_loop (loop, ref, rewrite_mem_ref_loc (tmp_var));\n }\n@@ -1744,24 +1744,24 @@ rewrite_mem_refs (struct loop *loop, mem_ref_p ref, tree tmp_var)\n \n struct first_mem_ref_loc_1\n {\n-  first_mem_ref_loc_1 (mem_ref_loc_p *locp_) : locp (locp_) {}\n-  bool operator () (mem_ref_loc_p loc);\n-  mem_ref_loc_p *locp;\n+  first_mem_ref_loc_1 (mem_ref_loc **locp_) : locp (locp_) {}\n+  bool operator () (mem_ref_loc *loc);\n+  mem_ref_loc **locp;\n };\n \n bool\n-first_mem_ref_loc_1::operator () (mem_ref_loc_p loc)\n+first_mem_ref_loc_1::operator () (mem_ref_loc *loc)\n {\n   *locp = loc;\n   return true;\n }\n \n /* Returns the first reference location to REF in LOOP.  */\n \n-static mem_ref_loc_p\n-first_mem_ref_loc (struct loop *loop, mem_ref_p ref)\n+static mem_ref_loc *\n+first_mem_ref_loc (struct loop *loop, im_mem_ref *ref)\n {\n-  mem_ref_loc_p locp = NULL;\n+  mem_ref_loc *locp = NULL;\n   for_all_locs_in_loop (loop, ref, first_mem_ref_loc_1 (&locp));\n   return locp;\n }\n@@ -1916,12 +1916,12 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n struct sm_set_flag_if_changed\n {\n   sm_set_flag_if_changed (tree flag_) : flag (flag_) {}\n-  bool operator () (mem_ref_loc_p loc);\n+  bool operator () (mem_ref_loc *loc);\n   tree flag;\n };\n \n bool\n-sm_set_flag_if_changed::operator () (mem_ref_loc_p loc)\n+sm_set_flag_if_changed::operator () (mem_ref_loc *loc)\n {\n   /* Only set the flag for writes.  */\n   if (is_gimple_assign (loc->stmt)\n@@ -1938,7 +1938,7 @@ sm_set_flag_if_changed::operator () (mem_ref_loc_p loc)\n    set, set an appropriate flag indicating the store.  */\n \n static tree\n-execute_sm_if_changed_flag_set (struct loop *loop, mem_ref_p ref)\n+execute_sm_if_changed_flag_set (struct loop *loop, im_mem_ref *ref)\n {\n   tree flag;\n   char *str = get_lsm_tmp_name (ref->mem.ref, ~0, \"_flag\");\n@@ -1953,7 +1953,7 @@ execute_sm_if_changed_flag_set (struct loop *loop, mem_ref_p ref)\n    to the reference from the temporary variable are emitted to exits.  */\n \n static void\n-execute_sm (struct loop *loop, vec<edge> exits, mem_ref_p ref)\n+execute_sm (struct loop *loop, vec<edge> exits, im_mem_ref *ref)\n {\n   tree tmp_var, store_flag = NULL_TREE;\n   unsigned i;\n@@ -2029,7 +2029,7 @@ static void\n hoist_memory_references (struct loop *loop, bitmap mem_refs,\n \t\t\t vec<edge> exits)\n {\n-  mem_ref_p ref;\n+  im_mem_ref *ref;\n   unsigned  i;\n   bitmap_iterator bi;\n \n@@ -2044,13 +2044,13 @@ struct ref_always_accessed\n {\n   ref_always_accessed (struct loop *loop_, bool stored_p_)\n       : loop (loop_), stored_p (stored_p_) {}\n-  bool operator () (mem_ref_loc_p loc);\n+  bool operator () (mem_ref_loc *loc);\n   struct loop *loop;\n   bool stored_p;\n };\n \n bool\n-ref_always_accessed::operator () (mem_ref_loc_p loc)\n+ref_always_accessed::operator () (mem_ref_loc *loc)\n {\n   struct loop *must_exec;\n \n@@ -2082,7 +2082,7 @@ ref_always_accessed::operator () (mem_ref_loc_p loc)\n    make sure REF is always stored to in LOOP.  */\n \n static bool\n-ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n+ref_always_accessed_p (struct loop *loop, im_mem_ref *ref, bool stored_p)\n {\n   return for_all_locs_in_loop (loop, ref,\n \t\t\t       ref_always_accessed (loop, stored_p));\n@@ -2091,7 +2091,7 @@ ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n /* Returns true if REF1 and REF2 are independent.  */\n \n static bool\n-refs_independent_p (mem_ref_p ref1, mem_ref_p ref2)\n+refs_independent_p (im_mem_ref *ref1, im_mem_ref *ref2)\n {\n   if (ref1 == ref2)\n     return true;\n@@ -2118,7 +2118,7 @@ refs_independent_p (mem_ref_p ref1, mem_ref_p ref2)\n    and its super-loops.  */\n \n static void\n-record_dep_loop (struct loop *loop, mem_ref_p ref, bool stored_p)\n+record_dep_loop (struct loop *loop, im_mem_ref *ref, bool stored_p)\n {\n   /* We can propagate dependent-in-loop bits up the loop\n      hierarchy to all outer loops.  */\n@@ -2131,12 +2131,12 @@ record_dep_loop (struct loop *loop, mem_ref_p ref, bool stored_p)\n    LOOP.  */\n \n static bool\n-ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref, bool stored_p)\n+ref_indep_loop_p_1 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n {\n   bitmap refs_to_check;\n   unsigned i;\n   bitmap_iterator bi;\n-  mem_ref_p aref;\n+  im_mem_ref *aref;\n \n   if (stored_p)\n     refs_to_check = &memory_accesses.refs_in_loop[loop->num];\n@@ -2160,7 +2160,7 @@ ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref, bool stored_p)\n    LOOP.  Wrapper over ref_indep_loop_p_1, caching its results.  */\n \n static bool\n-ref_indep_loop_p_2 (struct loop *loop, mem_ref_p ref, bool stored_p)\n+ref_indep_loop_p_2 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n {\n   stored_p |= (ref->stored && bitmap_bit_p (ref->stored, loop->num));\n \n@@ -2212,7 +2212,7 @@ ref_indep_loop_p_2 (struct loop *loop, mem_ref_p ref, bool stored_p)\n    LOOP.  */\n \n static bool\n-ref_indep_loop_p (struct loop *loop, mem_ref_p ref)\n+ref_indep_loop_p (struct loop *loop, im_mem_ref *ref)\n {\n   gcc_checking_assert (MEM_ANALYZABLE (ref));\n \n@@ -2222,7 +2222,7 @@ ref_indep_loop_p (struct loop *loop, mem_ref_p ref)\n /* Returns true if we can perform store motion of REF from LOOP.  */\n \n static bool\n-can_sm_ref_p (struct loop *loop, mem_ref_p ref)\n+can_sm_ref_p (struct loop *loop, im_mem_ref *ref)\n {\n   tree base;\n \n@@ -2268,7 +2268,7 @@ find_refs_for_sm (struct loop *loop, bitmap sm_executed, bitmap refs_to_sm)\n   bitmap refs = &memory_accesses.all_refs_stored_in_loop[loop->num];\n   unsigned i;\n   bitmap_iterator bi;\n-  mem_ref_p ref;\n+  im_mem_ref *ref;\n \n   EXECUTE_IF_AND_COMPL_IN_BITMAP (refs, sm_executed, 0, i, bi)\n     {\n@@ -2494,7 +2494,7 @@ tree_ssa_lim_finalize (void)\n {\n   basic_block bb;\n   unsigned i;\n-  mem_ref_p ref;\n+  im_mem_ref *ref;\n \n   free_aux_for_edges ();\n "}]}