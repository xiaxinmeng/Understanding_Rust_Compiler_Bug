{"sha": "02e3f1a8e25d56a4823b76369ae043150e182d16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlM2YxYThlMjVkNTZhNDgyM2I3NjM2OWFlMDQzMTUwZTE4MmQxNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-25T22:03:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-25T22:03:03Z"}, "message": "dbxout.c: Consistently use putc instead of fputc.\n\n\t* dbxout.c: Consistently use putc instead of fputc.\n \t(print_wide_int): New function; call instead of direct fprintf.\n\t(dbxout_type_index): Adjust calls of CHARS to be more accurate.\n\t(dbxout_type_fields, dbxout_type_method_1): Likewise.\n\t(dbxout_type_methods, dbxout_range_type, dbxout_type): Likewise.\n\t(print_int_cst_octal): Likewise.\n\t(print_octal): Show we wrote characters.\n\t(dbxout_type): Set have_used_extensions in more places.\n\nFrom-SVN: r44367", "tree": {"sha": "5763c7901d818dab44b17a315d53ea704df8eacb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5763c7901d818dab44b17a315d53ea704df8eacb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02e3f1a8e25d56a4823b76369ae043150e182d16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e3f1a8e25d56a4823b76369ae043150e182d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e3f1a8e25d56a4823b76369ae043150e182d16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e3f1a8e25d56a4823b76369ae043150e182d16/comments", "author": null, "committer": null, "parents": [{"sha": "f2d28b14f389e0e25d354a6c21dc76e2c35dae6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d28b14f389e0e25d354a6c21dc76e2c35dae6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d28b14f389e0e25d354a6c21dc76e2c35dae6d"}], "stats": {"total": 321, "additions": 201, "deletions": 120}, "files": [{"sha": "690e74f1e80498e05f7331ce663f73017256ee51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e3f1a8e25d56a4823b76369ae043150e182d16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e3f1a8e25d56a4823b76369ae043150e182d16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02e3f1a8e25d56a4823b76369ae043150e182d16", "patch": "@@ -1,3 +1,14 @@\n+Wed Jul 25 18:00:05 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* dbxout.c: Consistently use putc instead of fputc.\n+ \t(print_wide_int): New function; call instead of direct fprintf.\n+\t(dbxout_type_index): Adjust calls of CHARS to be more accurate.\n+\t(dbxout_type_fields, dbxout_type_method_1): Likewise.\n+\t(dbxout_type_methods, dbxout_range_type, dbxout_type): Likewise.\n+\t(print_int_cst_octal): Likewise.\n+\t(print_octal): Show we wrote characters.\n+\t(dbxout_type): Set have_used_extensions in more places.\n+\n 2001-07-25  Catherine Moore  <clm@redhat.com>\n \n         * config/v850/v850.c (v850_va_arg):  Use addr\n@@ -7,7 +18,8 @@ Wed Jul 25 22:48:59 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* flow.c (delete_dead_jumptables): New function.\n \t(life_analyzis): Call it.\n-\t* bb-reorder.c (skip_insns_after_block): Handle contradictive sequences.\n+\t* bb-reorder.c (skip_insns_after_block): Handle contradictory\n+\tsequences.\n \n 2001-07-25  Richard Henderson  <rth@redhat.com>\n \n@@ -17,7 +29,7 @@ Wed Jul 25 22:48:59 CEST 2001  Jan Hubicka  <jh@suse.cz>\n 2001-07-25  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (alpha_emit_conditional_move): Always\n-\tswap GE/GT if its an fp comparison.\n+\tswap GE/GT if it is an fp comparison.\n \n 2001-07-25  Andrew Haley  <aph@cambridge.redhat.com>\n "}, {"sha": "7589f69f6b00d0d4aa678c8133742eb14c2cf690", "filename": "gcc/dbxout.c", "status": "modified", "additions": 187, "deletions": 118, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e3f1a8e25d56a4823b76369ae043150e182d16/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e3f1a8e25d56a4823b76369ae043150e182d16/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=02e3f1a8e25d56a4823b76369ae043150e182d16", "patch": "@@ -306,6 +306,7 @@ static void dbxout_range_type\t\tPARAMS ((tree));\n static void dbxout_type\t\t\tPARAMS ((tree, int));\n static void print_int_cst_octal\t\tPARAMS ((tree));\n static void print_octal\t\t\tPARAMS ((unsigned HOST_WIDE_INT, int));\n+static void print_wide_int\t\tPARAMS ((HOST_WIDE_INT));\n static void dbxout_type_name\t\tPARAMS ((tree));\n static int dbxout_symbol_location\tPARAMS ((tree, tree, const char *, rtx));\n static void dbxout_symbol_name\t\tPARAMS ((tree, const char *, int));\n@@ -394,7 +395,7 @@ dbxout_function_end ()\n      symbol and an empty string.  */\n   fprintf (asmfile, \"%s\\\"\\\",%d,0,0,\", ASM_STABS_OP, N_FUN);\n   assemble_name (asmfile, lscope_label_name);\n-  fputc ('-', asmfile);\n+  putc ('-', asmfile);\n   assemble_name (asmfile, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n   fprintf (asmfile, \"\\n\");\n }\n@@ -690,7 +691,7 @@ dbxout_type_index (type)\n #else\n   struct typeinfo *t = &typevec[TYPE_SYMTAB_ADDRESS (type)];\n   fprintf (asmfile, \"(%d,%d)\", t->file_number, t->type_number);\n-  CHARS (7);\n+  CHARS (9);\n #endif\n }\n \n@@ -756,7 +757,7 @@ dbxout_type_fields (type)\n \t  else\n \t    {\n \t      fprintf (asmfile, \":\");\n-\t      CHARS (2);\n+\t      CHARS (1);\n \t    }\n \n \t  if (use_gnu_debug_info_extensions\n@@ -779,26 +780,27 @@ dbxout_type_fields (type)\n \t    {\n \t      if (TREE_STATIC (tem) && use_gnu_debug_info_extensions)\n \t\t{\n-\t\t  const char *name =\n-\t\t    IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (tem));\n+\t\t  tree name = DECL_ASSEMBLER_NAME (tem);\n+\n \t\t  have_used_extensions = 1;\n-\t\t  fprintf (asmfile, \":%s;\", name);\n-\t\t  CHARS (strlen (name));\n+\t\t  fprintf (asmfile, \":%s;\", IDENTIFIER_POINTER (name));\n+\t\t  CHARS (IDENTIFIER_LENGTH (name) + 2);\n \t\t}\n \t      else\n-\t\t/* If TEM is non-static, GDB won't understand it.  */\n-\t\tfprintf (asmfile, \",0,0;\");\n+\t\t{\n+\t\t  /* If TEM is non-static, GDB won't understand it.  */\n+\t\t  fprintf (asmfile, \",0,0;\");\n+\t\t  CHARS (5);\n+\t\t}\n \t    }\n \t  else\n \t    {\n-\t      fputc (',', asmfile);\n-\t      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t       int_bit_position (tem));\n-\t      fputc (',', asmfile);\n-\t      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t       tree_low_cst (DECL_SIZE (tem), 1));\n-\t      fputc (';', asmfile);\n-\t      CHARS (23);\n+\t      putc (',', asmfile);\n+\t      print_wide_int (int_bit_position (tem));\n+\t      putc (',', asmfile);\n+\t      print_wide_int (tree_low_cst (DECL_SIZE (tem), 1));\n+\t      putc (';', asmfile);\n+\t      CHARS (3);\n \t    }\n \t}\n     }\n@@ -844,12 +846,12 @@ dbxout_type_method_1 (decl, debug_name)\n \n   if (DECL_VINDEX (decl) && host_integerp (DECL_VINDEX (decl), 0))\n     {\n-      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t       tree_low_cst (DECL_VINDEX (decl), 0));\n-      fputc (';', asmfile);\n+      print_wide_int (tree_low_cst (DECL_VINDEX (decl), 0));\n+      putc (';', asmfile);\n+      CHARS (1);\n       dbxout_type (DECL_CONTEXT (decl), 0);\n       fprintf (asmfile, \";\");\n-      CHARS (8);\n+      CHARS (1);\n     }\n }\n \f\n@@ -925,8 +927,7 @@ dbxout_type_methods (type)\n \t  if (TREE_CODE (fndecl) != FUNCTION_DECL)\n \t    continue;\n \n-\t  debug_name =\n-\t    IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n+\t  debug_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n \n \t  CONTIN;\n \n@@ -995,23 +996,30 @@ dbxout_range_type (type)\n   if (TYPE_MIN_VALUE (type) != 0\n       && host_integerp (TYPE_MIN_VALUE (type), 0))\n     {\n-      fputc (';', asmfile);\n-      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t       tree_low_cst (TYPE_MIN_VALUE (type), 0));\n+      putc (';', asmfile);\n+      CHARS (1);\n+      print_wide_int (tree_low_cst (TYPE_MIN_VALUE (type), 0));\n     }\n   else\n-    fprintf (asmfile, \";0\");\n+    {\n+      fprintf (asmfile, \";0\");\n+      CHARS (2);\n+    }\n \n   if (TYPE_MAX_VALUE (type) != 0\n       && host_integerp (TYPE_MAX_VALUE (type), 0))\n     {\n-      fputc (';', asmfile);\n-      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t       tree_low_cst (TYPE_MAX_VALUE (type), 0));\n-      fputc (';', asmfile);\n+      putc (';', asmfile);\n+      CHARS (1);\n+      print_wide_int (tree_low_cst (TYPE_MAX_VALUE (type), 0));\n+      putc (';', asmfile);\n+      CHARS (1);\n     }\n   else\n-    fprintf (asmfile, \";-1;\");\n+    {\n+      fprintf (asmfile, \";-1;\");\n+      CHARS (4);\n+    }\n }\n \f\n /* Output a reference to a type.  If the type has not yet been\n@@ -1177,8 +1185,10 @@ dbxout_type (type, full)\n \t     This used to use `r2' explicitly and we used to\n \t     take care to make sure that `char' was type number 2.  */\n \t  fprintf (asmfile, \"r\");\n+\t  CHARS (1);\n \t  dbxout_type_index (type);\n \t  fprintf (asmfile, \";0;127;\");\n+\t  CHARS (7);\n \t}\n \n       /* If this is a subtype of another integer type, always prefer to\n@@ -1194,7 +1204,11 @@ dbxout_type (type, full)\n \n \t  if (use_gnu_debug_info_extensions\n \t      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n-\t    fprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\t    {\n+\t      have_used_extensions = 1;\n+\t      fprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\t      CHARS (5);\n+\t    }\n \n \t  /* If we can use GDB extensions and the size is wider than a\n \t     long (the size used by GDB to read them) or we may have\n@@ -1222,63 +1236,75 @@ dbxout_type (type, full)\n \t\t      && TREE_UNSIGNED (type))))\n \t    {\n \t      fprintf (asmfile, \"r\");\n+\t      CHARS (1);\n \t      dbxout_type_index (type);\n \t      fprintf (asmfile, \";\");\n+\t      CHARS (1);\n \t      print_int_cst_octal (TYPE_MIN_VALUE (type));\n \t      fprintf (asmfile, \";\");\n+\t      CHARS (1);\n \t      print_int_cst_octal (TYPE_MAX_VALUE (type));\n \t      fprintf (asmfile, \";\");\n+\t      CHARS (1);\n \t    }\n \n \t  else\n \t    /* Output other integer types as subranges of `int'.  */\n \t    dbxout_range_type (type);\n   \t}\n \n-      CHARS (22);\n       break;\n \n     case REAL_TYPE:\n       /* This used to say `r1' and we used to take care\n \t to make sure that `int' was type number 1.  */\n       fprintf (asmfile, \"r\");\n+      CHARS (1);\n       dbxout_type_index (integer_type_node);\n-      fputc (';', asmfile);\n-      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC, int_size_in_bytes (type));\n+      putc (';', asmfile);\n+      CHARS (1);\n+      print_wide_int (int_size_in_bytes (type));\n       fputs (\";0;\", asmfile);\n-      CHARS (13);\n+      CHARS (3);\n       break;\n \n     case CHAR_TYPE:\n       if (use_gnu_debug_info_extensions)\n \t{\n+\t  have_used_extensions = 1;\n \t  fputs (\"@s\", asmfile);\n-\t  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  CHARS (2);\n+\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n \t  fputs (\";-20;\", asmfile);\n+\t  CHARS (4);\n \t}\n       else\n \t{\n \t  /* Output the type `char' as a subrange of itself.\n \t     That is what pcc seems to do.  */\n \t  fprintf (asmfile, \"r\");\n+\t  CHARS (1);\n \t  dbxout_type_index (char_type_node);\n \t  fprintf (asmfile, \";0;%d;\", TREE_UNSIGNED (type) ? 255 : 127);\n+\t  CHARS (7);\n \t}\n-      CHARS (9);\n       break;\n \n     case BOOLEAN_TYPE:\n       if (use_gnu_debug_info_extensions)\n \t{\n+\t  have_used_extensions = 1;\n \t  fputs (\"@s\", asmfile);\n-\t  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  CHARS (2);\n+\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n \t  fputs (\";-16;\", asmfile);\n+\t  CHARS (4);\n \t}\n       else /* Define as enumeral type (False, True) */\n-\tfprintf (asmfile, \"eFalse:0,True:1,;\");\n-      CHARS (17);\n+\t{\n+\t  fprintf (asmfile, \"eFalse:0,True:1,;\");\n+\t  CHARS (17);\n+\t}\n       break;\n \n     case FILE_TYPE:\n@@ -1293,33 +1319,33 @@ dbxout_type (type, full)\n       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t{\n \t  fprintf (asmfile, \"r\");\n+\t  CHARS (1);\n \t  dbxout_type_index (type);\n-\t  fputc (';', asmfile);\n-\t  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   2 * int_size_in_bytes (TREE_TYPE (type)));\n+\t  putc (';', asmfile);\n+\t  CHARS (1);\n+\t  print_wide_int (2 * int_size_in_bytes (TREE_TYPE (type)));\n \t  fputs (\";0;\", asmfile);\n-\t  CHARS (12);\t\t/* The number is probably incorrect here.  */\n+\t  CHARS (3);\n \t}\n       else\n \t{\n \t  /* Output a complex integer type as a structure,\n \t     pending some other way to do it.  */\n-\t  fputc ('s', asmfile);\n-\t  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC, int_size_in_bytes (type));\n-\n+\t  putc ('s', asmfile);\n+\t  CHARS (1);\n+\t  print_wide_int (int_size_in_bytes (type));\n \t  fprintf (asmfile, \"real:\");\n-\t  CHARS (10);\n+\t  CHARS (5);\n+\n \t  dbxout_type (TREE_TYPE (type), 0);\n-\t  fprintf (asmfile, \",%d,%d;\",\n-\t\t   0, TYPE_PRECISION (TREE_TYPE (type)));\n-\t  CHARS (8);\n+\t  fprintf (asmfile, \",0,%d;\", TYPE_PRECISION (TREE_TYPE (type)));\n+\t  CHARS (7);\n \t  fprintf (asmfile, \"imag:\");\n \t  CHARS (5);\n \t  dbxout_type (TREE_TYPE (type), 0);\n-\t  fprintf (asmfile, \",%d,%d;;\",\n-\t\t   TYPE_PRECISION (TREE_TYPE (type)),\n+\t  fprintf (asmfile, \",%d,%d;;\", TYPE_PRECISION (TREE_TYPE (type)),\n \t\t   TYPE_PRECISION (TREE_TYPE (type)));\n-\t  CHARS (9);\n+\t  CHARS (10);\n \t}\n       break;\n \n@@ -1328,13 +1354,18 @@ dbxout_type (type, full)\n \t{\n \t  have_used_extensions = 1;\n \t  fputs (\"@s\", asmfile);\n-\t  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fputc (';', asmfile);\n+\t  CHARS (2);\n+\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  putc (';', asmfile);\n+\t  CHARS (1);\n+\n \t  /* Check if a bitstring type, which in Chill is\n \t     different from a [power]set.  */\n \t  if (TYPE_STRING_FLAG (type))\n-\t    fprintf (asmfile, \"@S;\");\n+\t    {\n+\t      fprintf (asmfile, \"@S;\");\n+\t      CHARS (3);\n+\t    }\n \t}\n       putc ('S', asmfile);\n       CHARS (1);\n@@ -1347,15 +1378,14 @@ dbxout_type (type, full)\n \t{\n \t  have_used_extensions = 1;\n \t  fputs (\"@s\", asmfile);\n-\t  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fputc (';', asmfile);\n-\t  fprintf (asmfile, \"@S;\");\n-\t  putc ('S', asmfile);\n-\t  CHARS (1);\n+\t  CHARS (2);\n+\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  fprintf (asmfile, \";@S;S\");\n+\t  CHARS (5);\n \t  dbxout_type (TYPE_DOMAIN (type), 0);\n \t  break;\n \t}\n+\n       /* Output \"a\" followed by a range type definition\n \t for the index type of the array\n \t followed by a reference to the target-type.\n@@ -1366,20 +1396,24 @@ dbxout_type (type, full)\n \t{\n \t  have_used_extensions = 1;\n \t  fprintf (asmfile, \"@S;\");\n+\t  CHARS (3);\n \t}\n       tem = TYPE_DOMAIN (type);\n       if (tem == NULL)\n \t{\n \t  fprintf (asmfile, \"ar\");\n+\t  CHARS (2);\n \t  dbxout_type_index (integer_type_node);\n \t  fprintf (asmfile, \";0;-1;\");\n+\t  CHARS (6);\n \t}\n       else\n \t{\n \t  fprintf (asmfile, \"a\");\n+\t  CHARS (1);\n \t  dbxout_range_type (tem);\n \t}\n-      CHARS (14);\n+\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n@@ -1412,7 +1446,7 @@ dbxout_type (type, full)\n \t       another type's definition; instead, output an xref\n \t       and let the definition come when the name is defined.  */\n \t    fputs ((TREE_CODE (type) == RECORD_TYPE) ? \"xs\" : \"xu\", asmfile);\n-\t    CHARS (3);\n+\t    CHARS (2);\n #if 0 /* This assertion is legitimately false in C++.  */\n \t    /* We shouldn't be outputting a reference to a type before its\n \t       definition unless the type has a tag name.\n@@ -1423,16 +1457,21 @@ dbxout_type (type, full)\n \t    if (TYPE_NAME (type) != 0)\n \t      dbxout_type_name (type);\n \t    else\n-\t      fprintf (asmfile, \"$$%d\", anonymous_type_number++);\n+\t      {\n+\t\tfprintf (asmfile, \"$$%d\", anonymous_type_number++);\n+\t\tCHARS (5);\n+\t      }\n+\n \t    fprintf (asmfile, \":\");\n+\t    CHARS (1);\n \t    typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n \t    break;\n \t  }\n \n \t/* Identify record or union, and print its size.  */\n-\tfputc (((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u'), asmfile);\n-\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t int_size_in_bytes (type));\n+\tputc (((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u'), asmfile);\n+\tCHARS (1);\n+\tprint_wide_int (int_size_in_bytes (type));\n \n \tif (use_gnu_debug_info_extensions)\n \t  {\n@@ -1452,38 +1491,40 @@ dbxout_type (type, full)\n \t\thave_used_extensions = 1;\n \t\tputc (TREE_VIA_VIRTUAL (child) ? '1' : '0', asmfile);\n \t\tputc (TREE_VIA_PUBLIC (child) ? '2' : '0', asmfile);\n-\t\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t (tree_low_cst (BINFO_OFFSET (child), 0)\n-\t\t\t  * BITS_PER_UNIT));\n-\t\tfputc (',', asmfile);\n-\t\tCHARS (15);\n+\t\tCHARS (2);\n+\t\tprint_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t\t* BITS_PER_UNIT);\n+\t\tputc (',', asmfile);\n+\t\tCHARS (1);\n \t\tdbxout_type (BINFO_TYPE (child), 0);\n \t\tputc (';', asmfile);\n+\t\tCHARS (1);\n \t      }\n \t    else\n \t      {\n \t\t/* Print out the base class information with fields\n \t\t   which have the same names at the types they hold.  */\n \t\tdbxout_type_name (BINFO_TYPE (child));\n \t\tputc (':', asmfile);\n+\t\tCHARS (1);\n \t\tdbxout_type (BINFO_TYPE (child), full);\n-\t\tfputc (',', asmfile);\n-\t\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t tree_low_cst (BINFO_OFFSET (child), 0)\n-\t\t\t * BITS_PER_UNIT);\n-\t\tfputc (',', asmfile);\n-\t\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t (tree_low_cst (DECL_SIZE (TYPE_NAME\n-\t\t\t\t\t\t  (BINFO_TYPE (child))), 0)\n-\t\t\t  * BITS_PER_UNIT));\n-\t\tfputc (';', asmfile);\n-\t\tCHARS (20);\n+\t\tputc (',', asmfile);\n+\t\tCHARS (1);\n+\t\tprint_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t\t* BITS_PER_UNIT);\n+\t\tputc (',', asmfile);\n+\t\tCHARS (1);\n+\t\tprint_wide_int (tree_low_cst (DECL_SIZE\n+\t\t\t\t\t      (TYPE_NAME\n+\t\t\t\t\t       (BINFO_TYPE (child))),\n+\t\t\t\t\t      0)\n+\t\t\t\t* BITS_PER_UNIT);\n+\t\tputc (';', asmfile);\n+\t\tCHARS (1);\n \t      }\n \t  }\n       }\n \n-      CHARS (11);\n-\n       /* Write out the field declarations.  */\n       dbxout_type_fields (type);\n       if (use_gnu_debug_info_extensions && TYPE_METHODS (type) != NULL_TREE)\n@@ -1493,6 +1534,7 @@ dbxout_type (type, full)\n \t}\n \n       putc (';', asmfile);\n+      CHARS (1);\n \n       if (use_gnu_debug_info_extensions && TREE_CODE (type) == RECORD_TYPE\n \t  /* Avoid the ~ if we don't really need it--it confuses dbx.  */\n@@ -1502,6 +1544,7 @@ dbxout_type (type, full)\n \n \t  /* Tell GDB+ that it may keep reading.  */\n \t  putc ('~', asmfile);\n+\t  CHARS (1);\n \n \t  /* We need to write out info about what field this class\n \t     uses as its \"main\" vtable pointer field, because if this\n@@ -1510,10 +1553,12 @@ dbxout_type (type, full)\n \t  if (TYPE_VFIELD (type))\n \t    {\n \t      putc ('%', asmfile);\n+\t      CHARS (1);\n \t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);\n \t    }\n+\n \t  putc (';', asmfile);\n-\t  CHARS (3);\n+\t  CHARS (1);\n \t}\n       break;\n \n@@ -1528,39 +1573,43 @@ dbxout_type (type, full)\n \t  || !COMPLETE_TYPE_P (type))\n \t{\n \t  fprintf (asmfile, \"xe\");\n-\t  CHARS (3);\n+\t  CHARS (2);\n \t  dbxout_type_name (type);\n \t  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n-\t  fprintf (asmfile, \":\");\n+\t  putc (':', asmfile);\n+\t  CHARS (1);\n \t  return;\n \t}\n #ifdef DBX_OUTPUT_ENUM\n       DBX_OUTPUT_ENUM (asmfile, type);\n #else\n       if (use_gnu_debug_info_extensions\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n-\tfprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\t{\n+\t  fprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\t  CHARS (5);\n+\t}\n+\n       putc ('e', asmfile);\n       CHARS (1);\n       for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))\n \t{\n \t  fprintf (asmfile, \"%s:\", IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n+\t  CHARS (IDENTIFIER_LENGTH (TREE_PURPOSE (tem)) + 1);\n \t  if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == 0)\n-\t    fprintf (asmfile, HOST_WIDE_INT_PRINT_UNSIGNED,\n-\t\t     TREE_INT_CST_LOW (TREE_VALUE (tem)));\n+\t    print_wide_int (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n \t  else if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == -1\n \t\t   && (HOST_WIDE_INT) TREE_INT_CST_LOW (TREE_VALUE (tem)) < 0)\n-\t    fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t     TREE_INT_CST_LOW (TREE_VALUE (tem)));\n+\t    print_wide_int (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n \t  else\n \t    print_int_cst_octal (TREE_VALUE (tem));\n-\t  fprintf (asmfile, \",\");\n-\t  CHARS (20 + IDENTIFIER_LENGTH (TREE_PURPOSE (tem)));\n+\n+\t  putc (',', asmfile);\n+\t  CHARS (1);\n \t  if (TREE_CHAIN (tem) != 0)\n-\t    {\n-\t      CONTIN;\n-\t    }\n+\t    CONTIN;\n \t}\n+\n       putc (';', asmfile);\n       CHARS (1);\n #endif\n@@ -1589,10 +1638,8 @@ dbxout_type (type, full)\n \t  CHARS (1);\n \t}\n       else\n-\t{\n-\t  /* Treat it as a function type.  */\n-\t  dbxout_type (TREE_TYPE (type), 0);\n-\t}\n+\t/* Treat it as a function type.  */\n+\tdbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case OFFSET_TYPE:\n@@ -1607,11 +1654,8 @@ dbxout_type (type, full)\n \t  dbxout_type (TREE_TYPE (type), 0);\n \t}\n       else\n-\t{\n-\t  /* Should print as an int, because it is really\n-\t     just an offset.  */\n-\t  dbxout_type (integer_type_node, 0);\n-\t}\n+\t/* Should print as an int, because it is really just an offset.  */\n+\tdbxout_type (integer_type_node, 0);\n       break;\n \n     case REFERENCE_TYPE:\n@@ -1658,6 +1702,7 @@ print_int_cst_octal (c)\n     high = 0, low &= (((HOST_WIDE_INT) 1 << width) - 1);\n \n   fprintf (asmfile, \"0\");\n+  CHARS (1);\n \n   if (excess == 3)\n     {\n@@ -1676,6 +1721,7 @@ print_int_cst_octal (c)\n \t\t - 1);\n \n       fprintf (asmfile, \"%o%01o\", (int) beg, (int) middle);\n+      CHARS (2);\n       print_octal (end, HOST_BITS_PER_WIDE_INT / 3);\n     }\n }\n@@ -1689,8 +1735,29 @@ print_octal (value, digits)\n \n   for (i = digits - 1; i >= 0; i--)\n     fprintf (asmfile, \"%01o\", (int) ((value >> (3 * i)) & 7));\n+\n+  CHARS (digits);\n }\n \n+/* Output C in decimal while adjusting the number of digits written.  */\n+\n+static void\n+print_wide_int (c)\n+     HOST_WIDE_INT c;\n+{\n+  int digs = 0;\n+\n+  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC, c);\n+\n+  if (c < 0)\n+    digs++, c = -c;\n+\n+  while (c > 0)\n+    c /= 10; digs++;\n+\n+  CHARS (digs);\n+}\n+      \n /* Output the name of type TYPE, with no punctuation.\n    Such names can be set up either by typedef declarations\n    or by struct, enum and union tags.  */\n@@ -2257,7 +2324,8 @@ dbxout_symbol_name (decl, suffix, letter)\n   fprintf (asmfile, \"%s\\\"%s%s:\", ASM_STABS_OP, name,\n \t   (suffix ? suffix : \"\"));\n \n-  if (letter) putc (letter, asmfile);\n+  if (letter)\n+    putc (letter, asmfile);\n }\n \n static void\n@@ -2479,7 +2547,8 @@ dbxout_parms (parms)\n \t    FORCE_TEXT;\n \t    if (DECL_NAME (parms))\n \t      {\n-\t\tcurrent_sym_nchars = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t\tcurrent_sym_nchars\n+\t\t  = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n \n \t\tfprintf (asmfile, \"%s\\\"%s:%c\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n@@ -2715,7 +2784,7 @@ dbxout_block (block, depth, args)\n \t      fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_LBRAC);\n \t      assemble_name (asmfile, buf);\n #if DBX_BLOCKS_FUNCTION_RELATIVE\n-\t      fputc ('-', asmfile);\n+\t      putc ('-', asmfile);\n \t      assemble_name (asmfile, begin_label);\n #endif\n \t      fprintf (asmfile, \"\\n\");\n@@ -2745,7 +2814,7 @@ dbxout_block (block, depth, args)\n \t      fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_RBRAC);\n \t      assemble_name (asmfile, buf);\n #if DBX_BLOCKS_FUNCTION_RELATIVE\n-\t      fputc ('-', asmfile);\n+\t      putc ('-', asmfile);\n \t      assemble_name (asmfile, begin_label);\n #endif\n \t      fprintf (asmfile, \"\\n\");"}]}