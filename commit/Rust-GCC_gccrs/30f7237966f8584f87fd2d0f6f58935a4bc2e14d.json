{"sha": "30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBmNzIzNzk2NmY4NTg0Zjg3ZmQyZDBmNmY1ODkzNWE0YmMyZTE0ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-03-30T20:52:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-30T20:52:33Z"}, "message": "alias.c (alias_set_compare): Remove.\n\n\t* alias.c (alias_set_compare): Remove.\n\t(record_alias_subset): Use splay_tree_compare_ints instaed of\n\talias_set_compare.\n\t(init_alias_once): Likewise.\n\t* cse.c: Include splay-tree.h.\n\t(reg_qty): Remove.\n\t(reg_tick): Likewise.\n\t(reg_table): Likewise.\n\t(cse_reg_info): New structure.\n\t(cse_reg_info_free_list): New variable.\n\t(cse_reg_info_tree): Likewise.\n\t(cached_regno): Likewise.\n\t(cached_cse_reg_info): Likewise.\n\t(all_minus_one): Remove.\n\t(consec_ints): Likewise.\n\t(GET_CSE_REG_INFO): New macro.\n\t(REG_TICK): Likewise.  Use throughout instead of reg_tick.\n\t(REG_IN_TABLE): Likewise.  Use throughout instead of reg_in_table.\n\t(REG_QTY): Likewise.  Use throughout instead of reg_qty.\n\t(get_cse_reg_info): New function.\n\t(free_cse_reg_info): Likewise.\n\t(new_basic_block): Reinitialize cse_reg_info_tree instead of\n\treg_tick, all_minus_one, and consec_ints.\n\t* Makefile.in (cse.o): Depend on splay-tree.h\n\t* splay-tree.h (splay_tree_compare_ints): Declare.\n\t* splay-tree.c (splay_tree_compare_ints): Define.\n\nFrom-SVN: r26069", "tree": {"sha": "677dd85fdef907b3c68542436e9dc467331e36eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/677dd85fdef907b3c68542436e9dc467331e36eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/comments", "author": null, "committer": null, "parents": [{"sha": "4cc48683f65e236df8d246207c8958d42d3c069a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc48683f65e236df8d246207c8958d42d3c069a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cc48683f65e236df8d246207c8958d42d3c069a"}], "stats": {"total": 409, "additions": 255, "deletions": 154}, "files": [{"sha": "ac7a78c1df979dbed83966651df3f8cb3731e2cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -1,3 +1,30 @@\n+Tue Mar 30 20:51:40 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* alias.c (alias_set_compare): Remove.\n+\t(record_alias_subset): Use splay_tree_compare_ints instaed of\n+\talias_set_compare.\n+\t(init_alias_once): Likewise.\n+\t* cse.c: Include splay-tree.h.\n+\t(reg_qty): Remove.\n+\t(reg_tick): Likewise.\n+\t(reg_table): Likewise.\n+\t(cse_reg_info): New structure.\n+\t(cse_reg_info_free_list): New variable.\n+\t(cse_reg_info_tree): Likewise.\n+\t(cached_regno): Likewise.\n+\t(cached_cse_reg_info): Likewise.\n+\t(all_minus_one): Remove.\n+\t(consec_ints): Likewise.\n+\t(GET_CSE_REG_INFO): New macro.\n+\t(REG_TICK): Likewise.  Use throughout instead of reg_tick.\n+\t(REG_IN_TABLE): Likewise.  Use throughout instead of reg_in_table.\n+\t(REG_QTY): Likewise.  Use throughout instead of reg_qty.\n+\t(get_cse_reg_info): New function.\n+\t(free_cse_reg_info): Likewise.\n+\t(new_basic_block): Reinitialize cse_reg_info_tree instead of\n+\treg_tick, all_minus_one, and consec_ints.\n+\t* Makefile.in (cse.o): Depend on splay-tree.h\n+\n Tue Mar 30 13:19:36 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* libgcc2.c (throw_helper): Just return the SP offset, rather than"}, {"sha": "c967ecea68c61b31d8930645b30482cb5ab06fa3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -1515,7 +1515,8 @@ stupid.o : stupid.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H) insn-config.h reload.h flags.h toplev.h\n \n cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n-   real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h\n+   real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h \\\n+   $(srcdir)/../include/splay-tree.h\n gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) output.h\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h system.h \\"}, {"sha": "3bfb44004861b12052792dca4ea41b622515ca07", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -83,8 +83,6 @@ static int base_alias_check\t\tPROTO((rtx, rtx, enum machine_mode,\n \t\t\t\t\t       enum machine_mode));\n static rtx find_base_value\t\tPROTO((rtx));\n static int mems_in_disjoint_alias_sets_p PROTO((rtx, rtx));\n-static int alias_set_compare            PROTO((splay_tree_key, \n-\t\t\t\t\t       splay_tree_key));\n static int insert_subset_children       PROTO((splay_tree_node,\n \t\t\t\t\t       void*));\n static alias_set_entry get_alias_set_entry PROTO((int));\n@@ -169,25 +167,6 @@ static int copying_arguments;\n \n static splay_tree alias_sets;\n \n-/* Returns -1, 0, 1 according to whether SET1 is less than, equal to,\n-   or greater than SET2.  */\n-\n-static int\n-alias_set_compare (set1, set2)\n-     splay_tree_key set1;\n-     splay_tree_key set2;\n-{\n-  int s1 = (int) set1;\n-  int s2 = (int) set2;\n-\n-  if (s1 < s2)\n-    return -1;\n-  else if (s1 > s2)\n-    return 1;\n-  else \n-    return 0;\n-}\n-\n /* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n    such an entry, or NULL otherwise.  */\n \n@@ -305,7 +284,7 @@ record_alias_subset (superset, subset)\n \t(alias_set_entry) xmalloc (sizeof (struct alias_set_entry));\n       superset_entry->alias_set = superset;\n       superset_entry->children \n-\t= splay_tree_new (alias_set_compare, 0, 0);\n+\t= splay_tree_new (splay_tree_compare_ints, 0, 0);\n       splay_tree_insert (alias_sets, \n \t\t\t (splay_tree_key) superset,\n \t\t\t (splay_tree_value) superset_entry);\n@@ -1329,7 +1308,7 @@ init_alias_once ()\n \t&& HARD_REGNO_MODE_OK (i, Pmode))\n       SET_HARD_REG_BIT (argument_registers, i);\n \n-  alias_sets = splay_tree_new (alias_set_compare, 0, 0);\n+  alias_sets = splay_tree_new (splay_tree_compare_ints, 0, 0);\n }\n \n void"}, {"sha": "da585c086dd7b9a941aba72db370703d01465df9", "filename": "gcc/cse.c", "status": "modified", "additions": 199, "deletions": 130, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -34,6 +34,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"splay-tree.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -274,11 +275,6 @@ static rtx prev_insn;\n \n static rtx this_insn;\n \n-/* Index by register number, gives the quantity number\n-   of the register's current contents.  */\n-\n-static int *reg_qty;\n-\n /* Index by register number, gives the number of the next (or\n    previous) register in the chain of registers sharing the same\n    value.\n@@ -290,19 +286,36 @@ static int *reg_qty;\n static int *reg_next_eqv;\n static int *reg_prev_eqv;\n \n-/* Index by register number, gives the number of times\n-   that register has been altered in the current basic block.  */\n+struct cse_reg_info {\n+  union {\n+    /* The number of times the register has been altered in the current\n+       basic block.  */\n+    int reg_tick;\n+    \n+    /* The next cse_reg_info structure in the free list.  */\n+    struct cse_reg_info* next;\n+  } variant;\n+\n+  /* The REG_TICK value at which rtx's containing this register are\n+     valid in the hash table.  If this does not equal the current\n+     reg_tick value, such expressions existing in the hash table are\n+     invalid.  */\n+  int reg_in_table;\n+\n+  /* The quantity number of the register's current contents.  */\n+  int reg_qty;\n+};\n \n-static int *reg_tick;\n+/* A free list of cse_reg_info entries.  */\n+static struct cse_reg_info *cse_reg_info_free_list;\n \n-/* Index by register number, gives the reg_tick value at which\n-   rtx's containing this register are valid in the hash table.\n-   If this does not equal the current reg_tick value, such expressions\n-   existing in the hash table are invalid.\n-   If this is -1, no expressions containing this register have been\n-   entered in the table.  */\n+/* A mapping from registers to cse_reg_info data structures.  */\n+static splay_tree cse_reg_info_tree;\n \n-static int *reg_in_table;\n+/* The last lookup we did into the cse_reg_info_tree.  This allows us\n+   to cache repeated lookups.  */\n+static int cached_regno;\n+static struct cse_reg_info *cached_cse_reg_info;\n \n /* A HARD_REG_SET containing all the hard registers for which there is \n    currently a REG expression in the hash table.  Note the difference\n@@ -316,14 +329,6 @@ static HARD_REG_SET hard_regs_in_table;\n \n static HARD_REG_SET regs_invalidated_by_call;\n \n-/* Two vectors of ints:\n-   one containing max_reg -1's; the other max_reg + 500 (an approximation\n-   for max_qty) elements where element i contains i.\n-   These are used to initialize various other vectors fast.  */\n-\n-static int *all_minus_one;\n-static int *consec_ints;\n-\n /* CUID of insn that starts the basic block currently being cse-processed.  */\n \n static int cse_basic_block_start;\n@@ -447,7 +452,7 @@ struct table_elt\n \n #define HASH(X, M)\t\\\n  (GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n-  ? (((unsigned) REG << 7) + (unsigned) reg_qty[REGNO (X)]) % NBUCKETS\t\\\n+  ? (((unsigned) REG << 7) + (unsigned) REG_QTY (REGNO (X))) % NBUCKETS\t\\\n   : canon_hash (X, M) % NBUCKETS)\n \n /* Determine whether register number N is considered a fixed register for CSE.\n@@ -492,10 +497,29 @@ struct table_elt\n       : 2)\t\t\t\t\t\t\t\t\\\n    : notreg_cost(X))\n \n+/* Get the info associated with register N.  */\n+\n+#define GET_CSE_REG_INFO(N) \t\t\t\\\n+  (((N) == cached_regno && cached_cse_reg_info)\t\\\n+   ? cached_cse_reg_info : get_cse_reg_info ((N)))\n+\n+/* Get the number of times this register has been updated in this\n+   basic block.  */\n+\n+#define REG_TICK(N) ((GET_CSE_REG_INFO (N))->variant.reg_tick)\n+\n+/* Get the point at which REG was recorded in the table.  */\n+\n+#define REG_IN_TABLE(N) ((GET_CSE_REG_INFO (N))->reg_in_table)\n+\n+/* Get the quantity number for REG.  */\n+\n+#define REG_QTY(N) ((GET_CSE_REG_INFO (N))->reg_qty)\n+\n /* Determine if the quantity number for register X represents a valid index\n    into the `qty_...' variables.  */\n \n-#define REGNO_QTY_VALID_P(N) (reg_qty[N] != (N))\n+#define REGNO_QTY_VALID_P(N) (REG_QTY (N) != (N))\n \n #ifdef ADDRESS_COST\n /* The ADDRESS_COST macro does not deal with ADDRESSOF nodes.  But,\n@@ -665,6 +689,8 @@ static rtx cse_basic_block\tPROTO((rtx, rtx, struct branch_path *, int));\n static void count_reg_usage\tPROTO((rtx, int *, rtx, int));\n extern void dump_class          PROTO((struct table_elt*));\n static void check_fold_consts\tPROTO((PTR));\n+static struct cse_reg_info* get_cse_reg_info PROTO((int));\n+static void free_cse_reg_info   PROTO((splay_tree_value));\n \n extern int rtx_equal_function_value_matters;\n \f\n@@ -808,6 +834,57 @@ rtx_cost (x, outer_code)\n   return total;\n }\n \f\n+static struct cse_reg_info *\n+get_cse_reg_info (regno)\n+     int regno;\n+{\n+  struct cse_reg_info *cri;\n+  splay_tree_node n;\n+\n+  /* See if we already have this entry.  */\n+  n = splay_tree_lookup (cse_reg_info_tree, \n+\t\t\t(splay_tree_key) regno);\n+  if (n)\n+    cri = (struct cse_reg_info *) (n->value);\n+  else \n+    {\n+      /* Get a new cse_reg_info structure.  */\n+      if (cse_reg_info_free_list) \n+\t{\n+\t  cri = cse_reg_info_free_list;\n+\t  cse_reg_info_free_list = cri->variant.next;\n+\t}\n+      else\n+\tcri = (struct cse_reg_info *) xmalloc (sizeof (struct cse_reg_info));\n+\n+      /* Initialize it.  */\n+      cri->variant.reg_tick = 0;\n+      cri->reg_in_table = -1;\n+      cri->reg_qty = regno;\n+\n+      splay_tree_insert (cse_reg_info_tree, \n+\t\t\t (splay_tree_key) regno, \n+\t\t\t (splay_tree_value) cri);\n+    }\n+\n+  /* Cache this lookup; we tend to be looking up information about the\n+     same register several times in a row.  */\n+  cached_regno = regno;\n+  cached_cse_reg_info = cri;\n+\n+  return cri;\n+}\n+\n+static void\n+free_cse_reg_info (v)\n+     splay_tree_value v;\n+{\n+  struct cse_reg_info *cri = (struct cse_reg_info *) v;\n+  \n+  cri->variant.next = cse_reg_info_free_list;\n+  cse_reg_info_free_list = cri;\n+}\n+\n /* Clear the hash table and initialize each register with its own quantity,\n    for a new basic block.  */\n \n@@ -818,11 +895,15 @@ new_basic_block ()\n \n   next_qty = max_reg;\n \n-  bzero ((char *) reg_tick, max_reg * sizeof (int));\n+  if (cse_reg_info_tree) \n+    {\n+      splay_tree_delete (cse_reg_info_tree);\n+      cached_cse_reg_info = 0;\n+    }\n+\n+  cse_reg_info_tree = splay_tree_new (splay_tree_compare_ints, 0, \n+\t\t\t\t      free_cse_reg_info);\n \n-  bcopy ((char *) all_minus_one, (char *) reg_in_table,\n-\t max_reg * sizeof (int));\n-  bcopy ((char *) consec_ints, (char *) reg_qty, max_reg * sizeof (int));\n   CLEAR_HARD_REG_SET (hard_regs_in_table);\n \n   /* The per-quantity values used to be initialized here, but it is\n@@ -859,7 +940,7 @@ make_new_qty (reg)\n   if (next_qty >= max_qty)\n     abort ();\n \n-  q = reg_qty[reg] = next_qty++;\n+  q = REG_QTY (reg) = next_qty++;\n   qty_first_reg[q] = reg;\n   qty_last_reg[q] = reg;\n   qty_const[q] = qty_const_insn[q] = 0;\n@@ -876,13 +957,13 @@ make_regs_eqv (new, old)\n      register int new, old;\n {\n   register int lastr, firstr;\n-  register int q = reg_qty[old];\n+  register int q = REG_QTY (old);\n \n   /* Nothing should become eqv until it has a \"non-invalid\" qty number.  */\n   if (! REGNO_QTY_VALID_P (old))\n     abort ();\n \n-  reg_qty[new] = q;\n+  REG_QTY (new) = q;\n   firstr = qty_first_reg[q];\n   lastr = qty_last_reg[q];\n \n@@ -936,7 +1017,7 @@ static void\n delete_reg_equiv (reg)\n      register int reg;\n {\n-  register int q = reg_qty[reg];\n+  register int q = REG_QTY (reg);\n   register int p, n;\n \n   /* If invalid, do nothing.  */\n@@ -955,7 +1036,7 @@ delete_reg_equiv (reg)\n   else\n     qty_first_reg[q] = n;\n \n-  reg_qty[reg] = reg;\n+  REG_QTY (reg) = reg;\n }\n \n /* Remove any invalid expressions from the hash table\n@@ -993,10 +1074,10 @@ mention_regs (x)\n \n       for (i = regno; i < endregno; i++)\n \t{\n-\t  if (reg_in_table[i] >= 0 && reg_in_table[i] != reg_tick[i])\n+\t  if (REG_IN_TABLE (i) >= 0 && REG_IN_TABLE (i) != REG_TICK (i))\n \t    remove_invalid_refs (i);\n \n-\t  reg_in_table[i] = reg_tick[i];\n+\t  REG_IN_TABLE (i) = REG_TICK (i);\n \t}\n \n       return 0;\n@@ -1010,19 +1091,19 @@ mention_regs (x)\n     {\n       int i = REGNO (SUBREG_REG (x));\n \n-      if (reg_in_table[i] >= 0 && reg_in_table[i] != reg_tick[i])\n+      if (REG_IN_TABLE (i) >= 0 && REG_IN_TABLE (i) != REG_TICK (i))\n \t{\n \t  /* If reg_tick has been incremented more than once since\n \t     reg_in_table was last set, that means that the entire\n \t     register has been set before, so discard anything memorized\n \t     for the entrire register, including all SUBREG expressions.  */\n-\t  if (reg_in_table[i] != reg_tick[i] - 1)\n+\t  if (REG_IN_TABLE (i) != REG_TICK (i) - 1)\n \t    remove_invalid_refs (i);\n \t  else\n \t    remove_invalid_subreg_refs (i, SUBREG_WORD (x), GET_MODE (x));\n \t}\n \n-      reg_in_table[i] = reg_tick[i];\n+      REG_IN_TABLE (i) = REG_TICK (i);\n       return 0;\n     }\n \n@@ -1090,7 +1171,7 @@ insert_regs (x, classp, modified)\n \t wrong mode for that equivalence, don't do anything here.  */\n \n       if (REGNO_QTY_VALID_P (regno)\n-\t  && qty_mode[reg_qty[regno]] != GET_MODE (x))\n+\t  && qty_mode[REG_QTY (regno)] != GET_MODE (x))\n \treturn 0;\n \n       if (modified || ! REGNO_QTY_VALID_P (regno))\n@@ -1107,7 +1188,7 @@ insert_regs (x, classp, modified)\n \t\t}\n \n \t  make_new_qty (regno);\n-\t  qty_mode[reg_qty[regno]] = GET_MODE (x);\n+\t  qty_mode[REG_QTY (regno)] = GET_MODE (x);\n \t  return 1;\n \t}\n \n@@ -1132,9 +1213,9 @@ insert_regs (x, classp, modified)\n \t for the full register.  Since we don't invalidate the SUBREG\n \t here first, we might have to bump up REG_TICK so that mention_regs\n \t will do the right thing.  */\n-      if (reg_in_table[regno] >= 0\n-\t  && reg_tick[regno] == reg_in_table[regno] + 1)\n-\treg_tick[regno]++;\n+      if (REG_IN_TABLE (regno) >= 0\n+\t  && REG_TICK (regno) == REG_IN_TABLE (regno) + 1)\n+\tREG_TICK (regno)++;\n       mention_regs (x);\n       return 1;\n     }\n@@ -1469,12 +1550,12 @@ insert (x, classp, hash, mode)\n   if (elt->is_const && classp && GET_CODE (classp->exp) == REG\n       && GET_CODE (x) != REG)\n     {\n-      qty_const[reg_qty[REGNO (classp->exp)]]\n-\t= gen_lowpart_if_possible (qty_mode[reg_qty[REGNO (classp->exp)]], x);\n-      qty_const_insn[reg_qty[REGNO (classp->exp)]] = this_insn;\n+      qty_const[REG_QTY (REGNO (classp->exp))]\n+\t= gen_lowpart_if_possible (qty_mode[REG_QTY (REGNO (classp->exp))], x);\n+      qty_const_insn[REG_QTY (REGNO (classp->exp))] = this_insn;\n     }\n \n-  else if (GET_CODE (x) == REG && classp && ! qty_const[reg_qty[REGNO (x)]]\n+  else if (GET_CODE (x) == REG && classp && ! qty_const[REG_QTY (REGNO (x))]\n \t   && ! elt->is_const)\n     {\n       register struct table_elt *p;\n@@ -1483,17 +1564,17 @@ insert (x, classp, hash, mode)\n \t{\n \t  if (p->is_const && GET_CODE (p->exp) != REG)\n \t    {\n-\t      qty_const[reg_qty[REGNO (x)]]\n+\t      qty_const[REG_QTY (REGNO (x))]\n \t\t= gen_lowpart_if_possible (GET_MODE (x), p->exp);\n-\t      qty_const_insn[reg_qty[REGNO (x)]] = this_insn;\n+\t      qty_const_insn[REG_QTY (REGNO (x))] = this_insn;\n \t      break;\n \t    }\n \t}\n     }\n \n-  else if (GET_CODE (x) == REG && qty_const[reg_qty[REGNO (x)]]\n-\t   && GET_MODE (x) == qty_mode[reg_qty[REGNO (x)]])\n-    qty_const_insn[reg_qty[REGNO (x)]] = this_insn;\n+  else if (GET_CODE (x) == REG && qty_const[REG_QTY (REGNO (x))]\n+\t   && GET_MODE (x) == qty_mode[REG_QTY (REGNO (x))])\n+    qty_const_insn[REG_QTY (REGNO (x))] = this_insn;\n \n   /* If this is a constant with symbolic value,\n      and it has a term with an explicit integer value,\n@@ -1628,7 +1709,7 @@ invalidate (x, full_mode)\n \t overlap these registers.  */\n \n       delete_reg_equiv (regno);\n-      reg_tick[regno]++;\n+      REG_TICK (regno)++;\n \n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n@@ -1655,7 +1736,7 @@ invalidate (x, full_mode)\n \t      in_table |= TEST_HARD_REG_BIT (hard_regs_in_table, i);\n \t      CLEAR_HARD_REG_BIT (hard_regs_in_table, i);\n \t      delete_reg_equiv (i);\n-\t      reg_tick[i]++;\n+\t      REG_TICK (i)++;\n \t    }\n \n \t  if (in_table)\n@@ -1804,8 +1885,8 @@ rehash_using_reg (x)\n      valid entries in the table, we have no work to do.  */\n \n   if (GET_CODE (x) != REG\n-      || reg_in_table[REGNO (x)] < 0\n-      || reg_in_table[REGNO (x)] != reg_tick[REGNO (x)])\n+      || REG_IN_TABLE (REGNO (x)) < 0\n+      || REG_IN_TABLE (REGNO (x)) != REG_TICK (REGNO (x)))\n     return;\n \n   /* Scan all hash chains looking for valid entries that mention X.\n@@ -1858,8 +1939,8 @@ invalidate_for_call ()\n     if (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n       {\n \tdelete_reg_equiv (regno);\n-\tif (reg_tick[regno] >= 0)\n-\t  reg_tick[regno]++;\n+\tif (REG_TICK (regno) >= 0)\n+\t  REG_TICK (regno)++;\n \n \tin_table |= (TEST_HARD_REG_BIT (hard_regs_in_table, regno) != 0);\n       }\n@@ -2031,7 +2112,7 @@ canon_hash (x, mode)\n \t    do_not_record = 1;\n \t    return 0;\n \t  }\n-\thash += ((unsigned) REG << 7) + (unsigned) reg_qty[regno];\n+\thash += ((unsigned) REG << 7) + (unsigned) REG_QTY (regno);\n \treturn hash;\n       }\n \n@@ -2223,15 +2304,15 @@ exp_equiv_p (x, y, validate, equal_values)\n \t equivalent.  We only have to validate if Y is a register.  */\n       if (CONSTANT_P (x) && GET_CODE (y) == REG\n \t  && REGNO_QTY_VALID_P (REGNO (y))\n-\t  && GET_MODE (y) == qty_mode[reg_qty[REGNO (y)]]\n-\t  && rtx_equal_p (x, qty_const[reg_qty[REGNO (y)]])\n-\t  && (! validate || reg_in_table[REGNO (y)] == reg_tick[REGNO (y)]))\n+\t  && GET_MODE (y) == qty_mode[REG_QTY (REGNO (y))]\n+\t  && rtx_equal_p (x, qty_const[REG_QTY (REGNO (y))])\n+\t  && (! validate || REG_IN_TABLE (REGNO (y)) == REG_TICK (REGNO (y))))\n \treturn 1;\n \n       if (CONSTANT_P (y) && code == REG\n \t  && REGNO_QTY_VALID_P (REGNO (x))\n-\t  && GET_MODE (x) == qty_mode[reg_qty[REGNO (x)]]\n-\t  && rtx_equal_p (y, qty_const[reg_qty[REGNO (x)]]))\n+\t  && GET_MODE (x) == qty_mode[REG_QTY (REGNO (x))]\n+\t  && rtx_equal_p (y, qty_const[REG_QTY (REGNO (x))]))\n \treturn 1;\n \n       return 0;\n@@ -2268,14 +2349,14 @@ exp_equiv_p (x, y, validate, equal_values)\n \t   equivalent.  If there are and we are not to validate, they\n \t   are equivalent.  Otherwise, ensure all regs are up-to-date.  */\n \n-\tif (reg_qty[REGNO (x)] != reg_qty[regno])\n+\tif (REG_QTY (REGNO (x)) != REG_QTY (regno))\n \t  return 0;\n \n \tif (! validate)\n \t  return 1;\n \n \tfor (i = regno; i < endregno; i++)\n-\t  if (reg_in_table[i] != reg_tick[i])\n+\t  if (REG_IN_TABLE (i) != REG_TICK (i))\n \t    return 0;\n \n \treturn 1;\n@@ -2434,20 +2515,20 @@ set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n   if (GET_CODE (base) == REG\n       && qty_const != 0\n       && REGNO_QTY_VALID_P (REGNO (base))\n-      && qty_mode[reg_qty[REGNO (base)]] == GET_MODE (base)\n-      && qty_const[reg_qty[REGNO (base)]] != 0)\n-    base = qty_const[reg_qty[REGNO (base)]];\n+      && qty_mode[REG_QTY (REGNO (base))] == GET_MODE (base)\n+      && qty_const[REG_QTY (REGNO (base))] != 0)\n+    base = qty_const[REG_QTY (REGNO (base))];\n   else if (GET_CODE (base) == PLUS\n \t   && GET_CODE (XEXP (base, 1)) == CONST_INT\n \t   && GET_CODE (XEXP (base, 0)) == REG\n \t   && qty_const != 0\n \t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 0)))\n-\t   && (qty_mode[reg_qty[REGNO (XEXP (base, 0))]]\n+\t   && (qty_mode[REG_QTY (REGNO (XEXP (base, 0)))]\n \t       == GET_MODE (XEXP (base, 0)))\n-\t   && qty_const[reg_qty[REGNO (XEXP (base, 0))]])\n+\t   && qty_const[REG_QTY (REGNO (XEXP (base, 0)))])\n     {\n       start = INTVAL (XEXP (base, 1));\n-      base = qty_const[reg_qty[REGNO (XEXP (base, 0))]];\n+      base = qty_const[REG_QTY (REGNO (XEXP (base, 0)))];\n     }\n   /* This can happen as the result of virtual register instantiation,\n      if the initial offset is too large to be a valid address.  */\n@@ -2456,16 +2537,16 @@ set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n \t   && GET_CODE (XEXP (base, 1)) == REG\n \t   && qty_const != 0\n \t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 0)))\n-\t   && (qty_mode[reg_qty[REGNO (XEXP (base, 0))]]\n+\t   && (qty_mode[REG_QTY (REGNO (XEXP (base, 0)))]\n \t       == GET_MODE (XEXP (base, 0)))\n-\t   && qty_const[reg_qty[REGNO (XEXP (base, 0))]]\n+\t   && qty_const[REG_QTY (REGNO (XEXP (base, 0)))]\n \t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 1)))\n-\t   && (qty_mode[reg_qty[REGNO (XEXP (base, 1))]]\n+\t   && (qty_mode[REG_QTY (REGNO (XEXP (base, 1)))]\n \t       == GET_MODE (XEXP (base, 1)))\n-\t   && qty_const[reg_qty[REGNO (XEXP (base, 1))]])\n+\t   && qty_const[REG_QTY (REGNO (XEXP (base, 1)))])\n     {\n-      rtx tem = qty_const[reg_qty[REGNO (XEXP (base, 1))]];\n-      base = qty_const[reg_qty[REGNO (XEXP (base, 0))]];\n+      rtx tem = qty_const[REG_QTY (REGNO (XEXP (base, 1)))];\n+      base = qty_const[REG_QTY (REGNO (XEXP (base, 0)))];\n \n       /* One of the two values must be a constant.  */\n       if (GET_CODE (base) != CONST_INT)\n@@ -2567,17 +2648,17 @@ cse_rtx_varies_p (x)\n \n   if (GET_CODE (x) == REG\n       && REGNO_QTY_VALID_P (REGNO (x))\n-      && GET_MODE (x) == qty_mode[reg_qty[REGNO (x)]]\n-      && qty_const[reg_qty[REGNO (x)]] != 0)\n+      && GET_MODE (x) == qty_mode[REG_QTY (REGNO (x))]\n+      && qty_const[REG_QTY (REGNO (x))] != 0)\n     return 0;\n \n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && GET_CODE (XEXP (x, 0)) == REG\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n       && (GET_MODE (XEXP (x, 0))\n-\t  == qty_mode[reg_qty[REGNO (XEXP (x, 0))]])\n-      && qty_const[reg_qty[REGNO (XEXP (x, 0))]])\n+\t  == qty_mode[REG_QTY (REGNO (XEXP (x, 0)))])\n+      && qty_const[REG_QTY (REGNO (XEXP (x, 0)))])\n     return 0;\n \n   /* This can happen as the result of virtual register instantiation, if\n@@ -2590,12 +2671,12 @@ cse_rtx_varies_p (x)\n       && GET_CODE (XEXP (x, 1)) == REG\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n       && (GET_MODE (XEXP (x, 0))\n-\t  == qty_mode[reg_qty[REGNO (XEXP (x, 0))]])\n-      && qty_const[reg_qty[REGNO (XEXP (x, 0))]]\n+\t  == qty_mode[REG_QTY (REGNO (XEXP (x, 0)))])\n+      && qty_const[REG_QTY (REGNO (XEXP (x, 0)))]\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 1)))\n       && (GET_MODE (XEXP (x, 1))\n-\t  == qty_mode[reg_qty[REGNO (XEXP (x, 1))]])\n-      && qty_const[reg_qty[REGNO (XEXP (x, 1))]])\n+\t  == qty_mode[REG_QTY (REGNO (XEXP (x, 1)))])\n+      && qty_const[REG_QTY (REGNO (XEXP (x, 1)))])\n     return 0;\n \n   return rtx_varies_p (x);\n@@ -2651,10 +2732,10 @@ canon_reg (x, insn)\n \t    || ! REGNO_QTY_VALID_P (REGNO (x)))\n \t  return x;\n \n-\tfirst = qty_first_reg[reg_qty[REGNO (x)]];\n+\tfirst = qty_first_reg[REG_QTY (REGNO (x))];\n \treturn (first >= FIRST_PSEUDO_REGISTER ? regno_reg_rtx[first]\n \t\t: REGNO_REG_CLASS (first) == NO_REGS ? x\n-\t\t: gen_rtx_REG (qty_mode[reg_qty[REGNO (x)]], first));\n+\t\t: gen_rtx_REG (qty_mode[REG_QTY (REGNO (x))], first));\n       }\n       \n     default:\n@@ -5227,9 +5308,9 @@ fold_rtx (x, insn)\n \n \tif (GET_CODE (addr) == REG\n \t    && REGNO_QTY_VALID_P (REGNO (addr))\n-\t    && GET_MODE (addr) == qty_mode[reg_qty[REGNO (addr)]]\n-\t    && qty_const[reg_qty[REGNO (addr)]] != 0)\n-\t  addr = qty_const[reg_qty[REGNO (addr)]];\n+\t    && GET_MODE (addr) == qty_mode[REG_QTY (REGNO (addr))]\n+\t    && qty_const[REG_QTY (REGNO (addr))] != 0)\n+\t  addr = qty_const[REG_QTY (REGNO (addr))];\n \n \t/* If address is constant, split it into a base and integer offset.  */\n \tif (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n@@ -5371,12 +5452,12 @@ fold_rtx (x, insn)\n \t    /* This is the same as calling equiv_constant; it is duplicated\n \t       here for speed.  */\n \t    if (REGNO_QTY_VALID_P (REGNO (arg))\n-\t\t&& qty_const[reg_qty[REGNO (arg)]] != 0\n-\t\t&& GET_CODE (qty_const[reg_qty[REGNO (arg)]]) != REG\n-\t\t&& GET_CODE (qty_const[reg_qty[REGNO (arg)]]) != PLUS)\n+\t\t&& qty_const[REG_QTY (REGNO (arg))] != 0\n+\t\t&& GET_CODE (qty_const[REG_QTY (REGNO (arg))]) != REG\n+\t\t&& GET_CODE (qty_const[REG_QTY (REGNO (arg))]) != PLUS)\n \t      const_arg\n \t\t= gen_lowpart_if_possible (GET_MODE (arg),\n-\t\t\t\t\t   qty_const[reg_qty[REGNO (arg)]]);\n+\t\t\t\t\t   qty_const[REG_QTY (REGNO (arg))]);\n \t    break;\n \n \t  case CONST:\n@@ -5599,8 +5680,8 @@ fold_rtx (x, insn)\n \t\t  && (folded_arg0 == folded_arg1\n \t\t      || (GET_CODE (folded_arg0) == REG\n \t\t\t  && GET_CODE (folded_arg1) == REG\n-\t\t\t  && (reg_qty[REGNO (folded_arg0)]\n-\t\t\t      == reg_qty[REGNO (folded_arg1)]))\n+\t\t\t  && (REG_QTY (REGNO (folded_arg0))\n+\t\t\t      == REG_QTY (REGNO (folded_arg1))))\n \t\t      || ((p0 = lookup (folded_arg0,\n \t\t\t\t\t(safe_hash (folded_arg0, mode_arg0)\n \t\t\t\t\t % NBUCKETS), mode_arg0))\n@@ -5617,7 +5698,7 @@ fold_rtx (x, insn)\n \t\t (we only check the reverse if not floating-point).  */\n \t      else if (GET_CODE (folded_arg0) == REG)\n \t\t{\n-\t\t  int qty = reg_qty[REGNO (folded_arg0)];\n+\t\t  int qty = REG_QTY (REGNO (folded_arg0));\n \n \t\t  if (REGNO_QTY_VALID_P (REGNO (folded_arg0))\n \t\t      && (comparison_dominates_p (qty_comparison_code[qty], code)\n@@ -5629,7 +5710,7 @@ fold_rtx (x, insn)\n \t\t\t      && rtx_equal_p (qty_comparison_const[qty],\n \t\t\t\t\t      const_arg1))\n \t\t\t  || (GET_CODE (folded_arg1) == REG\n-\t\t\t      && (reg_qty[REGNO (folded_arg1)]\n+\t\t\t      && (REG_QTY (REGNO (folded_arg1))\n \t\t\t\t  == qty_comparison_qty[qty]))))\n \t\t    return (comparison_dominates_p (qty_comparison_code[qty],\n \t\t\t\t\t\t    code)\n@@ -5924,8 +6005,8 @@ equiv_constant (x)\n {\n   if (GET_CODE (x) == REG\n       && REGNO_QTY_VALID_P (REGNO (x))\n-      && qty_const[reg_qty[REGNO (x)]])\n-    x = gen_lowpart_if_possible (GET_MODE (x), qty_const[reg_qty[REGNO (x)]]);\n+      && qty_const[REG_QTY (REGNO (x))])\n+    x = gen_lowpart_if_possible (GET_MODE (x), qty_const[REG_QTY (REGNO (x))]);\n \n   if (x == 0 || CONSTANT_P (x))\n     return x;\n@@ -6204,7 +6285,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t  op0_elt->in_struct = op0_in_struct;\n \t}\n \n-      qty_comparison_code[reg_qty[REGNO (op0)]] = code;\n+      qty_comparison_code[REG_QTY (REGNO (op0))] = code;\n       if (GET_CODE (op1) == REG)\n \t{\n \t  /* Look it up again--in case op0 and op1 are the same.  */\n@@ -6224,13 +6305,13 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t      op1_elt->in_struct = op1_in_struct;\n \t    }\n \n-\t  qty_comparison_qty[reg_qty[REGNO (op0)]] = reg_qty[REGNO (op1)];\n-\t  qty_comparison_const[reg_qty[REGNO (op0)]] = 0;\n+\t  qty_comparison_qty[REG_QTY (REGNO (op0))] = REG_QTY (REGNO (op1));\n+\t  qty_comparison_const[REG_QTY (REGNO (op0))] = 0;\n \t}\n       else\n \t{\n-\t  qty_comparison_qty[reg_qty[REGNO (op0)]] = -1;\n-\t  qty_comparison_const[reg_qty[REGNO (op0)]] = op1;\n+\t  qty_comparison_qty[REG_QTY (REGNO (op0))] = -1;\n+\t  qty_comparison_const[REG_QTY (REGNO (op0))] = op1;\n \t}\n \n       return;\n@@ -7155,8 +7236,8 @@ cse_insn (insn, libcall_insn)\n \t their lifetimes will likely abut instead of overlapping.  */\n       if (GET_CODE (dest) == REG\n \t  && REGNO_QTY_VALID_P (REGNO (dest))\n-\t  && qty_mode[reg_qty[REGNO (dest)]] == GET_MODE (dest)\n-\t  && qty_first_reg[reg_qty[REGNO (dest)]] != REGNO (dest)\n+\t  && qty_mode[REG_QTY (REGNO (dest))] == GET_MODE (dest)\n+\t  && qty_first_reg[REG_QTY (REGNO (dest))] != REGNO (dest)\n \t  && GET_CODE (src) == REG && REGNO (src) == REGNO (dest)\n \t  /* Don't do this if the original insn had a hard reg as\n \t     SET_SRC.  */\n@@ -7165,7 +7246,7 @@ cse_insn (insn, libcall_insn)\n \t/* We can't call canon_reg here because it won't do anything if\n \t   SRC is a hard register.  */\n \t{\n-\t  int first = qty_first_reg[reg_qty[REGNO (src)]];\n+\t  int first = qty_first_reg[REG_QTY (REGNO (src))];\n \t  rtx new_src\n \t    = (first >= FIRST_PSEUDO_REGISTER\n \t       ? regno_reg_rtx[first] : gen_rtx_REG (GET_MODE (src), first));\n@@ -7239,11 +7320,11 @@ cse_insn (insn, libcall_insn)\n \t     the last set for this quantity was for this register.  */\n \n \t  if (REGNO_QTY_VALID_P (REGNO (dest))\n-\t      && qty_const[reg_qty[REGNO (dest)]] == const0_rtx)\n+\t      && qty_const[REG_QTY (REGNO (dest))] == const0_rtx)\n \t    {\n \t      /* See if we previously had a REG_WAS_0 note.  */\n \t      rtx note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n-\t      rtx const_insn = qty_const_insn[reg_qty[REGNO (dest)]];\n+\t      rtx const_insn = qty_const_insn[REG_QTY (REGNO (dest))];\n \n \t      if ((tem = single_set (const_insn)) != 0\n \t\t  && rtx_equal_p (SET_DEST (tem), dest))\n@@ -7605,10 +7686,10 @@ cse_insn (insn, libcall_insn)\n \n \t      for (i = regno; i < endregno; i++)\n \t\t{\n-\t\t  if (reg_in_table[i] >= 0)\n+\t\t  if (REG_IN_TABLE (i) >= 0)\n \t\t    {\n \t\t      remove_invalid_refs (i);\n-\t\t      reg_in_table[i] = -1;\n+\t\t      REG_IN_TABLE (i) = -1;\n \t\t    }\n \t\t}\n \t    }\n@@ -7813,7 +7894,7 @@ cse_insn (insn, libcall_insn)\n       && GET_CODE (SET_SRC (sets[0].rtl)) == REG\n       && REGNO (SET_SRC (sets[0].rtl)) >= FIRST_PSEUDO_REGISTER\n       && REGNO_QTY_VALID_P (REGNO (SET_SRC (sets[0].rtl)))\n-      && (qty_first_reg[reg_qty[REGNO (SET_SRC (sets[0].rtl))]]\n+      && (qty_first_reg[REG_QTY (REGNO (SET_SRC (sets[0].rtl)))]\n \t  == REGNO (SET_DEST (sets[0].rtl)))\n       && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n     {\n@@ -7917,8 +7998,8 @@ note_mem_written (addr)\n       && GET_CODE (XEXP (addr, 0)) == REG\n       && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n     {\n-      if (reg_tick[STACK_POINTER_REGNUM] >= 0)\n-\treg_tick[STACK_POINTER_REGNUM]++;\n+      if (REG_TICK (STACK_POINTER_REGNUM) >= 0)\n+\tREG_TICK (STACK_POINTER_REGNUM)++;\n \n       /* This should be *very* rare.  */\n       if (TEST_HARD_REG_BIT (hard_regs_in_table, STACK_POINTER_REGNUM))\n@@ -8027,7 +8108,7 @@ cse_process_notes (x, object)\n       }\n \n     case REG:\n-      i = reg_qty[REGNO (x)];\n+      i = REG_QTY (REGNO (x));\n \n       /* Return a constant or a constant register.  */\n       if (REGNO_QTY_VALID_P (REGNO (x))\n@@ -8585,20 +8666,8 @@ cse_main (f, nregs, after_loop, file)\n \n   max_insn_uid = get_max_uid ();\n \n-  all_minus_one = (int *) alloca (nregs * sizeof (int));\n-  consec_ints = (int *) alloca (nregs * sizeof (int));\n-\n-  for (i = 0; i < nregs; i++)\n-    {\n-      all_minus_one[i] = -1;\n-      consec_ints[i] = i;\n-    }\n-\n   reg_next_eqv = (int *) alloca (nregs * sizeof (int));\n   reg_prev_eqv = (int *) alloca (nregs * sizeof (int));\n-  reg_qty = (int *) alloca (nregs * sizeof (int));\n-  reg_in_table = (int *) alloca (nregs * sizeof (int));\n-  reg_tick = (int *) alloca (nregs * sizeof (int));\n \n #ifdef LOAD_EXTEND_OP\n "}, {"sha": "8c04202b2b90abad749e39d9dd1db5bb34b80d9c", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -1,3 +1,7 @@\n+1999-03-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* splay-tree.h (splay_tree_compare_ints): Declare.\n+\n Mon Dec 14 09:53:31 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* demangle.h: Don't check IN_GCC anymore."}, {"sha": "509054b38931f4b708f669c9f18a245061572d6c", "filename": "include/splay-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/include%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/include%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsplay-tree.h?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -104,6 +104,8 @@ extern splay_tree_node splay_tree_lookup\n extern int splay_tree_foreach           PARAMS((splay_tree,\n \t\t\t\t\t        splay_tree_foreach_fn,\n \t\t\t\t\t        void*));\n+extern int splay_tree_compare_ints      PARAMS((splay_tree_key,\n+\t\t\t\t\t\tsplay_tree_key));\n \t\t\t\t\t       \n #ifdef __cplusplus\n }"}, {"sha": "8ce7bf495e4fc71764c5774d36cf997dccf0504d", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -1,3 +1,7 @@\n+1999-03-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* splay-tree.c (splay_tree_compare_ints): Define.\n+\n 1999-03-30  Tom Tromey  <tromey@cygnus.com>\n \n \t* cplus-dem.c (consume_count): If `count' wraps, return 0 and"}, {"sha": "24d035d2d60e6c8517afcdcbd31e604dfcb320bb", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f7237966f8584f87fd2d0f6f58935a4bc2e14d/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=30f7237966f8584f87fd2d0f6f58935a4bc2e14d", "patch": "@@ -336,3 +336,18 @@ splay_tree_foreach (sp, fn, data)\n {\n   return splay_tree_foreach_helper (sp, sp->root, fn, data);\n }\n+\n+/* Splay-tree comparison function, treating the keys as ints.  */\n+\n+int\n+splay_tree_compare_ints (k1, k2)\n+     splay_tree_key k1;\n+     splay_tree_key k2;\n+{\n+  if ((int) k1 < (int) k2)\n+    return -1;\n+  else if ((int) k1 > (int) k2)\n+    return 1;\n+  else \n+    return 0;\n+}"}]}