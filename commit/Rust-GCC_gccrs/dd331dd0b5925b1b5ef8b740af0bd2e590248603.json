{"sha": "dd331dd0b5925b1b5ef8b740af0bd2e590248603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQzMzFkZDBiNTkyNWIxYjVlZjhiNzQwYWYwYmQyZTU5MDI0ODYwMw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-10-29T20:45:56Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-10-29T20:45:56Z"}, "message": "re PR target/54236 ([SH] Improve addc and subc insn utilization)\n\n\tPR target/54236\n\t* config/sh/sh.md (*addc): Rename existing variations to ...\n\t(*addc_r_r_1, *addc_2r_1, *addc_r_1): ... these.\n\t(*addc_r_lsb, *addc_r_r_lsb, *addc_r_lsb_r, *addc_2r_lsb, *addc_r_msb,\n\t*addc_r_r_msb, *addc_2r_msb): New insn_and_split patterns.\n\t* config/sh/sh.c (addsubcosts): Handle some addc special cases.\n\n\tPR target/54236\n\t* gcc.target/sh/pr54236-2: New.\n\t* gcc.target/sh/pr54089-6: Add another rotl special case.\n\nFrom-SVN: r204180", "tree": {"sha": "c13da6c96167b6f0e064b5ded476c94ae0d9e39c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c13da6c96167b6f0e064b5ded476c94ae0d9e39c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd331dd0b5925b1b5ef8b740af0bd2e590248603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd331dd0b5925b1b5ef8b740af0bd2e590248603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd331dd0b5925b1b5ef8b740af0bd2e590248603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd331dd0b5925b1b5ef8b740af0bd2e590248603/comments", "author": null, "committer": null, "parents": [{"sha": "c6a684e36cabdac2c001b81426e075da29081cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a684e36cabdac2c001b81426e075da29081cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a684e36cabdac2c001b81426e075da29081cc3"}], "stats": {"total": 448, "additions": 444, "deletions": 4}, "files": [{"sha": "4c1cc9cac4ecbd3e24a54204869febdc7ea5c81c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd331dd0b5925b1b5ef8b740af0bd2e590248603", "patch": "@@ -1,3 +1,12 @@\n+2013-10-29  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54236\n+\t* config/sh/sh.md (*addc): Rename existing variations to ...\n+\t(*addc_r_r_1, *addc_2r_1, *addc_r_1): ... these.\n+\t(*addc_r_lsb, *addc_r_r_lsb, *addc_r_lsb_r, *addc_2r_lsb, *addc_r_msb,\n+\t*addc_r_r_msb, *addc_2r_msb): New insn_and_split patterns.\n+\t* config/sh/sh.c (addsubcosts): Handle some addc special cases.\n+\n 2013-10-29  Teresa Johnson  <tejohnson@google.com>\n \n \tPR ipa/58862"}, {"sha": "167b615e37b1f57ddf9a312e678c7cd02bd64505", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=dd331dd0b5925b1b5ef8b740af0bd2e590248603", "patch": "@@ -3159,6 +3159,35 @@ and_xor_ior_costs (rtx x, int code)\n static inline int\n addsubcosts (rtx x)\n {\n+  if (GET_MODE (x) == SImode)\n+    {\n+      /* The addc or subc patterns will eventually become one or two\n+\t instructions.  Below are some costs for some of the patterns\n+\t which combine would reject because the costs of the individual\n+\t insns in the patterns are lower.\n+\n+\t FIXME: It would be much easier if we had something like insn cost\n+\t attributes and the cost calculation machinery used those attributes\n+\t in the first place.  This would eliminate redundant recog-like C\n+\t code to calculate costs of complex patterns.  */\n+      rtx op0 = XEXP (x, 0);\n+      rtx op1 = XEXP (x, 1);\n+\n+      if (GET_CODE (x) == PLUS)\n+\t{\n+\t  if (GET_CODE (op0) == AND\n+\t      && XEXP (op0, 1) == const1_rtx\n+\t      && (GET_CODE (op1) == PLUS\n+\t\t  || (GET_CODE (op1) == MULT && XEXP (op1, 1) == const2_rtx)))\n+\t    return 1;\n+\n+\t  if (GET_CODE (op0) == MULT && XEXP (op0, 1) == const2_rtx\n+\t      && GET_CODE (op1) == LSHIFTRT\n+\t      && CONST_INT_P (XEXP (op1, 1)) && INTVAL (XEXP (op1, 1)) == 31)\n+\t    return 1;\n+\t}\n+    }\n+\n   /* On SH1-4 we have only max. SImode operations.\n      Double the cost for modes > SImode.  */\n   const int cost_scale = !TARGET_SHMEDIA"}, {"sha": "0b952991039d8ff0606c22f4defca061794a9c85", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 123, "deletions": 3, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=dd331dd0b5925b1b5ef8b740af0bd2e590248603", "patch": "@@ -1841,7 +1841,7 @@\n \n ;; Split 'reg + reg + 1' into a sett addc sequence, as it can be scheduled\n ;; better, if the sett insn can be done early.\n-(define_insn_and_split \"*addc\"\n+(define_insn_and_split \"*addc_r_r_1\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n \t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n \t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"\"))\n@@ -1857,7 +1857,7 @@\n \n ;; Left shifts by one are usually done with an add insn to avoid T_REG\n ;; clobbers.  Thus addc can also be used to do something like '(x << 1) + 1'.\n-(define_insn_and_split \"*addc\"\n+(define_insn_and_split \"*addc_2r_1\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n \t(plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\")\n \t\t\t  (const_int 2))\n@@ -1897,7 +1897,7 @@\n ;; can be scheduled much better since the load of the constant can be\n ;; done earlier, before any comparison insns that store the result in\n ;; the T bit.\n-(define_insn_and_split \"*addc\"\n+(define_insn_and_split \"*addc_r_1\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n \t(plus:SI (match_operand:SI 1 \"t_reg_operand\" \"\")\n \t\t (match_operand:SI 2 \"arith_reg_operand\" \"\")))\n@@ -1910,6 +1910,126 @@\n \t\t\t    (match_dup 1)))\n \t      (clobber (reg:SI T_REG))])])\n \n+;; Use shlr-addc to do 'reg + (reg & 1)'.\n+(define_insn_and_split \"*addc_r_lsb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t (const_int 1))\n+\t\t (match_operand:SI 2 \"arith_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0) (plus:SI (reg:SI T_REG) (match_dup 2)))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  emit_insn (gen_shlr (gen_reg_rtx (SImode), operands[1]));\n+})\n+\n+;; Use shlr-addc to do 'reg + reg + (reg & 1)'.\n+(define_insn_and_split \"*addc_r_r_lsb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t\t  (const_int 1))\n+\t\t\t  (match_operand:SI 2 \"arith_reg_operand\"))\n+\t\t (match_operand:SI 3 \"arith_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 3))\n+\t\t\t\t          (reg:SI T_REG)))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  emit_insn (gen_shlr (gen_reg_rtx (SImode), operands[1]));\n+})\n+\n+;; Canonicalize 'reg + (reg & 1) + reg' into 'reg + reg + (reg & 1)'.\n+(define_insn_and_split \"*addc_r_lsb_r\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t (const_int 1))\n+\t\t (plus:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t  (match_operand:SI 3 \"arith_reg_operand\"))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:SI (plus:SI (and:SI (match_dup 1) (const_int 1))\n+\t\t\t\t     (match_dup 2))\n+\t\t\t    (match_dup 3)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+;; Canonicalize '2 * reg + (reg & 1)' into 'reg + reg + (reg & 1)'.\n+(define_insn_and_split \"*addc_2r_lsb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t (const_int 1))\n+\t\t (mult:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t  (const_int 2))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:SI (plus:SI (and:SI (match_dup 1) (const_int 1))\n+\t\t\t\t     (match_dup 2))\n+\t\t\t    (match_dup 2)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+;; Use shll-addc to do 'reg + ((unsigned int)reg >> 31)'.\n+(define_insn_and_split \"*addc_r_msb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t      (const_int 31))\n+\t\t (match_operand:SI 2 \"arith_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0) (plus:SI (reg:SI T_REG) (match_dup 2)))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  emit_insn (gen_shll (gen_reg_rtx (SImode), operands[1]));\n+})\n+\n+;; Use shll-addc to do 'reg + reg + ((unsigned int)reg >> 31)'.\n+(define_insn_and_split \"*addc_r_r_msb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (plus:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t\t       (const_int 31))\n+\t\t \t  (match_operand:SI 2 \"arith_reg_operand\"))\n+\t\t (match_operand:SI 3 \"arith_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 3))\n+\t\t\t\t          (reg:SI T_REG)))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  emit_insn (gen_shll (gen_reg_rtx (SImode), operands[1]));\n+})\n+\n+;; Canonicalize '2 * reg + ((unsigned int)reg >> 31)'\n+;; into 'reg + reg + (reg & 1)'.\n+(define_insn_and_split \"*addc_2r_msb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t  (const_int 2))\n+\t\t (lshiftrt:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t      (const_int 31))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:SI (plus:SI (lshiftrt:SI (match_dup 2) (const_int 31))\n+\t\t\t\t     (match_dup 1))\n+\t\t\t    (match_dup 1)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"\")"}, {"sha": "0f5f02b8c0457e99ebbc48e96e334929040526d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd331dd0b5925b1b5ef8b740af0bd2e590248603", "patch": "@@ -1,3 +1,9 @@\n+2013-10-29  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54236\n+\t* gcc.target/sh/pr54236-2: New.\n+\t* gcc.target/sh/pr54089-6: Add another rotl special case.\n+\n 2013-10-29  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran 58793"}, {"sha": "629a764418642d79b23329ddf667cb88dfcaad41", "filename": "gcc/testsuite/gcc.target/sh/pr54089-6.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-6.c?ref=dd331dd0b5925b1b5ef8b740af0bd2e590248603", "patch": "@@ -3,7 +3,7 @@\n /* { dg-options \"-O1\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n /* { dg-final { scan-assembler-times \"rotr\" 2 } } */\n-/* { dg-final { scan-assembler-times \"rotl\" 2 } } */\n+/* { dg-final { scan-assembler-times \"rotl\" 3 } } */\n \n int\n test_00 (int a)\n@@ -28,3 +28,9 @@ test_03 (int a)\n {\n   return ((a >> 1) & 0x7FFFFFFF) | (a << 31);\n }\n+\n+int\n+test_04 (int a)\n+{\n+  return a + a + ((a >> 31) & 1);\n+}"}, {"sha": "afcd33817c696ac3498969fdc5959e0e0cc30194", "filename": "gcc/testsuite/gcc.target/sh/pr54236-2.c", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd331dd0b5925b1b5ef8b740af0bd2e590248603/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-2.c?ref=dd331dd0b5925b1b5ef8b740af0bd2e590248603", "patch": "@@ -0,0 +1,270 @@\n+/* Tests to check the utilization of the addc instruction in special cases.\n+   If everything works as expected we won't see any movt instructions in\n+   these cases.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } } */\n+/* { dg-final { scan-assembler-times \"addc\" 37 } } */\n+/* { dg-final { scan-assembler-times \"shlr\" 23 } } */\n+/* { dg-final { scan-assembler-times \"shll\" 14 } } */\n+/* { dg-final { scan-assembler-times \"add\\t\" 12 } } */\n+/* { dg-final { scan-assembler-not \"movt\" } } */\n+\n+int\n+test_000 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + (b & 1);\n+}\n+\n+int\n+test_001 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + b + (c & 1);\n+}\n+\n+int\n+test_002 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return a + b + c + (d & 1);\n+}\n+\n+int\n+test_003 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return (b & 1) + a;\n+}\n+\n+int\n+test_004 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + (c & 1) + b;\n+}\n+\n+int\n+test_005 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return a + b + (d & 1) + c;\n+}\n+\n+int\n+test_006 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return (c & 1) + a + b;\n+}\n+\n+int\n+test_007 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return a + (d & 1) + b + c;\n+}\n+\n+int\n+test_008 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return (d & 1) + a + b + c;\n+}\n+\n+int\n+test_009 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + b + (b & 1);\n+}\n+\n+int\n+test_010 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + (b & 1) + b;\n+}\n+\n+int\n+test_011 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return (b & 1) + a + b;\n+}\n+\n+int\n+test_012 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return a + b + d + (b & 1);\n+}\n+\n+int\n+test_013 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return a + d + (b & 1) + b;\n+}\n+\n+int\n+test_014 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return a + (b & 1) + d + b;\n+}\n+\n+int\n+test_015 (int a, int c, int b, int d)\n+{\n+  // 1x shlr, 1x add, 1x addc\n+  return (b & 1) + a + d + b;\n+}\n+\n+int\n+test_016 (int a, int b, int c, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + (a & 1);\n+}\n+\n+int\n+test_017 (int a, int b, int c, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + a + (a & 1);\n+}\n+\n+int\n+test_018 (int a, int b, int c, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return a + (a & 1) + a;\n+}\n+\n+int\n+test_019 (int a, int b, int c, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return (a & 1) + a + a;\n+}\n+\n+int\n+test_020 (int a, int b, int c, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return b + b + (a & 1);\n+}\n+\n+int\n+test_021 (int a, int b, int c, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return b + (a & 1) + b;\n+}\n+\n+int\n+test_022 (int a, int b, int c, int d)\n+{\n+  // 1x shlr, 1x addc\n+  return (a & 1) + b + b;\n+}\n+\n+int\n+test_023 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return a + ((b >> 31) & 1);\n+}\n+\n+int\n+test_024 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return ((b >> 31) & 1) + a;\n+}\n+\n+int\n+test_025 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return ((a >> 31) & 1) + a;\n+}\n+\n+int\n+test_026 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return a + ((a >> 31) & 1);\n+}\n+\n+int\n+test_027 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return a + b + ((c >> 31) & 1);\n+}\n+\n+int\n+test_028 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return a + ((c >> 31) & 1) + b;\n+}\n+\n+int\n+test_029 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return ((c >> 31) & 1) + a + b;\n+}\n+\n+int\n+test_030 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc, 1x add\n+  return a + b + c + ((d >> 31) & 1);\n+}\n+\n+int\n+test_031 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc, 1x add\n+  return a + b + ((d >> 31) & 1) + c;\n+}\n+\n+int\n+test_032 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc, 1x add\n+  return a + ((d >> 31) & 1) + b + c;\n+}\n+\n+int\n+test_033 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc, 1x add\n+  return ((d >> 31) & 1) + a + b + c;\n+}\n+\n+int\n+test_034 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return a + a + ((d >> 31) & 1);\n+}\n+\n+int\n+test_035 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return a + ((d >> 31) & 1) + a;\n+}\n+\n+int\n+test_036 (int a, int b, int c, int d)\n+{\n+  // 1x shll, 1x addc\n+  return ((d >> 31) & 1) + a + a;\n+}"}]}