{"sha": "4e03e2e08b94f65f2be3db17f880c205ec262f87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUwM2UyZTA4Yjk0ZjY1ZjJiZTNkYjE3Zjg4MGMyMDVlYzI2MmY4Nw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-09T13:21:09Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-09T13:21:09Z"}, "message": "c++: Fix resolving the address of overloaded pmf [PR96647]\n\nIn resolve_address_of_overloaded_function, currently only the second\npass over the overload set (which considers just the function templates\nin the overload set) checks constraints and performs return type\ndeduction when necessary.  But as the testcases below show, we need to\ndo the same when considering non-template functions during the first\npass.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96647\n\t* class.c (resolve_address_of_overloaded_function): Check\n\tconstraints_satisfied_p and perform return-type deduction via\n\tmaybe_instantiate_decl when considering non-template functions\n\tin the overload set.\n\t* cp-tree.h (maybe_instantiate_decl): Declare.\n\t* decl2.c (maybe_instantiate_decl): Remove static.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96647\n\t* g++.dg/cpp0x/auto-96647.C: New test.\n\t* g++.dg/cpp0x/error9.C: New test.\n\t* g++.dg/cpp2a/concepts-fn6.C: New test.", "tree": {"sha": "5374563ac2681eda05b43e4349fcc27042e963c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5374563ac2681eda05b43e4349fcc27042e963c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e03e2e08b94f65f2be3db17f880c205ec262f87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e03e2e08b94f65f2be3db17f880c205ec262f87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e03e2e08b94f65f2be3db17f880c205ec262f87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e03e2e08b94f65f2be3db17f880c205ec262f87/comments", "author": null, "committer": null, "parents": [{"sha": "58905f90434ba9a64abac56324131d67c53910ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58905f90434ba9a64abac56324131d67c53910ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58905f90434ba9a64abac56324131d67c53910ae"}], "stats": {"total": 43, "additions": 41, "deletions": 2}, "files": [{"sha": "c9a1f753d565419cd9bc6d4b2b28c7870de11fc7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4e03e2e08b94f65f2be3db17f880c205ec262f87", "patch": "@@ -8286,6 +8286,19 @@ resolve_address_of_overloaded_function (tree target_type,\n \t     one, or vice versa.  */\n \t  continue;\n \n+\t/* Constraints must be satisfied. This is done before\n+\t   return type deduction since that instantiates the\n+\t   function. */\n+\tif (!constraints_satisfied_p (fn))\n+\t  continue;\n+\n+\tif (undeduced_auto_decl (fn))\n+\t  {\n+\t    /* Force instantiation to do return type deduction.  */\n+\t    maybe_instantiate_decl (fn);\n+\t    require_deduced_type (fn);\n+\t  }\n+\n \t/* In C++17 we need the noexcept-qualifier to compare types.  */\n \tif (flag_noexcept_type\n \t    && !maybe_instantiate_noexcept (fn, complain))"}, {"sha": "7873941175522e4713f47f1cd92b7cc1b0ae0b2d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4e03e2e08b94f65f2be3db17f880c205ec262f87", "patch": "@@ -6905,6 +6905,7 @@ extern void do_type_instantiation\t\t(tree, tree, tsubst_flags_t);\n extern bool always_instantiate_p\t\t(tree);\n extern bool maybe_instantiate_noexcept\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern tree instantiate_decl\t\t\t(tree, bool, bool);\n+extern void maybe_instantiate_decl\t\t(tree);\n extern int comp_template_parms\t\t\t(const_tree, const_tree);\n extern bool template_heads_equivalent_p\t\t(const_tree, const_tree);\n extern bool builtin_pack_fn_p\t\t\t(tree);"}, {"sha": "50a042e807016e16d127d9392507c24a789853a2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4e03e2e08b94f65f2be3db17f880c205ec262f87", "patch": "@@ -81,7 +81,6 @@ static void import_export_class (tree);\n static tree get_guard_bits (tree);\n static void determine_visibility_from_class (tree, tree);\n static bool determine_hidden_inline (tree);\n-static void maybe_instantiate_decl (tree);\n \n /* A list of static class variables.  This is needed, because a\n    static class variable can be declared inside the class without\n@@ -5386,7 +5385,7 @@ possibly_inlined_p (tree decl)\n    them instantiated for reduction clauses which inline them by hand\n    directly.  */\n \n-static void\n+void\n maybe_instantiate_decl (tree decl)\n {\n   if (DECL_LANG_SPECIFIC (decl)"}, {"sha": "314b2a16ac2803110eb74ca6a989323ed36b0a9f", "filename": "gcc/testsuite/g++.dg/cpp0x/auto-96647.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto-96647.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto-96647.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto-96647.C?ref=4e03e2e08b94f65f2be3db17f880c205ec262f87", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/96647\n+// { dg-do compile { target c++11 } }\n+\n+template<typename>\n+struct Base {\n+  auto f(int) { }\n+  auto f(char) { }\n+};\n+\n+void (Base<void>::*ptr)(int) = &Base<void>::f;"}, {"sha": "b712c7d849a273b430510f61e34fb9c08268a97d", "filename": "gcc/testsuite/g++.dg/cpp0x/error9.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror9.C?ref=4e03e2e08b94f65f2be3db17f880c205ec262f87", "patch": "@@ -0,0 +1,6 @@\n+// { dg-do compile { target c++11 } }\n+\n+void f(int) { }\n+auto f(bool) { return f(true); } // { dg-error \"auto\" }\n+\n+void (*ptr)(int) = &f;"}, {"sha": "3d7941658d45599b41bbe25d16d7c725630e88f2", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-fn6.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03e2e08b94f65f2be3db17f880c205ec262f87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn6.C?ref=4e03e2e08b94f65f2be3db17f880c205ec262f87", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/96647\n+// { dg-do compile { target c++20 } }\n+\n+template<typename T>\n+struct Base {\n+  auto f(int) { }\n+  auto f(int) requires T::fail { static_assert(T::fail); }\n+};\n+\n+void (Base<void>::*ptr)(int) = &Base<void>::f;"}]}