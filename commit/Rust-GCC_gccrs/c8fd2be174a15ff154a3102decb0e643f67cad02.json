{"sha": "c8fd2be174a15ff154a3102decb0e643f67cad02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhmZDJiZTE3NGExNWZmMTU0YTMxMDJkZWNiMGU2NDNmNjdjYWQwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-10T18:55:37Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-10T18:55:37Z"}, "message": "Fix modref handling of parameter adjustments and jump functions.\n\n\t* ipa-modref-tree.h (struct modref_tree): Revert prevoius change.\n\t* ipa-modref.c (analyze_function): Dump original summary.\n\t(modref_read): Only set IPA if streaming summary (not optimization\n\tsummary).\n\t(remap_arguments): New function.\n\t(modref_transform): New function.\n\t(compute_parm_map): Fix offset calculation.\n\t(ipa_merge_modref_summary_after_inlining): Do not merge stores when\n\tthey can be ignored.", "tree": {"sha": "f455dceccfda9e4562a5486bd794ffef7cb3f9d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f455dceccfda9e4562a5486bd794ffef7cb3f9d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8fd2be174a15ff154a3102decb0e643f67cad02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8fd2be174a15ff154a3102decb0e643f67cad02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8fd2be174a15ff154a3102decb0e643f67cad02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8fd2be174a15ff154a3102decb0e643f67cad02/comments", "author": null, "committer": null, "parents": [{"sha": "f1f1008c7cd6912b6dc915524972f0217f1e0430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f1008c7cd6912b6dc915524972f0217f1e0430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f1008c7cd6912b6dc915524972f0217f1e0430"}], "stats": {"total": 102, "additions": 92, "deletions": 10}, "files": [{"sha": "b37280d18c7caac8d7496b7ca6cd93ee9b0e8fb0", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fd2be174a15ff154a3102decb0e643f67cad02/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fd2be174a15ff154a3102decb0e643f67cad02/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=c8fd2be174a15ff154a3102decb0e643f67cad02", "patch": "@@ -496,8 +496,7 @@ struct GTY((user)) modref_tree\n   /* Copy OTHER to THIS.  */\n   void copy_from (modref_tree <T> *other)\n   {\n-    auto_vec <modref_parm_map, 32> parm_map;\n-    merge (other, &parm_map);\n+    merge (other, NULL);\n   }\n \n   /* Search BASE in tree; return NULL if failed.  */"}, {"sha": "9392d73a9419cb9128ecf1dbf4e0a5a52af5bcc3", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 91, "deletions": 8, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fd2be174a15ff154a3102decb0e643f67cad02/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fd2be174a15ff154a3102decb0e643f67cad02/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=c8fd2be174a15ff154a3102decb0e643f67cad02", "patch": "@@ -757,7 +757,14 @@ analyze_function (function *f, bool ipa)\n   if (!summaries)\n     summaries = modref_summaries::create_ggc (symtab);\n   else /* Remove existing summary if we are re-running the pass.  */\n-    summaries->remove (cgraph_node::get (f->decl));\n+    {\n+      if (dump_file && summaries->get (cgraph_node::get (f->decl)))\n+\t{\n+\t  fprintf (dump_file, \"Past summary:\\n\");\n+\t  summaries->get (cgraph_node::get (f->decl))->dump (dump_file);\n+\t}\n+      summaries->remove (cgraph_node::get (f->decl));\n+    }\n \n   ((modref_summaries *)summaries)->ipa = ipa;\n \n@@ -1290,7 +1297,7 @@ modref_read (void)\n \n   if (!summaries)\n     summaries = modref_summaries::create_ggc (symtab);\n-  ((modref_summaries *)summaries)->ipa = true;\n+  ((modref_summaries *)summaries)->ipa = !flag_ltrans;\n \n   while ((file_data = file_data_vec[j++]))\n     {\n@@ -1309,6 +1316,76 @@ modref_read (void)\n     }\n }\n \n+/* Update parameter indexes in TT according to MAP.  */\n+\n+void\n+remap_arguments (vec <int> *map, modref_records *tt)\n+{\n+  size_t i;\n+  modref_base_node <alias_set_type> *base_node;\n+  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, base_node)\n+    {\n+      size_t j;\n+      modref_ref_node <alias_set_type> *ref_node;\n+      FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t{\n+\t  size_t k;\n+\t  modref_access_node *access_node;\n+\t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t    if (access_node->parm_index > 0)\n+\t      access_node->parm_index = (*map)[access_node->parm_index];\n+\t}\n+    }\n+}\n+\n+/* If signature changed, update the summary.  */\n+\n+static unsigned int\n+modref_transform (struct cgraph_node *node)\n+{\n+  if (!node->clone.param_adjustments)\n+    return 0;\n+  modref_summary *r = summaries->get (node);\n+  if (!r)\n+    return 0;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Updating summary for %s from:\\n\",\n+\t       node->dump_name ());\n+      r->dump (dump_file);\n+    }\n+\n+  size_t i, max = 0;\n+  ipa_adjusted_param *p;\n+\n+  FOR_EACH_VEC_SAFE_ELT (node->clone.param_adjustments->m_adj_params, i, p)\n+    {\n+      int idx = node->clone.param_adjustments->get_original_index (i);\n+      if (idx > (int)max)\n+\tmax = idx;\n+    }\n+\n+  auto_vec <int, 32> map;\n+\n+  map.safe_grow (max + 1);\n+  for (i = 0; i <= max; i++)\n+    map.quick_push (-1);\n+  FOR_EACH_VEC_SAFE_ELT (node->clone.param_adjustments->m_adj_params, i, p)\n+    {\n+      int idx = node->clone.param_adjustments->get_original_index (i);\n+      if (idx >= 0)\n+\tmap[i] = idx;\n+    }\n+  remap_arguments (&map, r->loads);\n+  remap_arguments (&map, r->stores);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"to:\\n\");\n+      r->dump (dump_file);\n+    }\n+  return 0;\n+}\n+\n /* Definition of the modref IPA pass.  */\n const pass_data pass_data_ipa_modref =\n {\n@@ -1335,7 +1412,7 @@ class pass_ipa_modref : public ipa_opt_pass_d\n \t\t      modref_read,     /* read_optimization_summary */\n \t\t      NULL,            /* stmt_fixup */\n \t\t      0,               /* function_transform_todo_flags_start */\n-\t\t      NULL,            /* function_transform */\n+\t\t      modref_transform,/* function_transform */\n \t\t      NULL)            /* variable_transform */\n   {}\n \n@@ -1448,7 +1525,10 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t    {\n \t      (*parm_map)[i].parm_index = ipa_get_jf_ancestor_formal_id (jf);\n \t      (*parm_map)[i].parm_offset_known = true;\n-\t      (*parm_map)[i].parm_offset = ipa_get_jf_ancestor_offset (jf);\n+\t      gcc_checking_assert\n+\t\t(!(ipa_get_jf_ancestor_offset (jf) & (BITS_PER_UNIT - 1)));\n+\t      (*parm_map)[i].parm_offset\n+\t\t = ipa_get_jf_ancestor_offset (jf) >> LOG2_BITS_PER_UNIT;\n  \t    }\n \t  else\n \t    (*parm_map)[i].parm_index = -1;\n@@ -1503,10 +1583,13 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \n       compute_parm_map (edge, &parm_map);\n \n-      if (to_info->loads)\n-\tto_info->loads->merge (callee_info->loads, &parm_map);\n-      if (to_info->stores)\n-\tto_info->stores->merge (callee_info->stores, &parm_map);\n+      if (!ignore_stores_p (edge->callee->decl, flags))\n+\t{\n+\t  if (to_info->loads)\n+\t    to_info->loads->merge (callee_info->loads, &parm_map);\n+\t  if (to_info->stores)\n+\t    to_info->stores->merge (callee_info->stores, &parm_map);\n+\t}\n       if (to_info->loads_lto)\n \tto_info->loads_lto->merge (callee_info->loads_lto, &parm_map);\n       if (to_info->stores_lto)"}]}