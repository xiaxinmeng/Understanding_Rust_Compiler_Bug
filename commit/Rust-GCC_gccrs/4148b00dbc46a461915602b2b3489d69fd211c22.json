{"sha": "4148b00dbc46a461915602b2b3489d69fd211c22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE0OGIwMGRiYzQ2YTQ2MTkxNTYwMmIyYjM0ODlkNjlmZDIxMWMyMg==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2018-08-16T22:38:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-08-16T22:38:04Z"}, "message": "builtins.c (c_strlen): Add new parameter eltsize.\n\n\t* builtins.c (c_strlen): Add new parameter eltsize.  Use it\n\tfor determining how to count the elements.\n\t* builtins.h (c_strlen): Adjust prototype.\n\t* expr.c (string_constant): Add new parameter mem_size.\n\tSet *mem_size appropriately.\n\t* expr.h (string_constant): Adjust protoype.\n\t* gimple-fold.c (get_range_strlen): Add new parameter eltsize.\n\t* gimple-fold.h (get_range_strlen): Adjust prototype.\n\t* gimple-ssa-sprintf.c (get_string_length): Add new parameter eltsize.\n\t(format_string): Call get_string_length with eltsize.\n\nFrom-SVN: r263607", "tree": {"sha": "6824c0132908bd3df28f7e8852acad2c0f4eaafd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6824c0132908bd3df28f7e8852acad2c0f4eaafd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4148b00dbc46a461915602b2b3489d69fd211c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4148b00dbc46a461915602b2b3489d69fd211c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4148b00dbc46a461915602b2b3489d69fd211c22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4148b00dbc46a461915602b2b3489d69fd211c22/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c6a2bf2720fd6412a2d63a3a82da5af0c18f824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c6a2bf2720fd6412a2d63a3a82da5af0c18f824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c6a2bf2720fd6412a2d63a3a82da5af0c18f824"}], "stats": {"total": 140, "additions": 87, "deletions": 53}, "files": [{"sha": "897ec9cc91f5f0c47adce002626ed679572b68fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -1,3 +1,16 @@\n+2018-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* builtins.c (c_strlen): Add new parameter eltsize.  Use it\n+\tfor determining how to count the elements.\n+\t* builtins.h (c_strlen): Adjust prototype.\n+\t* expr.c (string_constant): Add new parameter mem_size.\n+\tSet *mem_size appropriately.\n+\t* expr.h (string_constant): Adjust protoype.\n+\t* gimple-fold.c (get_range_strlen): Add new parameter eltsize.\n+\t* gimple-fold.h (get_range_strlen): Adjust prototype.\n+\t* gimple-ssa-sprintf.c (get_string_length): Add new parameter eltsize.\n+\t(format_string): Call get_string_length with eltsize.\n+\n 2018-08-16  David Malcolm  <dmalcolm@redhat.com>\n \n \t* diagnostic.c (default_diagnostic_start_span_fn): Call pp_string"}, {"sha": "b1a79f3f33f021e1f1f7f832c9ed2beca79c7e08", "filename": "gcc/builtins.c", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -568,41 +568,43 @@ string_length (const void *ptr, unsigned eltsize, unsigned maxelts)\n    accesses.  Note that this implies the result is not going to be emitted\n    into the instruction stream.\n \n-   The value returned is of type `ssizetype'.\n+   ELTSIZE is 1 for normal single byte character strings, and 2 or\n+   4 for wide characer strings.  ELTSIZE is by default 1.\n \n-   Unfortunately, string_constant can't access the values of const char\n-   arrays with initializers, so neither can we do so here.  */\n+   The value returned is of type `ssizetype'.  */\n \n tree\n-c_strlen (tree src, int only_value)\n+c_strlen (tree src, int only_value, unsigned eltsize)\n {\n+  gcc_assert (eltsize == 1 || eltsize == 2 || eltsize == 4);\n   STRIP_NOPS (src);\n   if (TREE_CODE (src) == COND_EXPR\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n     {\n       tree len1, len2;\n \n-      len1 = c_strlen (TREE_OPERAND (src, 1), only_value);\n-      len2 = c_strlen (TREE_OPERAND (src, 2), only_value);\n+      len1 = c_strlen (TREE_OPERAND (src, 1), only_value, eltsize);\n+      len2 = c_strlen (TREE_OPERAND (src, 2), only_value, eltsize);\n       if (tree_int_cst_equal (len1, len2))\n \treturn len1;\n     }\n \n   if (TREE_CODE (src) == COMPOUND_EXPR\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n-    return c_strlen (TREE_OPERAND (src, 1), only_value);\n+    return c_strlen (TREE_OPERAND (src, 1), only_value, eltsize);\n \n   location_t loc = EXPR_LOC_OR_LOC (src, input_location);\n \n   /* Offset from the beginning of the string in bytes.  */\n   tree byteoff;\n-  src = string_constant (src, &byteoff);\n+  tree memsize;\n+  src = string_constant (src, &byteoff, &memsize);\n   if (src == 0)\n     return NULL_TREE;\n \n   /* Determine the size of the string element.  */\n-  unsigned eltsize\n-    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (src))));\n+  if (eltsize != tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (src)))))\n+    return NULL_TREE;\n \n   /* Set MAXELTS to sizeof (SRC) / sizeof (*SRC) - 1, the maximum possible\n      length of SRC.  Prefer TYPE_SIZE() to TREE_STRING_LENGTH() if possible\n@@ -613,34 +615,34 @@ c_strlen (tree src, int only_value)\n   HOST_WIDE_INT strelts = TREE_STRING_LENGTH (src);\n   strelts = strelts / eltsize - 1;\n \n-  HOST_WIDE_INT maxelts = strelts;\n-  tree type = TREE_TYPE (src);\n-  if (tree size = TYPE_SIZE_UNIT (type))\n-    if (tree_fits_shwi_p (size))\n-      {\n-\tmaxelts = tree_to_uhwi (size);\n-\tmaxelts = maxelts / eltsize - 1;\n-      }\n+  if (!tree_fits_uhwi_p (memsize))\n+    return NULL_TREE;\n+\n+  HOST_WIDE_INT maxelts = tree_to_uhwi (memsize) / eltsize - 1;\n \n   /* PTR can point to the byte representation of any string type, including\n      char* and wchar_t*.  */\n   const char *ptr = TREE_STRING_POINTER (src);\n \n   if (byteoff && TREE_CODE (byteoff) != INTEGER_CST)\n     {\n+      /* For empty strings the result should be zero.  */\n+      if (maxelts == 0)\n+\treturn ssize_int (0);\n+\n+      /* The code below works only for single byte character types.  */\n+      if (eltsize != 1)\n+\treturn NULL_TREE;\n+\n       /* If the string has an internal NUL character followed by any\n \t non-NUL characters (e.g., \"foo\\0bar\"), we can't compute\n \t the offset to the following NUL if we don't know where to\n \t start searching for it.  */\n       unsigned len = string_length (ptr, eltsize, strelts);\n-      if (len < strelts)\n-\t{\n-\t  /* Return when an embedded null character is found.  */\n-\t  return NULL_TREE;\n-\t}\n \n-      if (!maxelts)\n-\treturn ssize_int (0);\n+      /* Return when an embedded null character is found or none at all.  */\n+      if (len < strelts || len > maxelts)\n+\treturn NULL_TREE;\n \n       /* We don't know the starting offset, but we do know that the string\n \t has no internal zero bytes.  If the offset falls within the bounds\n@@ -650,8 +652,8 @@ c_strlen (tree src, int only_value)\n       tree offsave = TREE_SIDE_EFFECTS (byteoff) ? save_expr (byteoff) : byteoff;\n       offsave = fold_convert (ssizetype, offsave);\n       tree condexp = fold_build2_loc (loc, LE_EXPR, boolean_type_node, offsave,\n-\t\t\t\t      build_int_cst (ssizetype, len * eltsize));\n-      tree lenexp = size_diffop_loc (loc, ssize_int (strelts * eltsize), offsave);\n+\t\t\t\t      build_int_cst (ssizetype, len));\n+      tree lenexp = size_diffop_loc (loc, ssize_int (strelts), offsave);\n       return fold_build3_loc (loc, COND_EXPR, ssizetype, condexp, lenexp,\n \t\t\t      build_zero_cst (ssizetype));\n     }\n@@ -684,14 +686,19 @@ c_strlen (tree src, int only_value)\n       return NULL_TREE;\n     }\n \n+  /* If eltoff is larger than strelts but less than maxelts the\n+     string length is zero, since the excess memory will be zero.  */\n+  if (eltoff > strelts)\n+    return ssize_int (0);\n+\n   /* Use strlen to search for the first zero byte.  Since any strings\n      constructed with build_string will have nulls appended, we win even\n      if we get handed something like (char[4])\"abcd\".\n \n      Since ELTOFF is our starting index into the string, no further\n      calculation is needed.  */\n   unsigned len = string_length (ptr + eltoff * eltsize, eltsize,\n-\t\t\t\tmaxelts - eltoff);\n+\t\t\t\tstrelts - eltoff);\n \n   return ssize_int (len);\n }"}, {"sha": "805f1801604ac25bcb93a158e96a06d7188eb3a0", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -58,7 +58,7 @@ extern bool get_pointer_alignment_1 (tree, unsigned int *,\n \t\t\t\t     unsigned HOST_WIDE_INT *);\n extern unsigned int get_pointer_alignment (tree);\n extern unsigned string_length (const void*, unsigned, unsigned);\n-extern tree c_strlen (tree, int);\n+extern tree c_strlen (tree, int, unsigned = 1);\n extern void expand_builtin_setjmp_setup (rtx, rtx);\n extern void expand_builtin_setjmp_receiver (rtx);\n extern void expand_builtin_update_setjmp_buf (rtx);"}, {"sha": "c071be67783951550eeabdf97c843a219091c408", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -11292,10 +11292,12 @@ is_aligning_offset (const_tree offset, const_tree exp)\n /* Return the tree node if an ARG corresponds to a string constant or zero\n    if it doesn't.  If we return nonzero, set *PTR_OFFSET to the (possibly\n    non-constant) offset in bytes within the string that ARG is accessing.\n-   The type of the offset is sizetype.  */\n+   The type of the offset is sizetype.  If MEM_SIZE is non-zero the storage\n+   size of the memory is returned.  If MEM_SIZE is zero, the string is\n+   only returned when it is properly zero terminated.  */\n \n tree\n-string_constant (tree arg, tree *ptr_offset)\n+string_constant (tree arg, tree *ptr_offset, tree *mem_size)\n {\n   tree array;\n   STRIP_NOPS (arg);\n@@ -11349,7 +11351,7 @@ string_constant (tree arg, tree *ptr_offset)\n \treturn NULL_TREE;\n \n       tree offset;\n-      if (tree str = string_constant (arg0, &offset))\n+      if (tree str = string_constant (arg0, &offset, mem_size))\n \t{\n \t  /* Avoid pointers to arrays (see bug 86622).  */\n \t  if (POINTER_TYPE_P (TREE_TYPE (arg))\n@@ -11389,6 +11391,8 @@ string_constant (tree arg, tree *ptr_offset)\n   if (TREE_CODE (array) == STRING_CST)\n     {\n       *ptr_offset = fold_convert (sizetype, offset);\n+      if (mem_size)\n+\t*mem_size = TYPE_SIZE_UNIT (TREE_TYPE (array));\n       return array;\n     }\n \n@@ -11448,7 +11452,9 @@ string_constant (tree arg, tree *ptr_offset)\n   unsigned HOST_WIDE_INT length = TREE_STRING_LENGTH (init);\n   length = string_length (TREE_STRING_POINTER (init), charsize,\n \t\t\t  length / charsize);\n-  if (compare_tree_int (array_size, length + 1) < 0)\n+  if (mem_size)\n+    *mem_size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n+  else if (compare_tree_int (array_size, length + 1) < 0)\n     return NULL_TREE;\n \n   *ptr_offset = offset;"}, {"sha": "d4d25645f618119334601fdb0484059b78ec47c7", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -288,7 +288,7 @@ expand_normal (tree exp)\n \n /* Return the tree node and offset if a given argument corresponds to\n    a string constant.  */\n-extern tree string_constant (tree, tree *);\n+extern tree string_constant (tree, tree *, tree * = NULL);\n \n /* Two different ways of generating switch statements.  */\n extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx, profile_probability);"}, {"sha": "07341ebe66fc9ea20c4b6a249c74bf8e1d983005", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -1275,11 +1275,13 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n    Set *FLEXP to true if the range of the string lengths has been\n    obtained from the upper bound of an array at the end of a struct.\n    Such an array may hold a string that's longer than its upper bound\n-   due to it being used as a poor-man's flexible array member.  */\n+   due to it being used as a poor-man's flexible array member.\n+   ELTSIZE is 1 for normal single byte character strings, and 2 or\n+   4 for wide characer strings.  ELTSIZE is by default 1.  */\n \n static bool\n get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n-\t\t  int fuzzy, bool *flexp)\n+\t\t  int fuzzy, bool *flexp, unsigned eltsize = 1)\n {\n   tree var, val = NULL_TREE;\n   gimple *def_stmt;\n@@ -1300,8 +1302,8 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t      tree aop0 = TREE_OPERAND (op, 0);\n \t      if (TREE_CODE (aop0) == INDIRECT_REF\n \t\t  && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n-\t\treturn get_range_strlen (TREE_OPERAND (aop0, 0),\n-\t\t\t\t\t length, visited, type, fuzzy, flexp);\n+\t\treturn get_range_strlen (TREE_OPERAND (aop0, 0), length,\n+\t\t\t\t\t visited, type, fuzzy, flexp, eltsize);\n \t    }\n \t  else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF && fuzzy)\n \t    {\n@@ -1329,13 +1331,13 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t    return false;\n \t}\n       else\n-\tval = c_strlen (arg, 1);\n+\tval = c_strlen (arg, 1, eltsize);\n \n       if (!val && fuzzy)\n \t{\n \t  if (TREE_CODE (arg) == ADDR_EXPR)\n \t    return get_range_strlen (TREE_OPERAND (arg, 0), length,\n-\t\t\t\t     visited, type, fuzzy, flexp);\n+\t\t\t\t     visited, type, fuzzy, flexp, eltsize);\n \n \t  if (TREE_CODE (arg) == ARRAY_REF)\n \t    {\n@@ -1477,7 +1479,8 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n             || gimple_assign_unary_nop_p (def_stmt))\n           {\n             tree rhs = gimple_assign_rhs1 (def_stmt);\n-\t    return get_range_strlen (rhs, length, visited, type, fuzzy, flexp);\n+\t    return get_range_strlen (rhs, length, visited, type, fuzzy, flexp,\n+\t\t\t\t     eltsize);\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n \t  {\n@@ -1486,7 +1489,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \n \t    for (unsigned int i = 0; i < 2; i++)\n \t      if (!get_range_strlen (ops[i], length, visited, type, fuzzy,\n-\t\t\t\t     flexp))\n+\t\t\t\t     flexp, eltsize))\n \t\t{\n \t\t  if (fuzzy == 2)\n \t\t    *maxlen = build_all_ones_cst (size_type_node);\n@@ -1513,7 +1516,8 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n             if (arg == gimple_phi_result (def_stmt))\n               continue;\n \n-\t    if (!get_range_strlen (arg, length, visited, type, fuzzy, flexp))\n+\t    if (!get_range_strlen (arg, length, visited, type, fuzzy, flexp,\n+\t\t\t\t   eltsize))\n \t      {\n \t\tif (fuzzy == 2)\n \t\t  *maxlen = build_all_ones_cst (size_type_node);\n@@ -1545,10 +1549,13 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n    and false if PHIs and COND_EXPRs are to be handled optimistically,\n    if we can determine string length minimum and maximum; it will use\n    the minimum from the ones where it can be determined.\n-   STRICT false should be only used for warning code.  */\n+   STRICT false should be only used for warning code.\n+\n+   ELTSIZE is 1 for normal single byte character strings, and 2 or\n+   4 for wide characer strings.  ELTSIZE is by default 1.  */\n \n bool\n-get_range_strlen (tree arg, tree minmaxlen[2], bool strict)\n+get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize, bool strict)\n {\n   bitmap visited = NULL;\n \n@@ -1557,7 +1564,7 @@ get_range_strlen (tree arg, tree minmaxlen[2], bool strict)\n \n   bool flexarray = false;\n   if (!get_range_strlen (arg, minmaxlen, &visited, 1, strict ? 1 : 2,\n-\t\t\t &flexarray))\n+\t\t\t &flexarray, eltsize))\n     {\n       minmaxlen[0] = NULL_TREE;\n       minmaxlen[1] = NULL_TREE;\n@@ -3500,7 +3507,7 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n   wide_int maxlen;\n \n   tree lenrange[2];\n-  if (!get_range_strlen (gimple_call_arg (stmt, 0), lenrange, true)\n+  if (!get_range_strlen (gimple_call_arg (stmt, 0), lenrange, 1, true)\n       && lenrange[0] && TREE_CODE (lenrange[0]) == INTEGER_CST\n       && lenrange[1] && TREE_CODE (lenrange[1]) == INTEGER_CST)\n     {"}, {"sha": "e3fad83bbfb687188c8289c95aaf9e1456857456", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n extern tree create_tmp_reg_or_ssa_name (tree, gimple *stmt = NULL);\n extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n-extern bool get_range_strlen (tree, tree[2], bool = false);\n+extern bool get_range_strlen (tree, tree[2], unsigned = 1, bool = false);\n extern tree get_maxval_strlen (tree, int);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);"}, {"sha": "2431b52e652e6aaf9412034eb545ed4fd0d6714c", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4148b00dbc46a461915602b2b3489d69fd211c22/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=4148b00dbc46a461915602b2b3489d69fd211c22", "patch": "@@ -2125,12 +2125,12 @@ format_floating (const directive &dir, tree arg, vr_values *)\n    Used by the format_string function below.  */\n \n static fmtresult\n-get_string_length (tree str)\n+get_string_length (tree str, unsigned eltsize)\n {\n   if (!str)\n     return fmtresult ();\n \n-  if (tree slen = c_strlen (str, 1))\n+  if (tree slen = c_strlen (str, 1, eltsize))\n     {\n       /* Simply return the length of the string.  */\n       fmtresult res (tree_to_shwi (slen));\n@@ -2143,7 +2143,7 @@ get_string_length (tree str)\n      aren't known to point any such arrays result in LENRANGE[1] set\n      to SIZE_MAX.  */\n   tree lenrange[2];\n-  bool flexarray = get_range_strlen (str, lenrange);\n+  bool flexarray = get_range_strlen (str, lenrange, eltsize);\n \n   if (lenrange [0] || lenrange [1])\n     {\n@@ -2195,7 +2195,7 @@ get_string_length (tree str)\n       return res;\n     }\n \n-  return get_string_length (NULL_TREE);\n+  return fmtresult ();\n }\n \n /* Return the minimum and maximum number of characters formatted\n@@ -2274,7 +2274,8 @@ format_string (const directive &dir, tree arg, vr_values *)\n   fmtresult res;\n \n   /* Compute the range the argument's length can be in.  */\n-  fmtresult slen = get_string_length (arg);\n+  int count_by = dir.specifier == 'S' || dir.modifier == FMT_LEN_l ? 4 : 1;\n+  fmtresult slen = get_string_length (arg, count_by);\n   if (slen.range.min == slen.range.max\n       && slen.range.min < HOST_WIDE_INT_MAX)\n     {"}]}