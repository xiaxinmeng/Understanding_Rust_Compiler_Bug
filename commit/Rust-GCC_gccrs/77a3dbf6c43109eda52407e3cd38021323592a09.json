{"sha": "77a3dbf6c43109eda52407e3cd38021323592a09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdhM2RiZjZjNDMxMDllZGE1MjQwN2UzY2QzODAyMTMyMzU5MmEwOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-06-23T16:41:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-06-23T16:41:53Z"}, "message": "i386: Extract the guts of mulv16qi3 to ix86_expand_vecop_qihi\n\n        * config/i386/sse.md (mul<VI1_AVX2>3): Change from insn_and_split to\n        pure expander; move expansion code ...\n        * config/i386/i386.c (ix86_expand_vecop_qihi): ... here.  New function.\n        * config/i386/i386-protos.h: Update.\n\nFrom-SVN: r188907", "tree": {"sha": "36f5fc94526ac4776e059fb03233b225322be11a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36f5fc94526ac4776e059fb03233b225322be11a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77a3dbf6c43109eda52407e3cd38021323592a09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a3dbf6c43109eda52407e3cd38021323592a09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77a3dbf6c43109eda52407e3cd38021323592a09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a3dbf6c43109eda52407e3cd38021323592a09/comments", "author": null, "committer": null, "parents": [{"sha": "6b39c806f3428add14da75efb87c2ef8fd0b5294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b39c806f3428add14da75efb87c2ef8fd0b5294", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b39c806f3428add14da75efb87c2ef8fd0b5294"}], "stats": {"total": 157, "additions": 97, "deletions": 60}, "files": [{"sha": "d867efdeef7d2998e49503b39d41eebfabfb44ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77a3dbf6c43109eda52407e3cd38021323592a09", "patch": "@@ -1,3 +1,10 @@\n+2012-06-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/sse.md (mul<VI1_AVX2>3): Change from insn_and_split to\n+\tpure expander; move expansion code ...\n+\t* config/i386/i386.c (ix86_expand_vecop_qihi): ... here.  New function.\n+\t* config/i386/i386-protos.h: Update.\n+\n 2012-06-22  Edmar Wienskoski  <edmar@freescale.com>\n \n \t* config/rs6000/rs6000.md (define_attr \"type\"): New type popcnt."}, {"sha": "4e7469de6bf3276e7eb339d5b2fcb7c559ef9e73", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=77a3dbf6c43109eda52407e3cd38021323592a09", "patch": "@@ -192,6 +192,8 @@ extern void ix86_expand_rounddf_32 (rtx, rtx);\n extern void ix86_expand_trunc (rtx, rtx);\n extern void ix86_expand_truncdf_32 (rtx, rtx);\n \n+extern void ix86_expand_vecop_qihi (enum rtx_code, rtx, rtx, rtx);\n+\n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n #endif\t/* TREE_CODE  */"}, {"sha": "e23c418f731a36caea92672b8b04423c54edd3c8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=77a3dbf6c43109eda52407e3cd38021323592a09", "patch": "@@ -38438,6 +38438,91 @@ ix86_expand_vec_extract_even_odd (rtx targ, rtx op0, rtx op1, unsigned odd)\n   expand_vec_perm_even_odd_1 (&d, odd);\n }\n \n+/* Expand a vector operation CODE for a V*QImode in terms of the\n+   same operation on V*HImode.  */\n+\n+void\n+ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n+{\n+  enum machine_mode qimode = GET_MODE (dest);\n+  enum machine_mode himode;\n+  rtx (*gen_il) (rtx, rtx, rtx);\n+  rtx (*gen_ih) (rtx, rtx, rtx);\n+  rtx op1_l, op1_h, op2_l, op2_h, res_l, res_h;\n+  struct expand_vec_perm_d d;\n+  bool ok;\n+  int i;\n+\n+  if (qimode == V16QImode)\n+    {\n+      himode = V8HImode;\n+      gen_il = gen_vec_interleave_lowv16qi;\n+      gen_ih = gen_vec_interleave_highv16qi;\n+    }\n+  else if (qimode == V32QImode)\n+    {\n+      himode = V16HImode;\n+      gen_il = gen_avx2_interleave_lowv32qi;\n+      gen_ih = gen_avx2_interleave_highv32qi;\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* Unpack data such that we've got a source byte in each low byte of\n+     each word.  We don't care what goes into the high byte of each word.\n+     Rather than trying to get zero in there, most convenient is to let\n+     it be a copy of the low byte.  */\n+  op1_l = gen_reg_rtx (qimode);\n+  op1_h = gen_reg_rtx (qimode);\n+  emit_insn (gen_il (op1_l, op1, op1));\n+  emit_insn (gen_ih (op1_h, op1, op1));\n+\n+  op2_l = gen_reg_rtx (qimode);\n+  op2_h = gen_reg_rtx (qimode);\n+  emit_insn (gen_il (op2_l, op2, op2));\n+  emit_insn (gen_ih (op2_h, op2, op2));\n+\n+  /* Perform the operation.  */\n+  res_l = expand_simple_binop (himode, code, gen_lowpart (himode, op1_l),\n+\t\t\t       gen_lowpart (himode, op2_l), NULL_RTX,\n+\t\t\t       1, OPTAB_DIRECT);\n+  res_h = expand_simple_binop (himode, code, gen_lowpart (himode, op1_h),\n+\t\t\t       gen_lowpart (himode, op2_h), NULL_RTX,\n+\t\t\t       1, OPTAB_DIRECT);\n+  gcc_assert (res_l && res_h);\n+\n+  /* Merge the data back into the right place.  */\n+  d.target = dest;\n+  d.op0 = gen_lowpart (qimode, res_l);\n+  d.op1 = gen_lowpart (qimode, res_h);\n+  d.vmode = qimode;\n+  d.nelt = GET_MODE_NUNITS (qimode);\n+  d.one_operand_p = false;\n+  d.testing_p = false;\n+\n+  if (qimode == V16QImode)\n+    {\n+      /* For SSE2, we used an full interleave, so the desired\n+\t results are in the even elements.  */\n+      for (i = 0; i < 16; ++i)\n+\td.perm[i] = i * 2;\n+    }\n+  else\n+    {\n+      /* For AVX, the interleave used above was not cross-lane.  So the\n+\t extraction is evens but with the second and third quarter swapped.\n+\t Happily, that is even one insn shorter than even extraction.  */\n+      for (i = 0; i < 32; ++i)\n+\td.perm[i] = i * 2 + ((i & 24) == 8 ? 16 : (i & 24) == 16 ? -16 : 0);\n+    }\n+\n+  ok = ix86_expand_vec_perm_const_1 (&d);\n+  gcc_assert (ok);\n+\n+  set_unique_reg_note (get_last_insn (), REG_EQUAL,\n+\t\t       gen_rtx_fmt_ee (code, qimode, op1, op2));\n+}\n+\n void\n ix86_expand_sse2_mulv4si3 (rtx op0, rtx op1, rtx op2)\n {"}, {"sha": "2f361a65d848ca48d1b305363240a4b7aca4d1bf", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a3dbf6c43109eda52407e3cd38021323592a09/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=77a3dbf6c43109eda52407e3cd38021323592a09", "patch": "@@ -5213,70 +5213,13 @@\n    (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn_and_split \"mul<mode>3\"\n+(define_expand \"mul<mode>3\"\n   [(set (match_operand:VI1_AVX2 0 \"register_operand\")\n \t(mult:VI1_AVX2 (match_operand:VI1_AVX2 1 \"register_operand\")\n \t\t       (match_operand:VI1_AVX2 2 \"register_operand\")))]\n-  \"TARGET_SSE2\n-   && can_create_pseudo_p ()\"\n-  \"#\"\n-  \"&& 1\"\n-  [(const_int 0)]\n+  \"TARGET_SSE2\"\n {\n-  rtx t[6];\n-  int i;\n-  enum machine_mode mulmode = <sseunpackmode>mode;\n-\n-  for (i = 0; i < 6; ++i)\n-    t[i] = gen_reg_rtx (<MODE>mode);\n-\n-  /* Unpack data such that we've got a source byte in each low byte of\n-     each word.  We don't care what goes into the high byte of each word.\n-     Rather than trying to get zero in there, most convenient is to let\n-     it be a copy of the low byte.  */\n-  emit_insn (gen_<vec_avx2>_interleave_high<mode> (t[0], operands[1],\n-\t\t\t\t\t\t   operands[1]));\n-  emit_insn (gen_<vec_avx2>_interleave_high<mode> (t[1], operands[2],\n-\t\t\t\t\t\t   operands[2]));\n-  emit_insn (gen_<vec_avx2>_interleave_low<mode> (t[2], operands[1],\n-\t\t\t\t\t\t  operands[1]));\n-  emit_insn (gen_<vec_avx2>_interleave_low<mode> (t[3], operands[2],\n-\t\t\t\t\t\t  operands[2]));\n-\n-  /* Multiply words.  The end-of-line annotations here give a picture of what\n-     the output of that instruction looks like.  Dot means don't care; the\n-     letters are the bytes of the result with A being the most significant.  */\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_lowpart (mulmode, t[4]),\n-\t\t\t  gen_rtx_MULT (mulmode,\t/* .A.B.C.D.E.F.G.H */\n-\t\t\t\t\tgen_lowpart (mulmode, t[0]),\n-\t\t\t\t\tgen_lowpart (mulmode, t[1]))));\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_lowpart (mulmode, t[5]),\n-\t\t\t  gen_rtx_MULT (mulmode,\t/* .I.J.K.L.M.N.O.P */\n-\t\t\t\t\tgen_lowpart (mulmode, t[2]),\n-\t\t\t\t\tgen_lowpart (mulmode, t[3]))));\n-\n-  /* Extract the even bytes and merge them back together.  */\n-  if (<MODE>mode == V16QImode)\n-    ix86_expand_vec_extract_even_odd (operands[0], t[5], t[4], 0);\n-  else\n-    {\n-      /* Since avx2_interleave_{low,high}v32qi used above aren't cross-lane,\n-\t this can't be normal even extraction, but one where additionally\n-\t the second and third quarter are swapped.  That is even one insn\n-\t shorter than even extraction.  */\n-      rtvec v = rtvec_alloc (32);\n-      for (i = 0; i < 32; ++i)\n-\tRTVEC_ELT (v, i)\n-\t  = GEN_INT (i * 2 + ((i & 24) == 8 ? 16 : (i & 24) == 16 ? -16 : 0));\n-      t[0] = operands[0];\n-      t[1] = t[5];\n-      t[2] = t[4];\n-      t[3] = gen_rtx_CONST_VECTOR (<MODE>mode, v);\n-      ix86_expand_vec_perm_const (t);\n-    }\n-\n-  set_unique_reg_note (get_last_insn (), REG_EQUAL,\n-\t\t       gen_rtx_MULT (<MODE>mode, operands[1], operands[2]));\n+  ix86_expand_vecop_qihi (MULT, operands[0], operands[1], operands[2]);\n   DONE;\n })\n "}]}