{"sha": "10d6cbb8126d2cc8cf32f732ec1178e373781a7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBkNmNiYjgxMjZkMmNjOGNmMzJmNzMyZWMxMTc4ZTM3Mzc4MWE3Zg==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-05-18T22:33:26Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-05-18T22:33:26Z"}, "message": "* gcc.c-torture/compile/20010518-1.c: New test.\n\nFrom-SVN: r42289", "tree": {"sha": "1b364b6be07b03604ff01e1ecefd0b6c5c5a1f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b364b6be07b03604ff01e1ecefd0b6c5c5a1f57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10d6cbb8126d2cc8cf32f732ec1178e373781a7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d6cbb8126d2cc8cf32f732ec1178e373781a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d6cbb8126d2cc8cf32f732ec1178e373781a7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d6cbb8126d2cc8cf32f732ec1178e373781a7f/comments", "author": null, "committer": null, "parents": [{"sha": "46fad5b72188e6627c63ce1979375deacfd7bdf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46fad5b72188e6627c63ce1979375deacfd7bdf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46fad5b72188e6627c63ce1979375deacfd7bdf6"}], "stats": {"total": 209, "additions": 209, "deletions": 0}, "files": [{"sha": "fabd9e6108d4070bb77d2c003cce96d5d99fe3d6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d6cbb8126d2cc8cf32f732ec1178e373781a7f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d6cbb8126d2cc8cf32f732ec1178e373781a7f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10d6cbb8126d2cc8cf32f732ec1178e373781a7f", "patch": "@@ -1,3 +1,7 @@\n+2001-05-18  Stan Shebs  <shebs@apple.com>\n+\n+\t* gcc.c-torture/compile/20010518-1.c: New test.\n+\n 2001-05-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.old-deja/g++.pt/inherit2.C: Remove XFAIL."}, {"sha": "4ab40d8e226eff24c5da6456a6e37c7a1c3fa537", "filename": "gcc/testsuite/gcc.c-torture/compile/20010518-1.c", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d6cbb8126d2cc8cf32f732ec1178e373781a7f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010518-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d6cbb8126d2cc8cf32f732ec1178e373781a7f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010518-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010518-1.c?ref=10d6cbb8126d2cc8cf32f732ec1178e373781a7f", "patch": "@@ -0,0 +1,205 @@\n+/* This was cut down from reload1.c in May 2001, was observed to cause\n+   a bootstrap failure for powerpc-apple-darwin1.3.\n+\n+   Copyright (C) 2001  Free Software Foundation.  */\n+\n+enum insn_code\n+{\n+  CODE_FOR_extendqidi2 = 3,\n+  CODE_FOR_nothing = 870\n+};\n+\n+struct rtx_def;\n+\n+enum machine_mode\n+{\n+  VOIDmode,\n+  MAX_MACHINE_MODE\n+};\n+\n+typedef unsigned long long HARD_REG_ELT_TYPE;\n+typedef HARD_REG_ELT_TYPE HARD_REG_SET[((77 + (8 * 8) - 1) / (8 * 8))];\n+\n+enum rtx_code\n+{\n+  UNKNOWN,\n+  NIL,\n+  REG,\n+  LAST_AND_UNUSED_RTX_CODE\n+};\n+\n+typedef struct\n+{\n+  unsigned min_align:8;\n+  unsigned base_after_vec:1;\n+  unsigned min_after_vec:1;\n+  unsigned max_after_vec:1;\n+  unsigned min_after_base:1;\n+  unsigned max_after_base:1;\n+  unsigned offset_unsigned:1;\n+  unsigned:2;\n+  unsigned scale:8;\n+}\n+addr_diff_vec_flags;\n+typedef union rtunion_def\n+{\n+  long long rtwint;\n+  int rtint;\n+  unsigned int rtuint;\n+  const char *rtstr;\n+  struct rtx_def *rtx;\n+  struct rtvec_def *rtvec;\n+  enum machine_mode rttype;\n+  addr_diff_vec_flags rt_addr_diff_vec_flags;\n+  struct cselib_val_struct *rt_cselib;\n+  struct bitmap_head_def *rtbit;\n+  union tree_node *rttree;\n+  struct basic_block_def *bb;\n+}\n+rtunion;\n+typedef struct rtx_def\n+{\n+  enum rtx_code code:16;\n+  enum machine_mode mode:8;\n+  unsigned int jump:1;\n+  unsigned int call:1;\n+  unsigned int unchanging:1;\n+  unsigned int volatil:1;\n+  unsigned int in_struct:1;\n+  unsigned int used:1;\n+  unsigned integrated:1;\n+  unsigned frame_related:1;\n+  rtunion fld[1];\n+}\n+ *rtx;\n+\n+enum reload_type\n+{\n+  RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN,\n+  RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_INPADDR_ADDRESS,\n+  RELOAD_FOR_OUTPUT_ADDRESS, RELOAD_FOR_OUTADDR_ADDRESS,\n+  RELOAD_FOR_OPERAND_ADDRESS, RELOAD_FOR_OPADDR_ADDR,\n+  RELOAD_OTHER, RELOAD_FOR_OTHER_ADDRESS\n+};\n+\n+struct reload\n+{\n+  rtx in;\n+  rtx out;\n+  //  enum reg_class class;\n+  enum machine_mode inmode;\n+  enum machine_mode outmode;\n+  enum machine_mode mode;\n+  unsigned int nregs;\n+  int inc;\n+  rtx in_reg;\n+  rtx out_reg;\n+  int regno;\n+  rtx reg_rtx;\n+  int opnum;\n+  int secondary_in_reload;\n+  int secondary_out_reload;\n+  enum insn_code secondary_in_icode;\n+  enum insn_code secondary_out_icode;\n+  enum reload_type when_needed;\n+  unsigned int optional:1;\n+  unsigned int nocombine:1;\n+  unsigned int secondary_p:1;\n+  unsigned int nongroup:1;\n+};\n+\n+struct insn_chain\n+{\n+  rtx insn;\n+};\n+\n+extern int n_reloads;\n+static short reload_order[(2 * 10 * (2 + 1))];\n+int reload_spill_index[(2 * 10 * (2 + 1))];\n+extern struct reload rld[(2 * 10 * (2 + 1))];\n+static rtx *reg_last_reload_reg;\n+static HARD_REG_SET reg_reloaded_valid;\n+static HARD_REG_SET reg_reloaded_dead;\n+static HARD_REG_SET reg_reloaded_died;\n+static HARD_REG_SET reg_is_output_reload;\n+extern const unsigned int mode_size[];\n+extern int target_flags;\n+\n+static void\n+emit_reload_insns (chain)\n+     struct insn_chain *chain;\n+{\n+  rtx insn = chain->insn;\n+  register int j;\n+  rtx following_insn = (((insn)->fld[2]).rtx);\n+  rtx before_insn = (((insn)->fld[1]).rtx);\n+\n+  for (j = 0; j < n_reloads; j++)\n+    {\n+      register int r = reload_order[j];\n+      register int i = reload_spill_index[r];\n+\n+\t{\n+\t  rtx out = (((enum rtx_code) (rld[r].out)->code) == REG ? rld[r].out : rld[r].out_reg);\n+\t  register int nregno = (((out)->fld[0]).rtuint);\n+\n+\t  if (nregno >= 77)\n+\t    {\n+\t      rtx src_reg, store_insn = (rtx) 0;\n+\n+\t      reg_last_reload_reg[nregno] = 0;\n+\t      if (src_reg && ((enum rtx_code) (src_reg)->code) == REG && (((src_reg)->fld[0]).rtuint) < 77)\n+\t\t{\n+\t\t  int src_regno = (((src_reg)->fld[0]).rtuint);\n+\t\t  int nr =\n+\t\t    (((src_regno) >= 32\n+\t\t      && (src_regno) <=\n+\t\t      63) ? (((mode_size[(int) (rld[r].mode)]) + 8 -\n+\t\t\t      1) / 8) : (((mode_size[(int) (rld[r].mode)]) +\n+\t\t\t\t\t  (!(target_flags & 0x00000020) ? 4 :\n+\t\t\t\t\t   8) - 1) / (!(target_flags & 0x00000020) ? 4 : 8)));\n+\t\t  rtx note = 0;\n+\n+\t\t  while (nr-- > 0)\n+\t\t    {\n+\t\t      ((reg_reloaded_dead)\n+\t\t       [(src_regno + nr) / ((unsigned) (8 * 8))] &=\n+\t\t       ~(((HARD_REG_ELT_TYPE) (1)) << ((src_regno + nr) % ((unsigned) (8 * 8)))));\n+\t\t      ((reg_reloaded_valid)\n+\t\t       [(src_regno + nr) / ((unsigned) (8 * 8))] |=\n+\t\t       ((HARD_REG_ELT_TYPE) (1)) << ((src_regno + nr) % ((unsigned) (8 * 8))));\n+\t\t      ((reg_is_output_reload)\n+\t\t       [(src_regno + nr) / ((unsigned) (8 * 8))] |=\n+\t\t       ((HARD_REG_ELT_TYPE) (1)) << ((src_regno + nr) % ((unsigned) (8 * 8))));\n+\t\t      if (note)\n+\t\t\t((reg_reloaded_died)\n+\t\t\t [(src_regno) / ((unsigned) (8 * 8))] |=\n+\t\t\t ((HARD_REG_ELT_TYPE) (1)) << ((src_regno) % ((unsigned) (8 * 8))));\n+\t\t      else\n+\t\t\t((reg_reloaded_died)\n+\t\t\t [(src_regno) / ((unsigned) (8 * 8))] &=\n+\t\t\t ~(((HARD_REG_ELT_TYPE) (1)) << ((src_regno) % ((unsigned) (8 * 8)))));\n+\t\t    }\n+\t\t  reg_last_reload_reg[nregno] = src_reg;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      int num_regs =\n+\t\t(((nregno) >= 32\n+\t\t  && (nregno) <=\n+\t\t  63)\n+\t\t ? (((mode_size\n+\t\t      [(int) (((enum machine_mode) (rld[r].out)->mode))]) +\n+\t\t     8 -\n+\t\t     1) /\n+\t\t    8)\n+\t\t : (((mode_size\n+\t\t      [(int) (((enum machine_mode) (rld[r].out)->mode))]) +\n+\t\t     (!(target_flags & 0x00000020) ? 4 : 8) - 1) / (!(target_flags & 0x00000020) ? 4 : 8)));\n+\t      while (num_regs-- > 0)\n+\t\treg_last_reload_reg[nregno + num_regs] = 0;\n+\t    }\n+\t}\n+    }\n+}"}]}