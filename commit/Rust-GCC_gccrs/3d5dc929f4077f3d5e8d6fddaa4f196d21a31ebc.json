{"sha": "3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q1ZGM5MjlmNDA3N2YzZDVlOGQ2ZmRkYWE0ZjE5NmQyMWEzMWViYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-07-17T17:23:45Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-07-17T17:23:45Z"}, "message": "re PR fortran/52846 ([F2008] Support submodules)\n\n2015-07-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/52846\n\t* decl.c (gfc_match_end): Pick out declared submodule name from\n\tthe composite identifier.\n\t* gfortran.h : Add 'submodule_name' to gfc_use_list structure.\n\t* module.c (gfc_match_submodule): Define submodule_name and add\n\tstatic 'submodule_name'.\n\t(gfc_match_submodule): Build up submodule filenames, using '@'\n\tas a delimiter. Store the output filename in 'submodule_name'.\n\tSimilarly, the submodule identifier is built using '.' as an\n\tidentifier.\n\t(gfc_dump_module): If current state is COMP_SUBMODULE, write\n\tto file 'submodule_name', using SUBMODULE_EXTENSION.\n\t(gfc_use_module): Similarly, use the 'submodule_name' field in\n\tthe gfc_use_list structure and SUBMODULE_EXTENSION to read the\n\timplicitly used submodule files.\n\n2015-07-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/52846\n\t* lib/fortran-modules.exp (proc cleanup-submodules): New\n\tprocedure.\n\t* gfortran.dg/submodule_1.f08: Change extension and clean up\n\tthe submodule files.\n\t* gfortran.dg/submodule_2.f08: ditto\n\t* gfortran.dg/submodule_6.f08: ditto\n\t* gfortran.dg/submodule_7.f08: ditto\n\t* gfortran.dg/submodule_8.f08: New test\n\t* gfortran.dg/submodule_9.f08: New test\n\nFrom-SVN: r225945", "tree": {"sha": "8c5237225381a2a0cd6f8e9c085f9249fa064ca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c5237225381a2a0cd6f8e9c085f9249fa064ca6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/comments", "author": null, "committer": null, "parents": [{"sha": "896c28a7fad4b23f722bd538c972160d0c9bc88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896c28a7fad4b23f722bd538c972160d0c9bc88d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896c28a7fad4b23f722bd538c972160d0c9bc88d"}], "stats": {"total": 110, "additions": 105, "deletions": 5}, "files": [{"sha": "4c61b1ae0b55313c66823b6f3b549d39bbec4357", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "patch": "@@ -1,3 +1,21 @@\n+2015-07-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/52846\n+\t* decl.c (gfc_match_end): Pick out declared submodule name from\n+\tthe composite identifier.\n+\t* gfortran.h : Add 'submodule_name' to gfc_use_list structure.\n+\t* module.c (gfc_match_submodule): Define submodule_name and add\n+\tstatic 'submodule_name'.\n+\t(gfc_match_submodule): Build up submodule filenames, using '@'\n+\tas a delimiter. Store the output filename in 'submodule_name'.\n+\tSimilarly, the submodule identifier is built using '.' as an\n+\tidentifier.\n+\t(gfc_dump_module): If current state is COMP_SUBMODULE, write\n+\tto file 'submodule_name', using SUBMODULE_EXTENSION.\n+\t(gfc_use_module): Similarly, use the 'submodule_name' field in\n+\tthe gfc_use_list structure and SUBMODULE_EXTENSION to read the\n+\timplicitly used submodule files.\n+\n 2015-07-17  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n \n \t* trans-intrinsic.c (conv_co_collective): Remove redundant address"}, {"sha": "ebc88eaa5dd86fbdf5ca06c93e456092759fb01c", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "patch": "@@ -6450,6 +6450,11 @@ gfc_match_end (gfc_statement *st)\n   if (block_name == NULL)\n     goto syntax;\n \n+  /* We have to pick out the declared submodule name from the composite\n+     required by F2008:11.2.3 para 2, which ends in the declared name.  */\n+  if (state == COMP_SUBMODULE)\n+    block_name = strchr (block_name, '.') + 1;\n+\n   if (strcmp (name, block_name) != 0 && strcmp (block_name, \"ppr@\") != 0)\n     {\n       gfc_error (\"Expected label %qs for %s statement at %C\", block_name,"}, {"sha": "69de5ad7a5697c4af145a409163082b0ab2ed119", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "patch": "@@ -1556,6 +1556,7 @@ gfc_use_rename;\n typedef struct gfc_use_list\n {\n   const char *module_name;\n+  const char *submodule_name;\n   bool intrinsic;\n   bool non_intrinsic;\n   bool only_flag;"}, {"sha": "db1d33928112798b37805b08e98aeed94486d2cb", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "patch": "@@ -81,6 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include <zlib.h>\n \n #define MODULE_EXTENSION \".mod\"\n+#define SUBMODULE_EXTENSION \".smod\"\n \n /* Don't put any single quote (') in MOD_VERSION, if you want it to be\n    recognized.  */\n@@ -190,6 +191,8 @@ static gzFile module_fp;\n \n /* The name of the module we're reading (USE'ing) or writing.  */\n static const char *module_name;\n+/* The name of the .smod file that the submodule will write to.  */\n+static const char *submodule_name;\n static gfc_use_list *module_list;\n \n /* If we're reading an intrinsic module, this is its ID.  */\n@@ -715,7 +718,17 @@ gfc_match_use (void)\n }\n \n \n-/* Match a SUBMODULE statement.  */\n+/* Match a SUBMODULE statement.\n+\n+   According to F2008:11.2.3.2, \"The submodule identifier is the\n+   ordered pair whose first element is the ancestor module name and\n+   whose second element is the submodule name. 'Submodule_name' is\n+   used for the submodule filename and uses '@' as a separator, whilst\n+   the name of the symbol for the module uses '.' as a a separator.\n+   The reasons for these choices are:\n+   (i) To follow another leading brand in the submodule filenames;\n+   (ii) Since '.' is not particularly visible in the filenames; and\n+   (iii) The linker does not permit '@' in mnemonics.  */\n \n match\n gfc_match_submodule (void)\n@@ -740,7 +753,6 @@ gfc_match_submodule (void)\n \tgoto syntax;\n \n       use_list = gfc_get_use_list ();\n-      use_list->module_name = gfc_get_string (name);\n       use_list->where = gfc_current_locus;\n \n       if (module_list)\n@@ -749,9 +761,17 @@ gfc_match_submodule (void)\n \t  while (last->next)\n \t    last = last->next;\n \t  last->next = use_list;\n+\t  use_list->module_name\n+\t\t= gfc_get_string (\"%s.%s\", module_list->module_name, name);\n+\t  use_list->submodule_name\n+\t\t= gfc_get_string (\"%s@%s\", module_list->module_name, name);\n \t}\n       else\n+\t{\n \tmodule_list = use_list;\n+\t  use_list->module_name = gfc_get_string (name);\n+\t  use_list->submodule_name = use_list->module_name;\n+\t}\n \n       if (gfc_match_char (')') == MATCH_YES)\n \tbreak;\n@@ -764,10 +784,26 @@ gfc_match_submodule (void)\n   if (m != MATCH_YES)\n     goto syntax;\n \n+  submodule_name = gfc_get_string (\"%s@%s\", module_list->module_name,\n+\t\t\t\t   gfc_new_block->name);\n+\n+  gfc_new_block->name = gfc_get_string (\"%s.%s\",\n+\t\t\t\t\tmodule_list->module_name,\n+\t\t\t\t\tgfc_new_block->name);\n+\n   if (!gfc_add_flavor (&gfc_new_block->attr, FL_MODULE,\n \t\t       gfc_new_block->name, NULL))\n     return MATCH_ERROR;\n \n+  /* Just retain the ultimate .(s)mod file for reading, since it\n+     contains all the information in its ancestors.  */\n+  use_list = module_list;\n+  for (; module_list->next; use_list = use_list->next)\n+    {\n+      module_list = use_list->next;\n+      free (use_list);\n+    }\n+\n   return MATCH_YES;\n \n syntax:\n@@ -5932,7 +5968,16 @@ gfc_dump_module (const char *name, int dump_flag)\n   char *filename, *filename_tmp;\n   uLong crc, crc_old;\n \n+  module_name = gfc_get_string (name);\n+\n+  if (gfc_state_stack->state == COMP_SUBMODULE)\n+    {\n+      name = submodule_name;\n+      n = strlen (name) + strlen (SUBMODULE_EXTENSION) + 1;\n+    }\n+  else\n   n = strlen (name) + strlen (MODULE_EXTENSION) + 1;\n+\n   if (gfc_option.module_dir != NULL)\n     {\n       n += strlen (gfc_option.module_dir);\n@@ -5945,6 +5990,10 @@ gfc_dump_module (const char *name, int dump_flag)\n       filename = (char *) alloca (n);\n       strcpy (filename, name);\n     }\n+\n+  if (gfc_state_stack->state == COMP_SUBMODULE)\n+    strcat (filename, SUBMODULE_EXTENSION);\n+  else\n   strcat (filename, MODULE_EXTENSION);\n \n   /* Name of the temporary file used to write the module.  */\n@@ -5974,7 +6023,6 @@ gfc_dump_module (const char *name, int dump_flag)\n \n   /* Write the module itself.  */\n   iomode = IO_OUTPUT;\n-  module_name = gfc_get_string (name);\n \n   init_pi_tree ();\n \n@@ -6705,10 +6753,22 @@ gfc_use_module (gfc_use_list *module)\n     gfc_warning_now (OPT_Wuse_without_only,\n \t\t     \"USE statement at %C has no ONLY qualifier\");\n \n-  filename = XALLOCAVEC (char, strlen (module_name) + strlen (MODULE_EXTENSION)\n-\t\t\t       + 1);\n+  if (gfc_state_stack->state == COMP_MODULE\n+      || module->submodule_name == NULL\n+      || strcmp (module_name, module->submodule_name) == 0)\n+    {\n+      filename = XALLOCAVEC (char, strlen (module_name)\n+\t\t\t\t   + strlen (MODULE_EXTENSION) + 1);\n   strcpy (filename, module_name);\n   strcat (filename, MODULE_EXTENSION);\n+    }\n+  else\n+    {\n+      filename = XALLOCAVEC (char, strlen (module->submodule_name)\n+\t\t\t\t   + strlen (SUBMODULE_EXTENSION) + 1);\n+      strcpy (filename, module->submodule_name);\n+      strcat (filename, SUBMODULE_EXTENSION);\n+    }\n \n   /* First, try to find an non-intrinsic module, unless the USE statement\n      specified that the module is intrinsic.  */"}, {"sha": "d117dc6dfd9186902c2d918c0f58260d501a4d3a", "filename": "gcc/testsuite/gfortran.dg/submodule_1.f08", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f08?ref=3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "patch": "@@ -170,3 +170,6 @@ subroutine clear_messages\n      message2 = \"\"\n    end subroutine\n  end program\n+! { dg-final { cleanup-submodules \"foo_interface_son\" } }\n+! { dg-final { cleanup-submodules \"foo_interface_grandson\" } }\n+! { dg-final { cleanup-submodules \"foo_interface_daughter\" } }", "previous_filename": "gcc/testsuite/gfortran.dg/submodule_1.f90"}, {"sha": "0e2f30accc41d646e41f718997b9c771d682a9d8", "filename": "gcc/testsuite/lib/fortran-modules.exp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ftestsuite%2Flib%2Ffortran-modules.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc/gcc%2Ftestsuite%2Flib%2Ffortran-modules.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ffortran-modules.exp?ref=3d5dc929f4077f3d5e8d6fddaa4f196d21a31ebc", "patch": "@@ -29,6 +29,19 @@ proc cleanup-modules { modlist } {\n     }\n }\n \n+# Remove files for specified Fortran submodules.\n+proc cleanup-submodules { modlist } {\n+    global clean\n+    foreach mod [concat $modlist $clean] {\n+\tset m [string tolower $mod].smod\n+\tverbose \"cleanup-submodule `$m'\" 2\n+\tif [is_remote host] {\n+\t    remote_file host delete $m\n+\t}\n+\tremote_file build delete $m\n+    }\n+}\n+\n proc keep-modules { modlist } {\n     global clean\n     # if the modlist is empty, keep everything"}]}