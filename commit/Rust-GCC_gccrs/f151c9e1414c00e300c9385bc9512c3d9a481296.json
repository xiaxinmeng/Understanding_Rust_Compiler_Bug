{"sha": "f151c9e1414c00e300c9385bc9512c3d9a481296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE1MWM5ZTE0MTRjMDBlMzAwYzkzODViYzk1MTJjM2Q5YTQ4MTI5Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:26:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:26:27Z"}, "message": "Remove vec_perm_const optab\n\nOne of the changes needed for variable-length VEC_PERM_EXPRs -- and for\nlong fixed-length VEC_PERM_EXPRs -- is the ability to use constant\nselectors that wouldn't fit in the vectors being permuted.  E.g. a\npermute on two V256QIs can't be done using a V256QI selector.\n\nAt the moment constant permutes use two interfaces:\ntargetm.vectorizer.vec_perm_const_ok for testing whether a permute is\nvalid and the vec_perm_const optab for actually emitting the permute.\nThe former gets passed a vec<> selector and the latter an rtx selector.\nMost ports share a lot of code between the hook and the optab, with a\nwrapper function for each interface.\n\nWe could try to keep that interface and require ports to define wider\nvector modes that could be attached to the CONST_VECTOR (e.g. V256HI or\nV256SI in the example above).  But building a CONST_VECTOR rtx seems a bit\npointless here, since the expand code only creates the CONST_VECTOR in\norder to call the optab, and the first thing the target does is take\nthe CONST_VECTOR apart again.\n\nThe easiest approach therefore seemed to be to remove the optab and\nreuse the target hook to emit the code.  One potential drawback is that\nit's no longer possible to use match_operand predicates to force\noperands into the required form, but in practice all targets want\nregister operands anyway.\n\nThe patch also changes vec_perm_indices into a class that provides\nsome simple routines for handling permutations.  A later patch will\nflesh this out and get rid of auto_vec_perm_indices, but I didn't\nwant to do all that in this patch and make it more complicated than\nit already is.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* Makefile.in (OBJS): Add vec-perm-indices.o.\n\t* vec-perm-indices.h: New file.\n\t* vec-perm-indices.c: Likewise.\n\t* target.h (vec_perm_indices): Replace with a forward class\n\tdeclaration.\n\t(auto_vec_perm_indices): Move to vec-perm-indices.h.\n\t* optabs.h: Include vec-perm-indices.h.\n\t(expand_vec_perm): Delete.\n\t(selector_fits_mode_p, expand_vec_perm_var): Declare.\n\t(expand_vec_perm_const): Declare.\n\t* target.def (vec_perm_const_ok): Replace with...\n\t(vec_perm_const): ...this new hook.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_VEC_PERM_CONST_OK): Replace with...\n\t(TARGET_VECTORIZE_VEC_PERM_CONST): ...this new hook.\n\t* doc/tm.texi: Regenerate.\n\t* optabs.def (vec_perm_const): Delete.\n\t* doc/md.texi (vec_perm_const): Likewise.\n\t(vec_perm): Refer to TARGET_VECTORIZE_VEC_PERM_CONST.\n\t* expr.c (expand_expr_real_2): Use expand_vec_perm_const rather than\n\texpand_vec_perm for constant permutation vectors.  Assert that\n\tthe mode of variable permutation vectors is the integer equivalent\n\tof the mode that is being permuted.\n\t* optabs-query.h (selector_fits_mode_p): Declare.\n\t* optabs-query.c: Include vec-perm-indices.h.\n\t(selector_fits_mode_p): New function.\n\t(can_vec_perm_const_p): Check whether targetm.vectorize.vec_perm_const\n\tis defined, instead of checking whether the vec_perm_const_optab\n\texists.  Use targetm.vectorize.vec_perm_const instead of\n\ttargetm.vectorize.vec_perm_const_ok.  Check whether the indices\n\tfit in the vector mode before using a variable permute.\n\t* optabs.c (shift_amt_for_vec_perm_mask): Take a mode and a\n\tvec_perm_indices instead of an rtx.\n\t(expand_vec_perm): Replace with...\n\t(expand_vec_perm_const): ...this new function.  Take the selector\n\tas a vec_perm_indices rather than an rtx.  Also take the mode of\n\tthe selector.  Update call to shift_amt_for_vec_perm_mask.\n\tUse targetm.vectorize.vec_perm_const instead of vec_perm_const_optab.\n\tUse vec_perm_indices::new_expanded_vector to expand the original\n\tselector into bytes.  Check whether the indices fit in the vector\n\tmode before using a variable permute.\n\t(expand_vec_perm_var): Make global.\n\t(expand_mult_highpart): Use expand_vec_perm_const.\n\t* fold-const.c: Includes vec-perm-indices.h.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* tree-vect-data-refs.c: Likewise.\n\t* tree-vect-generic.c: Likewise.\n\t* tree-vect-loop.c: Likewise.\n\t* tree-vect-slp.c: Likewise.\n\t* tree-vect-stmts.c: Likewise.\n\t* config/aarch64/aarch64-protos.h (aarch64_expand_vec_perm_const):\n\tDelete.\n\t* config/aarch64/aarch64-simd.md (vec_perm_const<mode>): Delete.\n\t* config/aarch64/aarch64.c (aarch64_expand_vec_perm_const)\n\t(aarch64_vectorize_vec_perm_const_ok): Fuse into...\n\t(aarch64_vectorize_vec_perm_const): ...this new function.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST_OK): Delete.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n\t* config/arm/arm-protos.h (arm_expand_vec_perm_const): Delete.\n\t* config/arm/vec-common.md (vec_perm_const<mode>): Delete.\n\t* config/arm/arm.c (TARGET_VECTORIZE_VEC_PERM_CONST_OK): Delete.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n\t(arm_expand_vec_perm_const, arm_vectorize_vec_perm_const_ok): Merge\n\tinto...\n\t(arm_vectorize_vec_perm_const): ...this new function.  Explicitly\n\tcheck for NEON modes.\n\t* config/i386/i386-protos.h (ix86_expand_vec_perm_const): Delete.\n\t* config/i386/sse.md (VEC_PERM_CONST, vec_perm_const<mode>): Delete.\n\t* config/i386/i386.c (ix86_expand_vec_perm_const_1): Update comment.\n\t(ix86_expand_vec_perm_const, ix86_vectorize_vec_perm_const_ok): Merge\n\tinto...\n\t(ix86_vectorize_vec_perm_const): ...this new function.  Incorporate\n\tthe old VEC_PERM_CONST conditions.\n\t* config/ia64/ia64-protos.h (ia64_expand_vec_perm_const): Delete.\n\t* config/ia64/vect.md (vec_perm_const<mode>): Delete.\n\t* config/ia64/ia64.c (ia64_expand_vec_perm_const)\n\t(ia64_vectorize_vec_perm_const_ok): Merge into...\n\t(ia64_vectorize_vec_perm_const): ...this new function.\n\t* config/mips/loongson.md (vec_perm_const<mode>): Delete.\n\t* config/mips/mips-msa.md (vec_perm_const<mode>): Delete.\n\t* config/mips/mips-ps-3d.md (vec_perm_constv2sf): Delete.\n\t* config/mips/mips-protos.h (mips_expand_vec_perm_const): Delete.\n\t* config/mips/mips.c (mips_expand_vec_perm_const)\n\t(mips_vectorize_vec_perm_const_ok): Merge into...\n\t(mips_vectorize_vec_perm_const): ...this new function.\n\t* config/powerpcspe/altivec.md (vec_perm_constv16qi): Delete.\n\t* config/powerpcspe/paired.md (vec_perm_constv2sf): Delete.\n\t* config/powerpcspe/spe.md (vec_perm_constv2si): Delete.\n\t* config/powerpcspe/vsx.md (vec_perm_const<mode>): Delete.\n\t* config/powerpcspe/powerpcspe-protos.h (altivec_expand_vec_perm_const)\n\t(rs6000_expand_vec_perm_const): Delete.\n\t* config/powerpcspe/powerpcspe.c (TARGET_VECTORIZE_VEC_PERM_CONST_OK):\n\tDelete.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n\t(altivec_expand_vec_perm_const_le): Take each operand individually.\n\tOperate on constant selectors rather than rtxes.\n\t(altivec_expand_vec_perm_const): Likewise.  Update call to\n\taltivec_expand_vec_perm_const_le.\n\t(rs6000_expand_vec_perm_const): Delete.\n\t(rs6000_vectorize_vec_perm_const_ok): Delete.\n\t(rs6000_vectorize_vec_perm_const): New function.\n\t(rs6000_do_expand_vec_perm): Take a vec_perm_builder instead of\n\tan element count and rtx array.\n\t(rs6000_expand_extract_even): Update call accordingly.\n\t(rs6000_expand_interleave): Likewise.\n\t* config/rs6000/altivec.md (vec_perm_constv16qi): Delete.\n\t* config/rs6000/paired.md (vec_perm_constv2sf): Delete.\n\t* config/rs6000/vsx.md (vec_perm_const<mode>): Delete.\n\t* config/rs6000/rs6000-protos.h (altivec_expand_vec_perm_const)\n\t(rs6000_expand_vec_perm_const): Delete.\n\t* config/rs6000/rs6000.c (TARGET_VECTORIZE_VEC_PERM_CONST_OK): Delete.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n\t(altivec_expand_vec_perm_const_le): Take each operand individually.\n\tOperate on constant selectors rather than rtxes.\n\t(altivec_expand_vec_perm_const): Likewise.  Update call to\n\taltivec_expand_vec_perm_const_le.\n\t(rs6000_expand_vec_perm_const): Delete.\n\t(rs6000_vectorize_vec_perm_const_ok): Delete.\n\t(rs6000_vectorize_vec_perm_const): New function.  Remove stray\n\treference to the SPE evmerge intructions.\n\t(rs6000_do_expand_vec_perm): Take a vec_perm_builder instead of\n\tan element count and rtx array.\n\t(rs6000_expand_extract_even): Update call accordingly.\n\t(rs6000_expand_interleave): Likewise.\n\t* config/sparc/sparc.md (vec_perm_constv8qi): Delete in favor of...\n\t* config/sparc/sparc.c (sparc_vectorize_vec_perm_const): ...this\n\tnew function.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n\nFrom-SVN: r256093", "tree": {"sha": "cc430a054b11cef7b925002187dba5a721bf148c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc430a054b11cef7b925002187dba5a721bf148c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f151c9e1414c00e300c9385bc9512c3d9a481296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f151c9e1414c00e300c9385bc9512c3d9a481296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f151c9e1414c00e300c9385bc9512c3d9a481296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f151c9e1414c00e300c9385bc9512c3d9a481296/comments", "author": null, "committer": null, "parents": [{"sha": "279b805713fd498afb7986698a2e3406bc947d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279b805713fd498afb7986698a2e3406bc947d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279b805713fd498afb7986698a2e3406bc947d87"}], "stats": {"total": 1613, "additions": 790, "deletions": 823}, "files": [{"sha": "821442fa72435b0f17437fd7165907f0087fae4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -1,3 +1,133 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* Makefile.in (OBJS): Add vec-perm-indices.o.\n+\t* vec-perm-indices.h: New file.\n+\t* vec-perm-indices.c: Likewise.\n+\t* target.h (vec_perm_indices): Replace with a forward class\n+\tdeclaration.\n+\t(auto_vec_perm_indices): Move to vec-perm-indices.h.\n+\t* optabs.h: Include vec-perm-indices.h.\n+\t(expand_vec_perm): Delete.\n+\t(selector_fits_mode_p, expand_vec_perm_var): Declare.\n+\t(expand_vec_perm_const): Declare.\n+\t* target.def (vec_perm_const_ok): Replace with...\n+\t(vec_perm_const): ...this new hook.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_VEC_PERM_CONST_OK): Replace with...\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST): ...this new hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* optabs.def (vec_perm_const): Delete.\n+\t* doc/md.texi (vec_perm_const): Likewise.\n+\t(vec_perm): Refer to TARGET_VECTORIZE_VEC_PERM_CONST.\n+\t* expr.c (expand_expr_real_2): Use expand_vec_perm_const rather than\n+\texpand_vec_perm for constant permutation vectors.  Assert that\n+\tthe mode of variable permutation vectors is the integer equivalent\n+\tof the mode that is being permuted.\n+\t* optabs-query.h (selector_fits_mode_p): Declare.\n+\t* optabs-query.c: Include vec-perm-indices.h.\n+\t(selector_fits_mode_p): New function.\n+\t(can_vec_perm_const_p): Check whether targetm.vectorize.vec_perm_const\n+\tis defined, instead of checking whether the vec_perm_const_optab\n+\texists.  Use targetm.vectorize.vec_perm_const instead of\n+\ttargetm.vectorize.vec_perm_const_ok.  Check whether the indices\n+\tfit in the vector mode before using a variable permute.\n+\t* optabs.c (shift_amt_for_vec_perm_mask): Take a mode and a\n+\tvec_perm_indices instead of an rtx.\n+\t(expand_vec_perm): Replace with...\n+\t(expand_vec_perm_const): ...this new function.  Take the selector\n+\tas a vec_perm_indices rather than an rtx.  Also take the mode of\n+\tthe selector.  Update call to shift_amt_for_vec_perm_mask.\n+\tUse targetm.vectorize.vec_perm_const instead of vec_perm_const_optab.\n+\tUse vec_perm_indices::new_expanded_vector to expand the original\n+\tselector into bytes.  Check whether the indices fit in the vector\n+\tmode before using a variable permute.\n+\t(expand_vec_perm_var): Make global.\n+\t(expand_mult_highpart): Use expand_vec_perm_const.\n+\t* fold-const.c: Includes vec-perm-indices.h.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* tree-vect-data-refs.c: Likewise.\n+\t* tree-vect-generic.c: Likewise.\n+\t* tree-vect-loop.c: Likewise.\n+\t* tree-vect-slp.c: Likewise.\n+\t* tree-vect-stmts.c: Likewise.\n+\t* config/aarch64/aarch64-protos.h (aarch64_expand_vec_perm_const):\n+\tDelete.\n+\t* config/aarch64/aarch64-simd.md (vec_perm_const<mode>): Delete.\n+\t* config/aarch64/aarch64.c (aarch64_expand_vec_perm_const)\n+\t(aarch64_vectorize_vec_perm_const_ok): Fuse into...\n+\t(aarch64_vectorize_vec_perm_const): ...this new function.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST_OK): Delete.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n+\t* config/arm/arm-protos.h (arm_expand_vec_perm_const): Delete.\n+\t* config/arm/vec-common.md (vec_perm_const<mode>): Delete.\n+\t* config/arm/arm.c (TARGET_VECTORIZE_VEC_PERM_CONST_OK): Delete.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n+\t(arm_expand_vec_perm_const, arm_vectorize_vec_perm_const_ok): Merge\n+\tinto...\n+\t(arm_vectorize_vec_perm_const): ...this new function.  Explicitly\n+\tcheck for NEON modes.\n+\t* config/i386/i386-protos.h (ix86_expand_vec_perm_const): Delete.\n+\t* config/i386/sse.md (VEC_PERM_CONST, vec_perm_const<mode>): Delete.\n+\t* config/i386/i386.c (ix86_expand_vec_perm_const_1): Update comment.\n+\t(ix86_expand_vec_perm_const, ix86_vectorize_vec_perm_const_ok): Merge\n+\tinto...\n+\t(ix86_vectorize_vec_perm_const): ...this new function.  Incorporate\n+\tthe old VEC_PERM_CONST conditions.\n+\t* config/ia64/ia64-protos.h (ia64_expand_vec_perm_const): Delete.\n+\t* config/ia64/vect.md (vec_perm_const<mode>): Delete.\n+\t* config/ia64/ia64.c (ia64_expand_vec_perm_const)\n+\t(ia64_vectorize_vec_perm_const_ok): Merge into...\n+\t(ia64_vectorize_vec_perm_const): ...this new function.\n+\t* config/mips/loongson.md (vec_perm_const<mode>): Delete.\n+\t* config/mips/mips-msa.md (vec_perm_const<mode>): Delete.\n+\t* config/mips/mips-ps-3d.md (vec_perm_constv2sf): Delete.\n+\t* config/mips/mips-protos.h (mips_expand_vec_perm_const): Delete.\n+\t* config/mips/mips.c (mips_expand_vec_perm_const)\n+\t(mips_vectorize_vec_perm_const_ok): Merge into...\n+\t(mips_vectorize_vec_perm_const): ...this new function.\n+\t* config/powerpcspe/altivec.md (vec_perm_constv16qi): Delete.\n+\t* config/powerpcspe/paired.md (vec_perm_constv2sf): Delete.\n+\t* config/powerpcspe/spe.md (vec_perm_constv2si): Delete.\n+\t* config/powerpcspe/vsx.md (vec_perm_const<mode>): Delete.\n+\t* config/powerpcspe/powerpcspe-protos.h (altivec_expand_vec_perm_const)\n+\t(rs6000_expand_vec_perm_const): Delete.\n+\t* config/powerpcspe/powerpcspe.c (TARGET_VECTORIZE_VEC_PERM_CONST_OK):\n+\tDelete.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n+\t(altivec_expand_vec_perm_const_le): Take each operand individually.\n+\tOperate on constant selectors rather than rtxes.\n+\t(altivec_expand_vec_perm_const): Likewise.  Update call to\n+\taltivec_expand_vec_perm_const_le.\n+\t(rs6000_expand_vec_perm_const): Delete.\n+\t(rs6000_vectorize_vec_perm_const_ok): Delete.\n+\t(rs6000_vectorize_vec_perm_const): New function.\n+\t(rs6000_do_expand_vec_perm): Take a vec_perm_builder instead of\n+\tan element count and rtx array.\n+\t(rs6000_expand_extract_even): Update call accordingly.\n+\t(rs6000_expand_interleave): Likewise.\n+\t* config/rs6000/altivec.md (vec_perm_constv16qi): Delete.\n+\t* config/rs6000/paired.md (vec_perm_constv2sf): Delete.\n+\t* config/rs6000/vsx.md (vec_perm_const<mode>): Delete.\n+\t* config/rs6000/rs6000-protos.h (altivec_expand_vec_perm_const)\n+\t(rs6000_expand_vec_perm_const): Delete.\n+\t* config/rs6000/rs6000.c (TARGET_VECTORIZE_VEC_PERM_CONST_OK): Delete.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n+\t(altivec_expand_vec_perm_const_le): Take each operand individually.\n+\tOperate on constant selectors rather than rtxes.\n+\t(altivec_expand_vec_perm_const): Likewise.  Update call to\n+\taltivec_expand_vec_perm_const_le.\n+\t(rs6000_expand_vec_perm_const): Delete.\n+\t(rs6000_vectorize_vec_perm_const_ok): Delete.\n+\t(rs6000_vectorize_vec_perm_const): New function.  Remove stray\n+\treference to the SPE evmerge intructions.\n+\t(rs6000_do_expand_vec_perm): Take a vec_perm_builder instead of\n+\tan element count and rtx array.\n+\t(rs6000_expand_extract_even): Update call accordingly.\n+\t(rs6000_expand_interleave): Likewise.\n+\t* config/sparc/sparc.md (vec_perm_constv8qi): Delete in favor of...\n+\t* config/sparc/sparc.c (sparc_vectorize_vec_perm_const): ...this\n+\tnew function.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST): Redefine.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* optabs.c (expand_vec_perm_1): Assert that SEL has an integer"}, {"sha": "3b0ba2769519e22371a8eff783814da5d87ca6d7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -1585,6 +1585,7 @@ OBJS = \\\n \tvar-tracking.o \\\n \tvarasm.o \\\n \tvarpool.o \\\n+\tvec-perm-indices.o \\\n \tvmsdbgout.o \\\n \tvr-values.o \\\n \tvtable-verify.o \\"}, {"sha": "3bc3756563ae6339e76b3df831a3a408399a3a91", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -488,8 +488,6 @@ extern void aarch64_split_combinev16qi (rtx operands[3]);\n extern void aarch64_expand_vec_perm (rtx, rtx, rtx, rtx, unsigned int);\n extern bool aarch64_madd_needs_nop (rtx_insn *);\n extern void aarch64_final_prescan_insn (rtx_insn *);\n-extern bool\n-aarch64_expand_vec_perm_const (rtx, rtx, rtx, rtx, unsigned int);\n void aarch64_atomic_assign_expand_fenv (tree *, tree *, tree *);\n int aarch64_ccmp_mode_to_code (machine_mode mode);\n "}, {"sha": "e04a9883892dd8a60f3aa47f0a48d65f78a1b8cf", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -5385,20 +5385,6 @@\n \n ;; vec_perm support\n \n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VALL_F16 0 \"register_operand\")\n-   (match_operand:VALL_F16 1 \"register_operand\")\n-   (match_operand:VALL_F16 2 \"register_operand\")\n-   (match_operand:<V_INT_EQUIV> 3)]\n-  \"TARGET_SIMD\"\n-{\n-  if (aarch64_expand_vec_perm_const (operands[0], operands[1],\n-\t\t\t\t     operands[2], operands[3], <nunits>))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_expand \"vec_perm<mode>\"\n   [(match_operand:VB 0 \"register_operand\")\n    (match_operand:VB 1 \"register_operand\")"}, {"sha": "05b82bcd6151de35e765ff0afad11ffa32553928", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 16, "deletions": 49, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -143,8 +143,6 @@ static void aarch64_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_elf_asm_destructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_override_options_after_change (void);\n static bool aarch64_vector_mode_supported_p (machine_mode);\n-static bool aarch64_vectorize_vec_perm_const_ok (machine_mode,\n-\t\t\t\t\t\t vec_perm_indices);\n static int aarch64_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t\t\t const_tree type,\n@@ -13670,29 +13668,27 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   return false;\n }\n \n-/* Expand a vec_perm_const pattern with the operands given by TARGET,\n-   OP0, OP1 and SEL.  NELT is the number of elements in the vector.  */\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n-bool\n-aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel,\n-\t\t\t       unsigned int nelt)\n+static bool\n+aarch64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n+\t\t\t\t  rtx op1, const vec_perm_indices &sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, which;\n \n+  d.vmode = vmode;\n   d.target = target;\n   d.op0 = op0;\n   d.op1 = op1;\n+  d.testing_p = !target;\n \n-  d.vmode = GET_MODE (target);\n-  gcc_assert (VECTOR_MODE_P (d.vmode));\n-  d.testing_p = false;\n-\n+  /* Calculate whether all elements are in one vector.  */\n+  unsigned int nelt = sel.length ();\n   d.perm.reserve (nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      unsigned int ei = INTVAL (e) & (2 * nelt - 1);\n+      unsigned int ei = sel[i] & (2 * nelt - 1);\n       which |= (ei < nelt ? 1 : 2);\n       d.perm.quick_push (ei);\n     }\n@@ -13704,7 +13700,7 @@ aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel,\n \n     case 3:\n       d.one_vector_p = false;\n-      if (!rtx_equal_p (op0, op1))\n+      if (d.testing_p || !rtx_equal_p (op0, op1))\n \tbreak;\n \n       /* The elements of PERM do not suggest that only the first operand\n@@ -13725,45 +13721,16 @@ aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel,\n       break;\n     }\n \n-  return aarch64_expand_vec_perm_const_1 (&d);\n-}\n-\n-static bool\n-aarch64_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n-{\n-  struct expand_vec_perm_d d;\n-  unsigned int i, nelt, which;\n-  bool ret;\n-\n-  d.vmode = vmode;\n-  d.testing_p = true;\n-  d.perm.safe_splice (sel);\n-\n-  /* Calculate whether all elements are in one vector.  */\n-  nelt = sel.length ();\n-  for (i = which = 0; i < nelt; ++i)\n-    {\n-      unsigned int e = d.perm[i];\n-      gcc_assert (e < 2 * nelt);\n-      which |= (e < nelt ? 1 : 2);\n-    }\n-\n-  /* If all elements are from the second vector, reindex as if from the\n-     first vector.  */\n-  if (which == 2)\n-    for (i = 0; i < nelt; ++i)\n-      d.perm[i] -= nelt;\n-\n-  /* Check whether the mask can be applied to a single vector.  */\n-  d.one_vector_p = (which != 3);\n+  if (!d.testing_p)\n+    return aarch64_expand_vec_perm_const_1 (&d);\n \n   d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n   d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n   if (!d.one_vector_p)\n     d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n \n   start_sequence ();\n-  ret = aarch64_expand_vec_perm_const_1 (&d);\n+  bool ret = aarch64_expand_vec_perm_const_1 (&d);\n   end_sequence ();\n \n   return ret;\n@@ -15515,9 +15482,9 @@ aarch64_libgcc_floating_mode_supported_p\n \n /* vec_perm support.  */\n \n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n-  aarch64_vectorize_vec_perm_const_ok\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST \\\n+  aarch64_vectorize_vec_perm_const\n \n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS aarch64_init_libfuncs"}, {"sha": "24a4ab870c77aaa2b0399283cd252124261d8ce5", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -357,7 +357,6 @@ extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n \n extern bool arm_gen_setmem (rtx *);\n extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n-extern bool arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n \n extern bool arm_autoinc_modes_ok_p (machine_mode, enum arm_auto_incmodes);\n "}, {"sha": "2173d95dd6d4d2480703f5ea4182557497c9fabc", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 45, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -290,7 +290,8 @@ static int arm_cortex_a5_branch_cost (bool, bool);\n static int arm_cortex_m_branch_cost (bool, bool);\n static int arm_cortex_m7_branch_cost (bool, bool);\n \n-static bool arm_vectorize_vec_perm_const_ok (machine_mode, vec_perm_indices);\n+static bool arm_vectorize_vec_perm_const (machine_mode, rtx, rtx, rtx,\n+\t\t\t\t\t  const vec_perm_indices &);\n \n static bool aarch_macro_fusion_pair_p (rtx_insn*, rtx_insn*);\n \n@@ -736,9 +737,8 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_PREFERRED_RENAME_CLASS \\\n   arm_preferred_rename_class\n \n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n-  arm_vectorize_vec_perm_const_ok\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST arm_vectorize_vec_perm_const\n \n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n@@ -29383,28 +29383,31 @@ arm_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   return false;\n }\n \n-/* Expand a vec_perm_const pattern.  */\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n-bool\n-arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n+static bool\n+arm_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0, rtx op1,\n+\t\t\t      const vec_perm_indices &sel)\n {\n   struct expand_vec_perm_d d;\n   int i, nelt, which;\n \n+  if (!VALID_NEON_DREG_MODE (vmode) && !VALID_NEON_QREG_MODE (vmode))\n+    return false;\n+\n   d.target = target;\n   d.op0 = op0;\n   d.op1 = op1;\n \n-  d.vmode = GET_MODE (target);\n+  d.vmode = vmode;\n   gcc_assert (VECTOR_MODE_P (d.vmode));\n-  d.testing_p = false;\n+  d.testing_p = !target;\n \n   nelt = GET_MODE_NUNITS (d.vmode);\n   d.perm.reserve (nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      int ei = INTVAL (e) & (2 * nelt - 1);\n+      int ei = sel[i] & (2 * nelt - 1);\n       which |= (ei < nelt ? 1 : 2);\n       d.perm.quick_push (ei);\n     }\n@@ -29416,7 +29419,7 @@ arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n \n     case 3:\n       d.one_vector_p = false;\n-      if (!rtx_equal_p (op0, op1))\n+      if (d.testing_p || !rtx_equal_p (op0, op1))\n \tbreak;\n \n       /* The elements of PERM do not suggest that only the first operand\n@@ -29437,46 +29440,16 @@ arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n       break;\n     }\n \n-  return arm_expand_vec_perm_const_1 (&d);\n-}\n-\n-/* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n-\n-static bool\n-arm_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n-{\n-  struct expand_vec_perm_d d;\n-  unsigned int i, nelt, which;\n-  bool ret;\n-\n-  d.vmode = vmode;\n-  d.testing_p = true;\n-  d.perm.safe_splice (sel);\n-\n-  /* Categorize the set of elements in the selector.  */\n-  nelt = GET_MODE_NUNITS (d.vmode);\n-  for (i = which = 0; i < nelt; ++i)\n-    {\n-      unsigned int e = d.perm[i];\n-      gcc_assert (e < 2 * nelt);\n-      which |= (e < nelt ? 1 : 2);\n-    }\n-\n-  /* For all elements from second vector, fold the elements to first.  */\n-  if (which == 2)\n-    for (i = 0; i < nelt; ++i)\n-      d.perm[i] -= nelt;\n-\n-  /* Check whether the mask can be applied to the vector type.  */\n-  d.one_vector_p = (which != 3);\n+  if (d.testing_p)\n+    return arm_expand_vec_perm_const_1 (&d);\n \n   d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n   d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n   if (!d.one_vector_p)\n     d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n \n   start_sequence ();\n-  ret = arm_expand_vec_perm_const_1 (&d);\n+  bool ret = arm_expand_vec_perm_const_1 (&d);\n   end_sequence ();\n \n   return ret;"}, {"sha": "20ae24fed560c8d4c04f38dd99c5cc75bcf7ccf3", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -109,35 +109,6 @@\n {\n })\n \n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VALL 0 \"s_register_operand\" \"\")\n-   (match_operand:VALL 1 \"s_register_operand\" \"\")\n-   (match_operand:VALL 2 \"s_register_operand\" \"\")\n-   (match_operand:<V_cmp_result> 3 \"\" \"\")]\n-  \"TARGET_NEON\n-   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n-{\n-  if (arm_expand_vec_perm_const (operands[0], operands[1],\n-\t\t\t\t operands[2], operands[3]))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VH 0 \"s_register_operand\")\n-   (match_operand:VH 1 \"s_register_operand\")\n-   (match_operand:VH 2 \"s_register_operand\")\n-   (match_operand:<V_cmp_result> 3)]\n-  \"TARGET_NEON\"\n-{\n-  if (arm_expand_vec_perm_const (operands[0], operands[1],\n-\t\t\t\t operands[2], operands[3]))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_expand \"vec_perm<mode>\"\n   [(match_operand:VE 0 \"s_register_operand\" \"\")\n    (match_operand:VE 1 \"s_register_operand\" \"\")"}, {"sha": "287b019858951935da14cb25bf2407ebaffed61a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -133,7 +133,6 @@ extern bool ix86_expand_fp_movcc (rtx[]);\n extern bool ix86_expand_fp_vcond (rtx[]);\n extern bool ix86_expand_int_vcond (rtx[]);\n extern void ix86_expand_vec_perm (rtx[]);\n-extern bool ix86_expand_vec_perm_const (rtx[]);\n extern bool ix86_expand_mask_vec_cmp (rtx[]);\n extern bool ix86_expand_int_vec_cmp (rtx[]);\n extern bool ix86_expand_fp_vec_cmp (rtx[]);"}, {"sha": "1acb2c6ab838d97b9c839a456ed5d624090c60f7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 90, "deletions": 91, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -47605,9 +47605,8 @@ expand_vec_perm_vpshufb4_vpermq2 (struct expand_vec_perm_d *d)\n   return true;\n }\n \n-/* The guts of ix86_expand_vec_perm_const, also used by the ok hook.\n-   With all of the interface bits taken care of, perform the expansion\n-   in D and return true on success.  */\n+/* The guts of ix86_vectorize_vec_perm_const.  With all of the interface bits\n+   taken care of, perform the expansion in D and return true on success.  */\n \n static bool\n ix86_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n@@ -47742,69 +47741,29 @@ canonicalize_perm (struct expand_vec_perm_d *d)\n   return (which == 3);\n }\n \n-bool\n-ix86_expand_vec_perm_const (rtx operands[4])\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n+\n+static bool\n+ix86_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n+\t\t\t       rtx op1, const vec_perm_indices &sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned char perm[MAX_VECT_LEN];\n-  int i, nelt;\n+  unsigned int i, nelt, which;\n   bool two_args;\n-  rtx sel;\n \n-  d.target = operands[0];\n-  d.op0 = operands[1];\n-  d.op1 = operands[2];\n-  sel = operands[3];\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n \n-  d.vmode = GET_MODE (d.target);\n+  d.vmode = vmode;\n   gcc_assert (VECTOR_MODE_P (d.vmode));\n   d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = false;\n+  d.testing_p = !target;\n \n-  gcc_assert (GET_CODE (sel) == CONST_VECTOR);\n-  gcc_assert (XVECLEN (sel, 0) == nelt);\n+  gcc_assert (sel.length () == nelt);\n   gcc_checking_assert (sizeof (d.perm) == sizeof (perm));\n \n-  for (i = 0; i < nelt; ++i)\n-    {\n-      rtx e = XVECEXP (sel, 0, i);\n-      int ei = INTVAL (e) & (2 * nelt - 1);\n-      d.perm[i] = ei;\n-      perm[i] = ei;\n-    }\n-\n-  two_args = canonicalize_perm (&d);\n-\n-  if (ix86_expand_vec_perm_const_1 (&d))\n-    return true;\n-\n-  /* If the selector says both arguments are needed, but the operands are the\n-     same, the above tried to expand with one_operand_p and flattened selector.\n-     If that didn't work, retry without one_operand_p; we succeeded with that\n-     during testing.  */\n-  if (two_args && d.one_operand_p)\n-    {\n-      d.one_operand_p = false;\n-      memcpy (d.perm, perm, sizeof (perm));\n-      return ix86_expand_vec_perm_const_1 (&d);\n-    }\n-\n-  return false;\n-}\n-\n-/* Implement targetm.vectorize.vec_perm_const_ok.  */\n-\n-static bool\n-ix86_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n-{\n-  struct expand_vec_perm_d d;\n-  unsigned int i, nelt, which;\n-  bool ret;\n-\n-  d.vmode = vmode;\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = true;\n-\n   /* Given sufficient ISA support we can just return true here\n      for selected vector modes.  */\n   switch (d.vmode)\n@@ -47813,91 +47772,132 @@ ix86_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n     case E_V16SImode:\n     case E_V8DImode:\n     case E_V8DFmode:\n-      if (TARGET_AVX512F)\n-\t/* All implementable with a single vperm[it]2 insn.  */\n+      if (!TARGET_AVX512F)\n+\treturn false;\n+      /* All implementable with a single vperm[it]2 insn.  */\n+      if (d.testing_p)\n \treturn true;\n       break;\n     case E_V32HImode:\n-      if (TARGET_AVX512BW)\n+      if (!TARGET_AVX512BW)\n+\treturn false;\n+      if (d.testing_p)\n \t/* All implementable with a single vperm[it]2 insn.  */\n \treturn true;\n       break;\n     case E_V64QImode:\n-      if (TARGET_AVX512BW)\n+      if (!TARGET_AVX512BW)\n+\treturn false;\n+      if (d.testing_p)\n \t/* Implementable with 2 vperm[it]2, 2 vpshufb and 1 or insn.  */\n \treturn true;\n       break;\n     case E_V8SImode:\n     case E_V8SFmode:\n     case E_V4DFmode:\n     case E_V4DImode:\n-      if (TARGET_AVX512VL)\n+      if (!TARGET_AVX)\n+\treturn false;\n+      if (d.testing_p && TARGET_AVX512VL)\n \t/* All implementable with a single vperm[it]2 insn.  */\n \treturn true;\n       break;\n     case E_V16HImode:\n-      if (TARGET_AVX2)\n+      if (!TARGET_SSE2)\n+\treturn false;\n+      if (d.testing_p && TARGET_AVX2)\n \t/* Implementable with 4 vpshufb insns, 2 vpermq and 3 vpor insns.  */\n \treturn true;\n       break;\n     case E_V32QImode:\n-      if (TARGET_AVX2)\n+      if (!TARGET_SSE2)\n+\treturn false;\n+      if (d.testing_p && TARGET_AVX2)\n \t/* Implementable with 4 vpshufb insns, 2 vpermq and 3 vpor insns.  */\n \treturn true;\n       break;\n-    case E_V4SImode:\n-    case E_V4SFmode:\n     case E_V8HImode:\n     case E_V16QImode:\n+      if (!TARGET_SSE2)\n+\treturn false;\n+      /* Fall through.  */\n+    case E_V4SImode:\n+    case E_V4SFmode:\n+      if (!TARGET_SSE)\n+\treturn false;\n       /* All implementable with a single vpperm insn.  */\n-      if (TARGET_XOP)\n+      if (d.testing_p && TARGET_XOP)\n \treturn true;\n       /* All implementable with 2 pshufb + 1 ior.  */\n-      if (TARGET_SSSE3)\n+      if (d.testing_p && TARGET_SSSE3)\n \treturn true;\n       break;\n     case E_V2DImode:\n     case E_V2DFmode:\n+      if (!TARGET_SSE)\n+\treturn false;\n       /* All implementable with shufpd or unpck[lh]pd.  */\n-      return true;\n+      if (d.testing_p)\n+\treturn true;\n+      break;\n     default:\n       return false;\n     }\n \n-  /* Extract the values from the vector CST into the permutation\n-     array in D.  */\n   for (i = which = 0; i < nelt; ++i)\n     {\n       unsigned char e = sel[i];\n       gcc_assert (e < 2 * nelt);\n       d.perm[i] = e;\n+      perm[i] = e;\n       which |= (e < nelt ? 1 : 2);\n     }\n \n-  /* For all elements from second vector, fold the elements to first.  */\n-  if (which == 2)\n-    for (i = 0; i < nelt; ++i)\n-      d.perm[i] -= nelt;\n+  if (d.testing_p)\n+    {\n+      /* For all elements from second vector, fold the elements to first.  */\n+      if (which == 2)\n+\tfor (i = 0; i < nelt; ++i)\n+\t  d.perm[i] -= nelt;\n \n-  /* Check whether the mask can be applied to the vector type.  */\n-  d.one_operand_p = (which != 3);\n+      /* Check whether the mask can be applied to the vector type.  */\n+      d.one_operand_p = (which != 3);\n \n-  /* Implementable with shufps or pshufd.  */\n-  if (d.one_operand_p && (d.vmode == V4SFmode || d.vmode == V4SImode))\n-    return true;\n+      /* Implementable with shufps or pshufd.  */\n+      if (d.one_operand_p && (d.vmode == V4SFmode || d.vmode == V4SImode))\n+\treturn true;\n \n-  /* Otherwise we have to go through the motions and see if we can\n-     figure out how to generate the requested permutation.  */\n-  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n-  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n-  if (!d.one_operand_p)\n-    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+      /* Otherwise we have to go through the motions and see if we can\n+\t figure out how to generate the requested permutation.  */\n+      d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+      d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+      if (!d.one_operand_p)\n+\td.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n \n-  start_sequence ();\n-  ret = ix86_expand_vec_perm_const_1 (&d);\n-  end_sequence ();\n+      start_sequence ();\n+      bool ret = ix86_expand_vec_perm_const_1 (&d);\n+      end_sequence ();\n \n-  return ret;\n+      return ret;\n+    }\n+\n+  two_args = canonicalize_perm (&d);\n+\n+  if (ix86_expand_vec_perm_const_1 (&d))\n+    return true;\n+\n+  /* If the selector says both arguments are needed, but the operands are the\n+     same, the above tried to expand with one_operand_p and flattened selector.\n+     If that didn't work, retry without one_operand_p; we succeeded with that\n+     during testing.  */\n+  if (two_args && d.one_operand_p)\n+    {\n+      d.one_operand_p = false;\n+      memcpy (d.perm, perm, sizeof (perm));\n+      return ix86_expand_vec_perm_const_1 (&d);\n+    }\n+\n+  return false;\n }\n \n void\n@@ -50549,9 +50549,8 @@ ix86_run_selftests (void)\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n   ix86_builtin_vectorization_cost\n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n-  ix86_vectorize_vec_perm_const_ok\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST ix86_vectorize_vec_perm_const\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE \\\n   ix86_preferred_simd_mode"}, {"sha": "76c150fe8ece481f6a019d8ba06fbc10a81e0644", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -11498,30 +11498,6 @@\n   DONE;\n })\n \n-(define_mode_iterator VEC_PERM_CONST\n-  [(V4SF \"TARGET_SSE\") (V4SI \"TARGET_SSE\")\n-   (V2DF \"TARGET_SSE\") (V2DI \"TARGET_SSE\")\n-   (V16QI \"TARGET_SSE2\") (V8HI \"TARGET_SSE2\")\n-   (V8SF \"TARGET_AVX\") (V4DF \"TARGET_AVX\")\n-   (V8SI \"TARGET_AVX\") (V4DI \"TARGET_AVX\")\n-   (V32QI \"TARGET_AVX2\") (V16HI \"TARGET_AVX2\")\n-   (V16SI \"TARGET_AVX512F\") (V8DI \"TARGET_AVX512F\")\n-   (V16SF \"TARGET_AVX512F\") (V8DF \"TARGET_AVX512F\")\n-   (V32HI \"TARGET_AVX512BW\") (V64QI \"TARGET_AVX512BW\")])\n-\n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VEC_PERM_CONST 0 \"register_operand\")\n-   (match_operand:VEC_PERM_CONST 1 \"register_operand\")\n-   (match_operand:VEC_PERM_CONST 2 \"register_operand\")\n-   (match_operand:<sseintvecmode> 3)]\n-  \"\"\n-{\n-  if (ix86_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel bitwise logical operations"}, {"sha": "71e55e47557749c171c9133e5fe8ed57faa6bb90", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -62,7 +62,6 @@ extern const char *get_bundle_name (int);\n extern const char *output_probe_stack_range (rtx, rtx);\n \n extern void ia64_expand_vec_perm_even_odd (rtx, rtx, rtx, int);\n-extern bool ia64_expand_vec_perm_const (rtx op[4]);\n extern void ia64_expand_vec_setv2sf (rtx op[3]);\n #endif /* RTX_CODE */\n "}, {"sha": "d2ce1a49fb90a59e76890323bfdb71215bb69993", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 34, "deletions": 63, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -335,7 +335,8 @@ static fixed_size_mode ia64_get_reg_raw_mode (int regno);\n static section * ia64_hpux_function_section (tree, enum node_frequency,\n \t\t\t\t\t     bool, bool);\n \n-static bool ia64_vectorize_vec_perm_const_ok (machine_mode, vec_perm_indices);\n+static bool ia64_vectorize_vec_perm_const (machine_mode, rtx, rtx, rtx,\n+\t\t\t\t\t   const vec_perm_indices &);\n \n static unsigned int ia64_hard_regno_nregs (unsigned int, machine_mode);\n static bool ia64_hard_regno_mode_ok (unsigned int, machine_mode);\n@@ -654,8 +655,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_DELAY_VARTRACK\n #define TARGET_DELAY_VARTRACK true\n \n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK ia64_vectorize_vec_perm_const_ok\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST ia64_vectorize_vec_perm_const\n \n #undef TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P\n #define TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P ia64_attribute_takes_identifier_p\n@@ -11743,32 +11744,31 @@ ia64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   return false;\n }\n \n-bool\n-ia64_expand_vec_perm_const (rtx operands[4])\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n+\n+static bool\n+ia64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n+\t\t\t       rtx op1, const vec_perm_indices &sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned char perm[MAX_VECT_LEN];\n-  int i, nelt, which;\n-  rtx sel;\n+  unsigned int i, nelt, which;\n \n-  d.target = operands[0];\n-  d.op0 = operands[1];\n-  d.op1 = operands[2];\n-  sel = operands[3];\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n \n-  d.vmode = GET_MODE (d.target);\n+  d.vmode = vmode;\n   gcc_assert (VECTOR_MODE_P (d.vmode));\n   d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = false;\n+  d.testing_p = !target;\n \n-  gcc_assert (GET_CODE (sel) == CONST_VECTOR);\n-  gcc_assert (XVECLEN (sel, 0) == nelt);\n+  gcc_assert (sel.length () == nelt);\n   gcc_checking_assert (sizeof (d.perm) == sizeof (perm));\n \n   for (i = which = 0; i < nelt; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      int ei = INTVAL (e) & (2 * nelt - 1);\n+      unsigned int ei = sel[i] & (2 * nelt - 1);\n \n       which |= (ei < nelt ? 1 : 2);\n       d.perm[i] = ei;\n@@ -11781,7 +11781,7 @@ ia64_expand_vec_perm_const (rtx operands[4])\n       gcc_unreachable();\n \n     case 3:\n-      if (!rtx_equal_p (d.op0, d.op1))\n+      if (d.testing_p || !rtx_equal_p (d.op0, d.op1))\n \t{\n \t  d.one_operand_p = false;\n \t  break;\n@@ -11809,6 +11809,22 @@ ia64_expand_vec_perm_const (rtx operands[4])\n       break;\n     }\n \n+  if (d.testing_p)\n+    {\n+      /* We have to go through the motions and see if we can\n+\t figure out how to generate the requested permutation.  */\n+      d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+      d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+      if (!d.one_operand_p)\n+\td.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+      start_sequence ();\n+      bool ret = ia64_expand_vec_perm_const_1 (&d);\n+      end_sequence ();\n+\n+      return ret;\n+    }\n+\n   if (ia64_expand_vec_perm_const_1 (&d))\n     return true;\n \n@@ -11825,51 +11841,6 @@ ia64_expand_vec_perm_const (rtx operands[4])\n   return false;\n }\n \n-/* Implement targetm.vectorize.vec_perm_const_ok.  */\n-\n-static bool\n-ia64_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n-{\n-  struct expand_vec_perm_d d;\n-  unsigned int i, nelt, which;\n-  bool ret;\n-\n-  d.vmode = vmode;\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = true;\n-\n-  /* Extract the values from the vector CST into the permutation\n-     array in D.  */\n-  for (i = which = 0; i < nelt; ++i)\n-    {\n-      unsigned char e = sel[i];\n-      d.perm[i] = e;\n-      gcc_assert (e < 2 * nelt);\n-      which |= (e < nelt ? 1 : 2);\n-    }\n-\n-  /* For all elements from second vector, fold the elements to first.  */\n-  if (which == 2)\n-    for (i = 0; i < nelt; ++i)\n-      d.perm[i] -= nelt;\n-\n-  /* Check whether the mask can be applied to the vector type.  */\n-  d.one_operand_p = (which != 3);\n-\n-  /* Otherwise we have to go through the motions and see if we can\n-     figure out how to generate the requested permutation.  */\n-  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n-  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n-  if (!d.one_operand_p)\n-    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n-\n-  start_sequence ();\n-  ret = ia64_expand_vec_perm_const_1 (&d);\n-  end_sequence ();\n-\n-  return ret;\n-}\n-\n void\n ia64_expand_vec_setv2sf (rtx operands[3])\n {"}, {"sha": "68ac05c0e8ab859312f018552cc1755a3d709d4a", "filename": "gcc/config/ia64/vect.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -1549,19 +1549,6 @@\n   DONE;\n })\n \n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VEC 0 \"register_operand\" \"\")\n-   (match_operand:VEC 1 \"register_operand\" \"\")\n-   (match_operand:VEC 2 \"register_operand\" \"\")\n-   (match_operand:<vecint> 3 \"\" \"\")]\n-  \"\"\n-{\n-  if (ia64_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n ;; Missing operations\n ;; fprcpa\n ;; fpsqrta"}, {"sha": "c75ce2cca5b79ca331f8d3ea5edeb35f94fc50f0", "filename": "gcc/config/mips/loongson.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Floongson.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Floongson.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Floongson.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -784,19 +784,6 @@\n   \"punpcklwd\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fcvt\")])\n \n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VWHB 0 \"register_operand\" \"\")\n-   (match_operand:VWHB 1 \"register_operand\" \"\")\n-   (match_operand:VWHB 2 \"register_operand\" \"\")\n-   (match_operand:VWHB 3 \"\" \"\")]\n-  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-{\n-  if (mips_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_expand \"vec_unpacks_lo_<mode>\"\n   [(match_operand:<V_stretch_half> 0 \"register_operand\" \"\")\n    (match_operand:VHB 1 \"register_operand\" \"\")]"}, {"sha": "73f38d3f5d412bdf9676a1663da5fd8217ff8510", "filename": "gcc/config/mips/mips-msa.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips-msa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips-msa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-msa.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -558,19 +558,6 @@\n   [(set_attr \"type\" \"simd_copy\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:MSA 0 \"register_operand\")\n-   (match_operand:MSA 1 \"register_operand\")\n-   (match_operand:MSA 2 \"register_operand\")\n-   (match_operand:<VIMODE> 3 \"\")]\n-  \"ISA_HAS_MSA\"\n-{\n-  if (mips_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_expand \"abs<mode>2\"\n   [(match_operand:IMSA 0 \"register_operand\" \"=f\")\n    (abs:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\"))]"}, {"sha": "8eab7c581149e287293c5c0e4abc98262beeb32c", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -348,7 +348,6 @@ extern void mips_expand_atomic_qihi (union mips_gen_fn_ptrs,\n \t\t\t\t     rtx, rtx, rtx, rtx);\n \n extern void mips_expand_vector_init (rtx, rtx);\n-extern bool mips_expand_vec_perm_const (rtx op[4]);\n extern void mips_expand_vec_unpack (rtx op[2], bool, bool);\n extern void mips_expand_vec_reduc (rtx, rtx, rtx (*)(rtx, rtx, rtx));\n extern void mips_expand_vec_minmax (rtx, rtx, rtx,"}, {"sha": "05d58e9968f950b7b437691f5eb91ac3ef343f5e", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -164,19 +164,6 @@\n   [(set_attr \"type\" \"fmove\")\n    (set_attr \"mode\" \"SF\")])\n \n-(define_expand \"vec_perm_constv2sf\"\n-  [(match_operand:V2SF 0 \"register_operand\" \"\")\n-   (match_operand:V2SF 1 \"register_operand\" \"\")\n-   (match_operand:V2SF 2 \"register_operand\" \"\")\n-   (match_operand:V2SI 3 \"\" \"\")]\n-  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-{\n-  if (mips_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n ;; Expanders for builtins.  The instruction:\n ;;\n ;;     P[UL][UL].PS <result>, <a>, <b>"}, {"sha": "966e7ce08912fc15ed23d14654d26c08f4905702", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 30, "deletions": 61, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -21379,34 +21379,32 @@ mips_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   return false;\n }\n \n-/* Expand a vec_perm_const pattern.  */\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n-bool\n-mips_expand_vec_perm_const (rtx operands[4])\n+static bool\n+mips_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n+\t\t\t       rtx op1, const vec_perm_indices &sel)\n {\n   struct expand_vec_perm_d d;\n   int i, nelt, which;\n   unsigned char orig_perm[MAX_VECT_LEN];\n-  rtx sel;\n   bool ok;\n \n-  d.target = operands[0];\n-  d.op0 = operands[1];\n-  d.op1 = operands[2];\n-  sel = operands[3];\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n \n-  d.vmode = GET_MODE (d.target);\n-  gcc_assert (VECTOR_MODE_P (d.vmode));\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = false;\n+  d.vmode = vmode;\n+  gcc_assert (VECTOR_MODE_P (vmode));\n+  d.nelt = nelt = GET_MODE_NUNITS (vmode);\n+  d.testing_p = !target;\n \n   /* This is overly conservative, but ensures we don't get an\n      uninitialized warning on ORIG_PERM.  */\n   memset (orig_perm, 0, MAX_VECT_LEN);\n   for (i = which = 0; i < nelt; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      int ei = INTVAL (e) & (2 * nelt - 1);\n+      int ei = sel[i] & (2 * nelt - 1);\n       which |= (ei < nelt ? 1 : 2);\n       orig_perm[i] = ei;\n     }\n@@ -21419,7 +21417,7 @@ mips_expand_vec_perm_const (rtx operands[4])\n \n     case 3:\n       d.one_vector_p = false;\n-      if (!rtx_equal_p (d.op0, d.op1))\n+      if (d.testing_p || !rtx_equal_p (d.op0, d.op1))\n \tbreak;\n       /* FALLTHRU */\n \n@@ -21436,6 +21434,19 @@ mips_expand_vec_perm_const (rtx operands[4])\n       break;\n     }\n \n+  if (d.testing_p)\n+    {\n+      d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+      d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+      if (!d.one_vector_p)\n+\td.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+      start_sequence ();\n+      ok = mips_expand_vec_perm_const_1 (&d);\n+      end_sequence ();\n+      return ok;\n+    }\n+\n   ok = mips_expand_vec_perm_const_1 (&d);\n \n   /* If we were given a two-vector permutation which just happened to\n@@ -21447,8 +21458,8 @@ mips_expand_vec_perm_const (rtx operands[4])\n      the original permutation.  */\n   if (!ok && which == 3)\n     {\n-      d.op0 = operands[1];\n-      d.op1 = operands[2];\n+      d.op0 = op0;\n+      d.op1 = op1;\n       d.one_vector_p = false;\n       memcpy (d.perm, orig_perm, MAX_VECT_LEN);\n       ok = mips_expand_vec_perm_const_1 (&d);\n@@ -21468,48 +21479,6 @@ mips_sched_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n-/* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n-\n-static bool\n-mips_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n-{\n-  struct expand_vec_perm_d d;\n-  unsigned int i, nelt, which;\n-  bool ret;\n-\n-  d.vmode = vmode;\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = true;\n-\n-  /* Categorize the set of elements in the selector.  */\n-  for (i = which = 0; i < nelt; ++i)\n-    {\n-      unsigned char e = sel[i];\n-      d.perm[i] = e;\n-      gcc_assert (e < 2 * nelt);\n-      which |= (e < nelt ? 1 : 2);\n-    }\n-\n-  /* For all elements from second vector, fold the elements to first.  */\n-  if (which == 2)\n-    for (i = 0; i < nelt; ++i)\n-      d.perm[i] -= nelt;\n-\n-  /* Check whether the mask can be applied to the vector type.  */\n-  d.one_vector_p = (which != 3);\n-\n-  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n-  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n-  if (!d.one_vector_p)\n-    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n-\n-  start_sequence ();\n-  ret = mips_expand_vec_perm_const_1 (&d);\n-  end_sequence ();\n-\n-  return ret;\n-}\n-\n /* Expand an integral vector unpack operation.  */\n \n void\n@@ -22591,8 +22560,8 @@ mips_starting_frame_offset (void)\n #undef TARGET_PREPARE_PCH_SAVE\n #define TARGET_PREPARE_PCH_SAVE mips_prepare_pch_save\n \n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK mips_vectorize_vec_perm_const_ok\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST mips_vectorize_vec_perm_const\n \n #undef TARGET_SCHED_REASSOCIATION_WIDTH\n #define TARGET_SCHED_REASSOCIATION_WIDTH mips_sched_reassociation_width"}, {"sha": "2f85e369c3e400bac5066f134cd5bac8ec302c5a", "filename": "gcc/config/powerpcspe/altivec.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -2080,19 +2080,6 @@\n   }\n })\n \n-(define_expand \"vec_perm_constv16qi\"\n-  [(match_operand:V16QI 0 \"register_operand\" \"\")\n-   (match_operand:V16QI 1 \"register_operand\" \"\")\n-   (match_operand:V16QI 2 \"register_operand\" \"\")\n-   (match_operand:V16QI 3 \"\" \"\")]\n-  \"TARGET_ALTIVEC\"\n-{\n-  if (altivec_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_insn \"*altivec_vpermr_<mode>_internal\"\n   [(set (match_operand:VM 0 \"register_operand\" \"=v,?wo\")\n \t(unspec:VM [(match_operand:VM 1 \"register_operand\" \"v,wo\")"}, {"sha": "e950e465861153f223847262d5fc04e5f681ffad", "filename": "gcc/config/powerpcspe/paired.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fpaired.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fpaired.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpaired.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -313,19 +313,6 @@\n   \"ps_merge11 %0, %1, %2\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"vec_perm_constv2sf\"\n-  [(match_operand:V2SF 0 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SF 1 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SF 2 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SI 3 \"\" \"\")]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  if (rs6000_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_insn \"paired_sum0\"\n   [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n \t(vec_concat:V2SF (plus:SF (vec_select:SF"}, {"sha": "b9baae8a6802e1cd8626839873a77e0ffe749a92", "filename": "gcc/config/powerpcspe/powerpcspe-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -64,9 +64,7 @@ extern void rs6000_expand_vector_extract (rtx, rtx, rtx);\n extern void rs6000_split_vec_extract_var (rtx, rtx, rtx, rtx, rtx);\n extern rtx rs6000_adjust_vec_address (rtx, rtx, rtx, rtx, machine_mode);\n extern void rs6000_split_v4si_init (rtx []);\n-extern bool altivec_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_vec_perm_le (rtx op[4]);\n-extern bool rs6000_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_lvx_be (rtx, rtx, machine_mode, unsigned);\n extern void altivec_expand_stvx_be (rtx, rtx, machine_mode, unsigned);\n extern void altivec_expand_stvex_be (rtx, rtx, machine_mode, unsigned);"}, {"sha": "9133125a3ea64b022a9a27bcd7db611a1ec78a52", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 58, "deletions": 67, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -1938,8 +1938,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P rs6000_legitimate_constant_p\n \n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK rs6000_vectorize_vec_perm_const_ok\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST rs6000_vectorize_vec_perm_const\n \n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n@@ -38313,6 +38313,9 @@ rs6000_emit_parity (rtx dst, rtx src)\n }\n \n /* Expand an Altivec constant permutation for little endian mode.\n+   OP0 and OP1 are the input vectors and TARGET is the output vector.\n+   SEL specifies the constant permutation vector.\n+\n    There are two issues: First, the two input operands must be\n    swapped so that together they form a double-wide array in LE\n    order.  Second, the vperm instruction has surprising behavior\n@@ -38354,22 +38357,18 @@ rs6000_emit_parity (rtx dst, rtx src)\n \n    vr9  = 00000006 00000004 00000002 00000000.  */\n \n-void\n-altivec_expand_vec_perm_const_le (rtx operands[4])\n+static void\n+altivec_expand_vec_perm_const_le (rtx target, rtx op0, rtx op1,\n+\t\t\t\t  const vec_perm_indices &sel)\n {\n   unsigned int i;\n   rtx perm[16];\n   rtx constv, unspec;\n-  rtx target = operands[0];\n-  rtx op0 = operands[1];\n-  rtx op1 = operands[2];\n-  rtx sel = operands[3];\n \n   /* Unpack and adjust the constant selector.  */\n   for (i = 0; i < 16; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      unsigned int elt = 31 - (INTVAL (e) & 31);\n+      unsigned int elt = 31 - (sel[i] & 31);\n       perm[i] = GEN_INT (elt);\n     }\n \n@@ -38451,10 +38450,14 @@ altivec_expand_vec_perm_le (rtx operands[4])\n }\n \n /* Expand an Altivec constant permutation.  Return true if we match\n-   an efficient implementation; false to fall back to VPERM.  */\n+   an efficient implementation; false to fall back to VPERM.\n \n-bool\n-altivec_expand_vec_perm_const (rtx operands[4])\n+   OP0 and OP1 are the input vectors and TARGET is the output vector.\n+   SEL specifies the constant permutation vector.  */\n+\n+static bool\n+altivec_expand_vec_perm_const (rtx target, rtx op0, rtx op1,\n+\t\t\t       const vec_perm_indices &sel)\n {\n   struct altivec_perm_insn {\n     HOST_WIDE_INT mask;\n@@ -38498,19 +38501,13 @@ altivec_expand_vec_perm_const (rtx operands[4])\n \n   unsigned int i, j, elt, which;\n   unsigned char perm[16];\n-  rtx target, op0, op1, sel, x;\n+  rtx x;\n   bool one_vec;\n \n-  target = operands[0];\n-  op0 = operands[1];\n-  op1 = operands[2];\n-  sel = operands[3];\n-\n   /* Unpack the constant selector.  */\n   for (i = which = 0; i < 16; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      elt = INTVAL (e) & 31;\n+      elt = sel[i] & 31;\n       which |= (elt < 16 ? 1 : 2);\n       perm[i] = elt;\n     }\n@@ -38666,7 +38663,7 @@ altivec_expand_vec_perm_const (rtx operands[4])\n \n   if (!BYTES_BIG_ENDIAN)\n     {\n-      altivec_expand_vec_perm_const_le (operands);\n+      altivec_expand_vec_perm_const_le (target, op0, op1, sel);\n       return true;\n     }\n \n@@ -38726,60 +38723,54 @@ rs6000_expand_vec_perm_const_1 (rtx target, rtx op0, rtx op1,\n   return true;\n }\n \n-bool\n-rs6000_expand_vec_perm_const (rtx operands[4])\n-{\n-  rtx target, op0, op1, sel;\n-  unsigned char perm0, perm1;\n-\n-  target = operands[0];\n-  op0 = operands[1];\n-  op1 = operands[2];\n-  sel = operands[3];\n-\n-  /* Unpack the constant selector.  */\n-  perm0 = INTVAL (XVECEXP (sel, 0, 0)) & 3;\n-  perm1 = INTVAL (XVECEXP (sel, 0, 1)) & 3;\n-\n-  return rs6000_expand_vec_perm_const_1 (target, op0, op1, perm0, perm1);\n-}\n-\n-/* Test whether a constant permutation is supported.  */\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n static bool\n-rs6000_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n+rs6000_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n+\t\t\t\t rtx op1, const vec_perm_indices &sel)\n {\n+  bool testing_p = !target;\n+\n   /* AltiVec (and thus VSX) can handle arbitrary permutations.  */\n-  if (TARGET_ALTIVEC)\n+  if (TARGET_ALTIVEC && testing_p)\n     return true;\n \n-  /* Check for ps_merge* or evmerge* insns.  */\n-  if ((TARGET_PAIRED_FLOAT && vmode == V2SFmode)\n-      || (TARGET_SPE && vmode == V2SImode))\n+  /* Check for ps_merge*, evmerge* or xxperm* insns.  */\n+  if ((vmode == V2SFmode && TARGET_PAIRED_FLOAT)\n+      || (vmode == V2SImode && TARGET_SPE)\n+      || ((vmode == V2DFmode || vmode == V2DImode)\n+\t  && VECTOR_MEM_VSX_P (vmode)))\n+    {\n+      if (testing_p)\n+\t{\n+\t  op0 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 1);\n+\t  op1 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 2);\n+\t}\n+      if (rs6000_expand_vec_perm_const_1 (target, op0, op1, sel[0], sel[1]))\n+\treturn true;\n+    }\n+\n+  if (TARGET_ALTIVEC)\n     {\n-      rtx op0 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 1);\n-      rtx op1 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 2);\n-      return rs6000_expand_vec_perm_const_1 (NULL, op0, op1, sel[0], sel[1]);\n+      /* Force the target-independent code to lower to V16QImode.  */\n+      if (vmode != V16QImode)\n+\treturn false;\n+      if (altivec_expand_vec_perm_const (target, op0, op1, sel))\n+\treturn true;\n     }\n \n   return false;\n }\n \n-/* A subroutine for rs6000_expand_extract_even & rs6000_expand_interleave.  */\n+/* A subroutine for rs6000_expand_extract_even & rs6000_expand_interleave.\n+   OP0 and OP1 are the input vectors and TARGET is the output vector.\n+   PERM specifies the constant permutation vector.  */\n \n static void\n rs6000_do_expand_vec_perm (rtx target, rtx op0, rtx op1,\n-\t\t\t   machine_mode vmode, unsigned nelt, rtx perm[])\n+\t\t\t   machine_mode vmode, const vec_perm_builder &perm)\n {\n-  machine_mode imode;\n-  rtx x;\n-\n-  imode = vmode;\n-  if (GET_MODE_CLASS (vmode) != MODE_VECTOR_INT)\n-    imode = mode_for_int_vector (vmode).require ();\n-\n-  x = gen_rtx_CONST_VECTOR (imode, gen_rtvec_v (nelt, perm));\n-  x = expand_vec_perm (vmode, op0, op1, x, target);\n+  rtx x = expand_vec_perm_const (vmode, op0, op1, perm, BLKmode, target);\n   if (x != target)\n     emit_move_insn (target, x);\n }\n@@ -38791,12 +38782,12 @@ rs6000_expand_extract_even (rtx target, rtx op0, rtx op1)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, nelt = GET_MODE_NUNITS (vmode);\n-  rtx perm[16];\n+  vec_perm_builder perm (nelt);\n \n   for (i = 0; i < nelt; i++)\n-    perm[i] = GEN_INT (i * 2);\n+    perm.quick_push (i * 2);\n \n-  rs6000_do_expand_vec_perm (target, op0, op1, vmode, nelt, perm);\n+  rs6000_do_expand_vec_perm (target, op0, op1, vmode, perm);\n }\n \n /* Expand a vector interleave operation.  */\n@@ -38806,16 +38797,16 @@ rs6000_expand_interleave (rtx target, rtx op0, rtx op1, bool highp)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, high, nelt = GET_MODE_NUNITS (vmode);\n-  rtx perm[16];\n+  vec_perm_builder perm (nelt);\n \n   high = (highp ? 0 : nelt / 2);\n   for (i = 0; i < nelt / 2; i++)\n     {\n-      perm[i * 2] = GEN_INT (i + high);\n-      perm[i * 2 + 1] = GEN_INT (i + nelt + high);\n+      perm.quick_push (i + high);\n+      perm.quick_push (i + nelt + high);\n     }\n \n-  rs6000_do_expand_vec_perm (target, op0, op1, vmode, nelt, perm);\n+  rs6000_do_expand_vec_perm (target, op0, op1, vmode, perm);\n }\n \n /* Scale a V2DF vector SRC by two to the SCALE and place in TGT.  */"}, {"sha": "56acfdd86d0ce6e5f6e42c82fb53c12a2a93e809", "filename": "gcc/config/powerpcspe/spe.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fspe.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -511,19 +511,6 @@\n   [(set_attr \"type\" \"vecsimple\")\n    (set_attr  \"length\" \"4\")])\n \n-(define_expand \"vec_perm_constv2si\"\n-  [(match_operand:V2SI 0 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SI 1 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SI 2 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SI 3 \"\" \"\")]\n-  \"TARGET_SPE\"\n-{\n-  if (rs6000_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_expand \"spe_evmergehi\"\n   [(match_operand:V2SI 0 \"register_operand\" \"\")\n    (match_operand:V2SI 1 \"register_operand\" \"\")"}, {"sha": "794ff446b8a2eeb2a58c8774545a2a9f463ac736", "filename": "gcc/config/powerpcspe/vsx.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fpowerpcspe%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fvsx.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -2543,19 +2543,6 @@\n }\n   [(set_attr \"type\" \"vecperm\")])\n \n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VSX_D 0 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_D 1 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_D 2 \"vsx_register_operand\" \"\")\n-   (match_operand:V2DI  3 \"\" \"\")]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n-{\n-  if (rs6000_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n ;; Extraction of a single element in a small integer vector.  Until ISA 3.0,\n ;; none of the small types were allowed in a vector register, so we had to\n ;; extract to a DImode and either do a direct move or store."}, {"sha": "5d10c82910334e8eb97a84eebf9ea8635d225563", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -2198,19 +2198,6 @@\n   }\n })\n \n-(define_expand \"vec_perm_constv16qi\"\n-  [(match_operand:V16QI 0 \"register_operand\" \"\")\n-   (match_operand:V16QI 1 \"register_operand\" \"\")\n-   (match_operand:V16QI 2 \"register_operand\" \"\")\n-   (match_operand:V16QI 3 \"\" \"\")]\n-  \"TARGET_ALTIVEC\"\n-{\n-  if (altivec_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_insn \"*altivec_vpermr_<mode>_internal\"\n   [(set (match_operand:VM 0 \"register_operand\" \"=v,?wo\")\n \t(unspec:VM [(match_operand:VM 1 \"register_operand\" \"v,wo\")"}, {"sha": "584a791d43198a37316c04a772f79cb8c0f43a56", "filename": "gcc/config/rs6000/paired.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Fpaired.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Fpaired.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpaired.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -313,19 +313,6 @@\n   \"ps_merge11 %0, %1, %2\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"vec_perm_constv2sf\"\n-  [(match_operand:V2SF 0 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SF 1 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SF 2 \"gpc_reg_operand\" \"\")\n-   (match_operand:V2SI 3 \"\" \"\")]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  if (rs6000_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n (define_insn \"paired_sum0\"\n   [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n \t(vec_concat:V2SF (plus:SF (vec_select:SF"}, {"sha": "90107ea88217146722ef9f80232c7e8b2be572ca", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -63,9 +63,7 @@ extern void rs6000_expand_vector_extract (rtx, rtx, rtx);\n extern void rs6000_split_vec_extract_var (rtx, rtx, rtx, rtx, rtx);\n extern rtx rs6000_adjust_vec_address (rtx, rtx, rtx, rtx, machine_mode);\n extern void rs6000_split_v4si_init (rtx []);\n-extern bool altivec_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_vec_perm_le (rtx op[4]);\n-extern bool rs6000_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_lvx_be (rtx, rtx, machine_mode, unsigned);\n extern void altivec_expand_stvx_be (rtx, rtx, machine_mode, unsigned);\n extern void altivec_expand_stvex_be (rtx, rtx, machine_mode, unsigned);"}, {"sha": "7d10b44fff98891c501bb99477a4b902e256a738", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 57, "deletions": 66, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -1910,8 +1910,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P rs6000_legitimate_constant_p\n \n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK rs6000_vectorize_vec_perm_const_ok\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST rs6000_vectorize_vec_perm_const\n \n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n@@ -35570,6 +35570,9 @@ rs6000_emit_parity (rtx dst, rtx src)\n }\n \n /* Expand an Altivec constant permutation for little endian mode.\n+   OP0 and OP1 are the input vectors and TARGET is the output vector.\n+   SEL specifies the constant permutation vector.\n+\n    There are two issues: First, the two input operands must be\n    swapped so that together they form a double-wide array in LE\n    order.  Second, the vperm instruction has surprising behavior\n@@ -35611,22 +35614,18 @@ rs6000_emit_parity (rtx dst, rtx src)\n \n    vr9  = 00000006 00000004 00000002 00000000.  */\n \n-void\n-altivec_expand_vec_perm_const_le (rtx operands[4])\n+static void\n+altivec_expand_vec_perm_const_le (rtx target, rtx op0, rtx op1,\n+\t\t\t\t  const vec_perm_indices &sel)\n {\n   unsigned int i;\n   rtx perm[16];\n   rtx constv, unspec;\n-  rtx target = operands[0];\n-  rtx op0 = operands[1];\n-  rtx op1 = operands[2];\n-  rtx sel = operands[3];\n \n   /* Unpack and adjust the constant selector.  */\n   for (i = 0; i < 16; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      unsigned int elt = 31 - (INTVAL (e) & 31);\n+      unsigned int elt = 31 - (sel[i] & 31);\n       perm[i] = GEN_INT (elt);\n     }\n \n@@ -35708,10 +35707,14 @@ altivec_expand_vec_perm_le (rtx operands[4])\n }\n \n /* Expand an Altivec constant permutation.  Return true if we match\n-   an efficient implementation; false to fall back to VPERM.  */\n+   an efficient implementation; false to fall back to VPERM.\n \n-bool\n-altivec_expand_vec_perm_const (rtx operands[4])\n+   OP0 and OP1 are the input vectors and TARGET is the output vector.\n+   SEL specifies the constant permutation vector.  */\n+\n+static bool\n+altivec_expand_vec_perm_const (rtx target, rtx op0, rtx op1,\n+\t\t\t       const vec_perm_indices &sel)\n {\n   struct altivec_perm_insn {\n     HOST_WIDE_INT mask;\n@@ -35759,19 +35762,13 @@ altivec_expand_vec_perm_const (rtx operands[4])\n \n   unsigned int i, j, elt, which;\n   unsigned char perm[16];\n-  rtx target, op0, op1, sel, x;\n+  rtx x;\n   bool one_vec;\n \n-  target = operands[0];\n-  op0 = operands[1];\n-  op1 = operands[2];\n-  sel = operands[3];\n-\n   /* Unpack the constant selector.  */\n   for (i = which = 0; i < 16; ++i)\n     {\n-      rtx e = XVECEXP (sel, 0, i);\n-      elt = INTVAL (e) & 31;\n+      elt = sel[i] & 31;\n       which |= (elt < 16 ? 1 : 2);\n       perm[i] = elt;\n     }\n@@ -35927,7 +35924,7 @@ altivec_expand_vec_perm_const (rtx operands[4])\n \n   if (!BYTES_BIG_ENDIAN)\n     {\n-      altivec_expand_vec_perm_const_le (operands);\n+      altivec_expand_vec_perm_const_le (target, op0, op1, sel);\n       return true;\n     }\n \n@@ -35987,59 +35984,53 @@ rs6000_expand_vec_perm_const_1 (rtx target, rtx op0, rtx op1,\n   return true;\n }\n \n-bool\n-rs6000_expand_vec_perm_const (rtx operands[4])\n-{\n-  rtx target, op0, op1, sel;\n-  unsigned char perm0, perm1;\n-\n-  target = operands[0];\n-  op0 = operands[1];\n-  op1 = operands[2];\n-  sel = operands[3];\n-\n-  /* Unpack the constant selector.  */\n-  perm0 = INTVAL (XVECEXP (sel, 0, 0)) & 3;\n-  perm1 = INTVAL (XVECEXP (sel, 0, 1)) & 3;\n-\n-  return rs6000_expand_vec_perm_const_1 (target, op0, op1, perm0, perm1);\n-}\n-\n-/* Test whether a constant permutation is supported.  */\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n static bool\n-rs6000_vectorize_vec_perm_const_ok (machine_mode vmode, vec_perm_indices sel)\n+rs6000_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n+\t\t\t\t rtx op1, const vec_perm_indices &sel)\n {\n+  bool testing_p = !target;\n+\n   /* AltiVec (and thus VSX) can handle arbitrary permutations.  */\n-  if (TARGET_ALTIVEC)\n+  if (TARGET_ALTIVEC && testing_p)\n     return true;\n \n-  /* Check for ps_merge* or evmerge* insns.  */\n-  if (TARGET_PAIRED_FLOAT && vmode == V2SFmode)\n+  /* Check for ps_merge* or xxpermdi insns.  */\n+  if ((vmode == V2SFmode && TARGET_PAIRED_FLOAT)\n+      || ((vmode == V2DFmode || vmode == V2DImode)\n+\t  && VECTOR_MEM_VSX_P (vmode)))\n+    {\n+      if (testing_p)\n+\t{\n+\t  op0 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 1);\n+\t  op1 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 2);\n+\t}\n+      if (rs6000_expand_vec_perm_const_1 (target, op0, op1, sel[0], sel[1]))\n+\treturn true;\n+    }\n+\n+  if (TARGET_ALTIVEC)\n     {\n-      rtx op0 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 1);\n-      rtx op1 = gen_raw_REG (vmode, LAST_VIRTUAL_REGISTER + 2);\n-      return rs6000_expand_vec_perm_const_1 (NULL, op0, op1, sel[0], sel[1]);\n+      /* Force the target-independent code to lower to V16QImode.  */\n+      if (vmode != V16QImode)\n+\treturn false;\n+      if (altivec_expand_vec_perm_const (target, op0, op1, sel))\n+\treturn true;\n     }\n \n   return false;\n }\n \n-/* A subroutine for rs6000_expand_extract_even & rs6000_expand_interleave.  */\n+/* A subroutine for rs6000_expand_extract_even & rs6000_expand_interleave.\n+   OP0 and OP1 are the input vectors and TARGET is the output vector.\n+   PERM specifies the constant permutation vector.  */\n \n static void\n rs6000_do_expand_vec_perm (rtx target, rtx op0, rtx op1,\n-\t\t\t   machine_mode vmode, unsigned nelt, rtx perm[])\n+\t\t\t   machine_mode vmode, const vec_perm_builder &perm)\n {\n-  machine_mode imode;\n-  rtx x;\n-\n-  imode = vmode;\n-  if (GET_MODE_CLASS (vmode) != MODE_VECTOR_INT)\n-    imode = mode_for_int_vector (vmode).require ();\n-\n-  x = gen_rtx_CONST_VECTOR (imode, gen_rtvec_v (nelt, perm));\n-  x = expand_vec_perm (vmode, op0, op1, x, target);\n+  rtx x = expand_vec_perm_const (vmode, op0, op1, perm, BLKmode, target);\n   if (x != target)\n     emit_move_insn (target, x);\n }\n@@ -36051,12 +36042,12 @@ rs6000_expand_extract_even (rtx target, rtx op0, rtx op1)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, nelt = GET_MODE_NUNITS (vmode);\n-  rtx perm[16];\n+  vec_perm_builder perm (nelt);\n \n   for (i = 0; i < nelt; i++)\n-    perm[i] = GEN_INT (i * 2);\n+    perm.quick_push (i * 2);\n \n-  rs6000_do_expand_vec_perm (target, op0, op1, vmode, nelt, perm);\n+  rs6000_do_expand_vec_perm (target, op0, op1, vmode, perm);\n }\n \n /* Expand a vector interleave operation.  */\n@@ -36066,16 +36057,16 @@ rs6000_expand_interleave (rtx target, rtx op0, rtx op1, bool highp)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, high, nelt = GET_MODE_NUNITS (vmode);\n-  rtx perm[16];\n+  vec_perm_builder perm (nelt);\n \n   high = (highp ? 0 : nelt / 2);\n   for (i = 0; i < nelt / 2; i++)\n     {\n-      perm[i * 2] = GEN_INT (i + high);\n-      perm[i * 2 + 1] = GEN_INT (i + nelt + high);\n+      perm.quick_push (i + high);\n+      perm.quick_push (i + nelt + high);\n     }\n \n-  rs6000_do_expand_vec_perm (target, op0, op1, vmode, nelt, perm);\n+  rs6000_do_expand_vec_perm (target, op0, op1, vmode, perm);\n }\n \n /* Scale a V2DF vector SRC by two to the SCALE and place in TGT.  */"}, {"sha": "7c6bb17a33bcd720de72188b6b72313ab079424e", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -3189,19 +3189,6 @@\n }\n   [(set_attr \"type\" \"vecperm\")])\n \n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VSX_D 0 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_D 1 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_D 2 \"vsx_register_operand\" \"\")\n-   (match_operand:V2DI  3 \"\" \"\")]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n-{\n-  if (rs6000_expand_vec_perm_const (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n ;; Extraction of a single element in a small integer vector.  Until ISA 3.0,\n ;; none of the small types were allowed in a vector register, so we had to\n ;; extract to a DImode and either do a direct move or store."}, {"sha": "62bc492229e9486eb305bc09d00249114c92e527", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -688,6 +688,8 @@ static bool sparc_modes_tieable_p (machine_mode, machine_mode);\n static bool sparc_can_change_mode_class (machine_mode, machine_mode,\n \t\t\t\t\t reg_class_t);\n static HOST_WIDE_INT sparc_constant_alignment (const_tree, HOST_WIDE_INT);\n+static bool sparc_vectorize_vec_perm_const (machine_mode, rtx, rtx, rtx,\n+\t\t\t\t\t    const vec_perm_indices &);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -932,6 +934,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_CONSTANT_ALIGNMENT\n #define TARGET_CONSTANT_ALIGNMENT sparc_constant_alignment\n \n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST sparc_vectorize_vec_perm_const\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Return the memory reference contained in X if any, zero otherwise.  */\n@@ -12813,6 +12818,32 @@ sparc_expand_vec_perm_bmask (machine_mode vmode, rtx sel)\n   emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), sel, t_1));\n }\n \n+/* Implement TARGET_VEC_PERM_CONST.  */\n+\n+static bool\n+sparc_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n+\t\t\t\trtx op1, const vec_perm_indices &sel)\n+{\n+  /* All permutes are supported.  */\n+  if (!target)\n+    return true;\n+\n+  /* Force target-independent code to convert constant permutations on other\n+     modes down to V8QI.  Rely on this to avoid the complexity of the byte\n+     order of the permutation.  */\n+  if (vmode != V8QImode)\n+    return false;\n+\n+  unsigned int i, mask;\n+  for (i = mask = 0; i < 8; ++i)\n+    mask |= (sel[i] & 0xf) << (28 - i*4);\n+  rtx mask_rtx = force_reg (SImode, gen_int_mode (mask, SImode));\n+\n+  emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), mask_rtx, const0_rtx));\n+  emit_insn (gen_bshufflev8qi_vis (target, op0, op1));\n+  return true;\n+}\n+\n /* Implement TARGET_FRAME_POINTER_REQUIRED.  */\n \n static bool"}, {"sha": "f7dff43564231082c1c9cfe72b6a1ec7b9bb85ef", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -9327,28 +9327,6 @@ visl\")\n    (set_attr \"subtype\" \"other\")\n    (set_attr \"fptype\" \"double\")])\n \n-;; The rtl expanders will happily convert constant permutations on other\n-;; modes down to V8QI.  Rely on this to avoid the complexity of the byte\n-;; order of the permutation.\n-(define_expand \"vec_perm_constv8qi\"\n-  [(match_operand:V8QI 0 \"register_operand\" \"\")\n-   (match_operand:V8QI 1 \"register_operand\" \"\")\n-   (match_operand:V8QI 2 \"register_operand\" \"\")\n-   (match_operand:V8QI 3 \"\" \"\")]\n-  \"TARGET_VIS2\"\n-{\n-  unsigned int i, mask;\n-  rtx sel = operands[3];\n-\n-  for (i = mask = 0; i < 8; ++i)\n-    mask |= (INTVAL (XVECEXP (sel, 0, i)) & 0xf) << (28 - i*4);\n-  sel = force_reg (SImode, gen_int_mode (mask, SImode));\n-\n-  emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), sel, const0_rtx));\n-  emit_insn (gen_bshufflev8qi_vis (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n ;; Unlike constant permutation, we can vastly simplify the compression of\n ;; the 64-bit selector input to the 32-bit %gsr value by knowing what the\n ;; width of the input is."}, {"sha": "85c180082ee1b56bd125476799920916a5fa04ee", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -4996,20 +4996,8 @@ where @var{q} is a vector of @code{QImode} of the same width as @var{m},\n the middle-end will lower the mode @var{m} @code{VEC_PERM_EXPR} to\n mode @var{q}.\n \n-@cindex @code{vec_perm_const@var{m}} instruction pattern\n-@item @samp{vec_perm_const@var{m}}\n-Like @samp{vec_perm} except that the permutation is a compile-time\n-constant.  That is, operand 3, the @dfn{selector}, is a @code{CONST_VECTOR}.\n-\n-Some targets cannot perform a permutation with a variable selector,\n-but can efficiently perform a constant permutation.  Further, the\n-target hook @code{vec_perm_ok} is queried to determine if the \n-specific constant permutation is available efficiently; the named\n-pattern is never expanded without @code{vec_perm_ok} returning true.\n-\n-There is no need for a target to supply both @samp{vec_perm@var{m}}\n-and @samp{vec_perm_const@var{m}} if the former can trivially implement\n-the operation with, say, the vector constant loaded into a register.\n+See also @code{TARGET_VECTORIZER_VEC_PERM_CONST}, which performs\n+the analogous operation for constant selectors.\n \n @cindex @code{push@var{m}1} instruction pattern\n @item @samp{push@var{m}1}"}, {"sha": "9793a0ed230b3aba068da223eff54b21dcb8fe3e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -5811,8 +5811,24 @@ correct for most targets.\n Return true if vector alignment is reachable (by peeling N iterations) for the given scalar type @var{type}.  @var{is_packed} is false if the scalar access using @var{type} is known to be naturally aligned.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST_OK (machine_mode, @var{vec_perm_indices})\n-Return true if a vector created for @code{vec_perm_const} is valid.\n+@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST (machine_mode @var{mode}, rtx @var{output}, rtx @var{in0}, rtx @var{in1}, const vec_perm_indices @var{&sel})\n+This hook is used to test whether the target can permute up to two\n+vectors of mode @var{mode} using the permutation vector @code{sel}, and\n+also to emit such a permutation.  In the former case @var{in0}, @var{in1}\n+and @var{out} are all null.  In the latter case @var{in0} and @var{in1} are\n+the source vectors and @var{out} is the destination vector; all three are\n+registers of mode @var{mode}.  @var{in1} is the same as @var{in0} if\n+@var{sel} describes a permutation on one vector instead of two.\n+\n+Return true if the operation is possible, emitting instructions for it\n+if rtxes are provided.\n+\n+@cindex @code{vec_perm@var{m}} instruction pattern\n+If the hook returns false for a mode with multibyte elements, GCC will\n+try the equivalent byte operation.  If that also fails, it will try forcing\n+the selector into a register and using the @var{vec_perm@var{mode}}\n+instruction pattern.  There is no need for the hook to handle these two\n+implementation approaches itself.\n @end deftypefn\n \n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_CONVERSION (unsigned @var{code}, tree @var{dest_type}, tree @var{src_type})"}, {"sha": "7bcfb37572a39917fc05efb564ac07111e5dd67e", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -4081,7 +4081,7 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n \n-@hook TARGET_VECTORIZE_VEC_PERM_CONST_OK\n+@hook TARGET_VECTORIZE_VEC_PERM_CONST\n \n @hook TARGET_VECTORIZE_BUILTIN_CONVERSION\n "}, {"sha": "74a32802bc48279d1bbc020eedda3b261cb8d15e", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -9515,28 +9515,24 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       goto binop;\n \n     case VEC_PERM_EXPR:\n-      expand_operands (treeop0, treeop1, target, &op0, &op1, EXPAND_NORMAL);\n-      op2 = expand_normal (treeop2);\n-\n-      /* Careful here: if the target doesn't support integral vector modes,\n-\t a constant selection vector could wind up smooshed into a normal\n-\t integral constant.  */\n-      if (CONSTANT_P (op2) && !VECTOR_MODE_P (GET_MODE (op2)))\n-\t{\n-\t  tree sel_type = TREE_TYPE (treeop2);\n-\t  machine_mode vmode\n-\t    = mode_for_vector (SCALAR_TYPE_MODE (TREE_TYPE (sel_type)),\n-\t\t\t       TYPE_VECTOR_SUBPARTS (sel_type)).require ();\n-\t  gcc_assert (GET_MODE_CLASS (vmode) == MODE_VECTOR_INT);\n-\t  op2 = simplify_subreg (vmode, op2, TYPE_MODE (sel_type), 0);\n-\t  gcc_assert (op2 && GET_CODE (op2) == CONST_VECTOR);\n-\t}\n-      else\n-        gcc_assert (GET_MODE_CLASS (GET_MODE (op2)) == MODE_VECTOR_INT);\n-\n-      temp = expand_vec_perm (mode, op0, op1, op2, target);\n-      gcc_assert (temp);\n-      return temp;\n+      {\n+\texpand_operands (treeop0, treeop1, target, &op0, &op1, EXPAND_NORMAL);\n+\tvec_perm_builder sel;\n+\tif (TREE_CODE (treeop2) == VECTOR_CST\n+\t    && tree_to_vec_perm_builder (&sel, treeop2))\n+\t  {\n+\t    machine_mode sel_mode = TYPE_MODE (TREE_TYPE (treeop2));\n+\t    temp = expand_vec_perm_const (mode, op0, op1, sel,\n+\t\t\t\t\t  sel_mode, target);\n+\t  }\n+\telse\n+\t  {\n+\t    op2 = expand_normal (treeop2);\n+\t    temp = expand_vec_perm_var (mode, op0, op1, op2, target);\n+\t  }\n+\tgcc_assert (temp);\n+\treturn temp;\n+      }\n \n     case DOT_PROD_EXPR:\n       {"}, {"sha": "421bdd3c68ed7f43ad3740f6a1914721cfa19468", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -82,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n \n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */"}, {"sha": "4060b4fc4db6578faa202facfd64472937113b5f", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-config.h\"\n #include \"rtl.h\"\n #include \"recog.h\"\n+#include \"vec-perm-indices.h\"\n \n struct target_optabs default_target_optabs;\n struct target_optabs *this_fn_optabs = &default_target_optabs;\n@@ -361,6 +362,17 @@ qimode_for_vec_perm (machine_mode mode)\n   return opt_machine_mode ();\n }\n \n+/* Return true if selector SEL can be represented in the integer\n+   equivalent of vector mode MODE.  */\n+\n+bool\n+selector_fits_mode_p (machine_mode mode, const vec_perm_indices &sel)\n+{\n+  unsigned HOST_WIDE_INT mask = GET_MODE_MASK (GET_MODE_INNER (mode));\n+  return (mask == HOST_WIDE_INT_M1U\n+\t  || sel.all_in_range_p (0, mask + 1));\n+}\n+\n /* Return true if VEC_PERM_EXPRs with variable selector operands can be\n    expanded using SIMD extensions of the CPU.  MODE is the mode of the\n    vectors being permuted.  */\n@@ -415,7 +427,7 @@ can_vec_perm_const_p (machine_mode mode, const vec_perm_indices &sel,\n     return false;\n \n   /* It's probably cheaper to test for the variable case first.  */\n-  if (allow_variable_p)\n+  if (allow_variable_p && selector_fits_mode_p (mode, sel))\n     {\n       if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n \treturn true;\n@@ -424,20 +436,28 @@ can_vec_perm_const_p (machine_mode mode, const vec_perm_indices &sel,\n \t related computing the QImode selector, since that happens at\n \t compile time.  */\n       machine_mode qimode;\n-      if (qimode_for_vec_perm (mode).exists (&qimode)\n-\t  && direct_optab_handler (vec_perm_optab, qimode) != CODE_FOR_nothing)\n-\treturn true;\n+      if (qimode_for_vec_perm (mode).exists (&qimode))\n+\t{\n+\t  vec_perm_indices qimode_indices;\n+\t  qimode_indices.new_expanded_vector (sel, GET_MODE_UNIT_SIZE (mode));\n+\t  if (selector_fits_mode_p (qimode, qimode_indices)\n+\t      && (direct_optab_handler (vec_perm_optab, qimode)\n+\t\t  != CODE_FOR_nothing))\n+\t    return true;\n+\t}\n     }\n \n-  if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing)\n+  if (targetm.vectorize.vec_perm_const != NULL)\n     {\n-      if (targetm.vectorize.vec_perm_const_ok == NULL\n-\t  || targetm.vectorize.vec_perm_const_ok (mode, sel))\n+      if (targetm.vectorize.vec_perm_const (mode, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t    NULL_RTX, sel))\n \treturn true;\n \n       /* ??? For completeness, we ought to check the QImode version of\n \t vec_perm_const_optab.  But all users of this implicit lowering\n-\t feature implement the variable vec_perm_optab.  */\n+\t feature implement the variable vec_perm_optab, and the ia64\n+\t port specifically doesn't want us to lower V2SF operations\n+\t into integer operations.  */\n     }\n \n   return false;"}, {"sha": "5b9d0721f364b2af93a0e24146a6c3263e459771", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -175,6 +175,7 @@ enum insn_code can_float_p (machine_mode, machine_mode, int);\n enum insn_code can_fix_p (machine_mode, machine_mode, int, bool *);\n bool can_conditionally_move_p (machine_mode mode);\n opt_machine_mode qimode_for_vec_perm (machine_mode);\n+bool selector_fits_mode_p (machine_mode, const vec_perm_indices &);\n bool can_vec_perm_var_p (machine_mode);\n bool can_vec_perm_const_p (machine_mode, const vec_perm_indices &,\n \t\t\t   bool = true);"}, {"sha": "9099ba2914321ad41751eb30b3526cd0d66f307d", "filename": "gcc/optabs.c", "status": "modified", "additions": 83, "deletions": 78, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -5387,35 +5387,33 @@ vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n   return gen_rtx_fmt_ee (rcode, cmp_mode, ops[0].value, ops[1].value);\n }\n \n-/* Checks if vec_perm mask SEL is a constant equivalent to a shift of the first\n-   vec_perm operand, assuming the second operand is a constant vector of zeroes.\n-   Return the shift distance in bits if so, or NULL_RTX if the vec_perm is not a\n-   shift.  */\n+/* Check if vec_perm mask SEL is a constant equivalent to a shift of\n+   the first vec_perm operand, assuming the second operand is a constant\n+   vector of zeros.  Return the shift distance in bits if so, or NULL_RTX\n+   if the vec_perm is not a shift.  MODE is the mode of the value being\n+   shifted.  */\n static rtx\n-shift_amt_for_vec_perm_mask (rtx sel)\n+shift_amt_for_vec_perm_mask (machine_mode mode, const vec_perm_indices &sel)\n {\n-  unsigned int i, first, nelt = GET_MODE_NUNITS (GET_MODE (sel));\n-  unsigned int bitsize = GET_MODE_UNIT_BITSIZE (GET_MODE (sel));\n+  unsigned int i, first, nelt = GET_MODE_NUNITS (mode);\n+  unsigned int bitsize = GET_MODE_UNIT_BITSIZE (mode);\n \n-  if (GET_CODE (sel) != CONST_VECTOR)\n-    return NULL_RTX;\n-\n-  first = INTVAL (CONST_VECTOR_ELT (sel, 0));\n+  first = sel[0];\n   if (first >= nelt)\n     return NULL_RTX;\n   for (i = 1; i < nelt; i++)\n     {\n-      int idx = INTVAL (CONST_VECTOR_ELT (sel, i));\n+      int idx = sel[i];\n       unsigned int expected = i + first;\n       /* Indices into the second vector are all equivalent.  */\n       if (idx < 0 || (MIN (nelt, (unsigned) idx) != MIN (nelt, expected)))\n \treturn NULL_RTX;\n     }\n \n-  return gen_int_shift_amount (GET_MODE (sel), first * bitsize);\n+  return gen_int_shift_amount (mode, first * bitsize);\n }\n \n-/* A subroutine of expand_vec_perm for expanding one vec_perm insn.  */\n+/* A subroutine of expand_vec_perm_var for expanding one vec_perm insn.  */\n \n static rtx\n expand_vec_perm_1 (enum insn_code icode, rtx target,\n@@ -5453,38 +5451,32 @@ expand_vec_perm_1 (enum insn_code icode, rtx target,\n   return NULL_RTX;\n }\n \n-static rtx expand_vec_perm_var (machine_mode, rtx, rtx, rtx, rtx);\n-\n /* Implement a permutation of vectors v0 and v1 using the permutation\n    vector in SEL and return the result.  Use TARGET to hold the result\n    if nonnull and convenient.\n \n-   MODE is the mode of the vectors being permuted (V0 and V1).  */\n+   MODE is the mode of the vectors being permuted (V0 and V1).  SEL_MODE\n+   is the TYPE_MODE associated with SEL, or BLKmode if SEL isn't known\n+   to have a particular mode.  */\n \n rtx\n-expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n+expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n+\t\t       const vec_perm_builder &sel, machine_mode sel_mode,\n+\t\t       rtx target)\n {\n-  enum insn_code icode;\n-  machine_mode qimode;\n-  unsigned int i, w, e, u;\n-  rtx tmp, sel_qi = NULL;\n-  rtvec vec;\n-\n-  if (GET_CODE (sel) != CONST_VECTOR)\n-    return expand_vec_perm_var (mode, v0, v1, sel, target);\n-\n-  if (!target || GET_MODE (target) != mode)\n+  if (!target || !register_operand (target, mode))\n     target = gen_reg_rtx (mode);\n \n-  w = GET_MODE_SIZE (mode);\n-  e = GET_MODE_NUNITS (mode);\n-  u = GET_MODE_UNIT_SIZE (mode);\n-\n   /* Set QIMODE to a different vector mode with byte elements.\n      If no such mode, or if MODE already has byte elements, use VOIDmode.  */\n+  machine_mode qimode;\n   if (!qimode_for_vec_perm (mode).exists (&qimode))\n     qimode = VOIDmode;\n \n+  rtx_insn *last = get_last_insn ();\n+\n+  bool single_arg_p = rtx_equal_p (v0, v1);\n+\n   /* See if this can be handled with a vec_shr.  We only do this if the\n      second vector is all zeroes.  */\n   insn_code shift_code = optab_handler (vec_shr_optab, mode);\n@@ -5496,7 +5488,7 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n       && (shift_code != CODE_FOR_nothing\n \t  || shift_code_qi != CODE_FOR_nothing))\n     {\n-      rtx shift_amt = shift_amt_for_vec_perm_mask (sel);\n+      rtx shift_amt = shift_amt_for_vec_perm_mask (mode, sel);\n       if (shift_amt)\n \t{\n \t  struct expand_operand ops[3];\n@@ -5520,65 +5512,81 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n \t}\n     }\n \n-  icode = direct_optab_handler (vec_perm_const_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n+  if (targetm.vectorize.vec_perm_const != NULL)\n     {\n-      tmp = expand_vec_perm_1 (icode, target, v0, v1, sel);\n-      if (tmp)\n-\treturn tmp;\n+      v0 = force_reg (mode, v0);\n+      if (single_arg_p)\n+\tv1 = v0;\n+      else\n+\tv1 = force_reg (mode, v1);\n+\n+      if (targetm.vectorize.vec_perm_const (mode, target, v0, v1, sel))\n+\treturn target;\n     }\n \n   /* Fall back to a constant byte-based permutation.  */\n+  vec_perm_indices qimode_indices;\n+  rtx target_qi = NULL_RTX, v0_qi = NULL_RTX, v1_qi = NULL_RTX;\n   if (qimode != VOIDmode)\n     {\n-      vec = rtvec_alloc (w);\n-      for (i = 0; i < e; ++i)\n-\t{\n-\t  unsigned int j, this_e;\n+      qimode_indices.new_expanded_vector (sel, GET_MODE_UNIT_SIZE (mode));\n+      target_qi = gen_reg_rtx (qimode);\n+      v0_qi = gen_lowpart (qimode, v0);\n+      v1_qi = gen_lowpart (qimode, v1);\n+      if (targetm.vectorize.vec_perm_const != NULL\n+\t  && targetm.vectorize.vec_perm_const (qimode, target_qi, v0_qi,\n+\t\t\t\t\t       v1_qi, qimode_indices))\n+\treturn gen_lowpart (mode, target_qi);\n+    }\n \n-\t  this_e = INTVAL (CONST_VECTOR_ELT (sel, i));\n-\t  this_e &= 2 * e - 1;\n-\t  this_e *= u;\n+  /* Otherwise expand as a fully variable permuation.  */\n \n-\t  for (j = 0; j < u; ++j)\n-\t    RTVEC_ELT (vec, i * u + j) = GEN_INT (this_e + j);\n-\t}\n-      sel_qi = gen_rtx_CONST_VECTOR (qimode, vec);\n+  /* The optabs are only defined for selectors with the same width\n+     as the values being permuted.  */\n+  machine_mode required_sel_mode;\n+  if (!mode_for_int_vector (mode).exists (&required_sel_mode)\n+      || !VECTOR_MODE_P (required_sel_mode))\n+    {\n+      delete_insns_since (last);\n+      return NULL_RTX;\n+    }\n \n-      icode = direct_optab_handler (vec_perm_const_optab, qimode);\n-      if (icode != CODE_FOR_nothing)\n+  /* We know that it is semantically valid to treat SEL as having SEL_MODE.\n+     If that isn't the mode we want then we need to prove that using\n+     REQUIRED_SEL_MODE is OK.  */\n+  if (sel_mode != required_sel_mode)\n+    {\n+      if (!selector_fits_mode_p (required_sel_mode, sel))\n \t{\n-\t  tmp = gen_reg_rtx (qimode);\n-\t  tmp = expand_vec_perm_1 (icode, tmp, gen_lowpart (qimode, v0),\n-\t\t\t\t   gen_lowpart (qimode, v1), sel_qi);\n-\t  if (tmp)\n-\t    return gen_lowpart (mode, tmp);\n+\t  delete_insns_since (last);\n+\t  return NULL_RTX;\n \t}\n+      sel_mode = required_sel_mode;\n     }\n \n-  /* Otherwise expand as a fully variable permuation.  */\n-\n-  icode = direct_optab_handler (vec_perm_optab, mode);\n+  insn_code icode = direct_optab_handler (vec_perm_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      rtx tmp = expand_vec_perm_1 (icode, target, v0, v1, sel);\n+      rtx sel_rtx = vec_perm_indices_to_rtx (sel_mode, sel);\n+      rtx tmp = expand_vec_perm_1 (icode, target, v0, v1, sel_rtx);\n       if (tmp)\n \treturn tmp;\n     }\n \n-  if (qimode != VOIDmode)\n+  if (qimode != VOIDmode\n+      && selector_fits_mode_p (qimode, qimode_indices))\n     {\n       icode = direct_optab_handler (vec_perm_optab, qimode);\n       if (icode != CODE_FOR_nothing)\n \t{\n-\t  rtx tmp = gen_reg_rtx (qimode);\n-\t  tmp = expand_vec_perm_1 (icode, tmp, gen_lowpart (qimode, v0),\n-\t\t\t\t   gen_lowpart (qimode, v1), sel_qi);\n+\t  rtx sel_qi = vec_perm_indices_to_rtx (qimode, qimode_indices);\n+\t  rtx tmp = expand_vec_perm_1 (icode, target_qi, v0_qi, v1_qi, sel_qi);\n \t  if (tmp)\n \t    return gen_lowpart (mode, tmp);\n \t}\n     }\n \n+  delete_insns_since (last);\n   return NULL_RTX;\n }\n \n@@ -5590,7 +5598,7 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n    SEL must have the integer equivalent of MODE and is known to be\n    unsuitable for permutes with a constant permutation vector.  */\n \n-static rtx\n+rtx\n expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n {\n   enum insn_code icode;\n@@ -5633,17 +5641,16 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   gcc_assert (sel != NULL);\n \n   /* Broadcast the low byte each element into each of its bytes.  */\n-  vec = rtvec_alloc (w);\n+  vec_perm_builder const_sel (w);\n   for (i = 0; i < w; ++i)\n     {\n       int this_e = i / u * u;\n       if (BYTES_BIG_ENDIAN)\n \tthis_e += u - 1;\n-      RTVEC_ELT (vec, i) = GEN_INT (this_e);\n+      const_sel.quick_push (this_e);\n     }\n-  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n   sel = gen_lowpart (qimode, sel);\n-  sel = expand_vec_perm (qimode, sel, sel, tmp, NULL);\n+  sel = expand_vec_perm_const (qimode, sel, sel, const_sel, qimode, NULL);\n   gcc_assert (sel != NULL);\n \n   /* Add the byte offset to each byte element.  */\n@@ -5838,9 +5845,8 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n   enum insn_code icode;\n   int method, i, nunits;\n   machine_mode wmode;\n-  rtx m1, m2, perm;\n+  rtx m1, m2;\n   optab tab1, tab2;\n-  rtvec v;\n \n   method = can_mult_highpart_p (mode, uns_p);\n   switch (method)\n@@ -5883,21 +5889,20 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n   expand_insn (optab_handler (tab2, mode), 3, eops);\n   m2 = gen_lowpart (mode, eops[0].value);\n \n-  v = rtvec_alloc (nunits);\n+  auto_vec_perm_indices sel (nunits);\n   if (method == 2)\n     {\n       for (i = 0; i < nunits; ++i)\n-\tRTVEC_ELT (v, i) = GEN_INT (!BYTES_BIG_ENDIAN + (i & ~1)\n-\t\t\t\t    + ((i & 1) ? nunits : 0));\n-      perm = gen_rtx_CONST_VECTOR (mode, v);\n+\tsel.quick_push (!BYTES_BIG_ENDIAN + (i & ~1)\n+\t\t\t+ ((i & 1) ? nunits : 0));\n     }\n   else\n     {\n-      int base = BYTES_BIG_ENDIAN ? 0 : 1;\n-      perm = gen_const_vec_series (mode, GEN_INT (base), GEN_INT (2));\n+      for (i = 0; i < nunits; ++i)\n+\tsel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n     }\n \n-  return expand_vec_perm (mode, m1, m2, perm, target);\n+  return expand_vec_perm_const (mode, m1, m2, sel, BLKmode, target);\n }\n \f\n /* Helper function to find the MODE_CC set in a sync_compare_and_swap"}, {"sha": "7fbc30ca6d63c31ae906658ec34a4b7f55edceb8", "filename": "gcc/optabs.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -302,7 +302,6 @@ OPTAB_D (vec_pack_ssat_optab, \"vec_pack_ssat_$a\")\n OPTAB_D (vec_pack_trunc_optab, \"vec_pack_trunc_$a\")\n OPTAB_D (vec_pack_ufix_trunc_optab, \"vec_pack_ufix_trunc_$a\")\n OPTAB_D (vec_pack_usat_optab, \"vec_pack_usat_$a\")\n-OPTAB_D (vec_perm_const_optab, \"vec_perm_const$a\")\n OPTAB_D (vec_perm_optab, \"vec_perm$a\")\n OPTAB_D (vec_realign_load_optab, \"vec_realign_load_$a\")\n OPTAB_D (vec_set_optab, \"vec_set$a\")"}, {"sha": "e968132dce02451f975f834fc303ed1c6378941d", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"optabs-query.h\"\n #include \"optabs-libfuncs.h\"\n+#include \"vec-perm-indices.h\"\n \n /* Generate code for a widening multiply.  */\n extern rtx expand_widening_mult (machine_mode, rtx, rtx, rtx, int, optab);\n@@ -301,7 +302,9 @@ extern int have_insn_for (enum rtx_code, machine_mode);\n extern rtx_insn *gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n \n /* Generate code for VEC_PERM_EXPR.  */\n-extern rtx expand_vec_perm (machine_mode, rtx, rtx, rtx, rtx);\n+extern rtx expand_vec_perm_var (machine_mode, rtx, rtx, rtx, rtx);\n+extern rtx expand_vec_perm_const (machine_mode, rtx, rtx,\n+\t\t\t\t  const vec_perm_builder &, machine_mode, rtx);\n \n /* Generate code for vector comparison.  */\n extern rtx expand_vec_cmp_expr (tree, tree, rtx);"}, {"sha": "e9eacc891ed7b2d8d1946002b78fe0eea49ae4a8", "filename": "gcc/target.def", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -1841,12 +1841,27 @@ DEFHOOK\n  bool, (const_tree type, bool is_packed),\n  default_builtin_vector_alignment_reachable)\n \n-/* Return true if a vector created for vec_perm_const is valid.\n-   A NULL indicates that all constants are valid permutations.  */\n DEFHOOK\n-(vec_perm_const_ok,\n- \"Return true if a vector created for @code{vec_perm_const} is valid.\",\n- bool, (machine_mode, vec_perm_indices),\n+(vec_perm_const,\n+ \"This hook is used to test whether the target can permute up to two\\n\\\n+vectors of mode @var{mode} using the permutation vector @code{sel}, and\\n\\\n+also to emit such a permutation.  In the former case @var{in0}, @var{in1}\\n\\\n+and @var{out} are all null.  In the latter case @var{in0} and @var{in1} are\\n\\\n+the source vectors and @var{out} is the destination vector; all three are\\n\\\n+registers of mode @var{mode}.  @var{in1} is the same as @var{in0} if\\n\\\n+@var{sel} describes a permutation on one vector instead of two.\\n\\\n+\\n\\\n+Return true if the operation is possible, emitting instructions for it\\n\\\n+if rtxes are provided.\\n\\\n+\\n\\\n+@cindex @code{vec_perm@var{m}} instruction pattern\\n\\\n+If the hook returns false for a mode with multibyte elements, GCC will\\n\\\n+try the equivalent byte operation.  If that also fails, it will try forcing\\n\\\n+the selector into a register and using the @var{vec_perm@var{mode}}\\n\\\n+instruction pattern.  There is no need for the hook to handle these two\\n\\\n+implementation approaches itself.\",\n+ bool, (machine_mode mode, rtx output, rtx in0, rtx in1,\n+\tconst vec_perm_indices &sel),\n  NULL)\n \n /* Return true if the target supports misaligned store/load of a"}, {"sha": "429285937b09a58709fecc841d6a1709a7b08343", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -193,13 +193,7 @@ enum vect_cost_model_location {\n   vect_epilogue = 2\n };\n \n-/* The type to use for vector permutes with a constant permute vector.\n-   Each entry is an index into the concatenated input vectors.  */\n-typedef vec<unsigned short> vec_perm_indices;\n-\n-/* Same, but can be used to construct local permute vectors that are\n-   automatically freed.  */\n-typedef auto_vec<unsigned short, 32> auto_vec_perm_indices;\n+class vec_perm_indices;\n \n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;"}, {"sha": "d6e3d986255c4b5d6e4c1c9dfc8a34442767e164", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfganal.h\"\n #include \"optabs-tree.h\"\n #include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n \n /* This pass propagates the RHS of assignment statements into use\n    sites of the LHS of the assignment.  It's basically a specialized"}, {"sha": "367b08541fa506147f70d3eabd9b1ebd1a51e07a", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-cfg.h\"\n #include \"tree-hash-traits.h\"\n+#include \"vec-perm-indices.h\"\n \n /* Return true if load- or store-lanes optab OPTAB is implemented for\n    COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */"}, {"sha": "7daf9aebd970aaeb76381c40bb1544cc643ccf59", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"tree-cfg.h\"\n #include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n \n \n static void expand_vector_operations_1 (gimple_stmt_iterator *);"}, {"sha": "81060e03f34501c15af362bd840d61b06d0bc742", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-if-conv.h\"\n #include \"internal-fn.h\"\n #include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n \n /* Loop Vectorization Pass.\n "}, {"sha": "9240fcd5d0bc1b8b0dee16c770c7139123e8b90c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-walk.h\"\n #include \"dbgcnt.h\"\n #include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n \n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */"}, {"sha": "71929d9ff1ccb743c8635c857e1ea1e1ed776328", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"internal-fn.h\"\n #include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\""}, {"sha": "20299fab963bba7a4ab3deb8529d6c836ce7800d", "filename": "gcc/vec-perm-indices.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fvec-perm-indices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fvec-perm-indices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.c?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -0,0 +1,93 @@\n+/* A representation of vector permutation indices.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"vec-perm-indices.h\"\n+#include \"tree.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+\n+/* Switch to a new permutation vector that selects the same input elements\n+   as ORIG, but with each element split into FACTOR pieces.  For example,\n+   if ORIG is { 1, 2, 0, 3 } and FACTOR is 2, the new permutation is\n+   { 2, 3, 4, 5, 0, 1, 6, 7 }.  */\n+\n+void\n+vec_perm_indices::new_expanded_vector (const vec_perm_indices &orig,\n+\t\t\t\t       unsigned int factor)\n+{\n+  truncate (0);\n+  reserve (orig.length () * factor);\n+  for (unsigned int i = 0; i < orig.length (); ++i)\n+    {\n+      element_type base = orig[i] * factor;\n+      for (unsigned int j = 0; j < factor; ++j)\n+\tquick_push (base + j);\n+    }\n+}\n+\n+/* Return true if all elements of the permutation vector are in the range\n+   [START, START + SIZE).  */\n+\n+bool\n+vec_perm_indices::all_in_range_p (element_type start, element_type size) const\n+{\n+  for (unsigned int i = 0; i < length (); ++i)\n+    if ((*this)[i] < start || ((*this)[i] - start) >= size)\n+      return false;\n+  return true;\n+}\n+\n+/* Try to read the contents of VECTOR_CST CST as a constant permutation\n+   vector.  Return true and add the elements to BUILDER on success,\n+   otherwise return false without modifying BUILDER.  */\n+\n+bool\n+tree_to_vec_perm_builder (vec_perm_builder *builder, tree cst)\n+{\n+  unsigned int nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (cst));\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    if (!tree_fits_shwi_p (vector_cst_elt (cst, i)))\n+      return false;\n+\n+  builder->reserve (nelts);\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    builder->quick_push (tree_to_shwi (vector_cst_elt (cst, i))\n+\t\t\t & (2 * nelts - 1));\n+  return true;\n+}\n+\n+/* Return a CONST_VECTOR of mode MODE that contains the elements of\n+   INDICES.  */\n+\n+rtx\n+vec_perm_indices_to_rtx (machine_mode mode, const vec_perm_indices &indices)\n+{\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+\t      && GET_MODE_NUNITS (mode) == indices.length ());\n+  unsigned int nelts = indices.length ();\n+  rtvec v = rtvec_alloc (nelts);\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    RTVEC_ELT (v, i) = gen_int_mode (indices[i], GET_MODE_INNER (mode));\n+  return gen_rtx_CONST_VECTOR (mode, v);\n+}"}, {"sha": "6892bb75d14811cc7d5328578005326c55decda3", "filename": "gcc/vec-perm-indices.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fvec-perm-indices.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f151c9e1414c00e300c9385bc9512c3d9a481296/gcc%2Fvec-perm-indices.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.h?ref=f151c9e1414c00e300c9385bc9512c3d9a481296", "patch": "@@ -0,0 +1,49 @@\n+/* A representation of vector permutation indices.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VEC_PERN_INDICES_H\n+#define GCC_VEC_PERN_INDICES_H 1\n+\n+/* This class represents a constant permutation vector, such as that used\n+   as the final operand to a VEC_PERM_EXPR.  */\n+class vec_perm_indices : public auto_vec<unsigned short, 32>\n+{\n+  typedef unsigned short element_type;\n+  typedef auto_vec<element_type, 32> parent_type;\n+\n+public:\n+  vec_perm_indices () {}\n+  vec_perm_indices (unsigned int nunits) : parent_type (nunits) {}\n+\n+  void new_expanded_vector (const vec_perm_indices &, unsigned int);\n+\n+  bool all_in_range_p (element_type, element_type) const;\n+\n+private:\n+  vec_perm_indices (const vec_perm_indices &);\n+};\n+\n+/* Temporary.  */\n+typedef vec_perm_indices vec_perm_builder;\n+typedef vec_perm_indices auto_vec_perm_indices;\n+\n+bool tree_to_vec_perm_builder (vec_perm_builder *, tree);\n+rtx vec_perm_indices_to_rtx (machine_mode, const vec_perm_indices &);\n+\n+#endif"}]}