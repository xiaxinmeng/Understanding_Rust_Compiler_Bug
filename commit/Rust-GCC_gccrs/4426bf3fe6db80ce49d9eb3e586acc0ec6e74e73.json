{"sha": "4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQyNmJmM2ZlNmRiODBjZTQ5ZDllYjNlNTg2YWNjMGVjNmU3NGU3Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-26T23:07:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-26T23:07:00Z"}, "message": "Changed Class * to Class in order to match NEXTSTEP and OpenStep runtime.\n\nChanged Class * to Class in order to match NEXTSTEP and OpenStep\nruntime.\n(OBJC_VERSION): Version 7.\n(objc_init_statics): New function.\n(__objc_exec_class): Invoke objc_init_statics if needed.\n\nFrom-SVN: r9494", "tree": {"sha": "374b04cf50a0990014b1e6f35fcdff4a1660abfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/374b04cf50a0990014b1e6f35fcdff4a1660abfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73/comments", "author": null, "committer": null, "parents": [{"sha": "e35ec8520bf2e4322618732f556d72590f24dc68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35ec8520bf2e4322618732f556d72590f24dc68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e35ec8520bf2e4322618732f556d72590f24dc68"}], "stats": {"total": 110, "additions": 86, "deletions": 24}, "files": [{"sha": "52efeb00ecc74d8d0818b6e0938b5a1392614c4b", "filename": "gcc/objc/init.c", "status": "modified", "additions": 86, "deletions": 24, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73/gcc%2Fobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73/gcc%2Fobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Finit.c?ref=4426bf3fe6db80ce49d9eb3e586acc0ec6e74e73", "patch": "@@ -1,22 +1,21 @@\n /* GNU Objective C Runtime initialization \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-Author: Kresten Krab Thorup\n+   Copyright (C) 1993, 1995 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n \n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify it under the\n-   terms of the GNU General Public License as published by the Free Software\n-   Foundation; either version 2, or (at your option) any later version.\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n \n GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-   details.\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n \n You should have received a copy of the GNU General Public License along with\n-   GNU CC; see the file COPYING.  If not, write to the Free Software\n-   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* As a special exception, if you link this library with files compiled with\n    GCC to produce an executable, this does not cause the resulting executable\n@@ -28,7 +27,7 @@ You should have received a copy of the GNU General Public License along with\n \n /* The version number of this runtime.  This must match the number \n    defined in gcc (objc-act.c) */\n-#define OBJC_VERSION 6\n+#define OBJC_VERSION 7\n #define PROTOCOL_VERSION 2\n \n /* This list contains all modules currently loaded into the runtime */\n@@ -37,14 +36,17 @@ static struct objc_list* __objc_module_list = 0;\n /* This list contains all proto_list's not yet assigned class links */\n static struct objc_list* unclaimed_proto_list = 0;\n \n+/* List of unresolved static instances.  */\n+static struct objc_list *uninitialized_statics;\n+\n /* Check compiler vs runtime version */\n-static void init_check_module_version(Module_t);\n+static void init_check_module_version (Module_t);\n \n /* Assign isa links to protos */\n static void __objc_init_protocols (struct objc_protocol_list* protos);\n \n /* Add protocol to class */\n-static void __objc_class_add_protocols (Class*, struct objc_protocol_list*);\n+static void __objc_class_add_protocols (Class, struct objc_protocol_list*);\n \n /* Is all categories/classes resolved? */\n BOOL __objc_dangling_categories = NO;\n@@ -53,6 +55,60 @@ extern SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig);\n \n+/* Run through the statics list, removing modules as soon as all its statics\n+   have been initialized.  */\n+static void\n+objc_init_statics ()\n+{\n+  struct objc_list **cell = &uninitialized_statics;\n+  struct objc_static_instances **statics_in_module;\n+\n+  while (*cell)\n+    {\n+      int module_initialized = 1;\n+\n+      for (statics_in_module = (*cell)->head;\n+\t   *statics_in_module; statics_in_module++)\n+\t{\n+\t  struct objc_static_instances *statics = *statics_in_module;\n+\t  Class *class = objc_lookup_class (statics->class_name);\n+\n+\t  if (!class)\n+\t    module_initialized = 0;\n+\t  /* Actually, the static's class_pointer will be NULL when we\n+             haven't been here before.  However, the comparison is to be\n+             reminded of taking into account class posing and to think about\n+             possible semantics...  */\n+\t  else if (class != statics->instances[0]->class_pointer)\n+\t    {\n+\t      id *inst;\n+\n+\t      for (inst = &statics->instances[0]; *inst; inst++)\n+\t\t{\n+\t\t  (*inst)->class_pointer = class;\n+\n+\t\t  /* ??? Make sure the object will not be freed.  With\n+                     refcounting, invoke `-retain'.  Without refcounting, do\n+                     nothing and hope that `-free' will never be invoked.  */\n+\n+\t\t  /* ??? Send the object an `-initStatic' or something to\n+                     that effect now or later on?  What are the semantics of\n+                     statically allocated instances, besides the trivial\n+                     NXConstantString, anyway?  */\n+\t\t}\n+\t    }\n+\t}\n+      if (module_initialized)\n+\t{\n+\t  /* Remove this module from the uninitialized list.  */\n+\t  struct objc_list *this = *cell;\n+\t  *cell = this->tail;\n+\t  free (this);\n+\t}\n+      else\n+\tcell = &(*cell)->tail;\n+    }\n+} /* objc_init_statics */\n \n /* This function is called by constructor functions generated for each\n    module compiled.  (_GLOBAL_$I$...) The purpose of this function is to\n@@ -62,13 +118,13 @@ __sel_register_typed_name (const char *name, const char *types,\n void\n __objc_exec_class (Module_t module)\n {\n-  /* Has we processed any constructors previously?  This flag used to \n-     indicate that some global data structures need to be built.  */ \n+  /* Have we processed any constructors previously?  This flag is used to\n+     indicate that some global data structures need to be built.  */\n   static BOOL previous_constructors = 0;\n \n   static struct objc_list* unclaimed_categories = 0;\n \n-  /* The symbol table (defined in objc.h) generated by gcc */\n+  /* The symbol table (defined in objc-api.h) generated by gcc */\n   Symtab_t symtab = module->symtab;\n \n   /* Entry used to traverse hash lists */\n@@ -81,6 +137,7 @@ __objc_exec_class (Module_t module)\n   int i;\n \n   DEBUG_PRINTF (\"received module: %s\\n\", module->name);\n+\n   /* check gcc version */\n   init_check_module_version(module);\n \n@@ -113,7 +170,7 @@ __objc_exec_class (Module_t module)\n   DEBUG_PRINTF (\"gathering selectors from module: %s\\n\", module->name);\n   for (i = 0; i < symtab->cls_def_cnt; ++i)\n     {\n-      Class* class = (Class*) symtab->defs[i];\n+      Class class = (Class) symtab->defs[i];\n \n       /* Make sure we have what we think.  */\n       assert (CLS_ISCLASS(class));\n@@ -125,7 +182,7 @@ __objc_exec_class (Module_t module)\n \n       /* Register all of the selectors in the class and meta class.  */\n       __objc_register_selectors_from_class (class);\n-      __objc_register_selectors_from_class ((Class*) class->class_pointer);\n+      __objc_register_selectors_from_class ((Class) class->class_pointer);\n \n       /* Install the fake dispatch tables */\n       __objc_install_premature_dtable(class);\n@@ -139,7 +196,7 @@ __objc_exec_class (Module_t module)\n   for (i = 0; i < symtab->cat_def_cnt; ++i)\n     {\n       Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n-      Class* class = objc_lookup_class (category->class_name);\n+      Class class = objc_lookup_class (category->class_name);\n       \n       /* If the class for the category exists then append its methods.  */\n       if (class)\n@@ -155,7 +212,7 @@ __objc_exec_class (Module_t module)\n \n \t  /* Do class methods.  */\n \t  if (category->class_methods)\n-\t    class_add_method_list ((Class*) class->class_pointer, \n+\t    class_add_method_list ((Class) class->class_pointer, \n \t\t\t\t   category->class_methods);\n \n \t  if (category->protocols)\n@@ -173,14 +230,19 @@ __objc_exec_class (Module_t module)\n \t}\n     }\n \n+  if (module->statics)\n+    uninitialized_statics = list_cons (module->statics, uninitialized_statics);\n+  if (uninitialized_statics)\n+    objc_init_statics ();\n+\n   /* Scan the unclaimed category hash.  Attempt to attach any unclaimed\n      categories to objects.  */\n   for (cell = &unclaimed_categories;\n        *cell;\n        ({ if (*cell) cell = &(*cell)->tail; }))\n     {\n       Category_t category = (*cell)->head;\n-      Class* class = objc_lookup_class (category->class_name);\n+      Class class = objc_lookup_class (category->class_name);\n       \n       if (class)\n \t{\n@@ -193,7 +255,7 @@ __objc_exec_class (Module_t module)\n \t    class_add_method_list (class, category->instance_methods);\n \t  \n \t  if (category->class_methods)\n-\t    class_add_method_list ((Class*) class->class_pointer,\n+\t    class_add_method_list ((Class) class->class_pointer,\n \t\t\t\t   category->class_methods);\n \t  \n \t  if (category->protocols)\n@@ -235,7 +297,7 @@ static void\n __objc_init_protocols (struct objc_protocol_list* protos)\n {\n   int i;\n-  static Class* proto_class = 0;\n+  static Class proto_class = 0;\n \n   if (! protos)\n     return;\n@@ -275,7 +337,7 @@ __objc_init_protocols (struct objc_protocol_list* protos)\n     }\n }\n \n-static void __objc_class_add_protocols (Class* class,\n+static void __objc_class_add_protocols (Class class,\n \t\t\t\t\tstruct objc_protocol_list* protos)\n {\n   /* Well... */"}]}