{"sha": "25e9b6fe27d7665b70f22067411328f07e8ae9ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlOWI2ZmUyN2Q3NjY1YjcwZjIyMDY3NDExMzI4ZjA3ZThhZTlmZg==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2008-05-20T12:46:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:46:31Z"}, "message": "2008-05-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.adb\n\t(GARLIC_Support.Add_RACW_Read_Attribute): When a zero value is received,\n\tand the RACW is null-excluding, raise CONSTRAINT_ERROR instead of\n\tassigning NULL into the result, to avoid a spurious warning.\n\t(Add_RACW_Features, case Same_Scope): Add assertion that designated type\n\tis not frozen.\n\t(Add_Stub_Type): Set entity flag Is_RACW_Stub_Type on generated stub\n\ttype.\n\t(Build_From_Any_Function, Build_To_Any_Function,\n\tBuild_TypeCode_Function): For a type that has user-specified stream\n\tattributes, use an opaque sequence of octets as the representation.\n\nFrom-SVN: r135626", "tree": {"sha": "61bf6a062cb91259e088728d5ed1c1fc9574453b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61bf6a062cb91259e088728d5ed1c1fc9574453b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e9b6fe27d7665b70f22067411328f07e8ae9ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e9b6fe27d7665b70f22067411328f07e8ae9ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e9b6fe27d7665b70f22067411328f07e8ae9ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e9b6fe27d7665b70f22067411328f07e8ae9ff/comments", "author": null, "committer": null, "parents": [{"sha": "5b7dd52da8cf43abfab1a2703c70fcb07f0a5278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278"}], "stats": {"total": 295, "additions": 201, "deletions": 94}, "files": [{"sha": "a409fe44191a35328fd9f81817ea1d183d2d260f", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 201, "deletions": 94, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e9b6fe27d7665b70f22067411328f07e8ae9ff/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e9b6fe27d7665b70f22067411328f07e8ae9ff/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=25e9b6fe27d7665b70f22067411328f07e8ae9ff", "patch": "@@ -1085,8 +1085,8 @@ package body Exp_Dist is\n       Existing : Boolean;\n       --  True when appropriate stubs have already been generated (this is the\n       --  case when another RACW with the same designated type has already been\n-      --  encountered, in which case we reuse the previous stubs rather than\n-      --  generating new ones).\n+      --  encountered), in which case we reuse the previous stubs rather than\n+      --  generating new ones.\n \n    begin\n       if not Expander_Active then\n@@ -1164,23 +1164,23 @@ package body Exp_Dist is\n          RPC_Receiver_Decl   => RPC_Receiver_Decl,\n          Body_Decls          => Body_Decls);\n \n-      if not Same_Scope and then not Existing then\n+      --  If we already have stubs for this designated type, nothing to do\n \n-         --  The RACW has been declared in another scope than the designated\n-         --  type and has not been handled by another RACW in the same package\n-         --  as the first one, so add primitives for the stub type here.\n+      if Existing then\n+         return;\n+      end if;\n \n+      if Is_Frozen (Desig) then\n          Validate_RACW_Primitives (RACW_Type);\n          Add_RACW_Primitive_Declarations_And_Bodies\n            (Designated_Type  => Desig,\n             Insertion_Node   => RPC_Receiver_Decl,\n             Body_Decls       => Body_Decls);\n \n       else\n-         --  Validate_RACW_Primitives will be called when the designated type\n-         --  is frozen, see Exp_Ch3.Freeze_Type.\n-\n-         --  ??? Shouldn't we have a pragma Assert (not Is_Frozen (Desig))?\n+         --  Validate_RACW_Primitives requires the list of all primitives of\n+         --  the designated type, so defer processing until Desig is frozen.\n+         --  See Exp_Ch3.Freeze_Type.\n \n          Add_Access_Type_To_Process (E => Desig, A => RACW_Type);\n       end if;\n@@ -1870,6 +1870,8 @@ package body Exp_Dist is\n       Stub_Type :=\n         Make_Defining_Identifier (Loc,\n           Chars => New_Internal_Name ('S'));\n+      Set_Ekind (Stub_Type, E_Record_Type);\n+      Set_Is_RACW_Stub_Type (Stub_Type);\n       Stub_Type_Access :=\n         Make_Defining_Identifier (Loc,\n           Chars => New_External_Name\n@@ -3085,19 +3087,34 @@ package body Exp_Dist is\n \n          Set_Etype (Stubbed_Result, Stub_Type_Access);\n \n-         --  If the Address is Null_Address, then return a null object\n+         --  If the Address is Null_Address, then return a null object, unless\n+         --  RACW_Type is null-excluding, in which case inconditionally raise\n+         --  CONSTRAINT_ERROR instead.\n \n-         Append_To (Statements,\n-           Make_Implicit_If_Statement (RACW_Type,\n-             Condition       =>\n-               Make_Op_Eq (Loc,\n-                 Left_Opnd  => New_Occurrence_Of (Source_Address, Loc),\n-                 Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n-             Then_Statements => New_List (\n-               Make_Assignment_Statement (Loc,\n-                 Name       => Result,\n-                 Expression => Make_Null (Loc)),\n-               Make_Simple_Return_Statement (Loc))));\n+         declare\n+            Zero_Statements : List_Id;\n+            --  Statements executed when a zero value is received\n+         begin\n+            if Can_Never_Be_Null (RACW_Type) then\n+               Zero_Statements := New_List (\n+                 Make_Raise_Constraint_Error (Loc,\n+                   Reason => CE_Null_Not_Allowed));\n+            else\n+               Zero_Statements := New_List (\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => Result,\n+                   Expression => Make_Null (Loc)),\n+                 Make_Simple_Return_Statement (Loc));\n+            end if;\n+\n+            Append_To (Statements,\n+              Make_Implicit_If_Statement (RACW_Type,\n+                Condition       =>\n+                  Make_Op_Eq (Loc,\n+                    Left_Opnd  => New_Occurrence_Of (Source_Address, Loc),\n+                    Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n+                Then_Statements => Zero_Statements));\n+         end;\n \n          --  If the RACW denotes an object created on the current partition,\n          --  Local_Statements will be executed. The real object will be used.\n@@ -8470,7 +8487,7 @@ package body Exp_Dist is\n \n          function Find_Numeric_Representation\n            (Typ : Entity_Id) return Entity_Id;\n-         --  Given a numeric type Typ, return the smallest integer or floarting\n+         --  Given a numeric type Typ, return the smallest integer or floating\n          --  point type from Standard, or the smallest unsigned (modular) type\n          --  from System.Unsigned_Types, whose range encompasses that of Typ.\n \n@@ -8729,11 +8746,16 @@ package body Exp_Dist is\n             Decl : out Node_Id;\n             Fnam : out Entity_Id)\n          is\n-            Spec : Node_Id;\n+            Spec  : Node_Id;\n             Decls : constant List_Id := New_List;\n-            Stms : constant List_Id := New_List;\n-            Any_Parameter : constant Entity_Id\n-              := Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+            Stms  : constant List_Id := New_List;\n+\n+            Any_Parameter : constant Entity_Id :=\n+                              Make_Defining_Identifier (Loc,\n+                                New_Internal_Name ('A'));\n+\n+            Use_Opaque_Representation : Boolean;\n+\n          begin\n             if Is_Itype (Typ) then\n                Build_From_Any_Function\n@@ -8763,9 +8785,21 @@ package body Exp_Dist is\n             pragma Assert\n               (not (Is_Remote_Access_To_Class_Wide_Type (Typ)));\n \n-            if Is_Derived_Type (Typ)\n-              and then not Is_Tagged_Type (Typ)\n+            Use_Opaque_Representation := False;\n+\n+            if Has_Stream_Attribute_Definition\n+                 (Typ, TSS_Stream_Output, At_Any_Place => True)\n+                 or else\n+               Has_Stream_Attribute_Definition\n+                 (Typ, TSS_Stream_Write, At_Any_Place => True)\n             then\n+               --  If user-defined stream attributes are specified for this\n+               --  type, use them and transmit data as an opaque sequence of\n+               --  stream elements.\n+\n+               Use_Opaque_Representation := True;\n+\n+            elsif Is_Derived_Type (Typ) and then not Is_Tagged_Type (Typ) then\n                Append_To (Stms,\n                  Make_Simple_Return_Statement (Loc,\n                    Expression =>\n@@ -9292,6 +9326,11 @@ package body Exp_Dist is\n                          Decls))));\n \n             else\n+               Use_Opaque_Representation := True;\n+            end if;\n+\n+            if Use_Opaque_Representation then\n+\n                --  Default: type is represented as an opaque sequence of bytes\n \n                declare\n@@ -9588,6 +9627,10 @@ package body Exp_Dist is\n             Any_Decl  : Node_Id;\n             Result_TC : Node_Id := Build_TypeCode_Call (Loc, Typ, Decls);\n \n+            Use_Opaque_Representation : Boolean;\n+            --  When True, use stream attributes and represent type as an\n+            --  opaque sequence of bytes.\n+\n          begin\n             if Is_Itype (Typ) then\n                Build_To_Any_Function\n@@ -9598,8 +9641,8 @@ package body Exp_Dist is\n                return;\n             end if;\n \n-            Fnam := Make_Stream_Procedure_Function_Name (Loc,\n-                      Typ, Name_uTo_Any);\n+            Fnam :=\n+              Make_Stream_Procedure_Function_Name (Loc, Typ, Name_uTo_Any);\n \n             Spec :=\n               Make_Function_Specification (Loc,\n@@ -9620,39 +9663,58 @@ package body Exp_Dist is\n                 Object_Definition   =>\n                   New_Occurrence_Of (RTE (RE_Any), Loc));\n \n-            if Is_Derived_Type (Typ) and then not Is_Tagged_Type (Typ) then\n+            Use_Opaque_Representation := False;\n+\n+            if Has_Stream_Attribute_Definition\n+                 (Typ, TSS_Stream_Output, At_Any_Place => True)\n+              or else\n+               Has_Stream_Attribute_Definition\n+                 (Typ, TSS_Stream_Write,  At_Any_Place => True)\n+            then\n+               --  If user-defined stream attributes are specified for this\n+               --  type, use them and transmit data as an opaque sequence of\n+               --  stream elements.\n+\n+               Use_Opaque_Representation := True;\n+\n+            elsif Is_Derived_Type (Typ) and then not Is_Tagged_Type (Typ) then\n+\n+               --  Non-tagged derived type: convert to root type\n+\n                declare\n-                  Rt_Type : constant Entity_Id\n-                    := Root_Type (Typ);\n-                  Expr : constant Node_Id\n-                    := OK_Convert_To (\n-                         Rt_Type,\n-                         New_Occurrence_Of (Expr_Parameter, Loc));\n+                  Rt_Type : constant Entity_Id := Root_Type (Typ);\n+                  Expr    : constant Node_Id :=\n+                              OK_Convert_To\n+                                (Rt_Type,\n+                                 New_Occurrence_Of (Expr_Parameter, Loc));\n                begin\n                   Set_Expression (Any_Decl, Build_To_Any_Call (Expr, Decls));\n                end;\n \n             elsif Is_Record_Type (Typ) and then not Is_Tagged_Type (Typ) then\n+\n+               --  Non-tagged record type\n+\n                if Nkind (Declaration_Node (Typ)) = N_Subtype_Declaration then\n                   declare\n-                     Rt_Type : constant Entity_Id\n-                       := Etype (Typ);\n-                     Expr : constant Node_Id\n-                       := OK_Convert_To (\n-                            Rt_Type,\n-                            New_Occurrence_Of (Expr_Parameter, Loc));\n+                     Rt_Type : constant Entity_Id := Etype (Typ);\n+                     Expr    : constant Node_Id :=\n+                                 OK_Convert_To (Rt_Type,\n+                                   New_Occurrence_Of (Expr_Parameter, Loc));\n \n                   begin\n                      Set_Expression (Any_Decl,\n                        Build_To_Any_Call (Expr, Decls));\n                   end;\n \n+               --  Comment needed here (and label on declare block ???)\n+\n                else\n                   declare\n-                     Disc : Entity_Id := Empty;\n-                     Rdef : constant Node_Id :=\n-                              Type_Definition (Declaration_Node (Typ));\n-                     Counter : Int := 0;\n+                     Disc     : Entity_Id := Empty;\n+                     Rdef     : constant Node_Id :=\n+                                  Type_Definition (Declaration_Node (Typ));\n+                     Counter  : Int := 0;\n                      Elements : constant List_Id := New_List;\n \n                      procedure TA_Rec_Add_Process_Element\n@@ -9661,6 +9723,7 @@ package body Exp_Dist is\n                         Counter   : in out Int;\n                         Rec       : Entity_Id;\n                         Field     : Node_Id);\n+                     --  Processing routine for traversal below\n \n                      procedure TA_Append_Record_Traversal is\n                         new Append_Record_Traversal\n@@ -9702,15 +9765,15 @@ package body Exp_Dist is\n                         else\n                            --  A variant part\n \n-                           declare\n-                              Variant : Node_Id;\n+                           Variant_Part : declare\n+                              Variant        : Node_Id;\n                               Struct_Counter : Int := 0;\n \n                               Block_Decls : constant List_Id := New_List;\n                               Block_Stmts : constant List_Id := New_List;\n                               VP_Stmts    : List_Id;\n \n-                              Alt_List : constant List_Id := New_List;\n+                              Alt_List    : constant List_Id := New_List;\n                               Choice_List : List_Id;\n \n                               Union_Any : constant Entity_Id :=\n@@ -9723,8 +9786,8 @@ package body Exp_Dist is\n \n                               function Make_Discriminant_Reference\n                                 return Node_Id;\n-                              --  Build a selected component for the\n-                              --  discriminant of this variant part.\n+                              --  Build reference to the discriminant for this\n+                              --  variant part.\n \n                               ---------------------------------\n                               -- Make_Discriminant_Reference --\n@@ -9743,6 +9806,8 @@ package body Exp_Dist is\n                                  return Nod;\n                               end Make_Discriminant_Reference;\n \n+                           --  Start processing for Variant_Part\n+\n                            begin\n                               Append_To (Stmts,\n                                 Make_Block_Statement (Loc,\n@@ -9752,11 +9817,10 @@ package body Exp_Dist is\n                                     Make_Handled_Sequence_Of_Statements (Loc,\n                                       Statements => Block_Stmts)));\n \n-                              --  Declare the Variant Part aggregate\n-                              --  (Union_Any).\n-                              --  Knowing the position of this VP in\n-                              --  the variant record, we can fetch the\n-                              --  VP typecode from Container.\n+                              --  Declare variant part aggregate (Union_Any).\n+                              --  Knowing the position of this VP in the\n+                              --  variant record, we can fetch the VP typecode\n+                              --  from Container.\n \n                               Append_To (Block_Decls,\n                                 Make_Object_Declaration (Loc,\n@@ -9777,9 +9841,8 @@ package body Exp_Dist is\n                                             Make_Integer_Literal (Loc,\n                                               Counter)))))));\n \n-                              --  Declare the inner struct aggregate\n-                              --  (that will contain the components\n-                              --   of this VP)\n+                              --  Declare inner struct aggregate (which\n+                              --  contains the components of this VP).\n \n                               Append_To (Block_Decls,\n                                 Make_Object_Declaration (Loc,\n@@ -9800,9 +9863,7 @@ package body Exp_Dist is\n                                             Make_Integer_Literal (Loc,\n                                               Uint_1)))))));\n \n-                              --  Construct a case statement that will choose\n-                              --  the appropriate code at runtime depending on\n-                              --  the discriminant.\n+                              --  Build case statement\n \n                               Append_To (Block_Stmts,\n                                 Make_Case_Statement (Loc,\n@@ -9818,8 +9879,7 @@ package body Exp_Dist is\n \n                                  VP_Stmts := New_List;\n \n-                                 --  Append discriminant value to union\n-                                 --  aggregate.\n+                                 --  Append discriminant val to union aggregate\n \n                                  Append_To (VP_Stmts,\n                                     Make_Procedure_Call_Statement (Loc,\n@@ -9878,8 +9938,9 @@ package body Exp_Dist is\n \n                                  Next_Non_Pragma (Variant);\n                               end loop;\n-                           end;\n+                           end Variant_Part;\n                         end if;\n+\n                         Counter := Counter + 1;\n                      end TA_Rec_Add_Process_Element;\n \n@@ -9989,6 +10050,9 @@ package body Exp_Dist is\n                end if;\n \n             elsif Is_Array_Type (Typ) then\n+\n+               --  Constrained and unconstrained array types\n+\n                declare\n                   Constrained : constant Boolean := Is_Constrained (Typ);\n \n@@ -10074,6 +10138,9 @@ package body Exp_Dist is\n                end;\n \n             elsif Is_Integer_Type (Typ) or else Is_Unsigned_Type (Typ) then\n+\n+               --  Integer types\n+\n                Set_Expression (Any_Decl,\n                  Build_To_Any_Call (\n                    OK_Convert_To (\n@@ -10082,14 +10149,22 @@ package body Exp_Dist is\n                    Decls));\n \n             else\n-               --  Default: type is represented as an opaque sequence of bytes\n+               --  Default case, including tagged types: opaque representation\n+\n+               Use_Opaque_Representation := True;\n+            end if;\n \n+            if Use_Opaque_Representation then\n                declare\n-                  Strm : constant Entity_Id := Make_Defining_Identifier (Loc,\n-                           New_Internal_Name ('S'));\n+                  Strm : constant Entity_Id :=\n+                           Make_Defining_Identifier (Loc,\n+                             Chars => New_Internal_Name ('S'));\n+                  --  Stream used to store data representation produced by\n+                  --  stream attribute.\n \n                begin\n-                  --  Strm : aliased Buffer_Stream_Type;\n+                  --  Generate:\n+                  --    Strm : aliased Buffer_Stream_Type;\n \n                   Append_To (Decls,\n                     Make_Object_Declaration (Loc,\n@@ -10100,7 +10175,8 @@ package body Exp_Dist is\n                       Object_Definition   =>\n                         New_Occurrence_Of (RTE (RE_Buffer_Stream_Type), Loc)));\n \n-                  --  Allocate_Buffer (Strm);\n+                  --  Generate:\n+                  --    Allocate_Buffer (Strm);\n \n                   Append_To (Stms,\n                     Make_Procedure_Call_Statement (Loc,\n@@ -10109,19 +10185,21 @@ package body Exp_Dist is\n                       Parameter_Associations => New_List (\n                         New_Occurrence_Of (Strm, Loc))));\n \n-                  --  T'Output (Strm'Access, E);\n+                  --  Generate:\n+                  --    T'Output (Strm'Access, E);\n \n                   Append_To (Stms,\n                       Make_Attribute_Reference (Loc,\n                         Prefix         => New_Occurrence_Of (Typ, Loc),\n                         Attribute_Name => Name_Output,\n-                        Expressions => New_List (\n+                        Expressions    => New_List (\n                           Make_Attribute_Reference (Loc,\n-                            Prefix => New_Occurrence_Of (Strm, Loc),\n+                            Prefix         => New_Occurrence_Of (Strm, Loc),\n                             Attribute_Name => Name_Access),\n                           New_Occurrence_Of (Expr_Parameter, Loc))));\n \n-                  --  BS_To_Any (Strm, A);\n+                  --  Generate:\n+                  --    BS_To_Any (Strm, A);\n \n                   Append_To (Stms,\n                     Make_Procedure_Call_Statement (Loc,\n@@ -10131,7 +10209,8 @@ package body Exp_Dist is\n                         New_Occurrence_Of (Strm, Loc),\n                         New_Occurrence_Of (Any, Loc))));\n \n-                  --  Release_Buffer (Strm);\n+                  --  Generate:\n+                  --    Release_Buffer (Strm);\n \n                   Append_To (Stms,\n                     Make_Procedure_Call_Statement (Loc,\n@@ -10175,14 +10254,13 @@ package body Exp_Dist is\n             Typ   : Entity_Id;\n             Decls : List_Id) return Node_Id\n          is\n-            U_Type : Entity_Id  := Underlying_Type (Typ);\n+            U_Type : Entity_Id := Underlying_Type (Typ);\n             --  The full view, if Typ is private; the completion,\n             --  if Typ is incomplete.\n \n-            Fnam    : Entity_Id := Empty;\n-            Lib_RE  : RE_Id := RE_Null;\n-\n-            Expr : Node_Id;\n+            Fnam   : Entity_Id := Empty;\n+            Lib_RE : RE_Id := RE_Null;\n+            Expr   : Node_Id;\n \n          begin\n             --  Special case System.PolyORB.Interface.Any: its primitives have\n@@ -10729,22 +10807,29 @@ package body Exp_Dist is\n             Initialize_Parameter_List\n               (Type_Name_Str, Type_Repo_Id_Str, Parameters);\n \n-            if Is_Derived_Type (Typ)\n-              and then not Is_Tagged_Type (Typ)\n+            if Has_Stream_Attribute_Definition\n+                 (Typ, TSS_Stream_Output, At_Any_Place => True)\n+                 or else\n+               Has_Stream_Attribute_Definition\n+                 (Typ, TSS_Stream_Write, At_Any_Place => True)\n             then\n+               --  If user-defined stream attributes are specified for this\n+               --  type, use them and transmit data as an opaque sequence of\n+               --  stream elements.\n+\n+               Return_Alias_TypeCode\n+                 (New_Occurrence_Of (RTE (RE_TC_Opaque), Loc));\n+\n+            elsif Is_Derived_Type (Typ) and then not Is_Tagged_Type (Typ) then\n                Return_Alias_TypeCode (\n                  Build_TypeCode_Call (Loc, Etype (Typ), Decls));\n \n-            elsif Is_Integer_Type (Typ)\n-              or else Is_Unsigned_Type (Typ)\n-            then\n+            elsif Is_Integer_Type (Typ) or else Is_Unsigned_Type (Typ) then\n                Return_Alias_TypeCode (\n                  Build_TypeCode_Call (Loc,\n                    Find_Numeric_Representation (Typ), Decls));\n \n-            elsif Is_Record_Type (Typ)\n-              and then not Is_Tagged_Type (Typ)\n-            then\n+            elsif Is_Record_Type (Typ) and then not Is_Tagged_Type (Typ) then\n \n                --  Record typecodes are encoded as follows:\n                --  -- TC_STRUCT\n@@ -11280,11 +11365,33 @@ package body Exp_Dist is\n       Stub_Elements : constant Stub_Structure :=\n                         Stubs_Table.Get (Full_View);\n    begin\n+      --  For an RACW encountered before the freeze point of its designated\n+      --  type, the stub type is generated at the point of the RACW declaration\n+      --  but the primitives are generated only once the designated type is\n+      --  frozen. That freeze can occur in another scope, for example when the\n+      --  RACW is declared in a nested package. In that case we need to\n+      --  reestablish the stub type's scope prior to generating its primitive\n+      --  operations.\n+\n       if Stub_Elements /= Empty_Stub_Structure then\n-         Add_RACW_Primitive_Declarations_And_Bodies\n-           (Full_View,\n-            Stub_Elements.RPC_Receiver_Decl,\n-            Stub_Elements.Body_Decls);\n+         declare\n+            Saved_Scope : constant Entity_Id := Current_Scope;\n+            Stubs_Scope : constant Entity_Id :=\n+                            Scope (Stub_Elements.Stub_Type);\n+         begin\n+            if Current_Scope /= Stubs_Scope then\n+               Push_Scope (Stubs_Scope);\n+            end if;\n+\n+            Add_RACW_Primitive_Declarations_And_Bodies\n+              (Full_View,\n+               Stub_Elements.RPC_Receiver_Decl,\n+               Stub_Elements.Body_Decls);\n+\n+            if Current_Scope /= Saved_Scope then\n+               Pop_Scope;\n+            end if;\n+         end;\n       end if;\n    end Remote_Types_Tagged_Full_View_Encountered;\n "}]}