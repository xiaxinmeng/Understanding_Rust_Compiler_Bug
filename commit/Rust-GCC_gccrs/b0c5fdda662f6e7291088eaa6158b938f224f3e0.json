{"sha": "b0c5fdda662f6e7291088eaa6158b938f224f3e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjNWZkZGE2NjJmNmU3MjkxMDg4ZWFhNjE1OGI5MzhmMjI0ZjNlMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T12:46:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T12:46:03Z"}, "message": "[multiple changes]\n\n2014-07-30  Bob Duff  <duff@adacore.com>\n\n\t* s-tasuti.ads, s-tasuti.adb (Make_Independent): Change this\n\tfrom a procedure to a function, so that it can more easily be\n\tcalled before the \"begin\" of a task.\n\t* s-taasde.ads (Delay_Block): Make this type immutably limited,\n\tso we can use a build-in-place function call to initialize\n\tTimer_Queue in the body.\n\t* a-rttiev.adb, s-asthan-vms-alpha.adb, s-asthan-vms-ia64.adb,\n\t* s-interr.adb, s-interr-hwint.adb, s-interr-sigaction.adb,\n\t* s-interr-vms.adb, s-taasde.adb: Each independent task now calls\n\tMake_Independent before reaching its \"begin\", to avoid race\n\tconditions. This causes the activating task to wait until after\n\tMake_Independent is complete before proceeding.  In addition,\n\twe initialize data structures used by independent tasks before\n\tactivating those tasks, to avoid possible use of uninitialized data.\n\t* s-interr.ads, s-intman.ads, s-taspri-posix.ads, s-tasdeb.ads:\n\tMinor comment fixes.\n\n2014-07-30  Bob Duff  <duff@adacore.com>\n\n\t* a-exctra.ads, s-traent-vms.ads, s-traent.ads (Tracebacks_Array): Move\n\tthe declaration of Tracebacks_Array from Ada.Exceptions.Traceback to\n\tSystem.Traceback_Entries (s-traent.ads and s-traent-vms.ads).  Add\n\tsubtypes renaming Tracebacks_Array in Ada.Exceptions.Traceback.\n\t* g-debpoo.adb: Refer to Tracebacks_Array in its new home.\n\n2014-07-30  Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-tasatt.adb: Remove old comments.\n\nFrom-SVN: r213256", "tree": {"sha": "edf3ff7d4d7c657a4d5bac94ea980f2fbfb23581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edf3ff7d4d7c657a4d5bac94ea980f2fbfb23581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c5fdda662f6e7291088eaa6158b938f224f3e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c5fdda662f6e7291088eaa6158b938f224f3e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c5fdda662f6e7291088eaa6158b938f224f3e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c5fdda662f6e7291088eaa6158b938f224f3e0/comments", "author": null, "committer": null, "parents": [{"sha": "52c1498c862bf1363560f8d487b1af327fd9256b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c1498c862bf1363560f8d487b1af327fd9256b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c1498c862bf1363560f8d487b1af327fd9256b"}], "stats": {"total": 488, "additions": 180, "deletions": 308}, "files": [{"sha": "4eb3b018dd00d30af3e619723fa9c859da3945b6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -1,3 +1,34 @@\n+2014-07-30  Bob Duff  <duff@adacore.com>\n+\n+\t* s-tasuti.ads, s-tasuti.adb (Make_Independent): Change this\n+\tfrom a procedure to a function, so that it can more easily be\n+\tcalled before the \"begin\" of a task.\n+\t* s-taasde.ads (Delay_Block): Make this type immutably limited,\n+\tso we can use a build-in-place function call to initialize\n+\tTimer_Queue in the body.\n+\t* a-rttiev.adb, s-asthan-vms-alpha.adb, s-asthan-vms-ia64.adb,\n+\t* s-interr.adb, s-interr-hwint.adb, s-interr-sigaction.adb,\n+\t* s-interr-vms.adb, s-taasde.adb: Each independent task now calls\n+\tMake_Independent before reaching its \"begin\", to avoid race\n+\tconditions. This causes the activating task to wait until after\n+\tMake_Independent is complete before proceeding.  In addition,\n+\twe initialize data structures used by independent tasks before\n+\tactivating those tasks, to avoid possible use of uninitialized data.\n+\t* s-interr.ads, s-intman.ads, s-taspri-posix.ads, s-tasdeb.ads:\n+\tMinor comment fixes.\n+\n+2014-07-30  Bob Duff  <duff@adacore.com>\n+\n+\t* a-exctra.ads, s-traent-vms.ads, s-traent.ads (Tracebacks_Array): Move\n+\tthe declaration of Tracebacks_Array from Ada.Exceptions.Traceback to\n+\tSystem.Traceback_Entries (s-traent.ads and s-traent-vms.ads).  Add\n+\tsubtypes renaming Tracebacks_Array in Ada.Exceptions.Traceback.\n+\t* g-debpoo.adb: Refer to Tracebacks_Array in its new home.\n+\n+2014-07-30  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-tasatt.adb: Remove old comments.\n+\n 2014-07-30  Yannick Moy  <moy@adacore.com>\n \n \t* einfo.ads (Is_Inlined): Document new use in GNATprove mode."}, {"sha": "af1d59b9658239b7340c553e06228a7aab238a77", "filename": "gcc/ada/a-exctra.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fa-exctra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fa-exctra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exctra.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,7 +44,7 @@ package Ada.Exceptions.Traceback is\n    subtype Code_Loc is System.Address;\n    --  Code location in executing program\n \n-   type Tracebacks_Array is array (Positive range <>) of STBE.Traceback_Entry;\n+   subtype Tracebacks_Array is STBE.Tracebacks_Array;\n    --  A traceback array is an array of traceback entries\n \n    function Tracebacks (E : Exception_Occurrence) return Tracebacks_Array;"}, {"sha": "ecb0aa7c9d573a77161e385ca5789d441696e669", "filename": "gcc/ada/a-rttiev.adb", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fa-rttiev.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fa-rttiev.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rttiev.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2005-2011, Free Software Foundation, Inc.        --\n+--           Copyright (C) 2005-2014, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,6 +64,15 @@ package body Ada.Real_Time.Timing_Events is\n    Event_Queue_Lock : aliased System.Task_Primitives.RTS_Lock;\n    --  Used for mutually exclusive access to All_Events\n \n+   --  We need to Initialize_Lock before Timer is activated. The purpose of the\n+   --  Dummy package is to get around Ada's syntax rules.\n+\n+   package Dummy is end Dummy;\n+   package body Dummy is\n+   begin\n+      Initialize_Lock (Event_Queue_Lock'Access, Level => PO_Level);\n+   end Dummy;\n+\n    procedure Process_Queued_Events;\n    --  Examine the queue of pending events for any that have timed out. For\n    --  those that have timed out, remove them from the queue and invoke their\n@@ -86,7 +95,6 @@ package body Ada.Real_Time.Timing_Events is\n \n    task Timer is\n       pragma Priority (System.Priority'Last);\n-      entry Start;\n    end Timer;\n \n    task body Timer is\n@@ -96,29 +104,16 @@ package body Ada.Real_Time.Timing_Events is\n       --  requirements. Obviously a shorter period would give better resolution\n       --  at the cost of more overhead.\n \n-   begin\n-      System.Tasking.Utilities.Make_Independent;\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n \n+   begin\n       --  Since this package may be elaborated before System.Interrupt,\n       --  we need to call Setup_Interrupt_Mask explicitly to ensure that\n       --  this task has the proper signal mask.\n \n       System.Interrupt_Management.Operations.Setup_Interrupt_Mask;\n \n-      --  We await the call to Start to ensure that Event_Queue_Lock has been\n-      --  initialized by the package executable part prior to accessing it in\n-      --  the loop. The task is activated before the first statement of the\n-      --  executable part so it would otherwise be possible for the task to\n-      --  call EnterCriticalSection in Process_Queued_Events before the\n-      --  initialization.\n-\n-      --  We don't simply put the initialization here, prior to the loop,\n-      --  because other application tasks could call the visible routines that\n-      --  also call Enter/LeaveCriticalSection prior to this task doing the\n-      --  initialization.\n-\n-      accept Start;\n-\n       loop\n          Process_Queued_Events;\n          delay until Clock + Period;\n@@ -369,7 +364,4 @@ package body Ada.Real_Time.Timing_Events is\n       Remove_From_Queue (This'Unchecked_Access);\n    end Finalize;\n \n-begin\n-   Initialize_Lock (Event_Queue_Lock'Access, Level => PO_Level);\n-   Timer.Start;\n end Ada.Real_Time.Timing_Events;"}, {"sha": "ae2a715d6011019c91753937fac658dba0454e59", "filename": "gcc/ada/a-tasatt.adb", "status": "modified", "additions": 1, "deletions": 190, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2010, AdaCore                     --\n+--                     Copyright (C) 1995-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,195 +30,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  The following notes are provided in case someone decides the implementation\n---  of this package is too complicated, or too slow. Please read this before\n---  making any \"simplifications\".\n-\n---  Correct implementation of this package is more difficult than one might\n---  expect. After considering (and coding) several alternatives, we settled on\n---  the present compromise. Things we do not like about this implementation\n---  include:\n-\n---  - It is vulnerable to bad Task_Id values, to the extent of possibly\n---    trashing memory and crashing the runtime system.\n-\n---  - It requires dynamic storage allocation for each new attribute value,\n---    except for types that happen to be the same size as System.Address, or\n---    shorter.\n-\n---  - Instantiations at other than the library level rely on being able to\n---    do down-level calls to a procedure declared in the generic package body.\n---    This makes it potentially vulnerable to compiler changes.\n-\n---  The main implementation issue here is that the connection from task to\n---  attribute is a potential source of dangling references.\n-\n---  When a task goes away, we want to be able to recover all the storage\n---  associated with its attributes. The Ada mechanism for this is finalization,\n---  via controlled attribute types. For this reason, the ARM requires\n---  finalization of attribute values when the associated task terminates.\n-\n---  This finalization must be triggered by the tasking runtime system, during\n---  termination of the task. Given the active set of instantiations of\n---  Ada.Task_Attributes is dynamic, the number and types of attributes\n---  belonging to a task will not be known until the task actually terminates.\n---  Some of these types may be controlled and some may not. The RTS must find\n---  some way to determine which of these attributes need finalization, and\n---  invoke the appropriate finalization on them.\n-\n---  One way this might be done is to create a special finalization chain for\n---  each task, similar to the finalization chain that is used for controlled\n---  objects within the task. This would differ from the usual finalization\n---  chain in that it would not have a LIFO structure, since attributes may be\n---  added to a task at any time during its lifetime. This might be the right\n---  way to go for the longer term, but at present this approach is not open,\n---  since GNAT does not provide such special finalization support.\n-\n---  Lacking special compiler support, the RTS is limited to the normal ways an\n---  application invokes finalization, i.e.\n-\n---  a) Explicit call to the procedure Finalize, if we know the type has this\n---     operation defined on it. This is not sufficient, since we have no way\n---     of determining whether a given generic formal Attribute type is\n---     controlled, and no visibility of the associated Finalize procedure, in\n---     the generic body.\n-\n---  b) Leaving the scope of a local object of a controlled type. This does not\n---     help, since the lifetime of an instantiation of Ada.Task_Attributes\n---     does not correspond to the lifetimes of the various tasks which may\n---     have that attribute.\n-\n---  c) Assignment of another value to the object. This would not help, since\n---     we then have to finalize the new value of the object.\n-\n---  d) Unchecked deallocation of an object of a controlled type. This seems to\n---     be the only mechanism available to the runtime system for finalization\n---     of task attributes.\n-\n---  We considered two ways of using unchecked deallocation, both based on a\n---  linked list of that would hang from the task control block.\n-\n---  In the first approach the objects on the attribute list are all derived\n---  from one controlled type, say T, and are linked using an access type to\n---  T'Class. The runtime system has an Ada.Unchecked_Deallocation for T'Class\n---  with access type T'Class, and uses this to deallocate and finalize all the\n---  items in the list. The limitation of this approach is that each\n---  instantiation of the package Ada.Task_Attributes derives a new record\n---  extension of T, and since T is controlled (RM 3.9.1 (3)), instantiation is\n---  only allowed at the library level.\n-\n---  In the second approach the objects on the attribute list are of unrelated\n---  but structurally similar types. Unchecked conversion is used to circument\n---  Ada type checking. Each attribute-storage node contains not only the\n---  attribute value and a link for chaining, but also a pointer to descriptor\n---  for the corresponding instantiation of Task_Attributes. The instantiation\n---  descriptor contains pointer to a procedure that can do the correct\n---  deallocation and finalization for that type of attribute. On task\n---  termination, the runtime system uses the pointer to call the appropriate\n---  deallocator.\n-\n---  While this gets around the limitation that instantations be at the library\n---  level, it relies on an implementation feature that may not always be safe,\n---  i.e. that it is safe to call the Deallocate procedure for an instantiation\n---  of Ada.Task_Attributes that no longer exists. In general, it seems this\n---  might result in dangling references.\n-\n---  Another problem with instantiations deeper than the library level is that\n---  there is risk of storage leakage, or dangling references to reused storage.\n---  That is, if an instantiation of Ada.Task_Attributes is made within a\n---  procedure, what happens to the storage allocated for attributes, when the\n---  procedure call returns? Apparently (RM 7.6.1 (4)) any such objects must be\n---  finalized, since they will no longer be accessible, and in general one\n---  would expect that the storage they occupy would be recovered for later\n---  reuse. (If not, we would have a case of storage leakage.) Assuming the\n---  storage is recovered and later reused, we have potentially dangerous\n---  dangling references. When the procedure containing the instantiation of\n---  Ada.Task_Attributes returns, there may still be unterminated tasks with\n---  associated attribute values for that instantiation. When such tasks\n---  eventually terminate, the RTS will attempt to call the Deallocate procedure\n---  on them. If the corresponding storage has already been deallocated, when\n---  the master of the access type was left, we have a potential disaster. This\n---  disaster is compounded since the pointer to Deallocate is probably through\n---  a \"trampoline\" which will also have been destroyed.\n-\n---  For this reason, we arrange to remove all dangling references before\n---  leaving the scope of an instantiation. This is ugly, since it requires\n---  traversing the list of all tasks, but it is no more ugly than a similar\n---  traversal that we must do at the point of instantiation in order to\n---  initialize the attributes of all tasks. At least we only need to do these\n---  traversals if the type is controlled.\n-\n---  We chose to defer allocation of storage for attributes until the Reference\n---  function is called or the attribute is first set to a value different from\n---  the default initial one. This allows a potential savings in allocation,\n---  for attributes that are not used by all tasks.\n-\n---  For efficiency, we reserve space in the TCB for a fixed number of direct-\n---  access attributes. These are required to be of a size that fits in the\n---  space of an object of type System.Address. Because we must use unchecked\n---  bitwise copy operations on these values, they cannot be of a controlled\n---  type, but that is covered automatically since controlled objects are too\n---  large to fit in the spaces.\n-\n---  We originally deferred initialization of these direct-access attributes,\n---  just as we do for the indirect-access attributes, and used a per-task bit\n---  vector to keep track of which attributes were currently defined for that\n---  task. We found that the overhead of maintaining this bit-vector seriously\n---  slowed down access to the attributes, and made the fetch operation non-\n---  atomic, so that even to read an attribute value required locking the TCB.\n---  Therefore, we now initialize such attributes for all existing tasks at the\n---  time of the attribute instantiation, and initialize existing attributes for\n---  each new task at the time it is created.\n-\n---  The latter initialization requires a list of all the instantiation\n---  descriptors. Updates to this list, as well as the bit-vector that is used\n---  to reserve slots for attributes in the TCB, require mutual exclusion. That\n---  is provided by the Lock/Unlock_RTS.\n-\n---  One special problem that added complexity to the design is that the per-\n---  task list of indirect attributes contains objects of different types. We\n---  use unchecked pointer conversion to link these nodes together and access\n---  them, but the records may not have identical internal structure. Initially,\n---  we thought it would be enough to allocate all the common components of\n---  the records at the front of each record, so that their positions would\n---  correspond. Unfortunately, GNAT adds \"dope\" information at the front\n---  of a record, if the record contains any controlled-type components.\n---\n---  This means that the offset of the fields we use to link the nodes is at\n---  different positions on nodes of different types. To get around this, each\n---  attribute storage record consists of a core node and wrapper. The core\n---  nodes are all of the same type, and it is these that are linked together\n---  and generally \"seen\" by the RTS. Each core node contains a pointer to its\n---  own wrapper, which is a record that contains the core node along with an\n---  attribute value, approximately as follows:\n-\n---    type Node;\n---    type Node_Access is access all Node;\n---    type Wrapper;\n---    type Access_Wrapper is access all Wrapper;\n---    type Node is record\n---       Next    : Node_Access;\n---       ...\n---       Wrapper : Access_Wrapper;\n---    end record;\n---    type Wrapper is record\n---       Dummy_Node : aliased Node;\n---       Value      : aliased Attribute;  --  the generic formal type\n---    end record;\n-\n---  Another interesting problem is with the initialization of the instantiation\n---  descriptors. Originally, we did this all via the Initialize procedure of\n---  the descriptor type and code in the package body. It turned out that the\n---  Initialize procedure needed quite a bit of information, including the size\n---  of the attribute type, the initial value of the attribute (if it fits in\n---  the TCB), and a pointer to the deallocator procedure. These needed to be\n---  \"passed\" in via access discriminants. GNAT was having trouble with access\n---  discriminants, so all this work was moved to the package body.\n-\n---  Note that references to objects declared in this package body must in\n---  general use 'Unchecked_Access instead of 'Access as the package can be\n---  instantiated from within a local context.\n-\n with System.Storage_Elements;\n with System.Task_Primitives.Operations;\n with System.Tasking;"}, {"sha": "db17fa408ca436289099c94a9970ad6350263d9b", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -29,14 +29,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Exceptions.Traceback;\n with GNAT.IO; use GNAT.IO;\n \n with System.Address_Image;\n with System.Memory;     use System.Memory;\n with System.Soft_Links; use System.Soft_Links;\n \n-with System.Traceback_Entries; use System.Traceback_Entries;\n+with System.Traceback_Entries;\n \n with GNAT.HTable;\n with GNAT.Traceback; use GNAT.Traceback;\n@@ -107,8 +106,7 @@ package body GNAT.Debug_Pools is\n    type Header is range 1 .. 1023;\n    --  Number of elements in the hash-table\n \n-   type Tracebacks_Array_Access\n-      is access GNAT.Traceback.Tracebacks_Array;\n+   type Tracebacks_Array_Access is access Tracebacks_Array;\n \n    type Traceback_Kind is (Alloc, Dealloc, Indirect_Alloc, Indirect_Dealloc);\n \n@@ -323,6 +321,11 @@ package body GNAT.Debug_Pools is\n    --  addresses internal to this package). Depth is the number of levels that\n    --  the user is interested in.\n \n+   package STBE renames System.Traceback_Entries;\n+\n+   function PC_For (TB_Entry : STBE.Traceback_Entry) return System.Address\n+     renames STBE.PC_For;\n+\n    -----------\n    -- Align --\n    -----------\n@@ -373,7 +376,7 @@ package body GNAT.Debug_Pools is\n    -----------\n \n    function Equal (K1, K2 : Tracebacks_Array_Access) return Boolean is\n-      use Ada.Exceptions.Traceback;\n+      use type Tracebacks_Array;\n    begin\n       return K1.all = K2.all;\n    end Equal;"}, {"sha": "8ecdd8c11e18d27104775f1f03e41759fc09413d", "filename": "gcc/ada/s-asthan-vms-alpha.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-asthan-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-asthan-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan-vms-alpha.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -348,13 +348,14 @@ package body System.AST_Handling is\n \n       pragma Volatile (Param);\n \n-   begin\n       --  By making this task independent of master, when the environment\n       --  task is finalizing, the AST_Server_Task will be notified that it\n       --  should terminate.\n \n-      STU.Make_Independent;\n+      Ignore : constant Boolean := STU.Make_Independent;\n+      pragma Unreferenced (Ignore);\n \n+   begin\n       --  Record our task Id for access by Process_AST\n \n       AST_Task_Ids (Num) := Self_Id;"}, {"sha": "5e201235f3659c77639bf29476cbdc256b1c37cd", "filename": "gcc/ada/s-asthan-vms-ia64.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-asthan-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-asthan-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan-vms-ia64.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1996-2013, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1996-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -353,13 +353,14 @@ package body System.AST_Handling is\n \n       pragma Volatile (Param);\n \n-   begin\n       --  By making this task independent of master, when the environment\n       --  task is finalizing, the AST_Server_Task will be notified that it\n       --  should terminate.\n \n-      STU.Make_Independent;\n+      Ignore : constant Boolean := STU.Make_Independent;\n+      pragma Unreferenced (Ignore);\n \n+   begin\n       --  Record our task Id for access by Process_AST\n \n       AST_Task_Ids (Num) := Self_Id;"}, {"sha": "9da97cff1bea731e59156800a746b2d464100f80", "filename": "gcc/ada/s-interr-hwint.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr-hwint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr-hwint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-hwint.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -719,6 +719,11 @@ package body System.Interrupts is\n    -----------------------\n \n    task body Interrupt_Manager is\n+      --  By making this task independent of any master, when the process goes\n+      --  away, the Interrupt_Manager will terminate gracefully.\n+\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n \n       --------------------\n       -- Local Routines --\n@@ -907,11 +912,6 @@ package body System.Interrupts is\n    --  Start of processing for Interrupt_Manager\n \n    begin\n-      --  By making this task independent of any master, when the process goes\n-      --  away, the Interrupt_Manager will terminate gracefully.\n-\n-      System.Tasking.Utilities.Make_Independent;\n-\n       loop\n          --  A block is needed to absorb Program_Error exception\n \n@@ -1039,14 +1039,16 @@ package body System.Interrupts is\n    --  Server task for vectored hardware interrupt handling\n \n    task body Interrupt_Server_Task is\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n+\n       Self_Id         : constant Task_Id := Self;\n       Tmp_Handler     : Parameterless_Handler;\n       Tmp_ID          : Task_Id;\n       Tmp_Entry_Index : Task_Entry_Index;\n       Status          : int;\n \n    begin\n-      System.Tasking.Utilities.Make_Independent;\n       Semaphore_ID_Map (Interrupt) := Int_Sema;\n \n       loop"}, {"sha": "f9612d51af5c856612332fd9c08a36d48905e7da", "filename": "gcc/ada/s-interr-sigaction.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr-sigaction.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr-sigaction.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-sigaction.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -616,13 +616,14 @@ package body System.Interrupts is\n    end Is_Blocked;\n \n    task body Server_Task is\n+      Ignore : constant Boolean := Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n+\n       Desc    : Handler_Desc renames Descriptors (Interrupt);\n       Self_Id : constant Task_Id := STPO.Self;\n       Temp    : Parameterless_Handler;\n \n    begin\n-      Utilities.Make_Independent;\n-\n       loop\n          while Interrupt_Count (Interrupt) > 0 loop\n             Interrupt_Count (Interrupt) := Interrupt_Count (Interrupt) - 1;"}, {"sha": "ae3a5c1487c066fe3f15640f03959d89afaa92bf", "filename": "gcc/ada/s-interr-vms.adb", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-vms.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -566,6 +566,11 @@ package body System.Interrupts is\n    -----------------------\n \n    task body Interrupt_Manager is\n+      --  By making this task independent of master, when the process goes\n+      --  away, the Interrupt_Manager will terminate gracefully.\n+\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n \n       --------------------\n       -- Local Routines --\n@@ -705,11 +710,6 @@ package body System.Interrupts is\n    --  Start of processing for Interrupt_Manager\n \n    begin\n-      --  By making this task independent of master, when the process goes\n-      --  away, the Interrupt_Manager will terminate gracefully.\n-\n-      System.Tasking.Utilities.Make_Independent;\n-\n       --  Environment task gets its own interrupt mask, saves it, and then\n       --  masks all interrupts except the Keep_Unmasked set.\n \n@@ -893,18 +893,19 @@ package body System.Interrupts is\n    -----------------\n \n    task body Server_Task is\n+      --  By making this task independent of master, when the process\n+      --  goes away, the Server_Task will terminate gracefully.\n+\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n+\n       Self_ID         : constant Task_Id := Self;\n       Tmp_Handler     : Parameterless_Handler;\n       Tmp_ID          : Task_Id;\n       Tmp_Entry_Index : Task_Entry_Index;\n       Intwait_Mask    : aliased IMNG.Interrupt_Mask;\n \n    begin\n-      --  By making this task independent of master, when the process\n-      --  goes away, the Server_Task will terminate gracefully.\n-\n-      System.Tasking.Utilities.Make_Independent;\n-\n       --  Install default action in system level\n \n       IMOP.Install_Default_Action (IMNG.Interrupt_ID (Interrupt));"}, {"sha": "a9b12087e9e22df73db1fa741437205202988ce5", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -52,6 +52,7 @@\n --  There is no more than one interrupt per Server_Task and no more than one\n --  Server_Task per interrupt.\n \n+with Ada.Exceptions;\n with Ada.Task_Identification;\n \n with System.Task_Primitives;\n@@ -60,6 +61,8 @@ with System.Interrupt_Management;\n with System.Interrupt_Management.Operations;\n pragma Elaborate_All (System.Interrupt_Management.Operations);\n \n+with System.IO;\n+\n with System.Task_Primitives.Operations;\n with System.Task_Primitives.Interrupt_Operations;\n with System.Storage_Elements;\n@@ -678,6 +681,11 @@ package body System.Interrupts is\n    -----------------------\n \n    task body Interrupt_Manager is\n+      --  By making this task independent of master, when the process\n+      --  goes away, the Interrupt_Manager will terminate gracefully.\n+\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n \n       ---------------------\n       -- Local Variables --\n@@ -940,11 +948,6 @@ package body System.Interrupts is\n    --  Start of processing for Interrupt_Manager\n \n    begin\n-      --  By making this task independent of master, when the process\n-      --  goes away, the Interrupt_Manager will terminate gracefully.\n-\n-      System.Tasking.Utilities.Make_Independent;\n-\n       --  Environment task gets its own interrupt mask, saves it, and then\n       --  masks all interrupts except the Keep_Unmasked set.\n \n@@ -1221,9 +1224,10 @@ package body System.Interrupts is\n             when Program_Error =>\n                null;\n \n-            when others =>\n+            when X : others =>\n+               System.IO.Put_Line (\"Exception in Interrupt_Manager\");\n+               System.IO.Put_Line (Ada.Exceptions.Exception_Information (X));\n                pragma Assert (False);\n-               null;\n          end;\n       end loop;\n    end Interrupt_Manager;\n@@ -1233,6 +1237,12 @@ package body System.Interrupts is\n    -----------------\n \n    task body Server_Task is\n+      --  By making this task independent of master, when the process goes\n+      --  away, the Server_Task will terminate gracefully.\n+\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n+\n       Intwait_Mask    : aliased IMNG.Interrupt_Mask;\n       Ret_Interrupt   : Interrupt_ID;\n       Self_ID         : constant Task_Id := Self;\n@@ -1241,11 +1251,6 @@ package body System.Interrupts is\n       Tmp_Entry_Index : Task_Entry_Index;\n \n    begin\n-      --  By making this task independent of master, when the process goes\n-      --  away, the Server_Task will terminate gracefully.\n-\n-      System.Tasking.Utilities.Make_Independent;\n-\n       --  Install default action in system level\n \n       IMOP.Install_Default_Action (IMNG.Interrupt_ID (Interrupt));"}, {"sha": "c1ac164f1248612b6202ead0e088810ed2189778", "filename": "gcc/ada/s-interr.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -156,9 +156,9 @@ package System.Interrupts is\n    function Is_Ignored (Interrupt : Interrupt_ID) return Boolean;\n    --  Comment needed ???\n \n-   --  Note : Direct calls to sigaction, sigprocmask, thr_sigsetmask or any\n+   --  Note : Direct calls to sigaction, sigprocmask, thr_sigsetmask, or any\n    --  other low-level interface that changes the signal action or signal mask\n-   --  needs a careful thought.\n+   --  needs careful thought.\n \n    --  One may achieve the effect of system calls first making RTS blocked (by\n    --  calling Block_Interrupt) for the signal under consideration. This will"}, {"sha": "71a1cefcc6e2b066058db177e4d04e5a73daa783", "filename": "gcc/ada/s-intman.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-intman.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-intman.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,9 +75,9 @@ package System.Interrupt_Management is\n    --  used for that purpose. This is one of the reserved interrupts.\n \n    Keep_Unmasked : Interrupt_Set := (others => False);\n-   --  Keep_Unmasked (I) is true iff the interrupt I is one that must that\n-   --  must be kept unmasked at all times, except (perhaps) for short critical\n-   --  sections. This includes interrupts that are mapped to exceptions (see\n+   --  Keep_Unmasked (I) is true iff the interrupt I is one that must be kept\n+   --  unmasked at all times, except (perhaps) for short critical sections.\n+   --  This includes interrupts that are mapped to exceptions (see\n    --  System.Interrupt_Exceptions.Is_Exception), but may also include\n    --  interrupts (e.g. timer) that need to be kept unmasked for other\n    --  reasons. Where interrupts are implemented as OS signals, and signal"}, {"sha": "40e3dc6e91c529b0530a1d3708c426b73497c688", "filename": "gcc/ada/s-taasde.adb", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-taasde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-taasde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taasde.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,22 +60,34 @@ package body System.Tasking.Async_Delays is\n    function To_System is new Ada.Unchecked_Conversion\n      (Ada.Task_Identification.Task_Id, Task_Id);\n \n-   Timer_Server_ID : ST.Task_Id;\n-\n    Timer_Attention : Boolean := False;\n    pragma Atomic (Timer_Attention);\n \n    task Timer_Server is\n       pragma Interrupt_Priority (System.Any_Priority'Last);\n    end Timer_Server;\n \n+   Timer_Server_ID : constant ST.Task_Id := To_System (Timer_Server'Identity);\n+\n    --  The timer queue is a circular doubly linked list, ordered by absolute\n    --  wakeup time. The first item in the queue is Timer_Queue.Succ.\n    --  It is given a Resume_Time that is larger than any legitimate wakeup\n    --  time, so that the ordered insertion will always stop searching when it\n    --  gets back to the queue header block.\n \n-   Timer_Queue : aliased Delay_Block;\n+   function Empty_Queue return Delay_Block;\n+   --  Initial value for Timer_Queue\n+\n+   function Empty_Queue return Delay_Block is\n+   begin\n+      return Result : aliased Delay_Block do\n+         Result.Succ := Result'Unchecked_Access;\n+         Result.Pred := Result'Unchecked_Access;\n+         Result.Resume_Time := Duration'Last;\n+      end return;\n+   end Empty_Queue;\n+\n+   Timer_Queue : aliased Delay_Block := Empty_Queue;\n \n    ------------------------\n    -- Cancel_Async_Delay --\n@@ -270,23 +282,12 @@ package body System.Tasking.Async_Delays is\n    ------------------\n \n    task body Timer_Server is\n-      function Get_Next_Wakeup_Time return Duration;\n-      --  Used to initialize Next_Wakeup_Time, but also to ensure that\n-      --  Make_Independent is called during the elaboration of this task.\n-\n-      --------------------------\n-      -- Get_Next_Wakeup_Time --\n-      --------------------------\n-\n-      function Get_Next_Wakeup_Time return Duration is\n-      begin\n-         STU.Make_Independent;\n-         return Duration'Last;\n-      end Get_Next_Wakeup_Time;\n+      Ignore : constant Boolean := STU.Make_Independent;\n+      pragma Unreferenced (Ignore);\n \n       --  Local Declarations\n \n-      Next_Wakeup_Time : Duration := Get_Next_Wakeup_Time;\n+      Next_Wakeup_Time : Duration := Duration'Last;\n       Timedout         : Boolean;\n       Yielded          : Boolean;\n       Now              : Duration;\n@@ -296,7 +297,7 @@ package body System.Tasking.Async_Delays is\n       pragma Unreferenced (Timedout, Yielded);\n \n    begin\n-      Timer_Server_ID := STPO.Self;\n+      pragma Assert (Timer_Server_ID = STPO.Self);\n \n       --  Since this package may be elaborated before System.Interrupt,\n       --  we need to call Setup_Interrupt_Mask explicitly to ensure that\n@@ -400,13 +401,4 @@ package body System.Tasking.Async_Delays is\n       end loop;\n    end Timer_Server;\n \n-   ------------------------------\n-   -- Package Body Elaboration --\n-   ------------------------------\n-\n-begin\n-   Timer_Queue.Succ := Timer_Queue'Access;\n-   Timer_Queue.Pred := Timer_Queue'Access;\n-   Timer_Queue.Resume_Time := Duration'Last;\n-   Timer_Server_ID := To_System (Timer_Server'Identity);\n end System.Tasking.Async_Delays;"}, {"sha": "46dc17877f38690790d106d3b857eeaeeb5d6b9e", "filename": "gcc/ada/s-taasde.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-taasde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-taasde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taasde.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1998-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -113,7 +113,7 @@ package System.Tasking.Async_Delays is\n \n private\n \n-   type Delay_Block is record\n+   type Delay_Block is limited record\n       Self_Id : Task_Id;\n       --  ID of the calling task\n "}, {"sha": "2c43dc1d127efa3fdbec724ea957f66b15c40bc4", "filename": "gcc/ada/s-tasdeb.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-tasdeb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-tasdeb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasdeb.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1997-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -105,25 +105,25 @@ package System.Tasking.Debug is\n \n    procedure Suspend_All_Tasks (Thread_Self : OS_Interface.Thread_Id);\n    --  Suspend all the tasks except the one whose associated thread is\n-   --  Thread_Self by traversing All_Tasks_Lists and calling\n+   --  Thread_Self by traversing All_Tasks_List and calling\n    --  System.Task_Primitives.Operations.Suspend_Task.\n \n    procedure Resume_All_Tasks (Thread_Self : OS_Interface.Thread_Id);\n    --  Resume all the tasks except the one whose associated thread is\n-   --  Thread_Self by traversing All_Tasks_Lists and calling\n+   --  Thread_Self by traversing All_Tasks_List and calling\n    --  System.Task_Primitives.Operations.Continue_Task.\n \n    procedure Stop_All_Tasks_Handler;\n-   --  Stop all the tasks by traversing All_Tasks_Lists and calling\n+   --  Stop all the tasks by traversing All_Tasks_List and calling\n    --  System.Task_Primitives.Operations.Stop_All_Task. This function\n    --  can be used in an interrupt handler.\n \n    procedure Stop_All_Tasks;\n-   --  Stop all the tasks by traversing All_Tasks_Lists and calling\n+   --  Stop all the tasks by traversing All_Tasks_List and calling\n    --  System.Task_Primitives.Operations.Stop_Task.\n \n    procedure Continue_All_Tasks;\n-   --  Continue all the tasks by traversing All_Tasks_Lists and calling\n+   --  Continue all the tasks by traversing All_Tasks_List and calling\n    --  System.Task_Primitives.Operations.Continue_Task.\n \n    -------------------------------"}, {"sha": "65f06909ac1aeb993a69ba83246bbefb84be574d", "filename": "gcc/ada/s-taspri-posix.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-taspri-posix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-taspri-posix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-posix.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,8 +6,8 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 1991-1994, Florida State University             --\n---                     Copyright (C) 1995-2011, AdaCore                     --\n+--            Copyright (C) 1991-1914, Florida State University             --\n+--                     Copyright (C) 1995-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,8 +48,8 @@ package System.Task_Primitives is\n \n    type RTS_Lock is limited private;\n    --  Should be used inside the runtime system. The difference between Lock\n-   --  and the RTS_Lock is that the later one serves only as a semaphore so\n-   --  that do not check for ceiling violations.\n+   --  and the RTS_Lock is that the latter serves only as a semaphore so that\n+   --  we do not check for ceiling violations.\n \n    type Suspension_Object is limited private;\n    --  Should be used for the implementation of Ada.Synchronous_Task_Control"}, {"sha": "8449ee51bcc96c92af98cc156069b46e2b264cd2", "filename": "gcc/ada/s-tasuti.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-tasuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-tasuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasuti.adb?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -242,7 +242,7 @@ package body System.Tasking.Utilities is\n    -- Make_Independent --\n    ----------------------\n \n-   procedure Make_Independent is\n+   function Make_Independent return Boolean is\n       Self_Id               : constant Task_Id := STPO.Self;\n       Environment_Task      : constant Task_Id := STPO.Environment_Task;\n       Parent                : constant Task_Id := Self_Id.Common.Parent;\n@@ -321,6 +321,8 @@ package body System.Tasking.Utilities is\n       end if;\n \n       Initialization.Undefer_Abort (Self_Id);\n+\n+      return True; -- return value doesn't matter\n    end Make_Independent;\n \n    ------------------"}, {"sha": "b2003711ba11ee2f1fc8be9b441e626482ca1052", "filename": "gcc/ada/s-tasuti.ads", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-tasuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-tasuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasuti.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---         Copyright (C) 1992-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,7 @@ package System.Tasking.Utilities is\n    -- Task_Stage Related routines --\n    ---------------------------------\n \n-   procedure Make_Independent;\n+   function Make_Independent return Boolean;\n    --  Move the current task to the outermost level (level 2) of the master\n    --  hierarchy of the environment task. That is one level further out\n    --  than normal tasks defined in library-level packages (level 3). The\n@@ -63,9 +63,35 @@ package System.Tasking.Utilities is\n    --  will change the task's parent. This assumption is particularly\n    --  important for master level completion and for the computation of\n    --  Independent_Task_Count.\n+   --\n+   --  NOTE WELL: Make_Independent should be called before the task reaches its\n+   --  \"begin\", like this:\n+   --\n+   --     task body Some_Independent_Task is\n+   --        ...\n+   --        Ignore : constant Boolean := Make_Independent;\n+   --        pragma Unreferenced (Ignore);\n+   --        ...\n+   --     begin\n+   --\n+   --  The return value is meaningless; the only reason this is a function is\n+   --  to get around the Ada limitation that makes a procedure call\n+   --  syntactically illegal before the \"begin\".\n+   --\n+   --  Calling it before \"begin\" ensures that the call completes before the\n+   --  activating task can proceed. This is important for preventing race\n+   --  conditions. For example, if the environment task reaches\n+   --  Finalize_Global_Tasks before some task has finished Make_Independent,\n+   --  the program can hang.\n+   --\n+   --  Note also that if a package declares independent tasks, it should not\n+   --  initialize its package-body data after \"begin\" of the package, because\n+   --  that's where the tasks are activated. Initializing such data before the\n+   --  task activation helps prevent the tasks from accessing uninitialized\n+   --  data.\n \n    Independent_Task_Count : Natural := 0;\n-   --  Number of independent task. This counter is incremented each time\n+   --  Number of independent tasks. This counter is incremented each time\n    --  Make_Independent is called. Note that if a server task terminates,\n    --  this counter will not be decremented. Since Make_Independent locks\n    --  the environment task (because every independent task depends on it),"}, {"sha": "07ab1c0198a99f4241855b82cf3267eb881bc80b", "filename": "gcc/ada/s-traent-vms.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-traent-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-traent-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-traent-vms.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -52,6 +52,8 @@ package System.Traceback_Entries is\n                      (PC => System.Null_Address,\n                       PV => System.Null_Address);\n \n+   type Tracebacks_Array is array (Positive range <>) of Traceback_Entry;\n+\n    function PC_For (TB_Entry : Traceback_Entry) return System.Address;\n    function PV_For (TB_Entry : Traceback_Entry) return System.Address;\n "}, {"sha": "74f53fd361dce45bb7c24a3030c864f62388260b", "filename": "gcc/ada/s-traent.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-traent.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c5fdda662f6e7291088eaa6158b938f224f3e0/gcc%2Fada%2Fs-traent.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-traent.ads?ref=b0c5fdda662f6e7291088eaa6158b938f224f3e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -49,6 +49,8 @@ package System.Traceback_Entries is\n    Null_TB_Entry : constant Traceback_Entry := System.Null_Address;\n    --  This is the value to be used when initializing an entry\n \n+   type Tracebacks_Array is array (Positive range <>) of Traceback_Entry;\n+\n    function PC_For (TB_Entry : Traceback_Entry) return System.Address;\n    pragma Inline (PC_For);\n    --  Returns the address of the call instruction associated with the"}]}