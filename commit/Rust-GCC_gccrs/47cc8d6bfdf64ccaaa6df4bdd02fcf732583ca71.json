{"sha": "47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdjYzhkNmJmZGY2NGNjYWFhNmRmNGJkZDAyZmNmNzMyNTgzY2E3MQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-06-06T10:24:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:24:57Z"}, "message": "exp_ch3.adb (Make_Controlling_Function_Wrappers): generate wrapper a wrapper when the full view of the controlling type of an...\n\n2007-04-20  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch3.adb (Make_Controlling_Function_Wrappers): generate wrapper a\n\twrapper when the full view of the controlling type of an inherited\n\tfunction that dispatches on result implements interfaces.\n\t(Expand_N_Object_Declaration): In cases where the type of the\n\tdeclaration is anonymous access, create finalization list for it.\n\t(Expand_N_Object_Declaration): Generate a persistent_bss directive only\n\tif the object has no explicit initialization, to match description of\n\tfunctionality of pragam Persistent_BSS.\n\t(Build_Equivalent_Array_Aggregate, Build_Equivalent_Record_Aggregate):\n\tnew function to build static aggregates, to replace initialization call\n\twhen static initialization is desired.\n\t(Freeze_Type): Generate a list controller for an access type whenever\n\tits designated type has controlled anonymous access discriminants.\n\t(Build_Equivalent_Aggregate): New procedure to compute a static\n\taggregate to be used as default initialization for composite types,\n\tinstead of a generating a call to the initialization procedure for the\n\ttype.\n\t(Build_Initialization_Call): When available, replace a call to the\n\tinitialization procedure with a copy of the equivalent static aggregate\n\tfor the type.\n\t(Expand_N_Object_Declaration):  Use New_Occurrence_Of in generated\n\tdeclarations for objects of a class-wide interface type, rather than\n\tjust identifiers, to prevent visibility problems.\n\t(Expand_N_Object_Declaration): When expanding the declaration for an\n\tobject of a class-wide interface type, preserve the homonym chain of\n\tthe original entity before exchanging it with that of the generated\n\trenaming declaration.\n\t(Freeze_Enumeration_Type): Don't raise CE if No_Exception_Propagation\n\tactive, because there is no way to handle the exception.\n\t(Freeze_Record_Type): In case of CPP_Class types add a call to Make_DT\n\tto do a minimum decoration of the Access_Disp_Table list.\n\t(Expand_Record_Controller): Avoid the addition of the controller between\n\tthe component containing the tag of a secondary dispatch table and its\n\tadjacent component that stores the offset to the base of the object.\n\tThis latter component is only generated when the parent type has\n\tdiscriminants ---documented in Add_Interface_Tag_Components).\n\t(Apply_Array_Size_Check): Removed, no longer needed.\n\t(Expand_N_Full_Type_Declaration): If the type has anonymous access\n\tcomponents, create a Master_Entity for it only if it contains tasks.\n\t(Build_Init_Procedure): Suppress the tag assignment compiling under\n\tno run-time mode.\n\t(Freeze_Record_Type): Remove code associated with creation of dispatch\n\ttable.\n\t(Init_Secondary_Tags): Update type of actuals when generating calls to\n\tAda.Tags.Set_Offset_To_Top\n\t(Stream_Operation_OK): Disable use of streams compiling under no\n\trun-time mode\n\t(Expand_N_Object_Declaration): Don't do Initialize_Scalars initalization\n\tif Has_Init_Expression set.\n\t(Build_Init_Procedure): Replace call to Fill_DT_Entry by call to\n\tRegister_Primitive, which provides the same functionality.\n\t(Requires_Init_Proc): Return false in case of interface types.\n\t(Add_Secondary_Tables): Use the new attribute Related_Interface to\n\tcleanup the code.\n\t(Predefined_Primitive_Freeze): Do not assume that an internal entity\n\tis always associated with a predefined primitive because the internal\n\tentities associated with interface types are not predefined primitives.\n\tTherefore, the call to Is_Internal is replaced by a call to the\n\tfunction Is_Predefined_Dispatching_Operation.\n\t(Make_Eq_If): When generating the list of comparisons for the\n\tcomponents of a given variant, omit the controller component that is\n\tpresent if the variant has controlled components.\n\nFrom-SVN: r125396", "tree": {"sha": "be0d685205befdc6dd3b45e1cfa7a24b241c39c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be0d685205befdc6dd3b45e1cfa7a24b241c39c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56"}], "stats": {"total": 1089, "additions": 677, "deletions": 412}, "files": [{"sha": "9f2a60b7375d05ea1439d6213b46848ba405fd99", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 677, "deletions": 412, "changes": 1089, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,8 +42,8 @@ with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n-with Hostparm; use Hostparm;\n with Nlists;   use Nlists;\n+with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n@@ -62,6 +62,7 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n with Snames;   use Snames;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Validsw;  use Validsw;\n@@ -92,6 +93,22 @@ package body Exp_Ch3 is\n    --  of the type. Otherwise new identifiers are created, with the source\n    --  names of the discriminants.\n \n+   function Build_Equivalent_Array_Aggregate (T : Entity_Id) return Node_Id;\n+   --  This function builds a static aggregate that can serve as the initial\n+   --  value for an array type whose bounds are static, and whose component\n+   --  type is a composite type that has a static equivalent aggregate.\n+   --  The equivalent array aggregate is used both for object initialization\n+   --  and for component initialization, when used in the following function.\n+\n+   function Build_Equivalent_Record_Aggregate (T : Entity_Id) return Node_Id;\n+   --  This function builds a static aggregate that can serve as the initial\n+   --  value for a record type whose components are scalar and initialized\n+   --  with compile-time values, or arrays with similarc initialization or\n+   --  defaults. When possible, initialization of an object of the type can\n+   --  be achieved by using a copy of the aggregate as an initial value, thus\n+   --  removing the implicit call that would otherwise constitute elaboration\n+   --  code.\n+\n    function Build_Master_Renaming\n      (N : Node_Id;\n       T : Entity_Id) return Entity_Id;\n@@ -121,10 +138,10 @@ package body Exp_Ch3 is\n    --  and attach it to the TSS list\n \n    procedure Check_Stream_Attributes (Typ : Entity_Id);\n-   --  Check that if a limited extension has a parent with user-defined\n-   --  stream attributes, and does not itself have user-definer\n-   --  stream-attributes, then any limited component of the extension also\n-   --  has the corresponding user-defined stream attributes.\n+   --  Check that if a limited extension has a parent with user-defined stream\n+   --  attributes, and does not itself have user-defined stream-attributes,\n+   --  then any limited component of the extension also has the corresponding\n+   --  user-defined stream attributes.\n \n    procedure Clean_Task_Names\n      (Typ     : Entity_Id;\n@@ -167,6 +184,12 @@ package body Exp_Ch3 is\n    --  Treat user-defined stream operations as renaming_as_body if the\n    --  subprogram they rename is not frozen when the type is frozen.\n \n+   procedure Initialization_Warning (E : Entity_Id);\n+   --  If static elaboration of the package is requested, indicate\n+   --  when a type does meet the conditions for static initialization. If\n+   --  E is a type, it has components that have no static initialization.\n+   --  if E is an entity, its initial expression is not compile-time known.\n+\n    function Init_Formals (Typ : Entity_Id) return List_Id;\n    --  This function builds the list of formals for an initialization routine.\n    --  The first formal is always _Init with the given type. For task value\n@@ -187,23 +210,23 @@ package body Exp_Ch3 is\n      (E     : Entity_Id;\n       CL    : Node_Id;\n       Discr : Entity_Id := Empty) return List_Id;\n-   --  Building block for variant record equality. Defined to share the\n-   --  code between the tagged and non-tagged case. Given a Component_List\n-   --  node CL, it generates an 'if' followed by a 'case' statement that\n-   --  compares all components of local temporaries named X and Y (that\n-   --  are declared as formals at some upper level). E provides the Sloc to be\n-   --  used for the generated code. Discr is used as the case statement switch\n-   --  in the case of Unchecked_Union equality.\n+   --  Building block for variant record equality. Defined to share the code\n+   --  between the tagged and non-tagged case. Given a Component_List node CL,\n+   --  it generates an 'if' followed by a 'case' statement that compares all\n+   --  components of local temporaries named X and Y (that are declared as\n+   --  formals at some upper level). E provides the Sloc to be used for the\n+   --  generated code. Discr is used as the case statement switch in the case\n+   --  of Unchecked_Union equality.\n \n    function Make_Eq_If\n      (E : Entity_Id;\n       L : List_Id) return Node_Id;\n-   --  Building block for variant record equality. Defined to share the\n-   --  code between the tagged and non-tagged case. Given the list of\n-   --  components (or discriminants) L, it generates a return statement\n-   --  that compares all components of local temporaries named X and Y\n-   --  (that are declared as formals at some upper level). E provides the Sloc\n-   --  to be used for the generated code.\n+   --  Building block for variant record equality. Defined to share the code\n+   --  between the tagged and non-tagged case. Given the list of components\n+   --  (or discriminants) L, it generates a return statement that compares all\n+   --  components of local temporaries named X and Y (that are declared as\n+   --  formals at some upper level). E provides the Sloc to be used for the\n+   --  generated code.\n \n    procedure Make_Predefined_Primitive_Specs\n      (Tag_Typ     : Entity_Id;\n@@ -222,32 +245,31 @@ package body Exp_Ch3 is\n    --     typSI          provides result of 'Input attribute\n    --     typSO          provides result of 'Output attribute\n    --\n-   --  The following entries are additionally present for non-limited\n-   --  tagged types, and implement additional dispatching operations\n-   --  for predefined operations:\n+   --  The following entries are additionally present for non-limited tagged\n+   --  types, and implement additional dispatching operations for predefined\n+   --  operations:\n    --\n    --     _equality      implements \"=\" operator\n    --     _assign        implements assignment operation\n    --     typDF          implements deep finalization\n-   --     typDA          implements deep adust\n+   --     typDA          implements deep adjust\n    --\n    --  The latter two are empty procedures unless the type contains some\n    --  controlled components that require finalization actions (the deep\n    --  in the name refers to the fact that the action applies to components).\n    --\n-   --  The list is returned in Predef_List. The Parameter Renamed_Eq\n-   --  either returns the value Empty, or else the defining unit name\n-   --  for the predefined equality function in the case where the type\n-   --  has a primitive operation that is a renaming of predefined equality\n-   --  (but only if there is also an overriding user-defined equality\n-   --  function). The returned Renamed_Eq will be passed to the\n-   --  corresponding parameter of Predefined_Primitive_Bodies.\n+   --  The list is returned in Predef_List. The Parameter Renamed_Eq either\n+   --  returns the value Empty, or else the defining unit name for the\n+   --  predefined equality function in the case where the type has a primitive\n+   --  operation that is a renaming of predefined equality (but only if there\n+   --  is also an overriding user-defined equality function). The returned\n+   --  Renamed_Eq will be passed to the corresponding parameter of\n+   --  Predefined_Primitive_Bodies.\n \n    function Has_New_Non_Standard_Rep (T : Entity_Id) return Boolean;\n-   --  returns True if there are representation clauses for type T that\n-   --  are not inherited. If the result is false, the init_proc and the\n-   --  discriminant_checking functions of the parent can be reused by\n-   --  a derived type.\n+   --  returns True if there are representation clauses for type T that are not\n+   --  inherited. If the result is false, the init_proc and the discriminant\n+   --  checking functions of the parent can be reused by a derived type.\n \n    procedure Make_Controlling_Function_Wrappers\n      (Tag_Typ   : Entity_Id;\n@@ -308,7 +330,7 @@ package body Exp_Ch3 is\n \n    function Predefined_Primitive_Freeze (Tag_Typ : Entity_Id) return List_Id;\n    --  Freeze entities of all predefined primitive operations. This is needed\n-   --  because the bodies of these operations do not normally do any freezeing.\n+   --  because the bodies of these operations do not normally do any freezing.\n \n    function Stream_Operation_OK\n      (Typ       : Entity_Id;\n@@ -323,12 +345,12 @@ package body Exp_Ch3 is\n    -- Adjust_Discriminants --\n    --------------------------\n \n-   --  This procedure attempts to define subtypes for discriminants that\n-   --  are more restrictive than those declared. Such a replacement is\n-   --  possible if we can demonstrate that values outside the restricted\n-   --  range would cause constraint errors in any case. The advantage of\n-   --  restricting the discriminant types in this way is tha the maximum\n-   --  size of the variant record can be calculated more conservatively.\n+   --  This procedure attempts to define subtypes for discriminants that are\n+   --  more restrictive than those declared. Such a replacement is possible if\n+   --  we can demonstrate that values outside the restricted range would cause\n+   --  constraint errors in any case. The advantage of restricting the\n+   --  discriminant types in this way is that the maximum size of the variant\n+   --  record can be calculated more conservatively.\n \n    --  An example of a situation in which we can perform this type of\n    --  restriction is the following:\n@@ -581,7 +603,7 @@ package body Exp_Ch3 is\n    --  Start of processing for Build_Array_Init_Proc\n \n    begin\n-      if Suppress_Init_Proc (A_Type) then\n+      if Suppress_Init_Proc (A_Type) or else Is_Value_Type (Comp_Type) then\n          return;\n       end if;\n \n@@ -592,7 +614,7 @@ package body Exp_Ch3 is\n       --    1. The component type has an initialization procedure\n       --    2. The component type needs simple initialization\n       --    3. Tasks are present\n-      --    4. The type is marked as a publc entity\n+      --    4. The type is marked as a public entity\n \n       --  The reason for the public entity test is to deal properly with the\n       --  Initialize_Scalars pragma. This pragma can be set in the client and\n@@ -644,7 +666,7 @@ package body Exp_Ch3 is\n \n          --  Set inlined unless controlled stuff or tasks around, in which\n          --  case we do not want to inline, because nested stuff may cause\n-         --  difficulties in interunit inlining, and furthermore there is\n+         --  difficulties in inter-unit inlining, and furthermore there is\n          --  in any case no point in inlining such complex init procs.\n \n          if not Has_Task (Proc_Id)\n@@ -666,6 +688,15 @@ package body Exp_Ch3 is\n            and then Nkind (First (Body_Stmts)) = N_Null_Statement\n          then\n             Set_Is_Null_Init_Proc (Proc_Id);\n+\n+         else\n+            --  Try to build a static aggregate to initialize statically\n+            --  objects of the type. This can only be done for constrained\n+            --  one-dimensional arrays with static bounds.\n+\n+            Set_Static_Initialization\n+              (Proc_Id,\n+                Build_Equivalent_Array_Aggregate (First_Subtype (A_Type)));\n          end if;\n       end if;\n    end Build_Array_Init_Proc;\n@@ -688,9 +719,9 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n-      --  Find declaration that created the access type: either a\n-      --  type declaration, or an object declaration with an\n-      --  access definition, in which case the type is anonymous.\n+      --  Find declaration that created the access type: either a type\n+      --  declaration, or an object declaration with an access definition,\n+      --  in which case the type is anonymous.\n \n       if Is_Itype (T) then\n          P := Associated_Node_For_Itype (T);\n@@ -702,9 +733,9 @@ package body Exp_Ch3 is\n \n       if not Has_Master_Entity (Scope (T)) then\n \n-         --  first build the master entity\n+         --  First build the master entity\n          --    _Master : constant Master_Id := Current_Master.all;\n-         --  and insert it just before the current declaration\n+         --  and insert it just before the current declaration.\n \n          Decl :=\n            Make_Object_Declaration (Loc,\n@@ -716,7 +747,7 @@ package body Exp_Ch3 is\n                Make_Explicit_Dereference (Loc,\n                  New_Reference_To (RTE (RE_Current_Master), Loc)));\n \n-         Insert_Before (P, Decl);\n+         Insert_Action (P, Decl);\n          Analyze (Decl);\n          Set_Has_Master_Entity (Scope (T));\n \n@@ -775,12 +806,12 @@ package body Exp_Ch3 is\n       function Build_Case_Statement\n         (Case_Id : Entity_Id;\n          Variant : Node_Id) return Node_Id;\n-      --  Build a case statement containing only two alternatives. The\n-      --  first alternative corresponds exactly to the discrete choices\n-      --  given on the variant with contains the components that we are\n-      --  generating the checks for. If the discriminant is one of these\n-      --  return False. The second alternative is an OTHERS choice that\n-      --  will return True indicating the discriminant did not match.\n+      --  Build a case statement containing only two alternatives. The first\n+      --  alternative corresponds exactly to the discrete choices given on the\n+      --  variant with contains the components that we are generating the\n+      --  checks for. If the discriminant is one of these return False. The\n+      --  second alternative is an OTHERS choice that will return True\n+      --  indicating the discriminant did not match.\n \n       function Build_Dcheck_Function\n         (Case_Id : Entity_Id;\n@@ -811,8 +842,8 @@ package body Exp_Ch3 is\n       begin\n          Case_Node := New_Node (N_Case_Statement, Loc);\n \n-         --  Replace the discriminant which controls the variant, with the\n-         --  name of the formal of the checking function.\n+         --  Replace the discriminant which controls the variant, with the name\n+         --  of the formal of the checking function.\n \n          Set_Expression (Case_Node,\n            Make_Identifier (Loc, Chars (Case_Id)));\n@@ -1054,25 +1085,194 @@ package body Exp_Ch3 is\n       return Parameter_List;\n    end Build_Discriminant_Formals;\n \n+   --------------------------------------\n+   -- Build_Equivalent_Array_Aggregate --\n+   --------------------------------------\n+\n+   function Build_Equivalent_Array_Aggregate (T : Entity_Id) return Node_Id is\n+      Loc        : constant Source_Ptr := Sloc (T);\n+      Comp_Type  : constant Entity_Id := Component_Type (T);\n+      Index_Type : constant Entity_Id := Etype (First_Index (T));\n+      Proc       : constant Entity_Id := Base_Init_Proc (T);\n+      Lo, Hi     : Node_Id;\n+      Aggr       : Node_Id;\n+      Expr       : Node_Id;\n+\n+   begin\n+      if not Is_Constrained (T)\n+        or else Number_Dimensions (T) > 1\n+        or else No (Proc)\n+      then\n+         Initialization_Warning (T);\n+         return Empty;\n+      end if;\n+\n+      Lo := Type_Low_Bound  (Index_Type);\n+      Hi := Type_High_Bound (Index_Type);\n+\n+      if not Compile_Time_Known_Value (Lo)\n+        or else not Compile_Time_Known_Value (Hi)\n+      then\n+         Initialization_Warning (T);\n+         return Empty;\n+      end if;\n+\n+      if Is_Record_Type (Comp_Type)\n+        and then Present (Base_Init_Proc (Comp_Type))\n+      then\n+         Expr := Static_Initialization (Base_Init_Proc (Comp_Type));\n+\n+         if No (Expr) then\n+            Initialization_Warning (T);\n+            return Empty;\n+         end if;\n+\n+      else\n+         Initialization_Warning (T);\n+         return Empty;\n+      end if;\n+\n+      Aggr := Make_Aggregate (Loc, No_List, New_List);\n+      Set_Etype (Aggr, T);\n+      Set_Aggregate_Bounds (Aggr,\n+        Make_Range (Loc,\n+          Low_Bound  => New_Copy (Lo),\n+          High_Bound => New_Copy (Hi)));\n+      Set_Parent (Aggr, Parent (Proc));\n+\n+      Append_To (Component_Associations (Aggr),\n+         Make_Component_Association (Loc,\n+              Choices =>\n+                 New_List (\n+                   Make_Range (Loc,\n+                     Low_Bound  => New_Copy (Lo),\n+                     High_Bound => New_Copy (Hi))),\n+              Expression => Expr));\n+\n+      if Static_Array_Aggregate (Aggr) then\n+         return Aggr;\n+      else\n+         Initialization_Warning (T);\n+         return Empty;\n+      end if;\n+   end Build_Equivalent_Array_Aggregate;\n+\n+   ---------------------------------------\n+   -- Build_Equivalent_Record_Aggregate --\n+   ---------------------------------------\n+\n+   function Build_Equivalent_Record_Aggregate (T : Entity_Id) return Node_Id is\n+      Agg  : Node_Id;\n+      Comp : Entity_Id;\n+\n+      --  Start of processing for Build_Equivalent_Record_Aggregate\n+\n+   begin\n+      if not Is_Record_Type (T)\n+        or else Has_Discriminants (T)\n+        or else Is_Limited_Type (T)\n+        or else Has_Non_Standard_Rep (T)\n+      then\n+         Initialization_Warning (T);\n+         return Empty;\n+      end if;\n+\n+      Comp := First_Component (T);\n+\n+      --  A null record needs no warning\n+\n+      if No (Comp) then\n+         return Empty;\n+      end if;\n+\n+      while Present (Comp) loop\n+\n+         --  Array components are acceptable if initialized by a positional\n+         --  aggregate with static components.\n+\n+         if Is_Array_Type (Etype (Comp)) then\n+            declare\n+               Comp_Type : constant Entity_Id := Component_Type (Etype (Comp));\n+\n+            begin\n+               if Nkind (Parent (Comp)) /= N_Component_Declaration\n+                 or else No (Expression (Parent (Comp)))\n+                 or else Nkind (Expression (Parent (Comp))) /= N_Aggregate\n+               then\n+                  Initialization_Warning (T);\n+                  return Empty;\n+\n+               elsif Is_Scalar_Type (Component_Type (Etype (Comp)))\n+                  and then\n+                    (not Compile_Time_Known_Value (Type_Low_Bound (Comp_Type))\n+                      or else not Compile_Time_Known_Value\n+                          (Type_High_Bound (Comp_Type)))\n+               then\n+                  Initialization_Warning (T);\n+                  return Empty;\n+\n+               elsif\n+                 not Static_Array_Aggregate (Expression (Parent (Comp)))\n+               then\n+                  Initialization_Warning (T);\n+                  return Empty;\n+               end if;\n+            end;\n+\n+         elsif Is_Scalar_Type (Etype (Comp)) then\n+            if Nkind (Parent (Comp)) /= N_Component_Declaration\n+              or else No (Expression (Parent (Comp)))\n+              or else not Compile_Time_Known_Value (Expression (Parent (Comp)))\n+            then\n+               Initialization_Warning (T);\n+               return Empty;\n+            end if;\n+\n+         --  For now, other types are excluded\n+\n+         else\n+            Initialization_Warning (T);\n+            return Empty;\n+         end if;\n+\n+         Next_Component (Comp);\n+      end loop;\n+\n+      --  All components have static initialization. Build  positional\n+      --  aggregate from the given expressions or defaults.\n+\n+      Agg := Make_Aggregate (Sloc (T), New_List, New_List);\n+      Set_Parent (Agg, Parent (T));\n+\n+      Comp := First_Component (T);\n+      while Present (Comp) loop\n+         Append\n+           (New_Copy_Tree (Expression (Parent (Comp))), Expressions (Agg));\n+         Next_Component (Comp);\n+      end loop;\n+\n+      Analyze_And_Resolve (Agg, T);\n+      return Agg;\n+   end Build_Equivalent_Record_Aggregate;\n+\n    -------------------------------\n    -- Build_Initialization_Call --\n    -------------------------------\n \n-   --  References to a discriminant inside the record type declaration\n-   --  can appear either in the subtype_indication to constrain a\n-   --  record or an array, or as part of a larger expression given for\n-   --  the initial value of a component. In both of these cases N appears\n-   --  in the record initialization procedure and needs to be replaced by\n-   --  the formal parameter of the initialization procedure which\n-   --  corresponds to that discriminant.\n+   --  References to a discriminant inside the record type declaration can\n+   --  appear either in the subtype_indication to constrain a record or an\n+   --  array, or as part of a larger expression given for the initial value\n+   --  of a component. In both of these cases N appears in the record\n+   --  initialization procedure and needs to be replaced by the formal\n+   --  parameter of the initialization procedure which corresponds to that\n+   --  discriminant.\n \n    --  In the example below, references to discriminants D1 and D2 in proc_1\n    --  are replaced by references to formals with the same name\n    --  (discriminals)\n \n-   --  A similar replacement is done for calls to any record\n-   --  initialization procedure for any components that are themselves\n-   --  of a record type.\n+   --  A similar replacement is done for calls to any record initialization\n+   --  procedure for any components that are themselves of a record type.\n \n    --  type R (D1, D2 : Integer) is record\n    --     X : Integer := F * D1;\n@@ -1113,8 +1313,12 @@ package body Exp_Ch3 is\n       --  Nothing to do if the Init_Proc is null, unless Initialize_Scalars\n       --  is active (in which case we make the call anyway, since in the\n       --  actual compiled client it may be non null).\n+      --  Also nothing to do for value types.\n \n-      if Is_Null_Init_Proc (Proc) and then not Init_Or_Norm_Scalars then\n+      if (Is_Null_Init_Proc (Proc) and then not Init_Or_Norm_Scalars)\n+        or else Is_Value_Type (Typ)\n+        or else Is_Value_Type (Component_Type (Typ))\n+      then\n          return Empty_List;\n       end if;\n \n@@ -1199,9 +1403,9 @@ package body Exp_Ch3 is\n          while Present (Discr) loop\n \n             --  If this is a discriminated concurrent type, the init_proc\n-            --  for the corresponding record is being called. Use that\n-            --  type directly to find the discriminant value, to handle\n-            --  properly intervening renamed discriminants.\n+            --  for the corresponding record is being called. Use that type\n+            --  directly to find the discriminant value, to handle properly\n+            --  intervening renamed discriminants.\n \n             declare\n                T : Entity_Id := Full_Type;\n@@ -1248,11 +1452,10 @@ package body Exp_Ch3 is\n                       Prefix         => New_Copy (Prefix (Id_Ref)),\n                       Attribute_Name => Name_Unrestricted_Access);\n \n-               --  Otherwise make a copy of the default expression. Note\n-               --  that we use the current Sloc for this, because we do not\n-               --  want the call to appear to be at the declaration point.\n-               --  Within the expression, replace discriminants with their\n-               --  discriminals.\n+               --  Otherwise make a copy of the default expression. Note that\n+               --  we use the current Sloc for this, because we do not want the\n+               --  call to appear to be at the declaration point. Within the\n+               --  expression, replace discriminants with their discriminals.\n \n                else\n                   Arg :=\n@@ -1263,9 +1466,9 @@ package body Exp_Ch3 is\n                if Is_Constrained (Full_Type) then\n                   Arg := Duplicate_Subexpr_No_Checks (Arg);\n                else\n-                  --  The constraints come from the discriminant default\n-                  --  exps, they must be reevaluated, so we use New_Copy_Tree\n-                  --  but we ensure the proper Sloc (for any embedded calls).\n+                  --  The constraints come from the discriminant default exps,\n+                  --  they must be reevaluated, so we use New_Copy_Tree but we\n+                  --  ensure the proper Sloc (for any embedded calls).\n \n                   Arg := New_Copy_Tree (Arg, New_Sloc => Loc);\n                end if;\n@@ -1324,6 +1527,7 @@ package body Exp_Ch3 is\n          --  If the enclosing type is an extension with new controlled\n          --  components, it has his own record controller. If the parent\n          --  also had a record controller, attach it to the new one.\n+\n          --  Build_Init_Statements relies on the fact that in this specific\n          --  case the last statement of the result is the attach call to\n          --  the controller. If this is changed, it must be synchronized.\n@@ -1428,11 +1632,11 @@ package body Exp_Ch3 is\n       Set_Tag     : Entity_Id := Empty;\n \n       function Build_Assignment (Id : Entity_Id; N : Node_Id) return List_Id;\n-      --  Build a assignment statement node which assigns to record\n-      --  component its default expression if defined. The left hand side\n-      --  of the assignment is marked Assignment_OK so that initialization\n-      --  of limited private records works correctly, Return also the\n-      --  adjustment call for controlled objects\n+      --  Build a assignment statement node which assigns to record component\n+      --  its default expression if defined. The assignment left hand side is\n+      --  marked Assignment_OK so that initialization of limited private\n+      --  records works correctly, Return also the adjustment call for\n+      --  controlled objects\n \n       procedure Build_Discriminant_Assignments (Statement_List : List_Id);\n       --  If the record has discriminants, adds assignment statements to\n@@ -1472,18 +1676,18 @@ package body Exp_Ch3 is\n       --  parent of a type with discriminants has secondary dispatch tables.\n \n       procedure Build_Record_Checks (S : Node_Id; Check_List : List_Id);\n-      --  Add range checks to components of disciminated records. S is a\n+      --  Add range checks to components of discriminated records. S is a\n       --  subtype indication of a record component. Check_List is a list\n       --  to which the check actions are appended.\n \n       function Component_Needs_Simple_Initialization\n         (T : Entity_Id) return Boolean;\n       --  Determines if a component needs simple initialization, given its type\n       --  T. This is the same as Needs_Simple_Initialization except for the\n-      --  following difference: the types Tag, Interface_Tag, and Vtable_Ptr\n-      --  which are access types which would normally require simple\n-      --  initialization to null, do not require initialization as components,\n-      --  since they are explicitly initialized by other means.\n+      --  following difference: the types Tag and Interface_Tag, that are\n+      --  access types which would normally require simple initialization to\n+      --  null, do not require initialization as components, since they are\n+      --  explicitly initialized by other means.\n \n       procedure Constrain_Array\n         (SI         : Node_Id;\n@@ -1497,12 +1701,12 @@ package body Exp_Ch3 is\n         (Index      : Node_Id;\n          S          : Node_Id;\n          Check_List : List_Id);\n-      --  Called from Build_Record_Checks.\n       --  Process an index constraint in a constrained array declaration.\n       --  The constraint can be a subtype name, or a range with or without\n       --  an explicit subtype mark. The index is the corresponding index of the\n       --  unconstrained array. S is the range expression. Check_List is a list\n-      --  to which the check actions are appended.\n+      --  to which the check actions are appended (called from\n+      --  Build_Record_Checks).\n \n       function Parent_Subtype_Renaming_Discrims return Boolean;\n       --  Returns True for base types N that rename discriminants, else False\n@@ -1570,9 +1774,9 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         --  Take a copy of Exp to ensure that later copies of this\n-         --  component_declaration in derived types see the original tree,\n-         --  not a node rewritten during expansion of the init_proc.\n+         --  Take a copy of Exp to ensure that later copies of this component\n+         --  declaration in derived types see the original tree, not a node\n+         --  rewritten during expansion of the init_proc.\n \n          Exp := New_Copy_Tree (Exp);\n \n@@ -1584,10 +1788,10 @@ package body Exp_Ch3 is\n          Set_No_Ctrl_Actions (First (Res));\n \n          --  Adjust the tag if tagged (because of possible view conversions).\n-         --  Suppress the tag adjustment when Java_VM because JVM tags are\n+         --  Suppress the tag adjustment when VM_Target because VM tags are\n          --  represented implicitly in objects.\n \n-         if Is_Tagged_Type (Typ) and then not Java_VM then\n+         if Is_Tagged_Type (Typ) and then VM_Target = No_VM then\n             Append_To (Res,\n               Make_Assignment_Statement (Loc,\n                 Name =>\n@@ -1602,15 +1806,16 @@ package body Exp_Ch3 is\n                       (Node (First_Elmt (Access_Disp_Table (Typ))), Loc))));\n          end if;\n \n-         --  Adjust the component if controlled except if it is an\n-         --  aggregate that will be expanded inline\n+         --  Adjust the component if controlled except if it is an aggregate\n+         --  that will be expanded inline\n \n          if Kind = N_Qualified_Expression then\n             Kind := Nkind (Expression (N));\n          end if;\n \n          if Controlled_Type (Typ)\n          and then not (Kind = N_Aggregate or else Kind = N_Extension_Aggregate)\n+         and then not Is_Inherently_Limited_Type (Typ)\n          then\n             Append_List_To (Res,\n               Make_Adjust_Call (\n@@ -1839,8 +2044,9 @@ package body Exp_Ch3 is\n                      if Typ = Rec_Type then\n                         Body_Node := New_Node (N_Subprogram_Body, Loc);\n \n-                        Func_Id := Make_Defining_Identifier (Loc,\n-                                     New_Internal_Name ('F'));\n+                        Func_Id :=\n+                          Make_Defining_Identifier (Loc,\n+                            Chars => New_Internal_Name ('F'));\n \n                         Set_DT_Offset_To_Top_Func (E, Func_Id);\n \n@@ -1908,9 +2114,8 @@ package body Exp_Ch3 is\n             return;\n          end if;\n \n-         --  Skip the first _Tag, which is the main tag of the\n-         --  tagged type. Following tags correspond with abstract\n-         --  interfaces.\n+         --  Skip the first _Tag, which is the main tag of the tagged type.\n+         --  Following tags correspond with abstract interfaces.\n \n          ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Rec_Type)));\n \n@@ -1961,7 +2166,8 @@ package body Exp_Ch3 is\n            and then not Is_CPP_Class (Rec_Type)\n          then\n             Set_Tag :=\n-                  Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('P'));\n \n             Append_To (Parameters,\n               Make_Parameter_Specification (Loc,\n@@ -2021,18 +2227,19 @@ package body Exp_Ch3 is\n \n          --  Add here the assignment to instantiate the Tag\n \n-         --  The assignement corresponds to the code:\n+         --  The assignment corresponds to the code:\n \n          --     _Init._Tag := Typ'Tag;\n \n-         --  Suppress the tag assignment when Java_VM because JVM tags are\n-         --  represented implicitly in objects. It is also suppressed in\n-         --  case of CPP_Class types because in this case the tag is\n-         --  initialized in the C++ side.\n+         --  Suppress the tag assignment when VM_Target because VM tags are\n+         --  represented implicitly in objects. It is also suppressed in case\n+         --  of CPP_Class types because in this case the tag is initialized in\n+         --  the C++ side.\n \n          if Is_Tagged_Type (Rec_Type)\n            and then not Is_CPP_Class (Rec_Type)\n-           and then not Java_VM\n+           and then VM_Target = No_VM\n+           and then not No_Run_Time_Mode\n          then\n             Init_Tag :=\n               Make_Assignment_Statement (Loc,\n@@ -2048,10 +2255,11 @@ package body Exp_Ch3 is\n \n             --  The tag must be inserted before the assignments to other\n             --  components,  because the initial value of the component may\n-            --  depend ot the tag (eg. through a dispatching operation on\n+            --  depend on the tag (eg. through a dispatching operation on\n             --  an access to the current type). The tag assignment is not done\n             --  when initializing the parent component of a type extension,\n             --  because in that case the tag is set in the extension.\n+\n             --  Extensions of imported C++ classes add a final complication,\n             --  because we cannot inhibit tag setting in the constructor for\n             --  the parent. In that case we insert the tag initialization\n@@ -2065,6 +2273,10 @@ package body Exp_Ch3 is\n \n                Prepend_To (Body_Stmts, Init_Tag);\n \n+            --  CPP_Class: In this case the dispatch table of the parent was\n+            --  built in the C++ side and we copy the table of the parent to\n+            --  initialize the new dispatch table.\n+\n             else\n                declare\n                   Nod   : Node_Id := First (Body_Stmts);\n@@ -2110,12 +2322,10 @@ package body Exp_Ch3 is\n \n                   Insert_After (Nod, Init_Tag);\n \n-                  --  We have inherited the whole contents of the DT table\n-                  --  from the CPP side. Therefore all our previous initia-\n-                  --  lization has been lost and we must refill entries\n-                  --  associated with Ada primitives. This needs more work\n-                  --  to avoid its execution each time an object is\n-                  --  initialized???\n+                  --  We have inherited table of the parent from the CPP side.\n+                  --  Now we fill the slots associated with Ada primitives.\n+                  --  This needs more work to avoid its execution each time\n+                  --  an object is initialized???\n \n                   declare\n                      E    : Elmt_Id;\n@@ -2131,8 +2341,9 @@ package body Exp_Ch3 is\n                           and then not Present (Abstract_Interface_Alias\n                                                  (Prim))\n                         then\n-                           Insert_After (Init_Tag,\n-                              Fill_DT_Entry (Loc, Prim));\n+                           Register_Primitive (Loc,\n+                             Prim    => Prim,\n+                             Ins_Nod => Init_Tag);\n                         end if;\n \n                         Next_Elmt (E);\n@@ -2141,11 +2352,13 @@ package body Exp_Ch3 is\n                end;\n             end if;\n \n-            --  Ada 2005 (AI-251): Initialization of all the tags\n-            --  corresponding with abstract interfaces\n+            --  Ada 2005 (AI-251): Initialization of all the tags corresponding\n+            --  with abstract interfaces\n \n-            if Ada_Version >= Ada_05\n+            if VM_Target = No_VM\n+              and then Ada_Version >= Ada_05\n               and then not Is_Interface (Rec_Type)\n+              and then Has_Abstract_Interfaces (Rec_Type)\n             then\n                Init_Secondary_Tags\n                  (Typ        => Rec_Type,\n@@ -2174,7 +2387,12 @@ package body Exp_Ch3 is\n \n          if List_Length (Body_Stmts) = 1\n            and then Nkind (First (Body_Stmts)) = N_Null_Statement\n+           and then VM_Target /= CLI_Target\n          then\n+            --  Even though the init proc may be null at this time it might get\n+            --  some stuff added to it later by the CIL backend, so always keep\n+            --  it when VM_Target = CLI_Target.\n+\n             Set_Is_Null_Init_Proc (Proc_Id);\n          end if;\n       end Build_Init_Procedure;\n@@ -2309,15 +2527,16 @@ package body Exp_Ch3 is\n                   --  the _Parent field is attached to it when the attachment\n                   --  can occur. It does not work to simply initialize the\n                   --  controller first: it must be initialized after the parent\n-                  --  if the parent holds discriminants that can be used\n-                  --  to compute the offset of the controller. We assume here\n-                  --  that the last statement of the initialization call is the\n+                  --  if the parent holds discriminants that can be used to\n+                  --  compute the offset of the controller. We assume here that\n+                  --  the last statement of the initialization call is the\n                   --  attachment of the parent (see Build_Initialization_Call)\n \n                   if Chars (Id) = Name_uController\n                     and then Rec_Type /= Etype (Rec_Type)\n                     and then Has_Controlled_Component (Etype (Rec_Type))\n                     and then Has_New_Controlled_Component (Rec_Type)\n+                    and then Present (Last (Statement_List))\n                   then\n                      Insert_List_Before (Last (Statement_List), Stmts);\n                   else\n@@ -2334,7 +2553,6 @@ package body Exp_Ch3 is\n             --  Second pass: components with per-object constraints\n \n             Decl := First_Non_Pragma (Component_Items (Comp_List));\n-\n             while Present (Decl) loop\n                Loc := Sloc (Decl);\n                Id := Defining_Identifier (Decl);\n@@ -2372,7 +2590,6 @@ package body Exp_Ch3 is\n          if Present (Variant_Part (Comp_List)) then\n             Alt_List := New_List;\n             Variant := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n-\n             while Present (Variant) loop\n                Loc := Sloc (Variant);\n                Append_To (Alt_List,\n@@ -2381,7 +2598,6 @@ package body Exp_Ch3 is\n                      New_Copy_List (Discrete_Choices (Variant)),\n                    Statements =>\n                      Build_Init_Statements (Component_List (Variant))));\n-\n                Next_Non_Pragma (Variant);\n             end loop;\n \n@@ -2623,7 +2839,7 @@ package body Exp_Ch3 is\n          end if;\n \n          --  Check if we have done some trivial renaming of the parent\n-         --  discriminants, i.e. someting like\n+         --  discriminants, i.e. something like\n          --\n          --    type DT (X1,X2: int) is new PT (X1,X2);\n \n@@ -2711,6 +2927,9 @@ package body Exp_Ch3 is\n          if Is_CPP_Class (Rec_Id) then\n             return False;\n \n+         elsif Is_Interface (Rec_Id) then\n+            return False;\n+\n          elsif not Restriction_Active (No_Initialize_Scalars)\n            and then Is_Public (Rec_Id)\n          then\n@@ -2749,6 +2968,10 @@ package body Exp_Ch3 is\n    begin\n       Rec_Type := Defining_Identifier (N);\n \n+      if Is_Value_Type (Rec_Type) then\n+         return;\n+      end if;\n+\n       --  This may be full declaration of a private type, in which case\n       --  the visible entity is a record, and the private entity has been\n       --  exchanged with it in the private part of the current package.\n@@ -2824,6 +3047,9 @@ package body Exp_Ch3 is\n          if not Debug_Generated_Code then\n             Set_Debug_Info_Off (Proc_Id);\n          end if;\n+\n+         Set_Static_Initialization\n+           (Proc_Id, Build_Equivalent_Record_Aggregate (Rec_Type));\n       end if;\n    end Build_Record_Init_Proc;\n \n@@ -2834,9 +3060,10 @@ package body Exp_Ch3 is\n    --  Generates the following subprogram:\n \n    --    procedure Assign\n-   --     (Source,   Target   : Array_Type,\n-   --      Left_Lo,  Left_Hi, Right_Lo, Right_Hi : Index;\n-   --      Rev :     Boolean)\n+   --     (Source,  Target    : Array_Type,\n+   --      Left_Lo, Left_Hi   : Index;\n+   --      Right_Lo, Right_Hi : Index;\n+   --      Rev                : Boolean)\n    --    is\n    --       Li1 : Index;\n    --       Ri1 : Index;\n@@ -2851,21 +3078,21 @@ package body Exp_Ch3 is\n    --       end if;\n \n    --       loop\n-   --             if Rev then\n-   --                exit when Li1 < Left_Lo;\n-   --             else\n-   --                exit when Li1 > Left_Hi;\n-   --             end if;\n-\n-   --             Target (Li1) := Source (Ri1);\n-\n-   --             if Rev then\n-   --                Li1 := Index'pred (Li1);\n-   --                Ri1 := Index'pred (Ri1);\n-   --             else\n-   --                Li1 := Index'succ (Li1);\n-   --                Ri1 := Index'succ (Ri1);\n-   --             end if;\n+   --          if Rev then\n+   --             exit when Li1 < Left_Lo;\n+   --          else\n+   --             exit when Li1 > Left_Hi;\n+   --          end if;\n+\n+   --          Target (Li1) := Source (Ri1);\n+\n+   --          if Rev then\n+   --             Li1 := Index'pred (Li1);\n+   --             Ri1 := Index'pred (Ri1);\n+   --          else\n+   --             Li1 := Index'succ (Li1);\n+   --             Ri1 := Index'succ (Ri1);\n+   --          end if;\n    --       end loop;\n    --    end Assign;\n \n@@ -3161,11 +3388,12 @@ package body Exp_Ch3 is\n    --                return False;\n    --             end if;\n    --       end case;\n+\n    --       return True;\n    --    end _Equality;\n \n    procedure Build_Variant_Record_Equality (Typ : Entity_Id) is\n-      Loc   : constant Source_Ptr := Sloc (Typ);\n+      Loc : constant Source_Ptr := Sloc (Typ);\n \n       F : constant Entity_Id :=\n             Make_Defining_Identifier (Loc,\n@@ -3179,9 +3407,9 @@ package body Exp_Ch3 is\n             Make_Defining_Identifier (Loc,\n               Chars => Name_Y);\n \n-      Def   : constant Node_Id := Parent (Typ);\n-      Comps : constant Node_Id := Component_List (Type_Definition (Def));\n-      Stmts : constant List_Id := New_List;\n+      Def    : constant Node_Id := Parent (Typ);\n+      Comps  : constant Node_Id := Component_List (Type_Definition (Def));\n+      Stmts  : constant List_Id := New_List;\n       Pspecs : constant List_Id := New_List;\n \n    begin\n@@ -3539,6 +3767,7 @@ package body Exp_Ch3 is\n             --  processing for type Ref.\n \n            and then Convention (Designated_Type (Def_Id)) /= Convention_Java\n+           and then Convention (Designated_Type (Def_Id)) /= Convention_CIL\n          then\n             Build_Class_Wide_Master (Def_Id);\n          end if;\n@@ -3593,16 +3822,22 @@ package body Exp_Ch3 is\n                Next_Entity (Comp);\n             end loop;\n \n-            --  If found we add a renaming reclaration of master_id and we\n+            --  If found we add a renaming declaration of master_id and we\n             --  associate it to each anonymous access type component. Do\n             --  nothing if the access type already has a master. This will be\n             --  the case if the array type is the packed array created for a\n             --  user-defined array type T, where the master_id is created when\n             --  expanding the declaration for T.\n \n             if Present (Comp)\n+              and then Ekind (Typ) = E_Anonymous_Access_Type\n               and then not Restriction_Active (No_Task_Hierarchy)\n               and then No (Master_Id (Typ))\n+\n+               --  Do not consider run-times with no tasking support\n+\n+              and then RTE_Available (RE_Current_Master)\n+              and then Has_Task (Non_Limited_Designated_Type (Typ))\n             then\n                Build_Master_Entity (Def_Id);\n                M_Id := Build_Master_Renaming (N, Def_Id);\n@@ -3692,13 +3927,14 @@ package body Exp_Ch3 is\n    --  For all types, we call an initialization procedure if there is one\n \n    procedure Expand_N_Object_Declaration (N : Node_Id) is\n-      Def_Id  : constant Entity_Id  := Defining_Identifier (N);\n-      Expr    : constant Node_Id    := Expression (N);\n-      Loc     : constant Source_Ptr := Sloc (N);\n-      Typ     : constant Entity_Id  := Etype (Def_Id);\n-      Expr_Q  : Node_Id;\n-      Id_Ref  : Node_Id;\n-      New_Ref : Node_Id;\n+      Def_Id   : constant Entity_Id  := Defining_Identifier (N);\n+      Expr     : constant Node_Id    := Expression (N);\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Typ      : constant Entity_Id  := Etype (Def_Id);\n+      Expr_Q   : Node_Id;\n+      Id_Ref   : Node_Id;\n+      New_Ref  : Node_Id;\n+      BIP_Call : Boolean := False;\n \n    begin\n       --  Don't do anything for deferred constants. All proper actions will\n@@ -3724,6 +3960,16 @@ package body Exp_Ch3 is\n          Build_Master_Entity (Def_Id);\n       end if;\n \n+      --  Build a list controller for declarations of the form\n+      --    Obj : access Some_Type [:= Expression];\n+\n+      if Ekind (Typ) = E_Anonymous_Access_Type\n+        and then Is_Controlled (Directly_Designated_Type (Typ))\n+        and then No (Associated_Final_Chain (Typ))\n+      then\n+         Build_Final_List (N, Typ);\n+      end if;\n+\n       --  Default initialization required, and no expression present\n \n       if No (Expr) then\n@@ -3799,6 +4045,7 @@ package body Exp_Ch3 is\n \n          if Has_Non_Null_Base_Init_Proc (Typ)\n            and then not No_Initialization (N)\n+           and then not Is_Value_Type (Typ)\n          then\n             --  The call to the initialization procedure does NOT freeze the\n             --  object being initialized. This is because the call is not a\n@@ -3811,19 +4058,34 @@ package body Exp_Ch3 is\n             Set_Must_Not_Freeze (Id_Ref);\n             Set_Assignment_OK (Id_Ref);\n \n-            Insert_Actions_After (N,\n-              Build_Initialization_Call (Loc, Id_Ref, Typ));\n+            declare\n+               Init_Expr : constant Node_Id :=\n+                             Static_Initialization (Base_Init_Proc (Typ));\n+            begin\n+               if Present (Init_Expr) then\n+                  Set_Expression\n+                    (N, New_Copy_Tree (Init_Expr, New_Scope => Current_Scope));\n+                  return;\n+               else\n+                  Initialization_Warning (Id_Ref);\n+\n+                  Insert_Actions_After (N,\n+                    Build_Initialization_Call (Loc, Id_Ref, Typ));\n+               end if;\n+            end;\n \n          --  If simple initialization is required, then set an appropriate\n          --  simple initialization expression in place. This special\n-         --  initialization is required even though No_Init_Flag is present.\n+         --  initialization is required even though No_Init_Flag is present,\n+         --  but is not needed if there was an explicit initialization.\n \n          --  An internally generated temporary needs no initialization because\n          --  it will be assigned subsequently. In particular, there is no point\n          --  in applying Initialize_Scalars to such a temporary.\n \n          elsif Needs_Simple_Initialization (Typ)\n-            and then not Is_Internal (Def_Id)\n+           and then not Is_Internal (Def_Id)\n+           and then not Has_Init_Expression (N)\n          then\n             Set_No_Initialization (N, False);\n             Set_Expression (N, Get_Simple_Init_Val (Typ, Loc, Esize (Def_Id)));\n@@ -3835,6 +4097,7 @@ package body Exp_Ch3 is\n          if Persistent_BSS_Mode\n            and then Comes_From_Source (N)\n            and then Is_Potentially_Persistent_Type (Typ)\n+           and then not Has_Init_Expression (N)\n            and then Is_Library_Level_Entity (Def_Id)\n          then\n             declare\n@@ -3878,13 +4141,14 @@ package body Exp_Ch3 is\n             --  call to a build-in-place function, then access to the declared\n             --  object must be passed to the function. Currently we limit such\n             --  functions to those with constrained limited result subtypes,\n-            --  but eventually we plan to expand the allowed forms of funtions\n+            --  but eventually we plan to expand the allowed forms of functions\n             --  that are treated as build-in-place.\n \n             if Ada_Version >= Ada_05\n               and then Is_Build_In_Place_Function_Call (Expr_Q)\n             then\n                Make_Build_In_Place_Call_In_Object_Declaration (N, Expr_Q);\n+               BIP_Call := True;\n             end if;\n \n             --  In most cases, we must check that the initial value meets any\n@@ -3937,8 +4201,9 @@ package body Exp_Ch3 is\n \n                       Object_Definition =>\n                         Make_Attribute_Reference (Loc,\n-                          Prefix => Make_Identifier (Loc,\n-                                      Chars (Root_Type (Etype (Def_Id)))),\n+                          Prefix =>\n+                            New_Occurrence_Of\n+                              (Root_Type (Etype (Def_Id)), Loc),\n                           Attribute_Name => Name_Class),\n \n                       Expression =>\n@@ -3966,8 +4231,8 @@ package body Exp_Ch3 is\n                       Subtype_Mark =>\n                         Make_Attribute_Reference (Loc,\n                           Prefix =>\n-                            Make_Identifier (Loc,\n-                              Chars => Chars (Root_Type (Etype (Def_Id)))),\n+                            New_Occurrence_Of\n+                              (Root_Type (Etype (Def_Id)), Loc),\n                           Attribute_Name => Name_Class),\n \n                       Name =>\n@@ -4003,74 +4268,49 @@ package body Exp_Ch3 is\n                   --  correct replacement of the object declaration by this\n                   --  object renaming declaration (because such definings\n                   --  identifier have been previously added by Enter_Name to\n-                  --  the current scope).\n+                  --  the current scope). We must preserve the homonym chain\n+                  --  of the source entity as well.\n \n                   Set_Chars (Defining_Identifier (N), Chars (Def_Id));\n+                  Set_Homonym (Defining_Identifier (N), Homonym (Def_Id));\n                   Exchange_Entities (Defining_Identifier (N), Def_Id);\n \n                   return;\n                end;\n             end if;\n \n-            --  If the type is controlled we attach the object to the final\n-            --  list and adjust the target after the copy. This\n-            --  ??? incomplete sentence\n-\n-            if Controlled_Type (Typ) then\n-               declare\n-                  Flist : Node_Id;\n-                  F     : Entity_Id;\n-\n-               begin\n-                  --  Attach the result to a dummy final list which will never\n-                  --  be finalized if Delay_Finalize_Attachis set. It is\n-                  --  important to attach to a dummy final list rather than not\n-                  --  attaching at all in order to reset the pointers coming\n-                  --  from the initial value. Equivalent code exists in the\n-                  --  sec-stack case in Exp_Ch4.Expand_N_Allocator.\n-\n-                  if Delay_Finalize_Attach (N) then\n-                     F :=\n-                       Make_Defining_Identifier (Loc, New_Internal_Name ('F'));\n-                     Insert_Action (N,\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => F,\n-                         Object_Definition   =>\n-                           New_Reference_To (RTE (RE_Finalizable_Ptr), Loc)));\n-\n-                     Flist := New_Reference_To (F, Loc);\n-\n-                  else\n-                     Flist := Find_Final_List (Def_Id);\n-                  end if;\n+            --  If the type is controlled and not limited then the target is\n+            --  adjusted after the copy and attached to the finalization list.\n+            --  However, no adjustment is done in the case where the object was\n+            --  initialized by a call to a function whose result is built in\n+            --  place, since no copy occurred. (We eventually plan to support\n+            --  in-place function results for some nonlimited types. ???)\n \n-                  --  Adjustment is only needed when the controlled type is not\n-                  --  limited.\n-\n-                  if not Is_Limited_Type (Typ) then\n-                     Insert_Actions_After (N,\n-                       Make_Adjust_Call (\n-                         Ref          => New_Reference_To (Def_Id, Loc),\n-                         Typ          => Base_Type (Typ),\n-                         Flist_Ref    => Flist,\n-                         With_Attach  => Make_Integer_Literal (Loc, 1)));\n-                  end if;\n-               end;\n+            if Controlled_Type (Typ)\n+              and then not Is_Limited_Type (Typ)\n+              and then not BIP_Call\n+            then\n+               Insert_Actions_After (N,\n+                 Make_Adjust_Call (\n+                   Ref          => New_Reference_To (Def_Id, Loc),\n+                   Typ          => Base_Type (Typ),\n+                   Flist_Ref    => Find_Final_List (Def_Id),\n+                   With_Attach  => Make_Integer_Literal (Loc, 1)));\n             end if;\n \n             --  For tagged types, when an init value is given, the tag has to\n             --  be re-initialized separately in order to avoid the propagation\n             --  of a wrong tag coming from a view conversion unless the type\n             --  is class wide (in this case the tag comes from the init value).\n-            --  Suppress the tag assignment when Java_VM because JVM tags are\n+            --  Suppress the tag assignment when VM_Target because VM tags are\n             --  represented implicitly in objects. Ditto for types that are\n             --  CPP_CLASS, and for initializations that are aggregates, because\n             --  they have to have the right tag.\n \n             if Is_Tagged_Type (Typ)\n               and then not Is_Class_Wide_Type (Typ)\n               and then not Is_CPP_Class (Typ)\n-              and then not Java_VM\n+              and then VM_Target = No_VM\n               and then Nkind (Expr) /= N_Aggregate\n             then\n                --  The re-assignment of the tag has to be done even if the\n@@ -4159,13 +4399,6 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n-      --  For array type, check for size too large\n-      --  We really need this for record types too???\n-\n-      if Is_Array_Type (Typ) then\n-         Apply_Array_Size_Check (N, Typ);\n-      end if;\n-\n    exception\n       when RE_Not_Available =>\n          return;\n@@ -4311,15 +4544,25 @@ package body Exp_Ch3 is\n          if not Is_Tagged_Type (T) then\n             Insert_Before (First_Comp, Comp_Decl);\n \n-         --  if T is a tagged type, place controller declaration after\n-         --  parent field and after eventual tags of implemented\n-         --  interfaces, if present.\n+         --  if T is a tagged type, place controller declaration after parent\n+         --  field and after eventual tags of interface types.\n \n          else\n             while Present (First_Comp)\n               and then\n                 (Chars (Defining_Identifier (First_Comp)) = Name_uParent\n-                   or else Is_Tag (Defining_Identifier (First_Comp)))\n+                   or else Is_Tag (Defining_Identifier (First_Comp))\n+\n+               --  Ada 2005 (AI-251): The following condition covers secondary\n+               --  tags but also the adjacent component contanining the offset\n+               --  to the base of the object (component generated if the parent\n+               --  has discriminants ---see Add_Interface_Tag_Components). This\n+               --  is required to avoid the addition of the controller between\n+               --  the secondary tag and its adjacent component.\n+\n+                   or else Present\n+                             (Related_Interface\n+                               (Defining_Identifier (First_Comp))))\n             loop\n                Next (First_Comp);\n             end loop;\n@@ -4336,7 +4579,7 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n-      New_Scope (T);\n+      Push_Scope (T);\n       Analyze (Comp_Decl);\n       Set_Ekind (Ent, E_Component);\n       Init_Component_Location (Ent);\n@@ -4441,6 +4684,7 @@ package body Exp_Ch3 is\n       if Has_Task (Typ)\n         and then not Restriction_Active (No_Implicit_Heap_Allocations)\n         and then not Global_Discard_Names\n+        and then VM_Target = No_VM\n       then\n          Set_Uses_Sec_Stack (Proc_Id);\n       end if;\n@@ -4471,8 +4715,8 @@ package body Exp_Ch3 is\n \n             --  If this is an anonymous array created for a declaration with\n             --  an initial value, its init_proc will never be called. The\n-            --  initial value itself may have been expanded into assign-\n-            --  ments, in which case the object declaration is carries the\n+            --  initial value itself may have been expanded into assignments,\n+            --  in which case the object declaration is carries the\n             --  No_Initialization flag.\n \n             if Is_Itype (Base)\n@@ -4655,6 +4899,8 @@ package body Exp_Ch3 is\n       --  case and there is no obligation to raise Constraint_Error here!) We\n       --  also do this if pragma Restrictions (No_Exceptions) is active.\n \n+      --  Is this right??? What about No_Exception_Propagation???\n+\n       --  Representations are signed\n \n       if Enumeration_Rep (First_Literal (Typ)) < 0 then\n@@ -4727,7 +4973,6 @@ package body Exp_Ch3 is\n \n       else\n          Ent := First_Literal (Typ);\n-\n          while Present (Ent) loop\n             Append_To (Lst,\n               Make_Case_Statement_Alternative (Loc,\n@@ -4747,7 +4992,7 @@ package body Exp_Ch3 is\n \n       --  In normal mode, add the others clause with the test\n \n-      if not Restriction_Active (No_Exception_Handlers) then\n+      if not No_Exception_Handlers_Set then\n          Append_To (Lst,\n            Make_Case_Statement_Alternative (Loc,\n              Discrete_Choices => New_List (Make_Others_Choice (Loc)),\n@@ -4759,8 +5004,8 @@ package body Exp_Ch3 is\n                  Expression =>\n                    Make_Integer_Literal (Loc, -1)))));\n \n-      --  If Restriction (No_Exceptions_Handlers) is active then we always\n-      --  return -1 (since we cannot usefully raise Constraint_Error in\n+      --  If either of the restrictions No_Exceptions_Handlers/Propagation is\n+      --  active then return -1 (we cannot usefully raise Constraint_Error in\n       --  this case). See description above for further details.\n \n       else\n@@ -4907,18 +5152,18 @@ package body Exp_Ch3 is\n          Next_Component (Comp);\n       end loop;\n \n-      --  Creation of the Dispatch Table. Note that a Dispatch Table is\n-      --  created for regular tagged types as well as for Ada types deriving\n-      --  from a C++ Class, but not for tagged types directly corresponding to\n-      --  the C++ classes. In the later case we assume that the Vtable is\n-      --  created in the C++ side and we just use it.\n+      --  Creation of the Dispatch Table. Note that a Dispatch Table is built\n+      --  for regular tagged types as well as for Ada types deriving from a C++\n+      --  Class, but not for tagged types directly corresponding to C++ classes\n+      --  In the later case we assume that it is created in the C++ side and we\n+      --  just use it.\n \n       if Is_Tagged_Type (Def_Id) then\n \n          if Is_CPP_Class (Def_Id) then\n \n             --  Because of the new C++ ABI compatibility we now allow the\n-            --  programer to use the Ada tag (and in this case we must do\n+            --  programmer to use the Ada tag (and in this case we must do\n             --  the normal expansion of the tag)\n \n             if Etype (First_Component (Def_Id)) = RTE (RE_Tag)\n@@ -4930,42 +5175,51 @@ package body Exp_Ch3 is\n             Set_All_DT_Position (Def_Id);\n             Set_Default_Constructor (Def_Id);\n \n+            --  With CPP_Class types Make_DT does a minimum decoration of the\n+            --  Access_Disp_Table list.\n+\n+            if VM_Target = No_VM then\n+               Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n+            end if;\n+\n          else\n-            --  Usually inherited primitives are not delayed but the first Ada\n-            --  extension of a CPP_Class is an exception since the address of\n-            --  the inherited subprogram has to be inserted in the new Ada\n-            --  Dispatch Table and this is a freezing action (usually the\n-            --  inherited primitive address is inserted in the DT by\n-            --  Inherit_DT)\n-\n-            --  Similarly, if this is an inherited operation whose parent is\n-            --  not frozen yet, it is not in the DT of the parent, and we\n-            --  generate an explicit freeze node for the inherited operation,\n-            --  so that it is properly inserted in the DT of the current type.\n+            if not Static_Dispatch_Tables then\n \n-            declare\n-               Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Def_Id));\n-               Subp : Entity_Id;\n+               --  Usually inherited primitives are not delayed but the first\n+               --  Ada extension of a CPP_Class is an exception since the\n+               --  address of the inherited subprogram has to be inserted in\n+               --  the new Ada Dispatch Table and this is a freezing action.\n \n-            begin\n-               while Present (Elmt) loop\n-                  Subp := Node (Elmt);\n-\n-                  if Present (Alias (Subp)) then\n-                     if Is_CPP_Class (Etype (Def_Id)) then\n-                        Set_Has_Delayed_Freeze (Subp);\n-\n-                     elsif Has_Delayed_Freeze (Alias (Subp))\n-                       and then not Is_Frozen (Alias (Subp))\n-                     then\n-                        Set_Is_Frozen (Subp, False);\n-                        Set_Has_Delayed_Freeze (Subp);\n+               --  Similarly, if this is an inherited operation whose parent is\n+               --  not frozen yet, it is not in the DT of the parent, and we\n+               --  generate an explicit freeze node for the inherited operation\n+               --  so that it is properly inserted in the DT of the current\n+               --  type.\n+\n+               declare\n+                  Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Def_Id));\n+                  Subp : Entity_Id;\n+\n+               begin\n+                  while Present (Elmt) loop\n+                     Subp := Node (Elmt);\n+\n+                     if Present (Alias (Subp)) then\n+                        if Is_CPP_Class (Etype (Def_Id)) then\n+                           Set_Has_Delayed_Freeze (Subp);\n+\n+                        elsif Has_Delayed_Freeze (Alias (Subp))\n+                          and then not Is_Frozen (Alias (Subp))\n+                        then\n+                           Set_Is_Frozen (Subp, False);\n+                           Set_Has_Delayed_Freeze (Subp);\n+                        end if;\n                      end if;\n-                  end if;\n \n-                  Next_Elmt (Elmt);\n-               end loop;\n-            end;\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+               end;\n+            end if;\n \n             if Underlying_Type (Etype (Def_Id)) = Def_Id then\n                Expand_Tagged_Root (Def_Id);\n@@ -5016,7 +5270,7 @@ package body Exp_Ch3 is\n                Insert_Actions (N, Null_Proc_Decl_List);\n             end if;\n \n-            Set_Is_Frozen (Def_Id, True);\n+            Set_Is_Frozen (Def_Id);\n             Set_All_DT_Position (Def_Id);\n \n             --  Add the controlled component before the freezing actions\n@@ -5026,90 +5280,12 @@ package body Exp_Ch3 is\n                Expand_Record_Controller (Def_Id);\n             end if;\n \n-            --  Suppress creation of a dispatch table when Java_VM because the\n-            --  dispatching mechanism is handled internally by the JVM.\n-\n-            if not Java_VM then\n-\n-               --  Ada 2005 (AI-251): Build the secondary dispatch tables\n-\n-               declare\n-                  ADT : Elist_Id := Access_Disp_Table (Def_Id);\n-\n-                  procedure Add_Secondary_Tables (Typ : Entity_Id);\n-                  --  Internal subprogram, recursively climb to the ancestors\n-\n-                  --------------------------\n-                  -- Add_Secondary_Tables --\n-                  --------------------------\n-\n-                  procedure Add_Secondary_Tables (Typ : Entity_Id) is\n-                     E            : Entity_Id;\n-                     Iface        : Elmt_Id;\n-                     Result       : List_Id;\n-                     Suffix_Index : Int;\n-\n-                  begin\n-                     --  Climb to the ancestor (if any) handling private types\n-\n-                     if Is_Concurrent_Record_Type (Typ) then\n-                        if Present (Abstract_Interface_List (Typ)) then\n-                           Add_Secondary_Tables\n-                             (Etype (First (Abstract_Interface_List (Typ))));\n-                        end if;\n-\n-                     elsif Present (Full_View (Etype (Typ))) then\n-                        if Full_View (Etype (Typ)) /= Typ then\n-                           Add_Secondary_Tables (Full_View (Etype (Typ)));\n-                        end if;\n-\n-                     elsif Etype (Typ) /= Typ then\n-                        Add_Secondary_Tables (Etype (Typ));\n-                     end if;\n-\n-                     if Present (Abstract_Interfaces (Typ))\n-                       and then\n-                         not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n-                     then\n-                        Iface := First_Elmt (Abstract_Interfaces (Typ));\n-                        Suffix_Index := 0;\n-\n-                        E := First_Entity (Typ);\n-                        while Present (E) loop\n-                           if Is_Tag (E) and then Chars (E) /= Name_uTag then\n-                              Make_Secondary_DT\n-                                (Typ             => Def_Id,\n-                                 Ancestor_Typ    => Typ,\n-                                 Suffix_Index    => Suffix_Index,\n-                                 Iface           => Node (Iface),\n-                                 AI_Tag          => E,\n-                                 Acc_Disp_Tables => ADT,\n-                                 Result          => Result);\n-\n-                              Append_Freeze_Actions (Def_Id, Result);\n-                              Suffix_Index := Suffix_Index + 1;\n-                              Next_Elmt (Iface);\n-                           end if;\n-\n-                           Next_Entity (E);\n-                        end loop;\n-                     end if;\n-                  end Add_Secondary_Tables;\n-\n-               --  Start of processing to build secondary dispatch tables\n-\n-               begin\n-                  --  Handle private types\n-\n-                  if Present (Full_View (Def_Id)) then\n-                     Add_Secondary_Tables (Full_View (Def_Id));\n-                  else\n-                     Add_Secondary_Tables (Def_Id);\n-                  end if;\n+            --  Build the dispatch table. Suppress its creation when VM_Target\n+            --  because the dispatching mechanism is handled internally by the\n+            --  VMs.\n \n-                  Set_Access_Disp_Table (Def_Id, ADT);\n-                  Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n-               end;\n+            if VM_Target = No_VM then\n+               Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n             end if;\n \n             --  Make sure that the primitives Initialize, Adjust and Finalize\n@@ -5204,7 +5380,14 @@ package body Exp_Ch3 is\n       end if;\n \n       Adjust_Discriminants (Def_Id);\n-      Build_Record_Init_Proc (Type_Decl, Def_Id);\n+\n+      if VM_Target = No_VM or else not Is_Interface (Def_Id) then\n+\n+         --  Do not need init for interfaces on e.g. CIL since they're\n+         --  abstract. Helps operation of peverify (the PE Verify tool).\n+\n+         Build_Record_Init_Proc (Type_Decl, Def_Id);\n+      end if;\n \n       --  For tagged type, build bodies of primitive operations. Note that we\n       --  do this after building the record initialization experiment, since\n@@ -5350,7 +5533,7 @@ package body Exp_Ch3 is\n \n                   New_C := New_Copy (Old_C);\n                   Set_Parent (New_C, Parent (Old_C));\n-                  New_Scope (Def_Id);\n+                  Push_Scope (Def_Id);\n                   Enter_Name (New_C);\n                   End_Scope;\n                end if;\n@@ -5491,7 +5674,7 @@ package body Exp_Ch3 is\n                       Chars => New_External_Name (Chars (Def_Id), 'P'));\n \n                   --  We put the code associated with the pools in the entity\n-                  --  that has the later freeze node, usually the acces type\n+                  --  that has the later freeze node, usually the access type\n                   --  but it can also be the designated_type; because the pool\n                   --  code requires both those types to be frozen\n \n@@ -5573,7 +5756,8 @@ package body Exp_Ch3 is\n                null;\n \n             elsif (Controlled_Type (Desig_Type)\n-                    and then Convention (Desig_Type) /= Convention_Java)\n+                    and then Convention (Desig_Type) /= Convention_Java\n+                    and then Convention (Desig_Type) /= Convention_CIL)\n               or else\n                 (Is_Incomplete_Or_Private_Type (Desig_Type)\n                    and then No (Full_View (Desig_Type))\n@@ -5596,6 +5780,11 @@ package body Exp_Ch3 is\n               or else (Is_Array_Type (Desig_Type)\n                 and then not Is_Frozen (Desig_Type)\n                 and then Controlled_Type (Component_Type (Desig_Type)))\n+\n+               --  The designated type has controlled anonymous access\n+               --  discriminants.\n+\n+              or else Has_Controlled_Coextensions (Desig_Type)\n             then\n                Set_Associated_Final_Chain (Def_Id,\n                  Make_Defining_Identifier (Loc,\n@@ -5818,7 +6007,7 @@ package body Exp_Ch3 is\n \n             --  For signed integer types that have no negative values, either\n             --  there is room for negative values, or there is not. If there\n-            --  is, then all 1 bits may be interpretecd as minus one, which is\n+            --  is, then all 1 bits may be interpreted as minus one, which is\n             --  certainly invalid. Alternatively it is treated as the largest\n             --  positive value, in which case the observation for modular types\n             --  still applies.\n@@ -6012,16 +6201,77 @@ package body Exp_Ch3 is\n    ----------------\n \n    function In_Runtime (E : Entity_Id) return Boolean is\n-      S1 : Entity_Id := Scope (E);\n+      S1 : Entity_Id;\n \n    begin\n+      S1 := Scope (E);\n       while Scope (S1) /= Standard_Standard loop\n          S1 := Scope (S1);\n       end loop;\n \n       return Chars (S1) = Name_System or else Chars (S1) = Name_Ada;\n    end In_Runtime;\n \n+   ----------------------------\n+   -- Initialization_Warning --\n+   ----------------------------\n+\n+   procedure Initialization_Warning (E : Entity_Id) is\n+      Warning_Needed : Boolean;\n+\n+   begin\n+      Warning_Needed := False;\n+\n+      if Ekind (Current_Scope) = E_Package\n+        and then Static_Elaboration_Desired (Current_Scope)\n+      then\n+         if Is_Type (E) then\n+            if Is_Record_Type (E) then\n+               if Has_Discriminants (E)\n+                 or else Is_Limited_Type (E)\n+                 or else Has_Non_Standard_Rep (E)\n+               then\n+                  Warning_Needed := True;\n+\n+               else\n+                  --  Verify that at least one component has an initializtion\n+                  --  expression. No need for a warning on a type if all its\n+                  --  components have no initialization.\n+\n+                  declare\n+                     Comp : Entity_Id;\n+\n+                  begin\n+                     Comp := First_Component (E);\n+                     while Present (Comp) loop\n+                        if Ekind (Comp) = E_Discriminant\n+                          or else\n+                            (Nkind (Parent (Comp)) = N_Component_Declaration\n+                               and then Present (Expression (Parent (Comp))))\n+                        then\n+                           Warning_Needed := True;\n+                           exit;\n+                        end if;\n+\n+                        Next_Component (Comp);\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               if Warning_Needed then\n+                  Error_Msg_N\n+                    (\"Objects of the type cannot be initialized \" &\n+                       \"statically by default?\",\n+                       Parent (E));\n+               end if;\n+            end if;\n+\n+         else\n+            Error_Msg_N (\"Object cannot be initialized statically?\", E);\n+         end if;\n+      end if;\n+   end Initialization_Warning;\n+\n    ------------------\n    -- Init_Formals --\n    ------------------\n@@ -6218,7 +6468,7 @@ package body Exp_Ch3 is\n                                 New_Reference_To (Tag_Comp, Loc)),\n                           Attribute_Name => Name_Position)),\n \n-                     Unchecked_Convert_To (RTE (RE_Address),\n+                     Unchecked_Convert_To (RTE (RE_Offset_To_Top_Function_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix => New_Reference_To\n                                      (DT_Offset_To_Top_Func (Tag_Comp), Loc),\n@@ -6284,8 +6534,7 @@ package body Exp_Ch3 is\n                                 New_Reference_To (Tag_Comp, Loc)),\n                          Attribute_Name => Name_Position)),\n \n-                     New_Reference_To\n-                       (RTE (RE_Null_Address), Loc))));\n+                     Make_Null (Loc))));\n             end if;\n          end if;\n       end Initialize_Tag;\n@@ -6342,7 +6591,7 @@ package body Exp_Ch3 is\n                        Loc)),\n                   New_Occurrence_Of (Standard_True, Loc),\n                   Make_Integer_Literal (Loc, Uint_0),\n-                  New_Reference_To (RTE (RE_Null_Address), Loc))));\n+                  Make_Null (Loc))));\n          end if;\n \n          if Present (Abstract_Interfaces (Typ))\n@@ -6435,8 +6684,12 @@ package body Exp_Ch3 is\n          --  Input constructed by the expander. The test for Comes_From_Source\n          --  is needed to distinguish inherited operations from renamings\n          --  (which also have Alias set).\n+         --  The function may be abstract, or require_Overriding may be set\n+         --  for it, because tests for null extensions may already have reset\n+         --  the Is_Abstract_Subprogram_Flag.\n \n-         if Is_Abstract_Subprogram (Subp)\n+         if (Is_Abstract_Subprogram (Subp)\n+               or else Requires_Overriding (Subp))\n            and then Present (Alias (Subp))\n            and then not Is_Abstract_Subprogram (Alias (Subp))\n            and then not Comes_From_Source (Subp)\n@@ -6660,13 +6913,18 @@ package body Exp_Ch3 is\n          while Present (C) loop\n             Field_Name := Chars (Defining_Identifier (C));\n \n-            --  The tags must not be compared they are not part of the value.\n+            --  The tags must not be compared: they are not part of the value.\n+            --  Ditto for the controller component, if present.\n+\n             --  Note also that in the following, we use Make_Identifier for\n             --  the component names. Use of New_Reference_To to identify the\n             --  components would be incorrect because the wrong entities for\n             --  discriminants could be picked up in the private type case.\n \n-            if Field_Name /= Name_uTag then\n+            if Field_Name /= Name_uTag\n+                 and then\n+               Field_Name /= Name_uController\n+            then\n                Evolve_Or_Else (Cond,\n                  Make_Op_Ne (Loc,\n                    Left_Opnd =>\n@@ -6918,13 +7176,12 @@ package body Exp_Ch3 is\n             Next_Elmt (Prim);\n          end loop;\n \n-         --  If a renaming of predefined equality was found\n-         --  but there was no user-defined equality (so Eq_Needed\n-         --  is still true), then set the name back to Name_Op_Eq.\n-         --  But in the case where a user-defined equality was\n-         --  located after such a renaming, then the predefined\n-         --  equality function is still needed, so Eq_Needed must\n-         --  be set back to True.\n+         --  If a renaming of predefined equality was found but there was no\n+         --  user-defined equality (so Eq_Needed is still true), then set the\n+         --  name back to Name_Op_Eq. But in the case where a user-defined\n+         --  equality was located after such a renaming, then the predefined\n+         --  equality function is still needed, so Eq_Needed must be set back\n+         --  to True.\n \n          if Eq_Name /= Name_Op_Eq then\n             if Eq_Needed then\n@@ -6957,10 +7214,10 @@ package body Exp_Ch3 is\n                while Present (Prim) loop\n \n                   --  Any renamings of equality that appeared before an\n-                  --  overriding equality must be updated to refer to\n-                  --  the entity for the predefined equality, otherwise\n-                  --  calls via the renaming would get incorrectly\n-                  --  resolved to call the user-defined equality function.\n+                  --  overriding equality must be updated to refer to the\n+                  --  entity for the predefined equality, otherwise calls via\n+                  --  the renaming would get incorrectly resolved to call the\n+                  --  user-defined equality function.\n \n                   if Is_Predefined_Eq_Renaming (Node (Prim)) then\n                      Set_Alias (Node (Prim), Renamed_Eq);\n@@ -6994,22 +7251,26 @@ package body Exp_Ch3 is\n                Parameter_Type      => New_Reference_To (Tag_Typ, Loc)))));\n       end if;\n \n-      --  Generate the declarations for the following primitive operations:\n+      --  Ada 2005: Generate declarations for the following primitive\n+      --  operations for limited interfaces and synchronized types that\n+      --  implement a limited interface.\n \n       --    disp_asynchronous_select\n       --    disp_conditional_select\n       --    disp_get_prim_op_kind\n       --    disp_get_task_id\n       --    disp_timed_select\n \n-      --  for limited interfaces and synchronized types that implement a\n-      --  limited interface.\n+      --  These operations cannot be implemented on VM targets, so we simply\n+      --  disable their generation in this case. We also disable generation\n+      --  of these bodies if No_Dispatching_Calls is active.\n \n       if Ada_Version >= Ada_05\n+        and then VM_Target = No_VM\n         and then\n           ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n               or else (Is_Concurrent_Record_Type (Tag_Typ)\n-                        and then Has_Abstract_Interfaces (Tag_Typ)))\n+                         and then Has_Abstract_Interfaces (Tag_Typ)))\n       then\n          Append_To (Res,\n            Make_Subprogram_Declaration (Loc,\n@@ -7037,13 +7298,12 @@ package body Exp_Ch3 is\n                Make_Disp_Timed_Select_Spec (Tag_Typ)));\n       end if;\n \n-      --  Specs for finalization actions that may be required in case a\n-      --  future extension contain a controlled element. We generate those\n-      --  only for root tagged types where they will get dummy bodies or\n-      --  when the type has controlled components and their body must be\n-      --  generated. It is also impossible to provide those for tagged\n-      --  types defined within s-finimp since it would involve circularity\n-      --  problems\n+      --  Specs for finalization actions that may be required in case a future\n+      --  extension contain a controlled element. We generate those only for\n+      --  root tagged types where they will get dummy bodies or when the type\n+      --  has controlled components and their body must be generated. It is\n+      --  also impossible to provide those for tagged types defined within\n+      --  s-finimp since it would involve circularity problems\n \n       if In_Finalization_Root (Tag_Typ) then\n          null;\n@@ -7081,8 +7341,8 @@ package body Exp_Ch3 is\n \n    function Needs_Simple_Initialization (T : Entity_Id) return Boolean is\n    begin\n-      --  Check for private type, in which case test applies to the\n-      --  underlying type of the private type.\n+      --  Check for private type, in which case test applies to the underlying\n+      --  type of the private type.\n \n       if Is_Private_Type (T) then\n          declare\n@@ -7196,12 +7456,11 @@ package body Exp_Ch3 is\n    begin\n       Set_Is_Public (Id, Is_Public (Tag_Typ));\n \n-      --  The internal flag is set to mark these declarations because\n-      --  they have specific properties. First they are primitives even\n-      --  if they are not defined in the type scope (the freezing point\n-      --  is not necessarily in the same scope), furthermore the\n-      --  predefined equality can be overridden by a user-defined\n-      --  equality, no body will be generated in this case.\n+      --  The internal flag is set to mark these declarations because they have\n+      --  specific properties. First, they are primitives even if they are not\n+      --  defined in the type scope (the freezing point is not necessarily in\n+      --  the same scope). Second, the predefined equality can be overridden by\n+      --  a user-defined equality, no body will be generated in this case.\n \n       Set_Is_Internal (Id);\n \n@@ -7223,18 +7482,18 @@ package body Exp_Ch3 is\n                New_Reference_To (Ret_Type, Loc));\n       end if;\n \n-      --  If body case, return empty subprogram body. Note that this is\n-      --  ill-formed, because there is not even a null statement, and\n-      --  certainly not a return in the function case. The caller is\n-      --  expected to do surgery on the body to add the appropriate stuff.\n+      --  If body case, return empty subprogram body. Note that this is ill-\n+      --  formed, because there is not even a null statement, and certainly not\n+      --  a return in the function case. The caller is expected to do surgery\n+      --  on the body to add the appropriate stuff.\n \n       if For_Body then\n          return Make_Subprogram_Body (Loc, Spec, Empty_List, Empty);\n \n       --  For the case of Input/Output attributes applied to an abstract type,\n-      --  generate abstract specifications. These will never be called,\n-      --  but we need the slots allocated in the dispatching table so\n-      --  that typ'Class'Input and typ'Class'Output will work properly.\n+      --  generate abstract specifications. These will never be called, but we\n+      --  need the slots allocated in the dispatching table so that attributes\n+      --  typ'Class'Input and typ'Class'Output will work properly.\n \n       elsif (Is_TSS (Name, TSS_Stream_Input)\n               or else\n@@ -7381,8 +7640,8 @@ package body Exp_Ch3 is\n          Append_To (Res, Decl);\n       end if;\n \n-      --  Skip bodies of _Input and _Output for the abstract case, since\n-      --  the corresponding specs are abstract (see Predef_Spec_Or_Body)\n+      --  Skip bodies of _Input and _Output for the abstract case, since the\n+      --  corresponding specs are abstract (see Predef_Spec_Or_Body).\n \n       if not Is_Abstract_Type (Tag_Typ) then\n          if Stream_Operation_OK (Tag_Typ, TSS_Stream_Input)\n@@ -7402,20 +7661,25 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n-      --  Generate the bodies for the following primitive operations:\n+      --  Ada 2005: Generate bodies for the following primitive operations for\n+      --  limited interfaces and synchronized types that implement a limited\n+      --  interface.\n \n       --    disp_asynchronous_select\n       --    disp_conditional_select\n       --    disp_get_prim_op_kind\n       --    disp_get_task_id\n       --    disp_timed_select\n \n-      --  for limited interfaces and synchronized types that implement a\n-      --  limited interface. The interface versions will have null bodies.\n+      --  The interface versions will have null bodies\n+\n+      --  These operations cannot be implemented on VM targets, so we simply\n+      --  disable their generation in this case. We also disable generation\n+      --  of these bodies if No_Dispatching_Calls is active.\n \n       if Ada_Version >= Ada_05\n-        and then\n-          not Restriction_Active (No_Dispatching_Calls)\n+        and then VM_Target = No_VM\n+        and then not Restriction_Active (No_Dispatching_Calls)\n         and then\n           ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n               or else (Is_Concurrent_Record_Type (Tag_Typ)\n@@ -7607,7 +7871,7 @@ package body Exp_Ch3 is\n    begin\n       Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n       while Present (Prim) loop\n-         if Is_Internal (Node (Prim)) then\n+         if Is_Predefined_Dispatching_Operation (Node (Prim)) then\n             Frnodes := Freeze_Entity (Node (Prim), Loc);\n \n             if Present (Frnodes) then\n@@ -7654,6 +7918,7 @@ package body Exp_Ch3 is\n                                    or else Is_Synchronized_Interface (Typ)))\n           and then not Restriction_Active (No_Streams)\n           and then not Restriction_Active (No_Dispatch)\n+          and then not No_Run_Time_Mode\n           and then RTE_Available (RE_Tag)\n           and then RTE_Available (RE_Root_Stream_Type);\n    end Stream_Operation_OK;"}]}