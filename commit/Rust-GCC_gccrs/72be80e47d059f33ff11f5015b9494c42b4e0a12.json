{"sha": "72be80e47d059f33ff11f5015b9494c42b4e0a12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiZTgwZTQ3ZDA1OWYzM2ZmMTFmNTAxNWI5NDk0YzQyYjRlMGExMg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:30:32Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:34:31Z"}, "message": "Make use of new attribute access infrastructure in -Wuninitialized (PR 50584).\n\ngcc/ChangeLog:\n\n\t* tree-ssa-uninit.c (maybe_warn_pass_by_reference): Handle attribute\n\taccess internal representation of arrays.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/uninit-37.c: New test.", "tree": {"sha": "e444c5fd806d4379be669a83e97219947800d84c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e444c5fd806d4379be669a83e97219947800d84c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72be80e47d059f33ff11f5015b9494c42b4e0a12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72be80e47d059f33ff11f5015b9494c42b4e0a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72be80e47d059f33ff11f5015b9494c42b4e0a12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72be80e47d059f33ff11f5015b9494c42b4e0a12/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6450f07388f9fe575a489c9309c36012b17b88b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6450f07388f9fe575a489c9309c36012b17b88b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6450f07388f9fe575a489c9309c36012b17b88b0"}], "stats": {"total": 216, "additions": 190, "deletions": 26}, "files": [{"sha": "b8c49ad17ce9b1564a326493ea8e6ae8a7ae591b", "filename": "gcc/testsuite/gcc.dg/uninit-37.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be80e47d059f33ff11f5015b9494c42b4e0a12/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be80e47d059f33ff11f5015b9494c42b4e0a12/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-37.c?ref=72be80e47d059f33ff11f5015b9494c42b4e0a12", "patch": "@@ -0,0 +1,154 @@\n+/* PR middle-end/10138 - warn for uninitialized arrays passed as const arguments\n+   Verify that -Wuninitialized and -Wmaybe-uninitialized trigger (or don't)\n+   when passing uninitialized variables by reference to functions declared\n+   with or without attribute access and with (or without) const qualified\n+   arguments of array, VLA, or pointer types.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#define NONE    /* none */\n+#define RO(...) __attribute__ ((access (read_only, __VA_ARGS__)))\n+#define RW(...) __attribute__ ((access (read_write, __VA_ARGS__)))\n+#define WO(...) __attribute__ ((access (write_only, __VA_ARGS__)))\n+#define X(...)  __attribute__ ((access (none, __VA_ARGS__)))\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y)    CONCAT (x, y)\n+#define UNIQ(pfx)    CAT (pfx, __LINE__)\n+\n+extern void sink (void*);\n+\n+\n+#define T1(attr, name, type)\t\t\t\\\n+  void UNIQ (CAT (test_, name))(void) {\t\t\\\n+    extern attr void UNIQ (name)(type);\t\t\\\n+    int x;\t\t\t\t\t\\\n+    UNIQ (name)(&x);\t\t\t\t\\\n+    sink (&x);\t\t\t\t\t\\\n+  }\n+\n+#define T2(attr, name, types)\t\t\t\\\n+  void UNIQ (CAT (test_, name))(void) {\t\t\\\n+    extern attr void UNIQ (name)(types);\t\\\n+    int x;\t\t\t\t\t\\\n+    UNIQ (name)(1, &x);\t\t\t\t\\\n+    sink (&x);\t\t\t\t\t\\\n+  }\n+\n+\n+typedef int IA_[];\n+typedef const int CIA_[];\n+\n+T1 (NONE,   fia_,   IA_);\n+T1 (NONE,   fcia_,  CIA_);    // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (RO (1), froia_, IA_);     // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+T1 (RW (1), frwia_, IA_);     // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (WO (1), fwoia_, IA_);\n+T1 (X (1),  fxia_,  IA_);\n+\n+\n+typedef int IA1[1];\n+typedef const int CIA1[1];\n+\n+T1 (NONE,   fia1,   IA1);\n+T1 (NONE,   fcia1,  CIA1);    // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (RO (1), froia1, IA1);     // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+T1 (RW (1), frwia1, IA1);     // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (WO (1), fwoia1, IA1);\n+T1 (X (1),  fxia1,  IA1);\n+\n+\n+#define IARS1  int[restrict static 1]\n+#define CIARS1 const int[restrict static 1]\n+\n+T1 (NONE,   fiars1,   IARS1);\n+T1 (NONE,   fciars1,  CIARS1);// { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (RO (1), froiars1, IARS1); // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+T1 (RW (1), frwiars1, IARS1); // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (WO (1), fwoiars1, IARS1);\n+T1 (X (1),  fxiars1,  IARS1);\n+\n+\n+#define IAS1  int[static 1]\n+#define CIAS1 const int[static 1]\n+\n+T1 (NONE,   fias1,   IAS1);\n+T1 (NONE,   fcias1,  CIAS1);   // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (RO (1), froias1, IAS1);    // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+T1 (RW (1), frwias1, IAS1);    // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (WO (1), fwoias1, IAS1);\n+T1 (X (1),  fxias1,  IAS1);\n+\n+\n+#define IAX  int[*]\n+#define CIAX const int[*]\n+\n+T1 (NONE,   fiax,   IAX);\n+T1 (NONE,   fciax,  CIAX);    // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (RO (1), froiax, IAX);     // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+T1 (RW (1), frwiax, IAX);     // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (WO (1), fwoiax, IAX);\n+T1 (X (1),  fxiax,  IAX);\n+\n+\n+#define IAN  int n, int[n]\n+#define CIAN int n, const int[n]\n+\n+T2 (NONE,      fian,   IAN);\n+T2 (NONE,      fcian,  CIAN); // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T2 (RO (2, 1), froian, IAN);  // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+T2 (RW (2, 1), frwian, IAN);  // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T2 (WO (2, 1), fwoian, IAN);\n+T2 (X (2, 1),  fxian,  IAN);\n+\n+\n+typedef int* IP;\n+typedef const int* CIP;\n+\n+T1 (NONE,   fip,   IP);\n+T1 (NONE,   fcip,  CIP);     // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (RO (1), froip, IP);      // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+T1 (RW (1), frwip, IP);      // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+T1 (WO (1), fwoip, IP);\n+T1 (X (1),  fxip,  IP);\n+\n+\n+/* Verify that the notes printed after the warning mention attribute\n+   access only when the attribute is explicitly used in the declaration\n+   and not otherwise.  */\n+\n+void test_note_cst_restrict (void)\n+{\n+  extern void\n+    fccar (const char[restrict]);   // { dg-message \"by argument 1 of type 'const char\\\\\\[restrict]' to 'fccar'\" \"note\" }\n+\n+  char a[1];                  // { dg-message \"'a' declared here\" \"note\" }\n+  fccar (a);                  // { dg-warning \"'a' may be used uninitialized\" }\n+}\n+\n+void test_note_vla (int n)\n+{\n+  extern void\n+    fccvla (const char[n]);   // { dg-message \"by argument 1 of type 'const char\\\\\\[n]' to 'fccvla'\" \"note\" }\n+\n+  char a[2];                  // { dg-message \"'a' declared here\" \"note\" }\n+  fccvla (a);                 // { dg-warning \"'a' may be used uninitialized\" }\n+}\n+\n+void test_note_ro (void)\n+{\n+  extern RO (1) void\n+    frocar (char[restrict]);  // { dg-message \"in a call to 'frocar' declared with attribute 'access \\\\\\(read_only, 1\\\\\\)'\" \"note\" }\n+\n+  char a[3];                  // { dg-message \"'a' declared here\" \"note\" }\n+  frocar (a);                 // { dg-warning \"'a' is used uninitialized\" }\n+}\n+\n+void test_note_rw (void)\n+{\n+  extern RW (1) void\n+    frwcar (char[restrict]);  // { dg-message \"in a call to 'frwcar' declared with attribute 'access \\\\\\(read_write, 1\\\\\\)'\" \"note\" }\n+\n+  char a[4];                  // { dg-message \"'a' declared here\" \"note\" }\n+  frwcar (a);                 // { dg-warning \"'a' may be used uninitialized\" }\n+}"}, {"sha": "0447bb2f3fbf1d8435ed1685ea5f31a77fca2f55", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be80e47d059f33ff11f5015b9494c42b4e0a12/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be80e47d059f33ff11f5015b9494c42b4e0a12/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=72be80e47d059f33ff11f5015b9494c42b4e0a12", "patch": "@@ -18,6 +18,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_STRING\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -472,7 +473,8 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n      read_only.  */\n   const bool save_always_executed = wlims.always_executed;\n \n-  /* Map of attribute access specifications for function arguments.  */\n+  /* Initialize a map of attribute access specifications for arguments\n+     to the function function call.  */\n   rdwr_map rdwr_idx;\n   init_attr_rdwr_indices (&rdwr_idx, TYPE_ATTRIBUTES (fntype));\n \n@@ -488,12 +490,17 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n \tcontinue;\n \n       tree access_size = NULL_TREE;\n-      attr_access *access = rdwr_idx.get (argno - 1);\n+      const attr_access* access = rdwr_idx.get (argno - 1);\n       if (access)\n \t{\n \t  if (access->mode == access_none\n \t      || access->mode == access_write_only)\n \t    continue;\n+\n+\t  if (access->mode == access_deferred\n+\t      && !TYPE_READONLY (TREE_TYPE (argtype)))\n+\t    continue;\n+\n \t  if (save_always_executed && access->mode == access_read_only)\n \t    /* Attribute read_only arguments imply read access.  */\n \t    wlims.always_executed = true;\n@@ -524,45 +531,48 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n       if (!argbase)\n \tcontinue;\n \n-      if (access)\n+      if (access && access->mode != access_deferred)\n \t{\n-\t  const char* const mode = (access->mode == access_read_only\n-\t\t\t\t    ? \"read_only\" : \"read_write\");\n-\t  char attrstr[80];\n-\t  int n = sprintf (attrstr, \"access (%s, %u\", mode, argno);\n-\t  if (access->sizarg < UINT_MAX)\n-\t    sprintf (attrstr + n, \", %u)\", access->sizarg);\n-\t  else\n-\t    strcpy (attrstr + n, \")\");\n+\t  const char* const access_str =\n+\t    TREE_STRING_POINTER (access->to_external_string ());\n \n \t  if (fndecl)\n \t    {\n \t      location_t loc = DECL_SOURCE_LOCATION (fndecl);\n-\t      inform (loc, \"in a call to %qD declared \"\n-\t\t      \"with attribute %<access (%s, %u)%> here\",\n-\t\t      fndecl, mode, argno);\n+\t      inform (loc, \"in a call to %qD declared with \"\n+\t\t      \"attribute %<%s%> here\", fndecl, access_str);\n \t    }\n \t  else\n \t    {\n \t      /* Handle calls through function pointers.  */\n \t      location_t loc = gimple_location (stmt);\n \t      inform (loc, \"in a call to %qT declared with \"\n-\t\t      \"attribute %<access (%s, %u)%>\",\n-\t\t      fntype, mode, argno);\n+\t\t      \"attribute %<%s%>\", fntype, access_str);\n \t    }\n \t}\n-      else if (fndecl)\n-\t{\n-\t  location_t loc = DECL_SOURCE_LOCATION (fndecl);\n-\t  inform (loc, \"by argument %u of type %qT to %qD declared here\",\n-\t\t  argno, argtype, fndecl);\n-\t}\n       else\n \t{\n-\t  /* Handle calls through function pointers.  */\n-\t  location_t loc = gimple_location (stmt);\n-\t  inform (loc, \"by argument %u of type %qT to %qT\",\n-\t\t  argno, argtype, fntype);\n+\t  /* For a declaration with no relevant attribute access create\n+\t     a dummy object and use the formatting function to avoid\n+\t     having to complicate things here.  */\n+\t  attr_access ptr_access = { };\n+\t  if (!access)\n+\t    access = &ptr_access;\n+\t  const std::string argtypestr = access->array_as_string (argtype);\n+\t  if (fndecl)\n+\t    {\n+\t      location_t loc (DECL_SOURCE_LOCATION (fndecl));\n+\t      inform (loc, \"by argument %u of type %<%s%> to %qD \"\n+\t\t      \"declared here\",\n+\t\t      argno, argtypestr.c_str (), fndecl);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Handle calls through function pointers.  */\n+\t      location_t loc (gimple_location (stmt));\n+\t      inform (loc, \"by argument %u of type %<%s%> to %qT\",\n+\t\t      argno, argtypestr.c_str (), fntype);\n+\t    }\n \t}\n \n       if (DECL_P (argbase))"}]}