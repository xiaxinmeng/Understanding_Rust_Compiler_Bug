{"sha": "54e9a19d9d7113828f585504d126e1a0c01fed77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRlOWExOWQ5ZDcxMTM4MjhmNTg1NTA0ZDEyNmUxYTBjMDFmZWQ3Nw==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2004-08-17T22:51:28Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2004-08-17T22:51:28Z"}, "message": "extend.texi: Document new xstormy16 attribute.\n\n* doc/extend.texi: Document new xstormy16 attribute.\n\n* config/stormy16/stormy16.c (xstormy16_splittable_below100_operand): New.\n(xstormy16_splittable_below100_or_register): New.\n(combine_bnp): New.\n(xstormy16_reorg): New.\n(TARGET_MACHINE_DEPENDENT_REORG): Define.\n\n\n* config/stormy16/stormy16.md (movqi_internal): Make name public.\n(movhi_internal): Likewise.\n(cbhranchhi): Likewise.\n(cbhranchhi_neg): Likewise.\n(andhi3): Only allow splittable below100 operands.\n(iorhi3): Likewise.\n(peephole2): New and/zero_extend->and peephole.\n(peephole2): New load/ior/save->set1 peephole.\n(peephole2): New load/and/save->clr1 peephole.\n(bclrx, bclrx2, bclr7, bclr15): New.\n(bsetx, bsetx2, bset7, bset15): New.\n\n* config/stormy16/stormy16.c (xstormy16_print_operand): Be more\nliberal about acceptable 'B' masks.\n\n* config/stormy16/stormy16-protos.h\n(xstormy16_asm_output_aligned_common, xstormy16_below100_symbol,\nxstormy16_below100_operand, xstormy16_below100_or_register,\nxstormy16_onebit_set_operand, xstormy16_onebit_clr_operand): New.\n(PREDICATE_CODES): Add new predicates.\n\n* config/stormy16/stormy16.c\n(xstormy16_asm_output_aligned_common, xstormy16_below100_symbol,\nxstormy16_below100_operand, xstormy16_below100_or_register,\nxstormy16_onebit_set_operand, xstormy16_onebit_clr_operand): New.\n(xstormy16_expand_iorqi3, xstormy16_expand_andqi3): New.\n(xstormy16_legitimate_address_p): Allow below100 symbols.\n(xstormy16_extra_constraint_p): Add 'W' for below100 operands.\n(xstormy16_expand_move): Leave below100 operands as-is.\n(xstormy16_encode_section_info): Encode below100 symbols.\n(xstormy16_strip_name_encoding): New.\n(xstormy16_print_operand): Print 'b' as shift mask.\n(xstormy16_attribute_table): Add below100 attributes.\n(xstormy16_handle_below100_attribute): New.\n\n* config/stormy16/stormy16.h (EXTRA_SECTIONS): add in_bss100.\n(XSTORMY16_SECTION_FUNCTION): New.\n(EXTRA_SECTION_FUNCTIONS): Define using the above.\n(ASM_OUTPUT_ALIGNED_DECL_COMMON, ASM_OUTPUT_ALIGNED_DECL_LOCAL): New.\n(ASM_OUTPUT_SYMBOL_REF): Handle encoded symbols.\n(ASM_OUTPUT_LABELREF): Define.\n\n* config/stormy16/stormy16.md (movqi_internal): Add below100 support.\n(movhi_internal): Add below100 support.\n(andhi3): Add below100 support.\n(iorhi3): Add below100 support.\n(iorqi3, iorqi3_internal, andqi3, andqi3_internal): New.\n\nFrom-SVN: r86154", "tree": {"sha": "eaaa0a4a229363772043a644402f2d73e2975780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaaa0a4a229363772043a644402f2d73e2975780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54e9a19d9d7113828f585504d126e1a0c01fed77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e9a19d9d7113828f585504d126e1a0c01fed77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e9a19d9d7113828f585504d126e1a0c01fed77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e9a19d9d7113828f585504d126e1a0c01fed77/comments", "author": null, "committer": null, "parents": [{"sha": "c3f84f61e3c13e4e16483cfc63322efe5a7949fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f84f61e3c13e4e16483cfc63322efe5a7949fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f84f61e3c13e4e16483cfc63322efe5a7949fd"}], "stats": {"total": 982, "additions": 956, "deletions": 26}, "files": [{"sha": "81822a29c97ad63250b2d645b7b677ae7c7fa959", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54e9a19d9d7113828f585504d126e1a0c01fed77", "patch": "@@ -1,3 +1,62 @@\n+2004-08-17  DJ Delorie  <dj@redhat.com>\n+\n+\t* doc/extend.texi: Document new xstormy16 attribute.\n+\n+\t* config/stormy16/stormy16.c (xstormy16_splittable_below100_operand): New.\n+\t(xstormy16_splittable_below100_or_register): New.\n+\t(combine_bnp): New.\n+\t(xstormy16_reorg): New.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\n+\n+\t* config/stormy16/stormy16.md (movqi_internal): Make name public.\n+\t(movhi_internal): Likewise.\n+\t(cbhranchhi): Likewise.\n+\t(cbhranchhi_neg): Likewise.\n+\t(andhi3): Only allow splittable below100 operands.\n+\t(iorhi3): Likewise.\n+\t(peephole2): New and/zero_extend->and peephole.\n+\t(peephole2): New load/ior/save->set1 peephole.\n+\t(peephole2): New load/and/save->clr1 peephole.\n+\t(bclrx, bclrx2, bclr7, bclr15): New.\n+\t(bsetx, bsetx2, bset7, bset15): New.\n+\n+\t* config/stormy16/stormy16.c (xstormy16_print_operand): Be more\n+\tliberal about acceptable 'B' masks.\n+\n+\t* config/stormy16/stormy16-protos.h\n+\t(xstormy16_asm_output_aligned_common, xstormy16_below100_symbol,\n+\txstormy16_below100_operand, xstormy16_below100_or_register,\n+\txstormy16_onebit_set_operand, xstormy16_onebit_clr_operand): New.\n+\t(PREDICATE_CODES): Add new predicates.\n+\t\n+\t* config/stormy16/stormy16.c\n+\t(xstormy16_asm_output_aligned_common, xstormy16_below100_symbol,\n+\txstormy16_below100_operand, xstormy16_below100_or_register,\n+\txstormy16_onebit_set_operand, xstormy16_onebit_clr_operand): New.\n+\t(xstormy16_expand_iorqi3, xstormy16_expand_andqi3): New.\n+\t(xstormy16_legitimate_address_p): Allow below100 symbols.\n+\t(xstormy16_extra_constraint_p): Add 'W' for below100 operands.\n+\t(xstormy16_expand_move): Leave below100 operands as-is.\n+\t(xstormy16_encode_section_info): Encode below100 symbols.\n+\t(xstormy16_strip_name_encoding): New.\n+\t(xstormy16_print_operand): Print 'b' as shift mask.\n+\t(xstormy16_attribute_table): Add below100 attributes.\n+\t(xstormy16_handle_below100_attribute): New.\n+\n+\t* config/stormy16/stormy16.h (EXTRA_SECTIONS): add in_bss100.\n+\t(XSTORMY16_SECTION_FUNCTION): New.\n+\t(EXTRA_SECTION_FUNCTIONS): Define using the above.\n+\t(ASM_OUTPUT_ALIGNED_DECL_COMMON, ASM_OUTPUT_ALIGNED_DECL_LOCAL): New.\n+\t(ASM_OUTPUT_SYMBOL_REF): Handle encoded symbols.\n+\t(ASM_OUTPUT_LABELREF): Define.\n+\n+\t* config/stormy16/stormy16.md (movqi_internal): Add below100 support.\n+\t(movhi_internal): Add below100 support.\n+\t(andhi3): Add below100 support.\n+\t(iorhi3): Add below100 support.\n+\t(iorqi3, iorqi3_internal, andqi3, andqi3_internal): New.\n+\n 2004-08-17  James E Wilson  <wilson@specifixinc.com>\n \n \t* config/mips/mips.c (gen_conditional_move): Use GET_MODE (op0) instead"}, {"sha": "a8b23565418030ceb4fcf7d8f67b1d0c13e5c78e", "filename": "gcc/config/stormy16/stormy16-protos.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h?ref=54e9a19d9d7113828f585504d126e1a0c01fed77", "patch": "@@ -29,6 +29,13 @@ extern int direct_return (void);\n extern int xstormy16_interrupt_function_p (void);\n extern int xstormy16_epilogue_uses (int);\n extern void xstormy16_function_profiler (void);\n+extern const char *xstormy16_strip_name_encoding (const char *name);\n+extern void bss100_section (void);\n+\n+#if defined (TREE_CODE)\n+extern void xstormy16_asm_output_aligned_common (FILE *, tree, const char *,\n+\t\t\t\t\t\t int, int, int);\n+#endif\n \n #if defined (TREE_CODE) && defined (HAVE_MACHINE_MODES)\n extern CUMULATIVE_ARGS xstormy16_function_arg_advance \n@@ -56,6 +63,8 @@ extern void xstormy16_print_operand_address (FILE *, rtx);\n extern void xstormy16_expand_casesi (rtx, rtx, rtx, rtx, rtx);\n extern void xstormy16_output_addr_vec (FILE *, rtx, rtx);\n extern void xstormy16_expand_call (rtx, rtx, rtx);\n+extern void xstormy16_expand_iorqi3 (rtx *);\n+extern void xstormy16_expand_andqi3 (rtx *);\n #endif\n \n #if defined (HAVE_MACHINE_MODES) && defined (RTX_CODE)\n@@ -79,5 +88,12 @@ extern void xstormy16_expand_arith (enum machine_mode, enum rtx_code,\n extern int  shift_operator (rtx, enum machine_mode);\n extern const char * xstormy16_output_shift (enum machine_mode, enum rtx_code, \n \t\t\t\t\t    rtx, rtx, rtx);\n+extern int  xstormy16_below100_symbol (rtx, enum machine_mode);\n+extern int  xstormy16_below100_operand (rtx, enum machine_mode);\n+extern int  xstormy16_splittable_below100_operand (rtx, enum machine_mode);\n+extern int  xstormy16_below100_or_register (rtx, enum machine_mode);\n+extern int  xstormy16_splittable_below100_or_register (rtx, enum machine_mode);\n+extern int xstormy16_onebit_set_operand (rtx, enum machine_mode);\n+extern int xstormy16_onebit_clr_operand (rtx, enum machine_mode);\n #endif\n "}, {"sha": "cc044be4d6aa4bee92b137d015c407c5ad5ebd73", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 558, "deletions": 3, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=54e9a19d9d7113828f585504d126e1a0c01fed77", "patch": "@@ -549,6 +549,194 @@ xstormy16_preferred_reload_class (rtx x, enum reg_class class)\n   return class;\n }\n \n+/* Predicate for symbols and addresses that reflect special 8-bit\n+   addressing.  */\n+int\n+xstormy16_below100_symbol (rtx x,\n+\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    x = XEXP (x, 0);\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      const char *n = XSTR (x, 0);\n+      if (n[0] == '@' && n[1] == 'b' && n[2] == '.')\n+\treturn 1;\n+    }\n+  if (GET_CODE (x) == CONST_INT)\n+    {\n+      HOST_WIDE_INT i = INTVAL (x);\n+      if ((i >= 0x0000 && i <= 0x00ff)\n+\t  || (i >= 0x7f00 && i <= 0x7fff))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Predicate for MEMs that can use special 8-bit addressing.  */\n+int\n+xstormy16_below100_operand (rtx x, enum machine_mode mode)\n+{\n+  if (GET_MODE (x) != mode)\n+    return 0;\n+  if (GET_CODE (x) == MEM)\n+    x = XEXP (x, 0);\n+  else if (GET_CODE (x) == SUBREG\n+\t   && GET_CODE (XEXP (x, 0)) == MEM\n+\t   && !MEM_VOLATILE_P (XEXP (x, 0)))\n+    x = XEXP (XEXP (x, 0), 0);\n+  else\n+    return 0;\n+  if (GET_CODE (x) == CONST_INT)\n+    {\n+      HOST_WIDE_INT i = INTVAL (x);\n+      return (i >= 0x7f00 && i < 0x7fff);\n+    }\n+  return xstormy16_below100_symbol (x, HImode);\n+}\n+\n+/* Likewise, but only for non-volatile MEMs, for patterns where the\n+   MEM will get split into smaller sized accesses.  */\n+int\n+xstormy16_splittable_below100_operand (rtx x, enum machine_mode mode)\n+{\n+  if (GET_CODE (x) == MEM && MEM_VOLATILE_P (x))\n+    return 0;\n+  return xstormy16_below100_operand (x, mode);\n+}\n+\n+int\n+xstormy16_below100_or_register (rtx x, enum machine_mode mode)\n+{\n+  return (xstormy16_below100_operand (x, mode)\n+\t  || register_operand (x, mode));\n+}\n+\n+int\n+xstormy16_splittable_below100_or_register (rtx x, enum machine_mode mode)\n+{\n+  if (GET_CODE (x) == MEM && MEM_VOLATILE_P (x))\n+    return 0;\n+  return (xstormy16_below100_operand (x, mode)\n+\t  || register_operand (x, mode));\n+}\n+\n+/* Predicate for constants with exactly one bit set.  */\n+int\n+xstormy16_onebit_set_operand (rtx x, enum machine_mode mode)\n+{\n+  HOST_WIDE_INT i;\n+  if (GET_CODE (x) != CONST_INT)\n+    return 0;\n+  i = INTVAL (x);\n+  if (mode == QImode)\n+    i &= 0xff;\n+  if (mode == HImode)\n+    i &= 0xffff;\n+  return exact_log2 (i) != -1;\n+}\n+\n+/* Predicate for constants with exactly one bit not set.  */\n+int\n+xstormy16_onebit_clr_operand (rtx x, enum machine_mode mode)\n+{\n+  HOST_WIDE_INT i;\n+  if (GET_CODE (x) != CONST_INT)\n+    return 0;\n+  i = ~ INTVAL (x);\n+  if (mode == QImode)\n+    i &= 0xff;\n+  if (mode == HImode)\n+    i &= 0xffff;\n+  return exact_log2 (i) != -1;\n+}\n+\n+/* Expand an 8-bit IOR.  This either detects the one case we can\n+   actually do, or uses a 16-bit IOR.  */\n+void\n+xstormy16_expand_iorqi3 (rtx *operands)\n+{\n+  rtx in, out, outsub, val;\n+\n+  out = operands[0];\n+  in = operands[1];\n+  val = operands[2];\n+\n+  if (xstormy16_onebit_set_operand (val, QImode))\n+    {\n+      if (!xstormy16_below100_or_register (in, QImode))\n+\tin = copy_to_mode_reg (QImode, in);\n+      if (!xstormy16_below100_or_register (out, QImode))\n+\tout = gen_reg_rtx (QImode);\n+      emit_insn (gen_iorqi3_internal (out, in, val));\n+      if (out != operands[0])\n+\temit_move_insn (operands[0], out);\n+      return;\n+    }\n+\n+  if (GET_CODE (in) != REG)\n+    in = copy_to_mode_reg (QImode, in);\n+  if (GET_CODE (val) != REG\n+      && GET_CODE (val) != CONST_INT)\n+    val = copy_to_mode_reg (QImode, val);\n+  if (GET_CODE (out) != REG)\n+    out = gen_reg_rtx (QImode);\n+\n+  in = simplify_gen_subreg (HImode, in, QImode, 0);\n+  outsub = simplify_gen_subreg (HImode, out, QImode, 0);\n+  if (GET_CODE (val) != CONST_INT)\n+    val = simplify_gen_subreg (HImode, val, QImode, 0);\n+\n+  emit_insn (gen_iorhi3 (outsub, in, val));\n+\n+  if (out != operands[0])\n+    emit_move_insn (operands[0], out);\n+}\n+\n+/* Likewise, for AND.  */\n+void\n+xstormy16_expand_andqi3 (rtx *operands)\n+{\n+  rtx in, out, outsub, val;\n+\n+  out = operands[0];\n+  in = operands[1];\n+  val = operands[2];\n+\n+  if (xstormy16_onebit_clr_operand (val, QImode))\n+    {\n+      if (!xstormy16_below100_or_register (in, QImode))\n+\tin = copy_to_mode_reg (QImode, in);\n+      if (!xstormy16_below100_or_register (out, QImode))\n+\tout = gen_reg_rtx (QImode);\n+      emit_insn (gen_andqi3_internal (out, in, val));\n+      if (out != operands[0])\n+\temit_move_insn (operands[0], out);\n+      return;\n+    }\n+\n+  if (GET_CODE (in) != REG)\n+    in = copy_to_mode_reg (QImode, in);\n+  if (GET_CODE (val) != REG\n+      && GET_CODE (val) != CONST_INT)\n+    val = copy_to_mode_reg (QImode, val);\n+  if (GET_CODE (out) != REG)\n+    out = gen_reg_rtx (QImode);\n+\n+  in = simplify_gen_subreg (HImode, in, QImode, 0);\n+  outsub = simplify_gen_subreg (HImode, out, QImode, 0);\n+  if (GET_CODE (val) != CONST_INT)\n+    val = simplify_gen_subreg (HImode, val, QImode, 0);\n+\n+  emit_insn (gen_andhi3 (outsub, in, val));\n+\n+  if (out != operands[0])\n+    emit_move_insn (operands[0], out);\n+}\n+\n #define LEGITIMATE_ADDRESS_INTEGER_P(X, OFFSET)\t\t\t\t\\\n  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n   && (unsigned HOST_WIDE_INT) (INTVAL (X) + (OFFSET) + 2048) < 4096)\n@@ -579,6 +767,9 @@ xstormy16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   if (GET_CODE (x) == REG && REGNO_OK_FOR_BASE_P (REGNO (x))\n       && (! strict || REGNO (x) < FIRST_PSEUDO_REGISTER))\n     return 1;\n+\n+  if (xstormy16_below100_symbol(x, mode))\n+    return 1;\n   \n   return 0;\n }\n@@ -668,6 +859,9 @@ xstormy16_extra_constraint_p (rtx x, int c)\n       return (GET_CODE (x) == CONST_INT\n \t      && (INTVAL (x) == 0));\n \n+    case 'W':\n+      return xstormy16_below100_operand(x, GET_MODE(x));\n+\n     default:\n       return 0;\n     }\n@@ -868,6 +1062,7 @@ xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n       && GET_CODE (dest) == MEM\n       && (GET_CODE (XEXP (dest, 0)) != CONST_INT\n \t  || ! xstormy16_legitimate_address_p (mode, XEXP (dest, 0), 0))\n+      && ! xstormy16_below100_operand (dest, mode)\n       && GET_CODE (src) != REG\n       && GET_CODE (src) != SUBREG)\n     src = copy_to_mode_reg (mode, src);\n@@ -1489,6 +1684,119 @@ xstormy16_asm_output_mi_thunk (FILE *file,\n   putc ('\\n', file);\n }\n \n+/* The purpose of this function is to override the default behavior of\n+   BSS objects.  Normally, they go into .bss or .sbss via \".common\"\n+   directives, but we need to override that and put them in\n+   .bss_below100.  We can't just use a section override (like we do\n+   for .data_below100), because that makes them initialized rather\n+   than uninitialized.  */\n+void\n+xstormy16_asm_output_aligned_common (FILE *stream,\n+\t\t\t\t     tree decl ATTRIBUTE_UNUSED,\n+\t\t\t\t     const char *name,\n+\t\t\t\t     int size,\n+\t\t\t\t     int align,\n+\t\t\t\t     int global)\n+{\n+  if (name[0] == '@' && name[2] == '.')\n+    {\n+      const char *op = 0;\n+      switch (name[1])\n+\t{\n+\tcase 'b':\n+\t  bss100_section();\n+\t  op = \"space\";\n+\t  break;\n+\t}\n+      if (op)\n+\t{\n+\t  const char *name2;\n+\t  int p2align = 0;\n+\n+\t  while (align > 8)\n+\t    {\n+\t      align /= 2;\n+\t      p2align ++;\n+\t    }\n+\t  name2 = xstormy16_strip_name_encoding (name);\n+\t  if (global)\n+\t    fprintf (stream, \"\\t.globl\\t%s\\n\", name2);\n+\t  if (p2align)\n+\t    fprintf (stream, \"\\t.p2align %d\\n\", p2align);\n+\t  fprintf (stream, \"\\t.type\\t%s, @object\\n\", name2);\n+\t  fprintf (stream, \"\\t.size\\t%s, %d\\n\", name2, size);\n+\t  fprintf (stream, \"%s:\\n\\t.%s\\t%d\\n\", name2, op, size);\n+\t  return;\n+\t}\n+    }\n+\n+  if (!global)\n+    {\n+      fprintf (stream, \"\\t.local\\t\");\n+      assemble_name (stream, name);\n+      fprintf (stream, \"\\n\");\n+    }\n+  fprintf (stream, \"\\t.comm\\t\");\n+  assemble_name (stream, name);\n+  fprintf (stream, \",%u,%u\\n\", size, align);\n+}\n+\n+/* Mark symbols with the \"below100\" attribute so that we can use the\n+   special addressing modes for them.  */\n+\n+static void\n+xstormy16_encode_section_info (tree decl,\n+\t\t\t       rtx r,\n+\t\t\t       int first ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && (lookup_attribute (\"below100\", DECL_ATTRIBUTES (decl))\n+\t  || lookup_attribute (\"BELOW100\", DECL_ATTRIBUTES (decl))))\n+    {\n+      const char *newsection = 0;\n+      char *newname;\n+      tree idp;\n+      rtx rtlname, rtl;\n+      const char *oldname;\n+\n+      rtl = r;\n+      rtlname = XEXP (rtl, 0);\n+      if (GET_CODE (rtlname) == SYMBOL_REF)\n+\toldname = XSTR (rtlname, 0);\n+      else if (GET_CODE (rtlname) == MEM\n+\t       && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+\toldname = XSTR (XEXP (rtlname, 0), 0);\n+      else\n+\tabort ();\n+\n+      if (DECL_INITIAL (decl))\n+\t{\n+\t  newsection = \".data_below100\";\n+\t  DECL_SECTION_NAME (decl) = build_string (strlen (newsection), newsection);\n+\t}\n+\n+      newname = alloca (strlen (oldname) + 4);\n+      sprintf (newname, \"@b.%s\", oldname);\n+      idp = get_identifier (newname);\n+      XEXP (rtl, 0) =\n+\tgen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+    }\n+}\n+\n+const char *\n+xstormy16_strip_name_encoding (const char *name)\n+{\n+  while (1)\n+    {\n+      if (name[0] == '@' && name[2] == '.')\n+\tname += 3;\n+      else if (name[0] == '*')\n+\tname ++;\n+      else\n+\treturn name;\n+    }\n+}\n+\n /* Output constructors and destructors.  Just like \n    default_named_section_asm_out_* but don't set the sections writable.  */\n #undef  TARGET_ASM_CONSTRUCTOR\n@@ -1603,6 +1911,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \t/* There is either one bit set, or one bit clear, in X.\n \t   Print it preceded by '#'.  */\n       {\n+\tstatic int bits_set[8] = { 0, 1, 1, 2, 1, 2, 2, 3 };\n \tHOST_WIDE_INT xx = 1;\n \tHOST_WIDE_INT l;\n \n@@ -1611,9 +1920,30 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \telse\n \t  output_operand_lossage (\"`B' operand is not constant\");\n \t\n-\tl = exact_log2 (xx);\n-\tif (l == -1)\n-\t  l = exact_log2 (~xx);\n+\t/* GCC sign-extends masks with the MSB set, so we have to\n+\t   detect all the cases that differ only in sign extension\n+\t   beyond the bits we care about.  Normally, the predicates\n+\t   and constraints ensure that we have the right values.  This\n+\t   works correctly for valid masks.  */\n+\tif (bits_set[xx & 7] <= 1)\n+\t  {\n+\t    /* Remove sign extension bits.  */\n+\t    if ((~xx & ~(HOST_WIDE_INT)0xff) == 0)\n+\t      xx &= 0xff;\n+\t    else if ((~xx & ~(HOST_WIDE_INT)0xffff) == 0)\n+\t      xx &= 0xffff;\n+\t    l = exact_log2 (xx);\n+\t  }\n+\telse\n+\t  {\n+\t    /* Add sign extension bits.  */\n+\t    if ((xx & ~(HOST_WIDE_INT)0xff) == 0)\n+\t      xx |= ~(HOST_WIDE_INT)0xff;\n+\t    else if ((xx & ~(HOST_WIDE_INT)0xffff) == 0)\n+\t      xx |= ~(HOST_WIDE_INT)0xffff;\n+\t    l = exact_log2 (~xx);\n+\t  }\n+\n \tif (l == -1)\n \t  output_operand_lossage (\"`B' operand has multiple bits set\");\n \t\n@@ -1650,6 +1980,24 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \treturn;\n       }\n \n+    case 'b':\n+      /* Print the shift mask for bp/bn.  */\n+      {\n+\tHOST_WIDE_INT xx = 1;\n+\tHOST_WIDE_INT l;\n+\n+\tif (GET_CODE (x) == CONST_INT)\n+\t  xx = INTVAL (x);\n+\telse\n+\t  output_operand_lossage (\"`B' operand is not constant\");\n+\t\n+\tl = 7 - xx;\n+\t\n+\tfputs (IMMEDIATE_PREFIX, file);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, l);\n+\treturn;\n+      }\n+\n     case 0:\n       /* Handled below.  */\n       break;\n@@ -2040,11 +2388,15 @@ xstormy16_interrupt_function_p (void)\n #define TARGET_ATTRIBUTE_TABLE xstormy16_attribute_table\n static tree xstormy16_handle_interrupt_attribute\n   (tree *, tree, tree, int, bool *);\n+static tree xstormy16_handle_below100_attribute\n+  (tree *, tree, tree, int, bool *);\n \n static const struct attribute_spec xstormy16_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   { \"interrupt\", 0, 0, false, true,  true,  xstormy16_handle_interrupt_attribute },\n+  { \"BELOW100\",  0, 0, false, false, false, xstormy16_handle_below100_attribute },\n+  { \"below100\",  0, 0, false, false, false, xstormy16_handle_below100_attribute },\n   { NULL,        0, 0, false, false, false, NULL }\n };\n \n@@ -2065,6 +2417,34 @@ xstormy16_handle_interrupt_attribute (tree *node, tree name,\n \n   return NULL_TREE;\n }\n+\n+/* Handle an \"below\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+xstormy16_handle_below100_attribute (tree *node,\n+\t\t\t\t     tree name ATTRIBUTE_UNUSED,\n+\t\t\t\t     tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t     bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != VAR_DECL\n+      && TREE_CODE (*node) != POINTER_TYPE\n+      && TREE_CODE (*node) != TYPE_DECL)\n+    {\n+      warning (\"`__BELOW100__' attribute only applies to variables\");\n+      *no_add_attrs = true;\n+    }\n+  else if (args == NULL_TREE && TREE_CODE (*node) == VAR_DECL)\n+    {\n+      if (! (TREE_PUBLIC (*node) || TREE_STATIC (*node)))\n+\t{\n+\t  warning (\"__BELOW100__ attribute not allowed with auto storage class.\");\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  \n+  return NULL_TREE;\n+}\n \f\n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS xstormy16_init_builtins\n@@ -2182,6 +2562,174 @@ xstormy16_expand_builtin(tree exp, rtx target,\n \n   return retval;\n }\n+\f\n+\n+/* Look for combinations of insns that can be converted to BN or BP\n+   opcodes.  This is, unfortunately, too complex to do with MD\n+   patterns.  */\n+static void\n+combine_bnp (rtx insn)\n+{\n+  int insn_code, regno, need_extend, mask;\n+  rtx cond, reg, and, load, qireg, mem;\n+  enum machine_mode load_mode = QImode;\n+\n+  insn_code = recog_memoized (insn);\n+  if (insn_code != CODE_FOR_cbranchhi\n+      && insn_code != CODE_FOR_cbranchhi_neg)\n+    return;\n+\n+  cond = XVECEXP (PATTERN (insn), 0, 0); /* set */\n+  cond = XEXP (cond, 1); /* if */\n+  cond = XEXP (cond, 0); /* cond */\n+  switch (GET_CODE (cond))\n+    {\n+    case NE:\n+    case EQ:\n+      need_extend = 0;\n+      break;\n+    case LT:\n+    case GE:\n+      need_extend = 1;\n+      break;\n+    default:\n+      return;\n+    }\n+\n+  reg = XEXP (cond, 0);\n+  if (GET_CODE (reg) != REG)\n+    return;\n+  regno = REGNO (reg);\n+  if (XEXP (cond, 1) != const0_rtx)\n+    return;\n+  if (! find_regno_note (insn, REG_DEAD, regno))\n+    return;\n+  qireg = gen_rtx_REG (QImode, regno);\n+\n+  if (need_extend)\n+    {\n+      /* LT and GE conditionals should have an sign extend before\n+\t them.  */\n+      for (and = prev_real_insn (insn); and; and = prev_real_insn (and))\n+\t{\n+\t  int and_code = recog_memoized (and);\n+\t  if (and_code == CODE_FOR_extendqihi2\n+\t      && rtx_equal_p (XEXP (PATTERN (and), 0), reg)\n+\t      && rtx_equal_p (XEXP (XEXP (PATTERN (and), 1), 0), qireg))\n+\t    {\n+\t      break;\n+\t    }\n+\t\n+\t  if (and_code == CODE_FOR_movhi_internal\n+\t      && rtx_equal_p (XEXP (PATTERN (and), 0), reg))\n+\t    {\n+\t      /* This is for testing bit 15.  */\n+\t      and = insn;\n+\t      break;\n+\t    }\n+\n+\t  if (reg_mentioned_p (reg, and))\n+\t    return;\n+\t  if (GET_CODE (and) != NOTE\n+\t      && GET_CODE (and) != INSN)\n+\t    return;\n+\t}\n+    }\n+  else\n+    {\n+      /* EQ and NE conditionals have an AND before them.  */\n+      for (and = prev_real_insn (insn); and; and = prev_real_insn (and))\n+\t{\n+\t  if (recog_memoized (and) == CODE_FOR_andhi3\n+\t      && rtx_equal_p (XEXP (PATTERN (and), 0), reg)\n+\t      && rtx_equal_p (XEXP (XEXP (PATTERN (and), 1), 0), reg))\n+\t    {\n+\t      break;\n+\t    }\n+\t\n+\t  if (reg_mentioned_p (reg, and))\n+\t    return;\n+\t  if (GET_CODE (and) != NOTE\n+\t      && GET_CODE (and) != INSN)\n+\t    return;\n+\t}\n+    }\n+  if (!and)\n+    return;\n+\n+  for (load = prev_real_insn (and); load; load = prev_real_insn (load))\n+    {\n+      int load_code = recog_memoized (load);\n+      if (load_code == CODE_FOR_movhi_internal\n+\t  && rtx_equal_p (XEXP (PATTERN (load), 0), reg)\n+\t  && xstormy16_below100_operand (XEXP (PATTERN (load), 1), HImode)\n+\t  && ! MEM_VOLATILE_P (XEXP (PATTERN (load), 1)))\n+\t{\n+\t  load_mode = HImode;\n+\t  break;\n+\t}\n+\n+      if (load_code == CODE_FOR_movqi_internal\n+\t  && rtx_equal_p (XEXP (PATTERN (load), 0), qireg)\n+\t  && xstormy16_below100_operand (XEXP (PATTERN (load), 1), QImode))\n+\t{\n+\t  load_mode = QImode;\n+\t  break;\n+\t}\n+\t\n+      if (reg_mentioned_p (reg, load))\n+\treturn;\n+      if (GET_CODE (load) != NOTE\n+\t  && GET_CODE (load) != INSN)\n+\treturn;\n+    }\n+  if (!load)\n+    return;\n+\n+  if (!need_extend)\n+    {\n+      if (!xstormy16_onebit_set_operand (XEXP (XEXP (PATTERN (and), 1), 1), load_mode))\n+\treturn;\n+      mask = (int) INTVAL (XEXP (XEXP (PATTERN (and), 1), 1));\n+    }\n+  else\n+    mask = (load_mode == HImode) ? 0x8000 : 0x80;\n+\n+  mem = XEXP (PATTERN (load), 1);\n+  if (load_mode == HImode)\n+    {\n+      rtx addr = XEXP (mem, 0);\n+      if (! (mask & 0xff))\n+\t{\n+\t  addr = plus_constant (addr, 1);\n+\t  mask >>= 8;\n+\t}\n+      mem = gen_rtx_MEM (QImode, addr);\n+    }\n+\n+  if (need_extend)\n+    XEXP (cond, 0) = gen_rtx_SIGN_EXTEND (HImode, mem);\n+  else\n+    XEXP (cond, 0) = gen_rtx_AND (QImode, mem, GEN_INT (mask));\n+  INSN_CODE (insn) = -1;\n+  delete_insn (load);\n+  if (and != insn)\n+    delete_insn (and);\n+}\n+\n+static void\n+xstormy16_reorg (void)\n+{\n+  rtx insn;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (! JUMP_P (insn))\n+\tcontinue;\n+      combine_bnp (insn);\n+    }\n+}\n+\n \f\n /* Worker function for TARGET_RETURN_IN_MEMORY.  */\n \n@@ -2196,6 +2744,10 @@ xstormy16_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n #undef TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+#undef TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO xstormy16_encode_section_info\n+#undef TARGET_STRIP_NAME_ENCODING\n+#define TARGET_STRIP_NAME_ENCODING xstormy16_strip_name_encoding\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK xstormy16_asm_output_mi_thunk\n@@ -2222,4 +2774,7 @@ xstormy16_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY xstormy16_return_in_memory\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG xstormy16_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "1cb40f6f0e0ab4eba0fbf8e3dcc64811178568ab", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=54e9a19d9d7113828f585504d126e1a0c01fed77", "patch": "@@ -626,6 +626,26 @@ do {\t\t\t\t\t\t\t\\\n #undef DTORS_SECTION_ASM_OP\n #define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"a\\\"\"\n #define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"a\\\"\"\n+#define EXTRA_SECTIONS in_bss100\n+\n+/* We define the function body in a separate macro so that if we ever\n+   add another section, we can just add an entry to\n+   EXTRA_SECTION_FUNCTIONS without making it difficult to read.  It is\n+   not used anywhere else.  */\n+#define XSTORMY16_SECTION_FUNCTION(name, in, string, bits) \t\t\t  \\\n+  void\t\t\t\t\t\t\t\t\t\t  \\\n+  name ()\t\t\t\t\t\t\t\t\t  \\\n+  { \t\t\t\t\t\t\t\t\t\t  \\\n+    if (in_section != in)\t\t\t\t\t\t\t  \\\n+      { \t\t\t\t\t\t\t\t\t  \\\n+\tfprintf (asm_out_file, \"\\t.section %s,\\\"aw\\\",@%sbits\\n\", string, bits);   \\\n+\tin_section = in;\t\t\t\t\t\t\t  \\\n+      }\t\t\t\t\t\t\t\t\t\t  \\\n+  }\n+\n+#undef  EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\\\n+  XSTORMY16_SECTION_FUNCTION (bss100_section, in_bss100, \".bss_below100\", \"no\")\n \n #define JUMP_TABLES_IN_TEXT_SECTION 1\n \n@@ -642,15 +662,23 @@ do {\t\t\t\t\t\t\t\\\n \n #define IS_ASM_LOGICAL_LINE_SEPARATOR(C) ((C) == '|')\n \n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+  xstormy16_asm_output_aligned_common(STREAM, DECL, NAME, SIZE, ALIGNMENT, 1)\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+  xstormy16_asm_output_aligned_common(STREAM, DECL, NAME, SIZE, ALIGNMENT, 0)\n+\n \f\n /* Output and Generation of Labels.  */\n \n #define ASM_OUTPUT_SYMBOL_REF(STREAM, SYMBOL)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n+    const char *rn = XSTR (SYMBOL, 0);\t\t\t\t\t\\\n+    if (rn[0] == '@' && rn[2] == '.')\t\t\t\t\t\\\n+      rn += 3;\t\t\t\t\t\t\t\t\\\n     if (SYMBOL_REF_FUNCTION_P (SYMBOL))\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL_REF ((STREAM), XSTR (SYMBOL, 0));\t\t\\\n+      ASM_OUTPUT_LABEL_REF ((STREAM), rn);\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n-      assemble_name (STREAM, XSTR (SYMBOL, 0));\t\t\t\t\\\n+      assemble_name (STREAM, rn);\t\t\t\t\t\\\n   } while (0)\n \n #define ASM_OUTPUT_LABEL_REF(STREAM, NAME)\t\\\n@@ -660,6 +688,9 @@ do  {\t\t\t\t\t\t\\\n   fputc (')', STREAM);\t\t\t\t\\\n } while (0)\n \n+#define ASM_OUTPUT_LABELREF(STREAM, NAME)\t\\\n+  asm_fprintf ((STREAM), \"%U%s\", xstormy16_strip_name_encoding (NAME));\n+\n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \"\\t.globl \"\n \n@@ -785,6 +816,11 @@ do  {\t\t\t\t\t\t\\\n   {\"equality_operator\", {EQ, NE }},\t\t\t\\\n   {\"inequality_operator\", {GE, GT, LE, LT, GEU, GTU, LEU, LTU }}, \\\n   {\"xstormy16_ineqsi_operator\", {LT, GE, LTU, GEU }}, \\\n+  {\"xstormy16_below100_operand\", {MEM }}, \\\n+  {\"xstormy16_below100_or_register\", {MEM, REG }}, \\\n+  {\"xstormy16_splittable_below100_or_register\", {MEM, REG }}, \\\n+  {\"xstormy16_onebit_clr_operand\", {CONST_INT }}, \\\n+  {\"xstormy16_onebit_set_operand\", {CONST_INT }}, \\\n   {\"nonimmediate_nonstack_operand\", {REG, MEM}},\n \n #define CASE_VECTOR_MODE SImode"}, {"sha": "372ca2f12108eb648c118e77da2b536229888faa", "filename": "gcc/config/stormy16/stormy16.md", "status": "modified", "additions": 268, "deletions": 21, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.md?ref=54e9a19d9d7113828f585504d126e1a0c01fed77", "patch": "@@ -130,9 +130,9 @@\n   \"\"\n   \"{ xstormy16_expand_move (QImode, operands[0], operands[1]); DONE; }\")\n \n-(define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_nonstack_operand\" \"=r,m,e,e,T,r,S\")\n-\t(match_operand:QI 1 \"general_operand\"       \"r,e,m,i,i,i,i\"))]\n+(define_insn \"movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmediate_nonstack_operand\" \"=r,m,e,e,T,r,S,W,r\")\n+\t(match_operand:QI 1 \"general_operand\"       \"r,e,m,i,i,i,i,ir,W\"))]\n   \"\"\n   \"@\n    mov %0,%1\n@@ -141,6 +141,8 @@\n    mov %0,%1\n    mov Rx,%1\n    mov %0,%1\n+   mov.b %0,%1\n+   mov.b %0,%1\n    mov.b %0,%1\"\n   [(set_attr_alternative \"length\" \n \t     [(const_int 2)\n@@ -153,8 +155,10 @@\n \t      (const_int 2)\n \t      (const_int 2)\n \t      (const_int 4)\n-\t      (const_int 4)])\n-   (set_attr \"psw_operand\" \"0,0,0,0,nop,0,nop\")])\n+\t      (const_int 4)\n+\t      (const_int 2)\n+\t      (const_int 2)])\n+   (set_attr \"psw_operand\" \"0,0,0,0,nop,0,nop,0,0\")])\n \n (define_insn \"pushhi\"\n   [(set (mem:HI (post_inc (reg:HI 15)))\n@@ -178,9 +182,9 @@\n   \"\"\n   \"{ xstormy16_expand_move (HImode, operands[0], operands[1]); DONE; }\")\n \n-(define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_nonstack_operand\" \"=r,m,e,e,T,r,S\")\n-\t(match_operand:HI 1 \"xs_hi_general_operand\"       \"r,e,m,L,L,i,i\"))]\n+(define_insn \"movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmediate_nonstack_operand\" \"=r,m,e,e,T,r,S,W,r\")\n+\t(match_operand:HI 1 \"xs_hi_general_operand\"       \"r,e,m,L,L,i,i,ir,W\"))]\n   \"\"\n   \"@\n    mov %0,%1\n@@ -189,6 +193,8 @@\n    mov.w %0,%1\n    mov.w Rx,%1\n    mov.w %0,%1\n+   mov.w %0,%1\n+   mov.w %0,%1\n    mov.w %0,%1\"\n   [(set_attr_alternative \"length\" \n \t     [(const_int 2)\n@@ -201,8 +207,10 @@\n \t      (const_int 2)\n \t      (const_int 2)\n \t      (const_int 4)\n+\t      (const_int 4)\n+\t      (const_int 4)\n \t      (const_int 4)])\n-   (set_attr \"psw_operand\" \"0,0,0,0,nop,0,nop\")])\n+   (set_attr \"psw_operand\" \"0,0,0,0,nop,0,nop,0,0\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n@@ -552,29 +560,63 @@\n \n ;; Logical AND, 16 bit integers\n (define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r,r\")\n-\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"L,r,K,i\")))]\n+  [(set (match_operand:HI 0 \"xstormy16_splittable_below100_or_register\" \"=T,r,r,r,W\")\n+\t(and:HI (match_operand:HI 1 \"xstormy16_below100_or_register\" \"%0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"L,r,K,i,K\")))]\n   \"\"\n   \"@\n    and Rx,%2\n    and %0,%2\n    clr1 %0,%B2\n-   and %0,%2\"\n-  [(set_attr \"length\" \"2,2,2,4\")])\n+   and %0,%2\n+   #\"\n+  [(set_attr \"length\" \"2,2,2,4,2\")])\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"xstormy16_below100_operand\" \"\")\n+\t(and:HI (match_operand:HI 1 \"xstormy16_below100_operand\" \"\")\n+\t\t(match_operand:HI 2 \"xstormy16_onebit_clr_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 3)\n+\t(and:QI (match_dup 4)\n+\t\t(match_dup 5)))]\n+  \"{ int s = ((INTVAL (operands[2]) & 0xff) == 0xff) ? 1 : 0;\n+     operands[3] = simplify_gen_subreg (QImode, operands[0], HImode, s);\n+     operands[4] = simplify_gen_subreg (QImode, operands[1], HImode, s);\n+     operands[5] = simplify_gen_subreg (QImode, operands[2], HImode, s);\n+     operands[5] = GEN_INT (INTVAL (operands[5]) | ~(HOST_WIDE_INT)0xff);\n+   }\n+\")\n \n ;; Inclusive OR, 16 bit integers\n (define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r,r\")\n-\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"L,r,J,i\")))]\n+  [(set (match_operand:HI 0 \"xstormy16_splittable_below100_or_register\" \"=T,r,r,r,W\")\n+\t(ior:HI (match_operand:HI 1 \"xstormy16_below100_or_register\" \"%0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"L,r,J,i,J\")))]\n   \"\"\n   \"@\n    or Rx,%2\n    or %0,%2\n    set1 %0,%B2\n-   or %0,%2\"\n-  [(set_attr \"length\" \"2,2,2,4\")])\n+   or %0,%2\n+   #\"\n+  [(set_attr \"length\" \"2,2,2,4,2\")])\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"xstormy16_below100_operand\" \"\")\n+\t(ior:HI (match_operand:HI 1 \"xstormy16_below100_operand\" \"\")\n+\t\t(match_operand:HI 2 \"xstormy16_onebit_set_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 3)\n+\t(ior:QI (match_dup 4)\n+\t\t(match_dup 5)))]\n+  \"{ int s = ((INTVAL (operands[2]) & 0xff) == 0x00) ? 1 : 0;\n+     operands[3] = simplify_gen_subreg (QImode, operands[0], HImode, s);\n+     operands[4] = simplify_gen_subreg (QImode, operands[1], HImode, s);\n+     operands[5] = simplify_gen_subreg (QImode, operands[2], HImode, s);\n+     operands[5] = GEN_INT (INTVAL (operands[5]) & 0xff);\n+   }\n+\")\n \n ;; Exclusive OR, 16 bit integers\n (define_insn \"xorhi3\"\n@@ -796,7 +838,7 @@\n   \"{ xstormy16_emit_cbranch (LTU, operands[0]); DONE; }\")\n \n \n-(define_insn \"*cbranchhi\"\n+(define_insn \"cbranchhi\"\n   [(set (pc) \n \t(if_then_else (match_operator:HI 1 \"comparison_operator\"\n \t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\" \n@@ -814,7 +856,7 @@\n   [(set_attr \"branch_class\" \"bcc12\")\n    (set_attr \"psw_operand\" \"0,0,1\")])\n \n-(define_insn \"*cbranchhi_neg\"\n+(define_insn \"cbranchhi_neg\"\n   [(set (pc) \n \t(if_then_else (match_operator:HI 1 \"comparison_operator\"\n \t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\" \n@@ -1095,3 +1137,208 @@\n   \"\"\n   [(set_attr \"length\" \"0\")\n    (set_attr \"psw_operand\" \"nop\")])\n+\n+;;---------------------------------------------------------------------------\n+\n+(define_expand \"iorqi3\"\n+  [(match_operand:QI 0 \"xstormy16_below100_or_register\" \"\")\n+   (match_operand:QI 1 \"xstormy16_below100_or_register\" \"\")\n+   (match_operand:QI 2 \"nonmemory_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  xstormy16_expand_iorqi3 (operands);\n+  DONE;\n+}\")\n+\n+(define_insn \"iorqi3_internal\"\n+  [(set (match_operand:QI 0 \"xstormy16_below100_or_register\" \"=Wr\")\n+\t(ior:QI (match_operand:QI 1 \"xstormy16_below100_or_register\" \"0\")\n+\t\t(match_operand:QI 2 \"xstormy16_onebit_set_operand\" \"i\")))]\n+  \"\"\n+  \"set1 %0,%B2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"psw_operand\" \"0\")])\n+\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(match_operand:QI 1 \"xstormy16_below100_operand\" \"\"))\n+   (set (match_operand:HI 2 \"register_operand\" \"\")\n+\t(ior:HI (match_operand:HI 3 \"register_operand\" \"\")\n+\t\t(match_operand:QI 4 \"xstormy16_onebit_set_operand\" \"\")))\n+   (set (match_operand:QI 5 \"xstormy16_below100_operand\" \"\")\n+\t(match_operand:QI 6 \"register_operand\" \"\"))\n+   ]\n+  \"REGNO (operands[0]) == REGNO (operands[2])\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && REGNO (operands[0]) == REGNO (operands[6])\n+   && rtx_equal_p (operands[1], operands[5])\"\n+  [(set (match_dup 1)\n+\t(ior:QI (match_dup 1)\n+\t\t(match_dup 4)))\n+   ]\n+  \"\")\n+\n+\n+(define_expand \"andqi3\"\n+  [(match_operand:QI 0 \"xstormy16_below100_or_register\" \"\")\n+   (match_operand:QI 1 \"xstormy16_below100_or_register\" \"\")\n+   (match_operand:QI 2 \"nonmemory_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  xstormy16_expand_andqi3 (operands);\n+  DONE;\n+}\")\n+\n+(define_insn \"andqi3_internal\"\n+  [(set (match_operand:QI 0 \"xstormy16_below100_or_register\" \"=Wr\")\n+\t(and:QI (match_operand:QI 1 \"xstormy16_below100_or_register\" \"0\")\n+\t\t(match_operand:QI 2 \"xstormy16_onebit_clr_operand\" \"i\")))]\n+  \"\"\n+  \"clr1 %0,%B2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"psw_operand\" \"0\")])\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand 2 \"immediate_operand\" \"\")))\n+   (set (match_operand:HI 3 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 4 \"register_operand\" \"\")));\n+   ]\n+  \"REGNO (operands[0]) == REGNO (operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && REGNO (operands[0]) == REGNO (operands[4])\"\n+  [(set (match_dup 0)\n+\t(and:HI (match_dup 1)\n+\t\t(match_dup 5)))\n+   ]\n+  \"operands[5] = GEN_INT (INTVAL (operands[2]) & 0xff);\")\n+\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(match_operand:QI 1 \"xstormy16_below100_operand\" \"\"))\n+   (set (match_operand:HI 2 \"register_operand\" \"\")\n+\t(and:HI (match_operand:HI 3 \"register_operand\" \"\")\n+\t\t(match_operand:QI 4 \"xstormy16_onebit_clr_operand\" \"\")))\n+   (set (match_operand:QI 5 \"xstormy16_below100_operand\" \"\")\n+\t(match_operand:QI 6 \"register_operand\" \"\"))\n+   ]\n+  \"REGNO (operands[0]) == REGNO (operands[2])\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && REGNO (operands[0]) == REGNO (operands[6])\n+   && rtx_equal_p (operands[1], operands[5])\"\n+  [(set (match_dup 1)\n+\t(and:QI (match_dup 1)\n+\t\t(match_dup 4)))\n+   ]\n+  \"\")\n+\n+;; GCC uses different techniques to optimize MSB and LSB accesses, so\n+;; we have to code those separately.\n+\n+(define_insn \"*bclrx\"\n+  [(set (pc) \n+\t(if_then_else (eq:HI (and:QI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\")\n+\t\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 3 \"\" \"=y\"))]\n+  \"\"\n+  \"bn %1,%B2,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"*bclrx2\"\n+  [(set (pc) \n+\t(if_then_else (zero_extract:HI\n+\t\t       (xor:HI (subreg:HI\n+\t\t\t\t(match_operand:QI 1 \"xstormy16_below100_operand\" \"W\") 0)\n+\t\t\t       (match_operand:HI 2 \"xstormy16_onebit_set_operand\" \"J\"))\n+\t\t       (const_int 1)\n+\t\t       (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 4 \"\" \"=y\"))]\n+  \"\"\n+  \"bn %1,%B2,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"*bclr7\"\n+  [(set (pc) \n+\t(if_then_else (xor:HI (lshiftrt:HI (subreg:HI\n+\t\t\t\t\t    (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\") 0)\n+\t\t\t\t\t   (const_int 7))\n+\t\t\t      (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 2 \"\" \"=y\"))]\n+  \"\"\n+  \"bn %1,#7,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"*bclr15\"\n+  [(set (pc) \n+\t(if_then_else (ge:HI (sign_extend:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\"))\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 2 \"\" \"=y\"))]\n+  \"\"\n+  \"bn %1,#7,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"*bsetx\"\n+  [(set (pc) \n+\t(if_then_else (ne:HI (and:QI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\")\n+\t\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 3 \"\" \"=y\"))]\n+  \"\"\n+  \"bp %1,%B2,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"*bsetx2\"\n+  [(set (pc) \n+\t(if_then_else (zero_extract:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\")\n+\t\t\t\t       (const_int 1)\n+\t\t\t\t       (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 3 \"\" \"=y\"))]\n+  \"\"\n+  \"bp %1,%b2,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"*bset7\"\n+  [(set (pc) \n+\t(if_then_else (lshiftrt:HI (subreg:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\") 0)\n+\t\t\t\t   (const_int 7))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 2 \"\" \"=y\"))]\n+  \"\"\n+  \"bp %1,#7,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])\n+\n+(define_insn \"*bset15\"\n+  [(set (pc) \n+\t(if_then_else (lt:HI (sign_extend:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\"))\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_operand:BI 2 \"\" \"=y\"))]\n+  \"\"\n+  \"bp %1,#7,%l0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"psw_operand\" \"nop\")])"}, {"sha": "5023f2776d672c4a8561794afc3876961df33747", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e9a19d9d7113828f585504d126e1a0c01fed77/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=54e9a19d9d7113828f585504d126e1a0c01fed77", "patch": "@@ -2977,6 +2977,23 @@ Currently @option{-m[no-]ms-bitfields} is provided for the Microsoft Windows X86\n compilers to match the native Microsoft compiler.\n @end table\n \n+@subsection Xstormy16 Variable Attributes\n+\n+One attribute is currently defined for xstormy16 configurations:\n+@code{below100}\n+\n+@table @code\n+@item below100\n+@cindex @code{below100} attribute\n+\n+If a variable has the @code{below100} attribute (@code{BELOW100} is\n+allowed also), GCC will place the variable in the first 0x100 bytes of\n+memory and use special opcodes to access it.  Such variables will be\n+placed in either the @code{.bss_below100} section or the\n+@code{.data_below100} section.\n+\n+@end table\n+\n @node Type Attributes\n @section Specifying Attributes of Types\n @cindex attribute of types"}]}