{"sha": "1af78e731feb9327a17c99ebaa19a4cca1125caf", "node_id": "C_kwDOANBUbNoAKDFhZjc4ZTczMWZlYjkzMjdhMTdjOTllYmFhMTlhNGNjYTExMjVjYWY", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-10-20T04:11:15Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-10-21T02:23:01Z"}, "message": "Fortran: Fixes and additional tests for shape/ubound/size [PR94070]\n\nThis patch reimplements the SHAPE intrinsic to be inlined similarly to\nLBOUND and UBOUND, instead of as a library call, to avoid an\nunnecessary array copy.  Various bugs are also fixed.\n\ngcc/fortran/\n\tPR fortran/94070\n\n\t* expr.c (gfc_simplify_expr): Handle GFC_ISYM_SHAPE along with\n\tGFC_ISYM_LBOUND and GFC_ISYM_UBOUND.\n\t* trans-array.c (gfc_conv_ss_startstride): Likewise.\n\t(set_loop_bounds): Likewise.\n\t* trans-intrinsic.c (gfc_trans_intrinsic_bound): Extend to\n\thandle SHAPE.  Correct logic for zero-size special cases and\n\tdetecting assumed-rank arrays associated with an assumed-size\n\targument.\n\t(gfc_conv_intrinsic_shape): Deleted.\n\t(gfc_conv_intrinsic_function): Handle GFC_ISYM_SHAPE like\n\tGFC_ISYM_LBOUND and GFC_ISYM_UBOUND.\n\t(gfc_add_intrinsic_ss_code): Likewise.\n\t(gfc_walk_intrinsic_bound): Likewise.\n\ngcc/testsuite/\n\tPR fortran/94070\n\n\t* gfortran.dg/c-interop/shape-bindc.f90: New test.\n\t* gfortran.dg/c-interop/shape-poly.f90: New test.\n\t* gfortran.dg/c-interop/size-bindc.f90: New test.\n\t* gfortran.dg/c-interop/size-poly.f90: New test.\n\t* gfortran.dg/c-interop/ubound-bindc.f90: New test.\n\t* gfortran.dg/c-interop/ubound-poly.f90: New test.", "tree": {"sha": "214c687eeeba131f0c1dc705406fa37e0560b44a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/214c687eeeba131f0c1dc705406fa37e0560b44a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1af78e731feb9327a17c99ebaa19a4cca1125caf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af78e731feb9327a17c99ebaa19a4cca1125caf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af78e731feb9327a17c99ebaa19a4cca1125caf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af78e731feb9327a17c99ebaa19a4cca1125caf/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1556e447c0fee5c77ccd9bda243d5281e10e895b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1556e447c0fee5c77ccd9bda243d5281e10e895b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1556e447c0fee5c77ccd9bda243d5281e10e895b"}], "stats": {"total": 933, "additions": 755, "deletions": 178}, "files": [{"sha": "b19d3a26c605e78bb777f8c2a1c4a0e0c921b745", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -2205,7 +2205,8 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t  (p->value.function.isym->id == GFC_ISYM_LBOUND\n \t   || p->value.function.isym->id == GFC_ISYM_UBOUND\n \t   || p->value.function.isym->id == GFC_ISYM_LCOBOUND\n-\t   || p->value.function.isym->id == GFC_ISYM_UCOBOUND))\n+\t   || p->value.function.isym->id == GFC_ISYM_UCOBOUND\n+\t   || p->value.function.isym->id == GFC_ISYM_SHAPE))\n \tap = ap->next;\n \n       for ( ; ap; ap = ap->next)"}, {"sha": "bceb8b24ba40b36932f5c93597f3fedeec5e6093", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -4507,6 +4507,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    case GFC_ISYM_UBOUND:\n \t    case GFC_ISYM_LCOBOUND:\n \t    case GFC_ISYM_UCOBOUND:\n+\t    case GFC_ISYM_SHAPE:\n \t    case GFC_ISYM_THIS_IMAGE:\n \t      loop->dimen = ss->dimen;\n \t      goto done;\n@@ -4558,12 +4559,14 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    /* Fall through to supply start and stride.  */\n \t    case GFC_ISYM_LBOUND:\n \t    case GFC_ISYM_UBOUND:\n+\t      /* This is the variant without DIM=...  */\n+\t      gcc_assert (expr->value.function.actual->next->expr == NULL);\n+\t      /* Fall through.  */\n+\n+\t    case GFC_ISYM_SHAPE:\n \t      {\n \t\tgfc_expr *arg;\n \n-\t\t/* This is the variant without DIM=...  */\n-\t\tgcc_assert (expr->value.function.actual->next->expr == NULL);\n-\n \t\targ = expr->value.function.actual->expr;\n \t\tif (arg->rank == -1)\n \t\t  {\n@@ -5350,10 +5353,13 @@ set_loop_bounds (gfc_loopinfo *loop)\n \t\tgfc_expr *expr = loopspec[n]->info->expr;\n \n \t\t/* The {l,u}bound of an assumed rank.  */\n-\t\tgcc_assert ((expr->value.function.isym->id == GFC_ISYM_LBOUND\n-\t\t\t     || expr->value.function.isym->id == GFC_ISYM_UBOUND)\n-\t\t\t     && expr->value.function.actual->next->expr == NULL\n-\t\t\t     && expr->value.function.actual->expr->rank == -1);\n+\t\tif (expr->value.function.isym->id == GFC_ISYM_SHAPE)\n+\t\t  gcc_assert (expr->value.function.actual->expr->rank == -1);\n+\t\telse\n+\t\t  gcc_assert ((expr->value.function.isym->id == GFC_ISYM_LBOUND\n+\t\t\t       || expr->value.function.isym->id == GFC_ISYM_UBOUND)\n+\t\t\t      && expr->value.function.actual->next->expr == NULL\n+\t\t\t      && expr->value.function.actual->expr->rank == -1);\n \n \t\tloop->to[n] = info->end[dim];\n \t\tbreak;"}, {"sha": "0d9195863a30ab5fda6f643a2fa702f93099a818", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 76, "deletions": 170, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -2922,17 +2922,18 @@ gfc_conv_is_contiguous_expr (gfc_se *se, gfc_expr *arg)\n /* TODO: bound intrinsic generates way too much unnecessary code.  */\n \n static void\n-gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n+gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, enum gfc_isym_id op)\n {\n   gfc_actual_arglist *arg;\n   gfc_actual_arglist *arg2;\n   tree desc;\n   tree type;\n   tree bound;\n   tree tmp;\n-  tree cond, cond1, cond3, cond4, size;\n+  tree cond, cond1;\n   tree ubound;\n   tree lbound;\n+  tree size;\n   gfc_se argse;\n   gfc_array_spec * as;\n   bool assumed_rank_lb_one;\n@@ -2943,7 +2944,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   if (se->ss)\n     {\n       /* Create an implicit second parameter from the loop variable.  */\n-      gcc_assert (!arg2->expr);\n+      gcc_assert (!arg2->expr || op == GFC_ISYM_SHAPE);\n       gcc_assert (se->loop->dimen == 1);\n       gcc_assert (se->ss->info->expr == expr);\n       gfc_advance_se_ss_chain (se);\n@@ -2979,12 +2980,14 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n   if (INTEGER_CST_P (bound))\n     {\n+      gcc_assert (op != GFC_ISYM_SHAPE);\n       if (((!as || as->type != AS_ASSUMED_RANK)\n \t   && wi::geu_p (wi::to_wide (bound),\n \t\t\t GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))))\n \t  || wi::gtu_p (wi::to_wide (bound), GFC_MAX_DIMENSIONS))\n \tgfc_error (\"%<dim%> argument of %s intrinsic at %L is not a valid \"\n-\t\t   \"dimension index\", upper ? \"UBOUND\" : \"LBOUND\",\n+\t\t   \"dimension index\",\n+\t\t   (op == GFC_ISYM_UBOUND) ? \"UBOUND\" : \"LBOUND\",\n \t\t   &expr->where);\n     }\n \n@@ -3008,8 +3011,8 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n         }\n     }\n \n-  /* Take care of the lbound shift for assumed-rank arrays, which are\n-     nonallocatable and nonpointers. Those has a lbound of 1.  */\n+  /* Take care of the lbound shift for assumed-rank arrays that are\n+     nonallocatable and nonpointers. Those have a lbound of 1.  */\n   assumed_rank_lb_one = as && as->type == AS_ASSUMED_RANK\n \t\t\t&& ((arg->expr->ts.type != BT_CLASS\n \t\t\t     && !arg->expr->symtree->n.sym->attr.allocatable\n@@ -3020,6 +3023,10 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n   ubound = gfc_conv_descriptor_ubound_get (desc, bound);\n   lbound = gfc_conv_descriptor_lbound_get (desc, bound);\n+  size = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t  gfc_array_index_type, ubound, lbound);\n+  size = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t  gfc_array_index_type, size, gfc_index_one_node);\n \n   /* 13.14.53: Result value for LBOUND\n \n@@ -3042,106 +3049,82 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n                not have size zero and has value zero if dimension DIM has\n                size zero.  */\n \n-  if (!upper && assumed_rank_lb_one)\n+  if (op == GFC_ISYM_LBOUND && assumed_rank_lb_one)\n     se->expr = gfc_index_one_node;\n   else if (as)\n     {\n-      tree stride = gfc_conv_descriptor_stride_get (desc, bound);\n-\n-      cond1 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n-\t\t\t       ubound, lbound);\n-      cond3 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n-\t\t\t       stride, gfc_index_zero_node);\n-      cond3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t       logical_type_node, cond3, cond1);\n-      cond4 = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n-\t\t\t       stride, gfc_index_zero_node);\n-\n-      if (upper)\n+      if (op == GFC_ISYM_UBOUND)\n \t{\n-\t  tree cond5;\n-\t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t  logical_type_node, cond3, cond4);\n-\t  cond5 = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n-\t\t\t\t   gfc_index_one_node, lbound);\n-\t  cond5 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t   logical_type_node, cond4, cond5);\n-\n-\t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t  logical_type_node, cond, cond5);\n-\n-\t  if (assumed_rank_lb_one)\n+\t  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n+\t\t\t\t  size, gfc_index_zero_node);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t      gfc_array_index_type, cond,\n+\t\t\t\t      (assumed_rank_lb_one ? size : ubound),\n+\t\t\t\t      gfc_index_zero_node);\n+\t}\n+      else if (op == GFC_ISYM_LBOUND)\n+\t{\n+\t  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n+\t\t\t\t  size, gfc_index_zero_node);\n+\t  if (as->type == AS_ASSUMED_SIZE)\n \t    {\n-\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t       gfc_array_index_type, ubound, lbound);\n-\t      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t       gfc_array_index_type, tmp, gfc_index_one_node);\n+\t      cond1 = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t       logical_type_node, bound,\n+\t\t\t\t       build_int_cst (TREE_TYPE (bound),\n+\t\t\t\t\t\t      arg->expr->rank - 1));\n+\t      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t      logical_type_node, cond, cond1);\n \t    }\n-          else\n-            tmp = ubound;\n-\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t      gfc_array_index_type, cond,\n-\t\t\t\t      tmp, gfc_index_zero_node);\n+\t\t\t\t      lbound, gfc_index_one_node);\n \t}\n+      else if (op == GFC_ISYM_SHAPE)\n+\tse->expr = size;\n       else\n-\t{\n-\t  if (as->type == AS_ASSUMED_SIZE)\n-\t    cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n-\t\t\t\t    bound, build_int_cst (TREE_TYPE (bound),\n-\t\t\t\t\t\t\t  arg->expr->rank - 1));\n-\t  else\n-\t    cond = logical_false_node;\n+\tgcc_unreachable ();\n \n-\t  cond1 = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t   logical_type_node, cond3, cond4);\n-\t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+      /* According to F2018 16.9.172, para 5, an assumed rank object,\n+\t argument associated with and assumed size array, has the ubound\n+\t of the final dimension set to -1 and UBOUND must return this.\n+\t Similarly for the SHAPE intrinsic.  */\n+      if (op != GFC_ISYM_LBOUND && assumed_rank_lb_one)\n+\t{\n+\t  tree minus_one = build_int_cst (gfc_array_index_type, -1);\n+\t  tree rank = fold_convert (gfc_array_index_type,\n+\t\t\t\t    gfc_conv_descriptor_rank (desc));\n+\t  rank = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t  gfc_array_index_type, rank, minus_one);\n+\n+\t  /* Fix the expression to stop it from becoming even more\n+\t     complicated.  */\n+\t  se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+\n+\t  /* Descriptors for assumed-size arrays have ubound = -1\n+\t     in the last dimension.  */\n+\t  cond1 = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t   logical_type_node, ubound, minus_one);\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t  logical_type_node, bound, rank);\n+\t  cond = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n \t\t\t\t  logical_type_node, cond, cond1);\n-\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t      gfc_array_index_type, cond,\n-\t\t\t\t      lbound, gfc_index_one_node);\n+\t\t\t\t      minus_one, se->expr);\n \t}\n     }\n-  else\n+  else   /* as is null; this is an old-fashioned 1-based array.  */\n     {\n-      if (upper)\n+      if (op != GFC_ISYM_LBOUND)\n         {\n-\t  size = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t  gfc_array_index_type, ubound, lbound);\n-\t  se->expr = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t      gfc_array_index_type, size,\n-\t\t\t\t  gfc_index_one_node);\n \t  se->expr = fold_build2_loc (input_location, MAX_EXPR,\n-\t\t\t\t      gfc_array_index_type, se->expr,\n+\t\t\t\t      gfc_array_index_type, size,\n \t\t\t\t      gfc_index_zero_node);\n \t}\n       else\n \tse->expr = gfc_index_one_node;\n     }\n \n-  /* According to F2018 16.9.172, para 5, an assumed rank object, argument\n-     associated with and assumed size array, has the ubound of the final\n-     dimension set to -1 and UBOUND must return this.  */\n-  if (upper && as && as->type == AS_ASSUMED_RANK)\n-    {\n-      tree minus_one = build_int_cst (gfc_array_index_type, -1);\n-      tree rank = fold_convert (gfc_array_index_type,\n-\t\t\t\tgfc_conv_descriptor_rank (desc));\n-      rank = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t      gfc_array_index_type, rank, minus_one);\n-      /* Fix the expression to stop it from becoming even more complicated.  */\n-      se->expr = gfc_evaluate_now (se->expr, &se->pre);\n-      cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t     logical_type_node, bound, rank);\n-      cond1 = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t       logical_type_node, ubound, minus_one);\n-      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t      logical_type_node, cond, cond1);\n-      se->expr = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t  gfc_array_index_type, cond,\n-\t\t\t\t  se->expr, minus_one);\n-    }\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, se->expr);\n@@ -6690,85 +6673,6 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   se->expr = fold_build2_loc (input_location, BIT_AND_EXPR, type, tmp, mask);\n }\n \n-static void\n-gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)\n-{\n-  gfc_actual_arglist *s, *k;\n-  gfc_expr *e;\n-  gfc_array_spec *as;\n-  gfc_ss *ss;\n-  symbol_attribute attr;\n-  tree result_desc = se->expr;\n-\n-  /* Remove the KIND argument, if present. */\n-  s = expr->value.function.actual;\n-  k = s->next;\n-  e = k->expr;\n-  gfc_free_expr (e);\n-  k->expr = NULL;\n-\n-  gfc_conv_intrinsic_funcall (se, expr);\n-\n-  /* According to F2018 16.9.172, para 5, an assumed rank entity, argument\n-     associated with an assumed size array, has the ubound of the final\n-     dimension set to -1 and SHAPE must return this.  */\n-\n-  as = gfc_get_full_arrayspec_from_expr (s->expr);\n-  if (!as || as->type != AS_ASSUMED_RANK)\n-    return;\n-  attr = gfc_expr_attr (s->expr);\n-  ss = gfc_walk_expr (s->expr);\n-  if (attr.pointer || attr.allocatable\n-      || !ss || ss->info->type != GFC_SS_SECTION)\n-    return;\n-  if (se->expr)\n-    result_desc = se->expr;\n-  if (POINTER_TYPE_P (TREE_TYPE (result_desc)))\n-    result_desc = build_fold_indirect_ref_loc (input_location, result_desc);\n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (result_desc)))\n-    {\n-      tree rank, minus_one, cond, ubound, tmp;\n-      stmtblock_t block;\n-      gfc_se ase;\n-\n-      minus_one = build_int_cst (gfc_array_index_type, -1);\n-\n-      /* Recover the descriptor for the array.  */\n-      gfc_init_se (&ase, NULL);\n-      ase.descriptor_only = 1;\n-      gfc_conv_expr_lhs (&ase, ss->info->expr);\n-\n-      /* Obtain rank-1 so that we can address both descriptors.  */\n-      rank = gfc_conv_descriptor_rank (ase.expr);\n-      rank = fold_convert (gfc_array_index_type, rank);\n-      rank = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t      gfc_array_index_type,\n-\t\t\t      rank, minus_one);\n-      rank = gfc_evaluate_now (rank, &se->pre);\n-\n-      /* The ubound for the final dimension will be tested for being -1.  */\n-      ubound = gfc_conv_descriptor_ubound_get (ase.expr, rank);\n-      ubound = gfc_evaluate_now (ubound, &se->pre);\n-      cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t     logical_type_node,\n-\t\t\t     ubound, minus_one);\n-\n-      /* Obtain the last element of the result from the library shape\n-\t intrinsic and set it to -1 if that is the value of ubound.  */\n-      tmp = gfc_conv_array_data (result_desc);\n-      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-      tmp = gfc_build_array_ref (tmp, rank, NULL, NULL);\n-\n-      gfc_init_block (&block);\n-      gfc_add_modify (&block, tmp, build_int_cst (TREE_TYPE (tmp), -1));\n-\n-      cond = build3_v (COND_EXPR, cond,\n-\t\t       gfc_finish_block (&block),\n-\t\t       build_empty_stmt (input_location));\n-      gfc_add_expr_to_block (&se->pre, cond);\n-    }\n-}\n-\n static void\n gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,\n \t\t\t  bool arithmetic)\n@@ -10178,10 +10082,6 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \t      gfc_conv_intrinsic_minmaxloc (se, expr, GT_EXPR);\n \t      break;\n \n-\t    case GFC_ISYM_SHAPE:\n-\t      gfc_conv_intrinsic_shape (se, expr);\n-\t      break;\n-\n \t    default:\n \t      gfc_conv_intrinsic_funcall (se, expr);\n \t      break;\n@@ -10575,7 +10475,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_LBOUND:\n-      gfc_conv_intrinsic_bound (se, expr, 0);\n+      gfc_conv_intrinsic_bound (se, expr, GFC_ISYM_LBOUND);\n       break;\n \n     case GFC_ISYM_LCOBOUND:\n@@ -10710,6 +10610,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_scale (se, expr);\n       break;\n \n+    case GFC_ISYM_SHAPE:\n+      gfc_conv_intrinsic_bound (se, expr, GFC_ISYM_SHAPE);\n+      break;\n+\n     case GFC_ISYM_SIGN:\n       gfc_conv_intrinsic_sign (se, expr);\n       break;\n@@ -10756,7 +10660,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_UBOUND:\n-      gfc_conv_intrinsic_bound (se, expr, 1);\n+      gfc_conv_intrinsic_bound (se, expr, GFC_ISYM_UBOUND);\n       break;\n \n     case GFC_ISYM_UCOBOUND:\n@@ -11030,6 +10934,7 @@ gfc_add_intrinsic_ss_code (gfc_loopinfo * loop ATTRIBUTE_UNUSED, gfc_ss * ss)\n     case GFC_ISYM_UCOBOUND:\n     case GFC_ISYM_LCOBOUND:\n     case GFC_ISYM_THIS_IMAGE:\n+    case GFC_ISYM_SHAPE:\n       break;\n \n     default:\n@@ -11038,8 +10943,8 @@ gfc_add_intrinsic_ss_code (gfc_loopinfo * loop ATTRIBUTE_UNUSED, gfc_ss * ss)\n }\n \n \n-/* The LBOUND, LCOBOUND, UBOUND and UCOBOUND intrinsics with one parameter\n-   are expanded into code inside the scalarization loop.  */\n+/* The LBOUND, LCOBOUND, UBOUND, UCOBOUND, and SHAPE intrinsics with\n+   one parameter are expanded into code inside the scalarization loop.  */\n \n static gfc_ss *\n gfc_walk_intrinsic_bound (gfc_ss * ss, gfc_expr * expr)\n@@ -11048,7 +10953,8 @@ gfc_walk_intrinsic_bound (gfc_ss * ss, gfc_expr * expr)\n     gfc_add_class_array_ref (expr->value.function.actual->expr);\n \n   /* The two argument version returns a scalar.  */\n-  if (expr->value.function.actual->next->expr)\n+  if (expr->value.function.isym->id != GFC_ISYM_SHAPE\n+      && expr->value.function.actual->next->expr)\n     return ss;\n \n   return gfc_get_array_ss (ss, expr, 1, GFC_SS_INTRINSIC);\n@@ -11148,7 +11054,6 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n     case GFC_ISYM_PARITY:\n     case GFC_ISYM_PRODUCT:\n     case GFC_ISYM_SUM:\n-    case GFC_ISYM_SHAPE:\n     case GFC_ISYM_SPREAD:\n     case GFC_ISYM_YN2:\n       /* Ignore absent optional parameters.  */\n@@ -11198,6 +11103,7 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n     case GFC_ISYM_UBOUND:\n     case GFC_ISYM_UCOBOUND:\n     case GFC_ISYM_THIS_IMAGE:\n+    case GFC_ISYM_SHAPE:\n       return gfc_walk_intrinsic_bound (ss, expr);\n \n     case GFC_ISYM_TRANSFER:"}, {"sha": "d9e193a6c3c483a79a473793112e481a2eef4c60", "filename": "gcc/testsuite/gfortran.dg/c-interop/shape-bindc.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape-bindc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape-bindc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape-bindc.f90?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.1  SHAPE\n+!\n+! The description of the intrinsic function SHAPE in ISO/IEC 1539-1:2010\n+! is changed for an assumed-rank array that is associated with an\n+! assumed-size array; an assumed-size array has no shape, but in this\n+! case the result has a value equal to \n+! [ (SIZE (ARRAY, I, KIND), I=1,RANK (ARRAY)) ] \n+! with KIND omitted from SIZE if it was omitted from SHAPE.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+\n+program test \n+\n+  ! Define some arrays for testing.\n+  integer, target :: x1(5)\n+  integer :: y1(0:9)\n+  integer, pointer :: p1(:)\n+  integer, allocatable :: a1(:)\n+  integer, target :: x3(2,3,4)\n+  integer :: y3(0:1,-3:-1,4)\n+  integer, pointer :: p3(:,:,:)\n+  integer, allocatable :: a3(:,:,:)\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call test1 (y1)\n+  p1 => x1\n+  call test1 (p1)\n+  allocate (a1(5))\n+  call test1 (a1)\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+contains\n+\n+  subroutine testit (a) bind(c)\n+    integer :: a(..)\n+    \n+    integer :: r\n+    r = rank(a)\n+\n+    block\n+      integer :: s(r)\n+      s = shape(a)\n+      do i = 1, r\n+        if (s(i) .ne. size(a,i)) stop 101\n+      end do\n+    end block\n+\n+  end subroutine\n+\n+  subroutine test1 (a) bind(c)\n+    integer :: a(*)\n+\n+    call testit (a)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2) bind(c)\n+    implicit none\n+    integer :: l1, u1, l2, u2\n+    integer :: a(l1:u1, l2:u2, *)\n+\n+    call testit (a)\n+  end subroutine\n+\n+end program"}, {"sha": "e17ca889fe993243729b6b6f1811fa0088629fd1", "filename": "gcc/testsuite/gfortran.dg/c-interop/shape-poly.f90", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape-poly.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape-poly.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape-poly.f90?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -0,0 +1,89 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.1  SHAPE\n+!\n+! The description of the intrinsic function SHAPE in ISO/IEC 1539-1:2010\n+! is changed for an assumed-rank array that is associated with an\n+! assumed-size array; an assumed-size array has no shape, but in this\n+! case the result has a value equal to \n+! [ (SIZE (ARRAY, I, KIND), I=1,RANK (ARRAY)) ] \n+! with KIND omitted from SIZE if it was omitted from SHAPE.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+!\n+! This is the polymorphic version of shape.f90.\n+\n+module m\n+  type :: t\n+    integer :: id\n+    real :: xyz(3)\n+  end type\n+end module\n+\n+program test \n+  use m\n+\n+  ! Define some arrays for testing.\n+  type(t), target :: x1(5)\n+  type(t) :: y1(0:9)\n+  class(t), pointer :: p1(:)\n+  class(t), allocatable :: a1(:)\n+  type(t), target :: x3(2,3,4)\n+  type(t) :: y3(0:1,-3:-1,4)\n+  class(t), pointer :: p3(:,:,:)\n+  type(t), allocatable :: a3(:,:,:)\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call test1 (y1)\n+  p1 => x1\n+  call test1 (p1)\n+  allocate (a1(5))\n+  call test1 (a1)\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+contains\n+\n+  subroutine testit (a)\n+    use m\n+    class(t) :: a(..)\n+    \n+    integer :: r\n+    r = rank(a)\n+\n+    block\n+      integer :: s(r)\n+      s = shape(a)\n+      do i = 1, r\n+        if (s(i) .ne. size(a,i)) stop 101\n+      end do\n+    end block\n+\n+  end subroutine\n+\n+  subroutine test1 (a)\n+    use m\n+    class(t) :: a(*)\n+\n+    call testit (a)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2)\n+    use m\n+    integer :: l1, u1, l2, u2\n+    class(t) :: a(l1:u1, l2:u2, *)\n+\n+    call testit (a)\n+  end subroutine\n+\n+end program"}, {"sha": "132ca50908785bd3c7e55b6b63ffe211684a465f", "filename": "gcc/testsuite/gfortran.dg/c-interop/size-bindc.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize-bindc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize-bindc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize-bindc.f90?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -0,0 +1,106 @@\n+! Reported as pr94070.\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.2 SIZE\n+!\n+! The description of the intrinsic function SIZE in ISO/IEC 1539-1:2010\n+! is changed in the following cases:\n+!\n+! (1) for an assumed-rank object that is associated with an assumed-size\n+! array, the result has the value \u22121 if DIM is present and equal to the\n+! rank of ARRAY, and a negative value that is equal to \n+! PRODUCT ( [ (SIZE (ARRAY, I, KIND), I=1, RANK (ARRAY)) ] ) \n+! if DIM is not present;\n+!\n+! (2) for an assumed-rank object that is associated with a scalar, the\n+! result has the value 1.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+\n+program test \n+\n+  ! Define some arrays for testing.\n+  integer, target :: x1(5)\n+  integer :: y1(0:9)\n+  integer, pointer :: p1(:)\n+  integer, allocatable :: a1(:)\n+  integer, target :: x3(2,3,4)\n+  integer :: y3(0:1,-3:-1,4)\n+  integer, pointer :: p3(:,:,:)\n+  integer, allocatable :: a3(:,:,:)\n+  integer :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call test1 (y1)\n+  p1 => x1\n+  call test1 (p1)\n+  allocate (a1(5))\n+  call test1 (a1)\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+  ! Test scalars.\n+  call test0 (x)\n+  call test0 (-1)\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a, r, sizes) bind(c)\n+    integer :: a(..)\n+    integer :: r\n+    integer :: sizes(r)\n+    \n+    integer :: totalsize, thissize\n+    totalsize = 1\n+\n+    if (r .ne. rank(a))  stop 101\n+\n+    do i = 1, r\n+      thissize = size (a, i)\n+      print *, 'got size ', thissize, ' expected ', sizes(i)\n+      if (thissize .ne. sizes(i)) stop 102\n+      totalsize = totalsize * thissize\n+    end do\n+\n+    if (size(a) .ne. totalsize) stop 103\n+  end subroutine\n+\n+  subroutine test0 (a) bind(c)\n+    integer :: a(..)\n+\n+    if (size (a) .ne. 1) stop 103\n+  end subroutine\n+\n+  subroutine test1 (a) bind(c)\n+    integer :: a(*)\n+\n+    integer :: sizes(1)\n+    sizes(1) = -1\n+    call testit (a, 1, sizes)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2) bind(c)\n+    implicit none\n+    integer :: l1, u1, l2, u2\n+    integer :: a(l1:u1, l2:u2, *)\n+\n+    integer :: sizes(3)\n+    sizes(1) = u1 - l1 + 1\n+    sizes(2) = u2 - l2 + 1\n+    sizes(3) = -1\n+\n+    call testit (a, 3, sizes)\n+  end subroutine\n+\n+end program"}, {"sha": "2241ab840bfdc9a8fdf28787300740d0b3b1fae4", "filename": "gcc/testsuite/gfortran.dg/c-interop/size-poly.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize-poly.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize-poly.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize-poly.f90?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -0,0 +1,118 @@\n+! Reported as pr94070.\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.2 SIZE\n+!\n+! The description of the intrinsic function SIZE in ISO/IEC 1539-1:2010\n+! is changed in the following cases:\n+!\n+! (1) for an assumed-rank object that is associated with an assumed-size\n+! array, the result has the value \u22121 if DIM is present and equal to the\n+! rank of ARRAY, and a negative value that is equal to \n+! PRODUCT ( [ (SIZE (ARRAY, I, KIND), I=1, RANK (ARRAY)) ] ) \n+! if DIM is not present;\n+!\n+! (2) for an assumed-rank object that is associated with a scalar, the\n+! result has the value 1.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+!\n+! This is the polymorphic version of size.f90.\n+\n+module m\n+  type :: t\n+    integer :: id\n+    real :: xyz(3)\n+  end type\n+end module\n+\n+program test\n+  use m\n+\n+  ! Define some arrays for testing.\n+  type(t), target :: x1(5)\n+  type(t) :: y1(0:9)\n+  class(t), pointer :: p1(:)\n+  class(t), allocatable :: a1(:)\n+  type(t), target :: x3(2,3,4)\n+  type(t) :: y3(0:1,-3:-1,4)\n+  class(t), pointer :: p3(:,:,:)\n+  type(t), allocatable :: a3(:,:,:)\n+  type(t) :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call test1 (y1)\n+  p1 => x1\n+  call test1 (p1)\n+  allocate (a1(5))\n+  call test1 (a1)\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+  ! Test scalars.\n+  call test0 (x)\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a, r, sizes)\n+    use m\n+    class(t) :: a(..)\n+    integer :: r\n+    integer :: sizes(r)\n+    \n+    integer :: totalsize, thissize\n+    totalsize = 1\n+\n+    if (r .ne. rank(a))  stop 101\n+\n+    do i = 1, r\n+      thissize = size (a, i)\n+      print *, 'got size ', thissize, ' expected ', sizes(i)\n+      if (thissize .ne. sizes(i)) stop 102\n+      totalsize = totalsize * thissize\n+    end do\n+\n+    if (size(a) .ne. totalsize) stop 103\n+  end subroutine\n+\n+  subroutine test0 (a)\n+    use m\n+    class(t) :: a(..)\n+\n+    if (size (a) .ne. 1) stop 103\n+  end subroutine\n+\n+  subroutine test1 (a)\n+    use m\n+    class(t) :: a(*)\n+\n+    integer :: sizes(1)\n+    sizes(1) = -1\n+    call testit (a, 1, sizes)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2)\n+    use m\n+    integer :: l1, u1, l2, u2\n+    class(t) :: a(l1:u1, l2:u2, *)\n+\n+    integer :: sizes(3)\n+    sizes(1) = u1 - l1 + 1\n+    sizes(2) = u2 - l2 + 1\n+    sizes(3) = -1\n+\n+    call testit (a, 3, sizes)\n+  end subroutine\n+\n+end program"}, {"sha": "e771836d11a77fa35d050300ade9321da1553b75", "filename": "gcc/testsuite/gfortran.dg/c-interop/ubound-bindc.f90", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound-bindc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound-bindc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound-bindc.f90?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -0,0 +1,129 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.3  UBOUND\n+!\n+! The description of the intrinsic function UBOUND in ISO/IEC\n+! 1539-1:2010 is changed for an assumed-rank object that is associated\n+! with an assumed-size array; the result of UBOUND (ARRAY, RANK(ARRAY),\n+! KIND) has a value equal to LBOUND (ARRAY, RANK (ARRAY), KIND) \u22122 with\n+! KIND omitted from LBOUND if it was omitted from UBOUND.\n+!\n+! NOTE 6.2  \n+! If LBOUND or UBOUND is invoked for an assumed-rank object that is\n+! associated with a scalar and DIM is absent, the result is a zero-sized\n+! array. LBOUND or UBOUND cannot be invoked for an assumed-rank object\n+! that is associated with a scalar if DIM is present because the rank of\n+! a scalar is zero and DIM must be \u2265 1.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+\n+program test \n+\n+  ! Define some arrays for testing.\n+  integer, target :: x1(5)\n+  integer :: y1(0:9)\n+  integer, pointer :: p1(:)\n+  integer, allocatable :: a1(:)\n+  integer, target :: x3(2,3,4)\n+  integer :: y3(0:1,-3:-1,4)\n+  integer, pointer :: p3(:,:,:)\n+  integer, allocatable :: a3(:,:,:)\n+  integer :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call testit2(x1, shape(x1))\n+  call test1 (y1)\n+  call testit2(y1, shape(y1))\n+  p1 => x1\n+  call testit2(p1, shape(p1))\n+  call testit2p(p1, lbound(p1), shape(p1))\n+  call test1 (p1)\n+  p1(77:) => x1\n+  call testit2p(p1, [77], shape(p1))\n+  allocate (a1(5))\n+  call testit2(a1, shape(a1))\n+  call testit2a(a1, lbound(a1), shape(a1))\n+  call test1 (a1)\n+  deallocate(a1)\n+  allocate (a1(-38:5))\n+  call test1 (a1)\n+  call testit2(a1, shape(a1))\n+  call testit2a(a1, [-38], shape(a1))\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+  ! Test some scalars.\n+  call test0 (x)\n+  call test0 (-1)\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a) bind(c)\n+    integer :: a(..)\n+    integer :: r\n+    r = rank(a)\n+    if (any (lbound (a) .ne. 1)) stop 101\n+    if (ubound (a, r) .ne. -1) stop 102\n+  end subroutine\n+\n+  subroutine testit2(a, shape) bind(c)\n+    integer :: a(..)\n+    integer :: shape(:)\n+    if (rank(a) /= size(shape)) stop 111\n+    if (any (lbound(a) /= 1)) stop 112\n+    if (any (ubound(a) /= shape)) stop 113\n+  end subroutine\n+\n+  subroutine testit2a(a,lbound2,  shape2) bind(c)\n+    integer, allocatable :: a(..)\n+    integer :: lbound2(:), shape2(:)\n+    if (rank(a) /= size(shape2)) stop 121\n+    if (any (lbound(a) /= lbound2)) stop 122\n+    if (any (ubound(a) /= lbound2 + shape2 - 1)) stop 123\n+    if (any (shape(a) /= shape2)) stop 124\n+    if (sum (shape(a)) /= size(a)) stop 125\n+  end subroutine\n+\n+  subroutine testit2p(a, lbound2, shape2) bind(c)\n+    integer, pointer :: a(..)\n+    integer :: lbound2(:), shape2(:)\n+    if (rank(a) /= size(shape2)) stop 131\n+    if (any (lbound(a) /= lbound2)) stop 132\n+    if (any (ubound(a) /= lbound2 + shape2 - 1)) stop 133\n+    if (any (shape(a) /= shape2)) stop 134\n+    if (sum (shape(a)) /= size(a)) stop 135\n+  end subroutine \n+\n+  subroutine test0 (a) bind(c)\n+    integer :: a(..)\n+    if (rank (a) .ne. 0) stop 141\n+    if (size (lbound (a)) .ne. 0) stop 142\n+    if (size (ubound (a)) .ne. 0) stop 143\n+  end subroutine\n+\n+  subroutine test1 (a) bind(c)\n+    integer :: a(*)\n+\n+    call testit (a)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2) bind(c)\n+    implicit none\n+    integer :: l1, u1, l2, u2\n+    integer :: a(l1:u1, l2:u2, *)\n+\n+    call testit (a)\n+  end subroutine\n+\n+end program"}, {"sha": "333a253fc1860b68329e978facaa168408bf5d91", "filename": "gcc/testsuite/gfortran.dg/c-interop/ubound-poly.f90", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound-poly.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af78e731feb9327a17c99ebaa19a4cca1125caf/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound-poly.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound-poly.f90?ref=1af78e731feb9327a17c99ebaa19a4cca1125caf", "patch": "@@ -0,0 +1,145 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.3  UBOUND\n+!\n+! The description of the intrinsic function UBOUND in ISO/IEC\n+! 1539-1:2010 is changed for an assumed-rank object that is associated\n+! with an assumed-size array; the result of UBOUND (ARRAY, RANK(ARRAY),\n+! KIND) has a value equal to LBOUND (ARRAY, RANK (ARRAY), KIND) \u22122 with\n+! KIND omitted from LBOUND if it was omitted from UBOUND.\n+!\n+! NOTE 6.2  \n+! If LBOUND or UBOUND is invoked for an assumed-rank object that is\n+! associated with a scalar and DIM is absent, the result is a zero-sized\n+! array. LBOUND or UBOUND cannot be invoked for an assumed-rank object\n+! that is associated with a scalar if DIM is present because the rank of\n+! a scalar is zero and DIM must be \u2265 1.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+!\n+! This is like ubound.f90, but using polymorphic arrays instead of integer\n+! arrays.\n+\n+module m\n+  type :: t\n+    integer :: id\n+    real :: xyz(3)\n+  end type\n+end module\n+\n+program test\n+  use m\n+\n+  ! Define some arrays for testing.\n+  type(t), target :: x1(5)\n+  type(t) :: y1(0:9)\n+  class(t), pointer :: p1(:)\n+  class(t), allocatable :: a1(:)\n+  type(t), target :: x3(2,3,4)\n+  type(t) :: y3(0:1,-3:-1,4)\n+  class(t), pointer :: p3(:,:,:)\n+  type(t), allocatable :: a3(:,:,:)\n+  type(t) :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call testit2(x1, shape(x1))\n+  call test1 (y1)\n+  call testit2(y1, shape(y1))\n+  p1 => x1\n+  call testit2(p1, shape(p1))\n+  call testit2p(p1, lbound(p1), shape(p1))\n+  call test1 (p1)\n+  p1(77:) => x1\n+  call testit2p(p1, [77], shape(p1))\n+  allocate (a1(5))\n+  call testit2(a1, shape(a1))\n+  call testit2a(a1, lbound(a1), shape(a1))\n+  call test1 (a1)\n+  deallocate(a1)\n+  allocate (a1(-38:5))\n+  call test1 (a1)\n+  call testit2(a1, shape(a1))\n+  call testit2a(a1, [-38], shape(a1))\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+  ! Test some scalars.\n+  call test0 (x)\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a)\n+    use m\n+    class(t) :: a(..)\n+    integer :: r\n+    r = rank(a)\n+    if (any (lbound (a) .ne. 1)) stop 101\n+    if (ubound (a, r) .ne. -1) stop 102\n+  end subroutine\n+\n+  subroutine testit2(a, shape)\n+    use m\n+    class(t) :: a(..)\n+    integer :: shape(:)\n+    if (rank(a) /= size(shape)) stop 111\n+    if (any (lbound(a) /= 1)) stop 112\n+    if (any (ubound(a) /= shape)) stop 113\n+  end subroutine\n+\n+  subroutine testit2a(a,lbound2,  shape2)\n+    use m\n+    class(t), allocatable :: a(..)\n+    integer :: lbound2(:), shape2(:)\n+    if (rank(a) /= size(shape2)) stop 121\n+    if (any (lbound(a) /= lbound2)) stop 122\n+    if (any (ubound(a) /= lbound2 + shape2 - 1)) stop 123\n+    if (any (shape(a) /= shape2)) stop 124\n+    if (sum (shape(a)) /= size(a)) stop 125\n+  end subroutine\n+\n+  subroutine testit2p(a, lbound2, shape2)\n+    use m\n+    class(t), pointer :: a(..)\n+    integer :: lbound2(:), shape2(:)\n+    if (rank(a) /= size(shape2)) stop 131\n+    if (any (lbound(a) /= lbound2)) stop 132\n+    if (any (ubound(a) /= lbound2 + shape2 - 1)) stop 133\n+    if (any (shape(a) /= shape2)) stop 134\n+    if (sum (shape(a)) /= size(a)) stop 135\n+  end subroutine \n+\n+  subroutine test0 (a)\n+    use m\n+    class(t) :: a(..)\n+    if (rank (a) .ne. 0) stop 141\n+    if (size (lbound (a)) .ne. 0) stop 142\n+    if (size (ubound (a)) .ne. 0) stop 143\n+  end subroutine\n+\n+  subroutine test1 (a)\n+    use m\n+    class(t) :: a(*)\n+\n+    call testit (a)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2)\n+    use m\n+    integer :: l1, u1, l2, u2\n+    class(t) :: a(l1:u1, l2:u2, *)\n+\n+    call testit (a)\n+  end subroutine\n+\n+end program"}]}