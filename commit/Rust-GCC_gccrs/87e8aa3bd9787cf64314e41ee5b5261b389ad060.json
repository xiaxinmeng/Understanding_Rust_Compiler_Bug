{"sha": "87e8aa3bd9787cf64314e41ee5b5261b389ad060", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlOGFhM2JkOTc4N2NmNjQzMTRlNDFlZTViNTI2MWIzODlhZDA2MA==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2018-02-19T17:30:57Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2018-02-19T17:30:57Z"}, "message": "gfortran.texi: Document additional src/dst_type.\n\ngcc/fortran/ChangeLog:\n\n2018-02-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.texi: Document additional src/dst_type.  Fix some typos.\n\t* trans-decl.c (gfc_build_builtin_function_decls): Declare the new\n\targument of _caf_*_by_ref () with * e { get, send, sendget }.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_caf_get): Add the type of the\n\tdata referenced when generating a call to caf_get_by_ref ().\n\t(conv_caf_send): Same but for caf_send_by_ref () and\n\tcaf_sendget_by_ref ().\n\ngcc/testsuite/ChangeLog:\n\n2018-02-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray_alloc_comp_6.f08: New test.\n\t* gfortran.dg/coarray_alloc_comp_7.f08: New test.\n\t* gfortran.dg/coarray_alloc_comp_8.f08: New test.\n\nlibgfortran/ChangeLog:\n\n2018-02-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* caf/libcaf.h: Add type parameters to the caf_*_by_ref prototypes.\n\t* caf/single.c (get_for_ref): Simplifications and now respecting\n\tthe type argument.\n\t(_gfortran_caf_get_by_ref): Added source type handing to get_for_ref().\n\t(send_by_ref): Simplifications and respecting the dst_type now.\n\t(_gfortran_caf_send_by_ref): Added destination type hand over to\n\tsend_by_ref().\n\t(_gfortran_caf_sendget_by_ref): Added general support and fixed stack\n\tcorruption.  The function is now really usable.\n\nFrom-SVN: r257813", "tree": {"sha": "3596b4c57cc39c5cea01844218aa9c8517c168db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3596b4c57cc39c5cea01844218aa9c8517c168db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e8aa3bd9787cf64314e41ee5b5261b389ad060", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e8aa3bd9787cf64314e41ee5b5261b389ad060", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e8aa3bd9787cf64314e41ee5b5261b389ad060", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e8aa3bd9787cf64314e41ee5b5261b389ad060/comments", "author": null, "committer": null, "parents": [{"sha": "bbe57e1e55ec6c97fce0f5e9e6ce1dacf4cc0d34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe57e1e55ec6c97fce0f5e9e6ce1dacf4cc0d34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe57e1e55ec6c97fce0f5e9e6ce1dacf4cc0d34"}], "stats": {"total": 459, "additions": 363, "deletions": 96}, "files": [{"sha": "e75361b63603324373f1bf0966431239be89bf15", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -1,3 +1,13 @@\n+2018-02-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.texi: Document additional src/dst_type.  Fix some typos.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Declare the new\n+\targument of _caf_*_by_ref () with * e { get, send, sendget }.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_caf_get): Add the type of the\n+\tdata referenced when generating a call to caf_get_by_ref ().\n+\t(conv_caf_send): Same but for caf_send_by_ref () and\n+\tcaf_sendget_by_ref ().\n+\n 2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/84389"}, {"sha": "db48a7136611f3f5e6bea2cd7f7e1e285007afbc", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -4750,7 +4750,7 @@ remote image identified by the @var{image_index}.\n @item @emph{Syntax}:\n @code{void _gfortran_caf_send_by_ref (caf_token_t token, int image_index,\n gfc_descriptor_t *src, caf_reference_t *refs, int dst_kind, int src_kind,\n-bool may_require_tmp, bool dst_reallocatable, int *stat)}\n+bool may_require_tmp, bool dst_reallocatable, int *stat, int dst_type)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -4774,6 +4774,9 @@ is a full array or component ref.\n @item @var{stat} @tab intent(out) When non-@code{NULL} give the result of the\n operation, i.e., zero on success and non-zero on error.  When @code{NULL} and\n an error occurs, then an error message is printed and the program is terminated.\n+@item @var{dst_type} @tab intent(in)  Give the type of the destination.  When\n+the destination is not an array, than the precise type, e.g. of a component in\n+a derived type, is not known, but provided here.\n @end multitable\n \n @item @emph{NOTES}\n@@ -4808,7 +4811,7 @@ identified by the @var{image_index}.\n @item @emph{Syntax}:\n @code{void _gfortran_caf_get_by_ref (caf_token_t token, int image_index,\n caf_reference_t *refs, gfc_descriptor_t *dst, int dst_kind, int src_kind,\n-bool may_require_tmp, bool dst_reallocatable, int *stat)}\n+bool may_require_tmp, bool dst_reallocatable, int *stat, int src_type)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -4833,6 +4836,9 @@ array or a component is referenced.\n @item @var{stat} @tab intent(out) When non-@code{NULL} give the result of the\n operation, i.e., zero on success and non-zero on error.  When @code{NULL} and an\n error occurs, then an error message is printed and the program is terminated.\n+@item @var{src_type} @tab intent(in)  Give the type of the source.  When the\n+source is not an array, than the precise type, e.g. of a component in a\n+derived type, is not known, but provided here.\n @end multitable\n \n @item @emph{NOTES}\n@@ -4868,7 +4874,8 @@ identified by the @var{src_image_index} to a remote image identified by the\n @code{void _gfortran_caf_sendget_by_ref (caf_token_t dst_token,\n int dst_image_index, caf_reference_t *dst_refs,\n caf_token_t src_token, int src_image_index, caf_reference_t *src_refs,\n-int dst_kind, int src_kind, bool may_require_tmp, int *dst_stat, int *src_stat)}\n+int dst_kind, int src_kind, bool may_require_tmp, int *dst_stat,\n+int *src_stat, int dst_type, int src_type)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -4899,6 +4906,12 @@ program is terminated.\n the get-operation, i.e., zero on success and non-zero on error.  When\n @code{NULL} and an error occurs, then an error message is printed and the\n program is terminated.\n+@item @var{dst_type} @tab intent(in)  Give the type of the destination.  When\n+the destination is not an array, than the precise type, e.g. of a component in\n+a derived type, is not known, but provided here.\n+@item @var{src_type} @tab intent(in)  Give the type of the source.  When the\n+source is not an array, than the precise type, e.g. of a component in a\n+derived type, is not known, but provided here.\n @end multitable\n \n @item @emph{NOTES}"}, {"sha": "51de933e82daf3302fe91e0e54815b75983ed01e", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -3662,24 +3662,25 @@ gfc_build_builtin_function_decls (void)\n \tinteger_type_node, boolean_type_node, integer_type_node);\n \n       gfor_fndecl_caf_get_by_ref = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_get_by_ref\")), \".RWRRRRRW\", void_type_node,\n-\t9, pvoid_type_node, integer_type_node, pvoid_type_node, pvoid_type_node,\n-\tinteger_type_node, integer_type_node, boolean_type_node,\n-\tboolean_type_node, pint_type);\n+\tget_identifier (PREFIX(\"caf_get_by_ref\")), \".RWRRRRRWR\", void_type_node,\n+\t10, pvoid_type_node, integer_type_node, pvoid_type_node,\n+\tpvoid_type_node, integer_type_node, integer_type_node,\n+\tboolean_type_node, boolean_type_node, pint_type, integer_type_node);\n \n       gfor_fndecl_caf_send_by_ref = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_send_by_ref\")), \".RRRRRRRW\", void_type_node,\n-\t9, pvoid_type_node, integer_type_node, pvoid_type_node, pvoid_type_node,\n-\tinteger_type_node, integer_type_node, boolean_type_node,\n-\tboolean_type_node, pint_type);\n+\tget_identifier (PREFIX(\"caf_send_by_ref\")), \".RRRRRRRWR\",\n+\tvoid_type_node,\t10, pvoid_type_node, integer_type_node, pvoid_type_node,\n+\tpvoid_type_node, integer_type_node, integer_type_node,\n+\tboolean_type_node, boolean_type_node, pint_type, integer_type_node);\n \n       gfor_fndecl_caf_sendget_by_ref\n \t  = gfc_build_library_function_decl_with_spec (\n-\t    get_identifier (PREFIX(\"caf_sendget_by_ref\")), \".RR.RRRRRWW\",\n-\t    void_type_node, 11, pvoid_type_node, integer_type_node,\n+\t    get_identifier (PREFIX(\"caf_sendget_by_ref\")), \".RR.RRRRRWWRR\",\n+\t    void_type_node, 13, pvoid_type_node, integer_type_node,\n \t    pvoid_type_node, pvoid_type_node, integer_type_node,\n \t    pvoid_type_node, integer_type_node, integer_type_node,\n-\t    boolean_type_node, pint_type, pint_type);\n+\t    boolean_type_node, pint_type, pint_type, integer_type_node,\n+\t    integer_type_node);\n \n       gfor_fndecl_caf_sync_all = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_sync_all\")), \".WW\", void_type_node,"}, {"sha": "dd4921681fc78a56a175f6a9692170c323690fd1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -1709,12 +1709,13 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \n \t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get_by_ref,\n-\t\t\t\t     9, token, image_index, dst_var,\n+\t\t\t\t     10, token, image_index, dst_var,\n \t\t\t\t     caf_reference, lhs_kind, kind,\n \t\t\t\t     may_require_tmp,\n \t\t\t\t     may_realloc ? boolean_true_node :\n \t\t\t\t\t\t   boolean_false_node,\n-\t\t\t\t     stat);\n+\t\t\t\t     stat, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t  array_expr->ts.type));\n \n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -2100,9 +2101,11 @@ conv_caf_send (gfc_code *code) {\n \t\t\t\t\t     : boolean_false_node;\n \t  tmp = build_call_expr_loc (input_location,\n \t\t\t\t     gfor_fndecl_caf_send_by_ref,\n-\t\t\t\t     9, token, image_index, rhs_se.expr,\n+\t\t\t\t     10, token, image_index, rhs_se.expr,\n \t\t\t\t     reference, lhs_kind, rhs_kind,\n-\t\t\t\t     may_require_tmp, dst_realloc, src_stat);\n+\t\t\t\t     may_require_tmp, dst_realloc, src_stat,\n+\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t    lhs_expr->ts.type));\n \t  }\n       else\n \ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 11,\n@@ -2147,11 +2150,15 @@ conv_caf_send (gfc_code *code) {\n \t  lhs_reference = conv_expr_ref_to_caf_ref (&block, lhs_expr);\n \t  rhs_reference = conv_expr_ref_to_caf_ref (&block, rhs_expr);\n \t  tmp = build_call_expr_loc (input_location,\n-\t\t\t\t     gfor_fndecl_caf_sendget_by_ref, 11,\n+\t\t\t\t     gfor_fndecl_caf_sendget_by_ref, 13,\n \t\t\t\t     token, image_index, lhs_reference,\n \t\t\t\t     rhs_token, rhs_image_index, rhs_reference,\n \t\t\t\t     lhs_kind, rhs_kind, may_require_tmp,\n-\t\t\t\t     dst_stat, src_stat);\n+\t\t\t\t     dst_stat, src_stat,\n+\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t    lhs_expr->ts.type),\n+\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t    rhs_expr->ts.type));\n \t}\n       else\n \t{"}, {"sha": "ef615a4eeca3dc6cc7c5e504008cb68ccf4773ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -1,3 +1,9 @@\n+2018-02-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray_alloc_comp_6.f08: New test.\n+\t* gfortran.dg/coarray_alloc_comp_7.f08: New test.\n+\t* gfortran.dg/coarray_alloc_comp_8.f08: New test.\n+\n 2018-02-19  Carl Love  <cel@us.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-neg-int.p7.c: Remove test file."}, {"sha": "a37554ffc1bd32d8aaf8261052ad899a45833e9f", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_6.f08", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_6.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_6.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_6.f08?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+! { dg-additional-options \"-latomic\" { target libatomic_available } }\n+\n+! Check that type conversion during caf_get_by_ref is done for components.\n+\n+program main\n+\n+  implicit none\n+\n+  type :: mytype\n+    integer :: i\n+    integer :: i4 \n+    integer(kind=1) :: i1\n+    real :: r8\n+    real(kind=4) :: r4\n+    integer :: arr_i4(4)\n+    integer(kind=1) :: arr_i1(4)\n+    real :: arr_r8(4)\n+    real(kind=4) :: arr_r4(4)\n+  end type\n+\n+  type T\n+    type(mytype), allocatable :: obj\n+  end type T\n+\n+  type(T), save :: bar[*]\n+  integer :: i4, arr_i4(4)\n+  integer(kind=1) :: i1, arr_i1(4)\n+  real :: r8, arr_r8(4)\n+  real(kind=4) :: r4, arr_r4(4)\n+\n+  bar%obj = mytype(42, 4, INT(1, 1), 8.0, REAL(4.0, 4), (/ 1,2,3,4 /), &\n+  &       INT((/ 5,6,7,8 /), 1), (/ 1.2,3.4,5.6,7.8 /), REAL( &\n+  &       (/ 8.7,6.5,4.3,2.1 /), 4))\n+\n+  i1 = bar[1]%obj%r4\n+  if (i1 /= 4) stop 1\n+  i4 = bar[1]%obj%r8\n+  if (i4 /= 8) stop 2\n+  r4 = bar[1]%obj%i1\n+  if (abs(r4 - 1.0) > 1E-4) stop 3\n+  r8 = bar[1]%obj%i4\n+  if (abs(r8 - 4.0) > 1E-6) stop 4\n+\n+  arr_i1 = bar[1]%obj%arr_r4\n+  if (any(arr_i1 /= INT((/ 8,6,4,2 /), 1))) stop 5\n+  arr_i4 = bar[1]%obj%arr_r8\n+  if (any(arr_i4 /= (/ 1,3,5,7 /))) stop 6\n+  arr_r4 = bar[1]%obj%arr_i1\n+  if (any(abs(arr_r4 - REAL((/ 5,6,7,8 /), 4)) > 1E-4)) stop 7\n+  arr_r8 = bar[1]%obj%arr_i4\n+  if (any(abs(arr_r8 - (/ 1,2,3,4 /)) > 1E-6)) stop 8\n+end program\n+"}, {"sha": "93925828da1de1d7665ff8e061c357d6246676d3", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_7.f08", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_7.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_7.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_7.f08?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+! { dg-additional-options \"-latomic\" { target libatomic_available } }\n+\n+! Check that type conversion during caf_send_by_ref is done for components.\n+\n+program main\n+\n+  implicit none\n+\n+  type :: mytype\n+    integer :: i\n+    integer :: i4 \n+    integer(kind=1) :: i1\n+    real :: r8\n+    real(kind=4) :: r4\n+    integer :: arr_i4(4)\n+    integer(kind=1) :: arr_i1(4)\n+    real :: arr_r8(4)\n+    real(kind=4) :: arr_r4(4)\n+  end type\n+\n+  type T\n+    type(mytype), allocatable :: obj\n+  end type T\n+\n+  type(T), save :: bar[*]\n+  integer :: i4, arr_i4(4)\n+  integer(kind=1) :: i1, arr_i1(4)\n+  real :: r8, arr_r8(4)\n+  real(kind=4) :: r4, arr_r4(4)\n+\n+  allocate(bar%obj)\n+  i1 = INT(1, 1)\n+  i4 = 4\n+  r4 = REAL(4.0, 4)\n+  r8 = 8.0\n+  arr_i1 = INT((/ 5,6,7,8 /), 1)\n+  arr_i4 = (/ 1,2,3,4 /)\n+  arr_r8 = (/ 1.2,3.4,5.6,7.8 /)\n+  arr_r4 = REAL((/ 8.7,6.5,4.3,2.1 /), 4)\n+\n+  bar[1]%obj%r4 = i1\n+  if (abs(bar%obj%r4 - 1.0) > 1E-4) stop 1\n+  bar[1]%obj%r8 = i4\n+  if (abs(bar%obj%r8 - 4.0) > 1E-6) stop 2\n+  bar[1]%obj%i1 = r4\n+  if (bar%obj%i1 /= 4) stop 3\n+  bar[1]%obj%i4 = r8\n+  if (bar%obj%i4 /= 8) stop 4\n+\n+  bar[1]%obj%arr_r4 = arr_i1\n+  print *, bar%obj%arr_r4\n+  if (any(abs(bar%obj%arr_r4 - REAL((/ 5,6,7,8 /), 4)) > 1E-4)) stop 5\n+  bar[1]%obj%arr_r8 = arr_i4\n+  if (any(abs(bar%obj%arr_r8 - (/ 1,2,3,4 /)) > 1E-6)) stop 6\n+  bar[1]%obj%arr_i1 = arr_r4\n+  if (any(bar%obj%arr_i1 /= INT((/ 8,6,4,2 /), 1))) stop 7\n+  bar[1]%obj%arr_i4 = arr_r8\n+  if (any(bar%obj%arr_i4 /= (/ 1,3,5,7 /))) stop 8\n+end program\n+"}, {"sha": "679bec3290221bd1df0e78c9aa158af9b150637f", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_8.f08", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_8.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_8.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_8.f08?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+! { dg-additional-options \"-latomic\" { target libatomic_available } }\n+\n+! Check that type conversion during caf_sendget_by_ref is done for components.\n+\n+program main\n+\n+  implicit none\n+\n+  type :: mytype\n+    integer :: i\n+    integer :: i4 \n+    integer(kind=1) :: i1\n+    real :: r8\n+    real(kind=4) :: r4\n+    integer :: arr_i4(4)\n+    integer(kind=1) :: arr_i1(4)\n+    real :: arr_r8(4)\n+    real(kind=4) :: arr_r4(4)\n+  end type\n+\n+  type T\n+    type(mytype), allocatable :: obj\n+  end type T\n+\n+  type(T), save :: bar[*]\n+  integer :: i4, arr_i4(4)\n+  integer(kind=1) :: i1, arr_i1(4)\n+  real :: r8, arr_r8(4)\n+  real(kind=4) :: r4, arr_r4(4)\n+\n+  bar%obj = mytype(42, 4, INT(1, 1), 8.0, REAL(4.0, 4), (/ 1,2,3,4 /), &\n+  &       INT((/ 5,6,7,8 /), 1), (/ 1.2,3.4,5.6,7.8 /), REAL( &\n+  &       (/ 8.7,6.5,4.3,2.1 /), 4))\n+\n+  bar[1]%obj%i1 = bar[1]%obj%r4\n+  if (bar%obj%i1 /= 4) stop 1\n+  bar[1]%obj%i4 = bar[1]%obj%r8\n+  if (bar%obj%i4 /= 8) stop 2\n+  bar[1]%obj%arr_i1 = bar[1]%obj%arr_r4\n+  if (any(bar%obj%arr_i1 /= (/ 8,6,4,2 /))) stop 3\n+  bar[1]%obj%arr_i4 = bar[1]%obj%arr_r8\n+  if (any(bar%obj%arr_i4 /= (/ 1,3,5,7 /))) stop 4\n+\n+  bar%obj%i1 = INT(1, 1)\n+  bar%obj%i4 = 4\n+  bar%obj%arr_i1 = INT((/ 5,6,7,8 /), 1)\n+  bar%obj%arr_i4 = (/ 1,2,3,4 /)\n+  bar[1]%obj%r4 = bar[1]%obj%i1\n+  if (abs(bar%obj%r4 - 1.0) > 1E-4) stop 5\n+  bar[1]%obj%r8 = bar[1]%obj%i4\n+  if (abs(bar%obj%r8 - 4.0) > 1E-6) stop 6\n+  bar[1]%obj%arr_r4 = bar[1]%obj%arr_i1\n+  if (any(abs(bar%obj%arr_r4 - REAL((/ 5,6,7,8 /), 4)) > 1E-4)) stop 7\n+  bar[1]%obj%arr_r8 = bar[1]%obj%arr_i4\n+  if (any(abs(bar%obj%arr_r8 - (/ 1,2,3,4 /)) > 1E-6)) stop 8\n+end program\n+"}, {"sha": "67ddbee606f8488ad50aeff73ead64ac09637b70", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -1,3 +1,15 @@\n+2018-02-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* caf/libcaf.h: Add type parameters to the caf_*_by_ref prototypes.\n+\t* caf/single.c (get_for_ref): Simplifications and now respecting\n+\tthe type argument.\n+\t(_gfortran_caf_get_by_ref): Added source type handing to get_for_ref().\n+\t(send_by_ref): Simplifications and respecting the dst_type now.\n+\t(_gfortran_caf_send_by_ref): Added destination type hand over to\n+\tsend_by_ref().\n+\t(_gfortran_caf_sendget_by_ref): Added general support and fixed stack\n+\tcorruption.  The function is now really usable.\n+\n 2018-02-14  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n \n \tPR target/84148"}, {"sha": "f3428a63faec3ab311c1eb7be1a219bcace53afa", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -226,15 +226,17 @@ void _gfortran_caf_sendget (caf_token_t, size_t, int, gfc_descriptor_t *,\n \n void _gfortran_caf_get_by_ref (caf_token_t token, int image_idx,\n \tgfc_descriptor_t *dst, caf_reference_t *refs, int dst_kind,\n-\tint src_kind, bool may_require_tmp, bool dst_reallocatable, int *stat);\n+\tint src_kind, bool may_require_tmp, bool dst_reallocatable, int *stat,\n+\tint src_type);\n void _gfortran_caf_send_by_ref (caf_token_t token, int image_index,\n \tgfc_descriptor_t *src, caf_reference_t *refs, int dst_kind,\n-\tint src_kind, bool may_require_tmp, bool dst_reallocatable, int *stat);\n+\tint src_kind, bool may_require_tmp, bool dst_reallocatable, int *stat,\n+\tint dst_type);\n void _gfortran_caf_sendget_by_ref (\n \tcaf_token_t dst_token, int dst_image_index, caf_reference_t *dst_refs,\n \tcaf_token_t src_token, int src_image_index, caf_reference_t *src_refs,\n \tint dst_kind, int src_kind, bool may_require_tmp, int *dst_stat,\n-\tint *src_stat);\n+\tint *src_stat, int dst_type, int src_type);\n \n void _gfortran_caf_atomic_define (caf_token_t, size_t, int, void *, int *,\n \t\t\t\t  int, int);"}, {"sha": "18906e99a9409b8f8ac8cc36034966e6be38dbc1", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 113, "deletions": 73, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e8aa3bd9787cf64314e41ee5b5261b389ad060/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e8aa3bd9787cf64314e41ee5b5261b389ad060/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=87e8aa3bd9787cf64314e41ee5b5261b389ad060", "patch": "@@ -1194,7 +1194,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t     caf_single_token_t single_token, gfc_descriptor_t *dst,\n \t     gfc_descriptor_t *src, void *ds, void *sr,\n \t     int dst_kind, int src_kind, size_t dst_dim, size_t src_dim,\n-\t     size_t num, int *stat)\n+\t     size_t num, int *stat, int src_type)\n {\n   ptrdiff_t extent_src = 1, array_offset_src = 0, stride_src;\n   size_t next_dst_dim;\n@@ -1209,34 +1209,32 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n       size_t dst_size = GFC_DESCRIPTOR_SIZE (dst);\n       ptrdiff_t array_offset_dst = 0;;\n       size_t dst_rank = GFC_DESCRIPTOR_RANK (dst);\n-      int src_type = -1;\n \n       switch (ref->type)\n \t{\n \tcase CAF_REF_COMPONENT:\n \t  /* Because the token is always registered after the component, its\n-\t     offset is always greater zeor.  */\n+\t     offset is always greater zero.  */\n \t  if (ref->u.c.caf_token_offset > 0)\n+\t    /* Note, that sr is dereffed here.  */\n \t    copy_data (ds, *(void **)(sr + ref->u.c.offset),\n-\t\t       GFC_DESCRIPTOR_TYPE (dst), GFC_DESCRIPTOR_TYPE (dst),\n+\t\t       GFC_DESCRIPTOR_TYPE (dst), src_type,\n \t\t       dst_kind, src_kind, dst_size, ref->item_size, 1, stat);\n \t  else\n \t    copy_data (ds, sr + ref->u.c.offset,\n-\t\t       GFC_DESCRIPTOR_TYPE (dst), GFC_DESCRIPTOR_TYPE (src),\n+\t\t       GFC_DESCRIPTOR_TYPE (dst), src_type,\n \t\t       dst_kind, src_kind, dst_size, ref->item_size, 1, stat);\n \t  ++(*i);\n \t  return;\n \tcase CAF_REF_STATIC_ARRAY:\n-\t  src_type = ref->u.a.static_array_type;\n \t  /* Intentionally fall through.  */\n \tcase CAF_REF_ARRAY:\n \t  if (ref->u.a.mode[src_dim] == CAF_ARR_REF_NONE)\n \t    {\n \t      for (size_t d = 0; d < dst_rank; ++d)\n \t\tarray_offset_dst += dst_index[d];\n \t      copy_data (ds + array_offset_dst * dst_size, sr,\n-\t\t\t GFC_DESCRIPTOR_TYPE (dst),\n-\t\t\t src_type == -1 ? GFC_DESCRIPTOR_TYPE (src) : src_type,\n+\t\t\t GFC_DESCRIPTOR_TYPE (dst), src_type,\n \t\t\t dst_kind, src_kind, dst_size, ref->item_size, num,\n \t\t\t stat);\n \t      *i += num;\n@@ -1252,23 +1250,39 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n     {\n     case CAF_REF_COMPONENT:\n       if (ref->u.c.caf_token_offset > 0)\n-\tget_for_ref (ref->next, i, dst_index,\n-\t\t    *(caf_single_token_t*)(sr + ref->u.c.caf_token_offset), dst,\n-\t\t (*(caf_single_token_t*)(sr + ref->u.c.caf_token_offset))->desc,\n-\t\t     ds, sr + ref->u.c.offset, dst_kind, src_kind, dst_dim, 0,\n-\t\t     1, stat);\n+\t{\n+\t  single_token = *(caf_single_token_t*)(sr + ref->u.c.caf_token_offset);\n+\n+\t  if (ref->next && ref->next->type == CAF_REF_ARRAY)\n+\t    src = single_token->desc;\n+\t  else\n+\t    src = NULL;\n+\n+\t  if (ref->next && ref->next->type == CAF_REF_COMPONENT)\n+\t    /* The currently ref'ed component was allocatabe (caf_token_offset\n+\t       > 0) and the next ref is a component, too, then the new sr has to\n+\t       be dereffed.  (static arrays can not be allocatable or they\n+\t       become an array with descriptor.  */\n+\t    sr = *(void **)(sr + ref->u.c.offset);\n+\t  else\n+\t    sr += ref->u.c.offset;\n+\n+\t  get_for_ref (ref->next, i, dst_index, single_token, dst, src,\n+\t\t       ds, sr, dst_kind, src_kind, dst_dim, 0,\n+\t\t       1, stat, src_type);\n+\t}\n       else\n \tget_for_ref (ref->next, i, dst_index, single_token, dst,\n \t\t     (gfc_descriptor_t *)(sr + ref->u.c.offset), ds,\n \t\t     sr + ref->u.c.offset, dst_kind, src_kind, dst_dim, 0, 1,\n-\t\t     stat);\n+\t\t     stat, src_type);\n       return;\n     case CAF_REF_ARRAY:\n       if (ref->u.a.mode[src_dim] == CAF_ARR_REF_NONE)\n \t{\n \t  get_for_ref (ref->next, i, dst_index, single_token, dst,\n \t\t       src, ds, sr, dst_kind, src_kind,\n-\t\t       dst_dim, 0, 1, stat);\n+\t\t       dst_dim, 0, 1, stat, src_type);\n \t  return;\n \t}\n       /* Only when on the left most index switch the data pointer to\n@@ -1311,7 +1325,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t    }\n@@ -1331,7 +1345,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t    }\n@@ -1358,7 +1372,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, next_dst_dim, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t      array_offset_src += stride_src;\n@@ -1372,7 +1386,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t  get_for_ref (ref, i, dst_index, single_token, dst, src, ds,\n \t\t       sr + array_offset_src * ref->item_size,\n \t\t       dst_kind, src_kind, dst_dim, src_dim + 1, 1,\n-\t\t       stat);\n+\t\t       stat, src_type);\n \t  return;\n \tcase CAF_ARR_REF_OPEN_END:\n \t  COMPUTE_NUM_ITEMS (extent_src,\n@@ -1390,7 +1404,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t      array_offset_src += stride_src;\n@@ -1410,7 +1424,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t      array_offset_src += stride_src;\n@@ -1425,7 +1439,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t{\n \t  get_for_ref (ref->next, i, dst_index, single_token, dst,\n \t\t       NULL, ds, sr, dst_kind, src_kind,\n-\t\t       dst_dim, 0, 1, stat);\n+\t\t       dst_dim, 0, 1, stat, src_type);\n \t  return;\n \t}\n       switch (ref->u.a.mode[src_dim])\n@@ -1460,7 +1474,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, NULL,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t    }\n@@ -1474,7 +1488,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, NULL,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t    }\n@@ -1491,7 +1505,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t      get_for_ref (ref, i, dst_index, single_token, dst, NULL,\n \t\t\t   ds, sr + array_offset_src * ref->item_size,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, stat);\n+\t\t\t   1, stat, src_type);\n \t      dst_index[dst_dim]\n \t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n \t      array_offset_src += ref->u.a.dim[src_dim].s.stride;\n@@ -1502,7 +1516,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t  get_for_ref (ref, i, dst_index, single_token, dst, NULL, ds,\n \t\t       sr + array_offset_src * ref->item_size,\n \t\t       dst_kind, src_kind, dst_dim, src_dim + 1, 1,\n-\t\t       stat);\n+\t\t       stat, src_type);\n \t  return;\n \t/* The OPEN_* are mapped to a RANGE and therefore can not occur.  */\n \tcase CAF_ARR_REF_OPEN_END:\n@@ -1523,7 +1537,8 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n \t\t\t  gfc_descriptor_t *dst, caf_reference_t *refs,\n \t\t\t  int dst_kind, int src_kind,\n \t\t\t  bool may_require_tmp __attribute__ ((unused)),\n-\t\t\t  bool dst_reallocatable, int *stat)\n+\t\t\t  bool dst_reallocatable, int *stat,\n+\t\t\t  int src_type)\n {\n   const char vecrefunknownkind[] = \"libcaf_single::caf_get_by_ref(): \"\n \t\t\t\t   \"unknown kind in vector-ref.\\n\";\n@@ -1585,7 +1600,13 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n \t  else\n \t    {\n \t      memptr += riter->u.c.offset;\n-\t      src = (gfc_descriptor_t *)memptr;\n+\t      /* When the next ref is an array ref, assume there is an\n+\t\t array descriptor at memptr.  Note, static arrays do not have\n+\t\t a descriptor.  */\n+\t      if (riter->next && riter->next->type == CAF_REF_ARRAY)\n+\t\tsrc = (gfc_descriptor_t *)memptr;\n+\t      else\n+\t\tsrc = NULL;\n \t    }\n \t  break;\n \tcase CAF_REF_ARRAY:\n@@ -1677,6 +1698,13 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n \t\t  caf_internal_error (extentoutofrange, stat, NULL, 0);\n \t\t  return;\n \t\t}\n+\t      /* Special mode when called by __caf_sendget_by_ref ().  */\n+\t      if (dst_rank == -1 && GFC_DESCRIPTOR_DATA (dst) == NULL)\n+\t\t{\n+\t\t  dst_rank = dst_cur_dim + 1;\n+\t\t  GFC_DESCRIPTOR_RANK (dst) = dst_rank;\n+\t\t  GFC_DESCRIPTOR_SIZE (dst) = dst_kind;\n+\t\t}\n \t      /* When dst is an array.  */\n \t      if (dst_rank > 0)\n \t\t{\n@@ -1845,6 +1873,13 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n \t\t  caf_internal_error (extentoutofrange, stat, NULL, 0);\n \t\t  return;\n \t\t}\n+\t      /* Special mode when called by __caf_sendget_by_ref ().  */\n+\t      if (dst_rank == -1 && GFC_DESCRIPTOR_DATA (dst) == NULL)\n+\t\t{\n+\t\t  dst_rank = dst_cur_dim + 1;\n+\t\t  GFC_DESCRIPTOR_RANK (dst) = dst_rank;\n+\t\t  GFC_DESCRIPTOR_SIZE (dst) = dst_kind;\n+\t\t}\n \t      /* When dst is an array.  */\n \t      if (dst_rank > 0)\n \t\t{\n@@ -1946,6 +1981,13 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n       if (!array_extent_fixed)\n \t{\n \t  assert (size == 1);\n+\t  /* Special mode when called by __caf_sendget_by_ref ().  */\n+\t  if (dst_rank == -1 && GFC_DESCRIPTOR_DATA (dst) == NULL)\n+\t    {\n+\t      dst_rank = dst_cur_dim + 1;\n+\t      GFC_DESCRIPTOR_RANK (dst) = dst_rank;\n+\t      GFC_DESCRIPTOR_SIZE (dst) = dst_kind;\n+\t    }\n \t  /* This can happen only, when the result is scalar.  */\n \t  for (dst_cur_dim = 0; dst_cur_dim < dst_rank; ++dst_cur_dim)\n \t    GFC_DIMENSION_SET (dst->dim[dst_cur_dim], 1, 1, 1);\n@@ -1967,7 +2009,7 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n   i = 0;\n   get_for_ref (refs, &i, dst_index, single_token, dst, src,\n \t       GFC_DESCRIPTOR_DATA (dst), memptr, dst_kind, src_kind, 0, 0,\n-\t       1, stat);\n+\t       1, stat, src_type);\n }\n \n \n@@ -1976,7 +2018,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t     caf_single_token_t single_token, gfc_descriptor_t *dst,\n \t     gfc_descriptor_t *src, void *ds, void *sr,\n \t     int dst_kind, int src_kind, size_t dst_dim, size_t src_dim,\n-\t     size_t num, size_t size, int *stat)\n+\t     size_t num, size_t size, int *stat, int dst_type)\n {\n   const char vecrefunknownkind[] = \"libcaf_single::caf_send_by_ref(): \"\n       \"unknown kind in vector-ref.\\n\";\n@@ -1992,7 +2034,6 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n     {\n       size_t src_size = GFC_DESCRIPTOR_SIZE (src);\n       ptrdiff_t array_offset_src = 0;;\n-      int dst_type = -1;\n \n       switch (ref->type)\n \t{\n@@ -2036,26 +2077,18 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t\t      dst_type = GFC_DESCRIPTOR_TYPE (dst);\n \t\t    }\n \t\t  else\n-\t\t    {\n-\t\t      /* When no destination descriptor is present, assume that\n-\t\t\t source and dest type are identical.  */\n-\t\t      dst_type = GFC_DESCRIPTOR_TYPE (src);\n-\t\t      ds = *(void **)(ds + ref->u.c.offset);\n-\t\t    }\n+\t\t    ds = *(void **)(ds + ref->u.c.offset);\n \t\t}\n \t      copy_data (ds, sr, dst_type, GFC_DESCRIPTOR_TYPE (src),\n \t\t\t dst_kind, src_kind, ref->item_size, src_size, 1, stat);\n \t    }\n \t  else\n-\t    copy_data (ds + ref->u.c.offset, sr,\n-\t\t       dst != NULL ? GFC_DESCRIPTOR_TYPE (dst)\n-\t\t\t\t   : GFC_DESCRIPTOR_TYPE (src),\n+\t    copy_data (ds + ref->u.c.offset, sr, dst_type,\n \t\t       GFC_DESCRIPTOR_TYPE (src),\n \t\t       dst_kind, src_kind, ref->item_size, src_size, 1, stat);\n \t  ++(*i);\n \t  return;\n \tcase CAF_REF_STATIC_ARRAY:\n-\t  dst_type = ref->u.a.static_array_type;\n \t  /* Intentionally fall through.  */\n \tcase CAF_REF_ARRAY:\n \t  if (ref->u.a.mode[dst_dim] == CAF_ARR_REF_NONE)\n@@ -2064,18 +2097,14 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t\t{\n \t\t  for (size_t d = 0; d < src_rank; ++d)\n \t\t    array_offset_src += src_index[d];\n-\t\t  copy_data (ds, sr + array_offset_src * ref->item_size,\n-\t\t\t     dst_type == -1 ? GFC_DESCRIPTOR_TYPE (dst)\n-\t\t\t\t\t    : dst_type,\n-\t\t\t     GFC_DESCRIPTOR_TYPE (src), dst_kind, src_kind,\n-\t\t\t     ref->item_size, src_size, num, stat);\n+\t\t  copy_data (ds, sr + array_offset_src * src_size,\n+\t\t\t     dst_type, GFC_DESCRIPTOR_TYPE (src), dst_kind,\n+\t\t\t     src_kind, ref->item_size, src_size, num, stat);\n \t\t}\n \t      else\n-\t\tcopy_data (ds, sr,\n-\t\t\t   dst_type == -1 ? GFC_DESCRIPTOR_TYPE (dst)\n-\t\t\t\t\t  : dst_type,\n-\t\t\t   GFC_DESCRIPTOR_TYPE (src), dst_kind, src_kind,\n-\t\t\t   ref->item_size, src_size, num, stat);\n+\t\tcopy_data (ds, sr, dst_type, GFC_DESCRIPTOR_TYPE (src),\n+\t\t\t   dst_kind, src_kind, ref->item_size, src_size, num,\n+\t\t\t   stat);\n \t      *i += num;\n \t      return;\n \t    }\n@@ -2123,22 +2152,30 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t\treturn;\n \t    }\n \t  single_token = *(caf_single_token_t*)(ds + ref->u.c.caf_token_offset);\n+\t  /* When a component is allocatable (caf_token_offset != 0) and not an\n+\t     array (ref->next->type == CAF_REF_COMPONENT), then ds has to be\n+\t     dereffed.  */\n+\t  if (ref->next && ref->next->type == CAF_REF_COMPONENT)\n+\t    ds = *(void **)(ds + ref->u.c.offset);\n+\t  else\n+\t    ds += ref->u.c.offset;\n+\n \t  send_by_ref (ref->next, i, src_index, single_token,\n-\t\t       single_token->desc, src, ds + ref->u.c.offset, sr,\n-\t\t       dst_kind, src_kind, 0, src_dim, 1, size, stat);\n+\t\t       single_token->desc, src, ds, sr,\n+\t\t       dst_kind, src_kind, 0, src_dim, 1, size, stat, dst_type);\n \t}\n       else\n \tsend_by_ref (ref->next, i, src_index, single_token,\n \t\t     (gfc_descriptor_t *)(ds + ref->u.c.offset), src,\n \t\t     ds + ref->u.c.offset, sr, dst_kind, src_kind, 0, src_dim,\n-\t\t     1, size, stat);\n+\t\t     1, size, stat, dst_type);\n       return;\n     case CAF_REF_ARRAY:\n       if (ref->u.a.mode[dst_dim] == CAF_ARR_REF_NONE)\n \t{\n \t  send_by_ref (ref->next, i, src_index, single_token,\n \t\t       (gfc_descriptor_t *)ds, src, ds, sr, dst_kind, src_kind,\n-\t\t       0, src_dim, 1, size, stat);\n+\t\t       0, src_dim, 1, size, stat, dst_type);\n \t  return;\n \t}\n       /* Only when on the left most index switch the data pointer to\n@@ -2180,7 +2217,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, dst, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      if (src_rank > 0)\n \t\tsrc_index[src_dim]\n \t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n@@ -2201,7 +2238,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, dst, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      if (src_rank > 0)\n \t\tsrc_index[src_dim]\n \t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n@@ -2222,7 +2259,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, dst, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      if (src_rank > 0)\n \t\tsrc_index[src_dim]\n \t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n@@ -2236,7 +2273,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t  send_by_ref (ref, i, src_index, single_token, dst, src, ds\n \t\t       + array_offset_dst * ref->item_size, sr,\n \t\t       dst_kind, src_kind, dst_dim + 1, src_dim, 1,\n-\t\t       size, stat);\n+\t\t       size, stat, dst_type);\n \t  return;\n \tcase CAF_ARR_REF_OPEN_END:\n \t  COMPUTE_NUM_ITEMS (extent_dst,\n@@ -2253,7 +2290,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, dst, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      if (src_rank > 0)\n \t\tsrc_index[src_dim]\n \t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n@@ -2274,7 +2311,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, dst, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      if (src_rank > 0)\n \t\tsrc_index[src_dim]\n \t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n@@ -2290,7 +2327,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t{\n \t  send_by_ref (ref->next, i, src_index, single_token, NULL,\n \t\t       src, ds, sr, dst_kind, src_kind,\n-\t\t       0, src_dim, 1, size, stat);\n+\t\t       0, src_dim, 1, size, stat, dst_type);\n \t  return;\n \t}\n       switch (ref->u.a.mode[dst_dim])\n@@ -2325,7 +2362,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, NULL, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      src_index[src_dim]\n \t\t  += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n \t    }\n@@ -2339,7 +2376,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, NULL, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      if (src_rank > 0)\n \t\tsrc_index[src_dim]\n \t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n@@ -2357,7 +2394,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      send_by_ref (ref, i, src_index, single_token, NULL, src,\n \t\t\t   ds + array_offset_dst * ref->item_size, sr,\n \t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n-\t\t\t   1, size, stat);\n+\t\t\t   1, size, stat, dst_type);\n \t      if (src_rank > 0)\n \t\tsrc_index[src_dim]\n \t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n@@ -2369,7 +2406,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t  send_by_ref (ref, i, src_index, single_token, NULL, src,\n \t\t       ds + array_offset_dst * ref->item_size, sr,\n \t\t       dst_kind, src_kind, dst_dim + 1, src_dim, 1,\n-\t\t       size, stat);\n+\t\t       size, stat, dst_type);\n \t  return;\n \t/* The OPEN_* are mapped to a RANGE and therefore can not occur.  */\n \tcase CAF_ARR_REF_OPEN_END:\n@@ -2390,7 +2427,7 @@ _gfortran_caf_send_by_ref (caf_token_t token,\n \t\t\t   gfc_descriptor_t *src, caf_reference_t *refs,\n \t\t\t   int dst_kind, int src_kind,\n \t\t\t   bool may_require_tmp __attribute__ ((unused)),\n-\t\t\t   bool dst_reallocatable, int *stat)\n+\t\t\t   bool dst_reallocatable, int *stat, int dst_type)\n {\n   const char vecrefunknownkind[] = \"libcaf_single::caf_get_by_ref(): \"\n \t\t\t\t   \"unknown kind in vector-ref.\\n\";\n@@ -2748,7 +2785,7 @@ _gfortran_caf_send_by_ref (caf_token_t token,\n   i = 0;\n   send_by_ref (refs, &i, dst_index, single_token, dst, src,\n \t       memptr, GFC_DESCRIPTOR_DATA (src), dst_kind, src_kind, 0, 0,\n-\t       1, size, stat);\n+\t       1, size, stat, dst_type);\n   assert (i == size);\n }\n \n@@ -2759,20 +2796,23 @@ _gfortran_caf_sendget_by_ref (caf_token_t dst_token, int dst_image_index,\n \t\t\t      int src_image_index,\n \t\t\t      caf_reference_t *src_refs, int dst_kind,\n \t\t\t      int src_kind, bool may_require_tmp, int *dst_stat,\n-\t\t\t      int *src_stat)\n+\t\t\t      int *src_stat, int dst_type, int src_type)\n {\n-  gfc_array_void temp;\n+  GFC_FULL_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, void) temp;\n+  GFC_DESCRIPTOR_DATA (&temp) = NULL;\n+  GFC_DESCRIPTOR_RANK (&temp) = -1;\n+  GFC_DESCRIPTOR_TYPE (&temp) = dst_type;\n \n   _gfortran_caf_get_by_ref (src_token, src_image_index, &temp, src_refs,\n \t\t\t    dst_kind, src_kind, may_require_tmp, true,\n-\t\t\t    src_stat);\n+\t\t\t    src_stat, src_type);\n \n   if (src_stat && *src_stat != 0)\n     return;\n \n   _gfortran_caf_send_by_ref (dst_token, dst_image_index, &temp, dst_refs,\n-\t\t\t     dst_kind, src_kind, may_require_tmp, true,\n-\t\t\t     dst_stat);\n+\t\t\t     dst_kind, dst_kind, may_require_tmp, true,\n+\t\t\t     dst_stat, dst_type);\n   if (GFC_DESCRIPTOR_DATA (&temp))\n     free (GFC_DESCRIPTOR_DATA (&temp));\n }"}]}