{"sha": "110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwZDA4MjBiZmNiNDIxYjhjNjgwNDA5Y2Y1YzY1YWEyYTBiNGI4ZQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2020-01-28T20:06:41Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-04T09:11:15Z"}, "message": "[Ada] Put_Image attribute\n\n2020-06-04  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-stobbu.adb, libgnat/a-stobbu.ads,\n\tlibgnat/a-stobfi.adb, libgnat/a-stobfi.ads,\n\tlibgnat/a-stoubu.adb, libgnat/a-stoubu.ads,\n\tlibgnat/a-stoufi.adb, libgnat/a-stoufi.ads,\n\tlibgnat/a-stoufo.adb, libgnat/a-stoufo.ads,\n\tlibgnat/a-stouut.adb, libgnat/a-stouut.ads,\n\tlibgnat/a-stteou.ads, libgnat/s-putaim.adb,\n\tlibgnat/s-putaim.ads, libgnat/s-putima.adb, libgnat/s-putima.ads\n\t(Ada.Strings.Text_Output and children, System.Put_Images): New\n\truntime support for Put_Image.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Add\n\texp_put_image.o.\n\t* exp_put_image.adb, exp_put_image.ads: New compiler package\n\tthat generates calls to runtime routines that implement\n\tPut_Image.\n\t* Makefile.rtl: Add object files for Ada.Strings.Text_Output and\n\tchildren and System.Put_Images.\n\t* aspects.adb: Simplify initialization of Canonical_Aspect.\n\t* aspects.ads: Improve documentation. Add Aspect_Put_Image.\n\t* exp_attr.adb: Add support for Put_Image, by calling routines\n\tin Exp_Put_Image.\n\t* sem_util.adb (Is_Predefined_Dispatching_Operation): Return\n\tTrue for new TSS_Put_Image operation.\n\t* exp_ch3.adb: For tagged types, build a dispatching\n\tTSS_Put_Image operation by calling routines in Exp_Put_Image.\n\t* exp_disp.adb, exp_disp.ads: Make TSS_Put_Image be number 10,\n\tadjusting other operations' numbers after 10. We choose 10\n\tbecause that's the last number shared by all runtimes.\n\t* exp_strm.adb: Use named notation as appropriate.\n\t* exp_cg.adb, exp_tss.ads: Add TSS_Put_Image.\n\t* libgnat/a-tags.ads: Modify Max_Predef_Prims for the new\n\tTSS_Put_Image.\n\t* impunit.adb: Add new runtime packages.\n\t* rtsfind.adb, rtsfind.ads: Add support for\n\tAda.Strings.Text_Output, Ada.Strings.Text_Output.Utils, and\n\tSystem.Put_Images.\n\t* sem_attr.adb: Error checking for Put_Image calls.\n\t* sem_ch12.adb (Valid_Default_Attribute): Support for passing\n\tPut_Image as a generic formal parameter.\n\t* sem_ch13.adb: Analysis of Put_Image aspect. Turn it into a\n\tPut_Image attribute definition clause.\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Support for\n\trenaming of the Put_Image attribute.\n\t* snames.adb-tmpl: Fix comments.\n\t* snames.ads-tmpl (Name_Put_Image): New Name_Id.\n\t(Attribute_Put_Image): New Attribute_Id.\n\t* tbuild.adb, tbuild.ads (Make_Increment): New utility.", "tree": {"sha": "b7f7f5be5a1a3d29e95cf08be19feded42995b7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7f7f5be5a1a3d29e95cf08be19feded42995b7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3fbeceef46546fd47ed370474feed347c86713f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fbeceef46546fd47ed370474feed347c86713f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3fbeceef46546fd47ed370474feed347c86713f"}], "stats": {"total": 3836, "additions": 3612, "deletions": 224}, "files": [{"sha": "e1b30b95a9266af92e50d0e8272cba5d86738ce0", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -52,6 +52,7 @@ GNATRTL_TASKING_OBJS= \\\n   s-mudido$(objext) \\\n   s-osinte$(objext) \\\n   s-proinf$(objext) \\\n+  s-putaim$(objext) \\\n   s-solita$(objext) \\\n   s-stusta$(objext) \\\n   s-taenca$(objext) \\\n@@ -79,7 +80,7 @@ GNATRTL_TASKING_OBJS= \\\n   thread$(objext) \\\n   $(EXTRA_GNATRTL_TASKING_OBJS)\n \n-# Objects the require IEEE Float\n+# Objects that require IEEE Float\n GNATRTL_ALTIVEC_OBJS= \\\n   g-allein$(objext) \\\n   g-alleve$(objext) \\\n@@ -263,7 +264,13 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-stboha$(objext) \\\n   a-stfiha$(objext) \\\n   a-stmaco$(objext) \\\n+  a-stobbu$(objext) \\\n+  a-stobfi$(objext) \\\n   a-storio$(objext) \\\n+  a-stoubu$(objext) \\\n+  a-stoufi$(objext) \\\n+  a-stoufo$(objext) \\\n+  a-stouut$(objext) \\\n   a-strbou$(objext) \\\n   a-stream$(objext) \\\n   a-strfix$(objext) \\\n@@ -274,6 +281,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-strsup$(objext) \\\n   a-strunb$(objext) \\\n   a-ststio$(objext) \\\n+  a-stteou$(objext) \\\n   a-stunau$(objext) \\\n   a-stunha$(objext) \\\n   a-stuten$(objext) \\\n@@ -421,7 +429,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-excact$(objext) \\\n   g-except$(objext) \\\n   g-exctra$(objext) \\\n-  s-exctra$(objext) \\\n   g-expect$(objext) \\\n   g-exptty$(objext) \\\n   g-flocon$(objext) \\\n@@ -476,7 +483,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-timsta$(objext) \\\n   g-traceb$(objext) \\\n   g-trasym$(objext) \\\n-  s-trasym$(objext) \\\n   g-tty$(objext) \\\n   g-u3spch$(objext) \\\n   g-utf_32$(objext) \\\n@@ -539,7 +545,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-dfmkio$(objext) \\\n   s-dfmopr$(objext) \\\n   s-dgmgop$(objext) \\\n-  s-dlmopr$(objext) \\\n   s-diflio$(objext) \\\n   s-diflmk$(objext) \\\n   s-digemk$(objext) \\\n@@ -550,12 +555,14 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-dimmks$(objext) \\\n   s-direio$(objext) \\\n   s-dlmkio$(objext) \\\n+  s-dlmopr$(objext) \\\n   s-dmotpr$(objext) \\\n   s-dsaser$(objext) \\\n   s-elaall$(objext) \\\n   s-excdeb$(objext) \\\n   s-except$(objext) \\\n   s-exctab$(objext) \\\n+  s-exctra$(objext) \\\n   s-exnint$(objext) \\\n   s-exnllf$(objext) \\\n   s-exnlli$(objext) \\\n@@ -672,6 +679,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-poosiz$(objext) \\\n   s-powtab$(objext) \\\n   s-purexc$(objext) \\\n+  s-putima$(objext) \\\n   s-rannum$(objext) \\\n   s-ransee$(objext) \\\n   s-regexp$(objext) \\\n@@ -700,6 +708,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-tasloc$(objext) \\\n   s-traceb$(objext) \\\n   s-traent$(objext) \\\n+  s-trasym$(objext) \\\n   s-unstyp$(objext) \\\n   s-utf_32$(objext) \\\n   s-valboo$(objext) \\"}, {"sha": "c55f4ed6b16a8c3ad927c86cd6348a4a004bdc21", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 30, "deletions": 130, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -500,136 +500,36 @@ package body Aspects is\n \n    --  Table used for Same_Aspect, maps aspect to canonical aspect\n \n-   Canonical_Aspect : constant array (Aspect_Id) of Aspect_Id :=\n-   (No_Aspect                           => No_Aspect,\n-    Aspect_Abstract_State               => Aspect_Abstract_State,\n-    Aspect_Address                      => Aspect_Address,\n-    Aspect_Alignment                    => Aspect_Alignment,\n-    Aspect_All_Calls_Remote             => Aspect_All_Calls_Remote,\n-    Aspect_Annotate                     => Aspect_Annotate,\n-    Aspect_Async_Readers                => Aspect_Async_Readers,\n-    Aspect_Async_Writers                => Aspect_Async_Writers,\n-    Aspect_Asynchronous                 => Aspect_Asynchronous,\n-    Aspect_Atomic                       => Aspect_Atomic,\n-    Aspect_Atomic_Components            => Aspect_Atomic_Components,\n-    Aspect_Attach_Handler               => Aspect_Attach_Handler,\n-    Aspect_Bit_Order                    => Aspect_Bit_Order,\n-    Aspect_Component_Size               => Aspect_Component_Size,\n-    Aspect_Constant_After_Elaboration   => Aspect_Constant_After_Elaboration,\n-    Aspect_Constant_Indexing            => Aspect_Constant_Indexing,\n-    Aspect_Contract_Cases               => Aspect_Contract_Cases,\n-    Aspect_Convention                   => Aspect_Convention,\n-    Aspect_CPU                          => Aspect_CPU,\n-    Aspect_Default_Component_Value      => Aspect_Default_Component_Value,\n-    Aspect_Default_Initial_Condition    => Aspect_Default_Initial_Condition,\n-    Aspect_Default_Iterator             => Aspect_Default_Iterator,\n-    Aspect_Default_Storage_Pool         => Aspect_Default_Storage_Pool,\n-    Aspect_Default_Value                => Aspect_Default_Value,\n-    Aspect_Depends                      => Aspect_Depends,\n-    Aspect_Dimension                    => Aspect_Dimension,\n-    Aspect_Dimension_System             => Aspect_Dimension_System,\n-    Aspect_Disable_Controlled           => Aspect_Disable_Controlled,\n-    Aspect_Discard_Names                => Aspect_Discard_Names,\n-    Aspect_Dispatching_Domain           => Aspect_Dispatching_Domain,\n-    Aspect_Dynamic_Predicate            => Aspect_Predicate,\n-    Aspect_Effective_Reads              => Aspect_Effective_Reads,\n-    Aspect_Effective_Writes             => Aspect_Effective_Writes,\n-    Aspect_Elaborate_Body               => Aspect_Elaborate_Body,\n-    Aspect_Export                       => Aspect_Export,\n-    Aspect_Extensions_Visible           => Aspect_Extensions_Visible,\n-    Aspect_External_Name                => Aspect_External_Name,\n-    Aspect_External_Tag                 => Aspect_External_Tag,\n-    Aspect_Favor_Top_Level              => Aspect_Favor_Top_Level,\n-    Aspect_Ghost                        => Aspect_Ghost,\n-    Aspect_Global                       => Aspect_Global,\n-    Aspect_Implicit_Dereference         => Aspect_Implicit_Dereference,\n-    Aspect_Import                       => Aspect_Import,\n-    Aspect_Independent                  => Aspect_Independent,\n-    Aspect_Independent_Components       => Aspect_Independent_Components,\n-    Aspect_Inline                       => Aspect_Inline,\n-    Aspect_Inline_Always                => Aspect_Inline,\n-    Aspect_Initial_Condition            => Aspect_Initial_Condition,\n-    Aspect_Initializes                  => Aspect_Initializes,\n-    Aspect_Input                        => Aspect_Input,\n-    Aspect_Interrupt_Handler            => Aspect_Interrupt_Handler,\n-    Aspect_Interrupt_Priority           => Aspect_Priority,\n-    Aspect_Invariant                    => Aspect_Invariant,\n-    Aspect_Iterable                     => Aspect_Iterable,\n-    Aspect_Iterator_Element             => Aspect_Iterator_Element,\n-    Aspect_Link_Name                    => Aspect_Link_Name,\n-    Aspect_Linker_Section               => Aspect_Linker_Section,\n-    Aspect_Lock_Free                    => Aspect_Lock_Free,\n-    Aspect_Machine_Radix                => Aspect_Machine_Radix,\n-    Aspect_Max_Entry_Queue_Depth        => Aspect_Max_Entry_Queue_Depth,\n-    Aspect_Max_Entry_Queue_Length       => Aspect_Max_Entry_Queue_Length,\n-    Aspect_Max_Queue_Length             => Aspect_Max_Queue_Length,\n-    Aspect_No_Caching                   => Aspect_No_Caching,\n-    Aspect_No_Elaboration_Code_All      => Aspect_No_Elaboration_Code_All,\n-    Aspect_No_Inline                    => Aspect_No_Inline,\n-    Aspect_No_Return                    => Aspect_No_Return,\n-    Aspect_No_Tagged_Streams            => Aspect_No_Tagged_Streams,\n-    Aspect_Obsolescent                  => Aspect_Obsolescent,\n-    Aspect_Object_Size                  => Aspect_Object_Size,\n-    Aspect_Output                       => Aspect_Output,\n-    Aspect_Pack                         => Aspect_Pack,\n-    Aspect_Part_Of                      => Aspect_Part_Of,\n-    Aspect_Persistent_BSS               => Aspect_Persistent_BSS,\n-    Aspect_Post                         => Aspect_Post,\n-    Aspect_Postcondition                => Aspect_Post,\n-    Aspect_Pre                          => Aspect_Pre,\n-    Aspect_Precondition                 => Aspect_Pre,\n-    Aspect_Predicate                    => Aspect_Predicate,\n-    Aspect_Predicate_Failure            => Aspect_Predicate_Failure,\n-    Aspect_Preelaborate                 => Aspect_Preelaborate,\n-    Aspect_Preelaborable_Initialization => Aspect_Preelaborable_Initialization,\n-    Aspect_Priority                     => Aspect_Priority,\n-    Aspect_Pure                         => Aspect_Pure,\n-    Aspect_Pure_Function                => Aspect_Pure_Function,\n-    Aspect_Refined_Depends              => Aspect_Refined_Depends,\n-    Aspect_Refined_Global               => Aspect_Refined_Global,\n-    Aspect_Refined_Post                 => Aspect_Refined_Post,\n-    Aspect_Refined_State                => Aspect_Refined_State,\n-    Aspect_Remote_Access_Type           => Aspect_Remote_Access_Type,\n-    Aspect_Remote_Call_Interface        => Aspect_Remote_Call_Interface,\n-    Aspect_Remote_Types                 => Aspect_Remote_Types,\n-    Aspect_Read                         => Aspect_Read,\n-    Aspect_Relative_Deadline            => Aspect_Relative_Deadline,\n-    Aspect_Scalar_Storage_Order         => Aspect_Scalar_Storage_Order,\n-    Aspect_Secondary_Stack_Size         => Aspect_Secondary_Stack_Size,\n-    Aspect_Shared                       => Aspect_Atomic,\n-    Aspect_Shared_Passive               => Aspect_Shared_Passive,\n-    Aspect_Simple_Storage_Pool          => Aspect_Simple_Storage_Pool,\n-    Aspect_Simple_Storage_Pool_Type     => Aspect_Simple_Storage_Pool_Type,\n-    Aspect_Size                         => Aspect_Size,\n-    Aspect_Small                        => Aspect_Small,\n-    Aspect_SPARK_Mode                   => Aspect_SPARK_Mode,\n-    Aspect_Static_Predicate             => Aspect_Predicate,\n-    Aspect_Storage_Pool                 => Aspect_Storage_Pool,\n-    Aspect_Storage_Size                 => Aspect_Storage_Size,\n-    Aspect_Stream_Size                  => Aspect_Stream_Size,\n-    Aspect_Suppress                     => Aspect_Suppress,\n-    Aspect_Suppress_Debug_Info          => Aspect_Suppress_Debug_Info,\n-    Aspect_Suppress_Initialization      => Aspect_Suppress_Initialization,\n-    Aspect_Synchronization              => Aspect_Synchronization,\n-    Aspect_Test_Case                    => Aspect_Test_Case,\n-    Aspect_Thread_Local_Storage         => Aspect_Thread_Local_Storage,\n-    Aspect_Type_Invariant               => Aspect_Invariant,\n-    Aspect_Unchecked_Union              => Aspect_Unchecked_Union,\n-    Aspect_Unimplemented                => Aspect_Unimplemented,\n-    Aspect_Universal_Aliasing           => Aspect_Universal_Aliasing,\n-    Aspect_Universal_Data               => Aspect_Universal_Data,\n-    Aspect_Unmodified                   => Aspect_Unmodified,\n-    Aspect_Unreferenced                 => Aspect_Unreferenced,\n-    Aspect_Unreferenced_Objects         => Aspect_Unreferenced_Objects,\n-    Aspect_Unsuppress                   => Aspect_Unsuppress,\n-    Aspect_Variable_Indexing            => Aspect_Variable_Indexing,\n-    Aspect_Value_Size                   => Aspect_Value_Size,\n-    Aspect_Volatile                     => Aspect_Volatile,\n-    Aspect_Volatile_Components          => Aspect_Volatile_Components,\n-    Aspect_Volatile_Full_Access         => Aspect_Volatile_Full_Access,\n-    Aspect_Volatile_Function            => Aspect_Volatile_Function,\n-    Aspect_Warnings                     => Aspect_Warnings,\n-    Aspect_Write                        => Aspect_Write);\n+   type Aspect_To_Aspect_Mapping is array (Aspect_Id) of Aspect_Id;\n+\n+   function Init_Canonical_Aspect return Aspect_To_Aspect_Mapping;\n+   --  Initialize the Canonical_Aspect mapping below\n+\n+   function Init_Canonical_Aspect return Aspect_To_Aspect_Mapping is\n+      Result : Aspect_To_Aspect_Mapping;\n+   begin\n+      --  They all map to themselves...\n+\n+      for Aspect in Aspect_Id loop\n+         Result (Aspect) := Aspect;\n+      end loop;\n+\n+      --  ...except for these:\n+\n+      Result (Aspect_Dynamic_Predicate)  := Aspect_Predicate;\n+      Result (Aspect_Inline_Always)      := Aspect_Inline;\n+      Result (Aspect_Interrupt_Priority) := Aspect_Priority;\n+      Result (Aspect_Postcondition)      := Aspect_Post;\n+      Result (Aspect_Precondition)       := Aspect_Pre;\n+      Result (Aspect_Shared)             := Aspect_Atomic;\n+      Result (Aspect_Static_Predicate)   := Aspect_Predicate;\n+      Result (Aspect_Type_Invariant)     := Aspect_Invariant;\n+\n+      return Result;\n+   end Init_Canonical_Aspect;\n+\n+   Canonical_Aspect : constant Aspect_To_Aspect_Mapping :=\n+     Init_Canonical_Aspect;\n \n    function Same_Aspect (A1 : Aspect_Id; A2 : Aspect_Id) return Boolean is\n    begin"}, {"sha": "73d12f30422b16b87577a8742c917daf3ff31e4e", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -38,11 +38,11 @@\n -- Adding New Aspects --\n ------------------------\n \n---  In general, each aspect should have a corresponding pragma, so that the\n---  newly developed functionality is available for Ada versions < Ada 2012.\n+--  In general, each aspect should have a corresponding pragma or attribute, so\n+--  that the newly developed functionality is available for old Ada versions.\n --  When both are defined, it is convenient to first transform the aspect into\n---  an equivalent pragma in Sem_Ch13.Analyze_Aspect_Specifications, and then\n---  analyze the pragma in Sem_Prag.Analyze_Pragma.\n+--  an equivalent pragma or attribute in Sem_Ch13.Analyze_Aspect_Specifications\n+--  and then analyze that.\n \n --  To add a new aspect, you need to do the following\n \n@@ -57,7 +57,7 @@\n --       treatments later.\n \n --    5. If the semantic analysis of expressions/names in the aspect should not\n---       occur at the point the aspect is defined, add code in the adequate\n+--       occur at the point the aspect is defined, add code in the appropriate\n --       semantic analysis procedure for the aspect. For example, this is the\n --       case for aspects Pre and Post on subprograms, which are preanalyzed\n --       at the end of the declaration list to which the subprogram belongs,\n@@ -131,6 +131,7 @@ package Aspects is\n       Aspect_Predicate,                     -- GNAT\n       Aspect_Predicate_Failure,\n       Aspect_Priority,\n+      Aspect_Put_Image,\n       Aspect_Read,\n       Aspect_Refined_Depends,               -- GNAT\n       Aspect_Refined_Global,                -- GNAT\n@@ -392,6 +393,7 @@ package Aspects is\n       Aspect_Predicate                  => Expression,\n       Aspect_Predicate_Failure          => Expression,\n       Aspect_Priority                   => Expression,\n+      Aspect_Put_Image                  => Name,\n       Aspect_Read                       => Name,\n       Aspect_Refined_Depends            => Expression,\n       Aspect_Refined_Global             => Expression,\n@@ -514,6 +516,7 @@ package Aspects is\n       Aspect_Priority                     => Name_Priority,\n       Aspect_Pure                         => Name_Pure,\n       Aspect_Pure_Function                => Name_Pure_Function,\n+      Aspect_Put_Image                    => Name_Put_Image,\n       Aspect_Read                         => Name_Read,\n       Aspect_Refined_Depends              => Name_Refined_Depends,\n       Aspect_Refined_Global               => Name_Refined_Global,\n@@ -719,6 +722,7 @@ package Aspects is\n       Aspect_Priority                     => Always_Delay,\n       Aspect_Pure                         => Always_Delay,\n       Aspect_Pure_Function                => Always_Delay,\n+      Aspect_Put_Image                    => Always_Delay,\n       Aspect_Read                         => Always_Delay,\n       Aspect_Relative_Deadline            => Always_Delay,\n       Aspect_Remote_Access_Type           => Always_Delay,"}, {"sha": "9d6979612485095843326e2945fa15a156e15d24", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 140, "deletions": 17, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -37,6 +37,7 @@ with Exp_Dist; use Exp_Dist;\n with Exp_Imgv; use Exp_Imgv;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Strm; use Exp_Strm;\n+with Exp_Put_Image;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Expander; use Expander;\n@@ -1737,22 +1738,19 @@ package body Exp_Attr is\n \n    procedure Expand_N_Attribute_Reference (N : Node_Id) is\n       Loc   : constant Source_Ptr   := Sloc (N);\n-      Typ   : constant Entity_Id    := Etype (N);\n-      Btyp  : constant Entity_Id    := Base_Type (Typ);\n       Pref  : constant Node_Id      := Prefix (N);\n-      Ptyp  : constant Entity_Id    := Etype (Pref);\n       Exprs : constant List_Id      := Expressions (N);\n-      Id    : constant Attribute_Id := Get_Attribute_Id (Attribute_Name (N));\n \n-      procedure Rewrite_Stream_Proc_Call (Pname : Entity_Id);\n-      --  Rewrites a stream attribute for Read, Write or Output with the\n-      --  procedure call. Pname is the entity for the procedure to call.\n+      procedure Rewrite_Attribute_Proc_Call (Pname : Entity_Id);\n+      --  Rewrites an attribute for Read, Write, Output, or Put_Image with a\n+      --  call to the appropriate TSS procedure. Pname is the entity for the\n+      --  procedure to call.\n \n-      ------------------------------\n-      -- Rewrite_Stream_Proc_Call --\n-      ------------------------------\n+      ---------------------------------\n+      -- Rewrite_Attribute_Proc_Call --\n+      ---------------------------------\n \n-      procedure Rewrite_Stream_Proc_Call (Pname : Entity_Id) is\n+      procedure Rewrite_Attribute_Proc_Call (Pname : Entity_Id) is\n          Item       : constant Node_Id   := Next (First (Exprs));\n          Item_Typ   : constant Entity_Id := Etype (Item);\n          Formal     : constant Entity_Id := Next_Formal (First_Formal (Pname));\n@@ -1847,8 +1845,8 @@ package body Exp_Attr is\n             end if;\n          end if;\n \n-         --  The stream operation to call may be a renaming created by an\n-         --  attribute definition clause, and may not be frozen yet. Ensure\n+         --  The stream operation to call might be a renaming created by an\n+         --  attribute definition clause, and might not be frozen yet. Ensure\n          --  that it has the necessary extra formals.\n \n          if not Is_Frozen (Pname) then\n@@ -1863,7 +1861,12 @@ package body Exp_Attr is\n              Parameter_Associations => Exprs));\n \n          Analyze (N);\n-      end Rewrite_Stream_Proc_Call;\n+      end Rewrite_Attribute_Proc_Call;\n+\n+      Typ   : constant Entity_Id    := Etype (N);\n+      Btyp  : constant Entity_Id    := Base_Type (Typ);\n+      Ptyp  : constant Entity_Id    := Etype (Pref);\n+      Id    : constant Attribute_Id := Get_Attribute_Id (Attribute_Name (N));\n \n    --  Start of processing for Expand_N_Attribute_Reference\n \n@@ -5110,7 +5113,7 @@ package body Exp_Attr is\n \n          --  If we fall through, Pname is the name of the procedure to call\n \n-         Rewrite_Stream_Proc_Call (Pname);\n+         Rewrite_Attribute_Proc_Call (Pname);\n       end Output;\n \n       ---------\n@@ -5435,6 +5438,126 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, Typ, Suppress => Access_Check);\n       end Priority;\n \n+      ---------------\n+      -- Put_Image --\n+      ---------------\n+\n+      when Attribute_Put_Image => Put_Image : declare\n+         use Exp_Put_Image;\n+         U_Type : constant Entity_Id := Underlying_Type (Entity (Pref));\n+         Pname  : Entity_Id;\n+         Decl   : Node_Id;\n+\n+      begin\n+         --  If no underlying type, we have an error that will be diagnosed\n+         --  elsewhere, so here we just completely ignore the expansion.\n+\n+         if No (U_Type) then\n+            return;\n+         end if;\n+\n+         --  If there is a TSS for Put_Image, just call it\n+\n+         Pname := TSS (U_Type, TSS_Put_Image);\n+         if No (Pname) then\n+            if Is_Tagged_Type (U_Type) and then Is_Derived_Type (U_Type) then\n+               Pname := Find_Optional_Prim_Op (U_Type, TSS_Put_Image);\n+               pragma Assert\n+                 (Has_Interfaces (U_Type) -- ????interfaces not yet supported\n+                    or else Enable_Put_Image (U_Type) = Present (Pname));\n+            else\n+               Pname := Find_Inherited_TSS (U_Type, TSS_Put_Image);\n+            end if;\n+         end if;\n+\n+         if No (Pname) then\n+            --  For elementary types, we call the routine in System.Put_Images\n+            --  directly.\n+\n+            if Is_Elementary_Type (U_Type) then\n+               Rewrite (N, Build_Elementary_Put_Image_Call (N));\n+               Analyze (N);\n+               return;\n+\n+            --  ???It would be nice to call Build_String_Put_Image_Call below\n+            --  if U_Type is a standard string type, but it currently generates\n+            --  something like:\n+            --\n+            --     Put_Image_String (Sink, String (X));\n+            --\n+            --  so if X is of a private type whose full type is \"new String\",\n+            --  then the type conversion is illegal. To fix that, we would need\n+            --  to do unchecked conversions of access values, taking care to\n+            --  deal with thin and fat pointers properly. For now, we just fall\n+            --  back to Build_Array_Put_Image_Procedure in these cases, so the\n+            --  following says \"Root_Type (Entity (Pref))\" instead of \"U_Type\".\n+\n+            elsif Is_Standard_String_Type (Root_Type (Entity (Pref))) then\n+               Rewrite (N, Build_String_Put_Image_Call (N));\n+               Analyze (N);\n+               return;\n+\n+            elsif Is_Array_Type (U_Type) then\n+               Build_Array_Put_Image_Procedure (N, U_Type, Decl, Pname);\n+               Insert_Action (N, Decl);\n+\n+            --  Tagged type case, use the primitive Put_Image function. Note\n+            --  that this will dispatch in the class-wide case which is what we\n+            --  want.\n+\n+            elsif Is_Tagged_Type (U_Type) then\n+               Pname := Find_Optional_Prim_Op (U_Type, TSS_Put_Image);\n+\n+               --  ????Need Find_Optional_Prim_Op instead of Find_Prim_Op,\n+               --  because we might be deriving from a predefined type, which\n+               --  currently has Enable_Put_Image False.\n+\n+               if No (Pname) then\n+                  Rewrite (N, Build_Unknown_Put_Image_Call (N));\n+                  Analyze (N);\n+                  return;\n+               end if;\n+\n+            elsif Is_Protected_Type (U_Type) then\n+               Rewrite (N, Build_Protected_Put_Image_Call (N));\n+               Analyze (N);\n+               return;\n+\n+            elsif Is_Task_Type (U_Type) then\n+               Rewrite (N, Build_Task_Put_Image_Call (N));\n+               Analyze (N);\n+               return;\n+\n+            --  All other record type cases, including protected records\n+\n+            else\n+               pragma Assert (Is_Record_Type (U_Type));\n+\n+               --  Program_Error is raised when calling the default\n+               --  implementation of the Put_Image attribute of an\n+               --  Unchecked_Union type. ???It would be friendlier to print a\n+               --  canned string. See handling of unchecked unions in\n+               --  exp_put_image.adb (which is not reachable).\n+\n+               if Is_Unchecked_Union (Base_Type (U_Type)) then\n+                  Rewrite (N,\n+                    Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Unchecked_Union_Restriction));\n+                  Set_Etype (N, Standard_Void_Type);\n+                  return;\n+               end if;\n+\n+               Build_Record_Put_Image_Procedure\n+                 (Loc, Full_Base (U_Type), Decl, Pname);\n+               Insert_Action (N, Decl);\n+            end if;\n+         end if;\n+\n+         --  If we fall through, Pname is the procedure to be called\n+\n+         Rewrite_Attribute_Proc_Call (Pname);\n+      end Put_Image;\n+\n       ------------------\n       -- Range_Length --\n       ------------------\n@@ -5765,7 +5888,7 @@ package body Exp_Attr is\n             end if;\n          end if;\n \n-         Rewrite_Stream_Proc_Call (Pname);\n+         Rewrite_Attribute_Proc_Call (Pname);\n       end Read;\n \n       ---------\n@@ -7411,7 +7534,7 @@ package body Exp_Attr is\n \n          --  If we fall through, Pname is the procedure to be called\n \n-         Rewrite_Stream_Proc_Call (Pname);\n+         Rewrite_Attribute_Proc_Call (Pname);\n       end Write;\n \n       --  Component_Size is handled by the back end, unless the component size"}, {"sha": "02a0652335ce74d5164260d3dfda0429fcbbbbc0", "filename": "gcc/ada/exp_cg.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_cg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_cg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_cg.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -81,7 +81,7 @@ package body Exp_CG is\n    --  Determines if E is a predefined primitive operation.\n    --  Note: This routine should replace the routine with the same name that is\n    --  currently available in exp_disp because it extends its functionality to\n-   --  handle fully qualified names ???\n+   --  handle fully qualified names. It's actually in Sem_Util. ???\n \n    function Slot_Number (Prim : Entity_Id) return Uint;\n    --  Returns the slot number associated with Prim. For predefined primitives\n@@ -261,6 +261,7 @@ package body Exp_CG is\n            or else TSS_Name = TSS_Stream_Write\n            or else TSS_Name = TSS_Stream_Input\n            or else TSS_Name = TSS_Stream_Output\n+           or else TSS_Name = TSS_Put_Image\n            or else TSS_Name = TSS_Deep_Adjust\n            or else TSS_Name = TSS_Deep_Finalize\n          then"}, {"sha": "8d1b2e13a727ba56d35182c1160db7d7d95d329b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -37,6 +37,7 @@ with Exp_Ch9;  use Exp_Ch9;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Disp; use Exp_Disp;\n with Exp_Dist; use Exp_Dist;\n+with Exp_Put_Image;\n with Exp_Smem; use Exp_Smem;\n with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n@@ -265,6 +266,7 @@ package body Exp_Ch3 is\n    --     typSW          provides result of 'Write attribute\n    --     typSI          provides result of 'Input attribute\n    --     typSO          provides result of 'Output attribute\n+   --     typPI          provides result of 'Put_Image attribute\n    --\n    --  The following entries are additionally present for non-limited tagged\n    --  types, and implement additional dispatching operations for predefined\n@@ -9924,6 +9926,8 @@ package body Exp_Ch3 is\n       --  Set to True if Tag_Typ has a primitive that renames the predefined\n       --  equality operator. Used to implement (RM 8-5-4(8)).\n \n+      use Exp_Put_Image;\n+\n    --  Start of processing for Make_Predefined_Primitive_Specs\n \n    begin\n@@ -9941,6 +9945,17 @@ package body Exp_Ch3 is\n \n         Ret_Type => Standard_Long_Long_Integer));\n \n+      --  Spec of Put_Image\n+\n+      if Enable_Put_Image (Tag_Typ)\n+        and then No (TSS (Tag_Typ, TSS_Put_Image))\n+      then\n+         Append_To (Res, Predef_Spec_Or_Body (Loc,\n+           Tag_Typ => Tag_Typ,\n+           Name    => Make_TSS_Name (Tag_Typ, TSS_Put_Image),\n+           Profile => Build_Put_Image_Profile (Loc, Tag_Typ)));\n+      end if;\n+\n       --  Specs for dispatching stream attributes\n \n       declare\n@@ -10450,6 +10465,8 @@ package body Exp_Ch3 is\n \n       pragma Warnings (Off, Ent);\n \n+      use Exp_Put_Image;\n+\n    begin\n       pragma Assert (not Is_Interface (Tag_Typ));\n \n@@ -10532,6 +10549,15 @@ package body Exp_Ch3 is\n \n       Append_To (Res, Decl);\n \n+      --  Body of Put_Image\n+\n+      if Enable_Put_Image (Tag_Typ)\n+        and then No (TSS (Tag_Typ, TSS_Put_Image))\n+      then\n+         Build_Record_Put_Image_Procedure (Loc, Tag_Typ, Decl, Ent);\n+         Append_To (Res, Decl);\n+      end if;\n+\n       --  Bodies for Dispatching stream IO routines. We need these only for\n       --  non-limited types (in the limited case there is no dispatching).\n       --  We also skip them if dispatching or finalization are not available"}, {"sha": "69c536f799df645859693f692e8390c7eebc6121", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -643,28 +643,31 @@ package body Exp_Disp is\n       elsif TSS_Name = TSS_Deep_Finalize then\n          return Uint_9;\n \n+      elsif TSS_Name = TSS_Put_Image then\n+         return Uint_10;\n+\n       --  In VM targets unconditionally allow obtaining the position associated\n       --  with predefined interface primitives since in these platforms any\n       --  tagged type has these primitives.\n \n       elsif Ada_Version >= Ada_2005 or else not Tagged_Type_Expansion then\n          if Chars (E) = Name_uDisp_Asynchronous_Select then\n-            return Uint_10;\n+            return Uint_11;\n \n          elsif Chars (E) = Name_uDisp_Conditional_Select then\n-            return Uint_11;\n+            return Uint_12;\n \n          elsif Chars (E) = Name_uDisp_Get_Prim_Op_Kind then\n-            return Uint_12;\n+            return Uint_13;\n \n          elsif Chars (E) = Name_uDisp_Get_Task_Id then\n-            return Uint_13;\n+            return Uint_14;\n \n          elsif Chars (E) = Name_uDisp_Requeue then\n-            return Uint_14;\n+            return Uint_15;\n \n          elsif Chars (E) = Name_uDisp_Timed_Select then\n-            return Uint_15;\n+            return Uint_16;\n          end if;\n       end if;\n \n@@ -4680,16 +4683,16 @@ package body Exp_Disp is\n       end if;\n \n       --  Ensure that the value of Max_Predef_Prims defined in a-tags is\n-      --  correct. Valid values are 9 under configurable runtime or 15\n+      --  correct. Valid values are 10 under configurable runtime or 16\n       --  with full runtime.\n \n       if RTE_Available (RE_Interface_Data) then\n-         if Max_Predef_Prims /= 15 then\n+         if Max_Predef_Prims /= 16 then\n             Error_Msg_N (\"run-time library configuration error\", Typ);\n             goto Leave;\n          end if;\n       else\n-         if Max_Predef_Prims /= 9 then\n+         if Max_Predef_Prims /= 10 then\n             Error_Msg_N (\"run-time library configuration error\", Typ);\n             Error_Msg_CRT (\"tagged types\", Typ);\n             goto Leave;"}, {"sha": "fb1de72ac69f082667c15c9d41c3671ac4d52c61", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -77,37 +77,40 @@ package Exp_Disp is\n    --      TSS_Deep_Finalize (9) - implementation of the finalization\n    --      operation Finalize for any non-limited tagged type.\n \n-   --      _Disp_Asynchronous_Select (10) - used in the expansion of ATC with\n+   --      Put_Image (10) - implementation of Put_Image attribute for any\n+   --      tagged type.\n+\n+   --      _Disp_Asynchronous_Select (11) - used in the expansion of ATC with\n    --      dispatching triggers. Null implementation for limited interfaces,\n    --      full body generation for types that implement limited interfaces,\n    --      not generated for the rest of the cases. See Expand_N_Asynchronous_\n    --      Select in Exp_Ch9 for more information.\n \n-   --      _Disp_Conditional_Select (11) - used in the expansion of conditional\n+   --      _Disp_Conditional_Select (12) - used in the expansion of conditional\n    --      selects with dispatching triggers. Null implementation for limited\n    --      interfaces, full body generation for types that implement limited\n    --      interfaces, not generated for the rest of the cases. See Expand_N_\n    --      Conditional_Entry_Call in Exp_Ch9 for more information.\n \n-   --      _Disp_Get_Prim_Op_Kind (12) - helper routine used in the expansion\n+   --      _Disp_Get_Prim_Op_Kind (13) - helper routine used in the expansion\n    --      of ATC with dispatching triggers. Null implementation for limited\n    --      interfaces, full body generation for types that implement limited\n    --      interfaces, not generated for the rest of the cases.\n \n-   --      _Disp_Get_Task_Id (13) - helper routine used in the expansion of\n+   --      _Disp_Get_Task_Id (14) - helper routine used in the expansion of\n    --      Abort, attributes 'Callable and 'Terminated for task interface\n    --      class-wide types. Full body generation for task types, null\n    --      implementation for limited interfaces, not generated for the rest\n    --      of the cases. See Expand_N_Attribute_Reference in Exp_Attr and\n    --      Expand_N_Abort_Statement in Exp_Ch9 for more information.\n \n-   --      _Disp_Requeue (14) - used in the expansion of dispatching requeue\n+   --      _Disp_Requeue (15) - used in the expansion of dispatching requeue\n    --      statements. Null implementation is provided for protected, task\n    --      and synchronized interfaces. Protected and task types implementing\n    --      concurrent interfaces receive full bodies. See Expand_N_Requeue_\n    --      Statement in Exp_Ch9 for more information.\n \n-   --      _Disp_Timed_Select (15) - used in the expansion of timed selects\n+   --      _Disp_Timed_Select (16) - used in the expansion of timed selects\n    --      with dispatching triggers. Null implementation for limited\n    --      interfaces, full body generation for types that implement limited\n    --      interfaces, not generated for the rest of the cases. See Expand_N_\n@@ -139,11 +142,13 @@ package Exp_Disp is\n    --      Update the value of constant Max_Predef_Prims in a-tags.ads to\n    --      indicate the new number of PPOs.\n \n+   --      Update Exp_Disp.Default_Prim_Op_Position.\n+\n    --      Introduce a new predefined name for the new PPO in Snames.ads and\n    --      Snames.adb.\n \n    --      Categorize the new PPO name as predefined by adding an entry in\n-   --      Is_Predefined_Dispatching_Operation in Exp_Disp.\n+   --      Is_Predefined_Dispatching_Operation in Sem_Util and Exp_Cg.\n \n    --      Generate the specification of the new PPO in Make_Predefined_\n    --      Primitive_Spec in Exp_Ch3.adb. The Is_Internal flag of the defining\n@@ -156,17 +161,9 @@ package Exp_Disp is\n    --      If the new PPO requires a thunk, add an entry in Freeze_Subprogram\n    --      in Exp_Ch6.adb.\n \n-   --      When generating calls to a PPO, use Find_Prim_Op from Exp_Util.ads\n+   --      When generating calls to a PPO, use Find_Prim_Op from exp_util.ads\n    --      to retrieve the entity of the operation directly.\n \n-   --  Number of predefined primitive operations added by the Expander\n-   --  for a tagged type. If more predefined primitive operations are\n-   --  added, the following items must be changed:\n-\n-   --    Ada.Tags.Max_Predef_Prims         - indirect use\n-   --    Exp_Disp.Default_Prim_Op_Position - indirect use\n-   --    Exp_Disp.Set_All_DT_Position      - direct   use\n-\n    procedure Apply_Tag_Checks (Call_Node : Node_Id);\n    --  Generate checks required on dispatching calls\n "}, {"sha": "af6a78370db8940d9a46dbed8f70e1042b6380fa", "filename": "gcc/ada/exp_put_image.adb", "status": "added", "additions": 891, "deletions": 0, "changes": 891, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_put_image.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_put_image.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_put_image.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,891 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        E X P _ P U T _ I M A G E                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2020, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Exp_Tss;  use Exp_Tss;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Rtsfind;  use Rtsfind;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;\n+with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n+with Uintp;    use Uintp;\n+\n+package body Exp_Put_Image is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Build_Put_Image_Proc\n+     (Loc  : Source_Ptr;\n+      Typ  : Entity_Id;\n+      Decl : out Node_Id;\n+      Pnam : Entity_Id;\n+      Stms : List_Id);\n+   --  Build an array or record Put_Image procedure. Stms is the list of\n+   --  statements for the body and Pnam is the name of the constructed\n+   --  procedure. (The declaration list is always null.)\n+\n+   function Make_Put_Image_Name\n+     (Loc : Source_Ptr; Typ : Entity_Id) return Entity_Id;\n+   --  Return the entity that identifies the Put_Image subprogram for Typ. This\n+   --  procedure deals with the difference between tagged types (where a single\n+   --  subprogram associated with the type is generated) and all other cases\n+   --  (where a subprogram is generated at the point of the attribute\n+   --  reference). The Loc parameter is used as the Sloc of the created entity.\n+\n+   function Put_Image_Base_Type (E : Entity_Id) return Entity_Id;\n+   --  Returns the base type, except for an array type whose whose first\n+   --  subtype is constrained, in which case it returns the first subtype.\n+\n+   -------------------------------------\n+   -- Build_Array_Put_Image_Procedure --\n+   -------------------------------------\n+\n+   procedure Build_Array_Put_Image_Procedure\n+     (Nod  : Node_Id;\n+      Typ  : Entity_Id;\n+      Decl : out Node_Id;\n+      Pnam : out Entity_Id)\n+   is\n+      Loc  : constant Source_Ptr := Sloc (Nod);\n+\n+      function Wrap_In_Loop\n+        (Stms : List_Id;\n+         Dim : Pos;\n+         Index_Subtype : Entity_Id;\n+         Between_Proc : RE_Id) return Node_Id;\n+      --  Wrap Stms in a loop and if statement of the form:\n+      --\n+      --     if V'First (Dim) <= V'Last (Dim) then -- nonempty range?\n+      --        declare\n+      --           LDim : Index_Type_For_Dim := V'First (Dim);\n+      --        begin\n+      --           loop\n+      --              Stms;\n+      --              exit when LDim = V'Last (Dim);\n+      --              Between_Proc (S);\n+      --              LDim := Index_Type_For_Dim'Succ (LDim);\n+      --           end loop;\n+      --        end;\n+      --     end if;\n+      --\n+      --  This is called once per dimension, from inner to outer.\n+\n+      function Wrap_In_Loop\n+        (Stms : List_Id;\n+         Dim : Pos;\n+         Index_Subtype : Entity_Id;\n+         Between_Proc : RE_Id) return Node_Id\n+      is\n+         Index : constant Entity_Id :=\n+           Make_Defining_Identifier\n+             (Loc, Chars => New_External_Name ('L', Dim));\n+         Decl : constant Node_Id :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Index,\n+             Object_Definition =>\n+               New_Occurrence_Of (Index_Subtype, Loc),\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => Make_Identifier (Loc, Name_V),\n+                 Attribute_Name => Name_First,\n+                 Expressions => New_List (\n+                   Make_Integer_Literal (Loc, Dim))));\n+         Loop_Stm : constant Node_Id :=\n+           Make_Implicit_Loop_Statement (Nod, Statements => Stms);\n+         Exit_Stm : constant Node_Id :=\n+           Make_Exit_Statement (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd => New_Occurrence_Of (Index, Loc),\n+                 Right_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         =>\n+                       Make_Identifier (Loc, Name_V),\n+                     Attribute_Name => Name_Last,\n+                     Expressions => New_List (\n+                       Make_Integer_Literal (Loc, Dim)))));\n+         Increment : constant Node_Id :=\n+           Make_Increment (Loc, Index, Index_Subtype);\n+         Between : constant Node_Id :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               New_Occurrence_Of (RTE (Between_Proc), Loc),\n+             Parameter_Associations => New_List\n+               (Make_Identifier (Loc, Name_S)));\n+         Block : constant Node_Id :=\n+           Make_Block_Statement (Loc,\n+             Declarations               => New_List (Decl),\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Loop_Stm)));\n+      begin\n+         Append_To (Stms, Exit_Stm);\n+         Append_To (Stms, Between);\n+         Append_To (Stms, Increment);\n+         --  Note that we're appending to the Stms list passed in\n+\n+         return\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Le (Loc,\n+                 Left_Opnd  =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => Make_Identifier (Loc, Name_V),\n+                     Attribute_Name => Name_First,\n+                     Expressions => New_List (\n+                       Make_Integer_Literal (Loc, Dim))),\n+                 Right_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => Make_Identifier (Loc, Name_V),\n+                     Attribute_Name => Name_Last,\n+                     Expressions => New_List (\n+                       Make_Integer_Literal (Loc, Dim)))),\n+             Then_Statements => New_List (Block));\n+      end Wrap_In_Loop;\n+\n+      Ndim : constant Pos        := Number_Dimensions (Typ);\n+      Ctyp : constant Entity_Id  := Component_Type (Typ);\n+\n+      Stm         : Node_Id;\n+      Exl         : constant List_Id := New_List;\n+      PI_Entity   : Entity_Id;\n+\n+      Indices : array (1 .. Ndim) of Entity_Id;\n+\n+   --  Start of processing for Build_Array_Put_Image_Procedure\n+\n+   begin\n+      Pnam :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => Make_TSS_Name_Local (Typ, TSS_Put_Image));\n+\n+      --  Get the Indices\n+\n+      declare\n+         Index_Subtype : Node_Id := First_Index (Typ);\n+      begin\n+         for Dim in 1 .. Ndim loop\n+            Indices (Dim) := Etype (Index_Subtype);\n+            Next_Index (Index_Subtype);\n+         end loop;\n+         pragma Assert (No (Index_Subtype));\n+      end;\n+\n+      --  Build the inner attribute call\n+\n+      for Dim in 1 .. Ndim loop\n+         Append_To (Exl, Make_Identifier (Loc, New_External_Name ('L', Dim)));\n+      end loop;\n+\n+      Stm :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix => New_Occurrence_Of (Put_Image_Base_Type (Ctyp), Loc),\n+          Attribute_Name => Name_Put_Image,\n+          Expressions => New_List (\n+            Make_Identifier (Loc, Name_S),\n+            Make_Indexed_Component (Loc,\n+              Prefix      => Make_Identifier (Loc, Name_V),\n+              Expressions => Exl)));\n+\n+      --  The corresponding attribute for the component type of the array might\n+      --  be user-defined, and frozen after the array type. In that case,\n+      --  freeze the Put_Image attribute of the component type, whose\n+      --  declaration could not generate any additional freezing actions in any\n+      --  case.\n+\n+      PI_Entity := TSS (Base_Type (Ctyp), TSS_Put_Image);\n+\n+      if Present (PI_Entity) and then not Is_Frozen (PI_Entity) then\n+         Set_Is_Frozen (PI_Entity);\n+      end if;\n+\n+      --  Loop through the dimensions, innermost first, generating a loop for\n+      --  each dimension.\n+\n+      declare\n+         Stms : List_Id := New_List (Stm);\n+      begin\n+         for Dim in reverse 1 .. Ndim loop\n+            declare\n+               New_Stms : constant List_Id := New_List;\n+               Between_Proc : RE_Id;\n+            begin\n+               --  For a one-dimensional array of elementary type, use\n+               --  RE_Simple_Array_Between. The same applies to the last\n+               --  dimension of a multidimensional array.\n+\n+               if Is_Elementary_Type (Ctyp) and then Dim = Ndim then\n+                  Between_Proc := RE_Simple_Array_Between;\n+               else\n+                  Between_Proc := RE_Array_Between;\n+               end if;\n+\n+               Append_To (New_Stms,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Occurrence_Of (RTE (RE_Array_Before), Loc),\n+                   Parameter_Associations => New_List\n+                     (Make_Identifier (Loc, Name_S))));\n+\n+               Append_To\n+                 (New_Stms,\n+                  Wrap_In_Loop (Stms, Dim, Indices (Dim), Between_Proc));\n+\n+               Append_To (New_Stms,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Occurrence_Of (RTE (RE_Array_After), Loc),\n+                   Parameter_Associations => New_List\n+                     (Make_Identifier (Loc, Name_S))));\n+\n+               Stms := New_Stms;\n+            end;\n+         end loop;\n+\n+         Build_Put_Image_Proc (Loc, Typ, Decl, Pnam, Stms);\n+      end;\n+   end Build_Array_Put_Image_Procedure;\n+\n+   -------------------------------------\n+   -- Build_Elementary_Put_Image_Call --\n+   -------------------------------------\n+\n+   function Build_Elementary_Put_Image_Call (N : Node_Id) return Node_Id is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      P_Type  : constant Entity_Id  := Entity (Prefix (N));\n+      U_Type  : constant Entity_Id  := Underlying_Type (P_Type);\n+      FST     : constant Entity_Id  := First_Subtype (U_Type);\n+      Sink    : constant Node_Id    := First (Expressions (N));\n+      Item    : constant Node_Id    := Next (Sink);\n+      P_Size  : constant Uint       := Esize (FST);\n+      Lib_RE  : RE_Id;\n+\n+   begin\n+      if Is_Signed_Integer_Type (U_Type) then\n+         if P_Size <= Standard_Integer_Size then\n+            Lib_RE := RE_Put_Image_Integer;\n+         else\n+            pragma Assert (P_Size <= Standard_Long_Long_Integer_Size);\n+            Lib_RE := RE_Put_Image_Long_Long_Integer;\n+         end if;\n+\n+      elsif Is_Modular_Integer_Type (U_Type) then\n+         if P_Size <= Standard_Integer_Size then -- Yes, Integer\n+            Lib_RE := RE_Put_Image_Unsigned;\n+         else\n+            pragma Assert (P_Size <= Standard_Long_Long_Integer_Size);\n+            Lib_RE := RE_Put_Image_Long_Long_Unsigned;\n+         end if;\n+\n+      elsif Is_Access_Type (U_Type) then\n+         if P_Size = System_Address_Size then\n+            Lib_RE := RE_Put_Image_Thin_Pointer;\n+         else\n+            pragma Assert (P_Size = 2 * System_Address_Size);\n+            Lib_RE := RE_Put_Image_Fat_Pointer;\n+         end if;\n+\n+      else\n+         pragma Assert\n+           (Is_Enumeration_Type (U_Type) or else Is_Real_Type (U_Type));\n+\n+         --  For other elementary types, generate:\n+         --\n+         --     Put_Wide_Wide_String (Sink, U_Type'Wide_Wide_Image (Item));\n+         --\n+         --  This is a bit of a cheat; we should probably do it the other way\n+         --  around (define '[[Wide_]Wide_]Image in terms of 'Put_Image). But\n+         --  this is expedient for now. We can't do this:\n+         --\n+         --     Put_UTF_8 (Sink, U_Type'Image (Item));\n+         --\n+         --  because we need to generate UTF-8, but 'Image for enumeration\n+         --  types uses the character encoding of the source file.\n+         --\n+         --  Note that this is putting a leading space for reals.\n+\n+         declare\n+            Image : constant Node_Id :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Occurrence_Of (U_Type, Loc),\n+                Attribute_Name => Name_Wide_Wide_Image,\n+                Expressions => New_List (Relocate_Node (Item)));\n+         begin\n+            return\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Occurrence_Of (RTE (RE_Put_Wide_Wide_String), Loc),\n+                Parameter_Associations => New_List\n+                  (Relocate_Node (Sink), Image));\n+         end;\n+      end if;\n+\n+      --  Unchecked-convert parameter to the required type (i.e. the type of\n+      --  the corresponding parameter), and call the appropriate routine.\n+      --  We could use a normal type conversion for scalars, but the\n+      --  \"unchecked\" is needed for access types.\n+\n+      declare\n+         Libent : constant Entity_Id := RTE (Lib_RE);\n+      begin\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (Libent, Loc),\n+             Parameter_Associations => New_List (\n+               Relocate_Node (Sink),\n+               Unchecked_Convert_To\n+                (Etype (Next_Formal (First_Formal (Libent))),\n+                 Relocate_Node (Item))));\n+      end;\n+   end Build_Elementary_Put_Image_Call;\n+\n+   -------------------------------------\n+   -- Build_String_Put_Image_Call --\n+   -------------------------------------\n+\n+   function Build_String_Put_Image_Call (N : Node_Id) return Node_Id is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      P_Type  : constant Entity_Id  := Entity (Prefix (N));\n+      U_Type  : constant Entity_Id  := Underlying_Type (P_Type);\n+      R       : constant Entity_Id  := Root_Type (U_Type);\n+      Sink    : constant Node_Id    := First (Expressions (N));\n+      Item    : constant Node_Id    := Next (Sink);\n+      Lib_RE  : RE_Id;\n+      use Stand;\n+   begin\n+      if R = Standard_String then\n+         Lib_RE := RE_Put_Image_String;\n+      elsif R = Standard_Wide_String then\n+         Lib_RE := RE_Put_Image_Wide_String;\n+      elsif R = Standard_Wide_Wide_String then\n+         Lib_RE := RE_Put_Image_Wide_Wide_String;\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      --  Convert parameter to the required type (i.e. the type of the\n+      --  corresponding parameter), and call the appropriate routine.\n+\n+      declare\n+         Libent : constant Entity_Id := RTE (Lib_RE);\n+      begin\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (Libent, Loc),\n+             Parameter_Associations => New_List (\n+               Relocate_Node (Sink),\n+               Convert_To\n+                (Etype (Next_Formal (First_Formal (Libent))),\n+                 Relocate_Node (Item))));\n+      end;\n+   end Build_String_Put_Image_Call;\n+\n+   ------------------------------------\n+   -- Build_Protected_Put_Image_Call --\n+   ------------------------------------\n+\n+   --  For \"Protected_Type'Put_Image (S, Protected_Object)\", build:\n+   --\n+   --    Put_Image_Protected (S);\n+   --\n+   --  The protected object is not passed.\n+\n+   function Build_Protected_Put_Image_Call (N : Node_Id) return Node_Id is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Sink   : constant Node_Id    := First (Expressions (N));\n+      Lib_RE : constant RE_Id      := RE_Put_Image_Protected;\n+      Libent : constant Entity_Id  := RTE (Lib_RE);\n+   begin\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (Libent, Loc),\n+          Parameter_Associations => New_List (\n+            Relocate_Node (Sink)));\n+   end Build_Protected_Put_Image_Call;\n+\n+   ------------------------------------\n+   -- Build_Task_Put_Image_Call --\n+   ------------------------------------\n+\n+   --  For \"Task_Type'Put_Image (S, Task_Object)\", build:\n+   --\n+   --    Put_Image_Task (S, Task_Object'Identity);\n+   --\n+   --  The task object is not passed; its Task_Id is.\n+\n+   function Build_Task_Put_Image_Call (N : Node_Id) return Node_Id is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Sink   : constant Node_Id    := First (Expressions (N));\n+      Item   : constant Node_Id    := Next (Sink);\n+      Lib_RE : constant RE_Id      := RE_Put_Image_Task;\n+      Libent : constant Entity_Id  := RTE (Lib_RE);\n+\n+      Task_Id : constant Node_Id :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix => Relocate_Node (Item),\n+          Attribute_Name => Name_Identity,\n+          Expressions => No_List);\n+\n+   begin\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (Libent, Loc),\n+          Parameter_Associations => New_List (\n+            Relocate_Node (Sink),\n+            Task_Id));\n+   end Build_Task_Put_Image_Call;\n+\n+   --------------------------------------\n+   -- Build_Record_Put_Image_Procedure --\n+   --------------------------------------\n+\n+   --  The form of the record Put_Image procedure is as shown by the\n+   --  following example:\n+\n+   --    procedure Put_Image (S : in out Sink'Class; V : Typ) is\n+   --    begin\n+   --       Component_Type'Put_Image (S, V.component);\n+   --       Component_Type'Put_Image (S, V.component);\n+   --       ...\n+   --       Component_Type'Put_Image (S, V.component);\n+   --\n+   --       case V.discriminant is\n+   --          when choices =>\n+   --             Component_Type'Put_Image (S, V.component);\n+   --             Component_Type'Put_Image (S, V.component);\n+   --             ...\n+   --             Component_Type'Put_Image (S, V.component);\n+   --\n+   --          when choices =>\n+   --             Component_Type'Put_Image (S, V.component);\n+   --             Component_Type'Put_Image (S, V.component);\n+   --             ...\n+   --             Component_Type'Put_Image (S, V.component);\n+   --          ...\n+   --       end case;\n+   --    end Put_Image;\n+\n+   procedure Build_Record_Put_Image_Procedure\n+     (Loc  : Source_Ptr;\n+      Typ  : Entity_Id;\n+      Decl : out Node_Id;\n+      Pnam : out Entity_Id)\n+   is\n+      pragma Assert (Typ = Base_Type (Typ));\n+      pragma Assert (not Is_Unchecked_Union (Typ));\n+\n+      First_Time : Boolean := True;\n+\n+      function Make_Component_List_Attributes (CL : Node_Id) return List_Id;\n+      --  Returns a sequence of Component_Type'Put_Image attribute_references\n+      --  to process the components that are referenced in the given component\n+      --  list. Called for the main component list, and then recursively for\n+      --  variants.\n+\n+      function Make_Component_Attributes (Clist : List_Id) return List_Id;\n+      --  Given Clist, a component items list, construct series of\n+      --  Component_Type'Put_Image attribute_references for componentwise\n+      --  processing of the corresponding components. Called for the\n+      --  discriminants, and then from Make_Component_List_Attributes for each\n+      --  list (including in variants).\n+\n+      procedure Append_Component_Attr (Clist : List_Id; C : Entity_Id);\n+      --  Given C, the entity for a discriminant or component, build a call to\n+      --  Component_Type'Put_Image for the corresponding component value, and\n+      --  append it onto Clist. Called from Make_Component_Attributes.\n+\n+      function Make_Component_Name (C : Entity_Id) return Node_Id;\n+      --  Create a call that prints \"Comp_Name => \"\n+\n+      ------------------------------------\n+      -- Make_Component_List_Attributes --\n+      ------------------------------------\n+\n+      function Make_Component_List_Attributes (CL : Node_Id) return List_Id is\n+         CI : constant List_Id := Component_Items (CL);\n+         VP : constant Node_Id := Variant_Part (CL);\n+\n+         Result : List_Id;\n+         Alts   : List_Id;\n+         V      : Node_Id;\n+         DC     : Node_Id;\n+         DCH    : List_Id;\n+         D_Ref  : Node_Id;\n+\n+      begin\n+         Result := Make_Component_Attributes (CI);\n+\n+         if Present (VP) then\n+            Alts := New_List;\n+\n+            V := First_Non_Pragma (Variants (VP));\n+            while Present (V) loop\n+               DCH := New_List;\n+\n+               DC := First (Discrete_Choices (V));\n+               while Present (DC) loop\n+                  Append_To (DCH, New_Copy_Tree (DC));\n+                  Next (DC);\n+               end loop;\n+\n+               Append_To (Alts,\n+                 Make_Case_Statement_Alternative (Loc,\n+                   Discrete_Choices => DCH,\n+                   Statements =>\n+                     Make_Component_List_Attributes (Component_List (V))));\n+               Next_Non_Pragma (V);\n+            end loop;\n+\n+            --  Note: in the following, we use New_Occurrence_Of for the\n+            --  selector, since there are cases in which we make a reference\n+            --  to a hidden discriminant that is not visible.\n+\n+            --  If the enclosing record is an unchecked_union, we use the\n+            --  default expressions for the discriminant (it must exist)\n+            --  because we cannot generate a reference to it, given that it is\n+            --  not stored. ????This seems unfriendly. It should just print\n+            --  \"(unchecked union)\" instead. (Note that this code is\n+            --  unreachable -- see exp_attr.)\n+\n+            if Is_Unchecked_Union (Scope (Entity (Name (VP)))) then\n+               D_Ref :=\n+                 New_Copy_Tree\n+                   (Discriminant_Default_Value (Entity (Name (VP))));\n+            else\n+               D_Ref :=\n+                  Make_Selected_Component (Loc,\n+                    Prefix        => Make_Identifier (Loc, Name_V),\n+                    Selector_Name =>\n+                      New_Occurrence_Of (Entity (Name (VP)), Loc));\n+            end if;\n+\n+            Append_To (Result,\n+              Make_Case_Statement (Loc,\n+                Expression   => D_Ref,\n+                Alternatives => Alts));\n+         end if;\n+\n+         return Result;\n+      end Make_Component_List_Attributes;\n+\n+      --------------------------------\n+      -- Append_Component_Attr --\n+      --------------------------------\n+\n+      procedure Append_Component_Attr (Clist : List_Id; C : Entity_Id) is\n+         Component_Typ : constant Entity_Id := Put_Image_Base_Type (Etype (C));\n+      begin\n+         if Ekind (C) /= E_Void\n+           and then Enable_Put_Image (Component_Typ)\n+         then\n+            Append_To (Clist,\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Occurrence_Of (Component_Typ, Loc),\n+                Attribute_Name => Name_Put_Image,\n+                Expressions    => New_List (\n+                  Make_Identifier (Loc, Name_S),\n+                  Make_Selected_Component (Loc,\n+                    Prefix        => Make_Identifier (Loc, Name_V),\n+                    Selector_Name => New_Occurrence_Of (C, Loc)))));\n+         end if;\n+      end Append_Component_Attr;\n+\n+      -------------------------------\n+      -- Make_Component_Attributes --\n+      -------------------------------\n+\n+      function Make_Component_Attributes (Clist : List_Id) return List_Id is\n+         Item   : Node_Id;\n+         Result : List_Id;\n+\n+      begin\n+         Result := New_List;\n+\n+         if Present (Clist) then\n+            Item := First (Clist);\n+\n+            --  Loop through components, skipping all internal components,\n+            --  which are not part of the value (e.g. _Tag), except that we\n+            --  don't skip the _Parent, since we do want to process that\n+            --  recursively. If _Parent is an interface type, being abstract\n+            --  with no components there is no need to handle it.\n+\n+            while Present (Item) loop\n+               if Nkind_In (Item, N_Component_Declaration,\n+                                  N_Discriminant_Specification)\n+                 and then\n+                   ((Chars (Defining_Identifier (Item)) = Name_uParent\n+                       and then not Is_Interface\n+                                      (Etype (Defining_Identifier (Item))))\n+                     or else\n+                    not Is_Internal_Name (Chars (Defining_Identifier (Item))))\n+               then\n+                  if First_Time then\n+                     First_Time := False;\n+                  else\n+                     Append_To (Result,\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name =>\n+                           New_Occurrence_Of (RTE (RE_Record_Between), Loc),\n+                         Parameter_Associations => New_List\n+                           (Make_Identifier (Loc, Name_S))));\n+                  end if;\n+\n+                  Append_To (Result, Make_Component_Name (Item));\n+                  Append_Component_Attr (Result, Defining_Identifier (Item));\n+               end if;\n+\n+               Next (Item);\n+            end loop;\n+         end if;\n+\n+         return Result;\n+      end Make_Component_Attributes;\n+\n+      -------------------------\n+      -- Make_Component_Name --\n+      -------------------------\n+\n+      function Make_Component_Name (C : Entity_Id) return Node_Id is\n+         Name : constant Name_Id := Chars (Defining_Identifier (C));\n+      begin\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (RTE (RE_Put_UTF_8), Loc),\n+             Parameter_Associations => New_List\n+               (Make_Identifier (Loc, Name_S),\n+                Make_String_Literal (Loc, Get_Name_String (Name) & \" => \")));\n+      end Make_Component_Name;\n+\n+      Stms : constant List_Id := New_List;\n+      Rdef : Node_Id;\n+      Typt : Entity_Id;\n+      Type_Decl : Node_Id;\n+\n+   --  Start of processing for Build_Record_Put_Image_Procedure\n+\n+   begin\n+      --  For the protected type case, use corresponding record\n+\n+      if Is_Protected_Type (Typ) then\n+         Typt := Corresponding_Record_Type (Typ);\n+      else\n+         Typt := Typ;\n+      end if;\n+\n+      Type_Decl := Declaration_Node (Base_Type (Underlying_Type (Typt)));\n+\n+      Append_To (Stms,\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (RTE (RE_Record_Before), Loc),\n+          Parameter_Associations => New_List\n+            (Make_Identifier (Loc, Name_S))));\n+\n+      --  Generate Put_Images for the discriminants of the type\n+      --  If the type is an unchecked union, use the default values of\n+      --  the discriminants, because they are not stored.\n+\n+      Append_List_To (Stms,\n+        Make_Component_Attributes (Discriminant_Specifications (Type_Decl)));\n+\n+      Rdef := Type_Definition (Type_Decl);\n+\n+      --  In the record extension case, the components we want, including the\n+      --  _Parent component representing the parent type, are to be found in\n+      --  the extension. We will process the _Parent component using the type\n+      --  of the parent.\n+\n+      if Nkind (Rdef) = N_Derived_Type_Definition then\n+         Rdef := Record_Extension_Part (Rdef);\n+      end if;\n+\n+      if Present (Component_List (Rdef)) then\n+         Append_List_To (Stms,\n+           Make_Component_List_Attributes (Component_List (Rdef)));\n+      end if;\n+\n+      Append_To (Stms,\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (RTE (RE_Record_After), Loc),\n+          Parameter_Associations => New_List\n+            (Make_Identifier (Loc, Name_S))));\n+\n+      Pnam := Make_Put_Image_Name (Loc, Typ);\n+      Build_Put_Image_Proc (Loc, Typ, Decl, Pnam, Stms);\n+   end Build_Record_Put_Image_Procedure;\n+\n+   -------------------------------\n+   -- Build_Put_Image_Profile --\n+   -------------------------------\n+\n+   function Build_Put_Image_Profile\n+     (Loc : Source_Ptr; Typ : Entity_Id) return List_Id\n+   is\n+   begin\n+      return New_List (\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => Make_Defining_Identifier (Loc, Name_S),\n+          In_Present          => True,\n+          Out_Present         => True,\n+          Parameter_Type      =>\n+            New_Occurrence_Of (Class_Wide_Type (RTE (RE_Sink)), Loc)),\n+\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n+          Parameter_Type      => New_Occurrence_Of (Typ, Loc)));\n+   end Build_Put_Image_Profile;\n+\n+   --------------------------\n+   -- Build_Put_Image_Proc --\n+   --------------------------\n+\n+   procedure Build_Put_Image_Proc\n+     (Loc  : Source_Ptr;\n+      Typ  : Entity_Id;\n+      Decl : out Node_Id;\n+      Pnam : Entity_Id;\n+      Stms : List_Id)\n+   is\n+      Spec : constant Node_Id :=\n+        Make_Procedure_Specification (Loc,\n+          Defining_Unit_Name => Pnam,\n+          Parameter_Specifications => Build_Put_Image_Profile (Loc, Typ));\n+   begin\n+      Decl :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              => Spec,\n+          Declarations               => Empty_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Stms));\n+   end Build_Put_Image_Proc;\n+\n+   ------------------------------------\n+   -- Build_Unknown_Put_Image_Call --\n+   ------------------------------------\n+\n+   function Build_Unknown_Put_Image_Call (N : Node_Id) return Node_Id is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Sink   : constant Node_Id    := First (Expressions (N));\n+      Lib_RE : constant RE_Id      := RE_Put_Image_Unknown;\n+      Libent : constant Entity_Id  := RTE (Lib_RE);\n+   begin\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (Libent, Loc),\n+          Parameter_Associations => New_List (\n+            Relocate_Node (Sink)));\n+   end Build_Unknown_Put_Image_Call;\n+\n+   ----------------------\n+   -- Enable_Put_Image --\n+   ----------------------\n+\n+   function Enable_Put_Image (T : Entity_Id) return Boolean is\n+   begin\n+      if True then -- ????True to disable for all types.\n+         return False;\n+      end if;\n+\n+      --  There's a bit of a chicken&egg problem. The compiler is likely to\n+      --  have trouble if we refer to the Put_Image of Sink itself, because\n+      --  Sink is part of the parameter profile:\n+      --\n+      --     function Sink'Put_Image (S : in out Sink'Class; V : T);\n+      --\n+      --  Likewise, the Ada.Strings.Text_Output package, where Sink is\n+      --  declared, depends on various other packages, so if we refer to\n+      --  Put_Image of types declared in those other packages, we could create\n+      --  cyclic dependencies. Therefore, we disable Put_Image for some\n+      --  types. It's not clear exactly what types should be disabled. Scalar\n+      --  types are OK, even if predefined, because calls to Put_Image of\n+      --  scalar types are expanded inline. We certainly want to be able to use\n+      --  Integer'Put_Image, for example.\n+\n+      --  ???Disable Put_Image on type Sink declared in\n+      --  Ada.Strings.Text_Output. Note that we can't call Is_RTU on\n+      --  Ada_Strings_Text_Output, because it's not known yet (we might be\n+      --  compiling it). But this is insufficient to allow support for tagged\n+      --  predefined types.\n+\n+      declare\n+         Parent_Scope : constant Entity_Id := Scope (Scope (T));\n+      begin\n+         if Present (Parent_Scope)\n+           and then Is_RTU (Parent_Scope, Ada_Strings)\n+           and then Chars (Scope (T)) = Name_Find (\"text_output\")\n+         then\n+            return False;\n+         end if;\n+      end;\n+\n+      return Is_Scalar_Type (T) or else not In_Predefined_Unit (T);\n+   end Enable_Put_Image;\n+\n+   ---------------------------------\n+   -- Make_Put_Image_Name --\n+   ---------------------------------\n+\n+   function Make_Put_Image_Name\n+     (Loc : Source_Ptr; Typ : Entity_Id) return Entity_Id\n+   is\n+      Sname : Name_Id;\n+   begin\n+      --  For tagged types, we are dealing with a TSS associated with the\n+      --  declaration, so we use the standard primitive function name. For\n+      --  other types, generate a local TSS name since we are generating\n+      --  the subprogram at the point of use.\n+\n+      if Is_Tagged_Type (Typ) then\n+         Sname := Make_TSS_Name (Typ, TSS_Put_Image);\n+      else\n+         Sname := Make_TSS_Name_Local (Typ, TSS_Put_Image);\n+      end if;\n+\n+      return Make_Defining_Identifier (Loc, Sname);\n+   end Make_Put_Image_Name;\n+\n+   ----------------------\n+   -- Put_Image_Base_Type --\n+   ----------------------\n+\n+   function Put_Image_Base_Type (E : Entity_Id) return Entity_Id is\n+   begin\n+      if Is_Array_Type (E) and then Is_First_Subtype (E) then\n+         return E;\n+      else\n+         return Base_Type (E);\n+      end if;\n+   end Put_Image_Base_Type;\n+\n+end Exp_Put_Image;"}, {"sha": "b245b0502ddbb3964b97cc9806f3658b59328a8b", "filename": "gcc/ada/exp_put_image.ads", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_put_image.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_put_image.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_put_image.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,87 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        E X P _ P U T _ I M A G E                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2020, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Exp_Put_Image is\n+\n+   --  Routines to build Put_Image calls. See Ada.Strings.Text_Output.Utils and\n+   --  System.Put_Images for the run-time routines we are generating calls to.\n+\n+   --  For a call to T'Put_Image, if T is elementary, we expand the code\n+   --  inline. If T is a tagged type, then Put_Image is a primitive procedure\n+   --  of T, and can be dispatched to in the class-wide case. For untagged\n+   --  composite types, we generate a procedure the first time we see a call,\n+   --  and call it. Subsequent calls call the same procedure. Thus, if there\n+   --  are calls to T'Put_Image in different units, there will be duplicates;\n+   --  each unit will get a copy of the T'Put_Image procedure.\n+\n+   function Enable_Put_Image (T : Entity_Id) return Boolean;\n+   --  True if Put_Image should be enabled for type T\n+\n+   function Build_Put_Image_Profile\n+     (Loc : Source_Ptr; Typ : Entity_Id) return List_Id;\n+   --  Builds the parameter profile for Put_Image. This is used for the tagged\n+   --  case to build the spec for the primitive operation.\n+\n+   --  In the following Build_... routines, N is the attribute reference node,\n+   --  from which the procedure to call and the parameters to pass can be\n+   --  determined.\n+\n+   function Build_Elementary_Put_Image_Call (N : Node_Id) return Node_Id;\n+   --  Builds a Put_Image call for an elementary type.\n+\n+   function Build_String_Put_Image_Call (N : Node_Id) return Node_Id;\n+   --  Builds a Put_Image call for a standard string type.\n+\n+   function Build_Protected_Put_Image_Call (N : Node_Id) return Node_Id;\n+   --  Builds a Put_Image call for a protected type.\n+\n+   function Build_Task_Put_Image_Call (N : Node_Id) return Node_Id;\n+   --  Builds a Put_Image call for a task type.\n+\n+   --  The following routines build the Put_Image procedure for composite\n+   --  types. Typ is the base type to which the procedure applies (i.e. the\n+   --  base type of the Put_Image attribute prefix). The returned results are\n+   --  the declaration and name (entity) of the procedure.\n+\n+   procedure Build_Array_Put_Image_Procedure\n+     (Nod  : Node_Id;\n+      Typ  : Entity_Id;\n+      Decl : out Node_Id;\n+      Pnam : out Entity_Id);\n+   --  Nod provides the Sloc value for the generated code\n+\n+   procedure Build_Record_Put_Image_Procedure\n+     (Loc  : Source_Ptr;\n+      Typ  : Entity_Id;\n+      Decl : out Node_Id;\n+      Pnam : out Entity_Id);\n+   --  Loc is the location of the subprogram declaration\n+\n+   function Build_Unknown_Put_Image_Call (N : Node_Id) return Node_Id;\n+   --  Build a call to Put_Image_Unknown\n+\n+end Exp_Put_Image;"}, {"sha": "5d73498be2e59e6659477f1c0471586293225f5e", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -297,7 +297,7 @@ package body Exp_Strm is\n         Make_Defining_Identifier (Loc,\n           Chars => Make_TSS_Name_Local (Typ, TSS_Stream_Output));\n \n-      Build_Stream_Procedure (Loc, Typ, Decl, Pnam, Stms, False);\n+      Build_Stream_Procedure (Loc, Typ, Decl, Pnam, Stms, Outp => False);\n    end Build_Array_Output_Procedure;\n \n    --------------------------------\n@@ -420,7 +420,7 @@ package body Exp_Strm is\n       end loop;\n \n       Build_Stream_Procedure\n-        (Loc, Typ, Decl, Pnam, New_List (Stm), Nam = Name_Read);\n+        (Loc, Typ, Decl, Pnam, New_List (Stm), Outp => Nam = Name_Read);\n    end Build_Array_Read_Write_Procedure;\n \n    ---------------------------------\n@@ -1320,7 +1320,7 @@ package body Exp_Strm is\n \n       Pnam := Make_Stream_Subprogram_Name (Loc, Typ, TSS_Stream_Output);\n \n-      Build_Stream_Procedure (Loc, Typ, Decl, Pnam, Stms, False);\n+      Build_Stream_Procedure (Loc, Typ, Decl, Pnam, Stms, Outp => False);\n    end Build_Record_Or_Elementary_Output_Procedure;\n \n    ---------------------------------\n@@ -1585,7 +1585,7 @@ package body Exp_Strm is\n       end if;\n \n       Build_Stream_Procedure\n-        (Loc, Typ, Decl, Pnam, Stms, Nam = Name_Read);\n+        (Loc, Typ, Decl, Pnam, Stms, Outp => Nam = Name_Read);\n    end Build_Record_Read_Write_Procedure;\n \n    ----------------------------------"}, {"sha": "37b0418515208d95855189b3840429782d638e70", "filename": "gcc/ada/exp_tss.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_tss.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fexp_tss.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -94,6 +94,7 @@ package Exp_Tss is\n    TSS_Stream_Output      : constant TNT := \"SO\";  -- Stream Output attribute\n    TSS_Stream_Read        : constant TNT := \"SR\";  -- Stream Read attribute\n    TSS_Stream_Write       : constant TNT := \"SW\";  -- Stream Write attribute\n+   TSS_Put_Image          : constant TNT := \"PI\";  -- Put_Image attribute\n    TSS_To_Any             : constant TNT := \"TA\";  -- PolyORB/DSA To_Any\n    TSS_TypeCode           : constant TNT := \"TC\";  -- PolyORB/DSA TypeCode\n \n@@ -116,6 +117,7 @@ package Exp_Tss is\n       TSS_Stream_Output,\n       TSS_Stream_Read,\n       TSS_Stream_Write,\n+      TSS_Put_Image,\n       TSS_To_Any,\n       TSS_TypeCode);\n "}, {"sha": "7d2ea52dce5705b44e00e827052def6ce8a8c03d", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -302,6 +302,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/exp_intr.o\t\\\n  ada/exp_pakd.o\t\\\n  ada/exp_prag.o\t\\\n+ ada/exp_put_image.o\t\\\n  ada/exp_sel.o\t\\\n  ada/exp_smem.o\t\\\n  ada/exp_strm.o\t\\"}, {"sha": "70c0b0b73269dacac5d06bd717fc8b229ca46231", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -620,14 +620,21 @@ package body Impunit is\n    --  The following units should be used only in Ada 202X mode\n \n    Non_Imp_File_Names_2X : constant File_List := (\n-    (\"a-stteou\", T),  -- Ada.Strings.Text_Output\n     (\"a-nubinu\", T),  -- Ada.Numerics.Big_Numbers\n     (\"a-nbnbin\", T),  -- Ada.Numerics.Big_Numbers.Big_Integers\n     (\"a-nbnbre\", T),  -- Ada.Numerics.Big_Numbers.Big_Reals\n     (\"s-aotase\", T),  -- System.Atomic_Operations.Test_And_Set\n     (\"s-atoope\", T),  -- System.Atomic_Operations\n     (\"s-atopar\", T),  -- System.Atomic_Operations.Arithmetic\n-    (\"s-atopex\", T)); -- System.Atomic_Operations.Exchange\n+    (\"s-atopex\", T),  -- System.Atomic_Operations.Exchange\n+    (\"a-stteou\", T),  -- Ada.Strings.Text_Output\n+    (\"a-stouut\", T),  -- Ada.Strings.Text_Output.Utils\n+    (\"a-stoubu\", T),  -- Ada.Strings.Text_Output.Buffers\n+    (\"a-stoufi\", T),  -- Ada.Strings.Text_Output.Files\n+    (\"a-stobfi\", T),  -- Ada.Strings.Text_Output.Basic_Files\n+    (\"a-stobbu\", T),  -- Ada.Strings.Text_Output.Bit_Buckets\n+    (\"a-stoufo\", T)   -- Ada.Strings.Text_Output.Formatting\n+   );\n \n    -----------------------\n    -- Alternative Units --"}, {"sha": "64f2b6da76da1886825a63aca5abd0eeaf4c7074", "filename": "gcc/ada/libgnat/a-stobbu.adb", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobbu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobbu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stobbu.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    ADA.STRINGS.TEXT_OUTPUT.BIT_BUCKETS                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+package body Ada.Strings.Text_Output.Bit_Buckets is\n+\n+   type Bit_Bucket_Type is new Sink with null record;\n+   overriding procedure Full_Method (S : in out Bit_Bucket_Type);\n+   overriding procedure Flush_Method (S : in out Bit_Bucket_Type);\n+\n+   The_Bit_Bucket : aliased Bit_Bucket_Type\n+     (Chunk_Length => Default_Chunk_Length);\n+   function Bit_Bucket return Sink_Access is (The_Bit_Bucket'Access);\n+\n+   overriding procedure Full_Method (S : in out Bit_Bucket_Type)\n+                renames Flush_Method;\n+\n+   overriding procedure Flush_Method (S : in out Bit_Bucket_Type) is\n+   begin\n+      S.Last := 0;\n+   end Flush_Method;\n+\n+begin\n+   The_Bit_Bucket.Indent_Amount := 0;\n+   The_Bit_Bucket.Cur_Chunk := The_Bit_Bucket.Initial_Chunk'Access;\n+end Ada.Strings.Text_Output.Bit_Buckets;"}, {"sha": "d2b1011f8f295356628bf93eede819986b8f4db2", "filename": "gcc/ada/libgnat/a-stobbu.ads", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobbu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobbu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stobbu.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,36 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    ADA.STRINGS.TEXT_OUTPUT.BIT_BUCKETS                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+package Ada.Strings.Text_Output.Bit_Buckets is\n+   function Bit_Bucket return Sink_Access;\n+end Ada.Strings.Text_Output.Bit_Buckets;"}, {"sha": "91edf3fd170fa175befa93177198f8ff4ea6776d", "filename": "gcc/ada/libgnat/a-stobfi.adb", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobfi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobfi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stobfi.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,120 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    ADA.STRINGS.TEXT_OUTPUT.BASIC_FILES                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+with Ada.Strings.Text_Output.Utils; use Ada.Strings.Text_Output.Utils;\n+package body Ada.Strings.Text_Output.Basic_Files is\n+   use type OS.File_Descriptor;\n+\n+   function Create_From_FD\n+     (FD : OS.File_Descriptor;\n+      Indent_Amount : Natural;\n+      Chunk_Length : Positive) return File;\n+   --  Create a file from an OS file descriptor\n+\n+   function Create_From_FD\n+     (FD : OS.File_Descriptor;\n+      Indent_Amount : Natural;\n+      Chunk_Length : Positive) return File\n+   is\n+   begin\n+      if FD = OS.Invalid_FD then\n+         raise Program_Error with OS.Errno_Message;\n+      end if;\n+      return Result : File (Chunk_Length) do\n+         Result.Indent_Amount := Indent_Amount;\n+         Result.Cur_Chunk := Result.Initial_Chunk'Unchecked_Access;\n+         Result.FD := FD;\n+      end return;\n+   end Create_From_FD;\n+\n+   function Create_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File\n+   is\n+   begin\n+      return Create_From_FD\n+        (OS.Create_File (Name, Fmode => OS.Text),\n+         Indent_Amount, Chunk_Length);\n+   end Create_File;\n+\n+   function Create_New_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File\n+   is\n+   begin\n+      return Create_From_FD\n+        (OS.Create_New_File (Name, Fmode => OS.Text),\n+         Indent_Amount, Chunk_Length);\n+   end Create_New_File;\n+\n+   procedure Close (S : in out File'Class) is\n+      Status : Boolean;\n+   begin\n+      Flush (S);\n+\n+      if S.FD not in OS.Standout | OS.Standerr then -- Don't close these\n+         OS.Close (S.FD, Status);\n+         if not Status then\n+            raise Program_Error with OS.Errno_Message;\n+         end if;\n+      end if;\n+   end Close;\n+\n+   overriding procedure Full_Method (S : in out File) renames Flush_Method;\n+\n+   overriding procedure Flush_Method (S : in out File) is\n+      pragma Assert (S.Cur_Chunk = S.Initial_Chunk'Unchecked_Access);\n+      Res : constant Integer :=\n+        OS.Write (S.FD, S.Cur_Chunk.Chars'Address, S.Last);\n+   begin\n+      if Res /= S.Last then\n+         raise Program_Error with OS.Errno_Message;\n+      end if;\n+      S.Last := 0;\n+   end Flush_Method;\n+\n+   The_Stdout : aliased File :=\n+     Create_From_FD (OS.Standout,\n+                     Indent_Amount => Default_Indent_Amount,\n+                     Chunk_Length => Default_Chunk_Length);\n+   The_Stderr : aliased File :=\n+     Create_From_FD (OS.Standerr,\n+                     Indent_Amount => Default_Indent_Amount,\n+                     Chunk_Length => Default_Chunk_Length);\n+\n+   function Standard_Output return Sink_Access is (The_Stdout'Access);\n+   function Standard_Error return Sink_Access is (The_Stderr'Access);\n+\n+end Ada.Strings.Text_Output.Basic_Files;"}, {"sha": "a2892f087aa04c83c2724b415953577761e4c6b2", "filename": "gcc/ada/libgnat/a-stobfi.ads", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobfi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stobfi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stobfi.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,68 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    ADA.STRINGS.TEXT_OUTPUT.BASIC_FILES                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+private with GNAT.OS_Lib;\n+package Ada.Strings.Text_Output.Basic_Files is\n+   --  Normally, you should use Ada.Strings.Text_Output.Files, which\n+   --  automatically Closes files via finalization. If you don't want to use\n+   --  finalization, use this package instead. You must then Close the file by\n+   --  hand. The semantics is otherwise the same as Files.\n+\n+   function Standard_Output return Sink_Access;\n+   function Standard_Error return Sink_Access;\n+\n+   type File (<>) is new Sink with private;\n+\n+   function Create_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File;\n+   function Create_New_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File;\n+\n+   procedure Close (S : in out File'Class);\n+\n+private\n+\n+   package OS renames GNAT.OS_Lib;\n+\n+   type File is new Sink with record\n+      FD : OS.File_Descriptor := OS.Invalid_FD;\n+   end record;\n+\n+   overriding procedure Full_Method (S : in out File);\n+   overriding procedure Flush_Method (S : in out File);\n+\n+end Ada.Strings.Text_Output.Basic_Files;"}, {"sha": "f563ea5c0dd1ceff30c0a444361a8ee6ce77a262", "filename": "gcc/ada/libgnat/a-stoubu.adb", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoubu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoubu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoubu.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,140 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      ADA.STRINGS.TEXT_OUTPUT.BUFFERS                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+with Unchecked_Deallocation;\n+with Ada.Strings.UTF_Encoding.Strings;\n+with Ada.Strings.UTF_Encoding.Wide_Strings;\n+with Ada.Strings.UTF_Encoding.Wide_Wide_Strings;\n+package body Ada.Strings.Text_Output.Buffers is\n+\n+   function New_Buffer\n+     (Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return Buffer\n+   is\n+   begin\n+      return Result : Buffer (Chunk_Length) do\n+         Result.Indent_Amount := Indent_Amount;\n+         Result.Cur_Chunk := Result.Initial_Chunk'Unchecked_Access;\n+      end return;\n+   end New_Buffer;\n+\n+   procedure Destroy (S : in out Buffer) is\n+      procedure Free is new Unchecked_Deallocation (Chunk, Chunk_Access);\n+      Cur : Chunk_Access := S.Initial_Chunk.Next;\n+   begin\n+      while Cur /= null loop\n+         declare\n+            Temp : constant Chunk_Access := Cur.Next;\n+         begin\n+            Free (Cur);\n+            Cur := Temp;\n+         end;\n+      end loop;\n+\n+      S.Cur_Chunk := null;\n+   end Destroy;\n+\n+   overriding procedure Full_Method (S : in out Buffer) is\n+   begin\n+      pragma Assert (S.Cur_Chunk.Next = null);\n+      pragma Assert (S.Last = S.Cur_Chunk.Chars'Length);\n+      S.Cur_Chunk.Next := new Chunk (S.Chunk_Length);\n+      S.Cur_Chunk := S.Cur_Chunk.Next;\n+      S.Num_Extra_Chunks := @ + 1;\n+      S.Last := 0;\n+   end Full_Method;\n+\n+   function UTF_8_Length (S : Buffer'Class) return Natural is\n+   begin\n+      return S.Num_Extra_Chunks * S.Chunk_Length + S.Last;\n+   end UTF_8_Length;\n+\n+   procedure Get_UTF_8\n+     (S : Buffer'Class; Result : out UTF_8_Lines)\n+   is\n+      Cur : access constant Chunk := S.Initial_Chunk'Access;\n+      First : Positive := 1;\n+   begin\n+      loop\n+         if Cur.Next = null then\n+            pragma Assert (Result'Last = First + S.Last - 1);\n+            Result (First .. Result'Last) := Cur.Chars (1 .. S.Last);\n+            exit;\n+         end if;\n+\n+         pragma Assert (S.Chunk_Length = Cur.Chars'Length);\n+         Result (First .. First + S.Chunk_Length - 1) := Cur.Chars;\n+         First := First + S.Chunk_Length;\n+         Cur := Cur.Next;\n+      end loop;\n+   end Get_UTF_8;\n+\n+   function Get_UTF_8 (S : Buffer'Class) return UTF_8_Lines is\n+   begin\n+      return Result : String (1 .. UTF_8_Length (S)) do\n+         Get_UTF_8 (S, Result);\n+      end return;\n+   end Get_UTF_8;\n+\n+   function Get (S : Buffer'Class) return String is\n+   begin\n+      --  If all characters are 7 bits, we don't need to decode;\n+      --  this is an optimization.\n+\n+      --  Otherwise, if all are 8 bits, we need to decode to get Latin-1.\n+      --  Otherwise, the result is implementation defined, so we return a\n+      --  String encoded as UTF-8. (Note that the AI says \"if any character\n+      --  in the sequence is not defined in Character, the result is\n+      --  implementation-defined\", so we are not obliged to decode ANY\n+      --  Latin-1 characters if ANY character is bigger than 8 bits.\n+\n+      if S.All_7_Bits then\n+         return Get_UTF_8 (S);\n+      elsif S.All_8_Bits then\n+         return UTF_Encoding.Strings.Decode (Get_UTF_8 (S));\n+      else\n+         return Get_UTF_8 (S);\n+      end if;\n+   end Get;\n+\n+   function Wide_Get (S : Buffer'Class) return Wide_String is\n+   begin\n+      return UTF_Encoding.Wide_Strings.Decode (Get_UTF_8 (S));\n+   end Wide_Get;\n+\n+   function Wide_Wide_Get (S : Buffer'Class) return Wide_Wide_String is\n+   begin\n+      return UTF_Encoding.Wide_Wide_Strings.Decode (Get_UTF_8 (S));\n+   end Wide_Wide_Get;\n+\n+end Ada.Strings.Text_Output.Buffers;"}, {"sha": "519e473da2feca00dbac5ce83dd9fd1ce77886cc", "filename": "gcc/ada/libgnat/a-stoubu.ads", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoubu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoubu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoubu.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,75 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      ADA.STRINGS.TEXT_OUTPUT.BUFFERS                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+package Ada.Strings.Text_Output.Buffers is\n+\n+   type Buffer (<>) is new Sink with private;\n+\n+   function New_Buffer\n+     (Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return Buffer;\n+\n+   procedure Destroy (S : in out Buffer);\n+   --  Reclaim any heap-allocated data, and render the Buffer unusable.\n+   --  It would make sense to do this via finalization, but we wish to\n+   --  avoid controlled types in the generated code for 'Image.\n+\n+   function Get_UTF_8 (S : Buffer'Class) return UTF_8_Lines;\n+   --  Get the characters in S, encoded as UTF-8.\n+\n+   function UTF_8_Length (S : Buffer'Class) return Natural;\n+   procedure Get_UTF_8\n+     (S : Buffer'Class; Result : out UTF_8_Lines) with\n+       Pre => Result'First = 1 and Result'Last = UTF_8_Length (S);\n+   --  This is a procedure version of the Get_UTF_8 function, for\n+   --  efficiency. The Result String must be the exact right length.\n+\n+   function Get (S : Buffer'Class) return String;\n+   function Wide_Get (S : Buffer'Class) return Wide_String;\n+   function Wide_Wide_Get (S : Buffer'Class) return Wide_Wide_String;\n+   --  Get the characters in S, decoded as [[Wide_]Wide_]String.\n+   --  There is no need for procedure versions of these, because\n+   --  they are intended primarily to implement the [[Wide_]Wide_]Image\n+   --  attribute, which is already a function.\n+\n+private\n+   type Chunk_Count is new Natural;\n+   type Buffer is new Sink with record\n+      Num_Extra_Chunks : Natural := 0;\n+      --  Number of chunks in the linked list, not including Initial_Chunk.\n+   end record;\n+\n+   overriding procedure Full_Method (S : in out Buffer);\n+   overriding procedure Flush_Method (S : in out Buffer) is null;\n+\n+end Ada.Strings.Text_Output.Buffers;"}, {"sha": "90c03daf2a01c58ae1d96595969bb4d507b7de32", "filename": "gcc/ada/libgnat/a-stoufi.adb", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoufi.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,125 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       ADA.STRINGS.TEXT_OUTPUT.FILES                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+with Ada.Strings.Text_Output.Utils; use Ada.Strings.Text_Output.Utils;\n+package body Ada.Strings.Text_Output.Files is\n+   use type OS.File_Descriptor;\n+\n+   function Create_From_FD\n+     (FD : OS.File_Descriptor;\n+      Indent_Amount : Natural;\n+      Chunk_Length : Positive) return File;\n+   --  Create a file from an OS file descriptor\n+\n+   function Create_From_FD\n+     (FD : OS.File_Descriptor;\n+      Indent_Amount : Natural;\n+      Chunk_Length : Positive) return File\n+   is\n+   begin\n+      if FD = OS.Invalid_FD then\n+         raise Program_Error with OS.Errno_Message;\n+      end if;\n+      return Result : File (Chunk_Length) do\n+         Result.Indent_Amount := Indent_Amount;\n+         Result.Cur_Chunk := Result.Initial_Chunk'Unchecked_Access;\n+         Result.FD := FD;\n+      end return;\n+   end Create_From_FD;\n+\n+   function Create_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File\n+   is\n+   begin\n+      return Create_From_FD\n+        (OS.Create_File (Name, Fmode => OS.Text),\n+         Indent_Amount, Chunk_Length);\n+   end Create_File;\n+\n+   function Create_New_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File\n+   is\n+   begin\n+      return Create_From_FD\n+        (OS.Create_New_File (Name, Fmode => OS.Text),\n+         Indent_Amount, Chunk_Length);\n+   end Create_New_File;\n+\n+   overriding procedure Finalize (Ref : in out Self_Ref) is\n+   begin\n+      Close (Ref.Self.all);\n+   end Finalize;\n+\n+   procedure Close (S : in out File'Class) is\n+      Status : Boolean;\n+   begin\n+      Flush (S);\n+\n+      if S.FD not in OS.Standout | OS.Standerr then -- Don't close these\n+         OS.Close (S.FD, Status);\n+         if not Status then\n+            raise Program_Error with OS.Errno_Message;\n+         end if;\n+      end if;\n+   end Close;\n+\n+   overriding procedure Full_Method (S : in out File) renames Flush_Method;\n+\n+   overriding procedure Flush_Method (S : in out File) is\n+      pragma Assert (S.Cur_Chunk = S.Initial_Chunk'Unchecked_Access);\n+      Res : constant Integer :=\n+        OS.Write (S.FD, S.Cur_Chunk.Chars'Address, S.Last);\n+   begin\n+      if Res /= S.Last then\n+         raise Program_Error with OS.Errno_Message;\n+      end if;\n+      S.Last := 0;\n+   end Flush_Method;\n+\n+   The_Stdout : aliased File :=\n+     Create_From_FD (OS.Standout,\n+                     Indent_Amount => Default_Indent_Amount,\n+                     Chunk_Length => Default_Chunk_Length);\n+   The_Stderr : aliased File :=\n+     Create_From_FD (OS.Standerr,\n+                     Indent_Amount => Default_Indent_Amount,\n+                     Chunk_Length => Default_Chunk_Length);\n+\n+   function Standard_Output return Sink_Access is (The_Stdout'Access);\n+   function Standard_Error return Sink_Access is (The_Stderr'Access);\n+\n+end Ada.Strings.Text_Output.Files;"}, {"sha": "a94124b421f0185f2adfb610946a1e3dea568b66", "filename": "gcc/ada/libgnat/a-stoufi.ads", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoufi.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,74 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       ADA.STRINGS.TEXT_OUTPUT.FILES                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+private with GNAT.OS_Lib;\n+private with Ada.Finalization;\n+package Ada.Strings.Text_Output.Files is\n+   --  This package supports a Sink type that sends output to a file. The file\n+   --  is automatically closed when finalized.\n+\n+   function Standard_Output return Sink_Access;\n+   function Standard_Error return Sink_Access;\n+\n+   type File (<>) is new Sink with private;\n+\n+   function Create_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File;\n+   function Create_New_File\n+     (Name : String;\n+      Indent_Amount : Natural := Default_Indent_Amount;\n+      Chunk_Length : Positive := Default_Chunk_Length) return File;\n+   --  Create a file. Create_New_File raises an exception if the file already\n+   --  exists; Create_File overwrites.\n+\n+   procedure Close (S : in out File'Class);\n+\n+private\n+\n+   package OS renames GNAT.OS_Lib;\n+\n+   type Self_Ref (Self : access File) is new Finalization.Limited_Controlled\n+     with null record;\n+   overriding procedure Finalize (Ref : in out Self_Ref);\n+\n+   type File is new Sink with record\n+      FD : OS.File_Descriptor := OS.Invalid_FD;\n+      Ref : Self_Ref (File'Access);\n+   end record;\n+\n+   overriding procedure Full_Method (S : in out File);\n+   overriding procedure Flush_Method (S : in out File);\n+\n+end Ada.Strings.Text_Output.Files;"}, {"sha": "0cbcd565019f28ff607c5b02d51b019d6a5ab83b", "filename": "gcc/ada/libgnat/a-stoufo.adb", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoufo.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,139 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    ADA.STRINGS.TEXT_OUTPUT.FORMATTING                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+with Ada.Strings.Text_Output.Files;\n+with Ada.Strings.Text_Output.Buffers; use Ada.Strings.Text_Output.Buffers;\n+with Ada.Strings.Text_Output.Utils; use Ada.Strings.Text_Output.Utils;\n+package body Ada.Strings.Text_Output.Formatting is\n+\n+   procedure Put\n+     (S : in out Sink'Class; T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\")\n+   is\n+      J : Positive := T'First;\n+      Used : array (1 .. 6) of Boolean := (others => False);\n+   begin\n+      while J <= T'Last loop\n+         if T (J) = '\\' then\n+            J := J + 1;\n+            case T (J) is\n+               when 'n' =>\n+                  New_Line (S);\n+               when '\\' =>\n+                  Put_7bit (S, '\\');\n+               when 'i' =>\n+                  Indent (S);\n+               when 'o' =>\n+                  Outdent (S);\n+               when 'I' =>\n+                  Indent (S, 1);\n+               when 'O' =>\n+                  Outdent (S, 1);\n+\n+               when '1' =>\n+                  Used (1) := True;\n+                  Put_UTF_8 (S, X1);\n+               when '2' =>\n+                  Used (2) := True;\n+                  Put_UTF_8 (S, X2);\n+               when '3' =>\n+                  Used (3) := True;\n+                  Put_UTF_8 (S, X3);\n+               when '4' =>\n+                  Used (4) := True;\n+                  Put_UTF_8 (S, X4);\n+               when '5' =>\n+                  Used (5) := True;\n+                  Put_UTF_8 (S, X5);\n+               when '6' =>\n+                  Used (6) := True;\n+                  Put_UTF_8 (S, X6);\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+         else\n+            Put_7bit (S, T (J));\n+         end if;\n+\n+         J := J + 1;\n+      end loop;\n+\n+      if not Used (1) then\n+         pragma Assert (X1 = \"\");\n+      end if;\n+      if not Used (2) then\n+         pragma Assert (X2 = \"\");\n+      end if;\n+      if not Used (3) then\n+         pragma Assert (X3 = \"\");\n+      end if;\n+      if not Used (4) then\n+         pragma Assert (X4 = \"\");\n+      end if;\n+      if not Used (5) then\n+         pragma Assert (X5 = \"\");\n+      end if;\n+      if not Used (6) then\n+         pragma Assert (X6 = \"\");\n+      end if;\n+\n+      Flush (S);\n+   end Put;\n+\n+   procedure Put\n+     (T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\") is\n+   begin\n+      Put (Files.Standard_Output.all, T, X1, X2, X3, X4, X5, X6);\n+   end Put;\n+\n+   procedure Err\n+     (T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\") is\n+   begin\n+      Put (Files.Standard_Error.all, T, X1, X2, X3, X4, X5, X6);\n+   end Err;\n+\n+   function Format\n+     (T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\")\n+     return UTF_8_Lines\n+   is\n+      Buf : Buffer := New_Buffer;\n+   begin\n+      Put (Buf, T, X1, X2, X3, X4, X5, X6);\n+      return Get_UTF_8 (Buf);\n+   end Format;\n+\n+end Ada.Strings.Text_Output.Formatting;"}, {"sha": "3636ae6c1f66ed8ec90023bdff058e2f33add729", "filename": "gcc/ada/libgnat/a-stoufo.ads", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stoufo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoufo.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,74 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    ADA.STRINGS.TEXT_OUTPUT.FORMATTING                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+package Ada.Strings.Text_Output.Formatting is\n+\n+   --  Template-based output, based loosely on C's printf family. Unlike\n+   --  printf, it is type safe. We don't support myriad formatting options; the\n+   --  caller is expected to call 'Image, or other functions that might have\n+   --  various formatting capabilities.\n+   --\n+   --  Each of the following calls Flush\n+\n+   type Template is new UTF_8;\n+   procedure Put\n+     (S : in out Sink'Class; T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\");\n+   --  Prints the template as is, except for the following escape sequences:\n+   --    \"\\n\" is end of line.\n+   --    \"\\i\" indents by the default amount, and \"\\o\" outdents.\n+   --    \"\\I\" indents by one space, and \"\\O\" outdents.\n+   --    \"\\1\" is replaced with X1, and similarly for 2, 3, ....\n+   --    \"\\\\\" is \"\\\".\n+\n+   --  Note that the template is not type UTF_8, to avoid this sort of thing:\n+   --\n+   --      https://xkcd.com/327/\n+\n+   procedure Put\n+     (T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\");\n+   --  Sends to standard output\n+\n+   procedure Err\n+     (T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\");\n+   --  Sends to standard error\n+\n+   function Format\n+     (T : Template;\n+      X1, X2, X3, X4, X5, X6 : UTF_8 := \"\")\n+     return UTF_8_Lines;\n+   --  Returns a UTF-8-encoded String\n+\n+end Ada.Strings.Text_Output.Formatting;"}, {"sha": "9d5d163ab9dd248e1256b051cef75d6be35b3fac", "filename": "gcc/ada/libgnat/a-stouut.adb", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stouut.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stouut.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stouut.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,261 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       ADA.STRINGS.TEXT_OUTPUT.UTILS                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+with Ada.Strings.UTF_Encoding.Wide_Wide_Strings;\n+package body Ada.Strings.Text_Output.Utils is\n+\n+   procedure Put_Octet (S : in out Sink'Class; Item : Character) with Inline;\n+   --  Send a single octet to the current Chunk\n+\n+   procedure Adjust_Column (S : in out Sink'Class) with Inline;\n+   --  Adjust the column for a non-NL character.\n+\n+   procedure Full (S : in out Sink'Class) is\n+   begin\n+      pragma Assert (S.Last = S.Chunk_Length);\n+      Full_Method (S);\n+      pragma Assert (S.Last = 0);\n+   end Full;\n+\n+   procedure Flush (S : in out Sink'Class) is\n+   begin\n+      Flush_Method (S);\n+   end Flush;\n+\n+   procedure Put_Octet (S : in out Sink'Class; Item : Character) is\n+   begin\n+      S.Last := @ + 1;\n+      S.Cur_Chunk.Chars (S.Last) := Item;\n+      pragma Assert (S.Chunk_Length = S.Cur_Chunk.Chars'Length);\n+      if S.Last = S.Chunk_Length then\n+         Full (S);\n+      end if;\n+   end Put_Octet;\n+\n+   procedure Adjust_Column (S : in out Sink'Class) is\n+   begin\n+      --  If we're in the first column, indent. This is handled here, rather\n+      --  than when we see NL, because we don't want spaces in a blank line.\n+      --  The character we're about to put is not NL; NL is handled in\n+      --  New_Line. So after indenting, we simply increment the Column.\n+\n+      if S.Column = 1 then\n+         Tab_To_Column (S, S.Indentation + 1);\n+      end if;\n+      S.Column := @ + 1;\n+   end Adjust_Column;\n+\n+   procedure Put_7bit (S : in out Sink'Class; Item : Character_7) is\n+   begin\n+      Adjust_Column (S);\n+      Put_Octet (S, Item);\n+   end Put_7bit;\n+\n+   procedure Put_7bit_NL (S : in out Sink'Class; Item : Character_7) is\n+   begin\n+      if Item = NL then\n+         New_Line (S);\n+      else\n+         Put_7bit (S, Item);\n+      end if;\n+   end Put_7bit_NL;\n+\n+   procedure Put_Character (S : in out Sink'Class; Item : Character) is\n+   begin\n+      if Character'Pos (Item) < 2**7 then\n+         Put_7bit_NL (S, Item);\n+      else\n+         Put_Wide_Wide_Character (S, To_Wide_Wide (Item));\n+      end if;\n+   end Put_Character;\n+\n+   procedure Put_Wide_Character\n+     (S : in out Sink'Class; Item : Wide_Character) is\n+   begin\n+      if Wide_Character'Pos (Item) < 2**7 then\n+         Put_7bit_NL (S, From_Wide (Item));\n+      else\n+         Put_Wide_Wide_Character (S, To_Wide_Wide (Item));\n+      end if;\n+   end Put_Wide_Character;\n+\n+   procedure Put_Wide_Wide_Character\n+     (S : in out Sink'Class; Item : Wide_Wide_Character) is\n+   begin\n+      if Wide_Wide_Character'Pos (Item) < 2**7 then\n+         Put_7bit_NL (S, From_Wide_Wide (Item));\n+      else\n+         S.All_7_Bits := False;\n+         if Wide_Wide_Character'Pos (Item) >= 2**8 then\n+            S.All_8_Bits := False;\n+         end if;\n+         declare\n+            Temp : constant UTF_8_Lines :=\n+              UTF_Encoding.Wide_Wide_Strings.Encode ((1 => Item));\n+         begin\n+            for X of Temp loop\n+               pragma Assert (X /= NL);\n+               Adjust_Column (S);\n+               Put_Octet (S, X);\n+            end loop;\n+         end;\n+      end if;\n+   end Put_Wide_Wide_Character;\n+\n+   procedure Put_UTF_8 (S : in out Sink'Class; Item : UTF_8) is\n+   begin\n+      Adjust_Column (S);\n+\n+      if S.Last + Item'Length < S.Chunk_Length then\n+         --  Item fits in current chunk\n+\n+         S.Cur_Chunk.Chars (S.Last + 1 .. S.Last + Item'Length) := Item;\n+         S.Last := S.Last + Item'Length;\n+      elsif S.Last + Item'Length = S.Chunk_Length then\n+         --  Item fits exactly in current chunk\n+\n+         S.Cur_Chunk.Chars (S.Last + 1 .. S.Last + Item'Length) := Item;\n+         S.Last := S.Last + Item'Length;\n+         Full (S);\n+         --  ???Seems like maybe we shouldn't call Full until we have MORE\n+         --  characters. But then we can't pass Chunk_Length => 1 to\n+         --  Create_File to get unbuffered output.\n+      else\n+         --  We get here only if Item doesn't fit in the current chunk, which\n+         --  should be fairly rare. We split Item into Left and Right, where\n+         --  Left exactly fills the current chunk, and recurse on Left and\n+         --  Right. Right will fit into the next chunk unless it's very long,\n+         --  so another level of recursion will be extremely rare.\n+\n+         declare\n+            Left_Length : constant Natural := S.Chunk_Length - S.Last;\n+            Right_First : constant Natural := Item'First + Left_Length;\n+            Left : UTF_8 renames Item (Item'First .. Right_First - 1);\n+            Right : UTF_8 renames Item (Right_First .. Item'Last);\n+            pragma Assert (Left & Right = Item);\n+         begin\n+            Put_UTF_8 (S, Left); -- This will call Full.\n+            Put_UTF_8 (S, Right); -- This might call Full, but probably not.\n+         end;\n+      end if;\n+   end Put_UTF_8;\n+\n+   procedure Put_UTF_8_Lines (S : in out Sink'Class; Item : UTF_8_Lines) is\n+      Line_Start, Index : Integer := Item'First;\n+      --  Needs to be Integer, because Item'First might be negative for empty\n+      --  Items.\n+   begin\n+      while Index <= Item'Last loop\n+         if Item (Index) = NL then\n+            if Index > Line_Start then\n+               Put_UTF_8 (S, Item (Line_Start .. Index - 1));\n+            end if;\n+            New_Line (S);\n+            S.Column := 1;\n+            Line_Start := Index + 1;\n+         end if;\n+\n+         Index := @ + 1;\n+      end loop;\n+\n+      if Index > Line_Start then\n+         Put_UTF_8 (S, Item (Line_Start .. Index - 1));\n+      end if;\n+   end Put_UTF_8_Lines;\n+\n+   procedure Put_String (S : in out Sink'Class; Item : String) is\n+   begin\n+      for X of Item loop\n+         Put_Character (S, X);\n+      end loop;\n+   end Put_String;\n+\n+   procedure Put_Wide_String (S : in out Sink'Class; Item : Wide_String) is\n+   begin\n+      for X of Item loop\n+         Put_Wide_Character (S, X);\n+      end loop;\n+   end Put_Wide_String;\n+\n+   procedure Put_Wide_Wide_String\n+     (S : in out Sink'Class; Item : Wide_Wide_String) is\n+   begin\n+      for X of Item loop\n+         Put_Wide_Wide_Character (S, X);\n+      end loop;\n+   end Put_Wide_Wide_String;\n+\n+   procedure New_Line (S : in out Sink'Class) is\n+   begin\n+      S.Column := 1;\n+      Put_Octet (S, NL);\n+   end New_Line;\n+\n+   function Column (S : Sink'Class) return Positive is (S.Column);\n+\n+   procedure Tab_To_Column (S : in out Sink'Class; Column : Positive) is\n+   begin\n+      if S.Column < Column then\n+         for X in 1 .. Column - S.Column loop\n+            Put_Octet (S, ' ');\n+         end loop;\n+         S.Column := Column;\n+      end if;\n+   end Tab_To_Column;\n+\n+   procedure Set_Indentation (S : in out Sink'Class; Amount : Natural) is\n+   begin\n+      S.Indentation := Amount;\n+   end Set_Indentation;\n+\n+   function Indentation (S : Sink'Class) return Natural is (S.Indentation);\n+\n+   procedure Indent\n+     (S : in out Sink'Class; Amount : Optional_Indentation := Default)\n+   is\n+      By : constant Natural :=\n+        (if Amount = Default then S.Indent_Amount else Amount);\n+   begin\n+      Set_Indentation (S, Indentation (S) + By);\n+   end Indent;\n+\n+   procedure Outdent\n+     (S : in out Sink'Class; Amount : Optional_Indentation := Default)\n+   is\n+      By : constant Natural :=\n+        (if Amount = Default then S.Indent_Amount else Amount);\n+   begin\n+      Set_Indentation (S, Indentation (S) - By);\n+   end Outdent;\n+\n+end Ada.Strings.Text_Output.Utils;"}, {"sha": "c02885e7cb9351a910dd47ddceedda711eac070a", "filename": "gcc/ada/libgnat/a-stouut.ads", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stouut.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stouut.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stouut.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,108 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       ADA.STRINGS.TEXT_OUTPUT.UTILS                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+package Ada.Strings.Text_Output.Utils is\n+\n+   --  This package provides utility functions on Sink'Class. These are\n+   --  intended for use by Put_Image attributes, both the default versions\n+   --  generated by the compiler, and user-defined ones.\n+\n+   procedure Full (S : in out Sink'Class) with Inline;\n+   --  Must be called when the current chunk is full. Dispatches to\n+   --  Full_Method.\n+\n+   procedure Flush (S : in out Sink'Class) with Inline;\n+   --  Dispatches to Flush_Method\n+\n+   --  Full_Method and Flush_Method should be called only via Full and Flush\n+\n+   procedure Put_Character (S : in out Sink'Class; Item : Character);\n+   procedure Put_Wide_Character (S : in out Sink'Class; Item : Wide_Character);\n+   procedure Put_Wide_Wide_Character\n+     (S : in out Sink'Class; Item : Wide_Wide_Character);\n+   procedure Put_String (S : in out Sink'Class; Item : String);\n+   procedure Put_Wide_String (S : in out Sink'Class; Item : Wide_String);\n+   procedure Put_Wide_Wide_String\n+     (S : in out Sink'Class; Item : Wide_Wide_String);\n+   --  Encode characters or strings as UTF-8, and send them to S.\n+\n+   subtype Character_7 is\n+     Character range Character'Val (0) .. Character'Val (2**7 - 1);\n+   --  7-bit character. These are the same in both Latin-1 and UTF-8.\n+\n+   procedure Put_7bit (S : in out Sink'Class; Item : Character_7)\n+     with Inline, Pre => Item /= NL;\n+   procedure Put_7bit_NL (S : in out Sink'Class; Item : Character_7)\n+     with Inline;\n+   --  Put a 7-bit character, and adjust the Column. For Put_7bit_NL, Item can\n+   --  be NL.\n+\n+   procedure Put_UTF_8 (S : in out Sink'Class; Item : UTF_8) with Inline;\n+   procedure Put_UTF_8_Lines (S : in out Sink'Class; Item : UTF_8_Lines);\n+   --  Send data that is already UTF-8 encoded (including 7-bit ASCII) to\n+   --  S. These are more efficient than Put_String.\n+\n+   procedure New_Line (S : in out Sink'Class) with Inline;\n+   --  Puts the new-line character.\n+\n+   function Column (S : Sink'Class) return Positive with Inline;\n+   --  Current output column. The Column is initially 1, and is incremented for\n+   --  each 7-bit character output, except for the new-line character, which\n+   --  sets Column back to 1. The next character to be output will go in this\n+   --  column.\n+\n+   procedure Tab_To_Column (S : in out Sink'Class; Column : Positive);\n+   --  Put spaces until we're at or past Column.\n+\n+   procedure Set_Indentation (S : in out Sink'Class; Amount : Natural)\n+     with Inline;\n+   function Indentation (S : Sink'Class) return Natural with Inline;\n+   --  Indentation is initially 0. Set_Indentation sets it, and Indentation\n+   --  returns it. This number of space characters are put at the start of\n+   --  each nonempty line.\n+\n+   subtype Optional_Indentation is Integer range -1 .. Natural'Last;\n+   Default : constant Optional_Indentation := -1;\n+\n+   procedure Indent\n+     (S : in out Sink'Class; Amount : Optional_Indentation := Default)\n+      with Inline;\n+   procedure Outdent\n+     (S : in out Sink'Class; Amount : Optional_Indentation := Default)\n+      with Inline;\n+   --  Increase/decrease Indentation by Amount. If Amount = Default, the amount\n+   --  specified by the Indent_Amount parameter of the sink creation function\n+   --  is used. The sink creation functions are New_Buffer, Create_File, and\n+   --  Create_New_File.\n+\n+end Ada.Strings.Text_Output.Utils;"}, {"sha": "1240f4af33c4d977925352976b32e051535c49aa", "filename": "gcc/ada/libgnat/a-stteou.ads", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stteou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-stteou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stteou.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,192 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          ADA.STRINGS.TEXT_OUTPUT                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+\n+with Ada.Strings.UTF_Encoding;\n+with Ada.Strings.UTF_Encoding.Wide_Wide_Strings;\n+package Ada.Strings.Text_Output is\n+\n+   --  This package provides a \"Sink\" abstraction, to which characters of type\n+   --  Character, Wide_Character, and Wide_Wide_Character can be sent. This\n+   --  type is used by the Put_Image attribute. In particular, T'Put_Image has\n+   --  the following parameter types:\n+   --\n+   --     procedure T'Put_Image (S : in out Sink'Class; V : T);\n+   --\n+   --  The default generated code for Put_Image of a composite type will\n+   --  typically call Put_Image on the components.\n+   --\n+   --  This is not a fully general abstraction that can be arbitrarily\n+   --  extended. It is designed with particular extensions in mind, and these\n+   --  extensions are declared in child packages of this package, because they\n+   --  depend on implementation details in the private part of this\n+   --  package. The primary extensions of Sink are:\n+   --\n+   --     Buffer. The characters sent to a Buffer are stored in memory, and can\n+   --     be retrieved via Get functions. This is intended for the\n+   --     implementation of the 'Image attribute. The compiler will generate a\n+   --     T'Image function that declares a local Buffer, sends characters to\n+   --     it, and then returns a call to Get, Destroying the Buffer on return.\n+   --\n+   --       function T'Image (V : T) return String is\n+   --          Buf : Buffer := New_Buffer (...);\n+   --       begin\n+   --          T'Put_Image (Buf, V);\n+   --          return Result : constant String := Get (Buf) do\n+   --             Destroy (Buf);\n+   --          end return;\n+   --       end T'Image;\n+   --       ????Perhaps Buffer should be controlled; if you don't like\n+   --       controlled types, call Put_Image directly.\n+   --\n+   --     File. The characters are sent to a file, possibly opened by file\n+   --     name, or possibly standard output or standard error. 'Put_Image\n+   --     can be called directly on a File, thus avoiding any heap allocation.\n+\n+   type Sink (<>) is abstract tagged limited private;\n+   type Sink_Access is access all Sink'Class with Storage_Size => 0;\n+   --  Sink is a character sink; you can send characters to a Sink.\n+   --  UTF-8 encoding is used.\n+\n+   procedure Full_Method (S : in out Sink) is abstract;\n+   procedure Flush_Method (S : in out Sink) is abstract;\n+   --  There is an internal buffer to store the characters. Full_Method is\n+   --  called when the buffer is full, and Flush_Method may be called to flush\n+   --  the buffer. For Buffer, Full_Method allocates more space for more\n+   --  characters, and Flush_Method does nothing. For File, Full_Method and\n+   --  Flush_Method do the same thing: write the characters to the file, and\n+   --  empty the internal buffer.\n+   --\n+   --  These are the only dispatching subprograms on Sink. This is for\n+   --  efficiency; we don't dispatch on every write to the Sink, but only when\n+   --  the internal buffer is full (or upon client request).\n+   --\n+   --  Full_Method and Flush_Method must make the current chunk empty.\n+   --\n+   --  Additional operations operating on Sink'Class are declared in the Utils\n+   --  child, including Full and Flush, which call the above.\n+\n+   function To_Wide (C : Character) return Wide_Character is\n+     (Wide_Character'Val (Character'Pos (C)));\n+   function To_Wide_Wide (C : Character) return Wide_Wide_Character is\n+     (Wide_Wide_Character'Val (Character'Pos (C)));\n+   function To_Wide_Wide (C : Wide_Character) return Wide_Wide_Character is\n+     (Wide_Wide_Character'Val (Wide_Character'Pos (C)));\n+   --  Conversions [Wide_]Character --> [Wide_]Wide_Character.\n+   --  These cannot fail.\n+\n+   function From_Wide (C : Wide_Character) return Character is\n+     (Character'Val (Wide_Character'Pos (C)));\n+   function From_Wide_Wide (C : Wide_Wide_Character) return Character is\n+     (Character'Val (Wide_Wide_Character'Pos (C)));\n+   function From_Wide_Wide (C : Wide_Wide_Character) return Wide_Character is\n+     (Wide_Character'Val (Wide_Wide_Character'Pos (C)));\n+   --  Conversions [Wide_]Wide_Character --> [Wide_]Character.\n+   --  These fail if the character is out of range.\n+\n+   function NL return Character is (ASCII.LF) with Inline;\n+   function Wide_NL return Wide_Character is (To_Wide (Character'(NL)))\n+     with Inline;\n+   function Wide_Wide_NL return Wide_Wide_Character is\n+     (To_Wide_Wide (Character'(NL))) with Inline;\n+   --  Character representing new line. There is no support for CR/LF line\n+   --  endings.\n+\n+   --  We have two subtypes of String that are encoded in UTF-8. UTF_8 cannot\n+   --  contain newline characters; UTF_8_Lines can. Sending UTF_8 data to a\n+   --  Sink is more efficient, because end-of-line processing is not needed.\n+   --  Both of these are more efficient than [[Wide_]Wide_]String, because no\n+   --  encoding is needed.\n+\n+   subtype UTF_8_Lines is UTF_Encoding.UTF_8_String with\n+     Predicate =>\n+       UTF_Encoding.Wide_Wide_Strings.Encode\n+         (UTF_Encoding.Wide_Wide_Strings.Decode (UTF_8_Lines)) = UTF_8_Lines;\n+\n+   subtype UTF_8 is UTF_8_Lines with\n+     Predicate => (for all C of UTF_8 => C /= NL);\n+\n+   Default_Indent_Amount : constant Natural := 4;\n+\n+   Default_Chunk_Length : constant Positive := 500;\n+   --  Experiment shows this value to be reasonably efficient; decreasing it\n+   --  slows things down, but increasing it doesn't gain much.\n+\n+private\n+   type String_Access is access all String;\n+\n+   --  For Buffer, the \"internal buffer\" mentioned above is implemented as a\n+   --  linked list of chunks. When the current chunk is full, we allocate a new\n+   --  one. For File, there is only one chunk. When it is full, we send the\n+   --  data to the file, and empty it.\n+\n+   type Chunk;\n+   type Chunk_Access is access all Chunk;\n+   type Chunk (Length : Positive) is limited record\n+      Next : Chunk_Access := null;\n+      Chars : UTF_8_Lines (1 .. Length);\n+   end record;\n+\n+   type Sink (Chunk_Length : Positive) is abstract tagged limited record\n+      Indent_Amount : Natural;\n+      Column : Positive := 1;\n+      Indentation : Natural := 0;\n+\n+      All_7_Bits : Boolean := True;\n+      --  For optimization of Text_Output.Buffers.Get (cf).\n+      --  True if all characters seen so far fit in 7 bits.\n+      --  7-bit characters are represented the same in Character\n+      --  and in UTF-8, so they don't need translation.\n+\n+      All_8_Bits : Boolean := True;\n+      --  True if all characters seen so far fit in 8 bits.\n+      --  This is needed in Text_Output.Buffers.Get to distinguish\n+      --  the case where all characters are Latin-1 (so it should\n+      --  decode) from the case where some characters are bigger than\n+      --  8 bits (so the result is implementation defined).\n+\n+      Cur_Chunk : Chunk_Access;\n+      --  Points to the chunk we are currently sending characters to.\n+      --  We want to say:\n+      --     Cur_Chunk : Chunk_Access := Initial_Chunk'Access;\n+      --  but that's illegal, so we have some horsing around to do.\n+\n+      Last : Natural := 0;\n+      --  Last-used character in Cur_Chunk.all.\n+\n+      Initial_Chunk : aliased Chunk (Length => Chunk_Length);\n+      --  For Buffer, this is the first chunk. Subsequent chunks are allocated\n+      --  on the heap. For File, this is the only chunk, and there is no heap\n+      --  allocation.\n+   end record;\n+\n+end Ada.Strings.Text_Output;"}, {"sha": "5c83701f92945c544cfe19cdb8a07026f0b5a412", "filename": "gcc/ada/libgnat/a-tags.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tags.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -588,7 +588,7 @@ private\n    procedure Unregister_Tag (T : Tag);\n    --  Remove a particular tag from the external tag hash table\n \n-   Max_Predef_Prims : constant Positive := 15;\n+   Max_Predef_Prims : constant Positive := 16;\n    --  Number of reserved slots for the following predefined ada primitives:\n    --\n    --    1. Size\n@@ -600,12 +600,13 @@ private\n    --    7. assignment\n    --    8. deep adjust\n    --    9. deep finalize\n-   --   10. async select\n-   --   11. conditional select\n-   --   12. prim_op kind\n-   --   13. task_id\n-   --   14. dispatching requeue\n-   --   15. timed select\n+   --   10. Put_Image\n+   --   11. async select\n+   --   12. conditional select\n+   --   13. prim_op kind\n+   --   14. task_id\n+   --   15. dispatching requeue\n+   --   16. timed select\n    --\n    --  The compiler checks that the value here is correct\n "}, {"sha": "ed8cfe4b1f97bb2dacf4367550503c8be099b656", "filename": "gcc/ada/libgnat/s-putaim.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putaim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putaim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putaim.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          SYSTEM.PUT_TASK_IMAGES                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+with Unchecked_Conversion;\n+with Ada.Strings.Text_Output.Utils;\n+use Ada.Strings.Text_Output;\n+use Ada.Strings.Text_Output.Utils;\n+\n+package body System.Put_Task_Images is\n+\n+   procedure Put_Image_Protected (S : in out Sink'Class) is\n+   begin\n+      Put_UTF_8 (S, \"(protected object)\");\n+   end Put_Image_Protected;\n+\n+   procedure Put_Image_Task\n+     (S : in out Sink'Class; Id : Ada.Task_Identification.Task_Id)\n+   is\n+   begin\n+      Put_UTF_8 (S, \"(task \" & Ada.Task_Identification.Image (Id) & \")\");\n+   end Put_Image_Task;\n+\n+end System.Put_Task_Images;"}, {"sha": "c06b75118a1e19ed589a2532cf4c70e3bf4cea53", "filename": "gcc/ada/libgnat/s-putaim.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putaim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putaim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putaim.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,48 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          SYSTEM.PUT_TASK_IMAGES                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+with Ada.Strings.Text_Output;\n+with Ada.Task_Identification;\n+package System.Put_Task_Images is\n+\n+   --  This package contains subprograms that are called by the generated code\n+   --  for the 'Put_Image attribute for protected and task types. This is\n+   --  separate from System.Put_Images to avoid dragging the tasking runtimes\n+   --  into nontasking programs.\n+\n+   subtype Sink is Ada.Strings.Text_Output.Sink;\n+\n+   procedure Put_Image_Protected (S : in out Sink'Class);\n+   procedure Put_Image_Task\n+     (S : in out Sink'Class; Id : Ada.Task_Identification.Task_Id);\n+\n+end System.Put_Task_Images;"}, {"sha": "cad693f49965779dbd5906f8d838b3205f994e65", "filename": "gcc/ada/libgnat/s-putima.adb", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putima.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putima.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putima.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,220 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                             SYSTEM.PUT_IMAGES                            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+with Unchecked_Conversion;\n+with Ada.Strings.Text_Output.Utils;\n+use Ada.Strings.Text_Output;\n+use Ada.Strings.Text_Output.Utils;\n+\n+package body System.Put_Images is\n+\n+   generic\n+      type Integer_Type is range <>;\n+      type Unsigned_Type is mod <>;\n+      Base : Unsigned_Type;\n+   package Generic_Integer_Images is\n+      pragma Assert (Integer_Type'Size = Unsigned_Type'Size);\n+      pragma Assert (Base in 2 .. 36);\n+      procedure Put_Image (S : in out Sink'Class; X : Integer_Type);\n+      procedure Put_Image (S : in out Sink'Class; X : Unsigned_Type);\n+   end Generic_Integer_Images;\n+\n+   package body Generic_Integer_Images is\n+\n+      A : constant := Character'Pos ('a');\n+      Z : constant := Character'Pos ('0');\n+      subtype Digit is Unsigned_Type range 0 .. Base - 1;\n+      function Digit_To_Character (X : Digit) return Character is\n+        (Character'Val (if X < 10 then X + Z else X + A - 10));\n+\n+      procedure Put_Digits (S : in out Sink'Class; X : Unsigned_Type);\n+      --  Put just the digits of X, without any leading minus sign or space.\n+\n+      procedure Put_Digits (S : in out Sink'Class; X : Unsigned_Type) is\n+      begin\n+         if X >= Base then\n+            Put_Digits (S, X / Base); -- recurse\n+            Put_7bit (S, Digit_To_Character (X mod Base));\n+         else\n+            Put_7bit (S, Digit_To_Character (X));\n+         end if;\n+      end Put_Digits;\n+\n+      procedure Put_Image (S : in out Sink'Class; X : Integer_Type) is\n+      begin\n+         --  Put the space or the minus sign, then pass the absolute value to\n+         --  Put_Digits.\n+\n+         if X >= 0 then\n+            Put_7bit (S, ' ');\n+            Put_Digits (S, Unsigned_Type (X));\n+         else\n+            Put_7bit (S, '-');\n+            Put_Digits (S, -Unsigned_Type'Mod (X));\n+            --  Convert to Unsigned_Type before negating, to avoid overflow\n+            --  on Integer_Type'First.\n+         end if;\n+      end Put_Image;\n+\n+      procedure Put_Image (S : in out Sink'Class; X : Unsigned_Type) is\n+      begin\n+         Put_7bit (S, ' ');\n+         Put_Digits (S, X);\n+      end Put_Image;\n+\n+   end Generic_Integer_Images;\n+\n+   package Small is new Generic_Integer_Images (Integer, Unsigned, Base => 10);\n+   package Large is new Generic_Integer_Images\n+     (Long_Long_Integer, Long_Long_Unsigned, Base => 10);\n+\n+   procedure Put_Image_Integer (S : in out Sink'Class; X : Integer)\n+     renames Small.Put_Image;\n+   procedure Put_Image_Long_Long_Integer\n+     (S : in out Sink'Class; X : Long_Long_Integer)\n+     renames Large.Put_Image;\n+\n+   procedure Put_Image_Unsigned (S : in out Sink'Class; X : Unsigned)\n+     renames Small.Put_Image;\n+   procedure Put_Image_Long_Long_Unsigned\n+     (S : in out Sink'Class; X : Long_Long_Unsigned)\n+     renames Large.Put_Image;\n+\n+   type Signed_Address is range\n+     -2**(Standard'Address_Size - 1) .. 2**(Standard'Address_Size - 1) - 1;\n+   type Unsigned_Address is mod 2**Standard'Address_Size;\n+   package Hex is new Generic_Integer_Images\n+     (Signed_Address, Unsigned_Address, Base => 16);\n+\n+   generic\n+      type Designated (<>) is private;\n+      type Pointer is access all Designated;\n+   procedure Put_Image_Pointer (S : in out Sink'Class; X : Pointer);\n+\n+   procedure Put_Image_Pointer (S : in out Sink'Class; X : Pointer) is\n+      function Cast is new Unchecked_Conversion\n+        (System.Address, Unsigned_Address);\n+   begin\n+      if X = null then\n+         Put_UTF_8 (S, \"null\");\n+      else\n+         Put_UTF_8 (S, \"(access \");\n+         Hex.Put_Image (S, Cast (X.all'Address));\n+         Put_UTF_8 (S, \")\");\n+      end if;\n+   end Put_Image_Pointer;\n+\n+   procedure Thin_Instance is new Put_Image_Pointer (Byte, Thin_Pointer);\n+   procedure Put_Image_Thin_Pointer\n+     (S : in out Sink'Class; X : Thin_Pointer) renames Thin_Instance;\n+   procedure Fat_Instance is new Put_Image_Pointer (Byte_String, Fat_Pointer);\n+   procedure Put_Image_Fat_Pointer\n+     (S : in out Sink'Class; X : Fat_Pointer) renames Fat_Instance;\n+\n+   procedure Put_Image_String (S : in out Sink'Class; X : String) is\n+   begin\n+      --  ????We should double double quotes, and maybe do something nice with\n+      --  control characters.\n+      Put_UTF_8 (S, \"\"\"\");\n+      Put_String (S, X);\n+      Put_UTF_8 (S, \"\"\"\");\n+   end Put_Image_String;\n+\n+   procedure Put_Image_Wide_String (S : in out Sink'Class; X : Wide_String) is\n+   begin\n+      Put_UTF_8 (S, \"\"\"\");\n+      Put_Wide_String (S, X);\n+      Put_UTF_8 (S, \"\"\"\");\n+   end Put_Image_Wide_String;\n+\n+   procedure Put_Image_Wide_Wide_String\n+     (S : in out Sink'Class; X : Wide_Wide_String) is\n+   begin\n+      Put_UTF_8 (S, \"\"\"\");\n+      Put_Wide_Wide_String (S, X);\n+      Put_UTF_8 (S, \"\"\"\");\n+   end Put_Image_Wide_Wide_String;\n+\n+   procedure Array_Before (S : in out Sink'Class) is\n+   begin\n+      New_Line (S);\n+      Put_7bit (S, '[');\n+      Indent (S, 1);\n+   end Array_Before;\n+\n+   procedure Array_Between (S : in out Sink'Class) is\n+   begin\n+      Put_7bit (S, ',');\n+      New_Line (S);\n+   end Array_Between;\n+\n+   procedure Array_After (S : in out Sink'Class) is\n+   begin\n+      Outdent (S, 1);\n+      Put_7bit (S, ']');\n+   end Array_After;\n+\n+   procedure Simple_Array_Between (S : in out Sink'Class) is\n+   begin\n+      Put_7bit (S, ',');\n+      if Column (S) > 60 then\n+         New_Line (S);\n+      else\n+         Put_7bit (S, ' ');\n+      end if;\n+   end Simple_Array_Between;\n+\n+   procedure Record_Before (S : in out Sink'Class) is\n+   begin\n+      New_Line (S);\n+      Put_7bit (S, '(');\n+      Indent (S, 1);\n+   end Record_Before;\n+\n+   procedure Record_Between (S : in out Sink'Class) is\n+   begin\n+      Put_7bit (S, ',');\n+      New_Line (S);\n+   end Record_Between;\n+\n+   procedure Record_After (S : in out Sink'Class) is\n+   begin\n+      Outdent (S, 1);\n+      Put_7bit (S, ')');\n+   end Record_After;\n+\n+   procedure Put_Image_Unknown (S : in out Sink'Class) is\n+   begin\n+      Put_UTF_8 (S, \"{unknown image}\");\n+   end Put_Image_Unknown;\n+\n+end System.Put_Images;"}, {"sha": "0cfe2171e8f8e9928862cf16867966311f3755e7", "filename": "gcc/ada/libgnat/s-putima.ads", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putima.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Flibgnat%2Fs-putima.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putima.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -0,0 +1,93 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                             SYSTEM.PUT_IMAGES                            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2020;\n+with Ada.Strings.Text_Output;\n+with System.Unsigned_Types;\n+package System.Put_Images is\n+\n+   --  This package contains subprograms that are called by the generated code\n+   --  for the 'Put_Image attribute.\n+   --\n+   --  For an integer type that fits in Integer, the actual parameter is\n+   --  converted to Integer, and Put_Image_Integer is called. For larger types,\n+   --  Put_Image_Long_Long_Integer is used. Other numeric types are treated\n+   --  similarly. Access values are unchecked-converted to either Thin_Pointer\n+   --  or Fat_Pointer, and Put_Image_Thin_Pointer or Put_Image_Fat_Pointer is\n+   --  called. The Before/Between/After procedures are called before printing\n+   --  the components of a composite type, between pairs of components, and\n+   --  after them. See Exp_Put_Image in the compiler for details of these\n+   --  calls.\n+\n+   subtype Sink is Ada.Strings.Text_Output.Sink;\n+\n+   procedure Put_Image_Integer (S : in out Sink'Class; X : Integer);\n+   procedure Put_Image_Long_Long_Integer\n+     (S : in out Sink'Class; X : Long_Long_Integer);\n+\n+   subtype Unsigned is System.Unsigned_Types.Unsigned;\n+   subtype Long_Long_Unsigned is System.Unsigned_Types.Long_Long_Unsigned;\n+\n+   procedure Put_Image_Unsigned (S : in out Sink'Class; X : Unsigned);\n+   procedure Put_Image_Long_Long_Unsigned\n+     (S : in out Sink'Class; X : Long_Long_Unsigned);\n+\n+   type Byte is new Character with Alignment => 1;\n+   type Byte_String is array (Positive range <>) of Byte with Alignment => 1;\n+   type Thin_Pointer is access all Byte;\n+   type Fat_Pointer is access all Byte_String;\n+   procedure Put_Image_Thin_Pointer (S : in out Sink'Class; X : Thin_Pointer);\n+   procedure Put_Image_Fat_Pointer (S : in out Sink'Class; X : Fat_Pointer);\n+   --  Print \"null\", or the address of the designated object as an unsigned\n+   --  hexadecimal integer.\n+\n+   procedure Put_Image_String (S : in out Sink'Class; X : String);\n+   procedure Put_Image_Wide_String (S : in out Sink'Class; X : Wide_String);\n+   procedure Put_Image_Wide_Wide_String\n+     (S : in out Sink'Class; X : Wide_Wide_String);\n+\n+   procedure Array_Before (S : in out Sink'Class);\n+   procedure Array_Between (S : in out Sink'Class);\n+   procedure Array_After (S : in out Sink'Class);\n+\n+   procedure Simple_Array_Between (S : in out Sink'Class);\n+   --  For \"simple\" arrays, where we don't want a newline between every\n+   --  component.\n+\n+   procedure Record_Before (S : in out Sink'Class);\n+   procedure Record_Between (S : in out Sink'Class);\n+   procedure Record_After (S : in out Sink'Class);\n+\n+   procedure Put_Image_Unknown (S : in out Sink'Class);\n+   --  For Put_Image of types that don't have the attribute, such as type\n+   --  Sink. Prints a canned string.\n+\n+end System.Put_Images;"}, {"sha": "5983ba95ff2daa6bbea6a31799a7eb89d9e2d558", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -572,6 +572,10 @@ package body Rtsfind is\n          elsif U_Id in Ada_Strings_Child then\n             Name_Buffer (12) := '.';\n \n+            if U_Id in Ada_Strings_Text_Output_Child then\n+               Name_Buffer (24) := '.';\n+            end if;\n+\n          elsif U_Id in Ada_Text_IO_Child then\n             Name_Buffer (12) := '.';\n "}, {"sha": "a86b98ef3646e5c4143304c8e720f2767f8e6073", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -46,10 +46,10 @@ package Rtsfind is\n    --  in the package entity table. The units must be either library level\n    --  package declarations, or library level subprogram declarations. Generic\n    --  units, library level instantiations and subprogram bodies acting as\n-   --  specs may not be referenced (all these cases could be added at the\n+   --  specs must not be referenced. (All these cases could be added at the\n    --  expense of additional complexity in the body of Rtsfind, but it doesn't\n    --  seem worthwhile, since the implementation controls the set of units that\n-   --  are referenced, and this restriction is easily met.\n+   --  are referenced, and this restriction is easily met.)\n \n    --  IMPORTANT NOTE: the specs of packages and procedures with'ed using\n    --  this mechanism must not contain use clauses. This is because these\n@@ -122,6 +122,11 @@ package Rtsfind is\n       Ada_Strings_Wide_Superbounded,\n       Ada_Strings_Wide_Wide_Superbounded,\n       Ada_Strings_Unbounded,\n+      Ada_Strings_Text_Output,\n+\n+      --  Children of Ada.Strings.Text_Output\n+\n+      Ada_Strings_Text_Output_Utils,\n \n       --  Children of Ada.Text_IO (for Check_Text_IO_Special_Unit)\n \n@@ -303,6 +308,8 @@ package Rtsfind is\n       System_Pool_Empty,\n       System_Pool_Local,\n       System_Pool_Size,\n+      System_Put_Images,\n+      System_Put_Task_Images,\n       System_Relative_Delays,\n       System_RPC,\n       System_Scalar_Values,\n@@ -375,7 +382,7 @@ package Rtsfind is\n \n    subtype Ada_Child is RTU_Id\n      range Ada_Calendar .. Ada_Wide_Wide_Text_IO_Modular_IO;\n-   --  Range of values for children or grand-children of Ada\n+   --  Range of values for children or grandchildren of Ada\n \n    subtype Ada_Calendar_Child is Ada_Child\n      range Ada_Calendar_Delays .. Ada_Calendar_Delays;\n@@ -403,8 +410,12 @@ package Rtsfind is\n    --  Range of values for children of Ada.Streams\n \n    subtype Ada_Strings_Child is Ada_Child\n-     range Ada_Strings_Superbounded .. Ada_Strings_Unbounded;\n-   --  Range of values for children of Ada.Strings\n+     range Ada_Strings_Superbounded .. Ada_Strings_Text_Output_Utils;\n+   --  Range of values for children and grandchildren of Ada.Strings\n+\n+   subtype Ada_Strings_Text_Output_Child is Ada_Child\n+     range Ada_Strings_Text_Output_Utils .. Ada_Strings_Text_Output_Utils;\n+   --  Range of values for children of Ada.Strings.Text_Output\n \n    subtype Ada_Text_IO_Child is Ada_Child\n      range Ada_Text_IO_Decimal_IO .. Ada_Text_IO_Modular_IO;\n@@ -563,6 +574,11 @@ package Rtsfind is\n \n      RE_Unbounded_String,                -- Ada.Strings.Unbounded\n \n+     RE_Sink,                            -- Ada.Strings.Text_Output\n+\n+     RE_Put_UTF_8,                       -- Ada.Strings.Text_Output.Utils\n+     RE_Put_Wide_Wide_String,            -- Ada.Strings.Text_Output.Utils\n+\n      RE_Wait_For_Release,                -- Ada.Synchronous_Barriers\n \n      RE_Suspend_Until_True,              -- Ada.Synchronous_Task_Control\n@@ -1244,6 +1260,27 @@ package Rtsfind is\n \n      RE_Stack_Bounded_Pool,              -- System.Pool_Size\n \n+     RE_Put_Image_Integer,               -- System.Put_Images\n+     RE_Put_Image_Long_Long_Integer,     -- System.Put_Images\n+     RE_Put_Image_Unsigned,              -- System.Put_Images\n+     RE_Put_Image_Long_Long_Unsigned,    -- System.Put_Images\n+     RE_Put_Image_Thin_Pointer,          -- System.Put_Images\n+     RE_Put_Image_Fat_Pointer,           -- System.Put_Images\n+     RE_Put_Image_String,                -- System.Put_Images\n+     RE_Put_Image_Wide_String,           -- System.Put_Images\n+     RE_Put_Image_Wide_Wide_String,      -- System.Put_Images\n+     RE_Array_Before,                    -- System.Put_Images\n+     RE_Array_Between,                   -- System.Put_Images\n+     RE_Array_After,                     -- System.Put_Images\n+     RE_Simple_Array_Between,            -- System.Put_Images\n+     RE_Record_Before,                   -- System.Put_Images\n+     RE_Record_Between,                  -- System.Put_Images\n+     RE_Record_After,                    -- System.Put_Images\n+     RE_Put_Image_Unknown,               -- System.Put_Images\n+\n+     RE_Put_Image_Protected,             -- System.Put_Task_Images\n+     RE_Put_Image_Task,                  -- System.Put_Task_Images\n+\n      RE_Do_Apc,                          -- System.RPC\n      RE_Do_Rpc,                          -- System.RPC\n      RE_Params_Stream_Type,              -- System.RPC\n@@ -1807,6 +1844,11 @@ package Rtsfind is\n \n      RE_Unbounded_String                 => Ada_Strings_Unbounded,\n \n+     RE_Sink                             => Ada_Strings_Text_Output,\n+\n+     RE_Put_UTF_8                        => Ada_Strings_Text_Output_Utils,\n+     RE_Put_Wide_Wide_String             => Ada_Strings_Text_Output_Utils,\n+\n      RE_Wait_For_Release                 => Ada_Synchronous_Barriers,\n \n      RE_Suspend_Until_True               => Ada_Synchronous_Task_Control,\n@@ -2612,6 +2654,27 @@ package Rtsfind is\n \n      RE_Stack_Bounded_Pool               => System_Pool_Size,\n \n+     RE_Put_Image_Integer                => System_Put_Images,\n+     RE_Put_Image_Long_Long_Integer      => System_Put_Images,\n+     RE_Put_Image_Unsigned               => System_Put_Images,\n+     RE_Put_Image_Long_Long_Unsigned     => System_Put_Images,\n+     RE_Put_Image_Thin_Pointer           => System_Put_Images,\n+     RE_Put_Image_Fat_Pointer            => System_Put_Images,\n+     RE_Put_Image_String                 => System_Put_Images,\n+     RE_Put_Image_Wide_String            => System_Put_Images,\n+     RE_Put_Image_Wide_Wide_String       => System_Put_Images,\n+     RE_Array_Before                     => System_Put_Images,\n+     RE_Array_Between                    => System_Put_Images,\n+     RE_Array_After                      => System_Put_Images,\n+     RE_Simple_Array_Between             => System_Put_Images,\n+     RE_Record_Before                    => System_Put_Images,\n+     RE_Record_Between                   => System_Put_Images,\n+     RE_Record_After                     => System_Put_Images,\n+     RE_Put_Image_Unknown                => System_Put_Images,\n+\n+     RE_Put_Image_Protected              => System_Put_Task_Images,\n+     RE_Put_Image_Task                   => System_Put_Task_Images,\n+\n      RO_RD_Delay_For                     => System_Relative_Delays,\n \n      RE_Do_Apc                           => System_RPC,"}, {"sha": "160a20626715767a6c9e9332015c837cf55b4fff", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -391,6 +391,9 @@ package body Sem_Attr is\n       --  corresponding possible defined attribute function (e.g. for the\n       --  Read attribute, Nam will be TSS_Stream_Read).\n \n+      procedure Check_Put_Image_Attribute;\n+      --  Validity checking for Put_Image attribute\n+\n       procedure Check_System_Prefix;\n       --  Verify that prefix of attribute N is package System\n \n@@ -2323,6 +2326,49 @@ package body Sem_Attr is\n          end if;\n       end Check_Standard_Prefix;\n \n+      -------------------------------\n+      -- Check_Put_Image_Attribute --\n+      -------------------------------\n+\n+      procedure Check_Put_Image_Attribute is\n+      begin\n+         --  Put_Image is a procedure, and can only appear at the position of a\n+         --  procedure call. If it's a list member and it's parent is a\n+         --  procedure call or aggregate, then this is appearing as an actual\n+         --  parameter or component association, which is wrong.\n+\n+         if Is_List_Member (N)\n+           and then not Nkind_In (Parent (N), N_Procedure_Call_Statement,\n+                                              N_Aggregate)\n+         then\n+            null;\n+         else\n+            Error_Attr\n+              (\"invalid context for attribute%, which is a procedure\", N);\n+         end if;\n+\n+         Check_Type;\n+         Analyze_And_Resolve (E1);\n+\n+         --  Check that the first argument is\n+         --  Ada.Strings.Text_Output.Sink'Class.\n+\n+         --  Note: the double call to Root_Type here is needed because the\n+         --  root type of a class-wide type is the corresponding type (e.g.\n+         --  X for X'Class, and we really want to go to the root.)\n+\n+         if Root_Type (Root_Type (Etype (E1))) /= RTE (RE_Sink) then\n+            Error_Attr\n+              (\"expected Ada.Strings.Text_Output.Sink''Class\", E1);\n+         end if;\n+\n+         --  Check that the second argument is of the right type\n+\n+         Analyze (E2);\n+         Resolve (E2, P_Type);\n+         Check_Not_CPP_Type;\n+      end Check_Put_Image_Attribute;\n+\n       ----------------------------\n       -- Check_Stream_Attribute --\n       ----------------------------\n@@ -5281,6 +5327,16 @@ package body Sem_Attr is\n \n          Validate_Non_Static_Attribute_Function_Call;\n \n+      ---------------\n+      -- Put_Image --\n+      ---------------\n+\n+      when Attribute_Put_Image =>\n+         Check_E2;\n+         Check_Put_Image_Attribute;\n+         Set_Etype (N, Standard_Void_Type);\n+         Resolve (N, Standard_Void_Type);\n+\n       -----------\n       -- Range --\n       -----------\n@@ -10262,6 +10318,7 @@ package body Sem_Attr is\n          | Attribute_Pool_Address\n          | Attribute_Position\n          | Attribute_Priority\n+         | Attribute_Put_Image\n          | Attribute_Read\n          | Attribute_Result\n          | Attribute_Scalar_Storage_Order"}, {"sha": "d4d383ff04979800aee092338791a4cc087699e7", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -16423,6 +16423,7 @@ package body Sem_Ch12 is\n             OK := (Is_Fun and then Num_F = 1);\n \n          when Attribute_Output\n+            | Attribute_Put_Image\n             | Attribute_Read\n             | Attribute_Write\n          =>"}, {"sha": "bd3010ca405aaeab5f5c2cae89e8cd09613e770b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 302, "deletions": 6, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -186,6 +186,12 @@ package body Sem_Ch13 is\n    --  We can't allow this, otherwise we have predicate-static applying to a\n    --  larger class than static expressions, which was never intended.\n \n+   procedure New_Put_Image_Subprogram\n+     (N    : Node_Id;\n+      Ent  : Entity_Id;\n+      Subp : Entity_Id);\n+   --  Similar to New_Stream_Subprogram, but for the Put_Image attribute\n+\n    procedure New_Stream_Subprogram\n      (N    : Node_Id;\n       Ent  : Entity_Id;\n@@ -2227,6 +2233,7 @@ package body Sem_Ch13 is\n                   | Aspect_Machine_Radix\n                   | Aspect_Object_Size\n                   | Aspect_Output\n+                  | Aspect_Put_Image\n                   | Aspect_Read\n                   | Aspect_Scalar_Storage_Order\n                   | Aspect_Simple_Storage_Pool\n@@ -4149,6 +4156,8 @@ package body Sem_Ch13 is\n       --  Storage_Size for derived task types, but that is also clearly\n       --  unintentional.\n \n+      procedure Analyze_Put_Image_TSS_Definition;\n+\n       procedure Analyze_Stream_TSS_Definition (TSS_Nam : TSS_Name_Type);\n       --  Common processing for 'Read, 'Write, 'Input and 'Output attribute\n       --  definition clauses.\n@@ -4171,6 +4180,152 @@ package body Sem_Ch13 is\n       function Check_Primitive_Function (Subp : Entity_Id) return Boolean;\n       --  Common legality check for the previous two\n \n+      -----------------------------------\n+      -- Analyze_Put_Image_TSS_Definition --\n+      -----------------------------------\n+\n+      procedure Analyze_Put_Image_TSS_Definition is\n+         Subp : Entity_Id := Empty;\n+         I    : Interp_Index;\n+         It   : Interp;\n+         Pnam : Entity_Id;\n+\n+         function Has_Good_Profile\n+           (Subp   : Entity_Id;\n+            Report : Boolean := False) return Boolean;\n+         --  Return true if the entity is a subprogram with an appropriate\n+         --  profile for the attribute being defined. If result is False and\n+         --  Report is True, function emits appropriate error.\n+\n+         ----------------------\n+         -- Has_Good_Profile --\n+         ----------------------\n+\n+         function Has_Good_Profile\n+           (Subp   : Entity_Id;\n+            Report : Boolean := False) return Boolean\n+         is\n+            F              : Entity_Id;\n+            Typ            : Entity_Id;\n+\n+         begin\n+            if Ekind (Subp) /= E_Procedure then\n+               return False;\n+            end if;\n+\n+            F := First_Formal (Subp);\n+\n+            if No (F) or else Etype (F) /= Class_Wide_Type (RTE (RE_Sink)) then\n+               return False;\n+            end if;\n+\n+            Next_Formal (F);\n+\n+            if Parameter_Mode (F) /= E_In_Parameter then\n+               return False;\n+            end if;\n+\n+            Typ := Etype (F);\n+\n+            --  Verify that the prefix of the attribute and the local name for\n+            --  the type of the formal match.\n+\n+            if Typ /= Ent then\n+               return False;\n+            end if;\n+\n+            if Present (Next_Formal (F)) then\n+               return False;\n+\n+            elsif not Is_Scalar_Type (Typ)\n+              and then not Is_First_Subtype (Typ)\n+            then\n+               if Report and not Is_First_Subtype (Typ) then\n+                  Error_Msg_N\n+                    (\"subtype of formal in Put_Image operation must be a \"\n+                     & \"first subtype\", Parameter_Type (Parent (F)));\n+               end if;\n+\n+               return False;\n+\n+            else\n+               return True;\n+            end if;\n+         end Has_Good_Profile;\n+\n+      --  Start of processing for Analyze_Put_Image_TSS_Definition\n+\n+      begin\n+         if not Is_Type (U_Ent) then\n+            Error_Msg_N (\"local name must be a subtype\", Nam);\n+            return;\n+\n+         elsif not Is_First_Subtype (U_Ent) then\n+            Error_Msg_N (\"local name must be a first subtype\", Nam);\n+            return;\n+         end if;\n+\n+         Pnam := TSS (Base_Type (U_Ent), TSS_Put_Image);\n+\n+         --  If Pnam is present, it can be either inherited from an ancestor\n+         --  type (in which case it is legal to redefine it for this type), or\n+         --  be a previous definition of the attribute for the same type (in\n+         --  which case it is illegal).\n+\n+         --  In the first case, it will have been analyzed already, and we can\n+         --  check that its profile does not match the expected profile for the\n+         --  Put_Image attribute of U_Ent. In the second case, either Pnam has\n+         --  been analyzed (and has the expected profile), or it has not been\n+         --  analyzed yet (case of a type that has not been frozen yet and for\n+         --  which Put_Image has been set using Set_TSS).\n+\n+         if Present (Pnam)\n+           and then (No (First_Entity (Pnam)) or else Has_Good_Profile (Pnam))\n+         then\n+            Error_Msg_Sloc := Sloc (Pnam);\n+            Error_Msg_Name_1 := Attr;\n+            Error_Msg_N (\"% attribute already defined #\", Nam);\n+            return;\n+         end if;\n+\n+         Analyze (Expr);\n+\n+         if Is_Entity_Name (Expr) then\n+            if not Is_Overloaded (Expr) then\n+               if Has_Good_Profile (Entity (Expr), Report => True) then\n+                  Subp := Entity (Expr);\n+               end if;\n+\n+            else\n+               Get_First_Interp (Expr, I, It);\n+               while Present (It.Nam) loop\n+                  if Has_Good_Profile (It.Nam) then\n+                     Subp := It.Nam;\n+                     exit;\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end if;\n+         end if;\n+\n+         if Present (Subp) then\n+            if Is_Abstract_Subprogram (Subp) then\n+               Error_Msg_N (\"Put_Image subprogram must not be abstract\", Expr);\n+               return;\n+            end if;\n+\n+            Set_Entity (Expr, Subp);\n+            Set_Etype (Expr, Etype (Subp));\n+\n+            New_Put_Image_Subprogram (N, U_Ent, Subp);\n+\n+         else\n+            Error_Msg_Name_1 := Attr;\n+            Error_Msg_N (\"incorrect expression for% attribute\", Expr);\n+         end if;\n+      end Analyze_Put_Image_TSS_Definition;\n+\n       -----------------------------------\n       -- Analyze_Stream_TSS_Definition --\n       -----------------------------------\n@@ -4891,6 +5046,7 @@ package body Sem_Ch13 is\n             when Attribute_External_Tag\n                | Attribute_Input\n                | Attribute_Output\n+               | Attribute_Put_Image\n                | Attribute_Read\n                | Attribute_Simple_Storage_Pool\n                | Attribute_Storage_Pool\n@@ -5892,6 +6048,13 @@ package body Sem_Ch13 is\n                  (\"attribute& cannot be set with definition clause\", N);\n             end if;\n \n+         ---------------\n+         -- Put_Image --\n+         ---------------\n+\n+         when Attribute_Put_Image =>\n+            Analyze_Put_Image_TSS_Definition;\n+\n          ----------\n          -- Read --\n          ----------\n@@ -9299,16 +9462,16 @@ package body Sem_Ch13 is\n       elsif A_Id = Aspect_Synchronization then\n          return;\n \n-      --  Case of stream attributes, just have to compare entities. However,\n-      --  the expression is just a name (possibly overloaded), and there may\n-      --  be stream operations declared for unrelated types, so we just need\n-      --  to verify that one of these interpretations is the one available at\n-      --  at the freeze point.\n+      --  Case of stream attributes and Put_Image, just have to compare\n+      --  entities. However, the expression is just a possibly-overloaded\n+      --  name, so we need to verify that one of these interpretations is\n+      --  the one available at at the freeze point.\n \n       elsif A_Id = Aspect_Input  or else\n             A_Id = Aspect_Output or else\n             A_Id = Aspect_Read   or else\n-            A_Id = Aspect_Write\n+            A_Id = Aspect_Write  or else\n+            A_Id = Aspect_Put_Image\n       then\n          Analyze (End_Decl_Expr);\n          Check_Overloaded_Name;\n@@ -9564,6 +9727,7 @@ package body Sem_Ch13 is\n \n          when Aspect_Input\n             | Aspect_Output\n+            | Aspect_Put_Image\n             | Aspect_Read\n             | Aspect_Suppress\n             | Aspect_Unsuppress\n@@ -12514,6 +12678,138 @@ package body Sem_Ch13 is\n       return S;\n    end Minimum_Size;\n \n+   ---------------------------\n+   -- New_Put_Image_Subprogram --\n+   ---------------------------\n+\n+   procedure New_Put_Image_Subprogram\n+     (N     : Node_Id;\n+      Ent   : Entity_Id;\n+      Subp  : Entity_Id)\n+   is\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Sname     : constant Name_Id    :=\n+        Make_TSS_Name (Base_Type (Ent), TSS_Put_Image);\n+      Subp_Id   : Entity_Id;\n+      Subp_Decl : Node_Id;\n+      F         : Entity_Id;\n+      Etyp      : Entity_Id;\n+\n+      Defer_Declaration : constant Boolean :=\n+                            Is_Tagged_Type (Ent) or else Is_Private_Type (Ent);\n+      --  For a tagged type, there is a declaration at the freeze point, and\n+      --  we must generate only a completion of this declaration. We do the\n+      --  same for private types, because the full view might be tagged.\n+      --  Otherwise we generate a declaration at the point of the attribute\n+      --  definition clause. If the attribute definition comes from an aspect\n+      --  specification the declaration is part of the freeze actions of the\n+      --  type.\n+\n+      function Build_Spec return Node_Id;\n+      --  Used for declaration and renaming declaration, so that this is\n+      --  treated as a renaming_as_body.\n+\n+      ----------------\n+      -- Build_Spec --\n+      ----------------\n+\n+      function Build_Spec return Node_Id is\n+         Formals : List_Id;\n+         Spec    : Node_Id;\n+         T_Ref   : constant Node_Id := New_Occurrence_Of (Etyp, Loc);\n+\n+      begin\n+         Subp_Id := Make_Defining_Identifier (Loc, Sname);\n+\n+         --  S : Sink'Class\n+\n+         Formals := New_List (\n+                      Make_Parameter_Specification (Loc,\n+                        Defining_Identifier =>\n+                          Make_Defining_Identifier (Loc, Name_S),\n+                        In_Present          => True,\n+                        Out_Present         => True,\n+                        Parameter_Type      =>\n+                          New_Occurrence_Of (Etype (F), Loc)));\n+\n+         --  V : T\n+\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n+             Parameter_Type      => T_Ref));\n+\n+         Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name       => Subp_Id,\n+             Parameter_Specifications => Formals);\n+\n+         return Spec;\n+      end Build_Spec;\n+\n+   --  Start of processing for New_Put_Image_Subprogram\n+\n+   begin\n+      F := First_Formal (Subp);\n+\n+      Etyp := Etype (Next_Formal (F));\n+\n+      --  Prepare subprogram declaration and insert it as an action on the\n+      --  clause node. The visibility for this entity is used to test for\n+      --  visibility of the attribute definition clause (in the sense of\n+      --  8.3(23) as amended by AI-195).\n+\n+      if not Defer_Declaration then\n+         Subp_Decl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Build_Spec);\n+\n+      --  For a tagged type, there is always a visible declaration for the\n+      --  Put_Image TSS (it is a predefined primitive operation), and the\n+      --  completion of this declaration occurs at the freeze point, which is\n+      --  not always visible at places where the attribute definition clause is\n+      --  visible. So, we create a dummy entity here for the purpose of\n+      --  tracking the visibility of the attribute definition clause itself.\n+\n+      else\n+         Subp_Id :=\n+           Make_Defining_Identifier (Loc, New_External_Name (Sname, 'V'));\n+         Subp_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Subp_Id,\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc));\n+      end if;\n+\n+      if not Defer_Declaration\n+        and then From_Aspect_Specification (N)\n+        and then Has_Delayed_Freeze (Ent)\n+      then\n+         Append_Freeze_Action (Ent, Subp_Decl);\n+\n+      else\n+         Insert_Action (N, Subp_Decl);\n+         Set_Entity (N, Subp_Id);\n+      end if;\n+\n+      Subp_Decl :=\n+        Make_Subprogram_Renaming_Declaration (Loc,\n+          Specification => Build_Spec,\n+          Name          => New_Occurrence_Of (Subp, Loc));\n+\n+      if Defer_Declaration then\n+         Set_TSS (Base_Type (Ent), Subp_Id);\n+\n+      else\n+         if From_Aspect_Specification (N) then\n+            Append_Freeze_Action (Ent, Subp_Decl);\n+         else\n+            Insert_Action (N, Subp_Decl);\n+         end if;\n+\n+         Copy_TSS (Subp_Id, Base_Type (Ent));\n+      end if;\n+   end New_Put_Image_Subprogram;\n+\n    ---------------------------\n    -- New_Stream_Subprogram --\n    ---------------------------"}, {"sha": "41e28502088756274539807f6574f2c52686400b", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -2838,25 +2838,25 @@ package body Sem_Ch8 is\n       if Nkind (Nam) = N_Attribute_Reference then\n \n          --  In the case of an abstract formal subprogram association, rewrite\n-         --  an actual given by a stream attribute as the name of the\n-         --  corresponding stream primitive of the type.\n+         --  an actual given by a stream or Put_Image attribute as the name of\n+         --  the corresponding stream or Put_Image primitive of the type.\n \n-         --  In a generic context the stream operations are not generated, and\n-         --  this must be treated as a normal attribute reference, to be\n-         --  expanded in subsequent instantiations.\n+         --  In a generic context the stream and Put_Image operations are not\n+         --  generated, and this must be treated as a normal attribute\n+         --  reference, to be expanded in subsequent instantiations.\n \n          if Is_Actual\n            and then Is_Abstract_Subprogram (Formal_Spec)\n            and then Expander_Active\n          then\n             declare\n                Prefix_Type : constant Entity_Id := Entity (Prefix (Nam));\n-               Stream_Prim : Entity_Id;\n+               Prim : Entity_Id;\n \n             begin\n-               --  The class-wide forms of the stream attributes are not\n-               --  primitive dispatching operations (even though they\n-               --  internally dispatch to a stream attribute).\n+               --  The class-wide forms of the stream and Put_Image attributes\n+               --  are not primitive dispatching operations (even though they\n+               --  internally dispatch).\n \n                if Is_Class_Wide_Type (Prefix_Type) then\n                   Error_Msg_N\n@@ -2873,32 +2873,39 @@ package body Sem_Ch8 is\n \n                case Attribute_Name (Nam) is\n                   when Name_Input =>\n-                     Stream_Prim :=\n+                     Prim :=\n                        Find_Optional_Prim_Op (Prefix_Type, TSS_Stream_Input);\n \n                   when Name_Output =>\n-                     Stream_Prim :=\n+                     Prim :=\n                        Find_Optional_Prim_Op (Prefix_Type, TSS_Stream_Output);\n \n                   when Name_Read =>\n-                     Stream_Prim :=\n+                     Prim :=\n                        Find_Optional_Prim_Op (Prefix_Type, TSS_Stream_Read);\n \n                   when Name_Write =>\n-                     Stream_Prim :=\n+                     Prim :=\n                        Find_Optional_Prim_Op (Prefix_Type, TSS_Stream_Write);\n \n+                  when Name_Put_Image =>\n+                     Prim :=\n+                       Find_Optional_Prim_Op (Prefix_Type, TSS_Put_Image);\n+\n                   when others =>\n                      Error_Msg_N\n                        (\"attribute must be a primitive dispatching operation\",\n                         Nam);\n                      return;\n                end case;\n \n-               --  If no operation was found, and the type is limited, the user\n-               --  should have defined one.\n+               --  If no stream operation was found, and the type is limited,\n+               --  the user should have defined one. This rule does not apply\n+               --  to Put_Image.\n \n-               if No (Stream_Prim) then\n+               if No (Prim)\n+                 and then Attribute_Name (Nam) /= Name_Put_Image\n+               then\n                   if Is_Limited_Type (Prefix_Type) then\n                      Error_Msg_NE\n                       (\"stream operation not defined for type&\",\n@@ -2919,9 +2926,9 @@ package body Sem_Ch8 is\n                declare\n                   Prim_Name : constant Node_Id :=\n                                 Make_Identifier (Sloc (Nam),\n-                                  Chars => Chars (Stream_Prim));\n+                                  Chars => Chars (Prim));\n                begin\n-                  Set_Entity (Prim_Name, Stream_Prim);\n+                  Set_Entity (Prim_Name, Prim);\n                   Rewrite (Nam, Prim_Name);\n                   Analyze (Nam);\n                end;"}, {"sha": "6a51703f2f6044692101dc644ac37530c6b9a328", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -17235,6 +17235,7 @@ package body Sem_Util is\n            or else TSS_Name = TSS_Stream_Output\n            or else TSS_Name = TSS_Stream_Read\n            or else TSS_Name = TSS_Stream_Write\n+           or else TSS_Name = TSS_Put_Image\n            or else Is_Predefined_Interface_Primitive (E)\n          then\n             return True;"}, {"sha": "a03cafba7ef09c224d2307cb9188d47fdf529d3d", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -103,8 +103,10 @@ package body Snames is\n    --    xxxDF   deep finalize routine for type xxx                 (Exp_TSS)\n    --    xxxDI   deep initialize routine for type xxx               (Exp_TSS)\n    --    xxxEQ   composite equality routine for record type xxx     (Exp_TSS)\n+   --    xxxFD   finalize address routine for type xxx              (Exp_TSS)\n    --    xxxFA   PolyORB/DSA From_Any converter for type xxx        (Exp_TSS)\n    --    xxxIP   initialization procedure for type xxx              (Exp_TSS)\n+   --    xxxIC   init C++ dispatch tables procedure for type xxx    (Exp_TSS)\n    --    xxxRA   RAS type access routine for type xxx               (Exp_TSS)\n    --    xxxRD   RAS type dereference routine for type xxx          (Exp_TSS)\n    --    xxxRP   Rep to Pos conversion for enumeration type xxx     (Exp_TSS)\n@@ -113,6 +115,7 @@ package body Snames is\n    --    xxxSO   stream output attribute subprogram for type xxx    (Exp_TSS)\n    --    xxxSR   stream read attribute subprogram for type xxx      (Exp_TSS)\n    --    xxxSW   stream write attribute subprogram for type xxx     (Exp_TSS)\n+   --    xxxPI   Put_Image attribute subprogram for type xxx        (Exp_TSS)\n    --    xxxTA   PolyORB/DSA To_Any converter for type xxx          (Exp_TSS)\n    --    xxxTC   PolyORB/DSA Typecode for type xxx                  (Exp_TSS)\n "}, {"sha": "9534bffd935130595e077b0a8ed86e19a9734789", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -1057,6 +1057,7 @@ package Snames is\n \n    First_Procedure_Attribute           : constant Name_Id := N + $;\n    Name_Output                         : constant Name_Id := N + $;\n+   Name_Put_Image                      : constant Name_Id := N + $;\n    Name_Read                           : constant Name_Id := N + $;\n    Name_Write                          : constant Name_Id := N + $;\n    Last_Procedure_Attribute            : constant Name_Id := N + $;\n@@ -1725,6 +1726,7 @@ package Snames is\n       --  Attributes designating procedures\n \n       Attribute_Output,\n+      Attribute_Put_Image,\n       Attribute_Read,\n       Attribute_Write,\n "}, {"sha": "140cb215d4fa28c93d7e3aaa1c2843abf6d187c4", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -365,6 +365,24 @@ package body Tbuild is\n         End_Label              => End_Label);\n    end Make_Implicit_Loop_Statement;\n \n+   --------------------\n+   -- Make_Increment --\n+   --------------------\n+\n+   function Make_Increment\n+     (Loc : Source_Ptr; Index : Entity_Id; Typ : Entity_Id) return Node_Id is\n+   begin\n+      return Make_Assignment_Statement (Loc,\n+               Name => New_Occurrence_Of (Index, Loc),\n+               Expression =>\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix =>\n+                     New_Occurrence_Of (Typ, Loc),\n+                   Attribute_Name => Name_Succ,\n+                   Expressions => New_List (\n+                     New_Occurrence_Of (Index, Loc))));\n+   end Make_Increment;\n+\n    --------------------------\n    -- Make_Integer_Literal --\n    ---------------------------"}, {"sha": "3256804de63ac62b47a0e36bf14ee0cd72748e72", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110d0820bfcb421b8c680409cf5c65aa2a0b4b8e/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=110d0820bfcb421b8c680409cf5c65aa2a0b4b8e", "patch": "@@ -140,6 +140,10 @@ package Tbuild is\n    --  all cases, and the second only for while loops), and if one of these\n    --  restrictions is being violated, an error message is posted on Node.\n \n+   function Make_Increment\n+     (Loc : Source_Ptr; Index : Entity_Id; Typ : Entity_Id) return Node_Id;\n+   --  Return an assignment statement of the form \"Index := Typ'Succ (Index);\"\n+\n    function Make_Integer_Literal\n      (Loc    : Source_Ptr;\n       Intval : Int) return Node_Id;"}]}