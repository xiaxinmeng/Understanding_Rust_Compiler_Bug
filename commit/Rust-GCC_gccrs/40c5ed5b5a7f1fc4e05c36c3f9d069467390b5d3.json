{"sha": "40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBjNWVkNWI1YTdmMWZjNGUwNWMzNmMzZjlkMDY5NDY3MzkwYjVkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-07T19:17:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-07T19:17:37Z"}, "message": "machmode.h (GET_MODE_UNIT_PRECISION): New macro.\n\ngcc/\n\t* machmode.h (GET_MODE_UNIT_PRECISION): New macro.\n\t* simplify-rtx.c (simplify_truncation): New function,\n\textracted from simplify_subreg and (in small part) from\n\tsimplify_unary_operation_1.\n\t(simplify_unary_operation_1) <TRUNCATE>: Use it.  Remove sign bit\n\ttest for !TRULY_NOOP_TRUNCATION_MODES_P.\n\t(simplify_subreg): Use simplify_truncate for lowpart subregs\n\twhere both the inner and outer modes are scalar integers.\n\t* config/mips/mips.c (mips_truncated_op_cost): New function.\n\t(mips_rtx_costs): Adjust test for BADDU.\n\t* config/mips/mips.md (*baddu_di<mode>): Push truncates to operands.\n\nFrom-SVN: r192186", "tree": {"sha": "f37c7454d22dd409224a66eb0ff4242c096607a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f37c7454d22dd409224a66eb0ff4242c096607a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed901e4c617dec0b7388b2410e802545a2a55bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed901e4c617dec0b7388b2410e802545a2a55bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed901e4c617dec0b7388b2410e802545a2a55bb0"}], "stats": {"total": 475, "additions": 275, "deletions": 200}, "files": [{"sha": "ef8297d7ed2674aabf76feea812a9b9c322dbbbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "patch": "@@ -1,3 +1,17 @@\n+2012-10-07  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* machmode.h (GET_MODE_UNIT_PRECISION): New macro.\n+\t* simplify-rtx.c (simplify_truncation): New function,\n+\textracted from simplify_subreg and (in small part) from\n+\tsimplify_unary_operation_1.\n+\t(simplify_unary_operation_1) <TRUNCATE>: Use it.  Remove sign bit\n+\ttest for !TRULY_NOOP_TRUNCATION_MODES_P.\n+\t(simplify_subreg): Use simplify_truncate for lowpart subregs\n+\twhere both the inner and outer modes are scalar integers.\n+\t* config/mips/mips.c (mips_truncated_op_cost): New function.\n+\t(mips_rtx_costs): Adjust test for BADDU.\n+\t* config/mips/mips.md (*baddu_di<mode>): Push truncates to operands.\n+\n 2012-10-07  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline-analysis.c (do_estimate_edge_time): Return actual"}, {"sha": "4073a15d05d7cd169f08ad3b9b861c2656adf5a1", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "patch": "@@ -3557,6 +3557,17 @@ mips_set_reg_reg_cost (enum machine_mode mode)\n     }\n }\n \n+/* Return the cost of an operand X that can be trucated for free.\n+   SPEED says whether we're optimizing for size or speed.  */\n+\n+static int\n+mips_truncated_op_cost (rtx x, bool speed)\n+{\n+  if (GET_CODE (x) == TRUNCATE)\n+    x = XEXP (x, 0);\n+  return set_src_cost (x, speed);\n+}\n+\n /* Implement TARGET_RTX_COSTS.  */\n \n static bool\n@@ -3937,12 +3948,13 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case ZERO_EXTEND:\n       if (outer_code == SET\n \t  && ISA_HAS_BADDU\n-\t  && (GET_CODE (XEXP (x, 0)) == TRUNCATE\n-\t      || GET_CODE (XEXP (x, 0)) == SUBREG)\n \t  && GET_MODE (XEXP (x, 0)) == QImode\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == PLUS)\n+\t  && GET_CODE (XEXP (x, 0)) == PLUS)\n \t{\n-\t  *total = set_src_cost (XEXP (XEXP (x, 0), 0), speed);\n+\t  rtx plus = XEXP (x, 0);\n+\t  *total = (COSTS_N_INSNS (1)\n+\t\t    + mips_truncated_op_cost (XEXP (plus, 0), speed)\n+\t\t    + mips_truncated_op_cost (XEXP (plus, 1), speed));\n \t  return true;\n \t}\n       *total = mips_zero_extend_cost (mode, XEXP (x, 0));"}, {"sha": "570e7851096f3c675f03f001631adb0e18a3cce7", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "patch": "@@ -1306,9 +1306,8 @@\n (define_insn \"*baddu_di<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n         (zero_extend:GPR\n-\t (truncate:QI\n-\t  (plus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t   (match_operand:DI 2 \"register_operand\" \"d\")))))]\n+\t (plus:QI (truncate:QI (match_operand:DI 1 \"register_operand\" \"d\"))\n+\t\t  (truncate:QI (match_operand:DI 2 \"register_operand\" \"d\")))))]\n   \"ISA_HAS_BADDU && TARGET_64BIT\"\n   \"baddu\\\\t%0,%1,%2\"\n   [(set_attr \"alu_type\" \"add\")])"}, {"sha": "b95d05b096e5d164f96d35aef65826b89fab922d", "filename": "gcc/machmode.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "patch": "@@ -217,6 +217,11 @@ extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n #define GET_MODE_UNIT_BITSIZE(MODE) \\\n   ((unsigned short) (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT))\n \n+#define GET_MODE_UNIT_PRECISION(MODE)\t\t\\\n+  (GET_MODE_INNER (MODE) == VOIDmode\t\t\\\n+   ? GET_MODE_PRECISION (MODE)\t\t\t\\\n+   : GET_MODE_PRECISION (GET_MODE_INNER (MODE)))\n+\n /* Get the number of units in the object.  */\n \n extern const unsigned char mode_nunits[NUM_MACHINE_MODES];"}, {"sha": "95cf1860af0114f8ee4482976b93a15586b4b421", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 238, "deletions": 193, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=40c5ed5b5a7f1fc4e05c36c3f9d069467390b5d3", "patch": "@@ -564,6 +564,212 @@ simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n   return simplify_replace_fn_rtx (x, old_rtx, 0, new_rtx);\n }\n \f\n+/* Try to simplify a MODE truncation of OP, which has OP_MODE.\n+   Only handle cases where the truncated value is inherently an rvalue.\n+\n+   RTL provides two ways of truncating a value:\n+\n+   1. a lowpart subreg.  This form is only a truncation when both\n+      the outer and inner modes (here MODE and OP_MODE respectively)\n+      are scalar integers, and only then when the subreg is used as\n+      an rvalue.\n+\n+      It is only valid to form such truncating subregs if the\n+      truncation requires no action by the target.  The onus for\n+      proving this is on the creator of the subreg -- e.g. the\n+      caller to simplify_subreg or simplify_gen_subreg -- and typically\n+      involves either TRULY_NOOP_TRUNCATION_MODES_P or truncated_to_mode.\n+\n+   2. a TRUNCATE.  This form handles both scalar and compound integers.\n+\n+   The first form is preferred where valid.  However, the TRUNCATE\n+   handling in simplify_unary_operation turns the second form into the\n+   first form when TRULY_NOOP_TRUNCATION_MODES_P or truncated_to_mode allow,\n+   so it is generally safe to form rvalue truncations using:\n+\n+      simplify_gen_unary (TRUNCATE, ...)\n+\n+   and leave simplify_unary_operation to work out which representation\n+   should be used.\n+\n+   Because of the proof requirements on (1), simplify_truncation must\n+   also use simplify_gen_unary (TRUNCATE, ...) to truncate parts of OP,\n+   regardless of whether the outer truncation came from a SUBREG or a\n+   TRUNCATE.  For example, if the caller has proven that an SImode\n+   truncation of:\n+\n+      (and:DI X Y)\n+\n+   is a no-op and can be represented as a subreg, it does not follow\n+   that SImode truncations of X and Y are also no-ops.  On a target\n+   like 64-bit MIPS that requires SImode values to be stored in\n+   sign-extended form, an SImode truncation of:\n+\n+      (and:DI (reg:DI X) (const_int 63))\n+\n+   is trivially a no-op because only the lower 6 bits can be set.\n+   However, X is still an arbitrary 64-bit number and so we cannot\n+   assume that truncating it too is a no-op.  */\n+\n+static rtx\n+simplify_truncation (enum machine_mode mode, rtx op,\n+\t\t     enum machine_mode op_mode)\n+{\n+  unsigned int precision = GET_MODE_UNIT_PRECISION (mode);\n+  unsigned int op_precision = GET_MODE_UNIT_PRECISION (op_mode);\n+  gcc_assert (precision <= op_precision);\n+\n+  /* Optimize truncations of zero and sign extended values.  */\n+  if (GET_CODE (op) == ZERO_EXTEND\n+      || GET_CODE (op) == SIGN_EXTEND)\n+    {\n+      /* There are three possibilities.  If MODE is the same as the\n+\t origmode, we can omit both the extension and the subreg.\n+\t If MODE is not larger than the origmode, we can apply the\n+\t truncation without the extension.  Finally, if the outermode\n+\t is larger than the origmode, we can just extend to the appropriate\n+\t mode.  */\n+      enum machine_mode origmode = GET_MODE (XEXP (op, 0));\n+      if (mode == origmode)\n+\treturn XEXP (op, 0);\n+      else if (precision <= GET_MODE_UNIT_PRECISION (origmode))\n+\treturn simplify_gen_unary (TRUNCATE, mode,\n+\t\t\t\t   XEXP (op, 0), origmode);\n+      else\n+\treturn simplify_gen_unary (GET_CODE (op), mode,\n+\t\t\t\t   XEXP (op, 0), origmode);\n+    }\n+\n+  /* Simplify (truncate:SI (op:DI (x:DI) (y:DI)))\n+     to (op:SI (truncate:SI (x:DI)) (truncate:SI (x:DI))).  */\n+  if (GET_CODE (op) == PLUS\n+      || GET_CODE (op) == MINUS\n+      || GET_CODE (op) == MULT)\n+    {\n+      rtx op0 = simplify_gen_unary (TRUNCATE, mode, XEXP (op, 0), op_mode);\n+      if (op0)\n+\t{\n+\t  rtx op1 = simplify_gen_unary (TRUNCATE, mode, XEXP (op, 1), op_mode);\n+\t  if (op1)\n+\t    return simplify_gen_binary (GET_CODE (op), mode, op0, op1);\n+\t}\n+    }\n+\n+  /* Simplify (truncate:QI (lshiftrt:SI (sign_extend:SI (x:QI)) C)) into\n+     to (ashiftrt:QI (x:QI) C), where C is a suitable small constant and\n+     the outer subreg is effectively a truncation to the original mode.  */\n+  if ((GET_CODE (op) == LSHIFTRT\n+       || GET_CODE (op) == ASHIFTRT)\n+      /* Ensure that OP_MODE is at least twice as wide as MODE\n+\t to avoid the possibility that an outer LSHIFTRT shifts by more\n+\t than the sign extension's sign_bit_copies and introduces zeros\n+\t into the high bits of the result.  */\n+      && 2 * precision <= op_precision\n+      && CONST_INT_P (XEXP (op, 1))\n+      && GET_CODE (XEXP (op, 0)) == SIGN_EXTEND\n+      && GET_MODE (XEXP (XEXP (op, 0), 0)) == mode\n+      && INTVAL (XEXP (op, 1)) < precision)\n+    return simplify_gen_binary (ASHIFTRT, mode,\n+\t\t\t\tXEXP (XEXP (op, 0), 0), XEXP (op, 1));\n+\n+  /* Likewise (truncate:QI (lshiftrt:SI (zero_extend:SI (x:QI)) C)) into\n+     to (lshiftrt:QI (x:QI) C), where C is a suitable small constant and\n+     the outer subreg is effectively a truncation to the original mode.  */\n+  if ((GET_CODE (op) == LSHIFTRT\n+       || GET_CODE (op) == ASHIFTRT)\n+      && CONST_INT_P (XEXP (op, 1))\n+      && GET_CODE (XEXP (op, 0)) == ZERO_EXTEND\n+      && GET_MODE (XEXP (XEXP (op, 0), 0)) == mode\n+      && INTVAL (XEXP (op, 1)) < precision)\n+    return simplify_gen_binary (LSHIFTRT, mode,\n+\t\t\t\tXEXP (XEXP (op, 0), 0), XEXP (op, 1));\n+\n+  /* Likewise (truncate:QI (ashift:SI (zero_extend:SI (x:QI)) C)) into\n+     to (ashift:QI (x:QI) C), where C is a suitable small constant and\n+     the outer subreg is effectively a truncation to the original mode.  */\n+  if (GET_CODE (op) == ASHIFT\n+      && CONST_INT_P (XEXP (op, 1))\n+      && (GET_CODE (XEXP (op, 0)) == ZERO_EXTEND\n+\t  || GET_CODE (XEXP (op, 0)) == SIGN_EXTEND)\n+      && GET_MODE (XEXP (XEXP (op, 0), 0)) == mode\n+      && INTVAL (XEXP (op, 1)) < precision)\n+    return simplify_gen_binary (ASHIFT, mode,\n+\t\t\t\tXEXP (XEXP (op, 0), 0), XEXP (op, 1));\n+\n+  /* Recognize a word extraction from a multi-word subreg.  */\n+  if ((GET_CODE (op) == LSHIFTRT\n+       || GET_CODE (op) == ASHIFTRT)\n+      && SCALAR_INT_MODE_P (mode)\n+      && SCALAR_INT_MODE_P (op_mode)\n+      && precision >= BITS_PER_WORD\n+      && 2 * precision <= op_precision\n+      && CONST_INT_P (XEXP (op, 1))\n+      && (INTVAL (XEXP (op, 1)) & (precision - 1)) == 0\n+      && INTVAL (XEXP (op, 1)) >= 0\n+      && INTVAL (XEXP (op, 1)) < op_precision)\n+    {\n+      int byte = subreg_lowpart_offset (mode, op_mode);\n+      int shifted_bytes = INTVAL (XEXP (op, 1)) / BITS_PER_UNIT;\n+      return simplify_gen_subreg (mode, XEXP (op, 0), op_mode,\n+\t\t\t\t  (WORDS_BIG_ENDIAN\n+\t\t\t\t   ? byte - shifted_bytes\n+\t\t\t\t   : byte + shifted_bytes));\n+    }\n+\n+  /* If we have a TRUNCATE of a right shift of MEM, make a new MEM\n+     and try replacing the TRUNCATE and shift with it.  Don't do this\n+     if the MEM has a mode-dependent address.  */\n+  if ((GET_CODE (op) == LSHIFTRT\n+       || GET_CODE (op) == ASHIFTRT)\n+      && SCALAR_INT_MODE_P (op_mode)\n+      && MEM_P (XEXP (op, 0))\n+      && CONST_INT_P (XEXP (op, 1))\n+      && (INTVAL (XEXP (op, 1)) % GET_MODE_BITSIZE (mode)) == 0\n+      && INTVAL (XEXP (op, 1)) > 0\n+      && INTVAL (XEXP (op, 1)) < GET_MODE_BITSIZE (op_mode)\n+      && ! mode_dependent_address_p (XEXP (XEXP (op, 0), 0),\n+\t\t\t\t     MEM_ADDR_SPACE (XEXP (op, 0)))\n+      && ! MEM_VOLATILE_P (XEXP (op, 0))\n+      && (GET_MODE_SIZE (mode) >= UNITS_PER_WORD\n+\t  || WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN))\n+    {\n+      int byte = subreg_lowpart_offset (mode, op_mode);\n+      int shifted_bytes = INTVAL (XEXP (op, 1)) / BITS_PER_UNIT;\n+      return adjust_address_nv (XEXP (op, 0), mode,\n+\t\t\t\t(WORDS_BIG_ENDIAN\n+\t\t\t\t ? byte - shifted_bytes\n+\t\t\t\t : byte + shifted_bytes));\n+    }\n+\n+  /* (truncate:SI (OP:DI ({sign,zero}_extend:DI foo:SI))) is\n+     (OP:SI foo:SI) if OP is NEG or ABS.  */\n+  if ((GET_CODE (op) == ABS\n+       || GET_CODE (op) == NEG)\n+      && (GET_CODE (XEXP (op, 0)) == SIGN_EXTEND\n+\t  || GET_CODE (XEXP (op, 0)) == ZERO_EXTEND)\n+      && GET_MODE (XEXP (XEXP (op, 0), 0)) == mode)\n+    return simplify_gen_unary (GET_CODE (op), mode,\n+\t\t\t       XEXP (XEXP (op, 0), 0), mode);\n+\n+  /* (truncate:A (subreg:B (truncate:C X) 0)) is\n+     (truncate:A X).  */\n+  if (GET_CODE (op) == SUBREG\n+      && SCALAR_INT_MODE_P (mode)\n+      && SCALAR_INT_MODE_P (op_mode)\n+      && SCALAR_INT_MODE_P (GET_MODE (SUBREG_REG (op)))\n+      && GET_CODE (SUBREG_REG (op)) == TRUNCATE\n+      && subreg_lowpart_p (op))\n+    return simplify_gen_unary (TRUNCATE, mode, XEXP (SUBREG_REG (op), 0),\n+\t\t\t       GET_MODE (XEXP (SUBREG_REG (op), 0)));\n+\n+  /* (truncate:A (truncate:B X)) is (truncate:A X).  */\n+  if (GET_CODE (op) == TRUNCATE)\n+    return simplify_gen_unary (TRUNCATE, mode, XEXP (op, 0),\n+\t\t\t       GET_MODE (XEXP (op, 0)));\n+\n+  return NULL_RTX;\n+}\n+\f\n /* Try to simplify a unary operation CODE whose output mode is to be\n    MODE with input operand OP whose mode was originally OP_MODE.\n    Return zero if no simplification can be made.  */\n@@ -815,50 +1021,34 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n       break;\n \n     case TRUNCATE:\n-      /* We can't handle truncation to a partial integer mode here\n-         because we don't know the real bitsize of the partial\n-         integer mode.  */\n-      if (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n-        break;\n-\n-      /* (truncate:SI ({sign,zero}_extend:DI foo:SI)) == foo:SI.  */\n-      if ((GET_CODE (op) == SIGN_EXTEND\n-\t   || GET_CODE (op) == ZERO_EXTEND)\n-\t  && GET_MODE (XEXP (op, 0)) == mode)\n-\treturn XEXP (op, 0);\n+      /* Don't optimize (lshiftrt (mult ...)) as it would interfere\n+\t with the umulXi3_highpart patterns.  */\n+      if (GET_CODE (op) == LSHIFTRT\n+\t  && GET_CODE (XEXP (op, 0)) == MULT)\n+\tbreak;\n \n-      /* (truncate:SI (OP:DI ({sign,zero}_extend:DI foo:SI))) is\n-\t (OP:SI foo:SI) if OP is NEG or ABS.  */\n-      if ((GET_CODE (op) == ABS\n-\t   || GET_CODE (op) == NEG)\n-\t  && (GET_CODE (XEXP (op, 0)) == SIGN_EXTEND\n-\t      || GET_CODE (XEXP (op, 0)) == ZERO_EXTEND)\n-\t  && GET_MODE (XEXP (XEXP (op, 0), 0)) == mode)\n-\treturn simplify_gen_unary (GET_CODE (op), mode,\n-\t\t\t\t   XEXP (XEXP (op, 0), 0), mode);\n+      if (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+\t{\n+\t  if (TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (op)))\n+\t    return rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t  /* We can't handle truncation to a partial integer mode here\n+\t     because we don't know the real bitsize of the partial\n+\t     integer mode.  */\n+\t  break;\n+\t}\n \n-      /* (truncate:A (subreg:B (truncate:C X) 0)) is\n-\t (truncate:A X).  */\n-      if (GET_CODE (op) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (op)) == TRUNCATE\n-\t  && subreg_lowpart_p (op))\n-\treturn simplify_gen_unary (TRUNCATE, mode, XEXP (SUBREG_REG (op), 0),\n-\t\t\t\t   GET_MODE (XEXP (SUBREG_REG (op), 0)));\n+      if (GET_MODE (op) != VOIDmode)\n+\t{\n+\t  temp = simplify_truncation (mode, op, GET_MODE (op));\n+\t  if (temp)\n+\t    return temp;\n+\t}\n \n       /* If we know that the value is already truncated, we can\n-         replace the TRUNCATE with a SUBREG.  Note that this is also\n-         valid if TRULY_NOOP_TRUNCATION is false for the corresponding\n-         modes we just have to apply a different definition for\n-         truncation.  But don't do this for an (LSHIFTRT (MULT ...))\n-         since this will cause problems with the umulXi3_highpart\n-         patterns.  */\n-      if ((TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (op))\n-\t   ? (num_sign_bit_copies (op, GET_MODE (op))\n-\t      > (unsigned int) (GET_MODE_PRECISION (GET_MODE (op))\n-\t\t\t\t- GET_MODE_PRECISION (mode)))\n-\t   : truncated_to_mode (mode, op))\n-\t  && ! (GET_CODE (op) == LSHIFTRT\n-\t\t&& GET_CODE (XEXP (op, 0)) == MULT))\n+\t replace the TRUNCATE with a SUBREG.  */\n+      if (GET_MODE_NUNITS (mode) == 1\n+\t  && (TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (op))\n+\t      || truncated_to_mode (mode, op)))\n \treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n \n       /* A truncate of a comparison can be replaced with a subreg if\n@@ -5596,14 +5786,6 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n       return NULL_RTX;\n     }\n \n-  /* Merge implicit and explicit truncations.  */\n-\n-  if (GET_CODE (op) == TRUNCATE\n-      && GET_MODE_SIZE (outermode) < GET_MODE_SIZE (innermode)\n-      && subreg_lowpart_offset (outermode, innermode) == byte)\n-    return simplify_gen_unary (TRUNCATE, outermode, XEXP (op, 0),\n-\t\t\t       GET_MODE (XEXP (op, 0)));\n-\n   /* SUBREG of a hard register => just change the register number\n      and/or mode.  If the hard register is not valid in that mode,\n      suppress this simplification.  If the hard register is the stack,\n@@ -5689,160 +5871,23 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n       return NULL_RTX;\n     }\n \n-  /* Optimize SUBREG truncations of zero and sign extended values.  */\n-  if ((GET_CODE (op) == ZERO_EXTEND\n-       || GET_CODE (op) == SIGN_EXTEND)\n-      && SCALAR_INT_MODE_P (innermode)\n-      && GET_MODE_PRECISION (outermode) < GET_MODE_PRECISION (innermode))\n+  /* A SUBREG resulting from a zero extension may fold to zero if\n+     it extracts higher bits that the ZERO_EXTEND's source bits.  */\n+  if (GET_CODE (op) == ZERO_EXTEND)\n     {\n       unsigned int bitpos = subreg_lsb_1 (outermode, innermode, byte);\n-\n-      /* If we're requesting the lowpart of a zero or sign extension,\n-\t there are three possibilities.  If the outermode is the same\n-\t as the origmode, we can omit both the extension and the subreg.\n-\t If the outermode is not larger than the origmode, we can apply\n-\t the truncation without the extension.  Finally, if the outermode\n-\t is larger than the origmode, but both are integer modes, we\n-\t can just extend to the appropriate mode.  */\n-      if (bitpos == 0)\n-\t{\n-\t  enum machine_mode origmode = GET_MODE (XEXP (op, 0));\n-\t  if (outermode == origmode)\n-\t    return XEXP (op, 0);\n-\t  if (GET_MODE_PRECISION (outermode) <= GET_MODE_PRECISION (origmode))\n-\t    return simplify_gen_subreg (outermode, XEXP (op, 0), origmode,\n-\t\t\t\t\tsubreg_lowpart_offset (outermode,\n-\t\t\t\t\t\t\t       origmode));\n-\t  if (SCALAR_INT_MODE_P (outermode))\n-\t    return simplify_gen_unary (GET_CODE (op), outermode,\n-\t\t\t\t       XEXP (op, 0), origmode);\n-\t}\n-\n-      /* A SUBREG resulting from a zero extension may fold to zero if\n-\t it extracts higher bits that the ZERO_EXTEND's source bits.  */\n-      if (GET_CODE (op) == ZERO_EXTEND\n-\t  && bitpos >= GET_MODE_PRECISION (GET_MODE (XEXP (op, 0))))\n+      if (bitpos >= GET_MODE_PRECISION (GET_MODE (XEXP (op, 0))))\n \treturn CONST0_RTX (outermode);\n     }\n \n-  /* Simplify (subreg:SI (op:DI ((x:DI) (y:DI)), 0)\n-     to (op:SI (subreg:SI (x:DI) 0) (subreg:SI (x:DI) 0)), where\n-     the outer subreg is effectively a truncation to the original mode.  */\n-  if ((GET_CODE (op) == PLUS\n-       || GET_CODE (op) == MINUS\n-       || GET_CODE (op) == MULT)\n-      && SCALAR_INT_MODE_P (outermode)\n+  if (SCALAR_INT_MODE_P (outermode)\n       && SCALAR_INT_MODE_P (innermode)\n       && GET_MODE_PRECISION (outermode) < GET_MODE_PRECISION (innermode)\n       && byte == subreg_lowpart_offset (outermode, innermode))\n     {\n-      rtx op0 = simplify_gen_subreg (outermode, XEXP (op, 0),\n-                                     innermode, byte);\n-      if (op0)\n-        {\n-          rtx op1 = simplify_gen_subreg (outermode, XEXP (op, 1),\n-                                         innermode, byte);\n-          if (op1)\n-            return simplify_gen_binary (GET_CODE (op), outermode, op0, op1);\n-        }\n-    }\n-\n-  /* Simplify (subreg:QI (lshiftrt:SI (sign_extend:SI (x:QI)) C), 0) into\n-     to (ashiftrt:QI (x:QI) C), where C is a suitable small constant and\n-     the outer subreg is effectively a truncation to the original mode.  */\n-  if ((GET_CODE (op) == LSHIFTRT\n-       || GET_CODE (op) == ASHIFTRT)\n-      && SCALAR_INT_MODE_P (outermode)\n-      && SCALAR_INT_MODE_P (innermode)\n-      /* Ensure that OUTERMODE is at least twice as wide as the INNERMODE\n-\t to avoid the possibility that an outer LSHIFTRT shifts by more\n-\t than the sign extension's sign_bit_copies and introduces zeros\n-\t into the high bits of the result.  */\n-      && (2 * GET_MODE_PRECISION (outermode)) <= GET_MODE_PRECISION (innermode)\n-      && CONST_INT_P (XEXP (op, 1))\n-      && GET_CODE (XEXP (op, 0)) == SIGN_EXTEND\n-      && GET_MODE (XEXP (XEXP (op, 0), 0)) == outermode\n-      && INTVAL (XEXP (op, 1)) < GET_MODE_PRECISION (outermode)\n-      && subreg_lsb_1 (outermode, innermode, byte) == 0)\n-    return simplify_gen_binary (ASHIFTRT, outermode,\n-\t\t\t\tXEXP (XEXP (op, 0), 0), XEXP (op, 1));\n-\n-  /* Likewise (subreg:QI (lshiftrt:SI (zero_extend:SI (x:QI)) C), 0) into\n-     to (lshiftrt:QI (x:QI) C), where C is a suitable small constant and\n-     the outer subreg is effectively a truncation to the original mode.  */\n-  if ((GET_CODE (op) == LSHIFTRT\n-       || GET_CODE (op) == ASHIFTRT)\n-      && SCALAR_INT_MODE_P (outermode)\n-      && SCALAR_INT_MODE_P (innermode)\n-      && GET_MODE_PRECISION (outermode) < GET_MODE_PRECISION (innermode)\n-      && CONST_INT_P (XEXP (op, 1))\n-      && GET_CODE (XEXP (op, 0)) == ZERO_EXTEND\n-      && GET_MODE (XEXP (XEXP (op, 0), 0)) == outermode\n-      && INTVAL (XEXP (op, 1)) < GET_MODE_PRECISION (outermode)\n-      && subreg_lsb_1 (outermode, innermode, byte) == 0)\n-    return simplify_gen_binary (LSHIFTRT, outermode,\n-\t\t\t\tXEXP (XEXP (op, 0), 0), XEXP (op, 1));\n-\n-  /* Likewise (subreg:QI (ashift:SI (zero_extend:SI (x:QI)) C), 0) into\n-     to (ashift:QI (x:QI) C), where C is a suitable small constant and\n-     the outer subreg is effectively a truncation to the original mode.  */\n-  if (GET_CODE (op) == ASHIFT\n-      && SCALAR_INT_MODE_P (outermode)\n-      && SCALAR_INT_MODE_P (innermode)\n-      && GET_MODE_PRECISION (outermode) < GET_MODE_PRECISION (innermode)\n-      && CONST_INT_P (XEXP (op, 1))\n-      && (GET_CODE (XEXP (op, 0)) == ZERO_EXTEND\n-\t  || GET_CODE (XEXP (op, 0)) == SIGN_EXTEND)\n-      && GET_MODE (XEXP (XEXP (op, 0), 0)) == outermode\n-      && INTVAL (XEXP (op, 1)) < GET_MODE_PRECISION (outermode)\n-      && subreg_lsb_1 (outermode, innermode, byte) == 0)\n-    return simplify_gen_binary (ASHIFT, outermode,\n-\t\t\t\tXEXP (XEXP (op, 0), 0), XEXP (op, 1));\n-\n-  /* Recognize a word extraction from a multi-word subreg.  */\n-  if ((GET_CODE (op) == LSHIFTRT\n-       || GET_CODE (op) == ASHIFTRT)\n-      && SCALAR_INT_MODE_P (innermode)\n-      && GET_MODE_PRECISION (outermode) >= BITS_PER_WORD\n-      && GET_MODE_PRECISION (innermode) >= (2 * GET_MODE_PRECISION (outermode))\n-      && CONST_INT_P (XEXP (op, 1))\n-      && (INTVAL (XEXP (op, 1)) & (GET_MODE_PRECISION (outermode) - 1)) == 0\n-      && INTVAL (XEXP (op, 1)) >= 0\n-      && INTVAL (XEXP (op, 1)) < GET_MODE_PRECISION (innermode)\n-      && byte == subreg_lowpart_offset (outermode, innermode))\n-    {\n-      int shifted_bytes = INTVAL (XEXP (op, 1)) / BITS_PER_UNIT;\n-      return simplify_gen_subreg (outermode, XEXP (op, 0), innermode,\n-\t\t\t\t  (WORDS_BIG_ENDIAN\n-\t\t\t\t   ? byte - shifted_bytes\n-\t\t\t\t   : byte + shifted_bytes));\n-    }\n-\n-  /* If we have a lowpart SUBREG of a right shift of MEM, make a new MEM\n-     and try replacing the SUBREG and shift with it.  Don't do this if\n-     the MEM has a mode-dependent address or if we would be widening it.  */\n-\n-  if ((GET_CODE (op) == LSHIFTRT\n-       || GET_CODE (op) == ASHIFTRT)\n-      && SCALAR_INT_MODE_P (innermode)\n-      && MEM_P (XEXP (op, 0))\n-      && CONST_INT_P (XEXP (op, 1))\n-      && GET_MODE_SIZE (outermode) < GET_MODE_SIZE (GET_MODE (op))\n-      && (INTVAL (XEXP (op, 1)) % GET_MODE_BITSIZE (outermode)) == 0\n-      && INTVAL (XEXP (op, 1)) > 0\n-      && INTVAL (XEXP (op, 1)) < GET_MODE_BITSIZE (innermode)\n-      && ! mode_dependent_address_p (XEXP (XEXP (op, 0), 0),\n-\t\t\t\t     MEM_ADDR_SPACE (XEXP (op, 0)))\n-      && ! MEM_VOLATILE_P (XEXP (op, 0))\n-      && byte == subreg_lowpart_offset (outermode, innermode)\n-      && (GET_MODE_SIZE (outermode) >= UNITS_PER_WORD\n-\t  || WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN))\n-    {\n-      int shifted_bytes = INTVAL (XEXP (op, 1)) / BITS_PER_UNIT;\n-      return adjust_address_nv (XEXP (op, 0), outermode,\n-\t\t\t\t(WORDS_BIG_ENDIAN\n-\t\t\t\t ? byte - shifted_bytes\n-\t\t\t\t : byte + shifted_bytes));\n+      rtx tem = simplify_truncation (outermode, op, innermode);\n+      if (tem)\n+\treturn tem;\n     }\n \n   return NULL_RTX;"}]}