{"sha": "eca315011760544a68bf639fed765e8ecb81f604", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNhMzE1MDExNzYwNTQ0YTY4YmY2MzlmZWQ3NjVlOGVjYjgxZjYwNA==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-01-20T06:39:06Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-01-20T06:39:06Z"}, "message": "(all functions): Use NULL_RTX instead of 0 for rtx comparisons.\n\n(emit_pop_insn): Emit insn with mode QImode: insn contains stack-regs.\n(emit_hard_swap_insn): Delete.\n(emit_swap_insn): Merge with emit_hard_swap_insn.\nDelete WHEN arg and change all callers.\nIf previous insn was a push from REG, omit swap.\nIf previous insn wrote reg-stack top to REG, omit swap.\nEmit swap insn with mode QImode: insn contains stack-regs.\nEmit swap insn after previous float insn, instead of before this one.\n(swap_rtx_condition): New function.\n(compare_for_stack_reg): If op 0 of COMPARE is not a stack reg, exchange\nops 0 and 1 and swap cc0 user condition.\n\nFrom-SVN: r3294", "tree": {"sha": "97eba3f8eb9516bacbf0e5765b8f06878c7a1c1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97eba3f8eb9516bacbf0e5765b8f06878c7a1c1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eca315011760544a68bf639fed765e8ecb81f604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca315011760544a68bf639fed765e8ecb81f604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca315011760544a68bf639fed765e8ecb81f604", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca315011760544a68bf639fed765e8ecb81f604/comments", "author": null, "committer": null, "parents": [{"sha": "b47de04b0832bb278ca84fcf73c9d32cb9ff580d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47de04b0832bb278ca84fcf73c9d32cb9ff580d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47de04b0832bb278ca84fcf73c9d32cb9ff580d"}], "stats": {"total": 172, "additions": 115, "deletions": 57}, "files": [{"sha": "5277cd21275db2615d1c3d87a816dcac3cd3ffe5", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 115, "deletions": 57, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca315011760544a68bf639fed765e8ecb81f604/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca315011760544a68bf639fed765e8ecb81f604/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=eca315011760544a68bf639fed765e8ecb81f604", "patch": "@@ -175,9 +175,11 @@ static int current_function_returns_real;\n /* This is the basic stack record.  TOP is an index into REG[] such\n    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.\n \n-   If TOP is -2 the stack is not yet initialized: reg_set indicates\n-   which registers are live.  Stack initialization consists of placing\n-   each live reg in array `reg' and setting `top' appropriately. */\n+   If TOP is -2, REG[] is not yet initialized.  Stack initialization\n+   consists of placing each live reg in array `reg' and setting `top'\n+   appropriately.\n+\n+   REG_SET indicates which registers are live.  */\n \n typedef struct stack_def\n {\n@@ -943,7 +945,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n \n       if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i]))\n \t  && operand_matches[i] == -1\n-\t  && ! find_regno_note (insn, REG_DEAD, REGNO (operands[i])))\n+\t  && find_regno_note (insn, REG_DEAD, REGNO (operands[i])) == NULL_RTX)\n \tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD, operands[i],\n \t\t\t\t    REG_NOTES (insn));\n \n@@ -1505,7 +1507,8 @@ emit_pop_insn (insn, regstack, reg, when)\n \t\t     FP_mode_reg[FIRST_STACK_REG][(int) DFmode]);\n \n   pop_insn = (*when) (pop_rtx, insn);\n-  PUT_MODE (pop_insn, VOIDmode);\n+  /* ??? This used to be VOIDmode, but that seems wrong. */\n+  PUT_MODE (pop_insn, QImode);\n \n   REG_NOTES (pop_insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n \t\t\t\t  FP_mode_reg[FIRST_STACK_REG][(int) DFmode],\n@@ -1528,48 +1531,68 @@ emit_pop_insn (insn, regstack, reg, when)\n    If REG is already at the top of the stack, no insn is emitted. */\n \n static void\n-emit_hard_swap_insn (insn, regstack, hard_regno, when)\n+emit_swap_insn (insn, regstack, reg)\n      rtx insn;\n      stack regstack;\n-     int hard_regno;\n-     rtx (*when)();\n+     rtx reg;\n {\n+  int hard_regno;\n   rtx gen_swapdf();\n   rtx swap_rtx, swap_insn;\n-  int tmp, other;\n+  int tmp, other_reg;\t\t/* swap regno temps */\n+  rtx i1;\t\t\t/* the stack-reg insn prior to INSN */\n+  rtx i1set = NULL_RTX;\t\t/* the SET rtx within I1 */\n \n+  hard_regno = get_hard_regnum (regstack, reg);\n+\n+  if (hard_regno < FIRST_STACK_REG)\n+    abort ();\n   if (hard_regno == FIRST_STACK_REG)\n     return;\n \n-  swap_rtx = gen_swapdf (FP_mode_reg[hard_regno][(int) DFmode],\n-\t\t\t FP_mode_reg[FIRST_STACK_REG][(int) DFmode]);\n-  swap_insn = (*when) (swap_rtx, insn);\n-  PUT_MODE (swap_insn, VOIDmode);\n+  other_reg = regstack->top - (hard_regno - FIRST_STACK_REG);\n \n-  other = regstack->top - (hard_regno - FIRST_STACK_REG);\n-\n-  tmp = regstack->reg[other];\n-  regstack->reg[other] = regstack->reg[regstack->top];\n+  tmp = regstack->reg[other_reg];\n+  regstack->reg[other_reg] = regstack->reg[regstack->top];\n   regstack->reg[regstack->top] = tmp;\n-}\n \n-/* Emit an insn before or after INSN to swap virtual register REG with the\n-   top of stack.  See comments before emit_hard_swap_insn. */\n+  /* Find the previous insn involving stack regs, but don't go past\n+     any labels, calls or jumps.  */\n+  i1 = prev_nonnote_insn (insn);\n+  while (i1 && GET_CODE (i1) == INSN && GET_MODE (i1) != QImode)\n+    i1 = prev_nonnote_insn (i1);\n \n-static void\n-emit_swap_insn (insn, regstack, reg, when)\n-     rtx insn;\n-     stack regstack;\n-     rtx reg;\n-     rtx (*when)();\n-{\n-  int hard_regno;\n+  if (i1)\n+    i1set = single_set (i1);\n \n-  hard_regno = get_hard_regnum (regstack, reg);\n-  if (hard_regno < FIRST_STACK_REG)\n-    abort ();\n+  if (i1set)\n+    {\n+      rtx i2;\t\t\t/* the stack-reg insn prior to I1 */\n+      rtx i1src = *get_true_reg (&SET_SRC (i1set));\n+      rtx i1dest = *get_true_reg (&SET_DEST (i1set));\n \n-  emit_hard_swap_insn (insn, regstack, hard_regno, when);\n+      /* If the previous register stack push was from the reg we are to\n+\t swap with, omit the swap. */\n+\n+      if (GET_CODE (i1dest) == REG && REGNO (i1dest) == FIRST_STACK_REG\n+\t  && GET_CODE (i1src) == REG && REGNO (i1src) == hard_regno - 1\n+\t  && find_regno_note (i1, REG_DEAD, FIRST_STACK_REG) == NULL_RTX)\n+\treturn;\n+\n+      /* If the previous insn wrote to the reg we are to swap with,\n+\t omit the swap.  */\n+\n+      if (GET_CODE (i1dest) == REG && REGNO (i1dest) == hard_regno\n+\t  && GET_CODE (i1src) == REG && REGNO (i1src) == FIRST_STACK_REG\n+\t  && find_regno_note (i1, REG_DEAD, FIRST_STACK_REG) == NULL_RTX)\n+\treturn;\n+    }\n+\n+  swap_rtx = gen_swapdf (FP_mode_reg[hard_regno][(int) DFmode],\n+\t\t\t FP_mode_reg[FIRST_STACK_REG][(int) DFmode]);\n+  swap_insn = emit_insn_after (swap_rtx, i1);\n+  /* ??? This used to be VOIDmode, but that seems wrong. */\n+  PUT_MODE (swap_insn, QImode);\n }\n \f\n /* Handle a move to or from a stack register in PAT, which is in INSN.\n@@ -1660,7 +1683,7 @@ move_for_stack_reg (insn, regstack, pat)\n \t only top of stack may be saved, emit an exchange first if\n \t needs be. */\n \n-      emit_swap_insn (insn, regstack, *src, emit_insn_before);\n+      emit_swap_insn (insn, regstack, *src);\n \n       note = find_regno_note (insn, REG_DEAD, REGNO (*src));\n       if (note)\n@@ -1694,6 +1717,34 @@ move_for_stack_reg (insn, regstack, pat)\n     abort ();\n }\n \f\n+void\n+swap_rtx_condition (pat)\n+     rtx pat;\n+{\n+  register char *fmt;\n+  register int i;\n+\n+  if (GET_RTX_CLASS (GET_CODE (pat)) == '<')\n+    {\n+      PUT_CODE (pat, swap_condition (GET_CODE (pat)));\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n+\t    swap_rtx_condition (XVECEXP (pat, i, j));\n+\t}\n+      else if (fmt[i] == 'e')\n+\tswap_rtx_condition (XEXP (pat, i));\n+    }\n+}\n+\n /* Handle a comparison.  Special care needs to be taken to avoid\n    causing comparisons that a 387 cannot do correctly, such as EQ.\n \n@@ -1714,11 +1765,25 @@ compare_for_stack_reg (insn, regstack, pat)\n   src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n   src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n \n-  /* The first argument must always be a stack reg. */\n-  /* ??? why? */\n+  /* ??? If fxch turns out to be cheaper than fstp, give priority to\n+     registers that die in this insn - move those to stack top first. */\n+  if (! STACK_REG_P (*src1)\n+      || (STACK_REG_P (*src2)\n+\t  && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))\n+    {\n+      rtx temp, next;\n \n-  if (! STACK_REG_P (*src1))\n-    abort ();\n+      temp = *src1;\n+      *src1 = *src2;\n+      *src2 = temp;\n+\n+      next = next_cc0_user (insn);\n+      if (next == NULL_RTX)\n+\tabort ();\n+\n+      swap_rtx_condition (PATTERN (next));\n+      INSN_CODE (next) = -1;\n+    }\n \n   /* We will fix any death note later. */\n \n@@ -1727,9 +1792,9 @@ compare_for_stack_reg (insn, regstack, pat)\n   if (STACK_REG_P (*src2))\n     src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n   else\n-    src2_note = 0;\n+    src2_note = NULL_RTX;\n \n-  emit_swap_insn (insn, regstack, *src1, emit_insn_before);\n+  emit_swap_insn (insn, regstack, *src1);\n \n   replace_reg (src1, FIRST_STACK_REG);\n \n@@ -1748,8 +1813,7 @@ compare_for_stack_reg (insn, regstack, pat)\n      needed, and it was just handled. */\n \n   if (src2_note\n-      && ! (STACK_REG_P (*src1)\n-\t    && STACK_REG_P (*src2)\n+      && ! (STACK_REG_P (*src1) && STACK_REG_P (*src2)\n \t    && REGNO (*src1) == REGNO (*src2)))\n     {\n       /* As a special case, two regs may die in this insn if src2 is\n@@ -1790,7 +1854,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n      rtx pat;\n {\n   rtx *dest, *src;\n-  rtx *src1 = 0, *src2;\n+  rtx *src1 = (rtx *) NULL_PTR, *src2;\n   rtx src1_note, src2_note;\n \n   if (GET_CODE (pat) != SET)\n@@ -1840,7 +1904,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \tif (src1 == 0)\n \t  src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n \n-\temit_swap_insn (insn, regstack, *src1, emit_insn_before);\n+\temit_swap_insn (insn, regstack, *src1);\n \n \tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \n@@ -1878,26 +1942,22 @@ subst_stack_regs_pat (insn, regstack, pat)\n \tif (STACK_REG_P (*src1))\n \t  src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \telse\n-\t  src1_note = 0;\n+\t  src1_note = NULL_RTX;\n \tif (STACK_REG_P (*src2))\n \t  src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n \telse\n-\t  src2_note = 0;\n+\t  src2_note = NULL_RTX;\n \n \t/* If either operand is not a stack register, then the dest\n \t   must be top of stack. */\n \n \tif (! STACK_REG_P (*src1) || ! STACK_REG_P (*src2))\n-\t  emit_swap_insn (insn, regstack, *dest, emit_insn_before);\n+\t  emit_swap_insn (insn, regstack, *dest);\n \telse\n \t  {\n \t    /* Both operands are REG.  If neither operand is already\n \t       at the top of stack, choose to make the one that is the dest\n-\t       the new top of stack.\n-\n-\t       ??? A later optimization here would be to look forward\n-\t       in the insns and see which source reg will be needed at top\n-\t       of stack soonest. */\n+\t       the new top of stack.  */\n \n \t    int src1_hard_regnum, src2_hard_regnum;\n \n@@ -1908,7 +1968,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \n \t    if (src1_hard_regnum != FIRST_STACK_REG\n \t\t&& src2_hard_regnum != FIRST_STACK_REG)\n-\t      emit_swap_insn (insn, regstack, *dest, emit_insn_before);\n+\t      emit_swap_insn (insn, regstack, *dest);\n \t  }\n \n \tif (STACK_REG_P (*src1))\n@@ -1985,7 +2045,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \n \t    src1 = get_true_reg (&XVECEXP (SET_SRC (pat), 0, 0));\n \n-\t    emit_swap_insn (insn, regstack, *src1, emit_insn_before);\n+\t    emit_swap_insn (insn, regstack, *src1);\n \n \t    src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \n@@ -2479,8 +2539,7 @@ change_stack (insn, old, new, when)\n \t\tabort ();\n \n \t      emit_swap_insn (insn, old,\n-\t\t\t      FP_mode_reg[old->reg[reg]][(int) DFmode],\n-\t\t\t      emit_insn_before);\n+\t\t\t      FP_mode_reg[old->reg[reg]][(int) DFmode]);\n \t    }\n \n \t  /* See if any regs remain incorrect.  If so, bring an\n@@ -2491,8 +2550,7 @@ change_stack (insn, old, new, when)\n \t    if (new->reg[reg] != old->reg[reg])\n \t      {\n \t\temit_swap_insn (insn, old,\n-\t\t\t\tFP_mode_reg[old->reg[reg]][(int) DFmode],\n-\t\t\t\temit_insn_before);\n+\t\t\t\tFP_mode_reg[old->reg[reg]][(int) DFmode]);\n \t\tbreak;\n \t      }\n \t} while (reg >= 0);"}]}