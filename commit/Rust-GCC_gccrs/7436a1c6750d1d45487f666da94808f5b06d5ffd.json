{"sha": "7436a1c6750d1d45487f666da94808f5b06d5ffd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQzNmExYzY3NTBkMWQ0NTQ4N2Y2NjZkYTk0ODA4ZjViMDZkNWZmZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2019-12-10T22:07:57Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2019-12-10T22:07:57Z"}, "message": "re PR rtl-optimization/92796 (ICE in lra_assign, at lra-assigns.c:1646 on powerpc64le-linux-gnu)\n\n2019-12-10  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/92796\n\t* lra-int.h (lra_risky_transformations_p): Rename to\n\tcheck_and_force_assignment_correctness_p.\n\t* lra-assigns.c: Ditto.\n\t(lra_assign): Reset check_and_force_assignment_correctness_p.\n\t* lra-constraints.c (lra_risky_transformations_p): Rename to\n\tcheck_and_force_assignment_correctness_p.\n\t(lra_constraints): Set up check_and_force_assignment_correctness_p\n\tonly for the 1st sub-pass.\n\t* lra-eliminations.c (process_insn_for_elimination): Set up\n\tcheck_and_force_assignment_correctness_p if the insn chnaged its\n\tcode.\n\n2019-12-10  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/92796\n\t* gcc.target/powerpc/pr92796.c: New test.\n\nFrom-SVN: r279204", "tree": {"sha": "75b58a637f57ab78d67ca56bb89c2da702305d23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75b58a637f57ab78d67ca56bb89c2da702305d23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7436a1c6750d1d45487f666da94808f5b06d5ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7436a1c6750d1d45487f666da94808f5b06d5ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7436a1c6750d1d45487f666da94808f5b06d5ffd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7436a1c6750d1d45487f666da94808f5b06d5ffd/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0cc063af32311944d66b6537aeade08038cabba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cc063af32311944d66b6537aeade08038cabba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cc063af32311944d66b6537aeade08038cabba9"}], "stats": {"total": 81, "additions": 66, "deletions": 15}, "files": [{"sha": "c8ff6941d8fdde08c049556ccdd5eae070aaa5a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7436a1c6750d1d45487f666da94808f5b06d5ffd", "patch": "@@ -1,3 +1,18 @@\n+2019-12-10  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/92796\n+\t* lra-int.h (lra_risky_transformations_p): Rename to\n+\tcheck_and_force_assignment_correctness_p.\n+\t* lra-assigns.c: Ditto.\n+\t(lra_assign): Reset check_and_force_assignment_correctness_p.\n+\t* lra-constraints.c (lra_risky_transformations_p): Rename to\n+\tcheck_and_force_assignment_correctness_p.\n+\t(lra_constraints): Set up check_and_force_assignment_correctness_p\n+\tonly for the 1st sub-pass.\n+\t* lra-eliminations.c (process_insn_for_elimination): Set up\n+\tcheck_and_force_assignment_correctness_p if the insn chnaged its\n+\tcode.\n+\n 2019-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/92882"}, {"sha": "532b065e2c4af4d301320afa45e96c273a09b284", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=7436a1c6750d1d45487f666da94808f5b06d5ffd", "patch": "@@ -1131,7 +1131,7 @@ static int *sorted_pseudos;\n /* The constraints pass is allowed to create equivalences between\n    pseudos that make the current allocation \"incorrect\" (in the sense\n    that pseudos are assigned to hard registers from their own conflict\n-   sets).  The global variable lra_risky_transformations_p says\n+   sets).  The global variable check_and_force_assignment_correctness_p says\n    whether this might have happened.\n \n    Process pseudos assigned to hard registers (less frequently used\n@@ -1152,7 +1152,7 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n   bitmap_iterator bi;\n   int max_regno = max_reg_num ();\n \n-  if (! lra_risky_transformations_p)\n+  if (! check_and_force_assignment_correctness_p)\n     {\n       for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n \tif (reg_renumber[i] >= 0 && lra_reg_info[i].nrefs > 0)\n@@ -1690,6 +1690,8 @@ lra_assign (bool &fails_p)\n     internal_error\n       (\"maximum number of LRA assignment passes is achieved (%d)\",\n        LRA_MAX_ASSIGNMENT_ITERATION_NUMBER);\n+  /* Reset the assignment correctness flag: */\n+  check_and_force_assignment_correctness_p = false;\n   return no_spills_p;\n }\n "}, {"sha": "9e0f50ea88c413fc7f51dc1160ce62408dbff3fa", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=7436a1c6750d1d45487f666da94808f5b06d5ffd", "patch": "@@ -4665,11 +4665,14 @@ loc_equivalence_callback (rtx loc, const_rtx, void *data)\n /* The current iteration number of this LRA pass.  */\n int lra_constraint_iter;\n \n-/* True if we substituted equiv which needs checking register\n-   allocation correctness because the equivalent value contains\n-   allocatable hard registers or when we restore multi-register\n-   pseudo.  */\n-bool lra_risky_transformations_p;\n+/* True if we should during assignment sub-pass check assignment\n+   correctness for all pseudos and spill some of them to correct\n+   conflicts.  It can be necessary when we substitute equiv which\n+   needs checking register allocation correctness because the\n+   equivalent value contains allocatable hard registers, or when we\n+   restore multi-register pseudo, or when we change the insn code and\n+   its operand became INOUT operand when it was IN one before.  */\n+bool check_and_force_assignment_correctness_p;\n \n /* Return true if REGNO is referenced in more than one block.  */\n static bool\n@@ -4811,14 +4814,14 @@ lra_constraints (bool first_p)\n   changed_p = false;\n   if (pic_offset_table_rtx\n       && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)\n-    lra_risky_transformations_p = true;\n-  else\n+    check_and_force_assignment_correctness_p = true;\n+  else if (first_p)\n     /* On the first iteration we should check IRA assignment\n        correctness.  In rare cases, the assignments can be wrong as\n        early clobbers operands are ignored in IRA or usages of\n        paradoxical sub-registers are not taken into account by\n        IRA.  */\n-    lra_risky_transformations_p = first_p;\n+    check_and_force_assignment_correctness_p = true;\n   new_insn_uid_start = get_max_uid ();\n   new_regno_start = first_p ? lra_constraint_new_regno_start : max_reg_num ();\n   /* Mark used hard regs for target stack size calulations.  */\n@@ -4994,7 +4997,7 @@ lra_constraints (bool first_p)\n \t\t      dump_insn_slim (lra_dump_file, curr_insn);\n \t\t    }\n \t\t  if (contains_reg_p (x, true, false))\n-\t\t    lra_risky_transformations_p = true;\n+\t\t    check_and_force_assignment_correctness_p = true;\n \t\t  lra_set_insn_deleted (curr_insn);\n \t\t  continue;\n \t\t}\n@@ -5507,7 +5510,7 @@ need_for_split_p (HARD_REG_SET potential_reload_hard_regs, int regno)\n \t   /* Don't split call clobbered hard regs living through\n \t      calls, otherwise we might have a check problem in the\n \t      assign sub-pass as in the most cases (exception is a\n-\t      situation when lra_risky_transformations_p value is\n+\t      situation when check_and_force_assignment_correctness_p value is\n \t      true) the assign pass assumes that all pseudos living\n \t      through calls are assigned to call saved hard regs.  */\n \t   && (regno >= FIRST_PSEUDO_REGISTER\n@@ -5799,7 +5802,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n        sub-register levels, LRA do this on pseudos level right now and\n        this discrepancy may create allocation conflicts after\n        splitting.  */\n-    lra_risky_transformations_p = true;\n+    check_and_force_assignment_correctness_p = true;\n   if (lra_dump_file != NULL)\n     fprintf (lra_dump_file,\n \t     \"\t  ))))))))))))))))))))))))))))))))))))))))))))))))\\n\");\n@@ -6561,7 +6564,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t\t\t\t\t before_p, curr_insn, max_uid))\n \t\t\t{\n \t\t\t  if (reg->subreg_p)\n-\t\t\t    lra_risky_transformations_p = true;\n+\t\t\t    check_and_force_assignment_correctness_p = true;\n \t\t\t  change_p = true;\n \t\t\t  /* Invalidate. */\n \t\t\t  usage_insns[src_regno].check = 0;"}, {"sha": "3c8ac77fd88d404fa188b602b35a8bb68cbc1643", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=7436a1c6750d1d45487f666da94808f5b06d5ffd", "patch": "@@ -1311,6 +1311,11 @@ process_insn_for_elimination (rtx_insn *insn, bool final_p, bool first_p)\n \n       if (icode >= 0 && icode != INSN_CODE (insn))\n \t{\n+\t  if (INSN_CODE (insn) >= 0)\n+\t    /* Insn code is changed.  It may change its operand type\n+\t       from IN to INOUT.  Inform the subsequent assignment\n+\t       subpass about this situation.  */\n+\t    check_and_force_assignment_correctness_p = true;\n \t  INSN_CODE (insn) = icode;\n \t  lra_update_insn_recog_data (insn);\n \t}"}, {"sha": "a103c7d537df174604f694009174d1f5b5d06253", "filename": "gcc/lra-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=7436a1c6750d1d45487f666da94808f5b06d5ffd", "patch": "@@ -337,7 +337,7 @@ extern void lra_init_equiv (void);\n extern int lra_constraint_offset (int, machine_mode);\n \n extern int lra_constraint_iter;\n-extern bool lra_risky_transformations_p;\n+extern bool check_and_force_assignment_correctness_p;\n extern int lra_inheritance_iter;\n extern int lra_undo_inheritance_iter;\n extern bool lra_constrain_insn (rtx_insn *);"}, {"sha": "2ce9f6a38fd18e7c1e7803b2ebfde58b59ed4a6a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7436a1c6750d1d45487f666da94808f5b06d5ffd", "patch": "@@ -1,3 +1,8 @@\n+2019-12-10  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/92796\n+\t* gcc.target/powerpc/pr92796.c: New test.\n+\n 2019-12-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/91643"}, {"sha": "aa15b2d07e5383b8042d83b3e6b9b242847528cb", "filename": "gcc/testsuite/gcc.target/powerpc/pr92796.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92796.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7436a1c6750d1d45487f666da94808f5b06d5ffd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92796.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92796.c?ref=7436a1c6750d1d45487f666da94808f5b06d5ffd", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-protector-strong -mcpu=power8\" } */\n+\n+typedef union\n+{\n+  __ieee128 a;\n+  int b;\n+} c;\n+\n+__ieee128\n+d (__ieee128 x)\n+{\n+  __ieee128 g;\n+  c h;\n+  h.a = x;\n+  g = h.b & 5;\n+  h.b = g;\n+  if (g)\n+    return x - x;\n+  return h.a;\n+}"}]}