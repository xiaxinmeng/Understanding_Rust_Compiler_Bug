{"sha": "7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjNGQ2MDAwYTBkNmM4NDdjNGMwNzM3M2ZiZDRhMTdlNTRjNjc4Zg==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-15T07:19:28Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-15T10:48:50Z"}, "message": "Optimize for V{8,16,32}HFmode vec_set/extract/init.\n\ngcc/ChangeLog:\n\n\tPR target/102327\n\t* config/i386/i386-expand.c\n\t(ix86_expand_vector_init_interleave): Use puncklwd to pack 2\n\tHFmodes.\n\t(ix86_expand_vector_set): Use blendw instead of pinsrw.\n\t* config/i386/i386.c (ix86_can_change_mode_class): Adjust for\n\tAVX512FP16 which supports 16bit vector load.\n\t* config/i386/sse.md (avx512bw_interleave_highv32hi<mask_name>):\n\tRename to ..\n\t(avx512bw_interleave_high<mode><mask_name>): .. this, and\n\textend to V32HFmode.\n\t(avx2_interleave_highv16hi<mask_name>): Rename to ..\n\t(avx2_interleave_high<mode><mask_name>): .. this, and extend\n\tto V16HFmode.\n\t(vec_interleave_highv8hi<mask_name>): Rename to ..\n\t(vec_interleave_high<mode><mask_name>): .. this, and extend to V8HFmode.\n\t(<mask_codefor>avx512bw_interleave_lowv32hi<mask_name>):\n\tRename to ..\n\t(<mask_codefor>avx512bw_interleave_low<mode><mask_name>):\n\tthis, and extend to V32HFmode.\n\t(avx2_interleave_lowv16hi<mask_name>): Rename to ..\n\t(avx2_interleave_low<mode><mask_name>): .. this, and extend to V16HFmode.\n\t(vec_interleave_lowv8hi<mask_name>): Rename to ..\n\t(vec_interleave_low<mode><mask_name>): .. this, and extend to V8HFmode.\n\t(sse4_1_pblendw): Rename to ..\n\t(sse4_1_pblend<blendsuf>): .. this, and extend to V8HFmode.\n\t(avx2_pblendph): New define_expand.\n\t(<sse2p4_1>_pinsr<ssemodesuffix>): Refactor, use\n\tsseintmodesuffix instead of ssemodesuffix.\n\t(blendsuf): New mode attr.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr102327-1.c: New test.\n\t* gcc.target/i386/pr102327-2.c: New test.\n\t* gcc.target/i386/avx512fp16-1c.c: Adjust testcase.", "tree": {"sha": "6b2188253a0aea36ea615c78b22db7ebdeb939ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b2188253a0aea36ea615c78b22db7ebdeb939ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feebc22ba934f154aad6d8cad6cce0adf1d4610e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feebc22ba934f154aad6d8cad6cce0adf1d4610e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feebc22ba934f154aad6d8cad6cce0adf1d4610e"}], "stats": {"total": 444, "additions": 343, "deletions": 101}, "files": [{"sha": "84acaa221511e349e535f485c8ff091d2b151be1", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 59, "deletions": 36, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "patch": "@@ -14069,7 +14069,7 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n \t  tmp1 = gen_reg_rtx (SImode);\n \t  emit_move_insn (tmp1, gen_lowpart (SImode, val));\n \n-\t  /* Insert the SImode value as low element of a V4SImode vector. */\n+\t  /* Insert the SImode value as low element of a V4SImode vector.  */\n \t  tmp2 = gen_reg_rtx (V4SImode);\n \t  emit_insn (gen_vec_setv4si_0 (tmp2, CONST0_RTX (V4SImode), tmp1));\n \t  emit_move_insn (dperm.op0, gen_lowpart (mode, tmp2));\n@@ -14653,7 +14653,7 @@ ix86_expand_vector_init_interleave (machine_mode mode,\n   switch (mode)\n     {\n     case E_V8HFmode:\n-      gen_load_even = gen_vec_setv8hf;\n+      gen_load_even = gen_vec_interleave_lowv8hf;\n       gen_interleave_first_low = gen_vec_interleave_lowv4si;\n       gen_interleave_second_low = gen_vec_interleave_lowv2di;\n       inner_mode = HFmode;\n@@ -14688,35 +14688,40 @@ ix86_expand_vector_init_interleave (machine_mode mode,\n       op = ops [i + i];\n       if (inner_mode == HFmode)\n \t{\n-\t  /* Convert HFmode to HImode.  */\n-\t  op1 = gen_reg_rtx (HImode);\n-\t  op1 = gen_rtx_SUBREG (HImode, force_reg (HFmode, op), 0);\n-\t  op = gen_reg_rtx (HImode);\n-\t  emit_move_insn (op, op1);\n+\t  rtx even, odd;\n+\t  /* Use vpuncklwd to pack 2 HFmode.  */\n+\t  op0 = gen_reg_rtx (V8HFmode);\n+\t  even = lowpart_subreg (V8HFmode, force_reg (HFmode, op), HFmode);\n+\t  odd = lowpart_subreg (V8HFmode,\n+\t\t\t\tforce_reg (HFmode, ops[i + i + 1]),\n+\t\t\t\tHFmode);\n+\t  emit_insn (gen_load_even (op0, even, odd));\n \t}\n+      else\n+\t{\n+\t  /* Extend the odd elment to SImode using a paradoxical SUBREG.  */\n+\t  op0 = gen_reg_rtx (SImode);\n+\t  emit_move_insn (op0, gen_lowpart (SImode, op));\n \n-      /* Extend the odd elment to SImode using a paradoxical SUBREG.  */\n-      op0 = gen_reg_rtx (SImode);\n-      emit_move_insn (op0, gen_lowpart (SImode, op));\n-\n-      /* Insert the SImode value as low element of V4SImode vector. */\n-      op1 = gen_reg_rtx (V4SImode);\n-      op0 = gen_rtx_VEC_MERGE (V4SImode,\n-\t\t\t       gen_rtx_VEC_DUPLICATE (V4SImode,\n-\t\t\t\t\t\t      op0),\n-\t\t\t       CONST0_RTX (V4SImode),\n-\t\t\t       const1_rtx);\n-      emit_insn (gen_rtx_SET (op1, op0));\n+\t  /* Insert the SImode value as low element of V4SImode vector.  */\n+\t  op1 = gen_reg_rtx (V4SImode);\n+\t  op0 = gen_rtx_VEC_MERGE (V4SImode,\n+\t\t\t\t   gen_rtx_VEC_DUPLICATE (V4SImode,\n+\t\t\t\t\t\t\t  op0),\n+\t\t\t\t   CONST0_RTX (V4SImode),\n+\t\t\t\t   const1_rtx);\n+\t  emit_insn (gen_rtx_SET (op1, op0));\n \n-      /* Cast the V4SImode vector back to a vector in orignal mode.  */\n-      op0 = gen_reg_rtx (mode);\n-      emit_move_insn (op0, gen_lowpart (mode, op1));\n+\t  /* Cast the V4SImode vector back to a vector in orignal mode.  */\n+\t  op0 = gen_reg_rtx (mode);\n+\t  emit_move_insn (op0, gen_lowpart (mode, op1));\n \n-      /* Load even elements into the second position.  */\n-      emit_insn (gen_load_even (op0,\n-\t\t\t\tforce_reg (inner_mode,\n-\t\t\t\t\t   ops [i + i + 1]),\n-\t\t\t\tconst1_rtx));\n+\t  /* Load even elements into the second position.  */\n+\t  emit_insn (gen_load_even (op0,\n+\t\t\t\t    force_reg (inner_mode,\n+\t\t\t\t\t       ops[i + i + 1]),\n+\t\t\t\t    const1_rtx));\n+\t}\n \n       /* Cast vector to FIRST_IMODE vector.  */\n       ops[i] = gen_reg_rtx (first_imode);\n@@ -15197,6 +15202,7 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n   machine_mode inner_mode = GET_MODE_INNER (mode);\n   machine_mode half_mode;\n   bool use_vec_merge = false;\n+  bool blendm_const = false;\n   rtx tmp;\n   static rtx (*gen_extract[7][2]) (rtx, rtx)\n     = {\n@@ -15384,7 +15390,14 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n       return;\n \n     case E_V8HFmode:\n-      use_vec_merge = true;\n+      if (TARGET_AVX2)\n+\t{\n+\t  mmode = SImode;\n+\t  gen_blendm = gen_sse4_1_pblendph;\n+\t  blendm_const = true;\n+\t}\n+      else\n+\tuse_vec_merge = true;\n       break;\n \n     case E_V8HImode:\n@@ -15411,10 +15424,20 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n       goto half;\n \n     case E_V16HFmode:\n-      half_mode = V8HFmode;\n-      j = 6;\n-      n = 8;\n-      goto half;\n+      if (TARGET_AVX2)\n+\t{\n+\t  mmode = SImode;\n+\t  gen_blendm = gen_avx2_pblendph;\n+\t  blendm_const = true;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  half_mode = V8HFmode;\n+\t  j = 6;\n+\t  n = 8;\n+\t  goto half;\n+\t}\n \n     case E_V16HImode:\n       half_mode = V8HImode;\n@@ -15575,15 +15598,15 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n     {\n       tmp = gen_reg_rtx (mode);\n       emit_insn (gen_rtx_SET (tmp, gen_rtx_VEC_DUPLICATE (mode, val)));\n+      rtx merge_mask = gen_int_mode (HOST_WIDE_INT_1U << elt, mmode);\n       /* The avx512*_blendm<mode> expanders have different operand order\n \t from VEC_MERGE.  In VEC_MERGE, the first input operand is used for\n \t elements where the mask is set and second input operand otherwise,\n \t in {sse,avx}*_*blend* the first input operand is used for elements\n \t where the mask is clear and second input operand otherwise.  */\n-      emit_insn (gen_blendm (target, target, tmp,\n-\t\t\t     force_reg (mmode,\n-\t\t\t\t\tgen_int_mode (HOST_WIDE_INT_1U << elt,\n-\t\t\t\t\t\t      mmode))));\n+      if (!blendm_const)\n+\tmerge_mask = force_reg (mmode, merge_mask);\n+      emit_insn (gen_blendm (target, target, tmp, merge_mask));\n     }\n   else if (use_vec_merge)\n     {"}, {"sha": "d7abff0f396cf6207182b73ee7a8b3124cdef2ad", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "patch": "@@ -19443,8 +19443,11 @@ ix86_can_change_mode_class (machine_mode from, machine_mode to,\n       /* Vector registers do not support QI or HImode loads.  If we don't\n \t disallow a change to these modes, reload will assume it's ok to\n \t drop the subreg from (subreg:SI (reg:HI 100) 0).  This affects\n-\t the vec_dupv4hi pattern.  */\n-      if (GET_MODE_SIZE (from) < 4)\n+\t the vec_dupv4hi pattern.\n+\t NB: AVX512FP16 supports vmovw which can load 16bit data to sse\n+\t register.  */\n+      int mov_size = MAYBE_SSE_CLASS_P (regclass) && TARGET_AVX512FP16 ? 2 : 4;\n+      if (GET_MODE_SIZE (from) < mov_size)\n \treturn false;\n     }\n "}, {"sha": "a1d419292d15481e555e3d72f2083047f5b8abab", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 116, "deletions": 60, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "patch": "@@ -817,6 +817,7 @@\n    (V8SF \"TARGET_AVX512VL\") (V4DF \"TARGET_AVX512VL\")\n    V16SF V8DF])\n \n+(define_mode_iterator V8_128 [V8HI V8HF])\n (define_mode_iterator V16_256 [V16HI V16HF])\n (define_mode_iterator V32_512 [V32HI V32HF])\n \n@@ -9950,16 +9951,33 @@\n   \"operands[1] = gen_lowpart (HFmode, operands[1]);\")\n \n (define_insn \"*vec_extracthf\"\n-  [(set (match_operand:HF 0 \"register_sse4nonimm_operand\" \"=r,m\")\n+  [(set (match_operand:HF 0 \"register_sse4nonimm_operand\" \"=*r,m,x,v\")\n \t(vec_select:HF\n-\t  (match_operand:V8HF 1 \"register_operand\" \"v,v\")\n+\t  (match_operand:V8HF 1 \"register_operand\" \"v,v,0,v\")\n \t  (parallel\n \t    [(match_operand:SI 2 \"const_0_to_7_operand\")])))]\n   \"TARGET_SSE2\"\n-  \"@\n-   vpextrw\\t{%2, %1, %k0|%k0, %1, %2}\n-   vpextrw\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sselog1\")\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"vpextrw\\t{%2, %1, %k0|%k0, %1, %2}\";\n+    case 1:\n+      return \"vpextrw\\t{%2, %1, %0|%0, %1, %2}\";\n+\n+    case 2:\n+      operands[2] = GEN_INT (INTVAL (operands[2]) * 2);\n+      return \"psrldq\\t{%2, %0|%0, %2}\";\n+    case 3:\n+      operands[2] = GEN_INT (INTVAL (operands[2]) * 2);\n+      return \"vpsrldq\\t{%2, %1, %0|%0, %1, %2}\";\n+\n+    default:\n+      gcc_unreachable ();\n+   }\n+}\n+  [(set_attr \"isa\" \"*,*,noavx,avx\")\n+   (set_attr \"type\" \"sselog1,sselog1,sseishft1,sseishft1\")\n    (set_attr \"prefix\" \"maybe_evex\")\n    (set_attr \"mode\" \"TI\")])\n \n@@ -15430,12 +15448,12 @@\n    (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"avx512bw_interleave_highv32hi<mask_name>\"\n-  [(set (match_operand:V32HI 0 \"register_operand\" \"=v\")\n-\t(vec_select:V32HI\n-\t  (vec_concat:V64HI\n-\t    (match_operand:V32HI 1 \"register_operand\" \"v\")\n-\t    (match_operand:V32HI 2 \"nonimmediate_operand\" \"vm\"))\n+(define_insn \"avx512bw_interleave_high<mode><mask_name>\"\n+  [(set (match_operand:V32_512 0 \"register_operand\" \"=v\")\n+\t(vec_select:V32_512\n+\t  (vec_concat:<ssedoublevecmode>\n+\t    (match_operand:V32_512 1 \"register_operand\" \"v\")\n+\t    (match_operand:V32_512 2 \"nonimmediate_operand\" \"vm\"))\n \t  (parallel [(const_int 4) (const_int 36)\n \t\t     (const_int 5) (const_int 37)\n \t\t     (const_int 6) (const_int 38)\n@@ -15458,12 +15476,12 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"XI\")])\n \n-(define_insn \"avx2_interleave_highv16hi<mask_name>\"\n-  [(set (match_operand:V16HI 0 \"register_operand\" \"=Yw\")\n-\t(vec_select:V16HI\n-\t  (vec_concat:V32HI\n-\t    (match_operand:V16HI 1 \"register_operand\" \"Yw\")\n-\t    (match_operand:V16HI 2 \"nonimmediate_operand\" \"Ywm\"))\n+(define_insn \"avx2_interleave_high<mode><mask_name>\"\n+  [(set (match_operand:V16_256 0 \"register_operand\" \"=Yw\")\n+\t(vec_select:V16_256\n+\t  (vec_concat:<ssedoublevecmode>\n+\t    (match_operand:V16_256 1 \"register_operand\" \"Yw\")\n+\t    (match_operand:V16_256 2 \"nonimmediate_operand\" \"Ywm\"))\n \t  (parallel [(const_int 4) (const_int 20)\n \t\t     (const_int 5) (const_int 21)\n \t\t     (const_int 6) (const_int 22)\n@@ -15478,12 +15496,12 @@\n    (set_attr \"prefix\" \"maybe_evex\")\n    (set_attr \"mode\" \"OI\")])\n \n-(define_insn \"vec_interleave_highv8hi<mask_name>\"\n-  [(set (match_operand:V8HI 0 \"register_operand\" \"=x,Yw\")\n-\t(vec_select:V8HI\n-\t  (vec_concat:V16HI\n-\t    (match_operand:V8HI 1 \"register_operand\" \"0,Yw\")\n-\t    (match_operand:V8HI 2 \"vector_operand\" \"xBm,Ywm\"))\n+(define_insn \"vec_interleave_high<mode><mask_name>\"\n+  [(set (match_operand:V8_128 0 \"register_operand\" \"=x,Yw\")\n+\t(vec_select:V8_128\n+\t  (vec_concat:<ssedoublevecmode>\n+\t    (match_operand:V8_128 1 \"register_operand\" \"0,Yw\")\n+\t    (match_operand:V8_128 2 \"vector_operand\" \"xBm,Ywm\"))\n \t  (parallel [(const_int 4) (const_int 12)\n \t\t     (const_int 5) (const_int 13)\n \t\t     (const_int 6) (const_int 14)\n@@ -15498,12 +15516,12 @@\n    (set_attr \"prefix\" \"orig,maybe_vex\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"<mask_codefor>avx512bw_interleave_lowv32hi<mask_name>\"\n-  [(set (match_operand:V32HI 0 \"register_operand\" \"=v\")\n-\t(vec_select:V32HI\n-\t  (vec_concat:V64HI\n-\t    (match_operand:V32HI 1 \"register_operand\" \"v\")\n-\t    (match_operand:V32HI 2 \"nonimmediate_operand\" \"vm\"))\n+(define_insn \"<mask_codefor>avx512bw_interleave_low<mode><mask_name>\"\n+  [(set (match_operand:V32_512 0 \"register_operand\" \"=v\")\n+\t(vec_select:V32_512\n+\t  (vec_concat:<ssedoublevecmode>\n+\t    (match_operand:V32_512 1 \"register_operand\" \"v\")\n+\t    (match_operand:V32_512 2 \"nonimmediate_operand\" \"vm\"))\n \t  (parallel [(const_int 0) (const_int 32)\n \t\t     (const_int 1) (const_int 33)\n \t\t     (const_int 2) (const_int 34)\n@@ -15526,12 +15544,12 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"XI\")])\n \n-(define_insn \"avx2_interleave_lowv16hi<mask_name>\"\n-  [(set (match_operand:V16HI 0 \"register_operand\" \"=Yw\")\n-\t(vec_select:V16HI\n-\t  (vec_concat:V32HI\n-\t    (match_operand:V16HI 1 \"register_operand\" \"Yw\")\n-\t    (match_operand:V16HI 2 \"nonimmediate_operand\" \"Ywm\"))\n+(define_insn \"avx2_interleave_low<mode><mask_name>\"\n+  [(set (match_operand:V16_256 0 \"register_operand\" \"=Yw\")\n+\t(vec_select:V16_256\n+\t  (vec_concat:<ssedoublevecmode>\n+\t    (match_operand:V16_256 1 \"register_operand\" \"Yw\")\n+\t    (match_operand:V16_256 2 \"nonimmediate_operand\" \"Ywm\"))\n \t  (parallel [(const_int 0) (const_int 16)\n \t\t     (const_int 1) (const_int 17)\n \t\t     (const_int 2) (const_int 18)\n@@ -15546,12 +15564,12 @@\n    (set_attr \"prefix\" \"maybe_evex\")\n    (set_attr \"mode\" \"OI\")])\n \n-(define_insn \"vec_interleave_lowv8hi<mask_name>\"\n-  [(set (match_operand:V8HI 0 \"register_operand\" \"=x,Yw\")\n-\t(vec_select:V8HI\n-\t  (vec_concat:V16HI\n-\t    (match_operand:V8HI 1 \"register_operand\" \"0,Yw\")\n-\t    (match_operand:V8HI 2 \"vector_operand\" \"xBm,Ywm\"))\n+(define_insn \"vec_interleave_low<mode><mask_name>\"\n+  [(set (match_operand:V8_128 0 \"register_operand\" \"=x,Yw\")\n+\t(vec_select:V8_128\n+\t  (vec_concat:<ssedoublevecmode>\n+\t    (match_operand:V8_128 1 \"register_operand\" \"0,Yw\")\n+\t    (match_operand:V8_128 2 \"vector_operand\" \"xBm,Ywm\"))\n \t  (parallel [(const_int 0) (const_int 8)\n \t\t     (const_int 1) (const_int 9)\n \t\t     (const_int 2) (const_int 10)\n@@ -15726,6 +15744,7 @@\n    (V4SI \"avx512dq\") (V2DI \"avx512dq\")])\n \n ;; sse4_1_pinsrd must come before sse2_loadld since it is preferred.\n+;; For V8HFmode and TARGET_AVX2, broadcastw + pblendw should be better.\n (define_insn \"<sse2p4_1>_pinsr<ssemodesuffix>\"\n   [(set (match_operand:PINSR_MODE 0 \"register_operand\" \"=x,x,x,x,v,v\")\n \t(vec_merge:PINSR_MODE\n@@ -15735,34 +15754,27 @@\n \t  (match_operand:SI 3 \"const_int_operand\")))]\n   \"TARGET_SSE2\n    && ((unsigned) exact_log2 (INTVAL (operands[3]))\n-       < GET_MODE_NUNITS (<MODE>mode))\"\n+       < GET_MODE_NUNITS (<MODE>mode))\n+   && !(<MODE>mode == V8HFmode && TARGET_AVX2)\"\n {\n   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));\n \n   switch (which_alternative)\n     {\n     case 0:\n       if (GET_MODE_SIZE (<ssescalarmode>mode) < GET_MODE_SIZE (SImode))\n-\treturn \"pinsr<ssemodesuffix>\\t{%3, %k2, %0|%0, %k2, %3}\";\n+\treturn \"pinsr<sseintmodesuffix>\\t{%3, %k2, %0|%0, %k2, %3}\";\n       /* FALLTHRU */\n     case 1:\n-      return \"pinsr<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\";\n+      return \"pinsr<sseintmodesuffix>\\t{%3, %2, %0|%0, %2, %3}\";\n     case 2:\n     case 4:\n       if (GET_MODE_SIZE (<ssescalarmode>mode) < GET_MODE_SIZE (SImode))\n-\t{\n-\t  if (<MODE>mode == V8HFmode)\n-\t    return \"vpinsrw\\t{%3, %k2, %1, %0|%0, %1, %k2, %3}\";\n-\t  else\n-\t    return \"vpinsr<ssemodesuffix>\\t{%3, %k2, %1, %0|%0, %1, %k2, %3}\";\n-\t}\n+\treturn \"vpinsr<sseintmodesuffix>\\t{%3, %k2, %1, %0|%0, %1, %k2, %3}\";\n       /* FALLTHRU */\n     case 3:\n     case 5:\n-      if (<MODE>mode == V8HFmode)\n-\treturn \"vpinsrw\\t{%3, %2, %1, %0|%0, %1, %2, %3}\";\n-      else\n-\treturn \"vpinsr<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\";\n+      return \"vpinsr<sseintmodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\";\n     default:\n       gcc_unreachable ();\n     }\n@@ -19250,11 +19262,14 @@\n \t  (lt:VI1_AVX2 (match_dup 3) (match_dup 4))] UNSPEC_BLENDV))]\n   \"operands[3] = gen_lowpart (<MODE>mode, operands[3]);\")\n \n-(define_insn \"sse4_1_pblendw\"\n-  [(set (match_operand:V8HI 0 \"register_operand\" \"=Yr,*x,x\")\n-\t(vec_merge:V8HI\n-\t  (match_operand:V8HI 2 \"vector_operand\" \"YrBm,*xBm,xm\")\n-\t  (match_operand:V8HI 1 \"register_operand\" \"0,0,x\")\n+(define_mode_attr blendsuf\n+  [(V8HI \"w\") (V8HF \"ph\")])\n+\n+(define_insn \"sse4_1_pblend<blendsuf>\"\n+  [(set (match_operand:V8_128 0 \"register_operand\" \"=Yr,*x,x\")\n+\t(vec_merge:V8_128\n+\t  (match_operand:V8_128 2 \"vector_operand\" \"YrBm,*xBm,xm\")\n+\t  (match_operand:V8_128 1 \"register_operand\" \"0,0,x\")\n \t  (match_operand:SI 3 \"const_0_to_255_operand\" \"n,n,n\")))]\n   \"TARGET_SSE4_1\"\n   \"@\n@@ -19281,6 +19296,47 @@\n   operands[3] = GEN_INT (val << 8 | val);\n })\n \n+(define_expand \"avx2_pblendph\"\n+  [(set (match_operand:V16HF 0 \"register_operand\")\n+\t(vec_merge:V16HF\n+\t  (match_operand:V16HF 2 \"register_operand\")\n+\t  (match_operand:V16HF 1 \"register_operand\")\n+\t  (match_operand:SI 3 \"const_int_operand\")))]\n+  \"TARGET_AVX2\n+  && !((INTVAL (operands[3]) & 0xff) && (INTVAL (operands[3]) & 0xff00))\"\n+{\n+  int mask = INTVAL (operands[3]);\n+  if (mask == 0)\n+    emit_move_insn (operands[0], operands[1]);\n+  else\n+   {\n+     rtx tmp = gen_reg_rtx (V16HImode);\n+     rtx blendw_idx, blendd_idx;\n+\n+     if (mask & 0xff)\n+       {\n+\t blendw_idx = GEN_INT (mask & 0xff);\n+\t blendd_idx = GEN_INT (15);\n+       }\n+     else\n+       {\n+\t blendw_idx = GEN_INT (mask >> 8 & 0xff);\n+\t blendd_idx = GEN_INT (240);\n+       }\n+     operands[1] = lowpart_subreg (V16HImode, operands[1], V16HFmode);\n+     operands[2] = lowpart_subreg (V16HImode, operands[2], V16HFmode);\n+     emit_insn (gen_avx2_pblendw (tmp, operands[1], operands[2], blendw_idx));\n+\n+     operands[0] = lowpart_subreg (V8SImode, operands[0], V16HFmode);\n+     tmp = lowpart_subreg (V8SImode, tmp, V16HImode);\n+     operands[1] = lowpart_subreg (V8SImode, operands[1], V16HImode);\n+     emit_insn (gen_avx2_pblenddv8si (operands[0], operands[1],\n+\t\t\t\t      tmp, blendd_idx));\n+  }\n+\n+  DONE;\n+})\n+\n (define_insn \"*avx2_pblendw\"\n   [(set (match_operand:V16HI 0 \"register_operand\" \"=x\")\n \t(vec_merge:V16HI"}, {"sha": "b41a90b7c9dc76497f2627119138211e32ebcbcb", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-1c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-1c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-1c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-1c.c?ref=7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-mavx512fp16 -O2\" } */\n-/* { dg-final { scan-assembler-times \"(?:vmovsh|vmovw)\" 2 { target { ! ia32 } } } }  */\n-/* { dg-final { scan-assembler-times \"vpinsrw\" 1 { target { ! ia32 } } } } */\n-/* { dg-final { scan-assembler-times \"vpinsrw\" 2 { target { ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"vmovsh\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"vpblendw\" 1 } } */\n+/* { dg-final { scan-assembler \"vpbroadcastw\" } }  */\n \n typedef _Float16 __v8hf __attribute__ ((__vector_size__ (16)));\n typedef _Float16 __m128h __attribute__ ((__vector_size__ (16), __may_alias__));"}, {"sha": "47439261b616a732024bbcfe8638b1082fd72787", "filename": "gcc/testsuite/gcc.target/i386/pr102327-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102327-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102327-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102327-1.c?ref=7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -mavx512vl -O2\" } */\n+\n+typedef _Float16 v8hf __attribute__((vector_size (16)));\n+typedef _Float16 v16hf __attribute__((vector_size (32)));\n+typedef _Float16 v32hf __attribute__((vector_size (64)));\n+\n+#define VEC_EXTRACT(V,S,IDX)\t\t\t\\\n+  S\t\t\t\t\t\t\\\n+  __attribute__((noipa))\t\t\t\\\n+  vec_extract_##V##_##IDX (V v)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return v[IDX];\t\t\t\t\\\n+  }\n+\n+#define VEC_SET(V,S,IDX)\t\t\t\\\n+  V\t\t\t\t\t\t\\\n+  __attribute__((noipa))\t\t\t\\\n+  vec_set_##V##_##IDX (V v, S s)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    v[IDX] = s;\t\t\t\t\\\n+    return v;\t\t\t\t\t\\\n+  }\n+\n+v8hf\n+vec_init_v8hf (_Float16 a1, _Float16 a2, _Float16 a3, _Float16 a4, _Float16 a5,\n+_Float16 a6, _Float16 a7, _Float16 a8)\n+{\n+    return __extension__ (v8hf) {a1, a2, a3, a4, a5, a6, a7, a8};\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpunpcklwd\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vpunpckldq\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vpunpcklqdq\" 1 } } */\n+\n+VEC_EXTRACT (v8hf, _Float16, 4);\n+VEC_EXTRACT (v16hf, _Float16, 3);\n+VEC_EXTRACT (v16hf, _Float16, 8);\n+VEC_EXTRACT (v16hf, _Float16, 15);\n+VEC_EXTRACT (v32hf, _Float16, 5);\n+VEC_EXTRACT (v32hf, _Float16, 8);\n+VEC_EXTRACT (v32hf, _Float16, 14);\n+VEC_EXTRACT (v32hf, _Float16, 16);\n+VEC_EXTRACT (v32hf, _Float16, 24);\n+VEC_EXTRACT (v32hf, _Float16, 28);\n+/* { dg-final { scan-assembler-times \"vpsrldq\\[\\t ]*\\\\\\$8\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vpsrldq\\[\\t ]*\\\\\\$6\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrldq\\[\\t ]*\\\\\\$14\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrldq\\[\\t ]*\\\\\\$10\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrldq\\[\\t ]*\\\\\\$12\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vextract\" 9 } } */\n+\n+VEC_SET (v8hf, _Float16, 4);\n+VEC_SET (v16hf, _Float16, 3);\n+VEC_SET (v16hf, _Float16, 8);\n+VEC_SET (v16hf, _Float16, 15);\n+VEC_SET (v32hf, _Float16, 5);\n+VEC_SET (v32hf, _Float16, 8);\n+VEC_SET (v32hf, _Float16, 14);\n+VEC_SET (v32hf, _Float16, 16);\n+VEC_SET (v32hf, _Float16, 24);\n+VEC_SET (v32hf, _Float16, 28);\n+/* { dg-final { scan-assembler-times \"vpbroadcastw\" 10 } } */\n+/* { dg-final { scan-assembler-times \"vpblendw\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vpblendd\" 3 } } */"}, {"sha": "363e4b65404061d08c959a5591d7297e838aeffd", "filename": "gcc/testsuite/gcc.target/i386/pr102327-2.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102327-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc4d6000a0d6c847c4c07373fbd4a17e54c678f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102327-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102327-2.c?ref=7fc4d6000a0d6c847c4c07373fbd4a17e54c678f", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx512vl -mavx512fp16\" } */\n+/* { dg-require-effective-target avx512vl } */\n+/* { dg-require-effective-target avx512fp16 } */\n+\n+#define AVX512VL\n+#define AVX512FP16\n+\n+#ifndef CHECK\n+#define CHECK \"avx512f-helper.h\"\n+#endif\n+\n+#include CHECK\n+#include \"pr102327-1.c\"\n+\n+#define RUNCHECK_VEC_EXTRACT(U,V,S,IDX)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      S tmp = vec_extract_##V##_##IDX ((V)U.x);\t\\\n+      if (tmp != U.a[IDX])\t\t\t\\\n+\tabort();\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define RUNCHECK_VEC_SET(UTYPE,U,V,S,IDX,NUM)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      S tmp = 3.0f;\t\t\t\t\t\\\n+      UTYPE res;\t\t\t\t\t\\\n+      res.x = vec_set_##V##_##IDX ((V)U.x, tmp);\t\\\n+      for (int i = 0; i != NUM; i++)\t\t\t\\\n+\tif (i == IDX)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\\\n+\t    if (res.a[i] != tmp)\t\t\t\\\n+\t      abort ();\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+\telse if (res.a[i] != U.a[i])\t\t\t\\\n+\t  abort();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+void\n+test_256 (void)\n+{\n+  union512h g1;\n+  union256h t1;\n+  union128h x1;\n+  int sign = 1;\n+\n+  int i = 0;\n+  for (i = 0; i < 32; i++)\n+    {\n+      g1.a[i] = 56.78 * (i - 30) * sign;\n+      sign = -sign;\n+    }\n+\n+  for (i = 0; i != 16; i++)\n+    {\n+      t1.a[i] = 90.12 * (i + 40) * sign;\n+      sign = -sign;\n+    }\n+\n+  for (i = 0; i != 8; i++)\n+    {\n+      x1.a[i] = 90.12 * (i + 40) * sign;\n+      sign = -sign;\n+    }\n+\n+  RUNCHECK_VEC_EXTRACT (x1, v8hf, _Float16, 4);\n+  RUNCHECK_VEC_EXTRACT (t1, v16hf, _Float16, 3);\n+  RUNCHECK_VEC_EXTRACT (t1, v16hf, _Float16, 8);\n+  RUNCHECK_VEC_EXTRACT (t1, v16hf, _Float16, 15);\n+  RUNCHECK_VEC_EXTRACT (g1, v32hf, _Float16, 5);\n+  RUNCHECK_VEC_EXTRACT (g1, v32hf, _Float16, 8);\n+  RUNCHECK_VEC_EXTRACT (g1, v32hf, _Float16, 14);\n+  RUNCHECK_VEC_EXTRACT (g1, v32hf, _Float16, 16);\n+  RUNCHECK_VEC_EXTRACT (g1, v32hf, _Float16, 24);\n+  RUNCHECK_VEC_EXTRACT (g1, v32hf, _Float16, 28);\n+\n+  RUNCHECK_VEC_SET (union128h, x1, v8hf, _Float16, 4, 8);\n+  RUNCHECK_VEC_SET (union256h, t1, v16hf, _Float16, 3, 16);\n+  RUNCHECK_VEC_SET (union256h, t1, v16hf, _Float16, 8, 16);\n+  RUNCHECK_VEC_SET (union256h, t1, v16hf, _Float16, 15, 16);\n+  RUNCHECK_VEC_SET (union512h, g1, v32hf, _Float16, 5, 32);\n+  RUNCHECK_VEC_SET (union512h, g1, v32hf, _Float16, 8, 32);\n+  RUNCHECK_VEC_SET (union512h, g1, v32hf, _Float16, 14, 32);\n+  RUNCHECK_VEC_SET (union512h, g1, v32hf, _Float16, 16, 32);\n+  RUNCHECK_VEC_SET (union512h, g1, v32hf, _Float16, 24, 32);\n+  RUNCHECK_VEC_SET (union512h, g1, v32hf, _Float16, 28, 32);\n+}\n+\n+void\n+test_128()\n+{\n+}"}]}