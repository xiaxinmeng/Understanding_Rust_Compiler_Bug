{"sha": "ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYxYjNmZGEzMmMwOGU5YmQ2OTc3Yjk2ZTFlNjE5YWFlM2UzNzI2YQ==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2013-11-04T21:33:31Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2013-11-04T21:33:31Z"}, "message": "libsanitizer merge from upstream r191666\n\nThis may break gcc-asan on Mac, will follow up separately.\n\nFrom-SVN: r204368", "tree": {"sha": "7cfc103c9b6b4ce7ca19d39f91509a1b68819a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cfc103c9b6b4ce7ca19d39f91509a1b68819a63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd5564d3c71195714c28ba150de7e9b90bf9c83d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd5564d3c71195714c28ba150de7e9b90bf9c83d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd5564d3c71195714c28ba150de7e9b90bf9c83d"}], "stats": {"total": 26089, "additions": 21183, "deletions": 4906}, "files": [{"sha": "e89177880eed9ea90eafbfea39595af7a47e6904", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -1,3 +1,17 @@\n+2013-11-04  Kostya Serebryany  <kcc@google.com>\n+\n+\tUpdate to match the changed asan API.\n+\t* asan.c (asan_function_start): New function.\n+\t(asan_emit_stack_protection): Update the string stored in the\n+\tstack red zone to match new API.  Store the PC of the current\n+\tfunction in the red zone.\n+\t(asan_global_struct): Update the __asan_global definition to match\n+\tthe new API.\n+\t(asan_add_global): Ditto.\n+\t* asan.h (asan_function_start): New prototype.\n+\t* final.c (final_start_function): Call asan_function_start.\n+\t* sanitizer.def (BUILT_IN_ASAN_INIT): Rename __asan_init_v1 to __asan_init_v3.\n+\n 2013-11-04  Wei Mi  <wmi@google.com>\n \n \t* gcc/config/i386/i386-c.c (ix86_target_macros_internal): Separate"}, {"sha": "fdca37755a9e4bc0c7162f7bcfb1c9ae643ce319", "filename": "gcc/asan.c", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -59,11 +59,13 @@ along with GCC; see the file COPYING3.  If not see\n \t if ((X & 7) + N - 1 > ShadowValue)\n \t   __asan_report_loadN(X);\n    Stores are instrumented similarly, but using __asan_report_storeN functions.\n-   A call too __asan_init() is inserted to the list of module CTORs.\n+   A call too __asan_init_vN() is inserted to the list of module CTORs.\n+   N is the version number of the AddressSanitizer API. The changes between the\n+   API versions are listed in libsanitizer/asan/asan_interface_internal.h.\n \n    The run-time library redefines malloc (so that redzone are inserted around\n    the allocated memory) and free (so that reuse of free-ed memory is delayed),\n-   provides __asan_report* and __asan_init functions.\n+   provides __asan_report* and __asan_init_vN functions.\n \n    Read more:\n    http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n@@ -125,9 +127,11 @@ along with GCC; see the file COPYING3.  If not see\n \n \twhere '(...){n}' means the content inside the parenthesis occurs 'n'\n \ttimes, with 'n' being the number of variables on the stack.\n+     \n+     3/ The following 8 bytes contain the PC of the current function which\n+     will be used by the run-time library to print an error message.\n \n-      3/ The following 16 bytes of the red zone have no particular\n-      format.\n+     4/ The following 8 bytes are reserved for internal use by the run-time.\n \n    The shadow memory for that stack layout is going to look like this:\n \n@@ -205,6 +209,9 @@ along with GCC; see the file COPYING3.  If not see\n        // Name of the global variable.\n        const void *__name;\n \n+       // Name of the module where the global variable is declared.\n+       const void *__module_name;\n+\n        // This is always set to NULL for now.\n        uptr __has_dynamic_init;\n      }\n@@ -914,6 +921,15 @@ asan_clear_shadow (rtx shadow_mem, HOST_WIDE_INT len)\n   add_int_reg_note (jump, REG_BR_PROB, REG_BR_PROB_BASE * 80 / 100);\n }\n \n+void\n+asan_function_start (void)\n+{\n+  section *fnsec = function_section (current_function_decl);\n+  switch_to_section (fnsec);\n+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LASANPC\",\n+                         current_function_funcdef_no);\n+}\n+\n /* Insert code to protect stack vars.  The prologue sequence should be emitted\n    directly, epilogue sequence returned.  BASE is the register holding the\n    stack base, against which OFFSETS array offsets are relative to, OFFSETS\n@@ -929,24 +945,20 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n \t\t\t    int length)\n {\n   rtx shadow_base, shadow_mem, ret, mem;\n+  char buf[30];\n   unsigned char shadow_bytes[4];\n   HOST_WIDE_INT base_offset = offsets[length - 1], offset, prev_offset;\n   HOST_WIDE_INT last_offset, last_size;\n   int l;\n   unsigned char cur_shadow_byte = ASAN_STACK_MAGIC_LEFT;\n-  tree str_cst;\n+  tree str_cst, decl, id;\n \n   if (shadow_ptr_types[0] == NULL_TREE)\n     asan_init_shadow_ptr_types ();\n \n   /* First of all, prepare the description string.  */\n   pretty_printer asan_pp;\n \n-  if (DECL_NAME (current_function_decl))\n-    pp_tree_identifier (&asan_pp, DECL_NAME (current_function_decl));\n-  else\n-    pp_string (&asan_pp, \"<unknown>\");\n-  pp_space (&asan_pp);\n   pp_decimal_int (&asan_pp, length / 2 - 1);\n   pp_space (&asan_pp);\n   for (l = length - 2; l; l -= 2)\n@@ -976,6 +988,20 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   emit_move_insn (mem, gen_int_mode (ASAN_STACK_FRAME_MAGIC, ptr_mode));\n   mem = adjust_address (mem, VOIDmode, GET_MODE_SIZE (ptr_mode));\n   emit_move_insn (mem, expand_normal (str_cst));\n+  mem = adjust_address (mem, VOIDmode, GET_MODE_SIZE (ptr_mode));\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LASANPC\", current_function_funcdef_no);\n+  id = get_identifier (buf);\n+  decl = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+                    VAR_DECL, id, char_type_node);\n+  SET_DECL_ASSEMBLER_NAME (decl, id);\n+  TREE_ADDRESSABLE (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  TREE_PUBLIC (decl) = 0;\n+  TREE_USED (decl) = 1;\n+  emit_move_insn (mem, expand_normal (build_fold_addr_expr (decl)));\n   shadow_base = expand_binop (Pmode, lshr_optab, base,\n \t\t\t      GEN_INT (ASAN_SHADOW_SHIFT),\n \t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n@@ -1924,20 +1950,21 @@ transform_statements (void)\n      uptr __size;\n      uptr __size_with_redzone;\n      const void *__name;\n+     const void *__module_name;\n      uptr __has_dynamic_init;\n    } type.  */\n \n static tree\n asan_global_struct (void)\n {\n-  static const char *field_names[5]\n+  static const char *field_names[6]\n     = { \"__beg\", \"__size\", \"__size_with_redzone\",\n-\t\"__name\", \"__has_dynamic_init\" };\n-  tree fields[5], ret;\n+\t\"__name\", \"__module_name\", \"__has_dynamic_init\" };\n+  tree fields[6], ret;\n   int i;\n \n   ret = make_node (RECORD_TYPE);\n-  for (i = 0; i < 5; i++)\n+  for (i = 0; i < 6; i++)\n     {\n       fields[i]\n \t= build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n@@ -1962,21 +1989,20 @@ asan_add_global (tree decl, tree type, vec<constructor_elt, va_gc> *v)\n {\n   tree init, uptr = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type)));\n   unsigned HOST_WIDE_INT size;\n-  tree str_cst, refdecl = decl;\n+  tree str_cst, module_name_cst, refdecl = decl;\n   vec<constructor_elt, va_gc> *vinner = NULL;\n \n-  pretty_printer asan_pp;\n+  pretty_printer asan_pp, module_name_pp;\n \n   if (DECL_NAME (decl))\n     pp_tree_identifier (&asan_pp, DECL_NAME (decl));\n   else\n     pp_string (&asan_pp, \"<unknown>\");\n-  pp_space (&asan_pp);\n-  pp_left_paren (&asan_pp);\n-  pp_string (&asan_pp, main_input_filename);\n-  pp_right_paren (&asan_pp);\n   str_cst = asan_pp_string (&asan_pp);\n \n+  pp_string (&module_name_pp, main_input_filename);\n+  module_name_cst = asan_pp_string (&module_name_pp);\n+\n   if (asan_needs_local_alias (decl))\n     {\n       char buf[20];\n@@ -2004,6 +2030,8 @@ asan_add_global (tree decl, tree type, vec<constructor_elt, va_gc> *v)\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE, build_int_cst (uptr, size));\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n \t\t\t  fold_convert (const_ptr_type_node, str_cst));\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n+\t\t\t  fold_convert (const_ptr_type_node, module_name_cst));\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE, build_int_cst (uptr, 0));\n   init = build_constructor (type, vinner);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n@@ -2158,7 +2186,7 @@ add_string_csts (void **slot, void *data)\n static GTY(()) tree asan_ctor_statements;\n \n /* Module-level instrumentation.\n-   - Insert __asan_init() into the list of CTORs.\n+   - Insert __asan_init_vN() into the list of CTORs.\n    - TODO: insert redzones around globals.\n  */\n "}, {"sha": "e56468424c9236c7ec5ef4102507b60f0193f417", "filename": "gcc/asan.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef TREE_ASAN\n #define TREE_ASAN\n \n+extern void asan_function_start (void);\n extern void asan_finish_file (void);\n extern rtx asan_emit_stack_protection (rtx, HOST_WIDE_INT *, tree *, int);\n extern bool asan_protect_global (tree);"}, {"sha": "399473296507df9159d442cc9575bfdfc7986e89", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -78,6 +78,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"params.h\"\n #include \"tree-pretty-print.h\" /* for dump_function_header */\n+#include \"asan.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -1738,6 +1739,9 @@ final_start_function (rtx first, FILE *file,\n \n   high_block_linenum = high_function_linenum = last_linenum;\n \n+  if (flag_sanitize & SANITIZE_ADDRESS)\n+    asan_function_start ();\n+\n   if (!DECL_IGNORED_P (current_function_decl))\n     debug_hooks->begin_prologue (last_linenum, last_filename);\n "}, {"sha": "0f45e9eead479b82076d9c9cbc3a07ee408af68b", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n    for other FEs by asan.c.  */\n \n /* Address Sanitizer */\n-DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_INIT, \"__asan_init_v1\",\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_INIT, \"__asan_init_v3\",\n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n /* Do not reorder the BUILT_IN_ASAN_REPORT* builtins, e.g. cfgcleanup.c\n    relies on this order.  */"}, {"sha": "8483842402f09050f423a42566d7de366c7b3d66", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -1,3 +1,9 @@\n+2013-11-04  Kostya Serebryany  <kcc@google.com>\n+\n+\t* g++.dg/asan/asan_test.cc: Update the test\n+\tto match the fresh asan run-time.\n+\t* c-c++-common/asan/stack-overflow-1.c: Ditto.\n+\n 2013-11-04  Ian Lance Taylor  <iant@google.com>\n \n \t* g++.dg/ext/sync-4.C: New test."}, {"sha": "c71765097104f16c5a95b7eca2d66a7a1c2ecc6a", "filename": "gcc/testsuite/c-c++-common/asan/stack-overflow-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstack-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstack-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstack-overflow-1.c?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -19,4 +19,5 @@ int main() {\n \n /* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ (in _*main (\\[^\\n\\r]*stack-overflow-1.c:16|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is\\[^\\n\\r]*frame <main>\" } */\n+/* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n+/* { dg-output \"\\[^\\n\\r]*in main.*stack-overflow-1.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "2df8c62cbb1157dd4024b1426a55e69c875f70b3", "filename": "gcc/testsuite/g++.dg/asan/asan_test.cc", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -204,16 +204,6 @@ TEST(AddressSanitizer, BitFieldNegativeTest) {\n   delete Ident(x);\n }\n \n-TEST(AddressSanitizer, OutOfMemoryTest) {\n-  size_t size = SANITIZER_WORDSIZE == 64 ? (size_t)(1ULL << 48) : (0xf0000000);\n-  EXPECT_EQ(0, realloc(0, size));\n-  EXPECT_EQ(0, realloc(0, ~Ident(0)));\n-  EXPECT_EQ(0, malloc(size));\n-  EXPECT_EQ(0, malloc(~Ident(0)));\n-  EXPECT_EQ(0, calloc(1, size));\n-  EXPECT_EQ(0, calloc(1, ~Ident(0)));\n-}\n-\n #if ASAN_NEEDS_SEGV\n namespace {\n \n@@ -497,42 +487,6 @@ TEST(AddressSanitizer, ManyStackObjectsTest) {\n   EXPECT_DEATH(Ident(ZZZ)[-1] = 0, ASAN_PCRE_DOTALL \"XXX.*YYY.*ZZZ\");\n }\n \n-NOINLINE static void Frame0(int frame, char *a, char *b, char *c) {\n-  char d[4] = {0};\n-  char *D = Ident(d);\n-  switch (frame) {\n-    case 3: a[5]++; break;\n-    case 2: b[5]++; break;\n-    case 1: c[5]++; break;\n-    case 0: D[5]++; break;\n-  }\n-}\n-NOINLINE static void Frame1(int frame, char *a, char *b) {\n-  char c[4] = {0}; Frame0(frame, a, b, c);\n-  break_optimization(0);\n-}\n-NOINLINE static void Frame2(int frame, char *a) {\n-  char b[4] = {0}; Frame1(frame, a, b);\n-  break_optimization(0);\n-}\n-NOINLINE static void Frame3(int frame) {\n-  char a[4] = {0}; Frame2(frame, a);\n-  break_optimization(0);\n-}\n-\n-TEST(AddressSanitizer, GuiltyStackFrame0Test) {\n-  EXPECT_DEATH(Frame3(0), \"located .*in frame <.*Frame0\");\n-}\n-TEST(AddressSanitizer, GuiltyStackFrame1Test) {\n-  EXPECT_DEATH(Frame3(1), \"located .*in frame <.*Frame1\");\n-}\n-TEST(AddressSanitizer, GuiltyStackFrame2Test) {\n-  EXPECT_DEATH(Frame3(2), \"located .*in frame <.*Frame2\");\n-}\n-TEST(AddressSanitizer, GuiltyStackFrame3Test) {\n-  EXPECT_DEATH(Frame3(3), \"located .*in frame <.*Frame3\");\n-}\n-\n NOINLINE void LongJmpFunc1(jmp_buf buf) {\n   // create three red zones for these two stack objects.\n   int a;"}, {"sha": "c7871e3295fe84e88682043f57efbd5db2aca117", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -1,3 +1,19 @@\n+2013-11-04  Kostya Serebryany  <kcc@google.com>\n+\n+\t* All source files: Merge from upstream r191666.\n+\t* merge.sh: Added lsan.\n+\t* configure.ac (AC_CONFIG_FILES): Added lsan.\n+\t* Makefile.am (SUBDIRS): Added lsan.\n+\t* sanitizer_common/Makefile.am (sanitizer_common_files): Added new fles.\n+\t* asan/Makefile.am (asan_files): Added new files.\n+\t(libasan_la_LIBADD): Added a dependency on lsan.\n+\t* lsan/Makefile.am: New file.\n+\t* asan/Makefile.in: Regenerate.\n+\t* lsan/Makefile.in: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* sanitizer_common/Makefile.in: Regenerate.\n+\n 2013-09-20  Alan Modra  <amodra@gmail.com>\n \n \t* configure: Regenerate."}, {"sha": "0431b147a16bc7af0e8f6fde6393c3d03aef6fec", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -1,4 +1,4 @@\n-175733\n+191666\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "15c11ecb2d72cf55d2fd7220afabd97d3757db13", "filename": "libsanitizer/Makefile.am", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.am?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -1,13 +1,13 @@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n \n if TSAN_SUPPORTED\n-SUBDIRS = interception sanitizer_common asan tsan ubsan\n+SUBDIRS = interception sanitizer_common lsan asan tsan ubsan\n else\n-SUBDIRS = interception sanitizer_common asan ubsan\n+SUBDIRS = interception sanitizer_common lsan asan ubsan\n endif\n \n if USING_MAC_INTERPOSE\n-SUBDIRS = sanitizer_common asan ubsan\n+SUBDIRS = sanitizer_common lsan asan ubsan\n endif\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS"}, {"sha": "47a8771c7831caa347430d7b74aea8070425e2a0", "filename": "libsanitizer/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -76,7 +76,7 @@ AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n \t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n ETAGS = etags\n CTAGS = ctags\n-DIST_SUBDIRS = interception sanitizer_common asan ubsan tsan\n+DIST_SUBDIRS = interception sanitizer_common lsan asan ubsan tsan\n ACLOCAL = @ACLOCAL@\n AMTAR = @AMTAR@\n AR = @AR@\n@@ -209,9 +209,9 @@ top_build_prefix = @top_build_prefix@\n top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n-@TSAN_SUPPORTED_FALSE@SUBDIRS = interception sanitizer_common asan ubsan\n-@TSAN_SUPPORTED_TRUE@SUBDIRS = interception sanitizer_common asan tsan ubsan\n-@USING_MAC_INTERPOSE_TRUE@SUBDIRS = sanitizer_common asan ubsan\n+@TSAN_SUPPORTED_FALSE@SUBDIRS = interception sanitizer_common lsan asan ubsan\n+@TSAN_SUPPORTED_TRUE@SUBDIRS = interception sanitizer_common lsan asan tsan ubsan\n+@USING_MAC_INTERPOSE_TRUE@SUBDIRS = sanitizer_common lsan asan ubsan\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "8764007ca4517fe365d379edf2ea265a01c75bdb", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -15,32 +15,31 @@ toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o\n \n asan_files = \\\n-\tasan_allocator.cc \\\n \tasan_allocator2.cc \\\n-\tasan_interceptors.cc \\\n-\tasan_mac.cc \\\n-\tasan_malloc_mac.cc \\\n-\tasan_new_delete.cc \\\n-\tasan_posix.cc \\\n-\tasan_rtl.cc \\\n-\tasan_stats.cc \\\n-\tasan_thread_registry.cc \\\n+\tasan_dll_thunk.cc \\\n \tasan_fake_stack.cc \\\n \tasan_globals.cc \\\n+\tasan_interceptors.cc \\\n \tasan_linux.cc \\\n+\tasan_mac.cc \\\n \tasan_malloc_linux.cc \\\n+\tasan_malloc_mac.cc \\\n \tasan_malloc_win.cc \\\n+\tasan_new_delete.cc \\\n \tasan_poisoning.cc \\\n+\tasan_posix.cc \\\n \tasan_report.cc \\\n+\tasan_rtl.cc \\\n \tasan_stack.cc \\\n+\tasan_stats.cc \\\n \tasan_thread.cc \\\n \tasan_win.cc\n \n libasan_la_SOURCES = $(asan_files)\n if USING_MAC_INTERPOSE\n-libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la\n+libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/lsan/libsanitizer_lsan.la\n else\n-libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la\n+libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/lsan/libsanitizer_lsan.la $(top_builddir)/interception/libinterception.la\n endif\n libasan_la_LIBADD += $(LIBSTDCXX_RAW_CXX_LDFLAGS)\n "}, {"sha": "be8b879b54952442481fff7aae6a2f797253409c", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -81,17 +81,18 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n @USING_MAC_INTERPOSE_FALSE@libasan_la_DEPENDENCIES = $(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+@USING_MAC_INTERPOSE_FALSE@\t$(top_builddir)/lsan/libsanitizer_lsan.la \\\n @USING_MAC_INTERPOSE_FALSE@\t$(top_builddir)/interception/libinterception.la \\\n @USING_MAC_INTERPOSE_FALSE@\t$(am__DEPENDENCIES_1)\n @USING_MAC_INTERPOSE_TRUE@libasan_la_DEPENDENCIES = $(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+@USING_MAC_INTERPOSE_TRUE@\t$(top_builddir)/lsan/libsanitizer_lsan.la \\\n @USING_MAC_INTERPOSE_TRUE@\t$(am__DEPENDENCIES_1)\n-am__objects_1 = asan_allocator.lo asan_allocator2.lo \\\n-\tasan_interceptors.lo asan_mac.lo asan_malloc_mac.lo \\\n-\tasan_new_delete.lo asan_posix.lo asan_rtl.lo asan_stats.lo \\\n-\tasan_thread_registry.lo asan_fake_stack.lo asan_globals.lo \\\n-\tasan_linux.lo asan_malloc_linux.lo asan_malloc_win.lo \\\n-\tasan_poisoning.lo asan_report.lo asan_stack.lo asan_thread.lo \\\n-\tasan_win.lo\n+am__objects_1 = asan_allocator2.lo asan_dll_thunk.lo \\\n+\tasan_fake_stack.lo asan_globals.lo asan_interceptors.lo \\\n+\tasan_linux.lo asan_mac.lo asan_malloc_linux.lo \\\n+\tasan_malloc_mac.lo asan_malloc_win.lo asan_new_delete.lo \\\n+\tasan_poisoning.lo asan_posix.lo asan_report.lo asan_rtl.lo \\\n+\tasan_stack.lo asan_stats.lo asan_thread.lo asan_win.lo\n am_libasan_la_OBJECTS = $(am__objects_1)\n libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n libasan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -260,32 +261,33 @@ ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o\n asan_files = \\\n-\tasan_allocator.cc \\\n \tasan_allocator2.cc \\\n-\tasan_interceptors.cc \\\n-\tasan_mac.cc \\\n-\tasan_malloc_mac.cc \\\n-\tasan_new_delete.cc \\\n-\tasan_posix.cc \\\n-\tasan_rtl.cc \\\n-\tasan_stats.cc \\\n-\tasan_thread_registry.cc \\\n+\tasan_dll_thunk.cc \\\n \tasan_fake_stack.cc \\\n \tasan_globals.cc \\\n+\tasan_interceptors.cc \\\n \tasan_linux.cc \\\n+\tasan_mac.cc \\\n \tasan_malloc_linux.cc \\\n+\tasan_malloc_mac.cc \\\n \tasan_malloc_win.cc \\\n+\tasan_new_delete.cc \\\n \tasan_poisoning.cc \\\n+\tasan_posix.cc \\\n \tasan_report.cc \\\n+\tasan_rtl.cc \\\n \tasan_stack.cc \\\n+\tasan_stats.cc \\\n \tasan_thread.cc \\\n \tasan_win.cc\n \n libasan_la_SOURCES = $(asan_files)\n @USING_MAC_INTERPOSE_FALSE@libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+@USING_MAC_INTERPOSE_FALSE@\t$(top_builddir)/lsan/libsanitizer_lsan.la \\\n @USING_MAC_INTERPOSE_FALSE@\t$(top_builddir)/interception/libinterception.la \\\n @USING_MAC_INTERPOSE_FALSE@\t$(LIBSTDCXX_RAW_CXX_LDFLAGS)\n @USING_MAC_INTERPOSE_TRUE@libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+@USING_MAC_INTERPOSE_TRUE@\t$(top_builddir)/lsan/libsanitizer_lsan.la \\\n @USING_MAC_INTERPOSE_TRUE@\t$(LIBSTDCXX_RAW_CXX_LDFLAGS)\n libasan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n \n@@ -402,8 +404,8 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_dll_thunk.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_fake_stack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@\n@@ -420,7 +422,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stats.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread_registry.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win.Plo@am__quote@\n \n .cc.o:"}, {"sha": "4e97ff57530223d01f1831772beefb65e9a44278", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "removed", "additions": 0, "deletions": 811, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=fd5564d3c71195714c28ba150de7e9b90bf9c83d", "patch": "@@ -1,811 +0,0 @@\n-//===-- asan_allocator.cc -------------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Implementation of ASan's memory allocator.\n-// Evey piece of memory (AsanChunk) allocated by the allocator\n-// has a left redzone of REDZONE bytes and\n-// a right redzone such that the end of the chunk is aligned by REDZONE\n-// (i.e. the right redzone is between 0 and REDZONE-1).\n-// The left redzone is always poisoned.\n-// The right redzone is poisoned on malloc, the body is poisoned on free.\n-// Once freed, a chunk is moved to a quarantine (fifo list).\n-// After quarantine, a chunk is returned to freelists.\n-//\n-// The left redzone contains ASan's internal data and the stack trace of\n-// the malloc call.\n-// Once freed, the body of the chunk contains the stack trace of the free call.\n-//\n-//===----------------------------------------------------------------------===//\n-#include \"asan_allocator.h\"\n-\n-#if ASAN_ALLOCATOR_VERSION == 1\n-#include \"asan_interceptors.h\"\n-#include \"asan_internal.h\"\n-#include \"asan_mapping.h\"\n-#include \"asan_stats.h\"\n-#include \"asan_report.h\"\n-#include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n-#include \"sanitizer_common/sanitizer_allocator.h\"\n-#include \"sanitizer_common/sanitizer_atomic.h\"\n-#include \"sanitizer_common/sanitizer_mutex.h\"\n-\n-namespace __asan {\n-\n-#define REDZONE ((uptr)(flags()->redzone))\n-static const uptr kMinAllocSize = REDZONE * 2;\n-static const u64 kMaxAvailableRam = 128ULL << 30;  // 128G\n-static const uptr kMaxThreadLocalQuarantine = 1 << 20;  // 1M\n-\n-static const uptr kMinMmapSize = (ASAN_LOW_MEMORY) ? 4UL << 17 : 4UL << 20;\n-static const uptr kMaxSizeForThreadLocalFreeList =\n-    (ASAN_LOW_MEMORY) ? 1 << 15 : 1 << 17;\n-\n-// Size classes less than kMallocSizeClassStep are powers of two.\n-// All other size classes are multiples of kMallocSizeClassStep.\n-static const uptr kMallocSizeClassStepLog = 26;\n-static const uptr kMallocSizeClassStep = 1UL << kMallocSizeClassStepLog;\n-\n-static const uptr kMaxAllowedMallocSize =\n-    (SANITIZER_WORDSIZE == 32) ? 3UL << 30 : 8UL << 30;\n-\n-static inline uptr SizeClassToSize(u8 size_class) {\n-  CHECK(size_class < kNumberOfSizeClasses);\n-  if (size_class <= kMallocSizeClassStepLog) {\n-    return 1UL << size_class;\n-  } else {\n-    return (size_class - kMallocSizeClassStepLog) * kMallocSizeClassStep;\n-  }\n-}\n-\n-static inline u8 SizeToSizeClass(uptr size) {\n-  u8 res = 0;\n-  if (size <= kMallocSizeClassStep) {\n-    uptr rounded = RoundUpToPowerOfTwo(size);\n-    res = Log2(rounded);\n-  } else {\n-    res = ((size + kMallocSizeClassStep - 1) / kMallocSizeClassStep)\n-        + kMallocSizeClassStepLog;\n-  }\n-  CHECK(res < kNumberOfSizeClasses);\n-  CHECK(size <= SizeClassToSize(res));\n-  return res;\n-}\n-\n-// Given REDZONE bytes, we need to mark first size bytes\n-// as addressable and the rest REDZONE-size bytes as unaddressable.\n-static void PoisonHeapPartialRightRedzone(uptr mem, uptr size) {\n-  CHECK(size <= REDZONE);\n-  CHECK(IsAligned(mem, REDZONE));\n-  CHECK(IsPowerOfTwo(SHADOW_GRANULARITY));\n-  CHECK(IsPowerOfTwo(REDZONE));\n-  CHECK(REDZONE >= SHADOW_GRANULARITY);\n-  PoisonShadowPartialRightRedzone(mem, size, REDZONE,\n-                                  kAsanHeapRightRedzoneMagic);\n-}\n-\n-static u8 *MmapNewPagesAndPoisonShadow(uptr size) {\n-  CHECK(IsAligned(size, GetPageSizeCached()));\n-  u8 *res = (u8*)MmapOrDie(size, __FUNCTION__);\n-  PoisonShadow((uptr)res, size, kAsanHeapLeftRedzoneMagic);\n-  if (flags()->debug) {\n-    Printf(\"ASAN_MMAP: [%p, %p)\\n\", res, res + size);\n-  }\n-  return res;\n-}\n-\n-// Every chunk of memory allocated by this allocator can be in one of 3 states:\n-// CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.\n-// CHUNK_ALLOCATED: the chunk is allocated and not yet freed.\n-// CHUNK_QUARANTINE: the chunk was freed and put into quarantine zone.\n-//\n-// The pseudo state CHUNK_MEMALIGN is used to mark that the address is not\n-// the beginning of a AsanChunk (in which the actual chunk resides at\n-// this - this->used_size).\n-//\n-// The magic numbers for the enum values are taken randomly.\n-enum {\n-  CHUNK_AVAILABLE  = 0x57,\n-  CHUNK_ALLOCATED  = 0x32,\n-  CHUNK_QUARANTINE = 0x19,\n-  CHUNK_MEMALIGN   = 0xDC\n-};\n-\n-struct ChunkBase {\n-  // First 8 bytes.\n-  uptr  chunk_state : 8;\n-  uptr  alloc_tid   : 24;\n-  uptr  size_class  : 8;\n-  uptr  free_tid    : 24;\n-\n-  // Second 8 bytes.\n-  uptr alignment_log : 8;\n-  uptr alloc_type    : 2;\n-  uptr used_size : FIRST_32_SECOND_64(32, 54);  // Size requested by the user.\n-\n-  // This field may overlap with the user area and thus should not\n-  // be used while the chunk is in CHUNK_ALLOCATED state.\n-  AsanChunk *next;\n-\n-  // Typically the beginning of the user-accessible memory is 'this'+REDZONE\n-  // and is also aligned by REDZONE. However, if the memory is allocated\n-  // by memalign, the alignment might be higher and the user-accessible memory\n-  // starts at the first properly aligned address after 'this'.\n-  uptr Beg() { return RoundUpTo((uptr)this + 1, 1 << alignment_log); }\n-  uptr Size() { return SizeClassToSize(size_class); }\n-  u8 SizeClass() { return size_class; }\n-};\n-\n-struct AsanChunk: public ChunkBase {\n-  u32 *compressed_alloc_stack() {\n-    return (u32*)((uptr)this + sizeof(ChunkBase));\n-  }\n-  u32 *compressed_free_stack() {\n-    return (u32*)((uptr)this + Max((uptr)REDZONE, (uptr)sizeof(ChunkBase)));\n-  }\n-\n-  // The left redzone after the ChunkBase is given to the alloc stack trace.\n-  uptr compressed_alloc_stack_size() {\n-    if (REDZONE < sizeof(ChunkBase)) return 0;\n-    return (REDZONE - sizeof(ChunkBase)) / sizeof(u32);\n-  }\n-  uptr compressed_free_stack_size() {\n-    if (REDZONE < sizeof(ChunkBase)) return 0;\n-    return (REDZONE) / sizeof(u32);\n-  }\n-};\n-\n-uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n-uptr AsanChunkView::End() { return Beg() + UsedSize(); }\n-uptr AsanChunkView::UsedSize() { return chunk_->used_size; }\n-uptr AsanChunkView::AllocTid() { return chunk_->alloc_tid; }\n-uptr AsanChunkView::FreeTid() { return chunk_->free_tid; }\n-\n-void AsanChunkView::GetAllocStack(StackTrace *stack) {\n-  StackTrace::UncompressStack(stack, chunk_->compressed_alloc_stack(),\n-                              chunk_->compressed_alloc_stack_size());\n-}\n-\n-void AsanChunkView::GetFreeStack(StackTrace *stack) {\n-  StackTrace::UncompressStack(stack, chunk_->compressed_free_stack(),\n-                              chunk_->compressed_free_stack_size());\n-}\n-\n-static AsanChunk *PtrToChunk(uptr ptr) {\n-  AsanChunk *m = (AsanChunk*)(ptr - REDZONE);\n-  if (m->chunk_state == CHUNK_MEMALIGN) {\n-    m = (AsanChunk*)((uptr)m - m->used_size);\n-  }\n-  return m;\n-}\n-\n-void AsanChunkFifoList::PushList(AsanChunkFifoList *q) {\n-  CHECK(q->size() > 0);\n-  size_ += q->size();\n-  append_back(q);\n-  q->clear();\n-}\n-\n-void AsanChunkFifoList::Push(AsanChunk *n) {\n-  push_back(n);\n-  size_ += n->Size();\n-}\n-\n-// Interesting performance observation: this function takes up to 15% of overal\n-// allocator time. That's because *first_ has been evicted from cache long time\n-// ago. Not sure if we can or want to do anything with this.\n-AsanChunk *AsanChunkFifoList::Pop() {\n-  CHECK(first_);\n-  AsanChunk *res = front();\n-  size_ -= res->Size();\n-  pop_front();\n-  return res;\n-}\n-\n-// All pages we ever allocated.\n-struct PageGroup {\n-  uptr beg;\n-  uptr end;\n-  uptr size_of_chunk;\n-  uptr last_chunk;\n-  bool InRange(uptr addr) {\n-    return addr >= beg && addr < end;\n-  }\n-};\n-\n-class MallocInfo {\n- public:\n-  explicit MallocInfo(LinkerInitialized x) : mu_(x) { }\n-\n-  AsanChunk *AllocateChunks(u8 size_class, uptr n_chunks) {\n-    AsanChunk *m = 0;\n-    AsanChunk **fl = &free_lists_[size_class];\n-    {\n-      BlockingMutexLock lock(&mu_);\n-      for (uptr i = 0; i < n_chunks; i++) {\n-        if (!(*fl)) {\n-          *fl = GetNewChunks(size_class);\n-        }\n-        AsanChunk *t = *fl;\n-        *fl = t->next;\n-        t->next = m;\n-        CHECK(t->chunk_state == CHUNK_AVAILABLE);\n-        m = t;\n-      }\n-    }\n-    return m;\n-  }\n-\n-  void SwallowThreadLocalMallocStorage(AsanThreadLocalMallocStorage *x,\n-                                       bool eat_free_lists) {\n-    CHECK(flags()->quarantine_size > 0);\n-    BlockingMutexLock lock(&mu_);\n-    AsanChunkFifoList *q = &x->quarantine_;\n-    if (q->size() > 0) {\n-      quarantine_.PushList(q);\n-      while (quarantine_.size() > (uptr)flags()->quarantine_size) {\n-        QuarantinePop();\n-      }\n-    }\n-    if (eat_free_lists) {\n-      for (uptr size_class = 0; size_class < kNumberOfSizeClasses;\n-           size_class++) {\n-        AsanChunk *m = x->free_lists_[size_class];\n-        while (m) {\n-          AsanChunk *t = m->next;\n-          m->next = free_lists_[size_class];\n-          free_lists_[size_class] = m;\n-          m = t;\n-        }\n-        x->free_lists_[size_class] = 0;\n-      }\n-    }\n-  }\n-\n-  void BypassThreadLocalQuarantine(AsanChunk *chunk) {\n-    BlockingMutexLock lock(&mu_);\n-    quarantine_.Push(chunk);\n-  }\n-\n-  AsanChunk *FindChunkByAddr(uptr addr) {\n-    BlockingMutexLock lock(&mu_);\n-    return FindChunkByAddrUnlocked(addr);\n-  }\n-\n-  uptr AllocationSize(uptr ptr) {\n-    if (!ptr) return 0;\n-    BlockingMutexLock lock(&mu_);\n-\n-    // Make sure this is our chunk and |ptr| actually points to the beginning\n-    // of the allocated memory.\n-    AsanChunk *m = FindChunkByAddrUnlocked(ptr);\n-    if (!m || m->Beg() != ptr) return 0;\n-\n-    if (m->chunk_state == CHUNK_ALLOCATED) {\n-      return m->used_size;\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  void ForceLock() {\n-    mu_.Lock();\n-  }\n-\n-  void ForceUnlock() {\n-    mu_.Unlock();\n-  }\n-\n-  void PrintStatus() {\n-    BlockingMutexLock lock(&mu_);\n-    uptr malloced = 0;\n-\n-    Printf(\" MallocInfo: in quarantine: %zu malloced: %zu; \",\n-           quarantine_.size() >> 20, malloced >> 20);\n-    for (uptr j = 1; j < kNumberOfSizeClasses; j++) {\n-      AsanChunk *i = free_lists_[j];\n-      if (!i) continue;\n-      uptr t = 0;\n-      for (; i; i = i->next) {\n-        t += i->Size();\n-      }\n-      Printf(\"%zu:%zu \", j, t >> 20);\n-    }\n-    Printf(\"\\n\");\n-  }\n-\n-  PageGroup *FindPageGroup(uptr addr) {\n-    BlockingMutexLock lock(&mu_);\n-    return FindPageGroupUnlocked(addr);\n-  }\n-\n- private:\n-  PageGroup *FindPageGroupUnlocked(uptr addr) {\n-    int n = atomic_load(&n_page_groups_, memory_order_relaxed);\n-    // If the page groups are not sorted yet, sort them.\n-    if (n_sorted_page_groups_ < n) {\n-      SortArray((uptr*)page_groups_, n);\n-      n_sorted_page_groups_ = n;\n-    }\n-    // Binary search over the page groups.\n-    int beg = 0, end = n;\n-    while (beg < end) {\n-      int med = (beg + end) / 2;\n-      uptr g = (uptr)page_groups_[med];\n-      if (addr > g) {\n-        // 'g' points to the end of the group, so 'addr'\n-        // may not belong to page_groups_[med] or any previous group.\n-        beg = med + 1;\n-      } else {\n-        // 'addr' may belong to page_groups_[med] or a previous group.\n-        end = med;\n-      }\n-    }\n-    if (beg >= n)\n-      return 0;\n-    PageGroup *g = page_groups_[beg];\n-    CHECK(g);\n-    if (g->InRange(addr))\n-      return g;\n-    return 0;\n-  }\n-\n-  // We have an address between two chunks, and we want to report just one.\n-  AsanChunk *ChooseChunk(uptr addr,\n-                         AsanChunk *left_chunk, AsanChunk *right_chunk) {\n-    // Prefer an allocated chunk or a chunk from quarantine.\n-    if (left_chunk->chunk_state == CHUNK_AVAILABLE &&\n-        right_chunk->chunk_state != CHUNK_AVAILABLE)\n-      return right_chunk;\n-    if (right_chunk->chunk_state == CHUNK_AVAILABLE &&\n-        left_chunk->chunk_state != CHUNK_AVAILABLE)\n-      return left_chunk;\n-    // Choose based on offset.\n-    sptr l_offset = 0, r_offset = 0;\n-    CHECK(AsanChunkView(left_chunk).AddrIsAtRight(addr, 1, &l_offset));\n-    CHECK(AsanChunkView(right_chunk).AddrIsAtLeft(addr, 1, &r_offset));\n-    if (l_offset < r_offset)\n-      return left_chunk;\n-    return right_chunk;\n-  }\n-\n-  AsanChunk *FindChunkByAddrUnlocked(uptr addr) {\n-    PageGroup *g = FindPageGroupUnlocked(addr);\n-    if (!g) return 0;\n-    CHECK(g->size_of_chunk);\n-    uptr offset_from_beg = addr - g->beg;\n-    uptr this_chunk_addr = g->beg +\n-        (offset_from_beg / g->size_of_chunk) * g->size_of_chunk;\n-    CHECK(g->InRange(this_chunk_addr));\n-    AsanChunk *m = (AsanChunk*)this_chunk_addr;\n-    CHECK(m->chunk_state == CHUNK_ALLOCATED ||\n-          m->chunk_state == CHUNK_AVAILABLE ||\n-          m->chunk_state == CHUNK_QUARANTINE);\n-    sptr offset = 0;\n-    AsanChunkView m_view(m);\n-    if (m_view.AddrIsInside(addr, 1, &offset))\n-      return m;\n-\n-    if (m_view.AddrIsAtRight(addr, 1, &offset)) {\n-      if (this_chunk_addr == g->last_chunk)  // rightmost chunk\n-        return m;\n-      uptr right_chunk_addr = this_chunk_addr + g->size_of_chunk;\n-      CHECK(g->InRange(right_chunk_addr));\n-      return ChooseChunk(addr, m, (AsanChunk*)right_chunk_addr);\n-    } else {\n-      CHECK(m_view.AddrIsAtLeft(addr, 1, &offset));\n-      if (this_chunk_addr == g->beg)  // leftmost chunk\n-        return m;\n-      uptr left_chunk_addr = this_chunk_addr - g->size_of_chunk;\n-      CHECK(g->InRange(left_chunk_addr));\n-      return ChooseChunk(addr, (AsanChunk*)left_chunk_addr, m);\n-    }\n-  }\n-\n-  void QuarantinePop() {\n-    CHECK(quarantine_.size() > 0);\n-    AsanChunk *m = quarantine_.Pop();\n-    CHECK(m);\n-    // if (F_v >= 2) Printf(\"MallocInfo::pop %p\\n\", m);\n-\n-    CHECK(m->chunk_state == CHUNK_QUARANTINE);\n-    m->chunk_state = CHUNK_AVAILABLE;\n-    PoisonShadow((uptr)m, m->Size(), kAsanHeapLeftRedzoneMagic);\n-    CHECK(m->alloc_tid >= 0);\n-    CHECK(m->free_tid >= 0);\n-\n-    uptr size_class = m->SizeClass();\n-    m->next = free_lists_[size_class];\n-    free_lists_[size_class] = m;\n-\n-    // Statistics.\n-    AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n-    thread_stats.real_frees++;\n-    thread_stats.really_freed += m->used_size;\n-    thread_stats.really_freed_redzones += m->Size() - m->used_size;\n-    thread_stats.really_freed_by_size[m->SizeClass()]++;\n-  }\n-\n-  // Get a list of newly allocated chunks.\n-  AsanChunk *GetNewChunks(u8 size_class) {\n-    uptr size = SizeClassToSize(size_class);\n-    CHECK(IsPowerOfTwo(kMinMmapSize));\n-    CHECK(size < kMinMmapSize || (size % kMinMmapSize) == 0);\n-    uptr mmap_size = Max(size, kMinMmapSize);\n-    uptr n_chunks = mmap_size / size;\n-    CHECK(n_chunks * size == mmap_size);\n-    uptr PageSize = GetPageSizeCached();\n-    if (size < PageSize) {\n-      // Size is small, just poison the last chunk.\n-      n_chunks--;\n-    } else {\n-      // Size is large, allocate an extra page at right and poison it.\n-      mmap_size += PageSize;\n-    }\n-    CHECK(n_chunks > 0);\n-    u8 *mem = MmapNewPagesAndPoisonShadow(mmap_size);\n-\n-    // Statistics.\n-    AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n-    thread_stats.mmaps++;\n-    thread_stats.mmaped += mmap_size;\n-    thread_stats.mmaped_by_size[size_class] += n_chunks;\n-\n-    AsanChunk *res = 0;\n-    for (uptr i = 0; i < n_chunks; i++) {\n-      AsanChunk *m = (AsanChunk*)(mem + i * size);\n-      m->chunk_state = CHUNK_AVAILABLE;\n-      m->size_class = size_class;\n-      m->next = res;\n-      res = m;\n-    }\n-    PageGroup *pg = (PageGroup*)(mem + n_chunks * size);\n-    // This memory is already poisoned, no need to poison it again.\n-    pg->beg = (uptr)mem;\n-    pg->end = pg->beg + mmap_size;\n-    pg->size_of_chunk = size;\n-    pg->last_chunk = (uptr)(mem + size * (n_chunks - 1));\n-    int idx = atomic_fetch_add(&n_page_groups_, 1, memory_order_relaxed);\n-    CHECK(idx < (int)ARRAY_SIZE(page_groups_));\n-    page_groups_[idx] = pg;\n-    return res;\n-  }\n-\n-  AsanChunk *free_lists_[kNumberOfSizeClasses];\n-  AsanChunkFifoList quarantine_;\n-  BlockingMutex mu_;\n-\n-  PageGroup *page_groups_[kMaxAvailableRam / kMinMmapSize];\n-  atomic_uint32_t n_page_groups_;\n-  int n_sorted_page_groups_;\n-};\n-\n-static MallocInfo malloc_info(LINKER_INITIALIZED);\n-\n-void AsanThreadLocalMallocStorage::CommitBack() {\n-  malloc_info.SwallowThreadLocalMallocStorage(this, true);\n-}\n-\n-AsanChunkView FindHeapChunkByAddress(uptr address) {\n-  return AsanChunkView(malloc_info.FindChunkByAddr(address));\n-}\n-\n-static u8 *Allocate(uptr alignment, uptr size, StackTrace *stack,\n-                    AllocType alloc_type) {\n-  __asan_init();\n-  CHECK(stack);\n-  if (size == 0) {\n-    size = 1;  // TODO(kcc): do something smarter\n-  }\n-  CHECK(IsPowerOfTwo(alignment));\n-  uptr rounded_size = RoundUpTo(size, REDZONE);\n-  uptr needed_size = rounded_size + REDZONE;\n-  if (alignment > REDZONE) {\n-    needed_size += alignment;\n-  }\n-  CHECK(IsAligned(needed_size, REDZONE));\n-  if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n-    Report(\"WARNING: AddressSanitizer failed to allocate %p bytes\\n\",\n-           (void*)size);\n-    return 0;\n-  }\n-\n-  u8 size_class = SizeToSizeClass(needed_size);\n-  uptr size_to_allocate = SizeClassToSize(size_class);\n-  CHECK(size_to_allocate >= kMinAllocSize);\n-  CHECK(size_to_allocate >= needed_size);\n-  CHECK(IsAligned(size_to_allocate, REDZONE));\n-\n-  if (flags()->verbosity >= 3) {\n-    Printf(\"Allocate align: %zu size: %zu class: %u real: %zu\\n\",\n-         alignment, size, size_class, size_to_allocate);\n-  }\n-\n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n-  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n-  // Statistics\n-  thread_stats.mallocs++;\n-  thread_stats.malloced += size;\n-  thread_stats.malloced_redzones += size_to_allocate - size;\n-  thread_stats.malloced_by_size[size_class]++;\n-\n-  AsanChunk *m = 0;\n-  if (!t || size_to_allocate >= kMaxSizeForThreadLocalFreeList) {\n-    // get directly from global storage.\n-    m = malloc_info.AllocateChunks(size_class, 1);\n-    thread_stats.malloc_large++;\n-  } else {\n-    // get from the thread-local storage.\n-    AsanChunk **fl = &t->malloc_storage().free_lists_[size_class];\n-    if (!*fl) {\n-      uptr n_new_chunks = kMaxSizeForThreadLocalFreeList / size_to_allocate;\n-      *fl = malloc_info.AllocateChunks(size_class, n_new_chunks);\n-      thread_stats.malloc_small_slow++;\n-    }\n-    m = *fl;\n-    *fl = (*fl)->next;\n-  }\n-  CHECK(m);\n-  CHECK(m->chunk_state == CHUNK_AVAILABLE);\n-  m->chunk_state = CHUNK_ALLOCATED;\n-  m->alloc_type = alloc_type;\n-  m->next = 0;\n-  CHECK(m->Size() == size_to_allocate);\n-  uptr addr = (uptr)m + REDZONE;\n-  CHECK(addr <= (uptr)m->compressed_free_stack());\n-\n-  if (alignment > REDZONE && (addr & (alignment - 1))) {\n-    addr = RoundUpTo(addr, alignment);\n-    CHECK((addr & (alignment - 1)) == 0);\n-    AsanChunk *p = (AsanChunk*)(addr - REDZONE);\n-    p->chunk_state = CHUNK_MEMALIGN;\n-    p->used_size = (uptr)p - (uptr)m;\n-    m->alignment_log = Log2(alignment);\n-    CHECK(m->Beg() == addr);\n-  } else {\n-    m->alignment_log = Log2(REDZONE);\n-  }\n-  CHECK(m == PtrToChunk(addr));\n-  m->used_size = size;\n-  CHECK(m->Beg() == addr);\n-  m->alloc_tid = t ? t->tid() : 0;\n-  m->free_tid   = kInvalidTid;\n-  StackTrace::CompressStack(stack, m->compressed_alloc_stack(),\n-                                m->compressed_alloc_stack_size());\n-  PoisonShadow(addr, rounded_size, 0);\n-  if (size < rounded_size) {\n-    PoisonHeapPartialRightRedzone(addr + rounded_size - REDZONE,\n-                                  size & (REDZONE - 1));\n-  }\n-  if (size <= (uptr)(flags()->max_malloc_fill_size)) {\n-    REAL(memset)((void*)addr, 0, rounded_size);\n-  }\n-  return (u8*)addr;\n-}\n-\n-static void Deallocate(u8 *ptr, StackTrace *stack, AllocType alloc_type) {\n-  if (!ptr) return;\n-  CHECK(stack);\n-\n-  if (flags()->debug) {\n-    CHECK(malloc_info.FindPageGroup((uptr)ptr));\n-  }\n-\n-  // Printf(\"Deallocate %p\\n\", ptr);\n-  AsanChunk *m = PtrToChunk((uptr)ptr);\n-\n-  // Flip the chunk_state atomically to avoid race on double-free.\n-  u8 old_chunk_state = atomic_exchange((atomic_uint8_t*)m, CHUNK_QUARANTINE,\n-                                       memory_order_acq_rel);\n-\n-  if (old_chunk_state == CHUNK_QUARANTINE) {\n-    ReportDoubleFree((uptr)ptr, stack);\n-  } else if (old_chunk_state != CHUNK_ALLOCATED) {\n-    ReportFreeNotMalloced((uptr)ptr, stack);\n-  }\n-  CHECK(old_chunk_state == CHUNK_ALLOCATED);\n-  if (m->alloc_type != alloc_type && flags()->alloc_dealloc_mismatch)\n-    ReportAllocTypeMismatch((uptr)ptr, stack,\n-                            (AllocType)m->alloc_type, (AllocType)alloc_type);\n-  // With REDZONE==16 m->next is in the user area, otherwise it should be 0.\n-  CHECK(REDZONE <= 16 || !m->next);\n-  CHECK(m->free_tid == kInvalidTid);\n-  CHECK(m->alloc_tid >= 0);\n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n-  m->free_tid = t ? t->tid() : 0;\n-  StackTrace::CompressStack(stack, m->compressed_free_stack(),\n-                                m->compressed_free_stack_size());\n-  uptr rounded_size = RoundUpTo(m->used_size, REDZONE);\n-  PoisonShadow((uptr)ptr, rounded_size, kAsanHeapFreeMagic);\n-\n-  // Statistics.\n-  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n-  thread_stats.frees++;\n-  thread_stats.freed += m->used_size;\n-  thread_stats.freed_by_size[m->SizeClass()]++;\n-\n-  CHECK(m->chunk_state == CHUNK_QUARANTINE);\n-\n-  if (t) {\n-    AsanThreadLocalMallocStorage *ms = &t->malloc_storage();\n-    ms->quarantine_.Push(m);\n-\n-    if (ms->quarantine_.size() > kMaxThreadLocalQuarantine) {\n-      malloc_info.SwallowThreadLocalMallocStorage(ms, false);\n-    }\n-  } else {\n-    malloc_info.BypassThreadLocalQuarantine(m);\n-  }\n-}\n-\n-static u8 *Reallocate(u8 *old_ptr, uptr new_size,\n-                           StackTrace *stack) {\n-  CHECK(old_ptr && new_size);\n-\n-  // Statistics.\n-  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n-  thread_stats.reallocs++;\n-  thread_stats.realloced += new_size;\n-\n-  AsanChunk *m = PtrToChunk((uptr)old_ptr);\n-  CHECK(m->chunk_state == CHUNK_ALLOCATED);\n-  uptr old_size = m->used_size;\n-  uptr memcpy_size = Min(new_size, old_size);\n-  u8 *new_ptr = Allocate(0, new_size, stack, FROM_MALLOC);\n-  if (new_ptr) {\n-    CHECK(REAL(memcpy) != 0);\n-    REAL(memcpy)(new_ptr, old_ptr, memcpy_size);\n-    Deallocate(old_ptr, stack, FROM_MALLOC);\n-  }\n-  return new_ptr;\n-}\n-\n-}  // namespace __asan\n-\n-#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n-// Provide default (no-op) implementation of malloc hooks.\n-extern \"C\" {\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n-void __asan_malloc_hook(void *ptr, uptr size) {\n-  (void)ptr;\n-  (void)size;\n-}\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n-void __asan_free_hook(void *ptr) {\n-  (void)ptr;\n-}\n-}  // extern \"C\"\n-#endif\n-\n-namespace __asan {\n-\n-void InitializeAllocator() { }\n-\n-void PrintInternalAllocatorStats() {\n-}\n-\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n-                    AllocType alloc_type) {\n-  void *ptr = (void*)Allocate(alignment, size, stack, alloc_type);\n-  ASAN_MALLOC_HOOK(ptr, size);\n-  return ptr;\n-}\n-\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void asan_free(void *ptr, StackTrace *stack, AllocType alloc_type) {\n-  ASAN_FREE_HOOK(ptr);\n-  Deallocate((u8*)ptr, stack, alloc_type);\n-}\n-\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void *asan_malloc(uptr size, StackTrace *stack) {\n-  void *ptr = (void*)Allocate(0, size, stack, FROM_MALLOC);\n-  ASAN_MALLOC_HOOK(ptr, size);\n-  return ptr;\n-}\n-\n-void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack) {\n-  if (__sanitizer::CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n-  void *ptr = (void*)Allocate(0, nmemb * size, stack, FROM_MALLOC);\n-  if (ptr)\n-    REAL(memset)(ptr, 0, nmemb * size);\n-  ASAN_MALLOC_HOOK(ptr, size);\n-  return ptr;\n-}\n-\n-void *asan_realloc(void *p, uptr size, StackTrace *stack) {\n-  if (p == 0) {\n-    void *ptr = (void*)Allocate(0, size, stack, FROM_MALLOC);\n-    ASAN_MALLOC_HOOK(ptr, size);\n-    return ptr;\n-  } else if (size == 0) {\n-    ASAN_FREE_HOOK(p);\n-    Deallocate((u8*)p, stack, FROM_MALLOC);\n-    return 0;\n-  }\n-  return Reallocate((u8*)p, size, stack);\n-}\n-\n-void *asan_valloc(uptr size, StackTrace *stack) {\n-  void *ptr = (void*)Allocate(GetPageSizeCached(), size, stack, FROM_MALLOC);\n-  ASAN_MALLOC_HOOK(ptr, size);\n-  return ptr;\n-}\n-\n-void *asan_pvalloc(uptr size, StackTrace *stack) {\n-  uptr PageSize = GetPageSizeCached();\n-  size = RoundUpTo(size, PageSize);\n-  if (size == 0) {\n-    // pvalloc(0) should allocate one page.\n-    size = PageSize;\n-  }\n-  void *ptr = (void*)Allocate(PageSize, size, stack, FROM_MALLOC);\n-  ASAN_MALLOC_HOOK(ptr, size);\n-  return ptr;\n-}\n-\n-int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n-                          StackTrace *stack) {\n-  void *ptr = Allocate(alignment, size, stack, FROM_MALLOC);\n-  CHECK(IsAligned((uptr)ptr, alignment));\n-  ASAN_MALLOC_HOOK(ptr, size);\n-  *memptr = ptr;\n-  return 0;\n-}\n-\n-uptr asan_malloc_usable_size(void *ptr, StackTrace *stack) {\n-  CHECK(stack);\n-  if (ptr == 0) return 0;\n-  uptr usable_size = malloc_info.AllocationSize((uptr)ptr);\n-  if (flags()->check_malloc_usable_size && (usable_size == 0)) {\n-    ReportMallocUsableSizeNotOwned((uptr)ptr, stack);\n-  }\n-  return usable_size;\n-}\n-\n-uptr asan_mz_size(const void *ptr) {\n-  return malloc_info.AllocationSize((uptr)ptr);\n-}\n-\n-void asan_mz_force_lock() {\n-  malloc_info.ForceLock();\n-}\n-\n-void asan_mz_force_unlock() {\n-  malloc_info.ForceUnlock();\n-}\n-\n-}  // namespace __asan\n-\n-// ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n-// ASan allocator doesn't reserve extra bytes, so normally we would\n-// just return \"size\".\n-uptr __asan_get_estimated_allocated_size(uptr size) {\n-  if (size == 0) return 1;\n-  return Min(size, kMaxAllowedMallocSize);\n-}\n-\n-bool __asan_get_ownership(const void *p) {\n-  return malloc_info.AllocationSize((uptr)p) > 0;\n-}\n-\n-uptr __asan_get_allocated_size(const void *p) {\n-  if (p == 0) return 0;\n-  uptr allocated_size = malloc_info.AllocationSize((uptr)p);\n-  // Die if p is not malloced or if it is already freed.\n-  if (allocated_size == 0) {\n-    GET_STACK_TRACE_FATAL_HERE;\n-    ReportAsanGetAllocatedSizeNotOwned((uptr)p, &stack);\n-  }\n-  return allocated_size;\n-}\n-#endif  // ASAN_ALLOCATOR_VERSION"}, {"sha": "1f83dcd6780005ad2a727c7415f3dd512d07777b", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 1, "deletions": 105, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -7,7 +7,7 @@\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_allocator.cc.\n+// ASan-private header for asan_allocator2.cc.\n //===----------------------------------------------------------------------===//\n \n #ifndef ASAN_ALLOCATOR_H\n@@ -17,18 +17,6 @@\n #include \"asan_interceptors.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n \n-// We are in the process of transitioning from the old allocator (version 1)\n-// to a new one (version 2). The change is quite intrusive so both allocators\n-// will co-exist in the source base for a while. The actual allocator is chosen\n-// at build time by redefining this macro.\n-#ifndef ASAN_ALLOCATOR_VERSION\n-# if (ASAN_LINUX && !ASAN_ANDROID) || ASAN_MAC || ASAN_WINDOWS\n-#  define ASAN_ALLOCATOR_VERSION 2\n-# else\n-#  define ASAN_ALLOCATOR_VERSION 1\n-# endif\n-#endif  // ASAN_ALLOCATOR_VERSION\n-\n namespace __asan {\n \n enum AllocType {\n@@ -101,109 +89,17 @@ class AsanChunkFifoList: public IntrusiveList<AsanChunk> {\n \n struct AsanThreadLocalMallocStorage {\n   explicit AsanThreadLocalMallocStorage(LinkerInitialized x)\n-#if ASAN_ALLOCATOR_VERSION == 1\n-      : quarantine_(x)\n-#endif\n       { }\n   AsanThreadLocalMallocStorage() {\n     CHECK(REAL(memset));\n     REAL(memset)(this, 0, sizeof(AsanThreadLocalMallocStorage));\n   }\n \n-#if ASAN_ALLOCATOR_VERSION == 1\n-  AsanChunkFifoList quarantine_;\n-  AsanChunk *free_lists_[kNumberOfSizeClasses];\n-#else\n   uptr quarantine_cache[16];\n   uptr allocator2_cache[96 * (512 * 8 + 16)];  // Opaque.\n-#endif\n   void CommitBack();\n };\n \n-// Fake stack frame contains local variables of one function.\n-// This struct should fit into a stack redzone (32 bytes).\n-struct FakeFrame {\n-  uptr magic;  // Modified by the instrumented code.\n-  uptr descr;  // Modified by the instrumented code.\n-  FakeFrame *next;\n-  u64 real_stack     : 48;\n-  u64 size_minus_one : 16;\n-};\n-\n-struct FakeFrameFifo {\n- public:\n-  void FifoPush(FakeFrame *node);\n-  FakeFrame *FifoPop();\n- private:\n-  FakeFrame *first_, *last_;\n-};\n-\n-class FakeFrameLifo {\n- public:\n-  void LifoPush(FakeFrame *node) {\n-    node->next = top_;\n-    top_ = node;\n-  }\n-  void LifoPop() {\n-    CHECK(top_);\n-    top_ = top_->next;\n-  }\n-  FakeFrame *top() { return top_; }\n- private:\n-  FakeFrame *top_;\n-};\n-\n-// For each thread we create a fake stack and place stack objects on this fake\n-// stack instead of the real stack. The fake stack is not really a stack but\n-// a fast malloc-like allocator so that when a function exits the fake stack\n-// is not poped but remains there for quite some time until gets used again.\n-// So, we poison the objects on the fake stack when function returns.\n-// It helps us find use-after-return bugs.\n-// We can not rely on __asan_stack_free being called on every function exit,\n-// so we maintain a lifo list of all current fake frames and update it on every\n-// call to __asan_stack_malloc.\n-class FakeStack {\n- public:\n-  FakeStack();\n-  explicit FakeStack(LinkerInitialized) {}\n-  void Init(uptr stack_size);\n-  void StopUsingFakeStack() { alive_ = false; }\n-  void Cleanup();\n-  uptr AllocateStack(uptr size, uptr real_stack);\n-  static void OnFree(uptr ptr, uptr size, uptr real_stack);\n-  // Return the bottom of the maped region.\n-  uptr AddrIsInFakeStack(uptr addr);\n-  bool StackSize() { return stack_size_; }\n-\n- private:\n-  static const uptr kMinStackFrameSizeLog = 9;  // Min frame is 512B.\n-  static const uptr kMaxStackFrameSizeLog = 16;  // Max stack frame is 64K.\n-  static const uptr kMaxStackMallocSize = 1 << kMaxStackFrameSizeLog;\n-  static const uptr kNumberOfSizeClasses =\n-      kMaxStackFrameSizeLog - kMinStackFrameSizeLog + 1;\n-\n-  bool AddrIsInSizeClass(uptr addr, uptr size_class);\n-\n-  // Each size class should be large enough to hold all frames.\n-  uptr ClassMmapSize(uptr size_class);\n-\n-  uptr ClassSize(uptr size_class) {\n-    return 1UL << (size_class + kMinStackFrameSizeLog);\n-  }\n-\n-  void DeallocateFrame(FakeFrame *fake_frame);\n-\n-  uptr ComputeSizeClass(uptr alloc_size);\n-  void AllocateOneSizeClass(uptr size_class);\n-\n-  uptr stack_size_;\n-  bool   alive_;\n-\n-  uptr allocated_size_classes_[kNumberOfSizeClasses];\n-  FakeFrameFifo size_classes_[kNumberOfSizeClasses];\n-  FakeFrameLifo call_stack_;\n-};\n-\n void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n                     AllocType alloc_type);\n void asan_free(void *ptr, StackTrace *stack, AllocType alloc_type);"}, {"sha": "34aad11ed75205a8f6ed1247c630a24b608844e4", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "modified", "additions": 213, "deletions": 102, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -11,28 +11,28 @@\n // This variant uses the allocator from sanitizer_common, i.e. the one shared\n // with ThreadSanitizer and MemorySanitizer.\n //\n-// Status: under development, not enabled by default yet.\n //===----------------------------------------------------------------------===//\n #include \"asan_allocator.h\"\n-#if ASAN_ALLOCATOR_VERSION == 2\n \n #include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_quarantine.h\"\n+#include \"lsan/lsan_common.h\"\n \n namespace __asan {\n \n struct AsanMapUnmapCallback {\n   void OnMap(uptr p, uptr size) const {\n     PoisonShadow(p, size, kAsanHeapLeftRedzoneMagic);\n     // Statistics.\n-    AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+    AsanStats &thread_stats = GetCurrentThreadStats();\n     thread_stats.mmaps++;\n     thread_stats.mmaped += size;\n   }\n@@ -47,7 +47,7 @@ struct AsanMapUnmapCallback {\n     uptr shadow_end = RoundDownTo(MemToShadow(p + size), page_size);\n     FlushUnneededShadowMemory(shadow_beg, shadow_end - shadow_beg);\n     // Statistics.\n-    AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+    AsanStats &thread_stats = GetCurrentThreadStats();\n     thread_stats.munmaps++;\n     thread_stats.munmaped += size;\n   }\n@@ -56,18 +56,23 @@ struct AsanMapUnmapCallback {\n #if SANITIZER_WORDSIZE == 64\n #if defined(__powerpc64__)\n const uptr kAllocatorSpace =  0xa0000000000ULL;\n+const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n #else\n const uptr kAllocatorSpace = 0x600000000000ULL;\n+const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n #endif\n-const uptr kAllocatorSize  =  0x10000000000ULL;  // 1T.\n typedef DefaultSizeClassMap SizeClassMap;\n typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, 0 /*metadata*/,\n     SizeClassMap, AsanMapUnmapCallback> PrimaryAllocator;\n #elif SANITIZER_WORDSIZE == 32\n static const u64 kAddressSpaceSize = 1ULL << 32;\n typedef CompactSizeClassMap SizeClassMap;\n+static const uptr kRegionSizeLog = 20;\n+static const uptr kFlatByteMapSize = kAddressSpaceSize >> kRegionSizeLog;\n typedef SizeClassAllocator32<0, kAddressSpaceSize, 16,\n-  SizeClassMap, AsanMapUnmapCallback> PrimaryAllocator;\n+  SizeClassMap, kRegionSizeLog,\n+  FlatByteMap<kFlatByteMapSize>,\n+  AsanMapUnmapCallback> PrimaryAllocator;\n #endif\n \n typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n@@ -139,14 +144,15 @@ static uptr ComputeRZLog(uptr user_requested_size) {\n // ChunkBase consists of ChunkHeader and other bytes that overlap with user\n // memory.\n \n-// If a memory chunk is allocated by memalign and we had to increase the\n-// allocation size to achieve the proper alignment, then we store this magic\n+// If the left redzone is greater than the ChunkHeader size we store a magic\n // value in the first uptr word of the memory block and store the address of\n // ChunkBase in the next uptr.\n-// M B ? ? ? L L L L L L  H H U U U U U U\n-//   M -- magic value kMemalignMagic\n+// M B L L L L L L L L L  H H U U U U U U\n+//   |                    ^\n+//   ---------------------|\n+//   M -- magic value kAllocBegMagic\n //   B -- address of ChunkHeader pointing to the first 'H'\n-static const uptr kMemalignMagic = 0xCC6E96B9;\n+static const uptr kAllocBegMagic = 0xCC6E96B9;\n \n struct ChunkHeader {\n   // 1-st 8 bytes.\n@@ -157,6 +163,7 @@ struct ChunkHeader {\n   u32 from_memalign     : 1;\n   u32 alloc_type        : 2;\n   u32 rz_log            : 3;\n+  u32 lsan_tag          : 2;\n   // 2-nd 8 bytes\n   // This field is used for small sizes. For large sizes it is equal to\n   // SizeClassMap::kMaxSize and the actual size is stored in the\n@@ -167,7 +174,6 @@ struct ChunkHeader {\n \n struct ChunkBase : ChunkHeader {\n   // Header2, intersects with user memory.\n-  AsanChunk *next;\n   u32 free_context_id;\n };\n \n@@ -188,7 +194,8 @@ struct AsanChunk: ChunkBase {\n       return allocator.GetBlockBegin(reinterpret_cast<void *>(this));\n     return reinterpret_cast<void*>(Beg() - RZLog2Size(rz_log));\n   }\n-  // We store the alloc/free stack traces in the chunk itself.\n+  // If we don't use stack depot, we store the alloc/free stack traces\n+  // in the chunk itself.\n   u32 *AllocStackBeg() {\n     return (u32*)(Beg() - RZLog2Size(rz_log));\n   }\n@@ -204,6 +211,9 @@ struct AsanChunk: ChunkBase {\n     uptr available = RoundUpTo(user_requested_size, SHADOW_GRANULARITY);\n     return (available - kChunkHeader2Size) / sizeof(u32);\n   }\n+  bool AddrIsInside(uptr addr) {\n+    return (addr >= Beg()) && (addr < Beg() + UsedSize());\n+  }\n };\n \n uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n@@ -257,22 +267,25 @@ struct QuarantineCallback {\n   }\n \n   void Recycle(AsanChunk *m) {\n-    CHECK(m->chunk_state == CHUNK_QUARANTINE);\n-    m->chunk_state = CHUNK_AVAILABLE;\n+    CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n+    atomic_store((atomic_uint8_t*)m, CHUNK_AVAILABLE, memory_order_relaxed);\n     CHECK_NE(m->alloc_tid, kInvalidTid);\n     CHECK_NE(m->free_tid, kInvalidTid);\n     PoisonShadow(m->Beg(),\n                  RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n                  kAsanHeapLeftRedzoneMagic);\n     void *p = reinterpret_cast<void *>(m->AllocBeg());\n-    if (m->from_memalign) {\n-      uptr *memalign_magic = reinterpret_cast<uptr *>(p);\n-      CHECK_EQ(memalign_magic[0], kMemalignMagic);\n-      CHECK_EQ(memalign_magic[1], reinterpret_cast<uptr>(m));\n+    if (p != m) {\n+      uptr *alloc_magic = reinterpret_cast<uptr *>(p);\n+      CHECK_EQ(alloc_magic[0], kAllocBegMagic);\n+      // Clear the magic value, as allocator internals may overwrite the\n+      // contents of deallocated chunk, confusing GetAsanChunk lookup.\n+      alloc_magic[0] = 0;\n+      CHECK_EQ(alloc_magic[1], reinterpret_cast<uptr>(m));\n     }\n \n     // Statistics.\n-    AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+    AsanStats &thread_stats = GetCurrentThreadStats();\n     thread_stats.real_frees++;\n     thread_stats.really_freed += m->UsedSize();\n \n@@ -296,9 +309,10 @@ void InitializeAllocator() {\n }\n \n static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n-                      AllocType alloc_type) {\n+                      AllocType alloc_type, bool can_fill) {\n   if (!asan_inited)\n     __asan_init();\n+  Flags &fl = *flags();\n   CHECK(stack);\n   const uptr min_alignment = SHADOW_GRANULARITY;\n   if (alignment < min_alignment)\n@@ -314,9 +328,7 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n   CHECK(IsPowerOfTwo(alignment));\n   uptr rz_log = ComputeRZLog(size);\n   uptr rz_size = RZLog2Size(rz_log);\n-  uptr rounded_size = RoundUpTo(size, alignment);\n-  if (rounded_size < kChunkHeader2Size)\n-    rounded_size = kChunkHeader2Size;\n+  uptr rounded_size = RoundUpTo(Max(size, kChunkHeader2Size), alignment);\n   uptr needed_size = rounded_size + rz_size;\n   if (alignment > min_alignment)\n     needed_size += alignment;\n@@ -331,10 +343,10 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n   if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n     Report(\"WARNING: AddressSanitizer failed to allocate %p bytes\\n\",\n            (void*)size);\n-    return 0;\n+    return AllocatorReturnNull();\n   }\n \n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  AsanThread *t = GetCurrentThread();\n   void *allocated;\n   if (t) {\n     AllocatorCache *cache = GetAllocatorCache(&t->malloc_storage());\n@@ -345,8 +357,6 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n     allocated = allocator.Allocate(cache, needed_size, 8, false);\n   }\n   uptr alloc_beg = reinterpret_cast<uptr>(allocated);\n-  // Clear the first allocated word (an old kMemalignMagic may still be there).\n-  reinterpret_cast<uptr *>(alloc_beg)[0] = 0;\n   uptr alloc_end = alloc_beg + needed_size;\n   uptr beg_plus_redzone = alloc_beg + rz_size;\n   uptr user_beg = beg_plus_redzone;\n@@ -356,19 +366,17 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n   CHECK_LE(user_end, alloc_end);\n   uptr chunk_beg = user_beg - kChunkHeaderSize;\n   AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n-  m->chunk_state = CHUNK_ALLOCATED;\n   m->alloc_type = alloc_type;\n   m->rz_log = rz_log;\n   u32 alloc_tid = t ? t->tid() : 0;\n   m->alloc_tid = alloc_tid;\n   CHECK_EQ(alloc_tid, m->alloc_tid);  // Does alloc_tid fit into the bitfield?\n   m->free_tid = kInvalidTid;\n   m->from_memalign = user_beg != beg_plus_redzone;\n-  if (m->from_memalign) {\n-    CHECK_LE(beg_plus_redzone + 2 * sizeof(uptr), user_beg);\n-    uptr *memalign_magic = reinterpret_cast<uptr *>(alloc_beg);\n-    memalign_magic[0] = kMemalignMagic;\n-    memalign_magic[1] = chunk_beg;\n+  if (alloc_beg != chunk_beg) {\n+    CHECK_LE(alloc_beg+ 2 * sizeof(uptr), chunk_beg);\n+    reinterpret_cast<uptr *>(alloc_beg)[0] = kAllocBegMagic;\n+    reinterpret_cast<uptr *>(alloc_beg)[1] = chunk_beg;\n   }\n   if (using_primary_allocator) {\n     CHECK(size);\n@@ -382,7 +390,7 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n     meta[1] = chunk_beg;\n   }\n \n-  if (flags()->use_stack_depot) {\n+  if (fl.use_stack_depot) {\n     m->alloc_context_id = StackDepotPut(stack->trace, stack->size);\n   } else {\n     m->alloc_context_id = 0;\n@@ -394,12 +402,12 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n   if (size_rounded_down_to_granularity)\n     PoisonShadow(user_beg, size_rounded_down_to_granularity, 0);\n   // Deal with the end of the region if size is not aligned to granularity.\n-  if (size != size_rounded_down_to_granularity && flags()->poison_heap) {\n+  if (size != size_rounded_down_to_granularity && fl.poison_heap) {\n     u8 *shadow = (u8*)MemToShadow(user_beg + size_rounded_down_to_granularity);\n     *shadow = size & (SHADOW_GRANULARITY - 1);\n   }\n \n-  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+  AsanStats &thread_stats = GetCurrentThreadStats();\n   thread_stats.mallocs++;\n   thread_stats.malloced += size;\n   thread_stats.malloced_redzones += needed_size - size;\n@@ -409,48 +417,64 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n     thread_stats.malloc_large++;\n \n   void *res = reinterpret_cast<void *>(user_beg);\n+  if (can_fill && fl.max_malloc_fill_size) {\n+    uptr fill_size = Min(size, (uptr)fl.max_malloc_fill_size);\n+    REAL(memset)(res, fl.malloc_fill_byte, fill_size);\n+  }\n+#if CAN_SANITIZE_LEAKS\n+  m->lsan_tag = __lsan::DisabledInThisThread() ? __lsan::kIgnored\n+                                               : __lsan::kDirectlyLeaked;\n+#endif\n+  // Must be the last mutation of metadata in this function.\n+  atomic_store((atomic_uint8_t *)m, CHUNK_ALLOCATED, memory_order_release);\n   ASAN_MALLOC_HOOK(res, size);\n   return res;\n }\n \n-static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n-  uptr p = reinterpret_cast<uptr>(ptr);\n-  if (p == 0) return;\n-  ASAN_FREE_HOOK(ptr);\n-  uptr chunk_beg = p - kChunkHeaderSize;\n-  AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n+static void ReportInvalidFree(void *ptr, u8 chunk_state, StackTrace *stack) {\n+  if (chunk_state == CHUNK_QUARANTINE)\n+    ReportDoubleFree((uptr)ptr, stack);\n+  else\n+    ReportFreeNotMalloced((uptr)ptr, stack);\n+}\n \n+static void AtomicallySetQuarantineFlag(AsanChunk *m,\n+                                        void *ptr, StackTrace *stack) {\n+  u8 old_chunk_state = CHUNK_ALLOCATED;\n   // Flip the chunk_state atomically to avoid race on double-free.\n-  u8 old_chunk_state = atomic_exchange((atomic_uint8_t*)m, CHUNK_QUARANTINE,\n-                                       memory_order_relaxed);\n+  if (!atomic_compare_exchange_strong((atomic_uint8_t*)m, &old_chunk_state,\n+                                      CHUNK_QUARANTINE, memory_order_acquire))\n+    ReportInvalidFree(ptr, old_chunk_state, stack);\n+  CHECK_EQ(CHUNK_ALLOCATED, old_chunk_state);\n+}\n+\n+// Expects the chunk to already be marked as quarantined by using\n+// AtomicallySetQuarantineFlag.\n+static void QuarantineChunk(AsanChunk *m, void *ptr,\n+                            StackTrace *stack, AllocType alloc_type) {\n+  CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n \n-  if (old_chunk_state == CHUNK_QUARANTINE)\n-    ReportDoubleFree((uptr)ptr, stack);\n-  else if (old_chunk_state != CHUNK_ALLOCATED)\n-    ReportFreeNotMalloced((uptr)ptr, stack);\n-  CHECK(old_chunk_state == CHUNK_ALLOCATED);\n   if (m->alloc_type != alloc_type && flags()->alloc_dealloc_mismatch)\n     ReportAllocTypeMismatch((uptr)ptr, stack,\n                             (AllocType)m->alloc_type, (AllocType)alloc_type);\n \n   CHECK_GE(m->alloc_tid, 0);\n   if (SANITIZER_WORDSIZE == 64)  // On 32-bits this resides in user area.\n     CHECK_EQ(m->free_tid, kInvalidTid);\n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  AsanThread *t = GetCurrentThread();\n   m->free_tid = t ? t->tid() : 0;\n   if (flags()->use_stack_depot) {\n     m->free_context_id = StackDepotPut(stack->trace, stack->size);\n   } else {\n     m->free_context_id = 0;\n     StackTrace::CompressStack(stack, m->FreeStackBeg(), m->FreeStackSize());\n   }\n-  CHECK(m->chunk_state == CHUNK_QUARANTINE);\n   // Poison the region.\n   PoisonShadow(m->Beg(),\n                RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n                kAsanHeapFreeMagic);\n \n-  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+  AsanStats &thread_stats = GetCurrentThreadStats();\n   thread_stats.frees++;\n   thread_stats.freed += m->UsedSize();\n \n@@ -468,57 +492,67 @@ static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n   }\n }\n \n+static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n+  uptr p = reinterpret_cast<uptr>(ptr);\n+  if (p == 0) return;\n+\n+  uptr chunk_beg = p - kChunkHeaderSize;\n+  AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n+  ASAN_FREE_HOOK(ptr);\n+  // Must mark the chunk as quarantined before any changes to its metadata.\n+  AtomicallySetQuarantineFlag(m, ptr, stack);\n+  QuarantineChunk(m, ptr, stack, alloc_type);\n+}\n+\n static void *Reallocate(void *old_ptr, uptr new_size, StackTrace *stack) {\n   CHECK(old_ptr && new_size);\n   uptr p = reinterpret_cast<uptr>(old_ptr);\n   uptr chunk_beg = p - kChunkHeaderSize;\n   AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n \n-  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+  AsanStats &thread_stats = GetCurrentThreadStats();\n   thread_stats.reallocs++;\n   thread_stats.realloced += new_size;\n \n-  CHECK(m->chunk_state == CHUNK_ALLOCATED);\n-  uptr old_size = m->UsedSize();\n-  uptr memcpy_size = Min(new_size, old_size);\n-  void *new_ptr = Allocate(new_size, 8, stack, FROM_MALLOC);\n+  void *new_ptr = Allocate(new_size, 8, stack, FROM_MALLOC, true);\n   if (new_ptr) {\n-    CHECK(REAL(memcpy) != 0);\n+    u8 chunk_state = m->chunk_state;\n+    if (chunk_state != CHUNK_ALLOCATED)\n+      ReportInvalidFree(old_ptr, chunk_state, stack);\n+    CHECK_NE(REAL(memcpy), (void*)0);\n+    uptr memcpy_size = Min(new_size, m->UsedSize());\n+    // If realloc() races with free(), we may start copying freed memory.\n+    // However, we will report racy double-free later anyway.\n     REAL(memcpy)(new_ptr, old_ptr, memcpy_size);\n     Deallocate(old_ptr, stack, FROM_MALLOC);\n   }\n   return new_ptr;\n }\n \n-static AsanChunk *GetAsanChunkByAddr(uptr p) {\n-  void *ptr = reinterpret_cast<void *>(p);\n-  uptr alloc_beg = reinterpret_cast<uptr>(allocator.GetBlockBegin(ptr));\n+// Assumes alloc_beg == allocator.GetBlockBegin(alloc_beg).\n+static AsanChunk *GetAsanChunk(void *alloc_beg) {\n   if (!alloc_beg) return 0;\n-  uptr *memalign_magic = reinterpret_cast<uptr *>(alloc_beg);\n-  if (memalign_magic[0] == kMemalignMagic) {\n-    AsanChunk *m = reinterpret_cast<AsanChunk *>(memalign_magic[1]);\n-    CHECK(m->from_memalign);\n-    return m;\n-  }\n-  if (!allocator.FromPrimary(ptr)) {\n-    uptr *meta = reinterpret_cast<uptr *>(\n-        allocator.GetMetaData(reinterpret_cast<void *>(alloc_beg)));\n+  if (!allocator.FromPrimary(alloc_beg)) {\n+    uptr *meta = reinterpret_cast<uptr *>(allocator.GetMetaData(alloc_beg));\n     AsanChunk *m = reinterpret_cast<AsanChunk *>(meta[1]);\n     return m;\n   }\n-  uptr actual_size = allocator.GetActuallyAllocatedSize(ptr);\n-  CHECK_LE(actual_size, SizeClassMap::kMaxSize);\n-  // We know the actually allocted size, but we don't know the redzone size.\n-  // Just try all possible redzone sizes.\n-  for (u32 rz_log = 0; rz_log < 8; rz_log++) {\n-    u32 rz_size = RZLog2Size(rz_log);\n-    uptr max_possible_size = actual_size - rz_size;\n-    if (ComputeRZLog(max_possible_size) != rz_log)\n-      continue;\n-    return reinterpret_cast<AsanChunk *>(\n-        alloc_beg + rz_size - kChunkHeaderSize);\n-  }\n-  return 0;\n+  uptr *alloc_magic = reinterpret_cast<uptr *>(alloc_beg);\n+  if (alloc_magic[0] == kAllocBegMagic)\n+    return reinterpret_cast<AsanChunk *>(alloc_magic[1]);\n+  return reinterpret_cast<AsanChunk *>(alloc_beg);\n+}\n+\n+static AsanChunk *GetAsanChunkByAddr(uptr p) {\n+  void *alloc_beg = allocator.GetBlockBegin(reinterpret_cast<void *>(p));\n+  return GetAsanChunk(alloc_beg);\n+}\n+\n+// Allocator must be locked when this function is called.\n+static AsanChunk *GetAsanChunkByAddrFastLocked(uptr p) {\n+  void *alloc_beg =\n+      allocator.GetBlockBeginFastLocked(reinterpret_cast<void *>(p));\n+  return GetAsanChunk(alloc_beg);\n }\n \n static uptr AllocationSize(uptr p) {\n@@ -583,33 +617,33 @@ void PrintInternalAllocatorStats() {\n   allocator.PrintStats();\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n                     AllocType alloc_type) {\n-  return Allocate(size, alignment, stack, alloc_type);\n+  return Allocate(size, alignment, stack, alloc_type, true);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n void asan_free(void *ptr, StackTrace *stack, AllocType alloc_type) {\n   Deallocate(ptr, stack, alloc_type);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n void *asan_malloc(uptr size, StackTrace *stack) {\n-  return Allocate(size, 8, stack, FROM_MALLOC);\n+  return Allocate(size, 8, stack, FROM_MALLOC, true);\n }\n \n void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack) {\n-  if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n-  void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC);\n-  if (ptr)\n+  if (CallocShouldReturnNullDueToOverflow(size, nmemb))\n+    return AllocatorReturnNull();\n+  void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC, false);\n+  // If the memory comes from the secondary allocator no need to clear it\n+  // as it comes directly from mmap.\n+  if (ptr && allocator.FromPrimary(ptr))\n     REAL(memset)(ptr, 0, nmemb * size);\n   return ptr;\n }\n \n void *asan_realloc(void *p, uptr size, StackTrace *stack) {\n   if (p == 0)\n-    return Allocate(size, 8, stack, FROM_MALLOC);\n+    return Allocate(size, 8, stack, FROM_MALLOC, true);\n   if (size == 0) {\n     Deallocate(p, stack, FROM_MALLOC);\n     return 0;\n@@ -618,7 +652,7 @@ void *asan_realloc(void *p, uptr size, StackTrace *stack) {\n }\n \n void *asan_valloc(uptr size, StackTrace *stack) {\n-  return Allocate(size, GetPageSizeCached(), stack, FROM_MALLOC);\n+  return Allocate(size, GetPageSizeCached(), stack, FROM_MALLOC, true);\n }\n \n void *asan_pvalloc(uptr size, StackTrace *stack) {\n@@ -628,12 +662,12 @@ void *asan_pvalloc(uptr size, StackTrace *stack) {\n     // pvalloc(0) should allocate one page.\n     size = PageSize;\n   }\n-  return Allocate(size, PageSize, stack, FROM_MALLOC);\n+  return Allocate(size, PageSize, stack, FROM_MALLOC, true);\n }\n \n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                         StackTrace *stack) {\n-  void *ptr = Allocate(size, alignment, stack, FROM_MALLOC);\n+  void *ptr = Allocate(size, alignment, stack, FROM_MALLOC, true);\n   CHECK(IsAligned((uptr)ptr, alignment));\n   *memptr = ptr;\n   return 0;\n@@ -664,6 +698,86 @@ void asan_mz_force_unlock() {\n \n }  // namespace __asan\n \n+// --- Implementation of LSan-specific functions --- {{{1\n+namespace __lsan {\n+void LockAllocator() {\n+  __asan::allocator.ForceLock();\n+}\n+\n+void UnlockAllocator() {\n+  __asan::allocator.ForceUnlock();\n+}\n+\n+void GetAllocatorGlobalRange(uptr *begin, uptr *end) {\n+  *begin = (uptr)&__asan::allocator;\n+  *end = *begin + sizeof(__asan::allocator);\n+}\n+\n+uptr PointsIntoChunk(void* p) {\n+  uptr addr = reinterpret_cast<uptr>(p);\n+  __asan::AsanChunk *m = __asan::GetAsanChunkByAddrFastLocked(addr);\n+  if (!m) return 0;\n+  uptr chunk = m->Beg();\n+  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) && m->AddrIsInside(addr))\n+    return chunk;\n+  return 0;\n+}\n+\n+uptr GetUserBegin(uptr chunk) {\n+  __asan::AsanChunk *m =\n+      __asan::GetAsanChunkByAddrFastLocked(chunk);\n+  CHECK(m);\n+  return m->Beg();\n+}\n+\n+LsanMetadata::LsanMetadata(uptr chunk) {\n+  metadata_ = reinterpret_cast<void *>(chunk - __asan::kChunkHeaderSize);\n+}\n+\n+bool LsanMetadata::allocated() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return m->chunk_state == __asan::CHUNK_ALLOCATED;\n+}\n+\n+ChunkTag LsanMetadata::tag() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return static_cast<ChunkTag>(m->lsan_tag);\n+}\n+\n+void LsanMetadata::set_tag(ChunkTag value) {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  m->lsan_tag = value;\n+}\n+\n+uptr LsanMetadata::requested_size() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return m->UsedSize();\n+}\n+\n+u32 LsanMetadata::stack_trace_id() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return m->alloc_context_id;\n+}\n+\n+void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+  __asan::allocator.ForEachChunk(callback, arg);\n+}\n+\n+IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n+  uptr addr = reinterpret_cast<uptr>(p);\n+  __asan::AsanChunk *m = __asan::GetAsanChunkByAddr(addr);\n+  if (!m) return kIgnoreObjectInvalid;\n+  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) && m->AddrIsInside(addr)) {\n+    if (m->lsan_tag == kIgnored)\n+      return kIgnoreObjectAlreadyIgnored;\n+    m->lsan_tag = __lsan::kIgnored;\n+    return kIgnoreObjectSuccess;\n+  } else {\n+    return kIgnoreObjectInvalid;\n+  }\n+}\n+}  // namespace __lsan\n+\n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n@@ -693,17 +807,14 @@ uptr __asan_get_allocated_size(const void *p) {\n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n // Provide default (no-op) implementation of malloc hooks.\n extern \"C\" {\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void __asan_malloc_hook(void *ptr, uptr size) {\n   (void)ptr;\n   (void)size;\n }\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void __asan_free_hook(void *ptr) {\n   (void)ptr;\n }\n }  // extern \"C\"\n #endif\n-\n-\n-#endif  // ASAN_ALLOCATOR_VERSION"}, {"sha": "26e194415231898dbcd5f602fd591d6ecd775aef", "filename": "libsanitizer/asan/asan_dll_thunk.cc", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_dll_thunk.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,194 @@\n+//===-- asan_dll_thunk.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This file defines a family of thunks that should be statically linked into\n+// the DLLs that have ASan instrumentation in order to delegate the calls to the\n+// shared runtime that lives in the main binary.\n+// See https://code.google.com/p/address-sanitizer/issues/detail?id=209 for the\n+// details.\n+//===----------------------------------------------------------------------===//\n+\n+// Only compile this code when buidling asan_dll_thunk.lib\n+// Using #ifdef rather than relying on Makefiles etc.\n+// simplifies the build procedure.\n+#ifdef ASAN_DLL_THUNK\n+\n+// ----------------- Helper functions and macros --------------------- {{{1\n+extern \"C\" {\n+void *__stdcall GetModuleHandleA(const char *module_name);\n+void *__stdcall GetProcAddress(void *module, const char *proc_name);\n+void abort();\n+}\n+\n+static void *getRealProcAddressOrDie(const char *name) {\n+  void *ret = GetProcAddress(GetModuleHandleA(0), name);\n+  if (!ret)\n+    abort();\n+  return ret;\n+}\n+\n+#define WRAP_V_V(name)                                                         \\\n+  extern \"C\" void name() {                                                     \\\n+    typedef void (*fntype)();                                                  \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    fn();                                                                      \\\n+  }\n+\n+#define WRAP_V_W(name)                                                         \\\n+  extern \"C\" void name(void *arg) {                                            \\\n+    typedef void (*fntype)(void *arg);                                         \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    fn(arg);                                                                   \\\n+  }\n+\n+#define WRAP_V_WW(name)                                                        \\\n+  extern \"C\" void name(void *arg1, void *arg2) {                               \\\n+    typedef void (*fntype)(void *, void *);                                    \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    fn(arg1, arg2);                                                            \\\n+  }\n+\n+#define WRAP_V_WWW(name)                                                       \\\n+  extern \"C\" void name(void *arg1, void *arg2, void *arg3) {                   \\\n+    typedef void *(*fntype)(void *, void *, void *);                           \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    fn(arg1, arg2, arg3);                                                      \\\n+  }\n+\n+#define WRAP_W_V(name)                                                         \\\n+  extern \"C\" void *name() {                                                    \\\n+    typedef void *(*fntype)();                                                 \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    return fn();                                                               \\\n+  }\n+\n+#define WRAP_W_W(name)                                                         \\\n+  extern \"C\" void *name(void *arg) {                                           \\\n+    typedef void *(*fntype)(void *arg);                                        \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    return fn(arg);                                                            \\\n+  }\n+\n+#define WRAP_W_WW(name)                                                        \\\n+  extern \"C\" void *name(void *arg1, void *arg2) {                              \\\n+    typedef void *(*fntype)(void *, void *);                                   \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    return fn(arg1, arg2);                                                     \\\n+  }\n+\n+#define WRAP_W_WWW(name)                                                       \\\n+  extern \"C\" void *name(void *arg1, void *arg2, void *arg3) {                  \\\n+    typedef void *(*fntype)(void *, void *, void *);                           \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    return fn(arg1, arg2, arg3);                                               \\\n+  }\n+\n+#define WRAP_W_WWWW(name)                                                      \\\n+  extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4) {      \\\n+    typedef void *(*fntype)(void *, void *, void *, void *);                   \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    return fn(arg1, arg2, arg3, arg4);                                         \\\n+  }\n+\n+#define WRAP_W_WWWWW(name)                                                     \\\n+  extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4,        \\\n+                        void *arg5) {                                          \\\n+    typedef void *(*fntype)(void *, void *, void *, void *, void *);           \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    return fn(arg1, arg2, arg3, arg4, arg5);                                   \\\n+  }\n+\n+#define WRAP_W_WWWWWW(name)                                                    \\\n+  extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4,        \\\n+                        void *arg5, void *arg6) {                              \\\n+    typedef void *(*fntype)(void *, void *, void *, void *, void *, void *);   \\\n+    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n+    return fn(arg1, arg2, arg3, arg4, arg5, arg6);                             \\\n+  }\n+// }}}\n+\n+// ----------------- ASan own interface functions --------------------\n+WRAP_W_V(__asan_should_detect_stack_use_after_return)\n+\n+extern \"C\" {\n+  int __asan_option_detect_stack_use_after_return;\n+\n+  // Manually wrap __asan_init as we need to initialize\n+  // __asan_option_detect_stack_use_after_return afterwards.\n+  void __asan_init_v3() {\n+    typedef void (*fntype)();\n+    static fntype fn = (fntype)getRealProcAddressOrDie(\"__asan_init_v3\");\n+    fn();\n+    __asan_option_detect_stack_use_after_return =\n+        (__asan_should_detect_stack_use_after_return() != 0);\n+  }\n+}\n+\n+WRAP_V_W(__asan_report_store1)\n+WRAP_V_W(__asan_report_store2)\n+WRAP_V_W(__asan_report_store4)\n+WRAP_V_W(__asan_report_store8)\n+WRAP_V_W(__asan_report_store16)\n+WRAP_V_WW(__asan_report_store_n)\n+\n+WRAP_V_W(__asan_report_load1)\n+WRAP_V_W(__asan_report_load2)\n+WRAP_V_W(__asan_report_load4)\n+WRAP_V_W(__asan_report_load8)\n+WRAP_V_W(__asan_report_load16)\n+WRAP_V_WW(__asan_report_load_n)\n+\n+WRAP_V_WW(__asan_register_globals)\n+WRAP_V_WW(__asan_unregister_globals)\n+\n+WRAP_W_WW(__asan_stack_malloc_0)\n+WRAP_W_WW(__asan_stack_malloc_1)\n+WRAP_W_WW(__asan_stack_malloc_2)\n+WRAP_W_WW(__asan_stack_malloc_3)\n+WRAP_W_WW(__asan_stack_malloc_4)\n+WRAP_W_WW(__asan_stack_malloc_5)\n+WRAP_W_WW(__asan_stack_malloc_6)\n+WRAP_W_WW(__asan_stack_malloc_7)\n+WRAP_W_WW(__asan_stack_malloc_8)\n+WRAP_W_WW(__asan_stack_malloc_9)\n+WRAP_W_WW(__asan_stack_malloc_10)\n+\n+WRAP_V_WWW(__asan_stack_free_0)\n+WRAP_V_WWW(__asan_stack_free_1)\n+WRAP_V_WWW(__asan_stack_free_2)\n+WRAP_V_WWW(__asan_stack_free_4)\n+WRAP_V_WWW(__asan_stack_free_5)\n+WRAP_V_WWW(__asan_stack_free_6)\n+WRAP_V_WWW(__asan_stack_free_7)\n+WRAP_V_WWW(__asan_stack_free_8)\n+WRAP_V_WWW(__asan_stack_free_9)\n+WRAP_V_WWW(__asan_stack_free_10)\n+\n+// TODO(timurrrr): Add more interface functions on the as-needed basis.\n+\n+// ----------------- Memory allocation functions ---------------------\n+WRAP_V_W(free)\n+WRAP_V_WW(_free_dbg)\n+\n+WRAP_W_W(malloc)\n+WRAP_W_WWWW(_malloc_dbg)\n+\n+WRAP_W_WW(calloc)\n+WRAP_W_WWWWW(_calloc_dbg)\n+WRAP_W_WWW(_calloc_impl)\n+\n+WRAP_W_WW(realloc)\n+WRAP_W_WWW(_realloc_dbg)\n+WRAP_W_WWW(_recalloc)\n+\n+WRAP_W_W(_msize)\n+\n+// TODO(timurrrr): Do we need to add _Crt* stuff here? (see asan_malloc_win.cc).\n+\n+#endif // ASAN_DLL_THUNK"}, {"sha": "b9cce88f34f97fddd325ef282eea80c6e0cdef3e", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 154, "deletions": 129, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -10,170 +10,195 @@\n // FakeStack is used to detect use-after-return bugs.\n //===----------------------------------------------------------------------===//\n #include \"asan_allocator.h\"\n+#include \"asan_poisoning.h\"\n #include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n \n namespace __asan {\n \n-FakeStack::FakeStack() {\n-  CHECK(REAL(memset) != 0);\n-  REAL(memset)(this, 0, sizeof(*this));\n+static const u64 kMagic1 = kAsanStackAfterReturnMagic;\n+static const u64 kMagic2 = (kMagic1 << 8) | kMagic1;\n+static const u64 kMagic4 = (kMagic2 << 16) | kMagic2;\n+static const u64 kMagic8 = (kMagic4 << 32) | kMagic4;\n+\n+// For small size classes inline PoisonShadow for better performance.\n+ALWAYS_INLINE void SetShadow(uptr ptr, uptr size, uptr class_id, u64 magic) {\n+  CHECK_EQ(SHADOW_SCALE, 3);  // This code expects SHADOW_SCALE=3.\n+  u64 *shadow = reinterpret_cast<u64*>(MemToShadow(ptr));\n+  if (class_id <= 6) {\n+    for (uptr i = 0; i < (1U << class_id); i++)\n+      shadow[i] = magic;\n+  } else {\n+    // The size class is too big, it's cheaper to poison only size bytes.\n+    PoisonShadow(ptr, size, static_cast<u8>(magic));\n+  }\n }\n \n-bool FakeStack::AddrIsInSizeClass(uptr addr, uptr size_class) {\n-  uptr mem = allocated_size_classes_[size_class];\n-  uptr size = ClassMmapSize(size_class);\n-  bool res = mem && addr >= mem && addr < mem + size;\n+FakeStack *FakeStack::Create(uptr stack_size_log) {\n+  static uptr kMinStackSizeLog = 16;\n+  static uptr kMaxStackSizeLog = FIRST_32_SECOND_64(24, 28);\n+  if (stack_size_log < kMinStackSizeLog)\n+    stack_size_log = kMinStackSizeLog;\n+  if (stack_size_log > kMaxStackSizeLog)\n+    stack_size_log = kMaxStackSizeLog;\n+  FakeStack *res = reinterpret_cast<FakeStack *>(\n+      MmapOrDie(RequiredSize(stack_size_log), \"FakeStack\"));\n+  res->stack_size_log_ = stack_size_log;\n+  if (flags()->verbosity) {\n+    u8 *p = reinterpret_cast<u8 *>(res);\n+    Report(\"T%d: FakeStack created: %p -- %p stack_size_log: %zd \\n\",\n+           GetCurrentTidOrInvalid(), p,\n+           p + FakeStack::RequiredSize(stack_size_log), stack_size_log);\n+  }\n   return res;\n }\n \n-uptr FakeStack::AddrIsInFakeStack(uptr addr) {\n-  for (uptr i = 0; i < kNumberOfSizeClasses; i++) {\n-    if (AddrIsInSizeClass(addr, i)) return allocated_size_classes_[i];\n-  }\n-  return 0;\n+void FakeStack::Destroy() {\n+  PoisonAll(0);\n+  UnmapOrDie(this, RequiredSize(stack_size_log_));\n }\n \n-// We may want to compute this during compilation.\n-inline uptr FakeStack::ComputeSizeClass(uptr alloc_size) {\n-  uptr rounded_size = RoundUpToPowerOfTwo(alloc_size);\n-  uptr log = Log2(rounded_size);\n-  CHECK(alloc_size <= (1UL << log));\n-  if (!(alloc_size > (1UL << (log-1)))) {\n-    Printf(\"alloc_size %zu log %zu\\n\", alloc_size, log);\n-  }\n-  CHECK(alloc_size > (1UL << (log-1)));\n-  uptr res = log < kMinStackFrameSizeLog ? 0 : log - kMinStackFrameSizeLog;\n-  CHECK(res < kNumberOfSizeClasses);\n-  CHECK(ClassSize(res) >= rounded_size);\n-  return res;\n+void FakeStack::PoisonAll(u8 magic) {\n+  PoisonShadow(reinterpret_cast<uptr>(this), RequiredSize(stack_size_log()),\n+               magic);\n }\n \n-void FakeFrameFifo::FifoPush(FakeFrame *node) {\n-  CHECK(node);\n-  node->next = 0;\n-  if (first_ == 0 && last_ == 0) {\n-    first_ = last_ = node;\n-  } else {\n-    CHECK(first_);\n-    CHECK(last_);\n-    last_->next = node;\n-    last_ = node;\n+ALWAYS_INLINE USED\n+FakeFrame *FakeStack::Allocate(uptr stack_size_log, uptr class_id,\n+                               uptr real_stack) {\n+  CHECK_LT(class_id, kNumberOfSizeClasses);\n+  if (needs_gc_)\n+    GC(real_stack);\n+  uptr &hint_position = hint_position_[class_id];\n+  const int num_iter = NumberOfFrames(stack_size_log, class_id);\n+  u8 *flags = GetFlags(stack_size_log, class_id);\n+  for (int i = 0; i < num_iter; i++) {\n+    uptr pos = ModuloNumberOfFrames(stack_size_log, class_id, hint_position++);\n+    // This part is tricky. On one hand, checking and setting flags[pos]\n+    // should be atomic to ensure async-signal safety. But on the other hand,\n+    // if the signal arrives between checking and setting flags[pos], the\n+    // signal handler's fake stack will start from a different hint_position\n+    // and so will not touch this particular byte. So, it is safe to do this\n+    // with regular non-atimic load and store (at least I was not able to make\n+    // this code crash).\n+    if (flags[pos]) continue;\n+    flags[pos] = 1;\n+    FakeFrame *res = reinterpret_cast<FakeFrame *>(\n+        GetFrame(stack_size_log, class_id, pos));\n+    res->real_stack = real_stack;\n+    *SavedFlagPtr(reinterpret_cast<uptr>(res), class_id) = &flags[pos];\n+    return res;\n   }\n+  return 0; // We are out of fake stack.\n }\n \n-FakeFrame *FakeFrameFifo::FifoPop() {\n-  CHECK(first_ && last_ && \"Exhausted fake stack\");\n-  FakeFrame *res = 0;\n-  if (first_ == last_) {\n-    res = first_;\n-    first_ = last_ = 0;\n-  } else {\n-    res = first_;\n-    first_ = first_->next;\n-  }\n-  return res;\n+uptr FakeStack::AddrIsInFakeStack(uptr ptr) {\n+  uptr stack_size_log = this->stack_size_log();\n+  uptr beg = reinterpret_cast<uptr>(GetFrame(stack_size_log, 0, 0));\n+  uptr end = reinterpret_cast<uptr>(this) + RequiredSize(stack_size_log);\n+  if (ptr < beg || ptr >= end) return 0;\n+  uptr class_id = (ptr - beg) >> stack_size_log;\n+  uptr base = beg + (class_id << stack_size_log);\n+  CHECK_LE(base, ptr);\n+  CHECK_LT(ptr, base + (1UL << stack_size_log));\n+  uptr pos = (ptr - base) >> (kMinStackFrameSizeLog + class_id);\n+  return base + pos * BytesInSizeClass(class_id);\n }\n \n-void FakeStack::Init(uptr stack_size) {\n-  stack_size_ = stack_size;\n-  alive_ = true;\n+void FakeStack::HandleNoReturn() {\n+  needs_gc_ = true;\n }\n \n-void FakeStack::Cleanup() {\n-  alive_ = false;\n-  for (uptr i = 0; i < kNumberOfSizeClasses; i++) {\n-    uptr mem = allocated_size_classes_[i];\n-    if (mem) {\n-      PoisonShadow(mem, ClassMmapSize(i), 0);\n-      allocated_size_classes_[i] = 0;\n-      UnmapOrDie((void*)mem, ClassMmapSize(i));\n+// When throw, longjmp or some such happens we don't call OnFree() and\n+// as the result may leak one or more fake frames, but the good news is that\n+// we are notified about all such events by HandleNoReturn().\n+// If we recently had such no-return event we need to collect garbage frames.\n+// We do it based on their 'real_stack' values -- everything that is lower\n+// than the current real_stack is garbage.\n+NOINLINE void FakeStack::GC(uptr real_stack) {\n+  uptr collected = 0;\n+  for (uptr class_id = 0; class_id < kNumberOfSizeClasses; class_id++) {\n+    u8 *flags = GetFlags(stack_size_log(), class_id);\n+    for (uptr i = 0, n = NumberOfFrames(stack_size_log(), class_id); i < n;\n+         i++) {\n+      if (flags[i] == 0) continue;  // not allocated.\n+      FakeFrame *ff = reinterpret_cast<FakeFrame *>(\n+          GetFrame(stack_size_log(), class_id, i));\n+      if (ff->real_stack < real_stack) {\n+        flags[i] = 0;\n+        collected++;\n+      }\n     }\n   }\n+  needs_gc_ = false;\n }\n \n-uptr FakeStack::ClassMmapSize(uptr size_class) {\n-  return RoundUpToPowerOfTwo(stack_size_);\n-}\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+static THREADLOCAL FakeStack *fake_stack_tls;\n \n-void FakeStack::AllocateOneSizeClass(uptr size_class) {\n-  CHECK(ClassMmapSize(size_class) >= GetPageSizeCached());\n-  uptr new_mem = (uptr)MmapOrDie(\n-      ClassMmapSize(size_class), __FUNCTION__);\n-  // Printf(\"T%d new_mem[%zu]: %p-%p mmap %zu\\n\",\n-  //       asanThreadRegistry().GetCurrent()->tid(),\n-  //       size_class, new_mem, new_mem + ClassMmapSize(size_class),\n-  //       ClassMmapSize(size_class));\n-  uptr i;\n-  for (i = 0; i < ClassMmapSize(size_class);\n-       i += ClassSize(size_class)) {\n-    size_classes_[size_class].FifoPush((FakeFrame*)(new_mem + i));\n-  }\n-  CHECK(i == ClassMmapSize(size_class));\n-  allocated_size_classes_[size_class] = new_mem;\n+FakeStack *GetTLSFakeStack() {\n+  return fake_stack_tls;\n+}\n+void SetTLSFakeStack(FakeStack *fs) {\n+  fake_stack_tls = fs;\n+}\n+#else\n+FakeStack *GetTLSFakeStack() { return 0; }\n+void SetTLSFakeStack(FakeStack *fs) { }\n+#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+\n+static FakeStack *GetFakeStack() {\n+  AsanThread *t = GetCurrentThread();\n+  if (!t) return 0;\n+  return t->fake_stack();\n }\n \n-uptr FakeStack::AllocateStack(uptr size, uptr real_stack) {\n-  if (!alive_) return real_stack;\n-  CHECK(size <= kMaxStackMallocSize && size > 1);\n-  uptr size_class = ComputeSizeClass(size);\n-  if (!allocated_size_classes_[size_class]) {\n-    AllocateOneSizeClass(size_class);\n-  }\n-  FakeFrame *fake_frame = size_classes_[size_class].FifoPop();\n-  CHECK(fake_frame);\n-  fake_frame->size_minus_one = size - 1;\n-  fake_frame->real_stack = real_stack;\n-  while (FakeFrame *top = call_stack_.top()) {\n-    if (top->real_stack > real_stack) break;\n-    call_stack_.LifoPop();\n-    DeallocateFrame(top);\n-  }\n-  call_stack_.LifoPush(fake_frame);\n-  uptr ptr = (uptr)fake_frame;\n-  PoisonShadow(ptr, size, 0);\n-  return ptr;\n+static FakeStack *GetFakeStackFast() {\n+  if (FakeStack *fs = GetTLSFakeStack())\n+    return fs;\n+  if (!__asan_option_detect_stack_use_after_return)\n+    return 0;\n+  return GetFakeStack();\n }\n \n-void FakeStack::DeallocateFrame(FakeFrame *fake_frame) {\n-  CHECK(alive_);\n-  uptr size = fake_frame->size_minus_one + 1;\n-  uptr size_class = ComputeSizeClass(size);\n-  CHECK(allocated_size_classes_[size_class]);\n-  uptr ptr = (uptr)fake_frame;\n-  CHECK(AddrIsInSizeClass(ptr, size_class));\n-  CHECK(AddrIsInSizeClass(ptr + size - 1, size_class));\n-  size_classes_[size_class].FifoPush(fake_frame);\n+ALWAYS_INLINE uptr OnMalloc(uptr class_id, uptr size, uptr real_stack) {\n+  FakeStack *fs = GetFakeStackFast();\n+  if (!fs) return real_stack;\n+  FakeFrame *ff = fs->Allocate(fs->stack_size_log(), class_id, real_stack);\n+  if (!ff)\n+    return real_stack;  // Out of fake stack, return the real one.\n+  uptr ptr = reinterpret_cast<uptr>(ff);\n+  SetShadow(ptr, size, class_id, 0);\n+  return ptr;\n }\n \n-void FakeStack::OnFree(uptr ptr, uptr size, uptr real_stack) {\n-  FakeFrame *fake_frame = (FakeFrame*)ptr;\n-  CHECK(fake_frame->magic = kRetiredStackFrameMagic);\n-  CHECK(fake_frame->descr != 0);\n-  CHECK(fake_frame->size_minus_one == size - 1);\n-  PoisonShadow(ptr, size, kAsanStackAfterReturnMagic);\n+ALWAYS_INLINE void OnFree(uptr ptr, uptr class_id, uptr size, uptr real_stack) {\n+  if (ptr == real_stack)\n+    return;\n+  FakeStack::Deallocate(ptr, class_id);\n+  SetShadow(ptr, size, class_id, kMagic8);\n }\n \n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n-uptr __asan_stack_malloc(uptr size, uptr real_stack) {\n-  if (!flags()->use_fake_stack) return real_stack;\n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n-  if (!t) {\n-    // TSD is gone, use the real stack.\n-    return real_stack;\n+#define DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(class_id)                       \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr                                \\\n+  __asan_stack_malloc_##class_id(uptr size, uptr real_stack) {                 \\\n+    return __asan::OnMalloc(class_id, size, real_stack);                       \\\n+  }                                                                            \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __asan_stack_free_##class_id(  \\\n+      uptr ptr, uptr size, uptr real_stack) {                                  \\\n+    __asan::OnFree(ptr, class_id, size, real_stack);                           \\\n   }\n-  uptr ptr = t->fake_stack().AllocateStack(size, real_stack);\n-  // Printf(\"__asan_stack_malloc %p %zu %p\\n\", ptr, size, real_stack);\n-  return ptr;\n-}\n \n-void __asan_stack_free(uptr ptr, uptr size, uptr real_stack) {\n-  if (!flags()->use_fake_stack) return;\n-  if (ptr != real_stack) {\n-    FakeStack::OnFree(ptr, size, real_stack);\n-  }\n-}\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(0)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(1)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(2)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(3)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(4)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(5)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(6)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(7)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(8)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(9)\n+DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(10)"}, {"sha": "4287497fd5d88a8b7caae35f1f26c546959daabf", "filename": "libsanitizer/asan/asan_fake_stack.h", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_fake_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_fake_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,167 @@\n+//===-- asan_fake_stack.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_fake_stack.cc, implements FakeStack.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_FAKE_STACK_H\n+#define ASAN_FAKE_STACK_H\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+namespace __asan {\n+\n+// Fake stack frame contains local variables of one function.\n+struct FakeFrame {\n+  uptr magic;  // Modified by the instrumented code.\n+  uptr descr;  // Modified by the instrumented code.\n+  uptr pc;     // Modified by the instrumented code.\n+  uptr real_stack;\n+};\n+\n+// For each thread we create a fake stack and place stack objects on this fake\n+// stack instead of the real stack. The fake stack is not really a stack but\n+// a fast malloc-like allocator so that when a function exits the fake stack\n+// is not popped but remains there for quite some time until gets used again.\n+// So, we poison the objects on the fake stack when function returns.\n+// It helps us find use-after-return bugs.\n+//\n+// The FakeStack objects is allocated by a single mmap call and has no other\n+// pointers. The size of the fake stack depends on the actual thread stack size\n+// and thus can not be a constant.\n+// stack_size is a power of two greater or equal to the thread's stack size;\n+// we store it as its logarithm (stack_size_log).\n+// FakeStack has kNumberOfSizeClasses (11) size classes, each size class\n+// is a power of two, starting from 64 bytes. Each size class occupies\n+// stack_size bytes and thus can allocate\n+// NumberOfFrames=(stack_size/BytesInSizeClass) fake frames (also a power of 2).\n+// For each size class we have NumberOfFrames allocation flags,\n+// each flag indicates whether the given frame is currently allocated.\n+// All flags for size classes 0 .. 10 are stored in a single contiguous region\n+// followed by another contiguous region which contains the actual memory for\n+// size classes. The addresses are computed by GetFlags and GetFrame without\n+// any memory accesses solely based on 'this' and stack_size_log.\n+// Allocate() flips the appropriate allocation flag atomically, thus achieving\n+// async-signal safety.\n+// This allocator does not have quarantine per se, but it tries to allocate the\n+// frames in round robin fasion to maximize the delay between a deallocation\n+// and the next allocation.\n+class FakeStack {\n+  static const uptr kMinStackFrameSizeLog = 6;  // Min frame is 64B.\n+  static const uptr kMaxStackFrameSizeLog = 16;  // Max stack frame is 64K.\n+\n+ public:\n+  static const uptr kNumberOfSizeClasses =\n+       kMaxStackFrameSizeLog - kMinStackFrameSizeLog + 1;\n+\n+  // CTOR: create the FakeStack as a single mmap-ed object.\n+  static FakeStack *Create(uptr stack_size_log);\n+\n+  void Destroy();\n+\n+  // stack_size_log is at least 15 (stack_size >= 32K).\n+  static uptr SizeRequiredForFlags(uptr stack_size_log) {\n+    return 1UL << (stack_size_log + 1 - kMinStackFrameSizeLog);\n+  }\n+\n+  // Each size class occupies stack_size bytes.\n+  static uptr SizeRequiredForFrames(uptr stack_size_log) {\n+    return (1ULL << stack_size_log) * kNumberOfSizeClasses;\n+  }\n+\n+  // Number of bytes requires for the whole object.\n+  static uptr RequiredSize(uptr stack_size_log) {\n+    return kFlagsOffset + SizeRequiredForFlags(stack_size_log) +\n+           SizeRequiredForFrames(stack_size_log);\n+  }\n+\n+  // Offset of the given flag from the first flag.\n+  // The flags for class 0 begin at offset  000000000\n+  // The flags for class 1 begin at offset  100000000\n+  // ....................2................  110000000\n+  // ....................3................  111000000\n+  // and so on.\n+  static uptr FlagsOffset(uptr stack_size_log, uptr class_id) {\n+    uptr t = kNumberOfSizeClasses - 1 - class_id;\n+    const uptr all_ones = (1 << (kNumberOfSizeClasses - 1)) - 1;\n+    return ((all_ones >> t) << t) << (stack_size_log - 15);\n+  }\n+\n+  static uptr NumberOfFrames(uptr stack_size_log, uptr class_id) {\n+    return 1UL << (stack_size_log - kMinStackFrameSizeLog - class_id);\n+  }\n+\n+  // Divide n by the numbe of frames in size class.\n+  static uptr ModuloNumberOfFrames(uptr stack_size_log, uptr class_id, uptr n) {\n+    return n & (NumberOfFrames(stack_size_log, class_id) - 1);\n+  }\n+\n+  // The the pointer to the flags of the given class_id.\n+  u8 *GetFlags(uptr stack_size_log, uptr class_id) {\n+    return reinterpret_cast<u8 *>(this) + kFlagsOffset +\n+           FlagsOffset(stack_size_log, class_id);\n+  }\n+\n+  // Get frame by class_id and pos.\n+  u8 *GetFrame(uptr stack_size_log, uptr class_id, uptr pos) {\n+    return reinterpret_cast<u8 *>(this) + kFlagsOffset +\n+           SizeRequiredForFlags(stack_size_log) +\n+           (1 << stack_size_log) * class_id + BytesInSizeClass(class_id) * pos;\n+  }\n+\n+  // Allocate the fake frame.\n+  FakeFrame *Allocate(uptr stack_size_log, uptr class_id, uptr real_stack);\n+\n+  // Deallocate the fake frame: read the saved flag address and write 0 there.\n+  static void Deallocate(uptr x, uptr class_id) {\n+    **SavedFlagPtr(x, class_id) = 0;\n+  }\n+\n+  // Poison the entire FakeStack's shadow with the magic value.\n+  void PoisonAll(u8 magic);\n+\n+  // Return the beginning of the FakeFrame or 0 if the address is not ours.\n+  uptr AddrIsInFakeStack(uptr addr);\n+\n+  // Number of bytes in a fake frame of this size class.\n+  static uptr BytesInSizeClass(uptr class_id) {\n+    return 1UL << (class_id + kMinStackFrameSizeLog);\n+  }\n+\n+  // The fake frame is guaranteed to have a right redzone.\n+  // We use the last word of that redzone to store the address of the flag\n+  // that corresponds to the current frame to make faster deallocation.\n+  static u8 **SavedFlagPtr(uptr x, uptr class_id) {\n+    return reinterpret_cast<u8 **>(x + BytesInSizeClass(class_id) - sizeof(x));\n+  }\n+\n+  uptr stack_size_log() const { return stack_size_log_; }\n+\n+  void HandleNoReturn();\n+  void GC(uptr real_stack);\n+\n+ private:\n+  FakeStack() { }\n+  static const uptr kFlagsOffset = 4096;  // This is were the flags begin.\n+  // Must match the number of uses of DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID\n+  COMPILER_CHECK(kNumberOfSizeClasses == 11);\n+  static const uptr kMaxStackMallocSize = 1 << kMaxStackFrameSizeLog;\n+\n+  uptr hint_position_[kNumberOfSizeClasses];\n+  uptr stack_size_log_;\n+  // a bit is set if something was allocated from the corresponding size class.\n+  bool needs_gc_;\n+};\n+\n+FakeStack *GetTLSFakeStack();\n+void SetTLSFakeStack(FakeStack *fs);\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_FAKE_STACK_H"}, {"sha": "c115997ff29d4c3414c6cae7f541328e4d15d037", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -30,8 +30,6 @@ struct Flags {\n   // Lower value may reduce memory usage but increase the chance of\n   // false negatives.\n   int  quarantine_size;\n-  // If set, uses in-process symbolizer from common sanitizer runtime.\n-  bool symbolize;\n   // Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\n   int  verbosity;\n   // Size (in bytes) of redzones around heap objects.\n@@ -45,20 +43,20 @@ struct Flags {\n   int  report_globals;\n   // If set, attempts to catch initialization order issues.\n   bool check_initialization_order;\n-  // Max number of stack frames kept for each allocation/deallocation.\n-  int  malloc_context_size;\n   // If set, uses custom wrappers and replacements for libc string functions\n   // to find more errors.\n   bool replace_str;\n   // If set, uses custom wrappers for memset/memcpy/memmove intinsics.\n   bool replace_intrin;\n   // Used on Mac only.\n   bool mac_ignore_invalid_free;\n-  // ASan allocator flag. See asan_allocator.cc.\n-  bool use_fake_stack;\n-  // ASan allocator flag. Sets the maximal size of allocation request\n-  // that would return memory filled with zero bytes.\n-  int  max_malloc_fill_size;\n+  // Enables stack-use-after-return checking at run-time.\n+  bool detect_stack_use_after_return;\n+  // The minimal fake stack size log.\n+  int uar_stack_size_log;\n+  // ASan allocator flag. max_malloc_fill_size is the maximal amount of bytes\n+  // that will be filled with malloc_fill_byte on malloc.\n+  int max_malloc_fill_size, malloc_fill_byte;\n   // Override exit status if something was reported.\n   int  exitcode;\n   // If set, user may manually mark memory regions as poisoned or unpoisoned.\n@@ -69,6 +67,8 @@ struct Flags {\n   int  sleep_before_dying;\n   // If set, registers ASan custom segv handler.\n   bool handle_segv;\n+  // If set, allows user register segv handler even if ASan registers one.\n+  bool allow_user_segv_handler;\n   // If set, uses alternate stack for signal handling.\n   bool use_sigaltstack;\n   // Allow the users to work around the bug in Nvidia drivers prior to 295.*.\n@@ -89,28 +89,29 @@ struct Flags {\n   // Allow the tool to re-exec the program. This may interfere badly with the\n   // debugger.\n   bool allow_reexec;\n-  // Strips this prefix from file paths in error reports.\n-  const char *strip_path_prefix;\n   // If set, prints not only thread creation stacks for threads in error report,\n   // but also thread creation stacks for threads that created those threads,\n   // etc. up to main thread.\n   bool print_full_thread_history;\n-  // ASan will write logs to \"log_path.pid\" instead of stderr.\n-  const char *log_path;\n-  // Use fast (frame-pointer-based) unwinder on fatal errors (if available).\n-  bool fast_unwind_on_fatal;\n-  // Use fast (frame-pointer-based) unwinder on malloc/free (if available).\n-  bool fast_unwind_on_malloc;\n   // Poison (or not) the heap memory on [de]allocation. Zero value is useful\n   // for benchmarking the allocator or instrumentator.\n   bool poison_heap;\n   // Report errors on malloc/delete, new/free, new/delete[], etc.\n   bool alloc_dealloc_mismatch;\n   // Use stack depot instead of storing stacks in the redzones.\n   bool use_stack_depot;\n+  // If true, assume that memcmp(p1, p2, n) always reads n bytes before\n+  // comparing p1 and p2.\n+  bool strict_memcmp;\n+  // If true, assume that dynamic initializers can never access globals from\n+  // other modules, even if the latter are already initialized.\n+  bool strict_init_order;\n };\n \n-Flags *flags();\n+extern Flags asan_flags_dont_use_directly;\n+inline Flags *flags() {\n+  return &asan_flags_dont_use_directly;\n+}\n void InitializeFlags(Flags *f, const char *env);\n \n }  // namespace __asan"}, {"sha": "96985af71a9fb71b97e204956144c102ee7ff28a", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -12,11 +12,14 @@\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n \n namespace __asan {\n \n@@ -30,31 +33,47 @@ struct ListOfGlobals {\n static BlockingMutex mu_for_globals(LINKER_INITIALIZED);\n static LowLevelAllocator allocator_for_globals;\n static ListOfGlobals *list_of_all_globals;\n-static ListOfGlobals *list_of_dynamic_init_globals;\n \n-void PoisonRedZones(const Global &g)  {\n+static const int kDynamicInitGlobalsInitialCapacity = 512;\n+struct DynInitGlobal {\n+  Global g;\n+  bool initialized;\n+};\n+typedef InternalMmapVector<DynInitGlobal> VectorOfGlobals;\n+// Lazy-initialized and never deleted.\n+static VectorOfGlobals *dynamic_init_globals;\n+\n+ALWAYS_INLINE void PoisonShadowForGlobal(const Global *g, u8 value) {\n+  FastPoisonShadow(g->beg, g->size_with_redzone, value);\n+}\n+\n+ALWAYS_INLINE void PoisonRedZones(const Global &g) {\n   uptr aligned_size = RoundUpTo(g.size, SHADOW_GRANULARITY);\n-  PoisonShadow(g.beg + aligned_size, g.size_with_redzone - aligned_size,\n-               kAsanGlobalRedzoneMagic);\n+  FastPoisonShadow(g.beg + aligned_size, g.size_with_redzone - aligned_size,\n+                   kAsanGlobalRedzoneMagic);\n   if (g.size != aligned_size) {\n-    // partial right redzone\n-    PoisonShadowPartialRightRedzone(\n+    FastPoisonShadowPartialRightRedzone(\n         g.beg + RoundDownTo(g.size, SHADOW_GRANULARITY),\n         g.size % SHADOW_GRANULARITY,\n         SHADOW_GRANULARITY,\n         kAsanGlobalRedzoneMagic);\n   }\n }\n \n+static void ReportGlobal(const Global &g, const char *prefix) {\n+  Report(\"%s Global: beg=%p size=%zu/%zu name=%s module=%s dyn_init=%zu\\n\",\n+         prefix, (void*)g.beg, g.size, g.size_with_redzone, g.name,\n+         g.module_name, g.has_dynamic_init);\n+}\n+\n bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n   if (!flags()->report_globals) return false;\n   BlockingMutexLock lock(&mu_for_globals);\n   bool res = false;\n   for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n     const Global &g = *l->g;\n     if (flags()->report_globals >= 2)\n-      Report(\"Search Global: beg=%p size=%zu name=%s\\n\",\n-             (void*)g.beg, g.size, (char*)g.name);\n+      ReportGlobal(g, \"Search\");\n     res |= DescribeAddressRelativeToGlobal(addr, size, g);\n   }\n   return res;\n@@ -66,24 +85,26 @@ bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n static void RegisterGlobal(const Global *g) {\n   CHECK(asan_inited);\n   if (flags()->report_globals >= 2)\n-    Report(\"Added Global: beg=%p size=%zu/%zu name=%s dyn.init=%zu\\n\",\n-           (void*)g->beg, g->size, g->size_with_redzone, g->name,\n-           g->has_dynamic_init);\n+    ReportGlobal(*g, \"Added\");\n   CHECK(flags()->report_globals);\n   CHECK(AddrIsInMem(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n-  PoisonRedZones(*g);\n+  if (flags()->poison_heap)\n+    PoisonRedZones(*g);\n   ListOfGlobals *l =\n       (ListOfGlobals*)allocator_for_globals.Allocate(sizeof(ListOfGlobals));\n   l->g = g;\n   l->next = list_of_all_globals;\n   list_of_all_globals = l;\n   if (g->has_dynamic_init) {\n-    l = (ListOfGlobals*)allocator_for_globals.Allocate(sizeof(ListOfGlobals));\n-    l->g = g;\n-    l->next = list_of_dynamic_init_globals;\n-    list_of_dynamic_init_globals = l;\n+    if (dynamic_init_globals == 0) {\n+      void *mem = allocator_for_globals.Allocate(sizeof(VectorOfGlobals));\n+      dynamic_init_globals = new(mem)\n+          VectorOfGlobals(kDynamicInitGlobalsInitialCapacity);\n+    }\n+    DynInitGlobal dyn_global = { *g, false };\n+    dynamic_init_globals->push_back(dyn_global);\n   }\n }\n \n@@ -93,34 +114,26 @@ static void UnregisterGlobal(const Global *g) {\n   CHECK(AddrIsInMem(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n-  PoisonShadow(g->beg, g->size_with_redzone, 0);\n+  if (flags()->poison_heap)\n+    PoisonShadowForGlobal(g, 0);\n   // We unpoison the shadow memory for the global but we do not remove it from\n   // the list because that would require O(n^2) time with the current list\n   // implementation. It might not be worth doing anyway.\n }\n \n-// Poison all shadow memory for a single global.\n-static void PoisonGlobalAndRedzones(const Global *g) {\n-  CHECK(asan_inited);\n-  CHECK(flags()->check_initialization_order);\n-  CHECK(AddrIsInMem(g->beg));\n-  CHECK(AddrIsAlignedByGranularity(g->beg));\n-  CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n-  if (flags()->report_globals >= 3)\n-    Printf(\"DynInitPoison  : %s\\n\", g->name);\n-  PoisonShadow(g->beg, g->size_with_redzone, kAsanInitializationOrderMagic);\n-}\n-\n-static void UnpoisonGlobal(const Global *g) {\n-  CHECK(asan_inited);\n-  CHECK(flags()->check_initialization_order);\n-  CHECK(AddrIsInMem(g->beg));\n-  CHECK(AddrIsAlignedByGranularity(g->beg));\n-  CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n-  if (flags()->report_globals >= 3)\n-    Printf(\"DynInitUnpoison: %s\\n\", g->name);\n-  PoisonShadow(g->beg, g->size_with_redzone, 0);\n-  PoisonRedZones(*g);\n+void StopInitOrderChecking() {\n+  BlockingMutexLock lock(&mu_for_globals);\n+  if (!flags()->check_initialization_order || !dynamic_init_globals)\n+    return;\n+  flags()->check_initialization_order = false;\n+  for (uptr i = 0, n = dynamic_init_globals->size(); i < n; ++i) {\n+    DynInitGlobal &dyn_g = (*dynamic_init_globals)[i];\n+    const Global *g = &dyn_g.g;\n+    // Unpoison the whole global.\n+    PoisonShadowForGlobal(g, 0);\n+    // Poison redzones back.\n+    PoisonRedZones(*g);\n+  }\n }\n \n }  // namespace __asan\n@@ -151,31 +164,47 @@ void __asan_unregister_globals(__asan_global *globals, uptr n) {\n // when all dynamically initialized globals are unpoisoned.  This method\n // poisons all global variables not defined in this TU, so that a dynamic\n // initializer can only touch global variables in the same TU.\n-void __asan_before_dynamic_init(uptr first_addr, uptr last_addr) {\n-  if (!flags()->check_initialization_order) return;\n-  CHECK(list_of_dynamic_init_globals);\n+void __asan_before_dynamic_init(const char *module_name) {\n+  if (!flags()->check_initialization_order ||\n+      !flags()->poison_heap)\n+    return;\n+  bool strict_init_order = flags()->strict_init_order;\n+  CHECK(dynamic_init_globals);\n+  CHECK(module_name);\n+  CHECK(asan_inited);\n   BlockingMutexLock lock(&mu_for_globals);\n-  bool from_current_tu = false;\n-  // The list looks like:\n-  // a => ... => b => last_addr => ... => first_addr => c => ...\n-  // The globals of the current TU reside between last_addr and first_addr.\n-  for (ListOfGlobals *l = list_of_dynamic_init_globals; l; l = l->next) {\n-    if (l->g->beg == last_addr)\n-      from_current_tu = true;\n-    if (!from_current_tu)\n-      PoisonGlobalAndRedzones(l->g);\n-    if (l->g->beg == first_addr)\n-      from_current_tu = false;\n+  if (flags()->report_globals >= 3)\n+    Printf(\"DynInitPoison module: %s\\n\", module_name);\n+  for (uptr i = 0, n = dynamic_init_globals->size(); i < n; ++i) {\n+    DynInitGlobal &dyn_g = (*dynamic_init_globals)[i];\n+    const Global *g = &dyn_g.g;\n+    if (dyn_g.initialized)\n+      continue;\n+    if (g->module_name != module_name)\n+      PoisonShadowForGlobal(g, kAsanInitializationOrderMagic);\n+    else if (!strict_init_order)\n+      dyn_g.initialized = true;\n   }\n-  CHECK(!from_current_tu);\n }\n \n // This method runs immediately after dynamic initialization in each TU, when\n // all dynamically initialized globals except for those defined in the current\n // TU are poisoned.  It simply unpoisons all dynamically initialized globals.\n void __asan_after_dynamic_init() {\n-  if (!flags()->check_initialization_order) return;\n+  if (!flags()->check_initialization_order ||\n+      !flags()->poison_heap)\n+    return;\n+  CHECK(asan_inited);\n   BlockingMutexLock lock(&mu_for_globals);\n-  for (ListOfGlobals *l = list_of_dynamic_init_globals; l; l = l->next)\n-    UnpoisonGlobal(l->g);\n+  // FIXME: Optionally report that we're unpoisoning globals from a module.\n+  for (uptr i = 0, n = dynamic_init_globals->size(); i < n; ++i) {\n+    DynInitGlobal &dyn_g = (*dynamic_init_globals)[i];\n+    const Global *g = &dyn_g.g;\n+    if (!dyn_g.initialized) {\n+      // Unpoison the whole global.\n+      PoisonShadowForGlobal(g, 0);\n+      // Poison redzones back.\n+      PoisonRedZones(*g);\n+    }\n+  }\n }"}, {"sha": "19b53363a5b7cb0c31a1d1efb245fe10f064022e", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "modified", "additions": 11, "deletions": 258, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -12,313 +12,66 @@\n #ifndef ASAN_INTERCEPTED_FUNCTIONS_H\n #define ASAN_INTERCEPTED_FUNCTIONS_H\n \n-#include \"asan_internal.h\"\n-#include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n-#include <stdarg.h>\n-#include <stddef.h>\n-\n-using __sanitizer::uptr;\n-\n // Use macro to describe if specific function should be\n // intercepted on a given platform.\n-#if !defined(_WIN32)\n+#if !SANITIZER_WINDOWS\n # define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 1\n # define ASAN_INTERCEPT__LONGJMP 1\n # define ASAN_INTERCEPT_STRDUP 1\n-# define ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP 1\n # define ASAN_INTERCEPT_INDEX 1\n # define ASAN_INTERCEPT_PTHREAD_CREATE 1\n # define ASAN_INTERCEPT_MLOCKX 1\n #else\n # define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 0\n # define ASAN_INTERCEPT__LONGJMP 0\n # define ASAN_INTERCEPT_STRDUP 0\n-# define ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP 0\n # define ASAN_INTERCEPT_INDEX 0\n # define ASAN_INTERCEPT_PTHREAD_CREATE 0\n # define ASAN_INTERCEPT_MLOCKX 0\n #endif\n \n-#if defined(__linux__)\n+#if SANITIZER_LINUX\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 1\n #else\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n #endif\n \n-#if !defined(__APPLE__)\n+#if !SANITIZER_MAC\n # define ASAN_INTERCEPT_STRNLEN 1\n #else\n # define ASAN_INTERCEPT_STRNLEN 0\n #endif\n \n-#if defined(__linux__) && !defined(ANDROID)\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n # define ASAN_INTERCEPT_SWAPCONTEXT 1\n #else\n # define ASAN_INTERCEPT_SWAPCONTEXT 0\n #endif\n \n-#if !defined(ANDROID) && !defined(_WIN32)\n+#if !SANITIZER_ANDROID && !SANITIZER_WINDOWS\n # define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 1\n #else\n # define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 0\n #endif\n \n-#if !defined(_WIN32)\n+#if !SANITIZER_WINDOWS\n # define ASAN_INTERCEPT_SIGLONGJMP 1\n #else\n # define ASAN_INTERCEPT_SIGLONGJMP 0\n #endif\n \n-#if ASAN_HAS_EXCEPTIONS && !defined(_WIN32)\n+#if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS\n # define ASAN_INTERCEPT___CXA_THROW 1\n #else\n # define ASAN_INTERCEPT___CXA_THROW 0\n #endif\n \n-#define INTERPOSE_FUNCTION(function) \\\n-    { reinterpret_cast<const uptr>(WRAP(function)), \\\n-      reinterpret_cast<const uptr>(function) }\n-\n-#define INTERPOSE_FUNCTION_2(function, wrapper) \\\n-    { reinterpret_cast<const uptr>(wrapper), \\\n-      reinterpret_cast<const uptr>(function) }\n-\n-struct interpose_substitution {\n-  const uptr replacement;\n-  const uptr original;\n-};\n-\n-#define INTERPOSER(func) __attribute__((used)) \\\n-const interpose_substitution substitution_##func[] \\\n-    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n-  INTERPOSE_FUNCTION(func), \\\n-}\n-\n-#define INTERPOSER_2(func, wrapper) __attribute__((used)) \\\n-const interpose_substitution substitution_##func[] \\\n-    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n-  INTERPOSE_FUNCTION_2(func, wrapper), \\\n-}\n-\n-\n-#define DECLARE_FUNCTION_AND_WRAPPER(ret_type, func, ...) \\\n-  ret_type func(__VA_ARGS__); \\\n-  ret_type WRAP(func)(__VA_ARGS__); \\\n-  INTERPOSER(func)\n-\n-// Use extern declarations of intercepted functions on Mac and Windows\n-// to avoid including system headers.\n-#if defined(__APPLE__) || (defined(_WIN32) && !defined(_DLL))\n-extern \"C\" {\n-// signal.h\n-# if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n-struct sigaction;\n-DECLARE_FUNCTION_AND_WRAPPER(int, sigaction, int sig,\n-              const struct sigaction *act,\n-              struct sigaction *oldact);\n-DECLARE_FUNCTION_AND_WRAPPER(void*, signal, int signum, void *handler);\n-# endif\n-\n-// setjmp.h\n-DECLARE_FUNCTION_AND_WRAPPER(void, longjmp, void *env, int value);\n-# if ASAN_INTERCEPT__LONGJMP\n-DECLARE_FUNCTION_AND_WRAPPER(void, _longjmp, void *env, int value);\n-# endif\n-# if ASAN_INTERCEPT_SIGLONGJMP\n-DECLARE_FUNCTION_AND_WRAPPER(void, siglongjmp, void *env, int value);\n-# endif\n-# if ASAN_INTERCEPT___CXA_THROW\n-DECLARE_FUNCTION_AND_WRAPPER(void, __cxa_throw, void *a, void *b, void *c);\n-# endif\n-\n-// string.h / strings.h\n-DECLARE_FUNCTION_AND_WRAPPER(int, memcmp,\n-                             const void *a1, const void *a2, uptr size);\n-DECLARE_FUNCTION_AND_WRAPPER(void*, memmove,\n-                             void *to, const void *from, uptr size);\n-DECLARE_FUNCTION_AND_WRAPPER(void*, memcpy,\n-                             void *to, const void *from, uptr size);\n-DECLARE_FUNCTION_AND_WRAPPER(void*, memset, void *block, int c, uptr size);\n-DECLARE_FUNCTION_AND_WRAPPER(char*, strchr, const char *str, int c);\n-DECLARE_FUNCTION_AND_WRAPPER(char*, strcat,  /* NOLINT */\n-                             char *to, const char* from);\n-DECLARE_FUNCTION_AND_WRAPPER(char*, strncat,\n-                             char *to, const char* from, uptr size);\n-DECLARE_FUNCTION_AND_WRAPPER(char*, strcpy,  /* NOLINT */\n-                             char *to, const char* from);\n-DECLARE_FUNCTION_AND_WRAPPER(char*, strncpy,\n-                             char *to, const char* from, uptr size);\n-DECLARE_FUNCTION_AND_WRAPPER(int, strcmp, const char *s1, const char* s2);\n-DECLARE_FUNCTION_AND_WRAPPER(int, strncmp,\n-                             const char *s1, const char* s2, uptr size);\n-DECLARE_FUNCTION_AND_WRAPPER(uptr, strlen, const char *s);\n-# if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n-DECLARE_FUNCTION_AND_WRAPPER(int, strcasecmp, const char *s1, const char *s2);\n-DECLARE_FUNCTION_AND_WRAPPER(int, strncasecmp,\n-                             const char *s1, const char *s2, uptr n);\n-# endif\n-# if ASAN_INTERCEPT_STRDUP\n-DECLARE_FUNCTION_AND_WRAPPER(char*, strdup, const char *s);\n-# endif\n-# if ASAN_INTERCEPT_STRNLEN\n-DECLARE_FUNCTION_AND_WRAPPER(uptr, strnlen, const char *s, uptr maxlen);\n-# endif\n-# if ASAN_INTERCEPT_INDEX\n-char* index(const char *string, int c);\n-INTERPOSER_2(index, WRAP(strchr));\n-# endif\n-\n-// stdlib.h\n-DECLARE_FUNCTION_AND_WRAPPER(int, atoi, const char *nptr);\n-DECLARE_FUNCTION_AND_WRAPPER(long, atol, const char *nptr);  // NOLINT\n-DECLARE_FUNCTION_AND_WRAPPER(long, strtol, const char *nptr, char **endptr, int base);  // NOLINT\n-# if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n-DECLARE_FUNCTION_AND_WRAPPER(long long, atoll, const char *nptr);  // NOLINT\n-DECLARE_FUNCTION_AND_WRAPPER(long long, strtoll, const char *nptr, char **endptr, int base);  // NOLINT\n-# endif\n-\n-// unistd.h\n-# if SANITIZER_INTERCEPT_READ\n-DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, read, int fd, void *buf, SIZE_T count);\n-# endif\n-# if SANITIZER_INTERCEPT_PREAD\n-DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pread, int fd, void *buf,\n-                             SIZE_T count, OFF_T offset);\n-# endif\n-# if SANITIZER_INTERCEPT_PREAD64\n-DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pread64, int fd, void *buf,\n-                             SIZE_T count, OFF64_T offset);\n-# endif\n-\n-# if SANITIZER_INTERCEPT_WRITE\n-DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, write, int fd, void *ptr, SIZE_T count);\n-# endif\n-# if SANITIZER_INTERCEPT_PWRITE\n-DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pwrite,\n-                             int fd, void *ptr, SIZE_T count, OFF_T offset);\n-# endif\n-\n-# if ASAN_INTERCEPT_MLOCKX\n-// mlock/munlock\n-DECLARE_FUNCTION_AND_WRAPPER(int, mlock, const void *addr, SIZE_T len);\n-DECLARE_FUNCTION_AND_WRAPPER(int, munlock, const void *addr, SIZE_T len);\n-DECLARE_FUNCTION_AND_WRAPPER(int, mlockall, int flags);\n-DECLARE_FUNCTION_AND_WRAPPER(int, munlockall, void);\n-# endif\n-\n-// Windows threads.\n-# if defined(_WIN32)\n-__declspec(dllimport)\n-void* __stdcall CreateThread(void *sec, uptr st, void* start,\n-                             void *arg, DWORD fl, DWORD *id);\n-# endif\n-// Posix threads.\n-# if ASAN_INTERCEPT_PTHREAD_CREATE\n-DECLARE_FUNCTION_AND_WRAPPER(int, pthread_create,\n-                             void *thread, void *attr,\n-                             void *(*start_routine)(void*), void *arg);\n-# endif\n-\n-# if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n-DECLARE_FUNCTION_AND_WRAPPER(void *, localtime, unsigned long *timep);\n-DECLARE_FUNCTION_AND_WRAPPER(void *, localtime_r, unsigned long *timep,\n-                             void *result);\n-DECLARE_FUNCTION_AND_WRAPPER(void *, gmtime, unsigned long *timep);\n-DECLARE_FUNCTION_AND_WRAPPER(void *, gmtime_r, unsigned long *timep,\n-                             void *result);\n-DECLARE_FUNCTION_AND_WRAPPER(char *, ctime, unsigned long *timep);\n-DECLARE_FUNCTION_AND_WRAPPER(char *, ctime_r, unsigned long *timep,\n-                             char *result);\n-DECLARE_FUNCTION_AND_WRAPPER(char *, asctime, void *tm);\n-DECLARE_FUNCTION_AND_WRAPPER(char *, asctime_r, void *tm, char *result);\n-# endif\n-\n-// stdio.h\n-# if SANITIZER_INTERCEPT_SCANF\n-DECLARE_FUNCTION_AND_WRAPPER(int, vscanf, const char *format, va_list ap);\n-DECLARE_FUNCTION_AND_WRAPPER(int, vsscanf, const char *str, const char *format,\n-                             va_list ap);\n-DECLARE_FUNCTION_AND_WRAPPER(int, vfscanf, void *stream, const char *format,\n-                             va_list ap);\n-DECLARE_FUNCTION_AND_WRAPPER(int, scanf, const char *format, ...);\n-DECLARE_FUNCTION_AND_WRAPPER(int, fscanf,\n-                             void* stream, const char *format, ...);\n-DECLARE_FUNCTION_AND_WRAPPER(int, sscanf,  // NOLINT\n-                             const char *str, const char *format, ...);\n-# endif\n-\n-# if defined(__APPLE__)\n-typedef void* pthread_workqueue_t;\n-typedef void* pthread_workitem_handle_t;\n-\n-typedef void* dispatch_group_t;\n-typedef void* dispatch_queue_t;\n-typedef void* dispatch_source_t;\n-typedef u64 dispatch_time_t;\n-typedef void (*dispatch_function_t)(void *block);\n-typedef void* (*worker_t)(void *block);\n-\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_async_f,\n-                             dispatch_queue_t dq,\n-                             void *ctxt, dispatch_function_t func);\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_sync_f,\n-                             dispatch_queue_t dq,\n-                             void *ctxt, dispatch_function_t func);\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_after_f,\n-                             dispatch_time_t when, dispatch_queue_t dq,\n-                             void *ctxt, dispatch_function_t func);\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_barrier_async_f,\n-                             dispatch_queue_t dq,\n-                             void *ctxt, dispatch_function_t func);\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async_f,\n-                             dispatch_group_t group, dispatch_queue_t dq,\n-                             void *ctxt, dispatch_function_t func);\n-\n-#  if !defined(MISSING_BLOCKS_SUPPORT)\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async,\n-                             dispatch_group_t dg,\n-                             dispatch_queue_t dq, void (^work)(void));\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_async,\n-                             dispatch_queue_t dq, void (^work)(void));\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_after,\n-                             dispatch_queue_t dq, void (^work)(void));\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_event_handler,\n-                             dispatch_source_t ds, void (^work)(void));\n-DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_cancel_handler,\n-                             dispatch_source_t ds, void (^work)(void));\n-#  endif  // MISSING_BLOCKS_SUPPORT\n-\n-typedef void malloc_zone_t;\n-typedef size_t vm_size_t;\n-DECLARE_FUNCTION_AND_WRAPPER(malloc_zone_t *, malloc_create_zone,\n-                             vm_size_t start_size, unsigned flags);\n-DECLARE_FUNCTION_AND_WRAPPER(malloc_zone_t *, malloc_default_zone, void);\n-DECLARE_FUNCTION_AND_WRAPPER(\n-    malloc_zone_t *, malloc_default_purgeable_zone, void);\n-DECLARE_FUNCTION_AND_WRAPPER(void, malloc_make_purgeable, void *ptr);\n-DECLARE_FUNCTION_AND_WRAPPER(int, malloc_make_nonpurgeable, void *ptr);\n-DECLARE_FUNCTION_AND_WRAPPER(void, malloc_set_zone_name,\n-                             malloc_zone_t *zone, const char *name);\n-DECLARE_FUNCTION_AND_WRAPPER(void *, malloc, size_t size);\n-DECLARE_FUNCTION_AND_WRAPPER(void, free, void *ptr);\n-DECLARE_FUNCTION_AND_WRAPPER(void *, realloc, void *ptr, size_t size);\n-DECLARE_FUNCTION_AND_WRAPPER(void *, calloc, size_t nmemb, size_t size);\n-DECLARE_FUNCTION_AND_WRAPPER(void *, valloc, size_t size);\n-DECLARE_FUNCTION_AND_WRAPPER(size_t, malloc_good_size, size_t size);\n-DECLARE_FUNCTION_AND_WRAPPER(int, posix_memalign,\n-                             void **memptr, size_t alignment, size_t size);\n-#if 0\n-DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_prepare, void);\n-DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_parent, void);\n-DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_child, void);\n+#if !SANITIZER_WINDOWS\n+# define ASAN_INTERCEPT___CXA_ATEXIT 1\n+#else\n+# define ASAN_INTERCEPT___CXA_ATEXIT 0\n #endif\n \n-\n-\n-# endif  // __APPLE__\n-}  // extern \"C\"\n-#endif  // defined(__APPLE__) || (defined(_WIN32) && !defined(_DLL))\n-\n #endif  // ASAN_INTERCEPTED_FUNCTIONS_H"}, {"sha": "6fa968da0a38ff0caaa9172993a87bccf72efb73", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 171, "deletions": 155, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -15,10 +15,10 @@\n #include \"asan_intercepted_functions.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n-#include \"asan_thread_registry.h\"\n #include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n@@ -42,15 +42,16 @@ static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n #define ACCESS_MEMORY_RANGE(offset, size, isWrite) do {                 \\\n     uptr __offset = (uptr)(offset);                                     \\\n     uptr __size = (uptr)(size);                                         \\\n+    uptr __bad = 0;                                                     \\\n     if (!QuickCheckForUnpoisonedRegion(__offset, __size) &&             \\\n-        __asan_region_is_poisoned(__offset, __size)) {                  \\\n+        (__bad = __asan_region_is_poisoned(__offset, __size))) {        \\\n       GET_CURRENT_PC_BP_SP;                                             \\\n-      __asan_report_error(pc, bp, sp, __offset, isWrite, __size);       \\\n+      __asan_report_error(pc, bp, sp, __bad, isWrite, __size);          \\\n     }                                                                   \\\n   } while (0)\n \n #define ASAN_READ_RANGE(offset, size) ACCESS_MEMORY_RANGE(offset, size, false)\n-#define ASAN_WRITE_RANGE(offset, size) ACCESS_MEMORY_RANGE(offset, size, true);\n+#define ASAN_WRITE_RANGE(offset, size) ACCESS_MEMORY_RANGE(offset, size, true)\n \n // Behavior of functions like \"memcpy\" or \"strcpy\" is undefined\n // if memory intervals overlap. We report error in this case.\n@@ -86,66 +87,102 @@ static inline uptr MaybeRealStrnlen(const char *s, uptr maxlen) {\n }\n \n void SetThreadName(const char *name) {\n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  AsanThread *t = GetCurrentThread();\n   if (t)\n-    t->summary()->set_name(name);\n+    asanThreadRegistry().SetThreadName(t->tid(), name);\n }\n \n }  // namespace __asan\n \n // ---------------------- Wrappers ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n+DECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr)\n+DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n+\n+#define COMMON_INTERCEPTOR_UNPOISON_PARAM(ctx, count) \\\n+  do {                                                \\\n+  } while (false)\n #define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size) \\\n   ASAN_WRITE_RANGE(ptr, size)\n #define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size) ASAN_READ_RANGE(ptr, size)\n-#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...) \\\n-  do {                                           \\\n-    ctx = 0;                                     \\\n-    (void)ctx;                                   \\\n-    ENSURE_ASAN_INITED();                        \\\n+#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...)              \\\n+  do {                                                        \\\n+    if (asan_init_is_running) return REAL(func)(__VA_ARGS__); \\\n+    ctx = 0;                                                  \\\n+    (void) ctx;                                               \\\n+    ENSURE_ASAN_INITED();                                     \\\n+  } while (false)\n+#define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n+  do {                                         \\\n+  } while (false)\n+#define COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd) \\\n+  do {                                         \\\n+  } while (false)\n+#define COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, newfd) \\\n+  do {                                                      \\\n   } while (false)\n-#define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) do { } while (false)\n-#define COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd) do { } while (false)\n #define COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, name) SetThreadName(name)\n+#define COMMON_INTERCEPTOR_BLOCK_REAL(name) REAL(name)\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n \n+#define COMMON_SYSCALL_PRE_READ_RANGE(p, s) ASAN_READ_RANGE(p, s)\n+#define COMMON_SYSCALL_PRE_WRITE_RANGE(p, s) ASAN_WRITE_RANGE(p, s)\n+#define COMMON_SYSCALL_POST_READ_RANGE(p, s) \\\n+  do {                                       \\\n+  } while (false)\n+#define COMMON_SYSCALL_POST_WRITE_RANGE(p, s) \\\n+  do {                                        \\\n+  } while (false)\n+#include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n+\n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n   AsanThread *t = (AsanThread*)arg;\n-  asanThreadRegistry().SetCurrent(t);\n-  return t->ThreadStart();\n+  SetCurrentThread(t);\n+  return t->ThreadStart(GetTid());\n }\n \n #if ASAN_INTERCEPT_PTHREAD_CREATE\n+extern \"C\" int pthread_attr_getdetachstate(void *attr, int *v);\n+\n INTERCEPTOR(int, pthread_create, void *thread,\n     void *attr, void *(*start_routine)(void*), void *arg) {\n+  EnsureMainThreadIDIsCorrect();\n+  // Strict init-order checking in thread-hostile.\n+  if (flags()->strict_init_order)\n+    StopInitOrderChecking();\n   GET_STACK_TRACE_THREAD;\n-  u32 current_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n-  AsanThread *t = AsanThread::Create(current_tid, start_routine, arg, &stack);\n-  asanThreadRegistry().RegisterThread(t);\n+  int detached = 0;\n+  if (attr != 0)\n+    pthread_attr_getdetachstate(attr, &detached);\n+\n+  u32 current_tid = GetCurrentTidOrInvalid();\n+  AsanThread *t = AsanThread::Create(start_routine, arg);\n+  CreateThreadContextArgs args = { t, &stack };\n+  asanThreadRegistry().CreateThread(*(uptr*)t, detached, current_tid, &args);\n   return REAL(pthread_create)(thread, attr, asan_thread_start, t);\n }\n #endif  // ASAN_INTERCEPT_PTHREAD_CREATE\n \n #if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n INTERCEPTOR(void*, signal, int signum, void *handler) {\n-  if (!AsanInterceptsSignal(signum)) {\n+  if (!AsanInterceptsSignal(signum) || flags()->allow_user_segv_handler) {\n     return REAL(signal)(signum, handler);\n   }\n   return 0;\n }\n \n INTERCEPTOR(int, sigaction, int signum, const struct sigaction *act,\n                             struct sigaction *oldact) {\n-  if (!AsanInterceptsSignal(signum)) {\n+  if (!AsanInterceptsSignal(signum) || flags()->allow_user_segv_handler) {\n     return REAL(sigaction)(signum, act, oldact);\n   }\n   return 0;\n }\n-#elif ASAN_POSIX\n+#elif SANITIZER_POSIX\n // We need to have defined REAL(sigaction) on posix systems.\n DEFINE_REAL(int, sigaction, int signum, const struct sigaction *act,\n-    struct sigaction *oldact);\n+    struct sigaction *oldact)\n #endif  // ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n \n #if ASAN_INTERCEPT_SWAPCONTEXT\n@@ -215,13 +252,15 @@ INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n // Since asan maps 16T of RAM, mlock is completely unfriendly to asan.\n // All functions return 0 (success).\n static void MlockIsUnsupported() {\n-  static bool printed = 0;\n+  static bool printed = false;\n   if (printed) return;\n   printed = true;\n-  Printf(\"INFO: AddressSanitizer ignores mlock/mlockall/munlock/munlockall\\n\");\n+  if (flags()->verbosity > 0) {\n+    Printf(\"INFO: AddressSanitizer ignores \"\n+           \"mlock/mlockall/munlock/munlockall\\n\");\n+  }\n }\n \n-extern \"C\" {\n INTERCEPTOR(int, mlock, const void *addr, uptr len) {\n   MlockIsUnsupported();\n   return 0;\n@@ -241,36 +280,56 @@ INTERCEPTOR(int, munlockall, void) {\n   MlockIsUnsupported();\n   return 0;\n }\n-}  // extern \"C\"\n \n static inline int CharCmp(unsigned char c1, unsigned char c2) {\n   return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n }\n \n-static inline int CharCaseCmp(unsigned char c1, unsigned char c2) {\n-  int c1_low = ToLower(c1);\n-  int c2_low = ToLower(c2);\n-  return c1_low - c2_low;\n-}\n-\n INTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n   if (!asan_inited) return internal_memcmp(a1, a2, size);\n   ENSURE_ASAN_INITED();\n-  unsigned char c1 = 0, c2 = 0;\n-  const unsigned char *s1 = (const unsigned char*)a1;\n-  const unsigned char *s2 = (const unsigned char*)a2;\n-  uptr i;\n-  for (i = 0; i < size; i++) {\n-    c1 = s1[i];\n-    c2 = s2[i];\n-    if (c1 != c2) break;\n+  if (flags()->replace_intrin) {\n+    if (flags()->strict_memcmp) {\n+      // Check the entire regions even if the first bytes of the buffers are\n+      // different.\n+      ASAN_READ_RANGE(a1, size);\n+      ASAN_READ_RANGE(a2, size);\n+      // Fallthrough to REAL(memcmp) below.\n+    } else {\n+      unsigned char c1 = 0, c2 = 0;\n+      const unsigned char *s1 = (const unsigned char*)a1;\n+      const unsigned char *s2 = (const unsigned char*)a2;\n+      uptr i;\n+      for (i = 0; i < size; i++) {\n+        c1 = s1[i];\n+        c2 = s2[i];\n+        if (c1 != c2) break;\n+      }\n+      ASAN_READ_RANGE(s1, Min(i + 1, size));\n+      ASAN_READ_RANGE(s2, Min(i + 1, size));\n+      return CharCmp(c1, c2);\n+    }\n   }\n-  ASAN_READ_RANGE(s1, Min(i + 1, size));\n-  ASAN_READ_RANGE(s2, Min(i + 1, size));\n-  return CharCmp(c1, c2);\n+  return REAL(memcmp(a1, a2, size));\n }\n \n+#define MEMMOVE_BODY { \\\n+  if (!asan_inited) return internal_memmove(to, from, size); \\\n+  if (asan_init_is_running) { \\\n+    return REAL(memmove)(to, from, size); \\\n+  } \\\n+  ENSURE_ASAN_INITED(); \\\n+  if (flags()->replace_intrin) { \\\n+    ASAN_READ_RANGE(from, size); \\\n+    ASAN_WRITE_RANGE(to, size); \\\n+  } \\\n+  return internal_memmove(to, from, size); \\\n+}\n+\n+INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) MEMMOVE_BODY\n+\n INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n+#if !SANITIZER_MAC\n   if (!asan_inited) return internal_memcpy(to, from, size);\n   // memcpy is called during __asan_init() from the internals\n   // of printf(...).\n@@ -287,24 +346,19 @@ INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n     ASAN_READ_RANGE(from, size);\n     ASAN_WRITE_RANGE(to, size);\n   }\n-  // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8.\n+  // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8, so\n+  // calling REAL(memcpy) here leads to infinite recursion.\n   // See also http://code.google.com/p/address-sanitizer/issues/detail?id=116.\n   return internal_memcpy(to, from, size);\n-}\n-\n-INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n-  if (!asan_inited) return internal_memmove(to, from, size);\n-  if (asan_init_is_running) {\n-    return REAL(memmove)(to, from, size);\n-  }\n-  ENSURE_ASAN_INITED();\n-  if (flags()->replace_intrin) {\n-    ASAN_READ_RANGE(from, size);\n-    ASAN_WRITE_RANGE(to, size);\n-  }\n-  // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8.\n-  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=116.\n-  return internal_memmove(to, from, size);\n+#else\n+  // At least on 10.7 and 10.8 both memcpy() and memmove() are being replaced\n+  // with WRAP(memcpy). As a result, false positives are reported for memmove()\n+  // calls. If we just disable error reporting with\n+  // ASAN_OPTIONS=replace_intrin=0, memmove() is still replaced with\n+  // internal_memcpy(), which may lead to crashes, see\n+  // http://llvm.org/bugs/show_bug.cgi?id=16362.\n+  MEMMOVE_BODY\n+#endif  // !SANITIZER_MAC\n }\n \n INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n@@ -341,7 +395,12 @@ INTERCEPTOR(char*, strchr, const char *str, int c) {\n INTERCEPTOR(char*, index, const char *string, int c)\n   ALIAS(WRAPPER_NAME(strchr));\n # else\n+#  if SANITIZER_MAC\n+DECLARE_REAL(char*, index, const char *string, int c)\n+OVERRIDE_FUNCTION(index, strchr);\n+#  else\n DEFINE_REAL(char*, index, const char *string, int c)\n+#  endif\n # endif\n #endif  // ASAN_INTERCEPT_INDEX\n \n@@ -383,26 +442,8 @@ INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n   return REAL(strncat)(to, from, size);\n }\n \n-INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n-  if (!asan_inited) return internal_strcmp(s1, s2);\n-  if (asan_init_is_running) {\n-    return REAL(strcmp)(s1, s2);\n-  }\n-  ENSURE_ASAN_INITED();\n-  unsigned char c1, c2;\n-  uptr i;\n-  for (i = 0; ; i++) {\n-    c1 = (unsigned char)s1[i];\n-    c2 = (unsigned char)s2[i];\n-    if (c1 != c2 || c1 == '\\0') break;\n-  }\n-  ASAN_READ_RANGE(s1, i + 1);\n-  ASAN_READ_RANGE(s2, i + 1);\n-  return CharCmp(c1, c2);\n-}\n-\n INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n-#if defined(__APPLE__)\n+#if SANITIZER_MAC\n   if (!asan_inited) return REAL(strcpy)(to, from);  // NOLINT\n #endif\n   // strcpy is called from malloc_default_purgeable_zone()\n@@ -422,21 +463,16 @@ INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n \n #if ASAN_INTERCEPT_STRDUP\n INTERCEPTOR(char*, strdup, const char *s) {\n-#if defined(__APPLE__)\n-  // FIXME: because internal_strdup() uses InternalAlloc(), which currently\n-  // just calls malloc() on Mac, we can't use internal_strdup() with the\n-  // dynamic runtime. We can remove the call to REAL(strdup) once InternalAlloc\n-  // starts using mmap() instead.\n-  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=123.\n-  if (!asan_inited) return REAL(strdup)(s);\n-#endif\n   if (!asan_inited) return internal_strdup(s);\n   ENSURE_ASAN_INITED();\n+  uptr length = REAL(strlen)(s);\n   if (flags()->replace_str) {\n-    uptr length = REAL(strlen)(s);\n     ASAN_READ_RANGE(s, length + 1);\n   }\n-  return REAL(strdup)(s);\n+  GET_STACK_TRACE_MALLOC;\n+  void *new_mem = asan_malloc(length + 1, &stack);\n+  REAL(memcpy)(new_mem, s, length + 1);\n+  return reinterpret_cast<char*>(new_mem);\n }\n #endif\n \n@@ -455,54 +491,13 @@ INTERCEPTOR(uptr, strlen, const char *s) {\n   return length;\n }\n \n-#if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n-INTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n-  ENSURE_ASAN_INITED();\n-  unsigned char c1, c2;\n-  uptr i;\n-  for (i = 0; ; i++) {\n-    c1 = (unsigned char)s1[i];\n-    c2 = (unsigned char)s2[i];\n-    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n-  }\n-  ASAN_READ_RANGE(s1, i + 1);\n-  ASAN_READ_RANGE(s2, i + 1);\n-  return CharCaseCmp(c1, c2);\n-}\n-\n-INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, uptr n) {\n-  ENSURE_ASAN_INITED();\n-  unsigned char c1 = 0, c2 = 0;\n-  uptr i;\n-  for (i = 0; i < n; i++) {\n-    c1 = (unsigned char)s1[i];\n-    c2 = (unsigned char)s2[i];\n-    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n-  }\n-  ASAN_READ_RANGE(s1, Min(i + 1, n));\n-  ASAN_READ_RANGE(s2, Min(i + 1, n));\n-  return CharCaseCmp(c1, c2);\n-}\n-#endif  // ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n-\n-INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n-  if (!asan_inited) return internal_strncmp(s1, s2, size);\n-  // strncmp is called from malloc_default_purgeable_zone()\n-  // in __asan::ReplaceSystemAlloc() on Mac.\n-  if (asan_init_is_running) {\n-    return REAL(strncmp)(s1, s2, size);\n-  }\n-  ENSURE_ASAN_INITED();\n-  unsigned char c1 = 0, c2 = 0;\n-  uptr i;\n-  for (i = 0; i < size; i++) {\n-    c1 = (unsigned char)s1[i];\n-    c2 = (unsigned char)s2[i];\n-    if (c1 != c2 || c1 == '\\0') break;\n+INTERCEPTOR(uptr, wcslen, const wchar_t *s) {\n+  uptr length = REAL(wcslen)(s);\n+  if (!asan_init_is_running) {\n+    ENSURE_ASAN_INITED();\n+    ASAN_READ_RANGE(s, (length + 1) * sizeof(wchar_t));\n   }\n-  ASAN_READ_RANGE(s1, Min(i + 1, size));\n-  ASAN_READ_RANGE(s2, Min(i + 1, size));\n-  return CharCmp(c1, c2);\n+  return length;\n }\n \n INTERCEPTOR(char*, strncpy, char *to, const char *from, uptr size) {\n@@ -532,7 +527,7 @@ static inline bool IsValidStrtolBase(int base) {\n }\n \n static inline void FixRealStrtolEndptr(const char *nptr, char **endptr) {\n-  CHECK(endptr != 0);\n+  CHECK(endptr);\n   if (nptr == *endptr) {\n     // No digits were found at strtol call, we need to find out the last\n     // symbol accessed by strtoll on our own.\n@@ -563,7 +558,7 @@ INTERCEPTOR(long, strtol, const char *nptr,  // NOLINT\n }\n \n INTERCEPTOR(int, atoi, const char *nptr) {\n-#if defined(__APPLE__)\n+#if SANITIZER_MAC\n   if (!asan_inited) return REAL(atoi)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n@@ -582,7 +577,7 @@ INTERCEPTOR(int, atoi, const char *nptr) {\n }\n \n INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n-#if defined(__APPLE__)\n+#if SANITIZER_MAC\n   if (!asan_inited) return REAL(atol)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n@@ -631,22 +626,47 @@ INTERCEPTOR(long long, atoll, const char *nptr) {  // NOLINT\n }\n #endif  // ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n \n+static void AtCxaAtexit(void *unused) {\n+  (void)unused;\n+  StopInitOrderChecking();\n+}\n+\n+#if ASAN_INTERCEPT___CXA_ATEXIT\n+INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n+            void *dso_handle) {\n+  ENSURE_ASAN_INITED();\n+  int res = REAL(__cxa_atexit)(func, arg, dso_handle);\n+  REAL(__cxa_atexit)(AtCxaAtexit, 0, 0);\n+  return res;\n+}\n+#endif  // ASAN_INTERCEPT___CXA_ATEXIT\n+\n+#if !SANITIZER_MAC\n #define ASAN_INTERCEPT_FUNC(name) do { \\\n       if (!INTERCEPT_FUNCTION(name) && flags()->verbosity > 0) \\\n         Report(\"AddressSanitizer: failed to intercept '\" #name \"'\\n\"); \\\n     } while (0)\n+#else\n+// OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION.\n+#define ASAN_INTERCEPT_FUNC(name)\n+#endif  // SANITIZER_MAC\n \n-#if defined(_WIN32)\n+#if SANITIZER_WINDOWS\n INTERCEPTOR_WINAPI(DWORD, CreateThread,\n                    void* security, uptr stack_size,\n                    DWORD (__stdcall *start_routine)(void*), void* arg,\n-                   DWORD flags, void* tid) {\n+                   DWORD thr_flags, void* tid) {\n+  // Strict init-order checking in thread-hostile.\n+  if (flags()->strict_init_order)\n+    StopInitOrderChecking();\n   GET_STACK_TRACE_THREAD;\n-  u32 current_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n-  AsanThread *t = AsanThread::Create(current_tid, start_routine, arg, &stack);\n-  asanThreadRegistry().RegisterThread(t);\n+  u32 current_tid = GetCurrentTidOrInvalid();\n+  AsanThread *t = AsanThread::Create(start_routine, arg);\n+  CreateThreadContextArgs args = { t, &stack };\n+  bool detached = false;  // FIXME: how can we determine it on Windows?\n+  asanThreadRegistry().CreateThread(*(uptr*)t, detached, current_tid, &args);\n   return REAL(CreateThread)(security, stack_size,\n-                            asan_thread_start, t, flags, tid);\n+                            asan_thread_start, t, thr_flags, tid);\n }\n \n namespace __asan {\n@@ -663,9 +683,6 @@ void InitializeAsanInterceptors() {\n   static bool was_called_once;\n   CHECK(was_called_once == false);\n   was_called_once = true;\n-#if defined(__APPLE__)\n-  return;\n-#else\n   SANITIZER_COMMON_INTERCEPTORS_INIT;\n \n   // Intercept mem* functions.\n@@ -679,16 +696,11 @@ void InitializeAsanInterceptors() {\n   // Intercept str* functions.\n   ASAN_INTERCEPT_FUNC(strcat);  // NOLINT\n   ASAN_INTERCEPT_FUNC(strchr);\n-  ASAN_INTERCEPT_FUNC(strcmp);\n   ASAN_INTERCEPT_FUNC(strcpy);  // NOLINT\n   ASAN_INTERCEPT_FUNC(strlen);\n+  ASAN_INTERCEPT_FUNC(wcslen);\n   ASAN_INTERCEPT_FUNC(strncat);\n-  ASAN_INTERCEPT_FUNC(strncmp);\n   ASAN_INTERCEPT_FUNC(strncpy);\n-#if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n-  ASAN_INTERCEPT_FUNC(strcasecmp);\n-  ASAN_INTERCEPT_FUNC(strncasecmp);\n-#endif\n #if ASAN_INTERCEPT_STRDUP\n   ASAN_INTERCEPT_FUNC(strdup);\n #endif\n@@ -741,15 +753,19 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(pthread_create);\n #endif\n \n+  // Intercept atexit function.\n+#if ASAN_INTERCEPT___CXA_ATEXIT\n+  ASAN_INTERCEPT_FUNC(__cxa_atexit);\n+#endif\n+\n   // Some Windows-specific interceptors.\n-#if defined(_WIN32)\n+#if SANITIZER_WINDOWS\n   InitializeWindowsInterceptors();\n #endif\n \n   if (flags()->verbosity > 0) {\n     Report(\"AddressSanitizer: libc interceptors initialized\\n\");\n   }\n-#endif  // __APPLE__\n }\n \n }  // namespace __asan"}, {"sha": "7deed9f46073e4088dc346379265f9acad657dde", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 68, "deletions": 73, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -23,111 +23,106 @@ extern \"C\" {\n   // Everytime the asan ABI changes we also change the version number in this\n   // name. Objects build with incompatible asan ABI version\n   // will not link with run-time.\n-  void __asan_init_v1() SANITIZER_INTERFACE_ATTRIBUTE;\n-  #define __asan_init __asan_init_v1\n+  // Changes between ABI versions:\n+  // v1=>v2: added 'module_name' to __asan_global\n+  // v2=>v3: stack frame description (created by the compiler)\n+  //         contains the function PC as the 3-rd field (see\n+  //         DescribeAddressIfStack).\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_init_v3();\n+  #define __asan_init __asan_init_v3\n \n   // This structure describes an instrumented global variable.\n   struct __asan_global {\n     uptr beg;                // The address of the global.\n     uptr size;               // The original size of the global.\n     uptr size_with_redzone;  // The size with the redzone.\n     const char *name;        // Name as a C string.\n+    const char *module_name; // Module name as a C string. This pointer is a\n+                             // unique identifier of a module.\n     uptr has_dynamic_init;   // Non-zero if the global has dynamic initializer.\n   };\n \n   // These two functions should be called by the instrumented code.\n   // 'globals' is an array of structures describing 'n' globals.\n-  void __asan_register_globals(__asan_global *globals, uptr n)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_unregister_globals(__asan_global *globals, uptr n)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_register_globals(__asan_global *globals, uptr n);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_unregister_globals(__asan_global *globals, uptr n);\n \n   // These two functions should be called before and after dynamic initializers\n-  // run, respectively.  They should be called with parameters describing all\n-  // dynamically initialized globals defined in the calling TU.\n-  void __asan_before_dynamic_init(uptr first_addr, uptr last_addr)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_after_dynamic_init()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  // These two functions are used by the instrumented code in the\n-  // use-after-return mode. __asan_stack_malloc allocates size bytes of\n-  // fake stack and __asan_stack_free poisons it. real_stack is a pointer to\n-  // the real stack region.\n-  uptr __asan_stack_malloc(uptr size, uptr real_stack)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_stack_free(uptr ptr, uptr size, uptr real_stack)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // of a single module run, respectively.\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_before_dynamic_init(const char *module_name);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_after_dynamic_init();\n \n   // These two functions are used by instrumented code in the\n   // use-after-scope mode. They mark memory for local variables as\n   // unaddressable when they leave scope and addressable before the\n   // function exits.\n-  void __asan_poison_stack_memory(uptr addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_unpoison_stack_memory(uptr addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_poison_stack_memory(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_unpoison_stack_memory(uptr addr, uptr size);\n \n   // Performs cleanup before a NoReturn function. Must be called before things\n   // like _exit and execl to avoid false positives on stack.\n-  void __asan_handle_no_return() SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_handle_no_return();\n \n-  void __asan_poison_memory_region(void const volatile *addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_unpoison_memory_region(void const volatile *addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_poison_memory_region(void const volatile *addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_unpoison_memory_region(void const volatile *addr, uptr size);\n \n-  bool __asan_address_is_poisoned(void const volatile *addr)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  bool __asan_address_is_poisoned(void const volatile *addr);\n \n-  uptr __asan_region_is_poisoned(uptr beg, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_region_is_poisoned(uptr beg, uptr size);\n \n-  void __asan_describe_address(uptr addr)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_describe_address(uptr addr);\n \n+  SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_report_error(uptr pc, uptr bp, uptr sp,\n-                           uptr addr, bool is_write, uptr access_size)\n-    SANITIZER_INTERFACE_ATTRIBUTE;\n+                           uptr addr, bool is_write, uptr access_size);\n \n-  int __asan_set_error_exit_code(int exit_code)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_set_death_callback(void (*callback)(void))\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_set_error_report_callback(void (*callback)(const char*))\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  int __asan_set_error_exit_code(int exit_code);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_death_callback(void (*callback)(void));\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_error_report_callback(void (*callback)(const char*));\n \n-  /* OPTIONAL */ void __asan_on_error()\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  /* OPTIONAL */ void __asan_on_error();\n \n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   /* OPTIONAL */ bool __asan_symbolize(const void *pc, char *out_buffer,\n-                                       int out_size)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  uptr __asan_get_estimated_allocated_size(uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  bool __asan_get_ownership(const void *p)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  uptr __asan_get_allocated_size(const void *p)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  uptr __asan_get_current_allocated_bytes()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  uptr __asan_get_heap_size()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  uptr __asan_get_free_bytes()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  uptr __asan_get_unmapped_bytes()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_print_accumulated_stats()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  /* OPTIONAL */ const char* __asan_default_options()\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  /* OPTIONAL */ void __asan_malloc_hook(void *ptr, uptr size)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-  /* OPTIONAL */ void __asan_free_hook(void *ptr)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+                                       int out_size);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_estimated_allocated_size(uptr size);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE bool __asan_get_ownership(const void *p);\n+  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_allocated_size(const void *p);\n+  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_current_allocated_bytes();\n+  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_heap_size();\n+  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_free_bytes();\n+  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_unmapped_bytes();\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_print_accumulated_stats();\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  /* OPTIONAL */ const char* __asan_default_options();\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  /* OPTIONAL */ void __asan_malloc_hook(void *ptr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  /* OPTIONAL */ void __asan_free_hook(void *ptr);\n+\n+  // Global flag, copy of ASAN_OPTIONS=detect_stack_use_after_return\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  extern int __asan_option_detect_stack_use_after_return;\n }  // extern \"C\"\n \n #endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "b5b48708090c9d9313e559b8856a8a4ec7c251e0", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -19,39 +19,8 @@\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n-#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n-# error \"This operating system is not supported by AddressSanitizer\"\n-#endif\n-\n #define ASAN_DEFAULT_FAILURE_EXITCODE 1\n \n-#if defined(__linux__)\n-# define ASAN_LINUX   1\n-#else\n-# define ASAN_LINUX   0\n-#endif\n-\n-#if defined(__APPLE__)\n-# define ASAN_MAC     1\n-#else\n-# define ASAN_MAC     0\n-#endif\n-\n-#if defined(_WIN32)\n-# define ASAN_WINDOWS 1\n-#else\n-# define ASAN_WINDOWS 0\n-#endif\n-\n-#if defined(__ANDROID__) || defined(ANDROID)\n-# define ASAN_ANDROID 1\n-#else\n-# define ASAN_ANDROID 0\n-#endif\n-\n-\n-#define ASAN_POSIX (ASAN_LINUX || ASAN_MAC)\n-\n #if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n # error \"The AddressSanitizer run-time should not be\"\n         \" instrumented by AddressSanitizer\"\n@@ -61,7 +30,7 @@\n \n // If set, asan will install its own SEGV signal handler.\n #ifndef ASAN_NEEDS_SEGV\n-# if ASAN_ANDROID == 1\n+# if SANITIZER_ANDROID == 1\n #  define ASAN_NEEDS_SEGV 0\n # else\n #  define ASAN_NEEDS_SEGV 1\n@@ -90,7 +59,7 @@\n #endif\n \n #ifndef ASAN_USE_PREINIT_ARRAY\n-# define ASAN_USE_PREINIT_ARRAY (ASAN_LINUX && !ASAN_ANDROID)\n+# define ASAN_USE_PREINIT_ARRAY (SANITIZER_LINUX && !SANITIZER_ANDROID)\n #endif\n \n // All internal functions in asan reside inside the __asan namespace\n@@ -121,6 +90,7 @@ void UnsetAlternateSignalStack();\n void InstallSignalHandlers();\n void ReadContextStack(void *context, uptr *stack, uptr *ssize);\n void AsanPlatformThreadInit();\n+void StopInitOrderChecking();\n \n // Wrapper for TLS/TSD.\n void AsanTSDInit(void (*destructor)(void *tsd));\n@@ -129,24 +99,14 @@ void AsanTSDSet(void *tsd);\n \n void AppendToErrorMessageBuffer(const char *buffer);\n \n-// asan_poisoning.cc\n-// Poisons the shadow memory for \"size\" bytes starting from \"addr\".\n-void PoisonShadow(uptr addr, uptr size, u8 value);\n-// Poisons the shadow memory for \"redzone_size\" bytes starting from\n-// \"addr + size\".\n-void PoisonShadowPartialRightRedzone(uptr addr,\n-                                     uptr size,\n-                                     uptr redzone_size,\n-                                     u8 value);\n-\n // Platfrom-specific options.\n-#ifdef __APPLE__\n+#if SANITIZER_MAC\n bool PlatformHasDifferentMemcpyAndMemmove();\n # define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE \\\n     (PlatformHasDifferentMemcpyAndMemmove())\n #else\n # define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE true\n-#endif  // __APPLE__\n+#endif  // SANITIZER_MAC\n \n // Add convenient macro for interface functions that may be represented as\n // weak hooks."}, {"sha": "10c6175092bba7ed8320cca4d6b8c32980e5665d", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -9,12 +9,13 @@\n //\n // Linux-specific details.\n //===----------------------------------------------------------------------===//\n-#ifdef __linux__\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n@@ -29,7 +30,7 @@\n #include <unistd.h>\n #include <unwind.h>\n \n-#if !ASAN_ANDROID\n+#if !SANITIZER_ANDROID\n // FIXME: where to get ucontext on Android?\n #include <sys/ucontext.h>\n #endif\n@@ -48,7 +49,7 @@ void *AsanDoesNotSupportStaticLinkage() {\n }\n \n void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n-#if ASAN_ANDROID\n+#if SANITIZER_ANDROID\n   *pc = *sp = *bp = 0;\n #elif defined(__arm__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n@@ -86,6 +87,11 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   stk_ptr = (uptr *) *sp;\n   *bp = stk_ptr[15];\n # endif\n+# elif defined(__mips__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.gregs[31];\n+  *bp = ucontext->uc_mcontext.gregs[30];\n+  *sp = ucontext->uc_mcontext.gregs[29];\n #else\n # error \"Unsupported arch\"\n #endif\n@@ -99,25 +105,7 @@ void AsanPlatformThreadInit() {\n   // Nothing here for now.\n }\n \n-void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n-#if defined(__arm__) || \\\n-    defined(__powerpc__) || defined(__powerpc64__) || \\\n-    defined(__sparc__)\n-  fast = false;\n-#endif\n-  if (!fast)\n-    return stack->SlowUnwindStack(pc, max_s);\n-  stack->size = 0;\n-  stack->trace[0] = pc;\n-  if (max_s > 1) {\n-    stack->max_size = max_s;\n-    if (!asan_inited) return;\n-    if (AsanThread *t = asanThreadRegistry().GetCurrent())\n-      stack->FastUnwindStack(pc, bp, t->stack_top(), t->stack_bottom());\n-  }\n-}\n-\n-#if !ASAN_ANDROID\n+#if !SANITIZER_ANDROID\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   ucontext_t *ucp = (ucontext_t*)context;\n   *stack = (uptr)ucp->uc_stack.ss_sp;\n@@ -131,4 +119,4 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n \n }  // namespace __asan\n \n-#endif  // __linux__\n+#endif  // SANITIZER_LINUX"}, {"sha": "4b28c1422cd9fb6e39f4bd68f54ff7bf2e703826", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 32, "deletions": 44, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -10,15 +10,16 @@\n // Mac-specific details.\n //===----------------------------------------------------------------------===//\n \n-#ifdef __APPLE__\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_MAC\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_mac.h\"\n #include \"asan_mapping.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n #include <crt_externs.h>  // for _NSGetArgv\n@@ -50,29 +51,44 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n # endif  // SANITIZER_WORDSIZE\n }\n \n-int GetMacosVersion() {\n+MacosVersion cached_macos_version = MACOS_VERSION_UNINITIALIZED;\n+\n+MacosVersion GetMacosVersionInternal() {\n   int mib[2] = { CTL_KERN, KERN_OSRELEASE };\n   char version[100];\n   uptr len = 0, maxlen = sizeof(version) / sizeof(version[0]);\n   for (uptr i = 0; i < maxlen; i++) version[i] = '\\0';\n   // Get the version length.\n-  CHECK(sysctl(mib, 2, 0, &len, 0, 0) != -1);\n-  CHECK(len < maxlen);\n-  CHECK(sysctl(mib, 2, version, &len, 0, 0) != -1);\n+  CHECK_NE(sysctl(mib, 2, 0, &len, 0, 0), -1);\n+  CHECK_LT(len, maxlen);\n+  CHECK_NE(sysctl(mib, 2, version, &len, 0, 0), -1);\n   switch (version[0]) {\n     case '9': return MACOS_VERSION_LEOPARD;\n     case '1': {\n       switch (version[1]) {\n         case '0': return MACOS_VERSION_SNOW_LEOPARD;\n         case '1': return MACOS_VERSION_LION;\n         case '2': return MACOS_VERSION_MOUNTAIN_LION;\n+        case '3': return MACOS_VERSION_MAVERICKS;\n         default: return MACOS_VERSION_UNKNOWN;\n       }\n     }\n     default: return MACOS_VERSION_UNKNOWN;\n   }\n }\n \n+MacosVersion GetMacosVersion() {\n+  atomic_uint32_t *cache =\n+      reinterpret_cast<atomic_uint32_t*>(&cached_macos_version);\n+  MacosVersion result =\n+      static_cast<MacosVersion>(atomic_load(cache, memory_order_acquire));\n+  if (result == MACOS_VERSION_UNINITIALIZED) {\n+    result = GetMacosVersionInternal();\n+    atomic_store(cache, result, memory_order_release);\n+  }\n+  return result;\n+}\n+\n bool PlatformHasDifferentMemcpyAndMemmove() {\n   // On OS X 10.7 memcpy() and memmove() are both resolved\n   // into memmove$VARIANT$sse42.\n@@ -227,18 +243,6 @@ bool AsanInterceptsSignal(int signum) {\n void AsanPlatformThreadInit() {\n }\n \n-void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n-  (void)fast;\n-  stack->size = 0;\n-  stack->trace[0] = pc;\n-  if ((max_s) > 1) {\n-    stack->max_size = max_s;\n-    if (!asan_inited) return;\n-    if (AsanThread *t = asanThreadRegistry().GetCurrent())\n-      stack->FastUnwindStack(pc, bp, t->stack_top(), t->stack_bottom());\n-  }\n-}\n-\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n@@ -286,32 +290,16 @@ typedef struct {\n   u32 parent_tid;\n } asan_block_context_t;\n \n-// We use extern declarations of libdispatch functions here instead\n-// of including <dispatch/dispatch.h>. This header is not present on\n-// Mac OS X Leopard and eariler, and although we don't expect ASan to\n-// work on legacy systems, it's bad to break the build of\n-// LLVM compiler-rt there.\n-extern \"C\" {\n-void dispatch_async_f(dispatch_queue_t dq, void *ctxt,\n-                      dispatch_function_t func);\n-void dispatch_sync_f(dispatch_queue_t dq, void *ctxt,\n-                     dispatch_function_t func);\n-void dispatch_after_f(dispatch_time_t when, dispatch_queue_t dq, void *ctxt,\n-                      dispatch_function_t func);\n-void dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt,\n-                              dispatch_function_t func);\n-void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t dq,\n-                            void *ctxt, dispatch_function_t func);\n-}  // extern \"C\"\n-\n-static ALWAYS_INLINE\n+ALWAYS_INLINE\n void asan_register_worker_thread(int parent_tid, StackTrace *stack) {\n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  AsanThread *t = GetCurrentThread();\n   if (!t) {\n-    t = AsanThread::Create(parent_tid, 0, 0, stack);\n-    asanThreadRegistry().RegisterThread(t);\n+    t = AsanThread::Create(0, 0);\n+    CreateThreadContextArgs args = { t, stack };\n+    asanThreadRegistry().CreateThread(*(uptr*)t, true, parent_tid, &args);\n     t->Init();\n-    asanThreadRegistry().SetCurrent(t);\n+    asanThreadRegistry().StartThread(t->tid(), 0, 0);\n+    SetCurrentThread(t);\n   }\n }\n \n@@ -345,7 +333,7 @@ asan_block_context_t *alloc_asan_context(void *ctxt, dispatch_function_t func,\n       (asan_block_context_t*) asan_malloc(sizeof(asan_block_context_t), stack);\n   asan_ctxt->block = ctxt;\n   asan_ctxt->func = func;\n-  asan_ctxt->parent_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+  asan_ctxt->parent_tid = GetCurrentTidOrInvalid();\n   return asan_ctxt;\n }\n \n@@ -411,7 +399,7 @@ void dispatch_source_set_event_handler(dispatch_source_t ds, void(^work)(void));\n \n #define GET_ASAN_BLOCK(work) \\\n   void (^asan_block)(void);  \\\n-  int parent_tid = asanThreadRegistry().GetCurrentTidOrInvalid(); \\\n+  int parent_tid = GetCurrentTidOrInvalid(); \\\n   asan_block = ^(void) { \\\n     GET_STACK_TRACE_THREAD; \\\n     asan_register_worker_thread(parent_tid, &stack); \\\n@@ -449,4 +437,4 @@ INTERCEPTOR(void, dispatch_source_set_event_handler,\n }\n #endif\n \n-#endif  // __APPLE__\n+#endif  // SANITIZER_MAC"}, {"sha": "2d1d4b0bfb33d6e11309659a281763171a89fb1b", "filename": "libsanitizer/asan/asan_mac.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -34,20 +34,22 @@ typedef struct __CFRuntimeBase {\n #endif\n } CFRuntimeBase;\n \n-enum {\n-  MACOS_VERSION_UNKNOWN = 0,\n+enum MacosVersion {\n+  MACOS_VERSION_UNINITIALIZED = 0,\n+  MACOS_VERSION_UNKNOWN,\n   MACOS_VERSION_LEOPARD,\n   MACOS_VERSION_SNOW_LEOPARD,\n   MACOS_VERSION_LION,\n-  MACOS_VERSION_MOUNTAIN_LION\n+  MACOS_VERSION_MOUNTAIN_LION,\n+  MACOS_VERSION_MAVERICKS\n };\n \n // Used by asan_malloc_mac.cc and asan_mac.cc\n extern \"C\" void __CFInitialize();\n \n namespace __asan {\n \n-int GetMacosVersion();\n+MacosVersion GetMacosVersion();\n void MaybeReplaceCFAllocator();\n \n }  // namespace __asan"}, {"sha": "97691fcd361e1c95b347466dcc5c0bc772cc8596", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -11,15 +11,16 @@\n // We simply define functions like malloc, free, realloc, etc.\n // They will replace the corresponding libc functions automagically.\n //===----------------------------------------------------------------------===//\n-#ifdef __linux__\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n \n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n-#include \"asan_thread_registry.h\"\n \n-#if ASAN_ANDROID\n+#if SANITIZER_ANDROID\n DECLARE_REAL_AND_INTERCEPTOR(void*, malloc, uptr size)\n DECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\n DECLARE_REAL_AND_INTERCEPTOR(void*, calloc, uptr nmemb, uptr size)\n@@ -144,4 +145,4 @@ INTERCEPTOR(void, malloc_stats, void) {\n   __asan_print_accumulated_stats();\n }\n \n-#endif  // __linux__\n+#endif  // SANITIZER_LINUX"}, {"sha": "342e806e3b67e494b643000cf938256cfad2f3db", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -10,12 +10,14 @@\n // Mac-specific malloc interception.\n //===----------------------------------------------------------------------===//\n \n-#ifdef __APPLE__\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_MAC\n \n #include <AvailabilityMacros.h>\n #include <CoreFoundation/CFBase.h>\n #include <dlfcn.h>\n #include <malloc/malloc.h>\n+#include <sys/mman.h>\n \n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n@@ -24,7 +26,6 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n-#include \"asan_thread_registry.h\"\n \n // Similar code is used in Google Perftools,\n // http://code.google.com/p/google-perftools.\n@@ -40,10 +41,19 @@ INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n                              vm_size_t start_size, unsigned zone_flags) {\n   if (!asan_inited) __asan_init();\n   GET_STACK_TRACE_MALLOC;\n+  uptr page_size = GetPageSizeCached();\n+  uptr allocated_size = RoundUpTo(sizeof(asan_zone), page_size);\n   malloc_zone_t *new_zone =\n-      (malloc_zone_t*)asan_malloc(sizeof(asan_zone), &stack);\n+      (malloc_zone_t*)asan_memalign(page_size, allocated_size,\n+                                    &stack, FROM_MALLOC);\n   internal_memcpy(new_zone, &asan_zone, sizeof(asan_zone));\n   new_zone->zone_name = NULL;  // The name will be changed anyway.\n+  if (GetMacosVersion() >= MACOS_VERSION_LION) {\n+    // Prevent the client app from overwriting the zone contents.\n+    // Library functions that need to modify the zone will set PROT_WRITE on it.\n+    // This matches the behavior of malloc_create_zone() on OSX 10.7 and higher.\n+    mprotect(new_zone, allocated_size, PROT_READ);\n+  }\n   return new_zone;\n }\n \n@@ -282,7 +292,7 @@ void mi_force_unlock(malloc_zone_t *zone) {\n \n void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {\n   AsanMallocStats malloc_stats;\n-  asanThreadRegistry().FillMallocStatistics(&malloc_stats);\n+  FillMallocStatistics(&malloc_stats);\n   CHECK(sizeof(malloc_statistics_t) == sizeof(AsanMallocStats));\n   internal_memcpy(stats, &malloc_stats, sizeof(malloc_statistics_t));\n }\n@@ -344,4 +354,4 @@ void ReplaceSystemMalloc() {\n }\n }  // namespace __asan\n \n-#endif  // __APPLE__\n+#endif  // SANITIZER_MAC"}, {"sha": "cabf8cd254c80abee43cd77a6bbdb201358fe28d", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -9,7 +9,9 @@\n //\n // Windows-specific malloc interception.\n //===----------------------------------------------------------------------===//\n-#ifdef _WIN32\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_WINDOWS\n \n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n@@ -28,11 +30,13 @@ using namespace __asan;  // NOLINT\n // revisited in the future.\n \n extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n void free(void *ptr) {\n   GET_STACK_TRACE_FREE;\n   return asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void _free_dbg(void* ptr, int) {\n   free(ptr);\n }\n@@ -41,38 +45,46 @@ void cfree(void *ptr) {\n   CHECK(!\"cfree() should not be used on Windows?\");\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void *malloc(size_t size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_malloc(size, &stack);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void* _malloc_dbg(size_t size, int , const char*, int) {\n   return malloc(size);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void *calloc(size_t nmemb, size_t size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_calloc(nmemb, size, &stack);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void* _calloc_dbg(size_t n, size_t size, int, const char*, int) {\n   return calloc(n, size);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void *_calloc_impl(size_t nmemb, size_t size, int *errno_tmp) {\n   return calloc(nmemb, size);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void *realloc(void *ptr, size_t size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_realloc(ptr, size, &stack);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void *_realloc_dbg(void *ptr, size_t size, int) {\n   CHECK(!\"_realloc_dbg should not exist!\");\n   return 0;\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n void* _recalloc(void* p, size_t n, size_t elem_size) {\n   if (!p)\n     return calloc(n, elem_size);\n@@ -82,6 +94,7 @@ void* _recalloc(void* p, size_t n, size_t elem_size) {\n   return realloc(p, size);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n size_t _msize(void *ptr) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_malloc_usable_size(ptr, &stack);"}, {"sha": "fd5c2039bcac46c44dc5b632e6caa04bfa7be962", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -47,29 +47,44 @@\n // || `[0x24000000, 0x27ffffff]` || ShadowGap  ||\n // || `[0x20000000, 0x23ffffff]` || LowShadow  ||\n // || `[0x00000000, 0x1fffffff]` || LowMem     ||\n+//\n+// Default Linux/MIPS mapping:\n+// || `[0x2aaa8000, 0xffffffff]` || HighMem    ||\n+// || `[0x0fffd000, 0x2aaa7fff]` || HighShadow ||\n+// || `[0x0bffd000, 0x0fffcfff]` || ShadowGap  ||\n+// || `[0x0aaa8000, 0x0bffcfff]` || LowShadow  ||\n+// || `[0x00000000, 0x0aaa7fff]` || LowMem     ||\n+\n+static const u64 kDefaultShadowScale = 3;\n+static const u64 kDefaultShadowOffset32 = 1ULL << 29;\n+static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n+static const u64 kDefaultShort64bitShadowOffset = 0x7FFF8000;  // < 2G.\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kMIPS32_ShadowOffset32 = 0x0aaa8000;\n \n #if ASAN_FLEXIBLE_MAPPING_AND_OFFSET == 1\n extern SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_scale;\n extern SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_offset;\n # define SHADOW_SCALE (__asan_mapping_scale)\n # define SHADOW_OFFSET (__asan_mapping_offset)\n #else\n-# if ASAN_ANDROID\n-#  define SHADOW_SCALE (3)\n+# define SHADOW_SCALE kDefaultShadowScale\n+# if SANITIZER_ANDROID\n #  define SHADOW_OFFSET (0)\n # else\n-#  define SHADOW_SCALE (3)\n #  if SANITIZER_WORDSIZE == 32\n-#   define SHADOW_OFFSET (1 << 29)\n+#   if defined(__mips__)\n+#     define SHADOW_OFFSET kMIPS32_ShadowOffset32\n+#   else\n+#     define SHADOW_OFFSET kDefaultShadowOffset32\n+#   endif\n #  else\n #   if defined(__powerpc64__)\n-#    define SHADOW_OFFSET (1ULL << 41)\n+#    define SHADOW_OFFSET kPPC64_ShadowOffset64\n+#   elif SANITIZER_MAC\n+#    define SHADOW_OFFSET kDefaultShadowOffset64\n #   else\n-#    if ASAN_MAC\n-#     define SHADOW_OFFSET (1ULL << 44)\n-#    else\n-#     define SHADOW_OFFSET 0x7fff8000ULL\n-#    endif\n+#    define SHADOW_OFFSET kDefaultShort64bitShadowOffset\n #   endif\n #  endif\n # endif\n@@ -131,7 +146,6 @@ static uptr kHighMemEnd = 0x7fffffffffffULL;\n static uptr kMidMemBeg =    0x3000000000ULL;\n static uptr kMidMemEnd =    0x4fffffffffULL;\n #else\n-SANITIZER_INTERFACE_ATTRIBUTE\n extern uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;  // Initialized in __asan_init.\n #endif\n "}, {"sha": "beac8cdbdd5ecea8843b4ae18807f6c71f038bae", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -27,7 +27,7 @@ using namespace __asan;  // NOLINT\n \n // On Android new() goes through malloc interceptors.\n // See also https://code.google.com/p/address-sanitizer/issues/detail?id=131.\n-#if !ASAN_ANDROID\n+#if !SANITIZER_ANDROID\n \n // Fake std::nothrow_t to avoid including <new>.\n namespace std {\n@@ -38,6 +38,14 @@ struct nothrow_t {};\n   GET_STACK_TRACE_MALLOC;\\\n   return asan_memalign(0, size, &stack, type);\n \n+// On OS X it's not enough to just provide our own 'operator new' and\n+// 'operator delete' implementations, because they're going to be in the\n+// runtime dylib, and the main executable will depend on both the runtime\n+// dylib and libstdc++, each of those'll have its implementation of new and\n+// delete.\n+// To make sure that C++ allocation/deallocation operators are overridden on\n+// OS X we need to intercept them using their mangled names.\n+#if !SANITIZER_MAC\n INTERCEPTOR_ATTRIBUTE\n void *operator new(size_t size) { OPERATOR_NEW_BODY(FROM_NEW); }\n INTERCEPTOR_ATTRIBUTE\n@@ -49,10 +57,26 @@ INTERCEPTOR_ATTRIBUTE\n void *operator new[](size_t size, std::nothrow_t const&)\n { OPERATOR_NEW_BODY(FROM_NEW_BR); }\n \n+#else  // SANITIZER_MAC\n+INTERCEPTOR(void *, _Znwm, size_t size) {\n+  OPERATOR_NEW_BODY(FROM_NEW);\n+}\n+INTERCEPTOR(void *, _Znam, size_t size) {\n+  OPERATOR_NEW_BODY(FROM_NEW_BR);\n+}\n+INTERCEPTOR(void *, _ZnwmRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n+  OPERATOR_NEW_BODY(FROM_NEW);\n+}\n+INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n+  OPERATOR_NEW_BODY(FROM_NEW_BR);\n+}\n+#endif\n+\n #define OPERATOR_DELETE_BODY(type) \\\n   GET_STACK_TRACE_FREE;\\\n   asan_free(ptr, &stack, type);\n \n+#if !SANITIZER_MAC\n INTERCEPTOR_ATTRIBUTE\n void operator delete(void *ptr) { OPERATOR_DELETE_BODY(FROM_NEW); }\n INTERCEPTOR_ATTRIBUTE\n@@ -64,4 +88,19 @@ INTERCEPTOR_ATTRIBUTE\n void operator delete[](void *ptr, std::nothrow_t const&)\n { OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n \n+#else  // SANITIZER_MAC\n+INTERCEPTOR(void, _ZdlPv, void *ptr) {\n+  OPERATOR_DELETE_BODY(FROM_NEW);\n+}\n+INTERCEPTOR(void, _ZdaPv, void *ptr) {\n+  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n+}\n+INTERCEPTOR(void, _ZdlPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&) {\n+  OPERATOR_DELETE_BODY(FROM_NEW);\n+}\n+INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&) {\n+  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n+}\n+#endif\n+\n #endif"}, {"sha": "b967acded636979e27d4f57a467bae2b554388ba", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -10,21 +10,19 @@\n // Shadow memory poisoning by ASan RTL and by user application.\n //===----------------------------------------------------------------------===//\n \n-#include \"asan_interceptors.h\"\n-#include \"asan_internal.h\"\n-#include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n namespace __asan {\n \n void PoisonShadow(uptr addr, uptr size, u8 value) {\n   if (!flags()->poison_heap) return;\n   CHECK(AddrIsAlignedByGranularity(addr));\n+  CHECK(AddrIsInMem(addr));\n   CHECK(AddrIsAlignedByGranularity(addr + size));\n-  uptr shadow_beg = MemToShadow(addr);\n-  uptr shadow_end = MemToShadow(addr + size - SHADOW_GRANULARITY) + 1;\n-  CHECK(REAL(memset) != 0);\n-  REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n+  CHECK(AddrIsInMem(addr + size - SHADOW_GRANULARITY));\n+  CHECK(REAL(memset));\n+  FastPoisonShadow(addr, size, value);\n }\n \n void PoisonShadowPartialRightRedzone(uptr addr,\n@@ -33,20 +31,10 @@ void PoisonShadowPartialRightRedzone(uptr addr,\n                                      u8 value) {\n   if (!flags()->poison_heap) return;\n   CHECK(AddrIsAlignedByGranularity(addr));\n-  u8 *shadow = (u8*)MemToShadow(addr);\n-  for (uptr i = 0; i < redzone_size;\n-       i += SHADOW_GRANULARITY, shadow++) {\n-    if (i + SHADOW_GRANULARITY <= size) {\n-      *shadow = 0;  // fully addressable\n-    } else if (i >= size) {\n-      *shadow = (SHADOW_GRANULARITY == 128) ? 0xff : value;  // unaddressable\n-    } else {\n-      *shadow = size - i;  // first size-i bytes are addressable\n-    }\n-  }\n+  CHECK(AddrIsInMem(addr));\n+  FastPoisonShadowPartialRightRedzone(addr, size, redzone_size, value);\n }\n \n-\n struct ShadowSegmentEndpoint {\n   u8 *chunk;\n   s8 offset;  // in [0, SHADOW_GRANULARITY)\n@@ -179,6 +167,55 @@ uptr __asan_region_is_poisoned(uptr beg, uptr size) {\n   return 0;\n }\n \n+#define CHECK_SMALL_REGION(p, size, isWrite)                  \\\n+  do {                                                        \\\n+    uptr __p = reinterpret_cast<uptr>(p);                     \\\n+    uptr __size = size;                                       \\\n+    if (UNLIKELY(__asan::AddressIsPoisoned(__p) ||            \\\n+        __asan::AddressIsPoisoned(__p + __size - 1))) {       \\\n+      GET_CURRENT_PC_BP_SP;                                   \\\n+      uptr __bad = __asan_region_is_poisoned(__p, __size);    \\\n+      __asan_report_error(pc, bp, sp, __bad, isWrite, __size);\\\n+    }                                                         \\\n+  } while (false);                                            \\\n+\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+u16 __sanitizer_unaligned_load16(const uu16 *p) {\n+  CHECK_SMALL_REGION(p, sizeof(*p), false);\n+  return *p;\n+}\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+u32 __sanitizer_unaligned_load32(const uu32 *p) {\n+  CHECK_SMALL_REGION(p, sizeof(*p), false);\n+  return *p;\n+}\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+u64 __sanitizer_unaligned_load64(const uu64 *p) {\n+  CHECK_SMALL_REGION(p, sizeof(*p), false);\n+  return *p;\n+}\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_unaligned_store16(uu16 *p, u16 x) {\n+  CHECK_SMALL_REGION(p, sizeof(*p), true);\n+  *p = x;\n+}\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_unaligned_store32(uu32 *p, u32 x) {\n+  CHECK_SMALL_REGION(p, sizeof(*p), true);\n+  *p = x;\n+}\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_unaligned_store64(uu64 *p, u64 x) {\n+  CHECK_SMALL_REGION(p, sizeof(*p), true);\n+  *p = x;\n+}\n+\n // This is a simplified version of __asan_(un)poison_memory_region, which\n // assumes that left border of region to be poisoned is properly aligned.\n static void PoisonAlignedStackMemory(uptr addr, uptr size, bool do_poison) {"}, {"sha": "866c0a57c7ef7ea39f604a6619c1ee31092d4798", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,57 @@\n+//===-- asan_poisoning.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Shadow memory poisoning by ASan RTL and by user application.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n+\n+namespace __asan {\n+\n+// Poisons the shadow memory for \"size\" bytes starting from \"addr\".\n+void PoisonShadow(uptr addr, uptr size, u8 value);\n+\n+// Poisons the shadow memory for \"redzone_size\" bytes starting from\n+// \"addr + size\".\n+void PoisonShadowPartialRightRedzone(uptr addr,\n+                                     uptr size,\n+                                     uptr redzone_size,\n+                                     u8 value);\n+\n+// Fast versions of PoisonShadow and PoisonShadowPartialRightRedzone that\n+// assume that memory addresses are properly aligned. Use in\n+// performance-critical code with care.\n+ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n+                                    u8 value) {\n+  DCHECK(flags()->poison_heap);\n+  uptr shadow_beg = MEM_TO_SHADOW(aligned_beg);\n+  uptr shadow_end = MEM_TO_SHADOW(\n+      aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;\n+  REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n+}\n+\n+ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n+    uptr aligned_addr, uptr size, uptr redzone_size, u8 value) {\n+  DCHECK(flags()->poison_heap);\n+  u8 *shadow = (u8*)MEM_TO_SHADOW(aligned_addr);\n+  for (uptr i = 0; i < redzone_size; i += SHADOW_GRANULARITY, shadow++) {\n+    if (i + SHADOW_GRANULARITY <= size) {\n+      *shadow = 0;  // fully addressable\n+    } else if (i >= size) {\n+      *shadow = (SHADOW_GRANULARITY == 128) ? 0xff : value;  // unaddressable\n+    } else {\n+      // first size-i bytes are addressable\n+      *shadow = static_cast<u8>(size - i);\n+    }\n+  }\n+}\n+\n+}  // namespace __asan"}, {"sha": "a210a810036ec1a7834f2bc342e9b82e17fd70ec", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -9,14 +9,15 @@\n //\n // Posix-specific details.\n //===----------------------------------------------------------------------===//\n-#if defined(__linux__) || defined(__APPLE__)\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_LINUX || SANITIZER_MAC\n \n #include \"asan_internal.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_mapping.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n-#include \"asan_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n@@ -40,7 +41,7 @@ static void MaybeInstallSigaction(int signum,\n   sigact.sa_sigaction = handler;\n   sigact.sa_flags = SA_SIGINFO;\n   if (flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;\n-  CHECK(0 == REAL(sigaction)(signum, &sigact, 0));\n+  CHECK_EQ(0, REAL(sigaction)(signum, &sigact, 0));\n   if (flags()->verbosity >= 1) {\n     Report(\"Installed the sigaction for signal %d\\n\", signum);\n   }\n@@ -57,7 +58,7 @@ static void     ASAN_OnSIGSEGV(int, siginfo_t *siginfo, void *context) {\n \n void SetAlternateSignalStack() {\n   stack_t altstack, oldstack;\n-  CHECK(0 == sigaltstack(0, &oldstack));\n+  CHECK_EQ(0, sigaltstack(0, &oldstack));\n   // If the alternate stack is already in place, do nothing.\n   if ((oldstack.ss_flags & SS_DISABLE) == 0) return;\n   // TODO(glider): the mapped stack should have the MAP_STACK flag in the\n@@ -67,10 +68,10 @@ void SetAlternateSignalStack() {\n   altstack.ss_sp = base;\n   altstack.ss_flags = 0;\n   altstack.ss_size = kAltStackSize;\n-  CHECK(0 == sigaltstack(&altstack, 0));\n+  CHECK_EQ(0, sigaltstack(&altstack, 0));\n   if (flags()->verbosity > 0) {\n     Report(\"Alternative stack for T%d set: [%p,%p)\\n\",\n-           asanThreadRegistry().GetCurrentTidOrInvalid(),\n+           GetCurrentTidOrInvalid(),\n            altstack.ss_sp, (char*)altstack.ss_sp + altstack.ss_size);\n   }\n }\n@@ -80,7 +81,7 @@ void UnsetAlternateSignalStack() {\n   altstack.ss_sp = 0;\n   altstack.ss_flags = SS_DISABLE;\n   altstack.ss_size = 0;\n-  CHECK(0 == sigaltstack(&altstack, &oldstack));\n+  CHECK_EQ(0, sigaltstack(&altstack, &oldstack));\n   UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);\n }\n \n@@ -100,7 +101,7 @@ static bool tsd_key_inited = false;\n void AsanTSDInit(void (*destructor)(void *tsd)) {\n   CHECK(!tsd_key_inited);\n   tsd_key_inited = true;\n-  CHECK(0 == pthread_key_create(&tsd_key, destructor));\n+  CHECK_EQ(0, pthread_key_create(&tsd_key, destructor));\n }\n \n void *AsanTSDGet() {\n@@ -115,4 +116,4 @@ void AsanTSDSet(void *tsd) {\n \n }  // namespace __asan\n \n-#endif  // __linux__ || __APPLE_\n+#endif  // SANITIZER_LINUX || SANITIZER_MAC"}, {"sha": "31042401536dfdced13f03d013a9cab9fd8766c4", "filename": "libsanitizer/asan/asan_preinit.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_preinit.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -16,9 +16,11 @@\n   // On Linux, we force __asan_init to be called before anyone else\n   // by placing it into .preinit_array section.\n   // FIXME: do we have anything like this on Mac?\n+  // The symbol is called __local_asan_preinit, because it's not intended to be\n+  // exported.\n   __attribute__((section(\".preinit_array\"), used))\n-  void (*__asan_preinit)(void) =__asan_init;\n-#elif defined(_WIN32) && defined(_DLL)\n+  void (*__local_asan_preinit)(void) = __asan_init;\n+#elif SANITIZER_WINDOWS && defined(_DLL)\n   // On Windows, when using dynamic CRT (/MD), we can put a pointer\n   // to __asan_init into the global list of C initializers.\n   // See crt0dat.c in the CRT sources for the details."}, {"sha": "8f11ff4eac333146275125789898524557a9e1f1", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 196, "deletions": 112, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -15,8 +15,8 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_report_decorator.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n@@ -42,15 +42,6 @@ void AppendToErrorMessageBuffer(const char *buffer) {\n }\n \n // ---------------------- Decorator ------------------------------ {{{1\n-bool PrintsToTtyCached() {\n-  static int cached = 0;\n-  static bool prints_to_tty;\n-  if (!cached) {  // Ok wrt threads since we are printing only from one thread.\n-    prints_to_tty = PrintsToTty();\n-    cached = 1;\n-  }\n-  return prints_to_tty;\n-}\n class Decorator: private __sanitizer::AnsiColorDecorator {\n  public:\n   Decorator() : __sanitizer::AnsiColorDecorator(PrintsToTtyCached()) { }\n@@ -111,7 +102,7 @@ static void PrintShadowBytes(const char *before, u8 *bytes,\n   for (uptr i = 0; i < n; i++) {\n     u8 *p = bytes + i;\n     const char *before = p == guilty ? \"[\" :\n-        p - 1 == guilty ? \"\" : \" \";\n+        (p - 1 == guilty && i != 0) ? \"\" : \" \";\n     const char *after = p == guilty ? \"]\" : \"\";\n     PrintShadowByte(before, *p, after);\n   }\n@@ -123,12 +114,12 @@ static void PrintLegend() {\n          \"application bytes):\\n\", (int)SHADOW_GRANULARITY);\n   PrintShadowByte(\"  Addressable:           \", 0);\n   Printf(\"  Partially addressable: \");\n-  for (uptr i = 1; i < SHADOW_GRANULARITY; i++)\n+  for (u8 i = 1; i < SHADOW_GRANULARITY; i++)\n     PrintShadowByte(\"\", i, \" \");\n   Printf(\"\\n\");\n   PrintShadowByte(\"  Heap left redzone:     \", kAsanHeapLeftRedzoneMagic);\n-  PrintShadowByte(\"  Heap righ redzone:     \", kAsanHeapRightRedzoneMagic);\n-  PrintShadowByte(\"  Freed Heap region:     \", kAsanHeapFreeMagic);\n+  PrintShadowByte(\"  Heap right redzone:    \", kAsanHeapRightRedzoneMagic);\n+  PrintShadowByte(\"  Freed heap region:     \", kAsanHeapFreeMagic);\n   PrintShadowByte(\"  Stack left redzone:    \", kAsanStackLeftRedzoneMagic);\n   PrintShadowByte(\"  Stack mid redzone:     \", kAsanStackMidRedzoneMagic);\n   PrintShadowByte(\"  Stack right redzone:   \", kAsanStackRightRedzoneMagic);\n@@ -173,19 +164,34 @@ static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n   }\n }\n \n+static void DescribeThread(AsanThread *t) {\n+  if (t)\n+    DescribeThread(t->context());\n+}\n+\n // ---------------------- Address Descriptions ------------------- {{{1\n \n static bool IsASCII(unsigned char c) {\n   return /*0x00 <= c &&*/ c <= 0x7F;\n }\n \n+static const char *MaybeDemangleGlobalName(const char *name) {\n+  // We can spoil names of globals with C linkage, so use an heuristic\n+  // approach to check if the name should be demangled.\n+  return (name[0] == '_' && name[1] == 'Z' && &getSymbolizer)\n+             ? getSymbolizer()->Demangle(name)\n+             : name;\n+}\n+\n // Check if the global is a zero-terminated ASCII string. If so, print it.\n static void PrintGlobalNameIfASCII(const __asan_global &g) {\n   for (uptr p = g.beg; p < g.beg + g.size - 1; p++) {\n-    if (!IsASCII(*(unsigned char*)p)) return;\n+    unsigned char c = *(unsigned char*)p;\n+    if (c == '\\0' || !IsASCII(c)) return;\n   }\n-  if (*(char*)(g.beg + g.size - 1) != 0) return;\n-  Printf(\"  '%s' is ascii string '%s'\\n\", g.name, (char*)g.beg);\n+  if (*(char*)(g.beg + g.size - 1) != '\\0') return;\n+  Printf(\"  '%s' is ascii string '%s'\\n\",\n+         MaybeDemangleGlobalName(g.name), (char*)g.beg);\n }\n \n bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n@@ -206,8 +212,8 @@ bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n     // Can it happen?\n     Printf(\"%p is located %zd bytes inside\", (void*)addr, addr - g.beg);\n   }\n-  Printf(\" of global variable '%s' (0x%zx) of size %zu\\n\",\n-             g.name, g.beg, g.size);\n+  Printf(\" of global variable '%s' from '%s' (0x%zx) of size %zu\\n\",\n+             MaybeDemangleGlobalName(g.name), g.module_name, g.beg, g.size);\n   Printf(\"%s\", d.EndLocation());\n   PrintGlobalNameIfASCII(g);\n   return true;\n@@ -234,57 +240,149 @@ bool DescribeAddressIfShadow(uptr addr) {\n   return false;\n }\n \n+// Return \" (thread_name) \" or an empty string if the name is empty.\n+const char *ThreadNameWithParenthesis(AsanThreadContext *t, char buff[],\n+                                      uptr buff_len) {\n+  const char *name = t->name;\n+  if (name[0] == '\\0') return \"\";\n+  buff[0] = 0;\n+  internal_strncat(buff, \" (\", 3);\n+  internal_strncat(buff, name, buff_len - 4);\n+  internal_strncat(buff, \")\", 2);\n+  return buff;\n+}\n+\n+const char *ThreadNameWithParenthesis(u32 tid, char buff[],\n+                                      uptr buff_len) {\n+  if (tid == kInvalidTid) return \"\";\n+  asanThreadRegistry().CheckLocked();\n+  AsanThreadContext *t = GetThreadContextByTidLocked(tid);\n+  return ThreadNameWithParenthesis(t, buff, buff_len);\n+}\n+\n+void PrintAccessAndVarIntersection(const char *var_name,\n+                                   uptr var_beg, uptr var_size,\n+                                   uptr addr, uptr access_size,\n+                                   uptr prev_var_end, uptr next_var_beg) {\n+  uptr var_end = var_beg + var_size;\n+  uptr addr_end = addr + access_size;\n+  const char *pos_descr = 0;\n+  // If the variable [var_beg, var_end) is the nearest variable to the\n+  // current memory access, indicate it in the log.\n+  if (addr >= var_beg) {\n+    if (addr_end <= var_end)\n+      pos_descr = \"is inside\";  // May happen if this is a use-after-return.\n+    else if (addr < var_end)\n+      pos_descr = \"partially overflows\";\n+    else if (addr_end <= next_var_beg &&\n+             next_var_beg - addr_end >= addr - var_end)\n+      pos_descr = \"overflows\";\n+  } else {\n+    if (addr_end > var_beg)\n+      pos_descr = \"partially underflows\";\n+    else if (addr >= prev_var_end &&\n+             addr - prev_var_end >= var_beg - addr_end)\n+      pos_descr = \"underflows\";\n+  }\n+  Printf(\"    [%zd, %zd) '%s'\", var_beg, var_beg + var_size, var_name);\n+  if (pos_descr) {\n+    Decorator d;\n+    // FIXME: we may want to also print the size of the access here,\n+    // but in case of accesses generated by memset it may be confusing.\n+    Printf(\"%s <== Memory access at offset %zd %s this variable%s\\n\",\n+           d.Location(), addr, pos_descr, d.EndLocation());\n+  } else {\n+    Printf(\"\\n\");\n+  }\n+}\n+\n+struct StackVarDescr {\n+  uptr beg;\n+  uptr size;\n+  const char *name_pos;\n+  uptr name_len;\n+};\n+\n bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n-  AsanThread *t = asanThreadRegistry().FindThreadByStackAddress(addr);\n+  AsanThread *t = FindThreadByStackAddress(addr);\n   if (!t) return false;\n-  const sptr kBufSize = 4095;\n+  const uptr kBufSize = 4095;\n   char buf[kBufSize];\n   uptr offset = 0;\n-  const char *frame_descr = t->GetFrameNameByAddr(addr, &offset);\n+  uptr frame_pc = 0;\n+  char tname[128];\n+  const char *frame_descr = t->GetFrameNameByAddr(addr, &offset, &frame_pc);\n+\n+#ifdef __powerpc64__\n+  // On PowerPC64, the address of a function actually points to a\n+  // three-doubleword data structure with the first field containing\n+  // the address of the function's code.\n+  frame_pc = *reinterpret_cast<uptr *>(frame_pc);\n+#endif\n+\n   // This string is created by the compiler and has the following form:\n-  // \"FunctioName n alloc_1 alloc_2 ... alloc_n\"\n+  // \"n alloc_1 alloc_2 ... alloc_n\"\n   // where alloc_i looks like \"offset size len ObjectName \".\n   CHECK(frame_descr);\n-  // Report the function name and the offset.\n-  const char *name_end = internal_strchr(frame_descr, ' ');\n-  CHECK(name_end);\n-  buf[0] = 0;\n-  internal_strncat(buf, frame_descr,\n-                   Min(kBufSize,\n-                       static_cast<sptr>(name_end - frame_descr)));\n   Decorator d;\n   Printf(\"%s\", d.Location());\n-  Printf(\"Address %p is located at offset %zu \"\n-             \"in frame <%s> of T%d's stack:\\n\",\n-             (void*)addr, offset, Demangle(buf), t->tid());\n+  Printf(\"Address %p is located in stack of thread T%d%s \"\n+         \"at offset %zu in frame\\n\",\n+         addr, t->tid(),\n+         ThreadNameWithParenthesis(t->tid(), tname, sizeof(tname)),\n+         offset);\n+  // Now we print the frame where the alloca has happened.\n+  // We print this frame as a stack trace with one element.\n+  // The symbolizer may print more than one frame if inlining was involved.\n+  // The frame numbers may be different than those in the stack trace printed\n+  // previously. That's unfortunate, but I have no better solution,\n+  // especially given that the alloca may be from entirely different place\n+  // (e.g. use-after-scope, or different thread's stack).\n+  StackTrace alloca_stack;\n+  alloca_stack.trace[0] = frame_pc + 16;\n+  alloca_stack.size = 1;\n   Printf(\"%s\", d.EndLocation());\n+  PrintStack(&alloca_stack);\n   // Report the number of stack objects.\n   char *p;\n-  uptr n_objects = internal_simple_strtoll(name_end, &p, 10);\n-  CHECK(n_objects > 0);\n+  uptr n_objects = (uptr)internal_simple_strtoll(frame_descr, &p, 10);\n+  CHECK_GT(n_objects, 0);\n   Printf(\"  This frame has %zu object(s):\\n\", n_objects);\n+\n   // Report all objects in this frame.\n+  InternalScopedBuffer<StackVarDescr> vars(n_objects);\n   for (uptr i = 0; i < n_objects; i++) {\n     uptr beg, size;\n-    sptr len;\n-    beg  = internal_simple_strtoll(p, &p, 10);\n-    size = internal_simple_strtoll(p, &p, 10);\n-    len  = internal_simple_strtoll(p, &p, 10);\n-    if (beg <= 0 || size <= 0 || len < 0 || *p != ' ') {\n+    uptr len;\n+    beg  = (uptr)internal_simple_strtoll(p, &p, 10);\n+    size = (uptr)internal_simple_strtoll(p, &p, 10);\n+    len  = (uptr)internal_simple_strtoll(p, &p, 10);\n+    if (beg == 0 || size == 0 || *p != ' ') {\n       Printf(\"AddressSanitizer can't parse the stack frame \"\n                  \"descriptor: |%s|\\n\", frame_descr);\n       break;\n     }\n     p++;\n-    buf[0] = 0;\n-    internal_strncat(buf, p, Min(kBufSize, len));\n+    vars[i].beg = beg;\n+    vars[i].size = size;\n+    vars[i].name_pos = p;\n+    vars[i].name_len = len;\n     p += len;\n-    Printf(\"    [%zu, %zu) '%s'\\n\", beg, beg + size, buf);\n+  }\n+  for (uptr i = 0; i < n_objects; i++) {\n+    buf[0] = 0;\n+    internal_strncat(buf, vars[i].name_pos,\n+                     static_cast<uptr>(Min(kBufSize, vars[i].name_len)));\n+    uptr prev_var_end = i ? vars[i - 1].beg + vars[i - 1].size : 0;\n+    uptr next_var_beg = i + 1 < n_objects ? vars[i + 1].beg : ~(0UL);\n+    PrintAccessAndVarIntersection(buf, vars[i].beg, vars[i].size,\n+                                  offset, access_size,\n+                                  prev_var_end, next_var_beg);\n   }\n   Printf(\"HINT: this may be a false positive if your program uses \"\n              \"some custom stack unwind mechanism or swapcontext\\n\"\n              \"      (longjmp and C++ exceptions *are* supported)\\n\");\n-  DescribeThread(t->summary());\n+  DescribeThread(t);\n   return true;\n }\n \n@@ -312,65 +410,43 @@ static void DescribeAccessToHeapChunk(AsanChunkView chunk, uptr addr,\n   Printf(\"%s\", d.EndLocation());\n }\n \n-// Return \" (thread_name) \" or an empty string if the name is empty.\n-const char *ThreadNameWithParenthesis(AsanThreadSummary *t, char buff[],\n-                                      uptr buff_len) {\n-  const char *name = t->name();\n-  if (*name == 0) return \"\";\n-  buff[0] = 0;\n-  internal_strncat(buff, \" (\", 3);\n-  internal_strncat(buff, name, buff_len - 4);\n-  internal_strncat(buff, \")\", 2);\n-  return buff;\n-}\n-\n-const char *ThreadNameWithParenthesis(u32 tid, char buff[],\n-                                      uptr buff_len) {\n-  if (tid == kInvalidTid) return \"\";\n-  AsanThreadSummary *t = asanThreadRegistry().FindByTid(tid);\n-  return ThreadNameWithParenthesis(t, buff, buff_len);\n-}\n-\n void DescribeHeapAddress(uptr addr, uptr access_size) {\n   AsanChunkView chunk = FindHeapChunkByAddress(addr);\n   if (!chunk.IsValid()) return;\n   DescribeAccessToHeapChunk(chunk, addr, access_size);\n   CHECK(chunk.AllocTid() != kInvalidTid);\n-  AsanThreadSummary *alloc_thread =\n-      asanThreadRegistry().FindByTid(chunk.AllocTid());\n+  asanThreadRegistry().CheckLocked();\n+  AsanThreadContext *alloc_thread =\n+      GetThreadContextByTidLocked(chunk.AllocTid());\n   StackTrace alloc_stack;\n   chunk.GetAllocStack(&alloc_stack);\n-  AsanThread *t = asanThreadRegistry().GetCurrent();\n-  CHECK(t);\n   char tname[128];\n   Decorator d;\n+  AsanThreadContext *free_thread = 0;\n   if (chunk.FreeTid() != kInvalidTid) {\n-    AsanThreadSummary *free_thread =\n-        asanThreadRegistry().FindByTid(chunk.FreeTid());\n+    free_thread = GetThreadContextByTidLocked(chunk.FreeTid());\n     Printf(\"%sfreed by thread T%d%s here:%s\\n\", d.Allocation(),\n-           free_thread->tid(),\n+           free_thread->tid,\n            ThreadNameWithParenthesis(free_thread, tname, sizeof(tname)),\n            d.EndAllocation());\n     StackTrace free_stack;\n     chunk.GetFreeStack(&free_stack);\n     PrintStack(&free_stack);\n     Printf(\"%spreviously allocated by thread T%d%s here:%s\\n\",\n-           d.Allocation(), alloc_thread->tid(),\n+           d.Allocation(), alloc_thread->tid,\n            ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n            d.EndAllocation());\n-    PrintStack(&alloc_stack);\n-    DescribeThread(t->summary());\n-    DescribeThread(free_thread);\n-    DescribeThread(alloc_thread);\n   } else {\n     Printf(\"%sallocated by thread T%d%s here:%s\\n\", d.Allocation(),\n-           alloc_thread->tid(),\n+           alloc_thread->tid,\n            ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n            d.EndAllocation());\n-    PrintStack(&alloc_stack);\n-    DescribeThread(t->summary());\n-    DescribeThread(alloc_thread);\n   }\n+  PrintStack(&alloc_stack);\n+  DescribeThread(GetCurrentThread());\n+  if (free_thread)\n+    DescribeThread(free_thread);\n+  DescribeThread(alloc_thread);\n }\n \n void DescribeAddress(uptr addr, uptr access_size) {\n@@ -388,26 +464,27 @@ void DescribeAddress(uptr addr, uptr access_size) {\n \n // ------------------- Thread description -------------------- {{{1\n \n-void DescribeThread(AsanThreadSummary *summary) {\n-  CHECK(summary);\n+void DescribeThread(AsanThreadContext *context) {\n+  CHECK(context);\n+  asanThreadRegistry().CheckLocked();\n   // No need to announce the main thread.\n-  if (summary->tid() == 0 || summary->announced()) {\n+  if (context->tid == 0 || context->announced) {\n     return;\n   }\n-  summary->set_announced(true);\n+  context->announced = true;\n   char tname[128];\n-  Printf(\"Thread T%d%s\", summary->tid(),\n-         ThreadNameWithParenthesis(summary->tid(), tname, sizeof(tname)));\n+  Printf(\"Thread T%d%s\", context->tid,\n+         ThreadNameWithParenthesis(context->tid, tname, sizeof(tname)));\n   Printf(\" created by T%d%s here:\\n\",\n-         summary->parent_tid(),\n-         ThreadNameWithParenthesis(summary->parent_tid(),\n+         context->parent_tid,\n+         ThreadNameWithParenthesis(context->parent_tid,\n                                    tname, sizeof(tname)));\n-  PrintStack(summary->stack());\n+  PrintStack(&context->stack);\n   // Recursively described parent thread if needed.\n   if (flags()->print_full_thread_history) {\n-    AsanThreadSummary *parent_summary =\n-        asanThreadRegistry().FindByTid(summary->parent_tid());\n-    DescribeThread(parent_summary);\n+    AsanThreadContext *parent_context =\n+        GetThreadContextByTidLocked(context->parent_tid);\n+    DescribeThread(parent_context);\n   }\n }\n \n@@ -426,7 +503,7 @@ class ScopedInErrorReport {\n       // they are defined as no-return.\n       Report(\"AddressSanitizer: while reporting a bug found another one.\"\n                  \"Ignoring.\\n\");\n-      u32 current_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+      u32 current_tid = GetCurrentTidOrInvalid();\n       if (current_tid != reporting_thread_tid) {\n         // ASan found two bugs in different threads simultaneously. Sleep\n         // long enough to make sure that the thread which started to print\n@@ -438,24 +515,20 @@ class ScopedInErrorReport {\n       internal__exit(flags()->exitcode);\n     }\n     ASAN_ON_ERROR();\n-    reporting_thread_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+    // Make sure the registry and sanitizer report mutexes are locked while\n+    // we're printing an error report.\n+    // We can lock them only here to avoid self-deadlock in case of\n+    // recursive reports.\n+    asanThreadRegistry().Lock();\n+    CommonSanitizerReportMutex.Lock();\n+    reporting_thread_tid = GetCurrentTidOrInvalid();\n     Printf(\"====================================================\"\n            \"=============\\n\");\n-    if (reporting_thread_tid != kInvalidTid) {\n-      // We started reporting an error message. Stop using the fake stack\n-      // in case we call an instrumented function from a symbolizer.\n-      AsanThread *curr_thread = asanThreadRegistry().GetCurrent();\n-      CHECK(curr_thread);\n-      curr_thread->fake_stack().StopUsingFakeStack();\n-    }\n   }\n   // Destructor is NORETURN, as functions that report errors are.\n   NORETURN ~ScopedInErrorReport() {\n     // Make sure the current thread is announced.\n-    AsanThread *curr_thread = asanThreadRegistry().GetCurrent();\n-    if (curr_thread) {\n-      DescribeThread(curr_thread->summary());\n-    }\n+    DescribeThread(GetCurrentThread());\n     // Print memory stats.\n     if (flags()->print_stats)\n       __asan_print_accumulated_stats();\n@@ -469,13 +542,15 @@ class ScopedInErrorReport {\n \n static void ReportSummary(const char *error_type, StackTrace *stack) {\n   if (!stack->size) return;\n-  if (IsSymbolizerAvailable()) {\n+  if (&getSymbolizer && getSymbolizer()->IsAvailable()) {\n     AddressInfo ai;\n     // Currently, we include the first stack frame into the report summary.\n     // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n-    SymbolizeCode(stack->trace[0], &ai, 1);\n+    uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n+    getSymbolizer()->SymbolizeCode(pc, &ai, 1);\n     ReportErrorSummary(error_type,\n-                       StripPathPrefix(ai.file, flags()->strip_path_prefix),\n+                       StripPathPrefix(ai.file,\n+                                       common_flags()->strip_path_prefix),\n                        ai.line, ai.function);\n   }\n   // FIXME: do we need to print anything at all if there is no symbolizer?\n@@ -488,7 +563,7 @@ void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n   Report(\"ERROR: AddressSanitizer: SEGV on unknown address %p\"\n              \" (pc %p sp %p bp %p T%d)\\n\",\n              (void*)addr, (void*)pc, (void*)sp, (void*)bp,\n-             asanThreadRegistry().GetCurrentTidOrInvalid());\n+             GetCurrentTidOrInvalid());\n   Printf(\"%s\", d.EndWarning());\n   Printf(\"AddressSanitizer can not provide additional info.\\n\");\n   GET_STACK_TRACE_FATAL(pc, bp);\n@@ -500,7 +575,13 @@ void ReportDoubleFree(uptr addr, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: attempting double-free on %p:\\n\", addr);\n+  char tname[128];\n+  u32 curr_tid = GetCurrentTidOrInvalid();\n+  Report(\"ERROR: AddressSanitizer: attempting double-free on %p in \"\n+         \"thread T%d%s:\\n\",\n+         addr, curr_tid,\n+         ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n+\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n@@ -511,8 +592,11 @@ void ReportFreeNotMalloced(uptr addr, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n+  char tname[128];\n+  u32 curr_tid = GetCurrentTidOrInvalid();\n   Report(\"ERROR: AddressSanitizer: attempting free on address \"\n-             \"which was not malloc()-ed: %p\\n\", addr);\n+             \"which was not malloc()-ed: %p in thread T%d%s\\n\", addr,\n+         curr_tid, ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n@@ -678,7 +762,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp,\n              bug_descr, (void*)addr, pc, bp, sp);\n   Printf(\"%s\", d.EndWarning());\n \n-  u32 curr_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+  u32 curr_tid = GetCurrentTidOrInvalid();\n   char tname[128];\n   Printf(\"%s%s of size %zu at %p thread T%d%s%s\\n\",\n          d.Access(),\n@@ -712,6 +796,6 @@ void __asan_describe_address(uptr addr) {\n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n // Provide default implementation of __asan_on_error that does nothing\n // and may be overriden by user.\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE NOINLINE\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n void __asan_on_error() {}\n #endif"}, {"sha": "afe7673304cb1433cde85f25d7e6a769aa9caf5a", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -27,7 +27,7 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size);\n // Determines memory type on its own.\n void DescribeAddress(uptr addr, uptr access_size);\n \n-void DescribeThread(AsanThreadSummary *summary);\n+void DescribeThread(AsanThreadContext *context);\n \n // Different kinds of error reports.\n void NORETURN ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr);"}, {"sha": "67327611e84c135785011779e2ae4b424e5e9bf8", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 120, "deletions": 67, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -11,17 +11,21 @@\n //===----------------------------------------------------------------------===//\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n+#include \"asan_interface_internal.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n+#include \"lsan/lsan_common.h\"\n+\n+int __asan_option_detect_stack_use_after_return;  // Global interface symbol.\n \n namespace __asan {\n \n@@ -62,13 +66,9 @@ static void AsanCheckFailed(const char *file, int line, const char *cond,\n }\n \n // -------------------------- Flags ------------------------- {{{1\n-static const int kDeafultMallocContextSize = 30;\n-\n-static Flags asan_flags;\n+static const int kDefaultMallocContextSize = 30;\n \n-Flags *flags() {\n-  return &asan_flags;\n-}\n+Flags asan_flags_dont_use_directly;  // use via flags().\n \n static const char *MaybeCallAsanDefaultOptions() {\n   return (&__asan_default_options) ? __asan_default_options() : \"\";\n@@ -86,28 +86,32 @@ static const char *MaybeUseAsanDefaultOptionsCompileDefiniton() {\n }\n \n static void ParseFlagsFromString(Flags *f, const char *str) {\n+  ParseCommonFlagsFromString(str);\n+  CHECK((uptr)common_flags()->malloc_context_size <= kStackTraceMax);\n+\n   ParseFlag(str, &f->quarantine_size, \"quarantine_size\");\n-  ParseFlag(str, &f->symbolize, \"symbolize\");\n   ParseFlag(str, &f->verbosity, \"verbosity\");\n   ParseFlag(str, &f->redzone, \"redzone\");\n-  CHECK(f->redzone >= 16);\n+  CHECK_GE(f->redzone, 16);\n   CHECK(IsPowerOfTwo(f->redzone));\n \n   ParseFlag(str, &f->debug, \"debug\");\n   ParseFlag(str, &f->report_globals, \"report_globals\");\n-  ParseFlag(str, &f->check_initialization_order, \"initialization_order\");\n-  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\");\n-  CHECK((uptr)f->malloc_context_size <= kStackTraceMax);\n+  ParseFlag(str, &f->check_initialization_order, \"check_initialization_order\");\n \n   ParseFlag(str, &f->replace_str, \"replace_str\");\n   ParseFlag(str, &f->replace_intrin, \"replace_intrin\");\n   ParseFlag(str, &f->mac_ignore_invalid_free, \"mac_ignore_invalid_free\");\n-  ParseFlag(str, &f->use_fake_stack, \"use_fake_stack\");\n+  ParseFlag(str, &f->detect_stack_use_after_return,\n+            \"detect_stack_use_after_return\");\n+  ParseFlag(str, &f->uar_stack_size_log, \"uar_stack_size_log\");\n   ParseFlag(str, &f->max_malloc_fill_size, \"max_malloc_fill_size\");\n+  ParseFlag(str, &f->malloc_fill_byte, \"malloc_fill_byte\");\n   ParseFlag(str, &f->exitcode, \"exitcode\");\n   ParseFlag(str, &f->allow_user_poisoning, \"allow_user_poisoning\");\n   ParseFlag(str, &f->sleep_before_dying, \"sleep_before_dying\");\n   ParseFlag(str, &f->handle_segv, \"handle_segv\");\n+  ParseFlag(str, &f->allow_user_segv_handler, \"allow_user_segv_handler\");\n   ParseFlag(str, &f->use_sigaltstack, \"use_sigaltstack\");\n   ParseFlag(str, &f->check_malloc_usable_size, \"check_malloc_usable_size\");\n   ParseFlag(str, &f->unmap_shadow_on_exit, \"unmap_shadow_on_exit\");\n@@ -116,37 +120,47 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n   ParseFlag(str, &f->print_legend, \"print_legend\");\n   ParseFlag(str, &f->atexit, \"atexit\");\n   ParseFlag(str, &f->disable_core, \"disable_core\");\n-  ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\");\n   ParseFlag(str, &f->allow_reexec, \"allow_reexec\");\n   ParseFlag(str, &f->print_full_thread_history, \"print_full_thread_history\");\n-  ParseFlag(str, &f->log_path, \"log_path\");\n-  ParseFlag(str, &f->fast_unwind_on_fatal, \"fast_unwind_on_fatal\");\n-  ParseFlag(str, &f->fast_unwind_on_malloc, \"fast_unwind_on_malloc\");\n   ParseFlag(str, &f->poison_heap, \"poison_heap\");\n   ParseFlag(str, &f->alloc_dealloc_mismatch, \"alloc_dealloc_mismatch\");\n   ParseFlag(str, &f->use_stack_depot, \"use_stack_depot\");\n+  ParseFlag(str, &f->strict_memcmp, \"strict_memcmp\");\n+  ParseFlag(str, &f->strict_init_order, \"strict_init_order\");\n }\n \n void InitializeFlags(Flags *f, const char *env) {\n-  internal_memset(f, 0, sizeof(*f));\n+  CommonFlags *cf = common_flags();\n+  cf->external_symbolizer_path = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n+  cf->symbolize = true;\n+  cf->malloc_context_size = kDefaultMallocContextSize;\n+  cf->fast_unwind_on_fatal = false;\n+  cf->fast_unwind_on_malloc = true;\n+  cf->strip_path_prefix = \"\";\n+  cf->handle_ioctl = false;\n+  cf->log_path = 0;\n+  cf->detect_leaks = false;\n+  cf->leak_check_at_exit = true;\n \n+  internal_memset(f, 0, sizeof(*f));\n   f->quarantine_size = (ASAN_LOW_MEMORY) ? 1UL << 26 : 1UL << 28;\n-  f->symbolize = false;\n   f->verbosity = 0;\n-  f->redzone = ASAN_ALLOCATOR_VERSION == 2 ? 16 : (ASAN_LOW_MEMORY) ? 64 : 128;\n+  f->redzone = 16;\n   f->debug = false;\n   f->report_globals = 1;\n-  f->check_initialization_order = true;\n-  f->malloc_context_size = kDeafultMallocContextSize;\n+  f->check_initialization_order = false;\n   f->replace_str = true;\n   f->replace_intrin = true;\n   f->mac_ignore_invalid_free = false;\n-  f->use_fake_stack = true;\n-  f->max_malloc_fill_size = 0;\n+  f->detect_stack_use_after_return = false;  // Also needs the compiler flag.\n+  f->uar_stack_size_log = 0;\n+  f->max_malloc_fill_size = 0x1000;  // By default, fill only the first 4K.\n+  f->malloc_fill_byte = 0xbe;\n   f->exitcode = ASAN_DEFAULT_FAILURE_EXITCODE;\n   f->allow_user_poisoning = true;\n   f->sleep_before_dying = 0;\n   f->handle_segv = ASAN_NEEDS_SEGV;\n+  f->allow_user_segv_handler = false;\n   f->use_sigaltstack = false;\n   f->check_malloc_usable_size = true;\n   f->unmap_shadow_on_exit = false;\n@@ -155,15 +169,15 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->print_legend = true;\n   f->atexit = false;\n   f->disable_core = (SANITIZER_WORDSIZE == 64);\n-  f->strip_path_prefix = \"\";\n   f->allow_reexec = true;\n   f->print_full_thread_history = true;\n-  f->log_path = 0;\n-  f->fast_unwind_on_fatal = false;\n-  f->fast_unwind_on_malloc = true;\n   f->poison_heap = true;\n-  f->alloc_dealloc_mismatch = true;\n-  f->use_stack_depot = true;  // Only affects allocator2.\n+  // Turn off alloc/dealloc mismatch checker on Mac and Windows for now.\n+  // TODO(glider,timurrrr): Fix known issues and enable this back.\n+  f->alloc_dealloc_mismatch = (SANITIZER_MAC == 0) && (SANITIZER_WINDOWS == 0);\n+  f->use_stack_depot = true;\n+  f->strict_memcmp = true;\n+  f->strict_init_order = false;\n \n   // Override from compile definition.\n   ParseFlagsFromString(f, MaybeUseAsanDefaultOptionsCompileDefiniton());\n@@ -177,6 +191,20 @@ void InitializeFlags(Flags *f, const char *env) {\n \n   // Override from command line.\n   ParseFlagsFromString(f, env);\n+\n+#if !CAN_SANITIZE_LEAKS\n+  if (cf->detect_leaks) {\n+    Report(\"%s: detect_leaks is not supported on this platform.\\n\",\n+           SanitizerToolName);\n+    cf->detect_leaks = false;\n+  }\n+#endif\n+\n+  if (cf->detect_leaks && !f->use_stack_depot) {\n+    Report(\"%s: detect_leaks is ignored (requires use_stack_depot).\\n\",\n+           SanitizerToolName);\n+    cf->detect_leaks = false;\n+  }\n }\n \n // -------------------------- Globals --------------------- {{{1\n@@ -197,8 +225,8 @@ void ShowStatsAndAbort() {\n // ---------------------- mmap -------------------- {{{1\n // Reserve memory range [beg, end].\n static void ReserveShadowMemoryRange(uptr beg, uptr end) {\n-  CHECK((beg % GetPageSizeCached()) == 0);\n-  CHECK(((end + 1) % GetPageSizeCached()) == 0);\n+  CHECK_EQ((beg % GetPageSizeCached()), 0);\n+  CHECK_EQ(((end + 1) % GetPageSizeCached()), 0);\n   uptr size = end - beg + 1;\n   void *res = MmapFixedNoReserve(beg, size);\n   if (res != (void*)beg) {\n@@ -281,9 +309,7 @@ static NOINLINE void force_interface_symbols() {\n     case 25: __asan_poison_memory_region(0, 0); break;\n     case 26: __asan_unpoison_memory_region(0, 0); break;\n     case 27: __asan_set_error_exit_code(0); break;\n-    case 28: __asan_stack_free(0, 0, 0); break;\n-    case 29: __asan_stack_malloc(0, 0); break;\n-    case 30: __asan_before_dynamic_init(0, 0); break;\n+    case 30: __asan_before_dynamic_init(0); break;\n     case 31: __asan_after_dynamic_init(); break;\n     case 32: __asan_poison_stack_memory(0, 0); break;\n     case 33: __asan_unpoison_stack_memory(0, 0); break;\n@@ -304,22 +330,12 @@ static void asan_atexit() {\n \n static void InitializeHighMemEnd() {\n #if !ASAN_FIXED_MAPPING\n-#if SANITIZER_WORDSIZE == 64\n-# if defined(__powerpc64__)\n-  // FIXME:\n-  // On PowerPC64 we have two different address space layouts: 44- and 46-bit.\n-  // We somehow need to figure our which one we are using now and choose\n-  // one of 0x00000fffffffffffUL and 0x00003fffffffffffUL.\n-  // Note that with 'ulimit -s unlimited' the stack is moved away from the top\n-  // of the address space, so simply checking the stack address is not enough.\n-  kHighMemEnd = (1ULL << 44) - 1;  // 0x00000fffffffffffUL\n-# else\n-  kHighMemEnd = (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n-# endif\n-#else  // SANITIZER_WORDSIZE == 32\n-  kHighMemEnd = (1ULL << 32) - 1;  // 0xffffffff;\n-#endif  // SANITIZER_WORDSIZE\n+  kHighMemEnd = GetMaxVirtualAddress();\n+  // Increase kHighMemEnd to make sure it's properly\n+  // aligned together with kHighMemBeg:\n+  kHighMemEnd |= SHADOW_GRANULARITY * GetPageSizeCached() - 1;\n #endif  // !ASAN_FIXED_MAPPING\n+  CHECK_EQ((kHighMemBeg % GetPageSizeCached()), 0);\n }\n \n static void ProtectGap(uptr a, uptr size) {\n@@ -361,7 +377,9 @@ static void PrintAddressSpaceLayout() {\n   }\n   Printf(\"\\n\");\n   Printf(\"red_zone=%zu\\n\", (uptr)flags()->redzone);\n-  Printf(\"malloc_context_size=%zu\\n\", (uptr)flags()->malloc_context_size);\n+  Printf(\"quarantine_size=%zuM\\n\", (uptr)flags()->quarantine_size >> 20);\n+  Printf(\"malloc_context_size=%zu\\n\",\n+         (uptr)common_flags()->malloc_context_size);\n \n   Printf(\"SHADOW_SCALE: %zx\\n\", (uptr)SHADOW_SCALE);\n   Printf(\"SHADOW_GRANULARITY: %zx\\n\", (uptr)SHADOW_GRANULARITY);\n@@ -380,7 +398,7 @@ using namespace __asan;  // NOLINT\n \n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n extern \"C\" {\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n const char* __asan_default_options() { return \"\"; }\n }  // extern \"C\"\n #endif\n@@ -393,12 +411,28 @@ int NOINLINE __asan_set_error_exit_code(int exit_code) {\n \n void NOINLINE __asan_handle_no_return() {\n   int local_stack;\n-  AsanThread *curr_thread = asanThreadRegistry().GetCurrent();\n+  AsanThread *curr_thread = GetCurrentThread();\n   CHECK(curr_thread);\n   uptr PageSize = GetPageSizeCached();\n   uptr top = curr_thread->stack_top();\n   uptr bottom = ((uptr)&local_stack - PageSize) & ~(PageSize-1);\n+  static const uptr kMaxExpectedCleanupSize = 64 << 20;  // 64M\n+  if (top - bottom > kMaxExpectedCleanupSize) {\n+    static bool reported_warning = false;\n+    if (reported_warning)\n+      return;\n+    reported_warning = true;\n+    Report(\"WARNING: ASan is ignoring requested __asan_handle_no_return: \"\n+           \"stack top: %p; bottom %p; size: %p (%zd)\\n\"\n+           \"False positive error reports may follow\\n\"\n+           \"For details see \"\n+           \"http://code.google.com/p/address-sanitizer/issues/detail?id=189\\n\",\n+           top, bottom, top - bottom, top - bottom);\n+    return;\n+  }\n   PoisonShadow(bottom, top - bottom, 0);\n+  if (curr_thread->has_fake_stack())\n+    curr_thread->fake_stack()->HandleNoReturn();\n }\n \n void NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n@@ -424,7 +458,9 @@ void __asan_init() {\n   // initialization steps look at flags().\n   const char *options = GetEnv(\"ASAN_OPTIONS\");\n   InitializeFlags(flags(), options);\n-  __sanitizer_set_report_path(flags()->log_path);\n+  __sanitizer_set_report_path(common_flags()->log_path);\n+  __asan_option_detect_stack_use_after_return =\n+      flags()->detect_stack_use_after_return;\n \n   if (flags()->verbosity && options) {\n     Report(\"Parsed ASAN_OPTIONS: %s\\n\", options);\n@@ -447,12 +483,12 @@ void __asan_init() {\n   ReplaceOperatorsNewAndDelete();\n \n   uptr shadow_start = kLowShadowBeg;\n-  if (kLowShadowBeg) shadow_start -= GetMmapGranularity();\n-  uptr shadow_end = kHighShadowEnd;\n+  if (kLowShadowBeg)\n+    shadow_start -= GetMmapGranularity();\n   bool full_shadow_is_available =\n-      MemoryRangeIsAvailable(shadow_start, shadow_end);\n+      MemoryRangeIsAvailable(shadow_start, kHighShadowEnd);\n \n-#if ASAN_LINUX && defined(__x86_64__) && !ASAN_FIXED_MAPPING\n+#if SANITIZER_LINUX && defined(__x86_64__) && !ASAN_FIXED_MAPPING\n   if (!full_shadow_is_available) {\n     kMidMemBeg = kLowMemEnd < 0x3000000000ULL ? 0x3000000000ULL : 0;\n     kMidMemEnd = kLowMemEnd < 0x3000000000ULL ? 0x4fffffffffULL : 0;\n@@ -476,7 +512,7 @@ void __asan_init() {\n     ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n   } else if (kMidMemBeg &&\n       MemoryRangeIsAvailable(shadow_start, kMidMemBeg - 1) &&\n-      MemoryRangeIsAvailable(kMidMemEnd + 1, shadow_end)) {\n+      MemoryRangeIsAvailable(kMidMemEnd + 1, kHighShadowEnd)) {\n     CHECK(kLowShadowBeg != kLowShadowEnd);\n     // mmap the low shadow plus at least one page at the left.\n     ReserveShadowMemoryRange(shadow_start, kLowShadowEnd);\n@@ -496,24 +532,41 @@ void __asan_init() {\n   }\n \n   InstallSignalHandlers();\n+\n+  AsanTSDInit(AsanThread::TSDDtor);\n+  // Allocator should be initialized before starting external symbolizer, as\n+  // fork() on Mac locks the allocator.\n+  InitializeAllocator();\n+\n   // Start symbolizer process if necessary.\n-  if (flags()->symbolize) {\n-    const char *external_symbolizer = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n-    if (external_symbolizer) {\n-      InitializeExternalSymbolizer(external_symbolizer);\n-    }\n+  if (common_flags()->symbolize && &getSymbolizer) {\n+    getSymbolizer()\n+        ->InitializeExternal(common_flags()->external_symbolizer_path);\n   }\n \n   // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n   // should be set to 1 prior to initializing the threads.\n   asan_inited = 1;\n   asan_init_is_running = false;\n \n-  asanThreadRegistry().Init();\n-  asanThreadRegistry().GetMain()->ThreadStart();\n+  InitTlsSize();\n+\n+  // Create main thread.\n+  AsanThread *main_thread = AsanThread::Create(0, 0);\n+  CreateThreadContextArgs create_main_args = { main_thread, 0 };\n+  u32 main_tid = asanThreadRegistry().CreateThread(\n+      0, true, 0, &create_main_args);\n+  CHECK_EQ(0, main_tid);\n+  SetCurrentThread(main_thread);\n+  main_thread->ThreadStart(internal_getpid());\n   force_interface_symbols();  // no-op.\n \n-  InitializeAllocator();\n+#if CAN_SANITIZE_LEAKS\n+  __lsan::InitCommonLsan();\n+  if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit) {\n+    Atexit(__lsan::DoLeakCheck);\n+  }\n+#endif  // CAN_SANITIZE_LEAKS\n \n   if (flags()->verbosity) {\n     Report(\"AddressSanitizer Init done\\n\");"}, {"sha": "749525186421c7236a0bd8cab4f4cbf1a968b4cb", "filename": "libsanitizer/asan/asan_stack.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -12,6 +12,7 @@\n #include \"asan_internal.h\"\n #include \"asan_flags.h\"\n #include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n \n namespace __asan {\n \n@@ -22,8 +23,8 @@ static bool MaybeCallAsanSymbolize(const void *pc, char *out_buffer,\n }\n \n void PrintStack(StackTrace *stack) {\n-  stack->PrintStack(stack->trace, stack->size, flags()->symbolize,\n-                    flags()->strip_path_prefix, MaybeCallAsanSymbolize);\n+  stack->PrintStack(stack->trace, stack->size, common_flags()->symbolize,\n+                    common_flags()->strip_path_prefix, MaybeCallAsanSymbolize);\n }\n \n }  // namespace __asan\n@@ -33,8 +34,8 @@ void PrintStack(StackTrace *stack) {\n // Provide default implementation of __asan_symbolize that does nothing\n // and may be overriden by user if he wants to use his own symbolization.\n // ASan on Windows has its own implementation of this.\n-#if !defined(_WIN32) && !SANITIZER_SUPPORTS_WEAK_HOOKS\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE NOINLINE\n+#if !SANITIZER_WINDOWS && !SANITIZER_SUPPORTS_WEAK_HOOKS\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n bool __asan_symbolize(const void *pc, char *out_buffer, int out_size) {\n   return false;\n }"}, {"sha": "3c0ac31f6c640aa130e4c4efa1a148b5f16528ed", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -12,23 +12,38 @@\n #ifndef ASAN_STACK_H\n #define ASAN_STACK_H\n \n-#include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"asan_flags.h\"\n+#include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n \n namespace __asan {\n \n-void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast);\n void PrintStack(StackTrace *stack);\n \n }  // namespace __asan\n \n // Get the stack trace with the given pc and bp.\n // The pc will be in the position 0 of the resulting stack trace.\n // The bp may refer to the current frame or to the caller's frame.\n-// fast_unwind is currently unused.\n-#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast)     \\\n-  StackTrace stack;                                             \\\n-  GetStackTrace(&stack, max_s, pc, bp, fast)\n+#if SANITIZER_WINDOWS\n+#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast) \\\n+  StackTrace stack;                                         \\\n+  GetStackTrace(&stack, max_s, pc, bp, 0, 0, fast)\n+#else\n+#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast)                \\\n+  StackTrace stack;                                                        \\\n+  {                                                                        \\\n+    AsanThread *t;                                                         \\\n+    stack.size = 0;                                                        \\\n+    if (asan_inited && (t = GetCurrentThread()) && !t->isUnwinding()) {    \\\n+      uptr stack_top = t->stack_top();                                     \\\n+      uptr stack_bottom = t->stack_bottom();                               \\\n+      ScopedUnwinding unwind_scope(t);                                     \\\n+      GetStackTrace(&stack, max_s, pc, bp, stack_top, stack_bottom, fast); \\\n+    }                                                                      \\\n+  }\n+#endif  // SANITIZER_WINDOWS\n \n // NOTE: A Rule of thumb is to retrieve stack trace in the interceptors\n // as early as possible (in functions exposed to the user), as we generally\n@@ -40,24 +55,24 @@ void PrintStack(StackTrace *stack);\n \n #define GET_STACK_TRACE_FATAL(pc, bp)                                 \\\n   GET_STACK_TRACE_WITH_PC_AND_BP(kStackTraceMax, pc, bp,              \\\n-                                 flags()->fast_unwind_on_fatal)\n+                                 common_flags()->fast_unwind_on_fatal)\n \n-#define GET_STACK_TRACE_FATAL_HERE                           \\\n-  GET_STACK_TRACE(kStackTraceMax, flags()->fast_unwind_on_fatal)\n+#define GET_STACK_TRACE_FATAL_HERE                                \\\n+  GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n \n-#define GET_STACK_TRACE_THREAD                              \\\n+#define GET_STACK_TRACE_THREAD                                    \\\n   GET_STACK_TRACE(kStackTraceMax, true)\n \n-#define GET_STACK_TRACE_MALLOC                             \\\n-  GET_STACK_TRACE(flags()->malloc_context_size,            \\\n-                  flags()->fast_unwind_on_malloc)\n+#define GET_STACK_TRACE_MALLOC                                    \\\n+  GET_STACK_TRACE(common_flags()->malloc_context_size,            \\\n+                  common_flags()->fast_unwind_on_malloc)\n \n #define GET_STACK_TRACE_FREE GET_STACK_TRACE_MALLOC\n \n #define PRINT_CURRENT_STACK()                    \\\n   {                                              \\\n     GET_STACK_TRACE(kStackTraceMax,              \\\n-      flags()->fast_unwind_on_fatal);            \\\n+      common_flags()->fast_unwind_on_fatal);     \\\n     PrintStack(&stack);                          \\\n   }\n "}, {"sha": "71c8582e81c37c0ce71c468f4bbc1ca2e2b32be2", "filename": "libsanitizer/asan/asan_stats.cc", "status": "modified", "additions": 91, "deletions": 6, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -12,13 +12,18 @@\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_stats.h\"\n-#include \"asan_thread_registry.h\"\n+#include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n namespace __asan {\n \n AsanStats::AsanStats() {\n-  CHECK(REAL(memset) != 0);\n+  Clear();\n+}\n+\n+void AsanStats::Clear() {\n+  CHECK(REAL(memset));\n   REAL(memset)(this, 0, sizeof(AsanStats));\n }\n \n@@ -51,11 +56,73 @@ void AsanStats::Print() {\n              malloc_large, malloc_small_slow);\n }\n \n+void AsanStats::MergeFrom(const AsanStats *stats) {\n+  uptr *dst_ptr = reinterpret_cast<uptr*>(this);\n+  const uptr *src_ptr = reinterpret_cast<const uptr*>(stats);\n+  uptr num_fields = sizeof(*this) / sizeof(uptr);\n+  for (uptr i = 0; i < num_fields; i++)\n+    dst_ptr[i] += src_ptr[i];\n+}\n+\n static BlockingMutex print_lock(LINKER_INITIALIZED);\n \n+static AsanStats unknown_thread_stats(LINKER_INITIALIZED);\n+static AsanStats dead_threads_stats(LINKER_INITIALIZED);\n+static BlockingMutex dead_threads_stats_lock(LINKER_INITIALIZED);\n+// Required for malloc_zone_statistics() on OS X. This can't be stored in\n+// per-thread AsanStats.\n+static uptr max_malloced_memory;\n+\n+static void MergeThreadStats(ThreadContextBase *tctx_base, void *arg) {\n+  AsanStats *accumulated_stats = reinterpret_cast<AsanStats*>(arg);\n+  AsanThreadContext *tctx = static_cast<AsanThreadContext*>(tctx_base);\n+  if (AsanThread *t = tctx->thread)\n+    accumulated_stats->MergeFrom(&t->stats());\n+}\n+\n+static void GetAccumulatedStats(AsanStats *stats) {\n+  stats->Clear();\n+  {\n+    ThreadRegistryLock l(&asanThreadRegistry());\n+    asanThreadRegistry()\n+        .RunCallbackForEachThreadLocked(MergeThreadStats, stats);\n+  }\n+  stats->MergeFrom(&unknown_thread_stats);\n+  {\n+    BlockingMutexLock lock(&dead_threads_stats_lock);\n+    stats->MergeFrom(&dead_threads_stats);\n+  }\n+  // This is not very accurate: we may miss allocation peaks that happen\n+  // between two updates of accumulated_stats_. For more accurate bookkeeping\n+  // the maximum should be updated on every malloc(), which is unacceptable.\n+  if (max_malloced_memory < stats->malloced) {\n+    max_malloced_memory = stats->malloced;\n+  }\n+}\n+\n+void FlushToDeadThreadStats(AsanStats *stats) {\n+  BlockingMutexLock lock(&dead_threads_stats_lock);\n+  dead_threads_stats.MergeFrom(stats);\n+  stats->Clear();\n+}\n+\n+void FillMallocStatistics(AsanMallocStats *malloc_stats) {\n+  AsanStats stats;\n+  GetAccumulatedStats(&stats);\n+  malloc_stats->blocks_in_use = stats.mallocs;\n+  malloc_stats->size_in_use = stats.malloced;\n+  malloc_stats->max_size_in_use = max_malloced_memory;\n+  malloc_stats->size_allocated = stats.mmaped;\n+}\n+\n+AsanStats &GetCurrentThreadStats() {\n+  AsanThread *t = GetCurrentThread();\n+  return (t) ? t->stats() : unknown_thread_stats;\n+}\n+\n static void PrintAccumulatedStats() {\n   AsanStats stats;\n-  asanThreadRegistry().GetAccumulatedStats(&stats);\n+  GetAccumulatedStats(&stats);\n   // Use lock to keep reports from mixing up.\n   BlockingMutexLock lock(&print_lock);\n   stats.Print();\n@@ -71,15 +138,33 @@ static void PrintAccumulatedStats() {\n using namespace __asan;  // NOLINT\n \n uptr __asan_get_current_allocated_bytes() {\n-  return asanThreadRegistry().GetCurrentAllocatedBytes();\n+  AsanStats stats;\n+  GetAccumulatedStats(&stats);\n+  uptr malloced = stats.malloced;\n+  uptr freed = stats.freed;\n+  // Return sane value if malloced < freed due to racy\n+  // way we update accumulated stats.\n+  return (malloced > freed) ? malloced - freed : 1;\n }\n \n uptr __asan_get_heap_size() {\n-  return asanThreadRegistry().GetHeapSize();\n+  AsanStats stats;\n+  GetAccumulatedStats(&stats);\n+  return stats.mmaped - stats.munmaped;\n }\n \n uptr __asan_get_free_bytes() {\n-  return asanThreadRegistry().GetFreeBytes();\n+  AsanStats stats;\n+  GetAccumulatedStats(&stats);\n+  uptr total_free = stats.mmaped\n+                  - stats.munmaped\n+                  + stats.really_freed\n+                  + stats.really_freed_redzones;\n+  uptr total_used = stats.malloced\n+                  + stats.malloced_redzones;\n+  // Return sane value if total_free < total_used due to racy\n+  // way we update accumulated stats.\n+  return (total_free > total_used) ? total_free - total_used : 1;\n }\n \n uptr __asan_get_unmapped_bytes() {"}, {"sha": "2f964f8d052e57f89d60a4c35d463de74c1b4d9a", "filename": "libsanitizer/asan/asan_stats.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -50,10 +50,17 @@ struct AsanStats {\n   // Default ctor for thread-local stats.\n   AsanStats();\n \n-  // Prints formatted stats to stderr.\n-  void Print();\n+  void Print();  // Prints formatted stats to stderr.\n+  void Clear();\n+  void MergeFrom(const AsanStats *stats);\n };\n \n+// Returns stats for GetCurrentThread(), or stats for fake \"unknown thread\"\n+// if GetCurrentThread() returns 0.\n+AsanStats &GetCurrentThreadStats();\n+// Flushes a given stats into accumulated stats of dead threads.\n+void FlushToDeadThreadStats(AsanStats *stats);\n+\n // A cross-platform equivalent of malloc_statistics_t on Mac OS.\n struct AsanMallocStats {\n   uptr blocks_in_use;\n@@ -62,6 +69,8 @@ struct AsanMallocStats {\n   uptr size_allocated;\n };\n \n+void FillMallocStatistics(AsanMallocStats *malloc_stats);\n+\n }  // namespace __asan\n \n #endif  // ASAN_STATS_H"}, {"sha": "1da714c60132b6a0ece04e37481282cdaf7e2807", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 207, "deletions": 38, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -11,88 +11,151 @@\n //===----------------------------------------------------------------------===//\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n+#include \"asan_poisoning.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n #include \"asan_mapping.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"lsan/lsan_common.h\"\n \n namespace __asan {\n \n-AsanThread::AsanThread(LinkerInitialized x)\n-    : fake_stack_(x),\n-      malloc_storage_(x),\n-      stats_(x) { }\n+// AsanThreadContext implementation.\n \n-AsanThread *AsanThread::Create(u32 parent_tid, thread_callback_t start_routine,\n-                               void *arg, StackTrace *stack) {\n+void AsanThreadContext::OnCreated(void *arg) {\n+  CreateThreadContextArgs *args = static_cast<CreateThreadContextArgs*>(arg);\n+  if (args->stack) {\n+    internal_memcpy(&stack, args->stack, sizeof(stack));\n+  }\n+  thread = args->thread;\n+  thread->set_context(this);\n+}\n+\n+void AsanThreadContext::OnFinished() {\n+  // Drop the link to the AsanThread object.\n+  thread = 0;\n+}\n+\n+// MIPS requires aligned address\n+static ALIGNED(16) char thread_registry_placeholder[sizeof(ThreadRegistry)];\n+static ThreadRegistry *asan_thread_registry;\n+\n+static ThreadContextBase *GetAsanThreadContext(u32 tid) {\n+  void *mem = MmapOrDie(sizeof(AsanThreadContext), \"AsanThreadContext\");\n+  return new(mem) AsanThreadContext(tid);\n+}\n+\n+ThreadRegistry &asanThreadRegistry() {\n+  static bool initialized;\n+  // Don't worry about thread_safety - this should be called when there is\n+  // a single thread.\n+  if (!initialized) {\n+    // Never reuse ASan threads: we store pointer to AsanThreadContext\n+    // in TSD and can't reliably tell when no more TSD destructors will\n+    // be called. It would be wrong to reuse AsanThreadContext for another\n+    // thread before all TSD destructors will be called for it.\n+    asan_thread_registry = new(thread_registry_placeholder) ThreadRegistry(\n+        GetAsanThreadContext, kMaxNumberOfThreads, kMaxNumberOfThreads);\n+    initialized = true;\n+  }\n+  return *asan_thread_registry;\n+}\n+\n+AsanThreadContext *GetThreadContextByTidLocked(u32 tid) {\n+  return static_cast<AsanThreadContext *>(\n+      asanThreadRegistry().GetThreadLocked(tid));\n+}\n+\n+// AsanThread implementation.\n+\n+AsanThread *AsanThread::Create(thread_callback_t start_routine,\n+                               void *arg) {\n   uptr PageSize = GetPageSizeCached();\n   uptr size = RoundUpTo(sizeof(AsanThread), PageSize);\n   AsanThread *thread = (AsanThread*)MmapOrDie(size, __FUNCTION__);\n   thread->start_routine_ = start_routine;\n   thread->arg_ = arg;\n-\n-  const uptr kSummaryAllocSize = PageSize;\n-  CHECK_LE(sizeof(AsanThreadSummary), kSummaryAllocSize);\n-  AsanThreadSummary *summary =\n-      (AsanThreadSummary*)MmapOrDie(PageSize, \"AsanThreadSummary\");\n-  summary->Init(parent_tid, stack);\n-  summary->set_thread(thread);\n-  thread->set_summary(summary);\n+  thread->context_ = 0;\n \n   return thread;\n }\n \n-void AsanThreadSummary::TSDDtor(void *tsd) {\n-  AsanThreadSummary *summary = (AsanThreadSummary*)tsd;\n-  if (flags()->verbosity >= 1) {\n-    Report(\"T%d TSDDtor\\n\", summary->tid());\n-  }\n-  if (summary->thread()) {\n-    summary->thread()->Destroy();\n-  }\n+void AsanThread::TSDDtor(void *tsd) {\n+  AsanThreadContext *context = (AsanThreadContext*)tsd;\n+  if (flags()->verbosity >= 1)\n+    Report(\"T%d TSDDtor\\n\", context->tid);\n+  if (context->thread)\n+    context->thread->Destroy();\n }\n \n void AsanThread::Destroy() {\n   if (flags()->verbosity >= 1) {\n     Report(\"T%d exited\\n\", tid());\n   }\n \n-  asanThreadRegistry().UnregisterThread(this);\n-  CHECK(summary()->thread() == 0);\n+  asanThreadRegistry().FinishThread(tid());\n+  FlushToDeadThreadStats(&stats_);\n   // We also clear the shadow on thread destruction because\n   // some code may still be executing in later TSD destructors\n   // and we don't want it to have any poisoned stack.\n-  ClearShadowForThreadStack();\n-  fake_stack().Cleanup();\n+  ClearShadowForThreadStackAndTLS();\n+  DeleteFakeStack();\n   uptr size = RoundUpTo(sizeof(AsanThread), GetPageSizeCached());\n   UnmapOrDie(this, size);\n }\n \n+// We want to create the FakeStack lazyly on the first use, but not eralier\n+// than the stack size is known and the procedure has to be async-signal safe.\n+FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n+  uptr stack_size = this->stack_size();\n+  if (stack_size == 0)  // stack_size is not yet available, don't use FakeStack.\n+    return 0;\n+  uptr old_val = 0;\n+  // fake_stack_ has 3 states:\n+  // 0   -- not initialized\n+  // 1   -- being initialized\n+  // ptr -- initialized\n+  // This CAS checks if the state was 0 and if so changes it to state 1,\n+  // if that was successfull, it initilizes the pointer.\n+  if (atomic_compare_exchange_strong(\n+      reinterpret_cast<atomic_uintptr_t *>(&fake_stack_), &old_val, 1UL,\n+      memory_order_relaxed)) {\n+    uptr stack_size_log = Log2(RoundUpToPowerOfTwo(stack_size));\n+    if (flags()->uar_stack_size_log)\n+      stack_size_log = static_cast<uptr>(flags()->uar_stack_size_log);\n+    fake_stack_ = FakeStack::Create(stack_size_log);\n+    SetTLSFakeStack(fake_stack_);\n+    return fake_stack_;\n+  }\n+  return 0;\n+}\n+\n void AsanThread::Init() {\n-  SetThreadStackTopAndBottom();\n+  SetThreadStackAndTls();\n   CHECK(AddrIsInMem(stack_bottom_));\n   CHECK(AddrIsInMem(stack_top_ - 1));\n-  ClearShadowForThreadStack();\n+  ClearShadowForThreadStackAndTLS();\n   if (flags()->verbosity >= 1) {\n     int local = 0;\n     Report(\"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\",\n            tid(), (void*)stack_bottom_, (void*)stack_top_,\n            stack_top_ - stack_bottom_, &local);\n   }\n-  fake_stack_.Init(stack_size());\n+  fake_stack_ = 0;  // Will be initialized lazily if needed.\n   AsanPlatformThreadInit();\n }\n \n-thread_return_t AsanThread::ThreadStart() {\n+thread_return_t AsanThread::ThreadStart(uptr os_id) {\n   Init();\n+  asanThreadRegistry().StartThread(tid(), os_id, 0);\n   if (flags()->use_sigaltstack) SetAlternateSignalStack();\n \n   if (!start_routine_) {\n     // start_routine_ == 0 if we're on the main thread or on one of the\n     // OS X libdispatch worker threads. But nobody is supposed to call\n     // ThreadStart() for the worker threads.\n-    CHECK(tid() == 0);\n+    CHECK_EQ(tid(), 0);\n     return 0;\n   }\n \n@@ -105,24 +168,33 @@ thread_return_t AsanThread::ThreadStart() {\n   return res;\n }\n \n-void AsanThread::SetThreadStackTopAndBottom() {\n-  GetThreadStackTopAndBottom(tid() == 0, &stack_top_, &stack_bottom_);\n+void AsanThread::SetThreadStackAndTls() {\n+  uptr tls_size = 0;\n+  GetThreadStackAndTls(tid() == 0, &stack_bottom_, &stack_size_, &tls_begin_,\n+                       &tls_size);\n+  stack_top_ = stack_bottom_ + stack_size_;\n+  tls_end_ = tls_begin_ + tls_size;\n+\n   int local;\n   CHECK(AddrIsInStack((uptr)&local));\n }\n \n-void AsanThread::ClearShadowForThreadStack() {\n+void AsanThread::ClearShadowForThreadStackAndTLS() {\n   PoisonShadow(stack_bottom_, stack_top_ - stack_bottom_, 0);\n+  if (tls_begin_ != tls_end_)\n+    PoisonShadow(tls_begin_, tls_end_ - tls_begin_, 0);\n }\n \n-const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset) {\n+const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset,\n+                                           uptr *frame_pc) {\n   uptr bottom = 0;\n   if (AddrIsInStack(addr)) {\n     bottom = stack_bottom();\n-  } else {\n-    bottom = fake_stack().AddrIsInFakeStack(addr);\n+  } else if (has_fake_stack()) {\n+    bottom = fake_stack()->AddrIsInFakeStack(addr);\n     CHECK(bottom);\n     *offset = addr - bottom;\n+    *frame_pc = ((uptr*)bottom)[2];\n     return  (const char *)((uptr*)bottom)[1];\n   }\n   uptr aligned_addr = addr & ~(SANITIZER_WORDSIZE/8 - 1);  // align addr.\n@@ -147,7 +219,104 @@ const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset) {\n   uptr* ptr = (uptr*)SHADOW_TO_MEM((uptr)(shadow_ptr + 1));\n   CHECK(ptr[0] == kCurrentStackFrameMagic);\n   *offset = addr - (uptr)ptr;\n+  *frame_pc = ptr[2];\n   return (const char*)ptr[1];\n }\n \n+static bool ThreadStackContainsAddress(ThreadContextBase *tctx_base,\n+                                       void *addr) {\n+  AsanThreadContext *tctx = static_cast<AsanThreadContext*>(tctx_base);\n+  AsanThread *t = tctx->thread;\n+  if (!t) return false;\n+  if (t->AddrIsInStack((uptr)addr)) return true;\n+  if (t->has_fake_stack() && t->fake_stack()->AddrIsInFakeStack((uptr)addr))\n+    return true;\n+  return false;\n+}\n+\n+AsanThread *GetCurrentThread() {\n+  AsanThreadContext *context =\n+      reinterpret_cast<AsanThreadContext *>(AsanTSDGet());\n+  if (!context) {\n+    if (SANITIZER_ANDROID) {\n+      // On Android, libc constructor is called _after_ asan_init, and cleans up\n+      // TSD. Try to figure out if this is still the main thread by the stack\n+      // address. We are not entirely sure that we have correct main thread\n+      // limits, so only do this magic on Android, and only if the found thread\n+      // is the main thread.\n+      AsanThreadContext *tctx = GetThreadContextByTidLocked(0);\n+      if (ThreadStackContainsAddress(tctx, &context)) {\n+        SetCurrentThread(tctx->thread);\n+        return tctx->thread;\n+      }\n+    }\n+    return 0;\n+  }\n+  return context->thread;\n+}\n+\n+void SetCurrentThread(AsanThread *t) {\n+  CHECK(t->context());\n+  if (flags()->verbosity >= 2) {\n+    Report(\"SetCurrentThread: %p for thread %p\\n\",\n+           t->context(), (void*)GetThreadSelf());\n+  }\n+  // Make sure we do not reset the current AsanThread.\n+  CHECK_EQ(0, AsanTSDGet());\n+  AsanTSDSet(t->context());\n+  CHECK_EQ(t->context(), AsanTSDGet());\n+}\n+\n+u32 GetCurrentTidOrInvalid() {\n+  AsanThread *t = GetCurrentThread();\n+  return t ? t->tid() : kInvalidTid;\n+}\n+\n+AsanThread *FindThreadByStackAddress(uptr addr) {\n+  asanThreadRegistry().CheckLocked();\n+  AsanThreadContext *tctx = static_cast<AsanThreadContext *>(\n+      asanThreadRegistry().FindThreadContextLocked(ThreadStackContainsAddress,\n+                                                   (void *)addr));\n+  return tctx ? tctx->thread : 0;\n+}\n+\n+void EnsureMainThreadIDIsCorrect() {\n+  AsanThreadContext *context =\n+      reinterpret_cast<AsanThreadContext *>(AsanTSDGet());\n+  if (context && (context->tid == 0))\n+    context->os_id = GetTid();\n+}\n }  // namespace __asan\n+\n+// --- Implementation of LSan-specific functions --- {{{1\n+namespace __lsan {\n+bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n+                           uptr *tls_begin, uptr *tls_end,\n+                           uptr *cache_begin, uptr *cache_end) {\n+  __asan::AsanThreadContext *context = static_cast<__asan::AsanThreadContext *>(\n+      __asan::asanThreadRegistry().FindThreadContextByOsIDLocked(os_id));\n+  if (!context) return false;\n+  __asan::AsanThread *t = context->thread;\n+  if (!t) return false;\n+  *stack_begin = t->stack_bottom();\n+  *stack_end = t->stack_top();\n+  *tls_begin = t->tls_begin();\n+  *tls_end = t->tls_end();\n+  // ASan doesn't keep allocator caches in TLS, so these are unused.\n+  *cache_begin = 0;\n+  *cache_end = 0;\n+  return true;\n+}\n+\n+void LockThreadRegistry() {\n+  __asan::asanThreadRegistry().Lock();\n+}\n+\n+void UnlockThreadRegistry() {\n+  __asan::asanThreadRegistry().Unlock();\n+}\n+\n+void EnsureMainThreadIDIsCorrect() {\n+  __asan::EnsureMainThreadIDIsCorrect();\n+}\n+}  // namespace __lsan"}, {"sha": "f21971ff4307befc33e6cdc7dceeb5b3279f63a5", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 96, "deletions": 47, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -14,99 +14,148 @@\n \n #include \"asan_allocator.h\"\n #include \"asan_internal.h\"\n+#include \"asan_fake_stack.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_thread_registry.h\"\n \n namespace __asan {\n \n const u32 kInvalidTid = 0xffffff;  // Must fit into 24 bits.\n+const u32 kMaxNumberOfThreads = (1 << 22);  // 4M\n \n class AsanThread;\n \n // These objects are created for every thread and are never deleted,\n // so we can find them by tid even if the thread is long dead.\n-class AsanThreadSummary {\n+class AsanThreadContext : public ThreadContextBase {\n  public:\n-  explicit AsanThreadSummary(LinkerInitialized) { }  // for T0.\n-  void Init(u32 parent_tid, StackTrace *stack) {\n-    parent_tid_ = parent_tid;\n-    announced_ = false;\n-    tid_ = kInvalidTid;\n-    if (stack) {\n-      internal_memcpy(&stack_, stack, sizeof(*stack));\n-    }\n-    thread_ = 0;\n-    name_[0] = 0;\n+  explicit AsanThreadContext(int tid)\n+      : ThreadContextBase(tid),\n+        announced(false),\n+        thread(0) {\n+    internal_memset(&stack, 0, sizeof(stack));\n   }\n-  u32 tid() { return tid_; }\n-  void set_tid(u32 tid) { tid_ = tid; }\n-  u32 parent_tid() { return parent_tid_; }\n-  bool announced() { return announced_; }\n-  void set_announced(bool announced) { announced_ = announced; }\n-  StackTrace *stack() { return &stack_; }\n-  AsanThread *thread() { return thread_; }\n-  void set_thread(AsanThread *thread) { thread_ = thread; }\n-  static void TSDDtor(void *tsd);\n-  void set_name(const char *name) {\n-    internal_strncpy(name_, name, sizeof(name_) - 1);\n-  }\n-  const char *name() { return name_; }\n+  bool announced;\n+  StackTrace stack;\n+  AsanThread *thread;\n \n- private:\n-  u32 tid_;\n-  u32 parent_tid_;\n-  bool announced_;\n-  StackTrace stack_;\n-  AsanThread *thread_;\n-  char name_[128];\n+  void OnCreated(void *arg);\n+  void OnFinished();\n };\n \n-// AsanThreadSummary objects are never freed, so we need many of them.\n-COMPILER_CHECK(sizeof(AsanThreadSummary) <= 4094);\n+// AsanThreadContext objects are never freed, so we need many of them.\n+COMPILER_CHECK(sizeof(AsanThreadContext) <= 4096);\n \n // AsanThread are stored in TSD and destroyed when the thread dies.\n class AsanThread {\n  public:\n-  explicit AsanThread(LinkerInitialized);  // for T0.\n-  static AsanThread *Create(u32 parent_tid, thread_callback_t start_routine,\n-                            void *arg, StackTrace *stack);\n+  static AsanThread *Create(thread_callback_t start_routine, void *arg);\n+  static void TSDDtor(void *tsd);\n   void Destroy();\n \n   void Init();  // Should be called from the thread itself.\n-  thread_return_t ThreadStart();\n+  thread_return_t ThreadStart(uptr os_id);\n \n   uptr stack_top() { return stack_top_; }\n   uptr stack_bottom() { return stack_bottom_; }\n-  uptr stack_size() { return stack_top_ - stack_bottom_; }\n-  u32 tid() { return summary_->tid(); }\n-  AsanThreadSummary *summary() { return summary_; }\n-  void set_summary(AsanThreadSummary *summary) { summary_ = summary; }\n+  uptr stack_size() { return stack_size_; }\n+  uptr tls_begin() { return tls_begin_; }\n+  uptr tls_end() { return tls_end_; }\n+  u32 tid() { return context_->tid; }\n+  AsanThreadContext *context() { return context_; }\n+  void set_context(AsanThreadContext *context) { context_ = context; }\n \n-  const char *GetFrameNameByAddr(uptr addr, uptr *offset);\n+  const char *GetFrameNameByAddr(uptr addr, uptr *offset, uptr *frame_pc);\n \n   bool AddrIsInStack(uptr addr) {\n     return addr >= stack_bottom_ && addr < stack_top_;\n   }\n \n-  FakeStack &fake_stack() { return fake_stack_; }\n+  void DeleteFakeStack() {\n+    if (!fake_stack_) return;\n+    FakeStack *t = fake_stack_;\n+    fake_stack_ = 0;\n+    SetTLSFakeStack(0);\n+    t->Destroy();\n+  }\n+\n+  bool has_fake_stack() {\n+    return (reinterpret_cast<uptr>(fake_stack_) > 1);\n+  }\n+\n+  FakeStack *fake_stack() {\n+    if (!__asan_option_detect_stack_use_after_return)\n+      return 0;\n+    if (!has_fake_stack())\n+      return AsyncSignalSafeLazyInitFakeStack();\n+    return fake_stack_;\n+  }\n+\n+  // True is this thread is currently unwinding stack (i.e. collecting a stack\n+  // trace). Used to prevent deadlocks on platforms where libc unwinder calls\n+  // malloc internally. See PR17116 for more details.\n+  bool isUnwinding() const { return unwinding; }\n+  void setUnwinding(bool b) { unwinding = b; }\n+\n   AsanThreadLocalMallocStorage &malloc_storage() { return malloc_storage_; }\n   AsanStats &stats() { return stats_; }\n \n  private:\n-  void SetThreadStackTopAndBottom();\n-  void ClearShadowForThreadStack();\n-  AsanThreadSummary *summary_;\n+  AsanThread() : unwinding(false) {}\n+  void SetThreadStackAndTls();\n+  void ClearShadowForThreadStackAndTLS();\n+  FakeStack *AsyncSignalSafeLazyInitFakeStack();\n+\n+  AsanThreadContext *context_;\n   thread_callback_t start_routine_;\n   void *arg_;\n   uptr  stack_top_;\n   uptr  stack_bottom_;\n+  // stack_size_ == stack_top_ - stack_bottom_;\n+  // It needs to be set in a async-signal-safe manner.\n+  uptr  stack_size_;\n+  uptr tls_begin_;\n+  uptr tls_end_;\n \n-  FakeStack fake_stack_;\n+  FakeStack *fake_stack_;\n   AsanThreadLocalMallocStorage malloc_storage_;\n   AsanStats stats_;\n+  bool unwinding;\n };\n \n+// ScopedUnwinding is a scope for stacktracing member of a context\n+class ScopedUnwinding {\n+ public:\n+  explicit ScopedUnwinding(AsanThread *t) : thread(t) {\n+    t->setUnwinding(true);\n+  }\n+  ~ScopedUnwinding() { thread->setUnwinding(false); }\n+\n+ private:\n+  AsanThread *thread;\n+};\n+\n+struct CreateThreadContextArgs {\n+  AsanThread *thread;\n+  StackTrace *stack;\n+};\n+\n+// Returns a single instance of registry.\n+ThreadRegistry &asanThreadRegistry();\n+\n+// Must be called under ThreadRegistryLock.\n+AsanThreadContext *GetThreadContextByTidLocked(u32 tid);\n+\n+// Get the current thread. May return 0.\n+AsanThread *GetCurrentThread();\n+void SetCurrentThread(AsanThread *t);\n+u32 GetCurrentTidOrInvalid();\n+AsanThread *FindThreadByStackAddress(uptr addr);\n+\n+// Used to handle fork().\n+void EnsureMainThreadIDIsCorrect();\n }  // namespace __asan\n \n #endif  // ASAN_THREAD_H"}, {"sha": "8fda9b6ea0a7b0ca41724ba72b4ec09c1062c000", "filename": "libsanitizer/asan/asan_thread_registry.cc", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.cc?ref=fd5564d3c71195714c28ba150de7e9b90bf9c83d", "patch": "@@ -1,196 +0,0 @@\n-//===-- asan_thread_registry.cc -------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// AsanThreadRegistry-related code. AsanThreadRegistry is a container\n-// for summaries of all created threads.\n-//===----------------------------------------------------------------------===//\n-\n-#include \"asan_stack.h\"\n-#include \"asan_thread.h\"\n-#include \"asan_thread_registry.h\"\n-#include \"sanitizer_common/sanitizer_common.h\"\n-\n-namespace __asan {\n-\n-static AsanThreadRegistry asan_thread_registry(LINKER_INITIALIZED);\n-\n-AsanThreadRegistry &asanThreadRegistry() {\n-  return asan_thread_registry;\n-}\n-\n-AsanThreadRegistry::AsanThreadRegistry(LinkerInitialized x)\n-    : main_thread_(x),\n-      main_thread_summary_(x),\n-      accumulated_stats_(x),\n-      max_malloced_memory_(x),\n-      mu_(x) { }\n-\n-void AsanThreadRegistry::Init() {\n-  AsanTSDInit(AsanThreadSummary::TSDDtor);\n-  main_thread_.set_summary(&main_thread_summary_);\n-  main_thread_summary_.set_thread(&main_thread_);\n-  RegisterThread(&main_thread_);\n-  SetCurrent(&main_thread_);\n-  // At this point only one thread exists.\n-  inited_ = true;\n-}\n-\n-void AsanThreadRegistry::RegisterThread(AsanThread *thread) {\n-  BlockingMutexLock lock(&mu_);\n-  u32 tid = n_threads_;\n-  n_threads_++;\n-  CHECK(n_threads_ < kMaxNumberOfThreads);\n-\n-  AsanThreadSummary *summary = thread->summary();\n-  CHECK(summary != 0);\n-  summary->set_tid(tid);\n-  thread_summaries_[tid] = summary;\n-}\n-\n-void AsanThreadRegistry::UnregisterThread(AsanThread *thread) {\n-  BlockingMutexLock lock(&mu_);\n-  FlushToAccumulatedStatsUnlocked(&thread->stats());\n-  AsanThreadSummary *summary = thread->summary();\n-  CHECK(summary);\n-  summary->set_thread(0);\n-}\n-\n-AsanThread *AsanThreadRegistry::GetMain() {\n-  return &main_thread_;\n-}\n-\n-AsanThread *AsanThreadRegistry::GetCurrent() {\n-  AsanThreadSummary *summary = (AsanThreadSummary *)AsanTSDGet();\n-  if (!summary) {\n-#if ASAN_ANDROID\n-    // On Android, libc constructor is called _after_ asan_init, and cleans up\n-    // TSD. Try to figure out if this is still the main thread by the stack\n-    // address. We are not entirely sure that we have correct main thread\n-    // limits, so only do this magic on Android, and only if the found thread is\n-    // the main thread.\n-    AsanThread* thread = FindThreadByStackAddress((uptr)&summary);\n-    if (thread && thread->tid() == 0) {\n-      SetCurrent(thread);\n-      return thread;\n-    }\n-#endif\n-    return 0;\n-  }\n-  return summary->thread();\n-}\n-\n-void AsanThreadRegistry::SetCurrent(AsanThread *t) {\n-  CHECK(t->summary());\n-  if (flags()->verbosity >= 2) {\n-    Report(\"SetCurrent: %p for thread %p\\n\",\n-           t->summary(), (void*)GetThreadSelf());\n-  }\n-  // Make sure we do not reset the current AsanThread.\n-  CHECK(AsanTSDGet() == 0);\n-  AsanTSDSet(t->summary());\n-  CHECK(AsanTSDGet() == t->summary());\n-}\n-\n-AsanStats &AsanThreadRegistry::GetCurrentThreadStats() {\n-  AsanThread *t = GetCurrent();\n-  return (t) ? t->stats() : main_thread_.stats();\n-}\n-\n-void AsanThreadRegistry::GetAccumulatedStats(AsanStats *stats) {\n-  BlockingMutexLock lock(&mu_);\n-  UpdateAccumulatedStatsUnlocked();\n-  internal_memcpy(stats, &accumulated_stats_, sizeof(accumulated_stats_));\n-}\n-\n-uptr AsanThreadRegistry::GetCurrentAllocatedBytes() {\n-  BlockingMutexLock lock(&mu_);\n-  UpdateAccumulatedStatsUnlocked();\n-  uptr malloced = accumulated_stats_.malloced;\n-  uptr freed = accumulated_stats_.freed;\n-  // Return sane value if malloced < freed due to racy\n-  // way we update accumulated stats.\n-  return (malloced > freed) ? malloced - freed : 1;\n-}\n-\n-uptr AsanThreadRegistry::GetHeapSize() {\n-  BlockingMutexLock lock(&mu_);\n-  UpdateAccumulatedStatsUnlocked();\n-  return accumulated_stats_.mmaped - accumulated_stats_.munmaped;\n-}\n-\n-uptr AsanThreadRegistry::GetFreeBytes() {\n-  BlockingMutexLock lock(&mu_);\n-  UpdateAccumulatedStatsUnlocked();\n-  uptr total_free = accumulated_stats_.mmaped\n-                  - accumulated_stats_.munmaped\n-                  + accumulated_stats_.really_freed\n-                  + accumulated_stats_.really_freed_redzones;\n-  uptr total_used = accumulated_stats_.malloced\n-                  + accumulated_stats_.malloced_redzones;\n-  // Return sane value if total_free < total_used due to racy\n-  // way we update accumulated stats.\n-  return (total_free > total_used) ? total_free - total_used : 1;\n-}\n-\n-// Return several stats counters with a single call to\n-// UpdateAccumulatedStatsUnlocked().\n-void AsanThreadRegistry::FillMallocStatistics(AsanMallocStats *malloc_stats) {\n-  BlockingMutexLock lock(&mu_);\n-  UpdateAccumulatedStatsUnlocked();\n-  malloc_stats->blocks_in_use = accumulated_stats_.mallocs;\n-  malloc_stats->size_in_use = accumulated_stats_.malloced;\n-  malloc_stats->max_size_in_use = max_malloced_memory_;\n-  malloc_stats->size_allocated = accumulated_stats_.mmaped;\n-}\n-\n-AsanThreadSummary *AsanThreadRegistry::FindByTid(u32 tid) {\n-  CHECK(tid < n_threads_);\n-  CHECK(thread_summaries_[tid]);\n-  return thread_summaries_[tid];\n-}\n-\n-AsanThread *AsanThreadRegistry::FindThreadByStackAddress(uptr addr) {\n-  BlockingMutexLock lock(&mu_);\n-  for (u32 tid = 0; tid < n_threads_; tid++) {\n-    AsanThread *t = thread_summaries_[tid]->thread();\n-    if (!t || !(t->fake_stack().StackSize())) continue;\n-    if (t->fake_stack().AddrIsInFakeStack(addr) || t->AddrIsInStack(addr)) {\n-      return t;\n-    }\n-  }\n-  return 0;\n-}\n-\n-void AsanThreadRegistry::UpdateAccumulatedStatsUnlocked() {\n-  for (u32 tid = 0; tid < n_threads_; tid++) {\n-    AsanThread *t = thread_summaries_[tid]->thread();\n-    if (t != 0) {\n-      FlushToAccumulatedStatsUnlocked(&t->stats());\n-    }\n-  }\n-  // This is not very accurate: we may miss allocation peaks that happen\n-  // between two updates of accumulated_stats_. For more accurate bookkeeping\n-  // the maximum should be updated on every malloc(), which is unacceptable.\n-  if (max_malloced_memory_ < accumulated_stats_.malloced) {\n-    max_malloced_memory_ = accumulated_stats_.malloced;\n-  }\n-}\n-\n-void AsanThreadRegistry::FlushToAccumulatedStatsUnlocked(AsanStats *stats) {\n-  // AsanStats consists of variables of type uptr only.\n-  uptr *dst = (uptr*)&accumulated_stats_;\n-  uptr *src = (uptr*)stats;\n-  uptr num_fields = sizeof(AsanStats) / sizeof(uptr);\n-  for (uptr i = 0; i < num_fields; i++) {\n-    dst[i] += src[i];\n-    src[i] = 0;\n-  }\n-}\n-\n-}  // namespace __asan"}, {"sha": "8c3d0c886e0aff424961cc84f520c8a24a594938", "filename": "libsanitizer/asan/asan_thread_registry.h", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fasan%2Fasan_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fasan%2Fasan_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.h?ref=fd5564d3c71195714c28ba150de7e9b90bf9c83d", "patch": "@@ -1,83 +0,0 @@\n-//===-- asan_thread_registry.h ----------------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// ASan-private header for asan_thread_registry.cc\n-//===----------------------------------------------------------------------===//\n-\n-#ifndef ASAN_THREAD_REGISTRY_H\n-#define ASAN_THREAD_REGISTRY_H\n-\n-#include \"asan_stack.h\"\n-#include \"asan_stats.h\"\n-#include \"asan_thread.h\"\n-#include \"sanitizer_common/sanitizer_mutex.h\"\n-\n-namespace __asan {\n-\n-// Stores summaries of all created threads, returns current thread,\n-// thread by tid, thread by stack address. There is a single instance\n-// of AsanThreadRegistry for the whole program.\n-// AsanThreadRegistry is thread-safe.\n-class AsanThreadRegistry {\n- public:\n-  explicit AsanThreadRegistry(LinkerInitialized);\n-  void Init();\n-  void RegisterThread(AsanThread *thread);\n-  void UnregisterThread(AsanThread *thread);\n-\n-  AsanThread *GetMain();\n-  // Get the current thread. May return 0.\n-  AsanThread *GetCurrent();\n-  void SetCurrent(AsanThread *t);\n-\n-  u32 GetCurrentTidOrInvalid() {\n-    if (!inited_) return 0;\n-    AsanThread *t = GetCurrent();\n-    return t ? t->tid() : kInvalidTid;\n-  }\n-\n-  // Returns stats for GetCurrent(), or stats for\n-  // T0 if GetCurrent() returns 0.\n-  AsanStats &GetCurrentThreadStats();\n-  // Flushes all thread-local stats to accumulated stats, and makes\n-  // a copy of accumulated stats.\n-  void GetAccumulatedStats(AsanStats *stats);\n-  uptr GetCurrentAllocatedBytes();\n-  uptr GetHeapSize();\n-  uptr GetFreeBytes();\n-  void FillMallocStatistics(AsanMallocStats *malloc_stats);\n-\n-  AsanThreadSummary *FindByTid(u32 tid);\n-  AsanThread *FindThreadByStackAddress(uptr addr);\n-\n- private:\n-  void UpdateAccumulatedStatsUnlocked();\n-  // Adds values of all counters in \"stats\" to accumulated stats,\n-  // and fills \"stats\" with zeroes.\n-  void FlushToAccumulatedStatsUnlocked(AsanStats *stats);\n-\n-  static const u32 kMaxNumberOfThreads = (1 << 22);  // 4M\n-  AsanThreadSummary *thread_summaries_[kMaxNumberOfThreads];\n-  AsanThread main_thread_;\n-  AsanThreadSummary main_thread_summary_;\n-  AsanStats accumulated_stats_;\n-  // Required for malloc_zone_statistics() on OS X. This can't be stored in\n-  // per-thread AsanStats.\n-  uptr max_malloced_memory_;\n-  u32 n_threads_;\n-  BlockingMutex mu_;\n-  bool inited_;\n-};\n-\n-// Returns a single instance of registry.\n-AsanThreadRegistry &asanThreadRegistry();\n-\n-}  // namespace __asan\n-\n-#endif  // ASAN_THREAD_REGISTRY_H"}, {"sha": "ed785b69281cb8a7338fdae0f6cf21fd72803bda", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -9,7 +9,9 @@\n //\n // Windows-specific details.\n //===----------------------------------------------------------------------===//\n-#ifdef _WIN32\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_WINDOWS\n #include <windows.h>\n \n #include <dbghelp.h>\n@@ -21,37 +23,21 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n \n+extern \"C\" {\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  int __asan_should_detect_stack_use_after_return() {\n+    __asan_init();\n+    return __asan_option_detect_stack_use_after_return;\n+  }\n+}\n+\n namespace __asan {\n \n // ---------------------- Stacktraces, symbols, etc. ---------------- {{{1\n static BlockingMutex dbghelp_lock(LINKER_INITIALIZED);\n static bool dbghelp_initialized = false;\n #pragma comment(lib, \"dbghelp.lib\")\n \n-void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n-  (void)fast;\n-  stack->max_size = max_s;\n-  void *tmp[kStackTraceMax];\n-\n-  // FIXME: CaptureStackBackTrace might be too slow for us.\n-  // FIXME: Compare with StackWalk64.\n-  // FIXME: Look at LLVMUnhandledExceptionFilter in Signals.inc\n-  uptr cs_ret = CaptureStackBackTrace(1, stack->max_size, tmp, 0);\n-  uptr offset = 0;\n-  // Skip the RTL frames by searching for the PC in the stacktrace.\n-  // FIXME: this doesn't work well for the malloc/free stacks yet.\n-  for (uptr i = 0; i < cs_ret; i++) {\n-    if (pc != (uptr)tmp[i])\n-      continue;\n-    offset = i;\n-    break;\n-  }\n-\n-  stack->size = cs_ret - offset;\n-  for (uptr i = 0; i < stack->size; i++)\n-    stack->trace[i] = (uptr)tmp[i + offset];\n-}\n-\n // ---------------------- TSD ---------------- {{{1\n static bool tsd_key_inited = false;\n "}, {"sha": "9a16cf5784486506302954f6050ea5159eae9a2e", "filename": "libsanitizer/asan/libtool-version", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fasan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Flibtool-version?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -1,6 +1,6 @@\n-# This file is used to maintain libtool version info for libmudflap.  See\n+# This file is used to maintain libtool version info for libasan.  See\n # the libtool manual to understand the meaning of the fields.  This is\n # a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-0:0:0\n+1:0:0"}, {"sha": "5e425d1d9e3b06e1abfa0f9c1cb3e9d69b53f725", "filename": "libsanitizer/configure", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -14549,7 +14549,7 @@ fi\n ac_config_files=\"$ac_config_files Makefile\"\n \n \n-ac_config_files=\"$ac_config_files interception/Makefile sanitizer_common/Makefile asan/Makefile ubsan/Makefile\"\n+ac_config_files=\"$ac_config_files interception/Makefile sanitizer_common/Makefile lsan/Makefile asan/Makefile ubsan/Makefile\"\n \n \n if test \"x$TSAN_SUPPORTED\" = \"xyes\"; then\n@@ -15679,6 +15679,7 @@ do\n     \"Makefile\") CONFIG_FILES=\"$CONFIG_FILES Makefile\" ;;\n     \"interception/Makefile\") CONFIG_FILES=\"$CONFIG_FILES interception/Makefile\" ;;\n     \"sanitizer_common/Makefile\") CONFIG_FILES=\"$CONFIG_FILES sanitizer_common/Makefile\" ;;\n+    \"lsan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES lsan/Makefile\" ;;\n     \"asan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES asan/Makefile\" ;;\n     \"ubsan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES ubsan/Makefile\" ;;\n     \"tsan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES tsan/Makefile\" ;;\n@@ -17026,6 +17027,17 @@ _EOF\n  ;;\n     \"sanitizer_common/Makefile\":F) cat > vpsed$$ << \\_EOF\n s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+   sed -f vpsed$$ $ac_file > tmp$$\n+   mv tmp$$ $ac_file\n+   rm vpsed$$\n+   echo 'MULTISUBDIR =' >> $ac_file\n+   ml_norecursion=yes\n+   . ${multi_basedir}/config-ml.in\n+   { ml_norecursion=; unset ml_norecursion;}\n+ ;;\n+    \"lsan/Makefile\":F) cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n _EOF\n    sed -f vpsed$$ $ac_file > tmp$$\n    mv tmp$$ $ac_file"}, {"sha": "0b2d8132fb655c2ec3db2c20e91a0a170869ffba", "filename": "libsanitizer/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -89,7 +89,7 @@ AM_CONDITIONAL(USING_MAC_INTERPOSE, $MAC_INTERPOSE)\n \n AC_CONFIG_FILES([Makefile])\n \n-AC_CONFIG_FILES(AC_FOREACH([DIR], [interception sanitizer_common asan ubsan], [DIR/Makefile ]),\n+AC_CONFIG_FILES(AC_FOREACH([DIR], [interception sanitizer_common lsan asan ubsan], [DIR/Makefile ]),\n   [cat > vpsed$$ << \\_EOF\n s!`test -f '$<' || echo '$(srcdir)/'`!!\n _EOF"}, {"sha": "a7db2ff1c123b11a2dd9ac2a5af7152c79fec17d", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -39,6 +39,16 @@ extern \"C\" {\n   // the error message. This function can be overridden by the client.\n   void __sanitizer_report_error_summary(const char *error_summary);\n \n+  // Some of the sanitizers (e.g. asan/tsan) may miss bugs that happen\n+  // in unaligned loads/stores. In order to find such bugs reliably one needs\n+  // to replace plain unaligned loads/stores with these calls.\n+  uint16_t __sanitizer_unaligned_load16(const void *p);\n+  uint32_t __sanitizer_unaligned_load32(const void *p);\n+  uint64_t __sanitizer_unaligned_load64(const void *p);\n+  void __sanitizer_unaligned_store16(void *p, uint16_t x);\n+  void __sanitizer_unaligned_store32(void *p, uint32_t x);\n+  void __sanitizer_unaligned_store64(void *p, uint64_t x);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "dd938483d1847b34dbd5a5a4ada0b2b85001dff5", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,85 @@\n+//===-- dfsan_interface.h -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of DataFlowSanitizer.\n+//\n+// Public interface header.\n+//===----------------------------------------------------------------------===//\n+#ifndef DFSAN_INTERFACE_H\n+#define DFSAN_INTERFACE_H\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <sanitizer/common_interface_defs.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef uint16_t dfsan_label;\n+\n+/// Stores information associated with a specific label identifier.  A label\n+/// may be a base label created using dfsan_create_label, with associated\n+/// text description and user data, or an automatically created union label,\n+/// which represents the union of two label identifiers (which may themselves\n+/// be base or union labels).\n+struct dfsan_label_info {\n+  // Fields for union labels, set to 0 for base labels.\n+  dfsan_label l1;\n+  dfsan_label l2;\n+\n+  // Fields for base labels.\n+  const char *desc;\n+  void *userdata;\n+};\n+\n+/// Computes the union of \\c l1 and \\c l2, possibly creating a union label in\n+/// the process.\n+dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);\n+\n+/// Creates and returns a base label with the given description and user data.\n+dfsan_label dfsan_create_label(const char *desc, void *userdata);\n+\n+/// Sets the label for each address in [addr,addr+size) to \\c label.\n+void dfsan_set_label(dfsan_label label, void *addr, size_t size);\n+\n+/// Sets the label for each address in [addr,addr+size) to the union of the\n+/// current label for that address and \\c label.\n+void dfsan_add_label(dfsan_label label, void *addr, size_t size);\n+\n+/// Retrieves the label associated with the given data.\n+///\n+/// The type of 'data' is arbitrary.  The function accepts a value of any type,\n+/// which can be truncated or extended (implicitly or explicitly) as necessary.\n+/// The truncation/extension operations will preserve the label of the original\n+/// value.\n+dfsan_label dfsan_get_label(long data);\n+\n+/// Retrieves the label associated with the data at the given address.\n+dfsan_label dfsan_read_label(const void *addr, size_t size);\n+\n+/// Retrieves a pointer to the dfsan_label_info struct for the given label.\n+const struct dfsan_label_info *dfsan_get_label_info(dfsan_label label);\n+\n+/// Returns whether the given label label contains the label elem.\n+int dfsan_has_label(dfsan_label label, dfsan_label elem);\n+\n+/// If the given label label contains a label with the description desc, returns\n+/// that label, else returns 0.\n+dfsan_label dfsan_has_label_with_desc(dfsan_label label, const char *desc);\n+\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+\n+template <typename T>\n+void dfsan_set_label(dfsan_label label, T &data) {  // NOLINT\n+  dfsan_set_label(label, (void *)&data, sizeof(T));\n+}\n+\n+#endif\n+\n+#endif  // DFSAN_INTERFACE_H"}, {"sha": "6cd7d7626b86dc323df8c8a844206f67174ff29e", "filename": "libsanitizer/include/sanitizer/linux_syscall_hooks.h", "status": "added", "additions": 3067, "deletions": 0, "changes": 3067, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "ec9c730eee304840eb1704e84bdec1ce74a5936b", "filename": "libsanitizer/include/sanitizer/lsan_interface.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,50 @@\n+//===-- sanitizer/lsan_interface.h ------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+//\n+// Public interface header.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_LSAN_INTERFACE_H\n+#define SANITIZER_LSAN_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+  // Allocations made between calls to __lsan_disable() and __lsan_enable() will\n+  // be treated as non-leaks. Disable/enable pairs may be nested.\n+  void __lsan_disable();\n+  void __lsan_enable();\n+  // The heap object into which p points will be treated as a non-leak.\n+  void __lsan_ignore_object(const void *p);\n+  // The user may optionally provide this function to disallow leak checking\n+  // for the program it is linked into (if the return value is non-zero). This\n+  // function must be defined as returning a constant value; any behavior beyond\n+  // that is unsupported.\n+  int __lsan_is_turned_off();\n+  // Calling this function makes LSan enter the leak checking phase immediately.\n+  // Use this if normal end-of-process leak checking happens too late (e.g. if\n+  // you have intentional memory leaks in your shutdown code). Calling this\n+  // function overrides end-of-process leak checking; it must be called at\n+  // most once per process. This function will terminate the process if there\n+  // are memory leaks and the exit_code flag is non-zero.\n+  void __lsan_do_leak_check();\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+\n+namespace __lsan {\n+class ScopedDisabler {\n+ public:\n+  ScopedDisabler() { __lsan_disable(); }\n+  ~ScopedDisabler() { __lsan_enable(); }\n+};\n+}  // namespace __lsan\n+#endif\n+\n+#endif  // SANITIZER_LSAN_INTERFACE_H"}, {"sha": "f531cf347c9b1a18c34be3a95528baded7e51337", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,160 @@\n+//===-- msan_interface.h --------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of MemorySanitizer.\n+//\n+// Public interface header.\n+//===----------------------------------------------------------------------===//\n+#ifndef MSAN_INTERFACE_H\n+#define MSAN_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#if __has_feature(memory_sanitizer)\n+  /* Returns a string describing a stack origin.\n+     Return NULL if the origin is invalid, or is not a stack origin. */\n+  const char *__msan_get_origin_descr_if_stack(uint32_t id);\n+\n+\n+  /* Set raw origin for the memory range. */\n+  void __msan_set_origin(const volatile void *a, size_t size, uint32_t origin);\n+\n+  /* Get raw origin for an address. */\n+  uint32_t __msan_get_origin(const volatile void *a);\n+\n+  /* Returns non-zero if tracking origins. */\n+  int __msan_get_track_origins();\n+\n+  /* Returns the origin id of the latest UMR in the calling thread. */\n+  uint32_t __msan_get_umr_origin();\n+\n+  /* Make memory region fully initialized (without changing its contents). */\n+  void __msan_unpoison(const volatile void *a, size_t size);\n+\n+  /* Make memory region fully uninitialized (without changing its contents). */\n+  void __msan_poison(const volatile void *a, size_t size);\n+\n+  /* Make memory region partially uninitialized (without changing its contents).\n+   */\n+  void __msan_partial_poison(const volatile void *data, void *shadow,\n+                             size_t size);\n+\n+  /* Returns the offset of the first (at least partially) poisoned byte in the\n+     memory range, or -1 if the whole range is good. */\n+  intptr_t __msan_test_shadow(const volatile void *x, size_t size);\n+\n+  /* Set exit code when error(s) were detected.\n+     Value of 0 means don't change the program exit code. */\n+  void __msan_set_exit_code(int exit_code);\n+\n+  /* For testing:\n+     __msan_set_expect_umr(1);\n+     ... some buggy code ...\n+     __msan_set_expect_umr(0);\n+     The last line will verify that a UMR happened. */\n+  void __msan_set_expect_umr(int expect_umr);\n+\n+  /* Change the value of keep_going flag. Non-zero value means don't terminate\n+     program execution when an error is detected. This will not affect error in\n+     modules that were compiled without the corresponding compiler flag. */\n+  void __msan_set_keep_going(int keep_going);\n+\n+  /* Print shadow and origin for the memory range to stdout in a human-readable\n+     format. */\n+  void __msan_print_shadow(const volatile void *x, size_t size);\n+\n+  /* Print current function arguments shadow and origin to stdout in a\n+     human-readable format. */\n+  void __msan_print_param_shadow();\n+\n+  /* Returns true if running under a dynamic tool (DynamoRio-based). */\n+  int  __msan_has_dynamic_component();\n+\n+  /* Tell MSan about newly allocated memory (ex.: custom allocator).\n+     Memory will be marked uninitialized, with origin at the call site. */\n+  void __msan_allocated_memory(const volatile void* data, size_t size);\n+\n+  /* This function may be optionally provided by user and should return\n+     a string containing Msan runtime options. See msan_flags.h for details. */\n+  const char* __msan_default_options();\n+\n+\n+  /***********************************/\n+  /* Allocator statistics interface. */\n+\n+  /* Returns the estimated number of bytes that will be reserved by allocator\n+     for request of \"size\" bytes. If Msan allocator can't allocate that much\n+     memory, returns the maximal possible allocation size, otherwise returns\n+     \"size\". */\n+  size_t __msan_get_estimated_allocated_size(size_t size);\n+\n+  /* Returns true if p was returned by the Msan allocator and\n+     is not yet freed. */\n+  int __msan_get_ownership(const volatile void *p);\n+\n+  /* Returns the number of bytes reserved for the pointer p.\n+     Requires (get_ownership(p) == true) or (p == 0). */\n+  size_t __msan_get_allocated_size(const volatile void *p);\n+\n+  /* Number of bytes, allocated and not yet freed by the application. */\n+  size_t __msan_get_current_allocated_bytes();\n+\n+  /* Number of bytes, mmaped by msan allocator to fulfill allocation requests.\n+     Generally, for request of X bytes, allocator can reserve and add to free\n+     lists a large number of chunks of size X to use them for future requests.\n+     All these chunks count toward the heap size. Currently, allocator never\n+     releases memory to OS (instead, it just puts freed chunks to free\n+     lists). */\n+  size_t __msan_get_heap_size();\n+\n+  /* Number of bytes, mmaped by msan allocator, which can be used to fulfill\n+     allocation requests. When a user program frees memory chunk, it can first\n+     fall into quarantine and will count toward __msan_get_free_bytes()\n+     later. */\n+  size_t __msan_get_free_bytes();\n+\n+  /* Number of bytes in unmapped pages, that are released to OS. Currently,\n+     always returns 0. */\n+  size_t __msan_get_unmapped_bytes();\n+\n+  /* Malloc hooks that may be optionally provided by user.\n+     __msan_malloc_hook(ptr, size) is called immediately after\n+       allocation of \"size\" bytes, which returned \"ptr\".\n+     __msan_free_hook(ptr) is called immediately before\n+       deallocation of \"ptr\". */\n+  void __msan_malloc_hook(const volatile void *ptr, size_t size);\n+  void __msan_free_hook(const volatile void *ptr);\n+\n+#else  // __has_feature(memory_sanitizer)\n+\n+#define __msan_get_origin_descr_if_stack(id) ((const char*)0)\n+#define __msan_set_origin(a, size, origin)\n+#define __msan_get_origin(a) ((uint32_t)-1)\n+#define __msan_get_track_origins() (0)\n+#define __msan_get_umr_origin() ((uint32_t)-1)\n+#define __msan_unpoison(a, size)\n+#define __msan_poison(a, size)\n+#define __msan_partial_poison(data, shadow, size)\n+#define __msan_test_shadow(x, size) ((intptr_t)-1)\n+#define __msan_set_exit_code(exit_code)\n+#define __msan_set_expect_umr(expect_umr)\n+#define __msan_print_shadow(x, size)\n+#define __msan_print_param_shadow()\n+#define __msan_has_dynamic_component() (0)\n+#define __msan_allocated_memory(data, size)\n+\n+#endif   // __has_feature(memory_sanitizer)\n+\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif"}, {"sha": "71740c5c40375e632e3aae73a1184b6fb40b085a", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -21,27 +21,20 @@\n \n // These typedefs should be used only in the interceptor definitions to replace\n // the standard system types (e.g. SSIZE_T instead of ssize_t)\n-typedef __sanitizer::uptr SIZE_T;\n-typedef __sanitizer::sptr SSIZE_T;\n-typedef __sanitizer::sptr PTRDIFF_T;\n-typedef __sanitizer::s64  INTMAX_T;\n-// WARNING: OFF_T may be different from OS type off_t, depending on the value of\n-// _FILE_OFFSET_BITS. This definition of OFF_T matches the ABI of system calls\n-// like pread and mmap, as opposed to pread64 and mmap64.\n-// Mac and Linux/x86-64 are special.\n-#if defined(__APPLE__) || (defined(__linux__) && defined(__x86_64__))\n-typedef __sanitizer::u64 OFF_T;\n-#else\n-typedef __sanitizer::uptr OFF_T;\n-#endif\n-typedef __sanitizer::u64  OFF64_T;\n+typedef __sanitizer::uptr    SIZE_T;\n+typedef __sanitizer::sptr    SSIZE_T;\n+typedef __sanitizer::sptr    PTRDIFF_T;\n+typedef __sanitizer::s64     INTMAX_T;\n+typedef __sanitizer::OFF_T   OFF_T;\n+typedef __sanitizer::OFF64_T OFF64_T;\n \n // How to add an interceptor:\n // Suppose you need to wrap/replace system function (generally, from libc):\n //      int foo(const char *bar, double baz);\n // You'll need to:\n //      1) define INTERCEPTOR(int, foo, const char *bar, double baz) { ... } in\n-//         your source file.\n+//         your source file. See the notes below for cases when\n+//         INTERCEPTOR_WITH_SUFFIX(...) should be used instead.\n //      2) Call \"INTERCEPT_FUNCTION(foo)\" prior to the first call of \"foo\".\n //         INTERCEPT_FUNCTION(foo) evaluates to \"true\" iff the function was\n //         intercepted successfully.\n@@ -55,15 +48,20 @@ typedef __sanitizer::u64  OFF64_T;\n //      3b) add DECLARE_REAL_AND_INTERCEPTOR(int, foo, const char*, double)\n //          to a header file.\n \n-// Notes: 1. Things may not work properly if macro INTERCEPT(...) {...} or\n+// Notes: 1. Things may not work properly if macro INTERCEPTOR(...) {...} or\n //           DECLARE_REAL(...) are located inside namespaces.\n-//        2. On Mac you can also use: \"OVERRIDE_FUNCTION(foo, zoo);\" to\n+//        2. On Mac you can also use: \"OVERRIDE_FUNCTION(foo, zoo)\" to\n //           effectively redirect calls from \"foo\" to \"zoo\". In this case\n //           you aren't required to implement\n //           INTERCEPTOR(int, foo, const char *bar, double baz) {...}\n //           but instead you'll have to add\n-//           DEFINE_REAL(int, foo, const char *bar, double baz) in your\n+//           DECLARE_REAL(int, foo, const char *bar, double baz) in your\n //           source file (to define a pointer to overriden function).\n+//        3. Some Mac functions have symbol variants discriminated by\n+//           additional suffixes, e.g. _$UNIX2003 (see\n+//           https://developer.apple.com/library/mac/#releasenotes/Darwin/SymbolVariantsRelNotes/index.html\n+//           for more details). To intercept such functions you need to use the\n+//           INTERCEPTOR_WITH_SUFFIX(...) macro.\n \n // How it works:\n // To replace system functions on Linux we just need to declare functions\n@@ -73,6 +71,7 @@ typedef __sanitizer::u64  OFF64_T;\n // we intercept. To resolve this we declare our interceptors with __interceptor_\n // prefix, and then make actual interceptors weak aliases to __interceptor_\n // functions.\n+//\n // This is not so on Mac OS, where the two-level namespace makes\n // our replacement functions invisible to other libraries. This may be overcomed\n // using the DYLD_FORCE_FLAT_NAMESPACE, but some errors loading the shared\n@@ -82,12 +81,43 @@ typedef __sanitizer::u64  OFF64_T;\n // preloaded before an executable using DYLD_INSERT_LIBRARIES, it routes all\n // the calls to interposed functions done through stubs to the wrapper\n // functions.\n+// As it's decided at compile time which functions are to be intercepted on Mac,\n+// INTERCEPT_FUNCTION() is effectively a no-op on this system.\n \n #if defined(__APPLE__)\n+#include <sys/cdefs.h>  // For __DARWIN_ALIAS_C().\n+\n+// Just a pair of pointers.\n+struct interpose_substitution {\n+  const uptr replacement;\n+  const uptr original;\n+};\n+\n+// For a function foo() create a global pair of pointers { wrap_foo, foo } in\n+// the __DATA,__interpose section.\n+// As a result all the calls to foo() will be routed to wrap_foo() at runtime.\n+#define INTERPOSER(func_name) __attribute__((used)) \\\n+const interpose_substitution substitution_##func_name[] \\\n+    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n+    { reinterpret_cast<const uptr>(WRAP(func_name)), \\\n+      reinterpret_cast<const uptr>(func_name) } \\\n+}\n+\n+// For a function foo() and a wrapper function bar() create a global pair\n+// of pointers { bar, foo } in the __DATA,__interpose section.\n+// As a result all the calls to foo() will be routed to bar() at runtime.\n+#define INTERPOSER_2(func_name, wrapper_name) __attribute__((used)) \\\n+const interpose_substitution substitution_##func_name[] \\\n+    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n+    { reinterpret_cast<const uptr>(wrapper_name), \\\n+      reinterpret_cast<const uptr>(func_name) } \\\n+}\n+\n # define WRAP(x) wrap_##x\n # define WRAPPER_NAME(x) \"wrap_\"#x\n # define INTERCEPTOR_ATTRIBUTE\n # define DECLARE_WRAPPER(ret_type, func, ...)\n+\n #elif defined(_WIN32)\n # if defined(_DLL)  // DLL CRT\n #  define WRAP(x) x\n@@ -98,7 +128,10 @@ typedef __sanitizer::u64  OFF64_T;\n #  define WRAPPER_NAME(x) \"wrap_\"#x\n #  define INTERCEPTOR_ATTRIBUTE\n # endif\n-# define DECLARE_WRAPPER(ret_type, func, ...)\n+# define DECLARE_WRAPPER(ret_type, func, ...) \\\n+    extern \"C\" ret_type func(__VA_ARGS__);\n+# define DECLARE_WRAPPER_WINAPI(ret_type, func, ...) \\\n+    extern \"C\" __declspec(dllimport) ret_type __stdcall func(__VA_ARGS__);\n #else\n # define WRAP(x) __interceptor_ ## x\n # define WRAPPER_NAME(x) \"__interceptor_\" #x\n@@ -142,20 +175,44 @@ typedef __sanitizer::u64  OFF64_T;\n # define DEFINE_REAL(ret_type, func, ...)\n #endif\n \n+#if !defined(__APPLE__)\n #define INTERCEPTOR(ret_type, func, ...) \\\n   DEFINE_REAL(ret_type, func, __VA_ARGS__) \\\n   DECLARE_WRAPPER(ret_type, func, __VA_ARGS__) \\\n   extern \"C\" \\\n   INTERCEPTOR_ATTRIBUTE \\\n   ret_type WRAP(func)(__VA_ARGS__)\n \n+// We don't need INTERCEPTOR_WITH_SUFFIX on non-Darwin for now.\n+#define INTERCEPTOR_WITH_SUFFIX(ret_type, func, ...) \\\n+  INTERCEPTOR(ret_type, func, __VA_ARGS__)\n+\n+#else  // __APPLE__\n+\n+#define INTERCEPTOR_ZZZ(suffix, ret_type, func, ...) \\\n+  extern \"C\" ret_type func(__VA_ARGS__) suffix; \\\n+  extern \"C\" ret_type WRAP(func)(__VA_ARGS__); \\\n+  INTERPOSER(func); \\\n+  extern \"C\" INTERCEPTOR_ATTRIBUTE ret_type WRAP(func)(__VA_ARGS__)\n+\n+#define INTERCEPTOR(ret_type, func, ...) \\\n+  INTERCEPTOR_ZZZ(/*no symbol variants*/, ret_type, func, __VA_ARGS__)\n+\n+#define INTERCEPTOR_WITH_SUFFIX(ret_type, func, ...) \\\n+  INTERCEPTOR_ZZZ(__DARWIN_ALIAS_C(func), ret_type, func, __VA_ARGS__)\n+\n+// Override |overridee| with |overrider|.\n+#define OVERRIDE_FUNCTION(overridee, overrider) \\\n+  INTERPOSER_2(overridee, WRAP(overrider))\n+#endif\n+\n #if defined(_WIN32)\n # define INTERCEPTOR_WINAPI(ret_type, func, ...) \\\n     typedef ret_type (__stdcall *FUNC_TYPE(func))(__VA_ARGS__); \\\n     namespace __interception { \\\n       FUNC_TYPE(func) PTR_TO_REAL(func); \\\n     } \\\n-    DECLARE_WRAPPER(ret_type, func, __VA_ARGS__) \\\n+    DECLARE_WRAPPER_WINAPI(ret_type, func, __VA_ARGS__) \\\n     extern \"C\" \\\n     INTERCEPTOR_ATTRIBUTE \\\n     ret_type __stdcall WRAP(func)(__VA_ARGS__)\n@@ -181,8 +238,6 @@ typedef unsigned long uptr;  // NOLINT\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX(func)\n #elif defined(__APPLE__)\n # include \"interception_mac.h\"\n-# define OVERRIDE_FUNCTION(old_func, new_func) \\\n-    OVERRIDE_FUNCTION_MAC(old_func, new_func)\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)\n #else  // defined(_WIN32)\n # include \"interception_win.h\""}, {"sha": "0a8df474ab49752bbd616cddab43c04598f96b31", "filename": "libsanitizer/interception/interception_linux.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finterception%2Finterception_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finterception%2Finterception_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -13,7 +13,6 @@\n #ifdef __linux__\n #include \"interception.h\"\n \n-#include <stddef.h>  // for NULL\n #include <dlfcn.h>   // for dlsym\n \n namespace __interception {\n@@ -22,6 +21,13 @@ bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n   *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);\n   return real == wrapper;\n }\n+\n+#if !defined(__ANDROID__)  // android does not have dlvsym\n+void *GetFuncAddrVer(const char *func_name, const char *ver) {\n+  return dlvsym(RTLD_NEXT, func_name, ver);\n+}\n+#endif  // !defined(__ANDROID__)\n+\n }  // namespace __interception\n \n "}, {"sha": "fbbfecbe0373930cdf3dab78495786ed63075b1b", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -23,6 +23,7 @@ namespace __interception {\n // returns true if a function with the given name was found.\n bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n     uptr real, uptr wrapper);\n+void *GetFuncAddrVer(const char *func_name, const char *ver);\n }  // namespace __interception\n \n #define INTERCEPT_FUNCTION_LINUX(func) \\\n@@ -31,5 +32,11 @@ bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n           (::__interception::uptr)&(func), \\\n           (::__interception::uptr)&WRAP(func))\n \n+#if !defined(__ANDROID__)  // android does not have dlvsym\n+#define INTERCEPT_FUNCTION_VER(func, symver) \\\n+    ::__interception::real_##func = (func##_f)(unsigned long) \\\n+        ::__interception::GetFuncAddrVer(#func, #symver)\n+#endif  // !defined(__ANDROID__)\n+\n #endif  // INTERCEPTION_LINUX_H\n #endif  // __linux__"}, {"sha": "5c8726fb35b881af041ebad1e820b9bc16849a8a", "filename": "libsanitizer/lsan/Makefile.am", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.am?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,60 @@\n+AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n+ \n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros\n+AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+ACLOCAL_AMFLAGS = -I m4\n+\n+noinst_LTLIBRARIES = libsanitizer_lsan.la\n+\n+sanitizer_lsan_files = \\\n+\tlsan_common.cc \\\n+\tlsan_common_linux.cc\n+\n+libsanitizer_lsan_la_SOURCES = $(sanitizer_lsan_files)\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+## ################################################################\n+"}, {"sha": "e01f65b86636d6dde04de3e93d4c651b40ef4b67", "filename": "libsanitizer/lsan/Makefile.in", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.in?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,514 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = lsan\n+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/libstdc++-raw-cxx.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+LTLIBRARIES = $(noinst_LTLIBRARIES)\n+libsanitizer_lsan_la_LIBADD =\n+am__objects_1 = lsan_common.lo lsan_common_linux.lo\n+am_libsanitizer_lsan_la_OBJECTS = $(am__objects_1)\n+libsanitizer_lsan_la_OBJECTS = $(am_libsanitizer_lsan_la_OBJECTS)\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libsanitizer_lsan_la_SOURCES)\n+ETAGS = etags\n+CTAGS = ctags\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBSTDCXX_RAW_CXX_CXXFLAGS = @LIBSTDCXX_RAW_CXX_CXXFLAGS@\n+LIBSTDCXX_RAW_CXX_LDFLAGS = @LIBSTDCXX_RAW_CXX_LDFLAGS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_noncanonical = @target_noncanonical@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n+\n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n+\t-Wno-long-long -fPIC -fno-builtin -fno-exceptions \\\n+\t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n+\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+ACLOCAL_AMFLAGS = -I m4\n+noinst_LTLIBRARIES = libsanitizer_lsan.la\n+sanitizer_lsan_files = \\\n+\tlsan_common.cc \\\n+\tlsan_common_linux.cc\n+\n+libsanitizer_lsan_la_SOURCES = $(sanitizer_lsan_files)\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign lsan/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign lsan/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+\n+clean-noinstLTLIBRARIES:\n+\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n+\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libsanitizer_lsan.la: $(libsanitizer_lsan_la_OBJECTS) $(libsanitizer_lsan_la_DEPENDENCIES) \n+\t$(CXXLINK)  $(libsanitizer_lsan_la_OBJECTS) $(libsanitizer_lsan_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_linux.Plo@am__quote@\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am:\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-noinstLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags dvi dvi-am html html-am info info-am install \\\n+\tinstall-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip installcheck installcheck-am installdirs \\\n+\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tpdf pdf-am ps ps-am tags uninstall uninstall-am\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "204fdd2d8e5fe21a5a9f9e23d6a6cf17d353362a", "filename": "libsanitizer/lsan/libtool-version", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flibtool-version?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,6 @@\n+# This file is used to maintain libtool version info for libmudflap.  See\n+# the libtool manual to understand the meaning of the fields.  This is\n+# a separate file so that version updates don't involve re-running\n+# automake.\n+# CURRENT:REVISION:AGE\n+0:0:0"}, {"sha": "500da50622c85706de41a3afb704d7564c084f32", "filename": "libsanitizer/lsan/lsan.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,63 @@\n+//=-- lsan.cc -------------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Standalone LSan RTL.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"lsan.h\"\n+\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"lsan_allocator.h\"\n+#include \"lsan_common.h\"\n+#include \"lsan_thread.h\"\n+\n+namespace __lsan {\n+\n+static void InitializeCommonFlags() {\n+  CommonFlags *cf = common_flags();\n+  cf->external_symbolizer_path = GetEnv(\"LSAN_SYMBOLIZER_PATH\");\n+  cf->symbolize = true;\n+  cf->strip_path_prefix = \"\";\n+  cf->fast_unwind_on_malloc = true;\n+  cf->malloc_context_size = 30;\n+  cf->detect_leaks = true;\n+  cf->leak_check_at_exit = true;\n+\n+  ParseCommonFlagsFromString(GetEnv(\"LSAN_OPTIONS\"));\n+}\n+\n+void Init() {\n+  static bool inited;\n+  if (inited)\n+    return;\n+  inited = true;\n+  SanitizerToolName = \"LeakSanitizer\";\n+  InitializeCommonFlags();\n+  InitializeAllocator();\n+  InitTlsSize();\n+  InitializeInterceptors();\n+  InitializeThreadRegistry();\n+  u32 tid = ThreadCreate(0, 0, true);\n+  CHECK_EQ(tid, 0);\n+  ThreadStart(tid, GetTid());\n+  SetCurrentThread(tid);\n+\n+  // Start symbolizer process if necessary.\n+  if (common_flags()->symbolize) {\n+    getSymbolizer()\n+        ->InitializeExternal(common_flags()->external_symbolizer_path);\n+  }\n+\n+  InitCommonLsan();\n+  if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit)\n+    Atexit(DoLeakCheck);\n+}\n+\n+}  // namespace __lsan"}, {"sha": "18ff5da6281e2291b2742d25d3ca2d5454adfd6e", "filename": "libsanitizer/lsan/lsan.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,21 @@\n+//=-- lsan.h --------------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Private header for standalone LSan RTL.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+\n+namespace __lsan {\n+\n+void Init();\n+void InitializeInterceptors();\n+\n+}  // namespace __lsan"}, {"sha": "66af603e6569fa2fee3c6b72b3ed1bad51b5bfca", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,191 @@\n+//=-- lsan_allocator.cc ---------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// See lsan_allocator.h for details.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"lsan_allocator.h\"\n+\n+#include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"lsan_common.h\"\n+\n+namespace __lsan {\n+\n+static const uptr kMaxAllowedMallocSize = 8UL << 30;\n+static const uptr kAllocatorSpace = 0x600000000000ULL;\n+static const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n+\n+struct ChunkMetadata {\n+  bool allocated : 8;  // Must be first.\n+  ChunkTag tag : 2;\n+  uptr requested_size : 54;\n+  u32 stack_trace_id;\n+};\n+\n+typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize,\n+        sizeof(ChunkMetadata), CompactSizeClassMap> PrimaryAllocator;\n+typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n+typedef LargeMmapAllocator<> SecondaryAllocator;\n+typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n+          SecondaryAllocator> Allocator;\n+\n+static Allocator allocator;\n+static THREADLOCAL AllocatorCache cache;\n+\n+void InitializeAllocator() {\n+  allocator.Init();\n+}\n+\n+void AllocatorThreadFinish() {\n+  allocator.SwallowCache(&cache);\n+}\n+\n+static ChunkMetadata *Metadata(void *p) {\n+  return reinterpret_cast<ChunkMetadata *>(allocator.GetMetaData(p));\n+}\n+\n+static void RegisterAllocation(const StackTrace &stack, void *p, uptr size) {\n+  if (!p) return;\n+  ChunkMetadata *m = Metadata(p);\n+  CHECK(m);\n+  m->tag = DisabledInThisThread() ? kIgnored : kDirectlyLeaked;\n+  m->stack_trace_id = StackDepotPut(stack.trace, stack.size);\n+  m->requested_size = size;\n+  atomic_store(reinterpret_cast<atomic_uint8_t *>(m), 1, memory_order_relaxed);\n+}\n+\n+static void RegisterDeallocation(void *p) {\n+  if (!p) return;\n+  ChunkMetadata *m = Metadata(p);\n+  CHECK(m);\n+  atomic_store(reinterpret_cast<atomic_uint8_t *>(m), 0, memory_order_relaxed);\n+}\n+\n+void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n+               bool cleared) {\n+  if (size == 0)\n+    size = 1;\n+  if (size > kMaxAllowedMallocSize) {\n+    Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", size);\n+    return 0;\n+  }\n+  void *p = allocator.Allocate(&cache, size, alignment, cleared);\n+  RegisterAllocation(stack, p, size);\n+  return p;\n+}\n+\n+void Deallocate(void *p) {\n+  RegisterDeallocation(p);\n+  allocator.Deallocate(&cache, p);\n+}\n+\n+void *Reallocate(const StackTrace &stack, void *p, uptr new_size,\n+                 uptr alignment) {\n+  RegisterDeallocation(p);\n+  if (new_size > kMaxAllowedMallocSize) {\n+    Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", new_size);\n+    allocator.Deallocate(&cache, p);\n+    return 0;\n+  }\n+  p = allocator.Reallocate(&cache, p, new_size, alignment);\n+  RegisterAllocation(stack, p, new_size);\n+  return p;\n+}\n+\n+void GetAllocatorCacheRange(uptr *begin, uptr *end) {\n+  *begin = (uptr)&cache;\n+  *end = *begin + sizeof(cache);\n+}\n+\n+uptr GetMallocUsableSize(void *p) {\n+  ChunkMetadata *m = Metadata(p);\n+  if (!m) return 0;\n+  return m->requested_size;\n+}\n+\n+///// Interface to the common LSan module. /////\n+\n+void LockAllocator() {\n+  allocator.ForceLock();\n+}\n+\n+void UnlockAllocator() {\n+  allocator.ForceUnlock();\n+}\n+\n+void GetAllocatorGlobalRange(uptr *begin, uptr *end) {\n+  *begin = (uptr)&allocator;\n+  *end = *begin + sizeof(allocator);\n+}\n+\n+uptr PointsIntoChunk(void* p) {\n+  uptr addr = reinterpret_cast<uptr>(p);\n+  uptr chunk = reinterpret_cast<uptr>(allocator.GetBlockBeginFastLocked(p));\n+  if (!chunk) return 0;\n+  // LargeMmapAllocator considers pointers to the meta-region of a chunk to be\n+  // valid, but we don't want that.\n+  if (addr < chunk) return 0;\n+  ChunkMetadata *m = Metadata(reinterpret_cast<void *>(chunk));\n+  CHECK(m);\n+  if (m->allocated && addr < chunk + m->requested_size)\n+    return chunk;\n+  return 0;\n+}\n+\n+uptr GetUserBegin(uptr chunk) {\n+  return chunk;\n+}\n+\n+LsanMetadata::LsanMetadata(uptr chunk) {\n+  metadata_ = Metadata(reinterpret_cast<void *>(chunk));\n+  CHECK(metadata_);\n+}\n+\n+bool LsanMetadata::allocated() const {\n+  return reinterpret_cast<ChunkMetadata *>(metadata_)->allocated;\n+}\n+\n+ChunkTag LsanMetadata::tag() const {\n+  return reinterpret_cast<ChunkMetadata *>(metadata_)->tag;\n+}\n+\n+void LsanMetadata::set_tag(ChunkTag value) {\n+  reinterpret_cast<ChunkMetadata *>(metadata_)->tag = value;\n+}\n+\n+uptr LsanMetadata::requested_size() const {\n+  return reinterpret_cast<ChunkMetadata *>(metadata_)->requested_size;\n+}\n+\n+u32 LsanMetadata::stack_trace_id() const {\n+  return reinterpret_cast<ChunkMetadata *>(metadata_)->stack_trace_id;\n+}\n+\n+void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+  allocator.ForEachChunk(callback, arg);\n+}\n+\n+IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n+  void *chunk = allocator.GetBlockBegin(p);\n+  if (!chunk || p < chunk) return kIgnoreObjectInvalid;\n+  ChunkMetadata *m = Metadata(chunk);\n+  CHECK(m);\n+  if (m->allocated && (uptr)p < (uptr)chunk + m->requested_size) {\n+    if (m->tag == kIgnored)\n+      return kIgnoreObjectAlreadyIgnored;\n+    m->tag = kIgnored;\n+    return kIgnoreObjectSuccess;\n+  } else {\n+    return kIgnoreObjectInvalid;\n+  }\n+}\n+}  // namespace __lsan"}, {"sha": "61ea86572ef3d43973be3be51dd7b7dae5cc0a7f", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,37 @@\n+//=-- lsan_allocator.h ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Allocator for standalone LSan.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef LSAN_ALLOCATOR_H\n+#define LSAN_ALLOCATOR_H\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+\n+namespace __lsan {\n+\n+void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n+               bool cleared);\n+void Deallocate(void *p);\n+void *Reallocate(const StackTrace &stack, void *p, uptr new_size,\n+                 uptr alignment);\n+uptr GetMallocUsableSize(void *p);\n+\n+template<typename Callable>\n+void ForEachChunk(const Callable &callback);\n+\n+void GetAllocatorCacheRange(uptr *begin, uptr *end);\n+void AllocatorThreadFinish();\n+void InitializeAllocator();\n+\n+}  // namespace __lsan\n+\n+#endif  // LSAN_ALLOCATOR_H"}, {"sha": "ce82430f48b0ed86e14501e55ce07689bc324ead", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "added", "additions": 577, "deletions": 0, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,577 @@\n+//=-- lsan_common.cc ------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Implementation of common leak checking functionality.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"lsan_common.h\"\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"sanitizer_common/sanitizer_stoptheworld.h\"\n+#include \"sanitizer_common/sanitizer_suppressions.h\"\n+#include \"sanitizer_common/sanitizer_report_decorator.h\"\n+\n+#if CAN_SANITIZE_LEAKS\n+namespace __lsan {\n+\n+// This mutex is used to prevent races between DoLeakCheck and IgnoreObject.\n+BlockingMutex global_mutex(LINKER_INITIALIZED);\n+\n+THREADLOCAL int disable_counter;\n+bool DisabledInThisThread() { return disable_counter > 0; }\n+\n+Flags lsan_flags;\n+\n+static void InitializeFlags() {\n+  Flags *f = flags();\n+  // Default values.\n+  f->report_objects = false;\n+  f->resolution = 0;\n+  f->max_leaks = 0;\n+  f->exitcode = 23;\n+  f->suppressions=\"\";\n+  f->use_registers = true;\n+  f->use_globals = true;\n+  f->use_stacks = true;\n+  f->use_tls = true;\n+  f->use_unaligned = false;\n+  f->verbosity = 0;\n+  f->log_pointers = false;\n+  f->log_threads = false;\n+\n+  const char *options = GetEnv(\"LSAN_OPTIONS\");\n+  if (options) {\n+    ParseFlag(options, &f->use_registers, \"use_registers\");\n+    ParseFlag(options, &f->use_globals, \"use_globals\");\n+    ParseFlag(options, &f->use_stacks, \"use_stacks\");\n+    ParseFlag(options, &f->use_tls, \"use_tls\");\n+    ParseFlag(options, &f->use_unaligned, \"use_unaligned\");\n+    ParseFlag(options, &f->report_objects, \"report_objects\");\n+    ParseFlag(options, &f->resolution, \"resolution\");\n+    CHECK_GE(&f->resolution, 0);\n+    ParseFlag(options, &f->max_leaks, \"max_leaks\");\n+    CHECK_GE(&f->max_leaks, 0);\n+    ParseFlag(options, &f->verbosity, \"verbosity\");\n+    ParseFlag(options, &f->log_pointers, \"log_pointers\");\n+    ParseFlag(options, &f->log_threads, \"log_threads\");\n+    ParseFlag(options, &f->exitcode, \"exitcode\");\n+    ParseFlag(options, &f->suppressions, \"suppressions\");\n+  }\n+}\n+\n+SuppressionContext *suppression_ctx;\n+\n+void InitializeSuppressions() {\n+  CHECK(!suppression_ctx);\n+  ALIGNED(64) static char placeholder_[sizeof(SuppressionContext)];\n+  suppression_ctx = new(placeholder_) SuppressionContext;\n+  char *suppressions_from_file;\n+  uptr buffer_size;\n+  if (ReadFileToBuffer(flags()->suppressions, &suppressions_from_file,\n+                       &buffer_size, 1 << 26 /* max_len */))\n+    suppression_ctx->Parse(suppressions_from_file);\n+  if (flags()->suppressions[0] && !buffer_size) {\n+    Printf(\"LeakSanitizer: failed to read suppressions file '%s'\\n\",\n+           flags()->suppressions);\n+    Die();\n+  }\n+  if (&__lsan_default_suppressions)\n+    suppression_ctx->Parse(__lsan_default_suppressions());\n+}\n+\n+void InitCommonLsan() {\n+  InitializeFlags();\n+  InitializeSuppressions();\n+  InitializePlatformSpecificModules();\n+}\n+\n+class Decorator: private __sanitizer::AnsiColorDecorator {\n+ public:\n+  Decorator() : __sanitizer::AnsiColorDecorator(PrintsToTtyCached()) { }\n+  const char *Error() { return Red(); }\n+  const char *Leak() { return Blue(); }\n+  const char *End() { return Default(); }\n+};\n+\n+static inline bool CanBeAHeapPointer(uptr p) {\n+  // Since our heap is located in mmap-ed memory, we can assume a sensible lower\n+  // bound on heap addresses.\n+  const uptr kMinAddress = 4 * 4096;\n+  if (p < kMinAddress) return false;\n+#ifdef __x86_64__\n+  // Accept only canonical form user-space addresses.\n+  return ((p >> 47) == 0);\n+#else\n+  return true;\n+#endif\n+}\n+\n+// Scans the memory range, looking for byte patterns that point into allocator\n+// chunks. Marks those chunks with |tag| and adds them to |frontier|.\n+// There are two usage modes for this function: finding reachable or ignored\n+// chunks (|tag| = kReachable or kIgnored) and finding indirectly leaked chunks\n+// (|tag| = kIndirectlyLeaked). In the second case, there's no flood fill,\n+// so |frontier| = 0.\n+void ScanRangeForPointers(uptr begin, uptr end,\n+                          Frontier *frontier,\n+                          const char *region_type, ChunkTag tag) {\n+  const uptr alignment = flags()->pointer_alignment();\n+  if (flags()->log_pointers)\n+    Report(\"Scanning %s range %p-%p.\\n\", region_type, begin, end);\n+  uptr pp = begin;\n+  if (pp % alignment)\n+    pp = pp + alignment - pp % alignment;\n+  for (; pp + sizeof(void *) <= end; pp += alignment) {  // NOLINT\n+    void *p = *reinterpret_cast<void **>(pp);\n+    if (!CanBeAHeapPointer(reinterpret_cast<uptr>(p))) continue;\n+    uptr chunk = PointsIntoChunk(p);\n+    if (!chunk) continue;\n+    LsanMetadata m(chunk);\n+    // Reachable beats ignored beats leaked.\n+    if (m.tag() == kReachable) continue;\n+    if (m.tag() == kIgnored && tag != kReachable) continue;\n+    m.set_tag(tag);\n+    if (flags()->log_pointers)\n+      Report(\"%p: found %p pointing into chunk %p-%p of size %zu.\\n\", pp, p,\n+             chunk, chunk + m.requested_size(), m.requested_size());\n+    if (frontier)\n+      frontier->push_back(chunk);\n+  }\n+}\n+\n+// Scans thread data (stacks and TLS) for heap pointers.\n+static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n+                           Frontier *frontier) {\n+  InternalScopedBuffer<uptr> registers(SuspendedThreadsList::RegisterCount());\n+  uptr registers_begin = reinterpret_cast<uptr>(registers.data());\n+  uptr registers_end = registers_begin + registers.size();\n+  for (uptr i = 0; i < suspended_threads.thread_count(); i++) {\n+    uptr os_id = static_cast<uptr>(suspended_threads.GetThreadID(i));\n+    if (flags()->log_threads) Report(\"Processing thread %d.\\n\", os_id);\n+    uptr stack_begin, stack_end, tls_begin, tls_end, cache_begin, cache_end;\n+    bool thread_found = GetThreadRangesLocked(os_id, &stack_begin, &stack_end,\n+                                              &tls_begin, &tls_end,\n+                                              &cache_begin, &cache_end);\n+    if (!thread_found) {\n+      // If a thread can't be found in the thread registry, it's probably in the\n+      // process of destruction. Log this event and move on.\n+      if (flags()->log_threads)\n+        Report(\"Thread %d not found in registry.\\n\", os_id);\n+      continue;\n+    }\n+    uptr sp;\n+    bool have_registers =\n+        (suspended_threads.GetRegistersAndSP(i, registers.data(), &sp) == 0);\n+    if (!have_registers) {\n+      Report(\"Unable to get registers from thread %d.\\n\");\n+      // If unable to get SP, consider the entire stack to be reachable.\n+      sp = stack_begin;\n+    }\n+\n+    if (flags()->use_registers && have_registers)\n+      ScanRangeForPointers(registers_begin, registers_end, frontier,\n+                           \"REGISTERS\", kReachable);\n+\n+    if (flags()->use_stacks) {\n+      if (flags()->log_threads)\n+        Report(\"Stack at %p-%p, SP = %p.\\n\", stack_begin, stack_end, sp);\n+      if (sp < stack_begin || sp >= stack_end) {\n+        // SP is outside the recorded stack range (e.g. the thread is running a\n+        // signal handler on alternate stack). Again, consider the entire stack\n+        // range to be reachable.\n+        if (flags()->log_threads)\n+          Report(\"WARNING: stack pointer not in stack range.\\n\");\n+      } else {\n+        // Shrink the stack range to ignore out-of-scope values.\n+        stack_begin = sp;\n+      }\n+      ScanRangeForPointers(stack_begin, stack_end, frontier, \"STACK\",\n+                           kReachable);\n+    }\n+\n+    if (flags()->use_tls) {\n+      if (flags()->log_threads) Report(\"TLS at %p-%p.\\n\", tls_begin, tls_end);\n+      if (cache_begin == cache_end) {\n+        ScanRangeForPointers(tls_begin, tls_end, frontier, \"TLS\", kReachable);\n+      } else {\n+        // Because LSan should not be loaded with dlopen(), we can assume\n+        // that allocator cache will be part of static TLS image.\n+        CHECK_LE(tls_begin, cache_begin);\n+        CHECK_GE(tls_end, cache_end);\n+        if (tls_begin < cache_begin)\n+          ScanRangeForPointers(tls_begin, cache_begin, frontier, \"TLS\",\n+                               kReachable);\n+        if (tls_end > cache_end)\n+          ScanRangeForPointers(cache_end, tls_end, frontier, \"TLS\", kReachable);\n+      }\n+    }\n+  }\n+}\n+\n+static void FloodFillTag(Frontier *frontier, ChunkTag tag) {\n+  while (frontier->size()) {\n+    uptr next_chunk = frontier->back();\n+    frontier->pop_back();\n+    LsanMetadata m(next_chunk);\n+    ScanRangeForPointers(next_chunk, next_chunk + m.requested_size(), frontier,\n+                         \"HEAP\", tag);\n+  }\n+}\n+\n+// ForEachChunk callback. If the chunk is marked as leaked, marks all chunks\n+// which are reachable from it as indirectly leaked.\n+static void MarkIndirectlyLeakedCb(uptr chunk, void *arg) {\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (m.allocated() && m.tag() != kReachable) {\n+    ScanRangeForPointers(chunk, chunk + m.requested_size(),\n+                         /* frontier */ 0, \"HEAP\", kIndirectlyLeaked);\n+  }\n+}\n+\n+// ForEachChunk callback. If chunk is marked as ignored, adds its address to\n+// frontier.\n+static void CollectIgnoredCb(uptr chunk, void *arg) {\n+  CHECK(arg);\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (m.allocated() && m.tag() == kIgnored)\n+    reinterpret_cast<Frontier *>(arg)->push_back(chunk);\n+}\n+\n+// Sets the appropriate tag on each chunk.\n+static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n+  // Holds the flood fill frontier.\n+  Frontier frontier(GetPageSizeCached());\n+\n+  if (flags()->use_globals)\n+    ProcessGlobalRegions(&frontier);\n+  ProcessThreads(suspended_threads, &frontier);\n+  FloodFillTag(&frontier, kReachable);\n+  // The check here is relatively expensive, so we do this in a separate flood\n+  // fill. That way we can skip the check for chunks that are reachable\n+  // otherwise.\n+  ProcessPlatformSpecificAllocations(&frontier);\n+  FloodFillTag(&frontier, kReachable);\n+\n+  if (flags()->log_pointers)\n+    Report(\"Scanning ignored chunks.\\n\");\n+  CHECK_EQ(0, frontier.size());\n+  ForEachChunk(CollectIgnoredCb, &frontier);\n+  FloodFillTag(&frontier, kIgnored);\n+\n+  // Iterate over leaked chunks and mark those that are reachable from other\n+  // leaked chunks.\n+  if (flags()->log_pointers)\n+    Report(\"Scanning leaked chunks.\\n\");\n+  ForEachChunk(MarkIndirectlyLeakedCb, 0 /* arg */);\n+}\n+\n+static void PrintStackTraceById(u32 stack_trace_id) {\n+  CHECK(stack_trace_id);\n+  uptr size = 0;\n+  const uptr *trace = StackDepotGet(stack_trace_id, &size);\n+  StackTrace::PrintStack(trace, size, common_flags()->symbolize,\n+                         common_flags()->strip_path_prefix, 0);\n+}\n+\n+// ForEachChunk callback. Aggregates unreachable chunks into a LeakReport.\n+static void CollectLeaksCb(uptr chunk, void *arg) {\n+  CHECK(arg);\n+  LeakReport *leak_report = reinterpret_cast<LeakReport *>(arg);\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (!m.allocated()) return;\n+  if (m.tag() == kDirectlyLeaked || m.tag() == kIndirectlyLeaked) {\n+    uptr resolution = flags()->resolution;\n+    if (resolution > 0) {\n+      uptr size = 0;\n+      const uptr *trace = StackDepotGet(m.stack_trace_id(), &size);\n+      size = Min(size, resolution);\n+      leak_report->Add(StackDepotPut(trace, size), m.requested_size(), m.tag());\n+    } else {\n+      leak_report->Add(m.stack_trace_id(), m.requested_size(), m.tag());\n+    }\n+  }\n+}\n+\n+// ForEachChunkCallback. Prints addresses of unreachable chunks.\n+static void PrintLeakedCb(uptr chunk, void *arg) {\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (!m.allocated()) return;\n+  if (m.tag() == kDirectlyLeaked || m.tag() == kIndirectlyLeaked) {\n+    Printf(\"%s leaked %zu byte object at %p.\\n\",\n+           m.tag() == kDirectlyLeaked ? \"Directly\" : \"Indirectly\",\n+           m.requested_size(), chunk);\n+  }\n+}\n+\n+static void PrintMatchedSuppressions() {\n+  InternalMmapVector<Suppression *> matched(1);\n+  suppression_ctx->GetMatched(&matched);\n+  if (!matched.size())\n+    return;\n+  const char *line = \"-----------------------------------------------------\";\n+  Printf(\"%s\\n\", line);\n+  Printf(\"Suppressions used:\\n\");\n+  Printf(\"  count      bytes template\\n\");\n+  for (uptr i = 0; i < matched.size(); i++)\n+    Printf(\"%7zu %10zu %s\\n\", static_cast<uptr>(matched[i]->hit_count),\n+           matched[i]->weight, matched[i]->templ);\n+  Printf(\"%s\\n\\n\", line);\n+}\n+\n+static void PrintLeaked() {\n+  Printf(\"\\n\");\n+  Printf(\"Reporting individual objects:\\n\");\n+  ForEachChunk(PrintLeakedCb, 0 /* arg */);\n+}\n+\n+struct DoLeakCheckParam {\n+  bool success;\n+  LeakReport leak_report;\n+};\n+\n+static void DoLeakCheckCallback(const SuspendedThreadsList &suspended_threads,\n+                                void *arg) {\n+  DoLeakCheckParam *param = reinterpret_cast<DoLeakCheckParam *>(arg);\n+  CHECK(param);\n+  CHECK(!param->success);\n+  CHECK(param->leak_report.IsEmpty());\n+  ClassifyAllChunks(suspended_threads);\n+  ForEachChunk(CollectLeaksCb, &param->leak_report);\n+  if (!param->leak_report.IsEmpty() && flags()->report_objects)\n+    PrintLeaked();\n+  param->success = true;\n+}\n+\n+void DoLeakCheck() {\n+  EnsureMainThreadIDIsCorrect();\n+  BlockingMutexLock l(&global_mutex);\n+  static bool already_done;\n+  if (already_done) return;\n+  already_done = true;\n+  if (&__lsan_is_turned_off && __lsan_is_turned_off())\n+    return;\n+\n+  DoLeakCheckParam param;\n+  param.success = false;\n+  LockThreadRegistry();\n+  LockAllocator();\n+  StopTheWorld(DoLeakCheckCallback, &param);\n+  UnlockAllocator();\n+  UnlockThreadRegistry();\n+\n+  if (!param.success) {\n+    Report(\"LeakSanitizer has encountered a fatal error.\\n\");\n+    Die();\n+  }\n+  uptr have_unsuppressed = param.leak_report.ApplySuppressions();\n+  if (have_unsuppressed) {\n+    Decorator d;\n+    Printf(\"\\n\"\n+           \"=================================================================\"\n+           \"\\n\");\n+    Printf(\"%s\", d.Error());\n+    Report(\"ERROR: LeakSanitizer: detected memory leaks\\n\");\n+    Printf(\"%s\", d.End());\n+    param.leak_report.PrintLargest(flags()->max_leaks);\n+  }\n+  if (have_unsuppressed || (flags()->verbosity >= 1)) {\n+    PrintMatchedSuppressions();\n+    param.leak_report.PrintSummary();\n+  }\n+  if (have_unsuppressed && flags()->exitcode)\n+    internal__exit(flags()->exitcode);\n+}\n+\n+static Suppression *GetSuppressionForAddr(uptr addr) {\n+  static const uptr kMaxAddrFrames = 16;\n+  InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n+  for (uptr i = 0; i < kMaxAddrFrames; i++) new (&addr_frames[i]) AddressInfo();\n+  uptr addr_frames_num =\n+      getSymbolizer()->SymbolizeCode(addr, addr_frames.data(), kMaxAddrFrames);\n+  for (uptr i = 0; i < addr_frames_num; i++) {\n+    Suppression* s;\n+    if (suppression_ctx->Match(addr_frames[i].function, SuppressionLeak, &s) ||\n+        suppression_ctx->Match(addr_frames[i].file, SuppressionLeak, &s) ||\n+        suppression_ctx->Match(addr_frames[i].module, SuppressionLeak, &s))\n+      return s;\n+  }\n+  return 0;\n+}\n+\n+static Suppression *GetSuppressionForStack(u32 stack_trace_id) {\n+  uptr size = 0;\n+  const uptr *trace = StackDepotGet(stack_trace_id, &size);\n+  for (uptr i = 0; i < size; i++) {\n+    Suppression *s =\n+        GetSuppressionForAddr(StackTrace::GetPreviousInstructionPc(trace[i]));\n+    if (s) return s;\n+  }\n+  return 0;\n+}\n+\n+///// LeakReport implementation. /////\n+\n+// A hard limit on the number of distinct leaks, to avoid quadratic complexity\n+// in LeakReport::Add(). We don't expect to ever see this many leaks in\n+// real-world applications.\n+// FIXME: Get rid of this limit by changing the implementation of LeakReport to\n+// use a hash table.\n+const uptr kMaxLeaksConsidered = 5000;\n+\n+void LeakReport::Add(u32 stack_trace_id, uptr leaked_size, ChunkTag tag) {\n+  CHECK(tag == kDirectlyLeaked || tag == kIndirectlyLeaked);\n+  bool is_directly_leaked = (tag == kDirectlyLeaked);\n+  for (uptr i = 0; i < leaks_.size(); i++)\n+    if (leaks_[i].stack_trace_id == stack_trace_id &&\n+        leaks_[i].is_directly_leaked == is_directly_leaked) {\n+      leaks_[i].hit_count++;\n+      leaks_[i].total_size += leaked_size;\n+      return;\n+    }\n+  if (leaks_.size() == kMaxLeaksConsidered) return;\n+  Leak leak = { /* hit_count */ 1, leaked_size, stack_trace_id,\n+                is_directly_leaked, /* is_suppressed */ false };\n+  leaks_.push_back(leak);\n+}\n+\n+static bool LeakComparator(const Leak &leak1, const Leak &leak2) {\n+  if (leak1.is_directly_leaked == leak2.is_directly_leaked)\n+    return leak1.total_size > leak2.total_size;\n+  else\n+    return leak1.is_directly_leaked;\n+}\n+\n+void LeakReport::PrintLargest(uptr num_leaks_to_print) {\n+  CHECK(leaks_.size() <= kMaxLeaksConsidered);\n+  Printf(\"\\n\");\n+  if (leaks_.size() == kMaxLeaksConsidered)\n+    Printf(\"Too many leaks! Only the first %zu leaks encountered will be \"\n+           \"reported.\\n\",\n+           kMaxLeaksConsidered);\n+\n+  uptr unsuppressed_count = 0;\n+  for (uptr i = 0; i < leaks_.size(); i++)\n+    if (!leaks_[i].is_suppressed) unsuppressed_count++;\n+  if (num_leaks_to_print > 0 && num_leaks_to_print < unsuppressed_count)\n+    Printf(\"The %zu largest leak(s):\\n\", num_leaks_to_print);\n+  InternalSort(&leaks_, leaks_.size(), LeakComparator);\n+  uptr leaks_printed = 0;\n+  Decorator d;\n+  for (uptr i = 0; i < leaks_.size(); i++) {\n+    if (leaks_[i].is_suppressed) continue;\n+    Printf(\"%s\", d.Leak());\n+    Printf(\"%s leak of %zu byte(s) in %zu object(s) allocated from:\\n\",\n+           leaks_[i].is_directly_leaked ? \"Direct\" : \"Indirect\",\n+           leaks_[i].total_size, leaks_[i].hit_count);\n+    Printf(\"%s\", d.End());\n+    PrintStackTraceById(leaks_[i].stack_trace_id);\n+    Printf(\"\\n\");\n+    leaks_printed++;\n+    if (leaks_printed == num_leaks_to_print) break;\n+  }\n+  if (leaks_printed < unsuppressed_count) {\n+    uptr remaining = unsuppressed_count - leaks_printed;\n+    Printf(\"Omitting %zu more leak(s).\\n\", remaining);\n+  }\n+}\n+\n+void LeakReport::PrintSummary() {\n+  CHECK(leaks_.size() <= kMaxLeaksConsidered);\n+  uptr bytes = 0, allocations = 0;\n+  for (uptr i = 0; i < leaks_.size(); i++) {\n+      if (leaks_[i].is_suppressed) continue;\n+      bytes += leaks_[i].total_size;\n+      allocations += leaks_[i].hit_count;\n+  }\n+  const int kMaxSummaryLength = 128;\n+  InternalScopedBuffer<char> summary(kMaxSummaryLength);\n+  internal_snprintf(summary.data(), kMaxSummaryLength,\n+                    \"LeakSanitizer: %zu byte(s) leaked in %zu allocation(s).\",\n+                    bytes, allocations);\n+  __sanitizer_report_error_summary(summary.data());\n+}\n+\n+uptr LeakReport::ApplySuppressions() {\n+  uptr unsuppressed_count = 0;\n+  for (uptr i = 0; i < leaks_.size(); i++) {\n+    Suppression *s = GetSuppressionForStack(leaks_[i].stack_trace_id);\n+    if (s) {\n+      s->weight += leaks_[i].total_size;\n+      s->hit_count += leaks_[i].hit_count;\n+      leaks_[i].is_suppressed = true;\n+    } else {\n+    unsuppressed_count++;\n+    }\n+  }\n+  return unsuppressed_count;\n+}\n+}  // namespace __lsan\n+#endif  // CAN_SANITIZE_LEAKS\n+\n+using namespace __lsan;  // NOLINT\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_ignore_object(const void *p) {\n+#if CAN_SANITIZE_LEAKS\n+  // Cannot use PointsIntoChunk or LsanMetadata here, since the allocator is not\n+  // locked.\n+  BlockingMutexLock l(&global_mutex);\n+  IgnoreObjectResult res = IgnoreObjectLocked(p);\n+  if (res == kIgnoreObjectInvalid && flags()->verbosity >= 2)\n+    Report(\"__lsan_ignore_object(): no heap object found at %p\", p);\n+  if (res == kIgnoreObjectAlreadyIgnored && flags()->verbosity >= 2)\n+    Report(\"__lsan_ignore_object(): \"\n+           \"heap object at %p is already being ignored\\n\", p);\n+  if (res == kIgnoreObjectSuccess && flags()->verbosity >= 3)\n+    Report(\"__lsan_ignore_object(): ignoring heap object at %p\\n\", p);\n+#endif  // CAN_SANITIZE_LEAKS\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_disable() {\n+#if CAN_SANITIZE_LEAKS\n+  __lsan::disable_counter++;\n+#endif\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_enable() {\n+#if CAN_SANITIZE_LEAKS\n+  if (!__lsan::disable_counter) {\n+    Report(\"Unmatched call to __lsan_enable().\\n\");\n+    Die();\n+  }\n+  __lsan::disable_counter--;\n+#endif\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_do_leak_check() {\n+#if CAN_SANITIZE_LEAKS\n+  if (common_flags()->detect_leaks)\n+    __lsan::DoLeakCheck();\n+#endif  // CAN_SANITIZE_LEAKS\n+}\n+\n+#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+int __lsan_is_turned_off() {\n+  return 0;\n+}\n+#endif\n+}  // extern \"C\""}, {"sha": "7906ecb91771b0199e9e0c3a583ed4355c94a92a", "filename": "libsanitizer/lsan/lsan_common.h", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,174 @@\n+//=-- lsan_common.h -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Private LSan header.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef LSAN_COMMON_H\n+#define LSAN_COMMON_H\n+\n+#include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n+\n+#if SANITIZER_LINUX && defined(__x86_64__)\n+#define CAN_SANITIZE_LEAKS 1\n+#else\n+#define CAN_SANITIZE_LEAKS 0\n+#endif\n+\n+namespace __lsan {\n+\n+// Chunk tags.\n+enum ChunkTag {\n+  kDirectlyLeaked = 0,  // default\n+  kIndirectlyLeaked = 1,\n+  kReachable = 2,\n+  kIgnored = 3\n+};\n+\n+struct Flags {\n+  uptr pointer_alignment() const {\n+    return use_unaligned ? 1 : sizeof(uptr);\n+  }\n+\n+  // Print addresses of leaked objects after main leak report.\n+  bool report_objects;\n+  // Aggregate two objects into one leak if this many stack frames match. If\n+  // zero, the entire stack trace must match.\n+  int resolution;\n+  // The number of leaks reported.\n+  int max_leaks;\n+  // If nonzero kill the process with this exit code upon finding leaks.\n+  int exitcode;\n+  // Suppressions file name.\n+  const char* suppressions;\n+\n+  // Flags controlling the root set of reachable memory.\n+  // Global variables (.data and .bss).\n+  bool use_globals;\n+  // Thread stacks.\n+  bool use_stacks;\n+  // Thread registers.\n+  bool use_registers;\n+  // TLS and thread-specific storage.\n+  bool use_tls;\n+\n+  // Consider unaligned pointers valid.\n+  bool use_unaligned;\n+\n+  // User-visible verbosity.\n+  int verbosity;\n+\n+  // Debug logging.\n+  bool log_pointers;\n+  bool log_threads;\n+};\n+\n+extern Flags lsan_flags;\n+inline Flags *flags() { return &lsan_flags; }\n+\n+struct Leak {\n+  uptr hit_count;\n+  uptr total_size;\n+  u32 stack_trace_id;\n+  bool is_directly_leaked;\n+  bool is_suppressed;\n+};\n+\n+// Aggregates leaks by stack trace prefix.\n+class LeakReport {\n+ public:\n+  LeakReport() : leaks_(1) {}\n+  void Add(u32 stack_trace_id, uptr leaked_size, ChunkTag tag);\n+  void PrintLargest(uptr max_leaks);\n+  void PrintSummary();\n+  bool IsEmpty() { return leaks_.size() == 0; }\n+  uptr ApplySuppressions();\n+ private:\n+  InternalMmapVector<Leak> leaks_;\n+};\n+\n+typedef InternalMmapVector<uptr> Frontier;\n+\n+// Platform-specific functions.\n+void InitializePlatformSpecificModules();\n+void ProcessGlobalRegions(Frontier *frontier);\n+void ProcessPlatformSpecificAllocations(Frontier *frontier);\n+\n+void ScanRangeForPointers(uptr begin, uptr end,\n+                          Frontier *frontier,\n+                          const char *region_type, ChunkTag tag);\n+\n+enum IgnoreObjectResult {\n+  kIgnoreObjectSuccess,\n+  kIgnoreObjectAlreadyIgnored,\n+  kIgnoreObjectInvalid\n+};\n+\n+// Functions called from the parent tool.\n+void InitCommonLsan();\n+void DoLeakCheck();\n+bool DisabledInThisThread();\n+\n+// The following must be implemented in the parent tool.\n+\n+void ForEachChunk(ForEachChunkCallback callback, void *arg);\n+// Returns the address range occupied by the global allocator object.\n+void GetAllocatorGlobalRange(uptr *begin, uptr *end);\n+// Wrappers for allocator's ForceLock()/ForceUnlock().\n+void LockAllocator();\n+void UnlockAllocator();\n+// Wrappers for ThreadRegistry access.\n+void LockThreadRegistry();\n+void UnlockThreadRegistry();\n+bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n+                           uptr *tls_begin, uptr *tls_end,\n+                           uptr *cache_begin, uptr *cache_end);\n+// If called from the main thread, updates the main thread's TID in the thread\n+// registry. We need this to handle processes that fork() without a subsequent\n+// exec(), which invalidates the recorded TID. To update it, we must call\n+// gettid() from the main thread. Our solution is to call this function before\n+// leak checking and also before every call to pthread_create() (to handle cases\n+// where leak checking is initiated from a non-main thread).\n+void EnsureMainThreadIDIsCorrect();\n+// If p points into a chunk that has been allocated to the user, returns its\n+// user-visible address. Otherwise, returns 0.\n+uptr PointsIntoChunk(void *p);\n+// Returns address of user-visible chunk contained in this allocator chunk.\n+uptr GetUserBegin(uptr chunk);\n+// Helper for __lsan_ignore_object().\n+IgnoreObjectResult IgnoreObjectLocked(const void *p);\n+// Wrapper for chunk metadata operations.\n+class LsanMetadata {\n+ public:\n+  // Constructor accepts address of user-visible chunk.\n+  explicit LsanMetadata(uptr chunk);\n+  bool allocated() const;\n+  ChunkTag tag() const;\n+  void set_tag(ChunkTag value);\n+  uptr requested_size() const;\n+  u32 stack_trace_id() const;\n+ private:\n+  void *metadata_;\n+};\n+\n+}  // namespace __lsan\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+int __lsan_is_turned_off();\n+\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char *__lsan_default_suppressions();\n+}  // extern \"C\"\n+\n+#endif  // LSAN_COMMON_H"}, {"sha": "80d2459a9ad1f7630d3847f1eefcbc823b5b99b4", "filename": "libsanitizer/lsan/lsan_common_linux.cc", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_common_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_common_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,139 @@\n+//=-- lsan_common_linux.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Implementation of common leak checking functionality. Linux-specific code.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#include \"lsan_common.h\"\n+\n+#if CAN_SANITIZE_LEAKS && SANITIZER_LINUX\n+#include <link.h>\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_linux.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+\n+namespace __lsan {\n+\n+static const char kLinkerName[] = \"ld\";\n+// We request 2 modules matching \"ld\", so we can print a warning if there's more\n+// than one match. But only the first one is actually used.\n+static char linker_placeholder[2 * sizeof(LoadedModule)] ALIGNED(64);\n+static LoadedModule *linker = 0;\n+\n+static bool IsLinker(const char* full_name) {\n+  return LibraryNameIs(full_name, kLinkerName);\n+}\n+\n+void InitializePlatformSpecificModules() {\n+  internal_memset(linker_placeholder, 0, sizeof(linker_placeholder));\n+  uptr num_matches = GetListOfModules(\n+      reinterpret_cast<LoadedModule *>(linker_placeholder), 2, IsLinker);\n+  if (num_matches == 1) {\n+    linker = reinterpret_cast<LoadedModule *>(linker_placeholder);\n+    return;\n+  }\n+  if (num_matches == 0)\n+    Report(\"LeakSanitizer: Dynamic linker not found. \"\n+           \"TLS will not be handled correctly.\\n\");\n+  else if (num_matches > 1)\n+    Report(\"LeakSanitizer: Multiple modules match \\\"%s\\\". \"\n+           \"TLS will not be handled correctly.\\n\", kLinkerName);\n+  linker = 0;\n+}\n+\n+static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n+                                        void *data) {\n+  Frontier *frontier = reinterpret_cast<Frontier *>(data);\n+  for (uptr j = 0; j < info->dlpi_phnum; j++) {\n+    const ElfW(Phdr) *phdr = &(info->dlpi_phdr[j]);\n+    // We're looking for .data and .bss sections, which reside in writeable,\n+    // loadable segments.\n+    if (!(phdr->p_flags & PF_W) || (phdr->p_type != PT_LOAD) ||\n+        (phdr->p_memsz == 0))\n+      continue;\n+    uptr begin = info->dlpi_addr + phdr->p_vaddr;\n+    uptr end = begin + phdr->p_memsz;\n+    uptr allocator_begin = 0, allocator_end = 0;\n+    GetAllocatorGlobalRange(&allocator_begin, &allocator_end);\n+    if (begin <= allocator_begin && allocator_begin < end) {\n+      CHECK_LE(allocator_begin, allocator_end);\n+      CHECK_LT(allocator_end, end);\n+      if (begin < allocator_begin)\n+        ScanRangeForPointers(begin, allocator_begin, frontier, \"GLOBAL\",\n+                             kReachable);\n+      if (allocator_end < end)\n+        ScanRangeForPointers(allocator_end, end, frontier, \"GLOBAL\",\n+                             kReachable);\n+    } else {\n+      ScanRangeForPointers(begin, end, frontier, \"GLOBAL\", kReachable);\n+    }\n+  }\n+  return 0;\n+}\n+\n+// Scans global variables for heap pointers.\n+void ProcessGlobalRegions(Frontier *frontier) {\n+  // FIXME: dl_iterate_phdr acquires a linker lock, so we run a risk of\n+  // deadlocking by running this under StopTheWorld. However, the lock is\n+  // reentrant, so we should be able to fix this by acquiring the lock before\n+  // suspending threads.\n+  dl_iterate_phdr(ProcessGlobalRegionsCallback, frontier);\n+}\n+\n+static uptr GetCallerPC(u32 stack_id, StackDepotReverseMap *map) {\n+  CHECK(stack_id);\n+  uptr size = 0;\n+  const uptr *trace = map->Get(stack_id, &size);\n+  // The top frame is our malloc/calloc/etc. The next frame is the caller.\n+  if (size >= 2)\n+    return trace[1];\n+  return 0;\n+}\n+\n+struct ProcessPlatformAllocParam {\n+  Frontier *frontier;\n+  StackDepotReverseMap *stack_depot_reverse_map;\n+};\n+\n+// ForEachChunk callback. Identifies unreachable chunks which must be treated as\n+// reachable. Marks them as reachable and adds them to the frontier.\n+static void ProcessPlatformSpecificAllocationsCb(uptr chunk, void *arg) {\n+  CHECK(arg);\n+  ProcessPlatformAllocParam *param =\n+      reinterpret_cast<ProcessPlatformAllocParam *>(arg);\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (m.allocated() && m.tag() != kReachable) {\n+    u32 stack_id = m.stack_trace_id();\n+    uptr caller_pc = 0;\n+    if (stack_id > 0)\n+      caller_pc = GetCallerPC(stack_id, param->stack_depot_reverse_map);\n+    // If caller_pc is unknown, this chunk may be allocated in a coroutine. Mark\n+    // it as reachable, as we can't properly report its allocation stack anyway.\n+    if (caller_pc == 0 || linker->containsAddress(caller_pc)) {\n+      m.set_tag(kReachable);\n+      param->frontier->push_back(chunk);\n+    }\n+  }\n+}\n+\n+// Handles dynamically allocated TLS blocks by treating all chunks allocated\n+// from ld-linux.so as reachable.\n+void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n+  if (!flags()->use_tls) return;\n+  if (!linker) return;\n+  StackDepotReverseMap stack_depot_reverse_map;\n+  ProcessPlatformAllocParam arg = {frontier, &stack_depot_reverse_map};\n+  ForEachChunk(ProcessPlatformSpecificAllocationsCb, &arg);\n+}\n+\n+}  // namespace __lsan\n+#endif  // CAN_SANITIZE_LEAKS && SANITIZER_LINUX"}, {"sha": "40ddc7773e2b8cdfd65737f19f22aa8400ee192e", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,279 @@\n+//=-- lsan_interceptors.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Interceptors for standalone LSan.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_linux.h\"\n+#include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n+#include \"lsan.h\"\n+#include \"lsan_allocator.h\"\n+#include \"lsan_thread.h\"\n+\n+using namespace __lsan;\n+\n+extern \"C\" {\n+int pthread_attr_init(void *attr);\n+int pthread_attr_destroy(void *attr);\n+int pthread_attr_getdetachstate(void *attr, int *v);\n+int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n+int pthread_setspecific(unsigned key, const void *v);\n+}\n+\n+#define GET_STACK_TRACE                                                      \\\n+  StackTrace stack;                                                          \\\n+  {                                                                          \\\n+    uptr stack_top = 0, stack_bottom = 0;                                    \\\n+    ThreadContext *t;                                                        \\\n+    bool fast = common_flags()->fast_unwind_on_malloc;                       \\\n+    if (fast && (t = CurrentThreadContext())) {                              \\\n+      stack_top = t->stack_end();                                            \\\n+      stack_bottom = t->stack_begin();                                       \\\n+    }                                                                        \\\n+    GetStackTrace(&stack, __sanitizer::common_flags()->malloc_context_size,  \\\n+                  StackTrace::GetCurrentPc(),                                \\\n+                  GET_CURRENT_FRAME(), stack_top, stack_bottom, fast);       \\\n+  }\n+\n+///// Malloc/free interceptors. /////\n+\n+const bool kAlwaysClearMemory = true;\n+\n+namespace std {\n+  struct nothrow_t;\n+}\n+\n+INTERCEPTOR(void*, malloc, uptr size) {\n+  Init();\n+  GET_STACK_TRACE;\n+  return Allocate(stack, size, 1, kAlwaysClearMemory);\n+}\n+\n+INTERCEPTOR(void, free, void *p) {\n+  Init();\n+  Deallocate(p);\n+}\n+\n+INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n+  if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n+  Init();\n+  GET_STACK_TRACE;\n+  size *= nmemb;\n+  return Allocate(stack, size, 1, true);\n+}\n+\n+INTERCEPTOR(void*, realloc, void *q, uptr size) {\n+  Init();\n+  GET_STACK_TRACE;\n+  return Reallocate(stack, q, size, 1);\n+}\n+\n+INTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n+  Init();\n+  GET_STACK_TRACE;\n+  return Allocate(stack, size, alignment, kAlwaysClearMemory);\n+}\n+\n+INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n+  Init();\n+  GET_STACK_TRACE;\n+  *memptr = Allocate(stack, size, alignment, kAlwaysClearMemory);\n+  // FIXME: Return ENOMEM if user requested more than max alloc size.\n+  return 0;\n+}\n+\n+INTERCEPTOR(void*, valloc, uptr size) {\n+  Init();\n+  GET_STACK_TRACE;\n+  if (size == 0)\n+    size = GetPageSizeCached();\n+  return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n+}\n+\n+INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n+  Init();\n+  return GetMallocUsableSize(ptr);\n+}\n+\n+struct fake_mallinfo {\n+  int x[10];\n+};\n+\n+INTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n+  struct fake_mallinfo res;\n+  internal_memset(&res, 0, sizeof(res));\n+  return res;\n+}\n+\n+INTERCEPTOR(int, mallopt, int cmd, int value) {\n+  return -1;\n+}\n+\n+INTERCEPTOR(void*, pvalloc, uptr size) {\n+  Init();\n+  GET_STACK_TRACE;\n+  uptr PageSize = GetPageSizeCached();\n+  size = RoundUpTo(size, PageSize);\n+  if (size == 0) {\n+    // pvalloc(0) should allocate one page.\n+    size = PageSize;\n+  }\n+  return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n+}\n+\n+INTERCEPTOR(void, cfree, void *p) ALIAS(\"free\");\n+\n+#define OPERATOR_NEW_BODY                              \\\n+  Init();                                              \\\n+  GET_STACK_TRACE;                                     \\\n+  return Allocate(stack, size, 1, kAlwaysClearMemory);\n+\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new(uptr size) { OPERATOR_NEW_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new[](uptr size) { OPERATOR_NEW_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new(uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new[](uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n+\n+#define OPERATOR_DELETE_BODY \\\n+  Init();                    \\\n+  Deallocate(ptr);\n+\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr) { OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr) { OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr, std::nothrow_t const&) { OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr, std::nothrow_t const &) {\n+  OPERATOR_DELETE_BODY;\n+}\n+\n+// We need this to intercept the __libc_memalign calls that are used to\n+// allocate dynamic TLS space in ld-linux.so.\n+INTERCEPTOR(void *, __libc_memalign, uptr align, uptr s) ALIAS(\"memalign\");\n+\n+///// Thread initialization and finalization. /////\n+\n+static unsigned g_thread_finalize_key;\n+\n+static void thread_finalize(void *v) {\n+  uptr iter = (uptr)v;\n+  if (iter > 1) {\n+    if (pthread_setspecific(g_thread_finalize_key, (void*)(iter - 1))) {\n+      Report(\"LeakSanitizer: failed to set thread key.\\n\");\n+      Die();\n+    }\n+    return;\n+  }\n+  ThreadFinish();\n+}\n+\n+struct ThreadParam {\n+  void *(*callback)(void *arg);\n+  void *param;\n+  atomic_uintptr_t tid;\n+};\n+\n+// PTHREAD_DESTRUCTOR_ITERATIONS from glibc.\n+const uptr kPthreadDestructorIterations = 4;\n+\n+extern \"C\" void *__lsan_thread_start_func(void *arg) {\n+  ThreadParam *p = (ThreadParam*)arg;\n+  void* (*callback)(void *arg) = p->callback;\n+  void *param = p->param;\n+  // Wait until the last iteration to maximize the chance that we are the last\n+  // destructor to run.\n+  if (pthread_setspecific(g_thread_finalize_key,\n+                          (void*)kPthreadDestructorIterations)) {\n+    Report(\"LeakSanitizer: failed to set thread key.\\n\");\n+    Die();\n+  }\n+  int tid = 0;\n+  while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n+    internal_sched_yield();\n+  atomic_store(&p->tid, 0, memory_order_release);\n+  SetCurrentThread(tid);\n+  ThreadStart(tid, GetTid());\n+  return callback(param);\n+}\n+\n+INTERCEPTOR(int, pthread_create, void *th, void *attr,\n+            void *(*callback)(void *), void *param) {\n+  Init();\n+  EnsureMainThreadIDIsCorrect();\n+  __sanitizer_pthread_attr_t myattr;\n+  if (attr == 0) {\n+    pthread_attr_init(&myattr);\n+    attr = &myattr;\n+  }\n+  AdjustStackSizeLinux(attr, 0);\n+  int detached = 0;\n+  pthread_attr_getdetachstate(attr, &detached);\n+  ThreadParam p;\n+  p.callback = callback;\n+  p.param = param;\n+  atomic_store(&p.tid, 0, memory_order_relaxed);\n+  int res = REAL(pthread_create)(th, attr, __lsan_thread_start_func, &p);\n+  if (res == 0) {\n+    int tid = ThreadCreate(GetCurrentThread(), *(uptr *)th, detached);\n+    CHECK_NE(tid, 0);\n+    atomic_store(&p.tid, tid, memory_order_release);\n+    while (atomic_load(&p.tid, memory_order_acquire) != 0)\n+      internal_sched_yield();\n+  }\n+  if (attr == &myattr)\n+    pthread_attr_destroy(&myattr);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n+  Init();\n+  int tid = ThreadTid((uptr)th);\n+  int res = REAL(pthread_join)(th, ret);\n+  if (res == 0)\n+    ThreadJoin(tid);\n+  return res;\n+}\n+\n+namespace __lsan {\n+\n+void InitializeInterceptors() {\n+  INTERCEPT_FUNCTION(malloc);\n+  INTERCEPT_FUNCTION(free);\n+  INTERCEPT_FUNCTION(cfree);\n+  INTERCEPT_FUNCTION(calloc);\n+  INTERCEPT_FUNCTION(realloc);\n+  INTERCEPT_FUNCTION(memalign);\n+  INTERCEPT_FUNCTION(posix_memalign);\n+  INTERCEPT_FUNCTION(__libc_memalign);\n+  INTERCEPT_FUNCTION(valloc);\n+  INTERCEPT_FUNCTION(pvalloc);\n+  INTERCEPT_FUNCTION(malloc_usable_size);\n+  INTERCEPT_FUNCTION(mallinfo);\n+  INTERCEPT_FUNCTION(mallopt);\n+  INTERCEPT_FUNCTION(pthread_create);\n+  INTERCEPT_FUNCTION(pthread_join);\n+\n+  if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n+    Report(\"LeakSanitizer: failed to create thread key.\\n\");\n+    Die();\n+  }\n+}\n+\n+}  // namespace __lsan"}, {"sha": "c260972cb479dc99032de7e266c78682e77f2482", "filename": "libsanitizer/lsan/lsan_thread.cc", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,154 @@\n+//=-- lsan_thread.cc ------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// See lsan_thread.h for details.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"lsan_thread.h\"\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_thread_registry.h\"\n+#include \"lsan_allocator.h\"\n+\n+namespace __lsan {\n+\n+const u32 kInvalidTid = (u32) -1;\n+\n+static ThreadRegistry *thread_registry;\n+static THREADLOCAL u32 current_thread_tid = kInvalidTid;\n+\n+static ThreadContextBase *CreateThreadContext(u32 tid) {\n+  void *mem = MmapOrDie(sizeof(ThreadContext), \"ThreadContext\");\n+  return new(mem) ThreadContext(tid);\n+}\n+\n+static const uptr kMaxThreads = 1 << 13;\n+static const uptr kThreadQuarantineSize = 64;\n+\n+void InitializeThreadRegistry() {\n+  static char thread_registry_placeholder[sizeof(ThreadRegistry)] ALIGNED(64);\n+  thread_registry = new(thread_registry_placeholder)\n+    ThreadRegistry(CreateThreadContext, kMaxThreads, kThreadQuarantineSize);\n+}\n+\n+u32 GetCurrentThread() {\n+  return current_thread_tid;\n+}\n+\n+void SetCurrentThread(u32 tid) {\n+  current_thread_tid = tid;\n+}\n+\n+ThreadContext::ThreadContext(int tid)\n+  : ThreadContextBase(tid),\n+    stack_begin_(0),\n+    stack_end_(0),\n+    cache_begin_(0),\n+    cache_end_(0),\n+    tls_begin_(0),\n+    tls_end_(0) {}\n+\n+struct OnStartedArgs {\n+  uptr stack_begin, stack_end,\n+       cache_begin, cache_end,\n+       tls_begin, tls_end;\n+};\n+\n+void ThreadContext::OnStarted(void *arg) {\n+  OnStartedArgs *args = reinterpret_cast<OnStartedArgs *>(arg);\n+  stack_begin_ = args->stack_begin;\n+  stack_end_ = args->stack_end;\n+  tls_begin_ = args->tls_begin;\n+  tls_end_ = args->tls_end;\n+  cache_begin_ = args->cache_begin;\n+  cache_end_ = args->cache_end;\n+}\n+\n+void ThreadContext::OnFinished() {\n+  AllocatorThreadFinish();\n+}\n+\n+u32 ThreadCreate(u32 parent_tid, uptr user_id, bool detached) {\n+  return thread_registry->CreateThread(user_id, detached, parent_tid,\n+                                       /* arg */ 0);\n+}\n+\n+void ThreadStart(u32 tid, uptr os_id) {\n+  OnStartedArgs args;\n+  uptr stack_size = 0;\n+  uptr tls_size = 0;\n+  GetThreadStackAndTls(tid == 0, &args.stack_begin, &stack_size,\n+                       &args.tls_begin, &tls_size);\n+  args.stack_end = args.stack_begin + stack_size;\n+  args.tls_end = args.tls_begin + tls_size;\n+  GetAllocatorCacheRange(&args.cache_begin, &args.cache_end);\n+  thread_registry->StartThread(tid, os_id, &args);\n+}\n+\n+void ThreadFinish() {\n+  thread_registry->FinishThread(GetCurrentThread());\n+}\n+\n+ThreadContext *CurrentThreadContext() {\n+  if (!thread_registry) return 0;\n+  if (GetCurrentThread() == kInvalidTid)\n+    return 0;\n+  // No lock needed when getting current thread.\n+  return (ThreadContext *)thread_registry->GetThreadLocked(GetCurrentThread());\n+}\n+\n+static bool FindThreadByUid(ThreadContextBase *tctx, void *arg) {\n+  uptr uid = (uptr)arg;\n+  if (tctx->user_id == uid && tctx->status != ThreadStatusInvalid) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+u32 ThreadTid(uptr uid) {\n+  return thread_registry->FindThread(FindThreadByUid, (void*)uid);\n+}\n+\n+void ThreadJoin(u32 tid) {\n+  CHECK_NE(tid, kInvalidTid);\n+  thread_registry->JoinThread(tid, /* arg */0);\n+}\n+\n+void EnsureMainThreadIDIsCorrect() {\n+  if (GetCurrentThread() == 0)\n+    CurrentThreadContext()->os_id = GetTid();\n+}\n+\n+///// Interface to the common LSan module. /////\n+\n+bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n+                           uptr *tls_begin, uptr *tls_end,\n+                           uptr *cache_begin, uptr *cache_end) {\n+  ThreadContext *context = static_cast<ThreadContext *>(\n+      thread_registry->FindThreadContextByOsIDLocked(os_id));\n+  if (!context) return false;\n+  *stack_begin = context->stack_begin();\n+  *stack_end = context->stack_end();\n+  *tls_begin = context->tls_begin();\n+  *tls_end = context->tls_end();\n+  *cache_begin = context->cache_begin();\n+  *cache_end = context->cache_end();\n+  return true;\n+}\n+\n+void LockThreadRegistry() {\n+  thread_registry->Lock();\n+}\n+\n+void UnlockThreadRegistry() {\n+  thread_registry->Unlock();\n+}\n+\n+}  // namespace __lsan"}, {"sha": "cd13fdb5c5229a92425bba69b23e0dc276f40492", "filename": "libsanitizer/lsan/lsan_thread.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Flsan%2Flsan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,51 @@\n+//=-- lsan_thread.h -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Thread registry for standalone LSan.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef LSAN_THREAD_H\n+#define LSAN_THREAD_H\n+\n+#include \"sanitizer_common/sanitizer_thread_registry.h\"\n+\n+namespace __lsan {\n+\n+class ThreadContext : public ThreadContextBase {\n+ public:\n+  explicit ThreadContext(int tid);\n+  void OnStarted(void *arg);\n+  void OnFinished();\n+  uptr stack_begin() { return stack_begin_; }\n+  uptr stack_end() { return stack_end_; }\n+  uptr tls_begin() { return tls_begin_; }\n+  uptr tls_end() { return tls_end_; }\n+  uptr cache_begin() { return cache_begin_; }\n+  uptr cache_end() { return cache_end_; }\n+ private:\n+  uptr stack_begin_, stack_end_,\n+       cache_begin_, cache_end_,\n+       tls_begin_, tls_end_;\n+};\n+\n+void InitializeThreadRegistry();\n+\n+void ThreadStart(u32 tid, uptr os_id);\n+void ThreadFinish();\n+u32 ThreadCreate(u32 tid, uptr uid, bool detached);\n+void ThreadJoin(u32 tid);\n+u32 ThreadTid(uptr uid);\n+\n+u32 GetCurrentThread();\n+void SetCurrentThread(u32 tid);\n+ThreadContext *CurrentThreadContext();\n+void EnsureMainThreadIDIsCorrect();\n+}  // namespace __lsan\n+\n+#endif  // LSAN_THREAD_H"}, {"sha": "aae8eb41f7d07f0403fa4f624f664c2b06d75836", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -66,6 +66,7 @@ CUR_REV=$(get_current_rev)\n echo Current upstream revision: $CUR_REV\n merge include/sanitizer include/sanitizer\n merge lib/asan asan\n+merge lib/lsan lsan\n merge lib/tsan/rtl tsan\n merge lib/sanitizer_common sanitizer_common\n merge lib/interception interception"}, {"sha": "6cd51187ccb72fe7d182e12653220e2c9213d00b", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -11,23 +11,27 @@ ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_common.la\n \n sanitizer_common_files = \\\n-        sanitizer_allocator.cc \\\n-        sanitizer_common.cc \\\n-        sanitizer_flags.cc \\\n-        sanitizer_libc.cc \\\n-        sanitizer_linux.cc \\\n-        sanitizer_mac.cc \\\n+\tsanitizer_allocator.cc \\\n+\tsanitizer_common.cc \\\n+\tsanitizer_common_libcdep.cc \\\n+\tsanitizer_flags.cc \\\n+\tsanitizer_libc.cc \\\n+\tsanitizer_linux.cc \\\n+\tsanitizer_linux_libcdep.cc \\\n+\tsanitizer_mac.cc \\\n+\tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n-        sanitizer_posix.cc \\\n-        sanitizer_printf.cc \\\n-        sanitizer_stackdepot.cc \\\n-        sanitizer_stacktrace.cc \\\n-        sanitizer_symbolizer.cc \\\n-\tsanitizer_symbolizer_itanium.cc \\\n-        sanitizer_symbolizer_linux.cc \\\n-        sanitizer_symbolizer_mac.cc \\\n-        sanitizer_symbolizer_win.cc \\\n-        sanitizer_win.cc\n+\tsanitizer_posix.cc \\\n+\tsanitizer_posix_libcdep.cc \\\n+\tsanitizer_printf.cc \\\n+\tsanitizer_stackdepot.cc \\\n+\tsanitizer_stacktrace.cc \\\n+\tsanitizer_stoptheworld_linux_libcdep.cc \\\n+\tsanitizer_suppressions.cc \\\n+\tsanitizer_symbolizer_posix_libcdep.cc \\\n+\tsanitizer_symbolizer_win.cc \\\n+\tsanitizer_thread_registry.cc \\\n+\tsanitizer_win.cc\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n "}, {"sha": "68c9849e1690d81867c15ce824a46cb4432c202f", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -56,12 +56,17 @@ CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libsanitizer_common_la_LIBADD =\n am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n-\tsanitizer_flags.lo sanitizer_libc.lo sanitizer_linux.lo \\\n-\tsanitizer_mac.lo sanitizer_platform_limits_posix.lo \\\n-\tsanitizer_posix.lo sanitizer_printf.lo sanitizer_stackdepot.lo \\\n-\tsanitizer_stacktrace.lo sanitizer_symbolizer.lo \\\n-\tsanitizer_symbolizer_itanium.lo sanitizer_symbolizer_linux.lo \\\n-\tsanitizer_symbolizer_mac.lo sanitizer_symbolizer_win.lo \\\n+\tsanitizer_common_libcdep.lo sanitizer_flags.lo \\\n+\tsanitizer_libc.lo sanitizer_linux.lo \\\n+\tsanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n+\tsanitizer_platform_limits_linux.lo \\\n+\tsanitizer_platform_limits_posix.lo sanitizer_posix.lo \\\n+\tsanitizer_posix_libcdep.lo sanitizer_printf.lo \\\n+\tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n+\tsanitizer_stoptheworld_linux_libcdep.lo \\\n+\tsanitizer_suppressions.lo \\\n+\tsanitizer_symbolizer_posix_libcdep.lo \\\n+\tsanitizer_symbolizer_win.lo sanitizer_thread_registry.lo \\\n \tsanitizer_win.lo\n am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n@@ -223,23 +228,27 @@ AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_common.la\n sanitizer_common_files = \\\n-        sanitizer_allocator.cc \\\n-        sanitizer_common.cc \\\n-        sanitizer_flags.cc \\\n-        sanitizer_libc.cc \\\n-        sanitizer_linux.cc \\\n-        sanitizer_mac.cc \\\n+\tsanitizer_allocator.cc \\\n+\tsanitizer_common.cc \\\n+\tsanitizer_common_libcdep.cc \\\n+\tsanitizer_flags.cc \\\n+\tsanitizer_libc.cc \\\n+\tsanitizer_linux.cc \\\n+\tsanitizer_linux_libcdep.cc \\\n+\tsanitizer_mac.cc \\\n+\tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n-        sanitizer_posix.cc \\\n-        sanitizer_printf.cc \\\n-        sanitizer_stackdepot.cc \\\n-        sanitizer_stacktrace.cc \\\n-        sanitizer_symbolizer.cc \\\n-\tsanitizer_symbolizer_itanium.cc \\\n-        sanitizer_symbolizer_linux.cc \\\n-        sanitizer_symbolizer_mac.cc \\\n-        sanitizer_symbolizer_win.cc \\\n-        sanitizer_win.cc\n+\tsanitizer_posix.cc \\\n+\tsanitizer_posix_libcdep.cc \\\n+\tsanitizer_printf.cc \\\n+\tsanitizer_stackdepot.cc \\\n+\tsanitizer_stacktrace.cc \\\n+\tsanitizer_stoptheworld_linux_libcdep.cc \\\n+\tsanitizer_suppressions.cc \\\n+\tsanitizer_symbolizer_posix_libcdep.cc \\\n+\tsanitizer_symbolizer_win.cc \\\n+\tsanitizer_thread_registry.cc \\\n+\tsanitizer_win.cc\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n \n@@ -336,20 +345,24 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_itanium.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_suppressions.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@\n \n .cc.o:"}, {"sha": "9d38e9429ac6f8b2374d369864f69154bef99251", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 87, "deletions": 18, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -7,44 +7,103 @@\n //\n // This file is shared between AddressSanitizer and ThreadSanitizer\n // run-time libraries.\n-// This allocator that is used inside run-times.\n+// This allocator is used inside run-times.\n //===----------------------------------------------------------------------===//\n+#include \"sanitizer_allocator.h\"\n+#include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n \n-// FIXME: We should probably use more low-level allocator that would\n-// mmap some pages and split them into chunks to fulfill requests.\n-#if defined(__linux__) && !defined(__ANDROID__)\n-extern \"C\" void *__libc_malloc(__sanitizer::uptr size);\n+namespace __sanitizer {\n+\n+// ThreadSanitizer for Go uses libc malloc/free.\n+#if defined(SANITIZER_GO)\n+# if SANITIZER_LINUX && !SANITIZER_ANDROID\n+extern \"C\" void *__libc_malloc(uptr size);\n extern \"C\" void __libc_free(void *ptr);\n-# define LIBC_MALLOC __libc_malloc\n-# define LIBC_FREE __libc_free\n-#else  // __linux__ && !ANDROID\n-# include <stdlib.h>\n-# define LIBC_MALLOC malloc\n-# define LIBC_FREE free\n-#endif  // __linux__ && !ANDROID\n+#  define LIBC_MALLOC __libc_malloc\n+#  define LIBC_FREE __libc_free\n+# else\n+#  include <stdlib.h>\n+#  define LIBC_MALLOC malloc\n+#  define LIBC_FREE free\n+# endif\n \n-namespace __sanitizer {\n+static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache) {\n+  (void)cache;\n+  return LIBC_MALLOC(size);\n+}\n+\n+static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n+  (void)cache;\n+  LIBC_FREE(ptr);\n+}\n+\n+InternalAllocator *internal_allocator() {\n+  return 0;\n+}\n+\n+#else  // SANITIZER_GO\n+\n+static ALIGNED(64) char internal_alloc_placeholder[sizeof(InternalAllocator)];\n+static atomic_uint8_t internal_allocator_initialized;\n+static StaticSpinMutex internal_alloc_init_mu;\n+\n+static InternalAllocatorCache internal_allocator_cache;\n+static StaticSpinMutex internal_allocator_cache_mu;\n+\n+InternalAllocator *internal_allocator() {\n+  InternalAllocator *internal_allocator_instance =\n+      reinterpret_cast<InternalAllocator *>(&internal_alloc_placeholder);\n+  if (atomic_load(&internal_allocator_initialized, memory_order_acquire) == 0) {\n+    SpinMutexLock l(&internal_alloc_init_mu);\n+    if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==\n+        0) {\n+      internal_allocator_instance->Init();\n+      atomic_store(&internal_allocator_initialized, 1, memory_order_release);\n+    }\n+  }\n+  return internal_allocator_instance;\n+}\n+\n+static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache) {\n+  if (cache == 0) {\n+    SpinMutexLock l(&internal_allocator_cache_mu);\n+    return internal_allocator()->Allocate(&internal_allocator_cache, size, 8,\n+                                          false);\n+  }\n+  return internal_allocator()->Allocate(cache, size, 8, false);\n+}\n+\n+static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n+  if (cache == 0) {\n+    SpinMutexLock l(&internal_allocator_cache_mu);\n+    return internal_allocator()->Deallocate(&internal_allocator_cache, ptr);\n+  }\n+  internal_allocator()->Deallocate(cache, ptr);\n+}\n+\n+#endif  // SANITIZER_GO\n \n const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;\n \n-void *InternalAlloc(uptr size) {\n+void *InternalAlloc(uptr size, InternalAllocatorCache *cache) {\n   if (size + sizeof(u64) < size)\n     return 0;\n-  void *p = LIBC_MALLOC(size + sizeof(u64));\n+  void *p = RawInternalAlloc(size + sizeof(u64), cache);\n   if (p == 0)\n     return 0;\n   ((u64*)p)[0] = kBlockMagic;\n   return (char*)p + sizeof(u64);\n }\n \n-void InternalFree(void *addr) {\n+void InternalFree(void *addr, InternalAllocatorCache *cache) {\n   if (addr == 0)\n     return;\n   addr = (char*)addr - sizeof(u64);\n-  CHECK_EQ(((u64*)addr)[0], kBlockMagic);\n+  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);\n   ((u64*)addr)[0] = 0;\n-  LIBC_FREE(addr);\n+  RawInternalFree(addr, cache);\n }\n \n // LowLevelAllocator\n@@ -79,4 +138,14 @@ bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n) {\n   return (max / size) < n;\n }\n \n+void *AllocatorReturnNull() {\n+  if (common_flags()->allocator_may_return_null)\n+    return 0;\n+  Report(\"%s's allocator is terminating the process instead of returning 0\\n\",\n+         SanitizerToolName);\n+  Report(\"If you don't like this behavior set allocator_may_return_null=1\\n\");\n+  CHECK(0);\n+  return 0;\n+}\n+\n }  // namespace __sanitizer"}, {"sha": "505fa5b8837218ecfc68cb87c8d1eac14a097c33", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 234, "deletions": 89, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -21,18 +21,21 @@\n \n namespace __sanitizer {\n \n+// Depending on allocator_may_return_null either return 0 or crash.\n+void *AllocatorReturnNull();\n+\n // SizeClassMap maps allocation sizes into size classes and back.\n // Class 0 corresponds to size 0.\n // Classes 1 - 16 correspond to sizes 16 to 256 (size = class_id * 16).\n-// Next 8 classes: 256 + i * 32 (i = 1 to 8).\n-// Next 8 classes: 512 + i * 64 (i = 1 to 8).\n+// Next 4 classes: 256 + i * 64  (i = 1 to 4).\n+// Next 4 classes: 512 + i * 128 (i = 1 to 4).\n // ...\n-// Next 8 classes: 2^k + i * 2^(k-3) (i = 1 to 8).\n+// Next 4 classes: 2^k + i * 2^(k-2) (i = 1 to 4).\n // Last class corresponds to kMaxSize = 1 << kMaxSizeLog.\n //\n // This structure of the size class map gives us:\n //   - Efficient table-free class-to-size and size-to-class functions.\n-//   - Difference between two consequent size classes is betweed 12% and 6%\n+//   - Difference between two consequent size classes is betweed 14% and 25%\n //\n // This class also gives a hint to a thread-caching allocator about the amount\n // of chunks that need to be cached per-thread:\n@@ -59,46 +62,51 @@ namespace __sanitizer {\n // c15 => s: 240 diff: +16 07% l 7 cached: 256 61440; id 15\n //\n // c16 => s: 256 diff: +16 06% l 8 cached: 256 65536; id 16\n-// c17 => s: 288 diff: +32 12% l 8 cached: 227 65376; id 17\n-// c18 => s: 320 diff: +32 11% l 8 cached: 204 65280; id 18\n-// c19 => s: 352 diff: +32 10% l 8 cached: 186 65472; id 19\n-// c20 => s: 384 diff: +32 09% l 8 cached: 170 65280; id 20\n-// c21 => s: 416 diff: +32 08% l 8 cached: 157 65312; id 21\n-// c22 => s: 448 diff: +32 07% l 8 cached: 146 65408; id 22\n-// c23 => s: 480 diff: +32 07% l 8 cached: 136 65280; id 23\n+// c17 => s: 320 diff: +64 25% l 8 cached: 204 65280; id 17\n+// c18 => s: 384 diff: +64 20% l 8 cached: 170 65280; id 18\n+// c19 => s: 448 diff: +64 16% l 8 cached: 146 65408; id 19\n+//\n+// c20 => s: 512 diff: +64 14% l 9 cached: 128 65536; id 20\n+// c21 => s: 640 diff: +128 25% l 9 cached: 102 65280; id 21\n+// c22 => s: 768 diff: +128 20% l 9 cached: 85 65280; id 22\n+// c23 => s: 896 diff: +128 16% l 9 cached: 73 65408; id 23\n+//\n+// c24 => s: 1024 diff: +128 14% l 10 cached: 64 65536; id 24\n+// c25 => s: 1280 diff: +256 25% l 10 cached: 51 65280; id 25\n+// c26 => s: 1536 diff: +256 20% l 10 cached: 42 64512; id 26\n+// c27 => s: 1792 diff: +256 16% l 10 cached: 36 64512; id 27\n+//\n+// ...\n //\n-// c24 => s: 512 diff: +32 06% l 9 cached: 128 65536; id 24\n-// c25 => s: 576 diff: +64 12% l 9 cached: 113 65088; id 25\n-// c26 => s: 640 diff: +64 11% l 9 cached: 102 65280; id 26\n-// c27 => s: 704 diff: +64 10% l 9 cached: 93 65472; id 27\n-// c28 => s: 768 diff: +64 09% l 9 cached: 85 65280; id 28\n-// c29 => s: 832 diff: +64 08% l 9 cached: 78 64896; id 29\n-// c30 => s: 896 diff: +64 07% l 9 cached: 73 65408; id 30\n-// c31 => s: 960 diff: +64 07% l 9 cached: 68 65280; id 31\n+// c48 => s: 65536 diff: +8192 14% l 16 cached: 1 65536; id 48\n+// c49 => s: 81920 diff: +16384 25% l 16 cached: 1 81920; id 49\n+// c50 => s: 98304 diff: +16384 20% l 16 cached: 1 98304; id 50\n+// c51 => s: 114688 diff: +16384 16% l 16 cached: 1 114688; id 51\n //\n-// c32 => s: 1024 diff: +64 06% l 10 cached: 64 65536; id 32\n+// c52 => s: 131072 diff: +16384 14% l 17 cached: 1 131072; id 52\n \n-template <uptr kMaxSizeLog, uptr kMaxNumCachedT, uptr kMaxBytesCachedLog,\n-          uptr kMinBatchClassT>\n+template <uptr kMaxSizeLog, uptr kMaxNumCachedT, uptr kMaxBytesCachedLog>\n class SizeClassMap {\n   static const uptr kMinSizeLog = 4;\n   static const uptr kMidSizeLog = kMinSizeLog + 4;\n   static const uptr kMinSize = 1 << kMinSizeLog;\n   static const uptr kMidSize = 1 << kMidSizeLog;\n   static const uptr kMidClass = kMidSize / kMinSize;\n-  static const uptr S = 3;\n+  static const uptr S = 2;\n   static const uptr M = (1 << S) - 1;\n \n  public:\n   static const uptr kMaxNumCached = kMaxNumCachedT;\n+  // We transfer chunks between central and thread-local free lists in batches.\n+  // For small size classes we allocate batches separately.\n+  // For large size classes we use one of the chunks to store the batch.\n   struct TransferBatch {\n     TransferBatch *next;\n     uptr count;\n     void *batch[kMaxNumCached];\n   };\n \n-  static const uptr kMinBatchClass = kMinBatchClassT;\n-  static const uptr kMaxSize = 1 << kMaxSizeLog;\n+  static const uptr kMaxSize = 1UL << kMaxSizeLog;\n   static const uptr kNumClasses =\n       kMidClass + ((kMaxSizeLog - kMidSizeLog) << S) + 1;\n   COMPILER_CHECK(kNumClasses >= 32 && kNumClasses <= 256);\n@@ -141,7 +149,7 @@ class SizeClassMap {\n         Printf(\"\\n\");\n       uptr d = s - prev_s;\n       uptr p = prev_s ? (d * 100 / prev_s) : 0;\n-      uptr l = MostSignificantSetBitIndex(s);\n+      uptr l = s ? MostSignificantSetBitIndex(s) : 0;\n       uptr cached = MaxCached(i) * s;\n       Printf(\"c%02zd => s: %zd diff: +%zd %02zd%% l %zd \"\n              \"cached: %zd %zd; id %zd\\n\",\n@@ -152,10 +160,16 @@ class SizeClassMap {\n     Printf(\"Total cached: %zd\\n\", total_cached);\n   }\n \n+  static bool SizeClassRequiresSeparateTransferBatch(uptr class_id) {\n+    return Size(class_id) < sizeof(TransferBatch) -\n+        sizeof(uptr) * (kMaxNumCached - MaxCached(class_id));\n+  }\n+\n   static void Validate() {\n     for (uptr c = 1; c < kNumClasses; c++) {\n       // Printf(\"Validate: c%zd\\n\", c);\n       uptr s = Size(c);\n+      CHECK_NE(s, 0U);\n       CHECK_EQ(ClassID(s), c);\n       if (c != kNumClasses - 1)\n         CHECK_EQ(ClassID(s + 1), c + 1);\n@@ -173,24 +187,11 @@ class SizeClassMap {\n       if (c > 0)\n         CHECK_LT(Size(c-1), s);\n     }\n-\n-    // TransferBatch for kMinBatchClass must fit into the block itself.\n-    const uptr batch_size = sizeof(TransferBatch)\n-        - sizeof(void*)  // NOLINT\n-            * (kMaxNumCached - MaxCached(kMinBatchClass));\n-    CHECK_LE(batch_size, Size(kMinBatchClass));\n-    // TransferBatch for kMinBatchClass-1 must not fit into the block itself.\n-    const uptr batch_size1 = sizeof(TransferBatch)\n-        - sizeof(void*)  // NOLINT\n-            * (kMaxNumCached - MaxCached(kMinBatchClass - 1));\n-    CHECK_GT(batch_size1, Size(kMinBatchClass - 1));\n   }\n };\n \n-typedef SizeClassMap<17, 256, 16, FIRST_32_SECOND_64(25, 28)>\n-    DefaultSizeClassMap;\n-typedef SizeClassMap<17, 64, 14, FIRST_32_SECOND_64(17, 20)>\n-    CompactSizeClassMap;\n+typedef SizeClassMap<17, 128, 16> DefaultSizeClassMap;\n+typedef SizeClassMap<17, 64,  14> CompactSizeClassMap;\n template<class SizeClassAllocator> struct SizeClassAllocatorLocalCache;\n \n // Memory allocator statistics\n@@ -279,6 +280,9 @@ struct NoOpMapUnmapCallback {\n   void OnUnmap(uptr p, uptr size) const { }\n };\n \n+// Callback type for iterating over chunks.\n+typedef void (*ForEachChunkCallback)(uptr chunk, void *arg);\n+\n // SizeClassAllocator64 -- allocator for 64-bit address space.\n //\n // Space: a portion of address space of kSpaceSize bytes starting at\n@@ -339,25 +343,28 @@ class SizeClassAllocator64 {\n \n   NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {\n     RegionInfo *region = GetRegionInfo(class_id);\n+    CHECK_GT(b->count, 0);\n     region->free_list.Push(b);\n     region->n_freed += b->count;\n   }\n \n-  static bool PointerIsMine(void *p) {\n+  static bool PointerIsMine(const void *p) {\n     return reinterpret_cast<uptr>(p) / kSpaceSize == kSpaceBeg / kSpaceSize;\n   }\n \n-  static uptr GetSizeClass(void *p) {\n+  static uptr GetSizeClass(const void *p) {\n     return (reinterpret_cast<uptr>(p) / kRegionSize) % kNumClassesRounded;\n   }\n \n-  void *GetBlockBegin(void *p) {\n+  void *GetBlockBegin(const void *p) {\n     uptr class_id = GetSizeClass(p);\n     uptr size = SizeClassMap::Size(class_id);\n+    if (!size) return 0;\n     uptr chunk_idx = GetChunkIdx((uptr)p, size);\n     uptr reg_beg = (uptr)p & ~(kRegionSize - 1);\n     uptr beg = chunk_idx * size;\n     uptr next_beg = beg + size;\n+    if (class_id >= kNumClasses) return 0;\n     RegionInfo *region = GetRegionInfo(class_id);\n     if (region->mapped_user >= next_beg)\n       return reinterpret_cast<void*>(reg_beg + beg);\n@@ -371,7 +378,7 @@ class SizeClassAllocator64 {\n \n   uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n \n-  void *GetMetaData(void *p) {\n+  void *GetMetaData(const void *p) {\n     uptr class_id = GetSizeClass(p);\n     uptr size = SizeClassMap::Size(class_id);\n     uptr chunk_idx = GetChunkIdx(reinterpret_cast<uptr>(p), size);\n@@ -430,6 +437,22 @@ class SizeClassAllocator64 {\n     }\n   }\n \n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n+      RegionInfo *region = GetRegionInfo(class_id);\n+      uptr chunk_size = SizeClassMap::Size(class_id);\n+      uptr region_beg = kSpaceBeg + class_id * kRegionSize;\n+      for (uptr chunk = region_beg;\n+           chunk < region_beg + region->allocated_user;\n+           chunk += chunk_size) {\n+        // Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));\n+        callback(chunk, arg);\n+      }\n+    }\n+  }\n+\n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n   static const uptr kNumClassesRounded = SizeClassMap::kNumClassesRounded;\n@@ -471,11 +494,12 @@ class SizeClassAllocator64 {\n   }\n \n   static uptr GetChunkIdx(uptr chunk, uptr size) {\n-    u32 offset = chunk % kRegionSize;\n+    uptr offset = chunk % kRegionSize;\n     // Here we divide by a non-constant. This is costly.\n-    // We require that kRegionSize is at least 2^32 so that offset is 32-bit.\n-    // We save 2x by using 32-bit div, but may need to use a 256-way switch.\n-    return offset / (u32)size;\n+    // size always fits into 32-bits. If the offset fits too, use 32-bit div.\n+    if (offset >> (SANITIZER_WORDSIZE / 2))\n+      return offset / size;\n+    return (u32)offset / (u32)size;\n   }\n \n   NOINLINE Batch* PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n@@ -513,14 +537,14 @@ class SizeClassAllocator64 {\n       region->mapped_meta += map_size;\n     }\n     CHECK_LE(region->allocated_meta, region->mapped_meta);\n-    if (region->allocated_user + region->allocated_meta > kRegionSize) {\n-      Printf(\"Out of memory. Dying.\\n\");\n+    if (region->mapped_user + region->mapped_meta > kRegionSize) {\n+      Printf(\"%s: Out of memory. Dying. \", SanitizerToolName);\n       Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n           kRegionSize / 1024 / 1024, size);\n       Die();\n     }\n     for (;;) {\n-      if (class_id < SizeClassMap::kMinBatchClass)\n+      if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n         b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));\n       else\n         b = (Batch*)(region_beg + beg_idx);\n@@ -532,12 +556,37 @@ class SizeClassAllocator64 {\n       beg_idx += count * size;\n       if (beg_idx + count * size + size > region->mapped_user)\n         break;\n+      CHECK_GT(b->count, 0);\n       region->free_list.Push(b);\n     }\n     return b;\n   }\n };\n \n+// Maps integers in rage [0, kSize) to u8 values.\n+template<u64 kSize>\n+class FlatByteMap {\n+ public:\n+  void TestOnlyInit() {\n+    internal_memset(map_, 0, sizeof(map_));\n+  }\n+\n+  void set(uptr idx, u8 val) {\n+    CHECK_LT(idx, kSize);\n+    CHECK_EQ(0U, map_[idx]);\n+    map_[idx] = val;\n+  }\n+  u8 operator[] (uptr idx) {\n+    CHECK_LT(idx, kSize);\n+    // FIXME: CHECK may be too expensive here.\n+    return map_[idx];\n+  }\n+ private:\n+  u8 map_[kSize];\n+};\n+\n+// FIXME: Also implement TwoLevelByteMap.\n+\n // SizeClassAllocator32 -- allocator for 32-bit address space.\n // This allocator can theoretically be used on 64-bit arch, but there it is less\n // efficient than SizeClassAllocator64.\n@@ -549,7 +598,7 @@ class SizeClassAllocator64 {\n //   a result of a single call to MmapAlignedOrDie(kRegionSize, kRegionSize).\n // Since the regions are aligned by kRegionSize, there are exactly\n // kNumPossibleRegions possible regions in the address space and so we keep\n-// an u8 array possible_regions[kNumPossibleRegions] to store the size classes.\n+// a ByteMap possible_regions to store the size classes of each Region.\n // 0 size class means the region is not used by the allocator.\n //\n // One Region is used to allocate chunks of a single size class.\n@@ -560,16 +609,19 @@ class SizeClassAllocator64 {\n // chache-line aligned.\n template <const uptr kSpaceBeg, const u64 kSpaceSize,\n           const uptr kMetadataSize, class SizeClassMap,\n+          const uptr kRegionSizeLog,\n+          class ByteMap,\n           class MapUnmapCallback = NoOpMapUnmapCallback>\n class SizeClassAllocator32 {\n  public:\n   typedef typename SizeClassMap::TransferBatch Batch;\n   typedef SizeClassAllocator32<kSpaceBeg, kSpaceSize, kMetadataSize,\n-      SizeClassMap, MapUnmapCallback> ThisT;\n+      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;\n   typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;\n \n   void Init() {\n-    state_ = reinterpret_cast<State *>(MapWithCallback(sizeof(State)));\n+    possible_regions.TestOnlyInit();\n+    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));\n   }\n \n   void *MapWithCallback(uptr size) {\n@@ -589,7 +641,7 @@ class SizeClassAllocator32 {\n       alignment <= SizeClassMap::kMaxSize;\n   }\n \n-  void *GetMetaData(void *p) {\n+  void *GetMetaData(const void *p) {\n     CHECK(PointerIsMine(p));\n     uptr mem = reinterpret_cast<uptr>(p);\n     uptr beg = ComputeRegionBeg(mem);\n@@ -617,18 +669,19 @@ class SizeClassAllocator32 {\n     CHECK_LT(class_id, kNumClasses);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n+    CHECK_GT(b->count, 0);\n     sci->free_list.push_front(b);\n   }\n \n-  bool PointerIsMine(void *p) {\n+  bool PointerIsMine(const void *p) {\n     return GetSizeClass(p) != 0;\n   }\n \n-  uptr GetSizeClass(void *p) {\n-    return state_->possible_regions[ComputeRegionId(reinterpret_cast<uptr>(p))];\n+  uptr GetSizeClass(const void *p) {\n+    return possible_regions[ComputeRegionId(reinterpret_cast<uptr>(p))];\n   }\n \n-  void *GetBlockBegin(void *p) {\n+  void *GetBlockBegin(const void *p) {\n     CHECK(PointerIsMine(p));\n     uptr mem = reinterpret_cast<uptr>(p);\n     uptr beg = ComputeRegionBeg(mem);\n@@ -650,16 +703,15 @@ class SizeClassAllocator32 {\n     // No need to lock here.\n     uptr res = 0;\n     for (uptr i = 0; i < kNumPossibleRegions; i++)\n-      if (state_->possible_regions[i])\n+      if (possible_regions[i])\n         res += kRegionSize;\n     return res;\n   }\n \n   void TestOnlyUnmap() {\n     for (uptr i = 0; i < kNumPossibleRegions; i++)\n-      if (state_->possible_regions[i])\n+      if (possible_regions[i])\n         UnmapWithCallback((i * kRegionSize), kRegionSize);\n-    UnmapWithCallback(reinterpret_cast<uptr>(state_), sizeof(State));\n   }\n \n   // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n@@ -676,14 +728,30 @@ class SizeClassAllocator32 {\n     }\n   }\n \n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    for (uptr region = 0; region < kNumPossibleRegions; region++)\n+      if (possible_regions[region]) {\n+        uptr chunk_size = SizeClassMap::Size(possible_regions[region]);\n+        uptr max_chunks_in_region = kRegionSize / (chunk_size + kMetadataSize);\n+        uptr region_beg = region * kRegionSize;\n+        for (uptr chunk = region_beg;\n+             chunk < region_beg + max_chunks_in_region * chunk_size;\n+             chunk += chunk_size) {\n+          // Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));\n+          callback(chunk, arg);\n+        }\n+      }\n+  }\n+\n   void PrintStats() {\n   }\n \n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n \n  private:\n-  static const uptr kRegionSizeLog = SANITIZER_WORDSIZE == 64 ? 24 : 20;\n   static const uptr kRegionSize = 1 << kRegionSizeLog;\n   static const uptr kNumPossibleRegions = kSpaceSize / kRegionSize;\n \n@@ -711,14 +779,13 @@ class SizeClassAllocator32 {\n     MapUnmapCallback().OnMap(res, kRegionSize);\n     stat->Add(AllocatorStatMmapped, kRegionSize);\n     CHECK_EQ(0U, (res & (kRegionSize - 1)));\n-    CHECK_EQ(0U, state_->possible_regions[ComputeRegionId(res)]);\n-    state_->possible_regions[ComputeRegionId(res)] = class_id;\n+    possible_regions.set(ComputeRegionId(res), static_cast<u8>(class_id));\n     return res;\n   }\n \n   SizeClassInfo *GetSizeClassInfo(uptr class_id) {\n     CHECK_LT(class_id, kNumClasses);\n-    return &state_->size_class_info_array[class_id];\n+    return &size_class_info_array[class_id];\n   }\n \n   void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n@@ -730,27 +797,27 @@ class SizeClassAllocator32 {\n     Batch *b = 0;\n     for (uptr i = reg; i < reg + n_chunks * size; i += size) {\n       if (b == 0) {\n-        if (class_id < SizeClassMap::kMinBatchClass)\n+        if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n           b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));\n         else\n           b = (Batch*)i;\n         b->count = 0;\n       }\n       b->batch[b->count++] = (void*)i;\n       if (b->count == max_count) {\n+        CHECK_GT(b->count, 0);\n         sci->free_list.push_back(b);\n         b = 0;\n       }\n     }\n-    if (b)\n+    if (b) {\n+      CHECK_GT(b->count, 0);\n       sci->free_list.push_back(b);\n+    }\n   }\n \n-  struct State {\n-    u8 possible_regions[kNumPossibleRegions];\n-    SizeClassInfo size_class_info_array[kNumClasses];\n-  };\n-  State *state_;\n+  ByteMap possible_regions;\n+  SizeClassInfo size_class_info_array[kNumClasses];\n };\n \n // Objects of this type should be used as local caches for SizeClassAllocator64\n@@ -788,8 +855,12 @@ struct SizeClassAllocatorLocalCache {\n   void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n+    // If the first allocator call on a new thread is a deallocation, then\n+    // max_count will be zero, leading to check failure.\n+    InitCache();\n     stats_.Add(AllocatorStatFreed, SizeClassMap::Size(class_id));\n     PerClass *c = &per_class_[class_id];\n+    CHECK_NE(c->max_count, 0UL);\n     if (UNLIKELY(c->count == c->max_count))\n       Drain(allocator, class_id);\n     c->batch[c->count++] = p;\n@@ -815,7 +886,7 @@ struct SizeClassAllocatorLocalCache {\n   AllocatorStats stats_;\n \n   void InitCache() {\n-    if (per_class_[0].max_count)\n+    if (per_class_[1].max_count)\n       return;\n     for (uptr i = 0; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n@@ -831,15 +902,15 @@ struct SizeClassAllocatorLocalCache {\n     for (uptr i = 0; i < b->count; i++)\n       c->batch[i] = b->batch[i];\n     c->count = b->count;\n-    if (class_id < SizeClassMap::kMinBatchClass)\n+    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n       Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);\n   }\n \n   NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {\n     InitCache();\n     PerClass *c = &per_class_[class_id];\n     Batch *b;\n-    if (class_id < SizeClassMap::kMinBatchClass)\n+    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n       b = (Batch*)Allocate(allocator, SizeClassMap::ClassID(sizeof(Batch)));\n     else\n       b = (Batch*)c->batch[0];\n@@ -850,6 +921,7 @@ struct SizeClassAllocatorLocalCache {\n     }\n     b->count = cnt;\n     c->count -= cnt;\n+    CHECK_GT(b->count, 0);\n     allocator->DeallocateBatch(&stats_, class_id, b);\n   }\n };\n@@ -870,7 +942,7 @@ class LargeMmapAllocator {\n     uptr map_size = RoundUpMapSize(size);\n     if (alignment > page_size_)\n       map_size += alignment;\n-    if (map_size < size) return 0;  // Overflow.\n+    if (map_size < size) return AllocatorReturnNull();  // Overflow.\n     uptr map_beg = reinterpret_cast<uptr>(\n         MmapOrDie(map_size, \"LargeMmapAllocator\"));\n     MapUnmapCallback().OnMap(map_beg, map_size);\n@@ -889,6 +961,7 @@ class LargeMmapAllocator {\n     {\n       SpinMutexLock l(&mutex_);\n       uptr idx = n_chunks_++;\n+      chunks_sorted_ = false;\n       CHECK_LT(idx, kMaxNumChunks);\n       h->chunk_idx = idx;\n       chunks_[idx] = h;\n@@ -912,6 +985,7 @@ class LargeMmapAllocator {\n       chunks_[idx] = chunks_[n_chunks_ - 1];\n       chunks_[idx]->chunk_idx = idx;\n       n_chunks_--;\n+      chunks_sorted_ = false;\n       stats.n_frees++;\n       stats.currently_allocated -= h->map_size;\n       stat->Add(AllocatorStatFreed, h->map_size);\n@@ -932,7 +1006,7 @@ class LargeMmapAllocator {\n     return res;\n   }\n \n-  bool PointerIsMine(void *p) {\n+  bool PointerIsMine(const void *p) {\n     return GetBlockBegin(p) != 0;\n   }\n \n@@ -941,13 +1015,16 @@ class LargeMmapAllocator {\n   }\n \n   // At least page_size_/2 metadata bytes is available.\n-  void *GetMetaData(void *p) {\n+  void *GetMetaData(const void *p) {\n     // Too slow: CHECK_EQ(p, GetBlockBegin(p));\n-    CHECK(IsAligned(reinterpret_cast<uptr>(p), page_size_));\n+    if (!IsAligned(reinterpret_cast<uptr>(p), page_size_)) {\n+      Printf(\"%s: bad pointer %p\\n\", SanitizerToolName, p);\n+      CHECK(IsAligned(reinterpret_cast<uptr>(p), page_size_));\n+    }\n     return GetHeader(p) + 1;\n   }\n \n-  void *GetBlockBegin(void *ptr) {\n+  void *GetBlockBegin(const void *ptr) {\n     uptr p = reinterpret_cast<uptr>(ptr);\n     SpinMutexLock l(&mutex_);\n     uptr nearest_chunk = 0;\n@@ -964,7 +1041,49 @@ class LargeMmapAllocator {\n     CHECK_GE(nearest_chunk, h->map_beg);\n     CHECK_LT(nearest_chunk, h->map_beg + h->map_size);\n     CHECK_LE(nearest_chunk, p);\n-    if (h->map_beg + h->map_size < p)\n+    if (h->map_beg + h->map_size <= p)\n+      return 0;\n+    return GetUser(h);\n+  }\n+\n+  // This function does the same as GetBlockBegin, but is much faster.\n+  // Must be called with the allocator locked.\n+  void *GetBlockBeginFastLocked(void *ptr) {\n+    uptr p = reinterpret_cast<uptr>(ptr);\n+    uptr n = n_chunks_;\n+    if (!n) return 0;\n+    if (!chunks_sorted_) {\n+      // Do one-time sort. chunks_sorted_ is reset in Allocate/Deallocate.\n+      SortArray(reinterpret_cast<uptr*>(chunks_), n);\n+      for (uptr i = 0; i < n; i++)\n+        chunks_[i]->chunk_idx = i;\n+      chunks_sorted_ = true;\n+      min_mmap_ = reinterpret_cast<uptr>(chunks_[0]);\n+      max_mmap_ = reinterpret_cast<uptr>(chunks_[n - 1]) +\n+          chunks_[n - 1]->map_size;\n+    }\n+    if (p < min_mmap_ || p >= max_mmap_)\n+      return 0;\n+    uptr beg = 0, end = n - 1;\n+    // This loop is a log(n) lower_bound. It does not check for the exact match\n+    // to avoid expensive cache-thrashing loads.\n+    while (end - beg >= 2) {\n+      uptr mid = (beg + end) / 2;  // Invariant: mid >= beg + 1\n+      if (p < reinterpret_cast<uptr>(chunks_[mid]))\n+        end = mid - 1;  // We are not interested in chunks_[mid].\n+      else\n+        beg = mid;  // chunks_[mid] may still be what we want.\n+    }\n+\n+    if (beg < end) {\n+      CHECK_EQ(beg + 1, end);\n+      // There are 2 chunks left, choose one.\n+      if (p >= reinterpret_cast<uptr>(chunks_[end]))\n+        beg = end;\n+    }\n+\n+    Header *h = chunks_[beg];\n+    if (h->map_beg + h->map_size <= p || p < h->map_beg)\n       return 0;\n     return GetUser(h);\n   }\n@@ -992,6 +1111,13 @@ class LargeMmapAllocator {\n     mutex_.Unlock();\n   }\n \n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    for (uptr i = 0; i < n_chunks_; i++)\n+      callback(reinterpret_cast<uptr>(GetUser(chunks_[i])), arg);\n+  }\n+\n  private:\n   static const int kMaxNumChunks = 1 << FIRST_32_SECOND_64(15, 18);\n   struct Header {\n@@ -1002,13 +1128,15 @@ class LargeMmapAllocator {\n   };\n \n   Header *GetHeader(uptr p) {\n-    CHECK_EQ(p % page_size_, 0);\n+    CHECK(IsAligned(p, page_size_));\n     return reinterpret_cast<Header*>(p - page_size_);\n   }\n-  Header *GetHeader(void *p) { return GetHeader(reinterpret_cast<uptr>(p)); }\n+  Header *GetHeader(const void *p) {\n+    return GetHeader(reinterpret_cast<uptr>(p));\n+  }\n \n   void *GetUser(Header *h) {\n-    CHECK_EQ((uptr)h % page_size_, 0);\n+    CHECK(IsAligned((uptr)h, page_size_));\n     return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);\n   }\n \n@@ -1019,6 +1147,8 @@ class LargeMmapAllocator {\n   uptr page_size_;\n   Header *chunks_[kMaxNumChunks];\n   uptr n_chunks_;\n+  uptr min_mmap_, max_mmap_;\n+  bool chunks_sorted_;\n   struct Stats {\n     uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n   } stats;\n@@ -1047,7 +1177,7 @@ class CombinedAllocator {\n     if (size == 0)\n       size = 1;\n     if (size + alignment < size)\n-      return 0;\n+      return AllocatorReturnNull();\n     if (alignment > 8)\n       size = RoundUpTo(size, alignment);\n     void *res;\n@@ -1098,18 +1228,26 @@ class CombinedAllocator {\n     return primary_.PointerIsMine(p);\n   }\n \n-  void *GetMetaData(void *p) {\n+  void *GetMetaData(const void *p) {\n     if (primary_.PointerIsMine(p))\n       return primary_.GetMetaData(p);\n     return secondary_.GetMetaData(p);\n   }\n \n-  void *GetBlockBegin(void *p) {\n+  void *GetBlockBegin(const void *p) {\n     if (primary_.PointerIsMine(p))\n       return primary_.GetBlockBegin(p);\n     return secondary_.GetBlockBegin(p);\n   }\n \n+  // This function does the same as GetBlockBegin, but is much faster.\n+  // Must be called with the allocator locked.\n+  void *GetBlockBeginFastLocked(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetBlockBegin(p);\n+    return secondary_.GetBlockBeginFastLocked(p);\n+  }\n+\n   uptr GetActuallyAllocatedSize(void *p) {\n     if (primary_.PointerIsMine(p))\n       return primary_.GetActuallyAllocatedSize(p);\n@@ -1155,6 +1293,13 @@ class CombinedAllocator {\n     primary_.ForceUnlock();\n   }\n \n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    primary_.ForEachChunk(callback, arg);\n+    secondary_.ForEachChunk(callback, arg);\n+  }\n+\n  private:\n   PrimaryAllocator primary_;\n   SecondaryAllocator secondary_;"}, {"sha": "c033b96e4ddea2cc8b9c92d9f9675570ca719f71", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,62 @@\n+//===-- sanitizer_allocator_internal.h -------------------------- C++ -----===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This allocator is used inside run-times.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ALLOCATOR_INTERNAL_H\n+#define SANITIZER_ALLOCATOR_INTERNAL_H\n+\n+#include \"sanitizer_allocator.h\"\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+\n+// FIXME: Check if we may use even more compact size class map for internal\n+// purposes.\n+typedef CompactSizeClassMap InternalSizeClassMap;\n+\n+static const uptr kInternalAllocatorSpace = 0;\n+#if SANITIZER_WORDSIZE == 32\n+static const u64 kInternalAllocatorSize = (1ULL << 32);\n+static const uptr kInternalAllocatorRegionSizeLog = 20;\n+#else\n+static const u64 kInternalAllocatorSize = (1ULL << 47);\n+static const uptr kInternalAllocatorRegionSizeLog = 24;\n+#endif\n+static const uptr kInternalAllocatorFlatByteMapSize =\n+    kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n+typedef SizeClassAllocator32<\n+    kInternalAllocatorSpace, kInternalAllocatorSize, 16, InternalSizeClassMap,\n+    kInternalAllocatorRegionSizeLog,\n+    FlatByteMap<kInternalAllocatorFlatByteMapSize> > PrimaryInternalAllocator;\n+\n+typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n+    InternalAllocatorCache;\n+\n+// We don't want our internal allocator to do any map/unmap operations.\n+struct CrashOnMapUnmap {\n+  void OnMap(uptr p, uptr size) const {\n+    RAW_CHECK_MSG(0, \"Unexpected mmap in InternalAllocator!\");\n+  }\n+  void OnUnmap(uptr p, uptr size) const {\n+    RAW_CHECK_MSG(0, \"Unexpected munmap in InternalAllocator!\");\n+  }\n+};\n+\n+typedef CombinedAllocator<PrimaryInternalAllocator, InternalAllocatorCache,\n+                          LargeMmapAllocator<CrashOnMapUnmap> >\n+    InternalAllocator;\n+\n+void *InternalAlloc(uptr size, InternalAllocatorCache *cache = 0);\n+void InternalFree(void *p, InternalAllocatorCache *cache = 0);\n+InternalAllocator *internal_allocator();\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ALLOCATOR_INTERNAL_H"}, {"sha": "88819e32a73705c6e58ac26a045f847ba7aa7c7a", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -39,7 +39,17 @@ INLINE typename T::Type atomic_load(\n       | memory_order_acquire | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));\n   typename T::Type v;\n-  // FIXME(dvyukov): 64-bit load is not atomic on 32-bits.\n+  // FIXME:\n+  // 64-bit atomic operations are not atomic on 32-bit platforms.\n+  // The implementation lacks necessary memory fences on ARM/PPC.\n+  // We would like to use compiler builtin atomic operations,\n+  // but they are mostly broken:\n+  // - they lead to vastly inefficient code generation\n+  // (http://llvm.org/bugs/show_bug.cgi?id=17281)\n+  // - 64-bit atomic operations are not implemented on x86_32\n+  // (http://llvm.org/bugs/show_bug.cgi?id=15034)\n+  // - they are not implemented on ARM\n+  // error: undefined reference to '__atomic_load_4'\n   if (mo == memory_order_relaxed) {\n     v = a->val_dont_use;\n   } else {\n@@ -55,7 +65,6 @@ INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_release\n       | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));\n-  // FIXME(dvyukov): 64-bit store is not atomic on 32-bits.\n   if (mo == memory_order_relaxed) {\n     a->val_dont_use = v;\n   } else {\n@@ -111,12 +120,14 @@ INLINE bool atomic_compare_exchange_strong(volatile T *a,\n \n template<typename T>\n INLINE bool atomic_compare_exchange_weak(volatile T *a,\n-                                           typename T::Type *cmp,\n-                                           typename T::Type xchg,\n-                                           memory_order mo) {\n+                                         typename T::Type *cmp,\n+                                         typename T::Type xchg,\n+                                         memory_order mo) {\n   return atomic_compare_exchange_strong(a, cmp, xchg, mo);\n }\n \n }  // namespace __sanitizer\n \n+#undef ATOMIC_ORDER\n+\n #endif  // SANITIZER_ATOMIC_CLANG_H"}, {"sha": "dac7c19199b97f5bf7fde211941e7cd2a360c4d8", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -132,6 +132,27 @@ INLINE u16 atomic_exchange(volatile atomic_uint16_t *a,\n   return v;\n }\n \n+INLINE bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n+                                           u8 *cmp,\n+                                           u8 xchgv,\n+                                           memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  u8 cmpv = *cmp;\n+  u8 prev;\n+  __asm {\n+    mov al, cmpv\n+    mov ecx, a\n+    mov dl, xchgv\n+    lock cmpxchg [ecx], dl\n+    mov prev, al\n+  }\n+  if (prev == cmpv)\n+    return true;\n+  *cmp = prev;\n+  return false;\n+}\n+\n INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n                                            uptr *cmp,\n                                            uptr xchg,\n@@ -147,9 +168,9 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n \n template<typename T>\n INLINE bool atomic_compare_exchange_weak(volatile T *a,\n-                                           typename T::Type *cmp,\n-                                           typename T::Type xchg,\n-                                           memory_order mo) {\n+                                         typename T::Type *cmp,\n+                                         typename T::Type xchg,\n+                                         memory_order mo) {\n   return atomic_compare_exchange_strong(a, cmp, xchg, mo);\n }\n "}, {"sha": "f689df421aa83ba3ec7d3b46b04958b1fb012c7d", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 46, "deletions": 81, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -15,6 +15,7 @@\n namespace __sanitizer {\n \n const char *SanitizerToolName = \"SanitizerTool\";\n+uptr SanitizerVerbosity = 0;\n \n uptr GetPageSizeCached() {\n   static uptr PageSize;\n@@ -23,22 +24,29 @@ uptr GetPageSizeCached() {\n   return PageSize;\n }\n \n-static bool log_to_file = false;  // Set to true by __sanitizer_set_report_path\n \n // By default, dump to stderr. If |log_to_file| is true and |report_fd_pid|\n // isn't equal to the current PID, try to obtain file descriptor by opening\n // file \"report_path_prefix.<PID>\".\n-static fd_t report_fd = kStderrFd;\n-static char report_path_prefix[4096];  // Set via __sanitizer_set_report_path.\n+fd_t report_fd = kStderrFd;\n+\n+// Set via __sanitizer_set_report_path.\n+bool log_to_file = false;\n+char report_path_prefix[sizeof(report_path_prefix)];\n+\n // PID of process that opened |report_fd|. If a fork() occurs, the PID of the\n // child thread will be different from |report_fd_pid|.\n-static int report_fd_pid = 0;\n+uptr report_fd_pid = 0;\n \n-static void (*DieCallback)(void);\n-void SetDieCallback(void (*callback)(void)) {\n+static DieCallbackType DieCallback;\n+void SetDieCallback(DieCallbackType callback) {\n   DieCallback = callback;\n }\n \n+DieCallbackType GetDieCallback() {\n+  return DieCallback;\n+}\n+\n void NORETURN Die() {\n   if (DieCallback) {\n     DieCallback();\n@@ -61,41 +69,6 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n   Die();\n }\n \n-static void MaybeOpenReportFile() {\n-  if (!log_to_file || (report_fd_pid == GetPid())) return;\n-  InternalScopedBuffer<char> report_path_full(4096);\n-  internal_snprintf(report_path_full.data(), report_path_full.size(),\n-                    \"%s.%d\", report_path_prefix, GetPid());\n-  fd_t fd = OpenFile(report_path_full.data(), true);\n-  if (fd == kInvalidFd) {\n-    report_fd = kStderrFd;\n-    log_to_file = false;\n-    Report(\"ERROR: Can't open file: %s\\n\", report_path_full.data());\n-    Die();\n-  }\n-  if (report_fd != kInvalidFd) {\n-    // We're in the child. Close the parent's log.\n-    internal_close(report_fd);\n-  }\n-  report_fd = fd;\n-  report_fd_pid = GetPid();\n-}\n-\n-bool PrintsToTty() {\n-  MaybeOpenReportFile();\n-  return internal_isatty(report_fd);\n-}\n-\n-void RawWrite(const char *buffer) {\n-  static const char *kRawWriteError = \"RawWrite can't output requested buffer!\";\n-  uptr length = (uptr)internal_strlen(buffer);\n-  MaybeOpenReportFile();\n-  if (length != internal_write(report_fd, buffer, length)) {\n-    internal_write(report_fd, kRawWriteError, internal_strlen(kRawWriteError));\n-    Die();\n-  }\n-}\n-\n uptr ReadFileToBuffer(const char *file_name, char **buff,\n                       uptr *buff_size, uptr max_len) {\n   uptr PageSize = GetPageSizeCached();\n@@ -105,8 +78,9 @@ uptr ReadFileToBuffer(const char *file_name, char **buff,\n   *buff_size = 0;\n   // The files we usually open are not seekable, so try different buffer sizes.\n   for (uptr size = kMinFileLen; size <= max_len; size *= 2) {\n-    fd_t fd = OpenFile(file_name, /*write*/ false);\n-    if (fd == kInvalidFd) return 0;\n+    uptr openrv = OpenFile(file_name, /*write*/ false);\n+    if (internal_iserror(openrv)) return 0;\n+    fd_t fd = openrv;\n     UnmapOrDie(*buff, *buff_size);\n     *buff = (char*)MmapOrDie(size, __FUNCTION__);\n     *buff_size = size;\n@@ -128,45 +102,15 @@ uptr ReadFileToBuffer(const char *file_name, char **buff,\n   return read_len;\n }\n \n-// We don't want to use std::sort to avoid including <algorithm>, as\n-// we may end up with two implementation of std::sort - one in instrumented\n-// code, and the other in runtime.\n-// qsort() from stdlib won't work as it calls malloc(), which results\n-// in deadlock in ASan allocator.\n-// We re-implement in-place sorting w/o recursion as straightforward heapsort.\n+typedef bool UptrComparisonFunction(const uptr &a, const uptr &b);\n+\n+template<class T>\n+static inline bool CompareLess(const T &a, const T &b) {\n+  return a < b;\n+}\n+\n void SortArray(uptr *array, uptr size) {\n-  if (size < 2)\n-    return;\n-  // Stage 1: insert elements to the heap.\n-  for (uptr i = 1; i < size; i++) {\n-    uptr j, p;\n-    for (j = i; j > 0; j = p) {\n-      p = (j - 1) / 2;\n-      if (array[j] > array[p])\n-        Swap(array[j], array[p]);\n-      else\n-        break;\n-    }\n-  }\n-  // Stage 2: swap largest element with the last one,\n-  // and sink the new top.\n-  for (uptr i = size - 1; i > 0; i--) {\n-    Swap(array[0], array[i]);\n-    uptr j, max_ind;\n-    for (j = 0; j < i; j = max_ind) {\n-      uptr left = 2 * j + 1;\n-      uptr right = 2 * j + 2;\n-      max_ind = j;\n-      if (left < i && array[left] > array[max_ind])\n-        max_ind = left;\n-      if (right < i && array[right] > array[max_ind])\n-        max_ind = right;\n-      if (max_ind != j)\n-        Swap(array[j], array[max_ind]);\n-      else\n-        break;\n-    }\n-  }\n+  InternalSort<uptr*, UptrComparisonFunction>(&array, size, CompareLess);\n }\n \n // We want to map a chunk of address space aligned to 'alignment'.\n@@ -200,6 +144,27 @@ void ReportErrorSummary(const char *error_type, const char *file,\n   __sanitizer_report_error_summary(buff.data());\n }\n \n+LoadedModule::LoadedModule(const char *module_name, uptr base_address) {\n+  full_name_ = internal_strdup(module_name);\n+  base_address_ = base_address;\n+  n_ranges_ = 0;\n+}\n+\n+void LoadedModule::addAddressRange(uptr beg, uptr end) {\n+  CHECK_LT(n_ranges_, kMaxNumberOfAddressRanges);\n+  ranges_[n_ranges_].beg = beg;\n+  ranges_[n_ranges_].end = end;\n+  n_ranges_++;\n+}\n+\n+bool LoadedModule::containsAddress(uptr address) const {\n+  for (uptr i = 0; i < n_ranges_; i++) {\n+    if (ranges_[i].beg <= address && address < ranges_[i].end)\n+      return true;\n+  }\n+  return false;\n+}\n+\n }  // namespace __sanitizer\n \n using namespace __sanitizer;  // NOLINT"}, {"sha": "417f71f987cd779e0653e766d32d53856ea91d92", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 183, "deletions": 12, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -15,6 +15,7 @@\n #define SANITIZER_COMMON_H\n \n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n #include \"sanitizer_mutex.h\"\n \n namespace __sanitizer {\n@@ -30,17 +31,22 @@ const uptr kCacheLineSize = 128;\n const uptr kCacheLineSize = 64;\n #endif\n \n+const uptr kMaxPathLength = 512;\n+\n extern const char *SanitizerToolName;  // Can be changed by the tool.\n+extern uptr SanitizerVerbosity;\n \n uptr GetPageSize();\n uptr GetPageSizeCached();\n uptr GetMmapGranularity();\n+uptr GetMaxVirtualAddress();\n // Threads\n-int GetPid();\n uptr GetTid();\n uptr GetThreadSelf();\n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                 uptr *stack_bottom);\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size);\n \n // Memory management\n void *MmapOrDie(uptr size, const char *mem_type);\n@@ -54,10 +60,6 @@ void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type);\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n void FlushUnneededShadowMemory(uptr addr, uptr size);\n \n-// Internal allocator\n-void *InternalAlloc(uptr size);\n-void InternalFree(void *p);\n-\n // InternalScopedBuffer can be used instead of large stack arrays to\n // keep frame size low.\n // FIXME: use InternalAlloc instead of MmapOrDie once\n@@ -103,13 +105,20 @@ void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback);\n // IO\n void RawWrite(const char *buffer);\n bool PrintsToTty();\n+// Caching version of PrintsToTty(). Not thread-safe.\n+bool PrintsToTtyCached();\n void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n // Can be used to prevent mixing error reports from different sanitizers.\n extern StaticSpinMutex CommonSanitizerReportMutex;\n+void MaybeOpenReportFile();\n+extern fd_t report_fd;\n+extern bool log_to_file;\n+extern char report_path_prefix[4096];\n+extern uptr report_fd_pid;\n \n-fd_t OpenFile(const char *filename, bool write);\n+uptr OpenFile(const char *filename, bool write);\n // Opens the file 'file_name\" and reads up to 'max_len' bytes.\n // The resulting buffer is mmaped and stored in '*buff'.\n // The size of the mmaped region is stored in '*buff_size',\n@@ -126,23 +135,29 @@ void DisableCoreDumper();\n void DumpProcessMap();\n bool FileExists(const char *filename);\n const char *GetEnv(const char *name);\n+bool SetEnv(const char *name, const char *value);\n const char *GetPwd();\n+char *FindPathToBinary(const char *name);\n u32 GetUid();\n void ReExec();\n bool StackSizeIsUnlimited();\n void SetStackSizeLimitInBytes(uptr limit);\n void PrepareForSandboxing();\n \n+void InitTlsSize();\n+uptr GetTlsSize();\n+\n // Other\n void SleepForSeconds(int seconds);\n void SleepForMillis(int millis);\n+u64 NanoTime();\n int Atexit(void (*function)(void));\n void SortArray(uptr *array, uptr size);\n \n // Exit\n void NORETURN Abort();\n void NORETURN Die();\n-void NORETURN SANITIZER_INTERFACE_ATTRIBUTE\n+void NORETURN\n CheckFailed(const char *file, int line, const char *cond, u64 v1, u64 v2);\n \n // Set the name of the current thread to 'name', return true on succees.\n@@ -154,7 +169,9 @@ bool SanitizerGetThreadName(char *name, int max_len);\n \n // Specific tools may override behavior of \"Die\" and \"CheckFailed\" functions\n // to do tool-specific job.\n-void SetDieCallback(void (*callback)(void));\n+typedef void (*DieCallbackType)(void);\n+void SetDieCallback(DieCallbackType);\n+DieCallbackType GetDieCallback();\n typedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n                                        u64, u64);\n void SetCheckFailedCallback(CheckFailedCallbackType callback);\n@@ -166,7 +183,7 @@ void ReportErrorSummary(const char *error_type, const char *file,\n                         int line, const char *function);\n \n // Math\n-#if defined(_WIN32) && !defined(__clang__)\n+#if SANITIZER_WINDOWS && !defined(__clang__) && !defined(__GNUC__)\n extern \"C\" {\n unsigned char _BitScanForward(unsigned long *index, unsigned long mask);  // NOLINT\n unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);  // NOLINT\n@@ -178,9 +195,9 @@ unsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);  /\n #endif\n \n INLINE uptr MostSignificantSetBitIndex(uptr x) {\n-  CHECK(x != 0);\n+  CHECK_NE(x, 0U);\n   unsigned long up;  // NOLINT\n-#if !defined(_WIN32) || defined(__clang__)\n+#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n   up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);\n #elif defined(_WIN64)\n   _BitScanReverse64(&up, x);\n@@ -219,7 +236,7 @@ INLINE bool IsAligned(uptr a, uptr alignment) {\n \n INLINE uptr Log2(uptr x) {\n   CHECK(IsPowerOfTwo(x));\n-#if !defined(_WIN32) || defined(__clang__)\n+#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n   return __builtin_ctzl(x);\n #elif defined(_WIN64)\n   unsigned long ret;  // NOLINT\n@@ -260,6 +277,160 @@ INLINE int ToLower(int c) {\n # define FIRST_32_SECOND_64(a, b) (a)\n #endif\n \n+// A low-level vector based on mmap. May incur a significant memory overhead for\n+// small vectors.\n+// WARNING: The current implementation supports only POD types.\n+template<typename T>\n+class InternalMmapVector {\n+ public:\n+  explicit InternalMmapVector(uptr initial_capacity) {\n+    CHECK_GT(initial_capacity, 0);\n+    capacity_ = initial_capacity;\n+    size_ = 0;\n+    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), \"InternalMmapVector\");\n+  }\n+  ~InternalMmapVector() {\n+    UnmapOrDie(data_, capacity_ * sizeof(T));\n+  }\n+  T &operator[](uptr i) {\n+    CHECK_LT(i, size_);\n+    return data_[i];\n+  }\n+  const T &operator[](uptr i) const {\n+    CHECK_LT(i, size_);\n+    return data_[i];\n+  }\n+  void push_back(const T &element) {\n+    CHECK_LE(size_, capacity_);\n+    if (size_ == capacity_) {\n+      uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);\n+      Resize(new_capacity);\n+    }\n+    data_[size_++] = element;\n+  }\n+  T &back() {\n+    CHECK_GT(size_, 0);\n+    return data_[size_ - 1];\n+  }\n+  void pop_back() {\n+    CHECK_GT(size_, 0);\n+    size_--;\n+  }\n+  uptr size() const {\n+    return size_;\n+  }\n+  const T *data() const {\n+    return data_;\n+  }\n+  uptr capacity() const {\n+    return capacity_;\n+  }\n+\n+ private:\n+  void Resize(uptr new_capacity) {\n+    CHECK_GT(new_capacity, 0);\n+    CHECK_LE(size_, new_capacity);\n+    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),\n+                                 \"InternalMmapVector\");\n+    internal_memcpy(new_data, data_, size_ * sizeof(T));\n+    T *old_data = data_;\n+    data_ = new_data;\n+    UnmapOrDie(old_data, capacity_ * sizeof(T));\n+    capacity_ = new_capacity;\n+  }\n+  // Disallow evil constructors.\n+  InternalMmapVector(const InternalMmapVector&);\n+  void operator=(const InternalMmapVector&);\n+\n+  T *data_;\n+  uptr capacity_;\n+  uptr size_;\n+};\n+\n+// HeapSort for arrays and InternalMmapVector.\n+template<class Container, class Compare>\n+void InternalSort(Container *v, uptr size, Compare comp) {\n+  if (size < 2)\n+    return;\n+  // Stage 1: insert elements to the heap.\n+  for (uptr i = 1; i < size; i++) {\n+    uptr j, p;\n+    for (j = i; j > 0; j = p) {\n+      p = (j - 1) / 2;\n+      if (comp((*v)[p], (*v)[j]))\n+        Swap((*v)[j], (*v)[p]);\n+      else\n+        break;\n+    }\n+  }\n+  // Stage 2: swap largest element with the last one,\n+  // and sink the new top.\n+  for (uptr i = size - 1; i > 0; i--) {\n+    Swap((*v)[0], (*v)[i]);\n+    uptr j, max_ind;\n+    for (j = 0; j < i; j = max_ind) {\n+      uptr left = 2 * j + 1;\n+      uptr right = 2 * j + 2;\n+      max_ind = j;\n+      if (left < i && comp((*v)[max_ind], (*v)[left]))\n+        max_ind = left;\n+      if (right < i && comp((*v)[max_ind], (*v)[right]))\n+        max_ind = right;\n+      if (max_ind != j)\n+        Swap((*v)[j], (*v)[max_ind]);\n+      else\n+        break;\n+    }\n+  }\n+}\n+\n+template<class Container, class Value, class Compare>\n+uptr InternalBinarySearch(const Container &v, uptr first, uptr last,\n+                          const Value &val, Compare comp) {\n+  uptr not_found = last + 1;\n+  while (last >= first) {\n+    uptr mid = (first + last) / 2;\n+    if (comp(v[mid], val))\n+      first = mid + 1;\n+    else if (comp(val, v[mid]))\n+      last = mid - 1;\n+    else\n+      return mid;\n+  }\n+  return not_found;\n+}\n+\n+// Represents a binary loaded into virtual memory (e.g. this can be an\n+// executable or a shared object).\n+class LoadedModule {\n+ public:\n+  LoadedModule(const char *module_name, uptr base_address);\n+  void addAddressRange(uptr beg, uptr end);\n+  bool containsAddress(uptr address) const;\n+\n+  const char *full_name() const { return full_name_; }\n+  uptr base_address() const { return base_address_; }\n+\n+ private:\n+  struct AddressRange {\n+    uptr beg;\n+    uptr end;\n+  };\n+  char *full_name_;\n+  uptr base_address_;\n+  static const uptr kMaxNumberOfAddressRanges = 6;\n+  AddressRange ranges_[kMaxNumberOfAddressRanges];\n+  uptr n_ranges_;\n+};\n+\n+// OS-dependent function that fills array with descriptions of at most\n+// \"max_modules\" currently loaded modules. Returns the number of\n+// initialized modules. If filter is nonzero, ignores modules for which\n+// filter(full_name) is false.\n+typedef bool (*string_predicate_t)(const char *);\n+uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n+                      string_predicate_t filter);\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_COMMON_H"}, {"sha": "17ef72e0c98cf693a263ccbfc39548ac14b70b82", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 1909, "deletions": 25, "changes": 1934, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -22,10 +22,157 @@\n \n #include <stdarg.h>\n \n-#ifdef _WIN32\n+#if SANITIZER_WINDOWS\n #define va_copy(dst, src) ((dst) = (src))\n #endif // _WIN32\n \n+#if SANITIZER_INTERCEPT_STRCMP\n+static inline int CharCmpX(unsigned char c1, unsigned char c2) {\n+  return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n+}\n+\n+INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strcmp, s1, s2);\n+  unsigned char c1, c2;\n+  uptr i;\n+  for (i = 0; ; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (c1 != c2 || c1 == '\\0') break;\n+  }\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, i + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, i + 1);\n+  return CharCmpX(c1, c2);\n+}\n+\n+INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strncmp, s1, s2, size);\n+  unsigned char c1 = 0, c2 = 0;\n+  uptr i;\n+  for (i = 0; i < size; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (c1 != c2 || c1 == '\\0') break;\n+  }\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, size));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, size));\n+  return CharCmpX(c1, c2);\n+}\n+\n+#define INIT_STRCMP INTERCEPT_FUNCTION(strcmp)\n+#define INIT_STRNCMP INTERCEPT_FUNCTION(strncmp)\n+#else\n+#define INIT_STRCMP\n+#define INIT_STRNCMP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRCASECMP\n+static inline int CharCaseCmp(unsigned char c1, unsigned char c2) {\n+  int c1_low = ToLower(c1);\n+  int c2_low = ToLower(c2);\n+  return c1_low - c2_low;\n+}\n+\n+INTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strcasecmp, s1, s2);\n+  unsigned char c1 = 0, c2 = 0;\n+  uptr i;\n+  for (i = 0; ; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0')\n+      break;\n+  }\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, i + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, i + 1);\n+  return CharCaseCmp(c1, c2);\n+}\n+\n+INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T n) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strncasecmp, s1, s2, n);\n+  unsigned char c1 = 0, c2 = 0;\n+  uptr i;\n+  for (i = 0; i < n; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0')\n+      break;\n+  }\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, n));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, n));\n+  return CharCaseCmp(c1, c2);\n+}\n+\n+#define INIT_STRCASECMP INTERCEPT_FUNCTION(strcasecmp)\n+#define INIT_STRNCASECMP INTERCEPT_FUNCTION(strncasecmp)\n+#else\n+#define INIT_STRCASECMP\n+#define INIT_STRNCASECMP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FREXP\n+INTERCEPTOR(double, frexp, double x, int *exp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, frexp, x, exp);\n+  double res = REAL(frexp)(x, exp);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n+  return res;\n+}\n+\n+#define INIT_FREXP INTERCEPT_FUNCTION(frexp);\n+#else\n+#define INIT_FREXP\n+#endif // SANITIZER_INTERCEPT_FREXP\n+\n+#if SANITIZER_INTERCEPT_FREXPF_FREXPL\n+INTERCEPTOR(float, frexpf, float x, int *exp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, frexpf, x, exp);\n+  float res = REAL(frexpf)(x, exp);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n+  return res;\n+}\n+\n+INTERCEPTOR(long double, frexpl, long double x, int *exp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, frexpl, x, exp);\n+  long double res = REAL(frexpl)(x, exp);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n+  return res;\n+}\n+\n+#define INIT_FREXPF_FREXPL                       \\\n+  INTERCEPT_FUNCTION(frexpf);                    \\\n+  INTERCEPT_FUNCTION(frexpl)\n+#else\n+#define INIT_FREXPF_FREXPL\n+#endif // SANITIZER_INTERCEPT_FREXPF_FREXPL\n+\n+#if SI_NOT_WINDOWS\n+static void write_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n+                        SIZE_T iovlen, SIZE_T maxlen) {\n+  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n+    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iovec[i].iov_base, sz);\n+    maxlen -= sz;\n+  }\n+}\n+\n+static void read_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n+                       SIZE_T iovlen, SIZE_T maxlen) {\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec, sizeof(*iovec) * iovlen);\n+  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n+    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec[i].iov_base, sz);\n+    maxlen -= sz;\n+  }\n+}\n+#endif\n+\n #if SANITIZER_INTERCEPT_READ\n INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n   void *ctx;\n@@ -74,13 +221,59 @@ INTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n #define INIT_PREAD64\n #endif\n \n+#if SANITIZER_INTERCEPT_READV\n+INTERCEPTOR_WITH_SUFFIX(SSIZE_T, readv, int fd, __sanitizer_iovec *iov,\n+                        int iovcnt) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, readv, fd, iov, iovcnt);\n+  SSIZE_T res = REAL(readv)(fd, iov, iovcnt);\n+  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n+  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  return res;\n+}\n+#define INIT_READV INTERCEPT_FUNCTION(readv)\n+#else\n+#define INIT_READV\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PREADV\n+INTERCEPTOR(SSIZE_T, preadv, int fd, __sanitizer_iovec *iov, int iovcnt,\n+            OFF_T offset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, preadv, fd, iov, iovcnt, offset);\n+  SSIZE_T res = REAL(preadv)(fd, iov, iovcnt, offset);\n+  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n+  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  return res;\n+}\n+#define INIT_PREADV INTERCEPT_FUNCTION(preadv)\n+#else\n+#define INIT_PREADV\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PREADV64\n+INTERCEPTOR(SSIZE_T, preadv64, int fd, __sanitizer_iovec *iov, int iovcnt,\n+            OFF64_T offset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, preadv64, fd, iov, iovcnt, offset);\n+  SSIZE_T res = REAL(preadv64)(fd, iov, iovcnt, offset);\n+  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n+  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  return res;\n+}\n+#define INIT_PREADV64 INTERCEPT_FUNCTION(preadv64)\n+#else\n+#define INIT_PREADV64\n+#endif\n+\n #if SANITIZER_INTERCEPT_WRITE\n INTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, write, fd, ptr, count);\n   if (fd >= 0)\n     COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   SSIZE_T res = REAL(write)(fd, ptr, count);\n+  // FIXME: this check should be _before_ the call to REAL(write), not after\n   if (res > 0)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n   return res;\n@@ -123,6 +316,51 @@ INTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count,\n #define INIT_PWRITE64\n #endif\n \n+#if SANITIZER_INTERCEPT_WRITEV\n+INTERCEPTOR_WITH_SUFFIX(SSIZE_T, writev, int fd, __sanitizer_iovec *iov,\n+                        int iovcnt) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, writev, fd, iov, iovcnt);\n+  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  SSIZE_T res = REAL(writev)(fd, iov, iovcnt);\n+  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n+  return res;\n+}\n+#define INIT_WRITEV INTERCEPT_FUNCTION(writev)\n+#else\n+#define INIT_WRITEV\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PWRITEV\n+INTERCEPTOR(SSIZE_T, pwritev, int fd, __sanitizer_iovec *iov, int iovcnt,\n+            OFF_T offset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pwritev, fd, iov, iovcnt, offset);\n+  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  SSIZE_T res = REAL(pwritev)(fd, iov, iovcnt, offset);\n+  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n+  return res;\n+}\n+#define INIT_PWRITEV INTERCEPT_FUNCTION(pwritev)\n+#else\n+#define INIT_PWRITEV\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PWRITEV64\n+INTERCEPTOR(SSIZE_T, pwritev64, int fd, __sanitizer_iovec *iov, int iovcnt,\n+            OFF64_T offset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pwritev64, fd, iov, iovcnt, offset);\n+  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  SSIZE_T res = REAL(pwritev64)(fd, iov, iovcnt, offset);\n+  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n+  return res;\n+}\n+#define INIT_PWRITEV64 INTERCEPT_FUNCTION(pwritev64)\n+#else\n+#define INIT_PWRITEV64\n+#endif\n+\n #if SANITIZER_INTERCEPT_PRCTL\n INTERCEPTOR(int, prctl, int option,\n             unsigned long arg2, unsigned long arg3,   // NOLINT\n@@ -144,6 +382,24 @@ INTERCEPTOR(int, prctl, int option,\n #define INIT_PRCTL\n #endif // SANITIZER_INTERCEPT_PRCTL\n \n+\n+#if SANITIZER_INTERCEPT_TIME\n+INTERCEPTOR(unsigned long, time, unsigned long *t) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, time, t);\n+  unsigned long res = REAL(time)(t);\n+  if (t && res != (unsigned long)-1) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, t, sizeof(*t));\n+  }\n+  return res;\n+}\n+#define INIT_TIME                                \\\n+  INTERCEPT_FUNCTION(time);\n+#else\n+#define INIT_TIME\n+#endif // SANITIZER_INTERCEPT_TIME\n+\n+\n #if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n INTERCEPTOR(void *, localtime, unsigned long *timep) {\n   void *ctx;\n@@ -279,9 +535,9 @@ VSCANF_INTERCEPTOR_IMPL(__isoc99_vfscanf, false, stream, format, ap)\n #define SCANF_INTERCEPTOR_IMPL(name, vname, ...)                               \\\n   {                                                                            \\\n     void *ctx;                                                                 \\\n-    COMMON_INTERCEPTOR_ENTER(ctx, name, __VA_ARGS__);                          \\\n     va_list ap;                                                                \\\n     va_start(ap, format);                                                      \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__, ap);                     \\\n     int res = vname(__VA_ARGS__, ap);                                          \\\n     va_end(ap);                                                                \\\n     return res;                                                                \\\n@@ -307,31 +563,1659 @@ INTERCEPTOR(int, __isoc99_sscanf, const char *str, const char *format, ...)\n SCANF_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n #endif\n \n-#define INIT_SCANF                                                             \\\n-  INTERCEPT_FUNCTION(scanf);                                                   \\\n-  INTERCEPT_FUNCTION(sscanf);                                                  \\\n-  INTERCEPT_FUNCTION(fscanf);                                                  \\\n-  INTERCEPT_FUNCTION(vscanf);                                                  \\\n-  INTERCEPT_FUNCTION(vsscanf);                                                 \\\n-  INTERCEPT_FUNCTION(vfscanf);                                                 \\\n-  INTERCEPT_FUNCTION(__isoc99_scanf);                                          \\\n-  INTERCEPT_FUNCTION(__isoc99_sscanf);                                         \\\n-  INTERCEPT_FUNCTION(__isoc99_fscanf);                                         \\\n-  INTERCEPT_FUNCTION(__isoc99_vscanf);                                         \\\n-  INTERCEPT_FUNCTION(__isoc99_vsscanf);                                        \\\n-  INTERCEPT_FUNCTION(__isoc99_vfscanf);\n+#endif\n \n+#if SANITIZER_INTERCEPT_SCANF\n+#define INIT_SCANF             \\\n+  INTERCEPT_FUNCTION(scanf);   \\\n+  INTERCEPT_FUNCTION(sscanf);  \\\n+  INTERCEPT_FUNCTION(fscanf);  \\\n+  INTERCEPT_FUNCTION(vscanf);  \\\n+  INTERCEPT_FUNCTION(vsscanf); \\\n+  INTERCEPT_FUNCTION(vfscanf);\n #else\n #define INIT_SCANF\n #endif\n \n-#define SANITIZER_COMMON_INTERCEPTORS_INIT                                     \\\n-  INIT_READ;                                                                   \\\n-  INIT_PREAD;                                                                  \\\n-  INIT_PREAD64;                                                                \\\n-  INIT_PRCTL;                                                                  \\\n-  INIT_WRITE;                                                                  \\\n-  INIT_PWRITE;                                                                 \\\n-  INIT_PWRITE64;                                                               \\\n-  INIT_LOCALTIME_AND_FRIENDS;                                                  \\\n-  INIT_SCANF;\n+#if SANITIZER_INTERCEPT_ISOC99_SCANF\n+#define INIT_ISOC99_SCANF               \\\n+  INTERCEPT_FUNCTION(__isoc99_scanf);   \\\n+  INTERCEPT_FUNCTION(__isoc99_sscanf);  \\\n+  INTERCEPT_FUNCTION(__isoc99_fscanf);  \\\n+  INTERCEPT_FUNCTION(__isoc99_vscanf);  \\\n+  INTERCEPT_FUNCTION(__isoc99_vsscanf); \\\n+  INTERCEPT_FUNCTION(__isoc99_vfscanf);\n+#else\n+#define INIT_ISOC99_SCANF\n+#endif\n+\n+#if SANITIZER_INTERCEPT_IOCTL\n+#include \"sanitizer_common_interceptors_ioctl.inc\"\n+INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ioctl, d, request, arg);\n+\n+  CHECK(ioctl_initialized);\n+\n+  // Note: TSan does not use common flags, and they are zero-initialized.\n+  // This effectively disables ioctl handling in TSan.\n+  if (!common_flags()->handle_ioctl)\n+    return REAL(ioctl)(d, request, arg);\n+\n+  const ioctl_desc *desc = ioctl_lookup(request);\n+  if (!desc)\n+    Printf(\"WARNING: unknown ioctl %x\\n\", request);\n+\n+  if (desc)\n+    ioctl_common_pre(ctx, desc, d, request, arg);\n+  int res = REAL(ioctl)(d, request, arg);\n+  // FIXME: some ioctls have different return values for success and failure.\n+  if (desc && res != -1)\n+    ioctl_common_post(ctx, desc, res, d, request, arg);\n+  return res;\n+}\n+#define INIT_IOCTL \\\n+  ioctl_init();    \\\n+  INTERCEPT_FUNCTION(ioctl);\n+#else\n+#define INIT_IOCTL\n+#endif\n+\n+\n+#if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\n+INTERCEPTOR(void *, getpwnam, const char *name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpwnam, name);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  void *res = REAL(getpwnam)(name);\n+  if (res != 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n+  return res;\n+}\n+INTERCEPTOR(void *, getpwuid, u32 uid) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpwuid, uid);\n+  void *res = REAL(getpwuid)(uid);\n+  if (res != 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n+  return res;\n+}\n+INTERCEPTOR(void *, getgrnam, const char *name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgrnam, name);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  void *res = REAL(getgrnam)(name);\n+  if (res != 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n+  return res;\n+}\n+INTERCEPTOR(void *, getgrgid, u32 gid) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgrgid, gid);\n+  void *res = REAL(getgrgid)(gid);\n+  if (res != 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n+  return res;\n+}\n+#define INIT_GETPWNAM_AND_FRIENDS                  \\\n+  INTERCEPT_FUNCTION(getpwnam);                    \\\n+  INTERCEPT_FUNCTION(getpwuid);                    \\\n+  INTERCEPT_FUNCTION(getgrnam);                    \\\n+  INTERCEPT_FUNCTION(getgrgid);\n+#else\n+#define INIT_GETPWNAM_AND_FRIENDS\n+#endif\n+\n+\n+#if SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n+INTERCEPTOR(int, getpwnam_r, const char *name, void *pwd,\n+    char *buf, SIZE_T buflen, void **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpwnam_r, name, pwd, buf, buflen, result);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  int res = REAL(getpwnam_r)(name, pwd, buf, buflen, result);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, struct_passwd_sz);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, getpwuid_r, u32 uid, void *pwd,\n+    char *buf, SIZE_T buflen, void **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpwuid_r, uid, pwd, buf, buflen, result);\n+  int res = REAL(getpwuid_r)(uid, pwd, buf, buflen, result);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, struct_passwd_sz);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, getgrnam_r, const char *name, void *grp,\n+    char *buf, SIZE_T buflen, void **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgrnam_r, name, grp, buf, buflen, result);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  int res = REAL(getgrnam_r)(name, grp, buf, buflen, result);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp, struct_group_sz);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, getgrgid_r, u32 gid, void *grp,\n+    char *buf, SIZE_T buflen, void **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgrgid_r, gid, grp, buf, buflen, result);\n+  int res = REAL(getgrgid_r)(gid, grp, buf, buflen, result);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp, struct_group_sz);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  return res;\n+}\n+#define INIT_GETPWNAM_R_AND_FRIENDS                \\\n+  INTERCEPT_FUNCTION(getpwnam_r);                  \\\n+  INTERCEPT_FUNCTION(getpwuid_r);                  \\\n+  INTERCEPT_FUNCTION(getgrnam_r);                  \\\n+  INTERCEPT_FUNCTION(getgrgid_r);\n+#else\n+#define INIT_GETPWNAM_R_AND_FRIENDS\n+#endif\n+\n+\n+#if SANITIZER_INTERCEPT_CLOCK_GETTIME\n+INTERCEPTOR(int, clock_getres, u32 clk_id, void *tp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, clock_getres, clk_id, tp);\n+  int res = REAL(clock_getres)(clk_id, tp);\n+  if (!res && tp) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, clock_gettime, u32 clk_id, void *tp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, clock_gettime, clk_id, tp);\n+  int res = REAL(clock_gettime)(clk_id, tp);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, clock_settime, clk_id, tp);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, tp, struct_timespec_sz);\n+  return REAL(clock_settime)(clk_id, tp);\n+}\n+#define INIT_CLOCK_GETTIME                         \\\n+  INTERCEPT_FUNCTION(clock_getres);                \\\n+  INTERCEPT_FUNCTION(clock_gettime);               \\\n+  INTERCEPT_FUNCTION(clock_settime);\n+#else\n+#define INIT_CLOCK_GETTIME\n+#endif\n+\n+\n+#if SANITIZER_INTERCEPT_GETITIMER\n+INTERCEPTOR(int, getitimer, int which, void *curr_value) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getitimer, which, curr_value);\n+  int res = REAL(getitimer)(which, curr_value);\n+  if (!res && curr_value) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, curr_value, struct_itimerval_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, setitimer, int which, const void *new_value, void *old_value) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, setitimer, which, new_value, old_value);\n+  if (new_value)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, new_value, struct_itimerval_sz);\n+  int res = REAL(setitimer)(which, new_value, old_value);\n+  if (!res && old_value) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, old_value, struct_itimerval_sz);\n+  }\n+  return res;\n+}\n+#define INIT_GETITIMER                             \\\n+  INTERCEPT_FUNCTION(getitimer);                   \\\n+  INTERCEPT_FUNCTION(setitimer);\n+#else\n+#define INIT_GETITIMER\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GLOB\n+static void unpoison_glob_t(void *ctx, __sanitizer_glob_t *pglob) {\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pglob, sizeof(*pglob));\n+  // +1 for NULL pointer at the end.\n+  if (pglob->gl_pathv)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(\n+        ctx, pglob->gl_pathv, (pglob->gl_pathc + 1) * sizeof(*pglob->gl_pathv));\n+  for (SIZE_T i = 0; i < pglob->gl_pathc; ++i) {\n+    char *p = pglob->gl_pathv[i];\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, REAL(strlen)(p) + 1);\n+  }\n+}\n+\n+static THREADLOCAL __sanitizer_glob_t* pglob_copy;\n+static THREADLOCAL void* glob_ctx;\n+\n+static void wrapped_gl_closedir(void *dir) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 1);\n+  pglob_copy->gl_closedir(dir);\n+}\n+\n+static void *wrapped_gl_readdir(void *dir) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 1);\n+  return pglob_copy->gl_readdir(dir);\n+}\n+\n+static void *wrapped_gl_opendir(const char *s) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 1);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(glob_ctx, s, REAL(strlen)(s) + 1);\n+  return pglob_copy->gl_opendir(s);\n+}\n+\n+static int wrapped_gl_lstat(const char *s, void *st) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 2);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(glob_ctx, s, REAL(strlen)(s) + 1);\n+  return pglob_copy->gl_lstat(s, st);\n+}\n+\n+static int wrapped_gl_stat(const char *s, void *st) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 2);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(glob_ctx, s, REAL(strlen)(s) + 1);\n+  return pglob_copy->gl_stat(s, st);\n+}\n+\n+INTERCEPTOR(int, glob, const char *pattern, int flags,\n+            int (*errfunc)(const char *epath, int eerrno),\n+            __sanitizer_glob_t *pglob) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, glob, pattern, flags, errfunc, pglob);\n+  __sanitizer_glob_t glob_copy = {0, 0, 0, 0, wrapped_gl_closedir,\n+                                  wrapped_gl_readdir, wrapped_gl_opendir,\n+                                  wrapped_gl_lstat, wrapped_gl_stat};\n+  if (flags & glob_altdirfunc) {\n+    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n+    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n+    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n+    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n+    Swap(pglob->gl_stat, glob_copy.gl_stat);\n+    pglob_copy = &glob_copy;\n+    glob_ctx = ctx;\n+  }\n+  int res = REAL(glob)(pattern, flags, errfunc, pglob);\n+  if (flags & glob_altdirfunc) {\n+    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n+    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n+    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n+    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n+    Swap(pglob->gl_stat, glob_copy.gl_stat);\n+  }\n+  pglob_copy = 0;\n+  glob_ctx = 0;\n+  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, glob64, const char *pattern, int flags,\n+            int (*errfunc)(const char *epath, int eerrno),\n+            __sanitizer_glob_t *pglob) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, glob64, pattern, flags, errfunc, pglob);\n+  __sanitizer_glob_t glob_copy = {0, 0, 0, 0, wrapped_gl_closedir,\n+                                  wrapped_gl_readdir, wrapped_gl_opendir,\n+                                  wrapped_gl_lstat, wrapped_gl_stat};\n+  if (flags & glob_altdirfunc) {\n+    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n+    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n+    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n+    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n+    Swap(pglob->gl_stat, glob_copy.gl_stat);\n+    pglob_copy = &glob_copy;\n+    glob_ctx = ctx;\n+  }\n+  int res = REAL(glob64)(pattern, flags, errfunc, pglob);\n+  if (flags & glob_altdirfunc) {\n+    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n+    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n+    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n+    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n+    Swap(pglob->gl_stat, glob_copy.gl_stat);\n+  }\n+  pglob_copy = 0;\n+  glob_ctx = 0;\n+  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n+  return res;\n+}\n+#define INIT_GLOB           \\\n+  INTERCEPT_FUNCTION(glob); \\\n+  INTERCEPT_FUNCTION(glob64);\n+#else  // SANITIZER_INTERCEPT_GLOB\n+#define INIT_GLOB\n+#endif  // SANITIZER_INTERCEPT_GLOB\n+\n+#if SANITIZER_INTERCEPT_WAIT\n+// According to sys/wait.h, wait(), waitid(), waitpid() may have symbol version\n+// suffixes on Darwin. See the declaration of INTERCEPTOR_WITH_SUFFIX for\n+// details.\n+INTERCEPTOR_WITH_SUFFIX(int, wait, int *status) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wait, status);\n+  int res = REAL(wait)(status);\n+  if (res != -1 && status)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n+  return res;\n+}\n+INTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, int id, void *infop,\n+  int options) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, waitid, idtype, id, infop, options);\n+  int res = REAL(waitid)(idtype, id, infop, options);\n+  if (res != -1 && infop)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, infop, siginfo_t_sz);\n+  return res;\n+}\n+INTERCEPTOR_WITH_SUFFIX(int, waitpid, int pid, int *status, int options) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, waitpid, pid, status, options);\n+  int res = REAL(waitpid)(pid, status, options);\n+  if (res != -1 && status)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n+  return res;\n+}\n+INTERCEPTOR(int, wait3, int *status, int options, void *rusage) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wait3, status, options, rusage);\n+  int res = REAL(wait3)(status, options, rusage);\n+  if (res != -1) {\n+    if (status)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n+    if (rusage)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, wait4, int pid, int *status, int options, void *rusage) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wait4, pid, status, options, rusage);\n+  int res = REAL(wait4)(pid, status, options, rusage);\n+  if (res != -1) {\n+    if (status)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n+    if (rusage)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n+  }\n+  return res;\n+}\n+#define INIT_WAIT                                \\\n+  INTERCEPT_FUNCTION(wait);                      \\\n+  INTERCEPT_FUNCTION(waitid);                    \\\n+  INTERCEPT_FUNCTION(waitpid);                   \\\n+  INTERCEPT_FUNCTION(wait3);                     \\\n+  INTERCEPT_FUNCTION(wait4);\n+#else\n+#define INIT_WAIT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_INET\n+INTERCEPTOR(char *, inet_ntop, int af, const void *src, char *dst, u32 size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, inet_ntop, af, src, dst, size);\n+  uptr sz = __sanitizer_in_addr_sz(af);\n+  if (sz) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sz);\n+  // FIXME: figure out read size based on the address family.\n+  char *res = REAL(inet_ntop)(af, src, dst, size);\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+INTERCEPTOR(int, inet_pton, int af, const char *src, void *dst) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, inet_pton, af, src, dst);\n+  // FIXME: figure out read size based on the address family.\n+  int res = REAL(inet_pton)(af, src, dst);\n+  if (res == 1) {\n+    uptr sz = __sanitizer_in_addr_sz(af);\n+    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sz);\n+  }\n+  return res;\n+}\n+#define INIT_INET                                \\\n+  INTERCEPT_FUNCTION(inet_ntop);                 \\\n+  INTERCEPT_FUNCTION(inet_pton);\n+#else\n+#define INIT_INET\n+#endif\n+\n+#if SANITIZER_INTERCEPT_INET\n+INTERCEPTOR(int, inet_aton, const char *cp, void *dst) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, inet_aton, cp, dst);\n+  if (cp) COMMON_INTERCEPTOR_READ_RANGE(ctx, cp, REAL(strlen)(cp) + 1);\n+  int res = REAL(inet_aton)(cp, dst);\n+  if (res != 0) {\n+    uptr sz = __sanitizer_in_addr_sz(af_inet);\n+    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sz);\n+  }\n+  return res;\n+}\n+#define INIT_INET_ATON INTERCEPT_FUNCTION(inet_aton);\n+#else\n+#define INIT_INET_ATON\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM\n+INTERCEPTOR(int, pthread_getschedparam, uptr thread, int *policy, int *param) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_getschedparam, thread, policy, param);\n+  int res = REAL(pthread_getschedparam)(thread, policy, param);\n+  if (res == 0) {\n+    if (policy) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, policy, sizeof(*policy));\n+    if (param) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, param, sizeof(*param));\n+  }\n+  return res;\n+}\n+#define INIT_PTHREAD_GETSCHEDPARAM INTERCEPT_FUNCTION(pthread_getschedparam);\n+#else\n+#define INIT_PTHREAD_GETSCHEDPARAM\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETADDRINFO\n+INTERCEPTOR(int, getaddrinfo, char *node, char *service,\n+            struct __sanitizer_addrinfo *hints,\n+            struct __sanitizer_addrinfo **out) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getaddrinfo, node, service, hints, out);\n+  if (node) COMMON_INTERCEPTOR_READ_RANGE(ctx, node, REAL(strlen)(node) + 1);\n+  if (service)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, service, REAL(strlen)(service) + 1);\n+  if (hints)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, hints, sizeof(__sanitizer_addrinfo));\n+  int res = REAL(getaddrinfo)(node, service, hints, out);\n+  if (res == 0 && out) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, out, sizeof(*out));\n+    struct __sanitizer_addrinfo *p = *out;\n+    while (p) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+      if (p->ai_addr)\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ai_addr, p->ai_addrlen);\n+      if (p->ai_canonname)\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ai_canonname,\n+                                       REAL(strlen)(p->ai_canonname) + 1);\n+      p = p->ai_next;\n+    }\n+  }\n+  return res;\n+}\n+#define INIT_GETADDRINFO INTERCEPT_FUNCTION(getaddrinfo);\n+#else\n+#define INIT_GETADDRINFO\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETNAMEINFO\n+INTERCEPTOR(int, getnameinfo, void *sockaddr, unsigned salen, char *host,\n+            unsigned hostlen, char *serv, unsigned servlen, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getnameinfo, sockaddr, salen, host, hostlen,\n+                           serv, servlen, flags);\n+  // FIXME: consider adding READ_RANGE(sockaddr, salen)\n+  // There is padding in in_addr that may make this too noisy\n+  int res =\n+      REAL(getnameinfo)(sockaddr, salen, host, hostlen, serv, servlen, flags);\n+  if (res == 0) {\n+    if (host && hostlen)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, host, REAL(strlen)(host) + 1);\n+    if (serv && servlen)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, serv, REAL(strlen)(serv) + 1);\n+  }\n+  return res;\n+}\n+#define INIT_GETNAMEINFO INTERCEPT_FUNCTION(getnameinfo);\n+#else\n+#define INIT_GETNAMEINFO\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETSOCKNAME\n+INTERCEPTOR(int, getsockname, int sock_fd, void *addr, int *addrlen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getsockname, sock_fd, addr, addrlen);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n+  int addrlen_in = *addrlen;\n+  int res = REAL(getsockname)(sock_fd, addr, addrlen);\n+  if (res == 0) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addrlen_in, *addrlen));\n+  }\n+  return res;\n+}\n+#define INIT_GETSOCKNAME INTERCEPT_FUNCTION(getsockname);\n+#else\n+#define INIT_GETSOCKNAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETHOSTBYNAME || SANITIZER_INTERCEPT_GETHOSTBYNAME_R\n+static void write_hostent(void *ctx, struct __sanitizer_hostent *h) {\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h, sizeof(__sanitizer_hostent));\n+  if (h->h_name)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h->h_name, REAL(strlen)(h->h_name) + 1);\n+  char **p = h->h_aliases;\n+  while (*p) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n+    ++p;\n+  }\n+  COMMON_INTERCEPTOR_WRITE_RANGE(\n+      ctx, h->h_aliases, (p - h->h_aliases + 1) * sizeof(*h->h_aliases));\n+  p = h->h_addr_list;\n+  while (*p) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, h->h_length);\n+    ++p;\n+  }\n+  COMMON_INTERCEPTOR_WRITE_RANGE(\n+      ctx, h->h_addr_list, (p - h->h_addr_list + 1) * sizeof(*h->h_addr_list));\n+}\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETHOSTBYNAME\n+INTERCEPTOR(struct __sanitizer_hostent *, gethostbyname, char *name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname, name);\n+  struct __sanitizer_hostent *res = REAL(gethostbyname)(name);\n+  if (res) write_hostent(ctx, res);\n+  return res;\n+}\n+\n+INTERCEPTOR(struct __sanitizer_hostent *, gethostbyaddr, void *addr, int len,\n+            int type) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyaddr, addr, len, type);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n+  struct __sanitizer_hostent *res = REAL(gethostbyaddr)(addr, len, type);\n+  if (res) write_hostent(ctx, res);\n+  return res;\n+}\n+\n+INTERCEPTOR(struct __sanitizer_hostent *, gethostent) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostent);\n+  struct __sanitizer_hostent *res = REAL(gethostent)();\n+  if (res) write_hostent(ctx, res);\n+  return res;\n+}\n+\n+INTERCEPTOR(struct __sanitizer_hostent *, gethostbyname2, char *name, int af) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2, name, af);\n+  struct __sanitizer_hostent *res = REAL(gethostbyname2)(name, af);\n+  if (res) write_hostent(ctx, res);\n+  return res;\n+}\n+#define INIT_GETHOSTBYNAME           \\\n+  INTERCEPT_FUNCTION(gethostent);    \\\n+  INTERCEPT_FUNCTION(gethostbyaddr); \\\n+  INTERCEPT_FUNCTION(gethostbyname); \\\n+  INTERCEPT_FUNCTION(gethostbyname2);\n+#else\n+#define INIT_GETHOSTBYNAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETHOSTBYNAME_R\n+INTERCEPTOR(int, gethostent_r, struct __sanitizer_hostent *ret, char *buf,\n+            SIZE_T buflen, __sanitizer_hostent **result, int *h_errnop) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostent_r, ret, buf, buflen, result,\n+                           h_errnop);\n+  int res = REAL(gethostent_r)(ret, buf, buflen, result, h_errnop);\n+  if (res == 0) {\n+    if (result) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+      if (*result) write_hostent(ctx, *result);\n+    }\n+    if (h_errnop)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(int, gethostbyaddr_r, void *addr, int len, int type,\n+            struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n+            __sanitizer_hostent **result, int *h_errnop) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyaddr_r, addr, len, type, ret, buf,\n+                           buflen, result, h_errnop);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n+  int res = REAL(gethostbyaddr_r)(addr, len, type, ret, buf, buflen, result,\n+                                  h_errnop);\n+  if (res == 0) {\n+    if (result) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+      if (*result) write_hostent(ctx, *result);\n+    }\n+    if (h_errnop)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(int, gethostbyname_r, char *name, struct __sanitizer_hostent *ret,\n+            char *buf, SIZE_T buflen, __sanitizer_hostent **result,\n+            int *h_errnop) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname_r, name, ret, buf, buflen, result,\n+                           h_errnop);\n+  int res = REAL(gethostbyname_r)(name, ret, buf, buflen, result, h_errnop);\n+  if (res == 0) {\n+    if (result) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+      if (*result) write_hostent(ctx, *result);\n+    }\n+    if (h_errnop)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(int, gethostbyname2_r, char *name, int af,\n+            struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n+            __sanitizer_hostent **result, int *h_errnop) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2_r, name, af, ret, buf, buflen,\n+                           result, h_errnop);\n+  int res =\n+      REAL(gethostbyname2_r)(name, af, ret, buf, buflen, result, h_errnop);\n+  if (res == 0) {\n+    if (result) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+      if (*result) write_hostent(ctx, *result);\n+    }\n+    if (h_errnop)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  }\n+  return res;\n+}\n+#define INIT_GETHOSTBYNAME_R           \\\n+  INTERCEPT_FUNCTION(gethostent_r);    \\\n+  INTERCEPT_FUNCTION(gethostbyaddr_r); \\\n+  INTERCEPT_FUNCTION(gethostbyname_r); \\\n+  INTERCEPT_FUNCTION(gethostbyname2_r);\n+#else\n+#define INIT_GETHOSTBYNAME_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETSOCKOPT\n+INTERCEPTOR(int, getsockopt, int sockfd, int level, int optname, void *optval,\n+            int *optlen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getsockopt, sockfd, level, optname, optval,\n+                           optlen);\n+  if (optlen) COMMON_INTERCEPTOR_READ_RANGE(ctx, optlen, sizeof(*optlen));\n+  int res = REAL(getsockopt)(sockfd, level, optname, optval, optlen);\n+  if (res == 0)\n+    if (optval && optlen) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, optval, *optlen);\n+  return res;\n+}\n+#define INIT_GETSOCKOPT INTERCEPT_FUNCTION(getsockopt);\n+#else\n+#define INIT_GETSOCKOPT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ACCEPT\n+INTERCEPTOR(int, accept, int fd, void *addr, unsigned *addrlen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, accept, fd, addr, addrlen);\n+  unsigned addrlen0;\n+  if (addrlen) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n+    addrlen0 = *addrlen;\n+  }\n+  int fd2 = REAL(accept)(fd, addr, addrlen);\n+  if (fd2 >= 0) {\n+    if (fd >= 0)\n+      COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n+    if (addr && addrlen)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n+  }\n+  return fd2;\n+}\n+#define INIT_ACCEPT INTERCEPT_FUNCTION(accept);\n+#else\n+#define INIT_ACCEPT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ACCEPT4\n+INTERCEPTOR(int, accept4, int fd, void *addr, unsigned *addrlen, int f) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, accept4, fd, addr, addrlen, f);\n+  unsigned addrlen0;\n+  if (addrlen) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n+    addrlen0 = *addrlen;\n+  }\n+  int fd2 = REAL(accept4)(fd, addr, addrlen, f);\n+  if (fd2 >= 0) {\n+    if (fd >= 0)\n+      COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n+    if (addr && addrlen)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n+  }\n+  return fd2;\n+}\n+#define INIT_ACCEPT4 INTERCEPT_FUNCTION(accept4);\n+#else\n+#define INIT_ACCEPT4\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MODF\n+INTERCEPTOR(double, modf, double x, double *iptr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, modf, x, iptr);\n+  double res = REAL(modf)(x, iptr);\n+  if (iptr) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n+  }\n+  return res;\n+}\n+INTERCEPTOR(float, modff, float x, float *iptr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, modff, x, iptr);\n+  float res = REAL(modff)(x, iptr);\n+  if (iptr) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n+  }\n+  return res;\n+}\n+INTERCEPTOR(long double, modfl, long double x, long double *iptr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, modfl, x, iptr);\n+  long double res = REAL(modfl)(x, iptr);\n+  if (iptr) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n+  }\n+  return res;\n+}\n+#define INIT_MODF            \\\n+  INTERCEPT_FUNCTION(modf);  \\\n+  INTERCEPT_FUNCTION(modff); \\\n+  INTERCEPT_FUNCTION(modfl);\n+#else\n+#define INIT_MODF\n+#endif\n+\n+#if SANITIZER_INTERCEPT_RECVMSG\n+static void write_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n+                         SSIZE_T maxlen) {\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg, sizeof(*msg));\n+  if (msg->msg_name)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_name,\n+                                   REAL(strlen)((char *)msg->msg_name) + 1);\n+  if (msg->msg_iov)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_iov,\n+                                   sizeof(*msg->msg_iov) * msg->msg_iovlen);\n+  write_iovec(ctx, msg->msg_iov, msg->msg_iovlen, maxlen);\n+  if (msg->msg_control)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_control, msg->msg_controllen);\n+}\n+\n+INTERCEPTOR(SSIZE_T, recvmsg, int fd, struct __sanitizer_msghdr *msg,\n+            int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, recvmsg, fd, msg, flags);\n+  SSIZE_T res = REAL(recvmsg)(fd, msg, flags);\n+  if (res >= 0) {\n+    if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+    if (msg) write_msghdr(ctx, msg, res);\n+  }\n+  return res;\n+}\n+#define INIT_RECVMSG INTERCEPT_FUNCTION(recvmsg);\n+#else\n+#define INIT_RECVMSG\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETPEERNAME\n+INTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpeername, sockfd, addr, addrlen);\n+  unsigned addr_sz;\n+  if (addrlen) addr_sz = *addrlen;\n+  int res = REAL(getpeername)(sockfd, addr, addrlen);\n+  if (!res && addr && addrlen)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addr_sz, *addrlen));\n+  return res;\n+}\n+#define INIT_GETPEERNAME INTERCEPT_FUNCTION(getpeername);\n+#else\n+#define INIT_GETPEERNAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SYSINFO\n+INTERCEPTOR(int, sysinfo, void *info) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sysinfo, info);\n+  int res = REAL(sysinfo)(info);\n+  if (!res && info)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, struct_sysinfo_sz);\n+  return res;\n+}\n+#define INIT_SYSINFO INTERCEPT_FUNCTION(sysinfo);\n+#else\n+#define INIT_SYSINFO\n+#endif\n+\n+#if SANITIZER_INTERCEPT_READDIR\n+INTERCEPTOR(__sanitizer_dirent *, readdir, void *dirp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, readdir, dirp);\n+  __sanitizer_dirent *res = REAL(readdir)(dirp);\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, readdir_r, void *dirp, __sanitizer_dirent *entry,\n+            __sanitizer_dirent **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, readdir_r, dirp, entry, result);\n+  int res = REAL(readdir_r)(dirp, entry, result);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+    if (*result)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *result, (*result)->d_reclen);\n+  }\n+  return res;\n+}\n+\n+#define INIT_READDIR           \\\n+  INTERCEPT_FUNCTION(readdir); \\\n+  INTERCEPT_FUNCTION(readdir_r);\n+#else\n+#define INIT_READDIR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_READDIR64\n+INTERCEPTOR(__sanitizer_dirent64 *, readdir64, void *dirp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, readdir64, dirp);\n+  __sanitizer_dirent64 *res = REAL(readdir64)(dirp);\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, readdir64_r, void *dirp, __sanitizer_dirent64 *entry,\n+            __sanitizer_dirent64 **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, readdir64_r, dirp, entry, result);\n+  int res = REAL(readdir64_r)(dirp, entry, result);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+    if (*result)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *result, (*result)->d_reclen);\n+  }\n+  return res;\n+}\n+#define INIT_READDIR64           \\\n+  INTERCEPT_FUNCTION(readdir64); \\\n+  INTERCEPT_FUNCTION(readdir64_r);\n+#else\n+#define INIT_READDIR64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTRACE\n+INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ptrace, request, pid, addr, data);\n+\n+  if (data) {\n+    if (request == ptrace_setregs)\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_regs_struct_sz);\n+    else if (request == ptrace_setfpregs)\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n+    else if (request == ptrace_setfpxregs)\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n+    else if (request == ptrace_setsiginfo)\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, siginfo_t_sz);\n+    else if (request == ptrace_setregset) {\n+      __sanitizer_iovec *iov = (__sanitizer_iovec *)data;\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, iov->iov_base, iov->iov_len);\n+    }\n+  }\n+\n+  uptr res = REAL(ptrace)(request, pid, addr, data);\n+\n+  if (!res && data) {\n+    // Note that PEEK* requests assing different meaning to the return value.\n+    // This function does not handle them (nor does it need to).\n+    if (request == ptrace_getregs)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_regs_struct_sz);\n+    else if (request == ptrace_getfpregs)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n+    else if (request == ptrace_getfpxregs)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n+    else if (request == ptrace_getsiginfo)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, siginfo_t_sz);\n+    else if (request == ptrace_getregset) {\n+      __sanitizer_iovec *iov = (__sanitizer_iovec *)data;\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iov->iov_base, iov->iov_len);\n+    }\n+  }\n+  return res;\n+}\n+\n+#define INIT_PTRACE           \\\n+  INTERCEPT_FUNCTION(ptrace);\n+#else\n+#define INIT_PTRACE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SETLOCALE\n+INTERCEPTOR(char *, setlocale, int category, char *locale) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, setlocale, category, locale);\n+  if (locale)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, locale, REAL(strlen)(locale) + 1);\n+  char *res = REAL(setlocale)(category, locale);\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+\n+#define INIT_SETLOCALE           \\\n+  INTERCEPT_FUNCTION(setlocale);\n+#else\n+#define INIT_SETLOCALE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETCWD\n+INTERCEPTOR(char *, getcwd, char *buf, SIZE_T size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getcwd, buf, size);\n+  char *res = REAL(getcwd)(buf, size);\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+#define INIT_GETCWD           \\\n+  INTERCEPT_FUNCTION(getcwd);\n+#else\n+#define INIT_GETCWD\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME\n+INTERCEPTOR(char *, get_current_dir_name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, get_current_dir_name);\n+  char *res = REAL(get_current_dir_name)();\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+\n+#define INIT_GET_CURRENT_DIR_NAME           \\\n+  INTERCEPT_FUNCTION(get_current_dir_name);\n+#else\n+#define INIT_GET_CURRENT_DIR_NAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRTOIMAX\n+INTERCEPTOR(INTMAX_T, strtoimax, const char *nptr, char **endptr, int base) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strtoimax, nptr, endptr, base);\n+  INTMAX_T res = REAL(strtoimax)(nptr, endptr, base);\n+  if (endptr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n+  return res;\n+}\n+\n+INTERCEPTOR(INTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strtoumax, nptr, endptr, base);\n+  INTMAX_T res = REAL(strtoumax)(nptr, endptr, base);\n+  if (endptr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n+  return res;\n+}\n+\n+#define INIT_STRTOIMAX           \\\n+  INTERCEPT_FUNCTION(strtoimax); \\\n+  INTERCEPT_FUNCTION(strtoumax);\n+#else\n+#define INIT_STRTOIMAX\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MBSTOWCS\n+INTERCEPTOR(SIZE_T, mbstowcs, wchar_t *dest, const char *src, SIZE_T len) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, mbstowcs, dest, src, len);\n+  SIZE_T res = REAL(mbstowcs)(dest, src, len);\n+  if (res != (SIZE_T) - 1 && dest) {\n+    SIZE_T write_cnt = res + (res < len);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(SIZE_T, mbsrtowcs, wchar_t *dest, const char **src, SIZE_T len,\n+            void *ps) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, mbsrtowcs, dest, src, len, ps);\n+  if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n+  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  SIZE_T res = REAL(mbsrtowcs)(dest, src, len, ps);\n+  if (res != (SIZE_T)(-1) && dest && src) {\n+    // This function, and several others, may or may not write the terminating\n+    // \\0 character. They write it iff they clear *src.\n+    SIZE_T write_cnt = res + !*src;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n+  }\n+  return res;\n+}\n+\n+#define INIT_MBSTOWCS           \\\n+  INTERCEPT_FUNCTION(mbstowcs); \\\n+  INTERCEPT_FUNCTION(mbsrtowcs);\n+#else\n+#define INIT_MBSTOWCS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MBSNRTOWCS\n+INTERCEPTOR(SIZE_T, mbsnrtowcs, wchar_t *dest, const char **src, SIZE_T nms,\n+            SIZE_T len, void *ps) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, mbsnrtowcs, dest, src, nms, len, ps);\n+  if (src) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n+    if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n+  }\n+  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  SIZE_T res = REAL(mbsnrtowcs)(dest, src, nms, len, ps);\n+  if (res != (SIZE_T)(-1) && dest && src) {\n+    SIZE_T write_cnt = res + !*src;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n+  }\n+  return res;\n+}\n+\n+#define INIT_MBSNRTOWCS INTERCEPT_FUNCTION(mbsnrtowcs);\n+#else\n+#define INIT_MBSNRTOWCS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_WCSTOMBS\n+INTERCEPTOR(SIZE_T, wcstombs, char *dest, const wchar_t *src, SIZE_T len) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcstombs, dest, src, len);\n+  SIZE_T res = REAL(wcstombs)(dest, src, len);\n+  if (res != (SIZE_T) - 1 && dest) {\n+    SIZE_T write_cnt = res + (res < len);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(SIZE_T, wcsrtombs, char *dest, const wchar_t **src, SIZE_T len,\n+            void *ps) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcsrtombs, dest, src, len, ps);\n+  if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n+  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  SIZE_T res = REAL(wcsrtombs)(dest, src, len, ps);\n+  if (res != (SIZE_T) - 1 && dest && src) {\n+    SIZE_T write_cnt = res + !*src;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n+  }\n+  return res;\n+}\n+\n+#define INIT_WCSTOMBS           \\\n+  INTERCEPT_FUNCTION(wcstombs); \\\n+  INTERCEPT_FUNCTION(wcsrtombs);\n+#else\n+#define INIT_WCSTOMBS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_WCSNRTOMBS\n+INTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n+            SIZE_T len, void *ps) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcsnrtombs, dest, src, nms, len, ps);\n+  if (src) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n+    if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n+  }\n+  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  SIZE_T res = REAL(wcsnrtombs)(dest, src, nms, len, ps);\n+  if (res != (SIZE_T) - 1 && dest && src) {\n+    SIZE_T write_cnt = res + !*src;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n+  }\n+  return res;\n+}\n+\n+#define INIT_WCSNRTOMBS INTERCEPT_FUNCTION(wcsnrtombs);\n+#else\n+#define INIT_WCSNRTOMBS\n+#endif\n+\n+\n+#if SANITIZER_INTERCEPT_TCGETATTR\n+INTERCEPTOR(int, tcgetattr, int fd, void *termios_p) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, tcgetattr, fd, termios_p);\n+  int res = REAL(tcgetattr)(fd, termios_p);\n+  if (!res && termios_p)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, termios_p, struct_termios_sz);\n+  return res;\n+}\n+\n+#define INIT_TCGETATTR INTERCEPT_FUNCTION(tcgetattr);\n+#else\n+#define INIT_TCGETATTR\n+#endif\n+\n+\n+#if SANITIZER_INTERCEPT_REALPATH\n+INTERCEPTOR(char *, realpath, const char *path, char *resolved_path) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, realpath, path, resolved_path);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+\n+  // Workaround a bug in glibc where dlsym(RTLD_NEXT, ...) returns the oldest\n+  // version of a versioned symbol. For realpath(), this gives us something\n+  // (called __old_realpath) that does not handle NULL in the second argument.\n+  // Handle it as part of the interceptor.\n+  char *allocated_path = 0;\n+  if (!resolved_path)\n+    allocated_path = resolved_path = (char *)WRAP(malloc)(path_max + 1);\n+\n+  char *res = REAL(realpath)(path, resolved_path);\n+  if (allocated_path && !res)\n+    WRAP(free)(allocated_path);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+#define INIT_REALPATH INTERCEPT_FUNCTION(realpath);\n+#else\n+#define INIT_REALPATH\n+#endif\n+\n+#if SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME\n+INTERCEPTOR(char *, canonicalize_file_name, const char *path) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, canonicalize_file_name, path);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  char *res = REAL(canonicalize_file_name)(path);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+#define INIT_CANONICALIZE_FILE_NAME INTERCEPT_FUNCTION(canonicalize_file_name);\n+#else\n+#define INIT_CANONICALIZE_FILE_NAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_CONFSTR\n+INTERCEPTOR(SIZE_T, confstr, int name, char *buf, SIZE_T len) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, confstr, name, buf, len);\n+  SIZE_T res = REAL(confstr)(name, buf, len);\n+  if (buf && res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res < len ? res : len);\n+  return res;\n+}\n+#define INIT_CONFSTR INTERCEPT_FUNCTION(confstr);\n+#else\n+#define INIT_CONFSTR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SCHED_GETAFFINITY\n+INTERCEPTOR(int, sched_getaffinity, int pid, SIZE_T cpusetsize, void *mask) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sched_getaffinity, pid, cpusetsize, mask);\n+  int res = REAL(sched_getaffinity)(pid, cpusetsize, mask);\n+  if (mask && !res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mask, cpusetsize);\n+  return res;\n+}\n+#define INIT_SCHED_GETAFFINITY INTERCEPT_FUNCTION(sched_getaffinity);\n+#else\n+#define INIT_SCHED_GETAFFINITY\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRERROR\n+INTERCEPTOR(char *, strerror, int errnum) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strerror, errnum);\n+  char *res = REAL(strerror)(errnum);\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+#define INIT_STRERROR INTERCEPT_FUNCTION(strerror);\n+#else\n+#define INIT_STRERROR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRERROR_R\n+INTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strerror_r, errnum, buf, buflen);\n+  char *res = REAL(strerror_r)(errnum, buf, buflen);\n+  // There are 2 versions of strerror_r:\n+  //  * POSIX version returns 0 on success, negative error code on failure,\n+  //    writes message to buf.\n+  //  * GNU version returns message pointer, which points to either buf or some\n+  //    static storage.\n+  SIZE_T posix_res = (SIZE_T)res;\n+  if (posix_res < 1024 || posix_res > (SIZE_T) - 1024) {\n+    // POSIX version. Spec is not clear on whether buf is NULL-terminated.\n+    // At least on OSX, buf contents are valid even when the call fails.\n+    SIZE_T sz = internal_strnlen(buf, buflen);\n+    if (sz < buflen) ++sz;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n+  } else {\n+    // GNU version.\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  }\n+  return res;\n+}\n+#define INIT_STRERROR_R INTERCEPT_FUNCTION(strerror_r);\n+#else\n+#define INIT_STRERROR_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SCANDIR\n+typedef int (*scandir_filter_f)(const struct __sanitizer_dirent *);\n+typedef int (*scandir_compar_f)(const struct __sanitizer_dirent **,\n+                                const struct __sanitizer_dirent **);\n+\n+static THREADLOCAL void *scandir_ctx;\n+static THREADLOCAL scandir_filter_f scandir_filter;\n+static THREADLOCAL scandir_compar_f scandir_compar;\n+\n+static int wrapped_scandir_filter(const struct __sanitizer_dirent *dir) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir_ctx, 1);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, dir, dir->d_reclen);\n+  return scandir_filter(dir);\n+}\n+\n+static int wrapped_scandir_compar(const struct __sanitizer_dirent **a,\n+                                  const struct __sanitizer_dirent **b) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir_ctx, 2);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, a, sizeof(*a));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, *a, (*a)->d_reclen);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, b, sizeof(*b));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, *b, (*b)->d_reclen);\n+  return scandir_compar(a, b);\n+}\n+\n+INTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n+            scandir_filter_f filter, scandir_compar_f compar) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, scandir, dirp, namelist, filter, compar);\n+  if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n+  CHECK_EQ(0, scandir_ctx);\n+  scandir_ctx = ctx;\n+  scandir_filter = filter;\n+  scandir_compar = compar;\n+  int res = REAL(scandir)(dirp, namelist, filter ? wrapped_scandir_filter : 0,\n+                          compar ? wrapped_scandir_compar : 0);\n+  scandir_ctx = 0;\n+  scandir_filter = 0;\n+  scandir_compar = 0;\n+  if (namelist && res > 0) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n+    for (int i = 0; i < res; ++i)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (*namelist)[i],\n+                                     (*namelist)[i]->d_reclen);\n+  }\n+  return res;\n+}\n+#define INIT_SCANDIR INTERCEPT_FUNCTION(scandir);\n+#else\n+#define INIT_SCANDIR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SCANDIR64\n+typedef int (*scandir64_filter_f)(const struct __sanitizer_dirent64 *);\n+typedef int (*scandir64_compar_f)(const struct __sanitizer_dirent64 **,\n+                                  const struct __sanitizer_dirent64 **);\n+\n+static THREADLOCAL void *scandir64_ctx;\n+static THREADLOCAL scandir64_filter_f scandir64_filter;\n+static THREADLOCAL scandir64_compar_f scandir64_compar;\n+\n+static int wrapped_scandir64_filter(const struct __sanitizer_dirent64 *dir) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir64_ctx, 1);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, dir, dir->d_reclen);\n+  return scandir64_filter(dir);\n+}\n+\n+static int wrapped_scandir64_compar(const struct __sanitizer_dirent64 **a,\n+                                    const struct __sanitizer_dirent64 **b) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir64_ctx, 2);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, a, sizeof(*a));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, *a, (*a)->d_reclen);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, b, sizeof(*b));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, *b, (*b)->d_reclen);\n+  return scandir64_compar(a, b);\n+}\n+\n+INTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n+            scandir64_filter_f filter, scandir64_compar_f compar) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, scandir64, dirp, namelist, filter, compar);\n+  if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n+  CHECK_EQ(0, scandir64_ctx);\n+  scandir64_ctx = ctx;\n+  scandir64_filter = filter;\n+  scandir64_compar = compar;\n+  int res =\n+      REAL(scandir64)(dirp, namelist, filter ? wrapped_scandir64_filter : 0,\n+                      compar ? wrapped_scandir64_compar : 0);\n+  scandir64_ctx = 0;\n+  scandir64_filter = 0;\n+  scandir64_compar = 0;\n+  if (namelist && res > 0) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n+    for (int i = 0; i < res; ++i)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (*namelist)[i],\n+                                     (*namelist)[i]->d_reclen);\n+  }\n+  return res;\n+}\n+#define INIT_SCANDIR64 INTERCEPT_FUNCTION(scandir64);\n+#else\n+#define INIT_SCANDIR64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETGROUPS\n+INTERCEPTOR(int, getgroups, int size, u32 *lst) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgroups, size, lst);\n+  int res = REAL(getgroups)(size, lst);\n+  if (res && lst)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lst, res * sizeof(*lst));\n+  return res;\n+}\n+#define INIT_GETGROUPS INTERCEPT_FUNCTION(getgroups);\n+#else\n+#define INIT_GETGROUPS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_POLL\n+static void read_pollfd(void *ctx, __sanitizer_pollfd *fds,\n+                        __sanitizer_nfds_t nfds) {\n+  for (unsigned i = 0; i < nfds; ++i) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, &fds[i].fd, sizeof(fds[i].fd));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, &fds[i].events, sizeof(fds[i].events));\n+  }\n+}\n+\n+static void write_pollfd(void *ctx, __sanitizer_pollfd *fds,\n+                         __sanitizer_nfds_t nfds) {\n+  for (unsigned i = 0; i < nfds; ++i)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &fds[i].revents,\n+                                   sizeof(fds[i].revents));\n+}\n+\n+INTERCEPTOR(int, poll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n+            int timeout) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, poll, fds, nfds, timeout);\n+  if (fds && nfds) read_pollfd(ctx, fds, nfds);\n+  int res = COMMON_INTERCEPTOR_BLOCK_REAL(poll)(fds, nfds, timeout);\n+  if (fds && nfds) write_pollfd(ctx, fds, nfds);\n+  return res;\n+}\n+#define INIT_POLL INTERCEPT_FUNCTION(poll);\n+#else\n+#define INIT_POLL\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PPOLL\n+INTERCEPTOR(int, ppoll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n+            void *timeout_ts, __sanitizer_sigset_t *sigmask) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ppoll, fds, nfds, timeout_ts, sigmask);\n+  if (fds && nfds) read_pollfd(ctx, fds, nfds);\n+  if (timeout_ts)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout_ts, struct_timespec_sz);\n+  // FIXME: read sigmask when all of sigemptyset, etc are intercepted.\n+  int res =\n+      COMMON_INTERCEPTOR_BLOCK_REAL(ppoll)(fds, nfds, timeout_ts, sigmask);\n+  if (fds && nfds) write_pollfd(ctx, fds, nfds);\n+  return res;\n+}\n+#define INIT_PPOLL INTERCEPT_FUNCTION(ppoll);\n+#else\n+#define INIT_PPOLL\n+#endif\n+\n+#if SANITIZER_INTERCEPT_WORDEXP\n+INTERCEPTOR(int, wordexp, char *s, __sanitizer_wordexp_t *p, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wordexp, s, p, flags);\n+  if (s) COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n+  int res = REAL(wordexp)(s, p, flags);\n+  if (!res && p) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+    if (p->we_wordc)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->we_wordv,\n+                                     sizeof(*p->we_wordv) * p->we_wordc);\n+    for (uptr i = 0; i < p->we_wordc; ++i) {\n+      char *w = p->we_wordv[i];\n+      if (w) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, w, REAL(strlen)(w) + 1);\n+    }\n+  }\n+  return res;\n+}\n+#define INIT_WORDEXP INTERCEPT_FUNCTION(wordexp);\n+#else\n+#define INIT_WORDEXP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SIGWAIT\n+INTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigwait, set, sig);\n+  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  int res = REAL(sigwait)(set, sig);\n+  if (!res && sig) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sig, sizeof(*sig));\n+  return res;\n+}\n+#define INIT_SIGWAIT INTERCEPT_FUNCTION(sigwait);\n+#else\n+#define INIT_SIGWAIT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SIGWAITINFO\n+INTERCEPTOR(int, sigwaitinfo, __sanitizer_sigset_t *set, void *info) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigwaitinfo, set, info);\n+  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  int res = REAL(sigwaitinfo)(set, info);\n+  if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n+  return res;\n+}\n+#define INIT_SIGWAITINFO INTERCEPT_FUNCTION(sigwaitinfo);\n+#else\n+#define INIT_SIGWAITINFO\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SIGTIMEDWAIT\n+INTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n+            void *timeout) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigtimedwait, set, info, timeout);\n+  if (timeout) COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout, struct_timespec_sz);\n+  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  int res = REAL(sigtimedwait)(set, info, timeout);\n+  if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n+  return res;\n+}\n+#define INIT_SIGTIMEDWAIT INTERCEPT_FUNCTION(sigtimedwait);\n+#else\n+#define INIT_SIGTIMEDWAIT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SIGSETOPS\n+INTERCEPTOR(int, sigemptyset, __sanitizer_sigset_t *set) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigemptyset, set);\n+  int res = REAL(sigemptyset)(set);\n+  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sigfillset, __sanitizer_sigset_t *set) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigfillset, set);\n+  int res = REAL(sigfillset)(set);\n+  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n+  return res;\n+}\n+#define INIT_SIGSETOPS             \\\n+  INTERCEPT_FUNCTION(sigemptyset); \\\n+  INTERCEPT_FUNCTION(sigfillset);\n+#else\n+#define INIT_SIGSETOPS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SIGPENDING\n+INTERCEPTOR(int, sigpending, __sanitizer_sigset_t *set) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigpending, set);\n+  int res = REAL(sigpending)(set);\n+  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n+  return res;\n+}\n+#define INIT_SIGPENDING INTERCEPT_FUNCTION(sigpending);\n+#else\n+#define INIT_SIGPENDING\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SIGPROCMASK\n+INTERCEPTOR(int, sigprocmask, int how, __sanitizer_sigset_t *set,\n+            __sanitizer_sigset_t *oldset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigprocmask, how, set, oldset);\n+  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  int res = REAL(sigprocmask)(how, set, oldset);\n+  if (!res && oldset)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldset, sizeof(*oldset));\n+  return res;\n+}\n+#define INIT_SIGPROCMASK INTERCEPT_FUNCTION(sigprocmask);\n+#else\n+#define INIT_SIGPROCMASK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_BACKTRACE\n+INTERCEPTOR(int, backtrace, void **buffer, int size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, backtrace, buffer, size);\n+  int res = REAL(backtrace)(buffer, size);\n+  if (res && buffer)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buffer, res * sizeof(*buffer));\n+  return res;\n+}\n+\n+INTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, backtrace_symbols, buffer, size);\n+  if (buffer && size)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, buffer, size * sizeof(*buffer));\n+  char ** res = REAL(backtrace_symbols)(buffer, size);\n+  if (res && size) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, size * sizeof(*res));\n+    for (int i = 0; i < size; ++i)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res[i], REAL(strlen(res[i])) + 1);\n+  }\n+  return res;\n+}\n+#define INIT_BACKTRACE           \\\n+  INTERCEPT_FUNCTION(backtrace); \\\n+  INTERCEPT_FUNCTION(backtrace_symbols);\n+#else\n+#define INIT_BACKTRACE\n+#endif\n+\n+#define SANITIZER_COMMON_INTERCEPTORS_INIT \\\n+  INIT_STRCMP;                             \\\n+  INIT_STRNCMP;                            \\\n+  INIT_STRCASECMP;                         \\\n+  INIT_STRNCASECMP;                        \\\n+  INIT_READ;                               \\\n+  INIT_PREAD;                              \\\n+  INIT_PREAD64;                            \\\n+  INIT_READV;                              \\\n+  INIT_PREADV;                             \\\n+  INIT_PREADV64;                           \\\n+  INIT_WRITE;                              \\\n+  INIT_PWRITE;                             \\\n+  INIT_PWRITE64;                           \\\n+  INIT_WRITEV;                             \\\n+  INIT_PWRITEV;                            \\\n+  INIT_PWRITEV64;                          \\\n+  INIT_PRCTL;                              \\\n+  INIT_LOCALTIME_AND_FRIENDS;              \\\n+  INIT_SCANF;                              \\\n+  INIT_ISOC99_SCANF;                       \\\n+  INIT_FREXP;                              \\\n+  INIT_FREXPF_FREXPL;                      \\\n+  INIT_GETPWNAM_AND_FRIENDS;               \\\n+  INIT_GETPWNAM_R_AND_FRIENDS;             \\\n+  INIT_CLOCK_GETTIME;                      \\\n+  INIT_GETITIMER;                          \\\n+  INIT_TIME;                               \\\n+  INIT_GLOB;                               \\\n+  INIT_WAIT;                               \\\n+  INIT_INET;                               \\\n+  INIT_PTHREAD_GETSCHEDPARAM;              \\\n+  INIT_GETADDRINFO;                        \\\n+  INIT_GETNAMEINFO;                        \\\n+  INIT_GETSOCKNAME;                        \\\n+  INIT_GETHOSTBYNAME;                      \\\n+  INIT_GETHOSTBYNAME_R;                    \\\n+  INIT_GETSOCKOPT;                         \\\n+  INIT_ACCEPT;                             \\\n+  INIT_ACCEPT4;                            \\\n+  INIT_MODF;                               \\\n+  INIT_RECVMSG;                            \\\n+  INIT_GETPEERNAME;                        \\\n+  INIT_IOCTL;                              \\\n+  INIT_INET_ATON;                          \\\n+  INIT_SYSINFO;                            \\\n+  INIT_READDIR;                            \\\n+  INIT_READDIR64;                          \\\n+  INIT_PTRACE;                             \\\n+  INIT_SETLOCALE;                          \\\n+  INIT_GETCWD;                             \\\n+  INIT_GET_CURRENT_DIR_NAME;               \\\n+  INIT_STRTOIMAX;                          \\\n+  INIT_MBSTOWCS;                           \\\n+  INIT_MBSNRTOWCS;                         \\\n+  INIT_WCSTOMBS;                           \\\n+  INIT_WCSNRTOMBS;                         \\\n+  INIT_TCGETATTR;                          \\\n+  INIT_REALPATH;                           \\\n+  INIT_CANONICALIZE_FILE_NAME;             \\\n+  INIT_CONFSTR;                            \\\n+  INIT_SCHED_GETAFFINITY;                  \\\n+  INIT_STRERROR;                           \\\n+  INIT_STRERROR_R;                         \\\n+  INIT_SCANDIR;                            \\\n+  INIT_SCANDIR64;                          \\\n+  INIT_GETGROUPS;                          \\\n+  INIT_POLL;                               \\\n+  INIT_PPOLL;                              \\\n+  INIT_WORDEXP;                            \\\n+  INIT_SIGWAIT;                            \\\n+  INIT_SIGWAITINFO;                        \\\n+  INIT_SIGTIMEDWAIT;                       \\\n+  INIT_SIGSETOPS;                          \\\n+  INIT_SIGPENDING;                         \\\n+  INIT_SIGPROCMASK;                        \\\n+  INIT_BACKTRACE;"}, {"sha": "50db0d71d891d9f54bef25a052037e9c99bdb19d", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,566 @@\n+//===-- sanitizer_common_interceptors_ioctl.inc -----------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Ioctl handling in common sanitizer interceptors.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_flags.h\"\n+\n+struct ioctl_desc {\n+  unsigned req;\n+  // FIXME: support read+write arguments. Those are currently marked as WRITE.\n+  enum {\n+    NONE,\n+    READ,\n+    WRITE,\n+    CUSTOM\n+  } type : 2;\n+  unsigned size : 30;\n+  const char* name;\n+};\n+\n+const unsigned ioctl_table_max = 500;\n+static ioctl_desc ioctl_table[ioctl_table_max];\n+static unsigned ioctl_table_size = 0;\n+\n+// This can not be declared as a global, because references to struct_*_sz\n+// require a global initializer. And this table must be available before global\n+// initializers are run.\n+static void ioctl_table_fill() {\n+#define _(rq, tp, sz)                                    \\\n+  if (IOCTL_##rq != IOCTL_NOT_PRESENT) {                 \\\n+    CHECK(ioctl_table_size < ioctl_table_max);           \\\n+    ioctl_table[ioctl_table_size].req = IOCTL_##rq;      \\\n+    ioctl_table[ioctl_table_size].type = ioctl_desc::tp; \\\n+    ioctl_table[ioctl_table_size].size = sz;             \\\n+    ioctl_table[ioctl_table_size].name = #rq;            \\\n+    ++ioctl_table_size;                                  \\\n+  }\n+\n+  _(FIOASYNC, READ, sizeof(int));\n+  _(FIOCLEX, NONE, 0);\n+  _(FIOGETOWN, WRITE, sizeof(int));\n+  _(FIONBIO, READ, sizeof(int));\n+  _(FIONCLEX, NONE, 0);\n+  _(FIOSETOWN, READ, sizeof(int));\n+  _(SIOCADDMULTI, READ, struct_ifreq_sz);\n+  _(SIOCATMARK, WRITE, sizeof(int));\n+  _(SIOCDELMULTI, READ, struct_ifreq_sz);\n+  _(SIOCGIFADDR, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFBRDADDR, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFCONF, CUSTOM, 0);\n+  _(SIOCGIFDSTADDR, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFFLAGS, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFMETRIC, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFMTU, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFNETMASK, WRITE, struct_ifreq_sz);\n+  _(SIOCGPGRP, WRITE, sizeof(int));\n+  _(SIOCSIFADDR, READ, struct_ifreq_sz);\n+  _(SIOCSIFBRDADDR, READ, struct_ifreq_sz);\n+  _(SIOCSIFDSTADDR, READ, struct_ifreq_sz);\n+  _(SIOCSIFFLAGS, READ, struct_ifreq_sz);\n+  _(SIOCSIFMETRIC, READ, struct_ifreq_sz);\n+  _(SIOCSIFMTU, READ, struct_ifreq_sz);\n+  _(SIOCSIFNETMASK, READ, struct_ifreq_sz);\n+  _(SIOCSPGRP, READ, sizeof(int));\n+  _(TIOCCONS, NONE, 0);\n+  _(TIOCEXCL, NONE, 0);\n+  _(TIOCGETD, WRITE, sizeof(int));\n+  _(TIOCGPGRP, WRITE, pid_t_sz);\n+  _(TIOCGWINSZ, WRITE, struct_winsize_sz);\n+  _(TIOCMBIC, READ, sizeof(int));\n+  _(TIOCMBIS, READ, sizeof(int));\n+  _(TIOCMGET, WRITE, sizeof(int));\n+  _(TIOCMSET, READ, sizeof(int));\n+  _(TIOCNOTTY, NONE, 0);\n+  _(TIOCNXCL, NONE, 0);\n+  _(TIOCOUTQ, WRITE, sizeof(int));\n+  _(TIOCPKT, READ, sizeof(int));\n+  _(TIOCSCTTY, NONE, 0);\n+  _(TIOCSETD, READ, sizeof(int));\n+  _(TIOCSPGRP, READ, pid_t_sz);\n+  _(TIOCSTI, READ, sizeof(char));\n+  _(TIOCSWINSZ, READ, struct_winsize_sz);\n+\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_MAC\n+  _(SIOCGETSGCNT, WRITE, struct_sioc_sg_req_sz);\n+  _(SIOCGETVIFCNT, WRITE, struct_sioc_vif_req_sz);\n+#endif\n+\n+#if SANITIZER_LINUX\n+  // Conflicting request ids.\n+  // _(CDROMAUDIOBUFSIZ, NONE, 0);\n+  // _(SNDCTL_TMR_CONTINUE, NONE, 0);\n+  // _(SNDCTL_TMR_START, NONE, 0);\n+  // _(SNDCTL_TMR_STOP, NONE, 0);\n+  // _(SOUND_MIXER_READ_LOUD, WRITE, sizeof(int)); // same as ...READ_ENHANCE\n+  // _(SOUND_MIXER_READ_MUTE, WRITE, sizeof(int)); // same as ...READ_ENHANCE\n+  // _(SOUND_MIXER_WRITE_LOUD, WRITE, sizeof(int)); // same as ...WRITE_ENHANCE\n+  // _(SOUND_MIXER_WRITE_MUTE, WRITE, sizeof(int)); // same as ...WRITE_ENHANCE\n+  _(BLKFLSBUF, NONE, 0);\n+  _(BLKGETSIZE, WRITE, sizeof(uptr));\n+  _(BLKRAGET, WRITE, sizeof(int));\n+  _(BLKRASET, NONE, 0);\n+  _(BLKROGET, WRITE, sizeof(int));\n+  _(BLKROSET, READ, sizeof(int));\n+  _(BLKRRPART, NONE, 0);\n+  _(CDROMEJECT, NONE, 0);\n+  _(CDROMEJECT_SW, NONE, 0);\n+  _(CDROMMULTISESSION, WRITE, struct_cdrom_multisession_sz);\n+  _(CDROMPAUSE, NONE, 0);\n+  _(CDROMPLAYMSF, READ, struct_cdrom_msf_sz);\n+  _(CDROMPLAYTRKIND, READ, struct_cdrom_ti_sz);\n+  _(CDROMREADAUDIO, READ, struct_cdrom_read_audio_sz);\n+  _(CDROMREADCOOKED, READ, struct_cdrom_msf_sz);\n+  _(CDROMREADMODE1, READ, struct_cdrom_msf_sz);\n+  _(CDROMREADMODE2, READ, struct_cdrom_msf_sz);\n+  _(CDROMREADRAW, READ, struct_cdrom_msf_sz);\n+  _(CDROMREADTOCENTRY, WRITE, struct_cdrom_tocentry_sz);\n+  _(CDROMREADTOCHDR, WRITE, struct_cdrom_tochdr_sz);\n+  _(CDROMRESET, NONE, 0);\n+  _(CDROMRESUME, NONE, 0);\n+  _(CDROMSEEK, READ, struct_cdrom_msf_sz);\n+  _(CDROMSTART, NONE, 0);\n+  _(CDROMSTOP, NONE, 0);\n+  _(CDROMSUBCHNL, WRITE, struct_cdrom_subchnl_sz);\n+  _(CDROMVOLCTRL, READ, struct_cdrom_volctrl_sz);\n+  _(CDROMVOLREAD, WRITE, struct_cdrom_volctrl_sz);\n+  _(CDROM_GET_UPC, WRITE, 8);\n+  _(EVIOCGABS, WRITE, struct_input_absinfo_sz); // fixup\n+  _(EVIOCGBIT, WRITE, struct_input_id_sz); // fixup\n+  _(EVIOCGEFFECTS, WRITE, sizeof(int));\n+  _(EVIOCGID, WRITE, struct_input_id_sz);\n+  _(EVIOCGKEY, WRITE, 0);\n+  _(EVIOCGKEYCODE, WRITE, sizeof(int) * 2);\n+  _(EVIOCGLED, WRITE, 0);\n+  _(EVIOCGNAME, WRITE, 0);\n+  _(EVIOCGPHYS, WRITE, 0);\n+  _(EVIOCGRAB, READ, sizeof(int));\n+  _(EVIOCGREP, WRITE, sizeof(int) * 2);\n+  _(EVIOCGSND, WRITE, 0);\n+  _(EVIOCGSW, WRITE, 0);\n+  _(EVIOCGUNIQ, WRITE, 0);\n+  _(EVIOCGVERSION, WRITE, sizeof(int));\n+  _(EVIOCRMFF, READ, sizeof(int));\n+  _(EVIOCSABS, READ, struct_input_absinfo_sz); // fixup\n+  _(EVIOCSFF, READ, struct_ff_effect_sz);\n+  _(EVIOCSKEYCODE, READ, sizeof(int) * 2);\n+  _(EVIOCSREP, READ, sizeof(int) * 2);\n+  _(FDCLRPRM, NONE, 0);\n+  _(FDDEFPRM, READ, struct_floppy_struct_sz);\n+  _(FDFLUSH, NONE, 0);\n+  _(FDFMTBEG, NONE, 0);\n+  _(FDFMTEND, NONE, 0);\n+  _(FDFMTTRK, READ, struct_format_descr_sz);\n+  _(FDGETDRVPRM, WRITE, struct_floppy_drive_params_sz);\n+  _(FDGETDRVSTAT, WRITE, struct_floppy_drive_struct_sz);\n+  _(FDGETDRVTYP, WRITE, 16);\n+  _(FDGETFDCSTAT, WRITE, struct_floppy_fdc_state_sz);\n+  _(FDGETMAXERRS, WRITE, struct_floppy_max_errors_sz);\n+  _(FDGETPRM, WRITE, struct_floppy_struct_sz);\n+  _(FDMSGOFF, NONE, 0);\n+  _(FDMSGON, NONE, 0);\n+  _(FDPOLLDRVSTAT, WRITE, struct_floppy_drive_struct_sz);\n+  _(FDRAWCMD, WRITE, struct_floppy_raw_cmd_sz);\n+  _(FDRESET, NONE, 0);\n+  _(FDSETDRVPRM, READ, struct_floppy_drive_params_sz);\n+  _(FDSETEMSGTRESH, NONE, 0);\n+  _(FDSETMAXERRS, READ, struct_floppy_max_errors_sz);\n+  _(FDSETPRM, READ, struct_floppy_struct_sz);\n+  _(FDTWADDLE, NONE, 0);\n+  _(FDWERRORCLR, NONE, 0);\n+  _(FDWERRORGET, WRITE, struct_floppy_write_errors_sz);\n+  _(HDIO_DRIVE_CMD, WRITE, sizeof(int));\n+  _(HDIO_GETGEO, WRITE, struct_hd_geometry_sz);\n+  _(HDIO_GET_32BIT, WRITE, sizeof(int));\n+  _(HDIO_GET_DMA, WRITE, sizeof(int));\n+  _(HDIO_GET_IDENTITY, WRITE, struct_hd_driveid_sz);\n+  _(HDIO_GET_KEEPSETTINGS, WRITE, sizeof(int));\n+  _(HDIO_GET_MULTCOUNT, WRITE, sizeof(int));\n+  _(HDIO_GET_NOWERR, WRITE, sizeof(int));\n+  _(HDIO_GET_UNMASKINTR, WRITE, sizeof(int));\n+  _(HDIO_SET_32BIT, NONE, 0);\n+  _(HDIO_SET_DMA, NONE, 0);\n+  _(HDIO_SET_KEEPSETTINGS, NONE, 0);\n+  _(HDIO_SET_MULTCOUNT, NONE, 0);\n+  _(HDIO_SET_NOWERR, NONE, 0);\n+  _(HDIO_SET_UNMASKINTR, NONE, 0);\n+  _(MTIOCGET, WRITE, struct_mtget_sz);\n+  _(MTIOCPOS, WRITE, struct_mtpos_sz);\n+  _(MTIOCTOP, READ, struct_mtop_sz);\n+  _(PPPIOCGASYNCMAP, WRITE, sizeof(int));\n+  _(PPPIOCGDEBUG, WRITE, sizeof(int));\n+  _(PPPIOCGFLAGS, WRITE, sizeof(int));\n+  _(PPPIOCGUNIT, WRITE, sizeof(int));\n+  _(PPPIOCGXASYNCMAP, WRITE, sizeof(int) * 8);\n+  _(PPPIOCSASYNCMAP, READ, sizeof(int));\n+  _(PPPIOCSDEBUG, READ, sizeof(int));\n+  _(PPPIOCSFLAGS, READ, sizeof(int));\n+  _(PPPIOCSMAXCID, READ, sizeof(int));\n+  _(PPPIOCSMRU, READ, sizeof(int));\n+  _(PPPIOCSXASYNCMAP, READ, sizeof(int) * 8);\n+  _(SIOCADDRT, READ, struct_rtentry_sz);\n+  _(SIOCDARP, READ, struct_arpreq_sz);\n+  _(SIOCDELRT, READ, struct_rtentry_sz);\n+  _(SIOCDRARP, READ, struct_arpreq_sz);\n+  _(SIOCGARP, WRITE, struct_arpreq_sz);\n+  _(SIOCGIFENCAP, WRITE, sizeof(int));\n+  _(SIOCGIFHWADDR, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFMAP, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFMEM, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFNAME, NONE, 0);\n+  _(SIOCGIFSLAVE, NONE, 0);\n+  _(SIOCGRARP, WRITE, struct_arpreq_sz);\n+  _(SIOCGSTAMP, WRITE, timeval_sz);\n+  _(SIOCSARP, READ, struct_arpreq_sz);\n+  _(SIOCSIFENCAP, READ, sizeof(int));\n+  _(SIOCSIFHWADDR, READ, struct_ifreq_sz);\n+  _(SIOCSIFLINK, NONE, 0);\n+  _(SIOCSIFMAP, READ, struct_ifreq_sz);\n+  _(SIOCSIFMEM, READ, struct_ifreq_sz);\n+  _(SIOCSIFSLAVE, NONE, 0);\n+  _(SIOCSRARP, READ, struct_arpreq_sz);\n+  _(SNDCTL_COPR_HALT, WRITE, struct_copr_debug_buf_sz);\n+  _(SNDCTL_COPR_LOAD, READ, struct_copr_buffer_sz);\n+  _(SNDCTL_COPR_RCODE, WRITE, struct_copr_debug_buf_sz);\n+  _(SNDCTL_COPR_RCVMSG, WRITE, struct_copr_msg_sz);\n+  _(SNDCTL_COPR_RDATA, WRITE, struct_copr_debug_buf_sz);\n+  _(SNDCTL_COPR_RESET, NONE, 0);\n+  _(SNDCTL_COPR_RUN, WRITE, struct_copr_debug_buf_sz);\n+  _(SNDCTL_COPR_SENDMSG, READ, struct_copr_msg_sz);\n+  _(SNDCTL_COPR_WCODE, READ, struct_copr_debug_buf_sz);\n+  _(SNDCTL_COPR_WDATA, READ, struct_copr_debug_buf_sz);\n+  _(SNDCTL_DSP_GETBLKSIZE, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_GETFMTS, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_NONBLOCK, NONE, 0);\n+  _(SNDCTL_DSP_POST, NONE, 0);\n+  _(SNDCTL_DSP_RESET, NONE, 0);\n+  _(SNDCTL_DSP_SETFMT, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_SETFRAGMENT, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_SPEED, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_STEREO, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_SUBDIVIDE, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_SYNC, NONE, 0);\n+  _(SNDCTL_FM_4OP_ENABLE, READ, sizeof(int));\n+  _(SNDCTL_FM_LOAD_INSTR, READ, struct_sbi_instrument_sz);\n+  _(SNDCTL_MIDI_INFO, WRITE, struct_midi_info_sz);\n+  _(SNDCTL_MIDI_PRETIME, WRITE, sizeof(int));\n+  _(SNDCTL_SEQ_CTRLRATE, WRITE, sizeof(int));\n+  _(SNDCTL_SEQ_GETINCOUNT, WRITE, sizeof(int));\n+  _(SNDCTL_SEQ_GETOUTCOUNT, WRITE, sizeof(int));\n+  _(SNDCTL_SEQ_NRMIDIS, WRITE, sizeof(int));\n+  _(SNDCTL_SEQ_NRSYNTHS, WRITE, sizeof(int));\n+  _(SNDCTL_SEQ_OUTOFBAND, READ, struct_seq_event_rec_sz);\n+  _(SNDCTL_SEQ_PANIC, NONE, 0);\n+  _(SNDCTL_SEQ_PERCMODE, NONE, 0);\n+  _(SNDCTL_SEQ_RESET, NONE, 0);\n+  _(SNDCTL_SEQ_RESETSAMPLES, READ, sizeof(int));\n+  _(SNDCTL_SEQ_SYNC, NONE, 0);\n+  _(SNDCTL_SEQ_TESTMIDI, READ, sizeof(int));\n+  _(SNDCTL_SEQ_THRESHOLD, READ, sizeof(int));\n+  _(SNDCTL_SYNTH_INFO, WRITE, struct_synth_info_sz);\n+  _(SNDCTL_SYNTH_MEMAVL, WRITE, sizeof(int));\n+  _(SNDCTL_TMR_METRONOME, READ, sizeof(int));\n+  _(SNDCTL_TMR_SELECT, WRITE, sizeof(int));\n+  _(SNDCTL_TMR_SOURCE, WRITE, sizeof(int));\n+  _(SNDCTL_TMR_TEMPO, WRITE, sizeof(int));\n+  _(SNDCTL_TMR_TIMEBASE, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_ALTPCM, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_BASS, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_CAPS, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_CD, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_DEVMASK, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_ENHANCE, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_IGAIN, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_IMIX, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_LINE, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_LINE1, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_LINE2, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_LINE3, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_MIC, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_OGAIN, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_PCM, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_RECLEV, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_RECMASK, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_RECSRC, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_SPEAKER, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_STEREODEVS, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_SYNTH, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_TREBLE, WRITE, sizeof(int));\n+  _(SOUND_MIXER_READ_VOLUME, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_ALTPCM, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_BASS, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_CD, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_ENHANCE, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_IGAIN, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_IMIX, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_LINE, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_LINE1, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_LINE2, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_LINE3, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_MIC, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_OGAIN, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_PCM, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_RECLEV, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_RECSRC, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_SPEAKER, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_SYNTH, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_TREBLE, WRITE, sizeof(int));\n+  _(SOUND_MIXER_WRITE_VOLUME, WRITE, sizeof(int));\n+  _(SOUND_PCM_READ_BITS, WRITE, sizeof(int));\n+  _(SOUND_PCM_READ_CHANNELS, WRITE, sizeof(int));\n+  _(SOUND_PCM_READ_FILTER, WRITE, sizeof(int));\n+  _(SOUND_PCM_READ_RATE, WRITE, sizeof(int));\n+  _(SOUND_PCM_WRITE_CHANNELS, WRITE, sizeof(int));\n+  _(SOUND_PCM_WRITE_FILTER, WRITE, sizeof(int));\n+  _(TCFLSH, NONE, 0);\n+  _(TCGETA, WRITE, struct_termio_sz);\n+  _(TCGETS, WRITE, struct_termios_sz);\n+  _(TCSBRK, NONE, 0);\n+  _(TCSBRKP, NONE, 0);\n+  _(TCSETA, READ, struct_termio_sz);\n+  _(TCSETAF, READ, struct_termio_sz);\n+  _(TCSETAW, READ, struct_termio_sz);\n+  _(TCSETS, READ, struct_termios_sz);\n+  _(TCSETSF, READ, struct_termios_sz);\n+  _(TCSETSW, READ, struct_termios_sz);\n+  _(TCXONC, NONE, 0);\n+  _(TIOCGLCKTRMIOS, WRITE, struct_termios_sz);\n+  _(TIOCGSOFTCAR, WRITE, sizeof(int));\n+  _(TIOCINQ, WRITE, sizeof(int));\n+  _(TIOCLINUX, READ, sizeof(char));\n+  _(TIOCSERCONFIG, NONE, 0);\n+  _(TIOCSERGETLSR, WRITE, sizeof(int));\n+  _(TIOCSERGWILD, WRITE, sizeof(int));\n+  _(TIOCSERSWILD, READ, sizeof(int));\n+  _(TIOCSLCKTRMIOS, READ, struct_termios_sz);\n+  _(TIOCSSOFTCAR, READ, sizeof(int));\n+  _(VT_ACTIVATE, NONE, 0);\n+  _(VT_DISALLOCATE, NONE, 0);\n+  _(VT_GETMODE, WRITE, struct_vt_mode_sz);\n+  _(VT_GETSTATE, WRITE, struct_vt_stat_sz);\n+  _(VT_OPENQRY, WRITE, sizeof(int));\n+  _(VT_RELDISP, NONE, 0);\n+  _(VT_RESIZE, READ, struct_vt_sizes_sz);\n+  _(VT_RESIZEX, READ, struct_vt_consize_sz);\n+  _(VT_SENDSIG, NONE, 0);\n+  _(VT_SETMODE, READ, struct_vt_mode_sz);\n+  _(VT_WAITACTIVE, NONE, 0);\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  // _(SIOCDEVPLIP, WRITE, struct_ifreq_sz); // the same as EQL_ENSLAVE\n+  _(CYGETDEFTHRESH, WRITE, sizeof(int));\n+  _(CYGETDEFTIMEOUT, WRITE, sizeof(int));\n+  _(CYGETMON, WRITE, struct_cyclades_monitor_sz);\n+  _(CYGETTHRESH, WRITE, sizeof(int));\n+  _(CYGETTIMEOUT, WRITE, sizeof(int));\n+  _(CYSETDEFTHRESH, NONE, 0);\n+  _(CYSETDEFTIMEOUT, NONE, 0);\n+  _(CYSETTHRESH, NONE, 0);\n+  _(CYSETTIMEOUT, NONE, 0);\n+  _(EQL_EMANCIPATE, WRITE, struct_ifreq_sz);\n+  _(EQL_ENSLAVE, WRITE, struct_ifreq_sz);\n+  _(EQL_GETMASTRCFG, WRITE, struct_ifreq_sz);\n+  _(EQL_GETSLAVECFG, WRITE, struct_ifreq_sz);\n+  _(EQL_SETMASTRCFG, WRITE, struct_ifreq_sz);\n+  _(EQL_SETSLAVECFG, WRITE, struct_ifreq_sz);\n+  _(EVIOCGKEYCODE_V2, WRITE, struct_input_keymap_entry_sz);\n+  _(EVIOCGPROP, WRITE, 0);\n+  _(EVIOCSKEYCODE_V2, READ, struct_input_keymap_entry_sz);\n+  _(FS_IOC_GETFLAGS, WRITE, sizeof(int));\n+  _(FS_IOC_GETVERSION, WRITE, sizeof(int));\n+  _(FS_IOC_SETFLAGS, READ, sizeof(int));\n+  _(FS_IOC_SETVERSION, READ, sizeof(int));\n+  _(GIO_CMAP, WRITE, 48);\n+  _(GIO_FONT, WRITE, 8192);\n+  _(GIO_SCRNMAP, WRITE, e_tabsz);\n+  _(GIO_UNIMAP, WRITE, struct_unimapdesc_sz);\n+  _(GIO_UNISCRNMAP, WRITE, sizeof(short) * e_tabsz);\n+  _(KDADDIO, NONE, 0);\n+  _(KDDELIO, NONE, 0);\n+  _(KDDISABIO, NONE, 0);\n+  _(KDENABIO, NONE, 0);\n+  _(KDGETKEYCODE, WRITE, struct_kbkeycode_sz);\n+  _(KDGETLED, WRITE, 1);\n+  _(KDGETMODE, WRITE, sizeof(int));\n+  _(KDGKBDIACR, WRITE, struct_kbdiacrs_sz);\n+  _(KDGKBENT, WRITE, struct_kbentry_sz);\n+  _(KDGKBLED, WRITE, sizeof(int));\n+  _(KDGKBMETA, WRITE, sizeof(int));\n+  _(KDGKBMODE, WRITE, sizeof(int));\n+  _(KDGKBSENT, WRITE, struct_kbsentry_sz);\n+  _(KDGKBTYPE, WRITE, 1);\n+  _(KDMAPDISP, NONE, 0);\n+  _(KDMKTONE, NONE, 0);\n+  _(KDSETKEYCODE, READ, struct_kbkeycode_sz);\n+  _(KDSETLED, NONE, 0);\n+  _(KDSETMODE, NONE, 0);\n+  _(KDSIGACCEPT, NONE, 0);\n+  _(KDSKBDIACR, READ, struct_kbdiacrs_sz);\n+  _(KDSKBENT, READ, struct_kbentry_sz);\n+  _(KDSKBLED, NONE, 0);\n+  _(KDSKBMETA, NONE, 0);\n+  _(KDSKBMODE, NONE, 0);\n+  _(KDSKBSENT, READ, struct_kbsentry_sz);\n+  _(KDUNMAPDISP, NONE, 0);\n+  _(KIOCSOUND, NONE, 0);\n+  _(LPABORT, NONE, 0);\n+  _(LPABORTOPEN, NONE, 0);\n+  _(LPCAREFUL, NONE, 0);\n+  _(LPCHAR, NONE, 0);\n+  _(LPGETIRQ, WRITE, sizeof(int));\n+  _(LPGETSTATUS, WRITE, sizeof(int));\n+  _(LPRESET, NONE, 0);\n+  _(LPSETIRQ, NONE, 0);\n+  _(LPTIME, NONE, 0);\n+  _(LPWAIT, NONE, 0);\n+  _(MTIOCGETCONFIG, WRITE, struct_mtconfiginfo_sz);\n+  _(MTIOCSETCONFIG, READ, struct_mtconfiginfo_sz);\n+  _(PIO_CMAP, NONE, 0);\n+  _(PIO_FONT, READ, 8192);\n+  _(PIO_SCRNMAP, READ, e_tabsz);\n+  _(PIO_UNIMAP, READ, struct_unimapdesc_sz);\n+  _(PIO_UNIMAPCLR, READ, struct_unimapinit_sz);\n+  _(PIO_UNISCRNMAP, READ, sizeof(short) * e_tabsz);\n+  _(SCSI_IOCTL_PROBE_HOST, READ, sizeof(int));\n+  _(SCSI_IOCTL_TAGGED_DISABLE, NONE, 0);\n+  _(SCSI_IOCTL_TAGGED_ENABLE, NONE, 0);\n+  _(SNDCTL_DSP_GETISPACE, WRITE, struct_audio_buf_info_sz);\n+  _(SNDCTL_DSP_GETOSPACE, WRITE, struct_audio_buf_info_sz);\n+  _(TIOCGSERIAL, WRITE, struct_serial_struct_sz);\n+  _(TIOCSERGETMULTI, WRITE, struct_serial_multiport_struct_sz);\n+  _(TIOCSERSETMULTI, READ, struct_serial_multiport_struct_sz);\n+  _(TIOCSSERIAL, READ, struct_serial_struct_sz);\n+\n+  // The following ioctl requests are shared between AX25, IPX, netrom and\n+  // mrouted.\n+  // _(SIOCAIPXITFCRT, READ, sizeof(char));\n+  // _(SIOCAX25GETUID, READ, struct_sockaddr_ax25_sz);\n+  // _(SIOCNRGETPARMS, WRITE, struct_nr_parms_struct_sz);\n+  // _(SIOCAIPXPRISLT, READ, sizeof(char));\n+  // _(SIOCNRSETPARMS, READ, struct_nr_parms_struct_sz);\n+  // _(SIOCAX25ADDUID, READ, struct_sockaddr_ax25_sz);\n+  // _(SIOCNRDECOBS, NONE, 0);\n+  // _(SIOCAX25DELUID, READ, struct_sockaddr_ax25_sz);\n+  // _(SIOCIPXCFGDATA, WRITE, struct_ipx_config_data_sz);\n+  // _(SIOCAX25NOUID, READ, sizeof(int));\n+  // _(SIOCNRRTCTL, READ, sizeof(int));\n+  // _(SIOCAX25DIGCTL, READ, sizeof(int));\n+  // _(SIOCAX25GETPARMS, WRITE, struct_ax25_parms_struct_sz);\n+  // _(SIOCAX25SETPARMS, READ, struct_ax25_parms_struct_sz);\n+#endif\n+#undef _\n+}\n+\n+static bool ioctl_initialized = false;\n+\n+struct ioctl_desc_compare {\n+  bool operator()(const ioctl_desc& left, const ioctl_desc& right) const {\n+    return left.req < right.req;\n+  }\n+};\n+\n+static void ioctl_init() {\n+  ioctl_table_fill();\n+  InternalSort(&ioctl_table, ioctl_table_size, ioctl_desc_compare());\n+\n+  bool bad = false;\n+  for (unsigned i = 0; i < ioctl_table_size - 1; ++i) {\n+    if (ioctl_table[i].req >= ioctl_table[i + 1].req) {\n+      Printf(\"Duplicate or unsorted ioctl request id %x >= %x (%s vs %s)\\n\",\n+             ioctl_table[i].req, ioctl_table[i + 1].req, ioctl_table[i].name,\n+             ioctl_table[i + 1].name);\n+      bad = true;\n+    }\n+  }\n+\n+  if (bad) Die();\n+\n+  ioctl_initialized = true;\n+}\n+\n+// Handle the most evil ioctls that encode argument value as part of request id.\n+static unsigned ioctl_request_fixup(unsigned req) {\n+#if SANITIZER_LINUX\n+  if ((req & ~0x3fff001fU) == IOCTL_EVIOCGBIT)\n+    return IOCTL_EVIOCGBIT;\n+  if ((req & ~0x3fU) == IOCTL_EVIOCGABS)\n+    return IOCTL_EVIOCGABS;\n+  if ((req & ~0x3fU) == IOCTL_EVIOCSABS)\n+    return IOCTL_EVIOCSABS;\n+#endif\n+  return req;\n+}\n+\n+static const ioctl_desc *ioctl_table_lookup(unsigned req) {\n+  int left = 0;\n+  int right = ioctl_table_size;\n+  while (left < right) {\n+    int mid = (left + right) / 2;\n+    if (ioctl_table[mid].req < req)\n+      left = mid + 1;\n+    else\n+      right = mid;\n+  }\n+  if (left == right && ioctl_table[left].req == req)\n+    return ioctl_table + left;\n+  else\n+    return 0;\n+}\n+\n+static const ioctl_desc *ioctl_lookup(unsigned req) {\n+  req = ioctl_request_fixup(req);\n+  const ioctl_desc *desc = ioctl_table_lookup(req);\n+  if (desc) return desc;\n+\n+  // Try stripping access size from the request id.\n+  desc = ioctl_table_lookup(req & ~0x3fff0000U);\n+  // Sanity check: requests that encode access size are either read or write and\n+  // have size of 0 in the table.\n+  if (desc && desc->size == 0 &&\n+      (desc->type == ioctl_desc::WRITE || desc->type == ioctl_desc::READ))\n+    return desc;\n+  return 0;\n+}\n+\n+static void ioctl_common_pre(void *ctx, const ioctl_desc *desc, int d,\n+                             unsigned request, void *arg) {\n+  if (desc->type == ioctl_desc::READ) {\n+    unsigned size = desc->size ? desc->size : IOC_SIZE(request);\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, arg, size);\n+  }\n+  if (desc->type != ioctl_desc::CUSTOM)\n+    return;\n+  switch (request) {\n+    case 0x00008912: {  // SIOCGIFCONF\n+      struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, &ifc->ifc_len, sizeof(ifc->ifc_len));\n+      break;\n+    }\n+  }\n+  return;\n+}\n+\n+static void ioctl_common_post(void *ctx, const ioctl_desc *desc, int res, int d,\n+                              unsigned request, void *arg) {\n+  if (desc->type == ioctl_desc::WRITE) {\n+    // FIXME: add verbose output\n+    unsigned size = desc->size ? desc->size : IOC_SIZE(request);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, arg, size);\n+  }\n+  if (desc->type != ioctl_desc::CUSTOM)\n+    return;\n+  switch (request) {\n+    case 0x00008912: {  // SIOCGIFCONF\n+      struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifc->ifc_ifcu.ifcu_req, ifc->ifc_len);\n+      break;\n+    }\n+  }\n+  return;\n+}"}, {"sha": "2660dada2bebfa388c9af7254291866ce1379c72", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_scanf.inc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -276,7 +276,7 @@ static void scanf_common(void *ctx, int n_inputs, bool allowGnuMalloc,\n   CHECK_GT(n_inputs, 0);\n   const char *p = format;\n \n-  while (*p && n_inputs) {\n+  while (*p) {\n     ScanfDirective dir;\n     p = scanf_parse_next(p, allowGnuMalloc, &dir);\n     if (!p)\n@@ -299,6 +299,8 @@ static void scanf_common(void *ctx, int n_inputs, bool allowGnuMalloc,\n     void *argp = va_arg(aq, void *);\n     if (dir.convSpecifier != 'n')\n       --n_inputs;\n+    if (n_inputs < 0)\n+      break;\n     if (size == SSS_STRLEN) {\n       size = internal_strlen((const char *)argp) + 1;\n     }"}, {"sha": "215a61deab632ed0fd60ca7df085f6594a7c23e9", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,35 @@\n+//===-- sanitizer_common_libcdep.cc ---------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common.h\"\n+\n+namespace __sanitizer {\n+\n+bool PrintsToTty() {\n+  MaybeOpenReportFile();\n+  return internal_isatty(report_fd) != 0;\n+}\n+\n+bool PrintsToTtyCached() {\n+  // FIXME: Add proper Windows support to AnsiColorDecorator and re-enable color\n+  // printing on Windows.\n+  if (SANITIZER_WINDOWS)\n+    return 0;\n+\n+  static int cached = 0;\n+  static bool prints_to_tty;\n+  if (!cached) {  // Not thread-safe.\n+    prints_to_tty = PrintsToTty();\n+    cached = 1;\n+  }\n+  return prints_to_tty;\n+}\n+}  // namespace __sanitizer"}, {"sha": "bc097c847d4a032040298ed93e15210cb21b9126", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "added", "additions": 2732, "deletions": 0, "changes": 2732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,2732 @@\n+//===-- sanitizer_common_syscalls.inc ---------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Common syscalls handlers for tools like AddressSanitizer,\n+// ThreadSanitizer, MemorySanitizer, etc.\n+//\n+// This file should be included into the tool's interceptor file,\n+// which has to define it's own macros:\n+//   COMMON_SYSCALL_PRE_READ_RANGE\n+//          Called in prehook for regions that will be read by the kernel and\n+//          must be initialized.\n+//   COMMON_SYSCALL_PRE_WRITE_RANGE\n+//          Called in prehook for regions that will be written to by the kernel\n+//          and must be addressable. The actual write range may be smaller than\n+//          reported in the prehook. See POST_WRITE_RANGE.\n+//   COMMON_SYSCALL_POST_READ_RANGE\n+//          Called in posthook for regions that were read by the kernel. Does\n+//          not make much sense.\n+//   COMMON_SYSCALL_POST_WRITE_RANGE\n+//          Called in posthook for regions that were written to by the kernel\n+//          and are now initialized.\n+//   COMMON_SYSCALL_FD_CLOSE(fd)\n+//          Called before closing file descriptor fd.\n+//   COMMON_SYSCALL_PRE_FORK()\n+//          Called before fork syscall.\n+//   COMMON_SYSCALL_POST_FORK(long res)\n+//          Called after fork syscall.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n+\n+#include \"sanitizer_libc.h\"\n+\n+#define PRE_SYSCALL(name)                                                      \\\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_syscall_pre_impl_##name\n+#define PRE_READ(p, s) COMMON_SYSCALL_PRE_READ_RANGE(p, s)\n+#define PRE_WRITE(p, s) COMMON_SYSCALL_PRE_WRITE_RANGE(p, s)\n+\n+#define POST_SYSCALL(name)                                                     \\\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_syscall_post_impl_##name\n+#define POST_READ(p, s) COMMON_SYSCALL_POST_READ_RANGE(p, s)\n+#define POST_WRITE(p, s) COMMON_SYSCALL_POST_WRITE_RANGE(p, s)\n+\n+#ifndef COMMON_SYSCALL_FD_CLOSE\n+# define COMMON_SYSCALL_FD_CLOSE(fd)\n+#endif\n+\n+#ifndef COMMON_SYSCALL_PRE_FORK\n+# define COMMON_SYSCALL_PRE_FORK()\n+#endif\n+\n+#ifndef COMMON_SYSCALL_POST_FORK\n+# define COMMON_SYSCALL_POST_FORK(res)\n+#endif\n+\n+// FIXME: do some kind of PRE_READ for all syscall arguments (int(s) and such).\n+\n+extern \"C\" {\n+struct sanitizer_kernel_iovec {\n+  void *iov_base;\n+  unsigned long iov_len;\n+};\n+\n+struct sanitizer_kernel_msghdr {\n+  void *msg_name;\n+  int msg_namelen;\n+  struct sanitizer_kernel_iovec *msg_iov;\n+  unsigned long msg_iovlen;\n+  void *msg_control;\n+  unsigned long msg_controllen;\n+  unsigned msg_flags;\n+};\n+\n+struct sanitizer_kernel_mmsghdr {\n+  struct sanitizer_kernel_msghdr msg_hdr;\n+  unsigned msg_len;\n+};\n+\n+struct sanitizer_kernel_timespec {\n+  long tv_sec;\n+  long tv_nsec;\n+};\n+\n+struct sanitizer_kernel_timeval {\n+  long tv_sec;\n+  long tv_usec;\n+};\n+\n+struct sanitizer_kernel_rusage {\n+  struct sanitizer_kernel_timeval ru_timeval[2];\n+  long ru_long[14];\n+};\n+\n+struct sanitizer_kernel_sockaddr {\n+  unsigned short sa_family;\n+  char sa_data[14];\n+};\n+\n+// Real sigset size is always passed as a syscall argument.\n+// Declare it \"void\" to catch sizeof(kernel_sigset_t).\n+typedef void kernel_sigset_t;\n+\n+static void kernel_write_iovec(const __sanitizer_iovec *iovec,\n+                        SIZE_T iovlen, SIZE_T maxlen) {\n+  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n+    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n+    POST_WRITE(iovec[i].iov_base, sz);\n+    maxlen -= sz;\n+  }\n+}\n+\n+// This functions uses POST_READ, because it needs to run after syscall to know\n+// the real read range.\n+static void kernel_read_iovec(const __sanitizer_iovec *iovec,\n+                       SIZE_T iovlen, SIZE_T maxlen) {\n+  POST_READ(iovec, sizeof(*iovec) * iovlen);\n+  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n+    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n+    POST_READ(iovec[i].iov_base, sz);\n+    maxlen -= sz;\n+  }\n+}\n+\n+PRE_SYSCALL(recvmsg)(long sockfd, sanitizer_kernel_msghdr *msg, long flags) {\n+  PRE_READ(msg, sizeof(*msg));\n+}\n+\n+POST_SYSCALL(recvmsg)(long res, long sockfd, sanitizer_kernel_msghdr *msg,\n+                      long flags) {\n+  if (res >= 0) {\n+    if (msg) {\n+      for (unsigned long i = 0; i < msg->msg_iovlen; ++i) {\n+        POST_WRITE(msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);\n+      }\n+      POST_WRITE(msg->msg_control, msg->msg_controllen);\n+    }\n+  }\n+}\n+\n+PRE_SYSCALL(recvmmsg)(long fd, sanitizer_kernel_mmsghdr *msg, long vlen,\n+                      long flags, void *timeout) {\n+  PRE_READ(msg, vlen * sizeof(*msg));\n+}\n+\n+POST_SYSCALL(recvmmsg)(long res, long fd, sanitizer_kernel_mmsghdr *msg,\n+                       long vlen, long flags, void *timeout) {\n+  if (res >= 0) {\n+    if (msg) {\n+      for (unsigned long i = 0; i < msg->msg_hdr.msg_iovlen; ++i) {\n+        POST_WRITE(msg->msg_hdr.msg_iov[i].iov_base,\n+                   msg->msg_hdr.msg_iov[i].iov_len);\n+      }\n+      POST_WRITE(msg->msg_hdr.msg_control, msg->msg_hdr.msg_controllen);\n+      POST_WRITE(&msg->msg_len, sizeof(msg->msg_len));\n+    }\n+    if (timeout) POST_WRITE(timeout, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(read)(long fd, void *buf, uptr count) {\n+  if (buf) {\n+    PRE_WRITE(buf, count);\n+  }\n+}\n+\n+POST_SYSCALL(read)(long res, long fd, void *buf, uptr count) {\n+  if (res > 0 && buf) {\n+    POST_WRITE(buf, res);\n+  }\n+}\n+\n+PRE_SYSCALL(time)(void *tloc) {}\n+\n+POST_SYSCALL(time)(long res, void *tloc) {\n+  if (res >= 0) {\n+    if (tloc) POST_WRITE(tloc, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(stime)(void *tptr) {}\n+\n+POST_SYSCALL(stime)(long res, void *tptr) {\n+  if (res >= 0) {\n+    if (tptr) POST_WRITE(tptr, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(gettimeofday)(void *tv, void *tz) {}\n+\n+POST_SYSCALL(gettimeofday)(long res, void *tv, void *tz) {\n+  if (res >= 0) {\n+    if (tv) POST_WRITE(tv, timeval_sz);\n+    if (tz) POST_WRITE(tz, struct_timezone_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(settimeofday)(void *tv, void *tz) {}\n+\n+POST_SYSCALL(settimeofday)(long res, void *tv, void *tz) {\n+  if (res >= 0) {\n+    if (tv) POST_WRITE(tv, timeval_sz);\n+    if (tz) POST_WRITE(tz, struct_timezone_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(adjtimex)(void *txc_p) {}\n+\n+POST_SYSCALL(adjtimex)(long res, void *txc_p) {\n+  if (res >= 0) {\n+    if (txc_p) POST_WRITE(txc_p, struct_timex_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(times)(void *tbuf) {}\n+\n+POST_SYSCALL(times)(long res, void *tbuf) {\n+  if (res >= 0) {\n+    if (tbuf) POST_WRITE(tbuf, struct_tms_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(gettid)() {}\n+\n+POST_SYSCALL(gettid)(long res) {}\n+\n+PRE_SYSCALL(nanosleep)(void *rqtp, void *rmtp) {}\n+\n+POST_SYSCALL(nanosleep)(long res, void *rqtp, void *rmtp) {\n+  if (res >= 0) {\n+    if (rqtp) POST_WRITE(rqtp, struct_timespec_sz);\n+    if (rmtp) POST_WRITE(rmtp, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(alarm)(long seconds) {}\n+\n+POST_SYSCALL(alarm)(long res, long seconds) {}\n+\n+PRE_SYSCALL(getpid)() {}\n+\n+POST_SYSCALL(getpid)(long res) {}\n+\n+PRE_SYSCALL(getppid)() {}\n+\n+POST_SYSCALL(getppid)(long res) {}\n+\n+PRE_SYSCALL(getuid)() {}\n+\n+POST_SYSCALL(getuid)(long res) {}\n+\n+PRE_SYSCALL(geteuid)() {}\n+\n+POST_SYSCALL(geteuid)(long res) {}\n+\n+PRE_SYSCALL(getgid)() {}\n+\n+POST_SYSCALL(getgid)(long res) {}\n+\n+PRE_SYSCALL(getegid)() {}\n+\n+POST_SYSCALL(getegid)(long res) {}\n+\n+PRE_SYSCALL(getresuid)(void *ruid, void *euid, void *suid) {}\n+\n+POST_SYSCALL(getresuid)(long res, void *ruid, void *euid, void *suid) {\n+  if (res >= 0) {\n+    if (ruid) POST_WRITE(ruid, sizeof(unsigned));\n+    if (euid) POST_WRITE(euid, sizeof(unsigned));\n+    if (suid) POST_WRITE(suid, sizeof(unsigned));\n+  }\n+}\n+\n+PRE_SYSCALL(getresgid)(void *rgid, void *egid, void *sgid) {}\n+\n+POST_SYSCALL(getresgid)(long res, void *rgid, void *egid, void *sgid) {\n+  if (res >= 0) {\n+    if (rgid) POST_WRITE(rgid, sizeof(unsigned));\n+    if (egid) POST_WRITE(egid, sizeof(unsigned));\n+    if (sgid) POST_WRITE(sgid, sizeof(unsigned));\n+  }\n+}\n+\n+PRE_SYSCALL(getpgid)(long pid) {}\n+\n+POST_SYSCALL(getpgid)(long res, long pid) {}\n+\n+PRE_SYSCALL(getpgrp)() {}\n+\n+POST_SYSCALL(getpgrp)(long res) {}\n+\n+PRE_SYSCALL(getsid)(long pid) {}\n+\n+POST_SYSCALL(getsid)(long res, long pid) {}\n+\n+PRE_SYSCALL(getgroups)(long gidsetsize, void *grouplist) {}\n+\n+POST_SYSCALL(getgroups)(long res, long gidsetsize,\n+                        __sanitizer___kernel_gid_t *grouplist) {\n+  if (res >= 0) {\n+    if (grouplist) POST_WRITE(grouplist, res * sizeof(*grouplist));\n+  }\n+}\n+\n+PRE_SYSCALL(setregid)(long rgid, long egid) {}\n+\n+POST_SYSCALL(setregid)(long res, long rgid, long egid) {}\n+\n+PRE_SYSCALL(setgid)(long gid) {}\n+\n+POST_SYSCALL(setgid)(long res, long gid) {}\n+\n+PRE_SYSCALL(setreuid)(long ruid, long euid) {}\n+\n+POST_SYSCALL(setreuid)(long res, long ruid, long euid) {}\n+\n+PRE_SYSCALL(setuid)(long uid) {}\n+\n+POST_SYSCALL(setuid)(long res, long uid) {}\n+\n+PRE_SYSCALL(setresuid)(long ruid, long euid, long suid) {}\n+\n+POST_SYSCALL(setresuid)(long res, long ruid, long euid, long suid) {}\n+\n+PRE_SYSCALL(setresgid)(long rgid, long egid, long sgid) {}\n+\n+POST_SYSCALL(setresgid)(long res, long rgid, long egid, long sgid) {}\n+\n+PRE_SYSCALL(setfsuid)(long uid) {}\n+\n+POST_SYSCALL(setfsuid)(long res, long uid) {}\n+\n+PRE_SYSCALL(setfsgid)(long gid) {}\n+\n+POST_SYSCALL(setfsgid)(long res, long gid) {}\n+\n+PRE_SYSCALL(setpgid)(long pid, long pgid) {}\n+\n+POST_SYSCALL(setpgid)(long res, long pid, long pgid) {}\n+\n+PRE_SYSCALL(setsid)() {}\n+\n+POST_SYSCALL(setsid)(long res) {}\n+\n+PRE_SYSCALL(setgroups)(long gidsetsize, __sanitizer___kernel_gid_t *grouplist) {\n+  if (grouplist) POST_WRITE(grouplist, gidsetsize * sizeof(*grouplist));\n+}\n+\n+POST_SYSCALL(setgroups)(long res, long gidsetsize,\n+                        __sanitizer___kernel_gid_t *grouplist) {}\n+\n+PRE_SYSCALL(acct)(const void *name) {\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(acct)(long res, const void *name) {}\n+\n+PRE_SYSCALL(capget)(void *header, void *dataptr) {}\n+\n+POST_SYSCALL(capget)(long res, void *header, void *dataptr) {\n+  if (res >= 0) {\n+    if (header) POST_WRITE(header, __user_cap_header_struct_sz);\n+    if (dataptr) POST_WRITE(dataptr, __user_cap_data_struct_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(capset)(void *header, const void *data) {\n+  if (data) PRE_READ(data, __user_cap_data_struct_sz);\n+}\n+\n+POST_SYSCALL(capset)(long res, void *header, const void *data) {\n+  if (res >= 0) {\n+    if (header) POST_WRITE(header, __user_cap_header_struct_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(personality)(long personality) {}\n+\n+POST_SYSCALL(personality)(long res, long personality) {}\n+\n+PRE_SYSCALL(sigpending)(void *set) {}\n+\n+POST_SYSCALL(sigpending)(long res, void *set) {\n+  if (res >= 0) {\n+    if (set) POST_WRITE(set, old_sigset_t_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(sigprocmask)(long how, void *set, void *oset) {}\n+\n+POST_SYSCALL(sigprocmask)(long res, long how, void *set, void *oset) {\n+  if (res >= 0) {\n+    if (set) POST_WRITE(set, old_sigset_t_sz);\n+    if (oset) POST_WRITE(oset, old_sigset_t_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(getitimer)(long which, void *value) {}\n+\n+POST_SYSCALL(getitimer)(long res, long which, void *value) {\n+  if (res >= 0) {\n+    if (value) POST_WRITE(value, struct_itimerval_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(setitimer)(long which, void *value, void *ovalue) {}\n+\n+POST_SYSCALL(setitimer)(long res, long which, void *value, void *ovalue) {\n+  if (res >= 0) {\n+    if (value) POST_WRITE(value, struct_itimerval_sz);\n+    if (ovalue) POST_WRITE(ovalue, struct_itimerval_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(timer_create)(long which_clock, void *timer_event_spec,\n+                          void *created_timer_id) {}\n+\n+POST_SYSCALL(timer_create)(long res, long which_clock, void *timer_event_spec,\n+                           void *created_timer_id) {\n+  if (res >= 0) {\n+    if (timer_event_spec) POST_WRITE(timer_event_spec, struct_sigevent_sz);\n+    if (created_timer_id) POST_WRITE(created_timer_id, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(timer_gettime)(long timer_id, void *setting) {}\n+\n+POST_SYSCALL(timer_gettime)(long res, long timer_id, void *setting) {\n+  if (res >= 0) {\n+    if (setting) POST_WRITE(setting, struct_itimerspec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(timer_getoverrun)(long timer_id) {}\n+\n+POST_SYSCALL(timer_getoverrun)(long res, long timer_id) {}\n+\n+PRE_SYSCALL(timer_settime)(long timer_id, long flags, const void *new_setting,\n+                           void *old_setting) {\n+  if (new_setting) PRE_READ(new_setting, struct_itimerspec_sz);\n+}\n+\n+POST_SYSCALL(timer_settime)(long res, long timer_id, long flags,\n+                            const void *new_setting, void *old_setting) {\n+  if (res >= 0) {\n+    if (old_setting) POST_WRITE(old_setting, struct_itimerspec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(timer_delete)(long timer_id) {}\n+\n+POST_SYSCALL(timer_delete)(long res, long timer_id) {}\n+\n+PRE_SYSCALL(clock_settime)(long which_clock, const void *tp) {\n+  if (tp) PRE_READ(tp, struct_timespec_sz);\n+}\n+\n+POST_SYSCALL(clock_settime)(long res, long which_clock, const void *tp) {}\n+\n+PRE_SYSCALL(clock_gettime)(long which_clock, void *tp) {}\n+\n+POST_SYSCALL(clock_gettime)(long res, long which_clock, void *tp) {\n+  if (res >= 0) {\n+    if (tp) POST_WRITE(tp, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(clock_adjtime)(long which_clock, void *tx) {}\n+\n+POST_SYSCALL(clock_adjtime)(long res, long which_clock, void *tx) {\n+  if (res >= 0) {\n+    if (tx) POST_WRITE(tx, struct_timex_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(clock_getres)(long which_clock, void *tp) {}\n+\n+POST_SYSCALL(clock_getres)(long res, long which_clock, void *tp) {\n+  if (res >= 0) {\n+    if (tp) POST_WRITE(tp, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(clock_nanosleep)(long which_clock, long flags, const void *rqtp,\n+                             void *rmtp) {\n+  if (rqtp) PRE_READ(rqtp, struct_timespec_sz);\n+}\n+\n+POST_SYSCALL(clock_nanosleep)(long res, long which_clock, long flags,\n+                              const void *rqtp, void *rmtp) {\n+  if (res >= 0) {\n+    if (rmtp) POST_WRITE(rmtp, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(nice)(long increment) {}\n+\n+POST_SYSCALL(nice)(long res, long increment) {}\n+\n+PRE_SYSCALL(sched_setscheduler)(long pid, long policy, void *param) {}\n+\n+POST_SYSCALL(sched_setscheduler)(long res, long pid, long policy, void *param) {\n+  if (res >= 0) {\n+    if (param) POST_WRITE(param, struct_sched_param_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(sched_setparam)(long pid, void *param) {\n+  if (param) PRE_READ(param, struct_sched_param_sz);\n+}\n+\n+POST_SYSCALL(sched_setparam)(long res, long pid, void *param) {}\n+\n+PRE_SYSCALL(sched_getscheduler)(long pid) {}\n+\n+POST_SYSCALL(sched_getscheduler)(long res, long pid) {}\n+\n+PRE_SYSCALL(sched_getparam)(long pid, void *param) {}\n+\n+POST_SYSCALL(sched_getparam)(long res, long pid, void *param) {\n+  if (res >= 0) {\n+    if (param) POST_WRITE(param, struct_sched_param_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(sched_setaffinity)(long pid, long len, void *user_mask_ptr) {\n+  if (user_mask_ptr) PRE_READ(user_mask_ptr, len);\n+}\n+\n+POST_SYSCALL(sched_setaffinity)(long res, long pid, long len,\n+                                void *user_mask_ptr) {}\n+\n+PRE_SYSCALL(sched_getaffinity)(long pid, long len, void *user_mask_ptr) {}\n+\n+POST_SYSCALL(sched_getaffinity)(long res, long pid, long len,\n+                                void *user_mask_ptr) {\n+  if (res >= 0) {\n+    if (user_mask_ptr) POST_WRITE(user_mask_ptr, len);\n+  }\n+}\n+\n+PRE_SYSCALL(sched_yield)() {}\n+\n+POST_SYSCALL(sched_yield)(long res) {}\n+\n+PRE_SYSCALL(sched_get_priority_max)(long policy) {}\n+\n+POST_SYSCALL(sched_get_priority_max)(long res, long policy) {}\n+\n+PRE_SYSCALL(sched_get_priority_min)(long policy) {}\n+\n+POST_SYSCALL(sched_get_priority_min)(long res, long policy) {}\n+\n+PRE_SYSCALL(sched_rr_get_interval)(long pid, void *interval) {}\n+\n+POST_SYSCALL(sched_rr_get_interval)(long res, long pid, void *interval) {\n+  if (res >= 0) {\n+    if (interval) POST_WRITE(interval, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(setpriority)(long which, long who, long niceval) {}\n+\n+POST_SYSCALL(setpriority)(long res, long which, long who, long niceval) {}\n+\n+PRE_SYSCALL(getpriority)(long which, long who) {}\n+\n+POST_SYSCALL(getpriority)(long res, long which, long who) {}\n+\n+PRE_SYSCALL(shutdown)(long arg0, long arg1) {}\n+\n+POST_SYSCALL(shutdown)(long res, long arg0, long arg1) {}\n+\n+PRE_SYSCALL(reboot)(long magic1, long magic2, long cmd, void *arg) {}\n+\n+POST_SYSCALL(reboot)(long res, long magic1, long magic2, long cmd, void *arg) {}\n+\n+PRE_SYSCALL(restart_syscall)() {}\n+\n+POST_SYSCALL(restart_syscall)(long res) {}\n+\n+PRE_SYSCALL(kexec_load)(long entry, long nr_segments, void *segments,\n+                        long flags) {}\n+\n+POST_SYSCALL(kexec_load)(long res, long entry, long nr_segments, void *segments,\n+                         long flags) {\n+  if (res >= 0) {\n+    if (segments) POST_WRITE(segments, struct_kexec_segment_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(exit)(long error_code) {}\n+\n+POST_SYSCALL(exit)(long res, long error_code) {}\n+\n+PRE_SYSCALL(exit_group)(long error_code) {}\n+\n+POST_SYSCALL(exit_group)(long res, long error_code) {}\n+\n+PRE_SYSCALL(wait4)(long pid, void *stat_addr, long options, void *ru) {}\n+\n+POST_SYSCALL(wait4)(long res, long pid, void *stat_addr, long options,\n+                    void *ru) {\n+  if (res >= 0) {\n+    if (stat_addr) POST_WRITE(stat_addr, sizeof(int));\n+    if (ru) POST_WRITE(ru, struct_rusage_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(waitid)(long which, long pid, void *infop, long options, void *ru) {\n+}\n+\n+POST_SYSCALL(waitid)(long res, long which, long pid, void *infop, long options,\n+                     void *ru) {\n+  if (res >= 0) {\n+    if (infop) POST_WRITE(infop, siginfo_t_sz);\n+    if (ru) POST_WRITE(ru, struct_rusage_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(waitpid)(long pid, void *stat_addr, long options) {}\n+\n+POST_SYSCALL(waitpid)(long res, long pid, void *stat_addr, long options) {\n+  if (res >= 0) {\n+    if (stat_addr) POST_WRITE(stat_addr, sizeof(int));\n+  }\n+}\n+\n+PRE_SYSCALL(set_tid_address)(void *tidptr) {}\n+\n+POST_SYSCALL(set_tid_address)(long res, void *tidptr) {\n+  if (res >= 0) {\n+    if (tidptr) POST_WRITE(tidptr, sizeof(int));\n+  }\n+}\n+\n+PRE_SYSCALL(init_module)(void *umod, long len, const void *uargs) {\n+  if (uargs)\n+    PRE_READ(uargs, __sanitizer::internal_strlen((const char *)uargs) + 1);\n+}\n+\n+POST_SYSCALL(init_module)(long res, void *umod, long len, const void *uargs) {}\n+\n+PRE_SYSCALL(delete_module)(const void *name_user, long flags) {\n+  if (name_user)\n+    PRE_READ(name_user,\n+             __sanitizer::internal_strlen((const char *)name_user) + 1);\n+}\n+\n+POST_SYSCALL(delete_module)(long res, const void *name_user, long flags) {}\n+\n+PRE_SYSCALL(rt_sigprocmask)(long how, void *set, void *oset, long sigsetsize) {}\n+\n+POST_SYSCALL(rt_sigprocmask)(long res, long how, kernel_sigset_t *set,\n+                             kernel_sigset_t *oset, long sigsetsize) {\n+  if (res >= 0) {\n+    if (set) POST_WRITE(set, sigsetsize);\n+    if (oset) POST_WRITE(oset, sigsetsize);\n+  }\n+}\n+\n+PRE_SYSCALL(rt_sigpending)(void *set, long sigsetsize) {}\n+\n+POST_SYSCALL(rt_sigpending)(long res, kernel_sigset_t *set, long sigsetsize) {\n+  if (res >= 0) {\n+    if (set) POST_WRITE(set, sigsetsize);\n+  }\n+}\n+\n+PRE_SYSCALL(rt_sigtimedwait)(const kernel_sigset_t *uthese, void *uinfo,\n+                             const void *uts, long sigsetsize) {\n+  if (uthese) PRE_READ(uthese, sigsetsize);\n+  if (uts) PRE_READ(uts, struct_timespec_sz);\n+}\n+\n+POST_SYSCALL(rt_sigtimedwait)(long res, const void *uthese, void *uinfo,\n+                              const void *uts, long sigsetsize) {\n+  if (res >= 0) {\n+    if (uinfo) POST_WRITE(uinfo, siginfo_t_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(rt_tgsigqueueinfo)(long tgid, long pid, long sig, void *uinfo) {}\n+\n+POST_SYSCALL(rt_tgsigqueueinfo)(long res, long tgid, long pid, long sig,\n+                                void *uinfo) {\n+  if (res >= 0) {\n+    if (uinfo) POST_WRITE(uinfo, siginfo_t_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(kill)(long pid, long sig) {}\n+\n+POST_SYSCALL(kill)(long res, long pid, long sig) {}\n+\n+PRE_SYSCALL(tgkill)(long tgid, long pid, long sig) {}\n+\n+POST_SYSCALL(tgkill)(long res, long tgid, long pid, long sig) {}\n+\n+PRE_SYSCALL(tkill)(long pid, long sig) {}\n+\n+POST_SYSCALL(tkill)(long res, long pid, long sig) {}\n+\n+PRE_SYSCALL(rt_sigqueueinfo)(long pid, long sig, void *uinfo) {}\n+\n+POST_SYSCALL(rt_sigqueueinfo)(long res, long pid, long sig, void *uinfo) {\n+  if (res >= 0) {\n+    if (uinfo) POST_WRITE(uinfo, siginfo_t_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(sgetmask)() {}\n+\n+POST_SYSCALL(sgetmask)(long res) {}\n+\n+PRE_SYSCALL(ssetmask)(long newmask) {}\n+\n+POST_SYSCALL(ssetmask)(long res, long newmask) {}\n+\n+PRE_SYSCALL(signal)(long sig, long handler) {}\n+\n+POST_SYSCALL(signal)(long res, long sig, long handler) {}\n+\n+PRE_SYSCALL(pause)() {}\n+\n+POST_SYSCALL(pause)(long res) {}\n+\n+PRE_SYSCALL(sync)() {}\n+\n+POST_SYSCALL(sync)(long res) {}\n+\n+PRE_SYSCALL(fsync)(long fd) {}\n+\n+POST_SYSCALL(fsync)(long res, long fd) {}\n+\n+PRE_SYSCALL(fdatasync)(long fd) {}\n+\n+POST_SYSCALL(fdatasync)(long res, long fd) {}\n+\n+PRE_SYSCALL(bdflush)(long func, long data) {}\n+\n+POST_SYSCALL(bdflush)(long res, long func, long data) {}\n+\n+PRE_SYSCALL(mount)(void *dev_name, void *dir_name, void *type, long flags,\n+                   void *data) {}\n+\n+POST_SYSCALL(mount)(long res, void *dev_name, void *dir_name, void *type,\n+                    long flags, void *data) {\n+  if (res >= 0) {\n+    if (dev_name)\n+      POST_WRITE(dev_name,\n+                 __sanitizer::internal_strlen((const char *)dev_name) + 1);\n+    if (dir_name)\n+      POST_WRITE(dir_name,\n+                 __sanitizer::internal_strlen((const char *)dir_name) + 1);\n+    if (type)\n+      POST_WRITE(type, __sanitizer::internal_strlen((const char *)type) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(umount)(void *name, long flags) {}\n+\n+POST_SYSCALL(umount)(long res, void *name, long flags) {\n+  if (res >= 0) {\n+    if (name)\n+      POST_WRITE(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(oldumount)(void *name) {}\n+\n+POST_SYSCALL(oldumount)(long res, void *name) {\n+  if (res >= 0) {\n+    if (name)\n+      POST_WRITE(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(truncate)(const void *path, long length) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(truncate)(long res, const void *path, long length) {}\n+\n+PRE_SYSCALL(ftruncate)(long fd, long length) {}\n+\n+POST_SYSCALL(ftruncate)(long res, long fd, long length) {}\n+\n+PRE_SYSCALL(stat)(const void *filename, void *statbuf) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(stat)(long res, const void *filename, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct___old_kernel_stat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(statfs)(const void *path, void *buf) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(statfs)(long res, const void *path, void *buf) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, struct_statfs_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(statfs64)(const void *path, long sz, void *buf) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(statfs64)(long res, const void *path, long sz, void *buf) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, struct_statfs64_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(fstatfs)(long fd, void *buf) {}\n+\n+POST_SYSCALL(fstatfs)(long res, long fd, void *buf) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, struct_statfs_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(fstatfs64)(long fd, long sz, void *buf) {}\n+\n+POST_SYSCALL(fstatfs64)(long res, long fd, long sz, void *buf) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, struct_statfs64_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(lstat)(const void *filename, void *statbuf) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(lstat)(long res, const void *filename, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct___old_kernel_stat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(fstat)(long fd, void *statbuf) {}\n+\n+POST_SYSCALL(fstat)(long res, long fd, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct___old_kernel_stat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(newstat)(const void *filename, void *statbuf) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(newstat)(long res, const void *filename, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(newlstat)(const void *filename, void *statbuf) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(newlstat)(long res, const void *filename, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(newfstat)(long fd, void *statbuf) {}\n+\n+POST_SYSCALL(newfstat)(long res, long fd, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(ustat)(long dev, void *ubuf) {}\n+\n+POST_SYSCALL(ustat)(long res, long dev, void *ubuf) {\n+  if (res >= 0) {\n+    if (ubuf) POST_WRITE(ubuf, struct_ustat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(stat64)(const void *filename, void *statbuf) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(stat64)(long res, const void *filename, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat64_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(fstat64)(long fd, void *statbuf) {}\n+\n+POST_SYSCALL(fstat64)(long res, long fd, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat64_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(lstat64)(const void *filename, void *statbuf) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(lstat64)(long res, const void *filename, void *statbuf) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat64_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(setxattr)(const void *path, const void *name, const void *value,\n+                      long size, long flags) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  if (value) PRE_READ(value, size);\n+}\n+\n+POST_SYSCALL(setxattr)(long res, const void *path, const void *name,\n+                       const void *value, long size, long flags) {}\n+\n+PRE_SYSCALL(lsetxattr)(const void *path, const void *name, const void *value,\n+                       long size, long flags) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  if (value) PRE_READ(value, size);\n+}\n+\n+POST_SYSCALL(lsetxattr)(long res, const void *path, const void *name,\n+                        const void *value, long size, long flags) {}\n+\n+PRE_SYSCALL(fsetxattr)(long fd, const void *name, const void *value, long size,\n+                       long flags) {\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  if (value) PRE_READ(value, size);\n+}\n+\n+POST_SYSCALL(fsetxattr)(long res, long fd, const void *name, const void *value,\n+                        long size, long flags) {}\n+\n+PRE_SYSCALL(getxattr)(const void *path, const void *name, void *value,\n+                      long size) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(getxattr)(long res, const void *path, const void *name,\n+                       void *value, long size) {\n+  if (res >= 0) {\n+    if (value) POST_WRITE(value, size);\n+  }\n+}\n+\n+PRE_SYSCALL(lgetxattr)(const void *path, const void *name, void *value,\n+                       long size) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(lgetxattr)(long res, const void *path, const void *name,\n+                        void *value, long size) {\n+  if (res >= 0) {\n+    if (value) POST_WRITE(value, size);\n+  }\n+}\n+\n+PRE_SYSCALL(fgetxattr)(long fd, const void *name, void *value, long size) {\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(fgetxattr)(long res, long fd, const void *name, void *value,\n+                        long size) {\n+  if (res >= 0) {\n+    if (value) POST_WRITE(value, size);\n+  }\n+}\n+\n+PRE_SYSCALL(listxattr)(const void *path, void *list, long size) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(listxattr)(long res, const void *path, void *list, long size) {\n+  if (res >= 0) {\n+    if (list) POST_WRITE(list, size);\n+  }\n+}\n+\n+PRE_SYSCALL(llistxattr)(const void *path, void *list, long size) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(llistxattr)(long res, const void *path, void *list, long size) {\n+  if (res >= 0) {\n+    if (list) POST_WRITE(list, size);\n+  }\n+}\n+\n+PRE_SYSCALL(flistxattr)(long fd, void *list, long size) {}\n+\n+POST_SYSCALL(flistxattr)(long res, long fd, void *list, long size) {\n+  if (res >= 0) {\n+    if (list) POST_WRITE(list, size);\n+  }\n+}\n+\n+PRE_SYSCALL(removexattr)(const void *path, const void *name) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(removexattr)(long res, const void *path, const void *name) {}\n+\n+PRE_SYSCALL(lremovexattr)(const void *path, const void *name) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(lremovexattr)(long res, const void *path, const void *name) {}\n+\n+PRE_SYSCALL(fremovexattr)(long fd, const void *name) {\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(fremovexattr)(long res, long fd, const void *name) {}\n+\n+PRE_SYSCALL(brk)(long brk) {}\n+\n+POST_SYSCALL(brk)(long res, long brk) {}\n+\n+PRE_SYSCALL(mprotect)(long start, long len, long prot) {}\n+\n+POST_SYSCALL(mprotect)(long res, long start, long len, long prot) {}\n+\n+PRE_SYSCALL(mremap)(long addr, long old_len, long new_len, long flags,\n+                    long new_addr) {}\n+\n+POST_SYSCALL(mremap)(long res, long addr, long old_len, long new_len,\n+                     long flags, long new_addr) {}\n+\n+PRE_SYSCALL(remap_file_pages)(long start, long size, long prot, long pgoff,\n+                              long flags) {}\n+\n+POST_SYSCALL(remap_file_pages)(long res, long start, long size, long prot,\n+                               long pgoff, long flags) {}\n+\n+PRE_SYSCALL(msync)(long start, long len, long flags) {}\n+\n+POST_SYSCALL(msync)(long res, long start, long len, long flags) {}\n+\n+PRE_SYSCALL(munmap)(long addr, long len) {}\n+\n+POST_SYSCALL(munmap)(long res, long addr, long len) {}\n+\n+PRE_SYSCALL(mlock)(long start, long len) {}\n+\n+POST_SYSCALL(mlock)(long res, long start, long len) {}\n+\n+PRE_SYSCALL(munlock)(long start, long len) {}\n+\n+POST_SYSCALL(munlock)(long res, long start, long len) {}\n+\n+PRE_SYSCALL(mlockall)(long flags) {}\n+\n+POST_SYSCALL(mlockall)(long res, long flags) {}\n+\n+PRE_SYSCALL(munlockall)() {}\n+\n+POST_SYSCALL(munlockall)(long res) {}\n+\n+PRE_SYSCALL(madvise)(long start, long len, long behavior) {}\n+\n+POST_SYSCALL(madvise)(long res, long start, long len, long behavior) {}\n+\n+PRE_SYSCALL(mincore)(long start, long len, void *vec) {}\n+\n+POST_SYSCALL(mincore)(long res, long start, long len, void *vec) {\n+  if (res >= 0) {\n+    if (vec) {\n+      POST_WRITE(vec, (len + GetPageSizeCached() - 1) / GetPageSizeCached());\n+    }\n+  }\n+}\n+\n+PRE_SYSCALL(pivot_root)(const void *new_root, const void *put_old) {\n+  if (new_root)\n+    PRE_READ(new_root,\n+             __sanitizer::internal_strlen((const char *)new_root) + 1);\n+  if (put_old)\n+    PRE_READ(put_old, __sanitizer::internal_strlen((const char *)put_old) + 1);\n+}\n+\n+POST_SYSCALL(pivot_root)(long res, const void *new_root, const void *put_old) {}\n+\n+PRE_SYSCALL(chroot)(const void *filename) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(chroot)(long res, const void *filename) {}\n+\n+PRE_SYSCALL(mknod)(const void *filename, long mode, long dev) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(mknod)(long res, const void *filename, long mode, long dev) {}\n+\n+PRE_SYSCALL(link)(const void *oldname, const void *newname) {\n+  if (oldname)\n+    PRE_READ(oldname, __sanitizer::internal_strlen((const char *)oldname) + 1);\n+  if (newname)\n+    PRE_READ(newname, __sanitizer::internal_strlen((const char *)newname) + 1);\n+}\n+\n+POST_SYSCALL(link)(long res, const void *oldname, const void *newname) {}\n+\n+PRE_SYSCALL(symlink)(const void *old, const void *new_) {\n+  if (old) PRE_READ(old, __sanitizer::internal_strlen((const char *)old) + 1);\n+  if (new_)\n+    PRE_READ(new_, __sanitizer::internal_strlen((const char *)new_) + 1);\n+}\n+\n+POST_SYSCALL(symlink)(long res, const void *old, const void *new_) {}\n+\n+PRE_SYSCALL(unlink)(const void *pathname) {\n+  if (pathname)\n+    PRE_READ(pathname,\n+             __sanitizer::internal_strlen((const char *)pathname) + 1);\n+}\n+\n+POST_SYSCALL(unlink)(long res, const void *pathname) {}\n+\n+PRE_SYSCALL(rename)(const void *oldname, const void *newname) {\n+  if (oldname)\n+    PRE_READ(oldname, __sanitizer::internal_strlen((const char *)oldname) + 1);\n+  if (newname)\n+    PRE_READ(newname, __sanitizer::internal_strlen((const char *)newname) + 1);\n+}\n+\n+POST_SYSCALL(rename)(long res, const void *oldname, const void *newname) {}\n+\n+PRE_SYSCALL(chmod)(const void *filename, long mode) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(chmod)(long res, const void *filename, long mode) {}\n+\n+PRE_SYSCALL(fchmod)(long fd, long mode) {}\n+\n+POST_SYSCALL(fchmod)(long res, long fd, long mode) {}\n+\n+PRE_SYSCALL(fcntl)(long fd, long cmd, long arg) {}\n+\n+POST_SYSCALL(fcntl)(long res, long fd, long cmd, long arg) {}\n+\n+PRE_SYSCALL(fcntl64)(long fd, long cmd, long arg) {}\n+\n+POST_SYSCALL(fcntl64)(long res, long fd, long cmd, long arg) {}\n+\n+PRE_SYSCALL(pipe)(void *fildes) {}\n+\n+POST_SYSCALL(pipe)(long res, void *fildes) {\n+  if (res >= 0) {\n+    if (fildes) POST_WRITE(fildes, sizeof(int));\n+  }\n+}\n+\n+PRE_SYSCALL(pipe2)(void *fildes, long flags) {}\n+\n+POST_SYSCALL(pipe2)(long res, void *fildes, long flags) {\n+  if (res >= 0) {\n+    if (fildes) POST_WRITE(fildes, sizeof(int));\n+  }\n+}\n+\n+PRE_SYSCALL(dup)(long fildes) {}\n+\n+POST_SYSCALL(dup)(long res, long fildes) {}\n+\n+PRE_SYSCALL(dup2)(long oldfd, long newfd) {}\n+\n+POST_SYSCALL(dup2)(long res, long oldfd, long newfd) {}\n+\n+PRE_SYSCALL(dup3)(long oldfd, long newfd, long flags) {}\n+\n+POST_SYSCALL(dup3)(long res, long oldfd, long newfd, long flags) {}\n+\n+PRE_SYSCALL(ioperm)(long from, long num, long on) {}\n+\n+POST_SYSCALL(ioperm)(long res, long from, long num, long on) {}\n+\n+PRE_SYSCALL(ioctl)(long fd, long cmd, long arg) {}\n+\n+POST_SYSCALL(ioctl)(long res, long fd, long cmd, long arg) {}\n+\n+PRE_SYSCALL(flock)(long fd, long cmd) {}\n+\n+POST_SYSCALL(flock)(long res, long fd, long cmd) {}\n+\n+PRE_SYSCALL(io_setup)(long nr_reqs, void *ctx) {}\n+\n+POST_SYSCALL(io_setup)(long res, long nr_reqs, void *ctx) {\n+  if (res >= 0) {\n+    if (ctx) POST_WRITE(ctx, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(io_destroy)(long ctx) {}\n+\n+POST_SYSCALL(io_destroy)(long res, long ctx) {}\n+\n+PRE_SYSCALL(io_getevents)(long ctx_id, long min_nr, long nr, void *events,\n+                          void *timeout) {\n+  if (timeout) PRE_READ(timeout, struct_timespec_sz);\n+}\n+\n+POST_SYSCALL(io_getevents)(long res, long ctx_id, long min_nr, long nr,\n+                           void *events, void *timeout) {\n+  if (res >= 0) {\n+    if (events) POST_WRITE(events, res * struct_io_event_sz);\n+    if (timeout) POST_WRITE(timeout, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(io_submit)(long, long arg1, void *arg2) {}\n+\n+POST_SYSCALL(io_submit)(long res, long, long arg1, void *arg2) {}\n+\n+PRE_SYSCALL(io_cancel)(long ctx_id, void *iocb, void *result) {}\n+\n+POST_SYSCALL(io_cancel)(long res, long ctx_id, void *iocb, void *result) {\n+  if (res >= 0) {\n+    if (iocb) POST_WRITE(iocb, struct_iocb_sz);\n+    if (result) POST_WRITE(result, struct_io_event_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(sendfile)(long out_fd, long in_fd, void *offset, long count) {}\n+\n+POST_SYSCALL(sendfile)(long res, long out_fd, long in_fd,\n+                       __sanitizer___kernel_off_t *offset, long count) {\n+  if (res >= 0) {\n+    if (offset) POST_WRITE(offset, sizeof(*offset));\n+  }\n+}\n+\n+PRE_SYSCALL(sendfile64)(long out_fd, long in_fd, void *offset, long count) {}\n+\n+POST_SYSCALL(sendfile64)(long res, long out_fd, long in_fd,\n+                         __sanitizer___kernel_loff_t *offset, long count) {\n+  if (res >= 0) {\n+    if (offset) POST_WRITE(offset, sizeof(*offset));\n+  }\n+}\n+\n+PRE_SYSCALL(readlink)(const void *path, void *buf, long bufsiz) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(readlink)(long res, const void *path, void *buf, long bufsiz) {\n+  if (res >= 0) {\n+    if (buf)\n+      POST_WRITE(buf, __sanitizer::internal_strlen((const char *)buf) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(creat)(const void *pathname, long mode) {\n+  if (pathname)\n+    PRE_READ(pathname,\n+             __sanitizer::internal_strlen((const char *)pathname) + 1);\n+}\n+\n+POST_SYSCALL(creat)(long res, const void *pathname, long mode) {}\n+\n+PRE_SYSCALL(open)(const void *filename, long flags, long mode) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(open)(long res, const void *filename, long flags, long mode) {}\n+\n+PRE_SYSCALL(close)(long fd) {\n+  COMMON_SYSCALL_FD_CLOSE((int)fd);\n+}\n+\n+POST_SYSCALL(close)(long res, long fd) {}\n+\n+PRE_SYSCALL(access)(const void *filename, long mode) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(access)(long res, const void *filename, long mode) {}\n+\n+PRE_SYSCALL(vhangup)() {}\n+\n+POST_SYSCALL(vhangup)(long res) {}\n+\n+PRE_SYSCALL(chown)(const void *filename, long user, long group) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(chown)(long res, const void *filename, long user, long group) {}\n+\n+PRE_SYSCALL(lchown)(const void *filename, long user, long group) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(lchown)(long res, const void *filename, long user, long group) {}\n+\n+PRE_SYSCALL(fchown)(long fd, long user, long group) {}\n+\n+POST_SYSCALL(fchown)(long res, long fd, long user, long group) {}\n+\n+PRE_SYSCALL(chown16)(const void *filename, long user, long group) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(chown16)(long res, const void *filename, long user, long group) {}\n+\n+PRE_SYSCALL(lchown16)(const void *filename, long user, long group) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(lchown16)(long res, const void *filename, long user, long group) {}\n+\n+PRE_SYSCALL(fchown16)(long fd, long user, long group) {}\n+\n+POST_SYSCALL(fchown16)(long res, long fd, long user, long group) {}\n+\n+PRE_SYSCALL(setregid16)(long rgid, long egid) {}\n+\n+POST_SYSCALL(setregid16)(long res, long rgid, long egid) {}\n+\n+PRE_SYSCALL(setgid16)(long gid) {}\n+\n+POST_SYSCALL(setgid16)(long res, long gid) {}\n+\n+PRE_SYSCALL(setreuid16)(long ruid, long euid) {}\n+\n+POST_SYSCALL(setreuid16)(long res, long ruid, long euid) {}\n+\n+PRE_SYSCALL(setuid16)(long uid) {}\n+\n+POST_SYSCALL(setuid16)(long res, long uid) {}\n+\n+PRE_SYSCALL(setresuid16)(long ruid, long euid, long suid) {}\n+\n+POST_SYSCALL(setresuid16)(long res, long ruid, long euid, long suid) {}\n+\n+PRE_SYSCALL(getresuid16)(void *ruid, void *euid, void *suid) {}\n+\n+POST_SYSCALL(getresuid16)(long res, __sanitizer___kernel_old_uid_t *ruid,\n+                          __sanitizer___kernel_old_uid_t *euid,\n+                          __sanitizer___kernel_old_uid_t *suid) {\n+  if (res >= 0) {\n+    if (ruid) POST_WRITE(ruid, sizeof(*ruid));\n+    if (euid) POST_WRITE(euid, sizeof(*euid));\n+    if (suid) POST_WRITE(suid, sizeof(*suid));\n+  }\n+}\n+\n+PRE_SYSCALL(setresgid16)(long rgid, long egid, long sgid) {}\n+\n+POST_SYSCALL(setresgid16)(long res, long rgid, long egid, long sgid) {}\n+\n+PRE_SYSCALL(getresgid16)(void *rgid, void *egid, void *sgid) {}\n+\n+POST_SYSCALL(getresgid16)(long res, __sanitizer___kernel_old_gid_t *rgid,\n+                          __sanitizer___kernel_old_gid_t *egid,\n+                          __sanitizer___kernel_old_gid_t *sgid) {\n+  if (res >= 0) {\n+    if (rgid) POST_WRITE(rgid, sizeof(*rgid));\n+    if (egid) POST_WRITE(egid, sizeof(*egid));\n+    if (sgid) POST_WRITE(sgid, sizeof(*sgid));\n+  }\n+}\n+\n+PRE_SYSCALL(setfsuid16)(long uid) {}\n+\n+POST_SYSCALL(setfsuid16)(long res, long uid) {}\n+\n+PRE_SYSCALL(setfsgid16)(long gid) {}\n+\n+POST_SYSCALL(setfsgid16)(long res, long gid) {}\n+\n+PRE_SYSCALL(getgroups16)(long gidsetsize,\n+                         __sanitizer___kernel_old_gid_t *grouplist) {}\n+\n+POST_SYSCALL(getgroups16)(long res, long gidsetsize,\n+                          __sanitizer___kernel_old_gid_t *grouplist) {\n+  if (res >= 0) {\n+    if (grouplist) POST_WRITE(grouplist, res * sizeof(*grouplist));\n+  }\n+}\n+\n+PRE_SYSCALL(setgroups16)(long gidsetsize,\n+                         __sanitizer___kernel_old_gid_t *grouplist) {\n+  if (grouplist) POST_WRITE(grouplist, gidsetsize * sizeof(*grouplist));\n+}\n+\n+POST_SYSCALL(setgroups16)(long res, long gidsetsize,\n+                          __sanitizer___kernel_old_gid_t *grouplist) {}\n+\n+PRE_SYSCALL(getuid16)() {}\n+\n+POST_SYSCALL(getuid16)(long res) {}\n+\n+PRE_SYSCALL(geteuid16)() {}\n+\n+POST_SYSCALL(geteuid16)(long res) {}\n+\n+PRE_SYSCALL(getgid16)() {}\n+\n+POST_SYSCALL(getgid16)(long res) {}\n+\n+PRE_SYSCALL(getegid16)() {}\n+\n+POST_SYSCALL(getegid16)(long res) {}\n+\n+PRE_SYSCALL(utime)(void *filename, void *times) {}\n+\n+POST_SYSCALL(utime)(long res, void *filename, void *times) {\n+  if (res >= 0) {\n+    if (filename)\n+      POST_WRITE(filename,\n+                 __sanitizer::internal_strlen((const char *)filename) + 1);\n+    if (times) POST_WRITE(times, struct_utimbuf_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(utimes)(void *filename, void *utimes) {}\n+\n+POST_SYSCALL(utimes)(long res, void *filename, void *utimes) {\n+  if (res >= 0) {\n+    if (filename)\n+      POST_WRITE(filename,\n+                 __sanitizer::internal_strlen((const char *)filename) + 1);\n+    if (utimes) POST_WRITE(utimes, timeval_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(lseek)(long fd, long offset, long origin) {}\n+\n+POST_SYSCALL(lseek)(long res, long fd, long offset, long origin) {}\n+\n+PRE_SYSCALL(llseek)(long fd, long offset_high, long offset_low, void *result,\n+                    long origin) {}\n+\n+POST_SYSCALL(llseek)(long res, long fd, long offset_high, long offset_low,\n+                     void *result, long origin) {\n+  if (res >= 0) {\n+    if (result) POST_WRITE(result, sizeof(long long));\n+  }\n+}\n+\n+PRE_SYSCALL(readv)(long fd, const __sanitizer_iovec *vec, long vlen) {}\n+\n+POST_SYSCALL(readv)(long res, long fd, const __sanitizer_iovec *vec,\n+                    long vlen) {\n+  if (res >= 0) {\n+    if (vec) kernel_write_iovec(vec, vlen, res);\n+  }\n+}\n+\n+PRE_SYSCALL(write)(long fd, const void *buf, long count) {\n+  if (buf) PRE_READ(buf, count);\n+}\n+\n+POST_SYSCALL(write)(long res, long fd, const void *buf, long count) {}\n+\n+PRE_SYSCALL(writev)(long fd, const __sanitizer_iovec *vec, long vlen) {}\n+\n+POST_SYSCALL(writev)(long res, long fd, const __sanitizer_iovec *vec,\n+                     long vlen) {\n+  if (res >= 0) {\n+    if (vec) kernel_read_iovec(vec, vlen, res);\n+  }\n+}\n+\n+#ifdef _LP64\n+PRE_SYSCALL(pread64)(long fd, void *buf, long count, long pos) {}\n+\n+POST_SYSCALL(pread64)(long res, long fd, void *buf, long count, long pos) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, res);\n+  }\n+}\n+\n+PRE_SYSCALL(pwrite64)(long fd, const void *buf, long count, long pos) {\n+  if (buf) PRE_READ(buf, count);\n+}\n+\n+POST_SYSCALL(pwrite64)(long res, long fd, const void *buf, long count,\n+                       long pos) {}\n+#else\n+PRE_SYSCALL(pread64)(long fd, void *buf, long count, long pos0, long pos1) {}\n+\n+POST_SYSCALL(pread64)(long res, long fd, void *buf, long count, long pos0,\n+                      long pos1) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, res);\n+  }\n+}\n+\n+PRE_SYSCALL(pwrite64)(long fd, const void *buf, long count, long pos0,\n+                      long pos1) {\n+  if (buf) PRE_READ(buf, count);\n+}\n+\n+POST_SYSCALL(pwrite64)(long res, long fd, const void *buf, long count,\n+                       long pos0, long pos1) {}\n+#endif\n+\n+PRE_SYSCALL(preadv)(long fd, const __sanitizer_iovec *vec, long vlen,\n+                    long pos_l, long pos_h) {}\n+\n+POST_SYSCALL(preadv)(long res, long fd, const __sanitizer_iovec *vec, long vlen,\n+                     long pos_l, long pos_h) {\n+  if (res >= 0) {\n+    if (vec) kernel_write_iovec(vec, vlen, res);\n+  }\n+}\n+\n+PRE_SYSCALL(pwritev)(long fd, const __sanitizer_iovec *vec, long vlen,\n+                     long pos_l, long pos_h) {}\n+\n+POST_SYSCALL(pwritev)(long res, long fd, const __sanitizer_iovec *vec,\n+                      long vlen, long pos_l, long pos_h) {\n+  if (res >= 0) {\n+    if (vec) kernel_read_iovec(vec, vlen, res);\n+  }\n+}\n+\n+PRE_SYSCALL(getcwd)(void *buf, long size) {}\n+\n+POST_SYSCALL(getcwd)(long res, void *buf, long size) {\n+  if (res >= 0) {\n+    if (buf)\n+      POST_WRITE(buf, __sanitizer::internal_strlen((const char *)buf) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(mkdir)(const void *pathname, long mode) {\n+  if (pathname)\n+    PRE_READ(pathname,\n+             __sanitizer::internal_strlen((const char *)pathname) + 1);\n+}\n+\n+POST_SYSCALL(mkdir)(long res, const void *pathname, long mode) {}\n+\n+PRE_SYSCALL(chdir)(const void *filename) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(chdir)(long res, const void *filename) {}\n+\n+PRE_SYSCALL(fchdir)(long fd) {}\n+\n+POST_SYSCALL(fchdir)(long res, long fd) {}\n+\n+PRE_SYSCALL(rmdir)(const void *pathname) {\n+  if (pathname)\n+    PRE_READ(pathname,\n+             __sanitizer::internal_strlen((const char *)pathname) + 1);\n+}\n+\n+POST_SYSCALL(rmdir)(long res, const void *pathname) {}\n+\n+PRE_SYSCALL(lookup_dcookie)(u64 cookie64, void *buf, long len) {}\n+\n+POST_SYSCALL(lookup_dcookie)(long res, u64 cookie64, void *buf, long len) {\n+  if (res >= 0) {\n+    if (buf)\n+      POST_WRITE(buf, __sanitizer::internal_strlen((const char *)buf) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(quotactl)(long cmd, const void *special, long id, void *addr) {\n+  if (special)\n+    PRE_READ(special, __sanitizer::internal_strlen((const char *)special) + 1);\n+}\n+\n+POST_SYSCALL(quotactl)(long res, long cmd, const void *special, long id,\n+                       void *addr) {}\n+\n+PRE_SYSCALL(getdents)(long fd, void *dirent, long count) {}\n+\n+POST_SYSCALL(getdents)(long res, long fd, void *dirent, long count) {\n+  if (res >= 0) {\n+    if (dirent) POST_WRITE(dirent, res);\n+  }\n+}\n+\n+PRE_SYSCALL(getdents64)(long fd, void *dirent, long count) {}\n+\n+POST_SYSCALL(getdents64)(long res, long fd, void *dirent, long count) {\n+  if (res >= 0) {\n+    if (dirent) POST_WRITE(dirent, res);\n+  }\n+}\n+\n+PRE_SYSCALL(setsockopt)(long fd, long level, long optname, void *optval,\n+                        long optlen) {}\n+\n+POST_SYSCALL(setsockopt)(long res, long fd, long level, long optname,\n+                         void *optval, long optlen) {\n+  if (res >= 0) {\n+    if (optval)\n+      POST_WRITE(optval,\n+                 __sanitizer::internal_strlen((const char *)optval) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(getsockopt)(long fd, long level, long optname, void *optval,\n+                        void *optlen) {}\n+\n+POST_SYSCALL(getsockopt)(long res, long fd, long level, long optname,\n+                         void *optval, void *optlen) {\n+  if (res >= 0) {\n+    if (optval)\n+      POST_WRITE(optval,\n+                 __sanitizer::internal_strlen((const char *)optval) + 1);\n+    if (optlen) POST_WRITE(optlen, sizeof(int));\n+  }\n+}\n+\n+PRE_SYSCALL(bind)(long arg0, sanitizer_kernel_sockaddr *arg1, long arg2) {}\n+\n+POST_SYSCALL(bind)(long res, long arg0, sanitizer_kernel_sockaddr *arg1,\n+                   long arg2) {\n+  if (res >= 0) {\n+    if (arg1) POST_WRITE(arg1, sizeof(*arg1));\n+  }\n+}\n+\n+PRE_SYSCALL(connect)(long arg0, sanitizer_kernel_sockaddr *arg1, long arg2) {}\n+\n+POST_SYSCALL(connect)(long res, long arg0, sanitizer_kernel_sockaddr *arg1,\n+                      long arg2) {\n+  if (res >= 0) {\n+    if (arg1) POST_WRITE(arg1, sizeof(*arg1));\n+  }\n+}\n+\n+PRE_SYSCALL(accept)(long arg0, sanitizer_kernel_sockaddr *arg1, void *arg2) {}\n+\n+POST_SYSCALL(accept)(long res, long arg0, sanitizer_kernel_sockaddr *arg1,\n+                     void *arg2) {\n+  if (res >= 0) {\n+    if (arg1) POST_WRITE(arg1, sizeof(*arg1));\n+    if (arg2) POST_WRITE(arg2, sizeof(unsigned));\n+  }\n+}\n+\n+PRE_SYSCALL(accept4)(long arg0, sanitizer_kernel_sockaddr *arg1, void *arg2,\n+                     long arg3) {}\n+\n+POST_SYSCALL(accept4)(long res, long arg0, sanitizer_kernel_sockaddr *arg1,\n+                      void *arg2, long arg3) {\n+  if (res >= 0) {\n+    if (arg1) POST_WRITE(arg1, sizeof(*arg1));\n+    if (arg2) POST_WRITE(arg2, sizeof(unsigned));\n+  }\n+}\n+\n+PRE_SYSCALL(getsockname)(long arg0, sanitizer_kernel_sockaddr *arg1,\n+                         void *arg2) {}\n+\n+POST_SYSCALL(getsockname)(long res, long arg0, sanitizer_kernel_sockaddr *arg1,\n+                          void *arg2) {\n+  if (res >= 0) {\n+    if (arg1) POST_WRITE(arg1, sizeof(*arg1));\n+    if (arg2) POST_WRITE(arg2, sizeof(unsigned));\n+  }\n+}\n+\n+PRE_SYSCALL(getpeername)(long arg0, sanitizer_kernel_sockaddr *arg1,\n+                         void *arg2) {}\n+\n+POST_SYSCALL(getpeername)(long res, long arg0, sanitizer_kernel_sockaddr *arg1,\n+                          void *arg2) {\n+  if (res >= 0) {\n+    if (arg1) POST_WRITE(arg1, sizeof(*arg1));\n+    if (arg2) POST_WRITE(arg2, sizeof(unsigned));\n+  }\n+}\n+\n+PRE_SYSCALL(send)(long arg0, void *arg1, long arg2, long arg3) {}\n+\n+POST_SYSCALL(send)(long res, long arg0, void *arg1, long arg2, long arg3) {\n+  if (res) {\n+    if (arg1) POST_READ(arg1, res);\n+  }\n+}\n+\n+PRE_SYSCALL(sendto)(long arg0, void *arg1, long arg2, long arg3,\n+                    sanitizer_kernel_sockaddr *arg4, long arg5) {}\n+\n+POST_SYSCALL(sendto)(long res, long arg0, void *arg1, long arg2, long arg3,\n+                     sanitizer_kernel_sockaddr *arg4, long arg5) {\n+  if (res >= 0) {\n+    if (arg1) POST_READ(arg1, res);\n+    if (arg4) POST_WRITE(arg4, sizeof(*arg4));\n+  }\n+}\n+\n+PRE_SYSCALL(sendmsg)(long fd, void *msg, long flags) {}\n+\n+POST_SYSCALL(sendmsg)(long res, long fd, void *msg, long flags) {\n+  // FIXME: POST_READ\n+}\n+\n+PRE_SYSCALL(sendmmsg)(long fd, void *msg, long vlen, long flags) {}\n+\n+POST_SYSCALL(sendmmsg)(long res, long fd, void *msg, long vlen, long flags) {\n+  // FIXME: POST_READ\n+}\n+\n+PRE_SYSCALL(recv)(long arg0, void *buf, long len, long flags) {}\n+\n+POST_SYSCALL(recv)(long res, void *buf, long len, long flags) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, res);\n+  }\n+}\n+\n+PRE_SYSCALL(recvfrom)(long arg0, void *buf, long len, long flags,\n+                      sanitizer_kernel_sockaddr *arg4, void *arg5) {}\n+\n+POST_SYSCALL(recvfrom)(long res, long arg0, void *buf, long len, long flags,\n+                       sanitizer_kernel_sockaddr *arg4, void *arg5) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, res);\n+    if (arg4) POST_WRITE(arg4, sizeof(*arg4));\n+    if (arg5) POST_WRITE(arg5, sizeof(int));\n+  }\n+}\n+\n+PRE_SYSCALL(socket)(long arg0, long arg1, long arg2) {}\n+\n+POST_SYSCALL(socket)(long res, long arg0, long arg1, long arg2) {}\n+\n+PRE_SYSCALL(socketpair)(long arg0, long arg1, long arg2, void *arg3) {}\n+\n+POST_SYSCALL(socketpair)(long res, long arg0, long arg1, long arg2,\n+                         void *arg3) {\n+  if (res >= 0) {\n+    if (arg3) POST_WRITE(arg3, sizeof(int));\n+  }\n+}\n+\n+PRE_SYSCALL(socketcall)(long call, void *args) {}\n+\n+POST_SYSCALL(socketcall)(long res, long call, void *args) {\n+  if (res >= 0) {\n+    if (args) POST_WRITE(args, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(listen)(long arg0, long arg1) {}\n+\n+POST_SYSCALL(listen)(long res, long arg0, long arg1) {}\n+\n+PRE_SYSCALL(poll)(void *ufds, long nfds, long timeout) {}\n+\n+POST_SYSCALL(poll)(long res, __sanitizer_pollfd *ufds, long nfds,\n+                   long timeout) {\n+  if (res >= 0) {\n+    if (ufds) POST_WRITE(ufds, nfds * sizeof(*ufds));\n+  }\n+}\n+\n+PRE_SYSCALL(select)(long n, __sanitizer___kernel_fd_set *inp,\n+                    __sanitizer___kernel_fd_set *outp,\n+                    __sanitizer___kernel_fd_set *exp, void *tvp) {}\n+\n+POST_SYSCALL(select)(long res, long n, __sanitizer___kernel_fd_set *inp,\n+                     __sanitizer___kernel_fd_set *outp,\n+                     __sanitizer___kernel_fd_set *exp, void *tvp) {\n+  if (res >= 0) {\n+    if (inp) POST_WRITE(inp, sizeof(*inp));\n+    if (outp) POST_WRITE(outp, sizeof(*outp));\n+    if (exp) POST_WRITE(exp, sizeof(*exp));\n+    if (tvp) POST_WRITE(tvp, timeval_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(old_select)(void *arg) {}\n+\n+POST_SYSCALL(old_select)(long res, void *arg) {}\n+\n+PRE_SYSCALL(epoll_create)(long size) {}\n+\n+POST_SYSCALL(epoll_create)(long res, long size) {}\n+\n+PRE_SYSCALL(epoll_create1)(long flags) {}\n+\n+POST_SYSCALL(epoll_create1)(long res, long flags) {}\n+\n+PRE_SYSCALL(epoll_ctl)(long epfd, long op, long fd, void *event) {}\n+\n+POST_SYSCALL(epoll_ctl)(long res, long epfd, long op, long fd, void *event) {\n+  if (res >= 0) {\n+    if (event) POST_WRITE(event, struct_epoll_event_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(epoll_wait)(long epfd, void *events, long maxevents, long timeout) {\n+}\n+\n+POST_SYSCALL(epoll_wait)(long res, long epfd, void *events, long maxevents,\n+                         long timeout) {\n+  if (res >= 0) {\n+    if (events) POST_WRITE(events, struct_epoll_event_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(epoll_pwait)(long epfd, void *events, long maxevents, long timeout,\n+                         const kernel_sigset_t *sigmask, long sigsetsize) {\n+  if (sigmask) PRE_READ(sigmask, sigsetsize);\n+}\n+\n+POST_SYSCALL(epoll_pwait)(long res, long epfd, void *events, long maxevents,\n+                          long timeout, const void *sigmask, long sigsetsize) {\n+  if (res >= 0) {\n+    if (events) POST_WRITE(events, struct_epoll_event_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(gethostname)(void *name, long len) {}\n+\n+POST_SYSCALL(gethostname)(long res, void *name, long len) {\n+  if (res >= 0) {\n+    if (name)\n+      POST_WRITE(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(sethostname)(void *name, long len) {}\n+\n+POST_SYSCALL(sethostname)(long res, void *name, long len) {\n+  if (res >= 0) {\n+    if (name)\n+      POST_WRITE(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(setdomainname)(void *name, long len) {}\n+\n+POST_SYSCALL(setdomainname)(long res, void *name, long len) {\n+  if (res >= 0) {\n+    if (name)\n+      POST_WRITE(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(newuname)(void *name) {}\n+\n+POST_SYSCALL(newuname)(long res, void *name) {\n+  if (res >= 0) {\n+    if (name) POST_WRITE(name, struct_new_utsname_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(uname)(void *arg0) {}\n+\n+POST_SYSCALL(uname)(long res, void *arg0) {\n+  if (res >= 0) {\n+    if (arg0) POST_WRITE(arg0, struct_old_utsname_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(olduname)(void *arg0) {}\n+\n+POST_SYSCALL(olduname)(long res, void *arg0) {\n+  if (res >= 0) {\n+    if (arg0) POST_WRITE(arg0, struct_oldold_utsname_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(getrlimit)(long resource, void *rlim) {}\n+\n+POST_SYSCALL(getrlimit)(long res, long resource, void *rlim) {\n+  if (res >= 0) {\n+    if (rlim) POST_WRITE(rlim, struct_rlimit_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(old_getrlimit)(long resource, void *rlim) {}\n+\n+POST_SYSCALL(old_getrlimit)(long res, long resource, void *rlim) {\n+  if (res >= 0) {\n+    if (rlim) POST_WRITE(rlim, struct_rlimit_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(setrlimit)(long resource, void *rlim) {}\n+\n+POST_SYSCALL(setrlimit)(long res, long resource, void *rlim) {\n+  if (res >= 0) {\n+    if (rlim) POST_WRITE(rlim, struct_rlimit_sz);\n+  }\n+}\n+\n+#if !SANITIZER_ANDROID\n+PRE_SYSCALL(prlimit64)(long pid, long resource, const void *new_rlim,\n+                       void *old_rlim) {\n+  if (new_rlim) PRE_READ(new_rlim, struct_rlimit64_sz);\n+}\n+\n+POST_SYSCALL(prlimit64)(long res, long pid, long resource, const void *new_rlim,\n+                        void *old_rlim) {\n+  if (res >= 0) {\n+    if (old_rlim) POST_WRITE(old_rlim, struct_rlimit64_sz);\n+  }\n+}\n+#endif\n+\n+PRE_SYSCALL(getrusage)(long who, void *ru) {}\n+\n+POST_SYSCALL(getrusage)(long res, long who, void *ru) {\n+  if (res >= 0) {\n+    if (ru) POST_WRITE(ru, struct_rusage_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(umask)(long mask) {}\n+\n+POST_SYSCALL(umask)(long res, long mask) {}\n+\n+PRE_SYSCALL(msgget)(long key, long msgflg) {}\n+\n+POST_SYSCALL(msgget)(long res, long key, long msgflg) {}\n+\n+PRE_SYSCALL(msgsnd)(long msqid, void *msgp, long msgsz, long msgflg) {\n+  if (msgp) PRE_READ(msgp, msgsz);\n+}\n+\n+POST_SYSCALL(msgsnd)(long res, long msqid, void *msgp, long msgsz,\n+                     long msgflg) {}\n+\n+PRE_SYSCALL(msgrcv)(long msqid, void *msgp, long msgsz, long msgtyp,\n+                    long msgflg) {}\n+\n+POST_SYSCALL(msgrcv)(long res, long msqid, void *msgp, long msgsz, long msgtyp,\n+                     long msgflg) {\n+  if (res >= 0) {\n+    if (msgp) POST_WRITE(msgp, res);\n+  }\n+}\n+\n+PRE_SYSCALL(msgctl)(long msqid, long cmd, void *buf) {}\n+\n+POST_SYSCALL(msgctl)(long res, long msqid, long cmd, void *buf) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, struct_msqid_ds_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(semget)(long key, long nsems, long semflg) {}\n+\n+POST_SYSCALL(semget)(long res, long key, long nsems, long semflg) {}\n+\n+PRE_SYSCALL(semop)(long semid, void *sops, long nsops) {}\n+\n+POST_SYSCALL(semop)(long res, long semid, void *sops, long nsops) {}\n+\n+PRE_SYSCALL(semctl)(long semid, long semnum, long cmd, void *arg) {}\n+\n+POST_SYSCALL(semctl)(long res, long semid, long semnum, long cmd, void *arg) {}\n+\n+PRE_SYSCALL(semtimedop)(long semid, void *sops, long nsops,\n+                        const void *timeout) {\n+  if (timeout) PRE_READ(timeout, struct_timespec_sz);\n+}\n+\n+POST_SYSCALL(semtimedop)(long res, long semid, void *sops, long nsops,\n+                         const void *timeout) {}\n+\n+PRE_SYSCALL(shmat)(long shmid, void *shmaddr, long shmflg) {}\n+\n+POST_SYSCALL(shmat)(long res, long shmid, void *shmaddr, long shmflg) {\n+  if (res >= 0) {\n+    if (shmaddr)\n+      POST_WRITE(shmaddr,\n+                 __sanitizer::internal_strlen((const char *)shmaddr) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(shmget)(long key, long size, long flag) {}\n+\n+POST_SYSCALL(shmget)(long res, long key, long size, long flag) {}\n+\n+PRE_SYSCALL(shmdt)(void *shmaddr) {}\n+\n+POST_SYSCALL(shmdt)(long res, void *shmaddr) {\n+  if (res >= 0) {\n+    if (shmaddr)\n+      POST_WRITE(shmaddr,\n+                 __sanitizer::internal_strlen((const char *)shmaddr) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(shmctl)(long shmid, long cmd, void *buf) {}\n+\n+POST_SYSCALL(shmctl)(long res, long shmid, long cmd, void *buf) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, struct_shmid_ds_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(ipc)(long call, long first, long second, long third, void *ptr,\n+                 long fifth) {}\n+\n+POST_SYSCALL(ipc)(long res, long call, long first, long second, long third,\n+                  void *ptr, long fifth) {}\n+\n+#if !SANITIZER_ANDROID\n+PRE_SYSCALL(mq_open)(const void *name, long oflag, long mode, void *attr) {\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(mq_open)(long res, const void *name, long oflag, long mode,\n+                      void *attr) {\n+  if (res >= 0) {\n+    if (attr) POST_WRITE(attr, struct_mq_attr_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(mq_unlink)(const void *name) {\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(mq_unlink)(long res, const void *name) {}\n+\n+PRE_SYSCALL(mq_timedsend)(long mqdes, const void *msg_ptr, long msg_len,\n+                          long msg_prio, const void *abs_timeout) {\n+  if (msg_ptr) PRE_READ(msg_ptr, msg_len);\n+  if (abs_timeout) PRE_READ(abs_timeout, struct_timespec_sz);\n+}\n+\n+POST_SYSCALL(mq_timedsend)(long res, long mqdes, const void *msg_ptr,\n+                           long msg_len, long msg_prio,\n+                           const void *abs_timeout) {}\n+\n+PRE_SYSCALL(mq_timedreceive)(long mqdes, void *msg_ptr, long msg_len,\n+                             void *msg_prio, const void *abs_timeout) {\n+  if (abs_timeout) PRE_READ(abs_timeout, struct_timespec_sz);\n+}\n+\n+POST_SYSCALL(mq_timedreceive)(long res, long mqdes, void *msg_ptr, long msg_len,\n+                              int *msg_prio, const void *abs_timeout) {\n+  if (res >= 0) {\n+    if (msg_ptr) POST_WRITE(msg_ptr, res);\n+    if (msg_prio) POST_WRITE(msg_prio, sizeof(*msg_prio));\n+  }\n+}\n+\n+PRE_SYSCALL(mq_notify)(long mqdes, const void *notification) {\n+  if (notification) PRE_READ(notification, struct_sigevent_sz);\n+}\n+\n+POST_SYSCALL(mq_notify)(long res, long mqdes, const void *notification) {}\n+\n+PRE_SYSCALL(mq_getsetattr)(long mqdes, const void *mqstat, void *omqstat) {\n+  if (mqstat) PRE_READ(mqstat, struct_mq_attr_sz);\n+}\n+\n+POST_SYSCALL(mq_getsetattr)(long res, long mqdes, const void *mqstat,\n+                            void *omqstat) {\n+  if (res >= 0) {\n+    if (omqstat) POST_WRITE(omqstat, struct_mq_attr_sz);\n+  }\n+}\n+#endif  // SANITIZER_ANDROID\n+\n+PRE_SYSCALL(pciconfig_iobase)(long which, long bus, long devfn) {}\n+\n+POST_SYSCALL(pciconfig_iobase)(long res, long which, long bus, long devfn) {}\n+\n+PRE_SYSCALL(pciconfig_read)(long bus, long dfn, long off, long len, void *buf) {\n+}\n+\n+POST_SYSCALL(pciconfig_read)(long res, long bus, long dfn, long off, long len,\n+                             void *buf) {}\n+\n+PRE_SYSCALL(pciconfig_write)(long bus, long dfn, long off, long len,\n+                             void *buf) {}\n+\n+POST_SYSCALL(pciconfig_write)(long res, long bus, long dfn, long off, long len,\n+                              void *buf) {}\n+\n+PRE_SYSCALL(swapon)(const void *specialfile, long swap_flags) {\n+  if (specialfile)\n+    PRE_READ(specialfile,\n+             __sanitizer::internal_strlen((const char *)specialfile) + 1);\n+}\n+\n+POST_SYSCALL(swapon)(long res, const void *specialfile, long swap_flags) {}\n+\n+PRE_SYSCALL(swapoff)(const void *specialfile) {\n+  if (specialfile)\n+    PRE_READ(specialfile,\n+             __sanitizer::internal_strlen((const char *)specialfile) + 1);\n+}\n+\n+POST_SYSCALL(swapoff)(long res, const void *specialfile) {}\n+\n+PRE_SYSCALL(sysctl)(__sanitizer___sysctl_args *args) {\n+  if (args) {\n+    if (args->name) PRE_READ(args->name, args->nlen * sizeof(*args->name));\n+    if (args->newval) PRE_READ(args->name, args->newlen);\n+  }\n+}\n+\n+POST_SYSCALL(sysctl)(long res, __sanitizer___sysctl_args *args) {\n+  if (res >= 0) {\n+    if (args && args->oldval && args->oldlenp) {\n+      POST_WRITE(args->oldlenp, sizeof(*args->oldlenp));\n+      POST_WRITE(args->oldval, *args->oldlenp);\n+    }\n+  }\n+}\n+\n+PRE_SYSCALL(sysinfo)(void *info) {}\n+\n+POST_SYSCALL(sysinfo)(long res, void *info) {\n+  if (res >= 0) {\n+    if (info) POST_WRITE(info, struct_sysinfo_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(sysfs)(long option, long arg1, long arg2) {}\n+\n+POST_SYSCALL(sysfs)(long res, long option, long arg1, long arg2) {}\n+\n+PRE_SYSCALL(syslog)(long type, void *buf, long len) {}\n+\n+POST_SYSCALL(syslog)(long res, long type, void *buf, long len) {\n+  if (res >= 0) {\n+    if (buf)\n+      POST_WRITE(buf, __sanitizer::internal_strlen((const char *)buf) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(uselib)(const void *library) {\n+  if (library)\n+    PRE_READ(library, __sanitizer::internal_strlen((const char *)library) + 1);\n+}\n+\n+POST_SYSCALL(uselib)(long res, const void *library) {}\n+\n+PRE_SYSCALL(ni_syscall)() {}\n+\n+POST_SYSCALL(ni_syscall)(long res) {}\n+\n+PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {}\n+\n+POST_SYSCALL(ptrace)(long res, long request, long pid, long addr, long data) {}\n+\n+PRE_SYSCALL(add_key)(const void *_type, const void *_description,\n+                     const void *_payload, long plen, long destringid) {\n+  if (_type)\n+    PRE_READ(_type, __sanitizer::internal_strlen((const char *)_type) + 1);\n+  if (_description)\n+    PRE_READ(_description,\n+             __sanitizer::internal_strlen((const char *)_description) + 1);\n+}\n+\n+POST_SYSCALL(add_key)(long res, const void *_type, const void *_description,\n+                      const void *_payload, long plen, long destringid) {}\n+\n+PRE_SYSCALL(request_key)(const void *_type, const void *_description,\n+                         const void *_callout_info, long destringid) {\n+  if (_type)\n+    PRE_READ(_type, __sanitizer::internal_strlen((const char *)_type) + 1);\n+  if (_description)\n+    PRE_READ(_description,\n+             __sanitizer::internal_strlen((const char *)_description) + 1);\n+  if (_callout_info)\n+    PRE_READ(_callout_info,\n+             __sanitizer::internal_strlen((const char *)_callout_info) + 1);\n+}\n+\n+POST_SYSCALL(request_key)(long res, const void *_type, const void *_description,\n+                          const void *_callout_info, long destringid) {}\n+\n+PRE_SYSCALL(keyctl)(long cmd, long arg2, long arg3, long arg4, long arg5) {}\n+\n+POST_SYSCALL(keyctl)(long res, long cmd, long arg2, long arg3, long arg4,\n+                     long arg5) {}\n+\n+PRE_SYSCALL(ioprio_set)(long which, long who, long ioprio) {}\n+\n+POST_SYSCALL(ioprio_set)(long res, long which, long who, long ioprio) {}\n+\n+PRE_SYSCALL(ioprio_get)(long which, long who) {}\n+\n+POST_SYSCALL(ioprio_get)(long res, long which, long who) {}\n+\n+PRE_SYSCALL(set_mempolicy)(long mode, void *nmask, long maxnode) {}\n+\n+POST_SYSCALL(set_mempolicy)(long res, long mode, void *nmask, long maxnode) {\n+  if (res >= 0) {\n+    if (nmask) POST_WRITE(nmask, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(migrate_pages)(long pid, long maxnode, const void *from,\n+                           const void *to) {\n+  if (from) PRE_READ(from, sizeof(long));\n+  if (to) PRE_READ(to, sizeof(long));\n+}\n+\n+POST_SYSCALL(migrate_pages)(long res, long pid, long maxnode, const void *from,\n+                            const void *to) {}\n+\n+PRE_SYSCALL(move_pages)(long pid, long nr_pages, const void **pages,\n+                        const int *nodes, int *status, long flags) {\n+  if (pages) PRE_READ(pages, nr_pages * sizeof(*pages));\n+  if (nodes) PRE_READ(nodes, nr_pages * sizeof(*nodes));\n+}\n+\n+POST_SYSCALL(move_pages)(long res, long pid, long nr_pages, const void **pages,\n+                         const int *nodes, int *status, long flags) {\n+  if (res >= 0) {\n+    if (status) POST_WRITE(status, nr_pages * sizeof(*status));\n+  }\n+}\n+\n+PRE_SYSCALL(mbind)(long start, long len, long mode, void *nmask, long maxnode,\n+                   long flags) {}\n+\n+POST_SYSCALL(mbind)(long res, long start, long len, long mode, void *nmask,\n+                    long maxnode, long flags) {\n+  if (res >= 0) {\n+    if (nmask) POST_WRITE(nmask, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(get_mempolicy)(void *policy, void *nmask, long maxnode, long addr,\n+                           long flags) {}\n+\n+POST_SYSCALL(get_mempolicy)(long res, void *policy, void *nmask, long maxnode,\n+                            long addr, long flags) {\n+  if (res >= 0) {\n+    if (policy) POST_WRITE(policy, sizeof(int));\n+    if (nmask) POST_WRITE(nmask, sizeof(long));\n+  }\n+}\n+\n+PRE_SYSCALL(inotify_init)() {}\n+\n+POST_SYSCALL(inotify_init)(long res) {}\n+\n+PRE_SYSCALL(inotify_init1)(long flags) {}\n+\n+POST_SYSCALL(inotify_init1)(long res, long flags) {}\n+\n+PRE_SYSCALL(inotify_add_watch)(long fd, const void *path, long mask) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(inotify_add_watch)(long res, long fd, const void *path,\n+                                long mask) {}\n+\n+PRE_SYSCALL(inotify_rm_watch)(long fd, long wd) {}\n+\n+POST_SYSCALL(inotify_rm_watch)(long res, long fd, long wd) {}\n+\n+PRE_SYSCALL(spu_run)(long fd, void *unpc, void *ustatus) {}\n+\n+POST_SYSCALL(spu_run)(long res, long fd, unsigned *unpc, unsigned *ustatus) {\n+  if (res >= 0) {\n+    if (unpc) POST_WRITE(unpc, sizeof(*unpc));\n+    if (ustatus) POST_WRITE(ustatus, sizeof(*ustatus));\n+  }\n+}\n+\n+PRE_SYSCALL(spu_create)(const void *name, long flags, long mode, long fd) {\n+  if (name)\n+    PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n+}\n+\n+POST_SYSCALL(spu_create)(long res, const void *name, long flags, long mode,\n+                         long fd) {}\n+\n+PRE_SYSCALL(mknodat)(long dfd, const void *filename, long mode, long dev) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(mknodat)(long res, long dfd, const void *filename, long mode,\n+                      long dev) {}\n+\n+PRE_SYSCALL(mkdirat)(long dfd, const void *pathname, long mode) {\n+  if (pathname)\n+    PRE_READ(pathname,\n+             __sanitizer::internal_strlen((const char *)pathname) + 1);\n+}\n+\n+POST_SYSCALL(mkdirat)(long res, long dfd, const void *pathname, long mode) {}\n+\n+PRE_SYSCALL(unlinkat)(long dfd, const void *pathname, long flag) {\n+  if (pathname)\n+    PRE_READ(pathname,\n+             __sanitizer::internal_strlen((const char *)pathname) + 1);\n+}\n+\n+POST_SYSCALL(unlinkat)(long res, long dfd, const void *pathname, long flag) {}\n+\n+PRE_SYSCALL(symlinkat)(const void *oldname, long newdfd, const void *newname) {\n+  if (oldname)\n+    PRE_READ(oldname, __sanitizer::internal_strlen((const char *)oldname) + 1);\n+  if (newname)\n+    PRE_READ(newname, __sanitizer::internal_strlen((const char *)newname) + 1);\n+}\n+\n+POST_SYSCALL(symlinkat)(long res, const void *oldname, long newdfd,\n+                        const void *newname) {}\n+\n+PRE_SYSCALL(linkat)(long olddfd, const void *oldname, long newdfd,\n+                    const void *newname, long flags) {\n+  if (oldname)\n+    PRE_READ(oldname, __sanitizer::internal_strlen((const char *)oldname) + 1);\n+  if (newname)\n+    PRE_READ(newname, __sanitizer::internal_strlen((const char *)newname) + 1);\n+}\n+\n+POST_SYSCALL(linkat)(long res, long olddfd, const void *oldname, long newdfd,\n+                     const void *newname, long flags) {}\n+\n+PRE_SYSCALL(renameat)(long olddfd, const void *oldname, long newdfd,\n+                      const void *newname) {\n+  if (oldname)\n+    PRE_READ(oldname, __sanitizer::internal_strlen((const char *)oldname) + 1);\n+  if (newname)\n+    PRE_READ(newname, __sanitizer::internal_strlen((const char *)newname) + 1);\n+}\n+\n+POST_SYSCALL(renameat)(long res, long olddfd, const void *oldname, long newdfd,\n+                       const void *newname) {}\n+\n+PRE_SYSCALL(futimesat)(long dfd, const void *filename, void *utimes) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(futimesat)(long res, long dfd, const void *filename,\n+                        void *utimes) {\n+  if (res >= 0) {\n+    if (utimes) POST_WRITE(utimes, timeval_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(faccessat)(long dfd, const void *filename, long mode) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(faccessat)(long res, long dfd, const void *filename, long mode) {}\n+\n+PRE_SYSCALL(fchmodat)(long dfd, const void *filename, long mode) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(fchmodat)(long res, long dfd, const void *filename, long mode) {}\n+\n+PRE_SYSCALL(fchownat)(long dfd, const void *filename, long user, long group,\n+                      long flag) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(fchownat)(long res, long dfd, const void *filename, long user,\n+                       long group, long flag) {}\n+\n+PRE_SYSCALL(openat)(long dfd, const void *filename, long flags, long mode) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(openat)(long res, long dfd, const void *filename, long flags,\n+                     long mode) {}\n+\n+PRE_SYSCALL(newfstatat)(long dfd, const void *filename, void *statbuf,\n+                        long flag) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(newfstatat)(long res, long dfd, const void *filename,\n+                         void *statbuf, long flag) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(fstatat64)(long dfd, const void *filename, void *statbuf,\n+                       long flag) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(fstatat64)(long res, long dfd, const void *filename, void *statbuf,\n+                        long flag) {\n+  if (res >= 0) {\n+    if (statbuf) POST_WRITE(statbuf, struct_kernel_stat64_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(readlinkat)(long dfd, const void *path, void *buf, long bufsiz) {\n+  if (path)\n+    PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n+}\n+\n+POST_SYSCALL(readlinkat)(long res, long dfd, const void *path, void *buf,\n+                         long bufsiz) {\n+  if (res >= 0) {\n+    if (buf)\n+      POST_WRITE(buf, __sanitizer::internal_strlen((const char *)buf) + 1);\n+  }\n+}\n+\n+PRE_SYSCALL(utimensat)(long dfd, const void *filename, void *utimes,\n+                       long flags) {\n+  if (filename)\n+    PRE_READ(filename,\n+             __sanitizer::internal_strlen((const char *)filename) + 1);\n+}\n+\n+POST_SYSCALL(utimensat)(long res, long dfd, const void *filename, void *utimes,\n+                        long flags) {\n+  if (res >= 0) {\n+    if (utimes) POST_WRITE(utimes, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(unshare)(long unshare_flags) {}\n+\n+POST_SYSCALL(unshare)(long res, long unshare_flags) {}\n+\n+PRE_SYSCALL(splice)(long fd_in, void *off_in, long fd_out, void *off_out,\n+                    long len, long flags) {}\n+\n+POST_SYSCALL(splice)(long res, long fd_in, void *off_in, long fd_out,\n+                     void *off_out, long len, long flags) {\n+  if (res >= 0) {\n+    if (off_in) POST_WRITE(off_in, sizeof(long long));\n+    if (off_out) POST_WRITE(off_out, sizeof(long long));\n+  }\n+}\n+\n+PRE_SYSCALL(vmsplice)(long fd, const __sanitizer_iovec *iov, long nr_segs,\n+                      long flags) {}\n+\n+POST_SYSCALL(vmsplice)(long res, long fd, const __sanitizer_iovec *iov,\n+                       long nr_segs, long flags) {\n+  if (res >= 0) {\n+    if (iov) kernel_read_iovec(iov, nr_segs, res);\n+  }\n+}\n+\n+PRE_SYSCALL(tee)(long fdin, long fdout, long len, long flags) {}\n+\n+POST_SYSCALL(tee)(long res, long fdin, long fdout, long len, long flags) {}\n+\n+PRE_SYSCALL(get_robust_list)(long pid, void *head_ptr, void *len_ptr) {}\n+\n+POST_SYSCALL(get_robust_list)(long res, long pid, void *head_ptr,\n+                              void *len_ptr) {}\n+\n+PRE_SYSCALL(set_robust_list)(void *head, long len) {}\n+\n+POST_SYSCALL(set_robust_list)(long res, void *head, long len) {}\n+\n+PRE_SYSCALL(getcpu)(void *cpu, void *node, void *cache) {}\n+\n+POST_SYSCALL(getcpu)(long res, void *cpu, void *node, void *cache) {\n+  if (res >= 0) {\n+    if (cpu) POST_WRITE(cpu, sizeof(unsigned));\n+    if (node) POST_WRITE(node, sizeof(unsigned));\n+    // The third argument to this system call is nowadays unused.\n+  }\n+}\n+\n+PRE_SYSCALL(signalfd)(long ufd, void *user_mask, long sizemask) {}\n+\n+POST_SYSCALL(signalfd)(long res, long ufd, kernel_sigset_t *user_mask,\n+                       long sizemask) {\n+  if (res >= 0) {\n+    if (user_mask) POST_WRITE(user_mask, sizemask);\n+  }\n+}\n+\n+PRE_SYSCALL(signalfd4)(long ufd, void *user_mask, long sizemask, long flags) {}\n+\n+POST_SYSCALL(signalfd4)(long res, long ufd, kernel_sigset_t *user_mask,\n+                        long sizemask, long flags) {\n+  if (res >= 0) {\n+    if (user_mask) POST_WRITE(user_mask, sizemask);\n+  }\n+}\n+\n+PRE_SYSCALL(timerfd_create)(long clockid, long flags) {}\n+\n+POST_SYSCALL(timerfd_create)(long res, long clockid, long flags) {}\n+\n+PRE_SYSCALL(timerfd_settime)(long ufd, long flags, const void *utmr,\n+                             void *otmr) {\n+  if (utmr) PRE_READ(utmr, struct_itimerspec_sz);\n+}\n+\n+POST_SYSCALL(timerfd_settime)(long res, long ufd, long flags, const void *utmr,\n+                              void *otmr) {\n+  if (res >= 0) {\n+    if (otmr) POST_WRITE(otmr, struct_itimerspec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(timerfd_gettime)(long ufd, void *otmr) {}\n+\n+POST_SYSCALL(timerfd_gettime)(long res, long ufd, void *otmr) {\n+  if (res >= 0) {\n+    if (otmr) POST_WRITE(otmr, struct_itimerspec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(eventfd)(long count) {}\n+\n+POST_SYSCALL(eventfd)(long res, long count) {}\n+\n+PRE_SYSCALL(eventfd2)(long count, long flags) {}\n+\n+POST_SYSCALL(eventfd2)(long res, long count, long flags) {}\n+\n+PRE_SYSCALL(old_readdir)(long arg0, void *arg1, long arg2) {}\n+\n+POST_SYSCALL(old_readdir)(long res, long arg0, void *arg1, long arg2) {\n+  // Missing definition of 'struct old_linux_dirent'.\n+}\n+\n+PRE_SYSCALL(pselect6)(long arg0, __sanitizer___kernel_fd_set *arg1,\n+                      __sanitizer___kernel_fd_set *arg2,\n+                      __sanitizer___kernel_fd_set *arg3, void *arg4,\n+                      void *arg5) {}\n+\n+POST_SYSCALL(pselect6)(long res, long arg0, __sanitizer___kernel_fd_set *arg1,\n+                       __sanitizer___kernel_fd_set *arg2,\n+                       __sanitizer___kernel_fd_set *arg3, void *arg4,\n+                       void *arg5) {\n+  if (res >= 0) {\n+    if (arg1) POST_WRITE(arg1, sizeof(*arg1));\n+    if (arg2) POST_WRITE(arg2, sizeof(*arg2));\n+    if (arg3) POST_WRITE(arg3, sizeof(*arg3));\n+    if (arg4) POST_WRITE(arg4, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(ppoll)(__sanitizer_pollfd *arg0, long arg1, void *arg2,\n+                   const kernel_sigset_t *arg3, long arg4) {\n+  if (arg3) PRE_READ(arg3, arg4);\n+}\n+\n+POST_SYSCALL(ppoll)(long res, __sanitizer_pollfd *arg0, long arg1, void *arg2,\n+                    const void *arg3, long arg4) {\n+  if (res >= 0) {\n+    if (arg0) POST_WRITE(arg0, sizeof(*arg0));\n+    if (arg2) POST_WRITE(arg2, struct_timespec_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(syncfs)(long fd) {}\n+\n+POST_SYSCALL(syncfs)(long res, long fd) {}\n+\n+PRE_SYSCALL(perf_event_open)(void *attr_uptr, long pid, long cpu, long group_fd,\n+                             long flags) {}\n+\n+POST_SYSCALL(perf_event_open)(long res, void *attr_uptr, long pid, long cpu,\n+                              long group_fd, long flags) {\n+  if (res >= 0) {\n+    if (attr_uptr) POST_WRITE(attr_uptr, struct_perf_event_attr_sz);\n+  }\n+}\n+\n+PRE_SYSCALL(mmap_pgoff)(long addr, long len, long prot, long flags, long fd,\n+                        long pgoff) {}\n+\n+POST_SYSCALL(mmap_pgoff)(long res, long addr, long len, long prot, long flags,\n+                         long fd, long pgoff) {}\n+\n+PRE_SYSCALL(old_mmap)(void *arg) {}\n+\n+POST_SYSCALL(old_mmap)(long res, void *arg) {}\n+\n+PRE_SYSCALL(name_to_handle_at)(long dfd, const void *name, void *handle,\n+                               void *mnt_id, long flag) {}\n+\n+POST_SYSCALL(name_to_handle_at)(long res, long dfd, const void *name,\n+                                void *handle, void *mnt_id, long flag) {}\n+\n+PRE_SYSCALL(open_by_handle_at)(long mountdirfd, void *handle, long flags) {}\n+\n+POST_SYSCALL(open_by_handle_at)(long res, long mountdirfd, void *handle,\n+                                long flags) {}\n+\n+PRE_SYSCALL(setns)(long fd, long nstype) {}\n+\n+POST_SYSCALL(setns)(long res, long fd, long nstype) {}\n+\n+PRE_SYSCALL(process_vm_readv)(long pid, const __sanitizer_iovec *lvec,\n+                              long liovcnt, const void *rvec, long riovcnt,\n+                              long flags) {}\n+\n+POST_SYSCALL(process_vm_readv)(long res, long pid,\n+                               const __sanitizer_iovec *lvec, long liovcnt,\n+                               const void *rvec, long riovcnt, long flags) {\n+  if (res >= 0) {\n+    if (lvec) kernel_write_iovec(lvec, liovcnt, res);\n+  }\n+}\n+\n+PRE_SYSCALL(process_vm_writev)(long pid, const __sanitizer_iovec *lvec,\n+                               long liovcnt, const void *rvec, long riovcnt,\n+                               long flags) {}\n+\n+POST_SYSCALL(process_vm_writev)(long res, long pid,\n+                                const __sanitizer_iovec *lvec, long liovcnt,\n+                                const void *rvec, long riovcnt, long flags) {\n+  if (res >= 0) {\n+    if (lvec) kernel_read_iovec(lvec, liovcnt, res);\n+  }\n+}\n+\n+PRE_SYSCALL(fork)() {\n+  COMMON_SYSCALL_PRE_FORK();\n+}\n+\n+POST_SYSCALL(fork)(long res) {\n+  COMMON_SYSCALL_POST_FORK(res);\n+}\n+\n+PRE_SYSCALL(vfork)() {\n+  COMMON_SYSCALL_PRE_FORK();\n+}\n+\n+POST_SYSCALL(vfork)(long res) {\n+  COMMON_SYSCALL_POST_FORK(res);\n+}\n+}  // extern \"C\"\n+\n+#undef PRE_SYSCALL\n+#undef PRE_READ\n+#undef PRE_WRITE\n+#undef POST_SYSCALL\n+#undef POST_READ\n+#undef POST_WRITE\n+\n+#endif  // SANITIZER_LINUX"}, {"sha": "06ac5435b9d6536b7e5341f6015f02d55f854abf", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -16,15 +16,40 @@\n \n namespace __sanitizer {\n \n+CommonFlags common_flags_dont_use_directly;\n+\n+void ParseCommonFlagsFromString(const char *str) {\n+  CommonFlags *f = common_flags();\n+  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\");\n+  ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\");\n+  ParseFlag(str, &f->fast_unwind_on_fatal, \"fast_unwind_on_fatal\");\n+  ParseFlag(str, &f->fast_unwind_on_malloc, \"fast_unwind_on_malloc\");\n+  ParseFlag(str, &f->symbolize, \"symbolize\");\n+  ParseFlag(str, &f->handle_ioctl, \"handle_ioctl\");\n+  ParseFlag(str, &f->log_path, \"log_path\");\n+  ParseFlag(str, &f->detect_leaks, \"detect_leaks\");\n+  ParseFlag(str, &f->leak_check_at_exit, \"leak_check_at_exit\");\n+  ParseFlag(str, &f->allocator_may_return_null, \"allocator_may_return_null\");\n+}\n+\n static bool GetFlagValue(const char *env, const char *name,\n                          const char **value, int *value_length) {\n   if (env == 0)\n     return false;\n-  const char *pos = internal_strstr(env, name);\n-  const char *end;\n-  if (pos == 0)\n-    return false;\n+  const char *pos = 0;\n+  for (;;) {\n+    pos = internal_strstr(env, name);\n+    if (pos == 0)\n+      return false;\n+    if (pos != env && ((pos[-1] >= 'a' && pos[-1] <= 'z') || pos[-1] == '_')) {\n+      // Seems to be middle of another flag name or value.\n+      env = pos + 1;\n+      continue;\n+    }\n+    break;\n+  }\n   pos += internal_strlen(name);\n+  const char *end;\n   if (pos[0] != '=') {\n     end = pos;\n   } else {\n@@ -75,7 +100,7 @@ void ParseFlag(const char *env, int *flag, const char *name) {\n   int value_length;\n   if (!GetFlagValue(env, name, &value, &value_length))\n     return;\n-  *flag = internal_atoll(value);\n+  *flag = static_cast<int>(internal_atoll(value));\n }\n \n static LowLevelAllocator allocator_for_flags;"}, {"sha": "62aa96bbb69923eecc5beae4110c170344edb448", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -20,6 +20,41 @@ void ParseFlag(const char *env, bool *flag, const char *name);\n void ParseFlag(const char *env, int *flag, const char *name);\n void ParseFlag(const char *env, const char **flag, const char *name);\n \n+struct CommonFlags {\n+  // If set, use the online symbolizer from common sanitizer runtime.\n+  bool symbolize;\n+  // Path to external symbolizer.\n+  const char *external_symbolizer_path;\n+  // Strips this prefix from file paths in error reports.\n+  const char *strip_path_prefix;\n+  // Use fast (frame-pointer-based) unwinder on fatal errors (if available).\n+  bool fast_unwind_on_fatal;\n+  // Use fast (frame-pointer-based) unwinder on malloc/free (if available).\n+  bool fast_unwind_on_malloc;\n+  // Intercept and handle ioctl requests.\n+  bool handle_ioctl;\n+  // Max number of stack frames kept for each allocation/deallocation.\n+  int malloc_context_size;\n+  // Write logs to \"log_path.pid\" instead of stderr.\n+  const char *log_path;\n+  // Enable memory leak detection.\n+  bool detect_leaks;\n+  // Invoke leak checking in an atexit handler. Has no effect if\n+  // detect_leaks=false, or if __lsan_do_leak_check() is called before the\n+  // handler has a chance to run.\n+  bool leak_check_at_exit;\n+  // If false, the allocator will crash instead of returning 0 on out-of-memory.\n+  bool allocator_may_return_null;\n+};\n+\n+extern CommonFlags common_flags_dont_use_directly;\n+\n+inline CommonFlags *common_flags() {\n+  return &common_flags_dont_use_directly;\n+}\n+\n+void ParseCommonFlagsFromString(const char *str);\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_FLAGS_H"}, {"sha": "cc9233cad5f91ff5383d350a97a4ee8370ab259a", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -11,9 +11,12 @@\n #ifndef SANITIZER_DEFS_H\n #define SANITIZER_DEFS_H\n \n-#if defined(_WIN32)\n-// FIXME find out what we need on Windows. __declspec(dllexport) ?\n-# define SANITIZER_INTERFACE_ATTRIBUTE\n+#include \"sanitizer_platform.h\"\n+\n+// Only use SANITIZER_*ATTRIBUTE* before the function return type!\n+#if SANITIZER_WINDOWS\n+# define SANITIZER_INTERFACE_ATTRIBUTE __declspec(dllexport)\n+// FIXME find out what we need on Windows, if anything.\n # define SANITIZER_WEAK_ATTRIBUTE\n #elif defined(SANITIZER_GO)\n # define SANITIZER_INTERFACE_ATTRIBUTE\n@@ -23,7 +26,7 @@\n # define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n #endif\n \n-#ifdef __linux__\n+#if SANITIZER_LINUX && !defined(SANITIZER_GO)\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n #else\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n@@ -64,29 +67,39 @@ typedef signed   int s32;\n typedef signed   long long s64;  // NOLINT\n typedef int fd_t;\n \n+// WARNING: OFF_T may be different from OS type off_t, depending on the value of\n+// _FILE_OFFSET_BITS. This definition of OFF_T matches the ABI of system calls\n+// like pread and mmap, as opposed to pread64 and mmap64.\n+// Mac and Linux/x86-64 are special.\n+#if SANITIZER_MAC || (SANITIZER_LINUX && defined(__x86_64__))\n+typedef u64 OFF_T;\n+#else\n+typedef uptr OFF_T;\n+#endif\n+typedef u64  OFF64_T;\n }  // namespace __sanitizer\n \n extern \"C\" {\n   // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n-  void __sanitizer_set_report_path(const char *path)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __sanitizer_set_report_path(const char *path);\n \n   // Tell the tools to write their reports to given file descriptor instead of\n   // stderr.\n-  void __sanitizer_set_report_fd(int fd)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __sanitizer_set_report_fd(int fd);\n \n   // Notify the tools that the sandbox is going to be turned on. The reserved\n   // parameter will be used in the future to hold a structure with functions\n   // that the tools may call to bypass the sandbox.\n-  void __sanitizer_sandbox_on_notify(void *reserved)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_sandbox_on_notify(void *reserved);\n \n   // This function is called by the tool when it has just finished reporting\n   // an error. 'error_summary' is a one-line string that summarizes\n   // the error message. This function can be overridden by the client.\n-  void __sanitizer_report_error_summary(const char *error_summary)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_report_error_summary(const char *error_summary);\n }  // extern \"C\"\n \n \n@@ -95,13 +108,13 @@ using namespace __sanitizer;  // NOLINT\n // This header should NOT include any other headers to avoid portability issues.\n \n // Common defs.\n-#define INLINE static inline\n+#define INLINE inline\n #define INTERFACE_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n #define WEAK SANITIZER_WEAK_ATTRIBUTE\n \n // Platform-specific defs.\n #if defined(_MSC_VER)\n-# define ALWAYS_INLINE __declspec(forceinline)\n+# define ALWAYS_INLINE __forceinline\n // FIXME(timurrrr): do we need this on Windows?\n # define ALIAS(x)\n # define ALIGNED(x) __declspec(align(x))\n@@ -116,8 +129,10 @@ using namespace __sanitizer;  // NOLINT\n # define USED\n # define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */\n #else  // _MSC_VER\n-# define ALWAYS_INLINE __attribute__((always_inline))\n+# define ALWAYS_INLINE inline __attribute__((always_inline))\n # define ALIAS(x) __attribute__((alias(x)))\n+// Please only use the ALIGNED macro before the type.\n+// Using ALIGNED after the variable declaration is not portable!\n # define ALIGNED(x) __attribute__((aligned(x)))\n # define FORMAT(f, a)  __attribute__((format(printf, f, a)))\n # define NOINLINE __attribute__((noinline))\n@@ -136,7 +151,15 @@ using namespace __sanitizer;  // NOLINT\n # endif\n #endif  // _MSC_VER\n \n-#if defined(_WIN32)\n+// Unaligned versions of basic types.\n+typedef ALIGNED(1) u16 uu16;\n+typedef ALIGNED(1) u32 uu32;\n+typedef ALIGNED(1) u64 uu64;\n+typedef ALIGNED(1) s16 us16;\n+typedef ALIGNED(1) s32 us32;\n+typedef ALIGNED(1) s64 us64;\n+\n+#if SANITIZER_WINDOWS\n typedef unsigned long DWORD;  // NOLINT\n typedef DWORD thread_return_t;\n # define THREAD_CALLING_CONV __stdcall\n@@ -155,6 +178,9 @@ typedef thread_return_t (THREAD_CALLING_CONV *thread_callback_t)(void* arg);\n // NOTE: Functions below must be defined in each run-time.\n namespace __sanitizer {\n void NORETURN Die();\n+\n+// FIXME: No, this shouldn't be in the sanitizer interface.\n+SANITIZER_INTERFACE_ATTRIBUTE\n void NORETURN CheckFailed(const char *file, int line, const char *cond,\n                           u64 v1, u64 v2);\n }  // namespace __sanitizer\n@@ -259,10 +285,12 @@ extern \"C\" void* _ReturnAddress(void);\n # define GET_CURRENT_FRAME() (uptr)0xDEADBEEF\n #endif\n \n-#define HANDLE_EINTR(res, f) {                               \\\n-  do {                                                                  \\\n-    res = (f);                                                         \\\n-  } while (res == -1 && errno == EINTR); \\\n+#define HANDLE_EINTR(res, f)                                       \\\n+  {                                                                \\\n+    int rverrno;                                                   \\\n+    do {                                                           \\\n+      res = (f);                                                   \\\n+    } while (internal_iserror(res, &rverrno) && rverrno == EINTR); \\\n   }\n \n #endif  // SANITIZER_DEFS_H"}, {"sha": "2a75e431b31d30dd0a8e87b52119e61520a4ab98", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -8,6 +8,7 @@\n // This file is shared between AddressSanitizer and ThreadSanitizer\n // run-time libraries. See sanitizer_libc.h for details.\n //===----------------------------------------------------------------------===//\n+#include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n \n@@ -122,6 +123,13 @@ char* internal_strchr(const char *s, int c) {\n   }\n }\n \n+char *internal_strchrnul(const char *s, int c) {\n+  char *res = internal_strchr(s, c);\n+  if (!res)\n+    res = (char*)s + internal_strlen(s);\n+  return res;\n+}\n+\n char *internal_strrchr(const char *s, int c) {\n   const char *res = 0;\n   for (uptr i = 0; s[i]; i++) {\n@@ -149,8 +157,7 @@ char *internal_strncpy(char *dst, const char *src, uptr n) {\n   uptr i;\n   for (i = 0; i < n && src[i]; i++)\n     dst[i] = src[i];\n-  for (; i < n; i++)\n-    dst[i] = '\\0';\n+  internal_memset(dst + i, '\\0', n - i);\n   return dst;\n }\n "}, {"sha": "f90ffcc679a7c850c64855cf4a393cc7aa626b9f", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -30,6 +30,7 @@ void *internal_memmove(void *dest, const void *src, uptr n);\n // Should not be used in performance-critical places.\n void *internal_memset(void *s, int c, uptr n);\n char* internal_strchr(const char *s, int c);\n+char *internal_strchrnul(const char *s, int c);\n int internal_strcmp(const char *s1, const char *s2);\n uptr internal_strcspn(const char *s, const char *reject);\n char *internal_strdup(const char *s);\n@@ -51,36 +52,46 @@ bool mem_is_zero(const char *mem, uptr size);\n \n \n // Memory\n-void *internal_mmap(void *addr, uptr length, int prot, int flags,\n-                    int fd, u64 offset);\n-int internal_munmap(void *addr, uptr length);\n+uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n+                   int fd, u64 offset);\n+uptr internal_munmap(void *addr, uptr length);\n \n // I/O\n const fd_t kInvalidFd = -1;\n const fd_t kStdinFd = 0;\n const fd_t kStdoutFd = 1;\n const fd_t kStderrFd = 2;\n-int internal_close(fd_t fd);\n+uptr internal_close(fd_t fd);\n int internal_isatty(fd_t fd);\n \n // Use __sanitizer::OpenFile() instead.\n-fd_t internal_open(const char *filename, int flags);\n-fd_t internal_open(const char *filename, int flags, u32 mode);\n+uptr internal_open(const char *filename, int flags);\n+uptr internal_open(const char *filename, int flags, u32 mode);\n \n uptr internal_read(fd_t fd, void *buf, uptr count);\n uptr internal_write(fd_t fd, const void *buf, uptr count);\n \n // OS\n uptr internal_filesize(fd_t fd);  // -1 on error.\n-int internal_stat(const char *path, void *buf);\n-int internal_lstat(const char *path, void *buf);\n-int internal_fstat(fd_t fd, void *buf);\n-int internal_dup2(int oldfd, int newfd);\n+uptr internal_stat(const char *path, void *buf);\n+uptr internal_lstat(const char *path, void *buf);\n+uptr internal_fstat(fd_t fd, void *buf);\n+uptr internal_dup2(int oldfd, int newfd);\n uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n+uptr internal_unlink(const char *path);\n void NORETURN internal__exit(int exitcode);\n+uptr internal_lseek(fd_t fd, OFF_T offset, int whence);\n+\n+uptr internal_ptrace(int request, int pid, void *addr, void *data);\n+uptr internal_waitpid(int pid, int *status, int options);\n+uptr internal_getpid();\n+uptr internal_getppid();\n \n // Threading\n-int internal_sched_yield();\n+uptr internal_sched_yield();\n+\n+// Error handling\n+bool internal_iserror(uptr retval, int *rverrno = 0);\n \n }  // namespace __sanitizer\n "}, {"sha": "666f15b4ed60d817974f069650b03f383b6eca84", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 486, "deletions": 203, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -9,29 +9,48 @@\n // run-time libraries and implements linux-specific functions from\n // sanitizer_libc.h.\n //===----------------------------------------------------------------------===//\n-#ifdef __linux__\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_linux.h\"\n #include \"sanitizer_mutex.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n \n+#include <asm/param.h>\n+#include <dlfcn.h>\n+#include <errno.h>\n #include <fcntl.h>\n+#if !SANITIZER_ANDROID\n+#include <link.h>\n+#endif\n #include <pthread.h>\n #include <sched.h>\n #include <sys/mman.h>\n+#include <sys/ptrace.h>\n #include <sys/resource.h>\n #include <sys/stat.h>\n #include <sys/syscall.h>\n #include <sys/time.h>\n #include <sys/types.h>\n-#include <sys/prctl.h>\n #include <unistd.h>\n #include <unwind.h>\n-#include <errno.h>\n+\n+#if !SANITIZER_ANDROID\n+#include <sys/signal.h>\n+#endif\n+\n+// <linux/time.h>\n+struct kernel_timeval {\n+  long tv_sec;\n+  long tv_usec;\n+};\n \n // <linux/futex.h> is broken on some linux distributions.\n const int FUTEX_WAIT = 0;\n@@ -48,165 +67,158 @@ const int FUTEX_WAKE = 1;\n \n namespace __sanitizer {\n \n+#ifdef __x86_64__\n+#include \"sanitizer_syscall_linux_x86_64.inc\"\n+#else\n+#include \"sanitizer_syscall_generic.inc\"\n+#endif\n+\n // --------------- sanitizer_libc.h\n-void *internal_mmap(void *addr, uptr length, int prot, int flags,\n+uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n                     int fd, u64 offset) {\n #if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return (void *)syscall(__NR_mmap, addr, length, prot, flags, fd, offset);\n+  return internal_syscall(__NR_mmap, addr, length, prot, flags, fd, offset);\n #else\n-  return (void *)syscall(__NR_mmap2, addr, length, prot, flags, fd, offset);\n+  return internal_syscall(__NR_mmap2, addr, length, prot, flags, fd, offset);\n #endif\n }\n \n-int internal_munmap(void *addr, uptr length) {\n-  return syscall(__NR_munmap, addr, length);\n+uptr internal_munmap(void *addr, uptr length) {\n+  return internal_syscall(__NR_munmap, addr, length);\n }\n \n-int internal_close(fd_t fd) {\n-  return syscall(__NR_close, fd);\n+uptr internal_close(fd_t fd) {\n+  return internal_syscall(__NR_close, fd);\n }\n \n-fd_t internal_open(const char *filename, int flags) {\n-  return syscall(__NR_open, filename, flags);\n+uptr internal_open(const char *filename, int flags) {\n+  return internal_syscall(__NR_open, filename, flags);\n }\n \n-fd_t internal_open(const char *filename, int flags, u32 mode) {\n-  return syscall(__NR_open, filename, flags, mode);\n+uptr internal_open(const char *filename, int flags, u32 mode) {\n+  return internal_syscall(__NR_open, filename, flags, mode);\n }\n \n-fd_t OpenFile(const char *filename, bool write) {\n+uptr OpenFile(const char *filename, bool write) {\n   return internal_open(filename,\n       write ? O_WRONLY | O_CREAT /*| O_CLOEXEC*/ : O_RDONLY, 0660);\n }\n \n uptr internal_read(fd_t fd, void *buf, uptr count) {\n   sptr res;\n-  HANDLE_EINTR(res, (sptr)syscall(__NR_read, fd, buf, count));\n+  HANDLE_EINTR(res, (sptr)internal_syscall(__NR_read, fd, buf, count));\n   return res;\n }\n \n uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   sptr res;\n-  HANDLE_EINTR(res, (sptr)syscall(__NR_write, fd, buf, count));\n+  HANDLE_EINTR(res, (sptr)internal_syscall(__NR_write, fd, buf, count));\n   return res;\n }\n \n-int internal_stat(const char *path, void *buf) {\n+#if !SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n+  internal_memset(out, 0, sizeof(*out));\n+  out->st_dev = in->st_dev;\n+  out->st_ino = in->st_ino;\n+  out->st_mode = in->st_mode;\n+  out->st_nlink = in->st_nlink;\n+  out->st_uid = in->st_uid;\n+  out->st_gid = in->st_gid;\n+  out->st_rdev = in->st_rdev;\n+  out->st_size = in->st_size;\n+  out->st_blksize = in->st_blksize;\n+  out->st_blocks = in->st_blocks;\n+  out->st_atime = in->st_atime;\n+  out->st_mtime = in->st_mtime;\n+  out->st_ctime = in->st_ctime;\n+  out->st_ino = in->st_ino;\n+}\n+#endif\n+\n+uptr internal_stat(const char *path, void *buf) {\n #if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return syscall(__NR_stat, path, buf);\n+  return internal_syscall(__NR_stat, path, buf);\n #else\n-  return syscall(__NR_stat64, path, buf);\n+  struct stat64 buf64;\n+  int res = internal_syscall(__NR_stat64, path, &buf64);\n+  stat64_to_stat(&buf64, (struct stat *)buf);\n+  return res;\n #endif\n }\n \n-int internal_lstat(const char *path, void *buf) {\n+uptr internal_lstat(const char *path, void *buf) {\n #if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return syscall(__NR_lstat, path, buf);\n+  return internal_syscall(__NR_lstat, path, buf);\n #else\n-  return syscall(__NR_lstat64, path, buf);\n+  struct stat64 buf64;\n+  int res = internal_syscall(__NR_lstat64, path, &buf64);\n+  stat64_to_stat(&buf64, (struct stat *)buf);\n+  return res;\n #endif\n }\n \n-int internal_fstat(fd_t fd, void *buf) {\n+uptr internal_fstat(fd_t fd, void *buf) {\n #if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return syscall(__NR_fstat, fd, buf);\n+  return internal_syscall(__NR_fstat, fd, buf);\n #else\n-  return syscall(__NR_fstat64, fd, buf);\n+  struct stat64 buf64;\n+  int res = internal_syscall(__NR_fstat64, fd, &buf64);\n+  stat64_to_stat(&buf64, (struct stat *)buf);\n+  return res;\n #endif\n }\n \n uptr internal_filesize(fd_t fd) {\n-#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n   struct stat st;\n-#else\n-  struct stat64 st;\n-#endif\n   if (internal_fstat(fd, &st))\n     return -1;\n   return (uptr)st.st_size;\n }\n \n-int internal_dup2(int oldfd, int newfd) {\n-  return syscall(__NR_dup2, oldfd, newfd);\n+uptr internal_dup2(int oldfd, int newfd) {\n+  return internal_syscall(__NR_dup2, oldfd, newfd);\n }\n \n uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n-  return (uptr)syscall(__NR_readlink, path, buf, bufsize);\n+  return internal_syscall(__NR_readlink, path, buf, bufsize);\n+}\n+\n+uptr internal_unlink(const char *path) {\n+  return internal_syscall(__NR_unlink, path);\n }\n \n-int internal_sched_yield() {\n-  return syscall(__NR_sched_yield);\n+uptr internal_sched_yield() {\n+  return internal_syscall(__NR_sched_yield);\n }\n \n void internal__exit(int exitcode) {\n-  syscall(__NR_exit_group, exitcode);\n+  internal_syscall(__NR_exit_group, exitcode);\n   Die();  // Unreachable.\n }\n \n+uptr internal_execve(const char *filename, char *const argv[],\n+                     char *const envp[]) {\n+  return internal_syscall(__NR_execve, filename, argv, envp);\n+}\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n-#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n   struct stat st;\n-  if (syscall(__NR_stat, filename, &st))\n+  if (internal_stat(filename, &st))\n     return false;\n-#else\n-  struct stat64 st;\n-  if (syscall(__NR_stat64, filename, &st))\n-    return false;\n-#endif\n   // Sanity check: filename is a regular file.\n   return S_ISREG(st.st_mode);\n }\n \n uptr GetTid() {\n-  return syscall(__NR_gettid);\n-}\n-\n-void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n-                                uptr *stack_bottom) {\n-  static const uptr kMaxThreadStackSize = 256 * (1 << 20);  // 256M\n-  CHECK(stack_top);\n-  CHECK(stack_bottom);\n-  if (at_initialization) {\n-    // This is the main thread. Libpthread may not be initialized yet.\n-    struct rlimit rl;\n-    CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n-\n-    // Find the mapping that contains a stack variable.\n-    MemoryMappingLayout proc_maps;\n-    uptr start, end, offset;\n-    uptr prev_end = 0;\n-    while (proc_maps.Next(&start, &end, &offset, 0, 0)) {\n-      if ((uptr)&rl < end)\n-        break;\n-      prev_end = end;\n-    }\n-    CHECK((uptr)&rl >= start && (uptr)&rl < end);\n-\n-    // Get stacksize from rlimit, but clip it so that it does not overlap\n-    // with other mappings.\n-    uptr stacksize = rl.rlim_cur;\n-    if (stacksize > end - prev_end)\n-      stacksize = end - prev_end;\n-    // When running with unlimited stack size, we still want to set some limit.\n-    // The unlimited stack size is caused by 'ulimit -s unlimited'.\n-    // Also, for some reason, GNU make spawns subprocesses with unlimited stack.\n-    if (stacksize > kMaxThreadStackSize)\n-      stacksize = kMaxThreadStackSize;\n-    *stack_top = end;\n-    *stack_bottom = end - stacksize;\n-    return;\n-  }\n-  pthread_attr_t attr;\n-  CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n-  uptr stacksize = 0;\n-  void *stackaddr = 0;\n-  pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n-  pthread_attr_destroy(&attr);\n+  return internal_syscall(__NR_gettid);\n+}\n \n-  *stack_top = (uptr)stackaddr + stacksize;\n-  *stack_bottom = (uptr)stackaddr;\n-  CHECK(stacksize < kMaxThreadStackSize);  // Sanity check.\n+u64 NanoTime() {\n+  kernel_timeval tv = {};\n+  internal_syscall(__NR_gettimeofday, &tv, 0);\n+  return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n }\n \n // Like getenv, but reads env directly from /proc and does not use libc.\n@@ -237,21 +249,11 @@ const char *GetEnv(const char *name) {\n   return 0;  // Not found.\n }\n \n-#ifdef __GLIBC__\n-\n extern \"C\" {\n-  extern void *__libc_stack_end;\n-}\n-\n-static void GetArgsAndEnv(char ***argv, char ***envp) {\n-  uptr *stack_end = (uptr *)__libc_stack_end;\n-  int argc = *stack_end;\n-  *argv = (char**)(stack_end + 1);\n-  *envp = (char**)(stack_end + argc + 2);\n+  SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;\n }\n \n-#else  // __GLIBC__\n-\n+#if !SANITIZER_GO\n static void ReadNullSepFileToArray(const char *path, char ***arr,\n                                    int arr_size) {\n   char *buff;\n@@ -270,20 +272,32 @@ static void ReadNullSepFileToArray(const char *path, char ***arr,\n   }\n   (*arr)[count] = 0;\n }\n+#endif\n \n-static void GetArgsAndEnv(char ***argv, char ***envp) {\n-  static const int kMaxArgv = 2000, kMaxEnvp = 2000;\n-  ReadNullSepFileToArray(\"/proc/self/cmdline\", argv, kMaxArgv);\n-  ReadNullSepFileToArray(\"/proc/self/environ\", envp, kMaxEnvp);\n+static void GetArgsAndEnv(char*** argv, char*** envp) {\n+#if !SANITIZER_GO\n+  if (&__libc_stack_end) {\n+#endif\n+    uptr* stack_end = (uptr*)__libc_stack_end;\n+    int argc = *stack_end;\n+    *argv = (char**)(stack_end + 1);\n+    *envp = (char**)(stack_end + argc + 2);\n+#if !SANITIZER_GO\n+  } else {\n+    static const int kMaxArgv = 2000, kMaxEnvp = 2000;\n+    ReadNullSepFileToArray(\"/proc/self/cmdline\", argv, kMaxArgv);\n+    ReadNullSepFileToArray(\"/proc/self/environ\", envp, kMaxEnvp);\n+  }\n+#endif\n }\n \n-#endif  // __GLIBC__\n-\n void ReExec() {\n   char **argv, **envp;\n   GetArgsAndEnv(&argv, &envp);\n-  execve(\"/proc/self/exe\", argv, envp);\n-  Printf(\"execve failed, errno %d\\n\", errno);\n+  uptr rv = internal_execve(\"/proc/self/exe\", argv, envp);\n+  int rverrno;\n+  CHECK_EQ(internal_iserror(rv, &rverrno), true);\n+  Printf(\"execve failed, errno %d\\n\", rverrno);\n   Die();\n }\n \n@@ -293,25 +307,33 @@ void PrepareForSandboxing() {\n   // process will be able to load additional libraries, so it's fine to use the\n   // cached mappings.\n   MemoryMappingLayout::CacheMemoryMappings();\n+  // Same for /proc/self/exe in the symbolizer.\n+#if !SANITIZER_GO\n+  getSymbolizer()->PrepareForSandboxing();\n+#endif\n }\n \n // ----------------- sanitizer_procmaps.h\n // Linker initialized.\n ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;\n StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.\n \n-MemoryMappingLayout::MemoryMappingLayout() {\n+MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n   proc_self_maps_.len =\n       ReadFileToBuffer(\"/proc/self/maps\", &proc_self_maps_.data,\n                        &proc_self_maps_.mmaped_size, 1 << 26);\n-  if (proc_self_maps_.mmaped_size == 0) {\n-    LoadFromCache();\n-    CHECK_GT(proc_self_maps_.len, 0);\n+  if (cache_enabled) {\n+    if (proc_self_maps_.mmaped_size == 0) {\n+      LoadFromCache();\n+      CHECK_GT(proc_self_maps_.len, 0);\n+    }\n+  } else {\n+    CHECK_GT(proc_self_maps_.mmaped_size, 0);\n   }\n-  // internal_write(2, proc_self_maps_.data, proc_self_maps_.len);\n   Reset();\n   // FIXME: in the future we may want to cache the mappings on demand only.\n-  CacheMemoryMappings();\n+  if (cache_enabled)\n+    CacheMemoryMappings();\n }\n \n MemoryMappingLayout::~MemoryMappingLayout() {\n@@ -373,16 +395,41 @@ static uptr ParseHex(char **str) {\n   return x;\n }\n \n-static bool IsOnOf(char c, char c1, char c2) {\n+static bool IsOneOf(char c, char c1, char c2) {\n   return c == c1 || c == c2;\n }\n \n static bool IsDecimal(char c) {\n   return c >= '0' && c <= '9';\n }\n \n+static bool IsHex(char c) {\n+  return (c >= '0' && c <= '9')\n+      || (c >= 'a' && c <= 'f');\n+}\n+\n+static uptr ReadHex(const char *p) {\n+  uptr v = 0;\n+  for (; IsHex(p[0]); p++) {\n+    if (p[0] >= '0' && p[0] <= '9')\n+      v = v * 16 + p[0] - '0';\n+    else\n+      v = v * 16 + p[0] - 'a' + 10;\n+  }\n+  return v;\n+}\n+\n+static uptr ReadDecimal(const char *p) {\n+  uptr v = 0;\n+  for (; IsDecimal(p[0]); p++)\n+    v = v * 10 + p[0] - '0';\n+  return v;\n+}\n+\n+\n bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n-                               char filename[], uptr filename_size) {\n+                               char filename[], uptr filename_size,\n+                               uptr *protection) {\n   char *last = proc_self_maps_.data + proc_self_maps_.len;\n   if (current_ >= last) return false;\n   uptr dummy;\n@@ -397,10 +444,22 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n   CHECK_EQ(*current_++, '-');\n   *end = ParseHex(&current_);\n   CHECK_EQ(*current_++, ' ');\n-  CHECK(IsOnOf(*current_++, '-', 'r'));\n-  CHECK(IsOnOf(*current_++, '-', 'w'));\n-  CHECK(IsOnOf(*current_++, '-', 'x'));\n-  CHECK(IsOnOf(*current_++, 's', 'p'));\n+  uptr local_protection = 0;\n+  CHECK(IsOneOf(*current_, '-', 'r'));\n+  if (*current_++ == 'r')\n+    local_protection |= kProtectionRead;\n+  CHECK(IsOneOf(*current_, '-', 'w'));\n+  if (*current_++ == 'w')\n+    local_protection |= kProtectionWrite;\n+  CHECK(IsOneOf(*current_, '-', 'x'));\n+  if (*current_++ == 'x')\n+    local_protection |= kProtectionExecute;\n+  CHECK(IsOneOf(*current_, 's', 'p'));\n+  if (*current_++ == 's')\n+    local_protection |= kProtectionShared;\n+  if (protection) {\n+    *protection = local_protection;\n+  }\n   CHECK_EQ(*current_++, ' ');\n   *offset = ParseHex(&current_);\n   CHECK_EQ(*current_++, ' ');\n@@ -432,87 +491,35 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n // Gets the object name and the offset by walking MemoryMappingLayout.\n bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n                                                  char filename[],\n-                                                 uptr filename_size) {\n-  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size);\n-}\n-\n-bool SanitizerSetThreadName(const char *name) {\n-#ifdef PR_SET_NAME\n-  return 0 == prctl(PR_SET_NAME, (unsigned long)name, 0, 0, 0);  // NOLINT\n-#else\n-  return false;\n-#endif\n-}\n-\n-bool SanitizerGetThreadName(char *name, int max_len) {\n-#ifdef PR_GET_NAME\n-  char buff[17];\n-  if (prctl(PR_GET_NAME, (unsigned long)buff, 0, 0, 0))  // NOLINT\n-    return false;\n-  internal_strncpy(name, buff, max_len);\n-  name[max_len] = 0;\n-  return true;\n-#else\n-  return false;\n-#endif\n-}\n-\n-#ifndef SANITIZER_GO\n-//------------------------- SlowUnwindStack -----------------------------------\n-#ifdef __arm__\n-#define UNWIND_STOP _URC_END_OF_STACK\n-#define UNWIND_CONTINUE _URC_NO_REASON\n-#else\n-#define UNWIND_STOP _URC_NORMAL_STOP\n-#define UNWIND_CONTINUE _URC_NO_REASON\n-#endif\n-\n-uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n-#ifdef __arm__\n-  uptr val;\n-  _Unwind_VRS_Result res = _Unwind_VRS_Get(ctx, _UVRSC_CORE,\n-      15 /* r15 = PC */, _UVRSD_UINT32, &val);\n-  CHECK(res == _UVRSR_OK && \"_Unwind_VRS_Get failed\");\n-  // Clear the Thumb bit.\n-  return val & ~(uptr)1;\n-#else\n-  return _Unwind_GetIP(ctx);\n-#endif\n-}\n-\n-_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n-  StackTrace *b = (StackTrace*)param;\n-  CHECK(b->size < b->max_size);\n-  uptr pc = Unwind_GetIP(ctx);\n-  b->trace[b->size++] = pc;\n-  if (b->size == b->max_size) return UNWIND_STOP;\n-  return UNWIND_CONTINUE;\n-}\n-\n-static bool MatchPc(uptr cur_pc, uptr trace_pc) {\n-  return cur_pc - trace_pc <= 64 || trace_pc - cur_pc <= 64;\n-}\n-\n-void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n-  this->size = 0;\n-  this->max_size = max_depth;\n-  if (max_depth > 1) {\n-    _Unwind_Backtrace(Unwind_Trace, this);\n-    // We need to pop a few frames so that pc is on top.\n-    // trace[0] belongs to the current function so we always pop it.\n-    int to_pop = 1;\n-    /**/ if (size > 1 && MatchPc(pc, trace[1])) to_pop = 1;\n-    else if (size > 2 && MatchPc(pc, trace[2])) to_pop = 2;\n-    else if (size > 3 && MatchPc(pc, trace[3])) to_pop = 3;\n-    else if (size > 4 && MatchPc(pc, trace[4])) to_pop = 4;\n-    else if (size > 5 && MatchPc(pc, trace[5])) to_pop = 5;\n-    this->PopStackFrames(to_pop);\n+                                                 uptr filename_size,\n+                                                 uptr *protection) {\n+  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size,\n+                                       protection);\n+}\n+\n+void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {\n+  char *smaps = 0;\n+  uptr smaps_cap = 0;\n+  uptr smaps_len = ReadFileToBuffer(\"/proc/self/smaps\",\n+      &smaps, &smaps_cap, 64<<20);\n+  uptr start = 0;\n+  bool file = false;\n+  const char *pos = smaps;\n+  while (pos < smaps + smaps_len) {\n+    if (IsHex(pos[0])) {\n+      start = ReadHex(pos);\n+      for (; *pos != '/' && *pos > '\\n'; pos++) {}\n+      file = *pos == '/';\n+    } else if (internal_strncmp(pos, \"Rss:\", 4) == 0) {\n+      for (; *pos < '0' || *pos > '9'; pos++) {}\n+      uptr rss = ReadDecimal(pos) * 1024;\n+      cb(start, rss, file, stats, stats_size);\n+    }\n+    while (*pos++ != '\\n') {}\n   }\n-  this->trace[0] = pc;\n+  UnmapOrDie(smaps, smaps_cap);\n }\n \n-#endif  // #ifndef SANITIZER_GO\n-\n enum MutexState {\n   MtxUnlocked = 0,\n   MtxLocked = 1,\n@@ -523,22 +530,298 @@ BlockingMutex::BlockingMutex(LinkerInitialized) {\n   CHECK_EQ(owner_, 0);\n }\n \n+BlockingMutex::BlockingMutex() {\n+  internal_memset(this, 0, sizeof(*this));\n+}\n+\n void BlockingMutex::Lock() {\n   atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n   if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)\n     return;\n   while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked)\n-    syscall(__NR_futex, m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);\n+    internal_syscall(__NR_futex, m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);\n }\n \n void BlockingMutex::Unlock() {\n   atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n   u32 v = atomic_exchange(m, MtxUnlocked, memory_order_relaxed);\n   CHECK_NE(v, MtxUnlocked);\n   if (v == MtxSleeping)\n-    syscall(__NR_futex, m, FUTEX_WAKE, 1, 0, 0, 0);\n+    internal_syscall(__NR_futex, m, FUTEX_WAKE, 1, 0, 0, 0);\n+}\n+\n+void BlockingMutex::CheckLocked() {\n+  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+  CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));\n+}\n+\n+// ----------------- sanitizer_linux.h\n+// The actual size of this structure is specified by d_reclen.\n+// Note that getdents64 uses a different structure format. We only provide the\n+// 32-bit syscall here.\n+struct linux_dirent {\n+  unsigned long      d_ino;\n+  unsigned long      d_off;\n+  unsigned short     d_reclen;\n+  char               d_name[256];\n+};\n+\n+// Syscall wrappers.\n+uptr internal_ptrace(int request, int pid, void *addr, void *data) {\n+  return internal_syscall(__NR_ptrace, request, pid, addr, data);\n+}\n+\n+uptr internal_waitpid(int pid, int *status, int options) {\n+  return internal_syscall(__NR_wait4, pid, status, options, 0 /* rusage */);\n+}\n+\n+uptr internal_getpid() {\n+  return internal_syscall(__NR_getpid);\n+}\n+\n+uptr internal_getppid() {\n+  return internal_syscall(__NR_getppid);\n+}\n+\n+uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count) {\n+  return internal_syscall(__NR_getdents, fd, dirp, count);\n+}\n+\n+uptr internal_lseek(fd_t fd, OFF_T offset, int whence) {\n+  return internal_syscall(__NR_lseek, fd, offset, whence);\n+}\n+\n+uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5) {\n+  return internal_syscall(__NR_prctl, option, arg2, arg3, arg4, arg5);\n+}\n+\n+uptr internal_sigaltstack(const struct sigaltstack *ss,\n+                         struct sigaltstack *oss) {\n+  return internal_syscall(__NR_sigaltstack, ss, oss);\n+}\n+\n+// ThreadLister implementation.\n+ThreadLister::ThreadLister(int pid)\n+  : pid_(pid),\n+    descriptor_(-1),\n+    buffer_(4096),\n+    error_(true),\n+    entry_((struct linux_dirent *)buffer_.data()),\n+    bytes_read_(0) {\n+  char task_directory_path[80];\n+  internal_snprintf(task_directory_path, sizeof(task_directory_path),\n+                    \"/proc/%d/task/\", pid);\n+  uptr openrv = internal_open(task_directory_path, O_RDONLY | O_DIRECTORY);\n+  if (internal_iserror(openrv)) {\n+    error_ = true;\n+    Report(\"Can't open /proc/%d/task for reading.\\n\", pid);\n+  } else {\n+    error_ = false;\n+    descriptor_ = openrv;\n+  }\n+}\n+\n+int ThreadLister::GetNextTID() {\n+  int tid = -1;\n+  do {\n+    if (error_)\n+      return -1;\n+    if ((char *)entry_ >= &buffer_[bytes_read_] && !GetDirectoryEntries())\n+      return -1;\n+    if (entry_->d_ino != 0 && entry_->d_name[0] >= '0' &&\n+        entry_->d_name[0] <= '9') {\n+      // Found a valid tid.\n+      tid = (int)internal_atoll(entry_->d_name);\n+    }\n+    entry_ = (struct linux_dirent *)(((char *)entry_) + entry_->d_reclen);\n+  } while (tid < 0);\n+  return tid;\n+}\n+\n+void ThreadLister::Reset() {\n+  if (error_ || descriptor_ < 0)\n+    return;\n+  internal_lseek(descriptor_, 0, SEEK_SET);\n+}\n+\n+ThreadLister::~ThreadLister() {\n+  if (descriptor_ >= 0)\n+    internal_close(descriptor_);\n+}\n+\n+bool ThreadLister::error() { return error_; }\n+\n+bool ThreadLister::GetDirectoryEntries() {\n+  CHECK_GE(descriptor_, 0);\n+  CHECK_NE(error_, true);\n+  bytes_read_ = internal_getdents(descriptor_,\n+                                  (struct linux_dirent *)buffer_.data(),\n+                                  buffer_.size());\n+  if (internal_iserror(bytes_read_)) {\n+    Report(\"Can't read directory entries from /proc/%d/task.\\n\", pid_);\n+    error_ = true;\n+    return false;\n+  } else if (bytes_read_ == 0) {\n+    return false;\n+  }\n+  entry_ = (struct linux_dirent *)buffer_.data();\n+  return true;\n+}\n+\n+uptr GetPageSize() {\n+#if defined(__x86_64__) || defined(__i386__)\n+  return EXEC_PAGESIZE;\n+#else\n+  return sysconf(_SC_PAGESIZE);  // EXEC_PAGESIZE may not be trustworthy.\n+#endif\n+}\n+\n+static char proc_self_exe_cache_str[kMaxPathLength];\n+static uptr proc_self_exe_cache_len = 0;\n+\n+uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n+  uptr module_name_len = internal_readlink(\n+      \"/proc/self/exe\", buf, buf_len);\n+  int readlink_error;\n+  if (internal_iserror(module_name_len, &readlink_error)) {\n+    if (proc_self_exe_cache_len) {\n+      // If available, use the cached module name.\n+      CHECK_LE(proc_self_exe_cache_len, buf_len);\n+      internal_strncpy(buf, proc_self_exe_cache_str, buf_len);\n+      module_name_len = internal_strlen(proc_self_exe_cache_str);\n+    } else {\n+      // We can't read /proc/self/exe for some reason, assume the name of the\n+      // binary is unknown.\n+      Report(\"WARNING: readlink(\\\"/proc/self/exe\\\") failed with errno %d, \"\n+             \"some stack frames may not be symbolized\\n\", readlink_error);\n+      module_name_len = internal_snprintf(buf, buf_len, \"/proc/self/exe\");\n+    }\n+    CHECK_LT(module_name_len, buf_len);\n+    buf[module_name_len] = '\\0';\n+  }\n+  return module_name_len;\n }\n \n+void CacheBinaryName() {\n+  if (!proc_self_exe_cache_len) {\n+    proc_self_exe_cache_len =\n+        ReadBinaryName(proc_self_exe_cache_str, kMaxPathLength);\n+  }\n+}\n+\n+// Match full names of the form /path/to/base_name{-,.}*\n+bool LibraryNameIs(const char *full_name, const char *base_name) {\n+  const char *name = full_name;\n+  // Strip path.\n+  while (*name != '\\0') name++;\n+  while (name > full_name && *name != '/') name--;\n+  if (*name == '/') name++;\n+  uptr base_name_length = internal_strlen(base_name);\n+  if (internal_strncmp(name, base_name, base_name_length)) return false;\n+  return (name[base_name_length] == '-' || name[base_name_length] == '.');\n+}\n+\n+#if !SANITIZER_ANDROID\n+// Call cb for each region mapped by map.\n+void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {\n+  typedef ElfW(Phdr) Elf_Phdr;\n+  typedef ElfW(Ehdr) Elf_Ehdr;\n+  char *base = (char *)map->l_addr;\n+  Elf_Ehdr *ehdr = (Elf_Ehdr *)base;\n+  char *phdrs = base + ehdr->e_phoff;\n+  char *phdrs_end = phdrs + ehdr->e_phnum * ehdr->e_phentsize;\n+\n+  // Find the segment with the minimum base so we can \"relocate\" the p_vaddr\n+  // fields.  Typically ET_DYN objects (DSOs) have base of zero and ET_EXEC\n+  // objects have a non-zero base.\n+  uptr preferred_base = (uptr)-1;\n+  for (char *iter = phdrs; iter != phdrs_end; iter += ehdr->e_phentsize) {\n+    Elf_Phdr *phdr = (Elf_Phdr *)iter;\n+    if (phdr->p_type == PT_LOAD && preferred_base > (uptr)phdr->p_vaddr)\n+      preferred_base = (uptr)phdr->p_vaddr;\n+  }\n+\n+  // Compute the delta from the real base to get a relocation delta.\n+  sptr delta = (uptr)base - preferred_base;\n+  // Now we can figure out what the loader really mapped.\n+  for (char *iter = phdrs; iter != phdrs_end; iter += ehdr->e_phentsize) {\n+    Elf_Phdr *phdr = (Elf_Phdr *)iter;\n+    if (phdr->p_type == PT_LOAD) {\n+      uptr seg_start = phdr->p_vaddr + delta;\n+      uptr seg_end = seg_start + phdr->p_memsz;\n+      // None of these values are aligned.  We consider the ragged edges of the\n+      // load command as defined, since they are mapped from the file.\n+      seg_start = RoundDownTo(seg_start, GetPageSizeCached());\n+      seg_end = RoundUpTo(seg_end, GetPageSizeCached());\n+      cb((void *)seg_start, seg_end - seg_start);\n+    }\n+  }\n+}\n+#endif\n+\n+#if defined(__x86_64__)\n+// We cannot use glibc's clone wrapper, because it messes with the child\n+// task's TLS. It writes the PID and TID of the child task to its thread\n+// descriptor, but in our case the child task shares the thread descriptor with\n+// the parent (because we don't know how to allocate a new thread\n+// descriptor to keep glibc happy). So the stock version of clone(), when\n+// used with CLONE_VM, would end up corrupting the parent's thread descriptor.\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  long long res;\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  CHECK_EQ(0, (uptr)child_stack % 16);\n+  child_stack = (char *)child_stack - 2 * sizeof(void *);\n+  ((void **)child_stack)[0] = (void *)(uptr)fn;\n+  ((void **)child_stack)[1] = arg;\n+  __asm__ __volatile__(\n+                       /* %rax = syscall(%rax = __NR_clone,\n+                        *                %rdi = flags,\n+                        *                %rsi = child_stack,\n+                        *                %rdx = parent_tidptr,\n+                        *                %r8  = new_tls,\n+                        *                %r10 = child_tidptr)\n+                        */\n+                       \"movq   %6,%%r8\\n\"\n+                       \"movq   %7,%%r10\\n\"\n+                       \".cfi_endproc\\n\"\n+                       \"syscall\\n\"\n+\n+                       /* if (%rax != 0)\n+                        *   return;\n+                        */\n+                       \"testq  %%rax,%%rax\\n\"\n+                       \"jnz    1f\\n\"\n+\n+                       /* In the child. Terminate unwind chain. */\n+                       \".cfi_startproc\\n\"\n+                       \".cfi_undefined %%rip;\\n\"\n+                       \"xorq   %%rbp,%%rbp\\n\"\n+\n+                       /* Call \"fn(arg)\". */\n+                       \"popq   %%rax\\n\"\n+                       \"popq   %%rdi\\n\"\n+                       \"call   *%%rax\\n\"\n+\n+                       /* Call _exit(%rax). */\n+                       \"movq   %%rax,%%rdi\\n\"\n+                       \"movq   %2,%%rax\\n\"\n+                       \"syscall\\n\"\n+\n+                       /* Return to parent. */\n+                     \"1:\\n\"\n+                       : \"=a\" (res)\n+                       : \"a\"(__NR_clone), \"i\"(__NR_exit),\n+                         \"S\"(child_stack),\n+                         \"D\"(flags),\n+                         \"d\"(parent_tidptr),\n+                         \"r\"(newtls),\n+                         \"r\"(child_tidptr)\n+                       : \"rsp\", \"memory\", \"r8\", \"r10\", \"r11\", \"rcx\");\n+  return res;\n+}\n+#endif  // defined(__x86_64__)\n }  // namespace __sanitizer\n \n-#endif  // __linux__\n+#endif  // SANITIZER_LINUX"}, {"sha": "5bbf47904d88e4b581b6ec44dab39338fe86fc4b", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,81 @@\n+//===-- sanitizer_linux.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Linux-specific syscall wrappers and classes.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_LINUX_H\n+#define SANITIZER_LINUX_H\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_internal_defs.h\"\n+\n+struct link_map;  // Opaque type returned by dlopen().\n+struct sigaltstack;\n+\n+namespace __sanitizer {\n+// Dirent structure for getdents(). Note that this structure is different from\n+// the one in <dirent.h>, which is used by readdir().\n+struct linux_dirent;\n+\n+// Syscall wrappers.\n+uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\n+uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n+uptr internal_sigaltstack(const struct sigaltstack* ss,\n+                          struct sigaltstack* oss);\n+#ifdef __x86_64__\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr);\n+#endif\n+\n+// This class reads thread IDs from /proc/<pid>/task using only syscalls.\n+class ThreadLister {\n+ public:\n+  explicit ThreadLister(int pid);\n+  ~ThreadLister();\n+  // GetNextTID returns -1 if the list of threads is exhausted, or if there has\n+  // been an error.\n+  int GetNextTID();\n+  void Reset();\n+  bool error();\n+\n+ private:\n+  bool GetDirectoryEntries();\n+\n+  int pid_;\n+  int descriptor_;\n+  InternalScopedBuffer<char> buffer_;\n+  bool error_;\n+  struct linux_dirent* entry_;\n+  int bytes_read_;\n+};\n+\n+void AdjustStackSizeLinux(void *attr, int verbosity);\n+\n+// Exposed for testing.\n+uptr ThreadDescriptorSize();\n+uptr ThreadSelf();\n+uptr ThreadSelfOffset();\n+\n+// Matches a library's file name against a base name (stripping path and version\n+// information).\n+bool LibraryNameIs(const char *full_name, const char *base_name);\n+\n+// Read the name of the current binary from /proc/self/exe.\n+uptr ReadBinaryName(/*out*/char *buf, uptr buf_len);\n+// Cache the value of /proc/self/exe.\n+void CacheBinaryName();\n+\n+// Call cb for each region mapped by map.\n+void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_LINUX_H"}, {"sha": "7d6c63918de4c5d80e1989744a01dba2933d9f1f", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,351 @@\n+//===-- sanitizer_linux_libcdep.cc ----------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries and implements linux-specific functions from\n+// sanitizer_libc.h.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_linux.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_stacktrace.h\"\n+\n+#include <dlfcn.h>\n+#include <pthread.h>\n+#include <sys/prctl.h>\n+#include <sys/resource.h>\n+#include <unwind.h>\n+\n+#if !SANITIZER_ANDROID\n+#include <elf.h>\n+#include <link.h>\n+#endif\n+\n+namespace __sanitizer {\n+\n+void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n+                                uptr *stack_bottom) {\n+  static const uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n+  CHECK(stack_top);\n+  CHECK(stack_bottom);\n+  if (at_initialization) {\n+    // This is the main thread. Libpthread may not be initialized yet.\n+    struct rlimit rl;\n+    CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n+\n+    // Find the mapping that contains a stack variable.\n+    MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+    uptr start, end, offset;\n+    uptr prev_end = 0;\n+    while (proc_maps.Next(&start, &end, &offset, 0, 0, /* protection */0)) {\n+      if ((uptr)&rl < end)\n+        break;\n+      prev_end = end;\n+    }\n+    CHECK((uptr)&rl >= start && (uptr)&rl < end);\n+\n+    // Get stacksize from rlimit, but clip it so that it does not overlap\n+    // with other mappings.\n+    uptr stacksize = rl.rlim_cur;\n+    if (stacksize > end - prev_end)\n+      stacksize = end - prev_end;\n+    // When running with unlimited stack size, we still want to set some limit.\n+    // The unlimited stack size is caused by 'ulimit -s unlimited'.\n+    // Also, for some reason, GNU make spawns subprocesses with unlimited stack.\n+    if (stacksize > kMaxThreadStackSize)\n+      stacksize = kMaxThreadStackSize;\n+    *stack_top = end;\n+    *stack_bottom = end - stacksize;\n+    return;\n+  }\n+  pthread_attr_t attr;\n+  CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n+  uptr stacksize = 0;\n+  void *stackaddr = 0;\n+  pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n+  pthread_attr_destroy(&attr);\n+\n+  CHECK_LE(stacksize, kMaxThreadStackSize);  // Sanity check.\n+  *stack_top = (uptr)stackaddr + stacksize;\n+  *stack_bottom = (uptr)stackaddr;\n+}\n+\n+// Does not compile for Go because dlsym() requires -ldl\n+#ifndef SANITIZER_GO\n+bool SetEnv(const char *name, const char *value) {\n+  void *f = dlsym(RTLD_NEXT, \"setenv\");\n+  if (f == 0)\n+    return false;\n+  typedef int(*setenv_ft)(const char *name, const char *value, int overwrite);\n+  setenv_ft setenv_f;\n+  CHECK_EQ(sizeof(setenv_f), sizeof(f));\n+  internal_memcpy(&setenv_f, &f, sizeof(f));\n+  return setenv_f(name, value, 1) == 0;\n+}\n+#endif\n+\n+bool SanitizerSetThreadName(const char *name) {\n+#ifdef PR_SET_NAME\n+  return 0 == prctl(PR_SET_NAME, (unsigned long)name, 0, 0, 0);  // NOLINT\n+#else\n+  return false;\n+#endif\n+}\n+\n+bool SanitizerGetThreadName(char *name, int max_len) {\n+#ifdef PR_GET_NAME\n+  char buff[17];\n+  if (prctl(PR_GET_NAME, (unsigned long)buff, 0, 0, 0))  // NOLINT\n+    return false;\n+  internal_strncpy(name, buff, max_len);\n+  name[max_len] = 0;\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+#ifndef SANITIZER_GO\n+//------------------------- SlowUnwindStack -----------------------------------\n+#ifdef __arm__\n+#define UNWIND_STOP _URC_END_OF_STACK\n+#define UNWIND_CONTINUE _URC_NO_REASON\n+#else\n+#define UNWIND_STOP _URC_NORMAL_STOP\n+#define UNWIND_CONTINUE _URC_NO_REASON\n+#endif\n+\n+uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n+#ifdef __arm__\n+  uptr val;\n+  _Unwind_VRS_Result res = _Unwind_VRS_Get(ctx, _UVRSC_CORE,\n+      15 /* r15 = PC */, _UVRSD_UINT32, &val);\n+  CHECK(res == _UVRSR_OK && \"_Unwind_VRS_Get failed\");\n+  // Clear the Thumb bit.\n+  return val & ~(uptr)1;\n+#else\n+  return _Unwind_GetIP(ctx);\n+#endif\n+}\n+\n+_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n+  StackTrace *b = (StackTrace*)param;\n+  CHECK(b->size < b->max_size);\n+  uptr pc = Unwind_GetIP(ctx);\n+  b->trace[b->size++] = pc;\n+  if (b->size == b->max_size) return UNWIND_STOP;\n+  return UNWIND_CONTINUE;\n+}\n+\n+static bool MatchPc(uptr cur_pc, uptr trace_pc) {\n+  return cur_pc - trace_pc <= 64 || trace_pc - cur_pc <= 64;\n+}\n+\n+void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n+  this->size = 0;\n+  this->max_size = max_depth;\n+  if (max_depth > 1) {\n+    _Unwind_Backtrace(Unwind_Trace, this);\n+    // We need to pop a few frames so that pc is on top.\n+    // trace[0] belongs to the current function so we always pop it.\n+    int to_pop = 1;\n+    /**/ if (size > 1 && MatchPc(pc, trace[1])) to_pop = 1;\n+    else if (size > 2 && MatchPc(pc, trace[2])) to_pop = 2;\n+    else if (size > 3 && MatchPc(pc, trace[3])) to_pop = 3;\n+    else if (size > 4 && MatchPc(pc, trace[4])) to_pop = 4;\n+    else if (size > 5 && MatchPc(pc, trace[5])) to_pop = 5;\n+    this->PopStackFrames(to_pop);\n+  }\n+  this->trace[0] = pc;\n+}\n+\n+#endif  // !SANITIZER_GO\n+\n+static uptr g_tls_size;\n+\n+#ifdef __i386__\n+# define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n+#else\n+# define DL_INTERNAL_FUNCTION\n+#endif\n+\n+void InitTlsSize() {\n+#if !defined(SANITIZER_GO) && !SANITIZER_ANDROID\n+  typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;\n+  get_tls_func get_tls;\n+  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n+  CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));\n+  internal_memcpy(&get_tls, &get_tls_static_info_ptr,\n+                  sizeof(get_tls_static_info_ptr));\n+  CHECK_NE(get_tls, 0);\n+  size_t tls_size = 0;\n+  size_t tls_align = 0;\n+  get_tls(&tls_size, &tls_align);\n+  g_tls_size = tls_size;\n+#endif\n+}\n+\n+uptr GetTlsSize() {\n+  return g_tls_size;\n+}\n+\n+#if defined(__x86_64__) || defined(__i386__)\n+// sizeof(struct thread) from glibc.\n+// There has been a report of this being different on glibc 2.11 and 2.13. We\n+// don't know when this change happened, so 2.14 is a conservative estimate.\n+#if __GLIBC_PREREQ(2, 14)\n+const uptr kThreadDescriptorSize = FIRST_32_SECOND_64(1216, 2304);\n+#else\n+const uptr kThreadDescriptorSize = FIRST_32_SECOND_64(1168, 2304);\n+#endif\n+\n+uptr ThreadDescriptorSize() {\n+  return kThreadDescriptorSize;\n+}\n+\n+// The offset at which pointer to self is located in the thread descriptor.\n+const uptr kThreadSelfOffset = FIRST_32_SECOND_64(8, 16);\n+\n+uptr ThreadSelfOffset() {\n+  return kThreadSelfOffset;\n+}\n+\n+uptr ThreadSelf() {\n+  uptr descr_addr;\n+#ifdef __i386__\n+  asm(\"mov %%gs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n+#else\n+  asm(\"mov %%fs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n+#endif\n+  return descr_addr;\n+}\n+#endif  // defined(__x86_64__) || defined(__i386__)\n+\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size) {\n+#ifndef SANITIZER_GO\n+#if defined(__x86_64__) || defined(__i386__)\n+  *tls_addr = ThreadSelf();\n+  *tls_size = GetTlsSize();\n+  *tls_addr -= *tls_size;\n+  *tls_addr += kThreadDescriptorSize;\n+#else\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+#endif\n+\n+  uptr stack_top, stack_bottom;\n+  GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n+  *stk_addr = stack_bottom;\n+  *stk_size = stack_top - stack_bottom;\n+\n+  if (!main) {\n+    // If stack and tls intersect, make them non-intersecting.\n+    if (*tls_addr > *stk_addr && *tls_addr < *stk_addr + *stk_size) {\n+      CHECK_GT(*tls_addr + *tls_size, *stk_addr);\n+      CHECK_LE(*tls_addr + *tls_size, *stk_addr + *stk_size);\n+      *stk_size -= *tls_size;\n+      *tls_addr = *stk_addr + *stk_size;\n+    }\n+  }\n+#else  // SANITIZER_GO\n+  *stk_addr = 0;\n+  *stk_size = 0;\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+#endif  // SANITIZER_GO\n+}\n+\n+void AdjustStackSizeLinux(void *attr_, int verbosity) {\n+  pthread_attr_t *attr = (pthread_attr_t *)attr_;\n+  uptr stackaddr = 0;\n+  size_t stacksize = 0;\n+  pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);\n+  // GLibC will return (0 - stacksize) as the stack address in the case when\n+  // stacksize is set, but stackaddr is not.\n+  bool stack_set = (stackaddr != 0) && (stackaddr + stacksize != 0);\n+  // We place a lot of tool data into TLS, account for that.\n+  const uptr minstacksize = GetTlsSize() + 128*1024;\n+  if (stacksize < minstacksize) {\n+    if (!stack_set) {\n+      if (verbosity && stacksize != 0)\n+        Printf(\"Sanitizer: increasing stacksize %zu->%zu\\n\", stacksize,\n+               minstacksize);\n+      pthread_attr_setstacksize(attr, minstacksize);\n+    } else {\n+      Printf(\"Sanitizer: pre-allocated stack size is insufficient: \"\n+             \"%zu < %zu\\n\", stacksize, minstacksize);\n+      Printf(\"Sanitizer: pthread_create is likely to fail.\\n\");\n+    }\n+  }\n+}\n+\n+#if SANITIZER_ANDROID\n+uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n+                      string_predicate_t filter) {\n+  return 0;\n+}\n+#else  // SANITIZER_ANDROID\n+typedef ElfW(Phdr) Elf_Phdr;\n+\n+struct DlIteratePhdrData {\n+  LoadedModule *modules;\n+  uptr current_n;\n+  bool first;\n+  uptr max_n;\n+  string_predicate_t filter;\n+};\n+\n+static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n+  DlIteratePhdrData *data = (DlIteratePhdrData*)arg;\n+  if (data->current_n == data->max_n)\n+    return 0;\n+  InternalScopedBuffer<char> module_name(kMaxPathLength);\n+  module_name.data()[0] = '\\0';\n+  if (data->first) {\n+    data->first = false;\n+    // First module is the binary itself.\n+    ReadBinaryName(module_name.data(), module_name.size());\n+  } else if (info->dlpi_name) {\n+    internal_strncpy(module_name.data(), info->dlpi_name, module_name.size());\n+  }\n+  if (module_name.data()[0] == '\\0')\n+    return 0;\n+  if (data->filter && !data->filter(module_name.data()))\n+    return 0;\n+  void *mem = &data->modules[data->current_n];\n+  LoadedModule *cur_module = new(mem) LoadedModule(module_name.data(),\n+                                                   info->dlpi_addr);\n+  data->current_n++;\n+  for (int i = 0; i < info->dlpi_phnum; i++) {\n+    const Elf_Phdr *phdr = &info->dlpi_phdr[i];\n+    if (phdr->p_type == PT_LOAD) {\n+      uptr cur_beg = info->dlpi_addr + phdr->p_vaddr;\n+      uptr cur_end = cur_beg + phdr->p_memsz;\n+      cur_module->addAddressRange(cur_beg, cur_end);\n+    }\n+  }\n+  return 0;\n+}\n+\n+uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n+                      string_predicate_t filter) {\n+  CHECK(modules);\n+  DlIteratePhdrData data = {modules, 0, true, max_modules, filter};\n+  dl_iterate_phdr(dl_iterate_phdr_cb, &data);\n+  return data.current_n;\n+}\n+#endif  // SANITIZER_ANDROID\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_LINUX"}, {"sha": "fa146b5b4e8a49c0f6ccba399828bebfe7e6d489", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 110, "deletions": 24, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -10,7 +10,9 @@\n // sanitizer_libc.h.\n //===----------------------------------------------------------------------===//\n \n-#ifdef __APPLE__\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+\n // Use 64-bit inodes in file operations. ASan does not support OS X 10.5, so\n // the clients will most certainly use 64-bit ones as well.\n #ifndef _DARWIN_USE_64_BIT_INODE\n@@ -21,6 +23,7 @@\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n \n #include <crt_externs.h>  // for _NSGetEnviron\n@@ -35,32 +38,35 @@\n #include <sys/types.h>\n #include <unistd.h>\n #include <libkern/OSAtomic.h>\n+#include <errno.h>\n \n namespace __sanitizer {\n \n+#include \"sanitizer_syscall_generic.inc\"\n+\n // ---------------------- sanitizer_libc.h\n-void *internal_mmap(void *addr, size_t length, int prot, int flags,\n-                    int fd, u64 offset) {\n-  return mmap(addr, length, prot, flags, fd, offset);\n+uptr internal_mmap(void *addr, size_t length, int prot, int flags,\n+                   int fd, u64 offset) {\n+  return (uptr)mmap(addr, length, prot, flags, fd, offset);\n }\n \n-int internal_munmap(void *addr, uptr length) {\n+uptr internal_munmap(void *addr, uptr length) {\n   return munmap(addr, length);\n }\n \n-int internal_close(fd_t fd) {\n+uptr internal_close(fd_t fd) {\n   return close(fd);\n }\n \n-fd_t internal_open(const char *filename, int flags) {\n+uptr internal_open(const char *filename, int flags) {\n   return open(filename, flags);\n }\n \n-fd_t internal_open(const char *filename, int flags, u32 mode) {\n+uptr internal_open(const char *filename, int flags, u32 mode) {\n   return open(filename, flags, mode);\n }\n \n-fd_t OpenFile(const char *filename, bool write) {\n+uptr OpenFile(const char *filename, bool write) {\n   return internal_open(filename,\n       write ? O_WRONLY | O_CREAT : O_RDONLY, 0660);\n }\n@@ -73,15 +79,15 @@ uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   return write(fd, buf, count);\n }\n \n-int internal_stat(const char *path, void *buf) {\n+uptr internal_stat(const char *path, void *buf) {\n   return stat(path, (struct stat *)buf);\n }\n \n-int internal_lstat(const char *path, void *buf) {\n+uptr internal_lstat(const char *path, void *buf) {\n   return lstat(path, (struct stat *)buf);\n }\n \n-int internal_fstat(fd_t fd, void *buf) {\n+uptr internal_fstat(fd_t fd, void *buf) {\n   return fstat(fd, (struct stat *)buf);\n }\n \n@@ -92,22 +98,26 @@ uptr internal_filesize(fd_t fd) {\n   return (uptr)st.st_size;\n }\n \n-int internal_dup2(int oldfd, int newfd) {\n+uptr internal_dup2(int oldfd, int newfd) {\n   return dup2(oldfd, newfd);\n }\n \n uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n   return readlink(path, buf, bufsize);\n }\n \n-int internal_sched_yield() {\n+uptr internal_sched_yield() {\n   return sched_yield();\n }\n \n void internal__exit(int exitcode) {\n   _exit(exitcode);\n }\n \n+uptr internal_getpid() {\n+  return getpid();\n+}\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n   struct stat st;\n@@ -159,9 +169,13 @@ void PrepareForSandboxing() {\n   // Nothing here for now.\n }\n \n+uptr GetPageSize() {\n+  return sysconf(_SC_PAGESIZE);\n+}\n+\n // ----------------- sanitizer_procmaps.h\n \n-MemoryMappingLayout::MemoryMappingLayout() {\n+MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n   Reset();\n }\n \n@@ -214,7 +228,9 @@ void MemoryMappingLayout::LoadFromCache() {\n template<u32 kLCSegment, typename SegmentCommand>\n bool MemoryMappingLayout::NextSegmentLoad(\n     uptr *start, uptr *end, uptr *offset,\n-    char filename[], uptr filename_size) {\n+    char filename[], uptr filename_size, uptr *protection) {\n+  if (protection)\n+    UNIMPLEMENTED();\n   const char* lc = current_load_cmd_addr_;\n   current_load_cmd_addr_ += ((const load_command *)lc)->cmdsize;\n   if (((const load_command *)lc)->cmd == kLCSegment) {\n@@ -239,7 +255,8 @@ bool MemoryMappingLayout::NextSegmentLoad(\n }\n \n bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n-                               char filename[], uptr filename_size) {\n+                               char filename[], uptr filename_size,\n+                               uptr *protection) {\n   for (; current_image_ >= 0; current_image_--) {\n     const mach_header* hdr = _dyld_get_image_header(current_image_);\n     if (!hdr) continue;\n@@ -271,14 +288,14 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n #ifdef MH_MAGIC_64\n         case MH_MAGIC_64: {\n           if (NextSegmentLoad<LC_SEGMENT_64, struct segment_command_64>(\n-                  start, end, offset, filename, filename_size))\n+                  start, end, offset, filename, filename_size, protection))\n             return true;\n           break;\n         }\n #endif\n         case MH_MAGIC: {\n           if (NextSegmentLoad<LC_SEGMENT, struct segment_command>(\n-                  start, end, offset, filename, filename_size))\n+                  start, end, offset, filename, filename_size, protection))\n             return true;\n           break;\n         }\n@@ -292,18 +309,24 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n \n bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n                                                  char filename[],\n-                                                 uptr filename_size) {\n-  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size);\n+                                                 uptr filename_size,\n+                                                 uptr *protection) {\n+  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size,\n+                                       protection);\n }\n \n BlockingMutex::BlockingMutex(LinkerInitialized) {\n   // We assume that OS_SPINLOCK_INIT is zero\n }\n \n+BlockingMutex::BlockingMutex() {\n+  internal_memset(this, 0, sizeof(*this));\n+}\n+\n void BlockingMutex::Lock() {\n   CHECK(sizeof(OSSpinLock) <= sizeof(opaque_storage_));\n-  CHECK(OS_SPINLOCK_INIT == 0);\n-  CHECK(owner_ != (uptr)pthread_self());\n+  CHECK_EQ(OS_SPINLOCK_INIT, 0);\n+  CHECK_NE(owner_, (uptr)pthread_self());\n   OSSpinLockLock((OSSpinLock*)&opaque_storage_);\n   CHECK(!owner_);\n   owner_ = (uptr)pthread_self();\n@@ -315,6 +338,69 @@ void BlockingMutex::Unlock() {\n   OSSpinLockUnlock((OSSpinLock*)&opaque_storage_);\n }\n \n+void BlockingMutex::CheckLocked() {\n+  CHECK_EQ((uptr)pthread_self(), owner_);\n+}\n+\n+u64 NanoTime() {\n+  return 0;\n+}\n+\n+uptr GetTlsSize() {\n+  return 0;\n+}\n+\n+void InitTlsSize() {\n+}\n+\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size) {\n+#ifndef SANITIZER_GO\n+  uptr stack_top, stack_bottom;\n+  GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n+  *stk_addr = stack_bottom;\n+  *stk_size = stack_top - stack_bottom;\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+#else\n+  *stk_addr = 0;\n+  *stk_size = 0;\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+#endif\n+}\n+\n+uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n+                      string_predicate_t filter) {\n+  MemoryMappingLayout memory_mapping(false);\n+  memory_mapping.Reset();\n+  uptr cur_beg, cur_end, cur_offset;\n+  InternalScopedBuffer<char> module_name(kMaxPathLength);\n+  uptr n_modules = 0;\n+  for (uptr i = 0;\n+       n_modules < max_modules &&\n+           memory_mapping.Next(&cur_beg, &cur_end, &cur_offset,\n+                               module_name.data(), module_name.size(), 0);\n+       i++) {\n+    const char *cur_name = module_name.data();\n+    if (cur_name[0] == '\\0')\n+      continue;\n+    if (filter && !filter(cur_name))\n+      continue;\n+    LoadedModule *cur_module = 0;\n+    if (n_modules > 0 &&\n+        0 == internal_strcmp(cur_name, modules[n_modules - 1].full_name())) {\n+      cur_module = &modules[n_modules - 1];\n+    } else {\n+      void *mem = &modules[n_modules];\n+      cur_module = new(mem) LoadedModule(cur_name, cur_beg);\n+      n_modules++;\n+    }\n+    cur_module->addAddressRange(cur_beg, cur_end);\n+  }\n+  return n_modules;\n+}\n+\n }  // namespace __sanitizer\n \n-#endif  // __APPLE__\n+#endif  // SANITIZER_MAC"}, {"sha": "b35011462793bae10cd0139d227b8abd8590a99f", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -68,8 +68,10 @@ class SpinMutex : public StaticSpinMutex {\n class BlockingMutex {\n  public:\n   explicit BlockingMutex(LinkerInitialized);\n+  BlockingMutex();\n   void Lock();\n   void Unlock();\n+  void CheckLocked();\n  private:\n   uptr opaque_storage_[10];\n   uptr owner_;  // for debugging"}, {"sha": "310327fd8f0b5220b15d0cb74fa87790cac4a099", "filename": "libsanitizer/sanitizer_common/sanitizer_placement_new.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -17,7 +17,7 @@\n #include \"sanitizer_internal_defs.h\"\n \n namespace __sanitizer {\n-#if (SANITIZER_WORDSIZE == 64) || defined(__APPLE__)\n+#if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC\n typedef uptr operator_new_ptr_type;\n #else\n typedef u32 operator_new_ptr_type;"}, {"sha": "2270709449bbc4897c7ffd7d4a01eb92752fa661", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,44 @@\n+//===-- sanitizer_platform.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Common platform macros.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_PLATFORM_H\n+#define SANITIZER_PLATFORM_H\n+\n+#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n+# error \"This operating system is not supported\"\n+#endif\n+\n+#if defined(__linux__)\n+# define SANITIZER_LINUX   1\n+#else\n+# define SANITIZER_LINUX   0\n+#endif\n+\n+#if defined(__APPLE__)\n+# define SANITIZER_MAC     1\n+#else\n+# define SANITIZER_MAC     0\n+#endif\n+\n+#if defined(_WIN32)\n+# define SANITIZER_WINDOWS 1\n+#else\n+# define SANITIZER_WINDOWS 0\n+#endif\n+\n+#if defined(__ANDROID__) || defined(ANDROID)\n+# define SANITIZER_ANDROID 1\n+#else\n+# define SANITIZER_ANDROID 0\n+#endif\n+\n+#define SANITIZER_POSIX (SANITIZER_LINUX || SANITIZER_MAC)\n+\n+#endif // SANITIZER_PLATFORM_H"}, {"sha": "e0199482f1060de4430af28a44e409c83a7ff46e", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 88, "deletions": 6, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -9,38 +9,120 @@\n // given library functions on a given platform.\n //\n //===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_PLATFORM_INTERCEPTORS_H\n+#define SANITIZER_PLATFORM_INTERCEPTORS_H\n \n #include \"sanitizer_internal_defs.h\"\n \n-#if !defined(_WIN32)\n+#if !SANITIZER_WINDOWS\n # define SI_NOT_WINDOWS 1\n # include \"sanitizer_platform_limits_posix.h\"\n #else\n # define SI_NOT_WINDOWS 0\n #endif\n \n-#if defined(__linux__) && !defined(ANDROID)\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n # define SI_LINUX_NOT_ANDROID 1\n #else\n # define SI_LINUX_NOT_ANDROID 0\n #endif\n \n-#if defined(__linux__)\n+#if SANITIZER_LINUX\n # define SI_LINUX 1\n #else\n # define SI_LINUX 0\n #endif\n \n+#if SANITIZER_MAC\n+# define SI_MAC 1\n+#else\n+# define SI_MAC 0\n+#endif\n+\n+# define SANITIZER_INTERCEPT_STRCMP 1\n+# define SANITIZER_INTERCEPT_STRCASECMP SI_NOT_WINDOWS\n+\n # define SANITIZER_INTERCEPT_READ   SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_PREAD  SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_WRITE  SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_PWRITE SI_NOT_WINDOWS\n \n-# define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_PRCTL   SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n+\n+#define SANITIZER_INTERCEPT_READV SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_WRITEV SI_NOT_WINDOWS\n+\n+#define SANITIZER_INTERCEPT_PREADV SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PWRITEV SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PREADV64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PWRITEV64 SI_LINUX_NOT_ANDROID\n+\n+# define SANITIZER_INTERCEPT_PRCTL   SI_LINUX\n \n # define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_NOT_WINDOWS\n \n # define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX\n+\n+# define SANITIZER_INTERCEPT_FREXP 1\n+# define SANITIZER_INTERCEPT_FREXPF_FREXPL SI_NOT_WINDOWS\n+\n+# define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS \\\n+    SI_MAC || SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_CLOCK_GETTIME SI_LINUX\n+# define SANITIZER_INTERCEPT_GETITIMER SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_TIME SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_WAIT SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_INET SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETADDRINFO SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETNAMEINFO SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETSOCKNAME SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETHOSTBYNAME_R SI_LINUX\n+# define SANITIZER_INTERCEPT_GETSOCKOPT SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_ACCEPT SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX\n+# define SANITIZER_INTERCEPT_MODF SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_RECVMSG SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETPEERNAME SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_IOCTL SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_INET_ATON SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_SYSINFO SI_LINUX\n+# define SANITIZER_INTERCEPT_READDIR SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_PTRACE SI_LINUX_NOT_ANDROID && \\\n+  (defined(__i386) || defined (__x86_64))  // NOLINT\n+# define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX\n+# define SANITIZER_INTERCEPT_STRTOIMAX SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_MBSTOWCS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_MBSNRTOWCS SI_MAC || SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_WCSTOMBS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_WCSNRTOMBS SI_MAC || SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX\n+# define SANITIZER_INTERCEPT_REALPATH SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_CONFSTR SI_MAC || SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_STRERROR SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_STRERROR_R SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_SCANDIR SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_GETGROUPS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_POLL SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PPOLL SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_WORDEXP SI_MAC || SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_SIGWAIT SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_SIGSETOPS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_SIGPENDING SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_SIGPROCMASK SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_BACKTRACE SI_LINUX_NOT_ANDROID\n+\n+#endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "fbea5962c81db0daa3893e9f681fb3361bb8ea19", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -0,0 +1,45 @@\n+//===-- sanitizer_platform_limits_linux.cc --------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of linux kernel data structures.\n+//===----------------------------------------------------------------------===//\n+\n+// This is a separate compilation unit for linux headers that conflict with\n+// userspace headers.\n+// Most \"normal\" includes go in sanitizer_platform_limits_posix.cc\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n+\n+// This header seems to contain the definitions of _kernel_ stat* structs.\n+#include <asm/stat.h>\n+#include <linux/aio_abi.h>\n+\n+#if !SANITIZER_ANDROID\n+#include <linux/perf_event.h>\n+#endif\n+\n+namespace __sanitizer {\n+  unsigned struct___old_kernel_stat_sz = sizeof(struct __old_kernel_stat);\n+  unsigned struct_kernel_stat_sz = sizeof(struct stat);\n+  unsigned struct_io_event_sz = sizeof(struct io_event);\n+  unsigned struct_iocb_sz = sizeof(struct iocb);\n+\n+#ifndef _LP64\n+  unsigned struct_kernel_stat64_sz = sizeof(struct stat64);\n+#else\n+  unsigned struct_kernel_stat64_sz = 0;\n+#endif\n+\n+#if !SANITIZER_ANDROID\n+  unsigned struct_perf_event_attr_sz = sizeof(struct perf_event_attr);\n+#endif\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_LINUX"}, {"sha": "971a19314d872c75a2c5cd6292659a69ffdfb6c3", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 839, "deletions": 24, "changes": 863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "patch": "@@ -10,59 +10,874 @@\n // Sizes and layouts of platform-specific POSIX data structures.\n //===----------------------------------------------------------------------===//\n \n-#if defined(__linux__) || defined(__APPLE__)\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_LINUX || SANITIZER_MAC\n \n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n \n+#include <arpa/inet.h>\n #include <dirent.h>\n-#include <sys/utsname.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n+#include <grp.h>\n+#include <limits.h>\n+#include <net/if.h>\n+#include <net/if_arp.h>\n+#include <net/route.h>\n+#include <netdb.h>\n+#include <poll.h>\n+#include <pthread.h>\n+#include <pwd.h>\n+#include <signal.h>\n+#include <stddef.h>\n #include <sys/resource.h>\n #include <sys/socket.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/times.h>\n+#include <sys/types.h>\n+#include <sys/utsname.h>\n+#include <termios.h>\n #include <time.h>\n+#include <wchar.h>\n+\n+#if SANITIZER_LINUX\n+#include <utime.h>\n+#include <sys/mount.h>\n+#include <sys/ptrace.h>\n+#include <sys/sysinfo.h>\n+#include <sys/vt.h>\n+#include <linux/cdrom.h>\n+#include <linux/fd.h>\n+#include <linux/fs.h>\n+#include <linux/hdreg.h>\n+#include <linux/input.h>\n+#include <linux/ioctl.h>\n+#include <linux/soundcard.h>\n+#include <linux/sysctl.h>\n+#include <linux/utsname.h>\n+#include <linux/posix_types.h>\n+#endif\n+\n+#if !SANITIZER_ANDROID\n+#include <sys/ucontext.h>\n+#include <wordexp.h>\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#include <glob.h>\n+#include <mqueue.h>\n+#include <net/if_ppp.h>\n+#include <netax25/ax25.h>\n+#include <netipx/ipx.h>\n+#include <netrom/netrom.h>\n+#include <scsi/scsi.h>\n+#include <sys/mtio.h>\n+#include <sys/kd.h>\n+#include <sys/shm.h>\n+#include <sys/timex.h>\n+#include <sys/user.h>\n+#include <sys/ustat.h>\n+#include <linux/cyclades.h>\n+#include <linux/if_eql.h>\n+#include <linux/if_plip.h>\n+#include <linux/lp.h>\n+#include <linux/mroute.h>\n+#include <linux/mroute6.h>\n+#include <linux/scc.h>\n+#include <linux/serial.h>\n+#include <sys/msg.h>\n+#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n+\n+#if SANITIZER_ANDROID\n+#include <linux/kd.h>\n+#include <linux/mtio.h>\n+#include <linux/ppp_defs.h>\n+#include <linux/if_ppp.h>\n+#endif\n \n-#if defined(__linux__)\n+#if SANITIZER_LINUX\n+#include <link.h>\n #include <sys/vfs.h>\n #include <sys/epoll.h>\n-#endif // __linux__\n+// #include <asm/stat.h>\n+#include <linux/capability.h>\n+#endif // SANITIZER_LINUX\n+\n+#if SANITIZER_MAC\n+#include <netinet/ip_mroute.h>\n+#include <sys/filio.h>\n+#include <sys/sockio.h>\n+#endif\n \n namespace __sanitizer {\n   unsigned struct_utsname_sz = sizeof(struct utsname);\n   unsigned struct_stat_sz = sizeof(struct stat);\n   unsigned struct_stat64_sz = sizeof(struct stat64);\n   unsigned struct_rusage_sz = sizeof(struct rusage);\n   unsigned struct_tm_sz = sizeof(struct tm);\n+  unsigned struct_passwd_sz = sizeof(struct passwd);\n+  unsigned struct_group_sz = sizeof(struct group);\n+  unsigned siginfo_t_sz = sizeof(siginfo_t);\n+  unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+  unsigned struct_itimerval_sz = sizeof(struct itimerval);\n+  unsigned pthread_t_sz = sizeof(pthread_t);\n+  unsigned pid_t_sz = sizeof(pid_t);\n+  unsigned timeval_sz = sizeof(timeval);\n+  unsigned uid_t_sz = sizeof(uid_t);\n+  unsigned mbstate_t_sz = sizeof(mbstate_t);\n+  unsigned sigset_t_sz = sizeof(sigset_t);\n+  unsigned struct_timezone_sz = sizeof(struct timezone);\n+  unsigned struct_tms_sz = sizeof(struct tms);\n+  unsigned struct_sigevent_sz = sizeof(struct sigevent);\n+  unsigned struct_sched_param_sz = sizeof(struct sched_param);\n+\n+#if !SANITIZER_ANDROID\n+  unsigned ucontext_t_sz = sizeof(ucontext_t);\n+#endif // !SANITIZER_ANDROID\n \n-#if defined(__linux__)\n+#if SANITIZER_LINUX\n   unsigned struct_rlimit_sz = sizeof(struct rlimit);\n-  unsigned struct_dirent_sz = sizeof(struct dirent);\n   unsigned struct_statfs_sz = sizeof(struct statfs);\n   unsigned struct_epoll_event_sz = sizeof(struct epoll_event);\n-#endif // __linux__\n+  unsigned struct_sysinfo_sz = sizeof(struct sysinfo);\n+  unsigned struct_timespec_sz = sizeof(struct timespec);\n+  unsigned __user_cap_header_struct_sz =\n+      sizeof(struct __user_cap_header_struct);\n+  unsigned __user_cap_data_struct_sz = sizeof(struct __user_cap_data_struct);\n+  unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n+  unsigned struct_new_utsname_sz = sizeof(struct new_utsname);\n+  unsigned struct_old_utsname_sz = sizeof(struct old_utsname);\n+  unsigned struct_oldold_utsname_sz = sizeof(struct oldold_utsname);\n+  unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n+  unsigned struct_ustat_sz = sizeof(struct ustat);\n+#endif // SANITIZER_LINUX\n \n-#if defined(__linux__) && !defined(__ANDROID__)\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n-#endif // __linux__ && !__ANDROID__\n+  unsigned struct_timex_sz = sizeof(struct timex);\n+  unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n+  unsigned struct_shmid_ds_sz = sizeof(struct shmid_ds);\n+  unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n+#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-  void* __sanitizer_get_msghdr_iov_iov_base(void* msg, int idx) {\n-    return ((struct msghdr *)msg)->msg_iov[idx].iov_base;\n-  }\n+  uptr sig_ign = (uptr)SIG_IGN;\n+  uptr sig_dfl = (uptr)SIG_DFL;\n+  uptr sa_siginfo = (uptr)SA_SIGINFO;\n \n-  uptr __sanitizer_get_msghdr_iov_iov_len(void* msg, int idx) {\n-    return ((struct msghdr *)msg)->msg_iov[idx].iov_len;\n-  }\n+#if SANITIZER_LINUX\n+  int e_tabsz = (int)E_TABSZ;\n+#endif\n \n-  uptr __sanitizer_get_msghdr_iovlen(void* msg) {\n-    return ((struct msghdr *)msg)->msg_iovlen;\n-  }\n+  int af_inet = (int)AF_INET;\n+  int af_inet6 = (int)AF_INET6;\n \n-  uptr __sanitizer_get_socklen_t(void* socklen_ptr) {\n-    return *(socklen_t*)socklen_ptr;\n+  uptr __sanitizer_in_addr_sz(int af) {\n+    if (af == AF_INET)\n+      return sizeof(struct in_addr);\n+    else if (af == AF_INET6)\n+      return sizeof(struct in6_addr);\n+    else\n+      return 0;\n   }\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  int glob_nomatch = GLOB_NOMATCH;\n+  int glob_altdirfunc = GLOB_ALTDIRFUNC;\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n+      (defined(__i386) || defined (__x86_64))  // NOLINT\n+  unsigned struct_user_regs_struct_sz = sizeof(struct user_regs_struct);\n+  unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpregs_struct);\n+#if __WORDSIZE == 64\n+  unsigned struct_user_fpxregs_struct_sz = 0;\n+#else\n+  unsigned struct_user_fpxregs_struct_sz = sizeof(struct user_fpxregs_struct);\n+#endif\n+\n+  int ptrace_getregs = PTRACE_GETREGS;\n+  int ptrace_setregs = PTRACE_SETREGS;\n+  int ptrace_getfpregs = PTRACE_GETFPREGS;\n+  int ptrace_setfpregs = PTRACE_SETFPREGS;\n+  int ptrace_getfpxregs = PTRACE_GETFPXREGS;\n+  int ptrace_setfpxregs = PTRACE_SETFPXREGS;\n+  int ptrace_getsiginfo = PTRACE_GETSIGINFO;\n+  int ptrace_setsiginfo = PTRACE_SETSIGINFO;\n+#if defined(PTRACE_GETREGSET) && defined(PTRACE_SETREGSET)\n+  int ptrace_getregset = PTRACE_GETREGSET;\n+  int ptrace_setregset = PTRACE_SETREGSET;\n+#else\n+  int ptrace_getregset = -1;\n+  int ptrace_setregset = -1;\n+#endif\n+#endif\n+\n+  unsigned path_max = PATH_MAX;\n+\n+  // ioctl arguments\n+  unsigned struct_arpreq_sz = sizeof(struct arpreq);\n+  unsigned struct_ifreq_sz = sizeof(struct ifreq);\n+  unsigned struct_termios_sz = sizeof(struct termios);\n+  unsigned struct_winsize_sz = sizeof(struct winsize);\n+\n+#if SANITIZER_LINUX\n+  unsigned struct_cdrom_msf_sz = sizeof(struct cdrom_msf);\n+  unsigned struct_cdrom_multisession_sz = sizeof(struct cdrom_multisession);\n+  unsigned struct_cdrom_read_audio_sz = sizeof(struct cdrom_read_audio);\n+  unsigned struct_cdrom_subchnl_sz = sizeof(struct cdrom_subchnl);\n+  unsigned struct_cdrom_ti_sz = sizeof(struct cdrom_ti);\n+  unsigned struct_cdrom_tocentry_sz = sizeof(struct cdrom_tocentry);\n+  unsigned struct_cdrom_tochdr_sz = sizeof(struct cdrom_tochdr);\n+  unsigned struct_cdrom_volctrl_sz = sizeof(struct cdrom_volctrl);\n+#if SOUND_VERSION >= 0x040000\n+  unsigned struct_copr_buffer_sz = 0;\n+  unsigned struct_copr_debug_buf_sz = 0;\n+  unsigned struct_copr_msg_sz = 0;\n+#else\n+  unsigned struct_copr_buffer_sz = sizeof(struct copr_buffer);\n+  unsigned struct_copr_debug_buf_sz = sizeof(struct copr_debug_buf);\n+  unsigned struct_copr_msg_sz = sizeof(struct copr_msg);\n+#endif\n+  unsigned struct_ff_effect_sz = sizeof(struct ff_effect);\n+  unsigned struct_floppy_drive_params_sz = sizeof(struct floppy_drive_params);\n+  unsigned struct_floppy_drive_struct_sz = sizeof(struct floppy_drive_struct);\n+  unsigned struct_floppy_fdc_state_sz = sizeof(struct floppy_fdc_state);\n+  unsigned struct_floppy_max_errors_sz = sizeof(struct floppy_max_errors);\n+  unsigned struct_floppy_raw_cmd_sz = sizeof(struct floppy_raw_cmd);\n+  unsigned struct_floppy_struct_sz = sizeof(struct floppy_struct);\n+  unsigned struct_floppy_write_errors_sz = sizeof(struct floppy_write_errors);\n+  unsigned struct_format_descr_sz = sizeof(struct format_descr);\n+  unsigned struct_hd_driveid_sz = sizeof(struct hd_driveid);\n+  unsigned struct_hd_geometry_sz = sizeof(struct hd_geometry);\n+  unsigned struct_input_absinfo_sz = sizeof(struct input_absinfo);\n+  unsigned struct_input_id_sz = sizeof(struct input_id);\n+  unsigned struct_midi_info_sz = sizeof(struct midi_info);\n+  unsigned struct_mtget_sz = sizeof(struct mtget);\n+  unsigned struct_mtop_sz = sizeof(struct mtop);\n+  unsigned struct_mtpos_sz = sizeof(struct mtpos);\n+  unsigned struct_rtentry_sz = sizeof(struct rtentry);\n+  unsigned struct_sbi_instrument_sz = sizeof(struct sbi_instrument);\n+  unsigned struct_seq_event_rec_sz = sizeof(struct seq_event_rec);\n+  unsigned struct_synth_info_sz = sizeof(struct synth_info);\n+  unsigned struct_termio_sz = sizeof(struct termio);\n+  unsigned struct_vt_consize_sz = sizeof(struct vt_consize);\n+  unsigned struct_vt_mode_sz = sizeof(struct vt_mode);\n+  unsigned struct_vt_sizes_sz = sizeof(struct vt_sizes);\n+  unsigned struct_vt_stat_sz = sizeof(struct vt_stat);\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n+  unsigned struct_ax25_parms_struct_sz = sizeof(struct ax25_parms_struct);\n+  unsigned struct_cyclades_monitor_sz = sizeof(struct cyclades_monitor);\n+#if EV_VERSION > (0x010000)\n+  unsigned struct_input_keymap_entry_sz = sizeof(struct input_keymap_entry);\n+#else\n+  unsigned struct_input_keymap_entry_sz = 0;\n+#endif\n+  unsigned struct_ipx_config_data_sz = sizeof(struct ipx_config_data);\n+  unsigned struct_kbdiacrs_sz = sizeof(struct kbdiacrs);\n+  unsigned struct_kbentry_sz = sizeof(struct kbentry);\n+  unsigned struct_kbkeycode_sz = sizeof(struct kbkeycode);\n+  unsigned struct_kbsentry_sz = sizeof(struct kbsentry);\n+  unsigned struct_mtconfiginfo_sz = sizeof(struct mtconfiginfo);\n+  unsigned struct_nr_parms_struct_sz = sizeof(struct nr_parms_struct);\n+  unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n+  unsigned struct_scc_modem_sz = sizeof(struct scc_modem);\n+  unsigned struct_scc_stat_sz = sizeof(struct scc_stat);\n+  unsigned struct_serial_multiport_struct_sz\n+      = sizeof(struct serial_multiport_struct);\n+  unsigned struct_serial_struct_sz = sizeof(struct serial_struct);\n+  unsigned struct_sockaddr_ax25_sz = sizeof(struct sockaddr_ax25);\n+  unsigned struct_unimapdesc_sz = sizeof(struct unimapdesc);\n+  unsigned struct_unimapinit_sz = sizeof(struct unimapinit);\n+#endif\n+\n+#if !SANITIZER_ANDROID\n+  unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n+  unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n+#endif\n+\n+  unsigned IOCTL_NOT_PRESENT = 0;\n+\n+  unsigned IOCTL_FIOASYNC = FIOASYNC;\n+  unsigned IOCTL_FIOCLEX = FIOCLEX;\n+  unsigned IOCTL_FIOGETOWN = FIOGETOWN;\n+  unsigned IOCTL_FIONBIO = FIONBIO;\n+  unsigned IOCTL_FIONCLEX = FIONCLEX;\n+  unsigned IOCTL_FIOSETOWN = FIOSETOWN;\n+  unsigned IOCTL_SIOCADDMULTI = SIOCADDMULTI;\n+  unsigned IOCTL_SIOCATMARK = SIOCATMARK;\n+  unsigned IOCTL_SIOCDELMULTI = SIOCDELMULTI;\n+  unsigned IOCTL_SIOCGIFADDR = SIOCGIFADDR;\n+  unsigned IOCTL_SIOCGIFBRDADDR = SIOCGIFBRDADDR;\n+  unsigned IOCTL_SIOCGIFCONF = SIOCGIFCONF;\n+  unsigned IOCTL_SIOCGIFDSTADDR = SIOCGIFDSTADDR;\n+  unsigned IOCTL_SIOCGIFFLAGS = SIOCGIFFLAGS;\n+  unsigned IOCTL_SIOCGIFMETRIC = SIOCGIFMETRIC;\n+  unsigned IOCTL_SIOCGIFMTU = SIOCGIFMTU;\n+  unsigned IOCTL_SIOCGIFNETMASK = SIOCGIFNETMASK;\n+  unsigned IOCTL_SIOCGPGRP = SIOCGPGRP;\n+  unsigned IOCTL_SIOCSIFADDR = SIOCSIFADDR;\n+  unsigned IOCTL_SIOCSIFBRDADDR = SIOCSIFBRDADDR;\n+  unsigned IOCTL_SIOCSIFDSTADDR = SIOCSIFDSTADDR;\n+  unsigned IOCTL_SIOCSIFFLAGS = SIOCSIFFLAGS;\n+  unsigned IOCTL_SIOCSIFMETRIC = SIOCSIFMETRIC;\n+  unsigned IOCTL_SIOCSIFMTU = SIOCSIFMTU;\n+  unsigned IOCTL_SIOCSIFNETMASK = SIOCSIFNETMASK;\n+  unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n+  unsigned IOCTL_TIOCCONS = TIOCCONS;\n+  unsigned IOCTL_TIOCEXCL = TIOCEXCL;\n+  unsigned IOCTL_TIOCGETD = TIOCGETD;\n+  unsigned IOCTL_TIOCGPGRP = TIOCGPGRP;\n+  unsigned IOCTL_TIOCGWINSZ = TIOCGWINSZ;\n+  unsigned IOCTL_TIOCMBIC = TIOCMBIC;\n+  unsigned IOCTL_TIOCMBIS = TIOCMBIS;\n+  unsigned IOCTL_TIOCMGET = TIOCMGET;\n+  unsigned IOCTL_TIOCMSET = TIOCMSET;\n+  unsigned IOCTL_TIOCNOTTY = TIOCNOTTY;\n+  unsigned IOCTL_TIOCNXCL = TIOCNXCL;\n+  unsigned IOCTL_TIOCOUTQ = TIOCOUTQ;\n+  unsigned IOCTL_TIOCPKT = TIOCPKT;\n+  unsigned IOCTL_TIOCSCTTY = TIOCSCTTY;\n+  unsigned IOCTL_TIOCSETD = TIOCSETD;\n+  unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n+  unsigned IOCTL_TIOCSTI = TIOCSTI;\n+  unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_MAC\n+  unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n+  unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n+#endif\n+#if SANITIZER_LINUX\n+  unsigned IOCTL_EVIOCGABS = EVIOCGABS(0);\n+  unsigned IOCTL_EVIOCGBIT = EVIOCGBIT(0, 0);\n+  unsigned IOCTL_EVIOCGEFFECTS = EVIOCGEFFECTS;\n+  unsigned IOCTL_EVIOCGID = EVIOCGID;\n+  unsigned IOCTL_EVIOCGKEY = EVIOCGKEY(0);\n+  unsigned IOCTL_EVIOCGKEYCODE = EVIOCGKEYCODE;\n+  unsigned IOCTL_EVIOCGLED = EVIOCGLED(0);\n+  unsigned IOCTL_EVIOCGNAME = EVIOCGNAME(0);\n+  unsigned IOCTL_EVIOCGPHYS = EVIOCGPHYS(0);\n+  unsigned IOCTL_EVIOCGRAB = EVIOCGRAB;\n+  unsigned IOCTL_EVIOCGREP = EVIOCGREP;\n+  unsigned IOCTL_EVIOCGSND = EVIOCGSND(0);\n+  unsigned IOCTL_EVIOCGSW = EVIOCGSW(0);\n+  unsigned IOCTL_EVIOCGUNIQ = EVIOCGUNIQ(0);\n+  unsigned IOCTL_EVIOCGVERSION = EVIOCGVERSION;\n+  unsigned IOCTL_EVIOCRMFF = EVIOCRMFF;\n+  unsigned IOCTL_EVIOCSABS = EVIOCSABS(0);\n+  unsigned IOCTL_EVIOCSFF = EVIOCSFF;\n+  unsigned IOCTL_EVIOCSKEYCODE = EVIOCSKEYCODE;\n+  unsigned IOCTL_EVIOCSREP = EVIOCSREP;\n+  unsigned IOCTL_BLKFLSBUF = BLKFLSBUF;\n+  unsigned IOCTL_BLKGETSIZE = BLKGETSIZE;\n+  unsigned IOCTL_BLKRAGET = BLKRAGET;\n+  unsigned IOCTL_BLKRASET = BLKRASET;\n+  unsigned IOCTL_BLKROGET = BLKROGET;\n+  unsigned IOCTL_BLKROSET = BLKROSET;\n+  unsigned IOCTL_BLKRRPART = BLKRRPART;\n+  unsigned IOCTL_CDROMAUDIOBUFSIZ = CDROMAUDIOBUFSIZ;\n+  unsigned IOCTL_CDROMEJECT = CDROMEJECT;\n+  unsigned IOCTL_CDROMEJECT_SW = CDROMEJECT_SW;\n+  unsigned IOCTL_CDROMMULTISESSION = CDROMMULTISESSION;\n+  unsigned IOCTL_CDROMPAUSE = CDROMPAUSE;\n+  unsigned IOCTL_CDROMPLAYMSF = CDROMPLAYMSF;\n+  unsigned IOCTL_CDROMPLAYTRKIND = CDROMPLAYTRKIND;\n+  unsigned IOCTL_CDROMREADAUDIO = CDROMREADAUDIO;\n+  unsigned IOCTL_CDROMREADCOOKED = CDROMREADCOOKED;\n+  unsigned IOCTL_CDROMREADMODE1 = CDROMREADMODE1;\n+  unsigned IOCTL_CDROMREADMODE2 = CDROMREADMODE2;\n+  unsigned IOCTL_CDROMREADRAW = CDROMREADRAW;\n+  unsigned IOCTL_CDROMREADTOCENTRY = CDROMREADTOCENTRY;\n+  unsigned IOCTL_CDROMREADTOCHDR = CDROMREADTOCHDR;\n+  unsigned IOCTL_CDROMRESET = CDROMRESET;\n+  unsigned IOCTL_CDROMRESUME = CDROMRESUME;\n+  unsigned IOCTL_CDROMSEEK = CDROMSEEK;\n+  unsigned IOCTL_CDROMSTART = CDROMSTART;\n+  unsigned IOCTL_CDROMSTOP = CDROMSTOP;\n+  unsigned IOCTL_CDROMSUBCHNL = CDROMSUBCHNL;\n+  unsigned IOCTL_CDROMVOLCTRL = CDROMVOLCTRL;\n+  unsigned IOCTL_CDROMVOLREAD = CDROMVOLREAD;\n+  unsigned IOCTL_CDROM_GET_UPC = CDROM_GET_UPC;\n+  unsigned IOCTL_FDCLRPRM = FDCLRPRM;\n+  unsigned IOCTL_FDDEFPRM = FDDEFPRM;\n+  unsigned IOCTL_FDFLUSH = FDFLUSH;\n+  unsigned IOCTL_FDFMTBEG = FDFMTBEG;\n+  unsigned IOCTL_FDFMTEND = FDFMTEND;\n+  unsigned IOCTL_FDFMTTRK = FDFMTTRK;\n+  unsigned IOCTL_FDGETDRVPRM = FDGETDRVPRM;\n+  unsigned IOCTL_FDGETDRVSTAT = FDGETDRVSTAT;\n+  unsigned IOCTL_FDGETDRVTYP = FDGETDRVTYP;\n+  unsigned IOCTL_FDGETFDCSTAT = FDGETFDCSTAT;\n+  unsigned IOCTL_FDGETMAXERRS = FDGETMAXERRS;\n+  unsigned IOCTL_FDGETPRM = FDGETPRM;\n+  unsigned IOCTL_FDMSGOFF = FDMSGOFF;\n+  unsigned IOCTL_FDMSGON = FDMSGON;\n+  unsigned IOCTL_FDPOLLDRVSTAT = FDPOLLDRVSTAT;\n+  unsigned IOCTL_FDRAWCMD = FDRAWCMD;\n+  unsigned IOCTL_FDRESET = FDRESET;\n+  unsigned IOCTL_FDSETDRVPRM = FDSETDRVPRM;\n+  unsigned IOCTL_FDSETEMSGTRESH = FDSETEMSGTRESH;\n+  unsigned IOCTL_FDSETMAXERRS = FDSETMAXERRS;\n+  unsigned IOCTL_FDSETPRM = FDSETPRM;\n+  unsigned IOCTL_FDTWADDLE = FDTWADDLE;\n+  unsigned IOCTL_FDWERRORCLR = FDWERRORCLR;\n+  unsigned IOCTL_FDWERRORGET = FDWERRORGET;\n+  unsigned IOCTL_HDIO_DRIVE_CMD = HDIO_DRIVE_CMD;\n+  unsigned IOCTL_HDIO_GETGEO = HDIO_GETGEO;\n+  unsigned IOCTL_HDIO_GET_32BIT = HDIO_GET_32BIT;\n+  unsigned IOCTL_HDIO_GET_DMA = HDIO_GET_DMA;\n+  unsigned IOCTL_HDIO_GET_IDENTITY = HDIO_GET_IDENTITY;\n+  unsigned IOCTL_HDIO_GET_KEEPSETTINGS = HDIO_GET_KEEPSETTINGS;\n+  unsigned IOCTL_HDIO_GET_MULTCOUNT = HDIO_GET_MULTCOUNT;\n+  unsigned IOCTL_HDIO_GET_NOWERR = HDIO_GET_NOWERR;\n+  unsigned IOCTL_HDIO_GET_UNMASKINTR = HDIO_GET_UNMASKINTR;\n+  unsigned IOCTL_HDIO_SET_32BIT = HDIO_SET_32BIT;\n+  unsigned IOCTL_HDIO_SET_DMA = HDIO_SET_DMA;\n+  unsigned IOCTL_HDIO_SET_KEEPSETTINGS = HDIO_SET_KEEPSETTINGS;\n+  unsigned IOCTL_HDIO_SET_MULTCOUNT = HDIO_SET_MULTCOUNT;\n+  unsigned IOCTL_HDIO_SET_NOWERR = HDIO_SET_NOWERR;\n+  unsigned IOCTL_HDIO_SET_UNMASKINTR = HDIO_SET_UNMASKINTR;\n+  unsigned IOCTL_MTIOCGET = MTIOCGET;\n+  unsigned IOCTL_MTIOCPOS = MTIOCPOS;\n+  unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n+  unsigned IOCTL_PPPIOCGASYNCMAP = PPPIOCGASYNCMAP;\n+  unsigned IOCTL_PPPIOCGDEBUG = PPPIOCGDEBUG;\n+  unsigned IOCTL_PPPIOCGFLAGS = PPPIOCGFLAGS;\n+  unsigned IOCTL_PPPIOCGUNIT = PPPIOCGUNIT;\n+  unsigned IOCTL_PPPIOCGXASYNCMAP = PPPIOCGXASYNCMAP;\n+  unsigned IOCTL_PPPIOCSASYNCMAP = PPPIOCSASYNCMAP;\n+  unsigned IOCTL_PPPIOCSDEBUG = PPPIOCSDEBUG;\n+  unsigned IOCTL_PPPIOCSFLAGS = PPPIOCSFLAGS;\n+  unsigned IOCTL_PPPIOCSMAXCID = PPPIOCSMAXCID;\n+  unsigned IOCTL_PPPIOCSMRU = PPPIOCSMRU;\n+  unsigned IOCTL_PPPIOCSXASYNCMAP = PPPIOCSXASYNCMAP;\n+  unsigned IOCTL_SIOCADDRT = SIOCADDRT;\n+  unsigned IOCTL_SIOCDARP = SIOCDARP;\n+  unsigned IOCTL_SIOCDELRT = SIOCDELRT;\n+  unsigned IOCTL_SIOCDRARP = SIOCDRARP;\n+  unsigned IOCTL_SIOCGARP = SIOCGARP;\n+  unsigned IOCTL_SIOCGIFENCAP = SIOCGIFENCAP;\n+  unsigned IOCTL_SIOCGIFHWADDR = SIOCGIFHWADDR;\n+  unsigned IOCTL_SIOCGIFMAP = SIOCGIFMAP;\n+  unsigned IOCTL_SIOCGIFMEM = SIOCGIFMEM;\n+  unsigned IOCTL_SIOCGIFNAME = SIOCGIFNAME;\n+  unsigned IOCTL_SIOCGIFSLAVE = SIOCGIFSLAVE;\n+  unsigned IOCTL_SIOCGRARP = SIOCGRARP;\n+  unsigned IOCTL_SIOCGSTAMP = SIOCGSTAMP;\n+  unsigned IOCTL_SIOCSARP = SIOCSARP;\n+  unsigned IOCTL_SIOCSIFENCAP = SIOCSIFENCAP;\n+  unsigned IOCTL_SIOCSIFHWADDR = SIOCSIFHWADDR;\n+  unsigned IOCTL_SIOCSIFLINK = SIOCSIFLINK;\n+  unsigned IOCTL_SIOCSIFMAP = SIOCSIFMAP;\n+  unsigned IOCTL_SIOCSIFMEM = SIOCSIFMEM;\n+  unsigned IOCTL_SIOCSIFSLAVE = SIOCSIFSLAVE;\n+  unsigned IOCTL_SIOCSRARP = SIOCSRARP;\n+#if SOUND_VERSION >= 0x040000\n+  unsigned IOCTL_SNDCTL_COPR_HALT = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_LOAD = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_RCODE = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_RCVMSG = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_RDATA = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_RESET = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_RUN = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_SENDMSG = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_WCODE = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SNDCTL_COPR_WDATA = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SOUND_PCM_READ_BITS = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SOUND_PCM_READ_CHANNELS = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SOUND_PCM_READ_FILTER = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SOUND_PCM_READ_RATE = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_SOUND_PCM_WRITE_FILTER = IOCTL_NOT_PRESENT;\n+#else\n+  unsigned IOCTL_SNDCTL_COPR_HALT = SNDCTL_COPR_HALT;\n+  unsigned IOCTL_SNDCTL_COPR_LOAD = SNDCTL_COPR_LOAD;\n+  unsigned IOCTL_SNDCTL_COPR_RCODE = SNDCTL_COPR_RCODE;\n+  unsigned IOCTL_SNDCTL_COPR_RCVMSG = SNDCTL_COPR_RCVMSG;\n+  unsigned IOCTL_SNDCTL_COPR_RDATA = SNDCTL_COPR_RDATA;\n+  unsigned IOCTL_SNDCTL_COPR_RESET = SNDCTL_COPR_RESET;\n+  unsigned IOCTL_SNDCTL_COPR_RUN = SNDCTL_COPR_RUN;\n+  unsigned IOCTL_SNDCTL_COPR_SENDMSG = SNDCTL_COPR_SENDMSG;\n+  unsigned IOCTL_SNDCTL_COPR_WCODE = SNDCTL_COPR_WCODE;\n+  unsigned IOCTL_SNDCTL_COPR_WDATA = SNDCTL_COPR_WDATA;\n+  unsigned IOCTL_SOUND_PCM_READ_BITS = SOUND_PCM_READ_BITS;\n+  unsigned IOCTL_SOUND_PCM_READ_CHANNELS = SOUND_PCM_READ_CHANNELS;\n+  unsigned IOCTL_SOUND_PCM_READ_FILTER = SOUND_PCM_READ_FILTER;\n+  unsigned IOCTL_SOUND_PCM_READ_RATE = SOUND_PCM_READ_RATE;\n+  unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS = SOUND_PCM_WRITE_CHANNELS;\n+  unsigned IOCTL_SOUND_PCM_WRITE_FILTER = SOUND_PCM_WRITE_FILTER;\n+#endif\n+  unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n+  unsigned IOCTL_SNDCTL_DSP_GETFMTS = SNDCTL_DSP_GETFMTS;\n+  unsigned IOCTL_SNDCTL_DSP_NONBLOCK = SNDCTL_DSP_NONBLOCK;\n+  unsigned IOCTL_SNDCTL_DSP_POST = SNDCTL_DSP_POST;\n+  unsigned IOCTL_SNDCTL_DSP_RESET = SNDCTL_DSP_RESET;\n+  unsigned IOCTL_SNDCTL_DSP_SETFMT = SNDCTL_DSP_SETFMT;\n+  unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT = SNDCTL_DSP_SETFRAGMENT;\n+  unsigned IOCTL_SNDCTL_DSP_SPEED = SNDCTL_DSP_SPEED;\n+  unsigned IOCTL_SNDCTL_DSP_STEREO = SNDCTL_DSP_STEREO;\n+  unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE = SNDCTL_DSP_SUBDIVIDE;\n+  unsigned IOCTL_SNDCTL_DSP_SYNC = SNDCTL_DSP_SYNC;\n+  unsigned IOCTL_SNDCTL_FM_4OP_ENABLE = SNDCTL_FM_4OP_ENABLE;\n+  unsigned IOCTL_SNDCTL_FM_LOAD_INSTR = SNDCTL_FM_LOAD_INSTR;\n+  unsigned IOCTL_SNDCTL_MIDI_INFO = SNDCTL_MIDI_INFO;\n+  unsigned IOCTL_SNDCTL_MIDI_PRETIME = SNDCTL_MIDI_PRETIME;\n+  unsigned IOCTL_SNDCTL_SEQ_CTRLRATE = SNDCTL_SEQ_CTRLRATE;\n+  unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT = SNDCTL_SEQ_GETINCOUNT;\n+  unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT = SNDCTL_SEQ_GETOUTCOUNT;\n+  unsigned IOCTL_SNDCTL_SEQ_NRMIDIS = SNDCTL_SEQ_NRMIDIS;\n+  unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS = SNDCTL_SEQ_NRSYNTHS;\n+  unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND = SNDCTL_SEQ_OUTOFBAND;\n+  unsigned IOCTL_SNDCTL_SEQ_PANIC = SNDCTL_SEQ_PANIC;\n+  unsigned IOCTL_SNDCTL_SEQ_PERCMODE = SNDCTL_SEQ_PERCMODE;\n+  unsigned IOCTL_SNDCTL_SEQ_RESET = SNDCTL_SEQ_RESET;\n+  unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES = SNDCTL_SEQ_RESETSAMPLES;\n+  unsigned IOCTL_SNDCTL_SEQ_SYNC = SNDCTL_SEQ_SYNC;\n+  unsigned IOCTL_SNDCTL_SEQ_TESTMIDI = SNDCTL_SEQ_TESTMIDI;\n+  unsigned IOCTL_SNDCTL_SEQ_THRESHOLD = SNDCTL_SEQ_THRESHOLD;\n+  unsigned IOCTL_SNDCTL_SYNTH_INFO = SNDCTL_SYNTH_INFO;\n+  unsigned IOCTL_SNDCTL_SYNTH_MEMAVL = SNDCTL_SYNTH_MEMAVL;\n+  unsigned IOCTL_SNDCTL_TMR_CONTINUE = SNDCTL_TMR_CONTINUE;\n+  unsigned IOCTL_SNDCTL_TMR_METRONOME = SNDCTL_TMR_METRONOME;\n+  unsigned IOCTL_SNDCTL_TMR_SELECT = SNDCTL_TMR_SELECT;\n+  unsigned IOCTL_SNDCTL_TMR_SOURCE = SNDCTL_TMR_SOURCE;\n+  unsigned IOCTL_SNDCTL_TMR_START = SNDCTL_TMR_START;\n+  unsigned IOCTL_SNDCTL_TMR_STOP = SNDCTL_TMR_STOP;\n+  unsigned IOCTL_SNDCTL_TMR_TEMPO = SNDCTL_TMR_TEMPO;\n+  unsigned IOCTL_SNDCTL_TMR_TIMEBASE = SNDCTL_TMR_TIMEBASE;\n+  unsigned IOCTL_SOUND_MIXER_READ_ALTPCM = SOUND_MIXER_READ_ALTPCM;\n+  unsigned IOCTL_SOUND_MIXER_READ_BASS = SOUND_MIXER_READ_BASS;\n+  unsigned IOCTL_SOUND_MIXER_READ_CAPS = SOUND_MIXER_READ_CAPS;\n+  unsigned IOCTL_SOUND_MIXER_READ_CD = SOUND_MIXER_READ_CD;\n+  unsigned IOCTL_SOUND_MIXER_READ_DEVMASK = SOUND_MIXER_READ_DEVMASK;\n+  unsigned IOCTL_SOUND_MIXER_READ_ENHANCE = SOUND_MIXER_READ_ENHANCE;\n+  unsigned IOCTL_SOUND_MIXER_READ_IGAIN = SOUND_MIXER_READ_IGAIN;\n+  unsigned IOCTL_SOUND_MIXER_READ_IMIX = SOUND_MIXER_READ_IMIX;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE = SOUND_MIXER_READ_LINE;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE1 = SOUND_MIXER_READ_LINE1;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE2 = SOUND_MIXER_READ_LINE2;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE3 = SOUND_MIXER_READ_LINE3;\n+  unsigned IOCTL_SOUND_MIXER_READ_LOUD = SOUND_MIXER_READ_LOUD;\n+  unsigned IOCTL_SOUND_MIXER_READ_MIC = SOUND_MIXER_READ_MIC;\n+  unsigned IOCTL_SOUND_MIXER_READ_MUTE = SOUND_MIXER_READ_MUTE;\n+  unsigned IOCTL_SOUND_MIXER_READ_OGAIN = SOUND_MIXER_READ_OGAIN;\n+  unsigned IOCTL_SOUND_MIXER_READ_PCM = SOUND_MIXER_READ_PCM;\n+  unsigned IOCTL_SOUND_MIXER_READ_RECLEV = SOUND_MIXER_READ_RECLEV;\n+  unsigned IOCTL_SOUND_MIXER_READ_RECMASK = SOUND_MIXER_READ_RECMASK;\n+  unsigned IOCTL_SOUND_MIXER_READ_RECSRC = SOUND_MIXER_READ_RECSRC;\n+  unsigned IOCTL_SOUND_MIXER_READ_SPEAKER = SOUND_MIXER_READ_SPEAKER;\n+  unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS = SOUND_MIXER_READ_STEREODEVS;\n+  unsigned IOCTL_SOUND_MIXER_READ_SYNTH = SOUND_MIXER_READ_SYNTH;\n+  unsigned IOCTL_SOUND_MIXER_READ_TREBLE = SOUND_MIXER_READ_TREBLE;\n+  unsigned IOCTL_SOUND_MIXER_READ_VOLUME = SOUND_MIXER_READ_VOLUME;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM = SOUND_MIXER_WRITE_ALTPCM;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_BASS = SOUND_MIXER_WRITE_BASS;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_CD = SOUND_MIXER_WRITE_CD;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE = SOUND_MIXER_WRITE_ENHANCE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN = SOUND_MIXER_WRITE_IGAIN;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_IMIX = SOUND_MIXER_WRITE_IMIX;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE = SOUND_MIXER_WRITE_LINE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE1 = SOUND_MIXER_WRITE_LINE1;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE2 = SOUND_MIXER_WRITE_LINE2;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE3 = SOUND_MIXER_WRITE_LINE3;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LOUD = SOUND_MIXER_WRITE_LOUD;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_MIC = SOUND_MIXER_WRITE_MIC;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_MUTE = SOUND_MIXER_WRITE_MUTE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN = SOUND_MIXER_WRITE_OGAIN;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_PCM = SOUND_MIXER_WRITE_PCM;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV = SOUND_MIXER_WRITE_RECLEV;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC = SOUND_MIXER_WRITE_RECSRC;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER = SOUND_MIXER_WRITE_SPEAKER;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH = SOUND_MIXER_WRITE_SYNTH;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE = SOUND_MIXER_WRITE_TREBLE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME = SOUND_MIXER_WRITE_VOLUME;\n+  unsigned IOCTL_TCFLSH = TCFLSH;\n+  unsigned IOCTL_TCGETA = TCGETA;\n+  unsigned IOCTL_TCGETS = TCGETS;\n+  unsigned IOCTL_TCSBRK = TCSBRK;\n+  unsigned IOCTL_TCSBRKP = TCSBRKP;\n+  unsigned IOCTL_TCSETA = TCSETA;\n+  unsigned IOCTL_TCSETAF = TCSETAF;\n+  unsigned IOCTL_TCSETAW = TCSETAW;\n+  unsigned IOCTL_TCSETS = TCSETS;\n+  unsigned IOCTL_TCSETSF = TCSETSF;\n+  unsigned IOCTL_TCSETSW = TCSETSW;\n+  unsigned IOCTL_TCXONC = TCXONC;\n+  unsigned IOCTL_TIOCGLCKTRMIOS = TIOCGLCKTRMIOS;\n+  unsigned IOCTL_TIOCGSOFTCAR = TIOCGSOFTCAR;\n+  unsigned IOCTL_TIOCINQ = TIOCINQ;\n+  unsigned IOCTL_TIOCLINUX = TIOCLINUX;\n+  unsigned IOCTL_TIOCSERCONFIG = TIOCSERCONFIG;\n+  unsigned IOCTL_TIOCSERGETLSR = TIOCSERGETLSR;\n+  unsigned IOCTL_TIOCSERGWILD = TIOCSERGWILD;\n+  unsigned IOCTL_TIOCSERSWILD = TIOCSERSWILD;\n+  unsigned IOCTL_TIOCSLCKTRMIOS = TIOCSLCKTRMIOS;\n+  unsigned IOCTL_TIOCSSOFTCAR = TIOCSSOFTCAR;\n+  unsigned IOCTL_VT_ACTIVATE = VT_ACTIVATE;\n+  unsigned IOCTL_VT_DISALLOCATE = VT_DISALLOCATE;\n+  unsigned IOCTL_VT_GETMODE = VT_GETMODE;\n+  unsigned IOCTL_VT_GETSTATE = VT_GETSTATE;\n+  unsigned IOCTL_VT_OPENQRY = VT_OPENQRY;\n+  unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n+  unsigned IOCTL_VT_RESIZE = VT_RESIZE;\n+  unsigned IOCTL_VT_RESIZEX = VT_RESIZEX;\n+  unsigned IOCTL_VT_SENDSIG = VT_SENDSIG;\n+  unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n+  unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n+#endif\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  unsigned IOCTL_CYGETDEFTHRESH = CYGETDEFTHRESH;\n+  unsigned IOCTL_CYGETDEFTIMEOUT = CYGETDEFTIMEOUT;\n+  unsigned IOCTL_CYGETMON = CYGETMON;\n+  unsigned IOCTL_CYGETTHRESH = CYGETTHRESH;\n+  unsigned IOCTL_CYGETTIMEOUT = CYGETTIMEOUT;\n+  unsigned IOCTL_CYSETDEFTHRESH = CYSETDEFTHRESH;\n+  unsigned IOCTL_CYSETDEFTIMEOUT = CYSETDEFTIMEOUT;\n+  unsigned IOCTL_CYSETTHRESH = CYSETTHRESH;\n+  unsigned IOCTL_CYSETTIMEOUT = CYSETTIMEOUT;\n+  unsigned IOCTL_EQL_EMANCIPATE = EQL_EMANCIPATE;\n+  unsigned IOCTL_EQL_ENSLAVE = EQL_ENSLAVE;\n+  unsigned IOCTL_EQL_GETMASTRCFG = EQL_GETMASTRCFG;\n+  unsigned IOCTL_EQL_GETSLAVECFG = EQL_GETSLAVECFG;\n+  unsigned IOCTL_EQL_SETMASTRCFG = EQL_SETMASTRCFG;\n+  unsigned IOCTL_EQL_SETSLAVECFG = EQL_SETSLAVECFG;\n+#if EV_VERSION > (0x010000)\n+  unsigned IOCTL_EVIOCGKEYCODE_V2 = EVIOCGKEYCODE_V2;\n+  unsigned IOCTL_EVIOCGPROP = EVIOCGPROP(0);\n+  unsigned IOCTL_EVIOCSKEYCODE_V2 = EVIOCSKEYCODE_V2;\n+#else\n+  unsigned IOCTL_EVIOCGKEYCODE_V2 = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_EVIOCGPROP = IOCTL_NOT_PRESENT;\n+  unsigned IOCTL_EVIOCSKEYCODE_V2 = IOCTL_NOT_PRESENT;\n+#endif\n+  unsigned IOCTL_FS_IOC_GETFLAGS = FS_IOC_GETFLAGS;\n+  unsigned IOCTL_FS_IOC_GETVERSION = FS_IOC_GETVERSION;\n+  unsigned IOCTL_FS_IOC_SETFLAGS = FS_IOC_SETFLAGS;\n+  unsigned IOCTL_FS_IOC_SETVERSION = FS_IOC_SETVERSION;\n+  unsigned IOCTL_GIO_CMAP = GIO_CMAP;\n+  unsigned IOCTL_GIO_FONT = GIO_FONT;\n+  unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n+  unsigned IOCTL_GIO_UNIMAP = GIO_UNIMAP;\n+  unsigned IOCTL_GIO_UNISCRNMAP = GIO_UNISCRNMAP;\n+  unsigned IOCTL_KDADDIO = KDADDIO;\n+  unsigned IOCTL_KDDELIO = KDDELIO;\n+  unsigned IOCTL_KDDISABIO = KDDISABIO;\n+  unsigned IOCTL_KDENABIO = KDENABIO;\n+  unsigned IOCTL_KDGETKEYCODE = KDGETKEYCODE;\n+  unsigned IOCTL_KDGETLED = KDGETLED;\n+  unsigned IOCTL_KDGETMODE = KDGETMODE;\n+  unsigned IOCTL_KDGKBDIACR = KDGKBDIACR;\n+  unsigned IOCTL_KDGKBENT = KDGKBENT;\n+  unsigned IOCTL_KDGKBLED = KDGKBLED;\n+  unsigned IOCTL_KDGKBMETA = KDGKBMETA;\n+  unsigned IOCTL_KDGKBMODE = KDGKBMODE;\n+  unsigned IOCTL_KDGKBSENT = KDGKBSENT;\n+  unsigned IOCTL_KDGKBTYPE = KDGKBTYPE;\n+  unsigned IOCTL_KDMAPDISP = KDMAPDISP;\n+  unsigned IOCTL_KDMKTONE = KDMKTONE;\n+  unsigned IOCTL_KDSETKEYCODE = KDSETKEYCODE;\n+  unsigned IOCTL_KDSETLED = KDSETLED;\n+  unsigned IOCTL_KDSETMODE = KDSETMODE;\n+  unsigned IOCTL_KDSIGACCEPT = KDSIGACCEPT;\n+  unsigned IOCTL_KDSKBDIACR = KDSKBDIACR;\n+  unsigned IOCTL_KDSKBENT = KDSKBENT;\n+  unsigned IOCTL_KDSKBLED = KDSKBLED;\n+  unsigned IOCTL_KDSKBMETA = KDSKBMETA;\n+  unsigned IOCTL_KDSKBMODE = KDSKBMODE;\n+  unsigned IOCTL_KDSKBSENT = KDSKBSENT;\n+  unsigned IOCTL_KDUNMAPDISP = KDUNMAPDISP;\n+  unsigned IOCTL_KIOCSOUND = KIOCSOUND;\n+  unsigned IOCTL_LPABORT = LPABORT;\n+  unsigned IOCTL_LPABORTOPEN = LPABORTOPEN;\n+  unsigned IOCTL_LPCAREFUL = LPCAREFUL;\n+  unsigned IOCTL_LPCHAR = LPCHAR;\n+  unsigned IOCTL_LPGETIRQ = LPGETIRQ;\n+  unsigned IOCTL_LPGETSTATUS = LPGETSTATUS;\n+  unsigned IOCTL_LPRESET = LPRESET;\n+  unsigned IOCTL_LPSETIRQ = LPSETIRQ;\n+  unsigned IOCTL_LPTIME = LPTIME;\n+  unsigned IOCTL_LPWAIT = LPWAIT;\n+  unsigned IOCTL_MTIOCGETCONFIG = MTIOCGETCONFIG;\n+  unsigned IOCTL_MTIOCSETCONFIG = MTIOCSETCONFIG;\n+  unsigned IOCTL_PIO_CMAP = PIO_CMAP;\n+  unsigned IOCTL_PIO_FONT = PIO_FONT;\n+  unsigned IOCTL_PIO_SCRNMAP = PIO_SCRNMAP;\n+  unsigned IOCTL_PIO_UNIMAP = PIO_UNIMAP;\n+  unsigned IOCTL_PIO_UNIMAPCLR = PIO_UNIMAPCLR;\n+  unsigned IOCTL_PIO_UNISCRNMAP = PIO_UNISCRNMAP;\n+  unsigned IOCTL_SCSI_IOCTL_GET_IDLUN = SCSI_IOCTL_GET_IDLUN;\n+  unsigned IOCTL_SCSI_IOCTL_PROBE_HOST = SCSI_IOCTL_PROBE_HOST;\n+  unsigned IOCTL_SCSI_IOCTL_TAGGED_DISABLE = SCSI_IOCTL_TAGGED_DISABLE;\n+  unsigned IOCTL_SCSI_IOCTL_TAGGED_ENABLE = SCSI_IOCTL_TAGGED_ENABLE;\n+  unsigned IOCTL_SIOCAIPXITFCRT = SIOCAIPXITFCRT;\n+  unsigned IOCTL_SIOCAIPXPRISLT = SIOCAIPXPRISLT;\n+  unsigned IOCTL_SIOCAX25ADDUID = SIOCAX25ADDUID;\n+  unsigned IOCTL_SIOCAX25DELUID = SIOCAX25DELUID;\n+  unsigned IOCTL_SIOCAX25GETPARMS = SIOCAX25GETPARMS;\n+  unsigned IOCTL_SIOCAX25GETUID = SIOCAX25GETUID;\n+  unsigned IOCTL_SIOCAX25NOUID = SIOCAX25NOUID;\n+  unsigned IOCTL_SIOCAX25SETPARMS = SIOCAX25SETPARMS;\n+  unsigned IOCTL_SIOCDEVPLIP = SIOCDEVPLIP;\n+  unsigned IOCTL_SIOCIPXCFGDATA = SIOCIPXCFGDATA;\n+  unsigned IOCTL_SIOCNRDECOBS = SIOCNRDECOBS;\n+  unsigned IOCTL_SIOCNRGETPARMS = SIOCNRGETPARMS;\n+  unsigned IOCTL_SIOCNRRTCTL = SIOCNRRTCTL;\n+  unsigned IOCTL_SIOCNRSETPARMS = SIOCNRSETPARMS;\n+  unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n+  unsigned IOCTL_SNDCTL_DSP_GETOSPACE = SNDCTL_DSP_GETOSPACE;\n+  unsigned IOCTL_TIOCGSERIAL = TIOCGSERIAL;\n+  unsigned IOCTL_TIOCSERGETMULTI = TIOCSERGETMULTI;\n+  unsigned IOCTL_TIOCSERSETMULTI = TIOCSERSETMULTI;\n+  unsigned IOCTL_TIOCSSERIAL = TIOCSSERIAL;\n+#endif\n }  // namespace __sanitizer\n \n-#endif  // __linux__ || __APPLE__\n+#define CHECK_TYPE_SIZE(TYPE) \\\n+  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n+\n+#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n+  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *) NULL)->MEMBER) == \\\n+                 sizeof(((CLASS *) NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==          \\\n+                 offsetof(CLASS, MEMBER))\n+\n+// For sigaction, which is a function and struct at the same time,\n+// and thus requires explicit \"struct\" in sizeof() expression.\n+#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n+  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *) NULL)->MEMBER) == \\\n+                 sizeof(((struct CLASS *) NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n+                 offsetof(struct CLASS, MEMBER))\n+\n+COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n+\n+COMPILER_CHECK(sizeof(socklen_t) == sizeof(unsigned));\n+CHECK_TYPE_SIZE(pthread_key_t);\n+\n+#if SANITIZER_LINUX\n+// There are more undocumented fields in dl_phdr_info that we are not interested\n+// in.\n+COMPILER_CHECK(sizeof(__sanitizer_dl_phdr_info) <= sizeof(dl_phdr_info));\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_addr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_name);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n+\n+COMPILER_CHECK(IOC_SIZE(0x12345678) == _IOC_SIZE(0x12345678));\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+CHECK_TYPE_SIZE(glob_t);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathc);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathv);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_offs);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_flags);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_closedir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_readdir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_opendir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_lstat);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_stat);\n+#endif\n+\n+CHECK_TYPE_SIZE(addrinfo);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_flags);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_family);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_socktype);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_protocol);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_protocol);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addrlen);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_canonname);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addr);\n+\n+CHECK_TYPE_SIZE(hostent);\n+CHECK_SIZE_AND_OFFSET(hostent, h_name);\n+CHECK_SIZE_AND_OFFSET(hostent, h_aliases);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addrtype);\n+CHECK_SIZE_AND_OFFSET(hostent, h_length);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addr_list);\n+\n+CHECK_TYPE_SIZE(iovec);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_base);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_len);\n+\n+CHECK_TYPE_SIZE(msghdr);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_name);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_namelen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iov);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iovlen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_control);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_controllen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_flags);\n+\n+CHECK_TYPE_SIZE(cmsghdr);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_len);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_level);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_type);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_dirent) <= sizeof(dirent));\n+CHECK_SIZE_AND_OFFSET(dirent, d_ino);\n+#if SANITIZER_MAC\n+CHECK_SIZE_AND_OFFSET(dirent, d_seekoff);\n+#else\n+CHECK_SIZE_AND_OFFSET(dirent, d_off);\n+#endif\n+CHECK_SIZE_AND_OFFSET(dirent, d_reclen);\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+COMPILER_CHECK(sizeof(__sanitizer_dirent64) <= sizeof(dirent64));\n+CHECK_SIZE_AND_OFFSET(dirent64, d_ino);\n+CHECK_SIZE_AND_OFFSET(dirent64, d_off);\n+CHECK_SIZE_AND_OFFSET(dirent64, d_reclen);\n+#endif\n+\n+CHECK_TYPE_SIZE(ifconf);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_len);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_ifcu);\n+\n+CHECK_TYPE_SIZE(pollfd);\n+CHECK_SIZE_AND_OFFSET(pollfd, fd);\n+CHECK_SIZE_AND_OFFSET(pollfd, events);\n+CHECK_SIZE_AND_OFFSET(pollfd, revents);\n+\n+CHECK_TYPE_SIZE(nfds_t);\n+\n+CHECK_TYPE_SIZE(sigset_t);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_sigaction) == sizeof(struct sigaction));\n+// Can't write checks for sa_handler and sa_sigaction due to them being\n+// preprocessor macros.\n+CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_mask);\n+CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_flags);\n+#if SANITIZER_LINUX\n+CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_restorer);\n+#endif\n+\n+#if SANITIZER_LINUX\n+CHECK_TYPE_SIZE(__sysctl_args);\n+CHECK_SIZE_AND_OFFSET(__sysctl_args, name);\n+CHECK_SIZE_AND_OFFSET(__sysctl_args, nlen);\n+CHECK_SIZE_AND_OFFSET(__sysctl_args, oldval);\n+CHECK_SIZE_AND_OFFSET(__sysctl_args, oldlenp);\n+CHECK_SIZE_AND_OFFSET(__sysctl_args, newval);\n+CHECK_SIZE_AND_OFFSET(__sysctl_args, newlen);\n+\n+CHECK_TYPE_SIZE(__kernel_uid_t);\n+CHECK_TYPE_SIZE(__kernel_gid_t);\n+CHECK_TYPE_SIZE(__kernel_old_uid_t);\n+CHECK_TYPE_SIZE(__kernel_old_gid_t);\n+CHECK_TYPE_SIZE(__kernel_off_t);\n+CHECK_TYPE_SIZE(__kernel_loff_t);\n+CHECK_TYPE_SIZE(__kernel_fd_set);\n+#endif\n+\n+#if !SANITIZER_ANDROID\n+CHECK_TYPE_SIZE(wordexp_t);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordc);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordv);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_offs);\n+#endif\n+\n+#endif  // SANITIZER_LINUX || SANITIZER_MAC"}, {"sha": "007b4ec7b96dd15d76ba12a8fc3811a2b39d0910", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "6d999e919613502f150ec92b562e3ff012e8f538", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 115, "deletions": 96, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "3d4f92db581de1d240f3de8d9e419afb2df166fa", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "d7ce9736b247e28b041d37d2f0bd1cf2e371b809", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 123, "deletions": 52, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "87887f6b74b1257d4bf8029b8890ba7e33ec2dae", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "7f567f97d7c5f58c7c135befb8690d9242e79f72", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "c6e79ad0c7c546124df5fa7416e68c166af73f9e", "filename": "libsanitizer/sanitizer_common/sanitizer_report_decorator.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "e8d9f01e7f931a276f19d048f82963d27dd9e090", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "c2c04ef9d64b6e87d3344badc9bf0ac633087433", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "4e7972424dc25bf8a355d98346712f77e0cc401b", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "1f05753d20777ab49d09f12ba12a6e7c45c45b51", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "b1241da1f73fca6780d527a593c3756a310ba17c", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "4f44a0369821b3cd3024aeb36b965cba01d2a29f", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "d8e8976a4b2f553cef8c51801826616dadc4e673", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "9a0d87b383e8c170531a1315bc3c1379c7d420fd", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "2c84773eebc1b198d67d8012212dba363c020987", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 38, "deletions": 44, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "b356f9a09e30cb425ebe499f0d5012071ec96116", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_itanium.cc", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_itanium.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_itanium.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_itanium.cc?ref=fd5564d3c71195714c28ba150de7e9b90bf9c83d"}, {"sha": "01f1e4588da706f9c6f47d410ac48d0e0886b352", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_linux.cc", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc?ref=fd5564d3c71195714c28ba150de7e9b90bf9c83d"}, {"sha": "a1b931b737e2f78b7b71b7dd63a559bc64e67710", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cc", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5564d3c71195714c28ba150de7e9b90bf9c83d/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc?ref=fd5564d3c71195714c28ba150de7e9b90bf9c83d"}, {"sha": "34063081c77c0f50459f48fa9f8e602b3b107e75", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "renamed", "additions": 237, "deletions": 50, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc"}, {"sha": "44801f39b313e1fe70f7c4248a66687c54d55993", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "6b2c915a3bc2719e62a9e32f725239a075eaeb10", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_generic.inc", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "4f405d92b052c27ecfe78afb55be231919ac7b6a", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_x86_64.inc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "e639430f73a15ed7fe0aa81afd4f6b9c254d5de3", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "1ae47b800caccc7c1223105c4ccb7c42f2859a17", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "0a5fe81ae454fa472700934bcfc174b8c83b4a09", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 157, "deletions": 27, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "68936e02e4b174ef61c9c477c11e538e38ca6a19", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "de852b185a6d6d45163722f5fff0bae77b23edd8", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "dbde4212c59de212b75267c4e7c17cd26eb06a28", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "a7571c92b5e0e6b31df6a5e7f518ef9a2ae91dcb", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "eaaf9e3ebf600279334f7874b17cfed757bde73d", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 382, "deletions": 196, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "e056bd465bf0c21f3514b09c54e013f121fe0a80", "filename": "libsanitizer/tsan/tsan_interface.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "63de7b2ab5c4eaca778523f6ed696964760bfe33", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "46d9e3ec1afa5b6ba146536d5603c4dcad757411", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 83, "deletions": 16, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "45c18352e698a5d0f013e0fe16fa5d5aba64d441", "filename": "libsanitizer/tsan/tsan_interface_ann.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "02ebb47e6af19456bf35f5b96027093f1602efa8", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "4d6e10bcf7b99f4cdac5355d426c08b6852fa59a", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "7cc725779773f8c4ffc2b0997f816ba1a31b6a6d", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "818c07b97d447bfe49700d2651a130359836a998", "filename": "libsanitizer/tsan/tsan_interface_java.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "832374becf5845b3504c03658674d61d148771f6", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 75, "deletions": 20, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "90faaffa1fca75f62e8813c48957b9c036af68f2", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "e7846c53e4af02b82d0f7f89b0cb8131fc19ffe4", "filename": "libsanitizer/tsan/tsan_mutex.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "ef60bd47db29f4d7f60292dae76b42297e08f567", "filename": "libsanitizer/tsan/tsan_mutexset.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutexset.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "ac36c5ab67a702a993ce134aa927bd271d130cc1", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "f13e3c893b39d826176d1a106604b21a97a5e5c7", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 106, "deletions": 73, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "3dca611dc928884e4b24e1be834ac1f149755954", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "6e49ef42f0c015b1220c660130023bed30e482f2", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "15ab22b4ba76b8067d0394ee102385ae36fcd7fd", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "c0eef9eb023b5fe3b880b82c80345e9761d594ce", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "7f18064e957d16a29f032c07cd16b260dff4bd74", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 201, "deletions": 123, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "2548f67b25c9555e2b831a6cba9d7d1ffac8eba1", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 126, "deletions": 70, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "d274a7a8cc504dcf9db0ea98d61639a71d6d370a", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "7c0a0280071e6ff5fb5128ae6d7dfea7857d3fbd", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 154, "deletions": 69, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "9811e1c015fc4408cd1eba4e7717136e8f62fe38", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 195, "deletions": 265, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "3a3ac1172d89cc8732379c72bf4386c797b455fd", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "e392ff62c63df3526a7bde03c62a88991d0a26bd", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "912b3834e87288e032207db5411f61c45103c4dc", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 87, "deletions": 96, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "e38d81ece85c7f19587ec24db9253a31b74f5926", "filename": "libsanitizer/tsan/tsan_suppressions.h", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "0c7efac7a268994c453bbfdda16ce94edb8fd82c", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "c610d1f54926e56805f66f99ae33945e012badda", "filename": "libsanitizer/tsan/tsan_symbolize.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "da0c87d297ed3d9872b0c9d3fcd565cfb867a984", "filename": "libsanitizer/tsan/tsan_symbolize_addr2line_linux.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "04fef615531742507e6ff2b8ca57b67c68afa4de", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "2867a8ac79ef568efec2d90eecb4fda36ba68338", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "42caf80d349edb30b261e6eee6e1d39114c26fce", "filename": "libsanitizer/tsan/tsan_update_shadow_word_inl.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "4da8b83d5c3ff191d114a8e7ad751aab336af1b0", "filename": "libsanitizer/tsan/tsan_vector.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Ftsan%2Ftsan_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_vector.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "c7378fdbda2ab3227fbc4e56b6e2d7b000950122", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}, {"sha": "9b31eb7defb59a5f6739916d72f35e32568d0ea3", "filename": "libsanitizer/ubsan/ubsan_value.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fubsan%2Fubsan_value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1b3fda32c08e9bd6977b96e1e619aae3e3726a/libsanitizer%2Fubsan%2Fubsan_value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.h?ref=ef1b3fda32c08e9bd6977b96e1e619aae3e3726a"}]}