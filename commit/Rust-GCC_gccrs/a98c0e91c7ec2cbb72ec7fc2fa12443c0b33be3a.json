{"sha": "a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk4YzBlOTFjN2VjMmNiYjcyZWM3ZmMyZmExMjQ0M2MwYjMzYmUzYQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mjw@redhat.com", "date": "2014-08-19T11:00:37Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2014-08-19T11:00:37Z"}, "message": "dwarf2out.c: Pass one cv_quals argument instead of two for const and volatile.\n\nmodified_type_die and add_type_attribute take two separate arguments\nfor whether the type should be const and/or volatile. To help add\nmore type modifiers pass the requested modifiers as one cv_quals argument\nto these functions. And introduce helper function decl_quals to extract\nadditional cv_quals from declaration trees.\n\nDWARFv3 added restrict_type [PR debug/59051] and DWARFv5 has proposals\nfor atomic_type and aligned_type. Which will be easier to implement based\non this change.\n\ngcc/ChangeLog\n\n\t* dwarf2out.c (decl_quals): New function.\n\t(modified_type_die): Take one cv_quals argument instead of two,\n\tone for const and one for volatile.\n\t(add_type_attribute): Likewise.\n\t(generic_parameter_die): Call add_type_attribute with one modifier\n\targument.\n\t(base_type_for_mode): Likewise.\n\t(add_bounds_info): Likewise.\n\t(add_subscript_info): Likewise.\n\t(gen_array_type_die): Likewise.\n\t(gen_descr_array_type_die): Likewise.\n\t(gen_entry_point_die): Likewise.\n\t(gen_enumeration_type_die): Likewise.\n\t(gen_formal_parameter_die): Likewise.\n\t(gen_subprogram_die): Likewise.\n\t(gen_variable_die): Likewise.\n\t(gen_const_die): Likewise.\n\t(gen_field_die): Likewise.\n\t(gen_pointer_type_die): Likewise.\n\t(gen_reference_type_die): Likewise.\n\t(gen_ptr_to_mbr_type_die): Likewise.\n\t(gen_inheritance_die): Likewise.\n\t(gen_subroutine_type_die): Likewise.\n\t(gen_typedef_die): Likewise.\n\t(force_type_die): Likewise.\n\nFrom-SVN: r214140", "tree": {"sha": "25a00394306de8c068bed101a93878ae6e3826db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25a00394306de8c068bed101a93878ae6e3826db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a/comments", "author": null, "committer": null, "parents": [{"sha": "a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5"}], "stats": {"total": 182, "additions": 115, "deletions": 67}, "files": [{"sha": "ccb3e5181e36e0e4e0605d548f18aac00d214c45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a", "patch": "@@ -1,3 +1,31 @@\n+2014-07-07  Mark Wielaard  <mjw@redhat.com>\n+\n+\t* dwarf2out.c (decl_quals): New function.\n+\t(modified_type_die): Take one cv_quals argument instead of two,\n+\tone for const and one for volatile.\n+\t(add_type_attribute): Likewise.\n+\t(generic_parameter_die): Call add_type_attribute with one modifier\n+\targument.\n+\t(base_type_for_mode): Likewise.\n+\t(add_bounds_info): Likewise.\n+\t(add_subscript_info): Likewise.\n+\t(gen_array_type_die): Likewise.\n+\t(gen_descr_array_type_die): Likewise.\n+\t(gen_entry_point_die): Likewise.\n+\t(gen_enumeration_type_die): Likewise.\n+\t(gen_formal_parameter_die): Likewise.\n+\t(gen_subprogram_die): Likewise.\n+\t(gen_variable_die): Likewise.\n+\t(gen_const_die): Likewise.\n+\t(gen_field_die): Likewise.\n+\t(gen_pointer_type_die): Likewise.\n+\t(gen_reference_type_die): Likewise.\n+\t(gen_ptr_to_mbr_type_die): Likewise.\n+\t(gen_inheritance_die): Likewise.\n+\t(gen_subroutine_type_die): Likewise.\n+\t(gen_typedef_die): Likewise.\n+\t(force_type_die): Likewise.\n+\n 2014-08-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (gcc_cv_as_comdat_group_group): Only default to no"}, {"sha": "79a1dc20b46baffa21b81124c9733cc7010953e7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 87, "deletions": 67, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a98c0e91c7ec2cbb72ec7fc2fa12443c0b33be3a", "patch": "@@ -3141,7 +3141,8 @@ static void output_file_names (void);\n static dw_die_ref base_type_die (tree);\n static int is_base_type (tree);\n static dw_die_ref subrange_type_die (tree, tree, tree, dw_die_ref);\n-static dw_die_ref modified_type_die (tree, int, int, dw_die_ref);\n+static int decl_quals (const_tree);\n+static dw_die_ref modified_type_die (tree, int, dw_die_ref);\n static dw_die_ref generic_parameter_die (tree, tree, bool, dw_die_ref);\n static dw_die_ref template_parameter_pack_die (tree, tree, dw_die_ref);\n static int type_is_enum (const_tree);\n@@ -3199,7 +3200,7 @@ static dw_die_ref scope_die_for (tree, dw_die_ref);\n static inline int local_scope_p (dw_die_ref);\n static inline int class_scope_p (dw_die_ref);\n static inline int class_or_namespace_scope_p (dw_die_ref);\n-static void add_type_attribute (dw_die_ref, tree, int, int, dw_die_ref);\n+static void add_type_attribute (dw_die_ref, tree, int, dw_die_ref);\n static void add_calling_convention_attribute (dw_die_ref, tree);\n static const char *type_tag (const_tree);\n static tree member_declared_type (const_tree);\n@@ -10446,12 +10447,24 @@ subrange_type_die (tree type, tree low, tree high, dw_die_ref context_die)\n   return subrange_die;\n }\n \n+/* Returns the (const and/or volatile) cv_qualifiers associated with\n+   the decl node.  This will normally be augmented with the\n+   cv_qualifiers of the underlying type in add_type_attribute.  */\n+\n+static int\n+decl_quals (const_tree decl)\n+{\n+  return ((TREE_READONLY (decl)\n+\t   ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED)\n+\t  | (TREE_THIS_VOLATILE (decl)\n+\t     ? TYPE_QUAL_VOLATILE : TYPE_UNQUALIFIED));\n+}\n+\n /* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging\n    entry that chains various modifiers in front of the given type.  */\n \n static dw_die_ref\n-modified_type_die (tree type, int is_const_type, int is_volatile_type,\n-\t\t   dw_die_ref context_die)\n+modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n {\n   enum tree_code code = TREE_CODE (type);\n   dw_die_ref mod_type_die;\n@@ -10464,12 +10477,12 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   if (code == ERROR_MARK)\n     return NULL;\n \n+  /* Only these cv-qualifiers are currently handled.  */\n+  cv_quals &= (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+\n   /* See if we already have the appropriately qualified variant of\n      this type.  */\n-  qualified_type\n-    = get_qualified_type (type,\n-\t\t\t  ((is_const_type ? TYPE_QUAL_CONST : 0)\n-\t\t\t   | (is_volatile_type ? TYPE_QUAL_VOLATILE : 0)));\n+  qualified_type = get_qualified_type (type, cv_quals);\n \n   if (qualified_type == sizetype\n       && TYPE_NAME (qualified_type)\n@@ -10507,35 +10520,38 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \t  gen_type_die (qualified_type, context_die);\n \t  return lookup_type_die (qualified_type);\n \t}\n-      else if (is_const_type < TYPE_READONLY (dtype)\n-\t       || is_volatile_type < TYPE_VOLATILE (dtype)\n-\t       || (is_const_type <= TYPE_READONLY (dtype)\n-\t\t   && is_volatile_type <= TYPE_VOLATILE (dtype)\n-\t\t   && DECL_ORIGINAL_TYPE (name) != type))\n-\t/* cv-unqualified version of named type.  Just use the unnamed\n-\t   type to which it refers.  */\n-\treturn modified_type_die (DECL_ORIGINAL_TYPE (name),\n-\t\t\t\t  is_const_type, is_volatile_type,\n-\t\t\t\t  context_die);\n-      /* Else cv-qualified version of named type; fall through.  */\n+      else\n+\t{\n+\t  int dquals = TYPE_QUALS_NO_ADDR_SPACE (dtype);\n+\t  dquals &= (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+\t  if ((dquals & ~cv_quals) != TYPE_UNQUALIFIED\n+\t      || (cv_quals == dquals && DECL_ORIGINAL_TYPE (name) != type))\n+\t    /* cv-unqualified version of named type.  Just use\n+\t       the unnamed type to which it refers.  */\n+\t    return modified_type_die (DECL_ORIGINAL_TYPE (name),\n+\t\t\t\t      cv_quals, context_die);\n+\t  /* Else cv-qualified version of named type; fall through.  */\n+\t}\n     }\n \n   mod_scope = scope_die_for (type, context_die);\n \n-  if (is_const_type\n-      /* If both is_const_type and is_volatile_type, prefer the path\n+  if ((cv_quals & TYPE_QUAL_CONST)\n+      /* If both const_type and volatile_type, prefer the path\n \t which leads to a qualified type.  */\n-      && (!is_volatile_type\n+      && (!(cv_quals & TYPE_QUAL_VOLATILE)\n \t  || get_qualified_type (type, TYPE_QUAL_CONST) == NULL_TREE\n \t  || get_qualified_type (type, TYPE_QUAL_VOLATILE) != NULL_TREE))\n     {\n       mod_type_die = new_die (DW_TAG_const_type, mod_scope, type);\n-      sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n+      sub_die = modified_type_die (type, cv_quals & ~TYPE_QUAL_CONST,\n+\t\t\t\t   context_die);\n     }\n-  else if (is_volatile_type)\n+  else if (cv_quals & TYPE_QUAL_VOLATILE)\n     {\n       mod_type_die = new_die (DW_TAG_volatile_type, mod_scope, type);\n-      sub_die = modified_type_die (type, is_const_type, 0, context_die);\n+      sub_die = modified_type_die (type, cv_quals & ~TYPE_QUAL_VOLATILE,\n+\t\t\t\t   context_die);\n     }\n   else if (code == POINTER_TYPE)\n     {\n@@ -10596,7 +10612,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   if (name\n       && ((TREE_CODE (name) != TYPE_DECL\n \t   && (qualified_type == TYPE_MAIN_VARIANT (type)\n-\t       || (!is_const_type && !is_volatile_type)))\n+\t       || (cv_quals == TYPE_UNQUALIFIED)))\n \t  || (TREE_CODE (name) == TYPE_DECL\n \t      && TREE_TYPE (name) == qualified_type\n \t      && DECL_NAME (name))))\n@@ -10625,8 +10641,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n        recursion will terminate even if the type is recursive.  Recursive\n        types are possible in Ada.  */\n     sub_die = modified_type_die (item_type,\n-\t\t\t\t TYPE_READONLY (item_type),\n-\t\t\t\t TYPE_VOLATILE (item_type),\n+\t\t\t\t TYPE_QUALS_NO_ADDR_SPACE (item_type),\n \t\t\t\t context_die);\n \n   if (sub_die != NULL)\n@@ -10768,8 +10783,9 @@ generic_parameter_die (tree parm, tree arg,\n \t     If PARM is a type generic parameter, TMPL_DIE should have a\n \t     child DW_AT_type that is set to ARG.  */\n \t  tmpl_type = TYPE_P (arg) ? arg : TREE_TYPE (arg);\n-\t  add_type_attribute (tmpl_die, tmpl_type, 0,\n-\t\t\t      TREE_THIS_VOLATILE (tmpl_type),\n+\t  add_type_attribute (tmpl_die, tmpl_type,\n+\t\t\t      (TREE_THIS_VOLATILE (tmpl_type)\n+\t\t\t       ? TYPE_QUAL_VOLATILE : TYPE_UNQUALIFIED),\n \t\t\t      parent_die);\n \t}\n       else\n@@ -11511,7 +11527,7 @@ base_type_for_mode (enum machine_mode mode, bool unsignedp)\n     }\n   type_die = lookup_type_die (type);\n   if (!type_die)\n-    type_die = modified_type_die (type, false, false, comp_unit_die ());\n+    type_die = modified_type_die (type, TYPE_UNQUALIFIED, comp_unit_die ());\n   if (type_die == NULL || type_die->die_tag != DW_TAG_base_type)\n     return NULL;\n   return type_die;\n@@ -16428,7 +16444,7 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \n \tdecl_die = new_die (DW_TAG_variable, ctx, bound);\n \tadd_AT_flag (decl_die, DW_AT_artificial, 1);\n-\tadd_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n+\tadd_type_attribute (decl_die, TREE_TYPE (bound), TYPE_QUAL_CONST, ctx);\n \tadd_AT_location_description (decl_die, DW_AT_location, list);\n \tadd_AT_die_ref (subrange_die, bound_attr, decl_die);\n \tbreak;\n@@ -16479,8 +16495,8 @@ add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n \t\t  && TYPE_NAME (TREE_TYPE (domain)) == NULL_TREE)\n \t\t;\n \t      else\n-\t\tadd_type_attribute (subrange_die, TREE_TYPE (domain), 0, 0,\n-\t\t\t\t    type_die);\n+\t\tadd_type_attribute (subrange_die, TREE_TYPE (domain),\n+\t\t\t\t    TYPE_UNQUALIFIED, type_die);\n \t    }\n \n \t  /* ??? If upper is NULL, the array has unspecified length,\n@@ -16971,11 +16987,12 @@ class_or_namespace_scope_p (dw_die_ref context_die)\n \n /* Many forms of DIEs require a \"type description\" attribute.  This\n    routine locates the proper \"type descriptor\" die for the type given\n-   by 'type', and adds a DW_AT_type attribute below the given die.  */\n+   by 'type' plus any additional qualifiers given by 'cv_quals', and\n+   adds a DW_AT_type attribute below the given die.  */\n \n static void\n-add_type_attribute (dw_die_ref object_die, tree type, int decl_const,\n-\t\t    int decl_volatile, dw_die_ref context_die)\n+add_type_attribute (dw_die_ref object_die, tree type, int cv_quals,\n+\t\t    dw_die_ref context_die)\n {\n   enum tree_code code  = TREE_CODE (type);\n   dw_die_ref type_die  = NULL;\n@@ -16996,8 +17013,7 @@ add_type_attribute (dw_die_ref object_die, tree type, int decl_const,\n     return;\n \n   type_die = modified_type_die (type,\n-\t\t\t\tdecl_const || TYPE_READONLY (type),\n-\t\t\t\tdecl_volatile || TYPE_VOLATILE (type),\n+\t\t\t\tcv_quals | TYPE_QUALS_NO_ADDR_SPACE (type),\n \t\t\t\tcontext_die);\n \n   if (type_die != NULL)\n@@ -17211,7 +17227,7 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \telement_type = TREE_TYPE (element_type);\n       }\n \n-  add_type_attribute (array_die, element_type, 0, 0, context_die);\n+  add_type_attribute (array_die, element_type, TYPE_UNQUALIFIED, context_die);\n \n   add_gnat_descriptive_type_attribute (array_die, type, context_die);\n   if (TYPE_ARTIFICIAL (type))\n@@ -17374,7 +17390,8 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n     }\n \n   gen_type_die (info->element_type, context_die);\n-  add_type_attribute (array_die, info->element_type, 0, 0, context_die);\n+  add_type_attribute (array_die, info->element_type, TYPE_UNQUALIFIED,\n+\t\t      context_die);\n \n   if (get_AT (array_die, DW_AT_name))\n     add_pubtype (type, array_die);\n@@ -17393,7 +17410,7 @@ gen_entry_point_die (tree decl, dw_die_ref context_die)\n     {\n       add_name_and_src_coords_attributes (decl_die, decl);\n       add_type_attribute (decl_die, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t  0, 0, context_die);\n+\t\t\t  TYPE_UNQUALIFIED, context_die);\n     }\n \n   if (DECL_ABSTRACT (decl))\n@@ -17483,7 +17500,8 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n       if (dwarf_version >= 3 || !dwarf_strict)\n \t{\n \t  tree underlying = lang_hooks.types.enum_underlying_base_type (type);\n-\t  add_type_attribute (type_die, underlying, 0, 0, context_die);\n+\t  add_type_attribute (type_die, underlying, TYPE_UNQUALIFIED,\n+\t\t\t      context_die);\n \t}\n       if (TYPE_STUB_DECL (type) != NULL_TREE)\n \t{\n@@ -17584,12 +17602,11 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n \t{\n \t  tree type = TREE_TYPE (node_or_origin);\n \t  if (decl_by_reference_p (node_or_origin))\n-\t    add_type_attribute (parm_die, TREE_TYPE (type), 0, 0,\n-\t\t\t\tcontext_die);\n+\t    add_type_attribute (parm_die, TREE_TYPE (type),\n+\t\t\t\tTYPE_UNQUALIFIED, context_die);\n \t  else\n \t    add_type_attribute (parm_die, type,\n-\t\t\t\tTREE_READONLY (node_or_origin),\n-\t\t\t\tTREE_THIS_VOLATILE (node_or_origin),\n+\t\t\t\tdecl_quals (node_or_origin),\n \t\t\t\tcontext_die);\n \t}\n       if (origin == NULL && DECL_ARTIFICIAL (node))\n@@ -17605,7 +17622,8 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n \n     case tcc_type:\n       /* We were called with some kind of a ..._TYPE node.  */\n-      add_type_attribute (parm_die, node_or_origin, 0, 0, context_die);\n+      add_type_attribute (parm_die, node_or_origin, TYPE_UNQUALIFIED,\n+\t\t\t  context_die);\n       break;\n \n     default:\n@@ -18187,7 +18205,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t      dw_die_ref die = get_AT_ref (old_die, DW_AT_type);\n \t      if (die == auto_die || die == decltype_auto_die)\n \t\tadd_type_attribute (subr_die, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t\t    0, 0, context_die);\n+\t\t\t\t    TYPE_UNQUALIFIED, context_die);\n \t    }\n \t}\n     }\n@@ -18204,7 +18222,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t{\n \t  add_prototyped_attribute (subr_die, TREE_TYPE (decl));\n \t  add_type_attribute (subr_die, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t      0, 0, context_die);\n+\t\t\t      TYPE_UNQUALIFIED, context_die);\n \t}\n \n       add_pure_or_virtual_attribute (subr_die, decl);\n@@ -18819,8 +18837,8 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t}\n       var_die = new_die (DW_TAG_variable, com_die, decl);\n       add_name_and_src_coords_attributes (var_die, decl);\n-      add_type_attribute (var_die, TREE_TYPE (decl), TREE_READONLY (decl),\n-\t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n+      add_type_attribute (var_die, TREE_TYPE (decl), decl_quals (decl),\n+\t\t\t  context_die);\n       add_AT_flag (var_die, DW_AT_external, 1);\n       if (loc)\n \t{\n@@ -18913,10 +18931,11 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n       tree type = TREE_TYPE (decl_or_origin);\n \n       if (decl_by_reference_p (decl_or_origin))\n-\tadd_type_attribute (var_die, TREE_TYPE (type), 0, 0, context_die);\n+\tadd_type_attribute (var_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+\t\t\t    context_die);\n       else\n-\tadd_type_attribute (var_die, type, TREE_READONLY (decl_or_origin),\n-\t\t\t    TREE_THIS_VOLATILE (decl_or_origin), context_die);\n+\tadd_type_attribute (var_die, type, decl_quals (decl_or_origin),\n+\t\t\t    context_die);\n     }\n \n   if (origin == NULL && !specialization_p)\n@@ -18970,7 +18989,7 @@ gen_const_die (tree decl, dw_die_ref context_die)\n \n   const_die = new_die (DW_TAG_constant, context_die, decl);\n   add_name_and_src_coords_attributes (const_die, decl);\n-  add_type_attribute (const_die, type, 1, 0, context_die);\n+  add_type_attribute (const_die, type, TYPE_QUAL_CONST, context_die);\n   if (TREE_PUBLIC (decl))\n     add_AT_flag (const_die, DW_AT_external, 1);\n   if (DECL_ARTIFICIAL (decl))\n@@ -19213,8 +19232,7 @@ gen_field_die (tree decl, dw_die_ref context_die)\n   decl_die = new_die (DW_TAG_member, context_die, decl);\n   add_name_and_src_coords_attributes (decl_die, decl);\n   add_type_attribute (decl_die, member_declared_type (decl),\n-\t\t      TREE_READONLY (decl), TREE_THIS_VOLATILE (decl),\n-\t\t      context_die);\n+\t\t      decl_quals (decl), context_die);\n \n   if (DECL_BIT_FIELD_TYPE (decl))\n     {\n@@ -19248,7 +19266,8 @@ gen_pointer_type_die (tree type, dw_die_ref context_die)\n     = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, ptr_die);\n-  add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);\n+  add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+\t\t      context_die);\n   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n }\n \n@@ -19268,7 +19287,8 @@ gen_reference_type_die (tree type, dw_die_ref context_die)\n     ref_die = new_die (DW_TAG_reference_type, scope_die, type);\n \n   equate_type_number_to_die (type, ref_die);\n-  add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);\n+  add_type_attribute (ref_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+\t\t      context_die);\n   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n }\n #endif\n@@ -19285,7 +19305,8 @@ gen_ptr_to_mbr_type_die (tree type, dw_die_ref context_die)\n   equate_type_number_to_die (type, ptr_die);\n   add_AT_die_ref (ptr_die, DW_AT_containing_type,\n \t\t  lookup_type_die (TYPE_OFFSET_BASETYPE (type)));\n-  add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);\n+  add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+\t\t      context_die);\n }\n \n typedef const char *dchar_p; /* For DEF_VEC_P.  */\n@@ -19490,7 +19511,7 @@ gen_inheritance_die (tree binfo, tree access, dw_die_ref context_die)\n {\n   dw_die_ref die = new_die (DW_TAG_inheritance, context_die, binfo);\n \n-  add_type_attribute (die, BINFO_TYPE (binfo), 0, 0, context_die);\n+  add_type_attribute (die, BINFO_TYPE (binfo), TYPE_UNQUALIFIED, context_die);\n   add_data_member_location_attribute (die, binfo);\n \n   if (BINFO_VIRTUAL_P (binfo))\n@@ -19687,7 +19708,7 @@ gen_subroutine_type_die (tree type, dw_die_ref context_die)\n \n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n-  add_type_attribute (subr_die, return_type, 0, 0, context_die);\n+  add_type_attribute (subr_die, return_type, TYPE_UNQUALIFIED, context_die);\n   gen_formal_types_die (type, subr_die);\n \n   if (get_AT (subr_die, DW_AT_name))\n@@ -19755,8 +19776,7 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n \t    }\n \t}\n \n-      add_type_attribute (type_die, type, TREE_READONLY (decl),\n-\t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n+      add_type_attribute (type_die, type, decl_quals (decl), context_die);\n \n       if (is_naming_typedef_decl (decl))\n \t/* We want that all subsequent calls to lookup_type_die with\n@@ -20331,8 +20351,8 @@ force_type_die (tree type)\n     {\n       dw_die_ref context_die = get_context_die (TYPE_CONTEXT (type));\n \n-      type_die = modified_type_die (type, TYPE_READONLY (type),\n-\t\t\t\t    TYPE_VOLATILE (type), context_die);\n+      type_die = modified_type_die (type, TYPE_QUALS_NO_ADDR_SPACE (type),\n+\t\t\t\t    context_die);\n       gcc_assert (type_die);\n     }\n   return type_die;"}]}