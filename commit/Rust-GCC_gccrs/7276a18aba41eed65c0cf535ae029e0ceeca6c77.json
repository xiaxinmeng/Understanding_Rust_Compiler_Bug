{"sha": "7276a18aba41eed65c0cf535ae029e0ceeca6c77", "node_id": "C_kwDOANBUbNoAKDcyNzZhMThhYmE0MWVlZDY1YzBjZjUzNWFlMDI5ZTBjZWVjYTZjNzc", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-17T08:23:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-17T08:23:45Z"}, "message": "gimplify: Emit clobbers for TARGET_EXPR_SLOT vars later [PR103984]\n\nAs mentioned in the PR, we emit a bogus uninitialized warning but\neasily could emit wrong-code for it or similar testcases too.\nThe bug is that we emit clobber for a TARGET_EXPR_SLOT too early:\n          D.2499.e = B::qux (&h); [return slot optimization]\n          D.2516 = 1;\n          try\n            {\n              B::B (&D.2498, &h);\n              try\n                {\n                  _2 = baz (&D.2498);\n                  D.2499.f = _2;\n                  D.2516 = 0;\n                  try\n                    {\n                      try\n                        {\n                          bar (&D.2499);\n                        }\n                      finally\n                        {\n                          C::~C (&D.2499);\n                        }\n                    }\n                  finally\n                    {\n                      D.2499 = {CLOBBER(eol)};\n                    }\n                }\n              finally\n                {\n                  D.2498 = {CLOBBER(eol)};\n                }\n            }\n          catch\n            {\n              if (D.2516 != 0) goto <D.2517>; else goto <D.2518>;\n              <D.2517>:\n              A::~A (&D.2499.e);\n              goto <D.2519>;\n              <D.2518>:\n              <D.2519>:\n            }\nThe CLOBBER for D.2499 is essentially only emitted on the non-exceptional\npath, if B::B or baz throws, then there is no CLOBBER for it but there\nis a conditional destructor A::~A (&D.2499.e).  Now, ehcleanup1\nsink_clobbers optimization assumes that clobbers in the EH cases are\nemitted after last use and so sinks the D.2499 = {CLOBBER(eol)}; later,\nso we then have\n  # _3 = PHI <1(3), 0(9)>\n<L2>:\n  D.2499 ={v} {CLOBBER(eol)};\n  D.2498 ={v} {CLOBBER(eol)};\n  if (_3 != 0)\n    goto <bb 11>; [INV]\n  else\n    goto <bb 15>; [INV]\n\n  <bb 11> :\n  _35 = D.2499.a;\n  if (&D.2499.b != _35)\nwhere that _35 = D.2499.a comes from inline expansion of the A::~A dtor,\nand that is a load from a clobbered memory.\n\nNow, what the gimplifier sees in this case is a CLEANUP_POINT_EXPR with\nsomewhere inside of it a TARGET_EXPR for D.2499 (with the C::~C (&D.2499)\ncleanup) which in its TARGET_EXPR_INITIAL has another TARGET_EXPR for\nD.2516 bool flag which has CLEANUP_EH_ONLY which performs that conditional\nA::~A (&D.2499.e) call.\nThe following patch ensures that CLOBBERs (and asan poisoning) are emitted\nafter even those gimple_push_cleanup pushed cleanups from within the\nTARGET_EXPR_INITIAL gimplification (i.e. the last point where the slot could\nbe in theory used).  In my first version of the patch I've done it by just\nmoving the\n      /* Add a clobber for the temporary going out of scope, like\n         gimplify_bind_expr.  */\n      if (gimplify_ctxp->in_cleanup_point_expr\n          && needs_to_live_in_memory (temp))\n        {\n...\n        }\nblock earlier in gimplify_target_expr, but that regressed a couple of tests\nwhere temp is marked TREE_ADDRESSABLE only during (well, very early during\nthat) the gimplification of TARGET_EXPR_INITIAL, so we didn't emit e.g. on\npr80032.C or stack2.C tests any clobbers for the slots and thus stack slot\nreuse wasn't performed.\nSo that we don't regress those tests, this patch gimplifies\nTARGET_EXPR_INITIAL as before, but doesn't emit it directly into pre_p,\nemits it into a temporary sequence.  Then emits the CLOBBER cleanup\ninto pre_p, then asan poisoning if needed, then appends the\nTARGET_EXPR_INITIAL temporary sequence and finally adds TARGET_EXPR_CLEANUP\ngimple_push_cleanup.  The earlier a GIMPLE_WCE appears in the sequence, the\nouter try/finally or try/catch it is.\nSo, with this patch the part of the testcase in gimple dump cited above\nlooks instead like:\n          try\n            {\n              D.2499.e = B::qux (&h); [return slot optimization]\n              D.2516 = 1;\n              try\n                {\n                  try\n                    {\n                      B::B (&D.2498, &h);\n                      _2 = baz (&D.2498);\n                      D.2499.f = _2;\n                      D.2516 = 0;\n                      try\n                        {\n                          bar (&D.2499);\n                        }\n                      finally\n                        {\n                          C::~C (&D.2499);\n                        }\n                    }\n                  finally\n                    {\n                      D.2498 = {CLOBBER(eol)};\n                    }\n                }\n              catch\n                {\n                  if (D.2516 != 0) goto <D.2517>; else goto <D.2518>;\n                  <D.2517>:\n                  A::~A (&D.2499.e);\n                  goto <D.2519>;\n                  <D.2518>:\n                  <D.2519>:\n                }\n            }\n          finally\n            {\n              D.2499 = {CLOBBER(eol)};\n            }\n\n2022-03-17  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/103984\n\t* gimplify.cc (gimplify_target_expr): Gimplify type sizes and\n\tTARGET_EXPR_INITIAL into a temporary sequence, then push clobbers\n\tand asan unpoisioning, then append the temporary sequence and\n\tfinally the TARGET_EXPR_CLEANUP clobbers.\n\n\t* g++.dg/opt/pr103984.C: New test.", "tree": {"sha": "a163c864d333b053dc347b653181f82a39c25520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a163c864d333b053dc347b653181f82a39c25520"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7276a18aba41eed65c0cf535ae029e0ceeca6c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7276a18aba41eed65c0cf535ae029e0ceeca6c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7276a18aba41eed65c0cf535ae029e0ceeca6c77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7276a18aba41eed65c0cf535ae029e0ceeca6c77/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c43cb355f25dd22133d15819bd6ec03d3d3939fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43cb355f25dd22133d15819bd6ec03d3d3939fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c43cb355f25dd22133d15819bd6ec03d3d3939fd"}], "stats": {"total": 65, "additions": 47, "deletions": 18}, "files": [{"sha": "139a0de6100065c11420c4e0df85236c3db46984", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7276a18aba41eed65c0cf535ae029e0ceeca6c77/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7276a18aba41eed65c0cf535ae029e0ceeca6c77/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=7276a18aba41eed65c0cf535ae029e0ceeca6c77", "patch": "@@ -6997,17 +6997,17 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \n   if (init)\n     {\n-      tree cleanup = NULL_TREE;\n+      gimple_seq init_pre_p = NULL;\n \n       /* TARGET_EXPR temps aren't part of the enclosing block, so add it\n \t to the temps list.  Handle also variable length TARGET_EXPRs.  */\n       if (!poly_int_tree_p (DECL_SIZE (temp)))\n \t{\n \t  if (!TYPE_SIZES_GIMPLIFIED (TREE_TYPE (temp)))\n-\t    gimplify_type_sizes (TREE_TYPE (temp), pre_p);\n+\t    gimplify_type_sizes (TREE_TYPE (temp), &init_pre_p);\n \t  /* FIXME: this is correct only when the size of the type does\n \t     not depend on expressions evaluated in init.  */\n-\t  gimplify_vla_decl (temp, pre_p);\n+\t  gimplify_vla_decl (temp, &init_pre_p);\n \t}\n       else\n \t{\n@@ -7022,12 +7022,14 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       /* If TARGET_EXPR_INITIAL is void, then the mere evaluation of the\n \t expression is supposed to initialize the slot.  */\n       if (VOID_TYPE_P (TREE_TYPE (init)))\n-\tret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n+\tret = gimplify_expr (&init, &init_pre_p, post_p, is_gimple_stmt,\n+\t\t\t     fb_none);\n       else\n \t{\n \t  tree init_expr = build2 (INIT_EXPR, void_type_node, temp, init);\n \t  init = init_expr;\n-\t  ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n+\t  ret = gimplify_expr (&init, &init_pre_p, post_p, is_gimple_stmt,\n+\t\t\t       fb_none);\n \t  init = NULL;\n \t  ggc_free (init_expr);\n \t}\n@@ -7037,18 +7039,9 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t  TARGET_EXPR_INITIAL (targ) = NULL_TREE;\n \t  return GS_ERROR;\n \t}\n-      if (init)\n-\tgimplify_and_add (init, pre_p);\n \n-      /* If needed, push the cleanup for the temp.  */\n-      if (TARGET_EXPR_CLEANUP (targ))\n-\t{\n-\t  if (CLEANUP_EH_ONLY (targ))\n-\t    gimple_push_cleanup (temp, TARGET_EXPR_CLEANUP (targ),\n-\t\t\t\t CLEANUP_EH_ONLY (targ), pre_p);\n-\t  else\n-\t    cleanup = TARGET_EXPR_CLEANUP (targ);\n-\t}\n+      if (init)\n+\tgimplify_and_add (init, &init_pre_p);\n \n       /* Add a clobber for the temporary going out of scope, like\n \t gimplify_bind_expr.  */\n@@ -7079,8 +7072,13 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t\t}\n \t    }\n \t}\n-      if (cleanup)\n-\tgimple_push_cleanup (temp, cleanup, false, pre_p);\n+\n+      gimple_seq_add_seq (pre_p, init_pre_p);\n+\n+      /* If needed, push the cleanup for the temp.  */\n+      if (TARGET_EXPR_CLEANUP (targ))\n+\tgimple_push_cleanup (temp, TARGET_EXPR_CLEANUP (targ),\n+\t\t\t     CLEANUP_EH_ONLY (targ), pre_p);\n \n       /* Only expand this once.  */\n       TREE_OPERAND (targ, 3) = init;"}, {"sha": "b9cb9431e3a3332fc8037b18edf7198426d21c1b", "filename": "gcc/testsuite/g++.dg/opt/pr103984.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7276a18aba41eed65c0cf535ae029e0ceeca6c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr103984.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7276a18aba41eed65c0cf535ae029e0ceeca6c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr103984.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr103984.C?ref=7276a18aba41eed65c0cf535ae029e0ceeca6c77", "patch": "@@ -0,0 +1,31 @@\n+// PR middle-end/103984\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -Wuninitialized\" }\n+\n+struct A {\n+  char *a;\n+  char b[4];\n+  A ();\n+  A (const A &);\n+  A (const char *);\n+  A (const char *, const char *);\n+  [[gnu::always_inline]] ~A () { if (a != b) delete a; }\n+};\n+struct B {\n+  const char *c = nullptr;\n+  const char *d = nullptr;\n+  A qux () const { return A (c, d); }\n+  B (const char *x) : c(x), d(x) { d += __builtin_strlen (x); }\n+  B (const B &x) { c = x.c; d = x.d; }\n+};\n+struct C { A e; int f; };\n+extern int baz (B);\n+void bar (C &&);\n+\n+void\n+foo (char **x)\n+{\n+  const A g (\"foo\");\n+  const B h = x[0];\n+  bar (C { h.qux (), baz (h) });\n+}"}]}