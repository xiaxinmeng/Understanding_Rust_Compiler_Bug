{"sha": "89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlhYmY4ZDFkNzEzYjgxODJjOWNlYmZhN2E1NjgyMTU1Y2M1ZTMyYw==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-08-08T23:19:11Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-08-08T23:19:11Z"}, "message": "c-common.c (combine_strings, [...]): Refer to ISO C or ISO C89 instead of ANSI C.\n\n\t* c-common.c (combine_strings, check_format_info): Refer to ISO C\n\tor ISO C89 instead of ANSI C.\n\t* c-decl.c (grokdeclarator, xref_tag, finish_struct,\n\tbuild_enumerator, do_case): Likewise.\n\t* c-lex.c (parse_float, yylex): Likewise.\n\t* c-parse.in: Likewise.\n\t* c-typeck.c (common_type, build_array_ref, build_binary_op,\n\tbuild_unary_op, pedantic_lvalue_warning, build_conditional_expr,\n\tbuild_c_cast, convert_for_assignment, set_init_index,\n\tset_init_label, c_expand_start_case): Likewise.\n\t* toplev.c (documented_lang_options, display_help): Likewise.\n\nFrom-SVN: r35576", "tree": {"sha": "a807f38e5528f2f079acd1807b2141242e597933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a807f38e5528f2f079acd1807b2141242e597933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a63219b0df915269b6e1176f12ec2da3d98ff30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a63219b0df915269b6e1176f12ec2da3d98ff30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a63219b0df915269b6e1176f12ec2da3d98ff30"}], "stats": {"total": 207, "additions": 115, "deletions": 92}, "files": [{"sha": "1a5e9c61fa565b3e668d49104563a4ed7cce19ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "patch": "@@ -1,3 +1,17 @@\n+2000-08-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (combine_strings, check_format_info): Refer to ISO C\n+\tor ISO C89 instead of ANSI C.\n+\t* c-decl.c (grokdeclarator, xref_tag, finish_struct,\n+\tbuild_enumerator, do_case): Likewise.\n+\t* c-lex.c (parse_float, yylex): Likewise.\n+\t* c-parse.in: Likewise.\n+\t* c-typeck.c (common_type, build_array_ref, build_binary_op,\n+\tbuild_unary_op, pedantic_lvalue_warning, build_conditional_expr,\n+\tbuild_c_cast, convert_for_assignment, set_init_index,\n+\tset_init_label, c_expand_start_case): Likewise.\n+\t* toplev.c (documented_lang_options, display_help): Likewise.\n+\n 2000-08-08  Kazu Hirata  <kazu@hxi.com>\n \n \t* h8300.c: Fix formatting."}, {"sha": "2b4b0d5515f6c06749d57dadb0dc4d17c7555d84", "filename": "gcc/c-common.c", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "patch": "@@ -375,8 +375,8 @@ combine_strings (strings)\n   nchars = wide_flag ? length / wchar_bytes : length;\n \n   if (pedantic && nchars > nchars_max)\n-    pedwarn (\"string length `%d' is greater than the minimum length `%d' ANSI C is required to support\",\n-\t     nchars, nchars_max);\n+    pedwarn (\"string length `%d' is greater than the minimum length `%d' ISO C%d is required to support\",\n+\t     nchars, nchars_max, flag_isoc99 ? 99 : 89);\n \n   /* Create the array type for the string constant.\n      -Wwrite-strings says make the string constant an array of const char\n@@ -1653,7 +1653,7 @@ check_format_info (info, params)\n \t  while (*format_chars != 0 && index (\"_-0^#\", *format_chars) != 0)\n \t    {\n \t      if (pedantic)\n-\t\twarning (\"ANSI C does not support the strftime `%c' flag\",\n+\t\twarning (\"ISO C does not support the strftime `%c' flag\",\n \t\t\t *format_chars);\n \t      if (index (flag_chars, *format_chars) != 0)\n \t\t{\n@@ -1674,7 +1674,7 @@ check_format_info (info, params)\n               ++format_chars;\n \t    }\n \t  if (wide && pedantic)\n-\t    warning (\"ANSI C does not support strftime format width\");\n+\t    warning (\"ISO C does not support strftime format width\");\n \t  if (*format_chars == 'E' || *format_chars == 'O')\n \t    {\n \t      i = strlen (flag_chars);\n@@ -1704,7 +1704,7 @@ check_format_info (info, params)\n \t\t  int opnum = atoi (format_chars);\n \n \t\t  if (pedantic)\n-\t\t    warning (\"ANSI C does not support printf %%n$\");\n+\t\t    warning (\"ISO C does not support printf %%n$\");\n \n \t\t  params = first_fillin_param;\n \t\t  format_chars = p + 1;\n@@ -1743,7 +1743,7 @@ check_format_info (info, params)\n \t      && index (flag_chars, '-') != 0)\n \t    warning (\"use of both `0' and `-' flags in format\");\n \t  if (index (flag_chars, '\\'') && pedantic)\n-\t    warning (\"ANSI C does not support the `'' format flag\");\n+\t    warning (\"ISO C does not support the `'' format flag\");\n \t  if (*format_chars == '*')\n \t    {\n \t      wide = TRUE;\n@@ -1826,21 +1826,27 @@ check_format_info (info, params)\n \t    {\n \t      length_char = *format_chars++;\n \t      if (length_char == 'q' && pedantic)\n-\t\twarning (\"ANSI C does not support the `%c' length modifier\",\n+\t\twarning (\"ISO C does not support the `%c' length modifier\",\n \t\t\t length_char);\n \t    }\n \t  else if (*format_chars == 'Z' || *format_chars == 'z')\n \t    {\n \t      length_char = *format_chars++;\n-\t      if (pedantic && (length_char == 'Z' || !flag_isoc99))\n-\t\twarning (\"ANSI C does not support the `%c' length modifier\",\n-\t\t\t length_char);\n+\t      if (pedantic)\n+\t\t{\n+\t\t  if (length_char == 'Z')\n+\t\t    warning (\"ISO C does not support the `%c' length modifier\",\n+\t\t\t     length_char);\n+\t\t  else if (!flag_isoc99)\n+\t\t    warning (\"ISO C89 does not support the `%c' length modifier\",\n+\t\t\t     length_char);\n+\t\t}\n \t    }\n \t  else if (*format_chars == 't' || *format_chars == 'j')\n \t    {\n \t      length_char = *format_chars++;\n \t      if (pedantic && !flag_isoc99)\n-\t\twarning (\"ANSI C does not support the `%c' length modifier\",\n+\t\twarning (\"ISO C89 does not support the `%c' length modifier\",\n \t\t\t length_char);\n \t    }\n \t  else\n@@ -1849,13 +1855,13 @@ check_format_info (info, params)\n \t    {\n \t      length_char = 'q', format_chars++;\n \t      if (pedantic && !flag_isoc99)\n-\t\twarning (\"ANSI C does not support the `ll' length modifier\");\n+\t\twarning (\"ISO C89 does not support the `ll' length modifier\");\n \t    }\n \t  else if (length_char == 'h' && *format_chars == 'h')\n \t    {\n \t      length_char = 'H', format_chars++;\n \t      if (pedantic && !flag_isoc99)\n-\t\twarning (\"ANSI C does not support the `hh' length modifier\");\n+\t\twarning (\"ISO C89 does not support the `hh' length modifier\");\n \t    }\n \t  if (*format_chars == 'a' && info->format_type == scanf_format_type)\n \t    {\n@@ -1880,12 +1886,12 @@ check_format_info (info, params)\n       /* The m, C, and S formats are GNU extensions.  */\n       if (pedantic && info->format_type != strftime_format_type\n \t  && (format_char == 'm' || format_char == 'C' || format_char == 'S'))\n-\twarning (\"ANSI C does not support the `%c' format\", format_char);\n+\twarning (\"ISO C does not support the `%c' format\", format_char);\n       /* The a, A and F formats are C99 extensions.  */\n       if (pedantic && info->format_type != strftime_format_type\n \t  && (format_char == 'a' || format_char == 'A' || format_char == 'F')\n \t  && !flag_isoc99)\n-\twarning (\"ANSI C does not support the `%c' format\", format_char);\n+\twarning (\"ISO C89 does not support the `%c' format\", format_char);\n       format_chars++;\n       switch (info->format_type)\n \t{\n@@ -1917,15 +1923,18 @@ check_format_info (info, params)\n       if (pedantic)\n \t{\n \t  if (index (fci->flag_chars, 'G') != 0)\n-\t    warning (\"ANSI C does not support `%%%c'\", format_char);\n+\t    warning (\"ISO C does not support `%%%c'\", format_char);\n \t  if (index (fci->flag_chars, '9') != 0 && !flag_isoc99)\n-\t    warning (\"ANSI C does not support `%%%c'\", format_char);\n-\t  if ((index (fci->flag_chars, 'o') != 0\n-\t       || (!flag_isoc99 && index (fci->flag_chars, 'O') != 0))\n-\t      && index (flag_chars, 'O') != 0)\n-\t    warning (\"ANSI C does not support `%%O%c'\", format_char);\n+\t    warning (\"ISO C89 does not support `%%%c'\", format_char);\n+\t  if (index (flag_chars, 'O') != 0)\n+\t    {\n+\t      if (index (fci->flag_chars, 'o') != 0)\n+\t\twarning (\"ISO C does not support `%%O%c'\", format_char);\n+\t      else if (!flag_isoc99 && index (fci->flag_chars, 'O') != 0)\n+\t\twarning (\"ISO C89 does not support `%%O%c'\", format_char);\n+\t    }\n \t  if (!flag_isoc99 && index (flag_chars, 'E'))\n-\t    warning (\"ANSI C does not support `%%E%c'\", format_char);\n+\t    warning (\"ISO C89 does not support `%%E%c'\", format_char);\n \t}\n       if (wide && index (fci->flag_chars, 'w') == 0)\n \twarning (\"width used with `%c' format\", format_char);\n@@ -1944,7 +1953,7 @@ check_format_info (info, params)\n \t}\n       /* The a flag is a GNU extension.  */\n       else if (pedantic && aflag)\n-\twarning (\"ANSI C does not support the `a' flag\");\n+\twarning (\"ISO C does not support the `a' flag\");\n       if (info->format_type == scanf_format_type && format_char == '[')\n \t{\n \t  /* Skip over scan set, in case it happens to have '%' in it.  */\n@@ -2004,20 +2013,20 @@ check_format_info (info, params)\n \t\t    || format_char == 'e' || format_char == 'E'\n \t\t    || format_char == 'f' || format_char == 'F'\n \t\t    || format_char == 'g' || format_char == 'G'))\n-\twarning (\"ANSI C does not support the `L' length modifier with the `%c' type character\",\n+\twarning (\"ISO C does not support the `L' length modifier with the `%c' type character\",\n \t\t format_char);\n       else if (length_char == 'l'\n \t       && (format_char == 'c' || format_char == 's'\n \t\t   || format_char == '[')\n \t       && pedantic && !flag_isoc94)\n-\twarning (\"ANSI C89 does not support the `l' length modifier with the `%c' type character\",\n+\twarning (\"ISO C89 does not support the `l' length modifier with the `%c' type character\",\n \t\t format_char);\n       else if (info->format_type == printf_format_type && pedantic\n \t       && !flag_isoc99 && length_char == 'l'\n \t       && (format_char == 'f' || format_char == 'e'\n \t\t   || format_char == 'E' || format_char == 'g'\n \t\t   || format_char == 'G'))\n-\twarning (\"ANSI C does not support the `l' length modifier with the `%c' type character\",\n+\twarning (\"ISO C89 does not support the `l' length modifier with the `%c' type character\",\n \t\t format_char);\n \n       /* Finally. . .check type of argument against desired type!  */"}, {"sha": "3863531623ef2ca143ffb6a42ea97973c99cc5c9", "filename": "gcc/c-decl.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "patch": "@@ -4005,7 +4005,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t      {\n \t\t\tif (pedantic && !flag_isoc99 && ! in_system_header\n \t\t\t    && warn_long_long)\n-\t\t\t  pedwarn (\"ANSI C does not support `long long'\");\n+\t\t\t  pedwarn (\"ISO C89 does not support `long long'\");\n \t\t\tlonglong = 1;\n \t\t      }\n \t\t  }\n@@ -4385,7 +4385,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t}\n \n \t      if (pedantic && integer_zerop (size))\n-\t\tpedwarn (\"ANSI C forbids zero-size array `%s'\", name);\n+\t\tpedwarn (\"ISO C forbids zero-size array `%s'\", name);\n \n \t      if (TREE_CODE (size) == INTEGER_CST)\n \t\t{\n@@ -4405,9 +4405,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t  if (pedantic)\n \t\t    {\n \t\t      if (TREE_CONSTANT (size))\n-\t\t\tpedwarn (\"ANSI C forbids array `%s' whose size can't be evaluated\", name);\n+\t\t\tpedwarn (\"ISO C89 forbids array `%s' whose size can't be evaluated\", name);\n \t\t      else\n-\t\t\tpedwarn (\"ANSI C forbids variable-size array `%s'\", name);\n+\t\t\tpedwarn (\"ISO C89 forbids variable-size array `%s'\", name);\n \t\t    }\n \t\t}\n \n@@ -4539,7 +4539,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n \t  if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t      && type_quals)\n-\t    pedwarn (\"ANSI C forbids qualified function types\");\n+\t    pedwarn (\"ISO C forbids qualified function types\");\n \t  if (type_quals)\n \t    type = c_build_qualified_type (type, type_quals);\n \t  type_quals = TYPE_UNQUALIFIED;\n@@ -4612,7 +4612,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t in typenames, fields or parameters */\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (\"ANSI C forbids qualified function types\");\n+\tpedwarn (\"ISO C forbids qualified function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n       decl = build_decl (TYPE_DECL, declarator, type);\n@@ -4646,7 +4646,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t in typenames, fields or parameters */\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (\"ANSI C forbids const or volatile function types\");\n+\tpedwarn (\"ISO C forbids const or volatile function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n       return type;\n@@ -4696,7 +4696,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n \t    if (pedantic && type_quals)\n-\t      pedwarn (\"ANSI C forbids qualified function types\");\n+\t      pedwarn (\"ISO C forbids qualified function types\");\n \t    if (type_quals)\n \t      type = c_build_qualified_type (type, type_quals);\n \t    type = build_pointer_type (type);\n@@ -4782,13 +4782,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \tdecl = build_decl_attribute_variant (decl, decl_machine_attr);\n \n \tif (pedantic && type_quals && ! DECL_IN_SYSTEM_HEADER (decl))\n-\t  pedwarn (\"ANSI C forbids qualified function types\");\n+\t  pedwarn (\"ISO C forbids qualified function types\");\n \n \tif (pedantic\n \t    && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl)))\n \t    && TYPE_QUALS (TREE_TYPE (TREE_TYPE (decl)))\n \t    && ! DECL_IN_SYSTEM_HEADER (decl))\n-\t  pedwarn (\"ANSI C forbids qualified void function return type\");\n+\t  pedwarn (\"ISO C forbids qualified void function return type\");\n \n \t/* GNU C interprets a `volatile void' return type to indicate\n \t   that the function does not return.  */\n@@ -5161,7 +5161,7 @@ xref_tag (code, name)\n     {\n       /* (In ANSI, Enums can be referred to only if already defined.)  */\n       if (pedantic)\n-\tpedwarn (\"ANSI C forbids forward references to `enum' types\");\n+\tpedwarn (\"ISO C forbids forward references to `enum' types\");\n       /* Give the type a default layout like unsigned int\n \t to avoid crashing if it does not get defined.  */\n       TYPE_MODE (ref) = TYPE_MODE (unsigned_type_node);\n@@ -5354,7 +5354,7 @@ finish_struct (t, fieldlist, attributes)\n \t  && !(TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n \t       && (TYPE_PRECISION (TREE_TYPE (x))\n \t\t   == TYPE_PRECISION (integer_type_node))))\n-\tpedwarn_with_decl (x, \"bit-field `%s' type invalid in ANSI C\");\n+\tpedwarn_with_decl (x, \"bit-field `%s' type invalid in ISO C\");\n \n       /* Detect and ignore out of range field width and process valid\n \t field widths.  */\n@@ -5749,7 +5749,7 @@ build_enumerator (name, value)\n \n   if (pedantic && ! int_fits_type_p (value, integer_type_node))\n     {\n-      pedwarn (\"ANSI C restricts enumerator values to range of `int'\");\n+      pedwarn (\"ISO C restricts enumerator values to range of `int'\");\n       value = convert (integer_type_node, value);\n     }\n \n@@ -6924,7 +6924,7 @@ do_case (low_value, high_value)\n   label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n   \n   if (pedantic && (high_value != NULL_TREE))\n-    pedwarn (\"ANSI C forbids case ranges\");\n+    pedwarn (\"ISO C forbids case ranges\");\n \n   if (value1 != error_mark_node && value2 != error_mark_node)\n     {\n@@ -6933,7 +6933,7 @@ do_case (low_value, high_value)\n       \n       if (high_value == NULL_TREE && value1 != NULL_TREE &&\n \t  pedantic && ! INTEGRAL_TYPE_P (TREE_TYPE (value1)))\n-\tpedwarn (\"label must have integral type in ANSI C\");\n+\tpedwarn (\"label must have integral type in ISO C\");\n       \n       if (low_value == NULL_TREE)\n \tsuccess = pushcase (NULL_TREE, 0, label, &duplicate);"}, {"sha": "9cbbc4daae95630b993080576542b1bdcf05c301", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "patch": "@@ -1122,7 +1122,7 @@ parse_float (data)\n \t  if (args->imag)\n \t    error (\"more than one `i' or `j' in numeric constant\");\n \t  else if (pedantic)\n-\t    pedwarn (\"ANSI C forbids imaginary numeric constants\");\n+\t    pedwarn (\"ISO C forbids imaginary numeric constants\");\n \t  args->imag = 1;\n \t  break;\n \n@@ -1789,7 +1789,7 @@ yylex ()\n \t\t\t  error (\"`Ll' and `lL' are not valid integer suffixes\");\n \t\t\telse if (pedantic && ! flag_isoc99\n \t\t\t\t && ! in_system_header && warn_long_long)\n-\t\t\t  pedwarn (\"ANSI C forbids long long integer constants\");\n+\t\t\t  pedwarn (\"ISO C89 forbids long long integer constants\");\n \t\t\tspec_long_long = 1;\n \t\t      }\n \t\t    spec_long = c;\n@@ -1799,7 +1799,7 @@ yylex ()\n \t\t    if (spec_imag)\n \t\t      error (\"more than one `i' or `j' in numeric constant\");\n \t\t    else if (pedantic)\n-\t\t      pedwarn (\"ANSI C forbids imaginary numeric constants\");\n+\t\t      pedwarn (\"ISO C forbids imaginary numeric constants\");\n \t\t    spec_imag = 1;\n \t\t  }\n \t\telse\n@@ -1914,7 +1914,7 @@ yylex ()\n \t\t  warning (\"width of integer constant changes with -traditional\");\n \t\telse if (TREE_UNSIGNED (traditional_type)\n \t\t\t != TREE_UNSIGNED (ansi_type))\n-\t\t  warning (\"integer constant is unsigned in ANSI C, signed with -traditional\");\n+\t\t  warning (\"integer constant is unsigned in ISO C, signed with -traditional\");\n \t\telse\n \t\t  warning (\"width of integer constant may change on other systems with -traditional\");\n \t      }\n@@ -2018,7 +2018,7 @@ yylex ()\n \t    else if (c == '\\n')\n \t      {\n \t\tif (pedantic)\n-\t\t  pedwarn (\"ANSI C forbids newline in character constant\");\n+\t\t  pedwarn (\"ISO C forbids newline in character constant\");\n \t\tlineno++;\n \t      }\n \t    else\n@@ -2175,7 +2175,7 @@ yylex ()\n \t    else if (c == '\\n')\n \t      {\n \t\tif (pedantic)\n-\t\t  pedwarn (\"ANSI C forbids newline in string constant\");\n+\t\t  pedwarn (\"ISO C forbids newline in string constant\");\n \t\tlineno++;\n \t      }\n \t    else"}, {"sha": "4e6d434523ca9f29094de7a81d9baee32c8cef89", "filename": "gcc/c-parse.in", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "patch": "@@ -277,7 +277,7 @@ end ifobjc\n %%\n program: /* empty */\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids an empty source file\");\n+\t\t    pedwarn (\"ISO C forbids an empty source file\");\n \t\t  finish_file ();\n \t\t}\n \t| extdefs\n@@ -320,7 +320,7 @@ end ifobjc\n datadef:\n \t  setspecs notype_initdecls ';'\n \t\t{ if (pedantic)\n-\t\t    error (\"ANSI C forbids data definition with no type or storage class\");\n+\t\t    error (\"ISO C forbids data definition with no type or storage class\");\n \t\t  else if (!flag_traditional)\n \t\t    warning (\"data definition has no type or storage class\"); \n \n@@ -343,7 +343,7 @@ datadef:\n \t| error '}'\n \t| ';'\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C does not allow extra `;' outside of a function\"); }\n+\t\t    pedwarn (\"ISO C does not allow extra `;' outside of a function\"); }\n \t;\n \f\n fndef:\n@@ -459,7 +459,7 @@ unary_expr:\n \t| ANDAND identifier\n \t\t{ tree label = lookup_label ($2);\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids `&&'\");\n+\t\t    pedwarn (\"ISO C forbids `&&'\");\n \t\t  if (label == 0)\n \t\t    $$ = null_pointer_node;\n \t\t  else\n@@ -479,7 +479,7 @@ unary_expr:\n \t\t  else\n \t\t    {\n \t\t      if (pedantic)\n-\t\t\tpedwarn (\"ANSI C forbids `&...'\");\n+\t\t\tpedwarn (\"ISO C forbids `&...'\");\n \t\t      $$ = tree_last (DECL_ARGUMENTS (current_function_decl));\n \t\t      $$ = build_unary_op (ADDR_EXPR, $$, 0);\n \t\t    } }\n@@ -531,7 +531,7 @@ cast_expr:\n \t\t  finish_init ();\n \n \t\t  if (pedantic && ! flag_isoc99)\n-\t\t    pedwarn (\"ANSI C forbids constructor expressions\");\n+\t\t    pedwarn (\"ISO C89 forbids constructor expressions\");\n \t\t  if (TYPE_NAME (type) != 0)\n \t\t    {\n \t\t      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n@@ -600,7 +600,7 @@ expr_no_commas:\n \t\t  $$ = build_conditional_expr ($1, $4, $7); }\n \t| expr_no_commas '?'\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids omitting the middle term of a ?: expression\");\n+\t\t    pedwarn (\"ISO C forbids omitting the middle term of a ?: expression\");\n \t\t  /* Make sure first operand is calculated only once.  */\n \t\t  $<ttype>2 = save_expr ($1);\n \t\t  $1 = truthvalue_conversion (default_conversion ($<ttype>2));\n@@ -648,7 +648,7 @@ primary:\n \t| compstmt_primary_start compstmt_nostart ')'\n \t\t{ tree rtl_exp;\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids braced-groups within expressions\");\n+\t\t    pedwarn (\"ISO C forbids braced-groups within expressions\");\n \t\t  pop_iterator_stack ();\n \t\t  pop_label_level ();\n \t\t  rtl_exp = expand_end_stmt_expr ($1);\n@@ -769,7 +769,7 @@ old_style_parm_decls:\n \t\t/* ... is used here to indicate a varargs function.  */\n \t\t{ c_mark_varargs ();\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C does not permit use of `varargs.h'\"); }\n+\t\t    pedwarn (\"ISO C does not permit use of `varargs.h'\"); }\n \t;\n \n /* The following are analogous to lineno_decl, decls and decl\n@@ -1112,7 +1112,7 @@ init:\n initlist_maybe_comma:\n \t  /* empty */\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids empty initializer braces\"); }\n+\t\t    pedwarn (\"ISO C forbids empty initializer braces\"); }\n \t| initlist1 maybecomma\n \t;\n \n@@ -1164,7 +1164,7 @@ end ifc\n nested_function:\n \t  declarator\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids nested functions\");\n+\t\t    pedwarn (\"ISO C forbids nested functions\");\n \n \t\t  push_function_context ();\n \t\t  if (! start_function (current_declspecs, $1,\n@@ -1190,7 +1190,7 @@ nested_function:\n notype_nested_function:\n \t  notype_declarator\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids nested functions\");\n+\t\t    pedwarn (\"ISO C forbids nested functions\");\n \n \t\t  push_function_context ();\n \t\t  if (! start_function (current_declspecs, $1,\n@@ -1442,7 +1442,7 @@ component_decl:\n \t\t     structs or unions (which is [a] useful and [b] supports \n \t\t     MS P-SDK).  */\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C doesn't support unnamed structs/unions\");\n+\t\t    pedwarn (\"ISO C doesn't support unnamed structs/unions\");\n \n \t\t  $$ = grokfield($3, $4, NULL, current_declspecs, NULL_TREE);\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n@@ -1456,7 +1456,7 @@ component_decl:\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n \t| nonempty_type_quals\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids member declarations with no members\");\n+\t\t    pedwarn (\"ISO C forbids member declarations with no members\");\n \t\t  shadow_tag($1);\n \t\t  $$ = NULL_TREE; }\n \t| error\n@@ -1570,7 +1570,7 @@ stmts:\n \tlineno_stmt_or_labels\n \t\t{\n \t\t  if (pedantic && $1)\n-\t\t    pedwarn (\"ANSI C forbids label at end of compound statement\");\n+\t\t    pedwarn (\"ISO C forbids label at end of compound statement\");\n \t\t}\n \t;\n \n@@ -1608,7 +1608,7 @@ maybe_label_decls:\n \t  /* empty */\n \t| label_decls\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids label declarations\"); }\n+\t\t    pedwarn (\"ISO C forbids label declarations\"); }\n \t;\n \n label_decls:\n@@ -1919,7 +1919,7 @@ stmt:\n \t\t}\n \t| GOTO '*' expr ';'\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids `goto *expr;'\");\n+\t\t    pedwarn (\"ISO C forbids `goto *expr;'\");\n \t\t  stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  expand_computed_goto (convert (ptr_type_node, $3)); }\n@@ -2072,7 +2072,7 @@ parmlist_1:\n \t| parms ';'\n \t\t{ tree parm;\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids forward parameter declarations\");\n+\t\t    pedwarn (\"ISO C forbids forward parameter declarations\");\n \t\t  /* Mark the forward decls as such.  */\n \t\t  for (parm = getdecls (); parm; parm = TREE_CHAIN (parm))\n \t\t    TREE_ASM_WRITTEN (parm) = 1;\n@@ -2095,7 +2095,7 @@ parmlist_2:  /* empty */\n \t\t     it caused problems with the code in expand_builtin which\n \t\t     tries to verify that BUILT_IN_NEXT_ARG is being used\n \t\t     correctly.  */\n-\t\t  error (\"ANSI C requires a named argument before `...'\");\n+\t\t  error (\"ISO C requires a named argument before `...'\");\n \t\t}\n \t| parms\n \t\t{ $$ = get_parm_info (1); }"}, {"sha": "0adc24a39eb1384fcc5324f77b742ed0eea87dca", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "patch": "@@ -388,7 +388,7 @@ common_type (t1, t2)\n \t\t    {\n \t\t      TREE_VALUE (n) = TREE_VALUE (p2);\n \t\t      if (pedantic)\n-\t\t\tpedwarn (\"function types not truly compatible in ANSI C\");\n+\t\t\tpedwarn (\"function types not truly compatible in ISO C\");\n \t\t      goto parm_done;\n \t\t    }\n \t      }\n@@ -402,7 +402,7 @@ common_type (t1, t2)\n \t\t    {\n \t\t      TREE_VALUE (n) = TREE_VALUE (p1);\n \t\t      if (pedantic)\n-\t\t\tpedwarn (\"function types not truly compatible in ANSI C\");\n+\t\t\tpedwarn (\"function types not truly compatible in ISO C\");\n \t\t      goto parm_done;\n \t\t    }\n \t      }\n@@ -1318,9 +1318,9 @@ build_array_ref (array, index)\n       if (pedantic && !lvalue_p (array))\n \t{\n \t  if (DECL_REGISTER (array))\n-\t    pedwarn (\"ANSI C forbids subscripting `register' array\");\n+\t    pedwarn (\"ISO C forbids subscripting `register' array\");\n \t  else\n-\t    pedwarn (\"ANSI C forbids subscripting non-lvalue array\");\n+\t    pedwarn (\"ISO C89 forbids subscripting non-lvalue array\");\n \t}\n \n       if (pedantic)\n@@ -1329,7 +1329,7 @@ build_array_ref (array, index)\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && DECL_REGISTER (foo))\n-\t    pedwarn (\"ANSI C forbids subscripting non-lvalue array\");\n+\t    pedwarn (\"ISO C89 forbids subscripting non-lvalue array\");\n \t}\n \n       type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (array)));\n@@ -2198,13 +2198,13 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\t whose value is 0 but which isn't a valid null ptr const.  */\n \t      if (pedantic && (!integer_zerop (op0) || op0 != orig_op0)\n \t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ANSI C forbids comparison of `void *' with function pointer\");\n+\t\tpedwarn (\"ISO C forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else if (VOID_TYPE_P (tt1))\n \t    {\n \t      if (pedantic && (!integer_zerop (op1) || op1 != orig_op1)\n \t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ANSI C forbids comparison of `void *' with function pointer\");\n+\t\tpedwarn (\"ISO C forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else\n \t    pedwarn (\"comparison of distinct pointer types lacks a cast\");\n@@ -2244,7 +2244,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      result_type = common_type (type0, type1);\n \t      if (pedantic \n \t\t  && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ANSI C forbids ordered comparisons of pointers to functions\");\n+\t\tpedwarn (\"ISO C forbids ordered comparisons of pointers to functions\");\n \t    }\n \t  else\n \t    {\n@@ -2272,7 +2272,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\tpedwarn (\"comparison of complete and incomplete pointers\");\n \t      else if (pedantic \n \t\t       && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ANSI C forbids ordered comparisons of pointers to functions\");\n+\t\tpedwarn (\"ISO C forbids ordered comparisons of pointers to functions\");\n \t    }\n \t  else\n \t    {\n@@ -3057,7 +3057,7 @@ build_unary_op (code, xarg, noconvert)\n \tcase FIX_ROUND_EXPR:\n \tcase FIX_CEIL_EXPR:\n \t  if (pedantic)\n-\t    pedwarn (\"ANSI C forbids the address of a cast expression\");\n+\t    pedwarn (\"ISO C forbids the address of a cast expression\");\n \t  return convert (build_pointer_type (TREE_TYPE (arg)),\n \t\t\t  build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0),\n \t\t\t\t\t  0));\n@@ -3268,13 +3268,13 @@ pedantic_lvalue_warning (code)\n     switch (code)\n       {\n       case COND_EXPR:\n-\tpedwarn (\"ANSI C forbids use of conditional expressions as lvalues\");\n+\tpedwarn (\"ISO C forbids use of conditional expressions as lvalues\");\n \tbreak;\n       case COMPOUND_EXPR:\n-\tpedwarn (\"ANSI C forbids use of compound expressions as lvalues\");\n+\tpedwarn (\"ISO C forbids use of compound expressions as lvalues\");\n \tbreak;\n       default:\n-\tpedwarn (\"ANSI C forbids use of cast expressions as lvalues\");\n+\tpedwarn (\"ISO C forbids use of cast expressions as lvalues\");\n \tbreak;\n       }\n }\n@@ -3490,7 +3490,7 @@ build_conditional_expr (ifexp, op1, op2)\n   else if (code1 == VOID_TYPE || code2 == VOID_TYPE)\n     {\n       if (pedantic && (code1 != VOID_TYPE || code2 != VOID_TYPE))\n-\tpedwarn (\"ANSI C forbids conditional expr with only one void side\");\n+\tpedwarn (\"ISO C forbids conditional expr with only one void side\");\n       result_type = void_type_node;\n     }\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n@@ -3506,13 +3506,13 @@ build_conditional_expr (ifexp, op1, op2)\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n \t  if (pedantic && TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C forbids conditional expr between `void *' and function pointer\");\n+\t    pedwarn (\"ISO C forbids conditional expr between `void *' and function pointer\");\n \t  result_type = qualify_type (type1, type2);\n \t}\n       else if (VOID_TYPE_P (TREE_TYPE (type2)))\n \t{\n \t  if (pedantic && TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C forbids conditional expr between `void *' and function pointer\");\n+\t    pedwarn (\"ISO C forbids conditional expr between `void *' and function pointer\");\n \t  result_type = qualify_type (type2, type1);\n \t}\n       else\n@@ -3684,7 +3684,7 @@ build_c_cast (type, expr)\n \t{\n \t  if (TREE_CODE (type) == RECORD_TYPE\n \t      || TREE_CODE (type) == UNION_TYPE)\n-\t    pedwarn (\"ANSI C forbids casting nonscalar to the same type\");\n+\t    pedwarn (\"ISO C forbids casting nonscalar to the same type\");\n \t}\n     }\n   else if (TREE_CODE (type) == UNION_TYPE)\n@@ -3705,7 +3705,7 @@ build_c_cast (type, expr)\n \t  tree t;\n \n \t  if (pedantic)\n-\t    pedwarn (\"ANSI C forbids casts to union type\");\n+\t    pedwarn (\"ISO C forbids casts to union type\");\n \t  if (TYPE_NAME (type) != 0)\n \t    {\n \t      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n@@ -4164,7 +4164,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t    }\n \t  \n \t  if (pedantic && ! DECL_IN_SYSTEM_HEADER (fundecl))\n-\t    pedwarn (\"ANSI C prohibits argument conversion to union type\");\n+\t    pedwarn (\"ISO C prohibits argument conversion to union type\");\n \n \t  return build1 (NOP_EXPR, type, rhs);\n \t}\n@@ -4193,7 +4193,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t      which are not ANSI null ptr constants.  */\n \t\t   && (!integer_zerop (rhs) || TREE_CODE (rhs) == NOP_EXPR)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n-\t    warn_for_assignment (\"ANSI forbids %s between function pointer and `void *'\",\n+\t    warn_for_assignment (\"ISO C forbids %s between function pointer and `void *'\",\n \t\t\t\t errtype, funname, parmnum);\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n@@ -5609,7 +5609,7 @@ set_init_index (first, last)\n       else\n \t{\n \t  if (pedantic)\n-\t    pedwarn (\"ANSI C forbids specifying element to initialize\");\n+\t    pedwarn (\"ISO C89 forbids specifying element to initialize\");\n \n \t  constructor_range_end = last ? convert (bitsizetype, last) : 0;\n \t}\n@@ -5649,7 +5649,7 @@ set_init_label (fieldname)\n     {\n       constructor_fields = tail;\n       if (pedantic)\n-\tpedwarn (\"ANSI C forbids specifying structure member to initialize\");\n+\tpedwarn (\"ISO C89 forbids specifying structure member to initialize\");\n     }\n }\n \f\n@@ -6740,7 +6740,7 @@ c_expand_start_case (exp)\n \t  && ! in_system_header\n \t  && (type == long_integer_type_node\n \t      || type == long_unsigned_type_node))\n-\twarning (\"`long' switch expression not converted to `int' in ANSI C\");\n+\twarning (\"`long' switch expression not converted to `int' in ISO C\");\n \n       exp = default_conversion (exp);\n       type = TREE_TYPE (exp);"}, {"sha": "79f6ff751f6bb9ea02987769da31988fd025fe94", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89abf8d1d713b8182c9cebfa7a5682155cc5e32c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=89abf8d1d713b8182c9cebfa7a5682155cc5e32c", "patch": "@@ -1135,7 +1135,7 @@ documented_lang_options[] =\n      used here is to only describe those options which are not\n      enabled by default.  */\n \n-  { \"-ansi\", \"Compile just for ANSI C\" },\n+  { \"-ansi\", \"Compile just for ISO C89\" },\n   { \"-fallow-single-precision\",\n     \"Do not promote floats to double if using -traditional\" },\n   { \"-std= \", \"Determine language standard\"},\n@@ -1236,7 +1236,7 @@ documented_lang_options[] =\n   { \"-Wno-unknown-pragmas\", \"\" },\n   { \"-Wstrict-prototypes\", \"Warn about non-prototyped function decls\" },\n   { \"-Wno-strict-prototypes\", \"\" },\n-  { \"-Wtraditional\", \"Warn about constructs whose meaning change in ANSI C\"},\n+  { \"-Wtraditional\", \"Warn about constructs whose meaning change in ISO C\"},\n   { \"-Wno-traditional\", \"\" },\n   { \"-Wtrigraphs\", \"Warn when trigraphs are encountered\" },\n   { \"-Wno-trigraphs\", \"\" },\n@@ -3741,7 +3741,7 @@ display_help ()\n \n   printf (_(\"  -O[number]              Set optimisation level to [number]\\n\"));\n   printf (_(\"  -Os                     Optimise for space rather than speed\\n\"));\n-  printf (_(\"  -pedantic               Issue warnings needed by strict compliance to ANSI C\\n\"));\n+  printf (_(\"  -pedantic               Issue warnings needed by strict compliance to ISO C\\n\"));\n   printf (_(\"  -pedantic-errors        Like -pedantic except that errors are produced\\n\"));\n   printf (_(\"  -w                      Suppress warnings\\n\"));\n   printf (_(\"  -W                      Enable extra warnings\\n\"));"}]}