{"sha": "70f40fea6a317d7be82d1f02defb59381c7752e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBmNDBmZWE2YTMxN2Q3YmU4MmQxZjAyZGVmYjU5MzgxYzc3NTJlNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-11-14T05:02:58Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-11-14T05:02:58Z"}, "message": "Implement P0217R3 - C++17 structured bindings\n\ngcc/\n\t* match.pd: Don't try to compare addresses of variables with\n\tDECL_VALUE_EXPR.\ngcc/cp/\n\t* cp-tree.h (struct lang_decl_base): Add decomposition_p.\n\t(DECL_DECOMPOSITION_P): New\n\t(enum auto_deduction_context): Add adc_decomp_type.\n\t(enum cp_declarator_kind): Add cdk_decomp.\n\t* constexpr.c (cxx_eval_constant_expression): Look through\n\tDECL_VALUE_EXPR.\n\t(potential_constant_expression_1): Likewise.\n\t* decl.c (reshape_init): Preserve CONSTRUCTOR_IS_DIRECT_INIT.\n\t(check_initializer): Use build_aggr_init for DECL_DECOMPOSITION_P.\n\t(cp_finish_decl): Pass adc_decomp_type for decomposition.\n\t(find_decomp_class_base, get_tuple_size, get_tuple_element_type)\n\t(get_tuple_decomp_init, cp_finish_decomp): New.\n\t(grokdeclarator): Handle decomposition.\n\t* init.c (build_aggr_init): Handle decomposition array.\n\t(build_vec_init): Handle initialization from { array }.\n\t* name-lookup.c (add_function): Always wrap TEMPLATE_DECL in\n\tOVERLOAD.\n\t* parser.c (declarator_can_be_parameter_pack): Handle cdk_decomp.\n\t(function_declarator_p, strip_declarator_types)\n\t(cp_parser_check_declarator_template_parameters): Likewise.\n\t(cp_parser_range_for, cp_convert_range_for): Handle decomposition.\n\t(cp_parser_simple_declaration): Parse decomposition.\n\t(cp_parser_decomposition_declaration): New.\n\t* pt.c (tsubst_decomp_names): New.\n\t(subst_expr) [DECL_EXPR, RANGE_FOR_STMT]: Handle decomposition.\n\t(do_auto_deduction): Handle adc_decomp_type.\n\t* semantics.c (finish_decltype_type): Look through DECL_VALUE_EXPR.\n\t* typeck.c (is_bitfield_expr_with_lowered_type): Likewise.\n\t* tree.c (lvalue_kind): Likewise.\n\t(cp_build_reference_type): Handle reference collapsing.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r242377", "tree": {"sha": "dc50db5d9b8178d8b61bbce0247a6a9df671c429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc50db5d9b8178d8b61bbce0247a6a9df671c429"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70f40fea6a317d7be82d1f02defb59381c7752e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f40fea6a317d7be82d1f02defb59381c7752e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f40fea6a317d7be82d1f02defb59381c7752e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f40fea6a317d7be82d1f02defb59381c7752e7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7555e42d0143f2a5ee50425902abde7c5091ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7555e42d0143f2a5ee50425902abde7c5091ad3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7555e42d0143f2a5ee50425902abde7c5091ad3"}], "stats": {"total": 998, "additions": 939, "deletions": 59}, "files": [{"sha": "323018240bdcc65d730404cb142cc1af31ff7f28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -1,3 +1,8 @@\n+2016-11-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* match.pd: Don't try to compare addresses of variables with\n+\tDECL_VALUE_EXPR.\n+\n 2016-11-13  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* ipa-cp.c (ipa_get_jf_pass_through_result): Skip unary expressions."}, {"sha": "65574d3ee4b81016d8750b27a90c5a2c158af804", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -1,3 +1,38 @@\n+2016-11-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0217R3 - C++17 structured bindings\n+\t* cp-tree.h (struct lang_decl_base): Add decomposition_p.\n+\t(DECL_DECOMPOSITION_P): New\n+\t(enum auto_deduction_context): Add adc_decomp_type.\n+\t(enum cp_declarator_kind): Add cdk_decomp.\n+\t* constexpr.c (cxx_eval_constant_expression): Look through\n+\tDECL_VALUE_EXPR.\n+\t(potential_constant_expression_1): Likewise.\n+\t* decl.c (reshape_init): Preserve CONSTRUCTOR_IS_DIRECT_INIT.\n+\t(check_initializer): Use build_aggr_init for DECL_DECOMPOSITION_P.\n+\t(cp_finish_decl): Pass adc_decomp_type for decomposition.\n+\t(find_decomp_class_base, get_tuple_size, get_tuple_element_type)\n+\t(get_tuple_decomp_init, cp_finish_decomp): New.\n+\t(grokdeclarator): Handle decomposition.\n+\t* init.c (build_aggr_init): Handle decomposition array.\n+\t(build_vec_init): Handle initialization from { array }.\n+\t* name-lookup.c (add_function): Always wrap TEMPLATE_DECL in\n+\tOVERLOAD.\n+\t* parser.c (declarator_can_be_parameter_pack): Handle cdk_decomp.\n+\t(function_declarator_p, strip_declarator_types)\n+\t(cp_parser_check_declarator_template_parameters): Likewise.\n+\t(cp_parser_range_for, cp_convert_range_for): Handle decomposition.\n+\t(cp_parser_simple_declaration): Parse decomposition.\n+\t(cp_parser_decomposition_declaration): New.\n+\t* pt.c (tsubst_decomp_names): New.\n+\t(subst_expr) [DECL_EXPR, RANGE_FOR_STMT]: Handle decomposition.\n+\t(do_auto_deduction): Handle adc_decomp_type.\n+\t* semantics.c (finish_decltype_type): Look through DECL_VALUE_EXPR.\n+\t* typeck.c (is_bitfield_expr_with_lowered_type): Likewise.\n+\t* tree.c (lvalue_kind): Likewise.\n+\t(cp_build_reference_type): Handle reference collapsing.\n+\n 2016-11-13  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (build_new_method_call_1): Include template arguments in"}, {"sha": "e8c7702dede77a2c542ac600a20bacfd9f2d7466", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -3770,7 +3770,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       return (*ctx->values->get (t));\n \n     case VAR_DECL:\n-      if (is_capture_proxy (t))\n+      if (DECL_HAS_VALUE_EXPR_P (t))\n \treturn cxx_eval_constant_expression (ctx, DECL_VALUE_EXPR (t),\n \t\t\t\t\t     lval, non_constant_p, overflow_p);\n       /* fall through */\n@@ -5037,6 +5037,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n       return RECUR (TREE_OPERAND (t, 0), rval);\n \n     case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (t))\n+\treturn RECUR (DECL_VALUE_EXPR (t), rval);\n       if (want_rval\n \t  && !var_in_maybe_constexpr_fn (t)\n \t  && !type_dependent_expression_p (t)"}, {"sha": "8c2dbe1fba6f0ab1008552d1fbe0508c17bbab16", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -2228,7 +2228,8 @@ struct GTY(()) lang_decl_base {\n   unsigned u2sel : 1;\n   unsigned concept_p : 1;                  /* applies to vars and functions */\n   unsigned var_declared_inline_p : 1;\t   /* var */\n-  /* 2 spare bits */\n+  unsigned decomposition_p : 1;\t\t   /* var */\n+  /* 1 spare bit */\n };\n \n /* True for DECL codes which have template info and access.  */\n@@ -3626,6 +3627,16 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.var_declared_inline_p \\\n    = true)\n \n+/* Nonzero if NODE is the artificial VAR_DECL for decomposition\n+   declaration.  */\n+#define DECL_DECOMPOSITION_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\t\t\t\\\n+   ? DECL_LANG_SPECIFIC (NODE)->u.base.decomposition_p\t\t\\\n+   : false)\n+#define SET_DECL_DECOMPOSITION_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.decomposition_p \\\n+   = true)\n+\n /* Nonzero if NODE is an inline VAR_DECL.  In C++17, static data members\n    declared with constexpr specifier are implicitly inline variables.  */\n #define DECL_INLINE_VAR_P(NODE) \\\n@@ -5165,7 +5176,8 @@ enum auto_deduction_context\n   adc_variable_type, /* Variable initializer deduction */\n   adc_return_type,   /* Return type deduction */\n   adc_unify,         /* Template argument deduction */\n-  adc_requirement    /* Argument dedution constraint */\n+  adc_requirement,   /* Argument deduction constraint */\n+  adc_decomp_type    /* Decomposition declaration initializer deduction */\n };\n \n /* True iff this TEMPLATE_TYPE_PARM represents decltype(auto).  */\n@@ -5382,6 +5394,7 @@ enum cp_declarator_kind {\n   cdk_pointer,\n   cdk_reference,\n   cdk_ptrmem,\n+  cdk_decomp,\n   cdk_error\n };\n \n@@ -5412,7 +5425,8 @@ struct cp_declarator {\n   /* Whether we parsed an ellipsis (`...') just before the declarator,\n      to indicate this is a parameter pack.  */\n   BOOL_BITFIELD parameter_pack_p : 1;\n-  location_t id_loc; /* Currently only set for cdk_id and cdk_function. */\n+  location_t id_loc; /* Currently only set for cdk_id, cdk_decomp and\n+\t\t\tcdk_function. */\n   /* GNU Attributes that apply to this declarator.  If the declarator\n      is a pointer or a reference, these attribute apply to the type\n      pointed to.  */\n@@ -5421,8 +5435,8 @@ struct cp_declarator {\n      declarator is a pointer or a reference, these attributes apply\n      to the pointer, rather than to the type pointed to.  */\n   tree std_attributes;\n-  /* For all but cdk_id and cdk_error, the contained declarator.  For\n-     cdk_id and cdk_error, guaranteed to be NULL.  */\n+  /* For all but cdk_id, cdk_decomp and cdk_error, the contained declarator.\n+     For cdk_id, cdk_decomp and cdk_error, guaranteed to be NULL.  */\n   cp_declarator *declarator;\n   union {\n     /* For identifiers.  */\n@@ -5794,6 +5808,7 @@ extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int,\n extern void start_decl_1\t\t\t(tree, bool);\n extern bool check_array_initializer\t\t(tree, tree, tree);\n extern void cp_finish_decl\t\t\t(tree, tree, bool, tree, int);\n+extern void cp_finish_decomp\t\t\t(tree, tree, unsigned int);\n extern int cp_complete_array_type\t\t(tree *, tree, bool);\n extern int cp_complete_array_type_or_error\t(tree *, tree, bool, tsubst_flags_t);\n extern tree build_ptrmemfunc_type\t\t(tree);\n@@ -6066,7 +6081,7 @@ extern tree implicitly_declare_fn               (special_function_kind, tree,\n extern bool maybe_clone_body\t\t\t(tree);\n \n /* In parser.c */\n-extern tree cp_convert_range_for (tree, tree, tree, bool);\n+extern tree cp_convert_range_for (tree, tree, tree, tree, unsigned int, bool);\n extern bool parsing_nsdmi (void);\n extern void inject_this_parameter (tree, cp_cv_quals);\n "}, {"sha": "f142c1fb9313b60bf70a47d36855e06306c2e8fd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 497, "deletions": 19, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -6074,6 +6074,10 @@ reshape_init (tree type, tree init, tsubst_flags_t complain)\n \treturn error_mark_node;\n     }\n \n+  if (CONSTRUCTOR_IS_DIRECT_INIT (init)\n+      && BRACE_ENCLOSED_INITIALIZER_P (new_init))\n+    CONSTRUCTOR_IS_DIRECT_INIT (new_init) = true;\n+\n   return new_init;\n }\n \n@@ -6254,7 +6258,8 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n       if (type == error_mark_node)\n \treturn NULL_TREE;\n \n-      if ((type_build_ctor_call (type) || CLASS_TYPE_P (type))\n+      if ((type_build_ctor_call (type) || CLASS_TYPE_P (type)\n+\t   || (DECL_DECOMPOSITION_P (decl) && TREE_CODE (type) == ARRAY_TYPE))\n \t  && !(flags & LOOKUP_ALREADY_DIGESTED)\n \t  && !(init && BRACE_ENCLOSED_INITIALIZER_P (init)\n \t       && CP_AGGREGATE_TYPE_P (type)\n@@ -6770,10 +6775,11 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \td_init = build_x_compound_expr_from_list (d_init, ELK_INIT,\n \t\t\t\t\t\t  tf_warning_or_error);\n       d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);\n-      type = TREE_TYPE (decl) = do_auto_deduction (type, d_init,\n-\t\t\t\t\t\t   auto_node,\n-                                                   tf_warning_or_error,\n-                                                   adc_variable_type);\n+      enum auto_deduction_context adc = adc_variable_type;\n+      if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n+\tadc = adc_decomp_type;\n+      type = TREE_TYPE (decl) = do_auto_deduction (type, d_init, auto_node,\n+\t\t\t\t\t\t   tf_warning_or_error, adc);\n       if (type == error_mark_node)\n \treturn;\n       if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -7137,6 +7143,390 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   invoke_plugin_callbacks (PLUGIN_FINISH_DECL, decl);\n }\n \n+/* For class TYPE return itself or some its bases that contain\n+   any direct non-static data members.  Return error_mark_node if an\n+   error has been diagnosed.  */\n+\n+static tree\n+find_decomp_class_base (location_t loc, tree type, tree ret)\n+{\n+  bool member_seen = false;\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n+      continue;\n+    else if (ret)\n+      return type;\n+    else if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+      {\n+\tif (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n+\t  error_at (loc, \"cannot decompose class type %qT because it has an \"\n+\t\t\t \"anonymous struct member\", type);\n+\telse\n+\t  error_at (loc, \"cannot decompose class type %qT because it has an \"\n+\t\t\t \"anonymous union member\", type);\n+\tinform (DECL_SOURCE_LOCATION (field), \"declared here\");\n+\treturn error_mark_node;\n+      }\n+    else if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n+      {\n+\terror_at (loc, \"cannot decompose non-public member %qD of %qT\",\n+\t\t  field, type);\n+\tinform (DECL_SOURCE_LOCATION (field),\n+\t\tTREE_PRIVATE (field) ? \"declared private here\"\n+\t\t: \"declared protected here\");\n+\treturn error_mark_node;\n+      }\n+    else\n+      member_seen = true;\n+\n+  tree base_binfo, binfo;\n+  tree orig_ret = ret;\n+  int i;\n+  if (member_seen)\n+    ret = type;\n+  for (binfo = TYPE_BINFO (type), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    {\n+      tree t = find_decomp_class_base (loc, TREE_TYPE (base_binfo), ret);\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+      if (t != NULL_TREE)\n+\t{\n+\t  if (ret == type)\n+\t    {\n+\t      error_at (loc, \"cannot decompose class type %qT: both it and \"\n+\t\t\t     \"its base class %qT have non-static data members\",\n+\t\t\ttype, t);\n+\t      return error_mark_node;\n+\t    }\n+\t  else if (orig_ret != NULL_TREE)\n+\t    return t;\n+\t  else if (ret == t)\n+\t    /* OK, found the same base along another path.  We'll complain\n+\t       in convert_to_base if it's ambiguous.  */;\n+\t  else if (ret != NULL_TREE)\n+\t    {\n+\t      error_at (loc, \"cannot decompose class type %qT: its base \"\n+\t\t\t     \"classes %qT and %qT have non-static data \"\n+\t\t\t     \"members\", type, ret, t);\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n+\t    ret = t;\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Return std::tuple_size<TYPE>::value.  */\n+\n+tree\n+get_tuple_size (tree type)\n+{\n+  tree args = make_tree_vec (1);\n+  TREE_VEC_ELT (args, 0) = type;\n+  tree inst = lookup_template_class (get_identifier (\"tuple_size\"), args,\n+\t\t\t\t     /*in_decl*/NULL_TREE,\n+\t\t\t\t     /*context*/std_node,\n+\t\t\t\t     /*entering_scope*/false, tf_none);\n+  tree val = lookup_qualified_name (inst, get_identifier (\"value\"),\n+\t\t\t\t    /*type*/false, /*complain*/false);\n+  if (TREE_CODE (val) == VAR_DECL || TREE_CODE (val) == CONST_DECL)\n+    val = maybe_constant_value (val);\n+  if (TREE_CODE (val) == INTEGER_CST)\n+    return val;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Return std::tuple_element<I,TYPE>::type.  */\n+\n+tree\n+get_tuple_element_type (tree type, unsigned i)\n+{\n+  tree args = make_tree_vec (2);\n+  TREE_VEC_ELT (args, 0) = build_int_cst (integer_type_node, i);\n+  TREE_VEC_ELT (args, 1) = type;\n+  tree inst = lookup_template_class (get_identifier (\"tuple_element\"), args,\n+\t\t\t\t     /*in_decl*/NULL_TREE,\n+\t\t\t\t     /*context*/std_node,\n+\t\t\t\t     /*entering_scope*/false,\n+\t\t\t\t     tf_warning_or_error);\n+  return make_typename_type (inst, get_identifier (\"type\"),\n+\t\t\t     none_type, tf_warning_or_error);\n+}\n+\n+/* Return e.get<i>() or get<i>(e).  */\n+\n+tree\n+get_tuple_decomp_init (tree decl, unsigned i)\n+{\n+  tree get_id = get_identifier (\"get\");\n+  tree targs = make_tree_vec (1);\n+  TREE_VEC_ELT (targs, 0) = build_int_cst (integer_type_node, i);\n+\n+  tree etype = TREE_TYPE (decl);\n+  tree e = convert_from_reference (decl);\n+\n+  /* [The id-expression] e is an lvalue if the type of the entity e is an\n+     lvalue reference and an xvalue otherwise.  */\n+  if (TREE_CODE (etype) != REFERENCE_TYPE\n+      || TYPE_REF_IS_RVALUE (etype))\n+    e = move (e);\n+\n+  tree fns = lookup_qualified_name (TREE_TYPE (e), get_id,\n+\t\t\t\t    /*type*/false, /*complain*/false);\n+  if (fns != error_mark_node)\n+    {\n+      fns = lookup_template_function (fns, targs);\n+      return build_new_method_call (e, fns, /*args*/NULL,\n+\t\t\t\t    /*path*/NULL_TREE, LOOKUP_NORMAL,\n+\t\t\t\t    /*fn_p*/NULL, tf_warning_or_error);\n+    }\n+  else\n+    {\n+      vec<tree,va_gc> *args = make_tree_vector_single (e);\n+      fns = lookup_template_function (get_id, targs);\n+      fns = perform_koenig_lookup (fns, args, tf_warning_or_error);\n+      return finish_call_expr (fns, &args, /*novirt*/false,\n+\t\t\t       /*koenig*/true, tf_warning_or_error);\n+    }\n+}\n+\n+/* Finish a decomposition declaration.  DECL is the underlying declaration\n+   \"e\", FIRST is the head of a chain of decls for the individual identifiers\n+   chained through DECL_CHAIN in reverse order and COUNT is the number of\n+   those decls.  */\n+\n+void\n+cp_finish_decomp (tree decl, tree first, unsigned int count)\n+{\n+  location_t loc = DECL_SOURCE_LOCATION (decl);\n+  if (error_operand_p (decl))\n+    {\n+     error_out:\n+      while (count--)\n+\t{\n+\t  TREE_TYPE (first) = error_mark_node;\n+\t  if (DECL_HAS_VALUE_EXPR_P (first))\n+\t    {\n+\t      SET_DECL_VALUE_EXPR (first, NULL_TREE);\n+\t      DECL_HAS_VALUE_EXPR_P (first) = 0;\n+\t    }\n+\t  first = DECL_CHAIN (first);\n+\t}\n+      return;\n+    }\n+\n+  if (type_dependent_expression_p (decl)\n+      /* This happens for range for when not in templates.\n+\t Still add the DECL_VALUE_EXPRs for later processing.  */\n+      || (!processing_template_decl\n+\t  && type_uses_auto (TREE_TYPE (decl))))\n+    {\n+      for (unsigned int i = 0; i < count; i++)\n+\t{\n+\t  if (!DECL_HAS_VALUE_EXPR_P (first))\n+\t    {\n+\t      tree v = build_nt (ARRAY_REF, decl,\n+\t\t\t\t size_int (count - i - 1),\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\t      SET_DECL_VALUE_EXPR (first, v);\n+\t      DECL_HAS_VALUE_EXPR_P (first) = 1;\n+\t    }\n+\t  if (processing_template_decl)\n+\t    {\n+\t      retrofit_lang_decl (first);\n+\t      SET_DECL_DECOMPOSITION_P (first);\n+\t    }\n+\t  first = DECL_CHAIN (first);\n+\t}\n+      return;\n+    }\n+\n+  auto_vec<tree, 16> v;\n+  v.safe_grow (count);\n+  tree d = first;\n+  for (unsigned int i = 0; i < count; i++, d = DECL_CHAIN (d))\n+    {\n+      v[count - i - 1] = d;\n+      if (processing_template_decl)\n+\t{\n+\t  retrofit_lang_decl (d);\n+\t  SET_DECL_DECOMPOSITION_P (d);\n+\t}\n+    }\n+\n+  tree type = TREE_TYPE (decl);\n+  tree eltype = NULL_TREE;\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  unsigned HOST_WIDE_INT eltscnt = 0;\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree nelts;\n+      nelts = array_type_nelts_top (type);\n+      if (nelts == error_mark_node)\n+\tgoto error_out;\n+      if (!tree_fits_uhwi_p (nelts))\n+\t{\n+\t  error_at (loc, \"cannot decompose variable length array %qT\", type);\n+\t  goto error_out;\n+\t}\n+      eltscnt = tree_to_uhwi (nelts);\n+      if (count != eltscnt)\n+\t{\n+       cnt_mismatch:\n+\t  if (count > eltscnt)\n+\t    error_at (loc, \"%u names provided while %qT decomposes into \"\n+\t\t\t   \"%wu elements\", count, type, eltscnt);\n+\t  else\n+\t    error_at (loc, \"only %u names provided while %qT decomposes into \"\n+\t\t\t   \"%wu elements\", count, type, eltscnt);\n+\t  goto error_out;\n+\t}\n+      eltype = TREE_TYPE (type);\n+      for (unsigned int i = 0; i < count; i++)\n+\t{\n+\t  TREE_TYPE (v[i]) = eltype;\n+\t  layout_decl (v[i], 0);\n+\t  tree t = convert_from_reference (decl);\n+\t  t = build4_loc (DECL_SOURCE_LOCATION (v[i]), ARRAY_REF,\n+\t\t\t  eltype, t, size_int (i), NULL_TREE,\n+\t\t\t  NULL_TREE);\n+\t  SET_DECL_VALUE_EXPR (v[i], t);\n+\t  DECL_HAS_VALUE_EXPR_P (v[i]) = 1;\n+\t}\n+    }\n+  /* 2 GNU extensions.  */\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      eltscnt = 2;\n+      if (count != eltscnt)\n+\tgoto cnt_mismatch;\n+      eltype = cp_build_qualified_type (TREE_TYPE (type), TYPE_QUALS (type));\n+      for (unsigned int i = 0; i < count; i++)\n+\t{\n+\t  TREE_TYPE (v[i]) = eltype;\n+\t  layout_decl (v[i], 0);\n+\t  tree t = convert_from_reference (decl);\n+\t  t = build1_loc (DECL_SOURCE_LOCATION (v[i]),\n+\t\t\t  i ? IMAGPART_EXPR : REALPART_EXPR, eltype,\n+\t\t\t  t);\n+\t  SET_DECL_VALUE_EXPR (v[i], t);\n+\t  DECL_HAS_VALUE_EXPR_P (v[i]) = 1;\n+\t}\n+    }\n+  else if (TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      eltscnt = TYPE_VECTOR_SUBPARTS (type);\n+      if (count != eltscnt)\n+\tgoto cnt_mismatch;\n+      eltype = cp_build_qualified_type (TREE_TYPE (type), TYPE_QUALS (type));\n+      for (unsigned int i = 0; i < count; i++)\n+\t{\n+\t  TREE_TYPE (v[i]) = eltype;\n+\t  layout_decl (v[i], 0);\n+\t  tree t = convert_from_reference (decl);\n+\t  convert_vector_to_array_for_subscript (DECL_SOURCE_LOCATION (v[i]),\n+\t\t\t\t\t\t &t, size_int (i));\n+\t  t = build4_loc (DECL_SOURCE_LOCATION (v[i]), ARRAY_REF,\n+\t\t\t  eltype, t, size_int (i), NULL_TREE,\n+\t\t\t  NULL_TREE);\n+\t  SET_DECL_VALUE_EXPR (v[i], t);\n+\t  DECL_HAS_VALUE_EXPR_P (v[i]) = 1;\n+\t}\n+    }\n+  else if (tree tsize = get_tuple_size (type))\n+    {\n+      eltscnt = tree_to_uhwi (tsize);\n+      if (count != eltscnt)\n+\tgoto cnt_mismatch;\n+      for (unsigned i = 0; i < count; ++i)\n+\t{\n+\t  location_t sloc = input_location;\n+\t  location_t dloc = DECL_SOURCE_LOCATION (v[i]);\n+\n+\t  input_location = dloc;\n+\t  tree init = get_tuple_decomp_init (decl, i);\n+\t  tree eltype = (init == error_mark_node ? error_mark_node\n+\t\t\t : get_tuple_element_type (type, i));\n+\t  input_location = sloc;\n+\n+\t  if (init == error_mark_node || eltype == error_mark_node)\n+\t    {\n+\t      inform (dloc, \"in initialization of decomposition variable %qD\",\n+\t\t      v[i]);\n+\t      goto error_out;\n+\t    }\n+\t  eltype = cp_build_reference_type (eltype, !lvalue_p (init));\n+\t  TREE_TYPE (v[i]) = eltype;\n+\t  layout_decl (v[i], 0);\n+\t  if (DECL_HAS_VALUE_EXPR_P (v[i]))\n+\t    {\n+\t      /* In this case the names are variables, not just proxies.  */\n+\t      SET_DECL_VALUE_EXPR (v[i], NULL_TREE);\n+\t      DECL_HAS_VALUE_EXPR_P (v[i]) = 0;\n+\t    }\n+\t  cp_finish_decl (v[i], init, /*constexpr*/false,\n+\t\t\t  /*asm*/NULL_TREE, LOOKUP_NORMAL);\n+\t}\n+    }\n+  else if (TREE_CODE (type) == UNION_TYPE)\n+    {\n+      error_at (loc, \"cannot decompose union type %qT\", type);\n+      goto error_out;\n+    }\n+  else if (!CLASS_TYPE_P (type))\n+    {\n+      error_at (loc, \"cannot decompose non-array non-class type %qT\", type);\n+      goto error_out;\n+    }\n+  else\n+    {\n+      tree btype = find_decomp_class_base (loc, type, NULL_TREE);\n+      if (btype == error_mark_node)\n+\tgoto error_out;\n+      else if (btype == NULL_TREE)\n+\t{\n+\t  error_at (loc, \"cannot decompose class type %qT without non-static \"\n+\t\t\t \"data members\", type);\n+\t  goto error_out;\n+\t}\n+      for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))\n+\tif (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n+\t  continue;\n+\telse\n+\t  eltscnt++;\n+      if (count != eltscnt)\n+\tgoto cnt_mismatch;\n+      tree t = convert_from_reference (decl);\n+      if (type != btype)\n+\t{\n+\t  t = convert_to_base (t, btype, /*check_access*/true,\n+\t\t\t       /*nonnull*/false, tf_warning_or_error);\n+\t  type = btype;\n+\t}\n+      unsigned int i = 0;\n+      for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))\n+\tif (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n+\t  continue;\n+\telse\n+\t  {\n+\t    tree tt = finish_non_static_data_member (field, t, NULL_TREE);\n+\t    tree probe = tt;\n+\t    if (REFERENCE_REF_P (probe))\n+\t      probe = TREE_OPERAND (probe, 0);\n+\t    TREE_TYPE (v[i]) = TREE_TYPE (probe);\n+\t    layout_decl (v[i], 0);\n+\t    SET_DECL_VALUE_EXPR (v[i], tt);\n+\t    DECL_HAS_VALUE_EXPR_P (v[i]) = 1;\n+\t    i++;\n+\t  }\n+    }\n+}\n+\n /* Returns a declaration for a VAR_DECL as if:\n \n      extern \"C\" TYPE NAME;\n@@ -9449,7 +9839,7 @@ grokdeclarator (const cp_declarator *declarator,\n   cp_storage_class storage_class;\n   bool unsigned_p, signed_p, short_p, long_p, thread_p;\n   bool type_was_error_mark_node = false;\n-  bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;\n+  bool parameter_pack_p = declarator ? declarator->parameter_pack_p : false;\n   bool template_type_arg = false;\n   bool template_parm_flag = false;\n   bool typedef_p = decl_spec_seq_has_spec_p (declspecs, ds_typedef);\n@@ -9650,6 +10040,10 @@ grokdeclarator (const cp_declarator *declarator,\n \tcase cdk_ptrmem:\n \t  break;\n \n+\tcase cdk_decomp:\n+\t  name = \"decomposition\";\n+\t  break;\n+\n \tcase cdk_error:\n \t  return error_mark_node;\n \n@@ -9859,15 +10253,15 @@ grokdeclarator (const cp_declarator *declarator,\n   if (explicit_intN)\n     {\n       if (! int_n_enabled_p[declspecs->int_n_idx])\n-       {\n-         error (\"%<__int%d%> is not supported by this target\",\n-\t\tint_n_data[declspecs->int_n_idx].bitsize);\n-         explicit_intN = false;\n-       }\n+\t{\n+\t  error (\"%<__int%d%> is not supported by this target\",\n+\t\t int_n_data[declspecs->int_n_idx].bitsize);\n+\t  explicit_intN = false;\n+\t}\n       else if (pedantic && ! in_system_header_at (input_location))\n-       pedwarn (input_location, OPT_Wpedantic,\n-                \"ISO C++ does not support %<__int%d%> for %qs\",\n-\t\tint_n_data[declspecs->int_n_idx].bitsize,  name);\n+\tpedwarn (input_location, OPT_Wpedantic,\n+\t\t \"ISO C++ does not support %<__int%d%> for %qs\",\n+\t\t int_n_data[declspecs->int_n_idx].bitsize, name);\n     }\n \n   /* Now process the modifiers that were specified\n@@ -10093,6 +10487,79 @@ grokdeclarator (const cp_declarator *declarator,\n       virtualp = 0;\n     }\n \n+  if (innermost_code == cdk_decomp)\n+    {\n+      location_t loc = (declarator->kind == cdk_reference\n+\t\t\t? declarator->declarator->id_loc : declarator->id_loc);\n+      if (inlinep)\n+\terror_at (declspecs->locations[ds_inline],\n+\t\t  \"decomposition declaration cannot be declared %<inline%>\");\n+      if (typedef_p)\n+\terror_at (declspecs->locations[ds_typedef],\n+\t\t  \"decomposition declaration cannot be declared %<typedef%>\");\n+      if (constexpr_p)\n+\terror_at (declspecs->locations[ds_constexpr], \"decomposition \"\n+\t\t  \"declaration cannot be declared %<constexpr%>\");\n+      if (thread_p)\n+\terror_at (declspecs->locations[ds_thread],\n+\t\t  \"decomposition declaration cannot be declared %qs\",\n+\t\t  declspecs->gnu_thread_keyword_p\n+\t\t  ? \"__thread\" : \"thread_local\");\n+      if (concept_p)\n+\terror_at (declspecs->locations[ds_concept],\n+\t\t  \"decomposition declaration cannot be declared %<concept%>\");\n+      switch (storage_class)\n+\t{\n+\tcase sc_none:\n+\t  break;\n+\tcase sc_register:\n+\t  error_at (loc, \"decomposition declaration cannot be declared \"\n+\t\t    \"%<register%>\");\n+\t  break;\n+\tcase sc_static:\n+\t  error_at (loc, \"decomposition declaration cannot be declared \"\n+\t\t    \"%<static%>\");\n+\t  break;\n+\tcase sc_extern:\n+\t  error_at (loc, \"decomposition declaration cannot be declared \"\n+\t\t    \"%<extern%>\");\n+\t  break;\n+\tcase sc_mutable:\n+\t  error_at (loc, \"decomposition declaration cannot be declared \"\n+\t\t    \"%<mutable%>\");\n+\t  break;\n+\tcase sc_auto:\n+\t  error_at (loc, \"decomposition declaration cannot be declared \"\n+\t\t    \"C++98 %<auto%>\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      if (TREE_CODE (type) != TEMPLATE_TYPE_PARM\n+\t  || TYPE_IDENTIFIER (type) != get_identifier (\"auto\"))\n+\t{\n+\t  if (type != error_mark_node)\n+\t    {\n+\t      error_at (loc, \"decomposition declaration cannot be declared \"\n+\t\t\t\"with type %qT\", type);\n+\t      inform (loc,\n+\t\t      \"type must be cv-qualified %<auto%> or reference to \"\n+\t\t      \"cv-qualified %<auto%>\");\n+\t    }\n+\t  type = build_qualified_type (make_auto (), type_quals);\n+\t  declspecs->type = type;\n+\t}\n+      inlinep = 0;\n+      typedef_p = 0;\n+      constexpr_p = 0;\n+      thread_p = 0;\n+      concept_p = 0;\n+      storage_class = sc_none;\n+      staticp = 0;\n+      declspecs->storage_class = sc_none;\n+      declspecs->locations[ds_thread] = UNKNOWN_LOCATION;\n+    }\n+\n   /* Static anonymous unions are dealt with here.  */\n   if (staticp && decl_context == TYPENAME\n       && declspecs->type\n@@ -10232,7 +10699,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t\t\t    attr_flags);\n \t}\n \n-      if (declarator->kind == cdk_id)\n+      if (declarator->kind == cdk_id || declarator->kind == cdk_decomp)\n \tbreak;\n \n       inner_declarator = declarator->declarator;\n@@ -10743,6 +11210,7 @@ grokdeclarator (const cp_declarator *declarator,\n      is non-NULL, we know it is a cdk_id declarator; otherwise, we\n      would not have exited the loop above.  */\n   if (declarator\n+      && declarator->kind == cdk_id\n       && declarator->u.id.qualifying_scope\n       && MAYBE_CLASS_TYPE_P (declarator->u.id.qualifying_scope))\n     {\n@@ -10754,13 +11222,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  if (friendp)\n \t    {\n-\t      permerror (input_location, \"member functions are implicitly friends of their class\");\n+\t      permerror (input_location, \"member functions are implicitly \"\n+\t\t\t\t\t \"friends of their class\");\n \t      friendp = 0;\n \t    }\n \t  else\n \t    permerror (declarator->id_loc, \n-\t\t\t  \"extra qualification %<%T::%> on member %qs\",\n-\t\t\t  ctype, name);\n+\t\t       \"extra qualification %<%T::%> on member %qs\",\n+\t\t       ctype, name);\n \t}\n       else if (/* If the qualifying type is already complete, then we\n \t\t  can skip the following checks.  */\n@@ -11133,7 +11602,8 @@ grokdeclarator (const cp_declarator *declarator,\n   else if (unqualified_id == NULL_TREE && decl_context != PARM\n \t   && decl_context != CATCHPARM\n \t   && TREE_CODE (type) != UNION_TYPE\n-\t   && ! bitfield)\n+\t   && ! bitfield\n+\t   && innermost_code != cdk_decomp)\n     {\n       error (\"abstract declarator %qT used as declaration\", type);\n       return error_mark_node;\n@@ -11719,6 +12189,14 @@ grokdeclarator (const cp_declarator *declarator,\n \n \tif (inlinep)\n \t  mark_inline_variable (decl);\n+\tif (innermost_code == cdk_decomp)\n+\t  {\n+\t    gcc_assert (declarator && declarator->kind == cdk_decomp);\n+\t    DECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n+\t    retrofit_lang_decl (decl);\n+\t    DECL_ARTIFICIAL (decl) = 1;\n+\t    SET_DECL_DECOMPOSITION_P (decl);\n+\t  }\n       }\n \n     if (VAR_P (decl) && !initialized)"}, {"sha": "1fad79cb247b9e06799d5398718fb6d67acd252c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -1575,27 +1575,34 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      tree itype;\n+      tree itype = init ? TREE_TYPE (init) : NULL_TREE;\n+      int from_array = 0;\n \n-      /* An array may not be initialized use the parenthesized\n-\t initialization form -- unless the initializer is \"()\".  */\n-      if (init && TREE_CODE (init) == TREE_LIST)\n+      if (VAR_P (exp) && DECL_DECOMPOSITION_P (exp))\n+\tfrom_array = 1;\n+      else\n \t{\n-          if (complain & tf_error)\n-            error (\"bad array initializer\");\n-\t  return error_mark_node;\n+\t  /* An array may not be initialized use the parenthesized\n+\t     initialization form -- unless the initializer is \"()\".  */\n+\t  if (init && TREE_CODE (init) == TREE_LIST)\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"bad array initializer\");\n+\t      return error_mark_node;\n+\t    }\n+\t  /* Must arrange to initialize each element of EXP\n+\t     from elements of INIT.  */\n+\t  if (cv_qualified_p (type))\n+\t    TREE_TYPE (exp) = cv_unqualified (type);\n+\t  if (itype && cv_qualified_p (itype))\n+\t    TREE_TYPE (init) = cv_unqualified (itype);\n+\t  from_array = (itype && same_type_p (TREE_TYPE (init),\n+\t\t\t\t\t      TREE_TYPE (exp)));\n \t}\n-      /* Must arrange to initialize each element of EXP\n-\t from elements of INIT.  */\n-      itype = init ? TREE_TYPE (init) : NULL_TREE;\n-      if (cv_qualified_p (type))\n-\tTREE_TYPE (exp) = cv_unqualified (type);\n-      if (itype && cv_qualified_p (itype))\n-\tTREE_TYPE (init) = cv_unqualified (itype);\n+\n       stmt_expr = build_vec_init (exp, NULL_TREE, init,\n \t\t\t\t  /*explicit_value_init_p=*/false,\n-\t\t\t\t  itype && same_type_p (TREE_TYPE (init),\n-\t\t\t\t\t\t\tTREE_TYPE (exp)),\n+\t\t\t\t  from_array,\n                                   complain);\n       TREE_READONLY (exp) = was_const;\n       TREE_THIS_VOLATILE (exp) = was_volatile;\n@@ -3891,6 +3898,18 @@ build_vec_init (tree base, tree maxindex, tree init,\n   base = get_temp_regvar (ptype, rval);\n   iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n \n+  bool direct_init = false;\n+  if (from_array && init && BRACE_ENCLOSED_INITIALIZER_P (init)\n+      && CONSTRUCTOR_NELTS (init) == 1)\n+    {\n+      tree elt = CONSTRUCTOR_ELT (init, 0)->value;\n+      if (TREE_CODE (TREE_TYPE (elt)) == ARRAY_TYPE)\n+\t{\n+\t  direct_init = DIRECT_LIST_INIT_P (init);\n+\t  init = elt;\n+\t}\n+    }\n+\n   /* If initializing one array from another, initialize element by\n      element.  We rely upon the below calls to do the argument\n      checking.  Evaluate the initializer before entering the try block.  */\n@@ -4115,6 +4134,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t      from = build1 (INDIRECT_REF, itype, base2);\n \t      if (xvalue)\n \t\tfrom = move (from);\n+\t      if (direct_init)\n+\t\tfrom = build_tree_list (NULL_TREE, from);\n \t    }\n \t  else\n \t    from = NULL_TREE;"}, {"sha": "7ad65b8959905457590b0c06eb30c9c0a2e5fa0a", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -5393,7 +5393,7 @@ add_function (struct arg_lookup *k, tree fn)\n        function templates are ignored.  */;\n   else if (k->fn_set && k->fn_set->add (fn))\n     /* It's already in the list.  */;\n-  else if (!k->functions)\n+  else if (!k->functions && TREE_CODE (fn) != TEMPLATE_DECL)\n     k->functions = fn;\n   else if (fn == k->functions)\n     ;"}, {"sha": "9360ab0cbd69eece8ea1def1a6f23cbb65a8cfad", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 229, "deletions": 10, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -1668,6 +1668,7 @@ declarator_can_be_parameter_pack (cp_declarator *declarator)\n \t{\n \tcase cdk_id:\n \tcase cdk_array:\n+\tcase cdk_decomp:\n \t  found = true;\n \t  break;\n \n@@ -1721,6 +1722,7 @@ function_declarator_p (const cp_declarator *declarator)\n \t  && declarator->declarator->kind == cdk_id)\n \treturn true;\n       if (declarator->kind == cdk_id\n+\t  || declarator->kind == cdk_decomp\n \t  || declarator->kind == cdk_error)\n \treturn false;\n       declarator = declarator->declarator;\n@@ -2200,6 +2202,8 @@ static void cp_parser_static_assert\n   (cp_parser *, bool);\n static tree cp_parser_decltype\n   (cp_parser *);\n+static tree cp_parser_decomposition_declaration\n+  (cp_parser *, cp_decl_specifier_seq *, tree *, location_t *);\n \n /* Declarators [gram.dcl.decl] */\n \n@@ -11471,16 +11475,45 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n \t\t     bool ivdep)\n {\n   tree stmt, range_expr;\n-  cxx_binding *binding = NULL;\n-  tree name = NULL_TREE;\n+  auto_vec <cxx_binding *, 16> bindings;\n+  auto_vec <tree, 16> names;\n+  tree decomp_first_name = NULL_TREE;\n+  unsigned int decomp_cnt = 0;\n \n   /* Get the range declaration momentarily out of the way so that\n      the range expression doesn't clash with it. */\n   if (range_decl != error_mark_node)\n     {\n-      name = DECL_NAME (range_decl);\n-      binding = IDENTIFIER_BINDING (name);\n-      IDENTIFIER_BINDING (name) = binding->previous;\n+      if (DECL_HAS_VALUE_EXPR_P (range_decl))\n+\t{\n+\t  tree v = DECL_VALUE_EXPR (range_decl);\n+\t  /* For decomposition declaration get all of the corresponding\n+\t     declarations out of the way.  */\n+\t  if (TREE_CODE (v) == ARRAY_REF\n+\t      && VAR_P (TREE_OPERAND (v, 0))\n+\t      && DECL_DECOMPOSITION_P (TREE_OPERAND (v, 0)))\n+\t    {\n+\t      tree d = range_decl;\n+\t      range_decl = TREE_OPERAND (v, 0);\n+\t      decomp_cnt = tree_to_uhwi (TREE_OPERAND (v, 1)) + 1;\n+\t      decomp_first_name = d;\n+\t      for (unsigned int i = 0; i < decomp_cnt; i++, d = DECL_CHAIN (d))\n+\t\t{\n+\t\t  tree name = DECL_NAME (d);\n+\t\t  names.quick_push (name);\n+\t\t  bindings.quick_push (IDENTIFIER_BINDING (name));\n+\t\t  IDENTIFIER_BINDING (name)\n+\t\t    = IDENTIFIER_BINDING (name)->previous;\n+\t\t}\n+\t    }\n+\t}\n+      if (names.is_empty ())\n+\t{\n+\t  tree name = DECL_NAME (range_decl);\n+\t  names.quick_push (name);\n+\t  bindings.quick_push (IDENTIFIER_BINDING (name));\n+\t  IDENTIFIER_BINDING (name) = IDENTIFIER_BINDING (name)->previous;\n+\t}\n     }\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n@@ -11491,11 +11524,12 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n   else\n     range_expr = cp_parser_expression (parser);\n \n-  /* Put the range declaration back into scope. */\n-  if (range_decl != error_mark_node)\n+  /* Put the range declaration(s) back into scope. */\n+  for (unsigned int i = 0; i < names.length (); i++)\n     {\n-      binding->previous = IDENTIFIER_BINDING (name);\n-      IDENTIFIER_BINDING (name) = binding;\n+      cxx_binding *binding = bindings[i];\n+      binding->previous = IDENTIFIER_BINDING (names[i]);\n+      IDENTIFIER_BINDING (names[i]) = binding;\n     }\n \n   /* If in template, STMT is converted to a normal for-statement\n@@ -11516,7 +11550,8 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n   else\n     {\n       stmt = begin_for_stmt (scope, init);\n-      stmt = cp_convert_range_for (stmt, range_decl, range_expr, ivdep);\n+      stmt = cp_convert_range_for (stmt, range_decl, range_expr,\n+\t\t\t\t   decomp_first_name, decomp_cnt, ivdep);\n     }\n   return stmt;\n }\n@@ -11608,6 +11643,7 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n \n tree\n cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n+\t\t      tree decomp_first_name, unsigned int decomp_cnt,\n \t\t      bool ivdep)\n {\n   tree begin, end;\n@@ -11681,6 +11717,8 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n \t\t\t\t\ttf_warning_or_error),\n \t\t  /*is_constant_init*/false, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING);\n+  if (VAR_P (range_decl) && DECL_DECOMPOSITION_P (range_decl))\n+    cp_finish_decomp (range_decl, decomp_first_name, decomp_cnt);\n \n   return statement;\n }\n@@ -12554,6 +12592,8 @@ cp_parser_block_declaration (cp_parser *parser,\n \n    simple-declaration:\n      decl-specifier-seq [opt] init-declarator-list [opt] ;\n+     decl-specifier-seq ref-qualifier [opt] [ identifier-list ]\n+       brace-or-equal-initializer ;\n \n    init-declarator-list:\n      init-declarator\n@@ -12639,6 +12679,45 @@ cp_parser_simple_declaration (cp_parser* parser,\n       && !cp_parser_error_occurred (parser))\n     cp_parser_commit_to_tentative_parse (parser);\n \n+  /* Look for C++17 decomposition declaration.  */\n+  for (size_t n = 1; ; n++)\n+    if (cp_lexer_nth_token_is (parser->lexer, n, CPP_AND)\n+\t|| cp_lexer_nth_token_is (parser->lexer, n, CPP_AND_AND))\n+      continue;\n+    else if (cp_lexer_nth_token_is (parser->lexer, n, CPP_OPEN_SQUARE)\n+\t     && !cp_lexer_nth_token_is (parser->lexer, n + 1, CPP_OPEN_SQUARE)\n+\t     && decl_specifiers.any_specifiers_p)\n+      {\n+\ttree decl\n+\t  = cp_parser_decomposition_declaration (parser, &decl_specifiers,\n+\t\t\t\t\t\t maybe_range_for_decl,\n+\t\t\t\t\t\t &init_loc);\n+\n+\t/* The next token should be either a `,' or a `;'.  */\n+\tcp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t/* If it's a `;', we are done.  */\n+\tif (token->type == CPP_SEMICOLON || maybe_range_for_decl)\n+\t  goto finish;\n+\t/* Anything else is an error.  */\n+\telse\n+\t  {\n+\t    /* If we have already issued an error message we don't need\n+\t       to issue another one.  */\n+\t    if ((decl != error_mark_node\n+\t\t && DECL_INITIAL (decl) != error_mark_node)\n+\t\t|| cp_parser_uncommitted_to_tentative_parse_p (parser))\n+\t      cp_parser_error (parser, \"expected %<,%> or %<;%>\");\n+\t    /* Skip tokens until we reach the end of the statement.  */\n+\t    cp_parser_skip_to_end_of_statement (parser);\n+\t    /* If the next token is now a `;', consume it.  */\n+\t    if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t    goto done;\n+\t  }\n+      }\n+    else\n+      break;\n+\n   tree last_type;\n \n   last_type = NULL_TREE;\n@@ -12791,6 +12870,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n     }\n \n   /* Consume the `;'.  */\n+ finish:\n   if (!maybe_range_for_decl)\n     cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n   else if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n@@ -12806,6 +12886,143 @@ cp_parser_simple_declaration (cp_parser* parser,\n   pop_deferring_access_checks ();\n }\n \n+/* Helper of cp_parser_simple_declaration, parse a decomposition declaration.\n+     decl-specifier-seq ref-qualifier [opt] [ identifier-list ]\n+       brace-or-equal-initializer ;  */\n+\n+static tree\n+cp_parser_decomposition_declaration (cp_parser *parser,\n+\t\t\t\t     cp_decl_specifier_seq *decl_specifiers,\n+\t\t\t\t     tree *maybe_range_for_decl,\n+\t\t\t\t     location_t *init_loc)\n+{\n+  cp_ref_qualifier ref_qual = cp_parser_ref_qualifier_opt (parser);\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+  cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);\n+\n+  /* Parse the identifier-list.  */\n+  auto_vec<cp_expr, 10> v;\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_SQUARE))\n+    while (true)\n+      {\n+\tcp_expr e = cp_parser_identifier (parser);\n+\tif (e.get_value () == error_mark_node)\n+\t  break;\n+\tv.safe_push (e);\n+\tif (!cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t  break;\n+\tcp_lexer_consume_token (parser->lexer);\n+      }\n+\n+  location_t end_loc = cp_lexer_peek_token (parser->lexer)->location;\n+  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))\n+    {\n+      end_loc = UNKNOWN_LOCATION;\n+      cp_parser_skip_to_closing_parenthesis_1 (parser, true, CPP_CLOSE_SQUARE,\n+\t\t\t\t\t       false);\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_SQUARE))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\t{\n+\t  cp_parser_skip_to_end_of_statement (parser);\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  if (cxx_dialect < cxx1z)\n+    pedwarn (loc, 0, \"decomposition declaration only available with \"\n+\t\t     \"-std=c++1z or -std=gnu++1z\");\n+\n+  tree pushed_scope;\n+  cp_declarator *declarator = make_declarator (cdk_decomp);\n+  loc = end_loc == UNKNOWN_LOCATION ? loc : make_location (loc, loc, end_loc);\n+  declarator->id_loc = loc;\n+  if (ref_qual != REF_QUAL_NONE)\n+    declarator = make_reference_declarator (TYPE_UNQUALIFIED, declarator,\n+\t\t\t\t\t    ref_qual == REF_QUAL_RVALUE,\n+\t\t\t\t\t    NULL_TREE);\n+  tree decl = start_decl (declarator, decl_specifiers, SD_INITIALIZED,\n+\t\t\t  NULL_TREE, decl_specifiers->attributes,\n+\t\t\t  &pushed_scope);\n+\n+  unsigned int i;\n+  cp_expr e;\n+  cp_decl_specifier_seq decl_specs;\n+  clear_decl_specs (&decl_specs);\n+  decl_specs.type = make_auto ();\n+  tree prev = decl;\n+  FOR_EACH_VEC_ELT (v, i, e)\n+    {\n+      if (i == 0)\n+\tdeclarator = make_id_declarator (NULL_TREE, e.get_value (), sfk_none);\n+      else\n+\tdeclarator->u.id.unqualified_name = e.get_value ();\n+      declarator->id_loc = e.get_location ();\n+      tree elt_pushed_scope;\n+      tree decl2 = start_decl (declarator, &decl_specs, SD_INITIALIZED,\n+\t\t\t       NULL_TREE, NULL_TREE, &elt_pushed_scope);\n+      if (decl2 == error_mark_node)\n+\tdecl = error_mark_node;\n+      else if (decl != error_mark_node && DECL_CHAIN (decl2) != prev)\n+\t{\n+\t  /* Ensure we've diagnosed redeclaration if we aren't creating\n+\t     a new VAR_DECL.  */\n+\t  gcc_assert (errorcount);\n+\t  decl = error_mark_node;\n+\t}\n+      else\n+\tprev = decl2;\n+      if (elt_pushed_scope)\n+\tpop_scope (elt_pushed_scope);\n+    }\n+\n+  if (v.is_empty ())\n+    {\n+      error_at (loc, \"empty decomposition declaration\");\n+      decl = error_mark_node;\n+    }\n+\n+  if (maybe_range_for_decl == NULL\n+      || cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+    {\n+      bool non_constant_p = false, is_direct_init = false;\n+      tree initializer;\n+      *init_loc = cp_lexer_peek_token (parser->lexer)->location;\n+      /* Parse the initializer.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t{\n+\t  initializer = cp_parser_braced_list (parser, &non_constant_p);\n+\t  CONSTRUCTOR_IS_DIRECT_INIT (initializer) = 1;\n+\t  is_direct_init = true;\n+\t}\n+      else\n+\t{\n+\t  /* Consume the `='.  */\n+\t  cp_parser_require (parser, CPP_EQ, RT_EQ);\n+\t  initializer = cp_parser_initializer_clause (parser, &non_constant_p);\n+\t}\n+\n+      if (decl != error_mark_node)\n+\t{\n+\t  cp_finish_decl (decl, initializer, non_constant_p, NULL_TREE,\n+\t\t\t  is_direct_init ? LOOKUP_NORMAL : LOOKUP_IMPLICIT);\n+\t  cp_finish_decomp (decl, prev, v.length ());\n+\t}\n+    }\n+  else if (decl != error_mark_node)\n+    {\n+      *maybe_range_for_decl = prev;\n+      /* Ensure DECL_VALUE_EXPR is created for all the decls but\n+\t the underlying DECL.  */\n+      cp_finish_decomp (decl, prev, v.length ());\n+    }\n+\n+  if (pushed_scope)\n+    pop_scope (pushed_scope);\n+\n+  return decl;\n+}\n+\n /* Parse a decl-specifier-seq.\n \n    decl-specifier-seq:\n@@ -18628,6 +18845,7 @@ strip_declarator_types (tree type, cp_declarator *declarator)\n     switch (d->kind)\n       {\n       case cdk_id:\n+      case cdk_decomp:\n       case cdk_error:\n \td = NULL;\n \tbreak;\n@@ -25502,6 +25720,7 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n       return (cp_parser_check_declarator_template_parameters\n \t      (parser, declarator->declarator, declarator_location));\n \n+    case cdk_decomp:\n     case cdk_error:\n       return true;\n "}, {"sha": "7eeb27ddd1cca0fff8dcb825df37884b8ddbc98d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -15311,6 +15311,55 @@ tsubst_find_omp_teams (tree *tp, int *walk_subtrees, void *)\n   return NULL_TREE;\n }\n \n+/* Helper function for tsubst_expr.  For decomposition declaration\n+   artificial base DECL, which is tsubsted PATTERN_DECL, tsubst\n+   also the corresponding decls representing the identifiers\n+   of the decomposition declaration.  Return DECL if successful\n+   or error_mark_node otherwise, set *FIRST to the first decl\n+   in the list chained through DECL_CHAIN and *CNT to the number\n+   of such decls.  */\n+\n+static tree\n+tsubst_decomp_names (tree decl, tree pattern_decl, tree args,\n+\t\t     tsubst_flags_t complain, tree in_decl, tree *first,\n+\t\t     unsigned int *cnt)\n+{\n+  tree decl2, decl3, prev = decl;\n+  *cnt = 0;\n+  gcc_assert (DECL_NAME (decl) == NULL_TREE);\n+  for (decl2 = DECL_CHAIN (pattern_decl);\n+       decl2\n+       && VAR_P (decl2)\n+       && DECL_DECOMPOSITION_P (decl2)\n+       && DECL_NAME (decl2);\n+       decl2 = DECL_CHAIN (decl2))\n+    {\n+      (*cnt)++;\n+      gcc_assert (DECL_HAS_VALUE_EXPR_P (decl2));\n+      tree v = DECL_VALUE_EXPR (decl2);\n+      DECL_HAS_VALUE_EXPR_P (decl2) = 0;\n+      SET_DECL_VALUE_EXPR (decl2, NULL_TREE);\n+      decl3 = tsubst (decl2, args, complain, in_decl);\n+      SET_DECL_VALUE_EXPR (decl2, v);\n+      DECL_HAS_VALUE_EXPR_P (decl2) = 1;\n+      if (VAR_P (decl3))\n+\tDECL_TEMPLATE_INSTANTIATED (decl3) = 1;\n+      maybe_push_decl (decl3);\n+      if (error_operand_p (decl3))\n+\tdecl = error_mark_node;\n+      else if (decl != error_mark_node\n+\t       && DECL_CHAIN (decl3) != prev)\n+\t{\n+\t  gcc_assert (errorcount);\n+\t  decl = error_mark_node;\n+\t}\n+      else\n+\tprev = decl3;\n+    }\n+  *first = prev;\n+  return decl;\n+}\n+\n /* Like tsubst_copy for expressions, etc. but also does semantic\n    processing.  */\n \n@@ -15454,6 +15503,16 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t      const_init = (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P\n \t\t\t\t    (pattern_decl));\n \t\t    cp_finish_decl (decl, init, const_init, NULL_TREE, 0);\n+\t\t    if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n+\t\t      {\n+\t\t\tunsigned int cnt;\n+\t\t\ttree first;\n+\t\t\tdecl = tsubst_decomp_names (decl, pattern_decl, args,\n+\t\t\t\t\t\t    complain, in_decl, &first,\n+\t\t\t\t\t\t    &cnt);\n+\t\t\tif (decl != error_mark_node)\n+\t\t\t  cp_finish_decomp (decl, first, cnt);\n+\t\t      }\n \t\t  }\n \t      }\n \t  }\n@@ -15481,7 +15540,18 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n         decl = tsubst (decl, args, complain, in_decl);\n         maybe_push_decl (decl);\n         expr = RECUR (RANGE_FOR_EXPR (t));\n-        stmt = cp_convert_range_for (stmt, decl, expr, RANGE_FOR_IVDEP (t));\n+\tif (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n+\t  {\n+\t    unsigned int cnt;\n+\t    tree first;\n+\t    decl = tsubst_decomp_names (decl, RANGE_FOR_DECL (t), args,\n+\t\t\t\t\tcomplain, in_decl, &first, &cnt);\n+\t    stmt = cp_convert_range_for (stmt, decl, expr, first, cnt,\n+\t\t\t\t\t RANGE_FOR_IVDEP (t));\n+\t  }\n+\telse\n+\t  stmt = cp_convert_range_for (stmt, decl, expr, NULL_TREE, 0,\n+\t\t\t\t       RANGE_FOR_IVDEP (t));\n         RECUR (RANGE_FOR_BODY (t));\n         finish_for_stmt (stmt);\n       }\n@@ -24800,7 +24870,15 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \n   init = resolve_nondeduced_context (init, complain);\n \n-  if (AUTO_IS_DECLTYPE (auto_node))\n+  if (context == adc_decomp_type\n+      && auto_node == type\n+      && init != error_mark_node\n+      && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)\n+    /* [dcl.decomp]/1 - if decomposition declaration has no ref-qualifiers\n+       and initializer has array type, deduce cv-qualified array type.  */\n+    return cp_build_qualified_type_real (TREE_TYPE (init), TYPE_QUALS (type),\n+\t\t\t\t\t complain);\n+  else if (AUTO_IS_DECLTYPE (auto_node))\n     {\n       bool id = (DECL_P (init)\n \t\t || ((TREE_CODE (init) == COMPONENT_REF\n@@ -24885,6 +24963,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n                     error(\"placeholder constraints not satisfied\");\n                     break;\n                   case adc_variable_type:\n+\t\t  case adc_decomp_type:\n                     error (\"deduced initializer does not satisfy \"\n                            \"placeholder constraints\");\n                     break;\n@@ -24893,7 +24972,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n                            \"placeholder constraints\");\n                     break;\n                   case adc_requirement:\n-                    error (\"deduced expression type does not saatisy \"\n+\t\t    error (\"deduced expression type does not satisfy \"\n                            \"placeholder constraints\");\n                     break;\n                   }"}, {"sha": "0164f2e5c7478a658410d5c9eedab19b12a2fe7d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -8873,6 +8873,9 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n       if (identifier_p (expr))\n         expr = lookup_name (expr);\n \n+      if (VAR_P (expr) && DECL_HAS_VALUE_EXPR_P (expr))\n+\texpr = DECL_VALUE_EXPR (expr);\n+\n       if (INDIRECT_REF_P (expr))\n         /* This can happen when the expression is, e.g., \"a.b\". Just\n            look at the underlying operand.  */"}, {"sha": "c59543768a80e28640c7339b163a34d885fd42d7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -142,6 +142,9 @@ lvalue_kind (const_tree ref)\n \treturn clk_none;\n       /* FALLTHRU */\n     case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (ref))\n+\treturn lvalue_kind (DECL_VALUE_EXPR (CONST_CAST_TREE (ref)));\n+\n       if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n \t  && DECL_LANG_SPECIFIC (ref)\n \t  && DECL_IN_AGGR_P (ref))\n@@ -1012,6 +1015,13 @@ tree\n cp_build_reference_type (tree to_type, bool rval)\n {\n   tree lvalue_ref, t;\n+\n+  if (TREE_CODE (to_type) == REFERENCE_TYPE)\n+    {\n+      rval = rval && TYPE_REF_IS_RVALUE (to_type);\n+      to_type = TREE_TYPE (to_type);\n+    }\n+\n   lvalue_ref = build_reference_type (to_type);\n   if (!rval)\n     return lvalue_ref;"}, {"sha": "2d8b7b104406ec53e84319c283d2270283671f24", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -1885,6 +1885,12 @@ is_bitfield_expr_with_lowered_type (const_tree exp)\n \treturn DECL_BIT_FIELD_TYPE (field);\n       }\n \n+    case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (exp))\n+\treturn is_bitfield_expr_with_lowered_type (DECL_VALUE_EXPR\n+\t\t\t\t\t\t   (CONST_CAST_TREE (exp)));\n+      return NULL_TREE;\n+\n     CASE_CONVERT:\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (exp, 0)))\n \t  == TYPE_MAIN_VARIANT (TREE_TYPE (exp)))"}, {"sha": "79a418fa31ef77cb88dec2e7e91431d3248551d7", "filename": "gcc/match.pd", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -2547,8 +2547,15 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     (with\n      {\n        int equal = 2;\n-       if (decl_in_symtab_p (base0)\n-\t   && decl_in_symtab_p (base1))\n+       /* Punt in GENERIC on variables with value expressions;\n+\t  the value expressions might point to fields/elements\n+\t  of other vars etc.  */\n+       if (GENERIC\n+\t   && ((VAR_P (base0) && DECL_HAS_VALUE_EXPR_P (base0))\n+\t       || (VAR_P (base1) && DECL_HAS_VALUE_EXPR_P (base1))))\n+\t ;\n+       else if (decl_in_symtab_p (base0)\n+\t\t&& decl_in_symtab_p (base1))\n          equal = symtab_node::get_create (base0)\n \t           ->equal_address_to (symtab_node::get_create (base1));\n        else if ((DECL_P (base0)"}, {"sha": "d2e538236bde6a1bb25c4e30492517aa4afa6c61", "filename": "gcc/testsuite/g++.dg/parse/parser-pr14875-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fparser-pr14875-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f40fea6a317d7be82d1f02defb59381c7752e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fparser-pr14875-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fparser-pr14875-2.C?ref=70f40fea6a317d7be82d1f02defb59381c7752e7", "patch": "@@ -15,7 +15,7 @@\n   CHECK (xor_eq);   // { dg-error \"before .xor_eq. token\" }\n #undef CHECK\n #define CHECK(x)  int x\n-  CHECK (<:);     // { dg-error \"before .<:. token\" }\n+  CHECK (<:);     // { dg-error \"\" }\n   CHECK (:>);     // { dg-error \"before .:>. token\" }\n #undef CHECK\n #define CHECK(x)  x"}]}