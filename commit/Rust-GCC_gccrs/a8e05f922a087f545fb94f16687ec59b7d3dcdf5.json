{"sha": "a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlMDVmOTIyYTA4N2Y1NDVmYjk0ZjE2Njg3ZWM1OWI3ZDNkY2RmNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-22T07:57:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-22T07:57:09Z"}, "message": "decl.c (gnat_to_gnu_entity): Compute is_type predicate on entry.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Compute is_type predicate\n\ton entry.  Defer common processing for types.  Reorder and clean up.\n\tCompute the equivalent GNAT node and the default size for types only.\n\t<E_Modular_Integer_Type>: Directly use Esize for the type's precision.\n\t<E_Access_Type>: For an unconstrained designated type, do not pretend\n\tthat a dummy type is always made.\n\t<all> Fix nits in comments.\n\t(validate_size): Fix formatting nits and comments.\n\t(set_rm_size): Likewise.\n\t* gcc-interface/utils.c (create_param_decl): Replace bogus argument\n\tpassed to TARGET_PROMOTE_PROTOTYPES hook.\n\nFrom-SVN: r146549", "tree": {"sha": "4d38300c733c45da31a1586e79179ec7f40fc2b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d38300c733c45da31a1586e79179ec7f40fc2b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e05f922a087f545fb94f16687ec59b7d3dcdf5/comments", "author": null, "committer": null, "parents": [{"sha": "3ad606bc1137d266e492308ba884474b69069a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad606bc1137d266e492308ba884474b69069a5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad606bc1137d266e492308ba884474b69069a5b"}], "stats": {"total": 311, "additions": 156, "deletions": 155}, "files": [{"sha": "f2686b8e4557915ecf48cf29bac91e7407d73d08", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e05f922a087f545fb94f16687ec59b7d3dcdf5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e05f922a087f545fb94f16687ec59b7d3dcdf5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "patch": "@@ -1,3 +1,17 @@\n+2009-04-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Compute is_type predicate\n+\ton entry.  Defer common processing for types.  Reorder and clean up.\n+\tCompute the equivalent GNAT node and the default size for types only.\n+\t<E_Modular_Integer_Type>: Directly use Esize for the type's precision.\n+\t<E_Access_Type>: For an unconstrained designated type, do not pretend\n+\tthat a dummy type is always made.\n+\t<all> Fix nits in comments.\n+\t(validate_size): Fix formatting nits and comments.\n+\t(set_rm_size): Likewise.\n+\t* gcc-interface/utils.c (create_param_decl): Replace bogus argument\n+\tpassed to TARGET_PROMOTE_PROTOTYPES hook.\n+\n 2009-04-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fe.h (Get_External_Name): Declare.\n@@ -9,13 +23,13 @@\n \ttypes associated with unconstrained array types.\n \t(make_aligning_type): Adjust for above renaming.\n \t(maybe_pad_type): Likewise.\n-\t(components_to_record): Likewise. \ufffdUse get_identifier_with_length for\n+\t(components_to_record): Likewise.  Use get_identifier_with_length for\n \tthe encoding of the variant.\n \t(get_entity_name): Use get_identifier_with_length.\n-\t(create_concat_name): Likewise. \ufffdUse Get_External_Name if no suffix.\n+\t(create_concat_name): Likewise.  Use Get_External_Name if no suffix.\n \tDo not fiddle with Name_Buffer.\n \t(concat_id_with_name): Rename to...\n-\t(concat_name): ...this. \ufffdUse get_identifier_with_length. \ufffdDo not fiddle\n+\t(concat_name): ...this.  Use get_identifier_with_length.  Do not fiddle\n \twith Name_Buffer.\n \t* gcc-interface/utils.c (rest_of_record_type_compilation): Adjust for\n \tabove renaming."}, {"sha": "c13c641f940b06bac86bb4be12d8e86d21127fe2", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 131, "deletions": 141, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e05f922a087f545fb94f16687ec59b7d3dcdf5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e05f922a087f545fb94f16687ec59b7d3dcdf5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "patch": "@@ -172,9 +172,14 @@ static void rest_of_type_decl_compilation_no_defer (tree);\n tree\n gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n {\n-  Entity_Id gnat_equiv_type = Gigi_Equivalent_Type (gnat_entity);\n+  /* Contains the kind of the input GNAT node.  */\n+  const Entity_Kind kind = Ekind (gnat_entity);\n+  /* True if this is a type.  */\n+  const bool is_type = IN (kind, Type_Kind);\n+  /* For a type, contains the equivalent GNAT node to be used in gigi.  */\n+  Entity_Id gnat_equiv_type = Empty;\n+  /* Temporary used to walk the GNAT tree.  */\n   Entity_Id gnat_temp;\n-  Entity_Kind kind = Ekind (gnat_entity);\n   /* Contains the GCC DECL node which is equivalent to the input GNAT node.\n      This node will be associated with the GNAT node by calling at the end\n      of the `switch' statement.  */\n@@ -201,30 +206,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   /* True if this entity is to be considered as imported.  */\n   bool imported_p = (Is_Imported (gnat_entity)\n \t\t     && No (Address_Clause (gnat_entity)));\n-  unsigned int esize, align = 0;\n+  /* Size and alignment of the GCC node, if meaningful.  */\n+  unsigned int esize = 0, align = 0;\n+  /* Contains the list of attributes directly attached to the entity.  */\n   struct attrib *attr_list = NULL;\n \n-  /* First compute a default value for the size of the entity.  */\n-  if (Known_Esize (gnat_entity) && UI_Is_In_Int_Range (Esize (gnat_entity)))\n-    {\n-      unsigned int max_esize;\n-      esize = UI_To_Int (Esize (gnat_entity));\n-\n-      if (IN (kind, Float_Kind))\n-\tmax_esize = fp_prec_to_size (LONG_DOUBLE_TYPE_SIZE);\n-      else if (IN (kind, Access_Kind))\n-\tmax_esize = POINTER_SIZE * 2;\n-      else\n-\tmax_esize = LONG_LONG_TYPE_SIZE;\n-\n-      esize = MIN (esize, max_esize);\n-    }\n-  else\n-    esize = LONG_LONG_TYPE_SIZE;\n-\n   /* Since a use of an Itype is a definition, process it as such if it\n      is not in a with'ed unit.  */\n   if (!definition\n+      && is_type\n       && Is_Itype (gnat_entity)\n       && !present_gnu_tree (gnat_entity)\n       && In_Extended_Main_Code_Unit (gnat_entity))\n@@ -267,21 +257,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \t}\n \n-      /* This abort means the entity has an incorrect scope, i.e. that its\n+      /* This abort means the Itype has an incorrect scope, i.e. that its\n \t scope does not correspond to the subprogram it is declared in.  */\n       gcc_unreachable ();\n     }\n \n-  /* If the entiy is not present, something went badly wrong.  */\n-  gcc_assert (Present (gnat_entity));\n-\n   /* If we've already processed this entity, return what we got last time.\n      If we are defining the node, we should not have already processed it.\n      In that case, we will abort below when we try to save a new GCC tree\n      for this object.  We also need to handle the case of getting a dummy\n      type when a Full_View exists.  */\n-  if (present_gnu_tree (gnat_entity)\n-      && (!definition || (Is_Type (gnat_entity) && imported_p)))\n+  if ((!definition || (is_type && imported_p))\n+      && present_gnu_tree (gnat_entity))\n     {\n       gnu_decl = get_gnu_tree (gnat_entity);\n \n@@ -311,46 +298,76 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      || kind == E_Access_Subtype)));\n \n   /* The RM size must be specified for all discrete and fixed-point types.  */\n-  gcc_assert (!IN (kind, Discrete_Or_Fixed_Point_Kind)\n-\t      || !Unknown_RM_Size (gnat_entity));\n+  gcc_assert (!(IN (kind, Discrete_Or_Fixed_Point_Kind)\n+\t\t&& Unknown_RM_Size (gnat_entity)));\n+\n+  /* If we get here, it means we have not yet done anything with this entity.\n+     If we are not defining it, it must be a type or an entity that is defined\n+     elsewhere or externally, otherwise we should have defined it already.  */\n+  gcc_assert (definition\n+\t      || type_annotate_only\n+\t      || is_type\n+\t      || kind == E_Discriminant\n+\t      || kind == E_Component\n+\t      || kind == E_Label\n+\t      || (kind == E_Constant && Present (Full_View (gnat_entity)))\n+\t      || Is_Public (gnat_entity));\n \n   /* Get the name of the entity and set up the line number and filename of\n      the original definition for use in any decl we make.  */\n   gnu_entity_name = get_entity_name (gnat_entity);\n   Sloc_to_locus (Sloc (gnat_entity), &input_location);\n \n-  /* If we get here, it means we have not yet done anything with this\n-     entity.  If we are not defining it here, it must be external,\n-     otherwise we should have defined it already.  */\n-  gcc_assert (definition || Is_Public (gnat_entity) || type_annotate_only\n-\t      || kind == E_Discriminant || kind == E_Component\n-\t      || kind == E_Label\n-\t      || (kind == E_Constant && Present (Full_View (gnat_entity)))\n-\t      || IN (kind, Type_Kind));\n-\n   /* For cases when we are not defining (i.e., we are referencing from\n      another compilation unit) public entities, show we are at global level\n      for the purpose of computing scopes.  Don't do this for components or\n      discriminants since the relevant test is whether or not the record is\n      being defined.  */\n   if (!definition\n-      && Is_Public (gnat_entity)\n-      && !Is_Statically_Allocated (gnat_entity)\n       && kind != E_Component\n-      && kind != E_Discriminant)\n+      && kind != E_Discriminant\n+      && Is_Public (gnat_entity)\n+      && !Is_Statically_Allocated (gnat_entity))\n     force_global++, this_global = true;\n \n   /* Handle any attributes directly attached to the entity.  */\n   if (Has_Gigi_Rep_Item (gnat_entity))\n     prepend_attributes (gnat_entity, &attr_list);\n \n-  /* Machine_Attributes on types are expected to be propagated to subtypes.\n-     The corresponding Gigi_Rep_Items are only attached to the first subtype\n-     though, so we handle the propagation here.  */\n-  if (Is_Type (gnat_entity) && Base_Type (gnat_entity) != gnat_entity\n-      && !Is_First_Subtype (gnat_entity)\n-      && Has_Gigi_Rep_Item (First_Subtype (Base_Type (gnat_entity))))\n-    prepend_attributes (First_Subtype (Base_Type (gnat_entity)), &attr_list);\n+  /* Do some common processing for types.  */\n+  if (is_type)\n+    {\n+      /* Compute the equivalent type to be used in gigi.  */\n+      gnat_equiv_type = Gigi_Equivalent_Type (gnat_entity);\n+\n+      /* Machine_Attributes on types are expected to be propagated to\n+\t subtypes.  The corresponding Gigi_Rep_Items are only attached\n+\t to the first subtype though, so we handle the propagation here.  */\n+      if (Base_Type (gnat_entity) != gnat_entity\n+\t  && !Is_First_Subtype (gnat_entity)\n+\t  && Has_Gigi_Rep_Item (First_Subtype (Base_Type (gnat_entity))))\n+\tprepend_attributes (First_Subtype (Base_Type (gnat_entity)),\n+\t\t\t    &attr_list);\n+\n+      /* Compute a default value for the size of the type.  */\n+      if (Known_Esize (gnat_entity)\n+\t  && UI_Is_In_Int_Range (Esize (gnat_entity)))\n+\t{\n+\t  unsigned int max_esize;\n+\t  esize = UI_To_Int (Esize (gnat_entity));\n+\n+\t  if (IN (kind, Float_Kind))\n+\t    max_esize = fp_prec_to_size (LONG_DOUBLE_TYPE_SIZE);\n+\t  else if (IN (kind, Access_Kind))\n+\t    max_esize = POINTER_SIZE * 2;\n+\t  else\n+\t    max_esize = LONG_LONG_TYPE_SIZE;\n+\n+\t  esize = MIN (esize, max_esize);\n+\t}\n+      else\n+\tesize = LONG_LONG_TYPE_SIZE;\n+    }\n \n   switch (kind)\n     {\n@@ -695,8 +712,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t && !TREE_OVERFLOW (TYPE_SIZE (gnu_type))))\n \t    && (!Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n \t\t|| !Is_Array_Type (Etype (gnat_entity)))\n-\t    && !Present (Renamed_Object (gnat_entity))\n-\t    && !Present (Address_Clause (gnat_entity)))\n+\t    && No (Renamed_Object (gnat_entity))\n+\t    && No (Address_Clause (gnat_entity)))\n \t  gnu_size = bitsize_unit_node;\n \n \t/* If this is an object with no specified size and alignment, and\n@@ -1333,8 +1350,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   for these.  */\n \tif (TREE_CODE (gnu_decl) == CONST_DECL\n \t    && (definition || Sloc (gnat_entity) > Standard_Location)\n-\t    && ((Is_Public (gnat_entity)\n-\t\t && !Present (Address_Clause (gnat_entity)))\n+\t    && ((Is_Public (gnat_entity) && No (Address_Clause (gnat_entity)))\n \t\t|| !optimize\n \t\t|| Address_Taken (gnat_entity)\n \t\t|| Is_Aliased (gnat_entity)\n@@ -1395,32 +1411,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Enumeration_Type:\n-      /* A special case, for the types Character and Wide_Character in\n+      /* A special case: for the types Character and Wide_Character in\n \t Standard, we do not list all the literals.  So if the literals\n \t are not specified, make this an unsigned type.  */\n       if (No (First_Literal (gnat_entity)))\n \t{\n \t  gnu_type = make_unsigned_type (esize);\n \t  TYPE_NAME (gnu_type) = gnu_entity_name;\n \n-\t  /* Set TYPE_STRING_FLAG for Ada Character and Wide_Character types.\n+\t  /* Set TYPE_STRING_FLAG for Character and Wide_Character types.\n \t     This is needed by the DWARF-2 back-end to distinguish between\n \t     unsigned integer types and character types.  */\n \t  TYPE_STRING_FLAG (gnu_type) = 1;\n \t  break;\n \t}\n \n-      /* Normal case of non-character type, or non-Standard character type */\n+      /* Normal case of non-character type or non-Standard character type.  */\n       {\n \t/* Here we have a list of enumeral constants in First_Literal.\n \t   We make a CONST_DECL for each and build into GNU_LITERAL_LIST\n-\t   the list to be places into TYPE_FIELDS.  Each node in the list\n-\t   is a TREE_LIST node whose TREE_VALUE is the literal name\n-\t   and whose TREE_PURPOSE is the value of the literal.\n-\n-\t   Esize contains the number of bits needed to represent the enumeral\n-\t   type, Type_Low_Bound also points to the first literal and\n-\t   Type_High_Bound points to the last literal.  */\n+\t   the list to be placed into TYPE_FIELDS.  Each node in the list\n+\t   is a TREE_LIST whose TREE_VALUE is the literal name and whose\n+\t   TREE_PURPOSE is the value of the literal.  */\n \n \tEntity_Id gnat_literal;\n \ttree gnu_literal_list = NULL_TREE;\n@@ -1451,8 +1463,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_VALUES (gnu_type) = nreverse (gnu_literal_list);\n \n \t/* Note that the bounds are updated at the end of this function\n-\t   because to avoid an infinite recursion when we get the bounds of\n-\t   this type, since those bounds are objects of this type.    */\n+\t   to avoid an infinite recursion since they refer to the type.  */\n       }\n       break;\n \n@@ -1469,19 +1480,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* For modular types, make the unsigned type of the proper number\n \t   of bits and then set up the modulus, if required.  */\n \ttree gnu_modulus, gnu_high = NULL_TREE;\n-\tenum machine_mode mode;\n \n \t/* Packed array types are supposed to be subtypes only.  */\n \tgcc_assert (!Is_Packed_Array_Type (gnat_entity));\n \n-\t/* Find the smallest mode at least ESIZE bits wide and make a class\n-\t   using that mode.  */\n-\tfor (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t     GET_MODE_BITSIZE (mode) < esize;\n-\t     mode = GET_MODE_WIDER_MODE (mode))\n-\t  ;\n-\n-\tgnu_type = make_unsigned_type (GET_MODE_BITSIZE (mode));\n+\tgnu_type = make_unsigned_type (esize);\n \n \t/* Get the modulus in this type.  If it overflows, assume it is because\n \t   it is equal to 2**Esize.  Note that there is no overflow checking\n@@ -1497,24 +1500,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    convert (gnu_type, integer_one_node));\n \t  }\n \n-\t/* If we have to set TYPE_PRECISION different from its natural value,\n-\t   make a subtype to do do.  Likewise if there is a modulus and\n-\t   it is not one greater than TYPE_MAX_VALUE.  */\n-\tif (TYPE_PRECISION (gnu_type) != esize\n-\t    || (TYPE_MODULAR_P (gnu_type)\n-\t\t&& !tree_int_cst_equal (TYPE_MAX_VALUE (gnu_type), gnu_high)))\n+\t/* If the upper bound is not maximal, make an extra subtype.  */\n+\tif (gnu_high\n+\t    && !tree_int_cst_equal (gnu_high, TYPE_MAX_VALUE (gnu_type)))\n \t  {\n-\t    tree gnu_subtype = make_node (INTEGER_TYPE);\n-\t    TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"UMT\");\n+\t    tree gnu_subtype = make_unsigned_type (esize);\n+\t    TYPE_MAX_VALUE (gnu_subtype) = gnu_high;\n \t    TREE_TYPE (gnu_subtype) = gnu_type;\n-\t    TYPE_MIN_VALUE (gnu_subtype) = TYPE_MIN_VALUE (gnu_type);\n-\t    TYPE_MAX_VALUE (gnu_subtype)\n-\t      = TYPE_MODULAR_P (gnu_type)\n-\t\t? gnu_high : TYPE_MAX_VALUE (gnu_type);\n-\t    TYPE_PRECISION (gnu_subtype) = esize;\n-\t    TYPE_UNSIGNED (gnu_subtype) = 1;\n \t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n-\t    layout_type (gnu_subtype);\n+\t    TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"UMT\");\n \t    gnu_type = gnu_subtype;\n \t  }\n       }\n@@ -1526,20 +1520,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Ordinary_Fixed_Point_Subtype:\n     case E_Decimal_Fixed_Point_Subtype:\n \n-      /* For integral subtypes, we make a new INTEGER_TYPE.  Note\n-\t that we do not want to call build_range_type since we would\n-\t like each subtype node to be distinct.  This will be important\n-\t when memory aliasing is implemented.\n+      /* For integral subtypes, we make a new INTEGER_TYPE.  Note hat we do\n+\t not want to call build_range_type since we would like each subtype\n+\t node to be distinct.  This will be important when memory aliasing\n+\t is implemented.\n \n-\t The TREE_TYPE field of the INTEGER_TYPE we make points to the\n-\t parent type; this fact is used by the arithmetic conversion\n-\t functions.\n+\t The TREE_TYPE field of the INTEGER_TYPE points to the base type;\n+\t this fact is used by the arithmetic conversion functions.\n \n-\t We elaborate the Ancestor_Subtype if it is not in the current\n-\t unit and one of our bounds is non-static.  We do this to ensure\n-\t consistent naming in the case where several subtypes share the same\n-\t bounds by always elaborating the first such subtype first, thus\n-\t using its name.  */\n+\t We elaborate the Ancestor_Subtype if it is not in the current unit\n+\t and one of our bounds is non-static.  We do this to ensure consistent\n+\t naming in the case where several subtypes share the same bounds, by\n+\t elaborating the first such subtype first, thus using its name.  */\n \n       if (!definition\n \t  && Present (Ancestor_Subtype (gnat_entity))\n@@ -3376,15 +3368,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    && ! present_gnu_tree (gnat_desig_equiv))\n \t\t|| (in_main_unit && is_from_limited_with\n \t\t    && Present (Freeze_Node (gnat_desig_rep)))))\n-  \t  {\n-\t    tree gnu_old\n-\t      = (present_gnu_tree (gnat_desig_rep)\n-\t\t ? TREE_TYPE (get_gnu_tree (gnat_desig_rep))\n-\t\t : make_dummy_type (gnat_desig_rep));\n-\t    tree fields;\n+\t  {\n+\t    tree gnu_old;\n \n-\t    /* Show the dummy we get will be a fat pointer.  */\n-\t    got_fat_p = made_dummy = true;\n+\t    if (present_gnu_tree (gnat_desig_rep))\n+\t      gnu_old = TREE_TYPE (get_gnu_tree (gnat_desig_rep));\n+\t    else\n+\t      {\n+\t\tgnu_old = make_dummy_type (gnat_desig_rep);\n+\n+\t\t/* Show the dummy we get will be a fat pointer.  */\n+\t\tgot_fat_p = made_dummy = true;\n+\t      }\n \n \t    /* If the call above got something that has a pointer, that\n \t       pointer is our type.  This could have happened either\n@@ -3397,6 +3392,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\ttree gnu_ptr_template = build_pointer_type (gnu_template_type);\n \t\ttree gnu_array_type = make_node (ENUMERAL_TYPE);\n \t\ttree gnu_ptr_array = build_pointer_type (gnu_array_type);\n+\t\ttree fields;\n \n \t\tTYPE_NAME (gnu_template_type)\n \t\t  = create_concat_name (gnat_desig_equiv, \"XUB\");\n@@ -4319,8 +4315,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   /* If we are processing a type and there is either no decl for it or\n      we just made one, do some common processing for the type, such as\n      handling alignment and possible padding.  */\n-\n-  if ((!gnu_decl || this_made_decl) && IN (kind, Type_Kind))\n+  if (is_type && (!gnu_decl || this_made_decl))\n     {\n       if (Is_Tagged_Type (gnat_entity)\n \t  || Is_Class_Wide_Equivalent_Type (gnat_entity))\n@@ -4531,7 +4526,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTREE_TYPE (gnu_decl) = gnu_type;\n     }\n \n-  if (IN (kind, Type_Kind) && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n+  if (is_type && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n     {\n       gnu_type = TREE_TYPE (gnu_decl);\n \n@@ -4639,10 +4634,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   /* If this is an enumeral or floating-point type, we were not able to set\n      the bounds since they refer to the type.  These bounds are always static.\n-\n      For enumeration types, also write debugging information and declare the\n-     enumeration literal  table, if needed.  */\n-\n+     enumeration literal table, if needed.  */\n   if ((kind == E_Enumeration_Type && Present (First_Literal (gnat_entity)))\n       || (kind == E_Floating_Point_Type && !Vax_Float (gnat_entity)))\n     {\n@@ -7141,13 +7134,13 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n   else\n     gnat_error_node = gnat_object;\n \n-  /* Return 0 if no size was specified, either because Esize was not Present or\n-     the specified size was zero.  */\n+  /* Return 0 if no size was specified, either because Esize was not Present\n+     or the specified size was zero.  */\n   if (No (uint_size) || uint_size == No_Uint)\n     return NULL_TREE;\n \n-  /* Get the size as a tree.  Give an error if a size was specified, but cannot\n-     be represented as in sizetype.  */\n+  /* Get the size as a tree.  Issue an error if a size was specified but\n+     cannot be represented in sizetype.  */\n   size = UI_To_gnu (uint_size, bitsizetype);\n   if (TREE_OVERFLOW (size))\n     {\n@@ -7158,8 +7151,8 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n     }\n \n   /* Ignore a negative size since that corresponds to our back-annotation.\n-     Also ignore a zero size unless a size clause exists.  */\n-  else if (tree_int_cst_sgn (size) < 0 || (integer_zerop (size) && !zero_ok))\n+     Also ignore a zero size if it is not permitted.  */\n+  if (tree_int_cst_sgn (size) < 0 || (integer_zerop (size) && !zero_ok))\n     return NULL_TREE;\n \n   /* The size of objects is always a multiple of a byte.  */\n@@ -7177,8 +7170,8 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n \n   /* If this is an integral type or a packed array type, the front-end has\n      verified the size, so we need not do it here (which would entail\n-     checking against the bounds).  However, if this is an aliased object, it\n-     may not be smaller than the type of the object.  */\n+     checking against the bounds).  However, if this is an aliased object,\n+     it may not be smaller than the type of the object.  */\n   if ((INTEGRAL_TYPE_P (gnu_type) || TYPE_IS_PACKED_ARRAY_TYPE_P (gnu_type))\n       && !(kind == VAR_DECL && Is_Aliased (gnat_object)))\n     return size;\n@@ -7246,56 +7239,53 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n static void\n set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n {\n-  /* Only give an error if a Value_Size clause was explicitly given.\n+  /* Only issue an error if a Value_Size clause was explicitly given.\n      Otherwise, we'd be duplicating an error on the Size clause.  */\n   Node_Id gnat_attr_node\n     = Get_Attribute_Definition_Clause (gnat_entity, Attr_Value_Size);\n-  tree old_size = rm_size (gnu_type);\n-  tree size;\n+  tree old_size = rm_size (gnu_type), size;\n \n-  /* Get the size as a tree.  Do nothing if none was specified, either\n-     because RM size was not Present or if the specified size was zero.\n-     Give an error if a size was specified, but cannot be represented as\n-     in sizetype.  */\n+  /* Do nothing if no size was specified, either because RM size was not\n+     Present or if the specified size was zero.  */\n   if (No (uint_size) || uint_size == No_Uint)\n     return;\n \n+  /* Get the size as a tree.  Issue an error if a size was specified but\n+     cannot be represented in sizetype.  */\n   size = UI_To_gnu (uint_size, bitsizetype);\n   if (TREE_OVERFLOW (size))\n     {\n       if (Present (gnat_attr_node))\n \tpost_error_ne (\"Value_Size of & is too large\", gnat_attr_node,\n \t\t       gnat_entity);\n-\n       return;\n     }\n \n   /* Ignore a negative size since that corresponds to our back-annotation.\n-     Also ignore a zero size unless a size clause exists, a Value_Size\n-     clause exists, or this is an integer type, in which case the\n-     front end will have always set it.  */\n-  else if (tree_int_cst_sgn (size) < 0\n-\t   || (integer_zerop (size) && No (gnat_attr_node)\n-\t       && !Has_Size_Clause (gnat_entity)\n-\t       && !Is_Discrete_Or_Fixed_Point_Type (gnat_entity)))\n+     Also ignore a zero size unless a Value_Size clause exists, or a size\n+     clause exists, or this is an integer type, in which case the front-end\n+     will have always set it.  */\n+  if (tree_int_cst_sgn (size) < 0\n+      || (integer_zerop (size)\n+\t  && No (gnat_attr_node)\n+\t  && !Has_Size_Clause (gnat_entity)\n+\t  && !Is_Discrete_Or_Fixed_Point_Type (gnat_entity)))\n     return;\n \n   /* If the old size is self-referential, get the maximum size.  */\n   if (CONTAINS_PLACEHOLDER_P (old_size))\n     old_size = max_size (old_size, true);\n \n   /* If the size of the object is a constant, the new size must not be\n-     smaller (the front end checks this for scalar types).  */\n+     smaller (the front-end checks this for scalar types).  */\n   if (TREE_CODE (old_size) != INTEGER_CST\n       || TREE_OVERFLOW (old_size)\n-      || (AGGREGATE_TYPE_P (gnu_type)\n-\t  && tree_int_cst_lt (size, old_size)))\n+      || (AGGREGATE_TYPE_P (gnu_type) && tree_int_cst_lt (size, old_size)))\n     {\n       if (Present (gnat_attr_node))\n \tpost_error_ne_tree\n \t  (\"Value_Size for& too small{, minimum allowed is ^}\",\n \t   gnat_attr_node, gnat_entity, old_size);\n-\n       return;\n     }\n "}, {"sha": "5e713437152e4dc4a6803d6261698a0e9251fef1", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e05f922a087f545fb94f16687ec59b7d3dcdf5/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e05f922a087f545fb94f16687ec59b7d3dcdf5/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "patch": "@@ -1397,7 +1397,7 @@ aggregate_type_contains_array_p (tree type)\n     }\n }\n \n-/* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n+/* Return a FIELD_DECL node.  FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n    this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n    it is the specified size for this field.  If POS is nonzero, it is the bit\n@@ -1540,22 +1540,19 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n   return field_decl;\n }\n \f\n-/* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n-   PARAM_TYPE is its type.  READONLY is true if the parameter is\n-   readonly (either an In parameter or an address of a pass-by-ref\n-   parameter). */\n+/* Return a PARM_DECL node.  PARAM_NAME is the name of the parameter and\n+   PARAM_TYPE is its type.  READONLY is true if the parameter is readonly\n+   (either an In parameter or an address of a pass-by-ref parameter).  */\n \n tree\n create_param_decl (tree param_name, tree param_type, bool readonly)\n {\n   tree param_decl = build_decl (PARM_DECL, param_name, param_type);\n \n-  /* Honor targetm.calls.promote_prototypes(), as not doing so can\n-     lead to various ABI violations.  */\n-  if (targetm.calls.promote_prototypes (param_type)\n-      && (TREE_CODE (param_type) == INTEGER_TYPE\n-\t  || TREE_CODE (param_type) == ENUMERAL_TYPE\n-\t  || TREE_CODE (param_type) == BOOLEAN_TYPE)\n+  /* Honor TARGET_PROMOTE_PROTOTYPES like the C compiler, as not doing so\n+     can lead to various ABI violations.  */\n+  if (targetm.calls.promote_prototypes (NULL_TREE)\n+      && INTEGRAL_TYPE_P (param_type)\n       && TYPE_PRECISION (param_type) < TYPE_PRECISION (integer_type_node))\n     {\n       /* We have to be careful about biased types here.  Make a subtype"}]}