{"sha": "6e25f095d8731f6da3643da168705f3b9e8e2d2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyNWYwOTVkODczMWY2ZGEzNjQzZGExNjg3MDVmM2I5ZThlMmQyYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-18T03:03:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-18T03:03:16Z"}, "message": "Don't crash on recursive variables and typed consts.\n\nFrom-SVN: r168012", "tree": {"sha": "84e7d40b307dd4390c585f793d9c7ef16e93f5ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84e7d40b307dd4390c585f793d9c7ef16e93f5ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e25f095d8731f6da3643da168705f3b9e8e2d2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e25f095d8731f6da3643da168705f3b9e8e2d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e25f095d8731f6da3643da168705f3b9e8e2d2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e25f095d8731f6da3643da168705f3b9e8e2d2c/comments", "author": null, "committer": null, "parents": [{"sha": "748414642faf35f955a8bfa38d9febd3ef88fdb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748414642faf35f955a8bfa38d9febd3ef88fdb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748414642faf35f955a8bfa38d9febd3ef88fdb0"}], "stats": {"total": 125, "additions": 117, "deletions": 8}, "files": [{"sha": "39baf9d1c156642dc7ccfd2d3af94e1ce989e3f4", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e25f095d8731f6da3643da168705f3b9e8e2d2c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e25f095d8731f6da3643da168705f3b9e8e2d2c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6e25f095d8731f6da3643da168705f3b9e8e2d2c", "patch": "@@ -2285,6 +2285,32 @@ Expression::make_complex(const mpfr_t* real, const mpfr_t* imag, Type* type,\n   return new Complex_expression(real, imag, type, location);\n }\n \n+// Find a named object in an expression.\n+\n+class Find_named_object : public Traverse\n+{\n+ public:\n+  Find_named_object(Named_object* no)\n+    : Traverse(traverse_expressions),\n+      no_(no), found_(false)\n+  { }\n+\n+  // Whether we found the object.\n+  bool\n+  found() const\n+  { return this->found_; }\n+\n+ protected:\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The object we are looking for.\n+  Named_object* no_;\n+  // Whether we found it.\n+  bool found_;\n+};\n+\n // A reference to a const in an expression.\n \n class Const_expression : public Expression\n@@ -2295,6 +2321,10 @@ class Const_expression : public Expression\n       constant_(constant), type_(NULL), seen_(false)\n   { }\n \n+  Named_object*\n+  named_object()\n+  { return this->constant_; }\n+\n   const std::string&\n   name() const\n   { return this->constant_->name(); }\n@@ -2565,6 +2595,19 @@ Const_expression::do_determine_type(const Type_context* context)\n void\n Const_expression::do_check_types(Gogo*)\n {\n+  if (this->type_ != NULL && this->type_->is_error_type())\n+    return;\n+\n+  Expression* init = this->constant_->const_value()->expr();\n+  Find_named_object find_named_object(this->constant_);\n+  Expression::traverse(&init, &find_named_object);\n+  if (find_named_object.found())\n+    {\n+      this->report_error(_(\"constant refers to itself\"));\n+      this->type_ = Type::make_error_type();\n+      return;\n+    }\n+\n   if (this->type_ == NULL || this->type_->is_abstract())\n     return;\n \n@@ -2682,6 +2725,32 @@ Expression::make_const_reference(Named_object* constant,\n   return new Const_expression(constant, location);\n }\n \n+// Find a named object in an expression.\n+\n+int\n+Find_named_object::expression(Expression** pexpr)\n+{\n+  switch ((*pexpr)->classification())\n+    {\n+    case Expression::EXPRESSION_CONST_REFERENCE:\n+      if (static_cast<Const_expression*>(*pexpr)->named_object() == this->no_)\n+\tbreak;\n+      return TRAVERSE_CONTINUE;\n+    case Expression::EXPRESSION_VAR_REFERENCE:\n+      if ((*pexpr)->var_expression()->named_object() == this->no_)\n+\tbreak;\n+      return TRAVERSE_CONTINUE;\n+    case Expression::EXPRESSION_FUNC_REFERENCE:\n+      if ((*pexpr)->func_expression()->named_object() == this->no_)\n+\tbreak;\n+      return TRAVERSE_CONTINUE;\n+    default:\n+      return TRAVERSE_CONTINUE;\n+    }\n+  this->found_ = true;\n+  return TRAVERSE_EXIT;\n+}\n+\n // The nil value.\n \n class Nil_expression : public Expression"}, {"sha": "d8d704d956e928fc0dab0a96967d9c211a7c139a", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e25f095d8731f6da3643da168705f3b9e8e2d2c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e25f095d8731f6da3643da168705f3b9e8e2d2c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=6e25f095d8731f6da3643da168705f3b9e8e2d2c", "patch": "@@ -3056,7 +3056,7 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n   : type_(type), init_(init), preinit_(NULL), location_(location),\n     is_global_(is_global), is_parameter_(is_parameter),\n     is_receiver_(is_receiver), is_varargs_parameter_(false),\n-    is_address_taken_(false), init_is_lowered_(false),\n+    is_address_taken_(false), seen_(false), init_is_lowered_(false),\n     type_from_init_tuple_(false), type_from_range_index_(false),\n     type_from_range_value_(false), type_from_chan_element_(false),\n     is_type_switch_var_(false)\n@@ -3090,7 +3090,18 @@ Variable::lower_init_expression(Gogo* gogo, Named_object* function)\n {\n   if (this->init_ != NULL && !this->init_is_lowered_)\n     {\n+      if (this->seen_)\n+\t{\n+\t  // We will give an error elsewhere, this is just to prevent\n+\t  // an infinite loop.\n+\t  return;\n+\t}\n+      this->seen_ = true;\n+\n       gogo->lower_expression(function, &this->init_);\n+\n+      this->seen_ = false;\n+\n       this->init_is_lowered_ = true;\n     }\n }\n@@ -3209,7 +3220,7 @@ Variable::type_from_chan_element(Expression* expr, bool report_error) const\n // with type determination, then this should be unnecessary.\n \n Type*\n-Variable::type() const\n+Variable::type()\n {\n   // A variable in a type switch with a nil case will have the wrong\n   // type here.  This gets fixed up in determine_type, below.\n@@ -3224,14 +3235,26 @@ Variable::type() const\n       type = NULL;\n     }\n \n+  if (this->seen_)\n+    {\n+      if (this->type_ == NULL || !this->type_->is_error_type())\n+\t{\n+\t  error_at(this->location_, \"variable initializer refers to itself\");\n+\t  this->type_ = Type::make_error_type();\n+\t}\n+      return this->type_;\n+    }\n+\n+  this->seen_ = true;\n+\n   if (type != NULL)\n-    return type;\n+    ;\n   else if (this->type_from_init_tuple_)\n-    return this->type_from_tuple(init, false);\n+    type = this->type_from_tuple(init, false);\n   else if (this->type_from_range_index_ || this->type_from_range_value_)\n-    return this->type_from_range(init, this->type_from_range_index_, false);\n+    type = this->type_from_range(init, this->type_from_range_index_, false);\n   else if (this->type_from_chan_element_)\n-    return this->type_from_chan_element(init, false);\n+    type = this->type_from_chan_element(init, false);\n   else\n     {\n       gcc_assert(init != NULL);\n@@ -3244,9 +3267,21 @@ Variable::type() const\n \n       if (type->is_void_type())\n \ttype = Type::make_error_type();\n-\n-      return type;\n     }\n+\n+  this->seen_ = false;\n+\n+  return type;\n+}\n+\n+// Fetch the type from a const pointer, in which case it should have\n+// been set already.\n+\n+Type*\n+Variable::type() const\n+{\n+  gcc_assert(this->type_ != NULL);\n+  return this->type_;\n }\n \n // Set the type if necessary."}, {"sha": "552a64344857316ccea77f93f1d1af4662f5aeda", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e25f095d8731f6da3643da168705f3b9e8e2d2c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e25f095d8731f6da3643da168705f3b9e8e2d2c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=6e25f095d8731f6da3643da168705f3b9e8e2d2c", "patch": "@@ -1038,6 +1038,9 @@ class Variable\n \t   bool is_receiver, source_location);\n \n   // Get the type of the variable.\n+  Type*\n+  type();\n+\n   Type*\n   type() const;\n \n@@ -1258,6 +1261,8 @@ class Variable\n   bool is_varargs_parameter_ : 1;\n   // Whether something takes the address of this variable.\n   bool is_address_taken_ : 1;\n+  // True if we have seen this variable in a traversal.\n+  bool seen_ : 1;\n   // True if we have lowered the initialization expression.\n   bool init_is_lowered_ : 1;\n   // True if init is a tuple used to set the type."}]}