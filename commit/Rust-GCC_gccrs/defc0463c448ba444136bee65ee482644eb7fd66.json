{"sha": "defc0463c448ba444136bee65ee482644eb7fd66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVmYzA0NjNjNDQ4YmE0NDQxMzZiZWU2NWVlNDgyNjQ0ZWI3ZmQ2Ng==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-10-17T10:58:17Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-10-17T10:58:17Z"}, "message": "arm-modes.def (CC_Nmode): New condition code mode.\n\n* arm-modes.def (CC_Nmode): New condition code mode.\n* arm.c (thumb_condition_code): Delete.\n(arm_select_cc_mode): Handle single-bit test for Thumb.\n(arm_print_operand, cases 'd' and 'D'): Don't special case the\ncondition code logic for Thumb.\n(get_arm_condition_code): Handle CC_Nmode.\n(thumb_cbrch_target_operand): New function.\n* arm.h (PREDICATE_CODES): Add thumb_cbrch_target_operand.\n* arm-protos.h (thumb_cbrch_target_operand): Add prototype.\n* arm.md: Add Thumb split patterns for zero_extract and\nsign_extract.\n(tbit_cbranch, andsi3_cbranch_scratch, andsi3_cbranch)\n(orrsi3_cbranch_scratch, orrsi3_cbranch, xorsi3_cbranch_scratch)\n(xorsi3_cbranch, addsi3_cbranch, addsi3_cbranch_scratch)\n(subsi3_cbranch, subsi3_cbranch_scratch): New Thumb patterns.\n(cbranchne_decr1): Re-work to use CC_Nmode.\n\n* arm.c (thumb_expand_epilogue): Add clobbers of registers restored\nby the return instruction.  Add a use of the link register if it\nwasn't stored.\n\nFrom-SVN: r72595", "tree": {"sha": "d402bff7289bb069a9367b802d647c14c1d1d00f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d402bff7289bb069a9367b802d647c14c1d1d00f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/defc0463c448ba444136bee65ee482644eb7fd66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defc0463c448ba444136bee65ee482644eb7fd66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/defc0463c448ba444136bee65ee482644eb7fd66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defc0463c448ba444136bee65ee482644eb7fd66/comments", "author": null, "committer": null, "parents": [{"sha": "38b2a60531f0da9ee440c82248774bf53596edf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b2a60531f0da9ee440c82248774bf53596edf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b2a60531f0da9ee440c82248774bf53596edf0"}], "stats": {"total": 779, "additions": 736, "deletions": 43}, "files": [{"sha": "a096fda0333831c1338c3d65724f452e24272357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=defc0463c448ba444136bee65ee482644eb7fd66", "patch": "@@ -1,3 +1,26 @@\n+2003-10-17  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm-modes.def (CC_Nmode): New condition code mode.\n+\t* arm.c (thumb_condition_code): Delete.\n+\t(arm_select_cc_mode): Handle single-bit test for Thumb.\n+\t(arm_print_operand, cases 'd' and 'D'): Don't special case the \n+\tcondition code logic for Thumb.\n+\t(get_arm_condition_code): Handle CC_Nmode.\n+\t(thumb_cbrch_target_operand): New function.\n+\t* arm.h (PREDICATE_CODES): Add thumb_cbrch_target_operand.\n+\t* arm-protos.h (thumb_cbrch_target_operand): Add prototype.\n+\t* arm.md: Add Thumb split patterns for zero_extract and\n+\tsign_extract.\n+\t(tbit_cbranch, andsi3_cbranch_scratch, andsi3_cbranch)\n+\t(orrsi3_cbranch_scratch, orrsi3_cbranch, xorsi3_cbranch_scratch)\n+\t(xorsi3_cbranch, addsi3_cbranch, addsi3_cbranch_scratch)\n+\t(subsi3_cbranch, subsi3_cbranch_scratch): New Thumb patterns.\n+\t(cbranchne_decr1): Re-work to use CC_Nmode.\n+\n+\t* arm.c (thumb_expand_epilogue): Add clobbers of registers restored \n+\tby the return instruction.  Add a use of the link register if it\n+\twasn't stored.\n+\n 2003-10-17  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* flow.c (init_propagate_block_info): Don't abort if a conditional"}, {"sha": "1d58b18bb23b30d6808089b03ce94378c3ad4702", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=defc0463c448ba444136bee65ee482644eb7fd66", "patch": "@@ -30,6 +30,7 @@ FLOAT_MODE (XF, 12, 0);\n    CCFPmode should be used with floating equalities.\n    CC_NOOVmode should be used with SImode integer equalities.\n    CC_Zmode should be used if only the Z flag is set correctly\n+   CC_Nmode should be used if only the N (sign) flag is set correctly\n    CCmode should be used otherwise. */\n \n CC_MODE (CC_NOOV);\n@@ -48,3 +49,4 @@ CC_MODE (CC_DLTU);\n CC_MODE (CC_DGEU);\n CC_MODE (CC_DGTU);\n CC_MODE (CC_C);\n+CC_MODE (CC_N);"}, {"sha": "61c28be862903b11e9e1a11479f56c9b93d40645", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=defc0463c448ba444136bee65ee482644eb7fd66", "patch": "@@ -178,6 +178,7 @@ extern const char *thumb_load_double_from_address (rtx *);\n extern const char *thumb_output_move_mem_multiple (int, rtx *);\n extern void thumb_expand_movstrqi (rtx *);\n extern int thumb_cmp_operand (rtx, enum machine_mode);\n+extern int thumb_cbrch_target_operand (rtx, enum machine_mode);\n extern rtx *thumb_legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int thumb_go_if_legitimate_address (enum machine_mode, rtx);\n extern rtx arm_return_addr (int, rtx);"}, {"sha": "dc8c536653609875962fc4c6792a689b10d9d9a4", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=defc0463c448ba444136bee65ee482644eb7fd66", "patch": "@@ -86,7 +86,6 @@ static int number_of_first_bit_set (int);\n static void replace_symbols_in_block (tree, rtx, rtx);\n static void thumb_exit (FILE *, int, rtx);\n static void thumb_pushpop (FILE *, int, int);\n-static const char *thumb_condition_code (rtx, int);\n static rtx is_jump_table (rtx);\n static HOST_WIDE_INT get_jump_table_size (rtx);\n static Mnode *move_minipool_fix_forward_ref (Mnode *, Mnode *, HOST_WIDE_INT);\n@@ -5575,10 +5574,19 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n     return arm_select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1),\n \t\t\t\t\t DOM_CC_X_OR_Y);\n \n+  /* An operation (on Thumb) where we want to test for a single bit.\n+     This is done by shifting that bit up into the top bit of a\n+     scratch register; we can then branch on the sign bit.  */\n+  if (TARGET_THUMB\n+      && GET_MODE (x) == SImode\n+      && (op == EQ || op == NE)\n+      && (GET_CODE (x) == ZERO_EXTRACT))\n+    return CC_Nmode;\n+\n   /* An operation that sets the condition codes as a side-effect, the\n      V flag is not set correctly, so we can only use comparisons where\n      this doesn't matter.  (For LT and GE we can use \"mi\" and \"pl\"\n-     instead.  */\n+     instead.)  */\n   if (GET_MODE (x) == SImode\n       && y == const0_rtx\n       && (op == EQ || op == NE || op == LT || op == GE)\n@@ -5588,7 +5596,8 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \t  || GET_CODE (x) == NOT || GET_CODE (x) == NEG\n \t  || GET_CODE (x) == LSHIFTRT\n \t  || GET_CODE (x) == ASHIFT || GET_CODE (x) == ASHIFTRT\n-\t  || GET_CODE (x) == ROTATERT || GET_CODE (x) == ZERO_EXTRACT))\n+\t  || GET_CODE (x) == ROTATERT\n+\t  || (TARGET_ARM && GET_CODE (x) == ZERO_EXTRACT)))\n     return CC_NOOVmode;\n \n   if (GET_MODE (x) == QImode && (op == EQ || op == NE))\n@@ -9557,11 +9566,8 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       if (x == const_true_rtx)\n \treturn;\n       \n-      if (TARGET_ARM)\n-        fputs (arm_condition_codes[get_arm_condition_code (x)],\n-\t       stream);\n-      else\n-\tfputs (thumb_condition_code (x, 0), stream);\n+      fputs (arm_condition_codes[get_arm_condition_code (x)],\n+\t     stream);\n       return;\n \n     case 'D':\n@@ -9570,12 +9576,9 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       if (x == const_true_rtx)\n \tabort ();\n \n-      if (TARGET_ARM)\n-\tfputs (arm_condition_codes[ARM_INVERSE_CONDITION_CODE\n-\t\t\t\t  (get_arm_condition_code (x))],\n-\t       stream);\n-      else\n-\tfputs (thumb_condition_code (x, 1), stream);\n+      fputs (arm_condition_codes[ARM_INVERSE_CONDITION_CODE\n+\t\t\t\t (get_arm_condition_code (x))],\n+\t     stream);\n       return;\n \n     /* Cirrus registers can be accessed in a variety of ways:\n@@ -9815,6 +9818,14 @@ get_arm_condition_code (rtx comparison)\n \tdefault: abort ();\n \t}\n \n+    case CC_Nmode:\n+      switch (comp_code)\n+\t{\n+\tcase NE: return ARM_MI;\n+\tcase EQ: return ARM_PL;\n+\tdefault: abort ();\n+\t}\n+\n     case CCFPEmode:\n     case CCFPmode:\n       /* These encodings assume that AC=1 in the FPA system control\n@@ -12083,7 +12094,8 @@ thumb_expand_epilogue (void)\n {\n   HOST_WIDE_INT amount = (thumb_get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n-  \n+  int regno;\n+\n   /* Naked functions don't have prologues.  */\n   if (IS_NAKED (arm_current_func_type ()))\n     return;\n@@ -12113,6 +12125,15 @@ thumb_expand_epilogue (void)\n \n   if (current_function_profile || TARGET_NO_SCHED_PRO)\n     emit_insn (gen_blockage ());\n+\n+  /* Emit a clobber for each insn that will be restored in the epilogue,\n+     so that flow2 will get register lifetimes correct.  */\n+  for (regno = 0; regno < 13; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, regno)));\n+\n+  if (! regs_ever_live[LR_REGNUM])\n+    emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, LR_REGNUM)));\n }\n \n static void\n@@ -12571,36 +12592,25 @@ thumb_cmp_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (unsigned HOST_WIDE_INT) (INTVAL (op)) < 256)\n-\t  || register_operand (op, mode));\n+\t  || s_register_operand (op, mode));\n }\n \n-static const char *\n-thumb_condition_code (rtx x, int invert)\n-{\n-  static const char * const conds[] =\n-  {\n-    \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\", \n-    \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\"\n-  };\n-  int val;\n+/* Return TRUE if a result can be stored in OP without clobbering the\n+   condition code register.  Prior to reload we only accept a\n+   register.  After reload we have to be able to handle memory as\n+   well, since a pseudo may not get a hard reg and reload cannot\n+   handle output-reloads on jump insns.\n \n-  switch (GET_CODE (x))\n-    {\n-    case EQ: val = 0; break;\n-    case NE: val = 1; break;\n-    case GEU: val = 2; break;\n-    case LTU: val = 3; break;\n-    case GTU: val = 8; break;\n-    case LEU: val = 9; break;\n-    case GE: val = 10; break;\n-    case LT: val = 11; break;\n-    case GT: val = 12; break;\n-    case LE: val = 13; break;\n-    default:\n-      abort ();\n-    }\n+   We could possibly handle mem before reload as well, but that might\n+   complicate things with the need to handle increment\n+   side-effects.  */\n \n-  return conds[val ^ invert];\n+int\n+thumb_cbrch_target_operand (rtx op, enum machine_mode mode)\n+{\n+  return (s_register_operand (op, mode)\n+\t  || ((reload_in_progress || reload_completed)\n+\t      && memory_operand (op, mode)));\n }\n \n /* Handle storing a half-word to memory during reload.  */ "}, {"sha": "bfdfb3b8e20912148a320b265c032e47177cf866", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=defc0463c448ba444136bee65ee482644eb7fd66", "patch": "@@ -2689,6 +2689,7 @@ extern int making_const_table;\n   {\"reg_or_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"index_operand\",      {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"thumb_cmp_operand\",  {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"thumb_cbrch_target_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n   {\"offsettable_memory_operand\", {MEM}},\t\t\t\t\\\n   {\"bad_signed_byte_operand\", {MEM}},\t\t\t\t\t\\\n   {\"alignable_memory_operand\", {MEM}},\t\t\t\t\t\\"}, {"sha": "c4ef68d937e06c856e787ecfaff44f171d5e5b5a", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 658, "deletions": 2, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defc0463c448ba444136bee65ee482644eb7fd66/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=defc0463c448ba444136bee65ee482644eb7fd66", "patch": "@@ -1721,6 +1721,39 @@\n    (set_attr \"length\" \"8\")]\n )\n \n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))\n+   (clobber (match_operand:SI 4 \"s_register_operand\" \"\"))]\n+  \"TARGET_THUMB\"\n+  [(set (match_dup 4) (ashift:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 4) (match_dup 3)))]\n+  \"{\n+     HOST_WIDE_INT temp = INTVAL (operands[2]);\n+\n+     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));\n+     operands[3] = GEN_INT (32 - temp);\n+   }\"\n+)\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(sign_extract:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"TARGET_THUMB\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 3)))]\n+  \"{\n+     HOST_WIDE_INT temp = INTVAL (operands[2]);\n+\n+     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));\n+     operands[3] = GEN_INT (32 - temp);\n+   }\"\n+)\n+\n ;;; ??? This pattern is bogus.  If operand3 has bits outside the range\n ;;; represented by the bitfield, then this will produce incorrect results.\n ;;; Somewhere, the value needs to be truncated.  On targets like the m68k,\n@@ -5246,14 +5279,373 @@\n \t\t(const_int 8))))]\n )\n \n+(define_insn \"*tbit_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t  [(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"l\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 4 \"=l\"))]\n+  \"TARGET_THUMB\"\n+  \"*\n+  {\n+  rtx op[3];\n+  op[0] = operands[4];\n+  op[1] = operands[1];\n+  op[2] = GEN_INT (32 - 1 - INTVAL (operands[2]));\n+\n+  output_asm_insn (\\\"lsl\\\\t%0, %1, %2\\\", op);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d0\\\\t%l3\\\";\n+    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\") \n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))]\n+)\n+  \n+(define_insn \"*andsi3_cbranch_scratch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 4 \"equality_operator\"\n+\t  [(and:SI (match_operand:SI 1 \"s_register_operand\" \"%0\")\n+\t\t   (match_operand:SI 2 \"s_register_operand\" \"l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 0 \"=l\"))]\n+  \"TARGET_THUMB\"\n+  \"*\n+  {\n+  output_asm_insn (\\\"and\\\\t%0, %2\\\", operands);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d4\\\\t%l3\\\";\n+    case 6:  return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\") \n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))]\n+)\n+  \n+(define_insn \"*andsi3_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 5 \"equality_operator\"\n+\t  [(and:SI (match_operand:SI 2 \"s_register_operand\" \"%0,1,1,1\")\n+\t\t   (match_operand:SI 3 \"s_register_operand\" \"l,l,l,l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 4 \"\" \"\"))\n+\t (pc)))\n+   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,?h,?m,?m\")\n+\t(and:SI (match_dup 2) (match_dup 3)))\n+   (clobber (match_scratch:SI 1 \"=X,l,&l,&l\"))]\n+  \"TARGET_THUMB\"\n+  \"*\n+  {\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"and\\\\t%0, %3\\\", operands);\n+  else if (which_alternative == 1)\n+    {\n+      output_asm_insn (\\\"and\\\\t%1, %3\\\", operands);\n+      output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"and\\\\t%1, %3\\\", operands);\n+      output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n+    }\n+\n+  switch (get_attr_length (insn) - (which_alternative ? 2 : 0))\n+    {\n+    case 4:  return \\\"b%d5\\\\t%l4\\\";\n+    case 6:  return \\\"b%D5\\\\t.LCB%=\\;b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D5\\\\t.LCB%=\\;bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (ior (and (eq (symbol_ref (\"which_alternative\"))\n+\t                  (const_int 0))\n+\t\t      (eq_attr \"length\" \"8\"))\n+\t\t (eq_attr \"length\" \"10\"))\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+     (if_then_else\n+       (eq (symbol_ref (\"which_alternative\"))\n+\t\t       (const_int 0))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8)))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))))]\n+)\n+\n+(define_insn \"*orrsi3_cbranch_scratch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 4 \"equality_operator\"\n+\t  [(ior:SI (match_operand:SI 1 \"s_register_operand\" \"%0\")\n+\t\t   (match_operand:SI 2 \"s_register_operand\" \"l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 0 \"=l\"))]\n+  \"TARGET_THUMB\"\n+  \"*\n+  {\n+  output_asm_insn (\\\"orr\\\\t%0, %2\\\", operands);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d4\\\\t%l3\\\";\n+    case 6:  return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\") \n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))]\n+)\n+  \n+(define_insn \"*orrsi3_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 5 \"equality_operator\"\n+\t  [(ior:SI (match_operand:SI 2 \"s_register_operand\" \"%0,1,1,1\")\n+\t\t   (match_operand:SI 3 \"s_register_operand\" \"l,l,l,l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 4 \"\" \"\"))\n+\t (pc)))\n+   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,?h,?m,?m\")\n+\t(ior:SI (match_dup 2) (match_dup 3)))\n+   (clobber (match_scratch:SI 1 \"=X,l,&l,&l\"))]\n+  \"TARGET_THUMB\"\n+  \"*\n+  {\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"orr\\\\t%0, %3\\\", operands);\n+  else if (which_alternative == 1)\n+    {\n+      output_asm_insn (\\\"orr\\\\t%1, %3\\\", operands);\n+      output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"orr\\\\t%1, %3\\\", operands);\n+      output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n+    }\n+\n+  switch (get_attr_length (insn) - (which_alternative ? 2 : 0))\n+    {\n+    case 4:  return \\\"b%d5\\\\t%l4\\\";\n+    case 6:  return \\\"b%D5\\\\t.LCB%=\\;b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D5\\\\t.LCB%=\\;bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (ior (and (eq (symbol_ref (\"which_alternative\"))\n+\t                  (const_int 0))\n+\t\t      (eq_attr \"length\" \"8\"))\n+\t\t (eq_attr \"length\" \"10\"))\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+     (if_then_else\n+       (eq (symbol_ref (\"which_alternative\"))\n+\t\t       (const_int 0))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8)))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))))]\n+)\n+\n+(define_insn \"*xorsi3_cbranch_scratch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 4 \"equality_operator\"\n+\t  [(xor:SI (match_operand:SI 1 \"s_register_operand\" \"%0\")\n+\t\t   (match_operand:SI 2 \"s_register_operand\" \"l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 0 \"=l\"))]\n+  \"TARGET_THUMB\"\n+  \"*\n+  {\n+  output_asm_insn (\\\"eor\\\\t%0, %2\\\", operands);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d4\\\\t%l3\\\";\n+    case 6:  return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\") \n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))]\n+)\n+  \n+(define_insn \"*xorsi3_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 5 \"equality_operator\"\n+\t  [(xor:SI (match_operand:SI 2 \"s_register_operand\" \"%0,1,1,1\")\n+\t\t   (match_operand:SI 3 \"s_register_operand\" \"l,l,l,l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 4 \"\" \"\"))\n+\t (pc)))\n+   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,?h,?m,?m\")\n+\t(xor:SI (match_dup 2) (match_dup 3)))\n+   (clobber (match_scratch:SI 1 \"=X,l,&l,&l\"))]\n+  \"TARGET_THUMB\"\n+  \"*\n+  {\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"eor\\\\t%0, %3\\\", operands);\n+  else if (which_alternative == 1)\n+    {\n+      output_asm_insn (\\\"eor\\\\t%1, %3\\\", operands);\n+      output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"eor\\\\t%1, %3\\\", operands);\n+      output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n+    }\n+\n+  switch (get_attr_length (insn) - (which_alternative ? 2 : 0))\n+    {\n+    case 4:  return \\\"b%d5\\\\t%l4\\\";\n+    case 6:  return \\\"b%D5\\\\t.LCB%=\\;b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D5\\\\t.LCB%=\\;bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (ior (and (eq (symbol_ref (\"which_alternative\"))\n+\t                  (const_int 0))\n+\t\t      (eq_attr \"length\" \"8\"))\n+\t\t (eq_attr \"length\" \"10\"))\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+     (if_then_else\n+       (eq (symbol_ref (\"which_alternative\"))\n+\t\t       (const_int 0))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8)))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))))]\n+)\n+\n (define_insn \"*cbranchne_decr1\"\n   [(set (pc)\n \t(if_then_else (match_operator 3 \"equality_operator\"\n \t\t       [(match_operand:SI 2 \"s_register_operand\" \"l,l,1,l\")\n \t\t        (const_int 0)])\n \t\t      (label_ref (match_operand 4 \"\" \"\"))\n \t\t      (pc)))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"=l,?h,?m,?m\")\n+   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,?h,?m,?m\")\n \t(plus:SI (match_dup 2) (const_int -1)))\n    (clobber (match_scratch:SI 1 \"=X,l,&l,&l\"))]\n   \"TARGET_THUMB\"\n@@ -5262,7 +5654,7 @@\n      rtx cond[2];\n      cond[0] = gen_rtx_fmt_ee ((GET_CODE (operands[3]) == NE\n \t\t\t\t? GEU : LTU),\n-\t\t\t       VOIDmode, NULL, NULL);\n+\t\t\t       VOIDmode, operands[2], const1_rtx);\n      cond[1] = operands[4];\n \n      if (which_alternative == 0)\n@@ -5349,6 +5741,270 @@\n \t   (const_int 10)))])]\n )\n \n+(define_insn \"*addsi3_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 4 \"comparison_operator\"\n+\t  [(plus:SI\n+\t    (match_operand:SI 2 \"s_register_operand\" \"%l,0,*0,1,1,1\")\n+\t    (match_operand:SI 3 \"reg_or_int_operand\" \"lL,IJ,*r,lIJ,lIJ,lIJ\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 5 \"\" \"\"))\n+\t (pc)))\n+   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,l,*!h,?h,?m,?m\")\n+\t(plus:SI (match_dup 2) (match_dup 3)))\n+   (clobber (match_scratch:SI 1 \"=X,X,X,l,&l,&l\"))]\n+  \"TARGET_THUMB\n+   && (GET_CODE (operands[4]) == EQ\n+       || GET_CODE (operands[4]) == NE\n+       || GET_CODE (operands[4]) == GE\n+       || GET_CODE (operands[4]) == LT)\"\n+  \"*\n+   {\n+     rtx cond[3];\n+\n+     \n+     cond[0] = (which_alternative < 3) ? operands[0] : operands[1];\n+     cond[1] = operands[2];\n+     cond[2] = operands[3];\n+\n+     if (GET_CODE (cond[2]) == CONST_INT && INTVAL (cond[2]) < 0)\n+       output_asm_insn (\\\"sub\\\\t%0, %1, #%n2\\\", cond);\n+     else\n+       output_asm_insn (\\\"add\\\\t%0, %1, %2\\\", cond);\n+\n+     if (which_alternative >= 3\n+\t && which_alternative < 4)\n+       output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n+     else if (which_alternative >= 4)\n+       output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n+\n+     switch (get_attr_length (insn) - ((which_alternative >= 3) ? 2 : 0))\n+       {\n+\t case 4:\n+\t   return \\\"b%d4\\\\t%l5\\\";\n+\t case 6:\n+\t   return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l5\\\\t%@long jump\\\\n.LCB%=:\\\";\n+\t default:\n+\t   return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l5\\\\t%@far jump\\\\n.LCB%=:\\\";\n+       }\n+   }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (ior (and (lt (symbol_ref (\"which_alternative\"))\n+\t                  (const_int 3))\n+\t\t      (eq_attr \"length\" \"8\"))\n+\t\t (eq_attr \"length\" \"10\"))\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+     (if_then_else\n+       (lt (symbol_ref (\"which_alternative\"))\n+\t\t       (const_int 3))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 5) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8)))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 5) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))))]\n+)\n+\n+(define_insn \"*addsi3_cbranch_scratch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"comparison_operator\"\n+\t  [(plus:SI\n+\t    (match_operand:SI 1 \"s_register_operand\" \"%l,l,l,0\")\n+\t    (match_operand:SI 2 \"reg_or_int_operand\" \"J,l,I,L\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 4 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 0 \"=X,X,l,l\"))]\n+  \"TARGET_THUMB\n+   && (GET_CODE (operands[3]) == EQ\n+       || GET_CODE (operands[3]) == NE\n+       || GET_CODE (operands[3]) == GE\n+       || GET_CODE (operands[3]) == LT)\"\n+  \"*\n+   {\n+     switch (which_alternative)\n+       {\n+       case 0:\n+\t output_asm_insn (\\\"cmp\\t%1, #%n2\\\", operands);\n+\t break;\n+       case 1:\n+\t output_asm_insn (\\\"cmn\\t%1, %2\\\", operands);\n+\t break;\n+       case 3:\n+\t output_asm_insn (\\\"add\\t%0, %1, %2\\\", operands);\n+\t break;\n+       case 4:\n+\t output_asm_insn (\\\"add\\t%0, %0, %2\\\", operands);\n+\t break;\n+       }\n+\n+     switch (get_attr_length (insn))\n+       {\n+\t case 4:\n+\t   return \\\"b%d3\\\\t%l4\\\";\n+\t case 6:\n+\t   return \\\"b%D3\\\\t.LCB%=\\;b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n+\t default:\n+\t   return \\\"b%D3\\\\t.LCB%=\\;bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n+       }\n+   }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8))))]\n+)\n+\n+(define_insn \"*subsi3_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 4 \"comparison_operator\"\n+\t  [(minus:SI\n+\t    (match_operand:SI 2 \"s_register_operand\" \"l,l,1,l\")\n+\t    (match_operand:SI 3 \"s_register_operand\" \"l,l,l,l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 5 \"\" \"\"))\n+\t (pc)))\n+   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,?h,?m,?m\")\n+\t(minus:SI (match_dup 2) (match_dup 3)))\n+   (clobber (match_scratch:SI 1 \"=X,l,&l,&l\"))]\n+  \"TARGET_THUMB\n+   && (GET_CODE (operands[4]) == EQ\n+       || GET_CODE (operands[4]) == NE\n+       || GET_CODE (operands[4]) == GE\n+       || GET_CODE (operands[4]) == LT)\"\n+  \"*\n+   {\n+     if (which_alternative == 0)\n+       output_asm_insn (\\\"sub\\\\t%0, %2, %3\\\", operands);\n+     else if (which_alternative == 1)\n+       {\n+\t /* We must provide an alternative for a hi reg because reload \n+\t    cannot handle output reloads on a jump instruction, but we\n+\t    can't subtract into that.  Fortunately a mov from lo to hi\n+\t    does not clobber the condition codes.  */\n+\t output_asm_insn (\\\"sub\\\\t%1, %2, %3\\\", operands);\n+\t output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n+       }\n+     else\n+       {\n+\t /* Similarly, but the target is memory.  */\n+\t output_asm_insn (\\\"sub\\\\t%1, %2, %3\\\", operands);\n+\t output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n+       }\n+\n+     switch (get_attr_length (insn) - ((which_alternative != 0) ? 2 : 0))\n+       {\n+\t case 4:\n+\t   return \\\"b%d4\\\\t%l5\\\";\n+\t case 6:\n+\t   return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l5\\\\t%@long jump\\\\n.LCB%=:\\\";\n+\t default:\n+\t   return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l5\\\\t%@far jump\\\\n.LCB%=:\\\";\n+       }\n+   }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (ior (and (eq (symbol_ref (\"which_alternative\"))\n+\t                  (const_int 0))\n+\t\t      (eq_attr \"length\" \"8\"))\n+\t\t (eq_attr \"length\" \"10\"))\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+     (if_then_else\n+       (eq (symbol_ref (\"which_alternative\"))\n+\t\t       (const_int 0))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 5) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8)))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 5) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))))]\n+)\n+\n+(define_insn \"*subsi3_cbranch_scratch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"arm_comparison_operator\"\n+\t  [(minus:SI (match_operand:SI 1 \"register_operand\" \"l\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_THUMB\n+   && (GET_CODE (operands[0]) == EQ\n+       || GET_CODE (operands[0]) == NE\n+       || GET_CODE (operands[0]) == GE\n+       || GET_CODE (operands[0]) == LT)\"\n+  \"*\n+  output_asm_insn (\\\"cmp\\\\t%1, %2\\\", operands);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d0\\\\t%l3\\\";\n+    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\") \n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))]\n+)\n+\n ;; Comparison and test insns\n \n (define_expand \"cmpsi\""}]}