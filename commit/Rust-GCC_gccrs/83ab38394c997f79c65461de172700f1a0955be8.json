{"sha": "83ab38394c997f79c65461de172700f1a0955be8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNhYjM4Mzk0Yzk5N2Y3OWM2NTQ2MWRlMTcyNzAwZjFhMDk1NWJlOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-03T22:23:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-03T22:23:11Z"}, "message": "flow.c (propagate_block): Use XEXP not SET_DEST for a USE.\n\n        * flow.c (propagate_block): Use XEXP not SET_DEST for a USE.\n        (recompute_reg_usage): Likewise.\n        * rtlanal.c (find_regno_fusage): Likewise.\n\n        * rtl.c (rtl_check_failed_code1): New function.\n        (rtl_check_failed_code2): New.\n        * rtl.h (RTL_CHECK1, RTL_CHECK2, RTVEC_ELT): Parenthesize args.\n        (RTL_CHECKC1, RTL_CHECKC2): New.\n        (XC*): New accessor macros.\n        (NOTE_*, LABEL_NAME, LABEL_NUSES, ADDRESSOF_REGNO): Use them.\n        (ADDRESSOF_DECL, JUMP_LABEL, LABEL_REFS, LABEL_NEXTREF): Likewise.\n        (CONTAINING_INSN, REGNO, INTVAL, SUBREG_REG, SUBREG_WORD): Likewise.\n        (ASM_OPERANDS_*, MEM_ALIAS_SET, SET_SRC, SET_DEST): Likewise.\n        (TRAP_*, RANGE_INFO_*): Likewise.\n\nFrom-SVN: r29089", "tree": {"sha": "264ee0a18e36e4a7ca076fd4562a9b3d755bc933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/264ee0a18e36e4a7ca076fd4562a9b3d755bc933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83ab38394c997f79c65461de172700f1a0955be8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ab38394c997f79c65461de172700f1a0955be8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83ab38394c997f79c65461de172700f1a0955be8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ab38394c997f79c65461de172700f1a0955be8/comments", "author": null, "committer": null, "parents": [{"sha": "02aadb7a10e8314ac6752427757d4bff29906e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02aadb7a10e8314ac6752427757d4bff29906e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02aadb7a10e8314ac6752427757d4bff29906e92"}], "stats": {"total": 240, "additions": 160, "deletions": 80}, "files": [{"sha": "23652ac8d63ae55a9badcb070801a9cfef52b318", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ab38394c997f79c65461de172700f1a0955be8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ab38394c997f79c65461de172700f1a0955be8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83ab38394c997f79c65461de172700f1a0955be8", "patch": "@@ -1,3 +1,20 @@\n+Fri Sep  3 15:13:34 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (propagate_block): Use XEXP not SET_DEST for a USE.\n+\t(recompute_reg_usage): Likewise.\n+\t* rtlanal.c (find_regno_fusage): Likewise.\n+\n+\t* rtl.c (rtl_check_failed_code1): New function.\n+\t(rtl_check_failed_code2): New.\n+\t* rtl.h (RTL_CHECK1, RTL_CHECK2, RTVEC_ELT): Parenthesize args.\n+\t(RTL_CHECKC1, RTL_CHECKC2): New.\n+\t(XC*): New accessor macros.\n+\t(NOTE_*, LABEL_NAME, LABEL_NUSES, ADDRESSOF_REGNO): Use them.\n+\t(ADDRESSOF_DECL, JUMP_LABEL, LABEL_REFS, LABEL_NEXTREF): Likewise.\n+\t(CONTAINING_INSN, REGNO, INTVAL, SUBREG_REG, SUBREG_WORD): Likewise.\n+\t(ASM_OPERANDS_*, MEM_ALIAS_SET, SET_SRC, SET_DEST): Likewise.\n+\t(TRAP_*, RANGE_INFO_*): Likewise.\n+\n Fri Sep  3 15:10:20 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (tlink.o): Don't depend on toplev.h."}, {"sha": "92ab49a172a310b3806476affd7f22661caf15f0", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=83ab38394c997f79c65461de172700f1a0955be8", "patch": "@@ -2845,7 +2845,7 @@ propagate_block (old, first, last, final, significant, bnum, remove_dead_code)\n \t\t       note;\n \t\t       note = XEXP (note, 1))\n \t\t    if (GET_CODE (XEXP (note, 0)) == USE)\n-\t\t      mark_used_regs (old, live, SET_DEST (XEXP (note, 0)),\n+\t\t      mark_used_regs (old, live, XEXP (XEXP (note, 0), 0),\n \t\t\t\t      final, insn);\n \n \t\t  /* Each call clobbers all call-clobbered regs that are not\n@@ -5048,7 +5048,7 @@ recompute_reg_usage (f, loop_step)\n \t\t   note;\n \t\t   note = XEXP (note, 1))\n \t\tif (GET_CODE (XEXP (note, 0)) == USE)\n-\t\t  count_reg_references (SET_DEST (XEXP (note, 0)));\n+\t\t  count_reg_references (XEXP (XEXP (note, 0), 0));\n \t    }\n \t}\n     }"}, {"sha": "4b14dabf5ccdae95be078f297fb662f7853a55ef", "filename": "gcc/rtl.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=83ab38394c997f79c65461de172700f1a0955be8", "patch": "@@ -986,6 +986,33 @@ rtl_check_failed_type2 (r, n, c1, c2, file, line, func)\n   fancy_abort (file, line, func);\n }\n \n+void\n+rtl_check_failed_code1 (r, code, file, line, func)\n+    rtx r;\n+    enum rtx_code code;\n+    const char *file;\n+    int line;\n+    const char *func;\n+{\n+  error (\"RTL check: expected code `%s', have `%s'\",\n+ \t GET_RTX_NAME (code), GET_RTX_NAME (GET_CODE (r)));\n+  fancy_abort (file, line, func);\n+}\n+\n+void\n+rtl_check_failed_code2 (r, code1, code2, file, line, func)\n+    rtx r;\n+    enum rtx_code code1, code2;\n+    const char *file;\n+    int line;\n+    const char *func;\n+{\n+  error (\"RTL check: expected code `%s' or `%s', have `%s'\",\n+ \t GET_RTX_NAME (code1), GET_RTX_NAME (code2),\n+\t GET_RTX_NAME (GET_CODE (r)));\n+  fancy_abort (file, line, func);\n+}\n+\n /* XXX Maybe print the vector?  */\n void\n rtvec_check_failed_bounds (r, n, file, line, func)"}, {"sha": "43eccffc1eead3085917573808d59d9599b3e498", "filename": "gcc/rtl.h", "status": "modified", "additions": 104, "deletions": 66, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=83ab38394c997f79c65461de172700f1a0955be8", "patch": "@@ -226,7 +226,7 @@ typedef struct rtvec_def{\n /* The bit with a star outside the statement expr and an & inside is\n    so that N can be evaluated only once.  */\n #define RTL_CHECK1(RTX, N, C1)\t\t\t\t\t\t\\\n-(*({ rtx _rtx = RTX; int _n = N;\t\t\t\t\t\\\n+(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n      enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n      if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n        rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n@@ -237,7 +237,7 @@ typedef struct rtvec_def{\n      &_rtx->fld[_n]; }))\n \n #define RTL_CHECK2(RTX, N, C1, C2)\t\t\t\t\t\\\n-(*({ rtx _rtx = RTX; int _n = N;\t\t\t\t\t\\\n+(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n      enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n      if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n        rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n@@ -248,8 +248,23 @@ typedef struct rtvec_def{\n \t\t\t       __PRETTY_FUNCTION__);\t\t\t\\\n      &_rtx->fld[_n]; }))\n \n+#define RTL_CHECKC1(RTX, N, C)\t\t\t\t\t\t\\\n+(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n+     if (GET_CODE (_rtx) != C)\t\t\t\t\t\t\\\n+       rtl_check_failed_code1 (_rtx, C, __FILE__, __LINE__,\t\t\\\n+\t\t\t       __PRETTY_FUNCTION__);\t\t\t\\\n+     &_rtx->fld[_n]; }))\n+\n+#define RTL_CHECKC2(RTX, N, C1, C2)\t\t\t\t\t\\\n+(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n+     enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n+     if (_code != C1 && _code != C2)\t\t\t\t\t\\\n+       rtl_check_failed_code2 (_rtx, C1, C2, __FILE__, __LINE__,\t\\\n+\t\t\t       __PRETTY_FUNCTION__);\t\t\t\\\n+     &_rtx->fld[_n]; }))\n+\n #define RTVEC_ELT(RTVEC, I)\t\t\t\t\t\t\\\n-(*({ rtvec _rtvec = RTVEC; int _i = I;\t\t\t\t\t\\\n+(*({ rtvec _rtvec = (RTVEC); int _i = (I);\t\t\t\t\\\n      if (_i < 0 || _i >= GET_NUM_ELEM (_rtvec))\t\t\t\t\\\n        rtvec_check_failed_bounds (_rtvec, _i, __FILE__, __LINE__,\t\\\n \t\t\t\t  __PRETTY_FUNCTION__);\t\t\t\\\n@@ -264,15 +279,23 @@ extern void rtl_check_failed_type1 PROTO((rtx, int, int,\n extern void rtl_check_failed_type2 PROTO((rtx, int, int, int,\n \t\t\t\t\t  const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n+extern void rtl_check_failed_code1 PROTO((rtx, enum rtx_code,\n+\t\t\t\t\t  const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+extern void rtl_check_failed_code2 PROTO((rtx, enum rtx_code, enum rtx_code,\n+\t\t\t\t\t  const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n extern void rtvec_check_failed_bounds PROTO((rtvec, int,\n \t\t\t\t\t     const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n \n #else   /* not ENABLE_CHECKING */\n \n-#define RTL_CHECK1(RTX, N, C1)     ((RTX)->fld[N])\n-#define RTL_CHECK2(RTX, N, C1, C2) ((RTX)->fld[N])\n-#define RTVEC_ELT(RTVEC, I)\t   ((RTVEC)->elem[I])\n+#define RTL_CHECK1(RTX, N, C1)      ((RTX)->fld[N])\n+#define RTL_CHECK2(RTX, N, C1, C2)  ((RTX)->fld[N])\n+#define RTL_CHECKC1(RTX, N, C)\t    ((RTX)->fld[N])\n+#define RTL_CHECKC2(RTX, N, C1, C1) ((RTX)->fld[N])\n+#define RTVEC_ELT(RTVEC, I)\t    ((RTVEC)->elem[I])\n \n #endif\n \n@@ -303,6 +326,21 @@ extern void rtvec_check_failed_bounds PROTO((rtvec, int,\n #define X0BBDEF(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').bb)\n #define X0ADVFLAGS(RTX, N) (RTL_CHECK1(RTX, N, '0').rt_addr_diff_vec_flags)\n \n+#define XCWINT(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rtwint)\n+#define XCINT(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtint)\n+#define XCSTR(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtstr)\n+#define XCEXP(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtx)\n+#define XCVEC(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtvec)\n+#define XCMODE(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rttype)\n+#define XCBITMAP(RTX, N, C)   (RTL_CHECKC1(RTX, N, C).rtbit)\n+#define XCTREE(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rttree)\n+#define XCBBDEF(RTX, N, C)    (RTL_CHECKC1(RTX, N, C).bb)\n+#define XCADVFLAGS(RTX, N, C) (RTL_CHECKC1(RTX, N, C).rt_addr_diff_vec_flags)\n+\n+#define XCVECEXP(RTX, N, M, C)\tRTVEC_ELT (XCVEC (RTX, N, C), M)\n+#define XCVECLEN(RTX, N, C)\tGET_NUM_ELEM (XCVEC (RTX, N, C))\n+\n+#define XC2EXP(RTX, N, C1, C2)      (RTL_CHECKC2(RTX, N, C1, C2).rtx)\n \f\n /* ACCESS MACROS for particular fields of insns.  */\n \n@@ -471,20 +509,20 @@ extern const char * const reg_note_name[];\n    The NOTE_INSN_RANGE_{START,END} and NOTE_INSN_LIVE notes record their\n    information as a rtx in the field.  */\n \n-#define NOTE_SOURCE_FILE(INSN) \tX0STR(INSN, 3)\n-#define NOTE_BLOCK_NUMBER(INSN)\tX0INT(INSN, 3)\n-#define NOTE_EH_HANDLER(INSN)\tX0INT(INSN, 3)\n-#define NOTE_RANGE_INFO(INSN)  \tX0EXP(INSN, 3)\n-#define NOTE_LIVE_INFO(INSN)   \tX0EXP(INSN, 3)\n-#define NOTE_BASIC_BLOCK(INSN)\tX0BBDEF(INSN, 3)\n+#define NOTE_SOURCE_FILE(INSN) \tXCSTR(INSN, 3, NOTE)\n+#define NOTE_BLOCK_NUMBER(INSN)\tXCINT(INSN, 3, NOTE)\n+#define NOTE_EH_HANDLER(INSN)\tXCINT(INSN, 3, NOTE)\n+#define NOTE_RANGE_INFO(INSN)  \tXCEXP(INSN, 3, NOTE)\n+#define NOTE_LIVE_INFO(INSN)   \tXCEXP(INSN, 3, NOTE)\n+#define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF(INSN, 3, NOTE)\n \n /* If the NOTE_BLOCK_NUMBER field gets a -1, it means create a new\n    block node for a live range block.  */\n #define NOTE_BLOCK_LIVE_RANGE_BLOCK -1\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n-#define NOTE_LINE_NUMBER(INSN) XINT(INSN, 4)\n+#define NOTE_LINE_NUMBER(INSN) XCINT(INSN, 4, NOTE)\n \n /* Codes that appear in the NOTE_LINE_NUMBER field\n    for kinds of notes that are not line numbers.\n@@ -552,43 +590,43 @@ extern const char * const note_insn_name[];\n \n /* The name of a label, in case it corresponds to an explicit label\n    in the input source code.  */\n-#define LABEL_NAME(LABEL) XSTR(LABEL, 4)\n+#define LABEL_NAME(RTX) XCSTR(RTX, 4, CODE_LABEL)\n \n /* In jump.c, each label contains a count of the number\n    of LABEL_REFs that point at it, so unused labels can be deleted.  */\n-#define LABEL_NUSES(LABEL) X0INT(LABEL, 5)\n+#define LABEL_NUSES(RTX) XCINT(RTX, 5, CODE_LABEL)\n \n /* The original regno this ADDRESSOF was built for.  */\n-#define ADDRESSOF_REGNO(RTX) XINT(RTX, 1)\n+#define ADDRESSOF_REGNO(RTX) XCINT(RTX, 1, ADDRESSOF)\n \n /* The variable in the register we took the address of.  */\n-#define ADDRESSOF_DECL(RTX) XTREE(RTX, 2)\n+#define ADDRESSOF_DECL(RTX) XCTREE(RTX, 2, ADDRESSOF)\n \n /* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n    so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n    be decremented and possibly the label can be deleted.  */\n-#define JUMP_LABEL(INSN)   X0EXP(INSN, 7)\n+#define JUMP_LABEL(INSN)   XCEXP(INSN, 7, JUMP_INSN)\n \n /* Once basic blocks are found in flow.c,\n    each CODE_LABEL starts a chain that goes through\n    all the LABEL_REFs that jump to that label.\n    The chain eventually winds up at the CODE_LABEL; it is circular.  */\n-#define LABEL_REFS(LABEL) X0EXP(LABEL, 6)\n+#define LABEL_REFS(LABEL) XCEXP(LABEL, 6, CODE_LABEL)\n \f\n /* This is the field in the LABEL_REF through which the circular chain\n    of references to a particular label is linked.\n    This chain is set up in flow.c.  */\n \n-#define LABEL_NEXTREF(REF) X0EXP(REF, 1)\n+#define LABEL_NEXTREF(REF) XCEXP(REF, 1, LABEL_REF)\n \n /* Once basic blocks are found in flow.c,\n    Each LABEL_REF points to its containing instruction with this field.  */\n \n-#define CONTAINING_INSN(RTX) X0EXP(RTX, 2)\n+#define CONTAINING_INSN(RTX) XCEXP(RTX, 2, LABEL_REF)\n \n /* For a REG rtx, REGNO extracts the register number.  */\n \n-#define REGNO(RTX) XINT(RTX, 0)\n+#define REGNO(RTX) XCINT(RTX, 0, REG)\n \n /* For a REG rtx, REG_FUNCTION_VALUE_P is nonzero if the reg\n    is the current function's return value.  */\n@@ -600,13 +638,13 @@ extern const char * const note_insn_name[];\n \n /* For a CONST_INT rtx, INTVAL extracts the integer.  */\n \n-#define INTVAL(RTX) XWINT(RTX, 0)\n+#define INTVAL(RTX) XCWINT(RTX, 0, CONST_INT)\n \n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n    SUBREG_WORD extracts the word-number.  */\n \n-#define SUBREG_REG(RTX) XEXP(RTX, 0)\n-#define SUBREG_WORD(RTX) XINT(RTX, 1)\n+#define SUBREG_REG(RTX) XCEXP(RTX, 0, SUBREG)\n+#define SUBREG_WORD(RTX) XCINT(RTX, 1, SUBREG)\n \n /* 1 if the REG contained in SUBREG_REG is already known to be\n    sign- or zero-extended from the mode of the SUBREG to the mode of\n@@ -621,17 +659,17 @@ extern const char * const note_insn_name[];\n \n /* Access various components of an ASM_OPERANDS rtx.  */\n \n-#define ASM_OPERANDS_TEMPLATE(RTX) XSTR ((RTX), 0)\n-#define ASM_OPERANDS_OUTPUT_CONSTRAINT(RTX) XSTR ((RTX), 1)\n-#define ASM_OPERANDS_OUTPUT_IDX(RTX) XINT ((RTX), 2)\n-#define ASM_OPERANDS_INPUT_VEC(RTX) XVEC ((RTX), 3)\n-#define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XVEC ((RTX), 4)\n-#define ASM_OPERANDS_INPUT(RTX, N) XVECEXP ((RTX), 3, (N))\n-#define ASM_OPERANDS_INPUT_LENGTH(RTX) XVECLEN ((RTX), 3)\n-#define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) XSTR (XVECEXP ((RTX), 4, (N)), 0)\n-#define ASM_OPERANDS_INPUT_MODE(RTX, N) GET_MODE (XVECEXP ((RTX), 4, (N)))\n-#define ASM_OPERANDS_SOURCE_FILE(RTX) XSTR ((RTX), 5)\n-#define ASM_OPERANDS_SOURCE_LINE(RTX) XINT ((RTX), 6)\n+#define ASM_OPERANDS_TEMPLATE(RTX) XCSTR ((RTX), 0, ASM_OPERANDS)\n+#define ASM_OPERANDS_OUTPUT_CONSTRAINT(RTX) XCSTR ((RTX), 1, ASM_OPERANDS)\n+#define ASM_OPERANDS_OUTPUT_IDX(RTX) XCINT ((RTX), 2, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT_VEC(RTX) XCVEC ((RTX), 3, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XCVEC ((RTX), 4, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT(RTX, N) XCVECEXP ((RTX), 3, (N), ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT_LENGTH(RTX) XCVECLEN ((RTX), 3, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) XSTR (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS), 0)\n+#define ASM_OPERANDS_INPUT_MODE(RTX, N) GET_MODE (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS))\n+#define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR ((RTX), 5, ASM_OPERANDS)\n+#define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT ((RTX), 6, ASM_OPERANDS)\n \n /* For a MEM rtx, 1 if it's a volatile reference.\n    Also in an ASM_OPERANDS rtx.  */\n@@ -669,7 +707,7 @@ extern const char * const note_insn_name[];\n    some front-ends, these numbers may correspond in some way to types,\n    or other language-level entities, but they need not, and the\n    back-end makes no such assumptions.  */\n-#define MEM_ALIAS_SET(RTX) X0INT(RTX, 1)\n+#define MEM_ALIAS_SET(RTX) XCINT(RTX, 1, MEM)\n \n /* For a LABEL_REF, 1 means that this reference is to a label outside the\n    loop containing the reference.  */\n@@ -701,12 +739,12 @@ extern const char * const note_insn_name[];\n \n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n-#define SET_DEST(RTX) XEXP(RTX, 0)\n-#define SET_SRC(RTX) XEXP(RTX, 1)\n+#define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)\n+#define SET_SRC(RTX) XCEXP(RTX, 1, SET)\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n-#define TRAP_CONDITION(RTX) XEXP(RTX, 0)\n-#define TRAP_CODE(RTX) XEXP(RTX, 1)\n+#define TRAP_CONDITION(RTX) XCEXP(RTX, 0, TRAP_IF)\n+#define TRAP_CODE(RTX) XCEXP(RTX, 1, TRAP_IF)\n \n /* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n #define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n@@ -795,81 +833,81 @@ extern const char * const note_insn_name[];\n \n /* Accessors for RANGE_INFO.  */\n /* For RANGE_{START,END} notes return the RANGE_START note.  */\n-#define RANGE_INFO_NOTE_START(INSN) (XEXP (INSN, 0))\n+#define RANGE_INFO_NOTE_START(INSN) XCEXP (INSN, 0, RANGE_INFO)\n \n /* For RANGE_{START,END} notes return the RANGE_START note.  */\n-#define RANGE_INFO_NOTE_END(INSN) (XEXP (INSN, 1))\n+#define RANGE_INFO_NOTE_END(INSN) XCEXP (INSN, 1, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, return the vector containing the registers used\n    in the range.  */\n-#define RANGE_INFO_REGS(INSN) (XVEC (INSN, 2))\n-#define RANGE_INFO_REGS_REG(INSN, N) (XVECEXP (INSN, 2, N))\n-#define RANGE_INFO_NUM_REGS(INSN) (XVECLEN (INSN, 2))\n+#define RANGE_INFO_REGS(INSN) XCVEC (INSN, 2, RANGE_INFO)\n+#define RANGE_INFO_REGS_REG(INSN, N) XCVECEXP (INSN, 2, N, RANGE_INFO)\n+#define RANGE_INFO_NUM_REGS(INSN) XCVECLEN (INSN, 2, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, the number of calls within the range.  */\n-#define RANGE_INFO_NCALLS(INSN) (XINT (INSN, 3))\n+#define RANGE_INFO_NCALLS(INSN) XCINT (INSN, 3, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, the number of insns within the range.  */\n-#define RANGE_INFO_NINSNS(INSN) (XINT (INSN, 4))\n+#define RANGE_INFO_NINSNS(INSN) XCINT (INSN, 4, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, a unique # to identify this range.  */\n-#define RANGE_INFO_UNIQUE(INSN) (XINT (INSN, 5))\n+#define RANGE_INFO_UNIQUE(INSN) XCINT (INSN, 5, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, the basic block # the range starts with. */\n-#define RANGE_INFO_BB_START(INSN) (XINT (INSN, 6))\n+#define RANGE_INFO_BB_START(INSN) XCINT (INSN, 6, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, the basic block # the range ends with. */\n-#define RANGE_INFO_BB_END(INSN) (XINT (INSN, 7))\n+#define RANGE_INFO_BB_END(INSN) XCINT (INSN, 7, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, the loop depth the range is in.  */\n-#define RANGE_INFO_LOOP_DEPTH(INSN) (XINT (INSN, 8))\n+#define RANGE_INFO_LOOP_DEPTH(INSN) XCINT (INSN, 8, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, the bitmap of live registers at the start\n    of the range.  */\n-#define RANGE_INFO_LIVE_START(INSN) (XBITMAP (INSN, 9))\n+#define RANGE_INFO_LIVE_START(INSN) XCBITMAP (INSN, 9, RANGE_INFO)\n \n /* For RANGE_{START,END} notes, the bitmap of live registers at the end\n    of the range.  */\n-#define RANGE_INFO_LIVE_END(INSN) (XBITMAP (INSN, 10))\n+#define RANGE_INFO_LIVE_END(INSN) XCBITMAP (INSN, 10, RANGE_INFO)\n \n /* For RANGE_START notes, the marker # of the start of the range.  */\n-#define RANGE_INFO_MARKER_START(INSN) (XINT (INSN, 11))\n+#define RANGE_INFO_MARKER_START(INSN) XCINT (INSN, 11, RANGE_INFO)\n \n /* For RANGE_START notes, the marker # of the end of the range.  */\n-#define RANGE_INFO_MARKER_END(INSN) (XINT (INSN, 12))\n+#define RANGE_INFO_MARKER_END(INSN) XCINT (INSN, 12, RANGE_INFO)\n \n /* Original pseudo register # for a live range note.  */\n-#define RANGE_REG_PSEUDO(INSN,N) (XINT (XVECEXP (INSN, 2, N), 0))\n+#define RANGE_REG_PSEUDO(INSN,N) XCINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 0, REG)\n \n /* Pseudo register # original register is copied into or -1.  */\n-#define RANGE_REG_COPY(INSN,N) (XINT (XVECEXP (INSN, 2, N), 1))\n+#define RANGE_REG_COPY(INSN,N) XCINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 1, REG)\n \n /* How many times a register in a live range note was referenced.  */\n-#define RANGE_REG_REFS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 2))\n+#define RANGE_REG_REFS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 2)\n \n /* How many times a register in a live range note was set.  */\n-#define RANGE_REG_SETS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 3))\n+#define RANGE_REG_SETS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 3)\n \n /* How many times a register in a live range note died.  */\n-#define RANGE_REG_DEATHS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 4))\n+#define RANGE_REG_DEATHS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 4)\n \n /* Whether the original value is needed to be copied into the range register at\n    the start of the range. */\n-#define RANGE_REG_COPY_FLAGS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 5))\n+#define RANGE_REG_COPY_FLAGS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 5)\n \n /* # of insns the register copy is live over.  */\n-#define RANGE_REG_LIVE_LENGTH(INSN,N) (XINT (XVECEXP (INSN, 2, N), 6))\n+#define RANGE_REG_LIVE_LENGTH(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 6)\n \n /* # of calls the register copy is live over.  */\n-#define RANGE_REG_N_CALLS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 7))\n+#define RANGE_REG_N_CALLS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 7)\n \n /* DECL_NODE pointer of the declaration if the register is a user defined\n    variable.  */\n-#define RANGE_REG_SYMBOL_NODE(INSN,N) (XTREE (XVECEXP (INSN, 2, N), 8))\n+#define RANGE_REG_SYMBOL_NODE(INSN,N) XTREE (XCVECEXP (INSN, 2, N, RANGE_INFO), 8)\n \n /* BLOCK_NODE pointer to the block the variable is declared in if the\n    register is a user defined variable.  */\n-#define RANGE_REG_BLOCK_NODE(INSN,N) (XTREE (XVECEXP (INSN, 2, N), 9))\n+#define RANGE_REG_BLOCK_NODE(INSN,N) XTREE (XCVECEXP (INSN, 2, N, RANGE_INFO), 9)\n \n /* EXPR_LIST of the distinct ranges a variable is in.  */\n #define RANGE_VAR_LIST(INSN) (XEXP (INSN, 0))"}, {"sha": "d1b23222ad7986a25880dae465ce49ffd7adb12d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ab38394c997f79c65461de172700f1a0955be8/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=83ab38394c997f79c65461de172700f1a0955be8", "patch": "@@ -1495,18 +1495,16 @@ find_regno_fusage (insn, code, regno)\n     return 0;\n \n   for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-   {\n-    register int regnote;\n-    register rtx op;\n-\n-    if (GET_CODE (op = XEXP (link, 0)) == code\n-\t&& GET_CODE (SET_DEST (op)) == REG\n-\t&& (regnote = REGNO (SET_DEST (op))) <= regno\n-\t&& regnote\n-\t\t+ HARD_REGNO_NREGS (regnote, GET_MODE (SET_DEST (op)))\n-\t    > regno)\n-      return 1;\n-   }\n+    {\n+      register int regnote;\n+      register rtx op, reg;\n+\n+      if (GET_CODE (op = XEXP (link, 0)) == code\n+\t  && GET_CODE (reg = XEXP (op, 0)) == REG\n+\t  && (regnote = REGNO (reg)) <= regno\n+\t  && regnote + HARD_REGNO_NREGS (regnote, GET_MODE (reg)) > regno)\n+\treturn 1;\n+    }\n \n   return 0;\n }"}]}