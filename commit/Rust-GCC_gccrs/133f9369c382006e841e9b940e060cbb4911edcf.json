{"sha": "133f9369c382006e841e9b940e060cbb4911edcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMzZjkzNjljMzgyMDA2ZTg0MWU5Yjk0MGUwNjBjYmI0OTExZWRjZg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-03-30T13:06:52Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-03-30T13:06:52Z"}, "message": "ipa-prop.h (jump_func_type): Rename IPA_UNKNOWN...\n\n2009-03-30  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (jump_func_type): Rename IPA_UNKNOWN, IPA_CONST,\n\tIPA_CONST_MEMBER_PTR, and IPA_PASS_THROUGH to IPA_JF_UNKNOWN,\n\tIPA_JF_CONST, IPA_JF_CONST_MEMBER_PTR, and IPA_JF_PASS_THROUGH\n\trespectively.\n\n\t* tree-dfa.c (get_ref_base_and_extent): Return -1 maxsize if\n\tseen_variable_array_ref while also traversing a union.\n\n\t* tree-inline.c (optimize_inline_calls): Do not call\n\tcgraph_node_remove_callees.\n\t* cgraphbuild.c (remove_cgraph_callee_edges): New function.\n\t(pass_remove_cgraph_callee_edges): New variable.\n\t* passes.c (init_optimization_passes): Add\n\tpass_remove_cgraph_callee_edges after early inlining and before all\n\tlate intraprocedural passes.\n\n\t* omp-low.c (expand_omp_taskreg): Always set current_function_decl.\n\nFrom-SVN: r145291", "tree": {"sha": "a998017d535126ebe28c42696a5e141a4c23b459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a998017d535126ebe28c42696a5e141a4c23b459"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/133f9369c382006e841e9b940e060cbb4911edcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133f9369c382006e841e9b940e060cbb4911edcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/133f9369c382006e841e9b940e060cbb4911edcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133f9369c382006e841e9b940e060cbb4911edcf/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77a08224eed85b4dc2baa566531ee21c8773302a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a08224eed85b4dc2baa566531ee21c8773302a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77a08224eed85b4dc2baa566531ee21c8773302a"}], "stats": {"total": 139, "additions": 102, "deletions": 37}, "files": [{"sha": "1215863c452b462b92b5293ec4f85bc83fed3909", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -1,3 +1,23 @@\n+2009-03-30  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (jump_func_type): Rename IPA_UNKNOWN, IPA_CONST,\n+\tIPA_CONST_MEMBER_PTR, and IPA_PASS_THROUGH to IPA_JF_UNKNOWN,\n+\tIPA_JF_CONST, IPA_JF_CONST_MEMBER_PTR, and IPA_JF_PASS_THROUGH\n+\trespectively.\n+\n+\t* tree-dfa.c (get_ref_base_and_extent): Return -1 maxsize if\n+\tseen_variable_array_ref while also traversing a union.\n+\n+\t* tree-inline.c (optimize_inline_calls): Do not call\n+\tcgraph_node_remove_callees.\n+\t* cgraphbuild.c (remove_cgraph_callee_edges): New function.\n+\t(pass_remove_cgraph_callee_edges): New variable.\n+\t* passes.c (init_optimization_passes): Add\n+\tpass_remove_cgraph_callee_edges after early inlining and before all\n+\tlate intraprocedural passes.\n+\n+\t* omp-low.c (expand_omp_taskreg): Always set current_function_decl.\n+\n 2009-03-30  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/sparc/sparc.md (*nand<V64mode>_vis, *nand<V32mode>_vis):"}, {"sha": "c7d6aa72329729f54aca21fe69ec5d2b5d9e7c82", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -251,3 +251,30 @@ struct gimple_opt_pass pass_rebuild_cgraph_edges =\n   0,\t\t\t\t\t/* todo_flags_finish */\n  }\n };\n+\n+\n+static unsigned int\n+remove_cgraph_callee_edges (void)\n+{\n+  cgraph_node_remove_callees (cgraph_node (current_function_decl));\n+  return 0;\n+}\n+\n+struct gimple_opt_pass pass_remove_cgraph_callee_edges =\n+{\n+ {\n+  GIMPLE_PASS,\n+  NULL,\t\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  remove_cgraph_callee_edges,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+ }\n+};"}, {"sha": "3fae0297a7886371d4981b77955349befc0152d1", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -310,12 +310,12 @@ static void\n ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n \t\t\t struct ipa_jump_func *jfunc)\n {\n-  if (jfunc->type == IPA_CONST)\n+  if (jfunc->type == IPA_JF_CONST)\n     {\n       lat->type = IPA_CONST_VALUE;\n       lat->constant = jfunc->value.constant;\n     }\n-  else if (jfunc->type == IPA_PASS_THROUGH)\n+  else if (jfunc->type == IPA_JF_PASS_THROUGH)\n     {\n       struct ipcp_lattice *caller_lat;\n \n@@ -916,7 +916,7 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n       if (ipcp_lat_is_const (lat))\n \t{\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t  if (jump_func->type != IPA_CONST)\n+\t  if (jump_func->type != IPA_JF_CONST)\n \t    return true;\n \t}\n     }"}, {"sha": "eab3aa7249a8dd4b95350957a09b8375055856e0", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -293,24 +293,24 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \t  type = jump_func->type;\n \n \t  fprintf (f, \"       param %d: \", i);\n-\t  if (type == IPA_UNKNOWN)\n+\t  if (type == IPA_JF_UNKNOWN)\n \t    fprintf (f, \"UNKNOWN\\n\");\n-\t  else if (type == IPA_CONST)\n+\t  else if (type == IPA_JF_CONST)\n  \t    {\n \t      tree val = jump_func->value.constant;\n \t      fprintf (f, \"CONST: \");\n \t      print_generic_expr (f, val, 0);\n \t      fprintf (f, \"\\n\");\n \t    }\n-\t  else if (type == IPA_CONST_MEMBER_PTR)\n+\t  else if (type == IPA_JF_CONST_MEMBER_PTR)\n \t    {\n \t      fprintf (f, \"CONST MEMBER PTR: \");\n \t      print_generic_expr (f, jump_func->value.member_cst.pfn, 0);\n \t      fprintf (f, \", \");\n \t      print_generic_expr (f, jump_func->value.member_cst.delta, 0);\n \t      fprintf (f, \"\\n\");\n \t    }\n-\t  else if (type == IPA_PASS_THROUGH)\n+\t  else if (type == IPA_JF_PASS_THROUGH)\n  \t    {\n \t      fprintf (f, \"PASS THROUGH: \");\n \t      fprintf (f, \"%d\\n\", jump_func->value.formal_id);\n@@ -353,7 +353,7 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \n       if (is_gimple_ip_invariant (arg))\n \t{\n-\t  functions[num].type = IPA_CONST;\n+\t  functions[num].type = IPA_JF_CONST;\n \t  functions[num].value.constant = arg;\n \t}\n       else if ((TREE_CODE (arg) == SSA_NAME) && SSA_NAME_IS_DEFAULT_DEF (arg))\n@@ -362,7 +362,7 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \n \t  if (index >= 0)\n \t    {\n-\t      functions[num].type = IPA_PASS_THROUGH;\n+\t      functions[num].type = IPA_JF_PASS_THROUGH;\n \t      functions[num].value.formal_id = index;\n \t    }\n \t}\n@@ -430,7 +430,7 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t      gcc_assert (index >=0);\n \t      if (!ipa_is_param_modified (info, index))\n \t\t{\n-\t\t  functions[num].type = IPA_PASS_THROUGH;\n+\t\t  functions[num].type = IPA_JF_PASS_THROUGH;\n \t\t  functions[num].value.formal_id = index;\n \t\t}\n \t      else\n@@ -451,7 +451,7 @@ static void\n fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n \t\t\t\t   tree pfn, tree delta)\n {\n-  jfunc->type = IPA_CONST_MEMBER_PTR;\n+  jfunc->type = IPA_JF_CONST_MEMBER_PTR;\n   jfunc->value.member_cst.pfn = pfn;\n   jfunc->value.member_cst.delta = delta;\n }\n@@ -545,7 +545,7 @@ compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n     {\n       arg = gimple_call_arg (call, num);\n \n-      if (functions[num].type == IPA_UNKNOWN\n+      if (functions[num].type == IPA_JF_UNKNOWN\n \t  && type_like_member_ptr_p (TREE_TYPE (arg), &method_field,\n \t\t\t\t     &delta_field))\n \tdetermine_cst_member_ptr (call, arg, method_field, delta_field,\n@@ -885,7 +885,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n     {\n       struct ipa_jump_func *src, *dst = ipa_get_ith_jump_func (args, i);\n \n-      if (dst->type != IPA_PASS_THROUGH)\n+      if (dst->type != IPA_JF_PASS_THROUGH)\n \tcontinue;\n \n       /* We must check range due to calls with variable number of arguments:  */\n@@ -910,7 +910,7 @@ print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n \t\t\t     struct cgraph_node *node)\n {\n   fprintf (f, \"ipa-prop: Discovered an indirect call to a known target (\");\n-  if (jfunc->type == IPA_CONST_MEMBER_PTR)\n+  if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n     {\n       print_node_brief (f, \"\", jfunc->value.member_cst.pfn, 0);\n       print_node_brief (f, \", \", jfunc->value.member_cst.delta, 0);\n@@ -953,16 +953,17 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n \t}\n \n       jfunc = ipa_get_ith_jump_func (top, nt->formal_id);\n-      if (jfunc->type == IPA_PASS_THROUGH)\n+      if (jfunc->type == IPA_JF_PASS_THROUGH)\n \tnt->formal_id = jfunc->value.formal_id;\n-      else if (jfunc->type == IPA_CONST || jfunc->type == IPA_CONST_MEMBER_PTR)\n+      else if (jfunc->type == IPA_JF_CONST\n+\t       || jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n \t{\n \t  struct cgraph_node *callee;\n \t  struct cgraph_edge *new_indirect_edge;\n \t  tree decl;\n \n \t  nt->processed = true;\n-\t  if (jfunc->type == IPA_CONST_MEMBER_PTR)\n+\t  if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n \t    decl = jfunc->value.member_cst.pfn;\n \t  else\n \t    decl = jfunc->value.constant;"}, {"sha": "5943a2af6f49a35b624c081b3ca71ff523066c5a", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -25,21 +25,24 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n \n /* The following definitions and interfaces are used by\n-   interprocedural analyses.  */\n+   interprocedural analyses or parameters.  */\n+\n+/* ipa-prop.c stuff (ipa-cp, indirect inlining):  */\n \n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. There are three main types of values :\n    Formal - the caller's formal parameter is passed as an actual argument.\n    Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n-   Integer and real constants are represented as IPA_CONST.\n-   Finally, IPA_CONST_MEMBER_PTR stands for C++ member pointers constants.  */\n+   Integer and real constants are represented as IPA_JF_CONST.\n+   Finally, IPA_JF_CONST_MEMBER_PTR stands for C++ member pointers\n+   constants.  */\n enum jump_func_type\n {\n-  IPA_UNKNOWN = 0,     /* newly allocated and zeroed jump functions default */\n-  IPA_CONST,\n-  IPA_CONST_MEMBER_PTR,\n-  IPA_PASS_THROUGH\n+  IPA_JF_UNKNOWN = 0,  /* newly allocated and zeroed jump functions default */\n+  IPA_JF_CONST,\n+  IPA_JF_CONST_MEMBER_PTR,\n+  IPA_JF_PASS_THROUGH\n };\n \n /* All formal parameters in the program have a lattice associated with it\n@@ -50,7 +53,7 @@ enum jump_func_type\n    IPA_CONST_VALUE - simple scalar constant,\n    Cval of formal f will have a constant value if all callsites to this\n    function have the same constant value passed to f.\n-   Integer and real constants are represented as IPA_CONST.  */\n+   Integer and real constants are represented as IPA_CONST_VALUE.  */\n enum ipa_lattice_type\n {\n   IPA_BOTTOM,"}, {"sha": "40658760d38c1b08e16eedc10eb2bee41e7edb29", "filename": "gcc/omp-low.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -3244,6 +3244,7 @@ expand_omp_taskreg (struct omp_region *region)\n   basic_block entry_bb, exit_bb, new_bb;\n   struct function *child_cfun;\n   tree child_fn, block, t, ws_args, *tp;\n+  tree save_current;\n   gimple_stmt_iterator gsi;\n   gimple entry_stmt, stmt;\n   edge e;\n@@ -3429,6 +3430,8 @@ expand_omp_taskreg (struct omp_region *region)\n       /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n \t fixed in a following pass.  */\n       push_cfun (child_cfun);\n+      save_current = current_function_decl;\n+      current_function_decl = child_fn;\n       if (optimize)\n \toptimize_omp_library_calls (entry_stmt);\n       rebuild_cgraph_edges ();\n@@ -3440,16 +3443,14 @@ expand_omp_taskreg (struct omp_region *region)\n       if (flag_exceptions)\n \t{\n \t  basic_block bb;\n-\t  tree save_current = current_function_decl;\n \t  bool changed = false;\n \n-\t  current_function_decl = child_fn;\n \t  FOR_EACH_BB (bb)\n \t    changed |= gimple_purge_dead_eh_edges (bb);\n \t  if (changed)\n \t    cleanup_tree_cfg ();\n-\t  current_function_decl = save_current;\n \t}\n+      current_function_decl = save_current;\n       pop_cfun ();\n     }\n   "}, {"sha": "4e8944ae1f77d92b20162b54be7363e77f431aab", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -551,6 +551,7 @@ init_optimization_passes (void)\n \t  struct opt_pass **p = &pass_all_early_optimizations.pass.sub;\n \t  NEXT_PASS (pass_rebuild_cgraph_edges);\n \t  NEXT_PASS (pass_early_inline);\n+\t  NEXT_PASS (pass_remove_cgraph_callee_edges);\n \t  NEXT_PASS (pass_rename_ssa_copies);\n \t  NEXT_PASS (pass_ccp);\n \t  NEXT_PASS (pass_forwprop);\n@@ -587,6 +588,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_all_optimizations);\n     {\n       struct opt_pass **p = &pass_all_optimizations.pass.sub;\n+      NEXT_PASS (pass_remove_cgraph_callee_edges);\n       /* Initial scalar cleanups before alias computation.\n \t They ensure memory accesses are not indirect wherever possible.  */\n       NEXT_PASS (pass_strip_predict_hints);"}, {"sha": "082ac082bf382ebd7f81d0492fd1c14df68b44c7", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -801,6 +801,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   tree size_tree = NULL_TREE;\n   HOST_WIDE_INT bit_offset = 0;\n   bool seen_variable_array_ref = false;\n+  bool seen_union = false;\n \n   gcc_assert (!SSA_VAR_P (exp));\n \n@@ -844,6 +845,9 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t    tree field = TREE_OPERAND (exp, 1);\n \t    tree this_offset = component_ref_field_offset (exp);\n \n+\t    if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == UNION_TYPE)\n+\t      seen_union = true;\n+\n \t    if (this_offset && TREE_CODE (this_offset) == INTEGER_CST)\n \t      {\n \t\tHOST_WIDE_INT hthis_offset = tree_low_cst (this_offset, 0);\n@@ -934,12 +938,22 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n      where we do not know maxsize for variable index accesses to\n      the array.  The simplest way to conservatively deal with this\n      is to punt in the case that offset + maxsize reaches the\n-     base type boundary.  */\n+     base type boundary.\n+\n+     Unfortunately this is difficult to determine reliably when unions are\n+     involved and so we are conservative in such cases.\n+\n+     FIXME: This approach may be too conservative, we probably want to at least\n+     check that the union is the last field/element at its level or even\n+     propagate the calculated offsets back up the access chain and check\n+     there.  */\n+\n   if (seen_variable_array_ref\n-      && maxsize != -1\n-      && host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n-      && bit_offset + maxsize\n-\t   == (signed)TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))))\n+      && (seen_union\n+\t  || (maxsize != -1\n+\t      && host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n+\t      && bit_offset + maxsize\n+\t      == (signed) TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))))))\n     maxsize = -1;\n \n   /* ???  Due to negative offsets in ARRAY_REF we can end up with"}, {"sha": "609a0818ad77d8dae2e4023170658a8a576ed908", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -3639,10 +3639,6 @@ optimize_inline_calls (tree fn)\n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (fn);\n \n-  /* We are not going to maintain the cgraph edges up to date.\n-     Kill it so it won't confuse us.  */\n-  cgraph_node_remove_callees (id.dst_node);\n-\n   fold_cond_expr_cond ();\n \n   /* It would be nice to check SSA/CFG/statement consistency here, but it is"}, {"sha": "2db0f226510cff7e4883392f95f75ab33858b9c9", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133f9369c382006e841e9b940e060cbb4911edcf/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=133f9369c382006e841e9b940e060cbb4911edcf", "patch": "@@ -389,6 +389,7 @@ extern struct gimple_opt_pass pass_uncprop;\n extern struct gimple_opt_pass pass_return_slot;\n extern struct gimple_opt_pass pass_reassoc;\n extern struct gimple_opt_pass pass_rebuild_cgraph_edges;\n+extern struct gimple_opt_pass pass_remove_cgraph_callee_edges;\n extern struct gimple_opt_pass pass_build_cgraph_edges;\n extern struct gimple_opt_pass pass_reset_cc_flags;\n extern struct gimple_opt_pass pass_local_pure_const;"}]}