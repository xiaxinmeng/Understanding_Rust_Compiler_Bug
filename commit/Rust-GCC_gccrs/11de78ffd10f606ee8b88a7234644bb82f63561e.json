{"sha": "11de78ffd10f606ee8b88a7234644bb82f63561e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFkZTc4ZmZkMTBmNjA2ZWU4Yjg4YTcyMzQ2NDRiYjgyZjYzNTYxZQ==", "commit": {"author": {"name": "Brooks Moses", "email": "brooks.moses@codesourcery.com", "date": "2007-01-04T01:02:40Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2007-01-04T01:02:40Z"}, "message": "gfortran.texi (GFORTRAN_DEFAULT_RECL): Added units to description.\n\n* gfortran.texi (GFORTRAN_DEFAULT_RECL): Added units\nto description.\n(Extensions): Miscellaneous minor rewriting and copyediting.\n(BOZ-literal constants): Renamed from Hexadecimal constants.\n(Hollerith constants support): Added explanation and \nsuggestions for standard-conforming modern equivalents.\n\nFrom-SVN: r120422", "tree": {"sha": "dcf1ac5f0278a40b438ea0c80d04eb186dfcecec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf1ac5f0278a40b438ea0c80d04eb186dfcecec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11de78ffd10f606ee8b88a7234644bb82f63561e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11de78ffd10f606ee8b88a7234644bb82f63561e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11de78ffd10f606ee8b88a7234644bb82f63561e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11de78ffd10f606ee8b88a7234644bb82f63561e/comments", "author": null, "committer": null, "parents": [{"sha": "4ba96c0283e415800421dfc9a1e1263b21dabfd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba96c0283e415800421dfc9a1e1263b21dabfd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba96c0283e415800421dfc9a1e1263b21dabfd9"}], "stats": {"total": 322, "additions": 178, "deletions": 144}, "files": [{"sha": "2ef7187710eb79f72447bed5152a2e5c91cc540d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11de78ffd10f606ee8b88a7234644bb82f63561e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11de78ffd10f606ee8b88a7234644bb82f63561e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=11de78ffd10f606ee8b88a7234644bb82f63561e", "patch": "@@ -1,3 +1,12 @@\n+2007-01-03  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\t* gfortran.texi (GFORTRAN_DEFAULT_RECL): Added units\n+\tto description.\n+\t(Extensions): Miscellaneous minor rewriting and copyediting.\n+\t(BOZ-literal constants): Renamed from Hexadecimal constants.\n+\t(Hollerith constants support): Added explanation and \n+\tsuggestions for standard-conforming modern equivalents.\n+\n 2007-01-03  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* intrinsic.texi: Improvements to index entries; change"}, {"sha": "13deb73c99577e356d8e22cfc7526293c936fa66", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 169, "deletions": 144, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11de78ffd10f606ee8b88a7234644bb82f63561e/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11de78ffd10f606ee8b88a7234644bb82f63561e/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=11de78ffd10f606ee8b88a7234644bb82f63561e", "patch": "@@ -603,10 +603,10 @@ in most cases. Default is not to print plus signs.\n @node GFORTRAN_DEFAULT_RECL\n @section @env{GFORTRAN_DEFAULT_RECL}---Default record length for new files\n \n-This environment variable specifies the default record length for\n-files which are opened without a @code{RECL} tag in the @code{OPEN}\n-statement.  This must be a positive integer.  The default value is\n-1073741824.\n+This environment variable specifies the default record length, in\n+bytes, for files which are opened without a @code{RECL} tag in the\n+@code{OPEN} statement.  This must be a positive integer.  The\n+default value is 1073741824 bytes (1 GB).\n \n @node GFORTRAN_LIST_SEPARATOR\n @section @env{GFORTRAN_LIST_SEPARATOR}---Separator for list output\n@@ -811,14 +811,14 @@ of extensions, and @option{-std=legacy} allows both without warning.\n * Old-style kind specifications::\n * Old-style variable initialization::\n * Extensions to namelist::\n-* X format descriptor::\n+* X format descriptor without count field::\n * Commas in FORMAT specifications::\n * Missing period in FORMAT specifications::\n * I/O item lists::\n-* Hexadecimal constants::\n+* BOZ literal constants::\n * Real array indices::\n * Unary operators::\n-* Implicitly interconvert LOGICAL and INTEGER::\n+* Implicitly convert LOGICAL and INTEGER values::\n * Hollerith constants support::\n * Cray pointers::\n * CONVERT specifier::\n@@ -834,10 +834,11 @@ declarations. These look like:\n @smallexample\n       TYPESPEC*k x,y,z\n @end smallexample\n-where @code{TYPESPEC} is a basic type, and where @code{k} is a valid kind\n-number for that type. The statement then declares @code{x}, @code{y}\n-and @code{z} to be of type @code{TYPESPEC} with kind @code{k}. In\n-other words, it is equivalent to the standard conforming declaration\n+where @code{TYPESPEC} is a basic type (@code{INTEGER}, @code{REAL},\n+etc.), and where @code{k} is a valid kind number for that type. The\n+statement then declares @code{x}, @code{y} and @code{z} to be of\n+type @code{TYPESPEC} with kind @code{k}. This is equivalent to the\n+standard conforming declaration\n @smallexample\n       TYPESPEC(k) x,y,z\n @end smallexample\n@@ -849,30 +850,33 @@ other words, it is equivalent to the standard conforming declaration\n GNU Fortran allows old-style initialization of variables of the\n form:\n @smallexample\n-      INTEGER*4 i/1/,j/2/\n-      REAL*8 x(2,2) /3*0.,1./\n+      INTEGER i/1/,j/2/\n+      REAL x(2,2) /3*0.,1./\n @end smallexample\n-These are only allowed in declarations without double colons\n-(@code{::}), as these were introduced in Fortran 90 which also\n-introduced a new syntax for variable initializations. The syntax for\n-the individual initializers is as for the @code{DATA} statement, but\n+The syntax for the initializers is as for the @code{DATA} statement, but\n unlike in a @code{DATA} statement, an initializer only applies to the\n-variable immediately preceding. In other words, something like\n-@code{INTEGER I,J/2,3/} is not valid.\n-\n-Examples of standard conforming code equivalent to the above example, are:\n+variable immediately preceding the initialization.  In other words,\n+something like @code{INTEGER I,J/2,3/} is not valid.  This style of\n+initialization is only allowed in declarations without double colons\n+(@code{::}); the double colons were introduced in Fortran 90, which also\n+introduced a standard syntax for initializating variables in type\n+declarations.\n+\n+Examples of standard-conforming code equivalent to the above example\n+are:\n @smallexample\n ! Fortran 90\n-      INTEGER(4) :: i = 1, j = 2\n-      REAL(8) :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))\n+      INTEGER :: i = 1, j = 2\n+      REAL :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))\n ! Fortran 77\n-      INTEGER  i, j\n-      DOUBLE PRECISION x(2,2)\n-      DATA i,j,x /1,2,3*0.,1./\n+      INTEGER i, j\n+      REAL x(2,2)\n+      DATA i/1/, j/2/, x/3*0.,1./\n @end smallexample\n \n-Note that variables initialized in type declarations\n-automatically acquire the @code{SAVE} attribute.\n+Note that variables which are explicitly initialized in declarations\n+or in @code{DATA} statements automatically acquire the @code{SAVE}\n+attribute.\n \n @node Extensions to namelist\n @section Extensions to namelist\n@@ -884,21 +888,22 @@ The output from a namelist write is compatible with namelist read.  The\n output has all names in upper case and indentation to column 1 after the\n namelist name.  Two extensions are permitted:\n \n-Old-style use of $ instead of &\n+Old-style use of @samp{$} instead of @samp{&}\n @smallexample\n $MYNML\n  X(:)%Y(2) = 1.0 2.0 3.0\n  CH(1:4) = \"abcd\"\n $END\n @end smallexample\n \n-It should be noticed that the default terminator is / rather than &END.\n+It should be noted that the default terminator is @samp{/} rather than\n+@samp{&END}.\n \n Querying of the namelist when inputting from stdin. After at least\n-one space, entering ? sends to stdout the namelist name and the names of\n+one space, entering @samp{?} sends to stdout the namelist name and the names of\n the variables in the namelist:\n @smallexample\n-?\n+ ?\n \n &mynml\n  x\n@@ -907,8 +912,8 @@ the variables in the namelist:\n &end\n @end smallexample\n \n-Entering =? outputs the namelist to stdout, as if WRITE (*,NML = mynml)\n-had been called:\n+Entering @samp{=?} outputs the namelist to stdout, as if\n+@code{WRITE(*,NML = mynml)} had been called:\n @smallexample\n =?\n \n@@ -920,9 +925,10 @@ had been called:\n @end smallexample\n \n To aid this dialog, when input is from stdin, errors send their\n-messages to stderr and execution continues, even if IOSTAT is set.\n+messages to stderr and execution continues, even if @code{IOSTAT} is set.\n \n-PRINT namelist is permitted.  This causes an error if -std=f95 is used.\n+@code{PRINT} namelist is permitted.  This causes an error if\n+@option{-std=f95} is used.\n @smallexample\n PROGRAM test_print\n   REAL, dimension (4)  ::  x = (/1.0, 2.0, 3.0, 4.0/)\n@@ -931,35 +937,36 @@ PROGRAM test_print\n END PROGRAM test_print\n @end smallexample\n \n-Expanded namelist reads are permitted.  This causes an error if -std=f95\n-is used.  In the following example, the first element of the array will be\n-given the value 0.00 and succeeding elements will be 1.00 and 2.00.\n+Expanded namelist reads are permitted.  This causes an error if \n+@option{-std=f95} is used.  In the following example, the first element\n+of the array will be given the value 0.00 and the two succeeding\n+elements will be given the values 1.00 and 2.00.\n @smallexample\n &MYNML\n   X(1,1) = 0.00 , 1.00 , 2.00\n /\n @end smallexample\n \n-@node X format descriptor\n-@section X format descriptor\n-@cindex X format descriptor\n+@node X format descriptor without count field\n+@section @code{X} format descriptor without count field\n+@cindex @code{X} format descriptor without count field\n \n-To support legacy codes, GNU Fortran permits the count field\n-of the X edit descriptor in FORMAT statements to be omitted.  When\n-omitted, the count is implicitly assumed to be one.\n+To support legacy codes, GNU Fortran permits the count field of the\n+@code{X} edit descriptor in @code{FORMAT} statements to be omitted.\n+When omitted, the count is implicitly assumed to be one.\n \n @smallexample\n        PRINT 10, 2, 3\n 10     FORMAT (I1, X, I1)\n @end smallexample\n \n @node Commas in FORMAT specifications\n-@section Commas in FORMAT specifications\n-@cindex Commas in FORMAT specifications\n+@section Commas in @code{FORMAT} specifications\n+@cindex Commas in @code{FORMAT} specifications\n \n To support legacy codes, GNU Fortran allows the comma separator\n to be omitted immediately before and after character string edit\n-descriptors in FORMAT statements.\n+descriptors in @code{FORMAT} statements.\n \n @smallexample\n        PRINT 10, 2, 3\n@@ -968,12 +975,13 @@ descriptors in FORMAT statements.\n \n \n @node Missing period in FORMAT specifications\n-@section Missing period in FORMAT specifications\n-@cindex Missing period in FORMAT specifications\n+@section Missing period in @code{FORMAT} specifications\n+@cindex Missing period in @code{FORMAT} specifications\n \n To support legacy codes, GNU Fortran allows missing periods in format\n-specifications if and only if -std=legacy is given on the command line.  This\n-is considered non-conforming code and is discouraged.\n+specifications if and only if @option{-std=legacy} is given on the\n+command line.  This is considered non-conforming code and is\n+discouraged.\n \n @smallexample\n        REAL :: value\n@@ -986,101 +994,116 @@ is considered non-conforming code and is discouraged.\n @cindex I/O item lists\n \n To support legacy codes, GNU Fortran allows the input item list\n-of the READ statement, and the output item lists of the WRITE and PRINT\n-statements to start with a comma.\n+of the @code{READ} statement, and the output item lists of the\n+@code{WRITE} and @code{PRINT} statements, to start with a comma.\n \n-@node Hexadecimal constants\n-@section Hexadecimal constants\n-@cindex Hexadecimal constants\n+@node BOZ literal constants\n+@section BOZ literal constants\n+@cindex BOZ literal constants\n \n-As an extension, GNU Fortran allows hexadecimal constants to\n+As an extension, GNU Fortran allows hexadecimal BOZ literal constants to\n be specified using the X prefix, in addition to the standard Z prefix.\n-BOZ literal constants can also be specified by adding a suffix to the string.\n-For example, @code{Z'ABC'} and @code{'ABC'Z} are the same constant.\n-\n-The Fortran standard restricts the appearance of a BOZ literal constant to\n-the @code{DATA} statement, and it is expected to be assigned to an \n-@code{INTEGER} variable.  GNU Fortran permits a BOZ literal to appear\n-in any initialization expression as well as assignment statements.\n-\n-Attempts to use a BOZ literal constant to do a bitwise initialization of a\n-variable can lead to confusion.  A BOZ literal constant is converted to an\n-@code{INTEGER} value with the kind type with the largest decimal representation,\n-and this value is then converted numerically to the type and kind of the\n-variable in question.  Thus, one should not expect a bitwise copy of the BOZ\n-literal constant to be assigned to a @code{REAL} variable.\n-\n-Similarly, initializing an @code{INTEGER} variable with a statement such as\n-@code{DATA i/Z'FFFFFFFF'/} will produce an integer overflow rather than the\n-desired result of @math{-1} when @code{i} is a 32-bit integer on a system that\n-supports 64-bit integers.  The @samp{-fno-range-check} option can be used as \n-a workaround for legacy code that initializes integers in this manner.\n-\n+BOZ literal constants can also be specified by adding a suffix to the\n+string. For example, @code{Z'ABC'} and @code{'ABC'Z} are equivalent.\n+\n+The Fortran standard restricts the appearance of a BOZ literal constant\n+to the @code{DATA} statement, and it is expected to be assigned to an\n+@code{INTEGER} variable.  GNU Fortran permits a BOZ literal to appear in\n+any initialization expression as well as assignment statements.\n+\n+Attempts to use a BOZ literal constant to do a bitwise initialization of\n+a variable can lead to confusion.  A BOZ literal constant is converted\n+to an @code{INTEGER} value with the kind type with the largest decimal\n+representation, and this value is then converted numerically to the type\n+and kind of the variable in question.  Thus, one should not expect a\n+bitwise copy of the BOZ literal constant to be assigned to a @code{REAL}\n+variable.\n+\n+Similarly, initializing an @code{INTEGER} variable with a statement such\n+as @code{DATA i/Z'FFFFFFFF'/} will produce an integer overflow rather\n+than the desired result of @math{-1} when @code{i} is a 32-bit integer\n+on a system that supports 64-bit integers.  The @samp{-fno-range-check}\n+option can be used as a workaround for legacy code that initializes\n+integers in this manner.\n \n @node Real array indices\n @section Real array indices\n @cindex Real array indices\n \n-As an extension, GNU Fortran allows arrays to be indexed using\n-real types, whose values are implicitly converted to integers.\n+As an extension, GNU Fortran allows the use of @code{REAL} expressions\n+or variables as array indices.\n \n @node Unary operators\n @section Unary operators\n @cindex Unary operators\n \n-As an extension, GNU Fortran allows unary plus and unary\n-minus operators to appear as the second operand of binary arithmetic\n-operators without the need for parenthesis.\n+As an extension, GNU Fortran allows unary plus and unary minus operators\n+to appear as the second operand of binary arithmetic operators without\n+the need for parenthesis.\n \n @smallexample\n        X = Y * -Z\n @end smallexample\n \n-@node Implicitly interconvert LOGICAL and INTEGER\n-@section Implicitly interconvert LOGICAL and INTEGER\n-@cindex Implicitly interconvert LOGICAL and INTEGER\n+@node Implicitly convert LOGICAL and INTEGER values\n+@section Implicitly convert @code{LOGICAL} and @code{INTEGER} values\n+@cindex Implicitly convert @code{LOGICAL} and @code{INTEGER} values\n \n-As an extension for backwards compatibility with other compilers,\n-GNU Fortran allows the implicit conversion of LOGICALs to INTEGERs\n-and vice versa.  When converting from a LOGICAL to an INTEGER, the numeric\n-value of @code{.FALSE.} is zero, and that of @code{.TRUE.} is one.  When\n-converting from INTEGER to LOGICAL, the value zero is interpreted as\n+As an extension for backwards compatibility with other compilers, GNU\n+Fortran allows the implicit conversion of @code{LOGICAL} values to\n+@code{INTEGER} values and vice versa.  When converting from a\n+@code{LOGICAL} to an @code{INTEGER}, @code{.FALSE.} is interpreted as\n+zero, and @code{.TRUE.} is interpreted as one.  When converting from\n+@code{INTEGER} to @code{LOGICAL}, the value zero is interpreted as\n @code{.FALSE.} and any nonzero value is interpreted as @code{.TRUE.}.\n \n @smallexample\n-       INTEGER*4 i\n-       i = .FALSE.\n+       INTEGER :: i = 1\n+       IF (i) PRINT *, 'True'\n @end smallexample\n \n @node Hollerith constants support\n @section Hollerith constants support\n @cindex Hollerith constants\n \n-A Hollerith constant is a string of characters preceded by the letter @samp{H}\n-or @samp{h}, and there must be an literal, unsigned, nonzero default integer\n-constant indicating the number of characters in the string. Hollerith constants\n-are stored as byte strings, one character per byte.\n+GNU Fortran supports Hollerith constants in assignments, function\n+arguments, and @code{DATA} and @code{ASSIGN} statements.  A Hollerith\n+constant is written as a string of characters preceeded by an integer\n+constant indicating the character count, and the letter @code{H} or\n+@code{h}, and stored in bytewise fashion in a numeric (@code{INTEGER},\n+@code{REAL}, or @code{complex}) or @code{LOGICAL} variable.  The\n+constant will be padded or truncated to fit the size of the variable in\n+which it is stored.\n \n-GNU Fortran supports Hollerith constants. They can be used as the right\n-hands in the @code{DATA} statement and @code{ASSIGN} statement, also as the\n-arguments. The left hands can be of Integer, Real, Complex and Logical type.\n-The constant will be padded or truncated to fit the size of left hand.\n-\n-Valid Hollerith constants examples:\n+Examples of valid uses of Hollerith constants:\n @smallexample\n-complex*16 x(2)\n-data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/\n-call foo (4H abc)\n-x(1) = 16Habcdefghijklmnop\n+      complex*16 x(2)\n+      data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/\n+      x(1) = 16HABCDEFGHIJKLMNOP\n+      call foo (4h abc)\n @end smallexample\n \n Invalid Hollerith constants examples:\n @smallexample\n-integer*4 a\n-a = 8H12345678 ! The Hollerith constant is too long. It will be truncated.\n-a = 0H         ! At least one character needed.\n+      integer*4 a\n+      a = 8H12345678 ! Valid, but the Hollerith constant will be truncated.\n+      a = 0H         ! At least one character is needed.\n @end smallexample\n \n+In general, Hollerith constants were used to provide a rudimentary\n+facility for handling character strings in early Fortran compilers,\n+prior to the introduction of @code{CHARACTER} variables in Fortran 77;\n+in those cases, the standard-compliant equivalent is to convert the\n+program to use proper character strings.  On occasion, there may be a\n+case where the intent is specifically to initialize a numeric variable\n+with a given byte sequence.  In these cases, the same result can be\n+obtained by using the @code{TRANSFER} statement, as in this example.\n+@smallexample\n+      INTEGER(KIND=4) :: a\n+      a = TRANSFER (\"abcd\", a)     ! equivalent to: a = 4Habcd\n+@end smallexample\n+\n+\n @node Cray pointers\n @section Cray pointers\n @cindex Cray pointers\n@@ -1101,8 +1124,8 @@ or,\n The pointer is an integer that is intended to hold a memory address.\n The pointee may be an array or scalar.  A pointee can be an assumed\n size array---that is, the last dimension may be left unspecified by\n-using a '*' in place of a value---but a pointee cannot be an assumed\n-shape array.  No space is allocated for the pointee.\n+using a @code{*} in place of a value---but a pointee cannot be an\n+assumed shape array.  No space is allocated for the pointee.\n \n The pointee may have its type declared before or after the pointer\n statement, and its array specification (if any) may be declared\n@@ -1133,17 +1156,16 @@ pointer in order to increment it.  Consider the following example:\n         ipt = loc (target)\n         ipt = ipt + 1       \n @end smallexample\n-The last statement does not set ipt to the address of\n-@code{target(1)}, as one familiar with C pointer arithmetic might\n-expect.  Adding 1 to ipt just adds one byte to the address stored in\n-ipt.\n+The last statement does not set @code{ipt} to the address of\n+@code{target(1)}, as it would in C pointer arithmetic.  Adding @code{1}\n+to @code{ipt} just adds one byte to the address stored in @code{ipt}.\n \n Any expression involving the pointee will be translated to use the\n value stored in the pointer as the base address.\n \n To get the address of elements, this extension provides an intrinsic\n-function loc(), loc() is essentially the C '&' operator, except the\n-address is cast to an integer type:\n+function @code{LOC()}.  The @code{LOC()} function is equivalent to the\n+@code{&} operator in C, except the address is cast to an integer type:\n @smallexample\n         real ar(10)\n         pointer(ipt, arpte(10))\n@@ -1162,33 +1184,35 @@ example:\n         pointer (ipt, iarr)\n         ipt = loc(target)\n @end smallexample\n-As long as ipt remains unchanged, iarr is now an alias for target.\n-The optimizer, however, will not detect this aliasing, so it is unsafe\n-to use iarr and target simultaneously.  Using a pointee in any way\n-that violates the Fortran aliasing rules or assumptions is illegal.\n-It is the user's responsibility to avoid doing this; the compiler\n-works under the assumption that no such aliasing occurs.\n-\n-Cray pointers will work correctly when there is no aliasing (i.e.,\n-when they're used to access a dynamically allocated block of memory),\n-and also in any routine where a pointee is used, but any variable with\n-which it shares storage is not used.  Code that violates these rules\n-may not run as the user intends.  This is not a bug in the optimizer;\n-any code that violates the aliasing rules is illegal.  (Note that this\n-is not unique to GNU Fortran; any Fortran compiler that supports Cray\n-pointers will ``incorrectly'' optimize code with illegal aliasing.)\n-\n-There are a number of restrictions on the attributes that can be\n-applied to Cray pointers and pointees.  Pointees may not have the\n-attributes ALLOCATABLE, INTENT, OPTIONAL, DUMMY, TARGET,\n-INTRINSIC, or POINTER.  Pointers may not have the attributes\n-DIMENSION, POINTER, TARGET, ALLOCATABLE, EXTERNAL, or INTRINSIC.\n+As long as @code{ipt} remains unchanged, @code{iarr} is now an alias for\n+@code{target}. The optimizer, however, will not detect this aliasing, so\n+it is unsafe to use @code{iarr} and @code{target} simultaneously.  Using\n+a pointee in any way that violates the Fortran aliasing rules or\n+assumptions is illegal. It is the user's responsibility to avoid doing\n+this; the compiler works under the assumption that no such aliasing\n+occurs.\n+\n+Cray pointers will work correctly when there is no aliasing (i.e., when\n+they are used to access a dynamically allocated block of memory), and\n+also in any routine where a pointee is used, but any variable with which\n+it shares storage is not used.  Code that violates these rules may not\n+run as the user intends.  This is not a bug in the optimizer; any code\n+that violates the aliasing rules is illegal.  (Note that this is not\n+unique to GNU Fortran; any Fortran compiler that supports Cray pointers\n+will ``incorrectly'' optimize code with illegal aliasing.)\n+\n+There are a number of restrictions on the attributes that can be applied\n+to Cray pointers and pointees.  Pointees may not have the\n+@code{ALLOCATABLE}, @code{INTENT}, @code{OPTIONAL}, @code{DUMMY},\n+@code{TARGET}, @code{INTRINSIC}, or @code{POINTER} attributes. Pointers\n+may not have the @code{DIMENSION}, @code{POINTER}, @code{TARGET},\n+@code{ALLOCATABLE}, @code{EXTERNAL}, or @code{INTRINSIC} attributes.\n Pointees may not occur in more than one pointer statement.  A pointee\n cannot be a pointer.  Pointees cannot occur in equivalence, common, or\n data statements.\n \n-A Cray pointer may point to a function or a subroutine.  For example,\n-the following excerpt is valid:\n+A Cray pointer may also point to a function or a subroutine.  For\n+example, the following excerpt is valid:\n @smallexample\n   implicit none\n   external sub\n@@ -1244,12 +1268,13 @@ The value of the conversion can be queried by using\n on IEEE systems of kinds 4 and 8.  Conversion between different\n ``extended double'' types on different architectures such as\n m68k and x86_64, which GNU Fortran\n-supports as @code{REAL(KIND=10)}, will probably not work.\n+supports as @code{REAL(KIND=10)} and @code{REAL(KIND=16)}, will\n+probably not work.\n \n @emph{Note that the values specified via the GFORTRAN_CONVERT_UNIT\n environment variable will override the CONVERT specifier in the\n open statement}.  This is to give control over data formats to\n-a user who does not have the source code of his program available.\n+users who do not have the source code of their program available.\n \n Using anything but the native representation for unformatted data\n carries a significant speed overhead.  If speed in this area matters"}]}