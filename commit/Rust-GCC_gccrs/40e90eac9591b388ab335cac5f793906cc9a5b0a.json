{"sha": "40e90eac9591b388ab335cac5f793906cc9a5b0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBlOTBlYWM5NTkxYjM4OGFiMzM1Y2FjNWY3OTM5MDZjYzlhNWIwYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-02-19T09:53:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-02-19T09:53:51Z"}, "message": "re PR middle-end/42233 (c++ builtin_expect code generation regression)\n\n\tPR middle-end/42233\n\t* expr.h (jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump,\n\tdo_jump_1, do_compare_rtx_and_jump): Add PROB argument.\n\t* dojump.c: Include output.h.\n\t(inv): New inline function.\n\t(jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump_1, do_jump,\n\tdo_jump_by_parts_greater_rtx, do_jump_by_parts_greater,\n\tdo_jump_by_parts_zero_rtx, do_jump_by_parts_equality_rtx,\n\tdo_jump_by_parts_equality, do_compare_and_jump): Add PROB\n\targument, pass it down to other calls.\n\t(do_compare_rtx_and_jump): Likewise.  If PROB is not -1,\n\tadd REG_BR_PROB note to the conditional jump.\n\t* cfgexpand.c (add_reg_br_prob_note): Removed.\n\t(expand_gimple_cond): Don't call it, add the probability\n\tas last argument to jumpif_1/jumpifnot_1.\n\t* Makefile.in (dojump.o): Depend on output.h.\n\t* builtins.c (expand_errno_check): Adjust do_compare_rtx_and_jump\n\tcallers.\n\t* expmed.c (emit_store_flag_force, do_cmp_and_jump): Likewise.\n\t* stmt.c (do_jump_if_equal): Likewise.\n\t* cfgrtl.c (rtl_lv_add_condition_to_bb): Likewise.\n\t* loop-unswitch.c (compare_and_jump_seq): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_aix_emit_builtin_unwind_init):\n\tLikewise.\n\t* optabs.c (expand_doubleword_shift, expand_abs): Likewise.\n\t* expr.c (expand_expr_real_1): Adjust do_jump, jumpifnot and\n\tjumpifnot_1 callers.\n\t(expand_expr_real_2): Adjust jumpifnot_1 and do_compare_rtx_and_jump\n\tcallers.\n\t(store_expr): Adjust jumpifnot caller.\n\t(store_constructor): Adjust jumpif caller.\n\nFrom-SVN: r156889", "tree": {"sha": "ae0cff8e2a111a3f985e8b1442893617e40733f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae0cff8e2a111a3f985e8b1442893617e40733f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40e90eac9591b388ab335cac5f793906cc9a5b0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e90eac9591b388ab335cac5f793906cc9a5b0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40e90eac9591b388ab335cac5f793906cc9a5b0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e90eac9591b388ab335cac5f793906cc9a5b0a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "554cf33034e4a4ba3960a0885f45fa7a919dbd0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554cf33034e4a4ba3960a0885f45fa7a919dbd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554cf33034e4a4ba3960a0885f45fa7a919dbd0d"}], "stats": {"total": 394, "additions": 227, "deletions": 167}, "files": [{"sha": "17f72d96e269363a70136bf52ee4b46869b882e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,5 +1,37 @@\n 2010-02-19  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/42233\n+\t* expr.h (jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump,\n+\tdo_jump_1, do_compare_rtx_and_jump): Add PROB argument.\n+\t* dojump.c: Include output.h.\n+\t(inv): New inline function.\n+\t(jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump_1, do_jump,\n+\tdo_jump_by_parts_greater_rtx, do_jump_by_parts_greater,\n+\tdo_jump_by_parts_zero_rtx, do_jump_by_parts_equality_rtx,\n+\tdo_jump_by_parts_equality, do_compare_and_jump): Add PROB\n+\targument, pass it down to other calls.\n+\t(do_compare_rtx_and_jump): Likewise.  If PROB is not -1,\n+\tadd REG_BR_PROB note to the conditional jump.\n+\t* cfgexpand.c (add_reg_br_prob_note): Removed.\n+\t(expand_gimple_cond): Don't call it, add the probability\n+\tas last argument to jumpif_1/jumpifnot_1.\n+\t* Makefile.in (dojump.o): Depend on output.h.\n+\t* builtins.c (expand_errno_check): Adjust do_compare_rtx_and_jump\n+\tcallers.\n+\t* expmed.c (emit_store_flag_force, do_cmp_and_jump): Likewise.\n+\t* stmt.c (do_jump_if_equal): Likewise.\n+\t* cfgrtl.c (rtl_lv_add_condition_to_bb): Likewise.\n+\t* loop-unswitch.c (compare_and_jump_seq): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_aix_emit_builtin_unwind_init):\n+\tLikewise.\n+\t* optabs.c (expand_doubleword_shift, expand_abs): Likewise.\n+\t* expr.c (expand_expr_real_1): Adjust do_jump, jumpifnot and\n+\tjumpifnot_1 callers.\n+\t(expand_expr_real_2): Adjust jumpifnot_1 and do_compare_rtx_and_jump\n+\tcallers.\n+\t(store_expr): Adjust jumpifnot caller.\n+\t(store_constructor): Adjust jumpif caller.\n+\n \tPR middle-end/42233\n \t* gimplify.c (gimple_boolify): For __builtin_expect call\n \tgimple_boolify also on its first argument."}, {"sha": "948b01a9e271fc70cb383b5ba90613f0f1e94c6a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -2788,7 +2788,7 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_PASS_H) $(DF_H) $(DIAGNOSTIC_H) vecprim.h $(SSAEXPAND_H)\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n-   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H)\n+   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H) output.h\n builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(TARGET_H) $(FUNCTION_H) $(REGS_H) \\\n    $(EXPR_H) $(OPTABS_H) insn-config.h $(RECOG_H) output.h typeclass.h \\"}, {"sha": "1e089ef99c40e392aeeb1d95dc5f42e51f7e83b4", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1881,7 +1881,9 @@ expand_errno_check (tree exp, rtx target)\n   /* Test the result; if it is NaN, set errno=EDOM because\n      the argument was not in the domain.  */\n   do_compare_rtx_and_jump (target, target, EQ, 0, GET_MODE (target),\n-                           NULL_RTX, NULL_RTX, lab);\n+\t\t\t   NULL_RTX, NULL_RTX, lab,\n+\t\t\t   /* The jump is very likely.  */\n+\t\t\t   REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1));\n \n #ifdef TARGET_EDOM\n   /* If this built-in doesn't throw an exception, set errno directly.  */"}, {"sha": "53beecd57fd6b4b937928f1832aaac4c9b75f564", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -91,46 +91,6 @@ gimple_assign_rhs_to_tree (gimple stmt)\n }\n \n \n-/* Verify that there is exactly single jump instruction since last and attach\n-   REG_BR_PROB note specifying probability.\n-   ??? We really ought to pass the probability down to RTL expanders and let it\n-   re-distribute it when the conditional expands into multiple conditionals.\n-   This is however difficult to do.  */\n-void\n-add_reg_br_prob_note (rtx last, int probability)\n-{\n-  if (profile_status == PROFILE_ABSENT)\n-    return;\n-  for (last = NEXT_INSN (last); last && NEXT_INSN (last); last = NEXT_INSN (last))\n-    if (JUMP_P (last))\n-      {\n-\t/* It is common to emit condjump-around-jump sequence when we don't know\n-\t   how to reverse the conditional.  Special case this.  */\n-\tif (!any_condjump_p (last)\n-\t    || !JUMP_P (NEXT_INSN (last))\n-\t    || !simplejump_p (NEXT_INSN (last))\n-\t    || !NEXT_INSN (NEXT_INSN (last))\n-\t    || !BARRIER_P (NEXT_INSN (NEXT_INSN (last)))\n-\t    || !NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))\n-\t    || !LABEL_P (NEXT_INSN (NEXT_INSN (NEXT_INSN (last))))\n-\t    || NEXT_INSN (NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))))\n-\t  goto failed;\n-\tgcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n-\tadd_reg_note (last, REG_BR_PROB,\n-\t\t      GEN_INT (REG_BR_PROB_BASE - probability));\n-\treturn;\n-      }\n-  if (!last || !JUMP_P (last) || !any_condjump_p (last))\n-    goto failed;\n-  gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n-  add_reg_note (last, REG_BR_PROB, GEN_INT (probability));\n-  return;\n-failed:\n-  if (dump_file)\n-    fprintf (dump_file, \"Failed to add probability note\\n\");\n-}\n-\n-\n #ifndef STACK_ALIGNMENT_NEEDED\n #define STACK_ALIGNMENT_NEEDED 1\n #endif\n@@ -1663,8 +1623,8 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n      two-way jump that needs to be decomposed into two basic blocks.  */\n   if (false_edge->dest == bb->next_bb)\n     {\n-      jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest));\n-      add_reg_br_prob_note (last, true_edge->probability);\n+      jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest),\n+\t\ttrue_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (true_edge->goto_locus)\n \t{\n@@ -1679,8 +1639,8 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n     }\n   if (true_edge->dest == bb->next_bb)\n     {\n-      jumpifnot_1 (code, op0, op1, label_rtx_for_bb (false_edge->dest));\n-      add_reg_br_prob_note (last, false_edge->probability);\n+      jumpifnot_1 (code, op0, op1, label_rtx_for_bb (false_edge->dest),\n+\t\t   false_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (false_edge->goto_locus)\n \t{\n@@ -1694,8 +1654,8 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       return NULL;\n     }\n \n-  jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest));\n-  add_reg_br_prob_note (last, true_edge->probability);\n+  jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest),\n+\t    true_edge->probability);\n   last = get_last_insn ();\n   if (false_edge->goto_locus)\n     {"}, {"sha": "13e0e5c40d6c5242b9440640dde1f49659d718d4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,6 +1,6 @@\n /* Control flow graph manipulation code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -3025,7 +3025,7 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n   op0 = force_operand (op0, NULL_RTX);\n   op1 = force_operand (op1, NULL_RTX);\n   do_compare_rtx_and_jump (op0, op1, comp, 0,\n-\t\t\t   mode, NULL_RTX, NULL_RTX, label);\n+\t\t\t   mode, NULL_RTX, NULL_RTX, label, -1);\n   jump = get_last_insn ();\n   JUMP_LABEL (jump) = label;\n   LABEL_NUSES (label)++;"}, {"sha": "af26bf165b70714400b9eb22754a7fa0dd60ed16", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on IBM RS/6000.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n@@ -17954,7 +17954,7 @@ rs6000_aix_emit_builtin_unwind_init (void)\n \n   do_compare_rtx_and_jump (opcode, tocompare, EQ, 1,\n \t\t\t   SImode, NULL_RTX, NULL_RTX,\n-\t\t\t   no_toc_save_needed);\n+\t\t\t   no_toc_save_needed, -1);\n \n   mem = gen_frame_mem (Pmode,\n \t\t       gen_rtx_PLUS (Pmode, stack_top,"}, {"sha": "3d03b4c32d4a1337d284512d7886737d39a9c832", "filename": "gcc/dojump.c", "status": "modified", "additions": 152, "deletions": 87, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,6 +1,6 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -35,12 +35,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"ggc.h\"\n #include \"basic-block.h\"\n+#include \"output.h\"\n \n static bool prefer_and_bit_test (enum machine_mode, int);\n-static void do_jump_by_parts_greater (tree, tree, int, rtx, rtx);\n-static void do_jump_by_parts_equality (tree, tree, rtx, rtx);\n+static void do_jump_by_parts_greater (tree, tree, int, rtx, rtx, int);\n+static void do_jump_by_parts_equality (tree, tree, rtx, rtx, int);\n static void do_compare_and_jump\t(tree, tree, enum rtx_code, enum rtx_code, rtx,\n-\t\t\t\t rtx);\n+\t\t\t\t rtx, int);\n+\n+/* Invert probability if there is any.  -1 stands for unknown.  */\n+\n+static inline int\n+inv (int prob)\n+{\n+  return prob == -1 ? -1 : REG_BR_PROB_BASE - prob;\n+}\n \n /* At the start of a function, record that we have no previously-pushed\n    arguments waiting to be popped.  */\n@@ -96,29 +105,29 @@ do_pending_stack_adjust (void)\n    functions here.  */\n \n void\n-jumpifnot (tree exp, rtx label)\n+jumpifnot (tree exp, rtx label, int prob)\n {\n-  do_jump (exp, label, NULL_RTX);\n+  do_jump (exp, label, NULL_RTX, inv (prob));\n }\n \n void\n-jumpifnot_1 (enum tree_code code, tree op0, tree op1, rtx label)\n+jumpifnot_1 (enum tree_code code, tree op0, tree op1, rtx label, int prob)\n {\n-  do_jump_1 (code, op0, op1, label, NULL_RTX);\n+  do_jump_1 (code, op0, op1, label, NULL_RTX, inv (prob));\n }\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n \n void\n-jumpif (tree exp, rtx label)\n+jumpif (tree exp, rtx label, int prob)\n {\n-  do_jump (exp, NULL_RTX, label);\n+  do_jump (exp, NULL_RTX, label, prob);\n }\n \n void\n-jumpif_1 (enum tree_code code, tree op0, tree op1, rtx label)\n+jumpif_1 (enum tree_code code, tree op0, tree op1, rtx label, int prob)\n {\n-  do_jump_1 (code, op0, op1, NULL_RTX, label);\n+  do_jump_1 (code, op0, op1, NULL_RTX, label, prob);\n }\n \n /* Used internally by prefer_and_bit_test.  */\n@@ -162,11 +171,12 @@ prefer_and_bit_test (enum machine_mode mode, int bitnum)\n }\n \n /* Subroutine of do_jump, dealing with exploded comparisons of the type\n-   OP0 CODE OP1 .  IF_FALSE_LABEL and IF_TRUE_LABEL like in do_jump.  */\n+   OP0 CODE OP1 .  IF_FALSE_LABEL and IF_TRUE_LABEL like in do_jump.\n+   PROB is probability of jump to if_true_label, or -1 if unknown.  */\n \n void\n do_jump_1 (enum tree_code code, tree op0, tree op1,\n-\t   rtx if_false_label, rtx if_true_label)\n+\t   rtx if_false_label, rtx if_true_label, int prob)\n {\n   enum machine_mode mode;\n   rtx drop_through_label = 0;\n@@ -183,12 +193,14 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \t\t    != MODE_COMPLEX_INT);\n \n         if (integer_zerop (op1))\n-          do_jump (op0, if_true_label, if_false_label);\n+\t  do_jump (op0, if_true_label, if_false_label, inv (prob));\n         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n                  && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))\n-          do_jump_by_parts_equality (op0, op1, if_false_label, if_true_label);\n+\t  do_jump_by_parts_equality (op0, op1, if_false_label, if_true_label,\n+\t\t\t\t     prob);\n         else\n-          do_compare_and_jump (op0, op1, EQ, EQ, if_false_label, if_true_label);\n+\t  do_compare_and_jump (op0, op1, EQ, EQ, if_false_label, if_true_label,\n+\t\t\t       prob);\n         break;\n       }\n \n@@ -202,110 +214,126 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \t\t    != MODE_COMPLEX_INT);\n \n         if (integer_zerop (op1))\n-          do_jump (op0, if_false_label, if_true_label);\n+\t  do_jump (op0, if_false_label, if_true_label, prob);\n         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n            && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))\n-          do_jump_by_parts_equality (op0, op1, if_true_label, if_false_label);\n+\t  do_jump_by_parts_equality (op0, op1, if_true_label, if_false_label,\n+\t\t\t\t     inv (prob));\n         else\n-          do_compare_and_jump (op0, op1, NE, NE, if_false_label, if_true_label);\n+\t  do_compare_and_jump (op0, op1, NE, NE, if_false_label, if_true_label,\n+\t\t\t       prob);\n         break;\n       }\n \n     case LT_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n           && ! can_compare_p (LT, mode, ccp_jump))\n-        do_jump_by_parts_greater (op0, op1, 1, if_false_label, if_true_label);\n+\tdo_jump_by_parts_greater (op0, op1, 1, if_false_label, if_true_label,\n+\t\t\t\t  prob);\n       else\n-        do_compare_and_jump (op0, op1, LT, LTU, if_false_label, if_true_label);\n+\tdo_compare_and_jump (op0, op1, LT, LTU, if_false_label, if_true_label,\n+\t\t\t     prob);\n       break;\n \n     case LE_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n           && ! can_compare_p (LE, mode, ccp_jump))\n-        do_jump_by_parts_greater (op0, op1, 0, if_true_label, if_false_label);\n+\tdo_jump_by_parts_greater (op0, op1, 0, if_true_label, if_false_label,\n+\t\t\t\t  inv (prob));\n       else\n-        do_compare_and_jump (op0, op1, LE, LEU, if_false_label, if_true_label);\n+\tdo_compare_and_jump (op0, op1, LE, LEU, if_false_label, if_true_label,\n+\t\t\t     prob);\n       break;\n \n     case GT_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n           && ! can_compare_p (GT, mode, ccp_jump))\n-        do_jump_by_parts_greater (op0, op1, 0, if_false_label, if_true_label);\n+\tdo_jump_by_parts_greater (op0, op1, 0, if_false_label, if_true_label,\n+\t\t\t\t  prob);\n       else\n-        do_compare_and_jump (op0, op1, GT, GTU, if_false_label, if_true_label);\n+\tdo_compare_and_jump (op0, op1, GT, GTU, if_false_label, if_true_label,\n+\t\t\t     prob);\n       break;\n \n     case GE_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n           && ! can_compare_p (GE, mode, ccp_jump))\n-        do_jump_by_parts_greater (op0, op1, 1, if_true_label, if_false_label);\n+\tdo_jump_by_parts_greater (op0, op1, 1, if_true_label, if_false_label,\n+\t\t\t\t  inv (prob));\n       else\n-        do_compare_and_jump (op0, op1, GE, GEU, if_false_label, if_true_label);\n+\tdo_compare_and_jump (op0, op1, GE, GEU, if_false_label, if_true_label,\n+\t\t\t     prob);\n       break;\n \n     case ORDERED_EXPR:\n       do_compare_and_jump (op0, op1, ORDERED, ORDERED,\n-\t\t\t   if_false_label, if_true_label);\n+\t\t\t   if_false_label, if_true_label, prob);\n       break;\n \n     case UNORDERED_EXPR:\n       do_compare_and_jump (op0, op1, UNORDERED, UNORDERED,\n-\t\t\t   if_false_label, if_true_label);\n+\t\t\t   if_false_label, if_true_label, prob);\n       break;\n \n     case UNLT_EXPR:\n-      do_compare_and_jump (op0, op1, UNLT, UNLT, if_false_label, if_true_label);\n+      do_compare_and_jump (op0, op1, UNLT, UNLT, if_false_label, if_true_label,\n+\t\t\t   prob);\n       break;\n \n     case UNLE_EXPR:\n-      do_compare_and_jump (op0, op1, UNLE, UNLE, if_false_label, if_true_label);\n+      do_compare_and_jump (op0, op1, UNLE, UNLE, if_false_label, if_true_label,\n+\t\t\t   prob);\n       break;\n \n     case UNGT_EXPR:\n-      do_compare_and_jump (op0, op1, UNGT, UNGT, if_false_label, if_true_label);\n+      do_compare_and_jump (op0, op1, UNGT, UNGT, if_false_label, if_true_label,\n+\t\t\t   prob);\n       break;\n \n     case UNGE_EXPR:\n-      do_compare_and_jump (op0, op1, UNGE, UNGE, if_false_label, if_true_label);\n+      do_compare_and_jump (op0, op1, UNGE, UNGE, if_false_label, if_true_label,\n+\t\t\t   prob);\n       break;\n \n     case UNEQ_EXPR:\n-      do_compare_and_jump (op0, op1, UNEQ, UNEQ, if_false_label, if_true_label);\n+      do_compare_and_jump (op0, op1, UNEQ, UNEQ, if_false_label, if_true_label,\n+\t\t\t   prob);\n       break;\n \n     case LTGT_EXPR:\n-      do_compare_and_jump (op0, op1, LTGT, LTGT, if_false_label, if_true_label);\n+      do_compare_and_jump (op0, op1, LTGT, LTGT, if_false_label, if_true_label,\n+\t\t\t   prob);\n       break;\n \n     case TRUTH_ANDIF_EXPR:\n       if (if_false_label == NULL_RTX)\n         {\n \t  drop_through_label = gen_label_rtx ();\n-          do_jump (op0, drop_through_label, NULL_RTX);\n-          do_jump (op1, NULL_RTX, if_true_label);\n+\t  do_jump (op0, drop_through_label, NULL_RTX, prob);\n+\t  do_jump (op1, NULL_RTX, if_true_label, prob);\n \t}\n       else\n \t{\n-\t  do_jump (op0, if_false_label, NULL_RTX);\n-          do_jump (op1, if_false_label, if_true_label);\n+\t  do_jump (op0, if_false_label, NULL_RTX, prob);\n+\t  do_jump (op1, if_false_label, if_true_label, prob);\n \t}\n       break;\n \n     case TRUTH_ORIF_EXPR:\n       if (if_true_label == NULL_RTX)\n \t{\n           drop_through_label = gen_label_rtx ();\n-          do_jump (op0, NULL_RTX, drop_through_label);\n-          do_jump (op1, if_false_label, NULL_RTX);\n+\t  do_jump (op0, NULL_RTX, drop_through_label, prob);\n+\t  do_jump (op1, if_false_label, NULL_RTX, prob);\n \t}\n       else\n \t{\n-          do_jump (op0, NULL_RTX, if_true_label);\n-          do_jump (op1, if_false_label, if_true_label);\n+\t  do_jump (op0, NULL_RTX, if_true_label, prob);\n+\t  do_jump (op1, if_false_label, if_true_label, prob);\n \t}\n       break;\n \n@@ -327,10 +355,12 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \n    do_jump always does any pending stack adjust except when it does not\n    actually perform a jump.  An example where there is no jump\n-   is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.  */\n+   is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.\n+\n+   PROB is probability of jump to if_true_label, or -1 if unknown.  */\n \n void\n-do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n+do_jump (tree exp, rtx if_false_label, rtx if_true_label, int prob)\n {\n   enum tree_code code = TREE_CODE (exp);\n   rtx temp;\n@@ -377,11 +407,11 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n       /* These cannot change zero->nonzero or vice versa.  */\n-      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n+      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label, prob);\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);\n+      do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label, prob);\n       break;\n \n     case COND_EXPR:\n@@ -397,10 +427,10 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t  }\n \n         do_pending_stack_adjust ();\n-        do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);\n-        do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n+\tdo_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX, -1);\n+\tdo_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);\n         emit_label (label1);\n-        do_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label);\n+\tdo_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label, prob);\n \tbreak;\n       }\n \n@@ -431,7 +461,8 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n             && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n             && have_insn_for (COMPARE, TYPE_MODE (type)))\n           {\n-            do_jump (fold_convert (type, exp), if_false_label, if_true_label);\n+\t    do_jump (fold_convert (type, exp), if_false_label, if_true_label,\n+\t\t     prob);\n             break;\n           }\n         goto normal;\n@@ -460,7 +491,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n     case TRUTH_ORIF_EXPR:\n     other_code:\n       do_jump_1 (code, TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t if_false_label, if_true_label);\n+\t\t if_false_label, if_true_label, prob);\n       break;\n \n     case BIT_AND_EXPR:\n@@ -471,6 +502,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t{\n \t  tree exp0 = TREE_OPERAND (exp, 0);\n \t  rtx set_label, clr_label;\n+\t  int setclr_prob = prob;\n \n \t  /* Strip narrowing integral type conversions.  */\n \t  while (CONVERT_EXPR_P (exp0)\n@@ -486,6 +518,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t      exp0 = TREE_OPERAND (exp0, 0);\n \t      clr_label = if_true_label;\n \t      set_label = if_false_label;\n+\t      setclr_prob = inv (prob);\n \t    }\n \t  else\n \t    {\n@@ -508,7 +541,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t\t    = (unsigned HOST_WIDE_INT) 1 << TREE_INT_CST_LOW (shift);\n \t\t  do_jump (build2 (BIT_AND_EXPR, argtype, arg,\n \t\t\t\t   build_int_cst_wide_type (argtype, mask, 0)),\n-\t\t\t   clr_label, set_label);\n+\t\t\t   clr_label, set_label, setclr_prob);\n \t\t  break;\n \t\t}\n \t    }\n@@ -530,7 +563,8 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n           && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n           && have_insn_for (COMPARE, TYPE_MODE (type)))\n         {\n-          do_jump (fold_convert (type, exp), if_false_label, if_true_label);\n+\t  do_jump (fold_convert (type, exp), if_false_label, if_true_label,\n+\t\t   prob);\n           break;\n         }\n \n@@ -556,7 +590,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       /* High branch cost, expand as the bitwise OR of the conditions.\n \t Do the same if the RHS has side effects, because we're effectively\n \t turning a TRUTH_OR_EXPR into a TRUTH_ORIF_EXPR.  */\n-      if (BRANCH_COST (optimize_insn_for_speed_p (), false)>= 4\n+      if (BRANCH_COST (optimize_insn_for_speed_p (), false) >= 4\n \t  || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \tgoto normal;\n       code = TRUTH_ORIF_EXPR;\n@@ -580,7 +614,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       do_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),\n \t\t\t       NE, TYPE_UNSIGNED (TREE_TYPE (exp)),\n \t\t\t       GET_MODE (temp), NULL_RTX,\n-\t\t\t       if_false_label, if_true_label);\n+\t\t\t       if_false_label, if_true_label, prob);\n     }\n \n   if (drop_through_label)\n@@ -596,7 +630,8 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \n static void\n do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n-\t\t\t      rtx op1, rtx if_false_label, rtx if_true_label)\n+\t\t\t      rtx op1, rtx if_false_label, rtx if_true_label,\n+\t\t\t      int prob)\n {\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n   rtx drop_through_label = 0;\n@@ -628,11 +663,12 @@ do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n       /* All but high-order word must be compared as unsigned.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, GT,\n                                (unsignedp || i > 0), word_mode, NULL_RTX,\n-                               NULL_RTX, if_true_label);\n+\t\t\t       NULL_RTX, if_true_label, prob);\n \n       /* Consider lower words only if these are equal.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,\n-                               NULL_RTX, NULL_RTX, if_false_label);\n+\t\t\t       NULL_RTX, NULL_RTX, if_false_label,\n+\t\t\t       inv (prob));\n     }\n \n   if (if_false_label)\n@@ -648,15 +684,15 @@ do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n \n static void\n do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n-\t\t\t  rtx if_false_label, rtx if_true_label)\n+\t\t\t  rtx if_false_label, rtx if_true_label, int prob)\n {\n   rtx op0 = expand_normal (swap ? treeop1 : treeop0);\n   rtx op1 = expand_normal (swap ? treeop0 : treeop1);\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (treeop0));\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (treeop0));\n \n   do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,\n-\t\t\t\tif_true_label);\n+\t\t\t\tif_true_label, prob);\n }\n \f\n /* Jump according to whether OP0 is 0.  We assume that OP0 has an integer\n@@ -666,7 +702,7 @@ do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n \n static void\n do_jump_by_parts_zero_rtx (enum machine_mode mode, rtx op0,\n-\t\t\t   rtx if_false_label, rtx if_true_label)\n+\t\t\t   rtx if_false_label, rtx if_true_label, int prob)\n {\n   int nwords = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n   rtx part;\n@@ -688,8 +724,7 @@ do_jump_by_parts_zero_rtx (enum machine_mode mode, rtx op0,\n   if (part != 0)\n     {\n       do_compare_rtx_and_jump (part, const0_rtx, EQ, 1, word_mode,\n-                               NULL_RTX, if_false_label, if_true_label);\n-\n+\t\t\t       NULL_RTX, if_false_label, if_true_label, prob);\n       return;\n     }\n \n@@ -700,7 +735,7 @@ do_jump_by_parts_zero_rtx (enum machine_mode mode, rtx op0,\n   for (i = 0; i < nwords; i++)\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n                              const0_rtx, EQ, 1, word_mode, NULL_RTX,\n-                             if_false_label, NULL_RTX);\n+\t\t\t     if_false_label, NULL_RTX, prob);\n \n   if (if_true_label)\n     emit_jump (if_true_label);\n@@ -716,20 +751,22 @@ do_jump_by_parts_zero_rtx (enum machine_mode mode, rtx op0,\n \n static void\n do_jump_by_parts_equality_rtx (enum machine_mode mode, rtx op0, rtx op1,\n-\t\t\t       rtx if_false_label, rtx if_true_label)\n+\t\t\t       rtx if_false_label, rtx if_true_label, int prob)\n {\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n   rtx drop_through_label = 0;\n   int i;\n \n   if (op1 == const0_rtx)\n     {\n-      do_jump_by_parts_zero_rtx (mode, op0, if_false_label, if_true_label);\n+      do_jump_by_parts_zero_rtx (mode, op0, if_false_label, if_true_label,\n+\t\t\t\t prob);\n       return;\n     }\n   else if (op0 == const0_rtx)\n     {\n-      do_jump_by_parts_zero_rtx (mode, op1, if_false_label, if_true_label);\n+      do_jump_by_parts_zero_rtx (mode, op1, if_false_label, if_true_label,\n+\t\t\t\t prob);\n       return;\n     }\n \n@@ -740,7 +777,7 @@ do_jump_by_parts_equality_rtx (enum machine_mode mode, rtx op0, rtx op1,\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n                              operand_subword_force (op1, i, mode),\n                              EQ, 0, word_mode, NULL_RTX,\n-\t\t\t     if_false_label, NULL_RTX);\n+\t\t\t     if_false_label, NULL_RTX, prob);\n \n   if (if_true_label)\n     emit_jump (if_true_label);\n@@ -753,13 +790,13 @@ do_jump_by_parts_equality_rtx (enum machine_mode mode, rtx op0, rtx op1,\n \n static void\n do_jump_by_parts_equality (tree treeop0, tree treeop1, rtx if_false_label,\n-\t\t\t   rtx if_true_label)\n+\t\t\t   rtx if_true_label, int prob)\n {\n   rtx op0 = expand_normal (treeop0);\n   rtx op1 = expand_normal (treeop1);\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (treeop0));\n   do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,\n-\t\t\t\t if_true_label);\n+\t\t\t\t if_true_label, prob);\n }\n \f\n /* Split a comparison into two others, the second of which has the other\n@@ -849,10 +886,11 @@ split_comparison (enum rtx_code code, enum machine_mode mode,\n void\n do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t\t enum machine_mode mode, rtx size, rtx if_false_label,\n-\t\t\t rtx if_true_label)\n+\t\t\t rtx if_true_label, int prob)\n {\n   rtx tem;\n   rtx dummy_label = NULL_RTX;\n+  rtx last;\n \n   /* Reverse the comparison if that is safe and we want to jump if it is\n      false.  Also convert to the reverse comparison if the target can\n@@ -878,6 +916,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n           if_true_label = if_false_label;\n           if_false_label = tem;\n \t  code = rcode;\n+\t  prob = inv (prob);\n \t}\n     }\n \n@@ -924,52 +963,56 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t{\n \tcase LTU:\n \t  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,\n-\t\t\t\t\tif_false_label, if_true_label);\n+\t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase LEU:\n \t  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,\n-\t\t\t\t\tif_true_label, if_false_label);\n+\t\t\t\t\tif_true_label, if_false_label,\n+\t\t\t\t\tinv (prob));\n \t  break;\n \n \tcase GTU:\n \t  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,\n-\t\t\t\t\tif_false_label, if_true_label);\n+\t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase GEU:\n \t  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,\n-\t\t\t\t\tif_true_label, if_false_label);\n+\t\t\t\t\tif_true_label, if_false_label,\n+\t\t\t\t\tinv (prob));\n \t  break;\n \n \tcase LT:\n \t  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,\n-\t\t\t\t\tif_false_label, if_true_label);\n+\t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase LE:\n \t  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,\n-\t\t\t\t\tif_true_label, if_false_label);\n+\t\t\t\t\tif_true_label, if_false_label,\n+\t\t\t\t\tinv (prob));\n \t  break;\n \n \tcase GT:\n \t  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,\n-\t\t\t\t\tif_false_label, if_true_label);\n+\t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase GE:\n \t  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,\n-\t\t\t\t\tif_true_label, if_false_label);\n+\t\t\t\t\tif_true_label, if_false_label,\n+\t\t\t\t\tinv (prob));\n \t  break;\n \n \tcase EQ:\n \t  do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,\n-\t\t\t\t\t if_true_label);\n+\t\t\t\t\t if_true_label, prob);\n \t  break;\n \n \tcase NE:\n \t  do_jump_by_parts_equality_rtx (mode, op0, op1, if_true_label,\n-\t\t\t\t\t if_false_label);\n+\t\t\t\t\t if_false_label, inv (prob));\n \t  break;\n \n \tdefault:\n@@ -1025,16 +1068,38 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t  else\n \t\t    dest_label = if_false_label;\n                   do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n-\t\t\t\t\t   size, dest_label, NULL_RTX);\n+\t\t\t\t\t   size, dest_label, NULL_RTX, prob);\n \t\t}\n               else\n                 do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n-\t\t\t\t\t size, NULL_RTX, if_true_label);\n+\t\t\t\t\t size, NULL_RTX, if_true_label, prob);\n \t    }\n \t}\n \n+      last = get_last_insn ();\n       emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n \t\t\t       if_true_label);\n+      if (prob != -1 && profile_status != PROFILE_ABSENT)\n+\t{\n+\t  for (last = NEXT_INSN (last);\n+\t       last && NEXT_INSN (last);\n+\t       last = NEXT_INSN (last))\n+\t    if (JUMP_P (last))\n+\t      break;\n+\t  if (!last\n+\t      || !JUMP_P (last)\n+\t      || NEXT_INSN (last)\n+\t      || !any_condjump_p (last))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Failed to add probability note\\n\");\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n+\t      add_reg_note (last, REG_BR_PROB, GEN_INT (prob));\n+\t    }\n+\t}\n     }\n \n   if (if_false_label)\n@@ -1056,7 +1121,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n static void\n do_compare_and_jump (tree treeop0, tree treeop1, enum rtx_code signed_code,\n \t\t     enum rtx_code unsigned_code, rtx if_false_label,\n-\t\t     rtx if_true_label)\n+\t\t     rtx if_true_label, int prob)\n {\n   rtx op0, op1;\n   tree type;\n@@ -1116,7 +1181,7 @@ do_compare_and_jump (tree treeop0, tree treeop1, enum rtx_code signed_code,\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,\n                            ((mode == BLKmode)\n                             ? expr_size (treeop0) : NULL_RTX),\n-                           if_false_label, if_true_label);\n+\t\t\t   if_false_label, if_true_label, prob);\n }\n \n #include \"gt-dojump.h\""}, {"sha": "ab42fd0a673dc35e3dc49b5053f88a9d118accad", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,7 +1,7 @@\n /* Medium-level subroutines: convert bit-field store and extract\n    and shifts, multiplies and divides to rtl instructions.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -5792,7 +5792,7 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n     {\n       label = gen_label_rtx ();\n       do_compare_rtx_and_jump (target, const0_rtx, EQ, unsignedp,\n-\t\t\t       mode, NULL_RTX, NULL_RTX, label);\n+\t\t\t       mode, NULL_RTX, NULL_RTX, label, -1);\n       emit_move_insn (target, trueval);\n       emit_label (label);\n       return target;\n@@ -5830,7 +5830,7 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   emit_move_insn (target, trueval);\n   label = gen_label_rtx ();\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX,\n-\t\t\t   NULL_RTX, label);\n+\t\t\t   NULL_RTX, label, -1);\n \n   emit_move_insn (target, falseval);\n   emit_label (label);\n@@ -5848,5 +5848,5 @@ do_cmp_and_jump (rtx arg1, rtx arg2, enum rtx_code op, enum machine_mode mode,\n {\n   int unsignedp = (op == LTU || op == LEU || op == GTU || op == GEU);\n   do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, label);\n+\t\t\t   NULL_RTX, NULL_RTX, label, -1);\n }"}, {"sha": "cd013b023a682107dca5a6819cc6cbd4f0c839f9", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,6 +1,6 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -4551,7 +4551,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n-      jumpifnot (TREE_OPERAND (exp, 0), lab1);\n+      jumpifnot (TREE_OPERAND (exp, 0), lab1, -1);\n       store_expr (TREE_OPERAND (exp, 1), target, call_param_p,\n \t\t  nontemporal);\n       emit_jump_insn (gen_jump (lab2));\n@@ -5547,7 +5547,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    /* Generate a conditional jump to exit the loop.  */\n \t\t    exit_cond = build2 (LT_EXPR, integer_type_node,\n \t\t\t\t\tindex, hi_index);\n-\t\t    jumpif (exit_cond, loop_end);\n+\t\t    jumpif (exit_cond, loop_end, -1);\n \n \t\t    /* Update the loop counter, and jump to the head of\n \t\t       the loop.  */\n@@ -8013,7 +8013,8 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n \ttemp = gen_label_rtx ();\n \tdo_compare_rtx_and_jump (target, cmpop1, comparison_code,\n-\t\t\t\t unsignedp, mode, NULL_RTX, NULL_RTX, temp);\n+\t\t\t\t unsignedp, mode, NULL_RTX, NULL_RTX, temp,\n+\t\t\t\t -1);\n       }\n       emit_move_insn (target, op1);\n       emit_label (temp);\n@@ -8121,7 +8122,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n       emit_move_insn (target, const0_rtx);\n \n       op1 = gen_label_rtx ();\n-      jumpifnot_1 (code, treeop0, treeop1, op1);\n+      jumpifnot_1 (code, treeop0, treeop1, op1, -1);\n \n       emit_move_insn (target, const1_rtx);\n \n@@ -9418,7 +9419,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \temit_move_insn (target, const0_rtx);\n \n       op1 = gen_label_rtx ();\n-      jumpifnot_1 (code, treeop0, treeop1, op1);\n+      jumpifnot_1 (code, treeop0, treeop1, op1, -1);\n \n       if (target)\n \temit_move_insn (target, const1_rtx);\n@@ -9475,7 +9476,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n        NO_DEFER_POP;\n        op0 = gen_label_rtx ();\n        op1 = gen_label_rtx ();\n-       jumpifnot (treeop0, op0);\n+       jumpifnot (treeop0, op0, -1);\n        store_expr (treeop1, temp,\n  \t\t  modifier == EXPAND_STACK_PARM,\n \t\t  false);\n@@ -9521,7 +9522,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    int value = TREE_CODE (rhs) == BIT_IOR_EXPR;\n \t    do_jump (TREE_OPERAND (rhs, 1),\n \t\t     value ? label : 0,\n-\t\t     value ? 0 : label);\n+\t\t     value ? 0 : label, -1);\n \t    expand_assignment (lhs, build_int_cst (TREE_TYPE (rhs), value),\n \t\t\t       MOVE_NONTEMPORAL (exp));\n \t    do_pending_stack_adjust ();"}, {"sha": "4fddde6006ef6650d00ec69bf0af51aa80bb1986", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for code generation pass of GNU compiler.\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -583,20 +583,20 @@ extern void do_pending_stack_adjust (void);\n extern tree string_constant (tree, tree *);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n-extern void jumpifnot (tree, rtx);\n-extern void jumpifnot_1 (enum tree_code, tree, tree, rtx);\n+extern void jumpifnot (tree, rtx, int);\n+extern void jumpifnot_1 (enum tree_code, tree, tree, rtx, int);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n-extern void jumpif (tree, rtx);\n-extern void jumpif_1 (enum tree_code, tree, tree, rtx);\n+extern void jumpif (tree, rtx, int);\n+extern void jumpif_1 (enum tree_code, tree, tree, rtx, int);\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.  */\n-extern void do_jump (tree, rtx, rtx);\n-extern void do_jump_1 (enum tree_code, tree, tree, rtx, rtx);\n+extern void do_jump (tree, rtx, rtx, int);\n+extern void do_jump_1 (enum tree_code, tree, tree, rtx, rtx, int);\n \n extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n-\t\t\t\t     enum machine_mode, rtx, rtx, rtx);\n+\t\t\t\t     enum machine_mode, rtx, rtx, rtx, int);\n \n /* Two different ways of generating switch statements.  */\n extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx);"}, {"sha": "edf62fa8aa8f7061f912ddbec3ef4fe1af499a45", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,5 +1,5 @@\n /* Loop unswitching for GNU compiler.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -121,7 +121,7 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n       op0 = force_operand (op0, NULL_RTX);\n       op1 = force_operand (op1, NULL_RTX);\n       do_compare_rtx_and_jump (op0, op1, comp, 0,\n-\t\t\t       mode, NULL_RTX, NULL_RTX, label);\n+\t\t\t       mode, NULL_RTX, NULL_RTX, label, -1);\n       jump = get_last_insn ();\n       JUMP_LABEL (jump) = label;\n       LABEL_NUSES (label)++;"}, {"sha": "747166b18d38b8d278a1f42ea4f22419698c143a", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,6 +1,6 @@\n /* Expand the basic unary and binary arithmetic operations, for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1127,7 +1127,7 @@ expand_doubleword_shift (enum machine_mode op1_mode, optab binoptab,\n \n   NO_DEFER_POP;\n   do_compare_rtx_and_jump (cmp1, cmp2, cmp_code, false, op1_mode,\n-\t\t\t   0, 0, subword_label);\n+\t\t\t   0, 0, subword_label, -1);\n   OK_DEFER_POP;\n \n   if (!expand_superword_shift (binoptab, outof_input, superword_op1,\n@@ -3469,7 +3469,7 @@ expand_abs (enum machine_mode mode, rtx op0, rtx target,\n   NO_DEFER_POP;\n \n   do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, op1);\n+\t\t\t   NULL_RTX, NULL_RTX, op1, -1);\n \n   op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,\n                      target, target, 0);"}, {"sha": "2778befd198507443ac5ec7f943ea632a3e793dc", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e90eac9591b388ab335cac5f793906cc9a5b0a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=40e90eac9591b388ab335cac5f793906cc9a5b0a", "patch": "@@ -1,7 +1,7 @@\n /* Expands front end tree to back end RTL for GCC\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n-   Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2535,7 +2535,7 @@ do_jump_if_equal (enum machine_mode mode, rtx op0, rtx op1, rtx label,\n \t\t  int unsignedp)\n {\n   do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, label);\n+\t\t\t   NULL_RTX, NULL_RTX, label, -1);\n }\n \f\n /* Not all case values are encountered equally.  This function"}]}