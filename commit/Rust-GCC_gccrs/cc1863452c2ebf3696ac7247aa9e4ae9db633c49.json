{"sha": "cc1863452c2ebf3696ac7247aa9e4ae9db633c49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MxODYzNDUyYzJlYmYzNjk2YWM3MjQ3YWE5ZTRhZTlkYjYzM2M0OQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2013-01-02T17:09:09Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2013-01-02T17:09:09Z"}, "message": "re PR fortran/55818 (Reading a REAL from a file which doesn't end in a new line fails)\n\n2013-01-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/55818\n\t* io/list_read.c (read_real): Do not call hit_eof when EOF can be\n\ttreated as a value separator.\n\t(parse_real): Likewise.\n\t(read_logical): Likewise.\n\t(read_character): Likewise.\n\t(read_complex): Likewise.\n\nFrom-SVN: r194809", "tree": {"sha": "96f69140388e01cd86f90c4f421f951de7d9ebb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96f69140388e01cd86f90c4f421f951de7d9ebb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc1863452c2ebf3696ac7247aa9e4ae9db633c49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1863452c2ebf3696ac7247aa9e4ae9db633c49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc1863452c2ebf3696ac7247aa9e4ae9db633c49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1863452c2ebf3696ac7247aa9e4ae9db633c49/comments", "author": null, "committer": null, "parents": [{"sha": "8c075fb4a3711edf275dea817aeaee0085e93e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c075fb4a3711edf275dea817aeaee0085e93e58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c075fb4a3711edf275dea817aeaee0085e93e58"}], "stats": {"total": 49, "additions": 34, "deletions": 15}, "files": [{"sha": "2c4dcbb7e465dd54ea4adf285ff1810e3c0ad555", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1863452c2ebf3696ac7247aa9e4ae9db633c49/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1863452c2ebf3696ac7247aa9e4ae9db633c49/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=cc1863452c2ebf3696ac7247aa9e4ae9db633c49", "patch": "@@ -1,3 +1,13 @@\n+2013-01-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/55818\n+\t* io/list_read.c (read_real): Do not call hit_eof when EOF can be\n+\ttreated as a value separator.\n+\t(parse_real): Likewise.\n+\t(read_logical): Likewise.\n+\t(read_character): Likewise.\n+\t(read_complex): Likewise.\n+\n 2012-12-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/48976"}, {"sha": "acc27e449b1bc941db15b160bec9c1a671800c42", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1863452c2ebf3696ac7247aa9e4ae9db633c49/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1863452c2ebf3696ac7247aa9e4ae9db633c49/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=cc1863452c2ebf3696ac7247aa9e4ae9db633c49", "patch": "@@ -1,4 +1,5 @@\n /* Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011, 2012\n+\t\t 2013\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist input contributed by Paul Thomas\n@@ -697,6 +698,7 @@ read_logical (st_parameter_dt *dtp, int length)\n       break;\n \n     CASE_SEPARATORS:\n+    case EOF:\n       unget_char (dtp, c);\n       eat_separator (dtp);\n       return;\t\t\t/* Null value.  */\n@@ -951,6 +953,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n       break;\n \n     CASE_SEPARATORS:\n+    case EOF:\n       unget_char (dtp, c);\t\t/* NULL value.  */\n       eat_separator (dtp);\n       return;\n@@ -975,15 +978,15 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \n   for (;;)\n     {\n-      if ((c = next_char (dtp)) == EOF)\n-\tgoto eof;\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n \t  push_char (dtp, c);\n \t  break;\n \n \tCASE_SEPARATORS:\n+\tcase EOF:\n \t  unget_char (dtp, c);\n \t  goto done;\t\t/* String was only digits!  */\n \n@@ -1041,7 +1044,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \t     the string.  */\n \n \t  if ((c = next_char (dtp)) == EOF)\n-\t    goto eof;\n+\t    goto done_eof;\n \t  if (c == quote)\n \t    {\n \t      push_char (dtp, quote);\n@@ -1167,6 +1170,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \t  goto exp2;\n \n \tCASE_SEPARATORS:\n+\tcase EOF:\n \t  goto done;\n \n \tdefault:\n@@ -1202,6 +1206,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \t  break;\n \n \tCASE_SEPARATORS:\n+\tcase EOF:\n \t  unget_char (dtp, c);\n \t  goto done;\n \n@@ -1243,7 +1248,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \t\t&& ((c = next_char (dtp)) == 'y' || c == 'Y')\n \t\t&& (c = next_char (dtp))))\n \t  {\n-\t     if (is_separator (c))\n+\t     if (is_separator (c) || (c == EOF))\n \t       unget_char (dtp, c);\n \t     push_char (dtp, 'i');\n \t     push_char (dtp, 'n');\n@@ -1255,7 +1260,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \t   && ((c = next_char (dtp)) == 'n' || c == 'N')\n \t   && (c = next_char (dtp)))\n     {\n-      if (is_separator (c))\n+      if (is_separator (c) || (c == EOF))\n \tunget_char (dtp, c);\n       push_char (dtp, 'n');\n       push_char (dtp, 'a');\n@@ -1269,7 +1274,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \t      goto bad;\n \n \t  c = next_char (dtp);\n-\t  if (is_separator (c))\n+\t  if (is_separator (c) || (c == EOF))\n \t    unget_char (dtp, c);\n \t}\n       goto done_infnan;\n@@ -1315,6 +1320,7 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n       break;\n \n     CASE_SEPARATORS:\n+    case EOF:\n       unget_char (dtp, c);\n       eat_separator (dtp);\n       return;\n@@ -1369,7 +1375,7 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n     goto bad_complex;\n \n   c = next_char (dtp);\n-  if (!is_separator (c))\n+  if (!is_separator (c) && (c != EOF))\n     goto bad_complex;\n \n   unget_char (dtp, c);\n@@ -1429,6 +1435,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n       goto got_sign;\n \n     CASE_SEPARATORS:\n+    case EOF:\n       unget_char (dtp, c);\t\t/* Single null.  */\n       eat_separator (dtp);\n       return;\n@@ -1484,6 +1491,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \t  goto got_repeat;\n \n \tCASE_SEPARATORS:\n+\tcase EOF:\n           if (c != '\\n' && c != ',' && c != '\\r' && c != ';')\n \t    unget_char (dtp, c);\n \t  goto done;\n@@ -1612,6 +1620,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \t  break;\n \n \tCASE_SEPARATORS:\n+\tcase EOF:\n \t  goto done;\n \n \tdefault:\n@@ -1647,7 +1656,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \tgoto unwind;\n       c = next_char (dtp);\n       l_push_char (dtp, c);\n-      if (!is_separator (c))\n+      if (!is_separator (c) && (c != EOF))\n \t{\n \t  if (c != 'i' && c != 'I')\n \t    goto unwind;\n@@ -1700,7 +1709,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \t}\n     }\n \n-  if (!is_separator (c))\n+  if (!is_separator (c) && (c != EOF))\n     goto unwind;\n \n   if (dtp->u.p.namelist_mode)\n@@ -2537,16 +2546,16 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n           switch (nl->type)\n \t  {\n \t  case BT_INTEGER:\n-\t      read_integer (dtp, len);\n-              break;\n+\t    read_integer (dtp, len);\n+            break;\n \n \t  case BT_LOGICAL:\n-\t      read_logical (dtp, len);\n-              break;\n+\t    read_logical (dtp, len);\n+\t    break;\n \n \t  case BT_CHARACTER:\n-\t      read_character (dtp, len);\n-              break;\n+\t    read_character (dtp, len);\n+\t    break;\n \n \t  case BT_REAL:\n \t    /* Need to copy data back from the real location to the temp in order"}]}