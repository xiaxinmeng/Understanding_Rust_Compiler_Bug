{"sha": "3b8f3e61394f27100fb788a839e61f8b753f502b", "node_id": "C_kwDOANBUbNoAKDNiOGYzZTYxMzk0ZjI3MTAwZmI3ODhhODM5ZTYxZjhiNzUzZjUwMmI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-09T10:11:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-09T10:11:28Z"}, "message": "Merge #1220 #1221\n\n1220: Ensure the coercion sites are applied correctly on unions r=philberty a=philberty\n\nWhen we construct a union, we were wrongly compiling the constructor\r\nwithout taking into account the associated union index. This meant we\r\nif you were constructing a union using any other field than the first one\r\nyou had a bad coercion type check resulting in a silent failure of generating\r\nan error_mark_node.\r\n\r\nThis was caught using an assertion to ensure there is no error on coercion site but it is valid\r\nto have errors from coercion sites.\n\n1221: Ensure we don't return error_mark_node for loop expressions r=philberty a=philberty\n\nLoop expressions can return a value even if its a unit-type so we must\r\nensure we don't return an error_mark_node for the eventual coercion site\r\nfor the unit-type case.\r\n\r\nThe offending test-case was: rust/compile/torture/loop7.rs\r\n\r\nThis was found while fixing #1220 \r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "4186f8b73ca7635db5c0e7ca6484dca79365e00a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4186f8b73ca7635db5c0e7ca6484dca79365e00a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b8f3e61394f27100fb788a839e61f8b753f502b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJieOjQCRBK7hj4Ov3rIwAAViYIAJyhnYvmCjB3NCJvvPrn35bF\nPIybgxwCtMcEgYvjV/Gpvaw4OD+QqlW4HlMvLMCCiVmAXKKtdYB8V+hyOeYikCSz\ns+4PKBsFiufExdK9Lfbo37R1VxDXGztrNMgBvequ3VYmeDYB0S5+0PIPiEytNJ5u\nVJIOoTdHfp0G34RNS3TSxkJRLeM+Tk3+VE3KzigcdRO5XTOCJJoJQ/k8pXI3FwMD\n/e57n3JuE7LR9aoCDOE9r9KDpJ0O8zIQW4W0WLa8YvqsEbUB+I1GevcmGciZ4lSp\nrRdKJC0cIUvM5I/O0RUKRlXVlyksNqR0XAzo2ccr7EFU4GrKwrDQ+J1ysXnwid0=\n=0Tgn\n-----END PGP SIGNATURE-----\n", "payload": "tree 4186f8b73ca7635db5c0e7ca6484dca79365e00a\nparent 74e836599ce80a11b1fe28065ed7aae6ffa3b7e2\nparent 224647d24a3fe0411a46ac97d76e06fe2156a9fc\nparent 0d8c298443615c1fd75c9af10ca26c7c36b69273\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1652091088 +0000\ncommitter GitHub <noreply@github.com> 1652091088 +0000\n\nMerge #1220 #1221\n\n1220: Ensure the coercion sites are applied correctly on unions r=philberty a=philberty\n\nWhen we construct a union, we were wrongly compiling the constructor\r\nwithout taking into account the associated union index. This meant we\r\nif you were constructing a union using any other field than the first one\r\nyou had a bad coercion type check resulting in a silent failure of generating\r\nan error_mark_node.\r\n\r\nThis was caught using an assertion to ensure there is no error on coercion site but it is valid\r\nto have errors from coercion sites.\n\n1221: Ensure we don't return error_mark_node for loop expressions r=philberty a=philberty\n\nLoop expressions can return a value even if its a unit-type so we must\r\nensure we don't return an error_mark_node for the eventual coercion site\r\nfor the unit-type case.\r\n\r\nThe offending test-case was: rust/compile/torture/loop7.rs\r\n\r\nThis was found while fixing #1220 \r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8f3e61394f27100fb788a839e61f8b753f502b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8f3e61394f27100fb788a839e61f8b753f502b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8f3e61394f27100fb788a839e61f8b753f502b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74e836599ce80a11b1fe28065ed7aae6ffa3b7e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e836599ce80a11b1fe28065ed7aae6ffa3b7e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74e836599ce80a11b1fe28065ed7aae6ffa3b7e2"}, {"sha": "224647d24a3fe0411a46ac97d76e06fe2156a9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224647d24a3fe0411a46ac97d76e06fe2156a9fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224647d24a3fe0411a46ac97d76e06fe2156a9fc"}, {"sha": "0d8c298443615c1fd75c9af10ca26c7c36b69273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8c298443615c1fd75c9af10ca26c7c36b69273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8c298443615c1fd75c9af10ca26c7c36b69273"}], "stats": {"total": 80, "additions": 53, "deletions": 27}, "files": [{"sha": "b05b129324cfe20f61f675d75e914b5c71138766", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8f3e61394f27100fb788a839e61f8b753f502b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8f3e61394f27100fb788a839e61f8b753f502b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=3b8f3e61394f27100fb788a839e61f8b753f502b", "patch": "@@ -419,18 +419,19 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n     // compile it\n     tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n-    // this assumes all fields are in order from type resolution and if a base\n-    // struct was specified those fields are filed via accesors\n     std::vector<tree> arguments;\n-    for (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n+    if (adt->is_union ())\n       {\n+\trust_assert (struct_expr.get_fields ().size () == 1);\n+\n \t// assignments are coercion sites so lets convert the rvalue if\n \t// necessary\n-\tauto respective_field = variant->get_field_at_index (i);\n+\tauto respective_field\n+\t  = variant->get_field_at_index (union_disriminator);\n \tauto expected = respective_field->get_field_type ();\n \n \t// process arguments\n-\tauto &argument = struct_expr.get_fields ().at (i);\n+\tauto &argument = struct_expr.get_fields ().at (0);\n \tauto lvalue_locus\n \t  = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n \tauto rvalue_locus = argument->get_locus ();\n@@ -440,8 +441,6 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \tbool ok = ctx->get_tyctx ()->lookup_type (\n \t  argument->get_mappings ().get_hirid (), &actual);\n \n-\t// coerce it if required/possible see\n-\t// compile/torture/struct_base_init_1.rs\n \tif (ok)\n \t  {\n \t    rvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n@@ -451,6 +450,41 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t// add it to the list\n \targuments.push_back (rvalue);\n       }\n+    else\n+      {\n+\t// this assumes all fields are in order from type resolution and if a\n+\t// base struct was specified those fields are filed via accesors\n+\tfor (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n+\t  {\n+\t    // assignments are coercion sites so lets convert the rvalue if\n+\t    // necessary\n+\t    auto respective_field = variant->get_field_at_index (i);\n+\t    auto expected = respective_field->get_field_type ();\n+\n+\t    // process arguments\n+\t    auto &argument = struct_expr.get_fields ().at (i);\n+\t    auto lvalue_locus\n+\t      = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+\t    auto rvalue_locus = argument->get_locus ();\n+\t    auto rvalue\n+\t      = CompileStructExprField::Compile (argument.get (), ctx);\n+\n+\t    TyTy::BaseType *actual = nullptr;\n+\t    bool ok = ctx->get_tyctx ()->lookup_type (\n+\t      argument->get_mappings ().get_hirid (), &actual);\n+\n+\t    // coerce it if required/possible see\n+\t    // compile/torture/struct_base_init_1.rs\n+\t    if (ok)\n+\t      {\n+\t\trvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n+\t\t\t\t\trvalue_locus);\n+\t      }\n+\n+\t    // add it to the list\n+\t    arguments.push_back (rvalue);\n+\t  }\n+      }\n \n     // the constructor depends on whether this is actually an enum or not if\n     // its an enum we need to setup the discriminator\n@@ -552,21 +586,16 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n       }\n \n     fncontext fnctx = ctx->peek_fn ();\n-    Bvariable *tmp = NULL;\n-    bool needs_temp = !block_tyty->is_unit ();\n-    if (needs_temp)\n-      {\n-\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n-\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+    tree enclosing_scope = ctx->peek_enclosing_scope ();\n+    tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n-\tbool is_address_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\ttmp = ctx->get_backend ()->temporary_variable (\n-\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-\t  expr.get_locus (), &ret_var_stmt);\n-\tctx->add_statement (ret_var_stmt);\n-\tctx->push_loop_context (tmp);\n-      }\n+    bool is_address_taken = false;\n+    tree ret_var_stmt = NULL_TREE;\n+    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n+      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+      expr.get_locus (), &ret_var_stmt);\n+    ctx->add_statement (ret_var_stmt);\n+    ctx->push_loop_context (tmp);\n \n     if (expr.has_loop_label ())\n       {\n@@ -595,12 +624,9 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n       = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n     ctx->add_statement (loop_expr);\n \n-    if (tmp != NULL)\n-      {\n-\tctx->pop_loop_context ();\n-\ttranslated\n-\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-      }\n+    ctx->pop_loop_context ();\n+    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+\n     ctx->pop_loop_begin_label ();\n   }\n "}]}