{"sha": "3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmMDRkMWFmYThhNDk1NWEwYTlhMzk1ZGQyMWNlMWI2NDg0YWE3OA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-04-22T03:02:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-04-22T03:03:05Z"}, "message": "Fix Fortran rounding issues, PR fortran/96983.\n\nI was looking at Fortran PR 96983, which fails on the PowerPC when trying to\nrun the test PR96711.F90.  The compiler ICEs because the PowerPC does not have\na floating point type with a type precision of 128.  The reason is that the\nPowerPC has 3 different 128 bit floating point types (__float128/_Float128,\n__ibm128, and long double).  Currently long double uses the IBM extended double\ntype, but we would like to switch to using IEEE 128-bit long doubles in the\nfuture.\n\nIn order to prevent the compiler from converting explicit __ibm128 types to\nlong double when long double uses the IEEE 128-bit representation, we have set\nup the precision for __ibm128 to be 128, long double to be 127, and\n__float128/_Float128 to be 126.\n\nOriginally, I was trying to see if for Fortran, I could change the precision of\nlong double to be 128 (Fortran doesn't access __ibm128), but it quickly became\nhard to get the changes to work.\n\nI looked at the Fortran code in build_round_expr, and I came to the conclusion\nthat there is no reason to promote the floating point type.  If you just do a\nnormal round of the value using the current floating point format and then\nconvert it to the integer type.  We don't have an appropriate built-in function\nthat provides the equivalent of llround for 128-bit integer types.\n\nThis patch fixes the compiler crash.\n\nHowever, while with this patch, the PowerPC compiler will not crash when\nbuilding the test case, it will not run on the current default installation.\nThe failure is because the test is explicitly expecting 128-bit floating point\nto handle 10384593717069655257060992658440192_16 (i.e. 2**113).\n\nBy default, the PowerPC uses IBM extended double used for 128-bit floating\npoint.  The IBM extended double format is a pair of doubles that provides more\nmantissa bits but does not grow the expoenent range.  The value in the test is\nfine for IEEE 128-bit floating point, but it is too large for the PowerPC\nextended double setup.\n\nI have built the following tests with this patch:\n\n   * I have built a bootstrap compiler on a little endian power9 Linux system\n     with the default long double format (IBM extended double).  The\n     pr96711.f90 test builds, but it does not run due to the range of the\n     real*16 exponent.  There were no other regressions in the C/C++/Fortran\n     tests.\n\n   * I have built a bootstrap compiler on a little endian power9 Linux system\n     with the default long double format set to IEEE 128-bit. I used the\n     Advance Toolchain 14.0-2 to provide the IEEE 128-bits.  The compiler was\n     configured to build power9 code by default, so the test generated native\n     power9 IEEE 128-bit instructions.  The pr96711.f90 test builds and runs\n     correctly in this setup.\n\n   * I have built a bootstrap compiler on a big endian power8 Linux system with\n     the default long double format (IBM extended double).  Like the first\n     case, the pr96711.f90 test does not crash the compiler, but the test fails\n     due to the range of the real*16 exponent.    There were no other\n     regressions in the C/C++/Fortran tests.\n\n   * I built a bootstrap compiler on my x86_64 laptop.  There were no\n     regressions in the tests.\n\ngcc/fortran/\n2021-04-21  Michael Meissner  <meissner@linux.ibm.com>\n\n\tPR fortran/96983\n\t* trans-intrinsic.c (build_round_expr): If int type is larger than\n\tlong long, do the round and convert to the integer type.  Do not\n\ttry to find a floating point type the exact size of the integer\n\ttype.", "tree": {"sha": "1afe775ded02897a2ce6e3fd3b1a870f40b1910e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1afe775ded02897a2ce6e3fd3b1a870f40b1910e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78/comments", "author": null, "committer": null, "parents": [{"sha": "c1ef0c9234c29c33397b7687ba54c1221fcbcb6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ef0c9234c29c33397b7687ba54c1221fcbcb6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ef0c9234c29c33397b7687ba54c1221fcbcb6b"}], "stats": {"total": 26, "additions": 8, "deletions": 18}, "files": [{"sha": "cceef8f34acc6d9fe2541207684a6ce49014ee91", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=3cf04d1afa8a4955a0a9a395dd21ce1b6484aa78", "patch": "@@ -386,30 +386,20 @@ build_round_expr (tree arg, tree restype)\n   argprec = TYPE_PRECISION (argtype);\n   resprec = TYPE_PRECISION (restype);\n \n-  /* Depending on the type of the result, choose the int intrinsic\n-     (iround, available only as a builtin, therefore cannot use it for\n-     __float128), long int intrinsic (lround family) or long long\n-     intrinsic (llround).  We might also need to convert the result\n-     afterwards.  */\n+  /* Depending on the type of the result, choose the int intrinsic (iround,\n+     available only as a builtin, therefore cannot use it for __float128), long\n+     int intrinsic (lround family) or long long intrinsic (llround).  If we\n+     don't have an appropriate function that converts directly to the integer\n+     type (such as kind == 16), just use ROUND, and then convert the result to\n+     an integer.  We might also need to convert the result afterwards.  */\n   if (resprec <= INT_TYPE_SIZE && argprec <= LONG_DOUBLE_TYPE_SIZE)\n     fn = builtin_decl_for_precision (BUILT_IN_IROUND, argprec);\n   else if (resprec <= LONG_TYPE_SIZE)\n     fn = builtin_decl_for_precision (BUILT_IN_LROUND, argprec);\n   else if (resprec <= LONG_LONG_TYPE_SIZE)\n     fn = builtin_decl_for_precision (BUILT_IN_LLROUND, argprec);\n-  else if (resprec >= argprec && resprec == 128)\n-    {\n-      /* Search for a real kind suitable as temporary for conversion.  */\n-      int kind = -1;\n-      for (int i = 0; kind < 0 && gfc_real_kinds[i].kind != 0; i++)\n-\tif (gfc_real_kinds[i].mode_precision >= resprec)\n-\t  kind = gfc_real_kinds[i].kind;\n-      if (kind < 0)\n-\tgfc_internal_error (\"Could not find real kind with at least %d bits\",\n-\t\t\t    resprec);\n-      arg = fold_convert (gfc_get_real_type (kind), arg);\n-      fn = gfc_builtin_decl_for_float_kind (BUILT_IN_ROUND, kind);\n-    }\n+  else if (resprec >= argprec)\n+    fn = builtin_decl_for_precision (BUILT_IN_ROUND, argprec);\n   else\n     gcc_unreachable ();\n "}]}