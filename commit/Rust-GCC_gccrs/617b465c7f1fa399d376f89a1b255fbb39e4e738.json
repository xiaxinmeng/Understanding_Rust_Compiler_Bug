{"sha": "617b465c7f1fa399d376f89a1b255fbb39e4e738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE3YjQ2NWM3ZjFmYTM5OWQzNzZmODlhMWIyNTVmYmIzOWU0ZTczOA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-02-08T14:29:00Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-02-08T14:29:00Z"}, "message": "cfgloop.h (fix_loop_placement, [...]): Declare.\n\n\t* cfgloop.h (fix_loop_placement, can_duplicate_loop_p,\n\tduplicate_loop_to_header_edge, loopify, remove_path, split_loop_bb):\n\tDeclare.\n\t(DLTHE_FLAG_UPDATE_FREQ): New.\n\t* cfgloopmanip.c (duplicate_loop, duplicate_subloops, copy_loops_to,\n\tloop_redirect_edge, loop_delete_branch_edge, copy_bbs, remove_bbs,\n\trpe_enum_p, find_branch, alp_enum_p, add_loop, fix_loop_placements,\n\tfix_bb_placement, fix_bb_placements, place_new_loop,\n\tscale_loop_frequencies, scale_bbs_frequencies, record_exit_edges):\n\tNew static functions.\n\t(fix_loop_placement, can_duplicate_loop_p,\n\tduplicate_loop_to_header_edge, loopify, remove_path, split_loop_bb):\n\tNew functions.\n\n\t* cfgloop.h (loop_optimizer_init, loop_optimizer_finalize,\n\tunswitch_loops): Declare.\n\t* loop-init.c: New file.\n\t* loop-unswitch.c: New file.\n\t* Makefile.in (loop-init.o, loop-unswitch.o): New.\n\t* params.def (PARAM_MAX_UNSWITCH_INSNS, PARAM_MAX_UNSWITCH_LEVEL): New.\n\t* toplev.c (DFI_loop2): New dump.\n\t(flag_unswitch_loops): New.\n\t(lang_independent_options): Add it.\n\t(rest_of_compilation): Call new loop optimizer.\n\t(parse_options_and_default_flags): Turn flag_unswitch_loops on with -O3.\n\nFrom-SVN: r62578", "tree": {"sha": "a5f2166463824a1a17e45cfd6cfe1c23ebc0c708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5f2166463824a1a17e45cfd6cfe1c23ebc0c708"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/617b465c7f1fa399d376f89a1b255fbb39e4e738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617b465c7f1fa399d376f89a1b255fbb39e4e738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617b465c7f1fa399d376f89a1b255fbb39e4e738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617b465c7f1fa399d376f89a1b255fbb39e4e738/comments", "author": null, "committer": null, "parents": [{"sha": "3bd03194ff92b377d9fc2519340be224a2c01459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd03194ff92b377d9fc2519340be224a2c01459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd03194ff92b377d9fc2519340be224a2c01459"}], "stats": {"total": 1818, "additions": 1810, "deletions": 8}, "files": [{"sha": "418ff2a55295f6b7b474ab237d3899c1848a5b8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -1,3 +1,31 @@\n+2003-02-08  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloop.h (fix_loop_placement, can_duplicate_loop_p,\n+\tduplicate_loop_to_header_edge, loopify, remove_path, split_loop_bb):\n+\tDeclare.\n+\t(DLTHE_FLAG_UPDATE_FREQ): New.\n+\t* cfgloopmanip.c (duplicate_loop, duplicate_subloops, copy_loops_to,\n+\tloop_redirect_edge, loop_delete_branch_edge, copy_bbs, remove_bbs,\n+\trpe_enum_p, find_branch, alp_enum_p, add_loop, fix_loop_placements,\n+\tfix_bb_placement, fix_bb_placements, place_new_loop,\n+\tscale_loop_frequencies, scale_bbs_frequencies, record_exit_edges):\n+\tNew static functions.\n+\t(fix_loop_placement, can_duplicate_loop_p,\n+\tduplicate_loop_to_header_edge, loopify, remove_path, split_loop_bb):\n+\tNew functions.\n+\n+\t* cfgloop.h (loop_optimizer_init, loop_optimizer_finalize,\n+\tunswitch_loops): Declare.\n+\t* loop-init.c: New file.\n+\t* loop-unswitch.c: New file.\n+\t* Makefile.in (loop-init.o, loop-unswitch.o): New.\n+\t* params.def (PARAM_MAX_UNSWITCH_INSNS, PARAM_MAX_UNSWITCH_LEVEL): New.\n+\t* toplev.c (DFI_loop2): New dump.\n+\t(flag_unswitch_loops): New.\n+\t(lang_independent_options): Add it.\n+\t(rest_of_compilation): Call new loop optimizer.\n+\t(parse_options_and_default_flags): Turn flag_unswitch_loops on with -O3.\n+\n 2003-02-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/clzsi2.c: New."}, {"sha": "48a12ce080dd8a8c70826a812d5dadcdf58cc23d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -768,7 +768,7 @@ C_OBJS = c-parse.o c-lang.o c-pretty-print.o $(C_AND_OBJC_OBJS)\n \n OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n- cfgloopanal.o cfgloopmanip.o \t\t\t\t\t\t   \\\n+ cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o\t\t   \\\n  cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o\t   \\\n  debug.o df.o diagnostic.o doloop.o dominance.o\t\t                   \\\n  dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o\t   \\\n@@ -1600,6 +1600,12 @@ cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h $(EXPR_H) coretypes.h $(TM_H)\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h output.h coretypes.h $(TM_H)\n+loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) gcov-io.h \\\n+   gcov-iov.h $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h profile.h \\\n+   coretypes.h $(TM_H)\n+loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h params.h \\\n+   output.h $(EXPR_H) coretypes.h $(TM_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h"}, {"sha": "c46602f790ac6834ab3da20155b35f68b2a7942f", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -293,6 +293,7 @@ extern void cancel_loop\t\t\tPARAMS ((struct loops *, struct loop *));\n extern void cancel_loop_tree\t\tPARAMS ((struct loops *, struct loop *));\n \n extern basic_block loop_split_edge_with PARAMS ((edge, rtx, struct loops *));\n+extern int fix_loop_placement\t\tPARAMS ((struct loop *));\n \n enum\n {\n@@ -312,3 +313,27 @@ extern rtx count_loop_iterations\tPARAMS ((struct loop_desc *, rtx, rtx));\n extern bool just_once_each_iteration_p\tPARAMS ((struct loops *,struct loop *,\n \t\t\t\t\t\t basic_block));\n extern unsigned expected_loop_iterations PARAMS ((const struct loop *));\n+\n+/* Loop manipulation.  */\n+extern bool can_duplicate_loop_p\tPARAMS ((struct loop *loop));\n+\n+#define DLTHE_FLAG_UPDATE_FREQ\t1\t/* Update frequencies in\n+\t\t\t\t\t   duplicate_loop_to_header_edge.  */\n+\n+extern int duplicate_loop_to_header_edge PARAMS ((struct loop *, edge,\n+\t\t\t\t\t\tstruct loops *, unsigned,\n+\t\t\t\t\t\tsbitmap, edge, edge *,\n+\t\t\t\t\t\tunsigned *, int));\n+extern struct loop *loopify\t\tPARAMS ((struct loops *, edge,\n+\t\t\t\t\t\tedge, basic_block));\n+extern bool remove_path\t\t\tPARAMS ((struct loops *, edge));\n+extern edge split_loop_bb\t\tPARAMS ((struct loops *, basic_block,\n+\t\t\t\t\t\trtx));\n+\n+/* Loop optimizer initialization.  */\n+extern struct loops *loop_optimizer_init PARAMS ((FILE *));\n+extern void loop_optimizer_finalize\tPARAMS ((struct loops *, FILE *));\n+\n+/* Optimization passes.  */\n+extern void unswitch_loops\t\tPARAMS ((struct loops *));\n+"}, {"sha": "69cb63b21ddc648adcc9892be3de752e0e85b82b", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1171, "deletions": 7, "changes": 1178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -29,13 +29,1175 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfglayout.h\"\n #include \"output.h\"\n \n+static struct loop * duplicate_loop\tPARAMS ((struct loops *,\n+\t\t\t\t\t\tstruct loop *, struct loop *));\n+static void duplicate_subloops\t\tPARAMS ((struct loops *, struct loop *,\n+\t\t\t\t\t\tstruct loop *));\n+static void copy_loops_to\t\tPARAMS ((struct loops *, struct loop **,\n+\t\t\t\t\t\tint, struct loop *));\n+static void loop_redirect_edge\t\tPARAMS ((edge, basic_block));\n+static bool loop_delete_branch_edge\tPARAMS ((edge));\n+static void copy_bbs\t\t\tPARAMS ((basic_block *, int, edge,\n+\t\t\t\t\t\tedge, basic_block **,\n+\t\t\t\t\t\tstruct loops *, edge *,\n+\t\t\t\t\t\tedge *, int));\n+static void remove_bbs\t\t\tPARAMS ((dominance_info, basic_block *,\n+\t\t\t\t\t\tint));\n+static bool rpe_enum_p\t\t\tPARAMS ((basic_block, void *));\n+static int find_path\t\t\tPARAMS ((edge, dominance_info,\n+\t\t\t\t\t\tbasic_block **));\n+static bool alp_enum_p\t\t\tPARAMS ((basic_block, void *));\n+static void add_loop\t\t\tPARAMS ((struct loops *, struct loop *));\n+static void fix_loop_placements\t\tPARAMS ((struct loop *));\n+static bool fix_bb_placement\t\tPARAMS ((struct loops *, basic_block));\n+static void fix_bb_placements\t\tPARAMS ((struct loops *, basic_block));\n+static void place_new_loop\t\tPARAMS ((struct loops *, struct loop *));\n+static void scale_loop_frequencies\tPARAMS ((struct loop *, int, int));\n+static void scale_bbs_frequencies\tPARAMS ((basic_block *, int, int, int));\n+static void record_exit_edges\t\tPARAMS ((edge, basic_block *, int,\n+\t\t\t\t\t\tedge *, unsigned *, int));\n static basic_block create_preheader\tPARAMS ((struct loop *, dominance_info,\n \t\t\t\t\t\tint));\n \n+/* Splits basic block BB after INSN, returns created edge.  Updates loops\n+   and dominators.  */\n+edge\n+split_loop_bb (loops, bb, insn)\n+     struct loops *loops;\n+     basic_block bb;\n+     rtx insn;\n+{\n+  edge e;\n+  basic_block *dom_bbs;\n+  int n_dom_bbs, i;\n+\n+  /* Split the block.  */\n+  e = split_block (bb, insn);\n+\n+  /* Add dest to loop.  */\n+  add_bb_to_loop (e->dest, e->src->loop_father);\n+\n+  /* Fix dominators.  */\n+  add_to_dominance_info (loops->cfg.dom, e->dest);\n+  n_dom_bbs = get_dominated_by (loops->cfg.dom, e->src, &dom_bbs);\n+  for (i = 0; i < n_dom_bbs; i++)\n+    set_immediate_dominator (loops->cfg.dom, dom_bbs[i], e->dest);\n+  free (dom_bbs);\n+  set_immediate_dominator (loops->cfg.dom, e->dest, e->src);\n+\n+  /* Take care of RBI.  */\n+  alloc_aux_for_block (e->dest, sizeof (struct reorder_block_def));\n+\n+  return e;\n+}\n+\n+/* Checks whether basic block BB is dominated by RPE->DOM, where\n+   RPE is passed through DATA.  */\n+struct rpe_data\n+ {\n+   basic_block dom;\n+   dominance_info doms;\n+ };\n+\n+static bool\n+rpe_enum_p (bb, data)\n+     basic_block bb;\n+     void *data;\n+{\n+  struct rpe_data *rpe = data;\n+  return dominated_by_p (rpe->doms, bb, rpe->dom);\n+}\n+\n+/* Remove basic blocks BBS from loop structure and dominance info,\n+   and delete them afterwards.  */\n+static void\n+remove_bbs (dom, bbs, nbbs)\n+     dominance_info dom;\n+     basic_block *bbs;\n+     int nbbs;\n+{\n+  int i;\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      remove_bb_from_loops (bbs[i]);\n+      delete_from_dominance_info (dom, bbs[i]);\n+      flow_delete_block (bbs[i]);\n+    }\n+}\n+\n+/* Find path -- i.e. the basic blocks dominated by edge E and put them\n+   into array BBS, that will be allocated large enough to contain them.\n+   The number of basic blocks in the path is returned. */\n+static int\n+find_path (e, doms, bbs)\n+     edge e;\n+     dominance_info doms;\n+     basic_block **bbs;\n+{\n+  edge ae = NULL;\n+  struct rpe_data rpe;\n+\n+  if (e->dest->pred->pred_next)\n+    {\n+      for (ae = e->dest->pred; ae; ae = ae->pred_next)\n+\tif (ae != e && !dominated_by_p (doms, ae->src, e->dest))\n+\t  break;\n+    }\n+  if (ae)\n+    {\n+      /* The path is formed just by the edge.  */\n+      *bbs = NULL;\n+      return 0;\n+    }\n+\n+  /* Find bbs in the path.  */\n+  rpe.dom = e->dest;\n+  rpe.doms = doms;\n+  *bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  return dfs_enumerate_from (e->dest, 0, rpe_enum_p, *bbs,\n+\t\t\t     n_basic_blocks, &rpe);\n+}\n+\n+/* Fix placement of basic block BB inside loop hierarchy stored in LOOPS --\n+   Let L be a loop to that BB belongs.  Then every successor of BB must either\n+     1) belong to some superloop of loop L, or\n+     2) be a header of loop K such that K->outer is superloop of L\n+   Returns true if we had to move BB into other loop to enforce this condition,\n+   false if the placement of BB was already correct (provided that placements\n+   of its successors are correct).  */\n+static bool\n+fix_bb_placement (loops, bb)\n+     struct loops *loops;\n+     basic_block bb;\n+{\n+  edge e;\n+  struct loop *loop = loops->tree_root, *act;\n+\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      act = e->dest->loop_father;\n+      if (act->header == e->dest)\n+\tact = act->outer;\n+\n+      if (flow_loop_nested_p (loop, act))\n+\tloop = act;\n+    }\n+\n+  if (loop == bb->loop_father)\n+    return false;\n+\n+  remove_bb_from_loops (bb);\n+  add_bb_to_loop (bb, loop);\n+\n+  return true;\n+}\n+\n+/* Fix placements of basic blocks inside loop hierarchy stored in loops; i.e.\n+   enforce condition condition stated in description of fix_bb_placement. We\n+   start from basic block FROM that had some of its successors removed, so that\n+   his placement no longer has to be correct, and iteratively fix placement of\n+   its predecessors that may change if placement of FROM changed.  Also fix\n+   placement of subloops of FROM->loop_father, that might also be altered due\n+   to this change; the condition for them is simmilar, except that instead of\n+   successors we consider edges coming out of the loops.  */\n+static void\n+fix_bb_placements (loops, from)\n+     struct loops *loops;\n+     basic_block from;\n+{\n+  sbitmap in_queue;\n+  basic_block *queue, *qtop, *qbeg, *qend;\n+  struct loop *base_loop;\n+  edge e;\n+\n+  /* We pass through blocks back-reachable from FROM, testing whether some\n+     of their successors moved to outer loop.  It may be necessary to\n+     iterate several times, but it is finite, as we stop unless we move\n+     the basic block up the loop structure.  The whole story is a bit\n+     more complicated due to presence of subloops, those are moved using\n+     fix_loop_placement.  */\n+\n+  base_loop = from->loop_father;\n+  if (base_loop == loops->tree_root)\n+    return;\n+\n+  in_queue = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (in_queue);\n+  SET_BIT (in_queue, from->index);\n+  /* Prevent us from going out of the base_loop.  */\n+  SET_BIT (in_queue, base_loop->header->index);\n+\n+  queue = xcalloc (base_loop->num_nodes + 1, sizeof (basic_block));\n+  qtop = queue + base_loop->num_nodes + 1;\n+  qbeg = queue;\n+  qend = queue + 1;\n+  *qbeg = from;\n+\n+  while (qbeg != qend)\n+    {\n+      from = *qbeg;\n+      qbeg++;\n+      if (qbeg == qtop)\n+\tqbeg = queue;\n+      RESET_BIT (in_queue, from->index);\n+\n+      if (from->loop_father->header == from)\n+\t{\n+\t  /* Subloop header, maybe move the loop upward.  */\n+\t  if (!fix_loop_placement (from->loop_father))\n+\t    continue;\n+\t}\n+      else\n+\t{\n+\t  /* Ordinary basic block.  */\n+\t  if (!fix_bb_placement (loops, from))\n+\t    continue;\n+\t}\n+\n+      /* Something has changed, insert predecessors into queue.  */\n+      for (e = from->pred; e; e = e->pred_next)\n+\t{\n+\t  basic_block pred = e->src;\n+\t  struct loop *nca;\n+\n+\t  if (TEST_BIT (in_queue, pred->index))\n+\t    continue;\n+\n+\t  /* If it is subloop, then it either was not moved, or \n+\t     the path up the loop tree from base_loop do not contain\n+\t     it.  */\n+\t  nca = find_common_loop (pred->loop_father, base_loop);\n+\t  if (pred->loop_father != base_loop\n+\t      && (nca == base_loop\n+\t\t  || nca != pred->loop_father))\n+\t    pred = pred->loop_father->header;\n+\t  else if (!flow_loop_nested_p (from->loop_father, pred->loop_father))\n+\t    {\n+\t      /* No point in processing it.  */\n+\t      continue;\n+\t    }\n+\n+\t  if (TEST_BIT (in_queue, pred->index))\n+\t    continue;\n+\n+\t  /* Schedule the basic block.  */\n+\t  *qend = pred;\n+\t  qend++;\n+\t  if (qend == qtop)\n+\t    qend = queue;\n+\t  SET_BIT (in_queue, pred->index);\n+\t}\n+    }\n+  free (in_queue);\n+  free (queue);\n+}\n+\n+/* Removes path beginning at edge E, i.e. remove basic blocks dominated by E\n+   and update loop structure stored in LOOPS and dominators.  Return true if\n+   we were able to remove the path, false otherwise (and nothing is affected\n+   then).  */\n+bool\n+remove_path (loops, e)\n+     struct loops *loops;\n+     edge e;\n+{\n+  edge ae;\n+  basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n+  int i, nrem, n_bord_bbs, n_dom_bbs;\n+  sbitmap seen;\n+\n+  /* First identify the path.  */\n+  nrem = find_path (e, loops->cfg.dom, &rem_bbs);\n+\n+  n_bord_bbs = 0;\n+  bord_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  seen = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (seen);\n+\n+  /* Find \"border\" hexes -- i.e. those with predecessor in removed path.  */\n+  for (i = 0; i < nrem; i++)\n+    SET_BIT (seen, rem_bbs[i]->index);\n+  if (nrem)\n+    {\n+      for (i = 0; i < nrem; i++)\n+\t{\n+\t  bb = rem_bbs[i];\n+\t  for (ae = rem_bbs[i]->succ; ae; ae = ae->succ_next)\n+\t    if (ae->dest != EXIT_BLOCK_PTR && !TEST_BIT (seen, ae->dest->index))\n+\t      {\n+\t\tSET_BIT (seen, ae->dest->index);\n+\t\tbord_bbs[n_bord_bbs++] = ae->dest;\n+\t      }\n+\t}\n+    }\n+  else if (e->dest != EXIT_BLOCK_PTR)\n+    bord_bbs[n_bord_bbs++] = e->dest;\n+\n+  /* Remove the path.  */\n+  from = e->src;\n+  if (!loop_delete_branch_edge (e))\n+    {\n+      free (rem_bbs);\n+      free (bord_bbs);\n+      free (seen);\n+      return false;\n+    }\n+  dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+\n+  /* Cancel loops contained in the path.  */\n+  for (i = 0; i < nrem; i++)\n+    if (rem_bbs[i]->loop_father->header == rem_bbs[i])\n+      cancel_loop_tree (loops, rem_bbs[i]->loop_father);\n+\n+  remove_bbs (loops->cfg.dom, rem_bbs, nrem);\n+  free (rem_bbs);\n+\n+  /* Find blocks with whose dominators may be affected.  */\n+  n_dom_bbs = 0;\n+  sbitmap_zero (seen);\n+  for (i = 0; i < n_bord_bbs; i++)\n+    {\n+      int j, nldom;\n+      basic_block *ldom;\n+\n+      bb = get_immediate_dominator (loops->cfg.dom, bord_bbs[i]);\n+      if (TEST_BIT (seen, bb->index))\n+\tcontinue;\n+      SET_BIT (seen, bb->index);\n+\n+      nldom = get_dominated_by (loops->cfg.dom, bb, &ldom);\n+      for (j = 0; j < nldom; j++)\n+\tif (!dominated_by_p (loops->cfg.dom, from, ldom[j]))\n+\t  dom_bbs[n_dom_bbs++] = ldom[j];\n+      free(ldom);\n+    }\n+\n+  free (bord_bbs);\n+  free (seen);\n+\n+  /* Recount dominators.  */\n+  iterate_fix_dominators (loops->cfg.dom, dom_bbs, n_dom_bbs);\n+  free (dom_bbs);\n+\n+  /* Fix placements of basic blocks inside loops and the placement of\n+     loops in the loop tree.  */\n+  fix_bb_placements (loops, from);\n+  fix_loop_placements (from->loop_father);\n+\n+  return true;\n+}\n+\n+/* Predicate for enumeration in add_loop.  */\n+static bool\n+alp_enum_p (bb, alp_header)\n+     basic_block bb;\n+     void *alp_header;\n+{\n+  return bb != (basic_block) alp_header;\n+}\n+\n+/* Given LOOP structure with filled header and latch, find the body of the\n+   corresponding loop and add it to LOOPS tree.  */\n+static void\n+add_loop (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  basic_block *bbs;\n+  int i, n;\n+  \n+  /* Add it to loop structure.  */\n+  place_new_loop (loops, loop);\n+  loop->level = 1;\n+\n+  /* Find its nodes.  */\n+  bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  n = dfs_enumerate_from (loop->latch, 1, alp_enum_p,\n+\t\t\t  bbs, n_basic_blocks, loop->header);\n+\n+  for (i = 0; i < n; i++)\n+    add_bb_to_loop (bbs[i], loop);\n+  add_bb_to_loop (loop->header, loop);\n+\n+  free (bbs);\n+}\n+\n+/* Multiply all frequencies of basic blocks in array BBS of lenght NBBS\n+   by NUM/DEN.  */\n+static void\n+scale_bbs_frequencies (bbs, nbbs, num, den)\n+     basic_block *bbs;\n+     int nbbs;\n+     int num;\n+     int den;\n+{\n+  int i;\n+  edge e;\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      bbs[i]->frequency = (bbs[i]->frequency * num) / den;\n+      bbs[i]->count = (bbs[i]->count * num) / den;\n+      for (e = bbs[i]->succ; e; e = e->succ_next)\n+\te->count = (e->count * num) /den;\n+    }\n+}\n+\n+/* Multiply all frequencies in LOOP by NUM/DEN.  */\n+static void\n+scale_loop_frequencies (loop, num, den)\n+     struct loop *loop;\n+     int num;\n+     int den;\n+{\n+  basic_block *bbs;\n+\n+  bbs = get_loop_body (loop);\n+  scale_bbs_frequencies (bbs, loop->num_nodes, num, den);\n+  free (bbs);\n+}\n+\n+/* Make area between HEADER_EDGE and LATCH_EDGE a loop by connecting\n+   latch to header and update loop tree stored in LOOPS and dominators\n+   accordingly. Everything between them plus LATCH_EDGE destination must\n+   be dominated by HEADER_EDGE destination, and back-reachable from\n+   LATCH_EDGE source.  HEADER_EDGE is redirected to basic block SWITCH_BB,\n+   SWITCH_BB->succ to original destination of LATCH_EDGE and\n+   SWITCH_BB->succ->succ_next to original destination of HEADER_EDGE.\n+   Returns newly created loop.  */\n+struct loop *\n+loopify (loops, latch_edge, header_edge, switch_bb)\n+     struct loops *loops;\n+     edge latch_edge;\n+     edge header_edge;\n+     basic_block switch_bb;\n+{\n+  basic_block succ_bb = latch_edge->dest;\n+  basic_block pred_bb = header_edge->src;\n+  basic_block *dom_bbs, *body;\n+  unsigned n_dom_bbs, i, j;\n+  sbitmap seen;\n+  struct loop *loop = xcalloc (1, sizeof (struct loop));\n+  struct loop *outer = succ_bb->loop_father->outer;\n+  int freq, prob, tot_prob;\n+  gcov_type cnt;\n+  edge e;\n+\n+  loop->header = header_edge->dest;\n+  loop->latch = latch_edge->src;\n+\n+  freq = EDGE_FREQUENCY (header_edge);\n+  cnt = header_edge->count;\n+  prob = switch_bb->succ->probability;\n+  tot_prob = prob + switch_bb->succ->succ_next->probability;\n+  if (tot_prob == 0)\n+    tot_prob = 1;\n+\n+  /* Redirect edges.  */\n+  loop_redirect_edge (latch_edge, loop->header);\n+  loop_redirect_edge (header_edge, switch_bb);\n+  loop_redirect_edge (switch_bb->succ->succ_next, loop->header);\n+  loop_redirect_edge (switch_bb->succ, succ_bb);\n+\n+  /* Update dominators.  */\n+  set_immediate_dominator (loops->cfg.dom, switch_bb, pred_bb);\n+  set_immediate_dominator (loops->cfg.dom, loop->header, switch_bb);\n+  set_immediate_dominator (loops->cfg.dom, succ_bb, switch_bb);\n+\n+  /* Compute new loop.  */\n+  add_loop (loops, loop);\n+  flow_loop_tree_node_add (outer, loop);\n+\n+  /* Add switch_bb to appropriate loop.  */\n+  add_bb_to_loop (switch_bb, outer);\n+\n+  /* Fix frequencies.  */\n+  switch_bb->frequency = freq;\n+  switch_bb->count = cnt;\n+  for (e = switch_bb->succ; e; e = e->succ_next)\n+    e->count = (switch_bb->count * e->probability) / REG_BR_PROB_BASE;\n+  scale_loop_frequencies (loop, prob, tot_prob);\n+  scale_loop_frequencies (succ_bb->loop_father, tot_prob - prob, tot_prob);\n+\n+  /* Update dominators of blocks outside of LOOP.  */\n+  dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  n_dom_bbs = 0;\n+  seen = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (seen);\n+  body = get_loop_body (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    SET_BIT (seen, body[i]->index);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      unsigned nldom;\n+      basic_block *ldom;\n+\n+      nldom = get_dominated_by (loops->cfg.dom, body[i], &ldom);\n+      for (j = 0; j < nldom; j++)\n+\tif (!TEST_BIT (seen, ldom[j]->index))\n+\t  {\n+\t    SET_BIT (seen, ldom[j]->index);\n+\t    dom_bbs[n_dom_bbs++] = ldom[j];\n+\t  }\n+      free (ldom);\n+    }\n+\n+  iterate_fix_dominators (loops->cfg.dom, dom_bbs, n_dom_bbs);\n+\n+  free (body);\n+  free (seen);\n+  free (dom_bbs);\n+\n+  return loop;\n+}\n+\n+/* Fix placement of LOOP inside loop tree, i.e. find the innermost superloop\n+   FATHER of LOOP such that all of the edges comming out of LOOP belong to\n+   FATHER, and set it as outer loop of LOOP.  Return 1 if placement of\n+   LOOP changed.  */\n+int\n+fix_loop_placement (loop)\n+     struct loop *loop;\n+{\n+  basic_block *body;\n+  unsigned i;\n+  edge e;\n+  struct loop *father = loop->pred[0], *act;\n+\n+  body = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    for (e = body[i]->succ; e; e = e->succ_next)\n+      if (!flow_bb_inside_loop_p (loop, e->dest))\n+\t{\n+\t  act = find_common_loop (loop, e->dest->loop_father);\n+\t  if (flow_loop_nested_p (father, act))\n+\t    father = act;\n+\t}\n+  free (body);\n+\n+  if (father != loop->outer)\n+    {\n+      for (act = loop->outer; act != father; act = act->outer)\n+\tact->num_nodes -= loop->num_nodes;\n+      flow_loop_tree_node_remove (loop);\n+      flow_loop_tree_node_add (father, loop);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Fix placement of superloops of LOOP inside loop tree, i.e. ensure that\n+   condition stated in description of fix_loop_placement holds for them.\n+   It is used in case when we removed some edges coming out of LOOP, which\n+   may cause the right placement of LOOP inside loop tree to change.  */\n+static void\n+fix_loop_placements (loop)\n+     struct loop *loop;\n+{\n+  struct loop *outer;\n+\n+  while (loop->outer)\n+    {\n+      outer = loop->outer;\n+      if (!fix_loop_placement (loop))\n+        break;\n+      loop = outer;\n+    }\n+}\n+\n+/* Creates place for a new LOOP in LOOPS structure.  */\n+static void\n+place_new_loop (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  loops->parray =\n+    xrealloc (loops->parray, (loops->num + 1) * sizeof (struct loop *));\n+  loops->parray[loops->num] = loop;\n+\n+  loop->num = loops->num++;\n+}\n+\n+/* Copies copy of LOOP as subloop of TARGET loop, placing newly\n+   created loop into LOOPS structure.  */\n+static struct loop *\n+duplicate_loop (loops, loop, target)\n+     struct loops *loops;\n+     struct loop *loop;\n+     struct loop *target;\n+{\n+  struct loop *cloop;\n+  cloop = xcalloc (1, sizeof (struct loop));\n+  place_new_loop (loops, cloop);\n+\n+  /* Initialize copied loop.  */\n+  cloop->level = loop->level;\n+\n+  /* Set it as copy of loop.  */\n+  loop->copy = cloop;\n+\n+  /* Add it to target.  */\n+  flow_loop_tree_node_add (target, cloop);\n+\n+  return cloop;\n+}\n+\n+/* Copies structure of subloops of LOOP into TARGET loop, placing\n+   newly created loops into loop tree stored in LOOPS.  */\n+static void \n+duplicate_subloops (loops, loop, target)\n+     struct loops *loops;\n+     struct loop *loop;\n+     struct loop *target;\n+{\n+  struct loop *aloop, *cloop;\n+\n+  for (aloop = loop->inner; aloop; aloop = aloop->next)\n+    {\n+      cloop = duplicate_loop (loops, aloop, target);\n+      duplicate_subloops (loops, aloop, cloop);\n+    }\n+}\n+\n+/* Copies structure of subloops of N loops, stored in array COPIED_LOOPS,\n+   into TARGET loop, placing newly created loops into loop tree LOOPS.  */\n+static void \n+copy_loops_to (loops, copied_loops, n, target)\n+     struct loops *loops;\n+     struct loop **copied_loops;\n+     int n;\n+     struct loop *target;\n+{\n+  struct loop *aloop;\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      aloop = duplicate_loop (loops, copied_loops[i], target);\n+      duplicate_subloops (loops, copied_loops[i], aloop);\n+    }\n+}\n+\n+/* Redirects edge E to basic block DEST.  */\n+static void\n+loop_redirect_edge (e, dest)\n+     edge e;\n+     basic_block dest;\n+{\n+  if (e->dest == dest)\n+    return;\n+\n+  cfg_layout_redirect_edge (e, dest);\n+}\n+\n+/* Deletes edge E from a branch if possible.  */\n+static bool\n+loop_delete_branch_edge (e)\n+     edge e;\n+{\n+  basic_block src = e->src;\n+\n+  if (src->succ->succ_next)\n+    {\n+      basic_block newdest;\n+      /* Cannot handle more than two exit edges.  */\n+      if (src->succ->succ_next->succ_next)\n+\treturn false;\n+      /* And it must be just a simple branch.  */\n+      if (!any_condjump_p (src->end))\n+\treturn false;\n+\n+      newdest = (e == src->succ\n+\t\t ? src->succ->succ_next->dest : src->succ->dest);\n+      if (newdest == EXIT_BLOCK_PTR)\n+\treturn false;\n+\n+      return cfg_layout_redirect_edge (e, newdest);\n+    }\n+  else\n+    {\n+      /* Cannot happen -- we are using this only to remove an edge\n+\t from branch. */\n+      abort ();\n+    }\n+\n+  return false;  /* To avoid warning, cannot get here.  */\n+}\n+\n+/* Duplicates N basic blocks stored in array BBS (they form a body of\n+   duplicated loop).  Newly created basic blocks are placed into array NEW_BBS\n+   that we allocate.  Edges from basic blocks in BBS are also duplicated and\n+   copies of those of them that lead into BBS are redirected to appropriate\n+   newly created block.  The function also assigns bbs into loops and updates\n+   dominators.  If ADD_IRREDUCIBLE_FLAG is set, newly created basic blocks that\n+   are not members of any inner loop are marked irreducible.\n+\n+   Additionally, we perform following manipulation with edges:\n+   We have two special edges given. LATCH_EDGE is the latch edge of the\n+   duplicated loop and leads into its header (one of blocks in BBS);\n+   it does not have neccessarily lead from one of the blocks, because\n+   we may be copying the loop body several times in unrolling.\n+   Edge ENTRY leads also leads to header, and it is either latch or entry\n+   edge.  Copy of LATCH_EDGE is redirected to header and is stored in\n+   HEADER_EDGE, the ENTRY edge is redirected into copy of header and\n+   returned as COPY_HEADER_EDGE.  The effect is following:\n+   if LATCH_EDGE == ENTRY, then the loop is unrolled by one copy,\n+     HEADER_EDGE is latch of a new loop, COPY_HEADER_EDGE leads from original\n+     latch source to first block in copy.\n+   if LATCH_EDGE != ENTRY, then the loop is peeled by one copy,\n+     HEADER_EDGE is entry edge of the loop, COPY_HEADER_EDGE leads from\n+     original entry block to first block in peeled copy.\n+ */\n+static void\n+copy_bbs (bbs, n, entry, latch_edge, new_bbs, loops, header_edge, copy_header_edge, add_irreducible_flag)\n+     basic_block *bbs;\n+     int n;\n+     edge entry;\n+     edge latch_edge;\n+     basic_block **new_bbs;\n+     struct loops *loops;\n+     edge *header_edge;\n+     edge *copy_header_edge;\n+     int add_irreducible_flag;\n+{\n+  int i;\n+  basic_block bb, new_bb, header = entry->dest, dom_bb;\n+  edge e;\n+\n+  /* Duplicate bbs, update dominators, assign bbs to loops.  */\n+  (*new_bbs) = xcalloc (n, sizeof (basic_block));\n+  for (i = 0; i < n; i++)\n+    {\n+      /* Duplicate.  */\n+      bb = bbs[i];\n+      new_bb = (*new_bbs)[i] = cfg_layout_duplicate_bb (bb, NULL);\n+      RBI (new_bb)->duplicated = 1;\n+      /* Add to loop.  */\n+      add_bb_to_loop (new_bb, bb->loop_father->copy);\n+      add_to_dominance_info (loops->cfg.dom, new_bb);\n+      /* Possibly set header.  */\n+      if (bb->loop_father->header == bb && bb != header)\n+\tnew_bb->loop_father->header = new_bb;\n+      /* Or latch.  */\n+      if (bb->loop_father->latch == bb &&\n+\t  bb->loop_father != header->loop_father)\n+\tnew_bb->loop_father->latch = new_bb;\n+      /* Take care of irreducible loops.  */\n+      if (add_irreducible_flag\n+\t  && bb->loop_father == header->loop_father)\n+\tnew_bb->flags |= BB_IRREDUCIBLE_LOOP;\n+    }\n+\n+  /* Set dominators.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      bb = bbs[i];\n+      new_bb = (*new_bbs)[i];\n+      if (bb != header)\n+\t{\n+\t  /* For anything else than loop header, just copy it.  */\n+\t  dom_bb = get_immediate_dominator (loops->cfg.dom, bb);\n+\t  dom_bb = RBI (dom_bb)->copy;\n+\t}\n+      else\n+\t{\n+\t  /* Copy of header is dominated by entry source.  */\n+\t  dom_bb = entry->src;\n+\t}\n+      if (!dom_bb)\n+\tabort ();\n+      set_immediate_dominator (loops->cfg.dom, new_bb, dom_bb);\n+    }\n+\n+  /* Redirect edges.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      edge e_pred;\n+      new_bb = (*new_bbs)[i];\n+      bb = bbs[i];\n+      for (e = bb->pred; e; e = e_pred)\n+\t{\n+\t  basic_block src = e->src;\n+\n+\t  e_pred = e->pred_next;\n+\t  \n+\t  if (!RBI (src)->duplicated)\n+\t    continue;\n+\n+\t  /* Leads to copied loop and it is not latch edge, redirect it.  */\n+\t  if (bb != header)\n+\t    loop_redirect_edge (e, new_bb);\n+\t}\n+    }\n+\n+  /* Redirect header edge.  */\n+  bb = RBI (latch_edge->src)->copy;\n+  for (e = bb->succ; e->dest != latch_edge->dest; e = e->succ_next);\n+  *header_edge = e;\n+  loop_redirect_edge (*header_edge, header);\n+\n+  /* Redirect entry to copy of header.  */\n+  loop_redirect_edge (entry, RBI (header)->copy);\n+  *copy_header_edge = entry;\n+\n+  /* Clear information about duplicates.  */\n+  for (i = 0; i < n; i++)\n+    RBI ((*new_bbs)[i])->duplicated = 0;\n+}\n+\n+/* Check whether LOOP's body can be duplicated.  */\n+bool\n+can_duplicate_loop_p (loop)\n+     struct loop *loop;\n+{\n+  basic_block *bbs;\n+  unsigned i;\n+\n+  bbs = get_loop_body (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      edge e;\n+\n+      /* In case loop contains abnormal edge we can not redirect,\n+         we can't perform duplication.  */\n+\n+      for (e = bbs[i]->succ; e; e = e->succ_next)\n+\tif ((e->flags & EDGE_ABNORMAL)\n+\t    && flow_bb_inside_loop_p (loop, e->dest))\n+\t  {\n+\t    free (bbs);\n+\t    return false;\n+\t  }\n+\n+      if (!cfg_layout_can_duplicate_bb_p (bbs[i]))\n+\t{\n+\t  free (bbs);\n+\t  return false;\n+\t}\n+    }\n+  free (bbs);\n+\n+  return true;\n+}\n+\n+/* Record edges, leading from NBBS basic blocks stored in BBS, that were created\n+   by copying ORIG edge (or just ORIG edge if IS_ORIG is set).\n+   If ORIG is NULL, then record all edges coming outside of BBS. Store them\n+   into TO_REMOVE array that must be large enough to hold them all; their\n+   number is returned in N_TO_REMOVE.  */\n+static void\n+record_exit_edges (orig, bbs, nbbs, to_remove, n_to_remove, is_orig)\n+     edge orig;\n+     basic_block *bbs;\n+     int nbbs;\n+     edge *to_remove;\n+     unsigned *n_to_remove;\n+     int is_orig;\n+{\n+  sbitmap my_blocks;\n+  int i;\n+  edge e;\n+\n+  if (orig)\n+    {\n+      if (is_orig)\n+\t{\n+\t  to_remove[(*n_to_remove)++] = orig;\n+\t  return;\n+\t}\n+\n+      for (e = RBI (orig->src)->copy->succ; e; e = e->succ_next)\n+\tif (e->dest == orig->dest)\n+\t  break;\n+      if (!e)\n+\tabort ();\n+\n+      to_remove[(*n_to_remove)++] = e;\n+    }\n+  else\n+    {\n+      my_blocks = sbitmap_alloc (last_basic_block);\n+      sbitmap_zero (my_blocks);\n+      for (i = 0; i < nbbs; i++)\n+        SET_BIT (my_blocks, bbs[i]->index);\n+\n+      for (i = 0; i < nbbs; i++)\n+\tfor (e = bbs[i]->succ; e; e = e->succ_next)\n+\t  if (e->dest == EXIT_BLOCK_PTR ||\n+\t      !TEST_BIT (my_blocks, e->dest->index))\n+\t    to_remove[(*n_to_remove)++] = e;\n+\n+      free (my_blocks);\n+    }\n+}\n+\n+\n+#define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n+\n+/* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of\n+   updating LOOPS structure and dominators.  E's destination must be LOOP\n+   header for this to work, i.e. it must be entry or latch edge of this loop;\n+   these are unique, as the loops must have preheaders for this function to\n+   work correctly (in case E is latch, the function unrolls the loop, if E is\n+   entry edge, it peels the loop).  Store edges created by copying ORIG edge\n+   (if NULL, then all edges leaving loop) from copies corresponding to set\n+   bits in WONT_EXIT bitmap (bit 0 corresponds to original LOOP body, the\n+   other copies are numbered in order given by control flow through them)\n+   into TO_REMOVE array.  Returns false if duplication is impossible.  */\n+int\n+duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n+\t\t\t       to_remove, n_to_remove, flags)\n+     struct loop *loop;\n+     edge e;\n+     struct loops *loops;\n+     unsigned ndupl;\n+     sbitmap wont_exit;\n+     edge orig;\n+     edge *to_remove;\n+     unsigned *n_to_remove;\n+     int flags;\n+{\n+  struct loop *target, *aloop;\n+  struct loop **orig_loops;\n+  unsigned n_orig_loops;\n+  basic_block header = loop->header, latch = loop->latch;\n+  basic_block *new_bbs, *bbs, *first_active;\n+  basic_block new_bb, bb, first_active_latch = NULL;\n+  edge ae, latch_edge, he;\n+  unsigned i, j, n;\n+  int is_latch = (latch == e->src);\n+  int scale_act = 0, *scale_step = NULL, scale_main = 0;\n+  int p, freq_in, freq_le, freq_out_orig;\n+  int prob_pass_thru, prob_pass_wont_exit, prob_pass_main;\n+  int add_irreducible_flag;\n+\n+  if (e->dest != loop->header)\n+    abort ();\n+  if (ndupl <= 0)\n+    abort ();\n+\n+  if (orig)\n+    {\n+      /* Orig must be edge out of the loop.  */\n+      if (!flow_bb_inside_loop_p (loop, orig->src))\n+\tabort ();\n+      if (flow_bb_inside_loop_p (loop, orig->dest))\n+\tabort ();\n+    }\n+\n+  bbs = get_loop_body (loop);\n+\n+  /* Check whether duplication is possible.  */\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      if (!cfg_layout_can_duplicate_bb_p (bbs[i]))\n+\t{\n+\t  free (bbs);\n+\t  return false;\n+\t}\n+    }\n+\n+  add_irreducible_flag = !is_latch && (e->src->flags & BB_IRREDUCIBLE_LOOP);\n+\n+  /* Find edge from latch.  */\n+  latch_edge = loop_latch_edge (loop);\n+\n+  if (flags & DLTHE_FLAG_UPDATE_FREQ)\n+    {\n+      /* Calculate coefficients by that we have to scale frequencies\n+\t of duplicated loop bodies.  */\n+      freq_in = header->frequency;\n+      freq_le = EDGE_FREQUENCY (latch_edge);\n+      if (freq_in == 0)\n+\tfreq_in = 1;\n+      if (freq_in < freq_le)\n+\tfreq_in = freq_le;\n+      freq_out_orig = orig ? EDGE_FREQUENCY (orig) : freq_in - freq_le;\n+      if (freq_out_orig > freq_in - freq_le)\n+\tfreq_out_orig = freq_in - freq_le;\n+      prob_pass_thru = RDIV (REG_BR_PROB_BASE * freq_le, freq_in);\n+      prob_pass_wont_exit =\n+\t      RDIV (REG_BR_PROB_BASE * (freq_le + freq_out_orig), freq_in);\n+\n+      scale_step = xmalloc (ndupl * sizeof (int));\n+\n+\tfor (i = 1; i <= ndupl; i++)\n+\t  scale_step[i - 1] = TEST_BIT (wont_exit, i) \n+\t\t\t\t? prob_pass_wont_exit\n+\t\t\t\t: prob_pass_thru;\n+\n+      if (is_latch)\n+\t{\n+\t  prob_pass_main = TEST_BIT (wont_exit, 0)\n+\t\t\t\t? prob_pass_wont_exit\n+\t\t\t\t: prob_pass_thru;\n+\t  p = prob_pass_main;\n+\t  scale_main = REG_BR_PROB_BASE;\n+\t  for (i = 0; i < ndupl; i++)\n+\t    {\n+\t      scale_main += p;\n+\t      p = RDIV (p * scale_step[i], REG_BR_PROB_BASE);\n+\t    }\n+\t  scale_main = RDIV (REG_BR_PROB_BASE * REG_BR_PROB_BASE, scale_main);\n+\t  scale_act = RDIV (scale_main * prob_pass_main, REG_BR_PROB_BASE);\n+\t}\n+      else\n+\t{\n+\t  scale_main = REG_BR_PROB_BASE;\n+\t  for (i = 0; i < ndupl; i++)\n+\t    scale_main = RDIV (scale_main * scale_step[i], REG_BR_PROB_BASE);\n+\t  scale_act = REG_BR_PROB_BASE - prob_pass_thru;\n+\t}\n+      for (i = 0; i < ndupl; i++)\n+\tif (scale_step[i] < 0 || scale_step[i] > REG_BR_PROB_BASE)\n+\t  abort ();\n+      if (scale_main < 0 || scale_main > REG_BR_PROB_BASE\n+\t  || scale_act < 0  || scale_act > REG_BR_PROB_BASE)\n+\tabort ();\n+    }\n+\n+  /* Loop the new bbs will belong to.  */\n+  target = find_common_loop (e->src->loop_father, e->dest->loop_father);\n+\n+  /* Original loops.  */\n+  n_orig_loops = 0;\n+  for (aloop = loop->inner; aloop; aloop = aloop->next)\n+    n_orig_loops++;\n+  orig_loops = xcalloc (n_orig_loops, sizeof (struct loop *));\n+  for (aloop = loop->inner, i = 0; aloop; aloop = aloop->next, i++)\n+    orig_loops[i] = aloop;\n+\n+  loop->copy = target;\n+  \n+  /* Original basic blocks.  */\n+  n = loop->num_nodes;\n+\n+  first_active = xcalloc(n, sizeof (basic_block));\n+  if (is_latch)\n+    {\n+      memcpy (first_active, bbs, n * sizeof (basic_block));\n+      first_active_latch = latch;\n+    }\n+\n+  /* Record exit edges in original loop body.  */\n+  if (TEST_BIT (wont_exit, 0))\n+    record_exit_edges (orig, bbs, n, to_remove, n_to_remove, true);\n+  \n+  for (j = 0; j < ndupl; j++)\n+    {\n+      /* Copy loops.  */\n+      copy_loops_to (loops, orig_loops, n_orig_loops, target);\n+\n+      /* Copy bbs.  */\n+      copy_bbs (bbs, n, e, latch_edge, &new_bbs, loops,\n+\t\t&e, &he, add_irreducible_flag);\n+      if (is_latch)\n+\tloop->latch = RBI (latch)->copy;\n+\n+      /* Record exit edges in this copy.  */\n+      if (TEST_BIT (wont_exit, j + 1))\n+\trecord_exit_edges (orig, new_bbs, n, to_remove, n_to_remove, false);\n+  \n+      /* Set counts and frequencies.  */\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  new_bb = new_bbs[i];\n+\t  bb = bbs[i];\n+\n+\t  if (flags & DLTHE_FLAG_UPDATE_FREQ)\n+\t    {\n+\t      new_bb->count = RDIV (scale_act * bb->count, REG_BR_PROB_BASE);\n+\t      new_bb->frequency = RDIV (scale_act * bb->frequency,\n+     \t\t\t\t\tREG_BR_PROB_BASE);\n+\t    }\n+\t  else\n+\t    {\n+\t      new_bb->count = bb->count;\n+\t      new_bb->frequency = bb->frequency;\n+\t    }\n+\n+\t  for (ae = new_bb->succ; ae; ae = ae->succ_next)\n+    \t    ae->count = RDIV (new_bb->count * ae->probability,\n+\t\t\t      REG_BR_PROB_BASE);\n+\t}\n+      if (flags & DLTHE_FLAG_UPDATE_FREQ)\n+\tscale_act = RDIV (scale_act * scale_step[j], REG_BR_PROB_BASE);\n+\n+      if (!first_active_latch)\n+\t{\n+\t  memcpy (first_active, new_bbs, n * sizeof (basic_block));\n+\t  first_active_latch = RBI (latch)->copy;\n+\t}\n+      \n+      free (new_bbs);\n+\n+      /* Original loop header is dominated by latch copy\n+\t if we duplicated on its only entry edge.  */\n+      if (!is_latch && !header->pred->pred_next->pred_next)\n+\tset_immediate_dominator (loops->cfg.dom, header, RBI (latch)->copy);\n+      if (is_latch && j == 0)\n+\t{\n+\t  /* Update edge from latch.  */\n+\t  for (latch_edge = RBI (header)->copy->pred;\n+\t       latch_edge->src != latch;\n+\t       latch_edge = latch_edge->pred_next);\n+\t}\n+    }\n+  /* Now handle original loop.  */\n+  \n+  /* Update edge counts.  */\n+  if (flags & DLTHE_FLAG_UPDATE_FREQ)\n+    {\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  bb = bbs[i];\n+\t  bb->count = RDIV (scale_main * bb->count, REG_BR_PROB_BASE);\n+\t  bb->frequency = RDIV (scale_main * bb->frequency, REG_BR_PROB_BASE);\n+\t  for (ae = bb->succ; ae; ae = ae->succ_next)\n+\t    ae->count = RDIV (bb->count * ae->probability, REG_BR_PROB_BASE);\n+\t}\n+      free (scale_step);\n+    }\n+  free (orig_loops);\n+\n+  /* Update dominators of other blocks if affected.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      basic_block dominated, dom_bb, *dom_bbs;\n+      int n_dom_bbs,j;\n+\n+      bb = bbs[i];\n+      n_dom_bbs = get_dominated_by (loops->cfg.dom, bb, &dom_bbs);\n+      for (j = 0; j < n_dom_bbs; j++)\n+\t{\n+\t  dominated = dom_bbs[j];\n+\t  if (flow_bb_inside_loop_p (loop, dominated))\n+\t    continue;\n+\t  dom_bb = nearest_common_dominator (\n+\t\t\tloops->cfg.dom, first_active[i], first_active_latch);\n+          set_immediate_dominator (loops->cfg.dom, dominated, dom_bb);\n+\t}\n+      free (dom_bbs);\n+    }\n+  free (first_active);\n+\n+  free (bbs);\n+\n+  return true;\n+}\n+\n /* Creates a pre-header for a LOOP.  Returns newly created block.  Unless\n    CP_SIMPLE_PREHEADERS is set in FLAGS, we only force LOOP to have single\n    entry; otherwise we also force preheader block to have only one successor.\n-   */\n+   The function also updates dominators stored in DOM.  */\n static basic_block\n create_preheader (loop, dom, flags)\n      struct loop *loop;\n@@ -131,8 +1293,8 @@ create_preheader (loop, dom, flags)\n   return dummy;\n }\n \n-/* Create preheaders for each loop; for meaning of flags see\n-   create_preheader.  */\n+/* Create preheaders for each loop from loop tree stored in LOOPS; for meaning\n+   of FLAGS see create_preheader.  */\n void\n create_preheaders (loops, flags)\n      struct loops *loops;\n@@ -144,7 +1306,8 @@ create_preheaders (loops, flags)\n   loops->state |= LOOPS_HAVE_PREHEADERS;\n }\n \n-/* Forces all loop latches to have only single successor.  */\n+/* Forces all loop latches of loops from loop tree LOOPS to have only single\n+   successor.  */\n void\n force_single_succ_latches (loops)\n      struct loops *loops;\n@@ -167,9 +1330,10 @@ force_single_succ_latches (loops)\n   loops->state |= LOOPS_HAVE_SIMPLE_LATCHES;\n }\n \n-/* A quite stupid function to put INSNS on E. They are supposed to form\n-   just one basic block. Jumps out are not handled, so cfg do not have to\n-   be ok after this function.  */\n+/* A quite stupid function to put INSNS on edge E. They are supposed to form\n+   just one basic block.  Jumps in INSNS are not handled, so cfg do not have to\n+   be ok after this function.  The created block is placed on correct place\n+   in LOOPS structure and its dominator is set.  */\n basic_block\n loop_split_edge_with (e, insns, loops)\n      edge e;"}, {"sha": "44b9d61d5b87f060d1b2f859c5ef8ee38fa3c4f4", "filename": "gcc/loop-init.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -0,0 +1,116 @@\n+/* Loop optimizer initialization routines.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"cfglayout.h\"\n+#include \"gcov-io.h\"\n+#include \"profile.h\"\n+\n+/* Initialize loop optimizer.  */\n+\n+struct loops *\n+loop_optimizer_init (dumpfile)\n+     FILE *dumpfile;\n+{\n+  struct loops *loops = xcalloc (1, sizeof (struct loops));\n+  edge e;\n+\n+  /* Avoid annoying special cases of edges going to exit\n+     block.  */\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+    if ((e->flags & EDGE_FALLTHRU) && e->src->succ->succ_next)\n+      split_edge (e);\n+\n+  /* Find the loops.  */\n+\n+  if (flow_loops_find (loops, LOOP_TREE) <= 1)\n+    {\n+      /* No loops.  */\n+      flow_loops_free (loops);\n+      free (loops);\n+      return NULL;\n+    }\n+\n+  /* Not going to update these.  */\n+  free (loops->cfg.rc_order);\n+  loops->cfg.rc_order = NULL;\n+  free (loops->cfg.dfs_order);\n+  loops->cfg.dfs_order = NULL;\n+\n+  /* Initialize structures for layout changes.  */\n+  cfg_layout_initialize (loops);\n+\n+  /* Create pre-headers.  */\n+  create_preheaders (loops, CP_SIMPLE_PREHEADERS | CP_INSIDE_CFGLAYOUT);\n+\n+  /* Force all latches to have only single successor.  */\n+  force_single_succ_latches (loops);\n+\n+  /* Mark irreducible loops.  */\n+  mark_irreducible_loops (loops);\n+\n+  /* Dump loops.  */\n+  flow_loops_dump (loops, dumpfile, NULL, 1);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_dominators (loops->cfg.dom);\n+  verify_loop_structure (loops);\n+#endif\n+\n+  return loops;\n+}\n+\n+/* Finalize loop optimizer.  */\n+void\n+loop_optimizer_finalize (loops, dumpfile)\n+     struct loops *loops;\n+     FILE *dumpfile;\n+{\n+  basic_block bb;\n+\n+  /* Finalize layout changes.  */\n+  /* Make chain.  */\n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      RBI (bb)->next = bb->next_bb;\n+\n+  /* Another dump.  */\n+  flow_loops_dump (loops, dumpfile, NULL, 1);\n+\n+  /* Clean up.  */\n+  flow_loops_free (loops);\n+  free (loops);\n+ \n+  /* Finalize changes.  */\n+  cfg_layout_finalize ();\n+\n+  /* Checking.  */\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+}\n+"}, {"sha": "8d6654c520eed0889d332b88658f87c3a6a0c111", "filename": "gcc/loop-unswitch.c", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -0,0 +1,412 @@\n+/* Loop unswitching for GNU compiler.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"cfglayout.h\"\n+#include \"params.h\"\n+#include \"output.h\"\n+#include \"expr.h\"\n+\n+/* This pass moves constant conditions out of loops, duplicating the loop\n+   in progres, i.e. this code:\n+\n+   while (loop_cond)\n+     {\n+       A;\n+       if (cond)\n+         branch1;\n+       else\n+\t branch2;\n+       B;\n+       if (cond)\n+         branch3;\n+       C;\n+     }\n+   where nothing inside the loop alters cond is transformed\n+   into\n+\n+   if (cond)\n+     {\n+       while (loop_cond)\n+\t {\n+\t   A;\n+\t   branch1;\n+\t   B;\n+\t   branch3;\n+\t   C;\n+\t }\n+     }\n+   else\n+     {\n+       while (loop_cond)\n+\t {\n+\t   A;\n+\t   branch2;\n+\t   B;\n+\t   C;\n+\t }\n+     }\n+\n+  Duplicating the loop might lead to code growth exponential in number of\n+  branches inside loop, so we limit the number of unswitchings performed\n+  in a single loop to PARAM_MAX_UNSWITCH_LEVEL.  We only perform the\n+  transformation on innermost loops, as the benefit of doing it on loops\n+  containing subloops would not be very large compared to complications\n+  with handling this case.  */\n+\n+static struct loop *unswitch_loop\tPARAMS ((struct loops *,\n+\t\t\t\t\t\tstruct loop *, basic_block));\n+static void unswitch_single_loop\tPARAMS ((struct loops *, struct loop *,\n+\t\t\t\t\t\trtx, int));\n+static bool may_unswitch_on_p\t\tPARAMS ((struct loops *, basic_block,\n+\t\t\t\t\t\tstruct loop *, basic_block *));\n+static rtx reversed_condition\t\tPARAMS ((rtx));\n+\n+/* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */\n+void\n+unswitch_loops (loops)\n+     struct loops *loops;\n+{\n+  int i, num;\n+  struct loop *loop;\n+\n+  /* Go through inner loops (only original ones).  */\n+  num = loops->num;\n+  \n+  for (i = 1; i < num; i++)\n+    {\n+      /* Removed loop?  */\n+      loop = loops->parray[i];\n+      if (!loop)\n+\tcontinue;\n+\n+      if (loop->inner)\n+\tcontinue;\n+\n+      unswitch_single_loop (loops, loop, NULL_RTX, 0);\n+#ifdef ENABLE_CHECKING\n+      verify_dominators (loops->cfg.dom);\n+      verify_loop_structure (loops);\n+#endif\n+    }\n+}\n+\n+/* Checks whether we can unswitch LOOP on condition at end of BB -- one of its\n+   basic blocks (for what it means see comments below).  List of basic blocks\n+   inside LOOP is provided in BODY to save time.  */\n+static bool\n+may_unswitch_on_p (loops, bb, loop, body)\n+     struct loops *loops;\n+     basic_block bb;\n+     struct loop *loop;\n+     basic_block *body;\n+{\n+  rtx test;\n+  unsigned i;\n+\n+  /* BB must end in a simple conditional jump.  */\n+  if (!bb->succ || !bb->succ->succ_next || bb->succ->succ_next->succ_next)\n+    return false;\n+  if (!any_condjump_p (bb->end))\n+    return false;\n+\n+  /* With branches inside loop.  */\n+  if (!flow_bb_inside_loop_p (loop, bb->succ->dest)\n+      || !flow_bb_inside_loop_p (loop, bb->succ->succ_next->dest))\n+    return false;\n+\n+  /* It must be executed just once each iteration (because otherwise we\n+     are unable to update dominator/irreducible loop information correctly).  */\n+  if (!just_once_each_iteration_p (loops, loop, bb))\n+    return false;\n+\n+  /* Condition must be invariant.  We use just a stupid test of invariantness\n+     of the condition: all used regs must not be modified inside loop body.  */\n+  test = get_condition (bb->end, NULL);\n+  if (!test)\n+    return false;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    if (modified_between_p (test, body[i]->head, NEXT_INSN (body[i]->end)))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Reverses CONDition; returns NULL if we cannot.  */\n+static rtx\n+reversed_condition (cond)\n+     rtx cond;\n+{\n+  enum rtx_code reversed;\n+  reversed = reversed_comparison_code (cond, NULL);\n+  if (reversed == UNKNOWN)\n+    return NULL_RTX;\n+  else\n+    return gen_rtx_fmt_ee (reversed,\n+\t\t\t   GET_MODE (cond), XEXP (cond, 0),\n+\t\t\t   XEXP (cond, 1));\n+}\n+\n+/* Unswitch single LOOP.  COND_CHECKED holds list of conditions we already\n+   unswitched on and are therefore known to be true in this LOOP.  NUM is\n+   number of unswitchings done; do not allow it to grow too much, it is too\n+   easy to create example on that the code would grow exponentially.  */\n+static void\n+unswitch_single_loop (loops, loop, cond_checked, num)\n+     struct loops *loops;\n+     struct loop *loop;\n+     rtx cond_checked;\n+     int num;\n+{\n+  basic_block *bbs, bb;\n+  struct loop *nloop;\n+  unsigned i;\n+  int true_first;\n+  rtx cond, rcond, conds, rconds, acond, split_before;\n+  int always_true;\n+  int always_false;\n+  int repeat;\n+  edge e;\n+\n+  /* Do not unswitch too much.  */\n+  if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unswitching anymore, hit max level\\n\");\n+      return;\n+    }\n+\n+  /* Only unswitch innermost loops.  */\n+  if (loop->inner)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unswitching, not innermost loop\\n\");\n+      return;\n+    }\n+  \n+  /* We must be able to duplicate loop body.  */\n+  if (!can_duplicate_loop_p (loop))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unswitching, can't duplicate loop\\n\");\n+      return;\n+    }\n+\n+  /* The loop should not be too large, to limit code growth.  */\n+  if (num_loop_insns (loop) > PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unswitching, loop too big\\n\");\n+      return;\n+    }\n+  \n+  /* Do not unswitch in cold areas.  */\n+  if (!maybe_hot_bb_p (loop->header))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unswitching, not hot area\\n\");\n+      return;\n+    }\n+  \n+  /* Nor if the loop usually does not roll.  */\n+  if (expected_loop_iterations (loop) < 1)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unswitching, loop iterations < 1\\n\");\n+      return;\n+    }\n+\n+  do\n+    {\n+      repeat = 0;\n+    \n+      /* Find a bb to unswitch on.  */\n+      bbs = get_loop_body (loop);\n+      for (i = 0; i < loop->num_nodes; i++)\n+\tif (may_unswitch_on_p (loops, bbs[i], loop, bbs))\n+\t  break;\n+\n+      if (i == loop->num_nodes)\n+\t{\n+\t  free (bbs);\n+\t  return;\n+\t}\n+\n+      if (!(cond = get_condition (bbs[i]->end, &split_before)))\n+\tabort ();\n+      rcond = reversed_condition (cond);\n+      \n+      /* Check whether the result can be predicted.  */\n+      always_true = 0;\n+      always_false = 0;\n+      for (acond = cond_checked; acond; acond = XEXP (acond, 1))\n+\t{\n+\t  if (rtx_equal_p (cond, XEXP (acond, 0)))\n+\t    {\n+\t      always_true = 1;\n+\t      break;\n+\t    }\n+\t  if (rtx_equal_p (rcond, XEXP (acond, 0)))\n+\t    {\n+\t      always_false = 1;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (always_true)\n+\t{\n+\t  /* Remove false path.  */\n+ \t  for (e = bbs[i]->succ; !(e->flags & EDGE_FALLTHRU); e = e->succ_next);\n+\t  remove_path (loops, e);\n+\t  free (bbs);\n+\t  repeat = 1;\n+\t}\n+      else if (always_false)\n+\t{\n+\t  /* Remove true path.  */\n+\t  for (e = bbs[i]->succ; e->flags & EDGE_FALLTHRU; e = e->succ_next);\n+\t  remove_path (loops, e);\n+\t  free (bbs);\n+\t  repeat = 1;\n+\t}\n+    } while (repeat);\n+ \n+  /* We found the condition we can unswitch on.  */\n+  conds = alloc_EXPR_LIST (0, cond, cond_checked);\n+  if (rcond)\n+    rconds = alloc_EXPR_LIST (0, rcond, cond_checked);\n+  else\n+    rconds = cond_checked;\n+\n+  /* Separate condition in a single basic block.  */\n+  bb = split_loop_bb (loops, bbs[i], PREV_INSN (split_before))->dest;\n+  free (bbs);\n+  true_first = !(bb->succ->flags & EDGE_FALLTHRU);\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Unswitching loop\\n\");\n+\n+  /* Unswitch the loop on this condition.  */\n+  nloop = unswitch_loop (loops, loop, bb);\n+  if (!nloop)\n+  abort ();\n+\n+  /* Invoke itself on modified loops.  */\n+  unswitch_single_loop (loops, nloop, true_first ? conds : rconds, num + 1);\n+  unswitch_single_loop (loops, loop, true_first ? rconds : conds, num + 1);\n+\n+  free_EXPR_LIST_node (conds);\n+  if (rcond)\n+    free_EXPR_LIST_node (rconds);\n+}\n+\n+/* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support\n+   unswitching of innermost loops.  UNSWITCH_ON must be executed in every\n+   iteration, i.e. it must dominate LOOP latch, and should only contain code\n+   for the condition we unswitch on.  Returns NULL if impossible, new\n+   loop otherwise.  */\n+static struct loop *\n+unswitch_loop (loops, loop, unswitch_on)\n+     struct loops *loops;\n+     struct loop *loop;\n+     basic_block unswitch_on;\n+{\n+  edge entry, e, latch_edge;\n+  basic_block switch_bb, unswitch_on_alt, src;\n+  struct loop *nloop;\n+  sbitmap zero_bitmap;\n+  int irred_flag;\n+\n+  /* Some sanity checking.  */\n+  if (!flow_bb_inside_loop_p (loop, unswitch_on))\n+    abort ();\n+  if (!unswitch_on->succ || !unswitch_on->succ->succ_next ||\n+      unswitch_on->succ->succ_next->succ_next)\n+    abort ();\n+  if (!just_once_each_iteration_p (loops, loop, unswitch_on))\n+    abort ();\n+  if (loop->inner)\n+    abort ();\n+  if (!flow_bb_inside_loop_p (loop, unswitch_on->succ->dest))\n+    abort ();\n+  if (!flow_bb_inside_loop_p (loop, unswitch_on->succ->succ_next->dest))\n+    abort ();\n+  \n+  /* Will we be able to perform redirection?  */\n+  if (!any_condjump_p (unswitch_on->end))\n+    return NULL;\n+  if (!cfg_layout_can_duplicate_bb_p (unswitch_on))\n+    return NULL;\n+\n+  entry = loop_preheader_edge (loop);\n+  \n+  /* Make a copy.  */\n+  src = entry->src;\n+  irred_flag = src->flags & BB_IRREDUCIBLE_LOOP;\n+  src->flags &= ~BB_IRREDUCIBLE_LOOP;\n+  zero_bitmap = sbitmap_alloc (2);\n+  sbitmap_zero (zero_bitmap);\n+  if (!duplicate_loop_to_header_edge (loop, entry, loops, 1,\n+\tzero_bitmap, NULL, NULL, NULL, 0))\n+    return NULL;\n+  free (zero_bitmap);\n+  src->flags |= irred_flag;\n+\n+  /* Record the block with condition we unswitch on.  */\n+  unswitch_on_alt = RBI (unswitch_on)->copy;\n+\n+  /* Make a copy of the block containing the condition; we will use\n+     it as switch to decide which loop we want to use.  */\n+  switch_bb = cfg_layout_duplicate_bb (unswitch_on, NULL);\n+  switch_bb->flags &= ~BB_IRREDUCIBLE_LOOP;\n+  switch_bb->flags |= irred_flag;\n+  add_to_dominance_info (loops->cfg.dom, switch_bb);\n+  RBI (unswitch_on)->copy = unswitch_on_alt;\n+\n+  /* Loopify from the copy of LOOP body, constructing the new loop.  */\n+  for (latch_edge = RBI (loop->latch)->copy->succ;\n+       latch_edge->dest != loop->header;\n+       latch_edge = latch_edge->succ_next);\n+  nloop = loopify (loops, latch_edge,\n+\t\t   RBI (loop->header)->copy->pred, switch_bb);\n+\n+  /* Remove branches that are now unreachable in new loops.  We rely on the\n+     fact that cfg_layout_duplicate_bb reverses list of edges.  */\n+  for (e = unswitch_on->succ->succ_next->dest->pred; e; e = e->pred_next)\n+    if (e->src != unswitch_on &&\n+\t!dominated_by_p (loops->cfg.dom, e->src, e->dest))\n+      break;\n+  remove_path (loops, unswitch_on->succ);\n+  remove_path (loops, unswitch_on_alt->succ);\n+\n+  /* One of created loops do not have to be subloop of the outer loop now,\n+     so fix its placement in loop datastructure.  */\n+  fix_loop_placement (loop);\n+  fix_loop_placement (nloop);\n+\n+  return nloop;\n+}"}, {"sha": "998b40d386b95eae01d27a948f733bf999b01bdc", "filename": "gcc/params.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -151,6 +151,17 @@ DEFPARAM(PARAM_MAX_UNROLLED_INSNS,\n \t \"The maximum number of instructions to consider to unroll in a loop\",\n \t 100)\n \n+/* The maximum number of insns of an unswitched loop.  */\n+DEFPARAM(PARAM_MAX_UNSWITCH_INSNS,\n+\t\"max-unswitch-insns\",\n+\t\"The maximum number of insns of an unswitched loop\",\n+\t50)\n+/* The maximum level of recursion in unswitch_single_loop.  */\n+DEFPARAM(PARAM_MAX_UNSWITCH_LEVEL,\n+\t\"max-unswitch-level\",\n+\t\"The maximum number of unswitchings in a single loop\",\n+\t3)\n+\n DEFPARAM(HOT_BB_COUNT_FRACTION,\n \t \"hot-bb-count-fraction\",\n \t \"Select fraction of the maximal count of repetitions of basic block in \\"}, {"sha": "840632a03158d377ab662d0b4ca5e3a5324e9a0e", "filename": "gcc/toplev.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617b465c7f1fa399d376f89a1b255fbb39e4e738/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=617b465c7f1fa399d376f89a1b255fbb39e4e738", "patch": "@@ -239,6 +239,7 @@ enum dump_file_index\n   DFI_bp,\n   DFI_ce1,\n   DFI_tracer,\n+  DFI_loop2,\n   DFI_cse2,\n   DFI_life,\n   DFI_combine,\n@@ -289,6 +290,7 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"bp\",\t'b', 1, 0, 0 },\n   { \"ce1\",\t'C', 1, 0, 0 },\n   { \"tracer\",\t'T', 1, 0, 0 },\n+  { \"loop2\",\t'L', 1, 0, 0 },\n   { \"cse2\",\t't', 1, 0, 0 },\n   { \"life\",\t'f', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n   { \"combine\",\t'c', 1, 0, 0 },\n@@ -519,6 +521,9 @@ int flag_unroll_loops;\n \n int flag_unroll_all_loops;\n \n+/* Nonzero enables loop unswitching.  */\n+int flag_unswitch_loops;\n+\n /* Nonzero enables prefetch optimizations for arrays in loops.  */\n \n int flag_prefetch_loop_arrays;\n@@ -997,6 +1002,8 @@ static const lang_independent_options f_options[] =\n    N_(\"Perform loop unrolling when iteration count is known\") },\n   {\"unroll-all-loops\", &flag_unroll_all_loops, 1,\n    N_(\"Perform loop unrolling for all loops\") },\n+  {\"unswitch-loops\", &flag_unswitch_loops, 1,\n+   N_(\"Perform loop unswitching\") },\n   {\"prefetch-loop-arrays\", &flag_prefetch_loop_arrays, 1,\n    N_(\"Generate prefetch instructions, if available, for arrays in loops\") },\n   {\"move-all-movables\", &flag_move_all_movables, 1,\n@@ -3057,6 +3064,38 @@ rest_of_compilation (decl)\n       timevar_pop (TV_TRACER);\n     }\n \n+  /* Perform loop optimalizations.  It might be better to do them a bit\n+     sooner, but we want the profile feedback to work more efficiently.  */\n+  if (optimize > 0\n+      && flag_unswitch_loops)\n+    {\n+      struct loops *loops;\n+      timevar_push (TV_LOOP);\n+      open_dump_file (DFI_loop2, decl);\n+      if (rtl_dump_file)\n+\tdump_flow_info (rtl_dump_file);\n+\n+      loops = loop_optimizer_init (rtl_dump_file);\n+\n+      if (loops)\n+\t{\n+\t  /* The optimalizations:  */\n+\t  if (flag_unswitch_loops)\n+\t    unswitch_loops (loops);\n+\n+\t  loop_optimizer_finalize (loops, rtl_dump_file);\n+\t}\n+\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n+      reg_scan (insns, max_reg_num (), 0);\n+      if (rtl_dump_file)\n+\tdump_flow_info (rtl_dump_file);\n+      close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n+      timevar_pop (TV_LOOP);\n+      ggc_collect ();\n+    }\n+\n   if (flag_rerun_cse_after_loop)\n     {\n       timevar_push (TV_CSE2);\n@@ -4884,6 +4923,7 @@ parse_options_and_default_flags (argc, argv)\n     {\n       flag_inline_functions = 1;\n       flag_rename_registers = 1;\n+      flag_unswitch_loops = 1;\n     }\n \n   if (optimize < 2 || optimize_size)"}]}