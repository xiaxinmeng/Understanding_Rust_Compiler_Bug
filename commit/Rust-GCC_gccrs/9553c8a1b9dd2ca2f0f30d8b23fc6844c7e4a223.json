{"sha": "9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU1M2M4YTFiOWRkMmNhMmYwZjMwZDhiMjNmYzY4NDRjN2U0YTIyMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-03T20:30:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-04T13:49:53Z"}, "message": "c++: Post-pending redesign cleanup [PR 99170]\n\nWith pending entities reimplemented, the remaining use of uintset can just\nuse a regular hash map -- I only used a uintset because it was there.\nSo one adhoc hash-table/vector structure goes away.\n\n\tPR c++/99170\n\tgcc/cp/\n\t* module.cc (class uintset): Delete.\n\t(typedef attached_map_t): A hash map.\n\t(attached_table): Use attached_map_t.  Adjust uses ...\n\t(trees_out::decl_value, trees_in::decl_value): ... here ...\n\t(trees_out::key_mergeable): ... here ...\n\t(trees_in::key_mergeable): ... here ...\n\t(maybe_attach_decl): ... here ...\n\t(direct_import): ... and here.", "tree": {"sha": "25ee084a21712d2373f0701d03718c305f111a21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25ee084a21712d2373f0701d03718c305f111a21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e52ef6e60d7a6d6f57b67415c73621ccc79d5440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52ef6e60d7a6d6f57b67415c73621ccc79d5440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e52ef6e60d7a6d6f57b67415c73621ccc79d5440"}], "stats": {"total": 207, "additions": 27, "deletions": 180}, "files": [{"sha": "31bbf9776dd6081c1a87896e6b9c2aad2cf47b40", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 27, "deletions": 180, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=9553c8a1b9dd2ca2f0f30d8b23fc6844c7e4a223", "patch": "@@ -2697,167 +2697,11 @@ pending_map_t *pending_table;\n    completed.  */\n vec<tree, va_heap, vl_embed> *post_load_decls;\n \n-/* Values keyed to some unsigned integer.  This is not GTY'd, so if\n-   T is tree they must be reachable via some other path.  */\n-\n-template<typename T>\n-class uintset {\n-public:\n-  unsigned key;  /* Entity index of the other entity.  */\n-\n-  /* Payload.  */\n-  unsigned allocp2 : 5;  /* log(2) allocated pending  */\n-  unsigned num : 27;    /* Number of pending.  */\n-\n-  /* Trailing array of values.   */\n-  T values[1];\n-\n-public:\n-  /* Even with ctors, we're very pod-like.  */\n-  uintset (unsigned uid)\n-    : key (uid), allocp2 (0), num (0)\n-  {\n-  }\n-  /* Copy constructor, which is exciting because of the trailing\n-     array.  */\n-  uintset (const uintset *from)\n-  {\n-    size_t size = (offsetof (uintset, values)\n-\t\t   + sizeof (uintset::values) * from->num);\n-    memmove (this, from, size);\n-    if (from->num)\n-      allocp2++;\n-  }\n-\n-public:\n-  struct traits : delete_ptr_hash<uintset> {\n-    typedef unsigned compare_type;\n-    typedef typename delete_ptr_hash<uintset>::value_type value_type;\n-\n-    /* Hash and equality for compare_type.  */\n-    inline static hashval_t hash (const compare_type k)\n-    {\n-      return hashval_t (k);\n-    }\n-    inline static hashval_t hash (const value_type v)\n-    {\n-      return hash (v->key);\n-    }\n-\n-    inline static bool equal (const value_type v, const compare_type k)\n-    {\n-      return v->key == k;\n-    }\n-  };\n-\n-public:\n-  class hash : public hash_table<traits> \n-  {\n-    typedef typename traits::compare_type key_t;\n-    typedef hash_table<traits> parent;\n-\n-  public:\n-    hash (size_t size)\n-      : parent (size)\n-    {\n-    }\n-    ~hash ()\n-    {\n-    }\n-\n-  private:\n-    uintset **find_slot (key_t key, insert_option insert)\n-    {\n-      return this->find_slot_with_hash (key, traits::hash (key), insert);\n-    }\n-\n-  public:\n-    uintset *get (key_t key, bool extract = false);\n-    bool add (key_t key, T value);\n-    uintset *create (key_t key, unsigned num, T init = 0);\n-  };\n-};\n-\n-/* Add VALUE to KEY's uintset, creating it if necessary.  Returns true\n-   if we created the uintset.  */\n-\n-template<typename T>\n-bool\n-uintset<T>::hash::add (typename uintset<T>::hash::key_t key, T value)\n-{\n-  uintset **slot = this->find_slot (key, INSERT);\n-  uintset *set = *slot;\n-  bool is_new = !set;\n-\n-  if (is_new || set->num == (1u << set->allocp2))\n-    {\n-      if (set)\n-\t{\n-\t  unsigned n = set->num * 2;\n-\t  size_t new_size = (offsetof (uintset, values)\n-\t\t\t     + sizeof (uintset (0u).values) * n);\n-\t  uintset *new_set = new (::operator new (new_size)) uintset (set);\n-\t  delete set;\n-\t  set = new_set;\n-\t}\n-      else\n-\tset = new (::operator new (sizeof (*set))) uintset (key);\n-      *slot = set;\n-    }\n-\n-  set->values[set->num++] = value;\n-\n-  return is_new;\n-}\n-\n-template<typename T>\n-uintset<T> *\n-uintset<T>::hash::create (typename uintset<T>::hash::key_t key, unsigned num,\n-\t\t\t  T init)\n-{\n-  unsigned p2alloc = 0;\n-  for (unsigned v = num; v != 1; v = (v >> 1) | (v & 1))\n-    p2alloc++;\n-\n-  size_t new_size = (offsetof (uintset, values)\n-\t\t     + (sizeof (uintset (0u).values) << p2alloc));\n-  uintset *set = new (::operator new (new_size)) uintset (key);\n-  set->allocp2 = p2alloc;\n-  set->num = num;\n-  while (num--)\n-    set->values[num] = init;\n-\n-  uintset **slot = this->find_slot (key, INSERT);\n-  gcc_checking_assert (!*slot);\n-  *slot = set;\n-\n-  return set;\n-}\n-\n-/* Locate KEY's uintset, potentially removing it from the hash table  */\n-\n-template<typename T>\n-uintset<T> *\n-uintset<T>::hash::get (typename uintset<T>::hash::key_t key, bool extract)\n-{\n-  uintset *res = NULL;\n-\n-  if (uintset **slot = this->find_slot (key, NO_INSERT))\n-    {\n-      res = *slot;\n-      if (extract)\n-\t/* We need to remove the pendset without deleting it. */\n-\ttraits::mark_deleted (*slot);\n-    }\n-\n-  return res;\n-}\n-\n /* Some entities are attached to another entitity for ODR purposes.\n    For example, at namespace scope, 'inline auto var = []{};', that\n    lambda is attached to 'var', and follows its ODRness.  */\n-typedef uintset<tree> attachset;\n-static attachset::hash *attached_table;\n+typedef hash_map<tree, auto_vec<tree>> attached_map_t;\n+static attached_map_t *attached_table;\n \n /********************************************************************/\n /* Tree streaming.   The tree streaming is very specific to the tree\n@@ -7865,13 +7709,13 @@ trees_out::decl_value (tree decl, depset *dep)\n       && !is_key_order ())\n     {\n       /* Stream the attached entities.  */\n-      attachset *set = attached_table->get (DECL_UID (inner));\n-      unsigned num = set->num;\n+      auto *attach_vec = attached_table->get (inner);\n+      unsigned num = attach_vec->length ();\n       if (streaming_p ())\n \tu (num);\n       for (unsigned ix = 0; ix != num; ix++)\n \t{\n-\t  tree attached = set->values[ix];\n+\t  tree attached = (*attach_vec)[ix];\n \t  tree_node (attached);\n \t  if (streaming_p ())\n \t    dump (dumper::MERGE)\n@@ -8169,22 +8013,23 @@ trees_in::decl_value ()\n       && DECL_MODULE_ATTACHMENTS_P (inner))\n     {\n       /* Read and maybe install the attached entities.  */\n-      attachset *set\n-\t= attached_table->get (DECL_UID (STRIP_TEMPLATE (existing)));\n+      bool existed;\n+      auto &set = attached_table->get_or_insert (STRIP_TEMPLATE (existing),\n+\t\t\t\t\t\t &existed);\n       unsigned num = u ();\n-      if (!is_new == !set)\n+      if (is_new == existed)\n \tset_overrun ();\n       if (is_new)\n-\tset = attached_table->create (DECL_UID (inner), num, NULL_TREE);\n+\tset.reserve (num);\n       for (unsigned ix = 0; !get_overrun () && ix != num; ix++)\n \t{\n \t  tree attached = tree_node ();\n \t  dump (dumper::MERGE)\n \t    && dump (\"Read %d[%u] %s attached decl %N\", tag, ix,\n \t\t     is_new ? \"new\" : \"matched\", attached);\n \t  if (is_new)\n-\t    set->values[ix] = attached;\n-\t  else if (set->values[ix] != attached)\n+\t    set.quick_push (attached);\n+\t  else if (set[ix] != attached)\n \t    set_overrun ();\n \t}\n     }\n@@ -10650,12 +10495,12 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t    tree scope = LAMBDA_EXPR_EXTRA_SCOPE (CLASSTYPE_LAMBDA_EXPR\n \t\t\t\t\t\t  (TREE_TYPE (inner)));\n \t    gcc_checking_assert (TREE_CODE (scope) == VAR_DECL);\n-\t    attachset *root = attached_table->get (DECL_UID (scope));\n-\t    unsigned ix = root->num;\n+\t    auto *root = attached_table->get (scope);\n+\t    unsigned ix = root->length ();\n \t    /* If we don't find it, we'll write a really big number\n \t       that the reader will ignore.  */\n \t    while (ix--)\n-\t      if (root->values[ix] == inner)\n+\t      if ((*root)[ix] == inner)\n \t\tbreak;\n \n \t    /* Use the attached-to decl as the 'name'.  */\n@@ -10951,10 +10796,10 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t\tif (DECL_LANG_SPECIFIC (name)\n \t\t    && VAR_OR_FUNCTION_DECL_P (name)\n \t\t    && DECL_MODULE_ATTACHMENTS_P (name))\n-\t\t  if (attachset *set = attached_table->get (DECL_UID (name)))\n-\t\t    if (key.index < set->num)\n+\t\t  if (auto *set = attached_table->get (name))\n+\t\t    if (key.index < set->length ())\n \t\t      {\n-\t\t\texisting = set->values[key.index];\n+\t\t\texisting = (*set)[key.index];\n \t\t\tif (existing)\n \t\t\t  {\n \t\t\t    gcc_checking_assert\n@@ -18736,13 +18581,15 @@ maybe_attach_decl (tree ctx, tree decl)\n   gcc_checking_assert (DECL_NAMESPACE_SCOPE_P (ctx));\n \n  if (!attached_table)\n-    attached_table = new attachset::hash (EXPERIMENT (1, 400));\n+    attached_table = new attached_map_t (EXPERIMENT (1, 400));\n \n-  if (attached_table->add (DECL_UID (ctx), decl))\n-    {\n-      retrofit_lang_decl (ctx);\n-      DECL_MODULE_ATTACHMENTS_P (ctx) = true;\n-    }\n+ auto &vec = attached_table->get_or_insert (ctx);\n+ if (!vec.length ())\n+   {\n+     retrofit_lang_decl (ctx);\n+     DECL_MODULE_ATTACHMENTS_P (ctx) = true;\n+   }\n+ vec.safe_push (decl);\n }\n \n /* Create the flat name string.  It is simplest to have it handy.  */\n@@ -19051,7 +18898,7 @@ direct_import (module_state *import, cpp_reader *reader)\n   if (import->loadedness < ML_LANGUAGE)\n     {\n       if (!attached_table)\n-\tattached_table = new attachset::hash (EXPERIMENT (1, 400));\n+\tattached_table = new attached_map_t (EXPERIMENT (1, 400));\n       import->read_language (true);\n     }\n "}]}