{"sha": "9686dbc79e2904ce4047003d78e30c7056321151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY4NmRiYzc5ZTI5MDRjZTQwNDcwMDNkNzhlMzBjNzA1NjMyMTE1MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:03:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:03:19Z"}, "message": "[multiple changes]\n\n2013-04-12  Robert Dewar  <dewar@adacore.com>\n\n\t* sem.ads, opt.ads: Minor comment edits.\n\t* sem_warn.adb, sem_ch6.adb: Minor reformatting.\n\n2013-04-12  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb a-cfdlli.ads (List, Not_No_Element, Iterate,\n\tReverse_Iterate, Query_Element, Update_Element, Read, Write): Removed,\n\tnot suitable for formal analysis.\n\n2013-04-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Abstract_State): Use Defining entity\n\tto locate package entity, which may be a child unit.\n\n2013-04-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.adb, g-socket.ads (Connect_Socket, version with timeout): If\n\tthe specified timeout is 0, do not attempt to determine whether the\n\tconnection succeeded.\n\n2013-04-12  Doug Rupp  <rupp@adacore.com>\n\n\t* s-fileio.adb (Form_RMS Context_Key): Fix some thinkos.\n\nFrom-SVN: r197904", "tree": {"sha": "b152f6a9f24a5fee00b80c213619b2bd6c89f774", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b152f6a9f24a5fee00b80c213619b2bd6c89f774"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9686dbc79e2904ce4047003d78e30c7056321151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9686dbc79e2904ce4047003d78e30c7056321151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9686dbc79e2904ce4047003d78e30c7056321151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9686dbc79e2904ce4047003d78e30c7056321151/comments", "author": null, "committer": null, "parents": [{"sha": "7a1f094d68561273f94f0934f5fad6c283375b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1f094d68561273f94f0934f5fad6c283375b3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1f094d68561273f94f0934f5fad6c283375b3d"}], "stats": {"total": 675, "additions": 70, "deletions": 605}, "files": [{"sha": "197627802eac760ee8e40f294d6d426bfbab5e70", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -1,3 +1,29 @@\n+2013-04-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem.ads, opt.ads: Minor comment edits.\n+\t* sem_warn.adb, sem_ch6.adb: Minor reformatting.\n+\n+2013-04-12  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb a-cfdlli.ads (List, Not_No_Element, Iterate,\n+\tReverse_Iterate, Query_Element, Update_Element, Read, Write): Removed,\n+\tnot suitable for formal analysis.\n+\n+2013-04-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Abstract_State): Use Defining entity\n+\tto locate package entity, which may be a child unit.\n+\n+2013-04-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.adb, g-socket.ads (Connect_Socket, version with timeout): If\n+\tthe specified timeout is 0, do not attempt to determine whether the\n+\tconnection succeeded.\n+\n+2013-04-12  Doug Rupp  <rupp@adacore.com>\n+\n+\t* s-fileio.adb (Form_RMS Context_Key): Fix some thinkos.\n+\n 2013-04-12  Doug Rupp  <rupp@adacore.com>\n \n \t* s-fileio.adb: Minor reformatting."}, {"sha": "34668bdd2d513c92e9b5dbdd02e49a890d0a2c15", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 0, "deletions": 473, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -176,8 +176,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if Container.Length = 0 then\n          pragma Assert (Container.First = 0);\n          pragma Assert (Container.Last = 0);\n-         pragma Assert (Container.Busy = 0);\n-         pragma Assert (Container.Lock = 0);\n          return;\n       end if;\n \n@@ -186,11 +184,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       pragma Assert (N (Container.First).Prev = 0);\n       pragma Assert (N (Container.Last).Next = 0);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       while Container.Length > 1 loop\n          X := Container.First;\n \n@@ -297,11 +290,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       for Index in 1 .. Count loop\n          pragma Assert (Container.Length >= 2);\n \n@@ -350,11 +338,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       for J in 1 .. Count loop\n          X := Container.First;\n          pragma Assert (N (N (X).Next).Prev = Container.First);\n@@ -389,11 +372,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       for J in 1 .. Count loop\n          X := Container.Last;\n          pragma Assert (N (N (X).Prev).Next = Container.Last);\n@@ -424,21 +402,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return Container.Nodes (Position.Node).Element;\n    end Element;\n \n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (Object : in out Iterator) is\n-   begin\n-      if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n    ----------\n    -- Find --\n    ----------\n@@ -490,28 +453,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.First);\n    end First;\n \n-   function First (Object : Iterator) return Cursor is\n-   begin\n-      --  The value of the iterator object's Node component influences the\n-      --  behavior of the First (and Last) selector function.\n-\n-      --  When the Node component is null, this means the iterator object was\n-      --  constructed without a start expression, in which case the (forward)\n-      --  iteration starts from the (logical) beginning of the entire sequence\n-      --  of items (corresponding to Container.First, for a forward iterator).\n-\n-      --  Otherwise, this is iteration over a partial sequence of items. When\n-      --  the Node component is non-null, the iterator object was constructed\n-      --  with a start expression, that specifies the position from which the\n-      --  (forward) partial iteration begins.\n-\n-      if Object.Node = 0 then\n-         return First (Object.Container.all);\n-      else\n-         return (Node => Object.Node);\n-      end if;\n-   end First;\n-\n    -------------------\n    -- First_Element --\n    -------------------\n@@ -613,16 +554,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n             return;\n          end if;\n \n-         if Target.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Target (list is busy)\";\n-         end if;\n-\n-         if Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Source (list is busy)\";\n-         end if;\n-\n          LI := First (Target);\n          RI := First (Source);\n          while RI.Node /= 0 loop\n@@ -739,11 +670,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          pragma Assert (N (Container.First).Prev = 0);\n          pragma Assert (N (Container.Last).Next = 0);\n \n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (list is busy)\";\n-         end if;\n-\n          Sort (Front => 0, Back => 0);\n \n          pragma Assert (N (Container.First).Prev = 0);\n@@ -792,11 +718,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds capacity\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       Allocate (Container, New_Item, New_Node => J);\n       Insert_Internal (Container, Before.Node, New_Node => J);\n       Position := (Node => J);\n@@ -840,11 +761,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds capacity\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       Allocate (Container, New_Node => J);\n       Insert_Internal (Container, Before.Node, New_Node => J);\n       Position := (Node => J);\n@@ -919,103 +835,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return Length (Container) = 0;\n    end Is_Empty;\n \n-   -------------\n-   -- Iterate --\n-   -------------\n-\n-   procedure Iterate\n-     (Container : List;\n-      Process   :\n-      not null access procedure (Container : List; Position : Cursor))\n-   is\n-      C    : List renames Container'Unrestricted_Access.all;\n-      B    : Natural renames C.Busy;\n-      Node : Count_Type;\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Node := Container.First;\n-         while Node /= 0 loop\n-            Process (Container, (Node => Node));\n-            Node := Container.Nodes (Node).Next;\n-         end loop;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Iterate;\n-\n-   function Iterate (Container : List)\n-     return List_Iterator_Interfaces.Reversible_Iterator'Class\n-   is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n-   begin\n-      --  The value of the Node component influences the behavior of the First\n-      --  and Last selector functions of the iterator object. When the Node\n-      --  component is null (as is the case here), this means the iterator\n-      --  object was constructed without a start expression. This is a\n-      --  complete iterator, meaning that the iteration starts from the\n-      --  (logical) beginning of the sequence of items.\n-\n-      --  Note: For a forward iterator, Container.First is the beginning, and\n-      --  for a reverse iterator, Container.Last is the beginning.\n-\n-      return It : constant Iterator :=\n-        Iterator'(Ada.Finalization.Limited_Controlled with\n-                    Container => Container'Unrestricted_Access,\n-                    Node      => 0)\n-      do\n-         B := B + 1;\n-      end return;\n-   end Iterate;\n-\n-   function Iterate (Container : List; Start : Cursor)\n-     return List_Iterator_Interfaces.Reversible_Iterator'Class\n-   is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n-   begin\n-      --  It was formerly the case that when Start = No_Element, the partial\n-      --  iterator was defined to behave the same as for a complete iterator,\n-      --  and iterate over the entire sequence of items. However, those\n-      --  semantics were unintuitive and arguably error-prone (it is too easy\n-      --  to accidentally create an endless loop), and so they were changed,\n-      --  per the ARG meeting in Denver on 2011/11. However, there was no\n-      --  consensus about what positive meaning this corner case should have,\n-      --  and so it was decided to simply raise an exception. This does imply,\n-      --  however, that it is not possible to use a partial iterator to specify\n-      --  an empty sequence of items.\n-\n-      if not Has_Element (Container, Start) then\n-         raise Constraint_Error with\n-           \"Start position for iterator is not a valid cursor\";\n-      end if;\n-\n-      --  The value of the Node component influences the behavior of the First\n-      --  and Last selector functions of the iterator object. When the Node\n-      --  component is non-null (as is the case here), it means that this\n-      --  is a partial iteration, over a subset of the complete sequence of\n-      --  items. The iterator object was constructed with a start expression,\n-      --  indicating the position from which the iteration begins. Note that\n-      --  the start position has the same value irrespective of whether this\n-      --  is a forward or reverse iteration.\n-\n-      return It : constant Iterator :=\n-        Iterator'(Ada.Finalization.Limited_Controlled with\n-                    Container => Container'Unrestricted_Access,\n-                    Node      => Start.Node)\n-      do\n-         B := B + 1;\n-      end return;\n-   end Iterate;\n-\n    ----------\n    -- Last --\n    ----------\n@@ -1028,28 +847,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.Last);\n    end Last;\n \n-   function Last (Object : Iterator) return Cursor is\n-   begin\n-      --  The value of the iterator object's Node component influences the\n-      --  behavior of the Last (and First) selector function.\n-\n-      --  When the Node component is null, this means the iterator object was\n-      --  constructed without a start expression, in which case the (reverse)\n-      --  iteration starts from the (logical) beginning of the entire sequence\n-      --  (corresponding to Container.Last, for a reverse iterator).\n-\n-      --  Otherwise, this is iteration over a partial sequence of items. When\n-      --  the Node component is non-null, the iterator object was constructed\n-      --  with a start expression, that specifies the position from which the\n-      --  (reverse) partial iteration begins.\n-\n-      if Object.Node = 0 then\n-         return Last (Object.Container.all);\n-      else\n-         return (Node => Object.Node);\n-      end if;\n-   end Last;\n-\n    ------------------\n    -- Last_Element --\n    ------------------\n@@ -1121,11 +918,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n-\n       Clear (Target);\n \n       while Source.Length > 1 loop\n@@ -1208,23 +1000,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.Nodes (Position.Node).Next);\n    end Next;\n \n-   function Next\n-     (Object   : Iterator;\n-      Position : Cursor) return Cursor\n-   is\n-   begin\n-      return Next (Object.Container.all, Position);\n-   end Next;\n-\n-   --------------------\n-   -- Not_No_Element --\n-   --------------------\n-\n-   function Not_No_Element (Position : Cursor) return Boolean is\n-   begin\n-      return Position /= No_Element;\n-   end Not_No_Element;\n-\n    -------------\n    -- Prepend --\n    -------------\n@@ -1260,106 +1035,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.Nodes (Position.Node).Prev);\n    end Previous;\n \n-   function Previous\n-     (Object   : Iterator;\n-      Position : Cursor) return Cursor\n-   is\n-   begin\n-      return Previous (Object.Container.all, Position);\n-   end Previous;\n-\n-   -------------------\n-   -- Query_Element --\n-   -------------------\n-\n-   procedure Query_Element\n-     (Container : List; Position : Cursor;\n-      Process   : not null access procedure (Element : Element_Type))\n-   is\n-      C : List renames Container'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-      L : Natural renames C.Lock;\n-\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n-      end if;\n-\n-      B := B + 1;\n-      L := L + 1;\n-\n-      declare\n-         N : Node_Type renames C.Nodes (Position.Node);\n-      begin\n-         Process (N.Element);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n-   end Query_Element;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out List)\n-   is\n-      N : Count_Type'Base;\n-\n-   begin\n-      Clear (Item);\n-\n-      Count_Type'Base'Read (Stream, N);\n-\n-      if N < 0 then\n-         raise Program_Error with \"bad list length\";\n-      end if;\n-\n-      if N = 0 then\n-         return;\n-      end if;\n-\n-      if N > Item.Capacity then\n-         raise Constraint_Error with \"length exceeds capacity\";\n-      end if;\n-\n-      for J in 1 .. N loop\n-         Item.Append (Element_Type'Input (Stream));  -- ???\n-      end loop;\n-   end Read;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream list cursor\";\n-   end Read;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Constant_Reference\n-     (Container : List;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Element => Container.Nodes (Position.Node).Element'Access);\n-   end Constant_Reference;\n-\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -1374,11 +1049,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is locked)\";\n-      end if;\n-\n       pragma Assert\n         (Vet (Container, Position), \"bad cursor in Replace_Element\");\n \n@@ -1444,11 +1114,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       pragma Assert (N (Container.First).Prev = 0);\n       pragma Assert (N (Container.Last).Next = 0);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       Container.First := J;\n       Container.Last := I;\n       loop\n@@ -1503,39 +1168,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return No_Element;\n    end Reverse_Find;\n \n-   ---------------------\n-   -- Reverse_Iterate --\n-   ---------------------\n-\n-   procedure Reverse_Iterate\n-     (Container : List;\n-      Process   :\n-      not null access procedure (Container : List; Position : Cursor))\n-   is\n-      C : List renames Container'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-\n-      Node : Count_Type;\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Node := Container.Last;\n-         while Node /= 0 loop\n-            Process (Container, (Node => Node));\n-            Node := Container.Nodes (Node).Prev;\n-         end loop;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Reverse_Iterate;\n-\n    -----------\n    -- Right --\n    -----------\n@@ -1597,16 +1229,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n-\n       loop\n          Insert (Target, Before, SN (Source.Last).Element);\n          Delete_Last (Source);\n@@ -1638,16 +1260,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n-\n       Insert\n         (Container => Target,\n          Before    => Before,\n@@ -1686,11 +1298,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n       pragma Assert (Container.Length >= 2);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       if Before.Node = 0 then\n          pragma Assert (Position.Node /= Container.Last);\n \n@@ -1800,11 +1407,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is locked)\";\n-      end if;\n-\n       pragma Assert (Vet (Container, I), \"bad I cursor in Swap\");\n       pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n \n@@ -1844,11 +1446,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is busy)\";\n-      end if;\n-\n       pragma Assert (Vet (Container, I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (Container, J), \"bad J cursor in Swap_Links\");\n \n@@ -1871,47 +1468,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       end if;\n    end Swap_Links;\n \n-   --------------------\n-   -- Update_Element --\n-   --------------------\n-\n-   procedure Update_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : in out Element_Type))\n-   is\n-   begin\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Update_Element\");\n-\n-      declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n-         begin\n-            Process (N.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n-      end;\n-   end Update_Element;\n-\n    ---------\n    -- Vet --\n    ---------\n@@ -2047,33 +1603,4 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return True;\n    end Vet;\n \n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : List)\n-   is\n-      N    : Node_Array renames Item.Nodes;\n-      Node : Count_Type;\n-\n-   begin\n-      Count_Type'Base'Write (Stream, Item.Length);\n-\n-      Node := Item.First;\n-      while Node /= 0 loop\n-         Element_Type'Write (Stream, N (Node).Element);\n-         Node := N (Node).Next;\n-      end loop;\n-   end Write;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream list cursor\";\n-   end Write;\n-\n end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "994589fec5fed277959cf8b7de76b977c9c89d37", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 6, "deletions": 104, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -51,9 +51,9 @@\n \n --    See detailed specifications for these subprograms\n \n-private with Ada.Streams;\n-private with Ada.Finalization;\n-with Ada.Iterator_Interfaces;\n+--  private with Ada.Streams;\n+--  private with Ada.Finalization;\n+--  with Ada.Iterator_Interfaces;\n \n generic\n    type Element_Type is private;\n@@ -64,11 +64,8 @@ generic\n package Ada.Containers.Formal_Doubly_Linked_Lists is\n    pragma Pure;\n \n-   type List (Capacity : Count_Type) is tagged private with\n-      Constant_Indexing => Constant_Reference,\n-      Default_Iterator  => Iterate,\n-      Iterator_Element  => Element_Type;\n-   --  pragma Preelaborable_Initialization (List);\n+   type List (Capacity : Count_Type) is private;\n+   pragma Preelaborable_Initialization (List);\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n@@ -77,17 +74,6 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    No_Element : constant Cursor;\n \n-   function Not_No_Element (Position : Cursor) return Boolean;\n-\n-   package List_Iterator_Interfaces is new\n-     Ada.Iterator_Interfaces (Cursor => Cursor, Has_Element => Not_No_Element);\n-\n-   function Iterate (Container : List; Start : Cursor)\n-      return List_Iterator_Interfaces.Reversible_Iterator'Class;\n-\n-   function Iterate (Container : List)\n-      return List_Iterator_Interfaces.Reversible_Iterator'Class;\n-\n    function \"=\" (Left, Right : List) return Boolean;\n \n    function Length (Container : List) return Count_Type;\n@@ -107,15 +93,6 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n       Position  : Cursor;\n       New_Item  : Element_Type);\n \n-   procedure Query_Element\n-     (Container : List; Position : Cursor;\n-      Process   : not null access procedure (Element : Element_Type));\n-\n-   procedure Update_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : in out Element_Type));\n-\n    procedure Move (Target : in out List; Source : in out List);\n \n    procedure Insert\n@@ -218,16 +195,6 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    function Has_Element (Container : List; Position : Cursor) return Boolean;\n \n-   procedure Iterate\n-     (Container : List;\n-      Process   :\n-      not null access procedure (Container : List; Position : Cursor));\n-\n-   procedure Reverse_Iterate\n-     (Container : List;\n-      Process   :\n-      not null access procedure (Container : List; Position : Cursor));\n-\n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is\n@@ -240,15 +207,6 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    end Generic_Sorting;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   function Constant_Reference\n-     (Container : List;      --  SHOULD BE ALIASED ???\n-      Position  : Cursor)   return Constant_Reference_Type;\n-\n    function Strict_Equal (Left, Right : List) return Boolean;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n@@ -268,7 +226,7 @@ private\n    type Node_Type is record\n       Prev    : Count_Type'Base := -1;\n       Next    : Count_Type;\n-      Element : aliased Element_Type;\n+      Element : Element_Type;\n    end record;\n \n    function \"=\" (L, R : Node_Type) return Boolean is abstract;\n@@ -279,73 +237,17 @@ private\n    type List (Capacity : Count_Type) is tagged record\n       Nodes  : Node_Array (1 .. Capacity) := (others => <>);\n       Free   : Count_Type'Base := -1;\n-      Busy   : Natural := 0;\n-      Lock   : Natural := 0;\n       Length : Count_Type := 0;\n       First  : Count_Type := 0;\n       Last   : Count_Type := 0;\n    end record;\n \n-   use Ada.Streams;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out List);\n-\n-   for List'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : List);\n-\n-   for List'Write use Write;\n-\n-   type List_Access is access all List;\n-   for List_Access'Storage_Size use 0;\n-\n    type Cursor is record\n       Node : Count_Type := 0;\n    end record;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is null record;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor);\n-\n-   for Cursor'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor);\n-\n-   for Cursor'Write use Write;\n-\n    Empty_List : constant List := (0, others => <>);\n \n    No_Element : constant Cursor := (Node => 0);\n \n-   use Ada.Finalization;\n-\n-   type Iterator is new Limited_Controlled and\n-     List_Iterator_Interfaces.Reversible_Iterator with\n-   record\n-      Container : List_Access;\n-      Node      : Count_Type;\n-   end record;\n-\n-   overriding procedure Finalize (Object : in out Iterator);\n-\n-   overriding function First (Object : Iterator) return Cursor;\n-   overriding function Last  (Object : Iterator) return Cursor;\n-\n-   overriding function Next\n-     (Object   : Iterator;\n-      Position : Cursor) return Cursor;\n-\n-   overriding function Previous\n-     (Object   : Iterator;\n-      Position : Cursor) return Cursor;\n-\n end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "8079e80b0bd5e89cd4a46ebeedb580b76c6550a8", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -516,10 +516,6 @@ package body GNAT.Sockets is\n         (Selector, R_Socket_Set, W_Socket_Set, E_Socket_Set, Status, Timeout);\n    end Check_Selector;\n \n-   --------------------\n-   -- Check_Selector --\n-   --------------------\n-\n    procedure Check_Selector\n      (Selector     : Selector_Type;\n       R_Socket_Set : in out Socket_Set_Type;\n@@ -739,12 +735,17 @@ package body GNAT.Sockets is\n \n       --  Wait for socket to become available for writing\n \n-      Wait_On_Socket\n-        (Socket   => Socket,\n-         For_Read => False,\n-         Timeout  => Timeout,\n-         Selector => Selector,\n-         Status   => Status);\n+      if Timeout = 0.0 then\n+         Status := Expired;\n+\n+      else\n+         Wait_On_Socket\n+           (Socket   => Socket,\n+            For_Read => False,\n+            Timeout  => Timeout,\n+            Selector => Selector,\n+            Status   => Status);\n+      end if;\n \n       --  Check error condition (the asynchronous connect may have terminated\n       --  with an error, e.g. ECONNREFUSED) if select(2) completed."}, {"sha": "4761f3a4ab5df7ff01e95439d5d80a8f204d279c", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2011, AdaCore                     --\n+--                     Copyright (C) 2001-2013, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -858,7 +858,9 @@ package GNAT.Sockets is\n    --  whether the operation completed successfully, timed out, or was aborted.\n    --  If Selector is not null, the designated selector is used to wait for the\n    --  socket to become available, else a private selector object is created\n-   --  by this procedure and destroyed before it returns.\n+   --  by this procedure and destroyed before it returns. If Timeout is 0.0,\n+   --  no attempt is made to detect whether the connection has succeeded; it\n+   --  is up to the user to determine this using Check_Selector later on.\n \n    procedure Control_Socket\n      (Socket  : Socket_Type;"}, {"sha": "efa9b4f07121a02716e2bcfd05d5fa2249b973a0", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -597,7 +597,7 @@ package Opt is\n    Fast_Math : Boolean := False;\n    --  GNAT\n    --  Indicates the current setting of Fast_Math mode, as set by the use\n-   --  of a Fast_Math pragma (set on by Fast_Math (On)).\n+   --  of a Fast_Math pragma (set True by Fast_Math (On)).\n \n    Float_Format : Character := ' ';\n    --  GNAT\n@@ -1274,8 +1274,8 @@ package Opt is\n    --  GNAT\n    --  Set True if Style_Check was set for the main unit. This is used to\n    --  renable style checks for units in the mail extended source that get\n-   --  with'ed indirectly. It is set on by use of either the -gnatg or -gnaty\n-   --  switches, but not by use of the Style_Checks pragma.\n+   --  with'ed indirectly. It is set True by use of either the -gnatg or\n+   --  -gnaty switches, but not by use of the Style_Checks pragma.\n \n    Suppress_All_Inlining : Boolean := False;\n    --  GNAT\n@@ -1411,7 +1411,7 @@ package Opt is\n    --  Flag set to force attempt at semantic analysis, even if parser errors\n    --  occur. This will probably cause blowups at this stage in the game. On\n    --  the other hand, most such blowups will be caught cleanly and simply\n-   --  say compilation abandoned. This flag is set on by -gnatq or -gnatQ.\n+   --  say compilation abandoned. This flag is set True by -gnatq or -gnatQ.\n \n    Unchecked_Shared_Lib_Imports : Boolean := False;\n    --  GPRBUILD"}, {"sha": "32f0c90e101b036c98a748bfb92c046d5d6c963f", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -696,12 +696,14 @@ package body System.File_IO is\n                   Klen := KImage'Length;\n                   To_Lower (KImage);\n \n-                  if Form (Index .. Index + Klen - 1) = KImage then\n+                  if Index + Klen - 1 <= Form'Last and then\n+                    Form (Index .. Index + Klen - 1) = KImage\n+                  then\n                      case Parm is\n                         when Force_Record_Mode =>\n                            VMS_Form (Pos) := '\"';\n                            Pos := Pos + 1;\n-                           VMS_Form (Pos .. Pos + 7) := \"ctx=rec\";\n+                           VMS_Form (Pos .. Pos + 6) := \"ctx=rec\";\n                            Pos := Pos + 7;\n                            VMS_Form (Pos) := '\"';\n                            Pos := Pos + 1;\n@@ -711,7 +713,7 @@ package body System.File_IO is\n                         when Force_Stream_Mode =>\n                            VMS_Form (Pos) := '\"';\n                            Pos := Pos + 1;\n-                           VMS_Form (Pos .. Pos + 7) := \"ctx=stm\";\n+                           VMS_Form (Pos .. Pos + 6) := \"ctx=stm\";\n                            Pos := Pos + 7;\n                            VMS_Form (Pos) := '\"';\n                            Pos := Pos + 1;"}, {"sha": "545aadc6a53dcddca09e8fa28f297742cc495d82", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -429,11 +429,11 @@ package Sem is\n    --  compilation unit. These sections are separated by distinct occurrences\n    --  of package Standard. The currently active section of the scope stack\n    --  goes from the current scope to the first (innermost) occurrence of\n-   --  Standard, which is additionally marked with the flag\n-   --  Is_Active_Stack_Base. The basic visibility routine (Find_Direct_Name, in\n-   --  Sem_Ch8) uses this contiguous section of the scope stack to determine\n-   --  whether a given entity is or is not visible at a point. In_Open_Scopes\n-   --  only examines the currently active section of the scope stack.\n+   --  Standard, which is additionally marked with flag Is_Active_Stack_Base.\n+   --  The basic visibility routine (Find_Direct_Name, in Sem_Ch8) uses this\n+   --  contiguous section of the scope stack to determine whether a given\n+   --  entity is or is not visible at a point. In_Open_Scopes only examines\n+   --  the currently active section of the scope stack.\n \n    --  Similar complications arise when processing child instances. These\n    --  must be compiled in the context of parent instances, and therefore the\n@@ -464,7 +464,12 @@ package Sem is\n       --  Save contents of Local_Suppress_Stack on entry to restore on exit\n \n       Save_Check_Policy_List : Node_Id;\n-      --  Save contents of Check_Policy_List on entry to restore on exit\n+      --  Save contents of Check_Policy_List on entry to restore on exit. The\n+      --  Check_Policy pragmas are chained with Check_Policy_List pointing to\n+      --  the most recent entry. This list is searched starting here, so that\n+      --  the search finds the most recent appicable entry. When we restore\n+      --  Check_Policy_List on exit from the scope, the effect is to remove\n+      --  all entries set in the scope being exited.\n \n       Save_Default_Storage_Pool : Node_Id;\n       --  Save contents of Default_Storage_Pool on entry to restore on exit"}, {"sha": "e57d95fcbeb74619e1d3d345a6d5798461c15f64", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -12242,7 +12242,7 @@ package body Sem_Ch6 is\n          while Present (Prag) loop\n             if Nkind (Prag) = N_Pragma then\n \n-               --  If pragma, capture if enabled postcondition, else ignore\n+               --  If pragma, capture if postconditions enabled, else ignore\n \n                if Pragma_Name (Prag) = Name_Postcondition\n                  and then Check_Enabled (Name_Postcondition)"}, {"sha": "fd675966cf97ce0a10e864ad17ce608a85f356eb", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -7012,7 +7012,7 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Pack_Id := Defining_Unit_Name (Specification (Par));\n+            Pack_Id := Defining_Entity (Par);\n             State   := Expression (Arg1);\n \n             --  Multiple abstract states appear as an aggregate"}, {"sha": "281b6e8fc01eff3295b2c2c07f6429b6b40ca70e", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9686dbc79e2904ce4047003d78e30c7056321151/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=9686dbc79e2904ce4047003d78e30c7056321151", "patch": "@@ -645,7 +645,7 @@ package body Sem_Warn is\n                end if;\n \n             --  If an unconditional exit statement is the last statement in the\n-            --  loop assume that no warning is needed. without any attempt at\n+            --  loop, assume that no warning is needed, without any attempt at\n             --  checking whether the exit is reachable.\n \n             elsif Exit_Stmt = Last (Statements (Loop_Statement)) then"}]}