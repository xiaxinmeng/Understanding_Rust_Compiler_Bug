{"sha": "5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4MThiOTM1MTU4ZWM2ZjRiMDNlNTgzYzdlOWEzYzJkOTg2ZmQ5ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2000-12-09T18:34:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-12-09T18:34:12Z"}, "message": "error.c (dump_function_name): Don't let the user see __comp_ctor.\n\n        * error.c (dump_function_name): Don't let the user see __comp_ctor.\n\n        Clean up copy-initialization in overloading code.\n        * call.c (build_user_type_conversion_1): Die if we are asked to\n        convert to the same or a base type.\n        (implicit_conversion): Avoid doing so.  Lose reference binding code.\n        (convert_like_real): Treat BASE_CONV and RVALUE_CONV as implicit\n        direct-initialization.  Also do direct-init part of copy-init.\n        (build_user_type_conversion): Don't provide context to convert_like.\n        * cvt.c (ocp_convert): build_user_type_conversion will now provide\n        the constructor call for copy-init.\n\n        * pt.c (tsubst_decl): Call clone_function_decl here if this is an\n        instantiation of a member template.\n        (do_decl_instantiation): Not here.\n\nFrom-SVN: r38158", "tree": {"sha": "54b3338c1d73ee9a2ebbb69f448b63e37a850f4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54b3338c1d73ee9a2ebbb69f448b63e37a850f4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "193ad8c673aeacf0f13882c7816c6e6aeee240de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193ad8c673aeacf0f13882c7816c6e6aeee240de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/193ad8c673aeacf0f13882c7816c6e6aeee240de"}], "stats": {"total": 210, "additions": 128, "deletions": 82}, "files": [{"sha": "0ef0b3d44816bc254e8a73f75932b6c2c87edd8b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -1,3 +1,21 @@\n+2000-12-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* error.c (dump_function_name): Don't let the user see __comp_ctor.\n+\n+\tClean up copy-initialization in overloading code.\n+\t* call.c (build_user_type_conversion_1): Die if we are asked to\n+\tconvert to the same or a base type.\n+\t(implicit_conversion): Avoid doing so.  Lose reference binding code.\n+\t(convert_like_real): Treat BASE_CONV and RVALUE_CONV as implicit\n+\tdirect-initialization.  Also do direct-init part of copy-init.\n+\t(build_user_type_conversion): Don't provide context to convert_like.\n+\t* cvt.c (ocp_convert): build_user_type_conversion will now provide\n+\tthe constructor call for copy-init.\n+\n+\t* pt.c (tsubst_decl): Call clone_function_decl here if this is an\n+\tinstantiation of a member template.\n+\t(do_decl_instantiation): Not here.\n+\n 2000-12-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (check_field_decls): Don't special case anonymous\n@@ -96,8 +114,6 @@\n \n \t* except.c (expand_throw): Use push_throw_library_fn for _Jv_Throw.\n \n-\t* pt.c (tsubst_decl): Call clone_function_decl here.\n-\t(do_decl_instantiation): Not here.\n \t* class.c (clone_function_decl): Robustify.\n \n 2000-12-04  Michael Matz  <matzmich@cs.tu-berlin.de>"}, {"sha": "2f8a9dc7ed66031092a785be3c2f8fd4b69e1e45", "filename": "gcc/cp/call.c", "status": "modified", "additions": 94, "deletions": 62, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -1237,29 +1237,18 @@ implicit_conversion (to, from, expr, flags)\n   if (conv)\n     ;\n   else if (expr != NULL_TREE\n-\t   && (IS_AGGR_TYPE (non_reference (from))\n-\t       || IS_AGGR_TYPE (non_reference (to)))\n+\t   && (IS_AGGR_TYPE (from)\n+\t       || IS_AGGR_TYPE (to))\n \t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n       cand = build_user_type_conversion_1\n \t(to, expr, LOOKUP_ONLYCONVERTING);\n       if (cand)\n \tconv = cand->second_conv;\n-      if ((! conv || ICS_BAD_FLAG (conv))\n-\t  && TREE_CODE (to) == REFERENCE_TYPE\n-\t  && (flags & LOOKUP_NO_TEMP_BIND) == 0)\n-\t{\n-\t  cand = build_user_type_conversion_1\n-\t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_ONLYCONVERTING);\n-\t  if (cand)\n-\t    {\n-\t      if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (to)))\n-\t\tICS_BAD_FLAG (cand->second_conv) = 1;\n-\t      if (!conv || (ICS_BAD_FLAG (conv)\n-\t\t\t    > ICS_BAD_FLAG (cand->second_conv)))\n-\t\tconv = build_conv (REF_BIND, to, cand->second_conv);\n-\t    }\n-\t}\n+\n+      /* We used to try to bind a reference to a temporary here, but that\n+\t is now handled by the recursive call to this function at the end\n+\t of reference_binding.  */\n     }\n \n   return conv;\n@@ -2325,15 +2314,21 @@ build_user_type_conversion_1 (totype, expr, flags)\n   tree args = NULL_TREE;\n   tree templates = NULL_TREE;\n \n+  /* We represent conversion within a hierarchy using RVALUE_CONV and\n+     BASE_CONV, as specified by [over.best.ics]; these become plain\n+     constructor calls, as specified in [dcl.init].  */\n+  if (IS_AGGR_TYPE (fromtype) && IS_AGGR_TYPE (totype)\n+      && DERIVED_FROM_P (totype, fromtype))\n+    abort ();\n+\n   if (IS_AGGR_TYPE (totype))\n     ctors = lookup_fnfields (TYPE_BINFO (totype),\n \t\t\t     (flag_new_abi \n \t\t\t      ? complete_ctor_identifier\n \t\t\t      : ctor_identifier),\n \t\t\t     0);\n \n-  if (IS_AGGR_TYPE (fromtype)\n-      && (! IS_AGGR_TYPE (totype) || ! DERIVED_FROM_P (totype, fromtype)))\n+  if (IS_AGGR_TYPE (fromtype))\n     convs = lookup_conversions (fromtype);\n \n   candidates = 0;\n@@ -2509,9 +2504,7 @@ build_user_type_conversion (totype, expr, flags)\n     {\n       if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n \treturn error_mark_node;\n-      return convert_from_reference\n-              (convert_like_with_context\n-                (cand->second_conv, expr, cand->fn, 0));\n+      return convert_from_reference (convert_like (cand->second_conv, expr));\n     }\n   return NULL_TREE;\n }\n@@ -3653,6 +3646,11 @@ convert_like_real (convs, expr, fn, argnum, inner)\n      int argnum;\n      int inner;\n {\n+  extern int warningcount, errorcount;\n+  int savew, savee;\n+\n+  tree totype = TREE_TYPE (convs);\n+\n   if (ICS_BAD_FLAG (convs)\n       && TREE_CODE (convs) != USER_CONV\n       && TREE_CODE (convs) != AMBIG_CONV\n@@ -3672,29 +3670,29 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t    break;\n \t}\n       return convert_for_initialization\n-\t(NULL_TREE, TREE_TYPE (convs), expr, LOOKUP_NORMAL,\n+\t(NULL_TREE, totype, expr, LOOKUP_NORMAL,\n \t \"conversion\", fn, argnum);\n     }\n   \n   if (!inner)\n     expr = dubious_conversion_warnings\n-             (TREE_TYPE (convs), expr, \"argument\", fn, argnum);\n+             (totype, expr, \"argument\", fn, argnum);\n   switch (TREE_CODE (convs))\n     {\n     case USER_CONV:\n       {\n \tstruct z_candidate *cand\n \t  = WRAPPER_PTR (TREE_OPERAND (convs, 1));\n-\ttree fn = cand->fn;\n+\ttree convfn = cand->fn;\n \ttree args;\n \n-\tif (DECL_CONSTRUCTOR_P (fn))\n+\tif (DECL_CONSTRUCTOR_P (convfn))\n \t  {\n \t    tree t = build_int_2 (0, 0);\n-\t    TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (fn));\n+\t    TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (convfn));\n \n \t    args = build_tree_list (NULL_TREE, expr);\n-\t    if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n+\t    if (DECL_HAS_IN_CHARGE_PARM_P (convfn))\n \t      args = tree_cons (NULL_TREE, integer_one_node, args);\n \t    args = tree_cons (NULL_TREE, t, args);\n \t  }\n@@ -3704,19 +3702,61 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \n \t/* If this is a constructor or a function returning an aggr type,\n \t   we need to build up a TARGET_EXPR.  */\n-\tif (DECL_CONSTRUCTOR_P (fn))\n-\t  expr = build_cplus_new (TREE_TYPE (convs), expr);\n+\tif (DECL_CONSTRUCTOR_P (convfn))\n+\t  expr = build_cplus_new (totype, expr);\n+\n+\t/* The result of the call is then used to direct-initialize the object\n+\t   that is the destination of the copy-initialization.  [dcl.init]\n+\n+\t   Note that this step is not reflected in the conversion sequence;\n+\t   it affects the semantics when we actually perform the\n+\t   conversion, but is not considered during overload resolution.\n \n+\t   If the target is a class, that means call a ctor.  */\n+\tif (IS_AGGR_TYPE (totype))\n+\t  {\n+\t    savew = warningcount, savee = errorcount;\n+\t    expr = build_new_method_call\n+\t      (NULL_TREE, complete_ctor_identifier,\n+\t       build_tree_list (NULL_TREE, expr), TYPE_BINFO (totype),\n+\t       /* Core issue 84, now a DR, says that we don't allow UDCs\n+\t\t  for these args (which deliberately breaks copy-init of an\n+\t\t  auto_ptr<Base> from an auto_ptr<Derived>).  */\n+\t       LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING|LOOKUP_NO_CONVERSION);\n+\n+\t    /* Tell the user where this failing constructor call came from.  */\n+\t    if (fn)\n+\t      {\n+\t\tif (warningcount > savew)\n+\t\t  cp_warning\n+\t\t    (\"  initializing argument %P of `%D' from result of `%D'\",\n+\t\t     argnum, fn, convfn);\n+\t\telse if (errorcount > savee)\n+\t\t  cp_error\n+\t\t    (\"  initializing argument %P of `%D' from result of `%D'\",\n+\t\t     argnum, fn, convfn);\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (warningcount > savew)\n+\t\t  cp_warning (\"  initializing temporary from result of `%D'\",\n+\t\t\t      convfn);\n+\t\telse if (errorcount > savee)\n+\t\t  cp_error (\"  initializing temporary from result of `%D'\",\n+\t\t\t    convfn);\n+\t      }\n+\t    expr = build_cplus_new (totype, expr);\n+\t  }\n \treturn expr;\n       }\n     case IDENTITY_CONV:\n       if (type_unknown_p (expr))\n-\texpr = instantiate_type (TREE_TYPE (convs), expr, itf_complain);\n+\texpr = instantiate_type (totype, expr, itf_complain);\n       return expr;\n     case AMBIG_CONV:\n       /* Call build_user_type_conversion again for the error.  */\n       return build_user_type_conversion\n-\t(TREE_TYPE (convs), TREE_OPERAND (convs, 0), LOOKUP_NORMAL);\n+\t(totype, TREE_OPERAND (convs, 0), LOOKUP_NORMAL);\n \n     default:\n       break;\n@@ -3736,15 +3776,15 @@ convert_like_real (convs, expr, fn, argnum, inner)\n   switch (TREE_CODE (convs))\n     {\n     case RVALUE_CONV:\n-      if (! IS_AGGR_TYPE (TREE_TYPE (convs)))\n+      if (! IS_AGGR_TYPE (totype))\n \treturn expr;\n       /* else fall through */\n     case BASE_CONV:\n       if (TREE_CODE (convs) == BASE_CONV && !NEED_TEMPORARY_P (convs))\n \t{\n \t  /* We are going to bind a reference directly to a base-class\n \t     subobject of EXPR.  */\n-\t  tree base_ptr = build_pointer_type (TREE_TYPE (convs));\n+\t  tree base_ptr = build_pointer_type (totype);\n \n \t  /* Build an expression for `*((base*) &expr)'.  */\n \t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n@@ -3753,35 +3793,27 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t  return expr;\n \t}\n \n-      {\n-\ttree cvt_expr = build_user_type_conversion\n-\t  (TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n-\tif (!cvt_expr) \n-\t  {\n-\t    /* This can occur if, for example, the EXPR has incomplete\n-\t       type.  We can't check for that before attempting the\n-\t       conversion because the type might be an incomplete\n-\t       array type, which is OK if some constructor for the\n-\t       destination type takes a pointer argument.  */\n-\t    if (!COMPLETE_TYPE_P (TREE_TYPE (expr)))\n-\t      {\n-\t\tif (same_type_p (TREE_TYPE (expr), TREE_TYPE (convs)))\n-\t\t  incomplete_type_error (expr, TREE_TYPE (expr));\n-\t\telse\n-\t\t  cp_error (\"could not convert `%E' (with incomplete type `%T') to `%T'\",\n-\t\t\t    expr, TREE_TYPE (expr), TREE_TYPE (convs));\n-\t      }\n-\t    else\n-\t      cp_error (\"could not convert `%E' to `%T'\",\n-\t\t\texpr, TREE_TYPE (convs));\n-\t    return error_mark_node;\n-\t  }\n-\treturn cvt_expr;\n-      }\n+      /* Copy-initialization where the cv-unqualified version of the source\n+\t type is the same class as, or a derived class of, the class of the\n+\t destination [is treated as direct-initialization].  [dcl.init] */\n+      if (fn)\n+\tsavew = warningcount, savee = errorcount;\n+      expr = build_new_method_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t    build_tree_list (NULL_TREE, expr),\n+\t\t\t\t    TYPE_BINFO (totype),\n+\t\t\t\t    LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING);\n+      if (fn)\n+\t{\n+\t  if (warningcount > savew)\n+\t    cp_warning (\"  initializing argument %P of `%D'\", argnum, fn);\n+\t  else if (errorcount > savee)\n+\t    cp_error (\"  initializing argument %P of `%D'\", argnum, fn);\n+\t}\n+      return build_cplus_new (totype, expr);\n \n     case REF_BIND:\n       {\n-\ttree ref_type = TREE_TYPE (convs);\n+\ttree ref_type = totype;\n \n \t/* If necessary, create a temporary.  */\n \tif (NEED_TEMPORARY_P (convs))\n@@ -3812,13 +3844,13 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \n     case QUAL_CONV:\n       /* Warn about deprecated conversion if appropriate.  */\n-      string_conv_p (TREE_TYPE (convs), expr, 1);\n+      string_conv_p (totype, expr, 1);\n       break;\n       \n     default:\n       break;\n     }\n-  return ocp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n+  return ocp_convert (totype, expr, CONV_IMPLICIT,\n \t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n }\n "}, {"sha": "e997d11d7bf4862fb1a0d700a58c6da7c5c7bc34", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -841,7 +841,7 @@ ocp_convert (type, expr, convtype, flags)\n \t   with a user-defined conversion sequence, then we direct-initialize\n \t   the target with the temp (see [dcl.init]).  */\n \tctor = build_user_type_conversion (type, ctor, flags);\n-      if (ctor)\n+      else\n \tctor = build_method_call (NULL_TREE, \n \t\t\t\t  complete_ctor_identifier,\n \t\t\t\t  build_tree_list (NULL_TREE, ctor),"}, {"sha": "b208e653f2cc90a4668c53d1b3b06222b15572cf", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -1340,6 +1340,11 @@ dump_function_name (t, flags)\n {\n   tree name = DECL_NAME (t);\n \n+  /* Don't let the user see __comp_ctor et al.  */\n+  if (DECL_CONSTRUCTOR_P (t)\n+      || DECL_DESTRUCTOR_P (t))\n+    name = constructor_name (DECL_CONTEXT (t));\n+\n   if (DECL_DESTRUCTOR_P (t))\n     {\n       output_add_character (scratch_buffer, '~');"}, {"sha": "87d4195b3175da953e435beca08f0cfdad497a58", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -5788,6 +5788,8 @@ tsubst_decl (t, args, type, in_decl)\n \t    maybe_retrofit_in_chrg (r);\n \t    if (DECL_CONSTRUCTOR_P (r))\n \t      grok_ctor_properties (ctx, r);\n+\t    if (PRIMARY_TEMPLATE_P (gen_tmpl))\n+\t      clone_function_decl(r, /*update_method_vec_p=*/0);\n \t  }\n \telse if (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n \t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n@@ -9280,15 +9282,6 @@ do_decl_instantiation (declspecs, declarator, storage)\n     cp_error (\"storage class `%D' applied to template instantiation\",\n \t      storage);\n \n-  /* Under the new ABI, we need to make sure to instantiate all the\n-     cloned versions of constructors or destructors.  */\n-  if (flag_new_abi &&\n-      (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (result) || \n-       DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (result)) &&\n-      !(TREE_CHAIN (result) && \n-\tDECL_CLONED_FUNCTION (TREE_CHAIN (result))))\n-    clone_function_decl(result, /*update_method_vec_p=*/0);\n-      \n   SET_DECL_EXPLICIT_INSTANTIATION (result);\n   mark_decl_instantiated (result, extern_p);\n   repo_template_instantiated (result, extern_p);"}, {"sha": "fc775c4f0790d4dd8ff3e380ad66bf9c6a5050f6", "filename": "gcc/testsuite/g++.old-deja/g++.law/cvt7.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fcvt7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fcvt7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fcvt7.C?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -11,8 +11,8 @@\n class A\n {\n public:\n-    A(int j) { i = j; }\n-    A(A& a) { i = a.i; }\n+    A(int j) { i = j; }\t\t// ERROR - candidate\n+    A(A& a) { i = a.i; }\t// ERROR - candidate\n     operator int() { return i; }\n \n     void assign(int v) { i = v; }\n@@ -38,10 +38,10 @@ B::run()\n     // Replacing above with \"switch (int(in))\" removes the error.\n     {\n     case 0:\n-        out = 1;\n+        out = 1;\t\t// ERROR - no usable copy ctor\n         break;\n     default:\n-        out = 0;\n+        out = 0;\t\t// ERROR - no usable copy ctor\n         break;\n     }\n }"}, {"sha": "9e5250e43de0f5297db6e51668d9b8f20223d559", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p5469.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp5469.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp5469.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp5469.C?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -4,7 +4,7 @@ int count;\n \n class A {\n   A();\n-  A(const A&);\n+  A(const A&);\t\t\t// ERROR - referenced below\n public:\n   A(int) { ++count; }\n   ~A() { --count; }\n@@ -14,7 +14,7 @@ public:\n int main() {\n   {\n     A a (1);\n-    if (a == 2 && a == 1)\n+    if (a == 2 && a == 1)\t// ERROR - private copy ctor\n       ;\n   }\n   return count;"}, {"sha": "9cbd2dfe7a80b83ddad4cbaca66f456782876025", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p5469a.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp5469a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e818b935158ec6f4b03e583c7e9a3c2d986fd9e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp5469a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp5469a.C?ref=5e818b935158ec6f4b03e583c7e9a3c2d986fd9e", "patch": "@@ -4,7 +4,7 @@ int count;\n \n class A {\n   A();\n-  A(const A&);\n+  A(const A&);\t\t\t// ERROR - referenced below\n public:\n   A(int) { ++count; }\n   ~A() { --count; }\n@@ -14,7 +14,7 @@ public:\n int main() {\n   {\n     A a (1);\n-    if (a == 2 || a == 1)\n+    if (a == 2 || a == 1)\t// ERROR - private copy ctor\n       ;\n   }\n   return count;"}]}