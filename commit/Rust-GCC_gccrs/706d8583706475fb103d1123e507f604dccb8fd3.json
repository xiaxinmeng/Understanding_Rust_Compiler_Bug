{"sha": "706d8583706475fb103d1123e507f604dccb8fd3", "node_id": "C_kwDOANBUbNoAKDcwNmQ4NTgzNzA2NDc1ZmIxMDNkMTEyM2U1MDdmNjA0ZGNjYjhmZDM", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-10T12:56:42Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-11T13:52:24Z"}, "message": "Implement ABS_EXPR operator for frange.\n\nImplementing ABS_EXPR allows us to fold certain __builtin_inf calls\nsince they are expanded into calls to involving ABS_EXPR.\n\nThis is an adaptation of the integer version.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (class foperator_abs): New.\n\t(floating_op_table::floating_op_table): Add ABS_EXPR entry.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/vrp-float-abs-1.c: New test.", "tree": {"sha": "5b1b7bef4dba8ee7bf0a8b0b50afe73b6be9ad79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b1b7bef4dba8ee7bf0a8b0b50afe73b6be9ad79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/706d8583706475fb103d1123e507f604dccb8fd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/706d8583706475fb103d1123e507f604dccb8fd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/706d8583706475fb103d1123e507f604dccb8fd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/706d8583706475fb103d1123e507f604dccb8fd3/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe7371e7f93c247b5d0e257ca2a68064123cd018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe7371e7f93c247b5d0e257ca2a68064123cd018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe7371e7f93c247b5d0e257ca2a68064123cd018"}], "stats": {"total": 108, "additions": 108, "deletions": 0}, "files": [{"sha": "283eb134c78de7b495f860c67bdf899ad684d0c4", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/706d8583706475fb103d1123e507f604dccb8fd3/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/706d8583706475fb103d1123e507f604dccb8fd3/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=706d8583706475fb103d1123e507f604dccb8fd3", "patch": "@@ -1132,6 +1132,95 @@ foperator_ordered::op1_range (frange &r, tree type,\n   return true;\n }\n \n+class foperator_abs : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+public:\n+  bool fold_range (frange &r, tree type,\n+\t\t   const frange &op1, const frange &,\n+\t\t   relation_kind) const final override;\n+  bool op1_range (frange &r, tree type,\n+\t\t  const frange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+} fop_abs;\n+\n+bool\n+foperator_abs::fold_range (frange &r, tree type,\n+\t\t\t   const frange &op1, const frange &op2,\n+\t\t\t   relation_kind) const\n+{\n+  if (empty_range_varying (r, type, op1, op2))\n+    return true;\n+  if (op1.known_isnan ())\n+    {\n+      r.set_nan (type, /*sign=*/false);\n+      return true;\n+    }\n+\n+  const REAL_VALUE_TYPE lh_lb = op1.lower_bound ();\n+  const REAL_VALUE_TYPE lh_ub = op1.upper_bound ();\n+  // Handle the easy case where everything is positive.\n+  if (real_compare (GE_EXPR, &lh_lb, &dconst0)\n+      && !real_iszero (&lh_lb, /*sign=*/true)\n+      && !op1.maybe_isnan (/*sign=*/true))\n+    {\n+      r = op1;\n+      return true;\n+    }\n+\n+  REAL_VALUE_TYPE min = real_value_abs (&lh_lb);\n+  REAL_VALUE_TYPE max = real_value_abs (&lh_ub);\n+  // If the range contains zero then we know that the minimum value in the\n+  // range will be zero.\n+  if (real_compare (LE_EXPR, &lh_lb, &dconst0)\n+      && real_compare (GE_EXPR, &lh_ub, &dconst0))\n+    {\n+      if (real_compare (GT_EXPR, &min, &max))\n+\tmax = min;\n+      min = dconst0;\n+    }\n+  else\n+    {\n+      // If the range was reversed, swap MIN and MAX.\n+      if (real_compare (GT_EXPR, &min, &max))\n+\tstd::swap (min, max);\n+    }\n+\n+  r.set (type, min, max);\n+  if (op1.maybe_isnan ())\n+    r.update_nan (/*sign=*/false);\n+  else\n+    r.clear_nan ();\n+  return true;\n+}\n+\n+bool\n+foperator_abs::op1_range (frange &r, tree type,\n+\t\t\t  const frange &lhs, const frange &op2,\n+\t\t\t  relation_kind) const\n+{\n+  if (empty_range_varying (r, type, lhs, op2))\n+    return true;\n+  if (lhs.known_isnan ())\n+    {\n+      r.set_nan (type);\n+      return true;\n+    }\n+\n+  // Start with the positives because negatives are an impossible result.\n+  frange positives (type, dconst0, frange_val_max (type));\n+  positives.update_nan (/*sign=*/false);\n+  positives.intersect (lhs);\n+  r = positives;\n+  // Then add the negative of each pair:\n+  // ABS(op1) = [5,20] would yield op1 => [-20,-5][5,20].\n+  r.union_ (frange (type,\n+\t\t    real_value_negate (&positives.upper_bound ()),\n+\t\t    real_value_negate (&positives.lower_bound ())));\n+  return true;\n+}\n+\n class foperator_unordered_lt : public range_operator_float\n {\n   using range_operator_float::fold_range;\n@@ -1502,6 +1591,8 @@ floating_op_table::floating_op_table ()\n   set (UNEQ_EXPR, fop_unordered_equal);\n   set (ORDERED_EXPR, fop_ordered);\n   set (UNORDERED_EXPR, fop_unordered);\n+\n+  set (ABS_EXPR, fop_abs);\n }\n \n // Return a pointer to the range_operator_float instance, if there is"}, {"sha": "4b7b75833e016048b1517ae34da5857577cb8266", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-abs-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/706d8583706475fb103d1123e507f604dccb8fd3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-abs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/706d8583706475fb103d1123e507f604dccb8fd3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-abs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-abs-1.c?ref=706d8583706475fb103d1123e507f604dccb8fd3", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-thread-jumps -fdump-tree-evrp\" }\n+\n+void link_error ();\n+\n+void\n+foo (double x, double y)\n+{\n+  if (x > y && __builtin_signbit (y) == 0)\n+    {\n+      // y == +INF is impossible.\n+      if (__builtin_isinf (y))\n+        link_error ();\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-not \"link_error\" \"evrp\" } }"}]}