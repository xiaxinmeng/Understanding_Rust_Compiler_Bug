{"sha": "11d8d07e31ce544fed5d4f2d2b4526b19672b558", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFkOGQwN2UzMWNlNTQ0ZmVkNWQ0ZjJkMmI0NTI2YjE5NjcyYjU1OA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2017-06-07T14:55:54Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2017-06-07T14:55:54Z"}, "message": "rs6000: Remove TARGET_FPRS\n\nSince rs6000 no longer supports SPE, TARGET_FPRS now always is true.\n\nThis makes TARGET_{SF,DF}_SPE always false.  Many patterns in spe.md\ncan now be deleted; which makes it possible to merge e.g. negdd2 with\n*negdd2_fpr.\n\nFinally, e500.h is deleted (it isn't used).\n\n\n\t* config/rs6000/darwin.md: Replace TARGET_FPRS by 1 and simplify.\n\t* config/rs6000/dfp.md: Ditto.\n\t(negdd2, *negdd2_fpr): Merge.\n\t(absdd2, *absdd2_fpr): Merge.\n\t(negtd2, *negtd2_fpr): Merge.\n\t(abstd2, *abstd2_fpr): Merge.\n\t* config/rs6000/e500.h: Delete file.\n\t* config/rs6000/predicates.md (rs6000_cbranch_operator): Replace\n\tTARGET_FPRS by 1 and simplify.\n\t* config/rs6000/rs6000-c.c: Ditto.\n\t* config/rs6000/rs6000.c: Ditto.  Also replace TARGET_SF_SPE and\n\tTARGET_DF_SPE by 0.\n\t* config/rs6000/rs6000.h: Ditto.  Delete TARGET_SF_SPE and\n\tTARGET_DF_SPE.\n\t* config/rs6000/rs6000.md: Ditto.\n\t(floatdidf2, *floatdidf2_fpr): Merge.\n\t(move_from_CR_gt_bit): Delete.\n\t* config/rs6000/spe.md: Replace TARGET_FPRS by 1 and simplify.\n\t(E500_CR_IOR_COMPARE): Delete.\n\t(All patterns that require !TARGET_FPRS): Delete.\n\t* config/rs6000/vsx.md: Replace TARGET_FPRS by 1 and simplify.\n\nFrom-SVN: r248974", "tree": {"sha": "8825da795da95da7619de8f7dfb99454105db880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8825da795da95da7619de8f7dfb99454105db880"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11d8d07e31ce544fed5d4f2d2b4526b19672b558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d8d07e31ce544fed5d4f2d2b4526b19672b558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11d8d07e31ce544fed5d4f2d2b4526b19672b558", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d8d07e31ce544fed5d4f2d2b4526b19672b558/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6d31e8499c5bb691feef26f3a5e6562129eec42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d31e8499c5bb691feef26f3a5e6562129eec42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6d31e8499c5bb691feef26f3a5e6562129eec42"}], "stats": {"total": 881, "additions": 195, "deletions": 686}, "files": [{"sha": "49c26e53140a25b5c4544f1bbddeb4b33c8f2ad7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -1,3 +1,27 @@\n+2017-06-07  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/darwin.md: Replace TARGET_FPRS by 1 and simplify.\n+\t* config/rs6000/dfp.md: Ditto.\n+\t(negdd2, *negdd2_fpr): Merge.\n+\t(absdd2, *absdd2_fpr): Merge.\n+\t(negtd2, *negtd2_fpr): Merge.\n+\t(abstd2, *abstd2_fpr): Merge.\n+\t* config/rs6000/e500.h: Delete file.\n+\t* config/rs6000/predicates.md (rs6000_cbranch_operator): Replace\n+\tTARGET_FPRS by 1 and simplify.\n+\t* config/rs6000/rs6000-c.c: Ditto.\n+\t* config/rs6000/rs6000.c: Ditto.  Also replace TARGET_SF_SPE and\n+\tTARGET_DF_SPE by 0.\n+\t* config/rs6000/rs6000.h: Ditto.  Delete TARGET_SF_SPE and\n+\tTARGET_DF_SPE.\n+\t* config/rs6000/rs6000.md: Ditto.\n+\t(floatdidf2, *floatdidf2_fpr): Merge.\n+\t(move_from_CR_gt_bit): Delete.\n+\t* config/rs6000/spe.md: Replace TARGET_FPRS by 1 and simplify.\n+\t(E500_CR_IOR_COMPARE): Delete.\n+\t(All patterns that require !TARGET_FPRS): Delete.\n+\t* config/rs6000/vsx.md: Replace TARGET_FPRS by 1 and simplify.\n+\n 2017-06-07  Bin Cheng  <bin.cheng@arm.com>\n \n \t* passes.def (pass_iv_canon): Move before pass_loop_distribution."}, {"sha": "a60185a4aeed904ac0725f569f08ee6e7b50d8d5", "filename": "gcc/config/rs6000/darwin.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fdarwin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fdarwin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.md?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -30,7 +30,7 @@ You should have received a copy of the GNU General Public License\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f,!r\")\n         (mem:DF (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && !TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && !TARGET_64BIT\"\n   \"*\n {\n   switch (which_alternative)\n@@ -61,7 +61,7 @@ You should have received a copy of the GNU General Public License\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f,!r\")\n         (mem:DF (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_64BIT\"\n   \"*\n {\n   switch (which_alternative)\n@@ -81,7 +81,7 @@ You should have received a copy of the GNU General Public License\n   [(set (mem:DF (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n                            (match_operand 2 \"\" \"\")))\n \t(match_operand:DF 0 \"gpc_reg_operand\" \"f\"))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && ! TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && ! TARGET_64BIT\"\n   \"stfd %0,lo16(%2)(%1)\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n@@ -90,7 +90,7 @@ You should have received a copy of the GNU General Public License\n   [(set (mem:DF (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b\")\n                            (match_operand 2 \"\" \"\")))\n \t(match_operand:DF 0 \"gpc_reg_operand\" \"f\"))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_64BIT\"\n   \"stfd %0,lo16(%2)(%1)\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n@@ -99,7 +99,7 @@ You should have received a copy of the GNU General Public License\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,!r\")\n         (mem:SF (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && ! TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && ! TARGET_64BIT\"\n   \"@\n    lfs %0,lo16(%2)(%1)\n    lwz %0,lo16(%2)(%1)\"\n@@ -110,7 +110,7 @@ You should have received a copy of the GNU General Public License\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,!r\")\n         (mem:SF (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_64BIT\"\n   \"@\n    lfs %0,lo16(%2)(%1)\n    lwz %0,lo16(%2)(%1)\"\n@@ -121,7 +121,7 @@ You should have received a copy of the GNU General Public License\n   [(set (mem:SF (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\")))\n \t(match_operand:SF 0 \"gpc_reg_operand\" \"f,!r\"))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && ! TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && ! TARGET_64BIT\"\n   \"@\n    stfs %0,lo16(%2)(%1)\n    stw %0,lo16(%2)(%1)\"\n@@ -132,7 +132,7 @@ You should have received a copy of the GNU General Public License\n   [(set (mem:SF (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\")))\n \t(match_operand:SF 0 \"gpc_reg_operand\" \"f,!r\"))]\n-  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_64BIT\"\n+  \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_64BIT\"\n   \"@\n    stfs %0,lo16(%2)(%1)\n    stw %0,lo16(%2)(%1)\""}, {"sha": "d42434fc15cd7188e47759fc7a5d73564716a95c", "filename": "gcc/config/rs6000/dfp.md", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -35,7 +35,7 @@\n \t\t   UNSPEC_MOVSD_STORE))]\n   \"(gpc_reg_operand (operands[0], DDmode)\n    || gpc_reg_operand (operands[1], SDmode))\n-   && TARGET_HARD_FLOAT && TARGET_FPRS\"\n+   && TARGET_HARD_FLOAT\"\n   \"stfd%U0%X0 %1,%0\"\n   [(set_attr \"type\" \"fpstore\")\n    (set_attr \"length\" \"4\")])\n@@ -46,7 +46,7 @@\n \t\t   UNSPEC_MOVSD_LOAD))]\n   \"(gpc_reg_operand (operands[0], SDmode)\n    || gpc_reg_operand (operands[1], DDmode))\n-   && TARGET_HARD_FLOAT && TARGET_FPRS\"\n+   && TARGET_HARD_FLOAT\"\n   \"lfd%U1%X1 %0,%1\"\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"4\")])\n@@ -78,65 +78,41 @@\n   \"drsp %0,%1\"\n   [(set_attr \"type\" \"dfp\")])\n \n-(define_expand \"negdd2\"\n-  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n-\t(neg:DD (match_operand:DD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n-  \"\")\n-\n-(define_insn \"*negdd2_fpr\"\n+(define_insn \"negdd2\"\n   [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=d\")\n \t(neg:DD (match_operand:DD 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"fneg %0,%1\"\n   [(set_attr \"type\" \"fpsimple\")])\n \n-(define_expand \"absdd2\"\n-  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n-\t(abs:DD (match_operand:DD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n-  \"\")\n-\n-(define_insn \"*absdd2_fpr\"\n+(define_insn \"absdd2\"\n   [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=d\")\n \t(abs:DD (match_operand:DD 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"fabs %0,%1\"\n   [(set_attr \"type\" \"fpsimple\")])\n \n (define_insn \"*nabsdd2_fpr\"\n   [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=d\")\n \t(neg:DD (abs:DD (match_operand:DD 1 \"gpc_reg_operand\" \"d\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"fnabs %0,%1\"\n   [(set_attr \"type\" \"fpsimple\")])\n \n-(define_expand \"negtd2\"\n-  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"\")\n-\t(neg:TD (match_operand:TD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n-  \"\")\n-\n-(define_insn \"*negtd2_fpr\"\n+(define_insn \"negtd2\"\n   [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=d,d\")\n \t(neg:TD (match_operand:TD 1 \"gpc_reg_operand\" \"0,d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fneg %0,%1\n    fneg %0,%1\\;fmr %L0,%L1\"\n   [(set_attr \"type\" \"fpsimple\")\n    (set_attr \"length\" \"4,8\")])\n \n-(define_expand \"abstd2\"\n-  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"\")\n-\t(abs:TD (match_operand:TD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n-  \"\")\n-\n-(define_insn \"*abstd2_fpr\"\n+(define_insn \"abstd2\"\n   [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=d,d\")\n \t(abs:TD (match_operand:TD 1 \"gpc_reg_operand\" \"0,d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fabs %0,%1\n    fabs %0,%1\\;fmr %L0,%L1\"\n@@ -146,7 +122,7 @@\n (define_insn \"*nabstd2_fpr\"\n   [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=d,d\")\n \t(neg:TD (abs:TD (match_operand:TD 1 \"gpc_reg_operand\" \"0,d\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fnabs %0,%1\n    fnabs %0,%1\\;fmr %L0,%L1\""}, {"sha": "a9bf8541f341be50e7c75677186b946025468fcd", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -1240,16 +1240,8 @@\n \t\t\t  1\"))))\n \n ;; Return 1 if OP is a valid comparison operator for \"cbranch\" instructions.\n-;; If we're assuming that FP operations cannot generate user-visible traps,\n-;; then on e500 we can use the ordered-signaling instructions to implement\n-;; the unordered-quiet FP comparison predicates modulo a reversal.\n (define_predicate \"rs6000_cbranch_operator\"\n-  (if_then_else (match_test \"TARGET_HARD_FLOAT && !TARGET_FPRS\")\n-\t\t(if_then_else (match_test \"flag_trapping_math\")\n-\t\t\t      (match_operand 0 \"ordered_comparison_operator\")\n-\t\t\t      (ior (match_operand 0 \"ordered_comparison_operator\")\n-\t\t\t\t   (match_code (\"unlt,unle,ungt,unge\"))))\n-\t\t(match_operand 0 \"comparison_operator\")))\n+  (match_operand 0 \"comparison_operator\"))\n \n ;; Return 1 if OP is an unsigned comparison operator.\n (define_predicate \"unsigned_comparison_operator\""}, {"sha": "3dc22237a7925fc8a19dfe59ddd92a740aa177d0", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -488,10 +488,10 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n      the following conditions:\n      1. The operating system does not support saving of AltiVec\n \tregisters (OS_MISSING_ALTIVEC).\n-     2. If any of the options TARGET_HARD_FLOAT, TARGET_FPRS,\n-\tTARGET_SINGLE_FLOAT, or TARGET_DOUBLE_FLOAT are turned off.\n-\tHereafter, the OPTION_MASK_VSX flag is considered to have been\n-\tturned off explicitly.\n+     2. If any of the options TARGET_HARD_FLOAT, TARGET_SINGLE_FLOAT,\n+\tor TARGET_DOUBLE_FLOAT are turned off.  Hereafter, the\n+\tOPTION_MASK_VSX flag is considered to have been turned off\n+\texplicitly.\n      3. If TARGET_PAIRED_FLOAT was enabled.  Hereafter, the\n \tOPTION_MASK_VSX flag is considered to have been turned off\n \texplicitly.\n@@ -674,8 +674,8 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n \t  cpp_get_callbacks (pfile)->macro_to_expand = rs6000_macro_to_expand;\n \t}\n     }\n-  if ((!(TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)))\n-      ||(TARGET_HARD_FLOAT && TARGET_FPRS && !TARGET_DOUBLE_FLOAT))\n+  if (!TARGET_HARD_FLOAT\n+      || (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT))\n     builtin_define (\"_SOFT_DOUBLE\");\n   /* Used by lwarx/stwcx. errata work-around.  */\n   if (rs6000_cpu == PROCESSOR_PPC405)\n@@ -775,7 +775,7 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"__VEC_ELEMENT_REG_ORDER__=__ORDER_LITTLE_ENDIAN__\");\n \n   /* Let the compiled code know if 'f' class registers will not be available.  */\n-  if (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n+  if (TARGET_SOFT_FLOAT)\n     builtin_define (\"__NO_FPRS__\");\n \n   /* Whether aggregates passed by value are aligned to a 16 byte boundary"}, {"sha": "d5ff96aa17919e4fa24ffdd977f496075f264f50", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 33, "deletions": 264, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -2853,9 +2853,6 @@ rs6000_debug_reg_global (void)\n   if (rs6000_float_gprs)\n     fprintf (stderr, DEBUG_FMT_S, \"float_gprs\", \"true\");\n \n-  fprintf (stderr, DEBUG_FMT_S, \"fprs\",\n-\t   (TARGET_FPRS ? \"true\" : \"false\"));\n-\n   fprintf (stderr, DEBUG_FMT_S, \"single_float\",\n \t   (TARGET_SINGLE_FLOAT ? \"true\" : \"false\"));\n \n@@ -3295,10 +3292,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \twJ - VSX register if QImode/HImode are allowed in VSX registers.\n \twK - Altivec register if QImode/HImode are allowed in VSX registers.  */\n \n-  if (TARGET_HARD_FLOAT && TARGET_FPRS)\n+  if (TARGET_HARD_FLOAT)\n     rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\t/* SFmode  */\n \n-  if (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n+  if (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n     rs6000_constraints[RS6000_CONSTRAINT_d]  = FLOAT_REGS;\t/* DFmode  */\n \n   if (TARGET_VSX)\n@@ -3663,8 +3660,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  if (addis_insns[i].pmode != cur_pmode)\n \t    continue;\n \n-\t  if (rtype == RELOAD_REG_FPR\n-\t      && (!TARGET_HARD_FLOAT || !TARGET_FPRS))\n+\t  if (rtype == RELOAD_REG_FPR && !TARGET_HARD_FLOAT)\n \t    continue;\n \n \t  reg_addr[xmode].fusion_addis_ld[rtype] = addis_insns[i].load;\n@@ -3689,7 +3685,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       reg_addr[HImode].fused_toc = true;\n       reg_addr[SImode].fused_toc = true;\n       reg_addr[DImode].fused_toc = true;\n-      if (TARGET_HARD_FLOAT && TARGET_FPRS)\n+      if (TARGET_HARD_FLOAT)\n \t{\n \t  if (TARGET_SINGLE_FLOAT)\n \t    reg_addr[SFmode].fused_toc = true;\n@@ -4355,8 +4351,7 @@ rs6000_option_override_internal (bool global_init_p)\n   if (TARGET_VSX)\n     {\n       const char *msg = NULL;\n-      if (!TARGET_HARD_FLOAT || !TARGET_FPRS\n-\t  || !TARGET_SINGLE_FLOAT || !TARGET_DOUBLE_FLOAT)\n+      if (!TARGET_HARD_FLOAT || !TARGET_SINGLE_FLOAT || !TARGET_DOUBLE_FLOAT)\n \t{\n \t  if (rs6000_isa_flags_explicit & OPTION_MASK_VSX)\n \t    msg = N_(\"-mvsx requires hardware floating point\");\n@@ -5550,8 +5545,7 @@ rs6000_option_override_internal (bool global_init_p)\n   /* Set up single/double float flags.  \n      If TARGET_HARD_FLOAT is set, but neither single or double is set, \n      then set both flags. */\n-  if (TARGET_HARD_FLOAT && TARGET_FPRS \n-      && rs6000_single_float == 0 && rs6000_double_float == 0)\n+  if (TARGET_HARD_FLOAT && rs6000_single_float == 0 && rs6000_double_float == 0)\n     rs6000_single_float = rs6000_double_float = 1;\n \n   /* If not explicitly specified via option, decide whether to generate indexed\n@@ -9104,7 +9098,7 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n \treturn false;\n       if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n \t  && !(/* ??? Assume floating point reg based on mode?  */\n-\t       TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+\t       TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n \t       && (mode == DFmode || mode == DDmode)))\n \treturn false;\n \n@@ -9215,7 +9209,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t       || (/* ??? Assume floating point reg based on mode?  */\n-\t\t   (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n+\t\t   (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n \t\t   && (mode == DFmode || mode == DDmode)))\n \t   && !avoiding_indexed_address_p (mode))\n     {\n@@ -9271,7 +9265,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t       || (/* ??? Assume floating point reg based on mode?  */\n-\t\t   (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n+\t\t   (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n \t\t   && (mode == DFmode || mode == DDmode))))\n     {\n       rtx reg = gen_reg_rtx (Pmode);\n@@ -10063,7 +10057,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       && mode != PTImode\n       && (mode != DImode || TARGET_POWERPC64)\n       && ((mode != DFmode && mode != DDmode) || TARGET_POWERPC64\n-\t  || (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)))\n+\t  || (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)))\n     {\n #if TARGET_MACHO\n       if (flag_pic)\n@@ -10244,7 +10238,7 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n   if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict, false))\n     return 1;\n   if (!FLOAT128_2REG_P (mode)\n-      && ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n+      && ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n \t  || TARGET_POWERPC64\n \t  || (mode != DFmode && mode != DDmode)\n \t  || (TARGET_E500_DOUBLE && mode != DDmode))\n@@ -10476,7 +10470,7 @@ rs6000_conditional_register_usage (void)\n       = call_really_used_regs[13] = 1;\n \n   /* Conditionally disable FPRs.  */\n-  if (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n+  if (TARGET_SOFT_FLOAT)\n     for (i = 32; i < 64; i++)\n       fixed_regs[i] = call_used_regs[i]\n \t= call_really_used_regs[i] = 1;\n@@ -11445,7 +11439,7 @@ rs6000_member_type_forces_blk (const_tree field, machine_mode mode)\n #define USE_FP_FOR_ARG_P(CUM,MODE)\t\t\\\n   (SCALAR_FLOAT_MODE_NOT_VECTOR_P (MODE)\t\t\\\n    && (CUM)->fregno <= FP_ARG_MAX_REG\t\t\\\n-   && TARGET_HARD_FLOAT && TARGET_FPRS)\n+   && TARGET_HARD_FLOAT)\n \n /* Nonzero if we can use an AltiVec register to pass this arg.  */\n #define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,NAMED)\t\t\t\\\n@@ -11971,7 +11965,7 @@ is_complex_IBM_long_double (machine_mode mode)\n static bool\n abi_v4_pass_in_fpr (machine_mode mode)\n {\n-  if (!TARGET_FPRS || !TARGET_HARD_FLOAT)\n+  if (!TARGET_HARD_FLOAT)\n     return false;\n   if (TARGET_SINGLE_FLOAT && mode == SFmode)\n     return true;\n@@ -12071,7 +12065,6 @@ rs6000_function_arg_boundary (machine_mode mode, const_tree type)\n   if (DEFAULT_ABI == ABI_V4\n       && (GET_MODE_SIZE (mode) == 8\n \t  || (TARGET_HARD_FLOAT\n-\t      && TARGET_FPRS\n \t      && !is_complex_IBM_long_double (mode)\n \t      && FLOAT128_2REG_P (mode))))\n     return 64;\n@@ -12524,7 +12517,7 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \n       cum->words = align_words + n_words;\n \n-      if (SCALAR_FLOAT_MODE_P (elt_mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+      if (SCALAR_FLOAT_MODE_P (elt_mode) && TARGET_HARD_FLOAT)\n \t{\n \t  /* _Decimal128 must be passed in an even/odd float register pair.\n \t     This assumes that the register number is odd when fregno is\n@@ -13016,7 +13009,7 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t  /* For the SPE, we need to crxor CR6 always.  */\n \t  if (TARGET_SPE_ABI)\n \t    return GEN_INT (cum->call_cookie | CALL_V4_SET_FP_ARGS);\n-\t  else if (TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t  else if (TARGET_HARD_FLOAT)\n \t    return GEN_INT (cum->call_cookie\n \t\t\t    | ((cum->fregno == FP_ARG_MIN_REG)\n \t\t\t       ? CALL_V4_SET_FP_ARGS\n@@ -13652,7 +13645,7 @@ setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t     anything.  */\n \t  if (cfun->va_list_gpr_size && first_reg_offset < GP_ARG_NUM_REG)\n \t    gpr_reg_num = GP_ARG_NUM_REG - first_reg_offset;\n-\t  if (TARGET_HARD_FLOAT && TARGET_FPRS\n+\t  if (TARGET_HARD_FLOAT\n \t      && next_cum.fregno <= FP_ARG_V4_MAX_REG\n \t      && cfun->va_list_fpr_size)\n \t    {\n@@ -13741,7 +13734,7 @@ setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \n   /* Save FP registers if needed.  */\n   if (DEFAULT_ABI == ABI_V4\n-      && TARGET_HARD_FLOAT && TARGET_FPRS\n+      && TARGET_HARD_FLOAT\n       && ! no_rtl\n       && next_cum.fregno <= FP_ARG_V4_MAX_REG\n       && cfun->va_list_fpr_size)\n@@ -14112,9 +14105,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \n       /* _Decimal32 varargs are located in the second word of the 64-bit\n \t FP register for 32-bit binaries.  */\n-      if (TARGET_32BIT\n-\t  && TARGET_HARD_FLOAT && TARGET_FPRS\n-\t  && mode == SDmode)\n+      if (TARGET_32BIT && TARGET_HARD_FLOAT && mode == SDmode)\n \tt = fold_build_pointer_plus_hwi (t, size);\n \n       /* Args are passed right-aligned.  */\n@@ -19506,7 +19497,7 @@ init_float128_ibm (machine_mode mode)\n       set_optab_libfunc (smul_optab, mode, \"__gcc_qmul\");\n       set_optab_libfunc (sdiv_optab, mode, \"__gcc_qdiv\");\n \n-      if (!(TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)))\n+      if (!TARGET_HARD_FLOAT)\n \t{\n \t  set_optab_libfunc (neg_optab, mode, \"__gcc_qneg\");\n \t  set_optab_libfunc (eq_optab, mode, \"__gcc_qeq\");\n@@ -19515,6 +19506,7 @@ init_float128_ibm (machine_mode mode)\n \t  set_optab_libfunc (ge_optab, mode, \"__gcc_qge\");\n \t  set_optab_libfunc (lt_optab, mode, \"__gcc_qlt\");\n \t  set_optab_libfunc (le_optab, mode, \"__gcc_qle\");\n+\t  set_optab_libfunc (unord_optab, mode, \"__gcc_qunord\");\n \n \t  set_conv_libfunc (sext_optab, mode, SFmode, \"__gcc_stoq\");\n \t  set_conv_libfunc (sext_optab, mode, DFmode, \"__gcc_dtoq\");\n@@ -19525,9 +19517,6 @@ init_float128_ibm (machine_mode mode)\n \t  set_conv_libfunc (sfloat_optab, mode, SImode, \"__gcc_itoq\");\n \t  set_conv_libfunc (ufloat_optab, mode, SImode, \"__gcc_utoq\");\n \t}\n-\n-      if (!(TARGET_HARD_FLOAT && TARGET_FPRS))\n-\tset_optab_libfunc (unord_optab, mode, \"__gcc_qunord\");\n     }\n   else\n     {\n@@ -24593,187 +24582,9 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n   /* First, the compare.  */\n   compare_result = gen_reg_rtx (comp_mode);\n \n-  /* E500 FP compare instructions on the GPRs.  Yuck!  */\n-  if ((!TARGET_FPRS && TARGET_HARD_FLOAT)\n-      && FLOAT_MODE_P (mode))\n-    {\n-      rtx cmp, or_result, compare_result2;\n-      machine_mode op_mode = GET_MODE (op0);\n-      bool reverse_p;\n-\n-      if (op_mode == VOIDmode)\n-\top_mode = GET_MODE (op1);\n-\n-      /* First reverse the condition codes that aren't directly supported.  */\n-      switch (code)\n-\t{\n-\t  case NE:\n-\t  case UNLT:\n-\t  case UNLE:\n-\t  case UNGT:\n-\t  case UNGE:\n-\t    code = reverse_condition_maybe_unordered (code);\n-\t    reverse_p = true;\n-\t    break;\n-\n-\t  case EQ:\n-\t  case LT:\n-\t  case LE:\n-\t  case GT:\n-\t  case GE:\n-\t    reverse_p = false;\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-\t}\n-\n-      /* The E500 FP compare instructions toggle the GT bit (CR bit 1) only.\n-\t This explains the following mess.  */\n-\n-      switch (code)\n-\t{\n-\tcase EQ:\n-\t  switch (op_mode)\n-\t    {\n-\t    case SFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsfeq_gpr (compare_result, op0, op1)\n-\t\t: gen_cmpsfeq_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    case DFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdfeq_gpr (compare_result, op0, op1)\n-\t\t: gen_cmpdfeq_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttfeq_gpr (compare_result, op0, op1)\n-\t\t: gen_cmptfeq_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\n-\tcase GT:\n-\tcase GE:\n-\t  switch (op_mode)\n-\t    {\n-\t    case SFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsfgt_gpr (compare_result, op0, op1)\n-\t\t: gen_cmpsfgt_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    case DFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdfgt_gpr (compare_result, op0, op1)\n-\t\t: gen_cmpdfgt_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttfgt_gpr (compare_result, op0, op1)\n-\t\t: gen_cmptfgt_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\n-\tcase LT: \n-\tcase LE:\n-\t  switch (op_mode)\n-\t    {\n-\t    case SFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsflt_gpr (compare_result, op0, op1)\n-\t\t: gen_cmpsflt_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    case DFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdflt_gpr (compare_result, op0, op1)\n-\t\t: gen_cmpdflt_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttflt_gpr (compare_result, op0, op1)\n-\t\t: gen_cmptflt_gpr (compare_result, op0, op1);\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\n-        default:\n-          gcc_unreachable ();\n-\t}\n-\n-      /* Synthesize LE and GE from LT/GT || EQ.  */\n-      if (code == LE || code == GE)\n-\t{\n-\t  emit_insn (cmp);\n-\n-\t  compare_result2 = gen_reg_rtx (CCFPmode);\n-\n-\t  /* Do the EQ.  */\n-\t  switch (op_mode)\n-\t    {\n-\t    case SFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsfeq_gpr (compare_result2, op0, op1)\n-\t\t: gen_cmpsfeq_gpr (compare_result2, op0, op1);\n-\t      break;\n-\n-\t    case DFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdfeq_gpr (compare_result2, op0, op1)\n-\t\t: gen_cmpdfeq_gpr (compare_result2, op0, op1);\n-\t      break;\n-\n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n-\t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttfeq_gpr (compare_result2, op0, op1)\n-\t\t: gen_cmptfeq_gpr (compare_result2, op0, op1);\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\n-\t  emit_insn (cmp);\n-\n-\t  /* OR them together.  */\n-\t  or_result = gen_reg_rtx (CCFPmode);\n-\t  cmp = gen_e500_cr_ior_compare (or_result, compare_result,\n-\t\t\t\t\t compare_result2);\n-\t  compare_result = or_result;\n-\t}\n-\n-      code = reverse_p ? NE : EQ;\n-\n-      emit_insn (cmp);\n-    }\n-\n   /* IEEE 128-bit support in VSX registers when we do not have hardware\n      support.  */\n-  else if (!TARGET_FLOAT128_HW && FLOAT128_VECTOR_P (mode))\n+  if (!TARGET_FLOAT128_HW && FLOAT128_VECTOR_P (mode))\n     {\n       rtx libfunc = NULL_RTX;\n       bool check_nan = false;\n@@ -24890,7 +24701,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t CLOBBERs to match cmptf_internal2 pattern.  */\n       if (comp_mode == CCFPmode && TARGET_XL_COMPAT\n \t  && FLOAT128_IBM_P (GET_MODE (op0))\n-\t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t  && TARGET_HARD_FLOAT)\n \temit_insn (gen_rtx_PARALLEL (VOIDmode,\n \t  gen_rtvec (10,\n \t\t     gen_rtx_SET (compare_result,\n@@ -24925,7 +24736,6 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n   if (FLOAT_MODE_P (mode)\n       && (!FLOAT128_IEEE_P (mode) || TARGET_FLOAT128_HW)\n       && !flag_finite_math_only\n-      && !(TARGET_HARD_FLOAT && !TARGET_FPRS)\n       && (code == LE || code == GE\n \t  || code == UNEQ || code == LTGT\n \t  || code == UNGT || code == UNLT))\n@@ -25287,23 +25097,6 @@ rs6000_emit_sCOND (machine_mode mode, rtx operands[])\n   condition_rtx = rs6000_generate_compare (operands[1], mode);\n   cond_code = GET_CODE (condition_rtx);\n \n-  if (FLOAT_MODE_P (mode)\n-      && !TARGET_FPRS && TARGET_HARD_FLOAT)\n-    {\n-      rtx t;\n-\n-      PUT_MODE (condition_rtx, SImode);\n-      t = XEXP (condition_rtx, 0);\n-\n-      gcc_assert (cond_code == NE || cond_code == EQ);\n-\n-      if (cond_code == NE)\n-\temit_insn (gen_e500_flip_gt_bit (t, t));\n-\n-      emit_insn (gen_move_from_CR_gt_bit (result, t));\n-      return;\n-    }\n-\n   if (cond_code == NE\n       || cond_code == GE || cond_code == LE\n       || cond_code == GEU || cond_code == LEU\n@@ -25394,26 +25187,6 @@ output_cbranch (rtx op, const char *label, int reversed, rtx_insn *insn)\n \tcode = reverse_condition (code);\n     }\n \n-  if ((!TARGET_FPRS && TARGET_HARD_FLOAT) && mode == CCFPmode)\n-    {\n-      /* The efscmp/tst* instructions twiddle bit 2, which maps nicely\n-\t to the GT bit.  */\n-      switch (code)\n-\t{\n-\tcase EQ:\n-\t  /* Opposite of GT.  */\n-\t  code = GT;\n-\t  break;\n-\n-\tcase NE:\n-\t  code = UNLE;\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n   switch (code)\n     {\n       /* Not all of these are actually distinct opcodes, but\n@@ -25937,9 +25710,6 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n \treturn rs6000_emit_int_cmove (dest, op, true_cond, false_cond);\n       return 0;\n     }\n-  else if (TARGET_HARD_FLOAT && !TARGET_FPRS\n-\t   && SCALAR_FLOAT_MODE_P (compare_mode))\n-    return 0;\n \n   is_against_zero = op1 == CONST0_RTX (compare_mode);\n \n@@ -36643,9 +36413,9 @@ rs6000_elf_file_end (void)\n     {\n       int fp;\n \n-      if (TARGET_DF_FPR | TARGET_DF_SPE)\n+      if (TARGET_DF_FPR)\n \tfp = 1;\n-      else if (TARGET_SF_FPR | TARGET_SF_SPE)\n+      else if (TARGET_SF_FPR)\n \tfp = 3;\n       else\n \tfp = 2;\n@@ -37716,8 +37486,7 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t  *total = COSTS_N_INSNS (1);\n \t  return true;\n \t}\n-      else if (FLOAT_MODE_P (mode)\n-\t       && TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS)\n+      else if (FLOAT_MODE_P (mode) && TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT)\n \t{\n \t  *total = rs6000_cost->fp;\n \t  return false;\n@@ -38855,7 +38624,7 @@ rs6000_complex_function_value (machine_mode mode)\n \t  || (mode == TCmode && TARGET_IEEEQUAD)))\n     regno = ALTIVEC_ARG_RETURN;\n \n-  else if (FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+  else if (FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT)\n     regno = FP_ARG_RETURN;\n \n   else\n@@ -38976,10 +38745,10 @@ rs6000_function_value (const_tree valtype,\n       || POINTER_TYPE_P (valtype))\n     mode = TARGET_32BIT ? SImode : DImode;\n \n-  if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+  if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT)\n     /* _Decimal128 must use an even/odd register pair.  */\n     regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n-  else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS\n+  else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT\n \t   && !FLOAT128_VECTOR_P (mode)\n \t   && ((TARGET_SINGLE_FLOAT && (mode == SFmode)) || TARGET_DOUBLE_FLOAT))\n     regno = FP_ARG_RETURN;\n@@ -39014,11 +38783,11 @@ rs6000_libcall_value (machine_mode mode)\n   if (TARGET_32BIT && TARGET_POWERPC64 && mode == DImode)\n     return rs6000_parallel_return (mode, 2, SImode, GP_ARG_RETURN, 1);\n \n-  if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+  if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT)\n     /* _Decimal128 must use an even/odd register pair.  */\n     regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n   else if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode)\n-\t   && TARGET_HARD_FLOAT && TARGET_FPRS\n+\t   && TARGET_HARD_FLOAT\n            && ((TARGET_SINGLE_FLOAT && mode == SFmode) || TARGET_DOUBLE_FLOAT))\n     regno = FP_ARG_RETURN;\n   /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same\n@@ -39064,7 +38833,7 @@ rs6000_compute_pressure_classes (enum reg_class *pressure_classes)\n     {\n       if (TARGET_ALTIVEC)\n \tpressure_classes[n++] = ALTIVEC_REGS;\n-      if (TARGET_HARD_FLOAT && TARGET_FPRS)\n+      if (TARGET_HARD_FLOAT)\n \tpressure_classes[n++] = FLOAT_REGS;\n     }\n   pressure_classes[n++] = CR_REGS;\n@@ -44008,7 +43777,7 @@ static tree atomic_hold_decl, atomic_clear_decl, atomic_update_decl;\n static void\n rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n {\n-  if (!TARGET_HARD_FLOAT || !TARGET_FPRS)\n+  if (!TARGET_HARD_FLOAT)\n     {\n #ifdef RS6000_GLIBC_ATOMIC_FENV\n       if (atomic_hold_decl == NULL_TREE)"}, {"sha": "dec1ab7f625c339e0adc85f2b08ddffa953fdb71", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -449,8 +449,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define FLOAT128_IBM_P(MODE)\t\t\t\t\t\t\\\n   ((!TARGET_IEEEQUAD && ((MODE) == TFmode || (MODE) == TCmode))\t\t\\\n-   || (TARGET_HARD_FLOAT && TARGET_FPRS\t\t\t\t\t\\\n-       && ((MODE) == IFmode || (MODE) == ICmode)))\n+   || (TARGET_HARD_FLOAT && ((MODE) == IFmode || (MODE) == ICmode)))\n \n /* Helper macros to say whether a 128-bit floating point type can go in a\n    single vector register, or whether it needs paired scalar values.  */\n@@ -573,7 +572,6 @@ extern int rs6000_vector_align[];\n #define TARGET_SPE_ABI 0\n #define TARGET_SPE 0\n #define TARGET_ISEL64 (TARGET_ISEL && TARGET_POWERPC64)\n-#define TARGET_FPRS 1\n #define TARGET_E500_SINGLE 0\n #define TARGET_E500_DOUBLE 0\n #define CHECK_E500_OPTIONS do { } while (0)\n@@ -724,39 +722,26 @@ extern int rs6000_vector_align[];\n \t\t\t  || rs6000_cpu == PROCESSOR_PPC8548)\n \n \n-/* Whether SF/DF operations are supported on the E500.  */\n-#define TARGET_SF_SPE\t(TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\t\\\n-\t\t\t && !TARGET_FPRS)\n-\n-#define TARGET_DF_SPE\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\t\\\n-\t\t\t && !TARGET_FPRS && TARGET_E500_DOUBLE)\n-\n /* Whether SF/DF operations are supported by the normal floating point unit\n    (or the vector/scalar unit).  */\n-#define TARGET_SF_FPR\t(TARGET_HARD_FLOAT && TARGET_FPRS\t\t\\\n-\t\t\t && TARGET_SINGLE_FLOAT)\n-\n-#define TARGET_DF_FPR\t(TARGET_HARD_FLOAT && TARGET_FPRS\t\t\\\n-\t\t\t && TARGET_DOUBLE_FLOAT)\n+#define TARGET_SF_FPR\t(TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT)\n+#define TARGET_DF_FPR\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n \n /* Whether SF/DF operations are supported by any hardware.  */\n-#define TARGET_SF_INSN\t(TARGET_SF_FPR || TARGET_SF_SPE)\n-#define TARGET_DF_INSN\t(TARGET_DF_FPR || TARGET_DF_SPE)\n+#define TARGET_SF_INSN\tTARGET_SF_FPR\n+#define TARGET_DF_INSN\tTARGET_DF_FPR\n \n /* Which machine supports the various reciprocal estimate instructions.  */\n #define TARGET_FRES\t(TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT \\\n-\t\t\t && TARGET_FPRS && TARGET_SINGLE_FLOAT)\n+\t\t\t && TARGET_SINGLE_FLOAT)\n \n-#define TARGET_FRE\t(TARGET_HARD_FLOAT && TARGET_FPRS \\\n-\t\t\t && TARGET_DOUBLE_FLOAT \\\n+#define TARGET_FRE\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT \\\n \t\t\t && (TARGET_POPCNTB || VECTOR_UNIT_VSX_P (DFmode)))\n \n #define TARGET_FRSQRTES\t(TARGET_HARD_FLOAT && TARGET_POPCNTB \\\n-\t\t\t && TARGET_PPC_GFXOPT && TARGET_FPRS \\\n-\t\t\t && TARGET_SINGLE_FLOAT)\n+\t\t\t && TARGET_PPC_GFXOPT && TARGET_SINGLE_FLOAT)\n \n-#define TARGET_FRSQRTE\t(TARGET_HARD_FLOAT && TARGET_FPRS \\\n-\t\t\t && TARGET_DOUBLE_FLOAT \\\n+#define TARGET_FRSQRTE\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT \\\n \t\t\t && (TARGET_PPC_GFXOPT || VECTOR_UNIT_VSX_P (DFmode)))\n \n /* Conditions to allow TOC fusion for loading/storing integers.  */\n@@ -771,7 +756,6 @@ extern int rs6000_vector_align[];\n \t\t\t\t && (TARGET_CMODEL != CMODEL_SMALL)\t\\\n \t\t\t\t && TARGET_POWERPC64\t\t\t\\\n \t\t\t\t && TARGET_HARD_FLOAT\t\t\t\\\n-\t\t\t\t && TARGET_FPRS\t\t\t\t\\\n \t\t\t\t && TARGET_SINGLE_FLOAT\t\t\t\\\n \t\t\t\t && TARGET_DOUBLE_FLOAT)\n \n@@ -1875,7 +1859,7 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define FUNCTION_VALUE_REGNO_P(N)\t\t\t\t\t\\\n   ((N) == GP_ARG_RETURN\t\t\t\t\t\t\t\\\n    || (IN_RANGE ((N), FP_ARG_RETURN, FP_ARG_MAX_RETURN)\t\t\t\\\n-       && TARGET_HARD_FLOAT && TARGET_FPRS)\t\t\t\t\\\n+       && TARGET_HARD_FLOAT)\t\t\t\t\t\t\\\n    || (IN_RANGE ((N), ALTIVEC_ARG_RETURN, ALTIVEC_ARG_MAX_RETURN)\t\\\n        && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI))\n \n@@ -1887,7 +1871,7 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n    || (IN_RANGE ((N), ALTIVEC_ARG_MIN_REG, ALTIVEC_ARG_MAX_REG)\t\t\\\n        && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)\t\t\t\t\\\n    || (IN_RANGE ((N), FP_ARG_MIN_REG, FP_ARG_MAX_REG)\t\t\t\\\n-       && TARGET_HARD_FLOAT && TARGET_FPRS))\n+       && TARGET_HARD_FLOAT))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should"}, {"sha": "210077de2186912eba11355b665808806ae7c91a", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 98, "deletions": 164, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -372,22 +372,18 @@\n \n ; Any hardware-supported floating-point mode\n (define_mode_iterator FP [\n-  (SF \"TARGET_HARD_FLOAT \n-   && ((TARGET_FPRS && TARGET_SINGLE_FLOAT) || TARGET_E500_SINGLE)\")\n-  (DF \"TARGET_HARD_FLOAT \n-   && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\")\n-  (TF \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\")\n-  (IF \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\")\n+  (SF \"TARGET_HARD_FLOAT && (TARGET_SINGLE_FLOAT || TARGET_E500_SINGLE)\")\n+  (DF \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\")\n+  (TF \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\")\n+  (IF \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\")\n   (KF \"TARGET_FLOAT128_TYPE\")\n   (DD \"TARGET_DFP\")\n   (TD \"TARGET_DFP\")])\n \n ; Any fma capable floating-point mode.\n (define_mode_iterator FMA_F [\n-  (SF \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\")\n-  (DF \"(TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n+  (SF \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\")\n+  (DF \"(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n        || VECTOR_UNIT_VSX_P (DFmode)\")\n   (V2SF \"TARGET_PAIRED_FLOAT\")\n   (V4SF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\")\n@@ -402,11 +398,11 @@\n (define_mode_iterator FMOVE64X [DI DF DD])\n (define_mode_iterator FMOVE128 [(TF \"TARGET_LONG_DOUBLE_128\")\n \t\t\t\t(IF \"FLOAT128_IBM_P (IFmode)\")\n-\t\t\t\t(TD \"TARGET_HARD_FLOAT && TARGET_FPRS\")])\n+\t\t\t\t(TD \"TARGET_HARD_FLOAT\")])\n \n (define_mode_iterator FMOVE128_FPR [(TF \"FLOAT128_2REG_P (TFmode)\")\n \t\t\t\t    (IF \"FLOAT128_2REG_P (IFmode)\")\n-\t\t\t\t    (TD \"TARGET_HARD_FLOAT && TARGET_FPRS\")])\n+\t\t\t\t    (TD \"TARGET_HARD_FLOAT\")])\n \n ; Iterators for 128 bit types for direct move\n (define_mode_iterator FMOVE128_GPR [(TI    \"TARGET_VSX_TIMODE\")\n@@ -426,7 +422,7 @@\n ; Whether a floating point move is ok, don't allow SD without hardware FP\n (define_mode_attr fmove_ok [(SF \"\")\n \t\t\t    (DF \"\")\n-\t\t\t    (SD \"TARGET_HARD_FLOAT && TARGET_FPRS\")\n+\t\t\t    (SD \"TARGET_HARD_FLOAT\")\n \t\t\t    (DD \"\")])\n \n ; Convert REAL_VALUE to the appropriate bits\n@@ -618,7 +614,7 @@\n (define_mode_attr SI_CONVERT_FP [(SF \"TARGET_FCFIDS\")\n \t\t\t\t (DF \"TARGET_FCFID\")])\n \n-(define_mode_attr E500_CONVERT [(SF \"!TARGET_FPRS\")\n+(define_mode_attr E500_CONVERT [(SF \"0\")\n \t\t\t\t(DF \"TARGET_E500_DOUBLE\")])\n \n (define_mode_attr TARGET_FLOAT [(SF \"TARGET_SINGLE_FLOAT\")\n@@ -4650,7 +4646,7 @@\n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\")\n \t(float_extend:DF (match_operand:SF 1 \"reg_or_none500mem_operand\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n {\n   if (HONOR_SNANS (SFmode))\n     operands[1] = force_reg (SFmode, operands[1]);\n@@ -4659,8 +4655,7 @@\n (define_insn_and_split \"*extendsfdf2_fpr\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d,ws,?ws,wu,wb\")\n \t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\" \"0,f,m,0,wy,Z,wY\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !HONOR_SNANS (SFmode)\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !HONOR_SNANS (SFmode)\"\n   \"@\n    #\n    fmr %0,%1\n@@ -4680,8 +4675,7 @@\n (define_insn \"*extendsfdf2_snan\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float_extend:DF (match_operand:SF 1 \"gpc_reg_operand\" \"f,wy\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && HONOR_SNANS (SFmode)\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && HONOR_SNANS (SFmode)\"\n   \"@\n    frsp %0,%1\n    xsrsp %x0,%x1\"\n@@ -4690,13 +4684,13 @@\n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:SF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n   \"\")\n \n (define_insn \"*truncdfsf2_fpr\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy\")\n \t(float_truncate:SF (match_operand:DF 1 \"gpc_reg_operand\" \"d,ws\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"@\n    frsp %0,%1\n    xsrsp %x0,%x1\"\n@@ -4715,7 +4709,6 @@\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n   \t(match_dup 6))]\n   \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && (!FLOAT128_IEEE_P (<MODE>mode)\n        || (TARGET_POWERPC64 && TARGET_DIRECT_MOVE))\"\n {\n@@ -4757,7 +4750,7 @@\n \t\t\t       (match_dup 5))\n \t\t\t (match_dup 3)\n \t\t\t (match_dup 4)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n+  \"TARGET_HARD_FLOAT && <TARGET_FLOAT>\n    && ((TARGET_PPC_GFXOPT\n         && !HONOR_NANS (<MODE>mode)\n         && !HONOR_SIGNED_ZEROS (<MODE>mode))\n@@ -5096,7 +5089,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,wj,wK\")\n \t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r,wK\")]\n \t\t   UNSPEC_LFIWAX))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\"\n   \"@\n    lfiwax %0,%y1\n    lxsiwax %x0,%y1\n@@ -5113,7 +5106,7 @@\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n    && <SI_CONVERT_FP> && can_create_pseudo_p ()\"\n   \"#\"\n   \"\"\n@@ -5156,8 +5149,7 @@\n \t (sign_extend:DI\n \t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\"))))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n-   && <SI_CONVERT_FP>\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX && <SI_CONVERT_FP>\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5180,7 +5172,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,wj,wJwK\")\n \t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r,wJwK\")]\n \t\t   UNSPEC_LFIWZX))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\"\n   \"@\n    lfiwzx %0,%y1\n    lxsiwzx %x0,%y1\n@@ -5192,8 +5184,7 @@\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(unsigned_float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n-   && <SI_CONVERT_FP>\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX && <SI_CONVERT_FP>\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5235,8 +5226,7 @@\n \t (zero_extend:DI\n \t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\"))))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n-   && <SI_CONVERT_FP>\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX && <SI_CONVERT_FP>\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5268,8 +5258,7 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n \t      (clobber (match_dup 6))])]\n-  \"TARGET_HARD_FLOAT \n-   && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n   \"\n {\n   if (TARGET_E500_DOUBLE)\n@@ -5311,7 +5300,7 @@\n    (clobber (match_operand:DF 4 \"offsettable_mem_operand\" \"=o\"))\n    (clobber (match_operand:DF 5 \"gpc_reg_operand\" \"=&d\"))\n    (clobber (match_operand:SI 6 \"gpc_reg_operand\" \"=&r\"))]\n-  \"! TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"! TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5342,19 +5331,12 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n         (unsigned_float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && (!TARGET_FPRS\n-       || (TARGET_FPRS\n-\t   && ((TARGET_FCFIDUS && TARGET_LFIWZX)\n-\t       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n-\t\t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))))\"\n+   && ((TARGET_FCFIDUS && TARGET_LFIWZX)\n+       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n+\t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))\"\n   \"\n {\n-  if (!TARGET_FPRS)\n-    {\n-      if (!REG_P (operands[1]))\n-\toperands[1] = force_reg (SImode, operands[1]);\n-    }\n-  else if (TARGET_LFIWZX && TARGET_FCFIDUS)\n+  if (TARGET_LFIWZX && TARGET_FCFIDUS)\n     {\n       emit_insn (gen_floatunssisf2_lfiwzx (operands[0], operands[1]));\n       DONE;\n@@ -5377,8 +5359,7 @@\n \t      (use (match_dup 3))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])]\n-  \"TARGET_HARD_FLOAT\n-   && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n   \"\n {\n   if (TARGET_E500_DOUBLE)\n@@ -5418,7 +5399,7 @@\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"d\"))\n    (clobber (match_operand:DF 4 \"offsettable_mem_operand\" \"=o\"))\n    (clobber (match_operand:DF 5 \"gpc_reg_operand\" \"=&d\"))]\n-  \"! TARGET_FCFIDU && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+  \"! TARGET_FCFIDU && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && !(TARGET_FCFID && TARGET_POWERPC64)\"\n   \"#\"\n   \"\"\n@@ -5551,7 +5532,7 @@\n (define_expand \"fix_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && <TARGET_FLOAT>) || <E500_CONVERT>)\"\n+  \"TARGET_HARD_FLOAT && (<TARGET_FLOAT> || <E500_CONVERT>)\"\n   \"\n {\n   if (!<E500_CONVERT> && !TARGET_VSX_SMALL_INTEGER)\n@@ -5578,7 +5559,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && (<MODE>mode != SFmode || TARGET_SINGLE_FLOAT)\n    && TARGET_STFIWX && can_create_pseudo_p ()\n    && !TARGET_VSX_SMALL_INTEGER\"\n@@ -5622,8 +5603,7 @@\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d,<rreg>\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=1,d\"))\n    (clobber (match_operand:DI 3 \"offsettable_mem_operand\" \"=o,o\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !TARGET_VSX_SMALL_INTEGER\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5644,15 +5624,13 @@\n (define_expand \"fix_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n-   && TARGET_FCFID\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCFID\"\n   \"\")\n \n (define_insn \"*fix_trunc<mode>di2_fctidz\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n \t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n-    && TARGET_FCFID\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCFID\"\n   \"@\n    fctidz %0,%1\n    xscvdpsxds %x0,%x1\"\n@@ -5703,8 +5681,7 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\n-   && ((TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ && TARGET_STFIWX)\n-       || <E500_CONVERT>)\"\n+   && ((<TARGET_FLOAT> && TARGET_FCTIWUZ && TARGET_STFIWX) || <E500_CONVERT>)\"\n   \"\n {\n   if (!<E500_CONVERT> && !TARGET_VSX_SMALL_INTEGER)\n@@ -5718,7 +5695,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\n+  \"TARGET_HARD_FLOAT && <TARGET_FLOAT> && TARGET_FCTIWUZ\n    && TARGET_STFIWX && can_create_pseudo_p ()\n    && !TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n@@ -5759,7 +5736,7 @@\n (define_insn \"fixuns_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n \t(unsigned_fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS && TARGET_FCTIDUZ\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCTIDUZ\"\n   \"@\n    fctiduz %0,%1\n    xscvdpuxds %x0,%x1\"\n@@ -5812,8 +5789,7 @@\n (define_insn \"*fctiw<u>z_<mode>_smallint\"\n   [(set (match_operand:SI 0 \"vsx_register_operand\" \"=d,wi\")\n \t(any_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && TARGET_VSX_SMALL_INTEGER\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_VSX_SMALL_INTEGER\"\n   \"@\n    fctiw<u>z %0,%1\n    xscvdp<su>xws %x0,%x1\"\n@@ -5825,8 +5801,7 @@\n   [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n \t(any_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"wa\")))\n    (clobber (match_scratch:SI 2 \"=wa\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && TARGET_VSX_SMALL_INTEGER\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -5843,7 +5818,7 @@\n \t(unspec:DI [(fix:SI\n \t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n \t\t   UNSPEC_FCTIWZ))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"@\n    fctiwz %0,%1\n    xscvdpsxws %x0,%x1\"\n@@ -5854,7 +5829,7 @@\n \t(unspec:DI [(unsigned_fix:SI\n \t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n \t\t   UNSPEC_FCTIWUZ))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\"\n+  \"TARGET_HARD_FLOAT && <TARGET_FLOAT> && TARGET_FCTIWUZ\"\n   \"@\n    fctiwuz %0,%1\n    xscvdpuxws %x0,%x1\"\n@@ -5866,7 +5841,7 @@\n (define_insn \"*friz\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float:DF (fix:DI (match_operand:DF 1 \"gpc_reg_operand\" \"d,ws\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_FPRND\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRND\n    && flag_unsafe_math_optimizations && !flag_trapping_math && TARGET_FRIZ\"\n   \"@\n    friz %0,%1\n@@ -5885,7 +5860,7 @@\n \t (fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))))\n    (clobber (match_scratch:DI 2 \"=d\"))\n    (clobber (match_scratch:DI 3 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && <SI_CONVERT_FP> && TARGET_LFIWAX && TARGET_STFIWX && TARGET_FCFID\n    && !TARGET_DIRECT_MOVE && can_create_pseudo_p ()\"\n   \"#\"\n@@ -5918,7 +5893,7 @@\n \t (unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))))\n    (clobber (match_scratch:DI 2 \"=d\"))\n    (clobber (match_scratch:DI 3 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && TARGET_LFIWZX && TARGET_STFIWX && TARGET_FCFIDU && !TARGET_DIRECT_MOVE\n    && can_create_pseudo_p ()\"\n   \"#\"\n@@ -6038,19 +6013,12 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n         (float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && (!TARGET_FPRS\n-       || (TARGET_FPRS\n-\t   && ((TARGET_FCFIDS && TARGET_LFIWAX)\n-\t       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n-\t\t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))))\"\n+   && ((TARGET_FCFIDS && TARGET_LFIWAX)\n+       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n+\t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))\"\n   \"\n {\n-  if (!TARGET_FPRS)\n-    {\n-      if (!REG_P (operands[1]))\n-\toperands[1] = force_reg (SImode, operands[1]);\n-    }\n-  else if (TARGET_FCFIDS && TARGET_LFIWAX)\n+  if (TARGET_FCFIDS && TARGET_LFIWAX)\n     {\n       emit_insn (gen_floatsisf2_lfiwax (operands[0], operands[1]));\n       DONE;\n@@ -6073,16 +6041,10 @@\n     }\n }\")\n \n-(define_expand \"floatdidf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\"\n-  \"\")\n-\n-(define_insn \"*floatdidf2_fpr\"\n+(define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"@\n    fcfid %0,%1\n    xscvsxddp %x0,%x1\"\n@@ -6097,7 +6059,7 @@\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float:DF (match_operand:DI 1 \"memory_operand\" \"m,Z\")))\n    (clobber (match_scratch:DI 2 \"=d,wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS && TARGET_FCFID\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCFID\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2) (match_dup 1))\n@@ -6139,7 +6101,7 @@\n (define_expand \"floatdisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && (TARGET_FCFIDS || TARGET_POWERPC64 || flag_unsafe_math_optimizations)\"\n   \"\n {\n@@ -6161,7 +6123,7 @@\n (define_insn \"floatdisf2_fcfids\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy\")\n \t(float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n   \"@\n    fcfids %0,%1\n@@ -6172,7 +6134,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy,wy\")\n \t(float:SF (match_operand:DI 1 \"memory_operand\" \"m,m,Z\")))\n    (clobber (match_scratch:DI 2 \"=d,d,wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -6193,8 +6155,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n-   && !TARGET_FCFIDS\"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT && !TARGET_FCFIDS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -6229,7 +6190,7 @@\n \t\t\t   (label_ref (match_operand:DI 2 \"\" \"\"))\n \t\t\t   (pc)))\n    (set (match_dup 0) (match_dup 1))]\n-  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && !TARGET_FCFIDS\"\n   \"\n {\n@@ -6240,14 +6201,14 @@\n (define_expand \"floatunsdisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n         (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n   \"\")\n \n (define_insn \"floatunsdisf2_fcfidus\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wu\")\n         (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n   \"@\n    fcfidus %0,%1\n@@ -6258,7 +6219,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy,wy\")\n \t(unsigned_float:SF (match_operand:DI 1 \"memory_operand\" \"m,m,Z\")))\n    (clobber (match_scratch:DI 2 \"=d,d,wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -7209,7 +7170,7 @@\n \t  r,         r,         *h,         0\"))]\n   \"(register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode))\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && (TARGET_ALLOW_SF_SUBREG\n        || valid_sf_si_move (operands[0], operands[1], SFmode))\"\n   \"@\n@@ -7245,7 +7206,7 @@\n \t  f,         r,         r,         *h,        0\"))]\n   \"(register_operand (operands[0], SDmode)\n    || register_operand (operands[1], SDmode))\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+   && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\"\n   \"@\n    lwz%U1%X1 %0,%1\n    lfiwzx %0,%y1\n@@ -7267,7 +7228,7 @@\n \t(match_operand:FMOVE32 1 \"input_operand\" \"r,r,h,m,r,I,L,G,Fn,0\"))]\n   \"(gpc_reg_operand (operands[0], <MODE>mode)\n    || gpc_reg_operand (operands[1], <MODE>mode))\n-   && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\"\n+   && TARGET_SOFT_FLOAT\"\n   \"@\n    mr %0,%1\n    mt%0 %1\n@@ -7446,7 +7407,7 @@\n (define_insn \"*mov<mode>_hardfloat32\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_p9>,wY,<f64_vsx>,<f64_vsx>,!r,Y,r,!r\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,wY,<f64_p9>,<f64_vsx>,<zero_fp>,<zero_fp>,r,Y,r\"))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT \n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n@@ -7471,8 +7432,7 @@\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"r,Y,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 \n-   && ((TARGET_FPRS && TARGET_SINGLE_FLOAT) \n-       || TARGET_SOFT_FLOAT || TARGET_E500_SINGLE\n+   && (TARGET_SINGLE_FLOAT || TARGET_SOFT_FLOAT || TARGET_E500_SINGLE\n        || (<MODE>mode == DDmode && TARGET_E500_DOUBLE))\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -7485,7 +7445,7 @@\n (define_insn \"*mov<mode>_hardfloat64\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_p9>,wY,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r,*c*l,!r,*h,r,wg,r,<f64_dm>\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,wY,<f64_p9>,Z,<f64_av>,<f64_vsx>,<zero_fp>,<zero_fp>,r,Y,r,r,h,0,wg,r,<f64_dm>,r\"))]\n-  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n@@ -7516,7 +7476,7 @@\n (define_insn \"*mov<mode>_softfloat64\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,cl,r,r,r,r,*h\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"r,Y,r,r,h,G,H,F,0\"))]\n-  \"TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n+  \"TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n@@ -7549,8 +7509,7 @@\n (define_insn_and_split \"*mov<mode>_64bit_dm\"\n   [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,d,Y,r,r,r,wh\")\n \t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,<zero_fp>,r,<zero_fp>Y,r,wh,r\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64\n-   && FLOAT128_2REG_P (<MODE>mode)\n+  \"TARGET_HARD_FLOAT && TARGET_POWERPC64 && FLOAT128_2REG_P (<MODE>mode)\n    && (<MODE>mode != TDmode || WORDS_BIG_ENDIAN)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -7563,7 +7522,7 @@\n (define_insn_and_split \"*movtd_64bit_nodm\"\n   [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n \t(match_operand:TD 1 \"input_operand\" \"d,m,d,r,Y,r\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64 && !WORDS_BIG_ENDIAN\n+  \"TARGET_HARD_FLOAT && TARGET_POWERPC64 && !WORDS_BIG_ENDIAN\n    && (gpc_reg_operand (operands[0], TDmode)\n        || gpc_reg_operand (operands[1], TDmode))\"\n   \"#\"\n@@ -7575,7 +7534,7 @@\n (define_insn_and_split \"*mov<mode>_32bit\"\n   [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,d,Y,r,r\")\n \t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,<zero_fp>,r,<zero_fp>Y,r\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && !TARGET_POWERPC64\n+  \"TARGET_HARD_FLOAT && !TARGET_POWERPC64\n    && (FLOAT128_2REG_P (<MODE>mode)\n        || int_reg_operand_not_pseudo (operands[0], <MODE>mode)\n        || int_reg_operand_not_pseudo (operands[1], <MODE>mode))\n@@ -7590,7 +7549,7 @@\n (define_insn_and_split \"*mov<mode>_softfloat\"\n   [(set (match_operand:FMOVE128 0 \"rs6000_nonimmediate_operand\" \"=Y,r,r\")\n \t(match_operand:FMOVE128 1 \"input_operand\" \"r,YGHF,r\"))]\n-  \"(TARGET_SOFT_FLOAT || !TARGET_FPRS)\n+  \"TARGET_SOFT_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n@@ -7602,8 +7561,7 @@\n (define_expand \"extenddf<mode>2\"\n   [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n \t(float_extend:FLOAT128 (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n@@ -7642,7 +7600,7 @@\n \t(float_extend:IBM128\n \t (match_operand:DF 1 \"nonimmediate_operand\" \"d,m,d\")))\n    (use (match_operand:DF 2 \"nonimmediate_operand\" \"m,m,d\"))]\n-  \"!TARGET_VSX && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+  \"!TARGET_VSX && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -7677,9 +7635,7 @@\n (define_expand \"extendsf<mode>2\"\n   [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n \t(float_extend:FLOAT128 (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n@@ -7695,9 +7651,7 @@\n (define_expand \"trunc<mode>df2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:DF (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     {\n@@ -7711,7 +7665,7 @@\n \t(float_truncate:DF\n \t (match_operand:IBM128 1 \"gpc_reg_operand\" \"0,d\")))]\n   \"FLOAT128_IBM_P (<MODE>mode) && !TARGET_XL_COMPAT\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"@\n    #\n    fmr %0,%1\"\n@@ -7727,17 +7681,15 @@\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n \t(float_truncate:DF (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))]\n   \"FLOAT128_IBM_P (<MODE>mode) && TARGET_XL_COMPAT && TARGET_HARD_FLOAT\n-   && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"fadd %0,%1,%L1\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_addsub_d\")])\n \n (define_expand \"trunc<mode>sf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:SF (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n@@ -7759,7 +7711,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(float_truncate:SF (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT \n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT \n    && TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -7773,9 +7725,7 @@\n   [(parallel [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\")\n \t\t   (float:FLOAT128 (match_operand:SI 1 \"gpc_reg_operand\")))\n \t      (clobber (match_scratch:DI 2))])]\n-  \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -7808,17 +7758,15 @@\n \t(unspec:DF [(match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")]\n \t\t   UNSPEC_FIX_TRUNC_TF))\n    (clobber (match_operand:DF 2 \"gpc_reg_operand\" \"=&d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && FLOAT128_IBM_P (<MODE>mode)\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && FLOAT128_IBM_P (<MODE>mode)\"\n   \"mffs %2\\n\\tmtfsb1 31\\n\\tmtfsb0 30\\n\\tfadd %0,%1,%L1\\n\\tmtfsf 1,%2\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"20\")])\n \n (define_expand \"fix_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE) && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -7848,7 +7796,7 @@\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   operands[2] = gen_reg_rtx (DFmode);\n   operands[3] = gen_reg_rtx (DFmode);\n@@ -7863,7 +7811,7 @@\n    (clobber (match_operand:DF 3 \"gpc_reg_operand\" \"=&d\"))\n    (clobber (match_operand:DI 4 \"gpc_reg_operand\" \"=d\"))\n    (clobber (match_operand:DI 5 \"offsettable_mem_operand\" \"=o\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -7945,9 +7893,7 @@\n   [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n \t(neg:FLOAT128 (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"FLOAT128_IEEE_P (<MODE>mode)\n-   || (FLOAT128_IBM_P (<MODE>mode)\n-       && TARGET_HARD_FLOAT\n-       && (TARGET_FPRS || TARGET_E500_DOUBLE))\"\n+   || (FLOAT128_IBM_P (<MODE>mode) && TARGET_HARD_FLOAT)\"\n   \"\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n@@ -7987,7 +7933,7 @@\n (define_insn \"neg<mode>2_internal\"\n   [(set (match_operand:IBM128 0 \"gpc_reg_operand\" \"=d\")\n \t(neg:IBM128 (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && FLOAT128_IBM_P (TFmode)\"\n+  \"TARGET_HARD_FLOAT && FLOAT128_IBM_P (TFmode)\"\n   \"*\n {\n   if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n@@ -8002,9 +7948,7 @@\n   [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n \t(abs:FLOAT128 (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"FLOAT128_IEEE_P (<MODE>mode)\n-   || (FLOAT128_IBM_P (<MODE>mode)\n-       && TARGET_HARD_FLOAT\n-       && (TARGET_FPRS || TARGET_E500_DOUBLE))\"\n+   || (FLOAT128_IBM_P (<MODE>mode) && TARGET_HARD_FLOAT)\"\n   \"\n {\n   rtx label;\n@@ -8063,8 +8007,7 @@\n \t\t\t   (label_ref (match_operand 2 \"\" \"\"))\n \t\t\t   (pc)))\n    (set (match_dup 6) (neg:DF (match_dup 6)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n-   && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"\n {\n   const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n@@ -9750,7 +9693,7 @@\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9766,7 +9709,7 @@\n \t(match_operand:SF 3 \"gpc_reg_operand\" \"f,f\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9782,7 +9725,7 @@\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SOFT_FLOAT || !TARGET_FPRS) && TARGET_UPDATE\n+  \"TARGET_SOFT_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9798,7 +9741,7 @@\n \t(match_operand:SF 3 \"gpc_reg_operand\" \"r,r\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SOFT_FLOAT || !TARGET_FPRS) && TARGET_UPDATE\n+  \"TARGET_SOFT_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9814,7 +9757,7 @@\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9831,7 +9774,7 @@\n \t(match_operand:DF 3 \"gpc_reg_operand\" \"d,d\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -12057,7 +12000,7 @@\n \t(compare:CCFP (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")\n \t\t      (match_operand:IBM128 2 \"gpc_reg_operand\" \"d\")))]\n   \"!TARGET_XL_COMPAT && FLOAT128_IBM_P (<MODE>mode)\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"fcmpu %0,%1,%2\\;bne %0,$+8\\;fcmpu %0,%L1,%L2\"\n   [(set_attr \"type\" \"fpcompare\")\n    (set_attr \"length\" \"12\")])\n@@ -12076,7 +12019,7 @@\n     (clobber (match_scratch:DF 10 \"=d\"))\n     (clobber (match_scratch:GPR 11 \"=b\"))]\n   \"TARGET_XL_COMPAT && FLOAT128_IBM_P (<MODE>mode)\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3) (match_dup 14))\n@@ -12144,15 +12087,6 @@\n \t(const_string \"mfcr\")))\n    (set_attr \"length\" \"8\")])\n \n-;; Same as above, but get the GT bit.\n-(define_insn \"move_from_CR_gt_bit\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec:SI [(match_operand 1 \"cc_reg_operand\" \"y\")] UNSPEC_MV_CR_GT))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"mfcr %0\\;rlwinm %0,%0,%D1,31,31\"\n-  [(set_attr \"type\" \"mfcr\")\n-   (set_attr \"length\" \"8\")])\n-\n ;; Same as above, but get the OV/ORDERED bit.\n (define_insn \"move_from_CR_ov_bit\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n@@ -13822,14 +13756,14 @@\n (define_insn \"rs6000_mffs\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n \t(unspec_volatile:DF [(const_int 0)] UNSPECV_MFFS))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"mffs %0\")\n \n (define_insn \"rs6000_mtfsf\"\n   [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"i\")\n \t\t     (match_operand:DF 1 \"gpc_reg_operand\" \"d\")]\n \t\t    UNSPECV_MTFSF)]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT\"\n   \"mtfsf %0,%1\")\n \n \f"}, {"sha": "b6f4e0a64855dc81c1643ede62fa2e170cb4ed5a", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -31,7 +31,6 @@\n    (TSTTFGT_GPR\t\t1015)\n    (CMPTFLT_GPR\t\t1016)\n    (TSTTFLT_GPR\t\t1017)\n-   (E500_CR_IOR_COMPARE 1018)\n    ])\n \n ;; Modes using a 64-bit register.\n@@ -43,59 +42,6 @@\n ;; DImode and TImode.\n (define_mode_iterator DITI [DI TI])\n \n-(define_insn \"*negsf2_gpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-        (neg:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsneg %0,%1\"\n-  [(set_attr \"type\" \"fpsimple\")])\n-\n-(define_insn \"*abssf2_gpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(abs:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsabs %0,%1\"\n-  [(set_attr \"type\" \"fpsimple\")])\n-\n-(define_insn \"*nabssf2_gpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:SF (abs:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\"))))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsnabs %0,%1\"\n-  [(set_attr \"type\" \"fpsimple\")])\n-\n-(define_insn \"*addsf3_gpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(plus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%r\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsadd %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*subsf3_gpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(minus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efssub %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*mulsf3_gpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-        (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%r\")\n-                 (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsmul %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*divsf3_gpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-        (div:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-                (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsdiv %0,%1,%2\"\n-  [(set_attr \"type\" \"vecfdiv\")])\n-\n ;; Floating point conversion instructions.\n \n (define_insn \"spe_fixuns_truncdfsi2\"\n@@ -112,48 +58,20 @@\n   \"efdcfs %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"spe_fixuns_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unsigned_fix:SI (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsctuiz %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"spe_fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efsctsiz %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n (define_insn \"spe_fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n   \"efdctsiz %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"spe_floatunssisf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-        (unsigned_float:SF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efscfui %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n (define_insn \"spe_floatunssidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n         (unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n   \"efdcfui %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"spe_floatsisf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-        (float:SF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"efscfsi %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n (define_insn \"spe_floatsidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n \t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n@@ -3233,88 +3151,10 @@\n   \"mfspefscr %0\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n-;; Flip the GT bit.\n-(define_insn \"e500_flip_gt_bit\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(match_operand:CCFP 1 \"cc_reg_operand\" \"y\")] 999))]\n-  \"!TARGET_FPRS && TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  return output_e500_flip_gt_bit (operands[0], operands[1]);\n-}\"\n-  [(set_attr \"type\" \"cr_logical\")])\n-\n ;; MPC8540 single-precision FP instructions on GPRs.\n ;; We have 2 variants for each.  One for IEEE compliant math and one\n ;; for non IEEE compliant math.\n \n-(define_insn \"cmpsfeq_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n-\t 1000))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efscmpeq %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmp\")])\n-\n-(define_insn \"tstsfeq_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n-\t 1001))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efststeq %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmpsimple\")])\n-\n-(define_insn \"cmpsfgt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n-\t 1002))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efscmpgt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmp\")])\n-\n-(define_insn \"tstsfgt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n-\t 1003))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efststgt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmpsimple\")])\n-\n-(define_insn \"cmpsflt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n-\t 1004))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efscmplt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmp\")])\n-\n-(define_insn \"tstsflt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n-\t 1005))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efststlt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmpsimple\")])\n-\n ;; Same thing, but for double-precision.\n \n (define_insn \"cmpdfeq_gpr\"\n@@ -3463,16 +3303,6 @@\n   [(set_attr \"type\" \"veccmpsimple\")\n    (set_attr \"length\" \"20\")])\n \n-;; Like cceq_ior_compare, but compare the GT bits.\n-(define_insn \"e500_cr_ior_compare\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP [(match_operand 1 \"cc_reg_operand\" \"y\")\n-\t\t      (match_operand 2 \"cc_reg_operand\" \"y\")]\n-\t\t     E500_CR_IOR_COMPARE))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"cror 4*%0+gt,4*%1+gt,4*%2+gt\"\n-  [(set_attr \"type\" \"cr_logical\")])\n-\n ;; Out-of-line prologues and epilogues.\n (define_insn \"*save_gpregs_spe\"\n   [(match_parallel 0 \"any_parallel_operand\""}, {"sha": "141aa4237c3eb4ec695a0ff14a9f5eb1ad5c15d9", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8d07e31ce544fed5d4f2d2b4526b19672b558/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=11d8d07e31ce544fed5d4f2d2b4526b19672b558", "patch": "@@ -1984,7 +1984,7 @@\n \t(float:V2DF\n \t (fix:V2DI\n \t  (match_operand:V2DF 1 \"vsx_register_operand\" \"wd,?wa\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && VECTOR_UNIT_VSX_P (V2DFmode) && flag_unsafe_math_optimizations\n    && !flag_trapping_math && TARGET_FRIZ\"\n   \"xvrdpiz %x0,%x1\""}]}