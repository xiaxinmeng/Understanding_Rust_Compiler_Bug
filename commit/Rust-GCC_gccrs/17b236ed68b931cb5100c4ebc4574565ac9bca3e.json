{"sha": "17b236ed68b931cb5100c4ebc4574565ac9bca3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiMjM2ZWQ2OGI5MzFjYjUxMDBjNGViYzQ1NzQ1NjVhYzliY2EzZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-03-15T23:47:18Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-03-15T23:47:18Z"}, "message": "tree-ssa-loop-niter.c (refine_bounds_using_guard, [...]): Handle NE_EXPR guards.\n\n\t* tree-ssa-loop-niter.c (refine_bounds_using_guard, bound_difference):\n\tHandle NE_EXPR guards.\n\nFrom-SVN: r122963", "tree": {"sha": "d2935d7f2f33812081b0014f86ea1614fad91f72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2935d7f2f33812081b0014f86ea1614fad91f72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17b236ed68b931cb5100c4ebc4574565ac9bca3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b236ed68b931cb5100c4ebc4574565ac9bca3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17b236ed68b931cb5100c4ebc4574565ac9bca3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b236ed68b931cb5100c4ebc4574565ac9bca3e/comments", "author": null, "committer": null, "parents": [{"sha": "2ce88bea6d9c7d451c9f2f5eda2f91de7884da65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce88bea6d9c7d451c9f2f5eda2f91de7884da65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce88bea6d9c7d451c9f2f5eda2f91de7884da65"}], "stats": {"total": 57, "additions": 47, "deletions": 10}, "files": [{"sha": "0825b1b84391b8b03d9a93c8fe1bfda5643a3ec5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b236ed68b931cb5100c4ebc4574565ac9bca3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b236ed68b931cb5100c4ebc4574565ac9bca3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17b236ed68b931cb5100c4ebc4574565ac9bca3e", "patch": "@@ -1,3 +1,8 @@\n+2007-03-15  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (refine_bounds_using_guard, bound_difference):\n+\tHandle NE_EXPR guards.\n+\n 2007-03-15  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/24924"}, {"sha": "688bc3910f662d549f15082803d1619babb27a0b", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b236ed68b931cb5100c4ebc4574565ac9bca3e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b236ed68b931cb5100c4ebc4574565ac9bca3e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=17b236ed68b931cb5100c4ebc4574565ac9bca3e", "patch": "@@ -283,7 +283,7 @@ refine_bounds_using_guard (tree type, tree varx, mpz_t offx,\n \t\t\t   tree c0, enum tree_code cmp, tree c1,\n \t\t\t   bounds *bnds)\n {\n-  tree varc0, varc1, tmp;\n+  tree varc0, varc1, tmp, ctype;\n   mpz_t offc0, offc1, loffx, loffy, bnd;\n   bool lbound = false;\n   bool no_wrap = nowrap_type_p (type);\n@@ -295,17 +295,48 @@ refine_bounds_using_guard (tree type, tree varx, mpz_t offx,\n     case LE_EXPR:\n     case GT_EXPR:\n     case GE_EXPR:\n+      STRIP_SIGN_NOPS (c0);\n+      STRIP_SIGN_NOPS (c1);\n+      ctype = TREE_TYPE (c0);\n+      if (!tree_ssa_useless_type_conversion_1 (ctype, type))\n+\treturn;\n+\n       break;\n \n     case EQ_EXPR:\n       /* We could derive quite precise information from EQ_EXPR, however, such\n-\t a guard is unlikely to appear, so we do not bother with handling it. \n-\t TODO.  */\n+\t a guard is unlikely to appear, so we do not bother with handling\n+\t it.  */\n       return;\n \n     case NE_EXPR:\n-      /* NE_EXPR comparisons do not contain much of useful information (except for\n-\t special cases like comparing with the bounds of the type, TODO).  */\n+      /* NE_EXPR comparisons do not contain much of useful information, except for\n+\t special case of comparing with the bounds of the type.  */\n+      if (TREE_CODE (c1) != INTEGER_CST\n+\t  || !INTEGRAL_TYPE_P (type))\n+\treturn;\n+\n+      /* Ensure that the condition speaks about an expression in the same type\n+\t as X and Y.  */\n+      ctype = TREE_TYPE (c0);\n+      if (TYPE_PRECISION (ctype) != TYPE_PRECISION (type))\n+\treturn;\n+      c0 = fold_convert (type, c0);\n+      c1 = fold_convert (type, c1);\n+\n+      if (TYPE_MIN_VALUE (type)\n+\t  && operand_equal_p (c1, TYPE_MIN_VALUE (type), 0))\n+\t{\n+\t  cmp = GT_EXPR;\n+\t  break;\n+\t}\n+      if (TYPE_MAX_VALUE (type)\n+\t  && operand_equal_p (c1, TYPE_MAX_VALUE (type), 0))\n+\t{\n+\t  cmp = LT_EXPR;\n+\t  break;\n+\t}\n+\n       return;\n     default:\n       return;\n@@ -422,9 +453,14 @@ bound_difference (struct loop *loop, tree x, tree y, bounds *bnds)\n   int cnt = 0;\n   edge e;\n   basic_block bb;\n-  tree cond, c0, c1, ctype;\n+  tree cond, c0, c1;\n   enum tree_code cmp;\n \n+  /* Get rid of unnecessary casts, but preserve the value of\n+     the expressions.  */\n+  STRIP_SIGN_NOPS (x);\n+  STRIP_SIGN_NOPS (y);\n+\n   mpz_init (bnds->below);\n   mpz_init (bnds->up);\n   mpz_init (offx);\n@@ -482,10 +518,6 @@ bound_difference (struct loop *loop, tree x, tree y, bounds *bnds)\n       c0 = TREE_OPERAND (cond, 0);\n       cmp = TREE_CODE (cond);\n       c1 = TREE_OPERAND (cond, 1);\n-      ctype = TREE_TYPE (c0);\n-\n-      if (!tree_ssa_useless_type_conversion_1 (ctype, type))\n-\tcontinue;\n \n       if (e->flags & EDGE_FALSE_VALUE)\n \tcmp = invert_tree_comparison (cmp, false);"}]}