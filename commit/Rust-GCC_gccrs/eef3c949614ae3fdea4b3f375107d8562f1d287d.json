{"sha": "eef3c949614ae3fdea4b3f375107d8562f1d287d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVmM2M5NDk2MTRhZTNmZGVhNGIzZjM3NTEwN2Q4NTYyZjFkMjg3ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-07-28T19:33:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-07-28T19:33:10Z"}, "message": "cse.c (validate_canon_reg): New function, split out from...\n\n\t* cse.c (validate_canon_reg): New function, split out from...\n\t(canon_reg): ...here.  Use validate_canon_reg for both 'e' and 'E'.\n\nFrom-SVN: r85270", "tree": {"sha": "a50ed41c19013b2c81fa36770025ff4f3a891633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50ed41c19013b2c81fa36770025ff4f3a891633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eef3c949614ae3fdea4b3f375107d8562f1d287d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef3c949614ae3fdea4b3f375107d8562f1d287d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef3c949614ae3fdea4b3f375107d8562f1d287d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef3c949614ae3fdea4b3f375107d8562f1d287d/comments", "author": null, "committer": null, "parents": [{"sha": "f0faf24b6a6beb1a4813eb7c57e73555758de50c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0faf24b6a6beb1a4813eb7c57e73555758de50c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0faf24b6a6beb1a4813eb7c57e73555758de50c"}], "stats": {"total": 47, "additions": 30, "deletions": 17}, "files": [{"sha": "9e3f1b817c73cc7b5cc8313e6d105cf75faec9e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef3c949614ae3fdea4b3f375107d8562f1d287d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef3c949614ae3fdea4b3f375107d8562f1d287d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eef3c949614ae3fdea4b3f375107d8562f1d287d", "patch": "@@ -1,3 +1,8 @@\n+2004-07-28  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* cse.c (validate_canon_reg): New function, split out from...\n+\t(canon_reg): ...here.  Use validate_canon_reg for both 'e' and 'E'.\n+\n 2004-07-28  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-ssa-alias.c (maybe_create_global_var): Don't just"}, {"sha": "6880787f4c5c178e703d9c5637c36dd9b0494f72", "filename": "gcc/cse.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef3c949614ae3fdea4b3f375107d8562f1d287d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef3c949614ae3fdea4b3f375107d8562f1d287d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=eef3c949614ae3fdea4b3f375107d8562f1d287d", "patch": "@@ -2626,6 +2626,29 @@ cse_rtx_varies_p (rtx x, int from_alias)\n   return rtx_varies_p (x, from_alias);\n }\n \f\n+/* Subroutine of canon_reg.  Pass *XLOC through canon_reg, and validate\n+   the result if necessary.  INSN is as for canon_reg.  */\n+\n+static void\n+validate_canon_reg (rtx *xloc, rtx insn)\n+{\n+  rtx new = canon_reg (*xloc, insn);\n+  int insn_code;\n+\n+  /* If replacing pseudo with hard reg or vice versa, ensure the\n+     insn remains valid.  Likewise if the insn has MATCH_DUPs.  */\n+  if (insn != 0 && new != 0\n+      && REG_P (new) && REG_P (*xloc)\n+      && (((REGNO (new) < FIRST_PSEUDO_REGISTER)\n+\t   != (REGNO (*xloc) < FIRST_PSEUDO_REGISTER))\n+\t  || GET_MODE (new) != GET_MODE (*xloc)\n+\t  || (insn_code = recog_memoized (insn)) < 0\n+\t  || insn_data[insn_code].n_dups > 0))\n+    validate_change (insn, xloc, new, 1);\n+  else\n+    *xloc = new;\n+}\n+\n /* Canonicalize an expression:\n    replace each register reference inside it\n    with the \"oldest\" equivalent register.\n@@ -2695,25 +2718,10 @@ canon_reg (rtx x, rtx insn)\n       int j;\n \n       if (fmt[i] == 'e')\n-\t{\n-\t  rtx new = canon_reg (XEXP (x, i), insn);\n-\t  int insn_code;\n-\n-\t  /* If replacing pseudo with hard reg or vice versa, ensure the\n-\t     insn remains valid.  Likewise if the insn has MATCH_DUPs.  */\n-\t  if (insn != 0 && new != 0\n-\t      && REG_P (new) && REG_P (XEXP (x, i))\n-\t      && (((REGNO (new) < FIRST_PSEUDO_REGISTER)\n-\t\t   != (REGNO (XEXP (x, i)) < FIRST_PSEUDO_REGISTER))\n-\t\t  || (insn_code = recog_memoized (insn)) < 0\n-\t\t  || insn_data[insn_code].n_dups > 0))\n-\t    validate_change (insn, &XEXP (x, i), new, 1);\n-\t  else\n-\t    XEXP (x, i) = new;\n-\t}\n+\tvalidate_canon_reg (&XEXP (x, i), insn);\n       else if (fmt[i] == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  XVECEXP (x, i, j) = canon_reg (XVECEXP (x, i, j), insn);\n+\t  validate_canon_reg (&XVECEXP (x, i, j), insn);\n     }\n \n   return x;"}]}