{"sha": "58aee036e81d53cfb0c9de70369270633a042c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThhZWUwMzZlODFkNTNjZmIwYzlkZTcwMzY5MjcwNjMzYTA0MmM0Mg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-06-15T00:38:43Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-06-15T00:38:43Z"}, "message": "h8300.exp: New.\n\n\t* gcc.target/h8300/h8300.exp: New.\n\t* gcc.dg/pragma-isr.c: Move to ...\n\t* gcc.target/sh/torture/pragma-isr.c: ... here ...\n\t* gcc.target/h8300/pragma-isr.c: ... and here.\n\t* gcc.dg/pragma-isr2.c: Move to ...\n\t* gcc.target/sh/torture/pragma-isr2.c: ... here ...\n\t* gcc.target/h8300/pragma-isr2.c: ... and here.\n\t* gcc.dg/pragma-isr-trapa.c: Move to ...\n\t* gcc.target/sh/pragma-isr-trapa.c: ... here.\n\t* gcc.dg/pragma-isr-trapa2.c: Move to ...\n\t* gcc.target/sh/pragma-isr-trapa2.c: ... here.\n\t* gcc.dg/pragma-isr-trap_exit.c: Move to ...\n\t* gcc.target/sh/pragma-isr-trap-exit.c: ... here.\n\t* gcc.dg/pragma-isr-nosave_low_regs.c: Move to ...\n\t* gcc.target/sh/pragma-isr-nosave_low_regs.c: ... here.\n\t* gcc.dg/attr-isr-nosave_low_regs.c: Move to ...\n\t* gcc.target/sh/attr-isr-nosave_low_regs.c: ... here.\n\t* gcc.dg/attr-isr-trap_exit.c: Move to ...\n\t* gcc.target/sh/attr-isr-trap_exit.c: ... here.\n\t* gcc.dg/attr-isr-trapa.c: Move to ...\n\t* gcc.target/sh/attr-isr-trapa.c: ... here.\n\nFrom-SVN: r200117", "tree": {"sha": "f104232147680b96eed31b55a805d9f76c48abe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f104232147680b96eed31b55a805d9f76c48abe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58aee036e81d53cfb0c9de70369270633a042c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58aee036e81d53cfb0c9de70369270633a042c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58aee036e81d53cfb0c9de70369270633a042c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58aee036e81d53cfb0c9de70369270633a042c42/comments", "author": null, "committer": null, "parents": [{"sha": "5042e37cd2acab88365e0da3d46272d07b9bbc1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5042e37cd2acab88365e0da3d46272d07b9bbc1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5042e37cd2acab88365e0da3d46272d07b9bbc1a"}], "stats": {"total": 579, "additions": 400, "deletions": 179}, "files": [{"sha": "753d94899ced0c912f85dd79589c1c487c64a15b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -1,3 +1,27 @@\n+2013-06-15  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* gcc.target/h8300/h8300.exp: New.\n+\t* gcc.dg/pragma-isr.c: Move to ...\n+\t* gcc.target/sh/torture/pragma-isr.c: ... here ...\n+\t* gcc.target/h8300/pragma-isr.c: ... and here.\n+\t* gcc.dg/pragma-isr2.c: Move to ...\n+\t* gcc.target/sh/torture/pragma-isr2.c: ... here ...\n+\t* gcc.target/h8300/pragma-isr2.c: ... and here.\n+\t* gcc.dg/pragma-isr-trapa.c: Move to ...\n+\t* gcc.target/sh/pragma-isr-trapa.c: ... here.\n+\t* gcc.dg/pragma-isr-trapa2.c: Move to ...\n+\t* gcc.target/sh/pragma-isr-trapa2.c: ... here.\n+\t* gcc.dg/pragma-isr-trap_exit.c: Move to ...\n+\t* gcc.target/sh/pragma-isr-trap-exit.c: ... here.\n+\t* gcc.dg/pragma-isr-nosave_low_regs.c: Move to ...\n+\t* gcc.target/sh/pragma-isr-nosave_low_regs.c: ... here.\n+\t* gcc.dg/attr-isr-nosave_low_regs.c: Move to ...\n+\t* gcc.target/sh/attr-isr-nosave_low_regs.c: ... here.\n+\t* gcc.dg/attr-isr-trap_exit.c: Move to ...\n+\t* gcc.target/sh/attr-isr-trap_exit.c: ... here.\n+\t* gcc.dg/attr-isr-trapa.c: Move to ...\n+\t* gcc.target/sh/attr-isr-trapa.c: ... here.\n+\n 2013-06-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51413"}, {"sha": "3bda1014caac72bf2554139fe53b2dff729071d7", "filename": "gcc/testsuite/gcc.dg/attr-isr-nosave_low_regs.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-nosave_low_regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-nosave_low_regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-nosave_low_regs.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-do compile { target { { sh-*-* sh[1234ble]*-*-* } && nonpic } } } */\n-/* { dg-options \"-O\" } */\n-\n-extern void bar ();\n-\n-void foo ()\n-{\n-}\n-\n-#pragma interrupt\n-void ( __attribute__ ((nosave_low_regs)) isr) ()\n-{\n-  bar ();\n-}\n-\n-void delay(int a)\n-{\n-}\n-\n-/* { dg-final { scan-assembler-times \"rte\" 1} } */\n-/* A call will clobber all call-saved registers, but because of\n-   #pragma nosave_low_regs, r0..r7 need not be saved/restored.\n-   One of these registers will also do fine to hold the function address.\n-   Call-saved registers r8..r13 also don't need to be restored.  */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-9\\]\\[ \\t\\]*,\" } } */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[89\\]\" } } */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } } */\n-/* { dg-final { scan-assembler-times \"macl\" 2} } */"}, {"sha": "7ea24c494f0233c1ced49db5d3ee648eb8228a0e", "filename": "gcc/testsuite/gcc.dg/attr-isr-trap_exit.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trap_exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trap_exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trap_exit.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,23 +0,0 @@\n-/* { dg-do compile { target sh-*-* sh[1234ble]*-*-* } } */\n-/* { dg-options \"-O\" } */\n-/* Check that trapa / interrput_handler attributes can paired in\n-   either order.  */\n-void h0() __attribute__ ((trap_exit (4))) __attribute__ ((interrupt_handler));\n-void h1() __attribute__ ((interrupt_handler)) __attribute__ ((trap_exit (5)));\n-\n-void foo ()\n-{\n-}\n-\n-void h0 () {}\n-/* { dg-final { scan-assembler \"trapa\\[ \\t\\]\\[ \\t\\]*#4\"} } */\n-/* { dg-final { scan-assembler-times \"trapa\" 1} } */\n-\n-void delay(int a)\n-{\n-}\n-int main()\n-{\n-  return 0;\n-}\n-"}, {"sha": "47caf2112daec9259ac62ebb4d416f19f0457eea", "filename": "gcc/testsuite/gcc.dg/attr-isr-trapa.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trapa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trapa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trapa.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile { target { { sh-*-* sh[1234ble]*-*-* } && nonpic } } } */\n-/* { dg-options \"-O\" } */\n-extern void foo ();\n-\n-void\n-(__attribute__ ((trapa_handler)) isr) ()\n-{\n-  foo ();\n-}\n-\n-/* { dg-final { scan-assembler-times \"rte\" 1} } */\n-/* No interrupt-specific saves should be needed.  /\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-7\\]\\[ \\t,\\]\\[^\\n\\]*r15\" } } */\n-/* { dg-final { scan-assembler-not \"@r15\\[^\\n\\]*\\[^f\\]r\\[0-7\\]\\n\" } } */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[8-9\\]\" } } */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } } */\n-/* { dg-final { scan-assembler-not \"macl\" } } */"}, {"sha": "c71c88cb75fe65a7fab81fa7f4b356e0c4a83a2e", "filename": "gcc/testsuite/gcc.dg/pragma-isr-nosave_low_regs.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-nosave_low_regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-nosave_low_regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-nosave_low_regs.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,20 +0,0 @@\n-/* { dg-do compile { target { { sh-*-* sh[1234ble]*-*-* } && nonpic } } } */\n-/* { dg-options \"-O\" } */\n-extern void foo ();\n-#pragma interrupt\n-#pragma nosave_low_regs\n-void\n-isr()\n-{\n-  foo ();\n-}\n-\n-/* { dg-final { scan-assembler-times \"rte\" 1} } */\n-/* A call will clobber all call-saved registers, but because of\n-   #pragma nosave_low_regs, r0..r7 need not be saved/restored.\n-   One of these registers will also do fine to hold the function address.\n-   Call-saved registers r8..r13 also don't need to be restored.  */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-9\\]\\[ \\t\\]*,\" } } */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[89\\]\" } } */\n-/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } } */\n-/* { dg-final { scan-assembler-times \"macl\" 2} } */"}, {"sha": "00a0608ccb409d29c27c6a5896b1e91dc6931854", "filename": "gcc/testsuite/gcc.dg/pragma-isr-trap_exit.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trap_exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trap_exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trap_exit.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile { target sh-*-* sh[1234ble]*-*-* } } */\n-/* { dg-options \"-O\" } */\n-/* This test case will check whether trapa is generated only for isr.  */\n-#pragma interrupt\n-void isr() __attribute__ ((trap_exit (4)));\n-void isr()\n-{\n-}\n-void delay(int a)\n-{\n-}\n-int main()\n-{\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-times \"trapa\\[ \\t\\]\\[ \\t\\]*#4\" 1} } */"}, {"sha": "2d32885dbdd0d81cdda0f74430d9220c80ab5fe4", "filename": "gcc/testsuite/gcc.dg/pragma-isr-trapa.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile { target { { sh-*-* sh[1234ble]*-*-* } && nonpic } } } */\n-/* { dg-options \"-O\" } */\n-extern void foo ();\n-#pragma trapa\n-void\n-isr()\n-{\n-  foo ();\n-}\n-\n-/* { dg-final { scan-assembler-times \"rte\" 1} } */\n-/* No interrupt-specific saves should be needed.  /\n-/* { dg-final { scan-assembler-not \"r\\[0-7\\]\\[ \\t,\\]\\[^\\n\\]*r15\" } } */\n-/* { dg-final { scan-assembler-not \"@r15\\[^\\n\\]*r\\[0-7\\]\\n\" } } */\n-/* { dg-final { scan-assembler-not \"r\\[8-9\\]\" } } */\n-/* { dg-final { scan-assembler-not \"r1\\[,0-3\\]\" } } */\n-/* { dg-final { scan-assembler-not \"macl\" } } */"}, {"sha": "a1165893be5fb3065750aa70276a300a739aa37e", "filename": "gcc/testsuite/gcc.dg/pragma-isr-trapa2.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa2.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,24 +0,0 @@\n-/* { dg-do compile { target { { sh-*-* sh4*-*-* } && nonpic } } } */\n-/* { dg-skip-if \"FPU Required\" { \"sh*-*-*\" } { \"-m*nofpu*\" } { \"\" } } */\n-/* { dg-skip-if \"FPU Required\" { \"sh*-*-*\" } { \"-m4al*\" } { \"\" } } */\n-/* { dg-options \"-O -m4\" } */\n-\n-extern void foo ();\n-#pragma trapa\n-void\n-isr()\n-{\n-  foo ();\n-}\n-\n-/* { dg-final { scan-assembler-times \"rte\" 1} } */\n-/* No interrupt-specific saves should be needed.\n-   The function call will require to load the address first into a register,\n-   then use that for a jsr or jmp.  It will also need to load a constant\n-   address in order to load fpscr.  */\n-/* { dg-final { scan-assembler-times \"r\\[0-7\\]\\n\" 3 } } */\n-/* { dg-final { scan-assembler-not \"r\\[8-9\\]\" } } */\n-/* { dg-final { scan-assembler-not \"r1\\[,0-3\\]\" } } */\n-/* { dg-final { scan-assembler-not \"macl\" } } */\n-/* fpscr needs to be saved, loaded and restored.  */\n-/* { dg-final { scan-assembler-times \"\\[^_\\]fpscr\" 3 } } */"}, {"sha": "e7565a682454d5b5ca9867b30cfea0ea1084ceaa", "filename": "gcc/testsuite/gcc.dg/pragma-isr.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile { target h8300-*-* sh-*-* sh[1234ble]*-*-* } } */\n-/* { dg-options \"-O3\" } */\n-/* Test case will check whether rte is generated for two ISRs*/\n-extern void foo();\n-#pragma interrupt\n-void  isr1(void)\n-{\n-\t\tfoo();\n-}\n-\n-#pragma interrupt\n-void  isr2(void)\n-{\n-\t\tfoo();\n-}\n-\n-/* { dg-final { scan-assembler-times \"rte\" 2} } */"}, {"sha": "3e2e4bb38bafcedb01c88e2de05efe252ae9f99e", "filename": "gcc/testsuite/gcc.dg/pragma-isr2.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5042e37cd2acab88365e0da3d46272d07b9bbc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr2.c?ref=5042e37cd2acab88365e0da3d46272d07b9bbc1a", "patch": "@@ -1,16 +0,0 @@\n-/* { dg-do compile { target h8300-*-* sh-*-* sh[1234ble]*-*-* } } */\n-/* { dg-options \"-O\" } */\n-/* This test case will check whether rte is generated only for isr.  */\n-#pragma interrupt\n-void isr()\n-{\n-}\n-void delay(int a)\n-{\n-}\n-int main()\n-{\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-times \"rte\" 1} } */"}, {"sha": "474fc454ce357fb6c62af2ccf3569aff301c532b", "filename": "gcc/testsuite/gcc.target/h8300/h8300.exp", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fh8300.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fh8300.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fh8300.exp?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,82 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't a h8300 target.\n+if ![istarget h8300*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't a h8300 target.\n+if ![istarget h8300*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "24fba30d8b77bbcd70baba4b27f7d53548ae6694", "filename": "gcc/testsuite/gcc.target/h8300/pragma-isr.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fpragma-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fpragma-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fpragma-isr.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,40 @@\n+/* Check whether rte is generated for two ISRs.  */\n+/* { dg-do compile { target h8300-*-* } }  */\n+/* { dg-options \"-O3\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 2} }  */\n+\n+extern void foo (void);\n+\n+#pragma interrupt\n+void\n+isr1 (void)\n+{\n+  foo ();\n+}\n+\n+#pragma interrupt\n+void\n+isr2 (void)\n+{\n+  foo ();\n+}\n+/* Check whether rte is generated for two ISRs.  */\n+/* { dg-do compile { target h8300-*-* } }  */\n+/* { dg-options \"-O3\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 2} }  */\n+\n+extern void foo (void);\n+\n+#pragma interrupt\n+void\n+isr1 (void)\n+{\n+  foo ();\n+}\n+\n+#pragma interrupt\n+void\n+isr2 (void)\n+{\n+  foo ();\n+}"}, {"sha": "7c242ec31122e530abdeafb73529b6e9beea3a49", "filename": "gcc/testsuite/gcc.target/h8300/pragma-isr2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fpragma-isr2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fpragma-isr2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fh8300%2Fpragma-isr2.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,42 @@\n+/* Check whether rte is generated only for an ISR.  */\n+/* { dg-do compile { target h8300-*-* } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+\n+#pragma interrupt\n+void\n+isr (void)\n+{\n+}\n+\n+void\n+delay (int a)\n+{\n+}\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}\n+/* Check whether rte is generated only for an ISR.  */\n+/* { dg-do compile { target h8300-*-* } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+\n+#pragma interrupt\n+void\n+isr (void)\n+{\n+}\n+\n+void\n+delay (int a)\n+{\n+}\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"}, {"sha": "2f1d5180140ccc9e2a879b658b1fd3f11fe5b47b", "filename": "gcc/testsuite/gcc.target/sh/attr-isr-nosave_low_regs.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-nosave_low_regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-nosave_low_regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-nosave_low_regs.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,32 @@\n+/* A call will clobber all call-saved registers.\n+   If #pragma nosave_low_regs is specified, do not save/restore r0..r7.\n+   (On SH3* and SH4* r0..r7 are banked)\n+   One of these registers will also do fine to hold the function address.\n+   Call-saved registers r8..r13 also don't need to be restored.  */\n+/* { dg-do compile { target { { \"sh*-*-*\" } && nonpic } } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m1*\" \"-m2*\" \"-m5*\" } { \"\" } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-9\\]\\[ \\t\\]*,\" } }  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[89\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } }  */\n+/* { dg-final { scan-assembler-times \"macl\" 2 } }  */\n+\n+extern void bar (void);\n+\n+void\n+foo (void)\n+{\n+}\n+\n+#pragma interrupt\n+void\n+( __attribute__ ((nosave_low_regs)) isr) (void)\n+{\n+  bar ();\n+}\n+\n+void\n+delay (int a)\n+{\n+}"}, {"sha": "ad61aaa1db57f6d2b4d01a8c605aa0c5a566d427", "filename": "gcc/testsuite/gcc.target/sh/attr-isr-trap_exit.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-trap_exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-trap_exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-trap_exit.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,31 @@\n+/* Check that trapa / interrput_handler attributes can paired in\n+   either order.  */\n+/* { dg-do compile { target \"sh*-*-*\" } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler \"trapa\\[ \\t\\]\\[ \\t\\]*#4\"} }  */\n+/* { dg-final { scan-assembler-times \"trapa\" 1 } }  */\n+\n+void h0 (void) __attribute__ ((trap_exit (4))) __attribute__ ((interrupt_handler));\n+void h1 (void) __attribute__ ((interrupt_handler)) __attribute__ ((trap_exit (5)));\n+\n+void\n+foo (void)\n+{\n+}\n+\n+void\n+h0 (void)\n+{\n+}\n+\n+void delay\n+(int a)\n+{\n+}\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"}, {"sha": "e1bc8a4af62d704998ca23f01a599d513d160d8f", "filename": "gcc/testsuite/gcc.target/sh/attr-isr-trapa.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-trapa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-trapa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fattr-isr-trapa.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,18 @@\n+/* Check that no interrupt-specific register saves are generated.  */\n+/* { dg-do compile { target { { \"sh*-*-*\" } && nonpic } } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+/* { dg-final { scan-assembler-not \"r\\[0-7\\]\\[ \\t,\\]\\[^\\n\\]*r15\" } }  */\n+/* { dg-final { scan-assembler-not \"@r15\\[^\\n\\]*r\\[0-7\\]\\n\" } }  */\n+/* { dg-final { scan-assembler-not \"r\\[8-9\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"r1\\[,0-3\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"macl\" } }  */\n+\n+extern void foo (void);\n+\n+void\n+(__attribute__ ((trapa_handler)) isr) (void)\n+{\n+  foo ();\n+}"}, {"sha": "e1d880d33092f9c4098099b6873ba28cf0b0b6ed", "filename": "gcc/testsuite/gcc.target/sh/pragma-isr-nosave_low_regs.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-nosave_low_regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-nosave_low_regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-nosave_low_regs.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,23 @@\n+/* A call will clobber all call-saved registers.\n+   If #pragma nosave_low_regs is specified, do not save/restore r0..r7.\n+   (On SH3* and SH4* r0..r7 are banked)\n+   One of these registers will also do fine to hold the function address.\n+   Call-saved registers r8..r13 also don't need to be restored.  */\n+/* { dg-do compile { target { { \"sh*-*-*\" } && nonpic } } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m1*\" \"-m2*\" \"-m5*\" } { \"\" } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-9\\]\\[ \\t\\]*,\" } }  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[89\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } }  */\n+/* { dg-final { scan-assembler-times \"macl\" 2 } }  */\n+\n+extern void foo (void);\n+\n+#pragma interrupt\n+#pragma nosave_low_regs\n+void\n+isr (void)\n+{\n+  foo ();\n+}"}, {"sha": "823eb967b41c104cedb61d73c14cfa3f3f0affbb", "filename": "gcc/testsuite/gcc.target/sh/pragma-isr-trap-exit.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trap-exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trap-exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trap-exit.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,24 @@\n+/* Check whether trapa is generated only for an ISR.  */\n+/* { dg-do compile { target \"sh*-*-*\" } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"trapa\\[ \\t\\]\\[ \\t\\]*#4\" 1 } }  */\n+\n+#pragma interrupt\n+void isr (void) __attribute__ ((trap_exit (4)));\n+\n+void\n+isr (void)\n+{\n+}\n+\n+void\n+delay (int a)\n+{\n+}\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"}, {"sha": "cc57014dde72f33a77fa29b621c803f6fa57d082", "filename": "gcc/testsuite/gcc.target/sh/pragma-isr-trapa.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trapa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trapa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trapa.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,19 @@\n+/* Check that no interrupt-specific register saves are generated.  */\n+/* { dg-do compile { target { { \"sh*-*-*\" } && nonpic } } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+/* { dg-final { scan-assembler-not \"r\\[0-7\\]\\[ \\t,\\]\\[^\\n\\]*r15\" } }  */\n+/* { dg-final { scan-assembler-not \"@r15\\[^\\n\\]*r\\[0-7\\]\\n\" } }  */\n+/* { dg-final { scan-assembler-not \"r\\[8-9\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"r1\\[,0-3\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"macl\" } }  */\n+\n+extern void foo (void);\n+\n+#pragma trapa\n+void\n+isr (void)\n+{\n+  foo ();\n+}"}, {"sha": "9a23b976f44d4c1e7c9dce0e2fad91ce804622e4", "filename": "gcc/testsuite/gcc.target/sh/pragma-isr-trapa2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trapa2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trapa2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpragma-isr-trapa2.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,24 @@\n+/* Check that no interrupt-specific register saves are generated.\n+   The function call will require to load the address first into a register,\n+   then use that for a jsr or jmp.  It will also need to load a constant\n+   address in order to load fpscr.  */\n+/* { dg-do compile { target { { \"sh*-*-*\" } && nonpic } } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m1\" \"-m2\" \"-m3\" \"-m4al\" \"*nofpu\" \"-m4-340*\" \"-m4-400*\" \"-m4-500*\" \"-m5*\" } { \"\" } }  */\n+/* { dg-options \"-O\" }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"r\\[0-7\\]\\n\" 3 } }  */\n+/* { dg-final { scan-assembler-not \"r\\[8-9\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"r1\\[,0-3\\]\" } }  */\n+/* { dg-final { scan-assembler-not \"macl\" } }  */\n+\n+/* Expect that fpscr needs to be saved, loaded and restored.  */\n+/* { dg-final { scan-assembler-times \"\\[^_\\]fpscr\" 3 } }  */\n+\n+extern void foo (void);\n+\n+#pragma trapa\n+void\n+isr (void)\n+{\n+  foo ();\n+}"}, {"sha": "3c917bc657756bd8ef0542129b0d9a0f3fb2b83e", "filename": "gcc/testsuite/gcc.target/sh/torture/pragma-isr.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpragma-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpragma-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpragma-isr.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,20 @@\n+/* Check whether rte is generated for two ISRs.  */\n+/* { dg-do compile { target \"sh*-*-*\" } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rte\" 2 } }  */\n+\n+extern void foo (void);\n+\n+#pragma interrupt\n+void\n+isr1 (void)\n+{\n+  foo ();\n+}\n+\n+#pragma interrupt\n+void\n+isr2 (void)\n+{\n+  foo ();\n+}"}, {"sha": "89d70084ed940e2e7f5f504afd41e71fca444b27", "filename": "gcc/testsuite/gcc.target/sh/torture/pragma-isr2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpragma-isr2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58aee036e81d53cfb0c9de70369270633a042c42/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpragma-isr2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpragma-isr2.c?ref=58aee036e81d53cfb0c9de70369270633a042c42", "patch": "@@ -0,0 +1,21 @@\n+/* Check whether rte is generated only for an ISRs.  */\n+/* { dg-do compile { target \"sh*-*-*\" } }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rte\" 1 } }  */\n+\n+#pragma interrupt\n+void\n+isr (void)\n+{\n+}\n+\n+void\n+delay (int a)\n+{\n+}\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"}]}