{"sha": "885f2199f39dcc84c7cabe6c8149d3e86c341fea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg1ZjIxOTlmMzlkY2M4NGM3Y2FiZTZjODE0OWQzZTg2YzM0MWZlYQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2005-03-28T04:22:33Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2005-03-28T04:22:33Z"}, "message": "partition.h: Remove use of PARAMS.\n\ninclude/\n2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n        * partition.h: Remove use of PARAMS.\n        * obstack.h: Remove conditional prototypes __STDC__.\n        * objalloc.h:  Remove use of PARAMS.\n        * splay-tree.h: Likewise.\n\nlibiberty/\n2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n        Convert libiberty to use ISO C prototype style 5/n.\n        * random.c (srandom, initstate, setstate, random): Use ISO C\n        prototypes.\n        * putenv.c (putenv): Likewise.\n        * physmem.c (physmem_available, physmem_total, main):\n        Likewise.\n        * pex-win32.c (fix_argv, pexecute, pwait): Likewise.\n        * pex-unix.c (pexecute, pwait): Likewise.\n        * pex-msdos.c (pexecute, pwait): Likewise.\n        * pex-djgpp.c (pexecute, pwait): Likewise.\n        * partition.c (partition_new, partition_delete,\n        partition_union)\n        (elem_compare, partition_print): Likewise.\n        * obstack.c (_obstack_begin, _obstack_begin_1,\n        _obstack_newchunk,\n        _obstack_allocated_p, _obstack_free, obstack_free,\n        _obstack_memory_used, print_and_abort, obstack_next_free,\n        obstack_object_size, obstack_base): Likewise.  Remove codes\n        predicated on !defined(__STDC__).\n        * objalloc.c (objalloc_create, _objalloc_alloc, objalloc_free,\n        objalloc_free_block): Use ISO C prototypes.\n        * mkstemps.c (mkstemps): Likewise.\n        * memset.c (memset): Likewise.\n        * mempcpy.c (mempcpy): Likewise.\n        * rename.c (rename): Likewise.\n        * rindex.c (rindex): Likewise.\n        * setenv.c (setenv, unsetenv): Likewise.\n        * sigsetmask.c (sigsetmask): Likewise.\n        * snprintf.c (snprintf): Likewise.\n        * sort.c (sort_pointers, xmalloc): Likewise.\n        * spaces.c (spaces): Likewise.\n        * splay-tree.c (splay_tree_delete_helper,\n        splay_tree_splay_helper, splay_tree_splay,\n        splay_tree_foreach_helper, splay_tree_xmalloc_allocate,\n        splay_tree_new, splay_tree_xmalloc_allocate,\n        splay_tree_new_with_allocator, splay_tree_delete,\n        splay_tree_insert, splay_tree_remove, splay_tree_lookup,\n        splay_tree_max, splay_tree_min, splay_tree_predecessor,\n        splay_tree_successor, splay_tree_foreach,\n        splay_tree_compare_ints, splay_tree_compare_pointers):\n        Likewise.\n        * stpcpy.c (stpcpy): Likewise.\n        * stpncpy.c (stpncpy): Likewise.\n        * strcasecmp.c (strcasecmp): Likewise.\n        * strchr.c (strchr): Likewise.\n        * strdup.c (strdup): Likewise.\n\nFrom-SVN: r97125", "tree": {"sha": "6b021876ac555fbdd0c1bc2ba8c2a0a644d78307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b021876ac555fbdd0c1bc2ba8c2a0a644d78307"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/885f2199f39dcc84c7cabe6c8149d3e86c341fea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885f2199f39dcc84c7cabe6c8149d3e86c341fea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/885f2199f39dcc84c7cabe6c8149d3e86c341fea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885f2199f39dcc84c7cabe6c8149d3e86c341fea/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b32f9fc292fb047f9dabbc7de9e49fad289f416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b32f9fc292fb047f9dabbc7de9e49fad289f416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b32f9fc292fb047f9dabbc7de9e49fad289f416"}], "stats": {"total": 714, "additions": 224, "deletions": 490}, "files": [{"sha": "5a63fac31fbebe23413e970b6810b2c860d7d791", "filename": "include/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -2,6 +2,13 @@\n \n \t* ternary.h: Don't use PARAMS anymore.\n \n+2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* partition.h: Remove use of PARAMS.\n+\t* obstack.h: Remove conditional prototypes __STDC__.\n+\t* objalloc.h:  Remove use of PARAMS.\n+\t* splay-tree.h: Likewise.\n+\n 2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* md5.h: Remove definition and uses of __P."}, {"sha": "67e8f00f4e6c4b8f92167aa1af095ac93cac3a61", "filename": "include/objalloc.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fobjalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fobjalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fobjalloc.h?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -64,12 +64,12 @@ struct objalloc_align { char x; double d; };\n \n /* Create an objalloc structure.  Returns NULL if malloc fails.  */\n \n-extern struct objalloc *objalloc_create PARAMS ((void));\n+extern struct objalloc *objalloc_create (void);\n \n /* Allocate space from an objalloc structure.  Returns NULL if malloc\n    fails.  */\n \n-extern PTR _objalloc_alloc PARAMS ((struct objalloc *, unsigned long));\n+extern PTR _objalloc_alloc (struct objalloc *, unsigned long);\n \n /* The macro version of objalloc_alloc.  We only define this if using\n    gcc, because otherwise we would have to evaluate the arguments\n@@ -105,11 +105,11 @@ extern PTR _objalloc_alloc PARAMS ((struct objalloc *, unsigned long));\n \n /* Free an entire objalloc structure.  */\n \n-extern void objalloc_free PARAMS ((struct objalloc *));\n+extern void objalloc_free (struct objalloc *);\n \n /* Free a block allocated by objalloc_alloc.  This also frees all more\n    recently allocated blocks.  */\n \n-extern void objalloc_free_block PARAMS ((struct objalloc *, PTR));\n+extern void objalloc_free_block (struct objalloc *, PTR);\n \n #endif /* OBJALLOC_H */"}, {"sha": "6e397ce2eb3bd4f4ce701aa127ed294e27b97761", "filename": "include/obstack.h", "status": "modified", "additions": 3, "deletions": 69, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fobstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fobstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fobstack.h?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -1,6 +1,6 @@\n /* obstack.h - object stack macros\n    Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,\n-   1999, 2000\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n \n@@ -145,11 +145,7 @@ extern \"C\" {\n \n #if defined _LIBC || defined HAVE_STRING_H\n # include <string.h>\n-# if defined __STDC__ && __STDC__\n-#  define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n-# else\n-#  define _obstack_memcpy(To, From, N) memcpy ((To), (char *)(From), (N))\n-# endif\n+# define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n #else\n # ifdef memcpy\n #  define _obstack_memcpy(To, From, N) memcpy ((To), (char *)(From), (N))\n@@ -174,18 +170,12 @@ struct obstack\t\t/* control current object in current chunk */\n   char\t*chunk_limit;\t\t/* address of char after current chunk */\n   PTR_INT_TYPE temp;\t\t/* Temporary for some macros.  */\n   int   alignment_mask;\t\t/* Mask of alignment for each object. */\n-#if defined __STDC__ && __STDC__\n   /* These prototypes vary based on `use_extra_arg', and we use\n      casts to the prototypeless function type in all assignments,\n      but having prototypes here quiets -Wstrict-prototypes.  */\n   struct _obstack_chunk *(*chunkfun) (void *, long);\n   void (*freefun) (void *, struct _obstack_chunk *);\n   void *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n-#else\n-  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */\n-  void (*freefun) ();\t\t/* User's function to free a chunk.  */\n-  char *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n-#endif\n   unsigned use_extra_arg:1;\t/* chunk alloc/dealloc funcs take extra arg */\n   unsigned maybe_empty_object:1;/* There is a possibility that the current\n \t\t\t\t   chunk contains a zero-length object.  This\n@@ -198,7 +188,6 @@ struct obstack\t\t/* control current object in current chunk */\n \n /* Declare the external functions we use; they are in obstack.c.  */\n \n-#if defined __STDC__ && __STDC__\n extern void _obstack_newchunk (struct obstack *, int);\n extern void _obstack_free (struct obstack *, void *);\n extern int _obstack_begin (struct obstack *, int, int,\n@@ -207,16 +196,7 @@ extern int _obstack_begin_1 (struct obstack *, int, int,\n \t\t\t     void *(*) (void *, long),\n \t\t\t     void (*) (void *, void *), void *);\n extern int _obstack_memory_used (struct obstack *);\n-#else\n-extern void _obstack_newchunk ();\n-extern void _obstack_free ();\n-extern int _obstack_begin ();\n-extern int _obstack_begin_1 ();\n-extern int _obstack_memory_used ();\n-#endif\n \f\n-#if defined __STDC__ && __STDC__\n-\n /* Do the function-declarations after the structs\n    but before defining the macros.  */\n \n@@ -255,19 +235,10 @@ int obstack_alignment_mask (struct obstack *obstack);\n int obstack_chunk_size (struct obstack *obstack);\n int obstack_memory_used (struct obstack *obstack);\n \n-#endif /* __STDC__ */\n-\n-/* Non-ANSI C cannot really support alternative functions for these macros,\n-   so we do not declare them.  */\n-\n /* Error handler called when `obstack_chunk_alloc' failed to allocate\n    more memory.  This can be set to a user defined function.  The\n    default action is to print a message and abort.  */\n-#if defined __STDC__ && __STDC__\n extern void (*obstack_alloc_failed_handler) (void);\n-#else\n-extern void (*obstack_alloc_failed_handler) ();\n-#endif\n \n /* Exit value used when `print_and_abort' is used.  */\n extern int obstack_exit_failure;\n@@ -292,8 +263,6 @@ extern int obstack_exit_failure;\n \n /* To prevent prototype warnings provide complete argument list in\n    standard C version.  */\n-#if defined __STDC__ && __STDC__\n-\n # define obstack_init(h) \\\n   _obstack_begin ((h), 0, 0, \\\n \t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n@@ -317,32 +286,6 @@ extern int obstack_exit_failure;\n # define obstack_freefun(h, newfreefun) \\\n   ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))\n \n-#else\n-\n-# define obstack_init(h) \\\n-  _obstack_begin ((h), 0, 0, \\\n-\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n-\n-# define obstack_begin(h, size) \\\n-  _obstack_begin ((h), (size), 0, \\\n-\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n-\n-# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n-  _obstack_begin ((h), (size), (alignment), \\\n-\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))\n-\n-# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n-  _obstack_begin_1 ((h), (size), (alignment), \\\n-\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))\n-\n-# define obstack_chunkfun(h, newchunkfun) \\\n-  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))\n-\n-# define obstack_freefun(h, newfreefun) \\\n-  ((h) -> freefun = (void (*)()) (newfreefun))\n-\n-#endif\n-\n #define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))\n \n #define obstack_blank_fast(h,n) ((h)->next_free += (n))\n@@ -586,21 +529,12 @@ __extension__\t\t\t\t\t\t\t\t\\\n   (h)->object_base = (h)->next_free,\t\t\t\t\t\\\n   __INT_TO_PTR ((h)->temp))\n \n-# if defined __STDC__ && __STDC__\n-#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n+# define obstack_free(h,obj)\t\t\t\t\t\t\\\n ( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n   (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n    ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n \t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n    : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))\n-# else\n-#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n-  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n-   ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n-\t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n-   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))\n-# endif\n \n #endif /* not __GNUC__ or not __STDC__ */\n "}, {"sha": "0cf3fbcb32d4b963b5b2fefb19fa038a2d5d3e0d", "filename": "include/partition.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fpartition.h?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -64,13 +64,10 @@ typedef struct partition_def\n   struct partition_elem elements[1];\n } *partition;\n \n-extern partition partition_new          PARAMS((int));\n-extern void partition_delete            PARAMS((partition));\n-extern int partition_union              PARAMS((partition,\n-\t\t\t\t\t\tint,\n-\t\t\t\t\t\tint));\n-extern void partition_print             PARAMS((partition,\n-\t\t\t\t\t\tFILE*));\n+extern partition partition_new (int);\n+extern void partition_delete (partition);\n+extern int partition_union (partition, int, int);\n+extern void partition_print (partition,\tFILE*);\n \n /* Returns the canonical element corresponding to the class containing\n    ELEMENT__ in PARTITION__.  */"}, {"sha": "bcd2a3d442523e89f26f2591afa2502a8a3e91d9", "filename": "include/splay-tree.h", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/include%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsplay-tree.h?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -52,30 +52,30 @@ typedef struct splay_tree_node_s *splay_tree_node;\n \n /* The type of a function which compares two splay-tree keys.  The\n    function should return values as for qsort.  */\n-typedef int (*splay_tree_compare_fn) PARAMS((splay_tree_key, splay_tree_key));\n+typedef int (*splay_tree_compare_fn) (splay_tree_key, splay_tree_key);\n \n /* The type of a function used to deallocate any resources associated\n    with the key.  */\n-typedef void (*splay_tree_delete_key_fn) PARAMS((splay_tree_key));\n+typedef void (*splay_tree_delete_key_fn) (splay_tree_key);\n \n /* The type of a function used to deallocate any resources associated\n    with the value.  */\n-typedef void (*splay_tree_delete_value_fn) PARAMS((splay_tree_value));\n+typedef void (*splay_tree_delete_value_fn) (splay_tree_value);\n \n /* The type of a function used to iterate over the tree.  */\n-typedef int (*splay_tree_foreach_fn) PARAMS((splay_tree_node, void*));\n+typedef int (*splay_tree_foreach_fn) (splay_tree_node, void*);\n \n /* The type of a function used to allocate memory for tree root and\n    node structures.  The first argument is the number of bytes needed;\n    the second is a data pointer the splay tree functions pass through\n    to the allocator.  This function must never return zero.  */\n-typedef PTR (*splay_tree_allocate_fn) PARAMS((int, void *));\n+typedef PTR (*splay_tree_allocate_fn) (int, void *);\n \n /* The type of a function used to free memory allocated using the\n    corresponding splay_tree_allocate_fn.  The first argument is the\n    memory to be freed; the latter is a data pointer the splay tree\n    functions pass through to the freer.  */\n-typedef void (*splay_tree_deallocate_fn) PARAMS((void *, void *));\n+typedef void (*splay_tree_deallocate_fn) (void *, void *);\n \n /* The nodes in the splay tree.  */\n struct splay_tree_node_s GTY(())\n@@ -114,43 +114,28 @@ struct splay_tree_s GTY(())\n };\n typedef struct splay_tree_s *splay_tree;\n \n-extern splay_tree splay_tree_new        PARAMS((splay_tree_compare_fn,\n-\t\t\t\t\t        splay_tree_delete_key_fn,\n-\t\t\t\t\t        splay_tree_delete_value_fn));\n-extern splay_tree splay_tree_new_with_allocator\n-                                        PARAMS((splay_tree_compare_fn,\n-\t\t\t\t\t        splay_tree_delete_key_fn,\n+extern splay_tree splay_tree_new        (splay_tree_compare_fn,\n+                                         splay_tree_delete_key_fn,\n+                                         splay_tree_delete_value_fn);\n+extern splay_tree splay_tree_new_with_allocator (splay_tree_compare_fn,\n+                                                 splay_tree_delete_key_fn,\n \t\t\t\t\t        splay_tree_delete_value_fn,\n-                                                splay_tree_allocate_fn,\n-                                                splay_tree_deallocate_fn,\n-                                                void *));\n-extern void splay_tree_delete           PARAMS((splay_tree));\n-extern splay_tree_node splay_tree_insert          \n-\t\t                        PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_key,\n-\t\t\t\t\t        splay_tree_value));\n-extern void splay_tree_remove\t\tPARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern splay_tree_node splay_tree_lookup   \n-                                        PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_key));\n-extern splay_tree_node splay_tree_predecessor\n-                                        PARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern splay_tree_node splay_tree_successor\n-                                        PARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern splay_tree_node splay_tree_max\n-                                        PARAMS((splay_tree));\n-extern splay_tree_node splay_tree_min\n-                                        PARAMS((splay_tree));\n-extern int splay_tree_foreach           PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_foreach_fn,\n-\t\t\t\t\t        void*));\n-extern int splay_tree_compare_ints      PARAMS((splay_tree_key,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern int splay_tree_compare_pointers  PARAMS((splay_tree_key,\n-\t\t\t\t\t\tsplay_tree_key));\n+                                                 splay_tree_allocate_fn,\n+                                                 splay_tree_deallocate_fn,\n+                                                 void *);\n+extern void splay_tree_delete           (splay_tree);\n+extern splay_tree_node splay_tree_insert (splay_tree,\n+                                          splay_tree_key,\n+                                          splay_tree_value);\n+extern void splay_tree_remove\t(splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_lookup (splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_predecessor (splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_successor (splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_max (splay_tree);\n+extern splay_tree_node splay_tree_min (splay_tree);\n+extern int splay_tree_foreach (splay_tree, splay_tree_foreach_fn, void*);\n+extern int splay_tree_compare_ints (splay_tree_key, splay_tree_key);\n+extern int splay_tree_compare_pointers (splay_tree_key,\tsplay_tree_key);\n \t\t\t\t\t       \n #ifdef __cplusplus\n }"}, {"sha": "8eb73b70bd48bfaa97c32f860c111999d21d1dcd", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -1,3 +1,48 @@\n+2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert libiberty to use ISO C prototype style 5/n.\n+\t* random.c (srandom, initstate, setstate, random): Use ISO C\n+\tprototypes. \n+\t* putenv.c (putenv): Likewise.\n+\t* physmem.c (physmem_available, physmem_total, main): Likewise.\n+\t* pex-win32.c (fix_argv, pexecute, pwait): Likewise.\n+\t* pex-unix.c (pexecute, pwait): Likewise.\n+\t* pex-msdos.c (pexecute, pwait): Likewise.\n+\t* pex-djgpp.c (pexecute, pwait): Likewise.\n+\t* partition.c (partition_new, partition_delete, partition_union) \n+\t(elem_compare, partition_print): Likewise.\n+\t* obstack.c (_obstack_begin, _obstack_begin_1, _obstack_newchunk, \n+\t_obstack_allocated_p, _obstack_free, obstack_free, \n+\t_obstack_memory_used, print_and_abort, obstack_next_free,\n+\tobstack_object_size, obstack_base): Likewise.  Remove codes\n+\tpredicated on !defined(__STDC__).\n+\t* objalloc.c (objalloc_create, _objalloc_alloc, objalloc_free, \n+\tobjalloc_free_block): Use ISO C prototypes.\n+\t* mkstemps.c (mkstemps): Likewise.\n+\t* memset.c (memset): Likewise.\n+\t* mempcpy.c (mempcpy): Likewise.\n+\t* rename.c (rename): Likewise.\n+\t* rindex.c (rindex): Likewise.\n+\t* setenv.c (setenv, unsetenv): Likewise.\n+\t* sigsetmask.c (sigsetmask): Likewise.\n+\t* snprintf.c (snprintf): Likewise.\n+\t* sort.c (sort_pointers, xmalloc): Likewise. \n+\t* spaces.c (spaces): Likewise.\n+\t* splay-tree.c (splay_tree_delete_helper, \n+\tsplay_tree_splay_helper, splay_tree_splay, \n+\tsplay_tree_foreach_helper, splay_tree_xmalloc_allocate,\n+\tsplay_tree_new, splay_tree_xmalloc_allocate, \n+\tsplay_tree_new_with_allocator, splay_tree_delete,\n+\tsplay_tree_insert, splay_tree_remove, splay_tree_lookup, \n+\tsplay_tree_max, splay_tree_min, splay_tree_predecessor, \n+\tsplay_tree_successor, splay_tree_foreach, \n+\tsplay_tree_compare_ints, splay_tree_compare_pointers): Likewise.\n+\t* stpcpy.c (stpcpy): Likewise.\n+\t* stpncpy.c (stpncpy): Likewise.\n+\t* strcasecmp.c (strcasecmp): Likewise.\n+\t* strchr.c (strchr): Likewise.\n+\t* strdup.c (strdup): Likewise.\n+\n 2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tConvert libiberty to use ISO C prototype style 6/n."}, {"sha": "ebd105c3e4471d9132fe446c2fa5350b7122fac9", "filename": "libiberty/mempcpy.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fmempcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fmempcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmempcpy.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -1,5 +1,5 @@\n /* Implement the mempcpy function.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n    Written by Kaveh R. Ghazi <ghazi@caip.rutgers.edu>.\n \n This file is part of the libiberty library.\n@@ -30,19 +30,12 @@ Copies @var{length} bytes from memory region @var{in} to region\n */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n-extern PTR memcpy PARAMS ((PTR, const PTR, size_t));\n+extern PTR memcpy (PTR, const PTR, size_t);\n \n PTR\n-mempcpy (dst, src, len)\n-     PTR dst;\n-     const PTR src;\n-     size_t len;\n+mempcpy (PTR dst, const PTR src, size_t len)\n {\n   return (char *) memcpy (dst, src, len) + len;\n }"}, {"sha": "1951ad6bd610c836367f8d0299f44f9ec13f8f7c", "filename": "libiberty/memset.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fmemset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fmemset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemset.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -13,17 +13,10 @@ Sets the first @var{count} bytes of @var{s} to the constant byte\n */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n PTR\n-memset (dest, val, len)\n-     PTR dest;\n-     register int val;\n-     register size_t len;\n+memset (PTR dest, register int val, register size_t len)\n {\n   register unsigned char *ptr = (unsigned char*)dest;\n   while (len-- > 0)"}, {"sha": "5963f58baf4ed5f5455d2fd5a3e1252eda70f54f", "filename": "libiberty/mkstemps.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fmkstemps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fmkstemps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmkstemps.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -71,9 +71,7 @@ reading and writing.\n */\n \n int\n-mkstemps (template, suffix_len)\n-     char *template;\n-     int suffix_len;\n+mkstemps (char *template, int suffix_len)\n {\n   static const char letters[]\n     = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";"}, {"sha": "a06047d00f619e9941a71480a31255fe4528d170", "filename": "libiberty/objalloc.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fobjalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fobjalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fobjalloc.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -39,8 +39,8 @@ Boston, MA 02111-1307, USA.  */\n #include <stdlib.h>\n #else\n /* For systems with larger pointers than ints, this must be declared.  */\n-extern PTR malloc PARAMS ((size_t));\n-extern void free PARAMS ((PTR));\n+extern PTR malloc (size_t);\n+extern void free (PTR);\n #endif\n \n #endif\n@@ -85,7 +85,7 @@ struct objalloc_chunk\n /* Create an objalloc structure.  */\n \n struct objalloc *\n-objalloc_create ()\n+objalloc_create (void)\n {\n   struct objalloc *ret;\n   struct objalloc_chunk *chunk;\n@@ -114,9 +114,7 @@ objalloc_create ()\n /* Allocate space from an objalloc structure.  */\n \n PTR\n-_objalloc_alloc (o, len)\n-     struct objalloc *o;\n-     unsigned long len;\n+_objalloc_alloc (struct objalloc *o, unsigned long len)\n {\n   /* We avoid confusion from zero sized objects by always allocating\n      at least 1 byte.  */\n@@ -171,8 +169,7 @@ _objalloc_alloc (o, len)\n /* Free an entire objalloc structure.  */\n \n void\n-objalloc_free (o)\n-     struct objalloc *o;\n+objalloc_free (struct objalloc *o)\n {\n   struct objalloc_chunk *l;\n \n@@ -193,9 +190,7 @@ objalloc_free (o)\n    recently allocated blocks.  */\n \n void\n-objalloc_free_block (o, block)\n-     struct objalloc *o;\n-     PTR block;\n+objalloc_free_block (struct objalloc *o, PTR block)\n {\n   struct objalloc_chunk *p, *small;\n   char *b = (char *) block;"}, {"sha": "1e12a8716e085ad4be31b2715a6f2e835fe33d4a", "filename": "libiberty/obstack.c", "status": "modified", "additions": 26, "deletions": 109, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fobstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fobstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fobstack.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -52,11 +52,7 @@\n #ifndef ELIDE_CODE\n \n \n-#if defined (__STDC__) && __STDC__\n #define POINTER void *\n-#else\n-#define POINTER char *\n-#endif\n \n /* Determine default alignment.  */\n struct fooalign {char x; double d;};\n@@ -81,13 +77,8 @@ union fooround {long x; double d;};\n    jump to the handler pointed to by `obstack_alloc_failed_handler'.\n    This variable by default points to the internal function\n    `print_and_abort'.  */\n-#if defined (__STDC__) && __STDC__\n static void print_and_abort (void);\n void (*obstack_alloc_failed_handler) (void) = print_and_abort;\n-#else\n-static void print_and_abort ();\n-void (*obstack_alloc_failed_handler) () = print_and_abort;\n-#endif\n \n /* Exit value used when `print_and_abort' is used.  */\n #if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H\n@@ -148,17 +139,8 @@ struct obstack *_obstack;\n    free up some memory, then call this again.  */\n \n int\n-_obstack_begin (h, size, alignment, chunkfun, freefun)\n-     struct obstack *h;\n-     int size;\n-     int alignment;\n-#if defined (__STDC__) && __STDC__\n-     POINTER (*chunkfun) (long);\n-     void (*freefun) (void *);\n-#else\n-     POINTER (*chunkfun) ();\n-     void (*freefun) ();\n-#endif\n+_obstack_begin (struct obstack *h, int size, int alignment,\n+                POINTER (*chunkfun) (long), void (*freefun) (void *))\n {\n   register struct _obstack_chunk *chunk; /* points to new chunk */\n \n@@ -181,13 +163,8 @@ _obstack_begin (h, size, alignment, chunkfun, freefun)\n       size = 4096 - extra;\n     }\n \n-#if defined (__STDC__) && __STDC__\n   h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n   h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n-#else\n-  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n-  h->freefun = freefun;\n-#endif\n   h->chunk_size = size;\n   h->alignment_mask = alignment - 1;\n   h->use_extra_arg = 0;\n@@ -206,18 +183,9 @@ _obstack_begin (h, size, alignment, chunkfun, freefun)\n }\n \n int\n-_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n-     struct obstack *h;\n-     int size;\n-     int alignment;\n-#if defined (__STDC__) && __STDC__\n-     POINTER (*chunkfun) (POINTER, long);\n-     void (*freefun) (POINTER, POINTER);\n-#else\n-     POINTER (*chunkfun) ();\n-     void (*freefun) ();\n-#endif\n-     POINTER arg;\n+_obstack_begin_1 (struct obstack *h, int size, int alignment,\n+                  POINTER (*chunkfun) (POINTER, long),\n+                  void (*freefun) (POINTER, POINTER), POINTER arg)\n {\n   register struct _obstack_chunk *chunk; /* points to new chunk */\n \n@@ -240,13 +208,8 @@ _obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n       size = 4096 - extra;\n     }\n \n-#if defined(__STDC__) && __STDC__\n   h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n   h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n-#else\n-  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n-  h->freefun = freefun;\n-#endif\n   h->chunk_size = size;\n   h->alignment_mask = alignment - 1;\n   h->extra_arg = arg;\n@@ -272,9 +235,7 @@ _obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n    to the beginning of the new one.  */\n \n void\n-_obstack_newchunk (h, length)\n-     struct obstack *h;\n-     int length;\n+_obstack_newchunk (struct obstack *h, int length)\n {\n   register struct _obstack_chunk *old_chunk = h->chunk;\n   register struct _obstack_chunk *new_chunk;\n@@ -335,16 +296,12 @@ _obstack_newchunk (h, length)\n    This is here for debugging.\n    If you use it in a program, you are probably losing.  */\n \n-#if defined (__STDC__) && __STDC__\n /* Suppress -Wmissing-prototypes warning.  We don't want to declare this in\n    obstack.h because it is just for debugging.  */\n int _obstack_allocated_p (struct obstack *h, POINTER obj);\n-#endif\n \n int\n-_obstack_allocated_p (h, obj)\n-     struct obstack *h;\n-     POINTER obj;\n+_obstack_allocated_p (struct obstack *h, POINTER obj)\n {\n   register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n   register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n@@ -370,9 +327,7 @@ _obstack_allocated_p (h, obj)\n    This is the first one, called from non-ANSI code.  */\n \n void\n-_obstack_free (h, obj)\n-     struct obstack *h;\n-     POINTER obj;\n+_obstack_free (struct obstack *h, POINTER obj)\n {\n   register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n   register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n@@ -404,9 +359,7 @@ _obstack_free (h, obj)\n /* This function is used from ANSI code.  */\n \n void\n-obstack_free (h, obj)\n-     struct obstack *h;\n-     POINTER obj;\n+obstack_free (struct obstack *h, POINTER obj)\n {\n   register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n   register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n@@ -436,8 +389,7 @@ obstack_free (h, obj)\n }\n \f\n int\n-_obstack_memory_used (h)\n-     struct obstack *h;\n+_obstack_memory_used (struct obstack *h)\n {\n   register struct _obstack_chunk* lp;\n   register int nbytes = 0;\n@@ -462,7 +414,7 @@ _obstack_memory_used (h)\n #endif\n \n static void\n-print_and_abort ()\n+print_and_abort (void)\n {\n   fputs (_(\"memory exhausted\\n\"), stderr);\n   exit (obstack_exit_failure);\n@@ -475,119 +427,84 @@ print_and_abort ()\n /* Now define the functional versions of the obstack macros.\n    Define them to simply use the corresponding macros to do the job.  */\n \n-#if defined (__STDC__) && __STDC__\n-/* These function definitions do not work with non-ANSI preprocessors;\n-   they won't pass through the macro names in parentheses.  */\n-\n /* The function names appear in parentheses in order to prevent\n    the macro-definitions of the names from being expanded there.  */\n \n-POINTER (obstack_base) (obstack)\n-     struct obstack *obstack;\n+POINTER (obstack_base) (struct obstack *obstack)\n {\n   return obstack_base (obstack);\n }\n \n-POINTER (obstack_next_free) (obstack)\n-     struct obstack *obstack;\n+POINTER (obstack_next_free) (struct obstack *obstack)\n {\n   return obstack_next_free (obstack);\n }\n \n-int (obstack_object_size) (obstack)\n-     struct obstack *obstack;\n+int (obstack_object_size) (struct obstack *obstack)\n {\n   return obstack_object_size (obstack);\n }\n \n-int (obstack_room) (obstack)\n-     struct obstack *obstack;\n+int (obstack_room) (struct obstack *obstack)\n {\n   return obstack_room (obstack);\n }\n \n-int (obstack_make_room) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n+int (obstack_make_room) (struct obstack *obstack, int length)\n {\n   return obstack_make_room (obstack, length);\n }\n \n-void (obstack_grow) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n+void (obstack_grow) (struct obstack *obstack, POINTER pointer, int length)\n {\n   obstack_grow (obstack, pointer, length);\n }\n \n-void (obstack_grow0) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n+void (obstack_grow0) (struct obstack *obstack, POINTER pointer, int length)\n {\n   obstack_grow0 (obstack, pointer, length);\n }\n \n-void (obstack_1grow) (obstack, character)\n-     struct obstack *obstack;\n-     int character;\n+void (obstack_1grow) (struct obstack *obstack, int character)\n {\n   obstack_1grow (obstack, character);\n }\n \n-void (obstack_blank) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n+void (obstack_blank) (struct obstack *obstack, int length)\n {\n   obstack_blank (obstack, length);\n }\n \n-void (obstack_1grow_fast) (obstack, character)\n-     struct obstack *obstack;\n-     int character;\n+void (obstack_1grow_fast) (struct obstack *obstack, int character)\n {\n   obstack_1grow_fast (obstack, character);\n }\n \n-void (obstack_blank_fast) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n+void (obstack_blank_fast) (struct obstack *obstack, int length)\n {\n   obstack_blank_fast (obstack, length);\n }\n \n-POINTER (obstack_finish) (obstack)\n-     struct obstack *obstack;\n+POINTER (obstack_finish) (struct obstack *obstack)\n {\n   return obstack_finish (obstack);\n }\n \n-POINTER (obstack_alloc) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n+POINTER (obstack_alloc) (struct obstack *obstack, int length)\n {\n   return obstack_alloc (obstack, length);\n }\n \n-POINTER (obstack_copy) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n+POINTER (obstack_copy) (struct obstack *obstack, POINTER pointer, int length)\n {\n   return obstack_copy (obstack, pointer, length);\n }\n \n-POINTER (obstack_copy0) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n+POINTER (obstack_copy0) (struct obstack *obstack, POINTER pointer, int length)\n {\n   return obstack_copy0 (obstack, pointer, length);\n }\n \n-#endif /* __STDC__ */\n-\n #endif /* 0 */\n \n #endif\t/* !ELIDE_CODE */"}, {"sha": "b67f0583778710d76d0d530350e440b5abceba11", "filename": "libiberty/partition.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpartition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpartition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpartition.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -40,8 +40,7 @@ static int elem_compare PARAMS ((const void *, const void *));\n    element is in a class by itself.  */\n \n partition\n-partition_new (num_elements)\n-     int num_elements;\n+partition_new (int num_elements)\n {\n   int e;\n   \n@@ -62,8 +61,7 @@ partition_new (num_elements)\n /* Freeds a partition.  */\n \n void\n-partition_delete (part)\n-      partition part;\n+partition_delete (partition part)\n {\n   free (part);\n }\n@@ -74,10 +72,7 @@ partition_delete (part)\n    resulting union class.  */\n \n int\n-partition_union (part, elem1, elem2)\n-     partition part;\n-     int elem1;\n-     int elem2;\n+partition_union (partition part, int elem1, int elem2)\n {\n   struct partition_elem *elements = part->elements;\n   struct partition_elem *e1;\n@@ -126,9 +121,7 @@ partition_union (part, elem1, elem2)\n    pointer to each.  Used to qsort such an array.  */\n \n static int \n-elem_compare (elem1, elem2)\n-     const void *elem1;\n-     const void *elem2;\n+elem_compare (const void *elem1, const void *elem2)\n {\n   int e1 = * (const int *) elem1;\n   int e2 = * (const int *) elem2;\n@@ -144,9 +137,7 @@ elem_compare (elem1, elem2)\n    class are sorted.  */\n \n void\n-partition_print (part, fp)\n-     partition part;\n-     FILE *fp;\n+partition_print (partition part, FILE *fp)\n {\n   char *done;\n   int num_elements = part->num_elements;"}, {"sha": "fe5b80b37dc227adf343954b231d5f7441f953b6", "filename": "libiberty/pex-djgpp.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-djgpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-djgpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-djgpp.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -49,13 +49,9 @@ static int last_status = 0;\n static int last_reaped = 0;\n \n int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n+pexecute (const char *program, char * const *argv, const char *this_pname,\n+          const char *temp_base, char **errmsg_fmt,\n+          char **errmsg_arg, int flags)\n {\n   int rc;\n \n@@ -82,10 +78,7 @@ pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n }\n \n int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n+pwait (int pid, int *status, int flags)\n {\n   /* On MSDOS each pexecute must be followed by its associated pwait.  */\n   if (pid != last_pid"}, {"sha": "f91e416a66f4099a70fa1b4267919aa9a0ede488", "filename": "libiberty/pex-msdos.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-msdos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-msdos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-msdos.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -47,13 +47,9 @@ static int last_status = 0;\n static int last_reaped = 0;\n \n int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n+pexecute (const char *program, char * const *argv, const char *this_pname,\n+          const char *temp_base, char **errmsg_fmt, char **errmsg_arg,\n+          int flags)\n {\n   int rc;\n   char *scmd, *rf;\n@@ -126,10 +122,7 @@ pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n #endif\n \n int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n+pwait (int pid, int *status, int flags)\n {\n   /* On MSDOS each pexecute must be followed by its associated pwait.  */\n   if (pid != last_pid"}, {"sha": "0c5f85c3528f185d38411a2b770a5db1de53bdc9", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -1,7 +1,7 @@\n /* Utilities to execute a program in a subprocess (possibly linked by pipes\n    with other subprocesses), and wait for it.  Generic Unix version\n    (also used for UWIN and VMS).\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n This file is part of the libiberty library.\n@@ -80,14 +80,9 @@ extern int errno;\n    exactly once and is not an argument, or is marked volatile.  */\n \n int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg,\n-\t  flagsarg)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base ATTRIBUTE_UNUSED;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flagsarg;\n+pexecute (const char *program, char * const *argv, const char *this_pname,\n+          const char *temp_base ATTRIBUTE_UNUSED,\n+          char **errmsg_fmt, char **errmsg_arg, int flagsarg)\n {\n   int pid;\n   int pdes[2];\n@@ -203,10 +198,7 @@ pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg,\n }\n \n int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags ATTRIBUTE_UNUSED;\n+pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)\n {\n   /* ??? Here's an opportunity to canonicalize the values in STATUS.\n      Needed?  */"}, {"sha": "8d3cb9731dbb459448693c3658a7f505855b9e30", "filename": "libiberty/pex-win32.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -1,6 +1,6 @@\n /* Utilities to execute a program in a subprocess (possibly linked by pipes\n    with other subprocesses), and wait for it.  Generic Win32 specialization.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n This file is part of the libiberty library.\n@@ -53,8 +53,7 @@ Boston, MA 02111-1307, USA.  */\n    to remove the outermost set of double quotes from all arguments.  */\n \n static const char * const *\n-fix_argv (argvec)\n-     char **argvec;\n+fix_argv (char **argvec)\n {\n   int i;\n   char * command0 = argvec[0];\n@@ -138,13 +137,10 @@ fix_argv (argvec)\n \n /* Win32 supports pipes */\n int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname ATTRIBUTE_UNUSED;\n-     const char *temp_base ATTRIBUTE_UNUSED;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n+pexecute (const char *program, char * const *argv,\n+          const char *this_pname ATTRIBUTE_UNUSED,\n+          const char *temp_base ATTRIBUTE_UNUSED,\n+          char **errmsg_fmt, char **errmsg_arg, int flags)\n {\n   int pid;\n   int pdes[2];\n@@ -230,10 +226,7 @@ pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n    macros. Note that WIFSIGNALED will never be true under CRTDLL. */\n \n int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags ATTRIBUTE_UNUSED;\n+pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)\n {\n   int termstat;\n "}, {"sha": "9c6d9cb80595e74e96f3a8fde95c11c3aee6fc13", "filename": "libiberty/physmem.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fphysmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fphysmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fphysmem.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -1,5 +1,5 @@\n /* Calculate the size of physical memory.\n-   Copyright 2000, 2001, 2003 Free Software Foundation, Inc.\n+   Copyright 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -80,7 +80,7 @@ typedef WINBOOL (WINAPI *PFN_MS_EX) (lMEMORYSTATUSEX*);\n \n /* Return the total amount of physical memory.  */\n double\n-physmem_total ()\n+physmem_total (void)\n {\n #if defined _SC_PHYS_PAGES && defined _SC_PAGESIZE\n   { /* This works on linux-gnu, solaris2 and cygwin.  */\n@@ -184,7 +184,7 @@ physmem_total ()\n \n /* Return the amount of physical memory available.  */\n double\n-physmem_available ()\n+physmem_available (void)\n {\n #if defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n   { /* This works on linux-gnu, solaris2 and cygwin.  */\n@@ -290,7 +290,7 @@ physmem_available ()\n # include <stdlib.h>\n \n int\n-main ()\n+main (void)\n {\n   printf (\"%12.f %12.f\\n\", physmem_total (), physmem_available ());\n   exit (0);"}, {"sha": "e04b759104b1aa6565168585086f6e407e70f45e", "filename": "libiberty/putenv.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fputenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fputenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fputenv.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -67,8 +67,7 @@ extern char *alloca ();\n \n /* Put STRING, which is of the form \"NAME=VALUE\", in the environment.  */\n int\n-putenv (string)\n-     const char *string;\n+putenv (const char *string)\n {\n   const char *const name_end = strchr (string, '=');\n "}, {"sha": "c306698a53896a4874c02bc2d8d7129a2b25baff", "filename": "libiberty/random.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frandom.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -80,7 +80,7 @@ control over the state of the random number generator.\n \n #endif\n \n-long int random ();\n+long int random (void);\n \n /* An improved random number generation package.  In addition to the standard\n    rand()/srand() like interface, this package also has a special state info\n@@ -227,8 +227,7 @@ static long int *end_ptr = &randtbl[sizeof(randtbl) / sizeof(randtbl[0])];\n    introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]\n    for default usage relies on values produced by this routine.  */\n void\n-srandom (x)\n-  unsigned int x;\n+srandom (unsigned int x)\n {\n   state[0] = x;\n   if (rand_type != TYPE_0)\n@@ -255,10 +254,7 @@ srandom (x)\n    setstate so that it doesn't matter when initstate is called.\n    Returns a pointer to the old state.  */\n PTR\n-initstate (seed, arg_state, n)\n-  unsigned int seed;\n-  PTR arg_state;\n-  unsigned long n;\n+initstate (unsigned int seed, PTR arg_state, unsigned long n)\n {\n   PTR ostate = (PTR) &state[-1];\n \n@@ -324,8 +320,7 @@ initstate (seed, arg_state, n)\n    Returns a pointer to the old state information.  */\n \n PTR\n-setstate (arg_state)\n-  PTR arg_state;\n+setstate (PTR arg_state)\n {\n   register long int *new_state = (long int *) arg_state;\n   register int type = new_state[0] % MAX_TYPES;\n@@ -378,7 +373,7 @@ setstate (arg_state)\n    pointer if the front one has wrapped.  Returns a 31-bit random number.  */\n \n long int\n-random ()\n+random (void)\n {\n   if (rand_type == TYPE_0)\n     {"}, {"sha": "ad342ffca65c59479667d11b77ba2ac8e52ee58a", "filename": "libiberty/rename.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Frename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Frename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frename.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -22,9 +22,7 @@ exists, it is removed.\n #endif\n \n int\n-rename (zfrom, zto)\n-     const char *zfrom;\n-     const char *zto;\n+rename (const char *zfrom, const char *zto)\n {\n   if (link (zfrom, zto) < 0)\n     {"}, {"sha": "741fd8ecb7ce44e7001087f55d426dd4fb763609", "filename": "libiberty/rindex.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Frindex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Frindex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frindex.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -15,9 +15,7 @@ deprecated in new programs in favor of @code{strrchr}.\n extern char *strrchr ();\n \n char *\n-rindex (s, c)\n-  char *s;\n-  int c;\n+rindex (char *s, int c)\n {\n   return strrchr (s, c);\n }"}, {"sha": "44ef99f50b79854baa25e193bdd71264a23dec60", "filename": "libiberty/safe-ctype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsafe-ctype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsafe-ctype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsafe-ctype.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -1,6 +1,7 @@\n /* <ctype.h> replacement macros.\n \n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004,\n+   2005 Free Software Foundation, Inc.\n    Contributed by Zack Weinberg <zackw@stanford.edu>.\n \n This file is part of the libiberty library."}, {"sha": "35f2a314e87ddf7199549f91d5eb2e8c842334e0", "filename": "libiberty/setenv.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsetenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsetenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsetenv.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -80,10 +80,7 @@ static char **last_environ;\n \n \n int\n-setenv (name, value, replace)\n-     const char *name;\n-     const char *value;\n-     int replace;\n+setenv (const char *name, const char *value, int replace)\n {\n   register char **ep = 0;\n   register size_t size;\n@@ -164,8 +161,7 @@ setenv (name, value, replace)\n }\n \n void\n-unsetenv (name)\n-     const char *name;\n+unsetenv (const char *name)\n {\n   const size_t len = strlen (name);\n   char **ep;"}, {"sha": "2df96fca9478ba897024aabf3afd47739dfa1673", "filename": "libiberty/sigsetmask.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsigsetmask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsigsetmask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsigsetmask.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -21,12 +21,11 @@ be the value @code{1}).\n #include <sys/types.h>\n #include <signal.h>\n \n-extern void abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n+extern void abort (void) ATTRIBUTE_NORETURN;\n \n #ifdef SIG_SETMASK\n int\n-sigsetmask (set)\n-      int set;\n+sigsetmask (int set)\n {\n     sigset_t new;\n     sigset_t old;"}, {"sha": "d8eb5855ab566cb972f7c98717e8b847a917baae", "filename": "libiberty/snprintf.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsnprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsnprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsnprintf.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -41,18 +41,13 @@ this function is used.\n \n #include \"ansidecl.h\"\n \n-#ifdef ANSI_PROTOTYPES\n #include <stdarg.h>\n #include <stddef.h>\n-#else\n-#include <varargs.h>\n-#define size_t unsigned long\n-#endif\n \n-int vsnprintf PARAMS ((char *, size_t, const char *, va_list));\n+int vsnprintf (char *, size_t, const char *, va_list);\n \n int\n-snprintf VPARAMS ((char *s, size_t n, const char *format, ...))\n+snprintf (char *s, size_t n, const char *format, ...)\n {\n   int result;\n   VA_OPEN (ap, format);"}, {"sha": "a525b81e382743b8a4e427ed473a4303277d61cc", "filename": "libiberty/sort.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsort.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -44,10 +44,7 @@ Boston, MA 02111-1307, USA.  */\n /* POINTERS and WORK are both arrays of N pointers.  When this\n    function returns POINTERS will be sorted in ascending order.  */\n \n-void sort_pointers (n, pointers, work)\n-     size_t n;\n-     void **pointers;\n-     void **work;\n+void sort_pointers (size_t n, void **pointers, void **work)\n {\n   /* The type of a single digit.  This can be any unsigned integral\n      type.  When changing this, DIGIT_MAX should be changed as \n@@ -140,8 +137,7 @@ void sort_pointers (n, pointers, work)\n \n #include <stdio.h>\n \n-void *xmalloc (n)\n-     size_t n;\n+void *xmalloc (size_t n)\n {\n   return malloc (n);\n }"}, {"sha": "6df0b13f0d24b8a2a1bde8a1d8b492772d69010f", "filename": "libiberty/spaces.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fspaces.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fspaces.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fspaces.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -37,13 +37,12 @@ valid until at least the next call.\n #include <unixlib.h>\n #else\n /* For systems with larger pointers than ints, these must be declared.  */\n-extern PTR malloc PARAMS ((size_t));\n-extern void free PARAMS ((PTR));\n+extern PTR malloc (size_t);\n+extern void free (PTR);\n #endif\n \n const char *\n-spaces (count)\n-  int count;\n+spaces (int count)\n {\n   register char *t;\n   static char *buf;"}, {"sha": "29eaf16efb19b0aae0c24bbce586e124a70aefc9", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 35, "deletions": 78, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -37,27 +37,20 @@ Boston, MA 02111-1307, USA.  */\n #include \"libiberty.h\"\n #include \"splay-tree.h\"\n \n-static void splay_tree_delete_helper    PARAMS((splay_tree, \n-\t\t\t\t\t\tsplay_tree_node));\n-static void splay_tree_splay            PARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-static splay_tree_node splay_tree_splay_helper     \n-                                        PARAMS((splay_tree,\n+static void splay_tree_delete_helper (splay_tree, splay_tree_node);\n+static void splay_tree_splay (splay_tree, splay_tree_key);\n+static splay_tree_node splay_tree_splay_helper (splay_tree,\n \t\t\t\t\t\tsplay_tree_key,\n \t\t\t\t\t\tsplay_tree_node*,\n \t\t\t\t\t\tsplay_tree_node*,\n-\t\t\t\t\t\tsplay_tree_node*));\n-static int splay_tree_foreach_helper    PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_node,\n-\t\t\t\t\t\tsplay_tree_foreach_fn,\n-\t\t\t\t\t\tvoid*));\n+\t\t\t\t\t\tsplay_tree_node*);\n+static int splay_tree_foreach_helper (splay_tree, splay_tree_node,\n+                                      splay_tree_foreach_fn, void*);\n \n /* Deallocate NODE (a member of SP), and all its sub-trees.  */\n \n static void \n-splay_tree_delete_helper (sp, node)\n-     splay_tree sp;\n-     splay_tree_node node;\n+splay_tree_delete_helper (splay_tree sp, splay_tree_node node)\n {\n   splay_tree_node pending = 0;\n   splay_tree_node active = 0;\n@@ -118,12 +111,9 @@ splay_tree_delete_helper (sp, node)\n    and grandparent, respectively, of NODE.  */\n \n static splay_tree_node\n-splay_tree_splay_helper (sp, key, node, parent, grandparent)\n-     splay_tree sp;\n-     splay_tree_key key;\n-     splay_tree_node *node;\n-     splay_tree_node *parent;\n-     splay_tree_node *grandparent;\n+splay_tree_splay_helper (splay_tree sp, splay_tree_key key,\n+                         splay_tree_node *node, splay_tree_node *parent,\n+                         splay_tree_node *grandparent)\n {\n   splay_tree_node *next;\n   splay_tree_node n;\n@@ -229,9 +219,7 @@ splay_tree_splay_helper (sp, key, node, parent, grandparent)\n /* Splay SP around KEY.  */\n \n static void\n-splay_tree_splay (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_splay (splay_tree sp, splay_tree_key key)\n {\n   if (sp->root == 0)\n     return;\n@@ -246,11 +234,8 @@ splay_tree_splay (sp, key)\n    value is returned.  Otherwise, this function returns 0.  */\n \n static int\n-splay_tree_foreach_helper (sp, node, fn, data)\n-     splay_tree sp;\n-     splay_tree_node node;\n-     splay_tree_foreach_fn fn;\n-     void* data;\n+splay_tree_foreach_helper (splay_tree sp, splay_tree_node node,\n+                           splay_tree_foreach_fn fn, void *data)\n {\n   int val;\n \n@@ -271,17 +256,13 @@ splay_tree_foreach_helper (sp, node, fn, data)\n \n /* An allocator and deallocator based on xmalloc.  */\n static void *\n-splay_tree_xmalloc_allocate (size, data)\n-     int size;\n-     void *data ATTRIBUTE_UNUSED;\n+splay_tree_xmalloc_allocate (int size, void *data ATTRIBUTE_UNUSED)\n {\n   return (void *) xmalloc (size);\n }\n \n static void\n-splay_tree_xmalloc_deallocate (object, data)\n-     void *object;\n-     void *data ATTRIBUTE_UNUSED;\n+splay_tree_xmalloc_deallocate (void *object, void *data ATTRIBUTE_UNUSED)\n {\n   free (object);\n }\n@@ -293,10 +274,9 @@ splay_tree_xmalloc_deallocate (object, data)\n    nodes added.  */\n \n splay_tree \n-splay_tree_new (compare_fn, delete_key_fn, delete_value_fn)\n-     splay_tree_compare_fn compare_fn;\n-     splay_tree_delete_key_fn delete_key_fn;\n-     splay_tree_delete_value_fn delete_value_fn;\n+splay_tree_new (splay_tree_compare_fn compare_fn,\n+                splay_tree_delete_key_fn delete_key_fn,\n+                splay_tree_delete_value_fn delete_value_fn)\n {\n   return (splay_tree_new_with_allocator\n           (compare_fn, delete_key_fn, delete_value_fn,\n@@ -309,14 +289,12 @@ splay_tree_new (compare_fn, delete_key_fn, delete_value_fn)\n    values.  */\n \n splay_tree \n-splay_tree_new_with_allocator (compare_fn, delete_key_fn, delete_value_fn,\n-                               allocate_fn, deallocate_fn, allocate_data)\n-     splay_tree_compare_fn compare_fn;\n-     splay_tree_delete_key_fn delete_key_fn;\n-     splay_tree_delete_value_fn delete_value_fn;\n-     splay_tree_allocate_fn allocate_fn;\n-     splay_tree_deallocate_fn deallocate_fn;\n-     void *allocate_data;\n+splay_tree_new_with_allocator (splay_tree_compare_fn compare_fn,\n+                               splay_tree_delete_key_fn delete_key_fn,\n+                               splay_tree_delete_value_fn delete_value_fn,\n+                               splay_tree_allocate_fn allocate_fn,\n+                               splay_tree_deallocate_fn deallocate_fn,\n+                               void *allocate_data)\n {\n   splay_tree sp = (splay_tree) (*allocate_fn) (sizeof (struct splay_tree_s),\n                                                allocate_data);\n@@ -334,8 +312,7 @@ splay_tree_new_with_allocator (compare_fn, delete_key_fn, delete_value_fn,\n /* Deallocate SP.  */\n \n void \n-splay_tree_delete (sp)\n-     splay_tree sp;\n+splay_tree_delete (splay_tree sp)\n {\n   splay_tree_delete_helper (sp, sp->root);\n   (*sp->deallocate) ((char*) sp, sp->allocate_data);\n@@ -346,10 +323,7 @@ splay_tree_delete (sp)\n    with the new value.  Returns the new node.  */\n \n splay_tree_node\n-splay_tree_insert (sp, key, value)\n-     splay_tree sp;\n-     splay_tree_key key;\n-     splay_tree_value value;\n+splay_tree_insert (splay_tree sp, splay_tree_key key, splay_tree_value value)\n {\n   int comparison = 0;\n \n@@ -401,9 +375,7 @@ splay_tree_insert (sp, key, value)\n /* Remove KEY from SP.  It is not an error if it did not exist.  */\n \n void\n-splay_tree_remove (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_remove (splay_tree sp, splay_tree_key key)\n {\n   splay_tree_splay (sp, key);\n \n@@ -443,9 +415,7 @@ splay_tree_remove (sp, key)\n    otherwise.  */\n \n splay_tree_node\n-splay_tree_lookup (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_lookup (splay_tree sp, splay_tree_key key)\n {\n   splay_tree_splay (sp, key);\n \n@@ -458,8 +428,7 @@ splay_tree_lookup (sp, key)\n /* Return the node in SP with the greatest key.  */\n \n splay_tree_node\n-splay_tree_max (sp)\n-     splay_tree sp;\n+splay_tree_max (splay_tree sp)\n {\n   splay_tree_node n = sp->root;\n \n@@ -475,8 +444,7 @@ splay_tree_max (sp)\n /* Return the node in SP with the smallest key.  */\n \n splay_tree_node\n-splay_tree_min (sp)\n-     splay_tree sp;\n+splay_tree_min (splay_tree sp)\n {\n   splay_tree_node n = sp->root;\n \n@@ -493,9 +461,7 @@ splay_tree_min (sp)\n    predecessor.  KEY need not be present in the tree.  */\n \n splay_tree_node\n-splay_tree_predecessor (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_predecessor (splay_tree sp, splay_tree_key key)\n {\n   int comparison;\n   splay_tree_node node;\n@@ -526,9 +492,7 @@ splay_tree_predecessor (sp, key)\n    successor.  KEY need not be present in the tree.  */\n \n splay_tree_node\n-splay_tree_successor (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_successor (splay_tree sp, splay_tree_key key)\n {\n   int comparison;\n   splay_tree_node node;\n@@ -561,20 +525,15 @@ splay_tree_successor (sp, key)\n    Otherwise, this function returns 0.  */\n \n int\n-splay_tree_foreach (sp, fn, data)\n-     splay_tree sp;\n-     splay_tree_foreach_fn fn;\n-     void *data;\n+splay_tree_foreach (splay_tree sp, splay_tree_foreach_fn fn, void *data)\n {\n   return splay_tree_foreach_helper (sp, sp->root, fn, data);\n }\n \n /* Splay-tree comparison function, treating the keys as ints.  */\n \n int\n-splay_tree_compare_ints (k1, k2)\n-     splay_tree_key k1;\n-     splay_tree_key k2;\n+splay_tree_compare_ints (splay_tree_key k1, splay_tree_key k2)\n {\n   if ((int) k1 < (int) k2)\n     return -1;\n@@ -587,9 +546,7 @@ splay_tree_compare_ints (k1, k2)\n /* Splay-tree comparison function, treating the keys as pointers.  */\n \n int\n-splay_tree_compare_pointers (k1, k2)\n-     splay_tree_key k1;\n-     splay_tree_key k2;\n+splay_tree_compare_pointers (splay_tree_key k1, splay_tree_key k2)\n {\n   if ((char*) k1 < (char*) k2)\n     return -1;"}, {"sha": "b7148d8d5b74353d79192ac50932d18716869d95", "filename": "libiberty/stpcpy.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstpcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstpcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstpcpy.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -30,19 +30,13 @@ Copies the string @var{src} into @var{dst}.  Returns a pointer to\n */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n-extern size_t strlen PARAMS ((const char *));\n-extern PTR memcpy PARAMS ((PTR, const PTR, size_t));\n+extern size_t strlen (const char *);\n+extern PTR memcpy (PTR, const PTR, size_t);\n \n char *\n-stpcpy (dst, src)\n-     char *dst;\n-     const char *src;\n+stpcpy (char *dst, const char *src)\n {\n   const size_t len = strlen (src);\n   return (char *) memcpy (dst, src, len + 1) + len;"}, {"sha": "b885d85bde2c3a2bd4cec6c0ccde1174f812be3e", "filename": "libiberty/stpncpy.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstpncpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstpncpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstpncpy.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -32,20 +32,13 @@ strlen(@var{src}).\n */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n-extern size_t strlen PARAMS ((const char *));\n-extern char *strncpy PARAMS ((char *, const char *, size_t));\n+extern size_t strlen (const char *);\n+extern char *strncpy (char *, const char *, size_t);\n \n char *\n-stpncpy (dst, src, len)\n-     char *dst;\n-     const char *src;\n-     size_t len;\n+stpncpy (char *dst, const char *src, size_t len)\n {\n   size_t n = strlen (src);\n   if (n > len)"}, {"sha": "131d81c2ce7881fa48c363dc5bf5fb302c61ce0b", "filename": "libiberty/strcasecmp.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstrcasecmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstrcasecmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrcasecmp.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -25,11 +25,7 @@ static char sccsid[] = \"@(#)strcasecmp.c\t5.5 (Berkeley) 11/24/87\";\n #endif /* LIBC_SCCS and not lint */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n /*\n  * This array is designed for mapping upper and lower case letter\n@@ -73,8 +69,7 @@ static const unsigned char charmap[] = {\n };\n \n int\n-strcasecmp(s1, s2)\n-    const char *s1, *s2;\n+strcasecmp(const char *s1, const char *s2)\n {\n     register unsigned char u1, u2;\n "}, {"sha": "935805ef4f4d236f49be446d7c2c139b60c10996", "filename": "libiberty/strchr.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstrchr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstrchr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrchr.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -16,9 +16,7 @@ null character, the results are undefined.\n #include <ansidecl.h>\n \n char *\n-strchr (s, c)\n-  register const char *s;\n-  int c;\n+strchr (register const char *s, int c)\n {\n   do {\n     if (*s == c)"}, {"sha": "78c2093b61a3d05c758c9c14814ef38eb468633b", "filename": "libiberty/strdup.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstrdup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885f2199f39dcc84c7cabe6c8149d3e86c341fea/libiberty%2Fstrdup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrdup.c?ref=885f2199f39dcc84c7cabe6c8149d3e86c341fea", "patch": "@@ -10,19 +10,14 @@ Returns a pointer to a copy of @var{s} in memory obtained from\n */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n-extern size_t\tstrlen PARAMS ((const char*));\n-extern PTR\tmalloc PARAMS ((size_t));\n-extern PTR\tmemcpy PARAMS ((PTR, const PTR, size_t));\n+extern size_t\tstrlen (const char*);\n+extern PTR\tmalloc (size_t);\n+extern PTR\tmemcpy (PTR, const PTR, size_t);\n \n char *\n-strdup(s)\n-     const char *s;\n+strdup(const char *s)\n {\n   size_t len = strlen (s) + 1;\n   char *result = (char*) malloc (len);"}]}