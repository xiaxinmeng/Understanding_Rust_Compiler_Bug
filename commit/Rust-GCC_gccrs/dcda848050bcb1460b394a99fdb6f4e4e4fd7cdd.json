{"sha": "dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNkYTg0ODA1MGJjYjE0NjBiMzk0YTk5ZmRiNmY0ZTRlNGZkN2NkZA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-09-29T01:28:22Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-09-29T01:28:22Z"}, "message": "sched-rgn.c (haifa_edge, [...]): Remove.\n\n\t* sched-rgn.c (haifa_edge, edge_table, NEXT_IN, NEXT_OUT, FROM_BLOCK,\n\tTO_BLOCK, nr_edges, in_edges, out_edges, IN_EDGES, OUT_EDGES,\n\tbuild_control_flow, new_edge): Remove.\n\t(schedule_insns): Remove edge_table/in_edges/out_edges cleanup.\n\t(bitlst, bitlst_table_last, bitlst_table): Remove.\n\t(bblst): Store basic_block pointer instead of block index.\n\t(bblst_table): Likewise.\n\t(edgelst): Store edge pointer instead of edge index.\n\t(edgelst_table, edgelst_last): New variables.\n\t(extract_bitlst): Rename to ...\n\t(extract_edgelst): ... this.  Return edge pointers, not indices.\n\t(split_edges): Update call.\n\t(rgn_edges): Store edge pointers instead of indices.\n\t(edge_to_bit): Remove.\n\t(EDGE_TO_BIT): Store per-region edge index in edge->aux.\n\t(SET_EDGE_TO_BIT): New macro.\n\t(is_cfg_nonregular): Check for simple cases of unreachable blocks.\n\t(find_rgns): Remove edge_list parameter.  Traverse standard CFG\n\tdata structures instead of haifa_edge et al.  Use edge pointers\n\tinstead of edge indices everywhere.\n\t(compute_dom_prob_ps): Use standard CFG data structures.  Account\n\tfor exit edges.\n\t(compute_trg_info): Likewise.\n\t(propagate_deps): Likewise.\n\t(debug_candidate): Account for bblst data structure change.\n\t(check_live_1, update_live_1, is_pfree): Likewise.\n\t(IS_REACHABLE): Use standard CFG data structures.\n\t(init_ready_list): Update bblst_table/edgelst_table allocation.\n\t(schedule_region): Update alloc/cleanup code to data structure\n\tchanges.  Use edge->aux to store per-region edge index.\n\t(init_regions): No longer call build_control_flow.  Do not\n\tcreate edge list any more.\n\nFrom-SVN: r88264", "tree": {"sha": "f7a5b00f340f9de00236110cadf124f2319118a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7a5b00f340f9de00236110cadf124f2319118a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd/comments", "author": null, "committer": null, "parents": [{"sha": "f7deb4e9f61414874d458602adb9cba9a00233e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7deb4e9f61414874d458602adb9cba9a00233e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7deb4e9f61414874d458602adb9cba9a00233e4"}], "stats": {"total": 671, "additions": 269, "deletions": 402}, "files": [{"sha": "008e73728b11c31a0e0eca46fea338186ce28a40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "patch": "@@ -1,3 +1,38 @@\n+2004-09-28  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* sched-rgn.c (haifa_edge, edge_table, NEXT_IN, NEXT_OUT, FROM_BLOCK,\n+\tTO_BLOCK, nr_edges, in_edges, out_edges, IN_EDGES, OUT_EDGES,\n+\tbuild_control_flow, new_edge): Remove.\n+\t(schedule_insns): Remove edge_table/in_edges/out_edges cleanup.\n+\t(bitlst, bitlst_table_last, bitlst_table): Remove.\n+\t(bblst): Store basic_block pointer instead of block index.\n+\t(bblst_table): Likewise.\n+\t(edgelst): Store edge pointer instead of edge index.\n+\t(edgelst_table, edgelst_last): New variables.\n+\t(extract_bitlst): Rename to ...\n+\t(extract_edgelst): ... this.  Return edge pointers, not indices.\n+\t(split_edges): Update call.\n+\t(rgn_edges): Store edge pointers instead of indices.\n+\t(edge_to_bit): Remove.\n+\t(EDGE_TO_BIT): Store per-region edge index in edge->aux.\n+\t(SET_EDGE_TO_BIT): New macro.\n+\t(is_cfg_nonregular): Check for simple cases of unreachable blocks.\n+\t(find_rgns): Remove edge_list parameter.  Traverse standard CFG\n+\tdata structures instead of haifa_edge et al.  Use edge pointers\n+\tinstead of edge indices everywhere.\n+\t(compute_dom_prob_ps): Use standard CFG data structures.  Account\n+\tfor exit edges.\n+\t(compute_trg_info): Likewise.\n+\t(propagate_deps): Likewise.\n+\t(debug_candidate): Account for bblst data structure change.\n+\t(check_live_1, update_live_1, is_pfree): Likewise.\n+\t(IS_REACHABLE): Use standard CFG data structures.\n+\t(init_ready_list): Update bblst_table/edgelst_table allocation.\n+\t(schedule_region): Update alloc/cleanup code to data structure\n+\tchanges.  Use edge->aux to store per-region edge index.\n+\t(init_regions): No longer call build_control_flow.  Do not\n+\tcreate edge list any more.\n+\n 2004-09-28  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* cse.c (cse_insn): Avoid creating direct non-local jumps."}, {"sha": "50b48c24a0f2930428b4e67651cb456ac469f598", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 234, "deletions": 402, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "patch": "@@ -87,36 +87,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* nr_inter/spec counts interblock/speculative motion for the function.  */\n static int nr_inter, nr_spec;\n \n-/* Control flow graph edges are kept in circular lists.  */\n-typedef struct\n-{\n-  int from_block;\n-  int to_block;\n-  int next_in;\n-  int next_out;\n-}\n-haifa_edge;\n-static haifa_edge *edge_table;\n-\n-#define NEXT_IN(edge) (edge_table[edge].next_in)\n-#define NEXT_OUT(edge) (edge_table[edge].next_out)\n-#define FROM_BLOCK(edge) (edge_table[edge].from_block)\n-#define TO_BLOCK(edge) (edge_table[edge].to_block)\n-\n-/* Number of edges in the control flow graph.  (In fact, larger than\n-   that by 1, since edge 0 is unused.)  */\n-static int nr_edges;\n-\n-/* Circular list of incoming/outgoing edges of a block.  */\n-static int *in_edges;\n-static int *out_edges;\n-\n-#define IN_EDGES(block) (in_edges[block])\n-#define OUT_EDGES(block) (out_edges[block])\n-\n static int is_cfg_nonregular (void);\n-static int build_control_flow (struct edge_list *);\n-static void new_edge (int, int);\n static bool sched_is_disabled_for_current_region_p (void);\n \n /* A region is the main entity for interblock scheduling: insns\n@@ -154,7 +125,7 @@ static int *containing_rgn;\n \n void debug_regions (void);\n static void find_single_block_region (void);\n-static void find_rgns (struct edge_list *);\n+static void find_rgns (void);\n static bool too_large (int, int *, int *);\n \n extern void debug_live (int, int);\n@@ -166,25 +137,19 @@ static int current_blocks;\n /* The mapping from bb to block.  */\n #define BB_TO_BLOCK(bb) (rgn_bb_table[current_blocks + (bb)])\n \n-typedef struct\n-{\n-  int *first_member;\t\t/* Pointer to the list start in bitlst_table.  */\n-  int nr_members;\t\t/* The number of members of the bit list.  */\n-}\n-bitlst;\n-\n-static int bitlst_table_last;\n-static int *bitlst_table;\n-\n-static void extract_bitlst (sbitmap, bitlst *);\n-\n /* Target info declarations.\n \n    The block currently being scheduled is referred to as the \"target\" block,\n    while other blocks in the region from which insns can be moved to the\n    target are called \"source\" blocks.  The candidate structure holds info\n    about such sources: are they valid?  Speculative?  Etc.  */\n-typedef bitlst bblst;\n+typedef struct\n+{\n+  basic_block *first_member;\n+  int nr_members;\n+}\n+bblst;\n+\n typedef struct\n {\n   char is_valid;\n@@ -204,7 +169,8 @@ static candidate *candidate_table;\n \n    Lists of split and update blocks for each candidate of the current\n    target are in array bblst_table.  */\n-static int *bblst_table, bblst_size, bblst_last;\n+static basic_block *bblst_table;\n+static int bblst_size, bblst_last;\n \n #define IS_VALID(src) ( candidate_table[src].is_valid )\n #define IS_SPECULATIVE(src) ( candidate_table[src].is_speculative )\n@@ -214,7 +180,18 @@ static int *bblst_table, bblst_size, bblst_last;\n static int target_bb;\n \n /* List of edges.  */\n-typedef bitlst edgelst;\n+typedef struct\n+{\n+  edge *first_member;\n+  int nr_members;\n+}\n+edgelst;\n+\n+static edge *edgelst_table;\n+static int edgelst_last;\n+\n+static void extract_edgelst (sbitmap, edgelst *);\n+\n \n /* Target info functions.  */\n static void split_edges (int, int, edgelst *);\n@@ -250,12 +227,11 @@ typedef sbitmap edgeset;\n static int rgn_nr_edges;\n \n /* Array of size rgn_nr_edges.  */\n-static int *rgn_edges;\n-\n+static edge *rgn_edges;\n \n /* Mapping from each edge in the graph to its number in the rgn.  */\n-static int *edge_to_bit;\n-#define EDGE_TO_BIT(edge) (edge_to_bit[edge])\n+#define EDGE_TO_BIT(edge) ((int)(size_t)(edge)->aux)\n+#define SET_EDGE_TO_BIT(edge,nr) ((edge)->aux = (void *)(size_t)(nr))\n \n /* The split edges of a source bb is different for each target\n    bb.  In order to compute this efficiently, the 'potential-split edges'\n@@ -308,8 +284,8 @@ static void free_pending_lists (void);\n /* Return 1 if control flow graph should not be constructed, 0 otherwise.\n \n    We decide not to build the control flow graph if there is possibly more\n-   than one entry to the function, if computed branches exist, of if we\n-   have nonlocal gotos.  */\n+   than one entry to the function, if computed branches exist, if we\n+   have nonlocal gotos, or if we have an unreachable loop.  */\n \n static int\n is_cfg_nonregular (void)\n@@ -360,141 +336,43 @@ is_cfg_nonregular (void)\n \t  break;\n       }\n \n-  /* All the tests passed.  Consider the cfg well structured.  */\n-  return 0;\n-}\n-\n-/* Build the control flow graph and set nr_edges.\n-\n-   Instead of trying to build a cfg ourselves, we rely on flow to\n-   do it for us.  Stamp out useless code (and bug) duplication.\n-\n-   Return nonzero if an irregularity in the cfg is found which would\n-   prevent cross block scheduling.  */\n-\n-static int\n-build_control_flow (struct edge_list *edge_list)\n-{\n-  int i, unreachable, num_edges;\n-  basic_block b;\n-\n-  /* This already accounts for entry/exit edges.  */\n-  num_edges = NUM_EDGES (edge_list);\n-\n   /* Unreachable loops with more than one basic block are detected\n      during the DFS traversal in find_rgns.\n \n      Unreachable loops with a single block are detected here.  This\n      test is redundant with the one in find_rgns, but it's much\n-    cheaper to go ahead and catch the trivial case here.  */\n-  unreachable = 0;\n+     cheaper to go ahead and catch the trivial case here.  */\n   FOR_EACH_BB (b)\n     {\n       if (EDGE_COUNT (b->preds) == 0\n \t  || (EDGE_PRED (b, 0)->src == b\n \t      && EDGE_COUNT (b->preds) == 1))\n-\tunreachable = 1;\n-    }\n-\n-  /* ??? We can kill these soon.  */\n-  in_edges = xcalloc (last_basic_block, sizeof (int));\n-  out_edges = xcalloc (last_basic_block, sizeof (int));\n-  edge_table = xcalloc (num_edges, sizeof (haifa_edge));\n-\n-  nr_edges = 0;\n-  for (i = 0; i < num_edges; i++)\n-    {\n-      edge e = INDEX_EDGE (edge_list, i);\n-\n-      if (e->dest != EXIT_BLOCK_PTR\n-\t  && e->src != ENTRY_BLOCK_PTR)\n-\tnew_edge (e->src->index, e->dest->index);\n-    }\n-\n-  /* Increment by 1, since edge 0 is unused.  */\n-  nr_edges++;\n-\n-  return unreachable;\n-}\n-\n-/* Record an edge in the control flow graph from SOURCE to TARGET.\n-\n-   In theory, this is redundant with the s_succs computed above, but\n-   we have not converted all of haifa to use information from the\n-   integer lists.  */\n-\n-static void\n-new_edge (int source, int target)\n-{\n-  int e, next_edge;\n-  int curr_edge, fst_edge;\n-\n-  /* Check for duplicates.  */\n-  fst_edge = curr_edge = OUT_EDGES (source);\n-  while (curr_edge)\n-    {\n-      if (FROM_BLOCK (curr_edge) == source\n-\t  && TO_BLOCK (curr_edge) == target)\n-\t{\n-\t  return;\n-\t}\n-\n-      curr_edge = NEXT_OUT (curr_edge);\n-\n-      if (fst_edge == curr_edge)\n-\tbreak;\n-    }\n-\n-  e = ++nr_edges;\n-\n-  FROM_BLOCK (e) = source;\n-  TO_BLOCK (e) = target;\n-\n-  if (OUT_EDGES (source))\n-    {\n-      next_edge = NEXT_OUT (OUT_EDGES (source));\n-      NEXT_OUT (OUT_EDGES (source)) = e;\n-      NEXT_OUT (e) = next_edge;\n-    }\n-  else\n-    {\n-      OUT_EDGES (source) = e;\n-      NEXT_OUT (e) = e;\n+\treturn 1;\n     }\n \n-  if (IN_EDGES (target))\n-    {\n-      next_edge = NEXT_IN (IN_EDGES (target));\n-      NEXT_IN (IN_EDGES (target)) = e;\n-      NEXT_IN (e) = next_edge;\n-    }\n-  else\n-    {\n-      IN_EDGES (target) = e;\n-      NEXT_IN (e) = e;\n-    }\n+  /* All the tests passed.  Consider the cfg well structured.  */\n+  return 0;\n }\n \n-/* Translate a bit-set SET to a list BL of the bit-set members.  */\n+/* Extract list of edges from a bitmap containing EDGE_TO_BIT bits.  */\n \n static void\n-extract_bitlst (sbitmap set, bitlst *bl)\n+extract_edgelst (sbitmap set, edgelst *el)\n {\n   int i;\n \n-  /* bblst table space is reused in each call to extract_bitlst.  */\n-  bitlst_table_last = 0;\n+  /* edgelst table space is reused in each call to extract_edgelst.  */\n+  edgelst_last = 0;\n \n-  bl->first_member = &bitlst_table[bitlst_table_last];\n-  bl->nr_members = 0;\n+  el->first_member = &edgelst_table[edgelst_last];\n+  el->nr_members = 0;\n \n   /* Iterate over each word in the bitset.  */\n   EXECUTE_IF_SET_IN_SBITMAP (set, 0, i,\n   {\n-    bitlst_table[bitlst_table_last++] = i;\n-    (bl->nr_members)++;\n+    edgelst_table[edgelst_last++] = rgn_edges[i];\n+    el->nr_members++;\n   });\n-\n }\n \n /* Functions for the construction of regions.  */\n@@ -609,20 +487,18 @@ too_large (int block, int *num_bbs, int *num_insns)\n    of edge tables.  That would simplify it somewhat.  */\n \n static void\n-find_rgns (struct edge_list *edge_list)\n+find_rgns (void)\n {\n-  int *max_hdr, *dfs_nr, *stack, *degree;\n+  int *max_hdr, *dfs_nr, *degree;\n   char no_loops = 1;\n   int node, child, loop_head, i, head, tail;\n   int count = 0, sp, idx = 0;\n-  int current_edge = out_edges[EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->index];\n+  edge_iterator current_edge;\n+  edge_iterator *stack;\n   int num_bbs, num_insns, unreachable;\n   int too_large_failure;\n   basic_block bb;\n \n-  /* Note if an edge has been passed.  */\n-  sbitmap passed;\n-\n   /* Note if a block is a natural loop header.  */\n   sbitmap header;\n \n@@ -635,8 +511,6 @@ find_rgns (struct edge_list *edge_list)\n   /* Note if a block is in the block queue.  */\n   sbitmap in_stack;\n \n-  int num_edges = NUM_EDGES (edge_list);\n-\n   /* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops\n      and a mapping from block to its loop header (if the block is contained\n      in a loop, else -1).\n@@ -649,17 +523,14 @@ find_rgns (struct edge_list *edge_list)\n   /* Allocate and initialize variables for the first traversal.  */\n   max_hdr = xmalloc (last_basic_block * sizeof (int));\n   dfs_nr = xcalloc (last_basic_block, sizeof (int));\n-  stack = xmalloc (nr_edges * sizeof (int));\n+  stack = xmalloc (n_edges * sizeof (edge_iterator));\n \n   inner = sbitmap_alloc (last_basic_block);\n   sbitmap_ones (inner);\n \n   header = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (header);\n \n-  passed = sbitmap_alloc (nr_edges);\n-  sbitmap_zero (passed);\n-\n   in_queue = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (in_queue);\n \n@@ -669,43 +540,58 @@ find_rgns (struct edge_list *edge_list)\n   for (i = 0; i < last_basic_block; i++)\n     max_hdr[i] = -1;\n \n+  #define EDGE_PASSED(E) (ei_end_p ((E)) || ei_edge ((E))->aux)\n+  #define SET_EDGE_PASSED(E) (ei_edge ((E))->aux = ei_edge ((E)))\n+\n   /* DFS traversal to find inner loops in the cfg.  */\n \n+  current_edge = ei_start (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->succs);\n   sp = -1;\n+\n   while (1)\n     {\n-      if (current_edge == 0 || TEST_BIT (passed, current_edge))\n+      if (EDGE_PASSED (current_edge))\n \t{\n \t  /* We have reached a leaf node or a node that was already\n \t     processed.  Pop edges off the stack until we find\n \t     an edge that has not yet been processed.  */\n-\t  while (sp >= 0\n-\t\t && (current_edge == 0 || TEST_BIT (passed, current_edge)))\n+\t  while (sp >= 0 && EDGE_PASSED (current_edge))\n \t    {\n \t      /* Pop entry off the stack.  */\n \t      current_edge = stack[sp--];\n-\t      node = FROM_BLOCK (current_edge);\n-\t      child = TO_BLOCK (current_edge);\n+\t      node = ei_edge (current_edge)->src->index;\n+\t      gcc_assert (node != ENTRY_BLOCK);\n+\t      child = ei_edge (current_edge)->dest->index;\n+\t      gcc_assert (child != EXIT_BLOCK);\n \t      RESET_BIT (in_stack, child);\n \t      if (max_hdr[child] >= 0 && TEST_BIT (in_stack, max_hdr[child]))\n \t\tUPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n-\t      current_edge = NEXT_OUT (current_edge);\n+\t      ei_next (&current_edge);\n \t    }\n \n \t  /* See if have finished the DFS tree traversal.  */\n-\t  if (sp < 0 && TEST_BIT (passed, current_edge))\n+\t  if (sp < 0 && EDGE_PASSED (current_edge))\n \t    break;\n \n \t  /* Nope, continue the traversal with the popped node.  */\n \t  continue;\n \t}\n \n       /* Process a node.  */\n-      node = FROM_BLOCK (current_edge);\n-      child = TO_BLOCK (current_edge);\n+      node = ei_edge (current_edge)->src->index;\n+      gcc_assert (node != ENTRY_BLOCK);\n       SET_BIT (in_stack, node);\n       dfs_nr[node] = ++count;\n \n+      /* We don't traverse to the exit block.  */\n+      child = ei_edge (current_edge)->dest->index;\n+      if (child == EXIT_BLOCK)\n+\t{\n+\t  SET_EDGE_PASSED (current_edge);\n+\t  ei_next (&current_edge);\n+\t  continue;\n+\t}\n+\n       /* If the successor is in the stack, then we've found a loop.\n \t Mark the loop, if it is not a natural loop, then it will\n \t be rejected during the second traversal.  */\n@@ -714,8 +600,8 @@ find_rgns (struct edge_list *edge_list)\n \t  no_loops = 0;\n \t  SET_BIT (header, child);\n \t  UPDATE_LOOP_RELATIONS (node, child);\n-\t  SET_BIT (passed, current_edge);\n-\t  current_edge = NEXT_OUT (current_edge);\n+\t  SET_EDGE_PASSED (current_edge);\n+\t  ei_next (&current_edge);\n \t  continue;\n \t}\n \n@@ -726,32 +612,27 @@ find_rgns (struct edge_list *edge_list)\n \t{\n \t  if (max_hdr[child] >= 0 && TEST_BIT (in_stack, max_hdr[child]))\n \t    UPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n-\t  SET_BIT (passed, current_edge);\n-\t  current_edge = NEXT_OUT (current_edge);\n+\t  SET_EDGE_PASSED (current_edge);\n+\t  ei_next (&current_edge);\n \t  continue;\n \t}\n \n       /* Push an entry on the stack and continue DFS traversal.  */\n       stack[++sp] = current_edge;\n-      SET_BIT (passed, current_edge);\n-      current_edge = OUT_EDGES (child);\n-\n-      /* This is temporary until haifa is converted to use rth's new\n-\t cfg routines which have true entry/exit blocks and the\n-\t appropriate edges from/to those blocks.\n-\n-\t Generally we update dfs_nr for a node when we process its\n-\t out edge.  However, if the node has no out edge then we will\n-\t not set dfs_nr for that node.  This can confuse the scheduler\n-\t into thinking that we have unreachable blocks, which in turn\n-\t disables cross block scheduling.\n-\n-\t So, if we have a node with no out edges, go ahead and mark it\n-\t as reachable now.  */\n-      if (current_edge == 0)\n-\tdfs_nr[child] = ++count;\n+      SET_EDGE_PASSED (current_edge);\n+      current_edge = ei_start (ei_edge (current_edge)->dest->succs);\n+    }\n+\n+  /* Reset ->aux field used by EDGE_PASSED.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\te->aux = NULL;\n     }\n \n+\n   /* Another check for unreachable blocks.  The earlier test in\n      is_cfg_nonregular only finds unreachable blocks that do not\n      form a loop.\n@@ -772,14 +653,7 @@ find_rgns (struct edge_list *edge_list)\n   degree = dfs_nr;\n \n   FOR_EACH_BB (bb)\n-    degree[bb->index] = 0;\n-  for (i = 0; i < num_edges; i++)\n-    {\n-      edge e = INDEX_EDGE (edge_list, i);\n-\n-      if (e->dest != EXIT_BLOCK_PTR)\n-\tdegree[e->dest->index]++;\n-    }\n+    degree[bb->index] = EDGE_COUNT (bb->preds);\n \n   /* Do not perform region scheduling if there are any unreachable\n      blocks.  */\n@@ -1019,7 +893,6 @@ find_rgns (struct edge_list *edge_list)\n   free (max_hdr);\n   free (dfs_nr);\n   free (stack);\n-  sbitmap_free (passed);\n   sbitmap_free (header);\n   sbitmap_free (inner);\n   sbitmap_free (in_queue);\n@@ -1034,8 +907,10 @@ find_rgns (struct edge_list *edge_list)\n static void\n compute_dom_prob_ps (int bb)\n {\n-  int nxt_in_edge, fst_in_edge, pred;\n-  int fst_out_edge, nxt_out_edge, nr_out_edges, nr_rgn_out_edges;\n+  int pred_bb;\n+  int nr_out_edges, nr_rgn_out_edges;\n+  edge_iterator in_ei, out_ei;\n+  edge in_edge, out_edge;\n \n   prob[bb] = 0.0;\n   if (IS_RGN_ENTRY (bb))\n@@ -1045,56 +920,48 @@ compute_dom_prob_ps (int bb)\n       return;\n     }\n \n-  fst_in_edge = nxt_in_edge = IN_EDGES (BB_TO_BLOCK (bb));\n-\n   /* Initialize dom[bb] to '111..1'.  */\n   sbitmap_ones (dom[bb]);\n \n-  do\n+  FOR_EACH_EDGE (in_edge, in_ei, BASIC_BLOCK (BB_TO_BLOCK (bb))->preds)\n     {\n-      pred = FROM_BLOCK (nxt_in_edge);\n-      sbitmap_a_and_b (dom[bb], dom[bb], dom[BLOCK_TO_BB (pred)]);\n-      sbitmap_a_or_b (ancestor_edges[bb], ancestor_edges[bb], ancestor_edges[BLOCK_TO_BB (pred)]);\n-\n-      SET_BIT (ancestor_edges[bb], EDGE_TO_BIT (nxt_in_edge));\n+      if (in_edge->src == ENTRY_BLOCK_PTR)\n+\tcontinue;\n \n-      nr_out_edges = 1;\n-      nr_rgn_out_edges = 0;\n-      fst_out_edge = OUT_EDGES (pred);\n-      nxt_out_edge = NEXT_OUT (fst_out_edge);\n+      pred_bb = BLOCK_TO_BB (in_edge->src->index);\n+      sbitmap_a_and_b (dom[bb], dom[bb], dom[pred_bb]);\n+      sbitmap_a_or_b (ancestor_edges[bb],\n+\t\t      ancestor_edges[bb], ancestor_edges[pred_bb]);\n \n-      sbitmap_a_or_b (pot_split[bb], pot_split[bb], pot_split[BLOCK_TO_BB (pred)]);\n+      SET_BIT (ancestor_edges[bb], EDGE_TO_BIT (in_edge));\n \n-      SET_BIT (pot_split[bb], EDGE_TO_BIT (fst_out_edge));\n+      sbitmap_a_or_b (pot_split[bb], pot_split[bb], pot_split[pred_bb]);\n \n-      /* The successor doesn't belong in the region?  */\n-      if (CONTAINING_RGN (TO_BLOCK (fst_out_edge)) !=\n-\t  CONTAINING_RGN (BB_TO_BLOCK (bb)))\n-\t++nr_rgn_out_edges;\n+      nr_out_edges = 0;\n+      nr_rgn_out_edges = 0;\n \n-      while (fst_out_edge != nxt_out_edge)\n+      FOR_EACH_EDGE (out_edge, out_ei, in_edge->src->succs)\n \t{\n \t  ++nr_out_edges;\n+\n \t  /* The successor doesn't belong in the region?  */\n-\t  if (CONTAINING_RGN (TO_BLOCK (nxt_out_edge)) !=\n-\t      CONTAINING_RGN (BB_TO_BLOCK (bb)))\n+\t  if (out_edge->dest != EXIT_BLOCK_PTR\n+\t      && CONTAINING_RGN (out_edge->dest->index)\n+\t\t != CONTAINING_RGN (BB_TO_BLOCK (bb)))\n \t    ++nr_rgn_out_edges;\n-\t  SET_BIT (pot_split[bb], EDGE_TO_BIT (nxt_out_edge));\n-\t  nxt_out_edge = NEXT_OUT (nxt_out_edge);\n \n+\t  SET_BIT (pot_split[bb], EDGE_TO_BIT (out_edge));\n \t}\n \n       /* Now nr_rgn_out_edges is the number of region-exit edges from\n          pred, and nr_out_edges will be the number of pred out edges\n          not leaving the region.  */\n       nr_out_edges -= nr_rgn_out_edges;\n       if (nr_rgn_out_edges > 0)\n-\tprob[bb] += 0.9 * prob[BLOCK_TO_BB (pred)] / nr_out_edges;\n+\tprob[bb] += 0.9 * prob[pred_bb] / nr_out_edges;\n       else\n-\tprob[bb] += prob[BLOCK_TO_BB (pred)] / nr_out_edges;\n-      nxt_in_edge = NEXT_IN (nxt_in_edge);\n+\tprob[bb] += prob[pred_bb] / nr_out_edges;\n     }\n-  while (fst_in_edge != nxt_in_edge);\n \n   SET_BIT (dom[bb], bb);\n   sbitmap_difference (pot_split[bb], pot_split[bb], ancestor_edges[bb]);\n@@ -1116,7 +983,7 @@ split_edges (int bb_src, int bb_trg, edgelst *bl)\n   sbitmap_copy (src, pot_split[bb_src]);\n \n   sbitmap_difference (src, src, pot_split[bb_trg]);\n-  extract_bitlst (src, bl);\n+  extract_edgelst (src, bl);\n   sbitmap_free (src);\n }\n \n@@ -1129,8 +996,10 @@ compute_trg_info (int trg)\n {\n   candidate *sp;\n   edgelst el;\n-  int check_block, update_idx;\n-  int i, j, k, fst_edge, nxt_edge;\n+  int i, j, k, update_idx;\n+  basic_block block;\n+  edge_iterator ei;\n+  edge e;\n \n   /* Define some of the fields for the target bb as well.  */\n   sp = candidate_table + trg;\n@@ -1159,15 +1028,12 @@ compute_trg_info (int trg)\n \n       if (sp->is_valid)\n \t{\n-\t  char *update_blocks;\n-\n \t  /* Compute split blocks and store them in bblst_table.\n \t     The TO block of every split edge is a split block.  */\n \t  sp->split_bbs.first_member = &bblst_table[bblst_last];\n \t  sp->split_bbs.nr_members = el.nr_members;\n \t  for (j = 0; j < el.nr_members; bblst_last++, j++)\n-\t    bblst_table[bblst_last] =\n-\t      TO_BLOCK (rgn_edges[el.first_member[j]]);\n+\t    bblst_table[bblst_last] = el.first_member[j]->dest;\n \t  sp->update_bbs.first_member = &bblst_table[bblst_last];\n \n \t  /* Compute update blocks and store them in bblst_table.\n@@ -1176,36 +1042,33 @@ compute_trg_info (int trg)\n \t     add the TO block to the update block list.  This list can end\n \t     up with a lot of duplicates.  We need to weed them out to avoid\n \t     overrunning the end of the bblst_table.  */\n-\t  update_blocks = alloca (last_basic_block);\n-\t  memset (update_blocks, 0, last_basic_block);\n \n \t  update_idx = 0;\n \t  for (j = 0; j < el.nr_members; j++)\n \t    {\n-\t      check_block = FROM_BLOCK (rgn_edges[el.first_member[j]]);\n-\t      fst_edge = nxt_edge = OUT_EDGES (check_block);\n-\t      do\n+\t      block = el.first_member[j]->src;\n+\t      FOR_EACH_EDGE (e, ei, block->succs)\n \t\t{\n-\t\t  if (! update_blocks[TO_BLOCK (nxt_edge)])\n+\t\t  if (!(e->dest->flags & BB_VISITED))\n \t\t    {\n \t\t      for (k = 0; k < el.nr_members; k++)\n-\t\t\tif (EDGE_TO_BIT (nxt_edge) == el.first_member[k])\n+\t\t\tif (e == el.first_member[k])\n \t\t\t  break;\n \n \t\t      if (k >= el.nr_members)\n \t\t\t{\n-\t\t\t  bblst_table[bblst_last++] = TO_BLOCK (nxt_edge);\n-\t\t\t  update_blocks[TO_BLOCK (nxt_edge)] = 1;\n+\t\t\t  bblst_table[bblst_last++] = e->dest;\n+\t\t\t  e->dest->flags |= BB_VISITED;\n \t\t\t  update_idx++;\n \t\t\t}\n \t\t    }\n-\n-\t\t  nxt_edge = NEXT_OUT (nxt_edge);\n \t\t}\n-\t      while (fst_edge != nxt_edge);\n \t    }\n \t  sp->update_bbs.nr_members = update_idx;\n \n+\t  FOR_ALL_BB (block)\n+\t    block->flags &= ~BB_VISITED;\n+\n \t  /* Make sure we didn't overrun the end of bblst_table.  */\n \t  gcc_assert (bblst_last <= bblst_size);\n \t}\n@@ -1235,7 +1098,7 @@ debug_candidate (int i)\n       fprintf (sched_dump, \"split path: \");\n       for (j = 0; j < candidate_table[i].split_bbs.nr_members; j++)\n \t{\n-\t  int b = candidate_table[i].split_bbs.first_member[j];\n+\t  int b = candidate_table[i].split_bbs.first_member[j]->index;\n \n \t  fprintf (sched_dump, \" %d \", b);\n \t}\n@@ -1244,7 +1107,7 @@ debug_candidate (int i)\n       fprintf (sched_dump, \"update path: \");\n       for (j = 0; j < candidate_table[i].update_bbs.nr_members; j++)\n \t{\n-\t  int b = candidate_table[i].update_bbs.first_member[j];\n+\t  int b = candidate_table[i].update_bbs.first_member[j]->index;\n \n \t  fprintf (sched_dump, \" %d \", b);\n \t}\n@@ -1321,10 +1184,9 @@ check_live_1 (int src, rtx x)\n \t    {\n \t      for (i = 0; i < candidate_table[src].split_bbs.nr_members; i++)\n \t\t{\n-\t\t  int b = candidate_table[src].split_bbs.first_member[i];\n+\t\t  basic_block b = candidate_table[src].split_bbs.first_member[i];\n \n-\t\t  if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start,\n-\t\t\t\t       regno + j))\n+\t\t  if (REGNO_REG_SET_P (b->global_live_at_start, regno + j))\n \t\t    {\n \t\t      return 0;\n \t\t    }\n@@ -1336,9 +1198,9 @@ check_live_1 (int src, rtx x)\n \t  /* Check for pseudo registers.  */\n \t  for (i = 0; i < candidate_table[src].split_bbs.nr_members; i++)\n \t    {\n-\t      int b = candidate_table[src].split_bbs.first_member[i];\n+\t      basic_block b = candidate_table[src].split_bbs.first_member[i];\n \n-\t      if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, regno))\n+\t      if (REGNO_REG_SET_P (b->global_live_at_start, regno))\n \t\t{\n \t\t  return 0;\n \t\t}\n@@ -1395,20 +1257,19 @@ update_live_1 (int src, rtx x)\n \t    {\n \t      for (i = 0; i < candidate_table[src].update_bbs.nr_members; i++)\n \t\t{\n-\t\t  int b = candidate_table[src].update_bbs.first_member[i];\n+\t\t  basic_block b = candidate_table[src].update_bbs.first_member[i];\n \n-\t\t  SET_REGNO_REG_SET (BASIC_BLOCK (b)->global_live_at_start,\n-\t\t\t\t     regno + j);\n+\t\t  SET_REGNO_REG_SET (b->global_live_at_start, regno + j);\n \t\t}\n \t    }\n \t}\n       else\n \t{\n \t  for (i = 0; i < candidate_table[src].update_bbs.nr_members; i++)\n \t    {\n-\t      int b = candidate_table[src].update_bbs.first_member[i];\n+\t      basic_block b = candidate_table[src].update_bbs.first_member[i];\n \n-\t      SET_REGNO_REG_SET (BASIC_BLOCK (b)->global_live_at_start, regno);\n+\t      SET_REGNO_REG_SET (b->global_live_at_start, regno);\n \t    }\n \t}\n     }\n@@ -1465,7 +1326,7 @@ update_live (rtx insn, int src)\n   (bb_from == bb_to\t\t\t\t\t\t\t\\\n    || IS_RGN_ENTRY (bb_from)\t\t\t\t\t\t\\\n    || (TEST_BIT (ancestor_edges[bb_to],\t\t\t\t\t\\\n-\t\t EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))))))\n+\t EDGE_TO_BIT (EDGE_PRED (BASIC_BLOCK (BB_TO_BLOCK (bb_from)), 0)))))\n \n /* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */\n \n@@ -1602,7 +1463,7 @@ is_pfree (rtx load_insn, int bb_src, int bb_trg)\n \t\t    /* insn2 is the similar load, in the target block.  */\n \t\t    return 1;\n \n-\t\t  if (*(candp->split_bbs.first_member) == BLOCK_NUM (insn2))\n+\t\t  if (*(candp->split_bbs.first_member) == BLOCK_FOR_INSN (insn2))\n \t\t    /* insn2 is a similar load, in a split-block.  */\n \t\t    return 1;\n \t\t}\n@@ -1736,10 +1597,10 @@ init_ready_list (struct ready_list *ready)\n \t the TO blocks of region edges, so there can be at most rgn_nr_edges\n \t of them.  */\n       bblst_size = (current_nr_blocks - target_bb) * rgn_nr_edges;\n-      bblst_table = xmalloc (bblst_size * sizeof (int));\n+      bblst_table = xmalloc (bblst_size * sizeof (basic_block));\n \n-      bitlst_table_last = 0;\n-      bitlst_table = xmalloc (rgn_nr_edges * sizeof (int));\n+      edgelst_last = 0;\n+      edgelst_table = xmalloc (rgn_nr_edges * sizeof (edge));\n \n       compute_trg_info (target_bb);\n     }\n@@ -2117,72 +1978,66 @@ concat_insn_mem_list (rtx copy_insns, rtx copy_mems, rtx *old_insns_p,\n static void\n propagate_deps (int bb, struct deps *pred_deps)\n {\n-  int b = BB_TO_BLOCK (bb);\n-  int e, first_edge;\n+  basic_block block = BASIC_BLOCK (BB_TO_BLOCK (bb));\n+  edge_iterator ei;\n+  edge e;\n \n   /* bb's structures are inherited by its successors.  */\n-  first_edge = e = OUT_EDGES (b);\n-  if (e > 0)\n-    do\n-      {\n-\tint b_succ = TO_BLOCK (e);\n-\tint bb_succ = BLOCK_TO_BB (b_succ);\n-\tstruct deps *succ_deps = bb_deps + bb_succ;\n-\tint reg;\n-\n-\t/* Only bbs \"below\" bb, in the same region, are interesting.  */\n-\tif (CONTAINING_RGN (b) != CONTAINING_RGN (b_succ)\n-\t    || bb_succ <= bb)\n-\t  {\n-\t    e = NEXT_OUT (e);\n-\t    continue;\n-\t  }\n+  FOR_EACH_EDGE (e, ei, block->succs)\n+    {\n+      struct deps *succ_deps;\n+      int reg;\n \n-\t/* The reg_last lists are inherited by bb_succ.  */\n-\tEXECUTE_IF_SET_IN_REG_SET (&pred_deps->reg_last_in_use, 0, reg,\n-\t  {\n-\t    struct deps_reg *pred_rl = &pred_deps->reg_last[reg];\n-\t    struct deps_reg *succ_rl = &succ_deps->reg_last[reg];\n-\n-\t    succ_rl->uses = concat_INSN_LIST (pred_rl->uses, succ_rl->uses);\n-\t    succ_rl->sets = concat_INSN_LIST (pred_rl->sets, succ_rl->sets);\n-\t    succ_rl->clobbers = concat_INSN_LIST (pred_rl->clobbers,\n-\t\t\t\t\t\t  succ_rl->clobbers);\n-\t    succ_rl->uses_length += pred_rl->uses_length;\n-\t    succ_rl->clobbers_length += pred_rl->clobbers_length;\n-\t  });\n-\tIOR_REG_SET (&succ_deps->reg_last_in_use, &pred_deps->reg_last_in_use);\n-\n-\t/* Mem read/write lists are inherited by bb_succ.  */\n-\tconcat_insn_mem_list (pred_deps->pending_read_insns,\n-\t\t\t      pred_deps->pending_read_mems,\n-\t\t\t      &succ_deps->pending_read_insns,\n-\t\t\t      &succ_deps->pending_read_mems);\n-\tconcat_insn_mem_list (pred_deps->pending_write_insns,\n-\t\t\t      pred_deps->pending_write_mems,\n-\t\t\t      &succ_deps->pending_write_insns,\n-\t\t\t      &succ_deps->pending_write_mems);\n-\n-\tsucc_deps->last_pending_memory_flush\n-\t  = concat_INSN_LIST (pred_deps->last_pending_memory_flush,\n-\t\t\t      succ_deps->last_pending_memory_flush);\n-\n-\tsucc_deps->pending_lists_length += pred_deps->pending_lists_length;\n-\tsucc_deps->pending_flush_length += pred_deps->pending_flush_length;\n-\n-\t/* last_function_call is inherited by bb_succ.  */\n-\tsucc_deps->last_function_call\n-\t  = concat_INSN_LIST (pred_deps->last_function_call,\n-\t\t\t      succ_deps->last_function_call);\n+      /* Only bbs \"below\" bb, in the same region, are interesting.  */\n+      if (e->dest == EXIT_BLOCK_PTR\n+\t  || CONTAINING_RGN (block->index) != CONTAINING_RGN (e->dest->index)\n+\t  || BLOCK_TO_BB (e->dest->index) <= bb)\n+\tcontinue;\n \n-\t/* sched_before_next_call is inherited by bb_succ.  */\n-\tsucc_deps->sched_before_next_call\n-\t  = concat_INSN_LIST (pred_deps->sched_before_next_call,\n-\t\t\t      succ_deps->sched_before_next_call);\n+      succ_deps = bb_deps + BLOCK_TO_BB (e->dest->index);\n \n-\te = NEXT_OUT (e);\n-      }\n-    while (e != first_edge);\n+      /* The reg_last lists are inherited by successor.  */\n+      EXECUTE_IF_SET_IN_REG_SET (&pred_deps->reg_last_in_use, 0, reg,\n+\t{\n+\t  struct deps_reg *pred_rl = &pred_deps->reg_last[reg];\n+\t  struct deps_reg *succ_rl = &succ_deps->reg_last[reg];\n+\n+\t  succ_rl->uses = concat_INSN_LIST (pred_rl->uses, succ_rl->uses);\n+\t  succ_rl->sets = concat_INSN_LIST (pred_rl->sets, succ_rl->sets);\n+\t  succ_rl->clobbers = concat_INSN_LIST (pred_rl->clobbers,\n+\t\t\t\t\t\tsucc_rl->clobbers);\n+\t  succ_rl->uses_length += pred_rl->uses_length;\n+\t  succ_rl->clobbers_length += pred_rl->clobbers_length;\n+\t});\n+      IOR_REG_SET (&succ_deps->reg_last_in_use, &pred_deps->reg_last_in_use);\n+\n+      /* Mem read/write lists are inherited by successor.  */\n+      concat_insn_mem_list (pred_deps->pending_read_insns,\n+\t\t\t    pred_deps->pending_read_mems,\n+\t\t\t    &succ_deps->pending_read_insns,\n+\t\t\t    &succ_deps->pending_read_mems);\n+      concat_insn_mem_list (pred_deps->pending_write_insns,\n+\t\t\t    pred_deps->pending_write_mems,\n+\t\t\t    &succ_deps->pending_write_insns,\n+\t\t\t    &succ_deps->pending_write_mems);\n+\n+      succ_deps->last_pending_memory_flush\n+\t= concat_INSN_LIST (pred_deps->last_pending_memory_flush,\n+\t\t\t    succ_deps->last_pending_memory_flush);\n+\n+      succ_deps->pending_lists_length += pred_deps->pending_lists_length;\n+      succ_deps->pending_flush_length += pred_deps->pending_flush_length;\n+\n+      /* last_function_call is inherited by successor.  */\n+      succ_deps->last_function_call\n+\t= concat_INSN_LIST (pred_deps->last_function_call,\n+\t\t\t      succ_deps->last_function_call);\n+\n+      /* sched_before_next_call is inherited by successor.  */\n+      succ_deps->sched_before_next_call\n+\t= concat_INSN_LIST (pred_deps->sched_before_next_call,\n+\t\t\t    succ_deps->sched_before_next_call);\n+    }\n \n   /* These lists should point to the right place, for correct\n      freeing later.  */\n@@ -2349,6 +2204,9 @@ sched_is_disabled_for_current_region_p (void)\n static void\n schedule_region (int rgn)\n {\n+  basic_block block;\n+  edge_iterator ei;\n+  edge e;\n   int bb;\n   int rgn_n_insns = 0;\n   int sched_rgn_n_insns = 0;\n@@ -2398,24 +2256,30 @@ schedule_region (int rgn)\n   /* Compute interblock info: probabilities, split-edges, dominators, etc.  */\n   if (current_nr_blocks > 1)\n     {\n-      int i;\n-\n       prob = xmalloc ((current_nr_blocks) * sizeof (float));\n \n       dom = sbitmap_vector_alloc (current_nr_blocks, current_nr_blocks);\n       sbitmap_vector_zero (dom, current_nr_blocks);\n-      /* Edge to bit.  */\n+\n+      /* Use ->aux to implement EDGE_TO_BIT mapping.  */\n       rgn_nr_edges = 0;\n-      edge_to_bit = xmalloc (nr_edges * sizeof (int));\n-      for (i = 1; i < nr_edges; i++)\n-\tif (CONTAINING_RGN (FROM_BLOCK (i)) == rgn)\n-\t  EDGE_TO_BIT (i) = rgn_nr_edges++;\n-      rgn_edges = xmalloc (rgn_nr_edges * sizeof (int));\n+      FOR_EACH_BB (block)\n+\t{\n+\t  if (CONTAINING_RGN (block->index) != rgn)\n+\t    continue;\n+\t  FOR_EACH_EDGE (e, ei, block->succs)\n+\t    SET_EDGE_TO_BIT (e, rgn_nr_edges++);\n+\t}\n \n+      rgn_edges = xmalloc (rgn_nr_edges * sizeof (edge));\n       rgn_nr_edges = 0;\n-      for (i = 1; i < nr_edges; i++)\n-\tif (CONTAINING_RGN (FROM_BLOCK (i)) == (rgn))\n-\t  rgn_edges[rgn_nr_edges++] = i;\n+      FOR_EACH_BB (block)\n+\t{\n+\t  if (CONTAINING_RGN (block->index) != rgn)\n+\t    continue;\n+\t  FOR_EACH_EDGE (e, ei, block->succs)\n+\t    rgn_edges[rgn_nr_edges++] = e;\n+\t}\n \n       /* Split edges.  */\n       pot_split = sbitmap_vector_alloc (current_nr_blocks, rgn_nr_edges);\n@@ -2491,7 +2355,7 @@ schedule_region (int rgn)\n \t{\n \t  free (candidate_table);\n \t  free (bblst_table);\n-\t  free (bitlst_table);\n+\t  free (edgelst_table);\n \t}\n     }\n \n@@ -2518,11 +2382,19 @@ schedule_region (int rgn)\n \n   if (current_nr_blocks > 1)\n     {\n+      /* Cleanup ->aux used for EDGE_TO_BIT mapping.  */\n+      FOR_EACH_BB (block)\n+\t{\n+\t  if (CONTAINING_RGN (block->index) != rgn)\n+\t    continue;\n+\t  FOR_EACH_EDGE (e, ei, block->succs)\n+\t    e->aux = NULL;\n+\t}\n+\n       free (prob);\n       sbitmap_vector_free (dom);\n       sbitmap_vector_free (pot_split);\n       sbitmap_vector_free (ancestor_edges);\n-      free (edge_to_bit);\n       free (rgn_edges);\n     }\n }\n@@ -2548,48 +2420,25 @@ init_regions (void)\n   /* Compute regions for scheduling.  */\n   if (reload_completed\n       || n_basic_blocks == 1\n-      || !flag_schedule_interblock)\n+      || !flag_schedule_interblock\n+      || is_cfg_nonregular ())\n     {\n       find_single_block_region ();\n     }\n   else\n     {\n-      /* Verify that a 'good' control flow graph can be built.  */\n-      if (is_cfg_nonregular ())\n-\t{\n-\t  find_single_block_region ();\n-\t}\n-      else\n-\t{\n-\t  struct edge_list *edge_list;\n-\n-\t  /* The scheduler runs after estimate_probabilities; therefore, we\n-\t     can't blindly call back into find_basic_blocks since doing so\n-\t     could invalidate the branch probability info.  We could,\n-\t     however, call cleanup_cfg.  */\n-\t  edge_list = create_edge_list ();\n-\n-\t  /* Compute the dominators and post dominators.  */\n-\t  calculate_dominance_info (CDI_DOMINATORS);\n-\n-\t  /* build_control_flow will return nonzero if it detects unreachable\n-\t     blocks or any other irregularity with the cfg which prevents\n-\t     cross block scheduling.  */\n-\t  if (build_control_flow (edge_list) != 0)\n-\t    find_single_block_region ();\n-\t  else\n-\t    find_rgns (edge_list);\n+      /* Compute the dominators and post dominators.  */\n+      calculate_dominance_info (CDI_DOMINATORS);\n \n-\t  if (sched_verbose >= 3)\n-\t    debug_regions ();\n+      /* Find regions.  */\n+      find_rgns ();\n \n-\t  /* We are done with flow's edge list.  */\n-\t  free_edge_list (edge_list);\n+      if (sched_verbose >= 3)\n+\tdebug_regions ();\n \n-\t  /* For now.  This will move as more and more of haifa is converted\n-\t     to using the cfg code in flow.c.  */\n-\t  free_dominance_info (CDI_DOMINATORS);\n-\t}\n+      /* For now.  This will move as more and more of haifa is converted\n+\t to using the cfg code in flow.c.  */\n+      free_dominance_info (CDI_DOMINATORS);\n     }\n \n \n@@ -2738,23 +2587,6 @@ schedule_insns (FILE *dump_file)\n \n   sched_finish ();\n \n-  if (edge_table)\n-    {\n-      free (edge_table);\n-      edge_table = NULL;\n-    }\n-\n-  if (in_edges)\n-    {\n-      free (in_edges);\n-      in_edges = NULL;\n-    }\n-  if (out_edges)\n-    {\n-      free (out_edges);\n-      out_edges = NULL;\n-    }\n-\n   sbitmap_free (blocks);\n   sbitmap_free (large_region_blocks);\n }"}]}