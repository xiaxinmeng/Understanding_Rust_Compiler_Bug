{"sha": "d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ4MTdlM2ZiZmUwZTAyNjhhZWI5NmE3Y2U4NDVlNWU3ZmIzYTZhNg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-05-20T12:46:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:46:06Z"}, "message": "exp_ch6.adb (Expand_Call): Add guard to ensure that both the parent and the derived type are of the same kind.\n\n2008-05-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Add guard to ensure that both the parent\n\tand the derived type are of the same kind.\n\t(Expand_Call): Generate type conversions for actuals of\n\trecord or array types when the parent and the derived types differ in\n\tsize and/or packed status.\n\nFrom-SVN: r135624", "tree": {"sha": "68995467c8c5e817aecaf2aea92a7acac83fcf0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68995467c8c5e817aecaf2aea92a7acac83fcf0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f469be30bf03ea36b23f390b7446f499cb5be5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f469be30bf03ea36b23f390b7446f499cb5be5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f469be30bf03ea36b23f390b7446f499cb5be5e"}], "stats": {"total": 153, "additions": 93, "deletions": 60}, "files": [{"sha": "8791fcf69588cd90e26a4c26eab4550fbc1a1f0a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 93, "deletions": 60, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6", "patch": "@@ -2641,77 +2641,110 @@ package body Exp_Ch6 is\n               (\"cannot call abstract subprogram &!\", Name (N), Parent_Subp);\n          end if;\n \n-         --  Add an explicit conversion for parameter of the derived type.\n-         --  This is only done for scalar and access in-parameters. Others\n-         --  have been expanded in expand_actuals.\n+         --  Inspect all formals of derived subprogram Subp. Compare parameter\n+         --  types with the parent subprogram and check whether an actual may\n+         --  need a type conversion to the corresponding formal of the parent\n+         --  subprogram.\n \n-         Formal := First_Formal (Subp);\n-         Parent_Formal := First_Formal (Parent_Subp);\n-         Actual := First_Actual (N);\n-\n-         --  It is not clear that conversion is needed for intrinsic\n-         --  subprograms, but it certainly is for those that are user-\n-         --  defined, and that can be inherited on derivation, namely\n-         --  unchecked conversion and deallocation.\n-         --  General case needs study ???\n+         --  Not clear whether intrinsic subprograms need such conversions. ???\n \n          if not Is_Intrinsic_Subprogram (Parent_Subp)\n            or else Is_Generic_Instance (Parent_Subp)\n          then\n-            while Present (Formal) loop\n-               if Etype (Formal) /= Etype (Parent_Formal)\n-                 and then Is_Scalar_Type (Etype (Formal))\n-                 and then Ekind (Formal) = E_In_Parameter\n-                 and then\n-                   not Subtypes_Statically_Match\n-                         (Etype (Parent_Formal), Etype (Actual))\n-                 and then not Raises_Constraint_Error (Actual)\n-               then\n-                  Rewrite (Actual,\n-                    OK_Convert_To (Etype (Parent_Formal),\n-                      Relocate_Node (Actual)));\n+            declare\n+               procedure Convert (Act : Node_Id; Typ : Entity_Id);\n+               --  Rewrite node Act as a type conversion of Act to Typ. Analyze\n+               --  and resolve the newly generated construct.\n \n-                  Analyze (Actual);\n-                  Resolve (Actual, Etype (Parent_Formal));\n-                  Enable_Range_Check (Actual);\n+               -------------\n+               -- Convert --\n+               -------------\n \n-               elsif Is_Access_Type (Etype (Formal))\n-                 and then Base_Type (Etype (Parent_Formal)) /=\n-                          Base_Type (Etype (Actual))\n-               then\n-                  if Ekind (Formal) /= E_In_Parameter then\n-                     Rewrite (Actual,\n-                       Convert_To (Etype (Parent_Formal),\n-                         Relocate_Node (Actual)));\n-\n-                     Analyze (Actual);\n-                     Resolve (Actual, Etype (Parent_Formal));\n-\n-                  elsif\n-                    Ekind (Etype (Parent_Formal)) = E_Anonymous_Access_Type\n-                      and then Designated_Type (Etype (Parent_Formal))\n-                                 /=\n-                               Designated_Type (Etype (Actual))\n-                      and then not Is_Controlling_Formal (Formal)\n+               procedure Convert (Act : Node_Id; Typ : Entity_Id) is\n+               begin\n+                  Rewrite (Act, OK_Convert_To (Typ, Relocate_Node (Act)));\n+                  Analyze (Act);\n+                  Resolve (Act, Typ);\n+               end Convert;\n+\n+               --  Local variables\n+\n+               Actual_Typ : Entity_Id;\n+               Formal_Typ : Entity_Id;\n+               Parent_Typ : Entity_Id;\n+\n+            begin\n+               Actual := First_Actual (N);\n+               Formal := First_Formal (Subp);\n+               Parent_Formal := First_Formal (Parent_Subp);\n+               while Present (Formal) loop\n+                  Actual_Typ := Etype (Actual);\n+                  Formal_Typ := Etype (Formal);\n+                  Parent_Typ := Etype (Parent_Formal);\n+\n+                  --  For an IN parameter of a scalar type, the parent formal\n+                  --  type and derived formal type differ or the parent formal\n+                  --  type and actual type do not match statically.\n+\n+                  if Is_Scalar_Type (Formal_Typ)\n+                    and then Ekind (Formal) = E_In_Parameter\n+                    and then Formal_Typ /= Parent_Typ\n+                    and then\n+                      not Subtypes_Statically_Match (Parent_Typ, Actual_Typ)\n+                    and then not Raises_Constraint_Error (Actual)\n                   then\n-                     --  This unchecked conversion is not necessary unless\n-                     --  inlining is enabled, because in that case the type\n-                     --  mismatch may become visible in the body about to be\n-                     --  inlined.\n+                     Convert (Actual, Parent_Typ);\n+                     Enable_Range_Check (Actual);\n \n-                     Rewrite (Actual,\n-                       Unchecked_Convert_To (Etype (Parent_Formal),\n-                         Relocate_Node (Actual)));\n+                  --  For access types, the parent formal type and actual type\n+                  --  differ.\n \n-                     Analyze (Actual);\n-                     Resolve (Actual, Etype (Parent_Formal));\n+                  elsif Is_Access_Type (Formal_Typ)\n+                    and then Base_Type (Parent_Typ) /= Base_Type (Actual_Typ)\n+                  then\n+                     if Ekind (Formal) /= E_In_Parameter then\n+                        Convert (Actual, Parent_Typ);\n+\n+                     elsif Ekind (Parent_Typ) = E_Anonymous_Access_Type\n+                       and then Designated_Type (Parent_Typ) /=\n+                                Designated_Type (Actual_Typ)\n+                       and then not Is_Controlling_Formal (Formal)\n+                     then\n+                        --  This unchecked conversion is not necessary unless\n+                        --  inlining is enabled, because in that case the type\n+                        --  mismatch may become visible in the body about to be\n+                        --  inlined.\n+\n+                        Rewrite (Actual,\n+                          Unchecked_Convert_To (Parent_Typ,\n+                            Relocate_Node (Actual)));\n+\n+                        Analyze (Actual);\n+                        Resolve (Actual, Parent_Typ);\n+                     end if;\n+\n+                  --  For array and record types, the parent formal type and\n+                  --  derived formal type have different sizes or pragma Pack\n+                  --  status.\n+\n+                  elsif ((Is_Array_Type (Formal_Typ)\n+                            and then Is_Array_Type (Parent_Typ))\n+                       or else\n+                         (Is_Record_Type (Formal_Typ)\n+                            and then Is_Record_Type (Parent_Typ)))\n+                    and then\n+                      (Esize (Formal_Typ) /= Esize (Parent_Typ)\n+                         or else Has_Pragma_Pack (Formal_Typ) /=\n+                                 Has_Pragma_Pack (Parent_Typ))\n+                  then\n+                     Convert (Actual, Parent_Typ);\n                   end if;\n-               end if;\n \n-               Next_Formal (Formal);\n-               Next_Formal (Parent_Formal);\n-               Next_Actual (Actual);\n-            end loop;\n+                  Next_Actual (Actual);\n+                  Next_Formal (Formal);\n+                  Next_Formal (Parent_Formal);\n+               end loop;\n+            end;\n          end if;\n \n          Orig_Subp := Subp;\n@@ -2744,7 +2777,7 @@ package body Exp_Ch6 is\n       --  Handle case of access to protected subprogram type\n \n          if Is_Access_Protected_Subprogram_Type\n-            (Base_Type (Etype (Prefix (Name (N)))))\n+              (Base_Type (Etype (Prefix (Name (N)))))\n          then\n             --  If this is a call through an access to protected operation,\n             --  the prefix has the form (object'address, operation'access)."}]}