{"sha": "2aa7ec3746c846618627de446610b303230bef68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFhN2VjMzc0NmM4NDY2MTg2MjdkZTQ0NjYxMGIzMDMyMzBiZWY2OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T06:05:57Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T06:05:57Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r482", "tree": {"sha": "d1b8ddc5cd4547b08464b28bcbe3a80d9e3103c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1b8ddc5cd4547b08464b28bcbe3a80d9e3103c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aa7ec3746c846618627de446610b303230bef68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa7ec3746c846618627de446610b303230bef68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa7ec3746c846618627de446610b303230bef68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa7ec3746c846618627de446610b303230bef68/comments", "author": null, "committer": null, "parents": [{"sha": "64a184e92d716f16d8af20f246891859e93d6397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a184e92d716f16d8af20f246891859e93d6397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64a184e92d716f16d8af20f246891859e93d6397"}], "stats": {"total": 86, "additions": 62, "deletions": 24}, "files": [{"sha": "9147e477bdb7325d766a523c3b9c13e826ad7edf", "filename": "gcc/cccp.c", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa7ec3746c846618627de446610b303230bef68/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa7ec3746c846618627de446610b303230bef68/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=2aa7ec3746c846618627de446610b303230bef68", "patch": "@@ -377,6 +377,10 @@ static int warn_stringify;\n \n static int warn_trigraphs;\n \n+/* Nonzero means warn if #import is used.  */\n+\n+static int warn_import = 1;\n+\n /* Nonzero means turn warnings into errors.  */\n \n static int warnings_are_errors;\n@@ -1081,6 +1085,10 @@ main (argc, argv)\n \t  warn_stringify = 1;\n \telse if (!strcmp (argv[i], \"-Wno-traditional\"))\n \t  warn_stringify = 0;\n+\telse if (!strcmp (argv[i], \"-Wimport\"))\n+\t  warn_import = 1;\n+\telse if (!strcmp (argv[i], \"-Wno-import\"))\n+\t  warn_import = 0;\n \telse if (!strcmp (argv[i], \"-Werror\"))\n \t  warnings_are_errors = 1;\n \telse if (!strcmp (argv[i], \"-Wno-error\"))\n@@ -1446,7 +1454,13 @@ main (argc, argv)\n       startp = endp = epath;\n       num_dirs = 0;\n       while (1) {\n-\tif ((*endp == ':') || (*endp == '\\0')) {\n+        /* Handle cases like c:/usr/lib:d:/gcc/lib */\n+        if ((*endp == ':'\n+#ifdef __MSDOS__\n+\t     && (endp-startp != 1 || !isalpha (*startp)))\n+#endif\n+\t     )\n+            || (*endp == 0)) {\n \t  strncpy (nstore, startp, endp-startp);\n \t  if (endp == startp)\n \t    strcpy (nstore, \".\");\n@@ -1813,7 +1827,12 @@ path_include (path)\n       struct file_name_list *dirtmp;\n \n       /* Find the end of this name.  */\n+#ifdef __MSDOS__\n+      /* Handle cases like c:/usr/lib:d:/gcc/lib */\n+      while (*q != 0 && (*q != ':' || (q - p == 1 && isalpha (*p)))) q++;\n+#else\n       while (*q != 0 && *q != ':') q++;\n+#endif\n       if (p == q) {\n \t/* An empty name in the path stands for the current directory.  */\n \tname = (char *) xmalloc (2);\n@@ -1924,7 +1943,7 @@ trigraph_pcp (buf)\n \f\n /* Move all backslash-newline pairs out of embarrassing places.\n    Exchange all such pairs following BP\n-   with any potentially-embarrasing characters that follow them.\n+   with any potentially-embarrassing characters that follow them.\n    Potentially-embarrassing characters are / and *\n    (because a backslash-newline inside a comment delimiter\n    would cause it not to be recognized).  */\n@@ -3042,7 +3061,7 @@ handle_directive (ip, op)\n       bp++;\n     } else if (*bp == '/' && bp[1] == '*') {\n       ip->bufp = bp;\n-      skip_to_end_of_comment (ip, &ip->lineno);\n+      skip_to_end_of_comment (ip, &ip->lineno, 0);\n       bp = ip->bufp;\n     } else if (*bp == '\\\\' && bp[1] == '\\n') {\n       bp += 2; ip->lineno++;\n@@ -3186,7 +3205,7 @@ handle_directive (ip, op)\n \t      || ((cplusplus || objc) && *bp == '/')) {\n \t    U_CHAR *obp = bp - 1;\n \t    ip->bufp = bp + 1;\n-\t    skip_to_end_of_comment (ip, &ip->lineno);\n+\t    skip_to_end_of_comment (ip, &ip->lineno, 0);\n \t    bp = ip->bufp;\n \t    /* No need to copy the command because of a comment at the end;\n \t       just don't include the comment in the directive.  */\n@@ -3320,7 +3339,7 @@ handle_directive (ip, op)\n \t      ip->bufp = xp + 1;\n \t      /* If we already copied the command through,\n \t\t already_output != 0 prevents outputting comment now.  */\n-\t      skip_to_end_of_comment (ip, already_output);\n+\t      skip_to_end_of_comment (ip, already_output, 0);\n \t      if (keep_comments)\n \t\twhile (xp != ip->bufp)\n \t\t  *cp++ = *xp++;\n@@ -3588,7 +3607,8 @@ do_include (buf, limit, op, keyword)\n   int pcfnum;\n   f= -1;\t\t\t/* JF we iz paranoid! */\n \n-  if (importing && !instack[indepth].system_header_p && !import_warning) {\n+  if (importing && warn_import\n+      && !instack[indepth].system_header_p && !import_warning) {\n     import_warning = 1;\n     warning (\"using `#import' is not recommended\");\n     fprintf (stderr, \"The fact that a certain header file need not be processed more than once\\n\");\n@@ -4336,7 +4356,7 @@ pcfinclude (buf, limit, name, op)\n     if (nkeys == -1)\n       str->writeflag = 1;\n     else\n-      /* Otherwist, for each key, */\n+      /* Otherwise, for each key, */\n       for (; nkeys--; free (tmpbuf.buf), cp = endofthiskey + 1) {\n \tKEYDEF *kp = (KEYDEF *) cp;\n \tHASHNODE *hp;\n@@ -4441,7 +4461,7 @@ write_output ()\n }\n \n /* Pass a directive through to the output file.\n-   BUF points to the contents of the directive, as a continguous string.\n+   BUF points to the contents of the directive, as a contiguous string.\n    LIMIT points to the first character past the end of the directive.\n    KEYWORD is the keyword-table entry for the directive.  */\n \n@@ -4618,7 +4638,7 @@ create_definition (buf, limit, op)\n }\n  \n /* Process a #define command.\n-BUF points to the contents of the #define command, as a continguous string.\n+BUF points to the contents of the #define command, as a contiguous string.\n LIMIT points to the first character past the end of the definition.\n KEYWORD is the keyword-table entry for #define.  */\n \n@@ -5558,13 +5578,20 @@ do_line (buf, limit, op, keyword)\n \tfile_change = enter_file;\n       else if (*bp == '2')\n \tfile_change = leave_file;\n+      else if (*bp == '3')\n+\tip->system_header_p = 1;\n       else {\n \terror (\"invalid format `#line' command\");\n \treturn 0;\n       }\n \n       bp++;\n       SKIP_WHITE_SPACE (bp);\n+      if (*bp == '3') {\n+\tip->system_header_p = 1;\n+\tbp++;\n+\tSKIP_WHITE_SPACE (bp);\n+      }\n       if (*bp) {\n \terror (\"invalid format `#line' command\");\n \treturn 0;\n@@ -5908,7 +5935,7 @@ do_xifdef (buf, limit, op, keyword)\n \t  int junk;\n \t  U_CHAR *save_bufp = ip->bufp;\n \t  ip->bufp = p + 1;\n-\t  p = skip_to_end_of_comment (ip, &junk);\n+\t  p = skip_to_end_of_comment (ip, &junk, 1);\n \t  ip->bufp = save_bufp;\n \t}\n \tbreak;\n@@ -6027,7 +6054,7 @@ skip_if_group (ip, any)\n       if (*bp == '*'\n \t  || ((cplusplus || objc) && *bp == '/')) {\n \tip->bufp = ++bp;\n-\tbp = skip_to_end_of_comment (ip, &ip->lineno);\n+\tbp = skip_to_end_of_comment (ip, &ip->lineno, 0);\n       }\n       break;\n     case '\\\"':\n@@ -6302,7 +6329,7 @@ do_endif (buf, limit, op, keyword)\n \t    int junk;\n \t    U_CHAR *save_bufp = ip->bufp;\n \t    ip->bufp = p + 1;\n-\t    p = skip_to_end_of_comment (ip, &junk);\n+\t    p = skip_to_end_of_comment (ip, &junk, 1);\n \t    ip->bufp = save_bufp;\n \t  }\n \t  break;\n@@ -6365,17 +6392,21 @@ validate_else (p)\n     pedwarn (\"text following `#else' or `#endif' violates ANSI standard\");\n }\n \f\n-/*\n- * Skip a comment, assuming the input ptr immediately follows the\n- * initial slash-star.  Bump line counter as necessary.\n- * (The canonical line counter is &ip->lineno).\n- * Don't use this routine (or the next one) if bumping the line\n- * counter is not sufficient to deal with newlines in the string.\n- */\n+/* Skip a comment, assuming the input ptr immediately follows the\n+   initial slash-star.  Bump *LINE_COUNTER for each newline.\n+   (The canonical line counter is &ip->lineno.)\n+   Don't use this routine (or the next one) if bumping the line\n+   counter is not sufficient to deal with newlines in the string.\n+\n+   If NOWARN is nonzero, don't warn about slash-star inside a comment.\n+   This feature is useful when processing a comment that is going to be\n+   processed or was processed at another point in the preprocessor,\n+   to avoid a duplicate warning.  */\n static U_CHAR *\n-skip_to_end_of_comment (ip, line_counter)\n+skip_to_end_of_comment (ip, line_counter, nowarn)\n      register FILE_BUF *ip;\n      int *line_counter;\t\t/* place to remember newlines, or NULL */\n+     int nowarn;\n {\n   register U_CHAR *limit = ip->buf + ip->length;\n   register U_CHAR *bp = ip->bufp;\n@@ -6415,7 +6446,7 @@ skip_to_end_of_comment (ip, line_counter)\n       *op->bufp++ = *bp;\n     switch (*bp++) {\n     case '/':\n-      if (warn_comments && bp < limit && *bp == '*')\n+      if (warn_comments && !nowarn && bp < limit && *bp == '*')\n \twarning (\"`/*' within comment\");\n       break;\n     case '\\n':\n@@ -6525,7 +6556,7 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n    IP->bufp is updated.  Use this with IP->bufp pointing at an open-paren.\n \n    This does not handle newlines, because it's used for the arg of #if,\n-   where there aren't any newlines.  Also, bacslash-newline can't appear.  */\n+   where there aren't any newlines.  Also, backslash-newline can't appear.  */\n \n static U_CHAR *\n skip_paren_group (ip)\n@@ -6552,7 +6583,7 @@ skip_paren_group (ip)\n     case '/':\n       if (*p == '*') {\n \tip->bufp = p;\n-\tp = skip_to_end_of_comment (ip, &lines_dummy);\n+\tp = skip_to_end_of_comment (ip, &lines_dummy, 0);\n \tp = ip->bufp;\n       }\n \n@@ -6612,6 +6643,13 @@ output_line_command (ip, op, conditional, file_change)\n     }\n   }\n \n+  /* Don't output a line number of 0 if we can help it.  */\n+  if (ip->lineno == 0 && ip->bufp - ip->buf < ip->length\n+      && *ip->bufp == '\\n') {\n+    ip->lineno++;\n+    ip->bufp++;\n+  }\n+\n #ifdef OUTPUT_LINE_COMMANDS\n   sprintf (line_cmd_buf, \"#line %d \\\"%s\\\"\", ip->lineno, ip->nominal_fname);\n #else\n@@ -8455,7 +8493,7 @@ hack_vms_include_specification (fname)\n   if (((cp - fname) > 1) && ((cp[-1] == ']') || (cp[-1] == '>'))) {\n     if (cp[-2] != '.') {\n       /*\n-       * The VMS part ends in a `]', and the preceeding character is not a `.'.\n+       * The VMS part ends in a `]', and the preceding character is not a `.'.\n        * We strip the `]', and then splice the two parts of the name in the\n        * usual way.  Given the default locations for include files in cccp.c,\n        * we will only use this code if the user specifies alternate locations"}]}