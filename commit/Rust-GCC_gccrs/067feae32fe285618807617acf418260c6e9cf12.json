{"sha": "067feae32fe285618807617acf418260c6e9cf12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY3ZmVhZTMyZmUyODU2MTg4MDc2MTdhY2Y0MTgyNjBjNmU5Y2YxMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-03-29T08:11:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-03-29T08:11:02Z"}, "message": "re PR fortran/35698 (lbound and ubound wrong for allocated run-time zero size array)\n\n2008-03-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35698\n\t* trans-array.c (gfc_array_init_size): Set 'size' zero if\n\tnegative in one dimension.\n\n\tPR fortran/35702\n\t* trans-expr.c (gfc_trans_string_copy): Only assign a char\n\tdirectly if the lhs and rhs types are the same.\n\n2008-03-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35698\n\t* gfortran.dg/allocate_zerosize_3.f: New test.\n\n\tPR fortran/35702\n\t* gfortran.dg/character_assign_1.f90: New test.\n\nFrom-SVN: r133710", "tree": {"sha": "4a75eff4d82cbafdd38d6c403013a27b5d32c727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a75eff4d82cbafdd38d6c403013a27b5d32c727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/067feae32fe285618807617acf418260c6e9cf12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067feae32fe285618807617acf418260c6e9cf12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/067feae32fe285618807617acf418260c6e9cf12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067feae32fe285618807617acf418260c6e9cf12/comments", "author": null, "committer": null, "parents": [{"sha": "dbc518f09c4ac4499dcbf5802e20cd4adb0d9a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc518f09c4ac4499dcbf5802e20cd4adb0d9a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbc518f09c4ac4499dcbf5802e20cd4adb0d9a41"}], "stats": {"total": 84, "additions": 82, "deletions": 2}, "files": [{"sha": "6615fd35051d0f513c72daaf9966e383529bdbdb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=067feae32fe285618807617acf418260c6e9cf12", "patch": "@@ -1,3 +1,13 @@\n+2008-03-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35698\n+\t* trans-array.c (gfc_array_init_size): Set 'size' zero if\n+\tnegative in one dimension.\n+\n+\tPR fortran/35702\n+\t* trans-expr.c (gfc_trans_string_copy): Only assign a char\n+\tdirectly if the lhs and rhs types are the same.\n+\n 2008-03-28  Daniel Franke  <franke.daniel@gmail.com>\n \t    Paul Richard Thomas <paul.richard.thomas@gmail.com>\n "}, {"sha": "3de1fb71f20c86fde3a8451659531858671fb0e5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=067feae32fe285618807617acf418260c6e9cf12", "patch": "@@ -3505,7 +3505,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n         size = 1 - lbound;\n         a.ubound[n] = specified_upper_bound;\n         a.stride[n] = stride;\n-        size = ubound + size; //size = ubound + 1 - lbound\n+        size = siz >= 0 ? ubound + size : 0; //size = ubound + 1 - lbound\n         stride = stride * size;\n       }\n     return (stride);\n@@ -3605,6 +3605,9 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       else\n \tor_expr = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, or_expr, cond);\n \n+      size = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t\t  gfc_index_zero_node, size);\n+\n       /* Multiply the stride by the number of elements in this dimension.  */\n       stride = fold_build2 (MULT_EXPR, gfc_array_index_type, stride, size);\n       stride = gfc_evaluate_now (stride, pblock);"}, {"sha": "016724703317e36682f6008d9faf7ca0dba64565", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=067feae32fe285618807617acf418260c6e9cf12", "patch": "@@ -2858,7 +2858,9 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n     dsc = gfc_to_single_character (dlen, dest);\n \n \n-  if (dsc != NULL_TREE && ssc != NULL_TREE)\n+  /* Assign directly if the types are compatible.  */\n+  if (dsc != NULL_TREE && ssc != NULL_TREE\n+\t&& TREE_TYPE (dsc) == TREE_TYPE (ssc))\n     {\n       gfc_add_modify_expr (block, dsc, ssc);\n       return;"}, {"sha": "079be17bc78f2cbf99575721246f7e0ee5f4c3b5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=067feae32fe285618807617acf418260c6e9cf12", "patch": "@@ -1,3 +1,11 @@\n+2008-03-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35698\n+\t* gfortran.dg/allocate_zerosize_3.f: New test.\n+\n+\tPR fortran/35702\n+\t* gfortran.dg/character_assign_1.f90: New test.\n+\n 2008-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/32972"}, {"sha": "57f2d75b67c99041ba1d89f13c22d64e56c2ec72", "filename": "gcc/testsuite/gfortran.dg/allocate_zerosize_3.f", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_zerosize_3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_zerosize_3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_zerosize_3.f?ref=067feae32fe285618807617acf418260c6e9cf12", "patch": "@@ -0,0 +1,40 @@\n+C { dg-do run }\n+C Test the fix for PR35698, in which the negative size dimension would\n+C throw out the subsequent bounds.\n+C\n+C Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+C\n+      program try_lf0030\n+      call LF0030(10)\n+      end\n+\n+      SUBROUTINE LF0030(nf10)\n+      INTEGER ILA1(7)\n+      INTEGER ILA2(7)\n+      LOGICAL LLA(:,:,:,:,:,:,:)\n+      INTEGER ICA(7)\n+      ALLOCATABLE LLA\n+\n+\n+      ALLOCATE (LLA(2:3, 4, 0:5,\n+     $          NF10:1, -2:7, -3:8,\n+     $          -4:9))\n+\n+      ILA1 = LBOUND(LLA)\n+      ILA2 = UBOUND(LLA)\n+C     CORRECT FOR THE ZERO DIMENSIONED TERM TO ALLOW AN EASIER VERIFY\n+      ILA1(4) = ILA1(4) - 2    !   1 - 2 = -1\n+      ILA2(4) = ILA2(4) + 6    !   0 + 6 = 6     \n+\n+      DO J1 = 1,7\n+      IVAL = 3-J1\n+      IF (ILA1(J1) .NE. IVAL) call abort ()\n+  100 ENDDO\n+\n+      DO J1 = 1,7\n+      IVAL = 2+J1\n+      IF (ILA2(J1) .NE. IVAL) call abort ()\n+  101 ENDDO\n+\n+      END SUBROUTINE\n+      \n\\ No newline at end of file"}, {"sha": "a4e073299b31bfc9385e18a98238e9bcca3d4060", "filename": "gcc/testsuite/gfortran.dg/character_assign_1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_assign_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067feae32fe285618807617acf418260c6e9cf12/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_assign_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_assign_1.f90?ref=067feae32fe285618807617acf418260c6e9cf12", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! Tests the fix for PR35702, which caused an ICE because the types in the assignment\n+! were not translated to be the same.\n+!\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+!\n+MODULE TESTS\n+  TYPE UNSEQ\n+    CHARACTER(1) :: C\n+  END TYPE UNSEQ       \n+CONTAINS\n+  SUBROUTINE CG0028 (TDA1L, TDA1R, nf0, nf1, nf2, nf3)\n+    TYPE(UNSEQ) TDA1L(NF3)\n+    TDA1L(NF1:NF2:NF1)%C = TDA1L(NF0+2:NF3:NF2/2)%C\n+  END SUBROUTINE\n+END MODULE TESTS\n+! { dg-final { cleanup-modules \"tests\" } }"}]}