{"sha": "17167fd8b5d38d7a273d66ef86a29492cace62f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcxNjdmZDhiNWQzOGQ3YTI3M2Q2NmVmODZhMjk0OTJjYWNlNjJmNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-09-25T17:49:19Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-09-25T17:49:19Z"}, "message": "Add OUTPUT_ASM_MI_THUNK; use r12 as temp for System V profiling, not r11\n\nFrom-SVN: r22594", "tree": {"sha": "74280e09ee509423fc4326d042930e2370cc1a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74280e09ee509423fc4326d042930e2370cc1a95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17167fd8b5d38d7a273d66ef86a29492cace62f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17167fd8b5d38d7a273d66ef86a29492cace62f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17167fd8b5d38d7a273d66ef86a29492cace62f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17167fd8b5d38d7a273d66ef86a29492cace62f6/comments", "author": null, "committer": null, "parents": [{"sha": "ccf82a75b03bf8fac0a0ee3ea1d5c14bcd7bb8a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf82a75b03bf8fac0a0ee3ea1d5c14bcd7bb8a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf82a75b03bf8fac0a0ee3ea1d5c14bcd7bb8a8"}], "stats": {"total": 273, "additions": 266, "deletions": 7}, "files": [{"sha": "b48812138fd5b2233ea9f60333be424d6d41cb60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17167fd8b5d38d7a273d66ef86a29492cace62f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17167fd8b5d38d7a273d66ef86a29492cace62f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17167fd8b5d38d7a273d66ef86a29492cace62f6", "patch": "@@ -1,3 +1,12 @@\n+Fri Sep 25 20:30:00 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* rs6000.h (ASM_OUTPUT_MI_THUNK): Declare, call output_mi_thunk.\n+\t(output_mi_thunk): Declare.\n+\n+\t* rs6000.c (output_mi_thunk): Function to create thunks for MI.\n+\t(output_function_profiler): Use r12 for temp, instead of r11 so\n+\tthat we preserve the static chain register.\n+\t\n Fri Sep 25 14:18:33 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* sdbout.c (sdbout_one_type): Don't look at TYPE_BINFO field of enums."}, {"sha": "eed242ecb934d72acbaf7e15070710e27017d35d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 224, "deletions": 7, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17167fd8b5d38d7a273d66ef86a29492cace62f6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17167fd8b5d38d7a273d66ef86a29492cace62f6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=17167fd8b5d38d7a273d66ef86a29492cace62f6", "patch": "@@ -4447,6 +4447,223 @@ output_epilog (file, size)\n       fputs (\":\\n\", file);\n     }\n }\n+\f\n+/* A C compound statement that outputs the assembler code for a thunk function,\n+   used to implement C++ virtual function calls with multiple inheritance.  The\n+   thunk acts as a wrapper around a virtual function, adjusting the implicit\n+   object parameter before handing control off to the real function.\n+\n+   First, emit code to add the integer DELTA to the location that contains the\n+   incoming first argument.  Assume that this argument contains a pointer, and\n+   is the one used to pass the `this' pointer in C++.  This is the incoming\n+   argument *before* the function prologue, e.g. `%o0' on a sparc.  The\n+   addition must preserve the values of all other incoming arguments.\n+\n+   After the addition, emit code to jump to FUNCTION, which is a\n+   `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does not touch\n+   the return address.  Hence returning from FUNCTION will return to whoever\n+   called the current `thunk'.\n+\n+   The effect must be as if FUNCTION had been called directly with the adjusted\n+   first argument.  This macro is responsible for emitting all of the code for\n+   a thunk function; `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' are not\n+   invoked.\n+\n+   The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been\n+   extracted from it.)  It might possibly be useful on some targets, but\n+   probably not.\n+\n+   If you do not define this macro, the target-independent code in the C++\n+   frontend will generate a less efficient heavyweight thunk that calls\n+   FUNCTION instead of jumping to it.  The generic approach does not support\n+   varargs.  */\n+\n+void\n+output_mi_thunk (file, thunk_fndecl, delta, function)\n+     FILE *file;\n+     tree thunk_fndecl;\n+     int delta;\n+     tree function;\n+{\n+  char *this_reg = reg_names[ aggregate_value_p (TREE_TYPE (function)) ? 3 : 4 ];\n+  char *r0\t = reg_names[0];\n+  char *sp\t = reg_names[1];\n+  char *toc\t = reg_names[2];\n+  char *schain\t = reg_names[11];\n+  char *r12\t = reg_names[12];\n+  char *prefix;\n+  char *fname;\n+  char buf[512];\n+  static int labelno = 0;\n+\n+  /* Small constants that can be done by one add instruction */\n+  if (delta >= -32768 && delta <= 32767)\n+    {\n+      if (!TARGET_NEW_MNEMONICS)\n+\tfprintf (file, \"\\tcal %s,%d(%s)\\n\", this_reg, delta, this_reg);\n+      else\n+\tfprintf (file, \"\\taddi %s,%s,%d\\n\", this_reg, this_reg, delta);\n+    }\n+\n+  /* Large constants that can be done by one addis instruction */\n+  else if ((delta & 0xffff) == 0 && num_insns_constant_wide (delta) == 1)\n+    asm_fprintf (file, \"\\t{cau|addis} %s,%s,%d\\n\", this_reg, this_reg,\n+\t\t delta >> 16);\n+\n+  /* 32-bit constants that can be done by an add and addis instruction.  */\n+  else if (TARGET_32BIT || num_insns_constant_wide (delta) == 1)\n+    {\n+      /* Break into two pieces, propigating the sign bit from the low word to\n+\t the upper word.  */\n+      int delta_high = delta >> 16;\n+      int delta_low  = delta & 0xffff;\n+      if ((delta_low & 0x8000) != 0)\n+\t{\n+\t  delta_high++;\n+\t  delta_low = (delta_low ^ 0x8000) - 0x8000;\t/* sign extend */\n+\t}\n+\n+      asm_fprintf (file, \"\\t{cau|addis} %s,%s,%d\\n\", this_reg, this_reg,\n+\t\t   delta_high);\n+\n+      if (!TARGET_NEW_MNEMONICS)\n+\tfprintf (file, \"\\tcal %s,%d(%s)\\n\", this_reg, delta_low, this_reg);\n+      else\n+\tfprintf (file, \"\\taddi %s,%s,%d\\n\", this_reg, this_reg, delta_low);\n+    }\n+\n+  /* 64-bit constants, fixme */\n+  else\n+    abort ();\n+\n+  /* Get the prefix in front of the names.  */\n+  switch (DEFAULT_ABI)\n+    {\n+    default:\n+      abort ();\n+\n+    case ABI_AIX:\n+      prefix = \".\";\n+      break;\n+\n+    case ABI_V4:\n+    case ABI_AIX_NODESC:\n+    case ABI_SOLARIS:\n+      prefix = \"\";\n+      break;\n+\n+    case ABI_NT:\n+      prefix = \"..\";\n+      break;\n+    }\n+\n+  /* If the function is compiled in this module, jump to it directly.\n+     Otherwise, load up its address and jump to it.  */\n+\n+  fname = XSTR (XEXP (DECL_RTL (function), 0), 0);\n+  if (TREE_ASM_WRITTEN (function)\n+      && !lookup_attribute (\"longcall\", TYPE_ATTRIBUTES (TREE_TYPE (function))))\n+    {\n+      fprintf (file, \"\\tb %s\", prefix);\n+      assemble_name (file, fname);\n+      fprintf (file, \"\\n\");\n+    }\n+\n+  else\n+    {\n+      switch (DEFAULT_ABI)\n+\t{\n+\tdefault:\n+\tcase ABI_NT:\n+\t  abort ();\n+\n+\tcase ABI_AIX:\n+\t  /* Set up a TOC entry for the function.  */\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"Lthunk\", labelno);\n+\t  toc_section ();\n+\t  ASM_OUTPUT_INTERNAL_LABEL (file, \"Lthunk\", labelno);\n+\t  labelno++;\n+\n+\t  /* Note, MINIMAL_TOC doesn't make sense in the case of a thunk, since\n+\t     there will be only one TOC entry for this function.  */\n+\t  fputs (\"\\t.tc\\t\", file);\n+\t  assemble_name (file, buf);\n+\t  fputs (\"[TC],\", file);\n+\t  assemble_name (file, buf);\n+\t  putc ('\\n', file);\n+\t  text_section ();\n+\t  asm_fprintf (file, (TARGET_32BIT) ? \"\\t{l|lwz} %s,\" : \"\\tld %s\", r12);\n+\t  assemble_name (file, buf);\n+\t  asm_fprintf (file, \"(%s)\\n\", reg_names[2]);\n+\t  asm_fprintf (file,\n+\t\t       (TARGET_32BIT) ? \"\\t{l|lwz} %s,0(%s)\\n\" : \"\\tld %s,0(%s)\\n\",\n+\t\t       r0, r12);\n+\n+\t  asm_fprintf (file,\n+\t\t       (TARGET_32BIT) ? \"\\t{l|lwz} %s,4(%s)\\n\" : \"\\tld %s,8(%s)\\n\",\n+\t\t       toc, r12);\n+\n+\t  asm_fprintf (file, \"\\tmtctr %s\\n\", r0);\n+\t  asm_fprintf (file,\n+\t\t       (TARGET_32BIT) ? \"\\t{l|lwz} %s,8(%s)\\n\" : \"\\tld %s,16(%s)\\n\",\n+\t\t       schain, r12);\n+\n+\t  asm_fprintf (file, \"\\tbctr\\n\");\n+\t  break;\n+\n+\t  /* Don't use r11, that contains the static chain, just use r0/r12.  */\n+\tcase ABI_V4:\n+\tcase ABI_AIX_NODESC:\n+\tcase ABI_SOLARIS:\n+\t  if (flag_pic == 1)\n+\t    {\n+\t      fprintf (file, \"\\tmflr %s\\n\", r0);\n+\t      fputs (\"\\tbl _GLOBAL_OFFSET_TABLE_@local-4\\n\", file);\n+\t      asm_fprintf (file, \"\\tmflr %s\\n\", r12);\n+\t      asm_fprintf (file, \"\\tmtlr %s\\n\", r0);\n+\t      asm_fprintf (file, \"\\t{l|lwz} %s,\", r0);\n+\t      assemble_name (file, fname);\n+\t      asm_fprintf (file, \"@got(%s)\\n\", r12);\n+\t    }\n+#if TARGET_ELF\n+\t  else if (flag_pic > 1 || TARGET_RELOCATABLE)\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (buf, \"Lthunk\", labelno);\n+\t      labelno++;\n+\t      fprintf (file, \"\\tmflr %s\\n\", r0);\n+\t      asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\", r0, sp);\n+\t      rs6000_pic_func_labelno = rs6000_pic_labelno;\n+\t      rs6000_output_load_toc_table (file, 12);\n+\t      asm_fprintf (file, \"\\t{l|lwz} %s,\", r0);\n+\t      assemble_name (file, buf);\n+\t      asm_fprintf (file, \"(%s)\\n\", r12);\n+\t      asm_fprintf (file, \"\\t{l|lwz} %s,4(%s)\\n\", r12, sp);\n+\t      asm_fprintf (file, \"\\tmtlr %s\\n\", r12);\n+\t      asm_fprintf (file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\n+\t      assemble_name (file, buf);\n+\t      fputs (\" = .-.LCTOC1\\n\", file);\n+\t      fputs (\"\\t.long \", file);\n+\t      assemble_name (file, fname);\n+\t      fputs (\"\\n\\t.previous\\n\", file);\n+\t    }\n+#endif\n+\t  else\n+\t    {\n+\t      asm_fprintf (file, \"\\t{liu|lis} %s,\", r0);\n+\t      assemble_name (file, fname);\n+\t      asm_fprintf (file, \"@ha\\n\");\n+\t      asm_fprintf (file, \"\\t{cal|la} %s,\", r0);\n+\t      assemble_name (file, fname);\n+\t      asm_fprintf (file, \"@l(%s)\\n\", r0);\n+\t    }\n+\n+\t  asm_fprintf (file, \"\\tmtctr %s\\n\", r0);\n+\t  asm_fprintf (file, \"\\tbctr\\n\");\n+\t  break;\n+\t}\n+    }\n+}\n+\n \f\n /* Output a TOC entry.  We derive the entry name from what is\n    being written.  */\n@@ -4778,21 +4995,21 @@ output_function_profiler (file, labelno)\n \t  fputs (\"\\tbl _GLOBAL_OFFSET_TABLE_@local-4\\n\", file);\n \t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\",\n \t\t       reg_names[0], reg_names[1]);\n-\t  asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[11]);\n+\t  asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[12]);\n \t  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[0]);\n \t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"@got(%s)\\n\", reg_names[11]);\n+\t  asm_fprintf (file, \"@got(%s)\\n\", reg_names[12]);\n \t}\n #if TARGET_ELF\n       else if (flag_pic > 1 || TARGET_RELOCATABLE)\n \t{\n \t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\",\n \t\t       reg_names[0], reg_names[1]);\n \t  rs6000_pic_func_labelno = rs6000_pic_labelno;\n-\t  rs6000_output_load_toc_table (file, 11);\n-\t  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[11]);\n+\t  rs6000_output_load_toc_table (file, 12);\n+\t  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[12]);\n \t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"X(%s)\\n\", reg_names[11]);\n+\t  asm_fprintf (file, \"X(%s)\\n\", reg_names[12]);\n \t  asm_fprintf (file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\n \t  assemble_name (file, buf);\n \t  fputs (\"X = .-.LCTOC1\\n\", file);\n@@ -4803,13 +5020,13 @@ output_function_profiler (file, labelno)\n #endif\n       else\n \t{\n-\t  asm_fprintf (file, \"\\t{liu|lis} %s,\", reg_names[11]);\n+\t  asm_fprintf (file, \"\\t{liu|lis} %s,\", reg_names[12]);\n \t  assemble_name (file, buf);\n \t  fputs (\"@ha\\n\", file);\n \t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n \t  asm_fprintf (file, \"\\t{cal|la} %s,\", reg_names[0]);\n \t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[11]);\n+\t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[12]);\n \t}\n \n       fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);"}, {"sha": "0e10ad671606622ac795144616009a3f4cc13a66", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17167fd8b5d38d7a273d66ef86a29492cace62f6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17167fd8b5d38d7a273d66ef86a29492cace62f6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=17167fd8b5d38d7a273d66ef86a29492cace62f6", "patch": "@@ -1587,6 +1587,38 @@ typedef struct rs6000_args\n    before returning.  */\n \n #define FUNCTION_EPILOGUE(FILE, SIZE) output_epilog (FILE, SIZE)\n+\n+/* A C compound statement that outputs the assembler code for a thunk function,\n+   used to implement C++ virtual function calls with multiple inheritance.  The\n+   thunk acts as a wrapper around a virtual function, adjusting the implicit\n+   object parameter before handing control off to the real function.\n+\n+   First, emit code to add the integer DELTA to the location that contains the\n+   incoming first argument.  Assume that this argument contains a pointer, and\n+   is the one used to pass the `this' pointer in C++.  This is the incoming\n+   argument *before* the function prologue, e.g. `%o0' on a sparc.  The\n+   addition must preserve the values of all other incoming arguments.\n+\n+   After the addition, emit code to jump to FUNCTION, which is a\n+   `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does not touch\n+   the return address.  Hence returning from FUNCTION will return to whoever\n+   called the current `thunk'.\n+\n+   The effect must be as if FUNCTION had been called directly with the adjusted\n+   first argument.  This macro is responsible for emitting all of the code for\n+   a thunk function; `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' are not\n+   invoked.\n+\n+   The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been\n+   extracted from it.)  It might possibly be useful on some targets, but\n+   probably not.\n+\n+   If you do not define this macro, the target-independent code in the C++\n+   frontend will generate a less efficient heavyweight thunk that calls\n+   FUNCTION instead of jumping to it.  The generic approach does not support\n+   varargs.  */\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION) \\\n+  output_mi_thunk (FILE, THUNK_FNDECL, DELTA, FUNCTION)\n \f\n /* TRAMPOLINE_TEMPLATE deleted */\n \n@@ -3263,6 +3295,7 @@ extern int rs6000_makes_calls ();\n extern rs6000_stack_t *rs6000_stack_info ();\n extern void output_prolog ();\n extern void output_epilog ();\n+extern void output_mi_thunk ();\n extern void output_toc ();\n extern void output_ascii ();\n extern void rs6000_gen_section_name ();"}]}