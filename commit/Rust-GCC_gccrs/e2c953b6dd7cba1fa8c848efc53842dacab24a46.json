{"sha": "e2c953b6dd7cba1fa8c848efc53842dacab24a46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjOTUzYjZkZDdjYmExZmE4Yzg0OGVmYzUzODQyZGFjYWIyNGE0Ng==", "commit": {"author": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2000-08-08T18:50:15Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2000-08-08T18:50:15Z"}, "message": "rs6000.c (optimization_options): Decorate 'level' as ATTRIBUTE_UNUSED.\n\n\t* rs6000.c (optimization_options): Decorate 'level' as\n\tATTRIBUTE_UNUSED.\n\t(mask64_operand): Remove sign-extend thinko.\n\t(rldic_operand): New function.\n\t(load_multiple_operation): regno's are unsigned ints.\n\t(store_multiple_operation): Likewise.\n\t(lmw_operation): Likewise.\n\t(stmw_operation): Likewise.\n\t(includes_lshift_p): shift_mask is unsigned int.\n\t(includes_lshift64_p): New function.\n\t(addrs_ok_for_quad_peep): unsigned int reg1.\n\t(print_operand): Consistently add \"else\" after\n\toutput_operand_lossage().\n\t(print_operand, case 'b'): Fold in case 'W'.\n\t(print_operand, case 'W'): Print rldic MB value.\n\t(output_epilogue): Update Objective-C language string.\n\t(output_toc): unsigned HOST_WIDE_INT low, compare unsigned.\n\t* rs6000.h (PREDICATE_CODES): Add rldic_operand.\n\t* rs6000.md (ashldi3): Add rldic instruction.\n\t(iordi3, xordi3): Remove redundant \"else if CONST_DOUBLE\".\n\t(cmpsi_internal2, cmpdi_interal2): Use 'b' output template\n\tmodifier.\n\nFrom-SVN: r35570", "tree": {"sha": "1937d86ac684cb7feca06a06065f215d94c3b1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1937d86ac684cb7feca06a06065f215d94c3b1e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2c953b6dd7cba1fa8c848efc53842dacab24a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c953b6dd7cba1fa8c848efc53842dacab24a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c953b6dd7cba1fa8c848efc53842dacab24a46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c953b6dd7cba1fa8c848efc53842dacab24a46/comments", "author": null, "committer": null, "parents": [{"sha": "6dd1b06886deb44ccd82a27c173baa82cf7c702a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd1b06886deb44ccd82a27c173baa82cf7c702a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd1b06886deb44ccd82a27c173baa82cf7c702a"}], "stats": {"total": 344, "additions": 248, "deletions": 96}, "files": [{"sha": "0cb3dbadf2b6e8a8c10b747c0ea00b5de30f10f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2c953b6dd7cba1fa8c848efc53842dacab24a46", "patch": "@@ -1,3 +1,28 @@\n+2000-08-08  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* rs6000.c (optimization_options): Decorate 'level' as\n+\tATTRIBUTE_UNUSED. \n+\t(mask64_operand): Remove sign-extend thinko.\n+\t(rldic_operand): New function.\n+\t(load_multiple_operation): regno's are unsigned ints.\n+\t(store_multiple_operation): Likewise.\n+\t(lmw_operation): Likewise.\n+\t(stmw_operation): Likewise.\n+\t(includes_lshift_p): shift_mask is unsigned int.\n+\t(includes_lshift64_p): New function.\n+\t(addrs_ok_for_quad_peep): unsigned int reg1.\n+\t(print_operand): Consistently add \"else\" after\n+\toutput_operand_lossage().\n+\t(print_operand, case 'b'): Fold in case 'W'.\n+\t(print_operand, case 'W'): Print rldic MB value.\n+\t(output_epilogue): Update Objective-C language string.\n+\t(output_toc): unsigned HOST_WIDE_INT low, compare unsigned.\n+\t* rs6000.h (PREDICATE_CODES): Add rldic_operand.\n+\t* rs6000.md (ashldi3): Add rldic instruction.\n+\t(iordi3, xordi3): Remove redundant \"else if CONST_DOUBLE\".\n+\t(cmpsi_internal2, cmpdi_interal2): Use 'b' output template\n+\tmodifier.\n+\n 2000-08-08  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64-protos.h: Remove duplicates.  Update\n@@ -827,7 +852,7 @@ Wed Aug  2 15:59:34 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t(f_options): Added dce entry.\n \t* invoke.texi: Document -fdce.  Emphasize experimental status of\n \t-fssa.\n-\t* dce: New file.\n+\t* dce.c: New file.\n \n 2000-08-01  Zack Weinberg  <zack@wolery.cumb.org>\n "}, {"sha": "ed157db0ae42596eefbf7278b10c27dc5a5202bb", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e2c953b6dd7cba1fa8c848efc53842dacab24a46", "patch": "@@ -56,6 +56,7 @@ extern int non_logical_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int logical_operand PARAMS ((rtx, enum machine_mode));\n extern int mask_operand PARAMS ((rtx, enum machine_mode));\n extern int mask64_operand PARAMS ((rtx, enum machine_mode));\n+extern int rldic_operand PARAMS ((rtx, enum machine_mode));\n extern int and64_operand PARAMS ((rtx, enum machine_mode));\n extern int and_operand PARAMS ((rtx, enum machine_mode));\n extern int count_register_operand PARAMS ((rtx, enum machine_mode));\n@@ -78,6 +79,7 @@ extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n extern int boolean_or_operator PARAMS ((rtx, enum machine_mode));\n extern int includes_lshift_p PARAMS ((rtx, rtx));\n extern int includes_rshift_p PARAMS ((rtx, rtx));\n+extern int includes_lshift64_p PARAMS ((rtx, rtx));\n extern int registers_ok_for_quad_peep PARAMS ((rtx, rtx));\n extern int addrs_ok_for_quad_peep PARAMS ((rtx, rtx));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,"}, {"sha": "8dd4311b308060c8e8542f05f86aebce881e10a2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 185, "deletions": 57, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e2c953b6dd7cba1fa8c848efc53842dacab24a46", "patch": "@@ -398,7 +398,7 @@ rs6000_override_options (default_cpu)\n \n void\n optimization_options (level, size)\n-     int level;\n+     int level ATTRIBUTE_UNUSED;\n      int size ATTRIBUTE_UNUSED;\n {\n }\n@@ -1077,13 +1077,80 @@ mask64_operand (op, mode)\n \tif (((c >>= 1) & 1) != last_bit_value)\n \t  last_bit_value ^= 1, transitions++;\n \n+      return transitions <= 1;\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE\n+\t   && (mode == VOIDmode || mode == DImode))\n+    {\n+      HOST_WIDE_INT low = CONST_DOUBLE_LOW (op);\n+#if HOST_BITS_PER_WIDE_INT == 32\n+      HOST_WIDE_INT high = CONST_DOUBLE_HIGH (op);\n+#endif\n+      int i;\n+      int last_bit_value;\n+      int transitions = 0;\n+\n+      if ((low == 0\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t  && high == 0\n+#endif\n+\t   )\n+\t  || (low == ~0\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t      && high == ~0\n+#endif\n+\t      ))\n+\treturn 0;\n+\n+      last_bit_value = low & 1;\n+\n+      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\tif (((low >>= 1) & 1) != last_bit_value)\n+\t  last_bit_value ^= 1, transitions++;\n+\n #if HOST_BITS_PER_WIDE_INT == 32\n-      /* Consider CONST_INT sign-extended.  */\n-      transitions += (last_bit_value != 1);\n+      if ((high & 1) != last_bit_value)\n+\tlast_bit_value ^= 1, transitions++;\n+\n+      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\tif (((high >>= 1) & 1) != last_bit_value)\n+\t  last_bit_value ^= 1, transitions++;\n #endif\n \n       return transitions <= 1;\n     }\n+  else\n+    return 0;\n+}\n+\n+/* Return 1 if the operand is a constant that is a PowerPC64 mask.\n+   It is if there are no more than two 1->0 or 0->1 transitions.\n+   Reject all ones and all zeros, since these should have been optimized\n+   away and confuse the making of MB and ME.  */\n+\n+int\n+rldic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      HOST_WIDE_INT c = INTVAL (op);\n+      int i;\n+      int last_bit_value;\n+      int transitions = 0;\n+\n+      if (c == 0 || c == ~0)\n+\treturn 0;\n+\n+      last_bit_value = c & 1;\n+\n+      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n+\tif (((c >>= 1) & 1) != last_bit_value)\n+\t  last_bit_value ^= 1, transitions++;\n+\n+      return transitions <= 2;\n+    }\n   else if (GET_CODE (op) == CONST_DOUBLE\n \t   && (mode == VOIDmode || mode == DImode))\n     {\n@@ -1122,7 +1189,7 @@ mask64_operand (op, mode)\n \t  last_bit_value ^= 1, transitions++;\n #endif\n \n-      return transitions <= 1;\n+      return transitions <= 2;\n     }\n   else\n     return 0;\n@@ -2846,7 +2913,7 @@ load_multiple_operation (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int count = XVECLEN (op, 0);\n-  int dest_regno;\n+  unsigned int dest_regno;\n   rtx src_addr;\n   int i;\n \n@@ -2889,7 +2956,7 @@ store_multiple_operation (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int count = XVECLEN (op, 0) - 1;\n-  int src_regno;\n+  unsigned int src_regno;\n   rtx dest_addr;\n   int i;\n \n@@ -2984,9 +3051,9 @@ lmw_operation (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int count = XVECLEN (op, 0);\n-  int dest_regno;\n+  unsigned int dest_regno;\n   rtx src_addr;\n-  int base_regno;\n+  unsigned int base_regno;\n   HOST_WIDE_INT offset;\n   int i;\n \n@@ -3001,7 +3068,7 @@ lmw_operation (op, mode)\n   src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n \n   if (dest_regno > 31\n-      || count != 32 - dest_regno)\n+      || count != 32 - (int) dest_regno)\n     return 0;\n \n   if (LEGITIMATE_INDIRECT_ADDRESS_P (src_addr))\n@@ -3062,9 +3129,9 @@ stmw_operation (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int count = XVECLEN (op, 0);\n-  int src_regno;\n+  unsigned int src_regno;\n   rtx dest_addr;\n-  int base_regno;\n+  unsigned int base_regno;\n   HOST_WIDE_INT offset;\n   int i;\n \n@@ -3079,7 +3146,7 @@ stmw_operation (op, mode)\n   dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n \n   if (src_regno > 31\n-      || count != 32 - src_regno)\n+      || count != 32 - (int) src_regno)\n     return 0;\n \n   if (LEGITIMATE_INDIRECT_ADDRESS_P (dest_addr))\n@@ -3238,7 +3305,9 @@ includes_lshift_p (shiftop, andop)\n      register rtx shiftop;\n      register rtx andop;\n {\n-  int shift_mask = (~0 << INTVAL (shiftop));\n+  unsigned HOST_WIDE_INT shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n+\n+  shift_mask <<= INTVAL (shiftop);\n \n   return (INTVAL (andop) & ~shift_mask) == 0;\n }\n@@ -3254,7 +3323,39 @@ includes_rshift_p (shiftop, andop)\n \n   shift_mask >>= INTVAL (shiftop);\n \n-  return (INTVAL (andop) & ~ shift_mask) == 0;\n+  return (INTVAL (andop) & ~shift_mask) == 0;\n+}\n+\n+/* Return 1 if ANDOP is a mask that has no bits on that are not in the\n+   mask required to convert the result of a rotate insn into a shift\n+   left insn of SHIFTOP bits.  */\n+\n+int\n+includes_lshift64_p (shiftop, andop)\n+     register rtx shiftop;\n+     register rtx andop;\n+{\n+#if HOST_BITS_PER_WIDE_INT == 64\n+  unsigned HOST_WIDE_INT shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n+\n+  shift_mask <<= INTVAL (shiftop);\n+\n+  return (INTVAL (andop) & ~shift_mask) == 0;\n+#else\n+  unsigned HOST_WIDE_INT shift_mask_low = ~(unsigned HOST_WIDE_INT) 0;\n+  unsigned HOST_WIDE_INT shift_mask_high = ~(unsigned HOST_WIDE_INT) 0;\n+\n+  shift_mask_low <<= INTVAL (shiftop);\n+\n+  if (INTVAL (shiftop) > 32)\n+    shift_mask_high <<= (INTVAL (shiftop) - 32);\n+\n+  if (GET_CODE (andop) == CONST_INT)\n+    return (INTVAL (andop) & ~shift_mask_low) == 0;\n+  else\n+    return ((CONST_DOUBLE_HIGH (andop) & ~shift_mask_high) == 0\n+\t    && (CONST_DOUBLE_LOW (andop) & ~shift_mask_low) == 0);\n+#endif\n }\n \n /* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates\n@@ -3282,7 +3383,7 @@ addrs_ok_for_quad_peep (addr1, addr2)\n      register rtx addr1;\n      register rtx addr2;\n {\n-  int reg1;\n+  unsigned int reg1;\n   int offset1;\n \n   /* Extract an offset (if used) from the first addr.  */\n@@ -3579,11 +3680,12 @@ print_operand (file, x, code)\n       return;\n \n     case 'b':\n-      /* Low-order 16 bits of constant, unsigned.  */\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%b value\");\n-\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 0xffff);\n+      /* If constant, low-order 16 bits of constant, unsigned.\n+\t Otherwise, write normally.  */\n+      if (INT_P (x))\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 0xffff);\n+      else\n+\tprint_operand (file, x, 0);\n       return;\n \n     case 'B':\n@@ -3687,7 +3789,7 @@ print_operand (file, x, code)\n       else\n \tputc ('m', file);\n       return;\n-\t\n+\n     case 'h':\n       /* If constant, output low-order five bits.  Otherwise,\n \t write normally. */\n@@ -3737,8 +3839,8 @@ print_operand (file, x, code)\n \t constant.  */\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%k value\");\n-\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, ~ INT_LOWPART (x));\n+      else\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, ~ INT_LOWPART (x));\n       return;\n \n     case 'K':\n@@ -3864,25 +3966,25 @@ print_operand (file, x, code)\n       /* Write the number of elements in the vector times 4.  */\n       if (GET_CODE (x) != PARALLEL)\n \toutput_operand_lossage (\"invalid %%N value\");\n-\n-      fprintf (file, \"%d\", XVECLEN (x, 0) * 4);\n+      else\n+\tfprintf (file, \"%d\", XVECLEN (x, 0) * 4);\n       return;\n \n     case 'O':\n       /* Similar, but subtract 1 first.  */\n       if (GET_CODE (x) != PARALLEL)\n \toutput_operand_lossage (\"invalid %%O value\");\n-\n-      fprintf (file, \"%d\", (XVECLEN (x, 0) - 1) * 4);\n+      else\n+\tfprintf (file, \"%d\", (XVECLEN (x, 0) - 1) * 4);\n       return;\n \n     case 'p':\n       /* X is a CONST_INT that is a power of two.  Output the logarithm.  */\n       if (! INT_P (x)\n \t  || (i = exact_log2 (INT_LOWPART (x))) < 0)\n \toutput_operand_lossage (\"invalid %%p value\");\n-\n-      fprintf (file, \"%d\", i);\n+      else\n+\tfprintf (file, \"%d\", i);\n       return;\n \n     case 'P':\n@@ -3891,8 +3993,8 @@ print_operand (file, x, code)\n       if (GET_CODE (x) != MEM || GET_CODE (XEXP (x, 0)) != REG\n \t  || REGNO (XEXP (x, 0)) >= 32)\n \toutput_operand_lossage (\"invalid %%P value\");\n-\n-      fprintf (file, \"%d\", REGNO (XEXP (x, 0)));\n+      else\n+\tfprintf (file, \"%d\", REGNO (XEXP (x, 0)));\n       return;\n \n     case 'q':\n@@ -3943,8 +4045,8 @@ print_operand (file, x, code)\n       /* Low 5 bits of 32 - value */\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%s value\");\n-\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, (32 - INT_LOWPART (x)) & 31);\n+      else\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, (32 - INT_LOWPART (x)) & 31);\n       return;\n \n     case 'S':\n@@ -4016,8 +4118,7 @@ print_operand (file, x, code)\n       if (GET_CODE (x) != REG || (REGNO (x) != LINK_REGISTER_REGNUM\n \t\t\t\t  && REGNO (x) != COUNT_REGISTER_REGNUM))\n \toutput_operand_lossage (\"invalid %%T value\");\n-\n-      if (REGNO (x) == LINK_REGISTER_REGNUM)\n+      else if (REGNO (x) == LINK_REGISTER_REGNUM)\n \tfputs (TARGET_NEW_MNEMONICS ? \"lr\" : \"r\", file);\n       else\n \tfputs (\"ctr\", file);\n@@ -4027,26 +4128,26 @@ print_operand (file, x, code)\n       /* High-order 16 bits of constant for use in unsigned operand.  */\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%u value\");\n-\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, \n-\t       (INT_LOWPART (x) >> 16) & 0xffff);\n+      else\n+\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, \n+\t\t (INT_LOWPART (x) >> 16) & 0xffff);\n       return;\n \n     case 'v':\n       /* High-order 16 bits of constant for use in signed operand.  */\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%v value\");\n+      else\n+\t{\n+\t  int value = (INT_LOWPART (x) >> 16) & 0xffff;\n \n-      {\n-\tint value = (INT_LOWPART (x) >> 16) & 0xffff;\n-\n-\t/* Solaris assembler doesn't like lis 0,0x8000 */\n-\tif (DEFAULT_ABI == ABI_SOLARIS && (value & 0x8000) != 0)\n-\t  fprintf (file, \"%d\", value | (~0 << 16));\n-\telse\n-\t  fprintf (file, \"0x%x\", value);\n-\treturn;\n-      }\n+\t  /* Solaris assembler doesn't like lis 0,0x8000 */\n+\t  if (DEFAULT_ABI == ABI_SOLARIS && (value & 0x8000) != 0)\n+\t    fprintf (file, \"%d\", value | (~0 << 16));\n+\t  else\n+\t    fprintf (file, \"0x%x\", value);\n+\t  return;\n+\t}\n \n     case 'U':\n       /* Print `u' if this has an auto-increment or auto-decrement.  */\n@@ -4106,12 +4207,39 @@ print_operand (file, x, code)\n       return;\n \n     case 'W':\n-      /* If constant, low-order 16 bits of constant, unsigned.\n-\t Otherwise, write normally.  */\n-      if (INT_P (x))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 0xffff);\n+      /* MB value for a PowerPC64 rldic operand.  */\n+      if (! rldic_operand (x, VOIDmode))\n+\toutput_operand_lossage (\"invalid %%W value\");\n+\n+      val = (GET_CODE (x) == CONST_INT\n+\t     ? INTVAL (x) : CONST_DOUBLE_HIGH (x));\n+\n+      if (val < 0)\n+\ti = -1;\n       else\n-\tprint_operand (file, x, 0);\n+\tfor (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)\n+\t  if ((val <<= 1) < 0)\n+\t    break;\n+\n+#if HOST_BITS_PER_WIDE_INT == 32\n+      if (GET_CODE (x) == CONST_INT && i >= 0)\n+\ti += 32;  /* zero-extend high-part was all 0's */\n+      else if (GET_CODE (x) == CONST_DOUBLE && i == 32)\n+\t{\n+\t  val = CONST_DOUBLE_LOW (x);\n+\n+\t  if (val == 0)\n+\t    abort();\n+\t  else if (val < 0)\n+\t    --i;\n+\t  else\n+\t    for ( ; i < 64; i++)\n+\t      if ((val <<= 1) < 0)\n+\t\tbreak;\n+\t}\n+#endif\n+\n+      fprintf (file, \"%d\", i + 1);\n       return;\n \n     case 'X':\n@@ -5944,7 +6072,7 @@ output_epilog (file, size)\n          although IBM appears to be using 13.  There is no official value\n \t for Chill, so we've choosen 44 pseudo-randomly.  */\n       if (! strcmp (language_string, \"GNU C\")\n-\t  || ! strcmp (language_string, \"GNU Obj-C\"))\n+\t  || ! strcmp (language_string, \"GNU Objective-C\"))\n \ti = 0;\n       else if (! strcmp (language_string, \"GNU F77\"))\n \ti = 1;\n@@ -6573,7 +6701,7 @@ output_toc (file, x, labelno, mode)\n   else if (GET_MODE (x) == VOIDmode\n \t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n     {\n-      HOST_WIDE_INT low;\n+      unsigned HOST_WIDE_INT low;\n       HOST_WIDE_INT high;\n \n       if (GET_CODE (x) == CONST_DOUBLE)\n@@ -6585,11 +6713,11 @@ output_toc (file, x, labelno, mode)\n #if HOST_BITS_PER_WIDE_INT == 32\n \t{\n \t  low = INTVAL (x);\n-\t  high = (low < 0) ? ~0 : 0;\n+\t  high = (low & 0x80000000u) ? ~0 : 0;\n \t}\n #else\n \t{\n-          low = INTVAL (x) & 0xffffffff;\n+          low = INTVAL (x) & 0xffffffffu;\n           high = (HOST_WIDE_INT) INTVAL (x) >> 32;\n \t}\n #endif"}, {"sha": "c4feb598414dc7988250f7f1dda456ab0a5c7bcf", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e2c953b6dd7cba1fa8c848efc53842dacab24a46", "patch": "@@ -2757,6 +2757,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"non_logical_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\\\n+  {\"rldic_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n   {\"count_register_operand\", {REG}},\t\t\t\t\\\n   {\"xer_operand\", {REG}},\t\t\t\t\t\\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\"}, {"sha": "5005f737762721dbdee268b01c01b428a052c42c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c953b6dd7cba1fa8c848efc53842dacab24a46/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e2c953b6dd7cba1fa8c848efc53842dacab24a46", "patch": "@@ -6664,15 +6664,15 @@\n     FAIL;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ashldi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\")))]\n   \"TARGET_POWERPC64\"\n   \"sld%I2 %0,%1,%H2\"\n   [(set_attr \"length\" \"8\")])\n   \n-(define_insn \"\"\n+(define_insn \"*ashldi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n@@ -6699,7 +6699,7 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*ashldi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n@@ -6728,27 +6728,25 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*ashldi3_internal4\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:DI 3 \"mask64_operand\" \"S\")))]\n-  \"((GET_CODE (operands[3]) == CONST_INT\n-     ? INTVAL (operands[3]) : CONST_DOUBLE_LOW (operands[3])) & 1) == 1\"\n-  \"rldic %0,%1,%H2,%S3\")\n+\t\t(match_operand:DI 3 \"rldic_operand\" \"n\")))]\n+  \"includes_lshift64_p (operands[2], operands[3])\"\n+  \"rldic %0,%1,%H2,%W3\")\n \n-(define_insn \"\"\n+(define_insn \"ashldi3_internal5\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"S,S\"))\n+\t\t (match_operand:DI 3 \"rldic_operand\" \"n,n\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"=r,r\"))]\n-  \"((GET_CODE (operands[3]) == CONST_INT\n-     ? INTVAL (operands[3]) : CONST_DOUBLE_LOW (operands[3])) & 1) == 1\"\n+  \"includes_lshift64_p (operands[2], operands[3])\"\n   \"@\n-   rldic. %0,%1,%H2,%S3\n+   rldic. %4,%1,%H2,%W3\n    #\"\n   [(set_attr \"type\" \"delayed_compare\")\n    (set_attr \"length\" \"4,8\")])\n@@ -6758,33 +6756,30 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"rldic_operand\" \"\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"\"))]\n-  \"((GET_CODE (operands[3]) == CONST_INT\n-     ? INTVAL (operands[3]) : CONST_DOUBLE_LOW (operands[3])) & 1) == 1\n-   && reload_completed\"\n+  \"includes_lshift64_p (operands[2], operands[3]) && reload_completed\"\n   [(set (match_dup 4)\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n-\t\t (match_dup 3)))\n+\t\t(match_dup 3)))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 4)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*ashldi3_internal6\"\n   [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"S,S\"))\n+\t\t    (match_operand:DI 3 \"rldic_operand\" \"n,n\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"((GET_CODE (operands[3]) == CONST_INT\n-     ? INTVAL (operands[3]) : CONST_DOUBLE_LOW (operands[3])) & 1) == 1\"\n+  \"includes_lshift64_p (operands[2], operands[3])\"\n   \"@\n-   rldic. %0,%1,%H2,%S3\n+   rldic. %0,%1,%H2,%W3\n    #\"\n   [(set_attr \"type\" \"delayed_compare\")\n    (set_attr \"length\" \"4,8\")])\n@@ -6794,15 +6789,14 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"rldic_operand\" \"\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"((GET_CODE (operands[3]) == CONST_INT\n-     ? INTVAL (operands[3]) : CONST_DOUBLE_LOW (operands[3])) & 1) == 1\n-   && reload_completed\"\n+  \"includes_lshift64_p (operands[2], operands[3]) && reload_completed\"\n   [(set (match_dup 0)\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))\n+\t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n+\t\t(match_dup 3)))\n    (set (match_dup 4)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n@@ -6826,14 +6820,14 @@\n     FAIL;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\")))]\n   \"TARGET_POWERPC64\"\n   \"srd%I2 %0,%1,%H2\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrdi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n@@ -6860,7 +6854,7 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*lshrdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n@@ -6907,14 +6901,14 @@\n     FAIL;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\")))]\n   \"TARGET_POWERPC64\"\n   \"srad%I2 %0,%1,%H2\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrdi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n@@ -6941,7 +6935,7 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*ashrdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n@@ -7076,14 +7070,15 @@\n \t  emit_insn (gen_iordi3 (tmp, operands[1],\n \t\t\t\t GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n \t}\n-      else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+      else\n         {\n \t  value = CONST_DOUBLE_LOW (operands[2]);\n \t  emit_insn (gen_iordi3 (tmp, operands[1],\n \t\t\t\t immed_double_const (value\n \t\t\t\t\t\t     & (~ (HOST_WIDE_INT) 0xffff),\n \t\t\t\t\t\t     0, DImode)));\n \t}\n+\n       emit_insn (gen_iordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n@@ -7108,14 +7103,15 @@\n \t  emit_insn (gen_xordi3 (tmp, operands[1],\n \t\t\t\t GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n \t}\n-      else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+      else\n         {\n \t  value = CONST_DOUBLE_LOW (operands[2]);\n \t  emit_insn (gen_xordi3 (tmp, operands[1],\n \t\t\t\t immed_double_const (value\n \t\t\t\t\t\t     & (~ (HOST_WIDE_INT) 0xffff),\n \t\t\t\t\t\t     0, DImode)));\n \t}\n+\n       emit_insn (gen_xordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n@@ -10424,15 +10420,15 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \t(compare:CCUNS (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t       (match_operand:SI 2 \"reg_or_u_short_operand\" \"rK\")))]\n   \"\"\n-  \"{cmpl%I2|cmplw%I2} %0,%1,%W2\"\n+  \"{cmpl%I2|cmplw%I2} %0,%1,%b2\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmpdi_internal2\"\n   [(set (match_operand:CCUNS 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CCUNS (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t       (match_operand:DI 2 \"reg_or_u_short_operand\" \"rK\")))]\n   \"\"\n-  \"cmpld%I2 %0,%1,%W2\"\n+  \"cmpld%I2 %0,%1,%b2\"\n   [(set_attr \"type\" \"compare\")])\n \n ;; The following two insns don't exist as single insns, but if we provide"}]}