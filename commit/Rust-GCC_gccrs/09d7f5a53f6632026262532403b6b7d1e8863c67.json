{"sha": "09d7f5a53f6632026262532403b6b7d1e8863c67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlkN2Y1YTUzZjY2MzIwMjYyNjI1MzI0MDNiNmI3ZDFlODg2M2M2Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:48:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:48:43Z"}, "message": "(basic_induction_var): Add new parameter P.\n\nCheck for bivs that are set over multiple insns and also allow a SIGN_EXTEND\nto be used; remove check for MINUS since we don't make MINUS with a constant\n2nd operand any more.\n\nFrom-SVN: r2178", "tree": {"sha": "c41fb4e96ccc97af45ab8ebe04be3730de45b5f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c41fb4e96ccc97af45ab8ebe04be3730de45b5f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09d7f5a53f6632026262532403b6b7d1e8863c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d7f5a53f6632026262532403b6b7d1e8863c67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09d7f5a53f6632026262532403b6b7d1e8863c67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d7f5a53f6632026262532403b6b7d1e8863c67/comments", "author": null, "committer": null, "parents": [{"sha": "4b7cb39e6230d7e1ae25d013c64714d7fe62f46d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7cb39e6230d7e1ae25d013c64714d7fe62f46d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7cb39e6230d7e1ae25d013c64714d7fe62f46d"}], "stats": {"total": 100, "additions": 81, "deletions": 19}, "files": [{"sha": "e4b47db3cdf6a12edec5776b78ca8a6b234c4539", "filename": "gcc/loop.c", "status": "modified", "additions": 81, "deletions": 19, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d7f5a53f6632026262532403b6b7d1e8863c67/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d7f5a53f6632026262532403b6b7d1e8863c67/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=09d7f5a53f6632026262532403b6b7d1e8863c67", "patch": "@@ -3151,7 +3151,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n \t      && reg_iv_type[REGNO (dest_reg)] != NOT_BASIC_INDUCT)\n \t    {\n-\t      if (basic_induction_var (SET_SRC (set), dest_reg,\n+\t      if (basic_induction_var (SET_SRC (set), dest_reg, p,\n \t\t\t\t      &inc_val, &mult_val))\n \t\t{\n \t\t  /* It is a possible basic induction variable.\n@@ -4637,79 +4637,141 @@ update_giv_derive (p)\n }\n \f\n /* Check whether an insn is an increment legitimate for a basic induction var.\n-   X is the source of the insn.\n+   X is the source of insn P.\n    DEST_REG is the putative biv, also the destination of the insn.\n    We accept patterns of these forms:\n-     REG = REG + INVARIANT\n+     REG = REG + INVARIANT (includes REG = REG - CONSTANT)\n      REG = INVARIANT + REG\n-     REG = REG - CONSTANT\n \n    If X is suitable, we return 1, set *MULT_VAL to CONST1_RTX,\n    and store the additive term into *INC_VAL.\n \n    If X is an assignment of an invariant into DEST_REG, we set\n    *MULT_VAL to CONST0_RTX, and store the invariant into *INC_VAL.\n \n-   Otherwise we return 0.  */\n+   We also want to detect a BIV when it corresponds to a variable\n+   whose mode was promoted via PROMOTED_MODE.  In that case, an increment\n+   of the variable may be a PLUS that adds a SUBREG of that variable to\n+   an invariant and then sign- or zero-extends the result of the PLUS\n+   into the variable.\n+\n+   Most GIVs in such cases will be in the promoted mode, since that is the\n+   probably the natural computation mode (and almost certainly the mode\n+   used for addresses) on the machine.  So we view the pseudo-reg containing\n+   the variable as the BIV, as if it were simply incremented.\n+\n+   Note that treating the entire pseudo as a BIV will result in making\n+   simple increments to any GIVs based on it.  However, if the variable\n+   overflows in its declared mode but not its promoted mode, the result will\n+   be incorrect.  This is acceptable if the variable is signed, since \n+   overflows in such cases are undefined, but not if it is unsigned, since\n+   those overflows are defined.  So we only check for SIGN_EXTEND and\n+   not ZERO_EXTEND.\n+\n+   If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (x, dest_reg, inc_val, mult_val)\n+basic_induction_var (x, dest_reg, p, inc_val, mult_val)\n      register rtx x;\n+     rtx p;\n      rtx dest_reg;\n      rtx *inc_val;\n      rtx *mult_val;\n {\n   register enum rtx_code code;\n   rtx arg;\n+  rtx insn, set = 0;\n \n   code = GET_CODE (x);\n   switch (code)\n     {\n     case PLUS:\n-      if (XEXP (x, 0) == dest_reg)\n+      if (XEXP (x, 0) == dest_reg\n+\t  || (GET_CODE (XEXP (x, 0)) == SUBREG\n+\t      && SUBREG_PROMOTED_VAR_P (XEXP (x, 0))\n+\t      && SUBREG_REG (XEXP (x, 0)) == dest_reg))\n  \targ = XEXP (x, 1);\n-      else if (XEXP (x, 1) == dest_reg)\n+      else if (XEXP (x, 1) == dest_reg\n+\t       || (GET_CODE (XEXP (x, 1)) == SUBREG\n+\t\t   && SUBREG_PROMOTED_VAR_P (XEXP (x, 1))))\n \targ = XEXP (x, 0);\n       else\n  \treturn 0;\n \n       if (invariant_p (arg) != 1)\n \treturn 0;\n \n-      *inc_val = arg;\n+      *inc_val = convert_to_mode (GET_MODE (dest_reg), arg, 0);;\n       *mult_val = const1_rtx;\n       return 1;\n \n-    case MINUS:\n-      if (XEXP (x, 0) == dest_reg\n- \t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n- \t*inc_val = GEN_INT (- INTVAL (XEXP (x, 1)));\n-      else\n- \treturn 0;\n+    case SUBREG:\n+      /* If this is a SUBREG for a promoted variable, check the inner\n+\t value.  */\n+      if (SUBREG_PROMOTED_VAR_P (x))\n+\t  return basic_induction_var (SUBREG_REG (x), dest_reg, p,\n+\t\t\t\t    inc_val, mult_val);\n \n-      *mult_val = const1_rtx;\n-      return 1;\n+    case REG:\n+      /* If this register is assigned in the previous insn, look at its\n+\t source, but don't go outside the loop or past a label.  */\n+\n+      for (insn = PREV_INSN (p);\n+\t   (insn && GET_CODE (insn) == NOTE\n+\t    && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n+\t   insn = PREV_INSN (insn))\n+\t;\n+\n+      if (insn)\n+\tset = single_set (insn);\n+\n+      if (set != 0 && SET_DEST (set) == x)\n+\treturn basic_induction_var (SET_SRC (set), dest_reg, insn,\n+\t\t\t\t    inc_val, mult_val);\n+      /* ... fall through ... */\n \n       /* Can accept constant setting of biv only when inside inner most loop.\n   \t Otherwise, a biv of an inner loop may be incorrectly recognized\n \t as a biv of the outer loop,\n \t causing code to be moved INTO the inner loop.  */\n     case MEM:\n-    case REG:\n       if (invariant_p (x) != 1)\n \treturn 0;\n     case CONST_INT:\n     case SYMBOL_REF:\n     case CONST:\n       if (loops_enclosed == 1)\n  \t{\n-\t  *inc_val = x;\n+\t  *inc_val = convert_to_mode (GET_MODE (dest_reg), x, 0);;\n  \t  *mult_val = const0_rtx;\n  \t  return 1;\n  \t}\n       else\n  \treturn 0;\n \n+    case SIGN_EXTEND:\n+      return basic_induction_var (XEXP (x, 0), dest_reg, p,\n+\t\t\t\t  inc_val, mult_val);\n+    case ASHIFTRT:\n+      /* Similar, since this can be a sign extension.  */\n+      for (insn = PREV_INSN (p);\n+\t   (insn && GET_CODE (insn) == NOTE\n+\t    && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n+\t   insn = PREV_INSN (insn))\n+\t;\n+\n+      if (insn)\n+\tset = single_set (insn);\n+\n+      if (set && SET_DEST (set) == XEXP (x, 0)\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) >= 0\n+\t  && GET_CODE (SET_SRC (set)) == ASHIFT\n+\t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1))\n+\treturn basic_induction_var (XEXP (SET_SRC (set), 0), dest_reg, insn,\n+\t\t\t\t    inc_val, mult_val);\n+      return 0;\n+\n     default:\n       return 0;\n     }"}]}