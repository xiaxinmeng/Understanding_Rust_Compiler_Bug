{"sha": "c42006e91e021ec222fd1a24d30eff38554f1d4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQyMDA2ZTkxZTAyMWVjMjIyZmQxYTI0ZDMwZWZmMzg1NTRmMWQ0Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-03-01T16:12:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-09T08:09:04Z"}, "message": "[Ada] Expand more others aggregates statically\n\n2020-06-09  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* exp_aggr.adb (Max_Aggregate_Size): New function to factorize\n\tcode.\n\t(Convert_To_Positional, Aggr_Size_OK): Use Max_Aggregate_Size.", "tree": {"sha": "58a1de59fb1e88479eafd1c3da50843e8f824fca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a1de59fb1e88479eafd1c3da50843e8f824fca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c42006e91e021ec222fd1a24d30eff38554f1d4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42006e91e021ec222fd1a24d30eff38554f1d4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42006e91e021ec222fd1a24d30eff38554f1d4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42006e91e021ec222fd1a24d30eff38554f1d4c/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4228c32ab0b50e10e74ff53159894708471bcdbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4228c32ab0b50e10e74ff53159894708471bcdbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4228c32ab0b50e10e74ff53159894708471bcdbc"}], "stats": {"total": 115, "additions": 57, "deletions": 58}, "files": [{"sha": "dd69297037d71813fdebcd8f3013f15a6028f29f", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42006e91e021ec222fd1a24d30eff38554f1d4c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42006e91e021ec222fd1a24d30eff38554f1d4c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=c42006e91e021ec222fd1a24d30eff38554f1d4c", "patch": "@@ -289,19 +289,12 @@ package body Exp_Aggr is\n    --  construct the allocated object on the heap.\n \n    procedure Convert_To_Positional\n-     (N                    : Node_Id;\n-      Max_Others_Replicate : Nat     := 32;\n-      Handle_Bit_Packed    : Boolean := False);\n+     (N                 : Node_Id;\n+      Handle_Bit_Packed : Boolean := False);\n    --  If possible, convert named notation to positional notation. This\n    --  conversion is possible only in some static cases. If the conversion is\n    --  possible, then N is rewritten with the analyzed converted aggregate.\n-   --  The parameter Max_Others_Replicate controls the maximum number of\n-   --  values corresponding to an others choice that will be converted to\n-   --  positional notation (the default of 32 is the normal limit, and reflects\n-   --  the fact that normally the loop is better than a lot of separate\n-   --  assignments). Note that this limit gets overridden in any case if\n-   --  either of the restrictions No_Elaboration_Code or No_Implicit_Loops is\n-   --  set. The parameter Handle_Bit_Packed is usually set False (since we do\n+   --  The parameter Handle_Bit_Packed is usually set False (since we do\n    --  not expect the back end to handle bit packed arrays, so the normal case\n    --  of conversion is pointless), but in the special case of a call from\n    --  Packed_Array_Aggregate_Handled, we set this parameter to True, since\n@@ -320,6 +313,12 @@ package body Exp_Aggr is\n    --  an array that is suitable for this optimization: it returns True if Typ\n    --  is a two dimensional bit packed array with component size 1, 2, or 4.\n \n+   function Max_Aggregate_Size\n+     (Typ          : Entity_Id;\n+      Default_Size : Nat := 5000) return Nat;\n+   --  Return the max size for a static aggregate for the given Typ.\n+   --  Return Default_Size if no other special criteria triggers.\n+\n    function Packed_Array_Aggregate_Handled (N : Node_Id) return Boolean;\n    --  Given an array aggregate, this function handles the case of a packed\n    --  array aggregate with all constant values, where the aggregate can be\n@@ -429,43 +428,15 @@ package body Exp_Aggr is\n    --  Start of processing for Aggr_Size_OK\n \n    begin\n-      --  The normal aggregate limit is 500000, but we increase this limit to\n-      --  2**24 (about 16 million) if Restrictions (No_Elaboration_Code) or\n-      --  Restrictions (No_Implicit_Loops) is specified, since in either case\n-      --  we are at risk of declaring the program illegal because of this\n-      --  limit. We also increase the limit when Static_Elaboration_Desired,\n-      --  given that this means that objects are intended to be placed in data\n-      --  memory.\n-\n-      --  We also increase the limit if the aggregate is for a packed two-\n-      --  dimensional array, because if components are static it is much more\n-      --  efficient to construct a one-dimensional equivalent array with static\n-      --  components.\n-\n-      --  Conversely, we decrease the maximum size if none of the above\n-      --  requirements apply, and if the aggregate has a single component\n+      --  We bump the maximum size unless the aggregate has a single component\n       --  association, which will be more efficient if implemented with a loop.\n \n-      --  Finally, we use a small limit in CodePeer mode where we favor loops\n-      --  instead of thousands of single assignments (from large aggregates).\n-\n-      Max_Aggr_Size := 500000;\n-\n-      if CodePeer_Mode then\n-         Max_Aggr_Size := 100;\n-\n-      elsif Restriction_Active (No_Elaboration_Code)\n-        or else Restriction_Active (No_Implicit_Loops)\n-        or else Is_Two_Dim_Packed_Array (Typ)\n-        or else (Ekind (Current_Scope) = E_Package\n-                   and then Static_Elaboration_Desired (Current_Scope))\n-      then\n-         Max_Aggr_Size := 2 ** 24;\n-\n-      elsif No (Expressions (N))\n+      if No (Expressions (N))\n         and then No (Next (First (Component_Associations (N))))\n       then\n-         Max_Aggr_Size := 5000;\n+         Max_Aggr_Size := Max_Aggregate_Size (Typ);\n+      else\n+         Max_Aggr_Size := Max_Aggregate_Size (Typ, 500_000);\n       end if;\n \n       Size := UI_From_Int (Component_Count (Component_Type (Typ)));\n@@ -4561,11 +4532,11 @@ package body Exp_Aggr is\n    ---------------------------\n \n    procedure Convert_To_Positional\n-     (N                    : Node_Id;\n-      Max_Others_Replicate : Nat     := 32;\n-      Handle_Bit_Packed    : Boolean := False)\n+     (N                 : Node_Id;\n+      Handle_Bit_Packed : Boolean := False)\n    is\n-      Typ : constant Entity_Id := Etype (N);\n+      Typ                  : constant Entity_Id := Etype (N);\n+      Max_Others_Replicate : constant Nat := Max_Aggregate_Size (Typ);\n \n       Static_Components : Boolean := True;\n \n@@ -6179,13 +6150,7 @@ package body Exp_Aggr is\n \n       --  At this point we try to convert to positional form\n \n-      if Ekind (Current_Scope) = E_Package\n-        and then Static_Elaboration_Desired (Current_Scope)\n-      then\n-         Convert_To_Positional (N, Max_Others_Replicate => 100);\n-      else\n-         Convert_To_Positional (N);\n-      end if;\n+      Convert_To_Positional (N);\n \n       --  if the result is no longer an aggregate (e.g. it may be a string\n       --  literal, or a temporary which has the needed value), then we are\n@@ -7895,6 +7860,42 @@ package body Exp_Aggr is\n       return Make_Assignment_Statement (Sloc, Name, Expression);\n    end Make_OK_Assignment_Statement;\n \n+   ------------------------\n+   -- Max_Aggregate_Size --\n+   ------------------------\n+\n+   function Max_Aggregate_Size\n+     (Typ          : Entity_Id;\n+      Default_Size : Nat := 5000) return Nat is\n+   begin\n+      --  We use a small limit in CodePeer mode where we favor loops\n+      --  instead of thousands of single assignments (from large aggregates).\n+\n+      --  We also increase the limit to 2**24 (about 16 million) if\n+      --  Restrictions (No_Elaboration_Code) or Restrictions\n+      --  (No_Implicit_Loops) is specified, since in either case we are at risk\n+      --  of declaring the program illegal because of this limit. We also\n+      --  increase the limit when Static_Elaboration_Desired, given that this\n+      --  means that objects are intended to be placed in data memory.\n+\n+      --  Same if the aggregate is for a packed two-dimensional array, because\n+      --  if components are static it is much more efficient to construct a\n+      --  one-dimensional equivalent array with static components.\n+\n+      if CodePeer_Mode then\n+         return 100;\n+      elsif Restriction_Active (No_Elaboration_Code)\n+        or else Restriction_Active (No_Implicit_Loops)\n+        or else Is_Two_Dim_Packed_Array (Typ)\n+        or else (Ekind (Current_Scope) = E_Package\n+                   and then Static_Elaboration_Desired (Current_Scope))\n+      then\n+         return 2 ** 24;\n+      else\n+         return Default_Size;\n+      end if;\n+   end Max_Aggregate_Size;\n+\n    -----------------------\n    -- Number_Of_Choices --\n    -----------------------\n@@ -8067,8 +8068,7 @@ package body Exp_Aggr is\n          --  have failed to create a packed value for it.\n \n          if Present (Component_Associations (N)) then\n-            Convert_To_Positional\n-              (N, Max_Others_Replicate => 64, Handle_Bit_Packed => True);\n+            Convert_To_Positional (N, Handle_Bit_Packed => True);\n             return Nkind (N) /= N_Aggregate;\n          end if;\n \n@@ -8763,8 +8763,7 @@ package body Exp_Aggr is\n          return False;\n       end if;\n \n-      Convert_To_Positional\n-        (N, Max_Others_Replicate => 64, Handle_Bit_Packed => True);\n+      Convert_To_Positional (N, Handle_Bit_Packed => True);\n \n       --  Verify that all components are static\n "}]}