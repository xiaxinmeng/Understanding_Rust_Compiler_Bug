{"sha": "c31a6508eedf17dc50388f1694bc131bd965004f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMxYTY1MDhlZWRmMTdkYzUwMzg4ZjE2OTRiYzEzMWJkOTY1MDA0Zg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-06-21T18:33:51Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-06-21T18:33:51Z"}, "message": "cppfiles.c: Include splay-tree.h, not hashtab.h.\n\n\t* cppfiles.c: Include splay-tree.h, not hashtab.h.\n\t(redundant_include_p, make_IHASH, hash_IHASH, eq_IHASH): Delete.\n\t(destroy_include_file_node): New.\n\t(_cpp_init_include_hash): Rename _cpp_init_include_table.\n\tCreate a splay tree, not a hash table.\n\t(open_include_file): Look up the path in the include table,\n\tdo the multiple include optimization here, etc.\n\t(cpp_included): Walk the path.\n\t(find_include_file): Just walk the path calling\n\topen_include_file, or call it directly for an absolute path.\n\t(_cpp_fake_ihash): Rename _cpp_fake_include and update for new\n\tscheme.\n\t(read_include_file): Update for new scheme.  Don't close the\n\tfile unless reading fails.\n\t(_cpp_execute_include, cpp_read_file): Tweak for new scheme.\n\n\t* cpphash.h (struct ihash, NEVER_REINCLUDE): Delete.\n\t(struct include_file): New.\n\t(NEVER_REREAD, DO_NOT_REREAD, CPP_IN_SYSTEM_HEADER): New\n\tmacros.\n\t(CPP_PEDANTIC, CPP_WTRADITIONAL): Update.\n\tUpdate prototypes.\n\n\t* cppinit.c: Include splay-tree.h.\n\t(cpp_reader_init, cpp_cleanup): Update.\n\n\t* cpplib.h (struct cpp_buffer): Change ihash field to\n\t'struct include_file *inc'.  Remove system_header_p.\n\t(struct cpp_reader): Change all_include_files to a\n\tstruct splay_tree_s *.\n\n\t* cpplex.c: Update all references to cpp_buffer->ihash and/or\n\tcpp_buffer->system_header_p.\n\t(cpp_pop_buffer): Close file here, only if DO_NOT_REREAD.\n\nFrom-SVN: r34636", "tree": {"sha": "eb5aadb8fbe401846a1ceb69f99c1b4e7af8d929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb5aadb8fbe401846a1ceb69f99c1b4e7af8d929"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c31a6508eedf17dc50388f1694bc131bd965004f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c31a6508eedf17dc50388f1694bc131bd965004f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c31a6508eedf17dc50388f1694bc131bd965004f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c31a6508eedf17dc50388f1694bc131bd965004f/comments", "author": null, "committer": null, "parents": [{"sha": "e3cd9945cbe33d50af459b6b4951d3dcb12a33f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3cd9945cbe33d50af459b6b4951d3dcb12a33f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3cd9945cbe33d50af459b6b4951d3dcb12a33f7"}], "stats": {"total": 1145, "additions": 566, "deletions": 579}, "files": [{"sha": "c52995a2296ef6703c55e97633a6b0b90347746f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -1,3 +1,40 @@\n+2000-06-21  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c: Include splay-tree.h, not hashtab.h.\n+\t(redundant_include_p, make_IHASH, hash_IHASH, eq_IHASH): Delete.\n+\t(destroy_include_file_node): New.\n+\t(_cpp_init_include_hash): Rename _cpp_init_include_table.\n+\tCreate a splay tree, not a hash table.\n+\t(open_include_file): Look up the path in the include table,\n+\tdo the multiple include optimization here, etc.\n+\t(cpp_included): Walk the path.\n+\t(find_include_file): Just walk the path calling\n+\topen_include_file, or call it directly for an absolute path.\n+\t(_cpp_fake_ihash): Rename _cpp_fake_include and update for new\n+\tscheme.\n+\t(read_include_file): Update for new scheme.  Don't close the\n+\tfile unless reading fails.\n+\t(_cpp_execute_include, cpp_read_file): Tweak for new scheme.\n+\n+\t* cpphash.h (struct ihash, NEVER_REINCLUDE): Delete.\n+\t(struct include_file): New.\n+\t(NEVER_REREAD, DO_NOT_REREAD, CPP_IN_SYSTEM_HEADER): New\n+\tmacros.\n+\t(CPP_PEDANTIC, CPP_WTRADITIONAL): Update.\n+\tUpdate prototypes.\n+\n+\t* cppinit.c: Include splay-tree.h.\n+\t(cpp_reader_init, cpp_cleanup): Update.\n+\n+\t* cpplib.h (struct cpp_buffer): Change ihash field to \n+\t'struct include_file *inc'.  Remove system_header_p.\n+\t(struct cpp_reader): Change all_include_files to a\n+\tstruct splay_tree_s *.\n+\n+\t* cpplex.c: Update all references to cpp_buffer->ihash and/or\n+\tcpp_buffer->system_header_p.\n+\t(cpp_pop_buffer): Close file here, only if DO_NOT_REREAD.\n+\n Wed Jun 21 11:05:48 2000  Martin Buchholz <martin@xemacs.org>\n \n \t* invoke.texi (g++): \"g++\" is not a script anymore."}, {"sha": "422a123a1e0ab3d657d1db9d9d8c0f33c420deaf", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 465, "deletions": 525, "changes": 990, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -22,11 +22,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include \"hashtab.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"intl.h\"\n #include \"mkdeps.h\"\n+#include \"splay-tree.h\"\n \n #ifdef HAVE_MMAP_FILE\n # include <sys/mman.h>\n@@ -43,496 +43,272 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n # define O_BINARY 0\n #endif\n \n-static IHASH *redundant_include_p PARAMS ((IHASH *, struct file_name_list *));\n-static IHASH *make_IHASH\tPARAMS ((const char *, const char *,\n-\t\t\t\t\t struct file_name_list *,\n-\t\t\t\t\t unsigned int, IHASH **));\n static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static char *read_filename_string PARAMS ((int, FILE *));\n static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n \t\t\t\t\t struct file_name_list *));\n static struct file_name_list *actual_directory\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n-static unsigned int hash_IHASH\tPARAMS ((const void *));\n-static int eq_IHASH\t\tPARAMS ((const void *, const void *));\n-static int find_include_file\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\tstruct file_name_list *,\n-\t\t\t\t\tIHASH **, int *));\n-static inline int open_include_file PARAMS ((cpp_reader *, const char *));\n-static int read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n+static struct include_file *find_include_file\n+\t\t\t\tPARAMS ((cpp_reader *, const char *,\n+\t\t\t\t\t struct file_name_list *));\n+static struct include_file *open_include_file\n+\t\t\t\tPARAMS ((cpp_reader *, const char *));\n+static int read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static ssize_t read_with_read\tPARAMS ((cpp_buffer *, int, ssize_t));\n static ssize_t read_file\tPARAMS ((cpp_buffer *, int, ssize_t));\n \n+static void destroy_include_file_node\tPARAMS ((splay_tree_value));\n+\n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n #endif\n \n-/* Initial size of include hash table.  */\n-#define IHASHSIZE 50\n-\n #ifndef INCLUDE_LEN_FUDGE\n #define INCLUDE_LEN_FUDGE 0\n #endif\n \n-/* Calculate hash of an IHASH entry.  */\n-static unsigned int\n-hash_IHASH (x)\n-     const void *x;\n-{\n-  const IHASH *i = (const IHASH *)x;\n-  return i->hash;\n-}\n+/* We use a splay tree to store information about all the include\n+   files seen in this compilation.  The key of each tree node is the\n+   physical path to the file.  The value is 0 if the file does not\n+   exist, or a struct include_file pointer.  */\n \n-/* Compare an existing IHASH structure with a potential one.  */\n-static int\n-eq_IHASH (x, y)\n-     const void *x;\n-     const void *y;\n+static void\n+destroy_include_file_node (v)\n+     splay_tree_value v;\n {\n-  const char *a = ((const IHASH *)x)->nshort;\n-  const char *b = ((const IHASH *)y)->nshort;\n-  return !strcmp (a, b);\n+  struct include_file *f = (struct include_file *)v;\n+  if (f)\n+    {\n+      if (f->fd != -1)\n+\tclose (f->fd);\n+      free (f);\n+    }\n }\n \n-/* Init the hash table.  In here so it can see the hash and eq functions.  */\n void\n-_cpp_init_include_hash (pfile)\n+_cpp_init_include_table (pfile)\n      cpp_reader *pfile;\n {\n   pfile->all_include_files\n-    = htab_create (IHASHSIZE, hash_IHASH, eq_IHASH, free);\n+    = splay_tree_new ((splay_tree_compare_fn) strcmp,\n+\t\t      (splay_tree_delete_key_fn) free,\n+\t\t      destroy_include_file_node);\n }\n \n-/* Return 0 if the file pointed to by IHASH has never been included before,\n-         -1 if it has been included before and need not be again,\n-\t or a pointer to an IHASH entry which is the file to be reread.\n-   \"Never before\" is with respect to the position in ILIST.\n+/* Given a filename, look it up and possibly open it.  If the file\n+   does not exist, return NULL.  If the file does exist but doesn't\n+   need to be reread, return an include_file entry with fd == -1.\n+   If it needs to be (re)read, return an include_file entry with\n+   fd a file descriptor open on the file. */\n \n-   This will not detect redundancies involving odd uses of the\n-   `current directory' rule for \"\" includes.  They aren't quite\n-   pathological, but I think they are rare enough not to worry about.\n-   The simplest example is:\n+static struct include_file *\n+open_include_file (pfile, filename)\n+     cpp_reader *pfile;\n+     const char *filename;\n+{\n+  splay_tree_node nd;\n+  struct include_file *file = 0;\n+  int fd;\n \n-   top.c:\n-   #include \"a/a.h\"\n-   #include \"b/b.h\"\n+  nd = splay_tree_lookup (pfile->all_include_files,\n+\t\t\t  (splay_tree_key) filename);\n \n-   a/a.h:\n-   #include \"../b/b.h\"\n+  if (nd)\n+    {\n+      if (nd->value == 0)\n+\treturn 0;\n \n-   and the problem is that for `current directory' includes,\n-   ihash->foundhere is not on any of the global include chains,\n-   so the test below (i->foundhere == l) may be false even when\n-   the directories are in fact the same.  */\n+      file = (struct include_file *)nd->value;\n \n-static IHASH *\n-redundant_include_p (ihash, ilist)\n-     IHASH *ihash;\n-     struct file_name_list *ilist;\n-{\n-  struct file_name_list *l;\n-  IHASH *i;\n+      if (DO_NOT_REREAD (file))\n+\t{\n+\t  if (file->fd != -1)\n+\t    {\n+\t      close (file->fd);\n+\t      file->fd = -1;\n+\t    }\n+\t  return file;\n+\t}\n \n-  if (! ihash->foundhere)\n-    return 0;\n+      /* File descriptors are cached for files that might be reread.  */\n+      if (file->fd != -1)\n+\t{\n+\t  lseek (file->fd, 0, SEEK_SET);\n+\t  return file;\n+\t}\n+    }\n \n-  for (i = ihash; i; i = i->next_this_file)\n-    for (l = ilist; l; l = l->next)\n-       if (i->foundhere == l)\n-\t /* The cmacro works like this: If it's NULL, the file is to\n-\t    be included again.  If it's NEVER_REINCLUDE, the file is\n-\t    never to be included again.  Otherwise it is a macro\n-\t    hashnode, and the file is to be included again if the\n-\t    macro is not defined.  */\n-\t return (i->cmacro\n-\t\t && (i->cmacro == NEVER_REINCLUDE\n-\t\t     || i->cmacro->type != T_VOID))\n-\t     ? (IHASH *)-1 : i;\n+  /* We used to open files in nonblocking mode, but that caused more\n+     problems than it solved.  Do take care not to acquire a\n+     controlling terminal by mistake (this can't happen on sane\n+     systems, but paranoia is a virtue).\n \n-  return 0;\n-}\n+     Use the three-argument form of open even though we aren't\n+     specifying O_CREAT, to defend against broken system headers.\n \n-/* Return 1 if the file named by FNAME has been included before in\n-   any context, 0 otherwise.  */\n-int\n-cpp_included (pfile, fname)\n-     cpp_reader *pfile;\n-     const char *fname;\n-{\n-  IHASH dummy, *ptr;\n-  dummy.nshort = fname;\n-  dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n-  ptr = htab_find_with_hash (pfile->all_include_files,\n-\t\t\t     (const void *)&dummy, dummy.hash);\n-  return (ptr != NULL);\n-}\n+     O_BINARY tells some runtime libraries (notably DJGPP) not to do\n+     newline translation; we can handle DOS line breaks just fine\n+     ourselves.\n \n-/* Create an IHASH entry and insert it in SLOT.  */\n-static IHASH *\n-make_IHASH (name, fname, path, hash, slot)\n-     const char *name, *fname;\n-     struct file_name_list *path;\n-     unsigned int hash;\n-     IHASH **slot;\n-{\n-  IHASH *ih;\n-  if (path == ABSOLUTE_PATH)\n-    {\n-      ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n-      ih->nshort = ih->name;\n-    }\n+     Special case: the empty string is translated to stdin.  */\n+  if (filename[0] == '\\0')\n+    fd = 0;\n   else\n+    fd = open (filename, O_RDONLY|O_NOCTTY|O_BINARY, 0666);\n+\n+  if (fd == -1)\n     {\n-      char *s;\n-      \n-      if ((s = strstr (name, fname)) != NULL)\n+#ifdef EACCES\n+      if (errno == EACCES)\n \t{\n-\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n-\t  ih->nshort = ih->name + (s - name);\n+\t  cpp_error (pfile, \"included file `%s' exists but is not readable\",\n+\t\t     filename);\n \t}\n-      else\n+#endif\n+      /* Nonexistent or inaccessible file.  Create a negative node for it.  */\n+      if (nd)\n \t{\n-\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name)\n-\t\t\t\t  + strlen (fname) + 1);\n-\t  ih->nshort = ih->name + strlen (name) + 1;\n-\t  strcpy ((char *)ih->nshort, fname);\n+\t  cpp_ice (pfile,\n+\t\t   \"node for '%s' exists, open failed, error '%s', value %lx\\n\",\n+\t\t   filename, strerror (errno), nd->value);\n+\t  destroy_include_file_node (nd->value);\n \t}\n+      splay_tree_insert (pfile->all_include_files,\n+\t\t\t (splay_tree_key) xstrdup (filename), 0);\n+      return 0;\n     }\n-  strcpy ((char *)ih->name, name);\n-  ih->foundhere = path;\n-  ih->cmacro = NULL;\n-  ih->hash = hash;\n-  ih->next_this_file = *slot;\n-  *slot = ih;\n-  return ih;\n-}\n-\n-/* Centralize calls to open(2) here.  This provides a hook for future\n-   changes which might, e.g. look for and open a precompiled version\n-   of the header.  It also means all the magic currently associated\n-   with calling open is in one place, and if we ever need more, it'll\n-   be in one place too.\n-\n-   We used to open files in nonblocking mode, but that caused more\n-   problems than it solved.  Do take care not to acquire a controlling\n-   terminal by mistake (this can't happen on sane systems, but\n-   paranoia is a virtue).\n \n-   Use the three-argument form of open even though we aren't\n-   specifying O_CREAT, to defend against broken system headers.\n-\n-   O_BINARY tells some runtime libraries (notably DJGPP) not to do\n-   newline translation; we can handle DOS line breaks just fine\n-   ourselves.  */\n+  /* If we haven't seen this file before, create a positive node for it.  */\n+  if (!nd)\n+    {\n+      file = xnew (struct include_file);\n+      file->cmacro = 0;\n+      file->before = 0;\n+      file->sysp = 0;\n+      file->foundhere = 0;\n+      file->name = xstrdup (filename);\n+      splay_tree_insert (pfile->all_include_files,\n+\t\t\t (splay_tree_key) file->name,\n+\t\t\t (splay_tree_value) file);\n+    }\n \n-static inline int\n-open_include_file (pfile, filename)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     const char *filename;\n-{\n-  return open (filename, O_RDONLY|O_NOCTTY|O_BINARY, 0666);\n+  file->fd = fd;\n+  return file;\n }\n \n-/* Search for include file FNAME in the include chain starting at\n-   SEARCH_START.  Return -2 if this file doesn't need to be included\n-   (because it was included already and it's marked idempotent),\n-   -1 if an error occurred, or a file descriptor open on the file.\n-   *IHASH is set to point to the include hash entry for this file, and\n-   *BEFORE is set to 1 if the file was included before (but needs to be read\n-   again). */\n-static int\n-find_include_file (pfile, fname, search_start, ihash, before)\n+/* Return 1 if the file named by FNAME has been included before in\n+   any context, 0 otherwise.  */\n+int\n+cpp_included (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n-     struct file_name_list *search_start;\n-     IHASH **ihash;\n-     int *before;\n {\n   struct file_name_list *path;\n-  IHASH *ih, **slot;\n-  IHASH dummy;\n-  int f;\n   char *name;\n+  splay_tree_node nd;\n \n-  dummy.nshort = fname;\n-  dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n-  path = (fname[0] == '/') ? ABSOLUTE_PATH : search_start;\n-  slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n-\t\t\t\t\t      (const void *) &dummy,\n-\t\t\t\t\t      dummy.hash, INSERT);\n-\n-  if (*slot && (ih = redundant_include_p (*slot, path)))\n-    {\n-      if (ih == (IHASH *)-1)\n-\treturn -2;\n-\n-      *before = 1;\n-      *ihash = ih;\n-      return open_include_file (pfile, ih->name);\n-    }\n-\n-  if (path == ABSOLUTE_PATH)\n+  if (fname[0] == '/')\n     {\n-      name = (char *) fname;\n-      f = open_include_file (pfile, name);\n+      /* Just look it up.  */\n+      nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) fname);\n+      return (nd && nd->value);\n     }\n-  else\n+      \n+  /* Search directory path for the file.  */\n+  name = (char *) alloca (strlen (fname) + pfile->max_include_len\n+\t\t\t  + 2 + INCLUDE_LEN_FUDGE);\n+  for (path = CPP_OPTION (pfile, quote_include); path; path = path->next)\n     {\n-      /* Search directory path, trying to open the file.  */\n-      name = (char *) alloca (strlen (fname) + pfile->max_include_len\n-\t\t     + 2 + INCLUDE_LEN_FUDGE);\n-      do\n-\t{\n-\t  memcpy (name, path->name, path->nlen);\n-\t  name[path->nlen] = '/';\n-\t  strcpy (&name[path->nlen+1], fname);\n-\t  _cpp_simplify_pathname (name);\n-\t  if (CPP_OPTION (pfile, remap))\n-\t    name = remap_filename (pfile, name, path);\n-\n-\t  f = open_include_file (pfile, name);\n-#ifdef EACCES\n-\t  if (f == -1 && errno == EACCES)\n-\t    {\n-\t      cpp_error (pfile,\n-\t\t\t \"included file `%s' exists but is not readable\",\n-\t\t\t name);\n-\t      return -1;\n-\t    }\n-#endif\n-\t  if (f >= 0)\n-\t    break;\n-\t  path = path->next;\n-\t}\n-      while (path);\n+      memcpy (name, path->name, path->nlen);\n+      name[path->nlen] = '/';\n+      strcpy (&name[path->nlen+1], fname);\n+      _cpp_simplify_pathname (name);\n+      if (CPP_OPTION (pfile, remap))\n+\tname = remap_filename (pfile, name, path);\n+\n+      nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) name);\n+      if (nd && nd->value)\n+\treturn 1;\n     }\n-  if (f == -1)\n-    return -1;\n-\n-  ih = make_IHASH (name, fname, path, dummy.hash, slot);\n-  *before = 0;\n-  *ihash = ih;\n-  return f;\n+  return 0;\n }\n \n-/* Create a dummy IHASH entry for FNAME, and return its name pointer.\n-   This is used by #line.  */\n-const char *\n-_cpp_fake_ihash (pfile, fname)\n+/* Search for include file FNAME in the include chain starting at\n+   SEARCH_START.  Return 0 if there is no such file (or it's un-openable),\n+   otherwise an include_file structure, possibly with a file descriptor\n+   open on the file.  */\n+\n+static struct include_file *\n+find_include_file (pfile, fname, search_start)\n      cpp_reader *pfile;\n      const char *fname;\n+     struct file_name_list *search_start;\n {\n-  IHASH *ih, **slot;\n-  IHASH dummy;\n-\n-  dummy.nshort = fname;\n-  dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n-  slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n-\t\t\t\t\t      (const void *) &dummy,\n-\t\t\t\t\t      dummy.hash, INSERT);\n-  if (*slot)\n-    return (*slot)->name;\n-  ih = make_IHASH (fname, 0, ABSOLUTE_PATH, dummy.hash, slot);\n-  return ih->name;\n-}\n-\n-\n-/* The file_name_map structure holds a mapping of file names for a\n-   particular directory.  This mapping is read from the file named\n-   FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n-   map filenames on a file system with severe filename restrictions,\n-   such as DOS.  The format of the file name map file is just a series\n-   of lines with two tokens on each line.  The first token is the name\n-   to map, and the second token is the actual name to use.  */\n-\n-struct file_name_map\n-{\n-  struct file_name_map *map_next;\n-  char *map_from;\n-  char *map_to;\n-};\n-\n-#define FILE_NAME_MAP_FILE \"header.gcc\"\n-\n-/* Read a space delimited string of unlimited length from a stdio\n-   file.  */\n-\n-static char *\n-read_filename_string (ch, f)\n-     int ch;\n-     FILE *f;\n-{\n-  char *alloc, *set;\n-  int len;\n+  struct file_name_list *path;\n+  char *name;\n+  struct include_file *file;\n \n-  len = 20;\n-  set = alloc = xmalloc (len + 1);\n-  if (! is_space(ch))\n+  if (fname[0] == '/')\n+    return open_include_file (pfile, fname);\n+      \n+  /* Search directory path for the file.  */\n+  name = (char *) alloca (strlen (fname) + pfile->max_include_len\n+\t\t\t  + 2 + INCLUDE_LEN_FUDGE);\n+  for (path = search_start; path; path = path->next)\n     {\n-      *set++ = ch;\n-      while ((ch = getc (f)) != EOF && ! is_space(ch))\n+      memcpy (name, path->name, path->nlen);\n+      name[path->nlen] = '/';\n+      strcpy (&name[path->nlen+1], fname);\n+      _cpp_simplify_pathname (name);\n+      if (CPP_OPTION (pfile, remap))\n+\tname = remap_filename (pfile, name, path);\n+\n+      file = open_include_file (pfile, name);\n+      if (file)\n \t{\n-\t  if (set - alloc == len)\n-\t    {\n-\t      len *= 2;\n-\t      alloc = xrealloc (alloc, len + 1);\n-\t      set = alloc + len / 2;\n-\t    }\n-\t  *set++ = ch;\n+\t  file->sysp = path->sysp;\n+\t  file->foundhere = path;\n+\t  return file;\n \t}\n     }\n-  *set = '\\0';\n-  ungetc (ch, f);\n-  return alloc;\n+  return 0;\n }\n \n-/* This structure holds a linked list of file name maps, one per directory.  */\n-\n-struct file_name_map_list\n-{\n-  struct file_name_map_list *map_list_next;\n-  char *map_list_name;\n-  struct file_name_map *map_list_map;\n-};\n-\n-/* Read the file name map file for DIRNAME.  */\n-\n-static struct file_name_map *\n-read_name_map (pfile, dirname)\n+/* #line uses this to save artificial file names.  We have to try\n+   opening the file because an all_include_files entry is always\n+   either + or -, there's no 'I don't know' value.  */\n+const char *\n+_cpp_fake_include (pfile, fname)\n      cpp_reader *pfile;\n-     const char *dirname;\n+     const char *fname;\n {\n-  register struct file_name_map_list *map_list_ptr;\n+  splay_tree_node nd;\n+  struct include_file *file;\n   char *name;\n-  FILE *f;\n \n-  for (map_list_ptr = CPP_OPTION (pfile, map_list); map_list_ptr;\n-       map_list_ptr = map_list_ptr->map_list_next)\n-    if (! strcmp (map_list_ptr->map_list_name, dirname))\n-      return map_list_ptr->map_list_map;\n+  file = find_include_file (pfile, fname, CPP_OPTION (pfile, quote_include));\n+  if (file)\n+    return file->name;\n \n-  map_list_ptr = ((struct file_name_map_list *)\n-\t\t  xmalloc (sizeof (struct file_name_map_list)));\n-  map_list_ptr->map_list_name = xstrdup (dirname);\n+  name = xstrdup (fname);\n+  _cpp_simplify_pathname (name);\n \n-  name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n-  strcpy (name, dirname);\n-  if (*dirname)\n-    strcat (name, \"/\");\n-  strcat (name, FILE_NAME_MAP_FILE);\n-  f = fopen (name, \"r\");\n-  if (!f)\n-    map_list_ptr->map_list_map = (struct file_name_map *)-1;\n-  else\n+  /* We cannot just blindly insert a node, because there's still the\n+     chance that the node already exists but isn't on the search path.  */\n+  nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) name);\n+  if (nd)\n     {\n-      int ch;\n-      int dirlen = strlen (dirname);\n-\n-      while ((ch = getc (f)) != EOF)\n-\t{\n-\t  char *from, *to;\n-\t  struct file_name_map *ptr;\n-\n-\t  if (is_space(ch))\n-\t    continue;\n-\t  from = read_filename_string (ch, f);\n-\t  while ((ch = getc (f)) != EOF && is_hspace(ch))\n-\t    ;\n-\t  to = read_filename_string (ch, f);\n-\n-\t  ptr = ((struct file_name_map *)\n-\t\t xmalloc (sizeof (struct file_name_map)));\n-\t  ptr->map_from = from;\n-\n-\t  /* Make the real filename absolute.  */\n-\t  if (*to == '/')\n-\t    ptr->map_to = to;\n-\t  else\n-\t    {\n-\t      ptr->map_to = xmalloc (dirlen + strlen (to) + 2);\n-\t      strcpy (ptr->map_to, dirname);\n-\t      ptr->map_to[dirlen] = '/';\n-\t      strcpy (ptr->map_to + dirlen + 1, to);\n-\t      free (to);\n-\t    }\t      \n-\n-\t  ptr->map_next = map_list_ptr->map_list_map;\n-\t  map_list_ptr->map_list_map = ptr;\n-\n-\t  while ((ch = getc (f)) != '\\n')\n-\t    if (ch == EOF)\n-\t      break;\n-\t}\n-      fclose (f);\n+      free (name);\n+      return (const char *) nd->key;\n     }\n-  \n-  map_list_ptr->map_list_next = CPP_OPTION (pfile, map_list);\n-  CPP_OPTION (pfile, map_list) = map_list_ptr;\n-\n-  return map_list_ptr->map_list_map;\n-}  \n-\n-/* Remap NAME based on the file_name_map (if any) for LOC. */\n-\n-static char *\n-remap_filename (pfile, name, loc)\n-     cpp_reader *pfile;\n-     char *name;\n-     struct file_name_list *loc;\n-{\n-  struct file_name_map *map;\n-  const char *from, *p, *dir;\n-\n-  if (! loc->name_map)\n-    loc->name_map = read_name_map (pfile,\n-\t\t\t\t   loc->name\n-\t\t\t\t   ? loc->name : \".\");\n-\n-  if (loc->name_map == (struct file_name_map *)-1)\n-    return name;\n-  \n-  from = name + strlen (loc->name) + 1;\n-  \n-  for (map = loc->name_map; map; map = map->map_next)\n-    if (!strcmp (map->map_from, from))\n-      return map->map_to;\n \n-  /* Try to find a mapping file for the particular directory we are\n-     looking in.  Thus #include <sys/types.h> will look up sys/types.h\n-     in /usr/include/header.gcc and look up types.h in\n-     /usr/include/sys/header.gcc.  */\n-  p = strrchr (name, '/');\n-  if (!p)\n-    p = name;\n-  if (loc && loc->name\n-      && strlen (loc->name) == (size_t) (p - name)\n-      && !strncmp (loc->name, name, p - name))\n-    /* FILENAME is in SEARCHPTR, which we've already checked.  */\n-    return name;\n-\n-  if (p == name)\n-    {\n-      dir = \".\";\n-      from = name;\n-    }\n-  else\n-    {\n-      char * newdir = (char *) alloca (p - name + 1);\n-      memcpy (newdir, name, p - name);\n-      newdir[p - name] = '\\0';\n-      dir = newdir;\n-      from = p + 1;\n-    }\n-  \n-  for (map = read_name_map (pfile, dir); map; map = map->map_next)\n-    if (! strcmp (map->map_from, name))\n-      return map->map_to;\n-\n-  return name;\n+  splay_tree_insert (pfile->all_include_files, (splay_tree_key) name, 0);\n+  return (const char *)name;\n }\n \n-\n+#define PRINT_THIS_DEP(p, b) (CPP_PRINT_DEPS(p) > (b||p->system_include_depth))\n void\n _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n      cpp_reader *pfile;\n@@ -541,11 +317,9 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n      int no_reinclude;\n      struct file_name_list *search_start;\n {\n-  IHASH *ihash;\n+  struct include_file *inc;\n   char *fname = (char *)f;\n-  int fd;\n   int angle_brackets = fname[0] == '<';\n-  int before;\n \n   if (!search_start)\n     {\n@@ -568,137 +342,109 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n   len -= 2;\n   fname[len] = '\\0';\n \n-  fd = find_include_file (pfile, fname, search_start, &ihash, &before);\n+  inc = find_include_file (pfile, fname, search_start);\n \n-  if (fd == -2)\n-    return;\n-  \n-  if (fd == -1)\n+  if (inc)\n     {\n-      if (CPP_OPTION (pfile, print_deps_missing_files)\n-\t  && CPP_PRINT_DEPS (pfile) > (angle_brackets ||\n-\t\t\t\t       (pfile->system_include_depth > 0)))\n-        {\n-\t  if (!angle_brackets)\n-\t    deps_add_dep (pfile->deps, fname);\n-\t  else\n-\t    {\n-\t      char *p;\n-\t      struct file_name_list *ptr;\n-\t      /* If requested as a system header, assume it belongs in\n-\t\t the first system header directory. */\n-\t      if (CPP_OPTION (pfile, bracket_include))\n-\t        ptr = CPP_OPTION (pfile, bracket_include);\n-\t      else\n-\t        ptr = CPP_OPTION (pfile, quote_include);\n-\n-\t      p = (char *) alloca (strlen (ptr->name)\n-\t\t\t\t   + strlen (fname) + 2);\n-\t      if (*ptr->name != '\\0')\n-\t        {\n-\t\t  strcpy (p, ptr->name);\n-\t\t  strcat (p, \"/\");\n-\t        }\n-\t      strcat (p, fname);\n-\t      deps_add_dep (pfile->deps, p);\n-\t    }\n+      if (inc->fd == -1)\n+\treturn;\n+\n+      /* For -M, add the file to the dependencies on its first inclusion. */\n+      if (!inc->before && PRINT_THIS_DEP (pfile, angle_brackets))\n+\tdeps_add_dep (pfile->deps, inc->name);\n+      inc->before = 1;\n+\n+      /* Handle -H option.  */\n+      if (CPP_OPTION (pfile, print_include_names))\n+\t{\n+\t  cpp_buffer *fp = CPP_BUFFER (pfile);\n+\t  while ((fp = CPP_PREV_BUFFER (fp)) != NULL)\n+\t    putc ('.', stderr);\n+\t  fprintf (stderr, \" %s\\n\", inc->name);\n \t}\n-      /* If -M was specified, and this header file won't be added to\n-\t the dependency list, then don't count this as an error,\n-\t because we can still produce correct output.  Otherwise, we\n-\t can't produce correct output, because there may be\n-\t dependencies we need inside the missing file, and we don't\n-\t know what directory this missing file exists in. */\n-      else if (CPP_PRINT_DEPS (pfile)\n-\t       && (CPP_PRINT_DEPS (pfile)\n-\t\t   <= (angle_brackets || (pfile->system_include_depth > 0))))\n-\tcpp_warning (pfile, \"No include path in which to find %s\", fname);\n-      else\n-\tcpp_error_from_errno (pfile, fname);\n \n+      /* Actually process the file.  */\n+      if (no_reinclude)\n+\tinc->cmacro = NEVER_REREAD;\n+  \n+      if (read_include_file (pfile, inc))\n+\t{\n+\t  if (angle_brackets)\n+\t    pfile->system_include_depth++;\n+\t}\n       return;\n     }\n-\n-  /* For -M, add the file to the dependencies on its first inclusion. */\n-  if (!before && (CPP_PRINT_DEPS (pfile)\n-\t\t  > (angle_brackets || (pfile->system_include_depth > 0))))\n-    deps_add_dep (pfile->deps, ihash->name);\n-\n-  /* Handle -H option.  */\n-  if (CPP_OPTION (pfile, print_include_names))\n+      \n+  if (CPP_OPTION (pfile, print_deps_missing_files)\n+      && PRINT_THIS_DEP (pfile, angle_brackets))\n     {\n-      cpp_buffer *fp = CPP_BUFFER (pfile);\n-      while ((fp = CPP_PREV_BUFFER (fp)) != NULL)\n-\tputc ('.', stderr);\n-      fprintf (stderr, \" %s\\n\", ihash->name);\n-    }\n+      if (!angle_brackets)\n+\tdeps_add_dep (pfile->deps, fname);\n+      else\n+\t{\n+\t  char *p;\n+\t  struct file_name_list *ptr;\n+\t  /* If requested as a system header, assume it belongs in\n+\t     the first system header directory. */\n+\t  if (CPP_OPTION (pfile, bracket_include))\n+\t    ptr = CPP_OPTION (pfile, bracket_include);\n+\t  else\n+\t    ptr = CPP_OPTION (pfile, quote_include);\n \n-  /* Actually process the file.  */\n-  if (no_reinclude)\n-    ihash->cmacro = NEVER_REINCLUDE;\n-  \n-  if (read_include_file (pfile, fd, ihash))\n-    {\n-      if (angle_brackets)\n-\tpfile->system_include_depth++;\n+\t  p = (char *) alloca (strlen (ptr->name)\n+\t\t\t       + strlen (fname) + 2);\n+\t  if (*ptr->name != '\\0')\n+\t    {\n+\t      strcpy (p, ptr->name);\n+\t      strcat (p, \"/\");\n+\t    }\n+\t  strcat (p, fname);\n+\t  _cpp_simplify_pathname (p);\n+\t  deps_add_dep (pfile->deps, p);\n+\t}\n     }\n+  /* If -M was specified, and this header file won't be added to\n+     the dependency list, then don't count this as an error,\n+     because we can still produce correct output.  Otherwise, we\n+     can't produce correct output, because there may be\n+     dependencies we need inside the missing file, and we don't\n+     know what directory this missing file exists in. */\n+  else if (CPP_PRINT_DEPS (pfile)\n+\t   && ! PRINT_THIS_DEP (pfile, angle_brackets))\n+    cpp_warning (pfile, \"No include path in which to find %s\", fname);\n+  else\n+    cpp_error_from_errno (pfile, fname);\n }\n \n-\n /* Push an input buffer and load it up with the contents of FNAME.\n    If FNAME is \"\" or NULL, read standard input.  */\n int\n cpp_read_file (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  IHASH *ih, **slot;\n-  IHASH dummy;\n-  int f;\n+  struct include_file *f;\n \n   if (fname == NULL)\n     fname = \"\";\n \n-  dummy.nshort = fname;\n-  /* _cpp_calc_hash doesn't like zero-length strings.  */\n-  if (*fname == 0)\n-    dummy.hash = 0;\n-  else\n-    dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n-  slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n-\t\t\t\t\t      (const void *) &dummy,\n-\t\t\t\t\t      dummy.hash, INSERT);\n-  if (*slot && (ih = redundant_include_p (*slot, ABSOLUTE_PATH)))\n-    {\n-      if (ih == (IHASH *) -1)\n-\treturn 1;  /* Already included.  */\n-    }\n-  else\n-    ih = make_IHASH (fname, 0, ABSOLUTE_PATH, dummy.hash, slot);\n-\n-  if (*fname == '\\0')\n-    f = 0;\n-  else\n-    f = open_include_file (pfile, fname);\n+  f = open_include_file (pfile, fname);\n \n-  return read_include_file (pfile, f, ih);\n+  return read_include_file (pfile, f);\n }\n \n-/* Read the contents of FD into the buffer on the top of PFILE's stack.\n-   IHASH points to the include hash entry for the file associated with\n-   FD.\n-\n-   The caller is responsible for the cpp_push_buffer.  */\n+/* Read the file referenced by INC into a new buffer on PFILE's stack.\n+   Return 1 if successful, 0 if not.  */\n \n static int\n-read_include_file (pfile, fd, ihash)\n+read_include_file (pfile, inc)\n      cpp_reader *pfile;\n-     int fd;\n-     IHASH *ihash;\n+     struct include_file *inc;\n {\n   struct stat st;\n   ssize_t length;\n   cpp_buffer *fp;\n+  int fd = inc->fd;\n \n   fp = cpp_push_buffer (pfile, NULL, 0);\n \n@@ -733,24 +479,24 @@ read_include_file (pfile, fd, ihash)\n \t does not bite us.  */\n       if (st.st_size > INTTYPE_MAXIMUM (ssize_t))\n \t{\n-\t  cpp_error (pfile, \"%s is too large\", ihash->name);\n+\t  cpp_error (pfile, \"%s is too large\", inc->name);\n \t  goto fail;\n \t}\n       st_size = st.st_size;\n       length = read_file (fp, fd, st_size);\n       if (length == -1)\n \tgoto perror_fail;\n       if (length < st_size)\n-\tcpp_warning (pfile, \"%s is shorter than expected\\n\", ihash->name);\n+\tcpp_warning (pfile, \"%s is shorter than expected\\n\", inc->name);\n     }\n   else if (S_ISBLK (st.st_mode))\n     {\n-      cpp_error (pfile, \"%s is a block device\", ihash->name);\n+      cpp_error (pfile, \"%s is a block device\", inc->name);\n       goto fail;\n     }\n   else if (S_ISDIR (st.st_mode))\n     {\n-      cpp_error (pfile, \"%s is a directory\", ihash->name);\n+      cpp_error (pfile, \"%s is a directory\", inc->name);\n       goto fail;\n     }\n   else\n@@ -764,38 +510,38 @@ read_include_file (pfile, fd, ihash)\n     }\n \n   /* These must be set before prescan.  */\n-  fp->ihash = ihash;\n-  fp->nominal_fname = ihash->name;\n+  fp->inc = inc;\n+  fp->nominal_fname = inc->name;\n   \n   if (length == 0)\n-    ihash->cmacro = NEVER_REINCLUDE;\n+    inc->cmacro = NEVER_REREAD;\n   else\n     /* Temporary - I hope.  */\n     length = _cpp_prescan (pfile, fp, length);\n \n   fp->rlimit = fp->buf + length;\n   fp->cur = fp->buf;\n-  if (ihash->foundhere != ABSOLUTE_PATH)\n-    fp->system_header_p = ihash->foundhere->sysp;\n   fp->lineno = 1;\n   fp->line_base = fp->buf;\n \n   /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n      see do_include */\n   if (!CPP_OPTION (pfile, ignore_srcdir))\n-    fp->actual_dir = actual_directory (pfile, ihash->name);\n+    fp->actual_dir = actual_directory (pfile, inc->name);\n \n   pfile->input_stack_listing_current = 0;\n   pfile->only_seen_white = 2;\n-  close (fd);\n   return 1;\n \n  perror_fail:\n-  cpp_error_from_errno (pfile, ihash->name);\n+  cpp_error_from_errno (pfile, inc->name);\n+  /* Do not try to read this file again.  */\n+  close (fd);\n+  inc->fd = -1;\n+  inc->cmacro = NEVER_REREAD;\n  fail:\n   cpp_pop_buffer (pfile);\n  push_fail:\n-  close (fd);\n   return 0;\n }\n \n@@ -867,6 +613,200 @@ read_with_read (fp, fd, size)\n   return offset;\n }\n \n+/* The file_name_map structure holds a mapping of file names for a\n+   particular directory.  This mapping is read from the file named\n+   FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n+   map filenames on a file system with severe filename restrictions,\n+   such as DOS.  The format of the file name map file is just a series\n+   of lines with two tokens on each line.  The first token is the name\n+   to map, and the second token is the actual name to use.  */\n+\n+struct file_name_map\n+{\n+  struct file_name_map *map_next;\n+  char *map_from;\n+  char *map_to;\n+};\n+\n+#define FILE_NAME_MAP_FILE \"header.gcc\"\n+\n+/* Read a space delimited string of unlimited length from a stdio\n+   file.  */\n+\n+static char *\n+read_filename_string (ch, f)\n+     int ch;\n+     FILE *f;\n+{\n+  char *alloc, *set;\n+  int len;\n+\n+  len = 20;\n+  set = alloc = xmalloc (len + 1);\n+  if (! is_space(ch))\n+    {\n+      *set++ = ch;\n+      while ((ch = getc (f)) != EOF && ! is_space(ch))\n+\t{\n+\t  if (set - alloc == len)\n+\t    {\n+\t      len *= 2;\n+\t      alloc = xrealloc (alloc, len + 1);\n+\t      set = alloc + len / 2;\n+\t    }\n+\t  *set++ = ch;\n+\t}\n+    }\n+  *set = '\\0';\n+  ungetc (ch, f);\n+  return alloc;\n+}\n+\n+/* This structure holds a linked list of file name maps, one per directory.  */\n+\n+struct file_name_map_list\n+{\n+  struct file_name_map_list *map_list_next;\n+  char *map_list_name;\n+  struct file_name_map *map_list_map;\n+};\n+\n+/* Read the file name map file for DIRNAME.  */\n+\n+static struct file_name_map *\n+read_name_map (pfile, dirname)\n+     cpp_reader *pfile;\n+     const char *dirname;\n+{\n+  register struct file_name_map_list *map_list_ptr;\n+  char *name;\n+  FILE *f;\n+\n+  for (map_list_ptr = CPP_OPTION (pfile, map_list); map_list_ptr;\n+       map_list_ptr = map_list_ptr->map_list_next)\n+    if (! strcmp (map_list_ptr->map_list_name, dirname))\n+      return map_list_ptr->map_list_map;\n+\n+  map_list_ptr = ((struct file_name_map_list *)\n+\t\t  xmalloc (sizeof (struct file_name_map_list)));\n+  map_list_ptr->map_list_name = xstrdup (dirname);\n+\n+  name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n+  strcpy (name, dirname);\n+  if (*dirname)\n+    strcat (name, \"/\");\n+  strcat (name, FILE_NAME_MAP_FILE);\n+  f = fopen (name, \"r\");\n+  if (!f)\n+    map_list_ptr->map_list_map = (struct file_name_map *)-1;\n+  else\n+    {\n+      int ch;\n+      int dirlen = strlen (dirname);\n+\n+      while ((ch = getc (f)) != EOF)\n+\t{\n+\t  char *from, *to;\n+\t  struct file_name_map *ptr;\n+\n+\t  if (is_space(ch))\n+\t    continue;\n+\t  from = read_filename_string (ch, f);\n+\t  while ((ch = getc (f)) != EOF && is_hspace(ch))\n+\t    ;\n+\t  to = read_filename_string (ch, f);\n+\n+\t  ptr = ((struct file_name_map *)\n+\t\t xmalloc (sizeof (struct file_name_map)));\n+\t  ptr->map_from = from;\n+\n+\t  /* Make the real filename absolute.  */\n+\t  if (*to == '/')\n+\t    ptr->map_to = to;\n+\t  else\n+\t    {\n+\t      ptr->map_to = xmalloc (dirlen + strlen (to) + 2);\n+\t      strcpy (ptr->map_to, dirname);\n+\t      ptr->map_to[dirlen] = '/';\n+\t      strcpy (ptr->map_to + dirlen + 1, to);\n+\t      free (to);\n+\t    }\t      \n+\n+\t  ptr->map_next = map_list_ptr->map_list_map;\n+\t  map_list_ptr->map_list_map = ptr;\n+\n+\t  while ((ch = getc (f)) != '\\n')\n+\t    if (ch == EOF)\n+\t      break;\n+\t}\n+      fclose (f);\n+    }\n+  \n+  map_list_ptr->map_list_next = CPP_OPTION (pfile, map_list);\n+  CPP_OPTION (pfile, map_list) = map_list_ptr;\n+\n+  return map_list_ptr->map_list_map;\n+}  \n+\n+/* Remap NAME based on the file_name_map (if any) for LOC. */\n+\n+static char *\n+remap_filename (pfile, name, loc)\n+     cpp_reader *pfile;\n+     char *name;\n+     struct file_name_list *loc;\n+{\n+  struct file_name_map *map;\n+  const char *from, *p, *dir;\n+\n+  if (! loc->name_map)\n+    loc->name_map = read_name_map (pfile,\n+\t\t\t\t   loc->name\n+\t\t\t\t   ? loc->name : \".\");\n+\n+  if (loc->name_map == (struct file_name_map *)-1)\n+    return name;\n+  \n+  from = name + strlen (loc->name) + 1;\n+  \n+  for (map = loc->name_map; map; map = map->map_next)\n+    if (!strcmp (map->map_from, from))\n+      return map->map_to;\n+\n+  /* Try to find a mapping file for the particular directory we are\n+     looking in.  Thus #include <sys/types.h> will look up sys/types.h\n+     in /usr/include/header.gcc and look up types.h in\n+     /usr/include/sys/header.gcc.  */\n+  p = strrchr (name, '/');\n+  if (!p)\n+    p = name;\n+  if (loc && loc->name\n+      && strlen (loc->name) == (size_t) (p - name)\n+      && !strncmp (loc->name, name, p - name))\n+    /* FILENAME is in SEARCHPTR, which we've already checked.  */\n+    return name;\n+\n+  if (p == name)\n+    {\n+      dir = \".\";\n+      from = name;\n+    }\n+  else\n+    {\n+      char * newdir = (char *) alloca (p - name + 1);\n+      memcpy (newdir, name, p - name);\n+      newdir[p - name] = '\\0';\n+      dir = newdir;\n+      from = p + 1;\n+    }\n+  \n+  for (map = read_name_map (pfile, dir); map; map = map->map_next)\n+    if (! strcmp (map->map_from, name))\n+      return map->map_to;\n+\n+  return name;\n+}\n+\n /* Given a path FNAME, extract the directory component and place it\n    onto the actual_dirs list.  Return a pointer to the allocated\n    file_name_list structure.  These structures are used to implement\n@@ -919,7 +859,7 @@ actual_directory (pfile, fname)\n   x->nlen = dlen;\n   x->next = CPP_OPTION (pfile, quote_include);\n   x->alloc = pfile->actual_dirs;\n-  x->sysp = CPP_BUFFER (pfile)->system_header_p;\n+  x->sysp = CPP_BUFFER (pfile)->inc->sysp;\n   x->name_map = NULL;\n \n   pfile->actual_dirs = x;"}, {"sha": "d82c2850809895da68cc7c5bb5db0a8f369a464a", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -1148,7 +1148,7 @@ special_symbol (pfile, hp)\n     case T_STDC:\n #ifdef STDC_0_IN_SYSTEM_HEADERS\n       ip = cpp_file_buffer (pfile);\n-      if (ip && ip->system_header_p\n+      if (ip && ip->inc->sysp\n \t  && !cpp_defined (pfile, DSC(\"__STRICT_ANSI__\")))\n \t{\n \t  CPP_PUTC (pfile, '0');"}, {"sha": "967dcef8ff434031715d5aeb2c5b13a612a9d58a", "filename": "gcc/cpphash.h", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -53,27 +53,27 @@ struct file_name_list\n };\n #define ABSOLUTE_PATH ((struct file_name_list *)-1)\n \n-/* This structure is used for the table of all includes.  It is\n-   indexed by the `short name' (the name as it appeared in the\n-   #include statement) which is stored in *nshort.  */\n-struct ihash\n+/* This structure is used for the table of all includes.  */\n+struct include_file\n {\n-  /* Next file with the same short name but a\n-     different (partial) pathname). */\n-  struct ihash *next_this_file;\n-\n-  /* Location of the file in the include search path.\n-     Used for include_next and to detect redundant includes. */\n-  struct file_name_list *foundhere;\n-\n-  unsigned int hash;\t\t/* save hash value for future reference */\n-  const char *nshort;\t\t/* name of file as referenced in #include;\n-\t\t\t\t   points into name[]  */\n+  const char *name;\t\t/* actual path name of file */\n   const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n-  const char name[1];\t\t/* (partial) pathname of file */\n+  const struct file_name_list *foundhere;\n+\t\t\t\t/* location in search path where file was\n+\t\t\t\t   found, for #include_next */\n+  int fd;\t\t\t/* file descriptor possibly open on file */\n+  unsigned char before;\t\t/* file has been included before */\n+  unsigned char sysp;\t\t/* file is a system header */\n };\n-typedef struct ihash IHASH;\n-#define NEVER_REINCLUDE ((const cpp_hashnode *)-1)\n+\n+/* The cmacro works like this: If it's NULL, the file is to be\n+   included again.  If it's NEVER_REREAD, the file is never to be\n+   included again.  Otherwise it is a macro hashnode, and the file is\n+   to be included again if the macro is not defined.  */\n+#define NEVER_REREAD ((const cpp_hashnode *)-1)\n+#define DO_NOT_REREAD(inc) \\\n+((inc)->cmacro && \\\n+ ((inc)->cmacro == NEVER_REREAD || (inc)->cmacro->type != T_VOID))\n \n /* Character classes.\n    If the definition of `numchar' looks odd to you, please look up the\n@@ -143,10 +143,11 @@ extern unsigned char _cpp_IStable[256];\n \n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n #define CPP_TRADITIONAL(PFILE) CPP_OPTION (PFILE, traditional)\n-#define CPP_PEDANTIC(PFILE) \\\n-  (CPP_OPTION (PFILE, pedantic) && !CPP_BUFFER (PFILE)->system_header_p)\n+#define CPP_IN_SYSTEM_HEADER(PFILE) (cpp_file_buffer (PFILE)->inc->sysp)\n+#define CPP_PEDANTIC(PF) \\\n+  (CPP_OPTION (PF, pedantic) && !CPP_IN_SYSTEM_HEADER (PF))\n #define CPP_WTRADITIONAL(PF) \\\n-  (CPP_OPTION (PF, warn_traditional) && !CPP_BUFFER (PF)->system_header_p)\n+  (CPP_OPTION (PF, warn_traditional) && !CPP_IN_SYSTEM_HEADER (PF))\n \n /* CPP_IS_MACRO_BUFFER is true if the buffer contains macro expansion.\n    (Note that it is false while we're expanding macro *arguments*.) */\n@@ -192,8 +193,8 @@ extern void _cpp_simplify_pathname\tPARAMS ((char *));\n extern void _cpp_execute_include\tPARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t\t unsigned int, int,\n \t\t\t\t\t\t struct file_name_list *));\n-extern void _cpp_init_include_hash\tPARAMS ((cpp_reader *));\n-extern const char *_cpp_fake_ihash\tPARAMS ((cpp_reader *, const char *));\n+extern void _cpp_init_include_table\tPARAMS ((cpp_reader *));\n+extern const char *_cpp_fake_include\tPARAMS ((cpp_reader *, const char *));\n \n /* In cppexp.c */\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n@@ -234,6 +235,10 @@ extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));\n extern void _cpp_unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n extern void _cpp_check_directive        PARAMS ((cpp_toklist *, cpp_token *));\n \n+/* Utility routines and macros.  */\n+#define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n+#define xnewvec(T, N)\t(T *) xmalloc (sizeof(T) * (N))\n+\n /* These are inline functions instead of macros so we can get type\n    checking.  */\n "}, {"sha": "e21c566f6521419b73e254f8f6441eb335b4e58d", "filename": "gcc/cppinit.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -22,6 +22,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"hashtab.h\"\n+#include \"splay-tree.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"output.h\"\n@@ -551,7 +552,7 @@ cpp_reader_init (pfile)\n     (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n \n   _cpp_init_macro_hash (pfile);\n-  _cpp_init_include_hash (pfile);\n+  _cpp_init_include_table (pfile);\n }\n \n /* Initialize a cpp_printer structure.  As a side effect, open the\n@@ -605,7 +606,7 @@ cpp_cleanup (pfile)\n     deps_free (pfile->deps);\n \n   htab_delete (pfile->hashtab);\n-  htab_delete (pfile->all_include_files);\n+  splay_tree_delete (pfile->all_include_files);\n }\n \n "}, {"sha": "b7f6da5181b9196826a53c5e3d97bff7cc197192", "filename": "gcc/cpplex.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -211,7 +211,7 @@ cpp_pop_buffer (pfile)\n   if (ACTIVE_MARK_P (pfile))\n     cpp_ice (pfile, \"mark active in cpp_pop_buffer\");\n \n-  if (buf->ihash)\n+  if (buf->inc)\n     {\n       _cpp_unwind_if_stack (pfile, buf);\n       if (buf->buf)\n@@ -220,10 +220,17 @@ cpp_pop_buffer (pfile)\n \tpfile->system_include_depth--;\n       if (pfile->potential_control_macro)\n \t{\n-\t  buf->ihash->cmacro = pfile->potential_control_macro;\n+\t  if (buf->inc->cmacro != NEVER_REREAD)\n+\t    buf->inc->cmacro = pfile->potential_control_macro;\n \t  pfile->potential_control_macro = 0;\n \t}\n       pfile->input_stack_listing_current = 0;\n+      /* If the file will not be included again, then close it.  */\n+      if (DO_NOT_REREAD (buf->inc))\n+\t{\n+\t  close (buf->inc->fd);\n+\t  buf->inc->fd = -1;\n+\t}\n     }\n   else if (buf->macro)\n     {\n@@ -321,13 +328,13 @@ output_line_command (pfile, print, line)\n   if (CPP_OPTION (pfile, cplusplus))\n     fprintf (print->outf, \"# %u \\\"%s\\\"%s%s%s\\n\", line, ip->nominal_fname,\n \t     codes[change],\n-\t     ip->system_header_p ? \" 3\" : \"\",\n-\t     (ip->system_header_p == 2) ? \" 4\" : \"\");\n+\t     ip->inc->sysp ? \" 3\" : \"\",\n+\t     (ip->inc->sysp == 2) ? \" 4\" : \"\");\n   else\n #endif\n     fprintf (print->outf, \"# %u \\\"%s\\\"%s%s\\n\", line, ip->nominal_fname,\n \t     codes[change],\n-\t     ip->system_header_p ? \" 3\" : \"\");\n+\t     ip->inc->sysp ? \" 3\" : \"\");\n   print->lineno = line;\n }\n \n@@ -516,7 +523,7 @@ cpp_file_buffer (pfile)\n   cpp_buffer *ip;\n \n   for (ip = CPP_BUFFER (pfile); ip; ip = CPP_PREV_BUFFER (ip))\n-    if (ip->ihash != NULL)\n+    if (ip->inc != NULL)\n       return ip;\n   return NULL;\n }\n@@ -914,7 +921,7 @@ skip_comment (pfile, m)\n     }\n   else if (m == '/' && PEEKC() == '/')\n     {\n-      if (CPP_BUFFER (pfile)->system_header_p)\n+      if (CPP_IN_SYSTEM_HEADER (pfile))\n \t{\n \t  /* We silently allow C++ comments in system headers, irrespective\n \t     of conformance mode, because lots of busted systems do that\n@@ -2965,7 +2972,7 @@ _cpp_lex_line (pfile, list)\n \t\t     irrespective of conformance mode, because lots of\n \t\t     broken systems do that and trying to clean it up\n \t\t     in fixincludes is a nightmare.  */\n-\t\t  if (buffer->system_header_p)\n+\t\t  if (CPP_IN_SYSTEM_HEADER (pfile))\n \t\t    goto do_line_comment;\n \t\t  else if (CPP_OPTION (pfile, cplusplus_comments))\n \t\t    {"}, {"sha": "3fc39dc06a47078649b201450152fc4013a96862", "filename": "gcc/cpplib.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -214,7 +214,7 @@ _cpp_handle_directive (pfile)\n \treturn 0;\n \n       if (CPP_PEDANTIC (pfile)\n-\t  && CPP_BUFFER (pfile)->ihash\n+\t  && CPP_BUFFER (pfile)->inc\n \t  && ! CPP_OPTION (pfile, preprocessed))\n \tcpp_pedwarn (pfile, \"# followed by integer\");\n       i = T_LINE;\n@@ -463,7 +463,7 @@ do_import (pfile)\n   U_CHAR *token;\n \n   if (CPP_OPTION (pfile, warn_import)\n-      && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n+      && !CPP_IN_SYSTEM_HEADER (pfile) && !pfile->import_warning)\n     {\n       pfile->import_warning = 1;\n       cpp_warning (pfile,\n@@ -508,8 +508,8 @@ do_include_next (pfile)\n      file like any other included source, but generate a warning.  */\n   if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)))\n     {\n-      if (CPP_BUFFER (pfile)->ihash->foundhere != ABSOLUTE_PATH)\n-\tsearch_start = CPP_BUFFER (pfile)->ihash->foundhere->next;\n+      if (CPP_BUFFER (pfile)->inc->foundhere)\n+\tsearch_start = CPP_BUFFER (pfile)->inc->foundhere->next;\n     }\n   else\n     cpp_warning (pfile, \"#include_next in primary source file\");\n@@ -603,23 +603,23 @@ do_line (pfile)\n \t  if (action_number == 1)\n \t    {\n \t      pfile->buffer_stack_depth++;\n-\t      ip->system_header_p = 0;\n+\t      ip->inc->sysp = 0;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  else if (action_number == 2)\n \t    {\n \t      pfile->buffer_stack_depth--;\n-\t      ip->system_header_p = 0;\n+\t      ip->inc->sysp = 0;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  if (action_number == 3)\n \t    {\n-\t      ip->system_header_p = 1;\n+\t      ip->inc->sysp = 1;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  if (action_number == 4)\n \t    {\n-\t      ip->system_header_p = 2;\n+\t      ip->inc->sysp = 2;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t}\n@@ -628,10 +628,10 @@ do_line (pfile)\n       \n       if (strcmp ((const char *)fname, ip->nominal_fname))\n \t{\n-\t  if (!strcmp ((const char *)fname, ip->ihash->name))\n-\t    ip->nominal_fname = ip->ihash->name;\n+\t  if (!strcmp ((const char *)fname, ip->inc->name))\n+\t    ip->nominal_fname = ip->inc->name;\n \t  else\n-\t    ip->nominal_fname = _cpp_fake_ihash (pfile, (const char *)fname);\n+\t    ip->nominal_fname = _cpp_fake_include (pfile, (const char *)fname);\n \t}\n     }\n   else if (token != CPP_VSPACE && token != CPP_EOF)\n@@ -868,13 +868,13 @@ do_pragma_once (pfile)\n \n   /* Allow #pragma once in system headers, since that's not the user's\n      fault.  */\n-  if (!ip->system_header_p)\n+  if (!CPP_IN_SYSTEM_HEADER (pfile))\n     cpp_warning (pfile, \"#pragma once is obsolete\");\n       \n   if (CPP_PREV_BUFFER (ip) == NULL)\n     cpp_warning (pfile, \"#pragma once outside include file\");\n   else\n-    ip->ihash->cmacro = NEVER_REINCLUDE;\n+    ip->inc->cmacro = NEVER_REREAD;\n \n   return 1;\n }\n@@ -978,7 +978,7 @@ do_pragma_system_header (pfile)\n   if (CPP_PREV_BUFFER (ip) == NULL)\n     cpp_warning (pfile, \"#pragma system_header outside include file\");\n   else\n-    ip->system_header_p = 1;\n+    ip->inc->sysp = 1;\n \n   return 1;\n }"}, {"sha": "e79c2c8b74244daf22eb96a984992eaea5ae55a4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31a6508eedf17dc50388f1694bc131bd965004f/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c31a6508eedf17dc50388f1694bc131bd965004f", "patch": "@@ -233,9 +233,9 @@ struct cpp_buffer\n   /* Actual directory of this file, used only for \"\" includes */\n   struct file_name_list *actual_dir;\n \n-  /* Pointer into the include hash table.  Used for include_next and\n+  /* Pointer into the include table.  Used for include_next and\n      to record control macros. */\n-  struct ihash *ihash;\n+  struct include_file *inc;\n \n   /* If the buffer is the expansion of a macro, this points to the\n      macro's hash table entry.  */\n@@ -248,9 +248,6 @@ struct cpp_buffer\n   /* Line number at line_base (above). */\n   unsigned int lineno;\n \n-  /* True if this is a header file included using <FILENAME>.  */\n-  char system_header_p;\n-\n   /* True if buffer contains escape sequences.\n      Currently there are two kinds:\n      \"\\r-\" means following identifier should not be macro-expanded.\n@@ -499,7 +496,7 @@ struct cpp_reader\n   struct htab *hashtab;\n \n   /* Hash table of other included files.  See cppfiles.c */\n-  struct htab *all_include_files;\n+  struct splay_tree_s *all_include_files;\n \n   /* Chain of `actual directory' file_name_list entries,\n      for \"\" inclusion. */"}]}