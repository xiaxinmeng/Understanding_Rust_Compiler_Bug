{"sha": "0720f6fbcd82afb4f87d9822af12738cef51be16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcyMGY2ZmJjZDgyYWZiNGY4N2Q5ODIyYWYxMjczOGNlZjUxYmUxNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-17T09:30:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-08-17T09:30:15Z"}, "message": "stmt.c (expand_end_loop): Tidy.\n\n        * stmt.c (expand_end_loop): Tidy.  Allow unconditional\n        jumps out of the loop to be treated as part of the exit test.\n\nFrom-SVN: r21782", "tree": {"sha": "efa4b7eb799766fb0924c25c6c47435b681d74bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efa4b7eb799766fb0924c25c6c47435b681d74bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0720f6fbcd82afb4f87d9822af12738cef51be16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0720f6fbcd82afb4f87d9822af12738cef51be16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0720f6fbcd82afb4f87d9822af12738cef51be16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0720f6fbcd82afb4f87d9822af12738cef51be16/comments", "author": null, "committer": null, "parents": [{"sha": "804a4e13f8c8f010adf3db2a0f20e424d4edc0e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804a4e13f8c8f010adf3db2a0f20e424d4edc0e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804a4e13f8c8f010adf3db2a0f20e424d4edc0e0"}], "stats": {"total": 84, "additions": 51, "deletions": 33}, "files": [{"sha": "fae6f12c17c636e9870a850ce9a0241d65f69360", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0720f6fbcd82afb4f87d9822af12738cef51be16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0720f6fbcd82afb4f87d9822af12738cef51be16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0720f6fbcd82afb4f87d9822af12738cef51be16", "patch": "@@ -1,3 +1,8 @@\n+Mon Aug 17 10:28:52 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* stmt.c (expand_end_loop): Tidy.  Allow unconditional\n+\tjumps out of the loop to be treated as part of the exit test.\n+\n Mon Aug 17 10:06:11 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \t\t\t  Jeff Law <law@cygnus.com>\n "}, {"sha": "61766bf13ce2c26ad1b0324feb0d53fecba825ea", "filename": "gcc/stmt.c", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0720f6fbcd82afb4f87d9822af12738cef51be16/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0720f6fbcd82afb4f87d9822af12738cef51be16/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=0720f6fbcd82afb4f87d9822af12738cef51be16", "patch": "@@ -1911,13 +1911,8 @@ expand_loop_continue_here ()\n void\n expand_end_loop ()\n {\n-  register rtx insn;\n-  register rtx start_label;\n-  rtx last_test_insn = 0;\n-  int num_insns = 0;\n-    \n-  insn = get_last_insn ();\n-  start_label = loop_stack->data.loop.start_label;\n+  rtx start_label = loop_stack->data.loop.start_label;\n+  rtx insn = get_last_insn ();\n \n   /* Mark the continue-point at the top of the loop if none elsewhere.  */\n   if (start_label == loop_stack->data.loop.continue_label)\n@@ -1938,7 +1933,7 @@ expand_end_loop ()\n          if (test) goto end_label;\n \t body;\n \t goto start_label;\n-\t end_label;\n+\t end_label:\n \t \n      transform it to look like:\n \n@@ -1948,10 +1943,11 @@ expand_end_loop ()\n \t start_label:\n \t if (test) goto end_label;\n \t goto newstart_label;\n-\t end_label;\n+\t end_label:\n \n      Here, the `test' may actually consist of some reasonably complex\n      code, terminating in a test.  */\n+\n   if (optimize\n       &&\n       ! (GET_CODE (insn) == JUMP_INSN\n@@ -1960,6 +1956,8 @@ expand_end_loop ()\n \t && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE))\n     {\n       int eh_regions = 0;\n+      int num_insns = 0;\n+      rtx last_test_insn = NULL_RTX;\n \n       /* Scan insns from the top of the loop looking for a qualified\n \t conditional exit.  */\n@@ -2036,31 +2034,46 @@ expand_end_loop ()\n \t        So we don't look for tests within an EH region.  */\n \t    continue;\n \n-\t  if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) == SET\n-\t      && SET_DEST (PATTERN (insn)) == pc_rtx\n-\t      && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE\n-\t      && ((GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 1)) == LABEL_REF\n-\t\t   && ((XEXP (XEXP (SET_SRC (PATTERN (insn)), 1), 0)\n-\t\t\t== loop_stack->data.loop.end_label)\n-\t\t       || (XEXP (XEXP (SET_SRC (PATTERN (insn)), 1), 0)\n-\t\t\t   == loop_stack->data.loop.alt_end_label)))\n-\t\t  || (GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 2)) == LABEL_REF\n-\t\t      && ((XEXP (XEXP (SET_SRC (PATTERN (insn)), 2), 0)\n-\t\t\t   == loop_stack->data.loop.end_label)\n-\t\t\t  || (XEXP (XEXP (SET_SRC (PATTERN (insn)), 2), 0)\n-\t\t\t      == loop_stack->data.loop.alt_end_label)))))\n-\t    last_test_insn = insn;\n-\n-\t  if (last_test_insn == 0 && GET_CODE (insn) == JUMP_INSN\n+\t  if (GET_CODE (insn) == JUMP_INSN \n \t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && SET_DEST (PATTERN (insn)) == pc_rtx\n-\t      && GET_CODE (SET_SRC (PATTERN (insn))) == LABEL_REF\n-\t      && ((XEXP (SET_SRC (PATTERN (insn)), 0)\n-\t\t   == loop_stack->data.loop.end_label)\n-\t\t  || (XEXP (SET_SRC (PATTERN (insn)), 0)\n-\t\t      == loop_stack->data.loop.alt_end_label)))\n-\t    /* Include BARRIER.  */\n-\t    last_test_insn = NEXT_INSN (insn);\n+\t      && SET_DEST (PATTERN (insn)) == pc_rtx)\n+\t    {\n+\t      /* This is indeed a jump.  */\n+\t      rtx dest1 = NULL_RTX;\n+\t      rtx dest2 = NULL_RTX;\n+\t      rtx potential_last_test;\n+\t      if (GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n+\t\t{\n+\t\t  /* A conditional jump.  */\n+\t\t  dest1 = XEXP (SET_SRC (PATTERN (insn)), 1);\n+\t\t  dest2 = XEXP (SET_SRC (PATTERN (insn)), 2);\n+\t\t  potential_last_test = insn;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* An unconditional jump.  */\n+\t\t  dest1 = SET_SRC (PATTERN (insn));\n+\t\t  /* Include the BARRIER after the JUMP.  */\n+\t\t  potential_last_test = NEXT_INSN (insn);\n+\t\t}\n+\n+\t      do {\n+\t\tif (dest1 && GET_CODE (dest1) == LABEL_REF\n+\t\t    && ((XEXP (dest1, 0) \n+\t\t\t == loop_stack->data.loop.alt_end_label)\n+\t\t\t|| (XEXP (dest1, 0) \n+\t\t\t    == loop_stack->data.loop.end_label)))\n+\t\t  {\n+\t\t    last_test_insn = potential_last_test;\n+\t\t    break;\n+\t\t  }\n+\n+\t\t/* If this was a conditional jump, there may be\n+\t\t   another label at which we should look.  */\n+\t\tdest1 = dest2;\n+\t\tdest2 = NULL_RTX;\n+\t      } while (dest1);\n+\t    }\n \t}\n \n       if (last_test_insn != 0 && last_test_insn != get_last_insn ())"}]}