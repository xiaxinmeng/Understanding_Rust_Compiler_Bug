{"sha": "9733e4ee3172af5cf90267abf4a9ce8e082c058b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczM2U0ZWUzMTcyYWY1Y2Y5MDI2N2FiZjRhOWNlOGUwODJjMDU4Yg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-05-10T12:33:07Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-05-10T12:33:07Z"}, "message": "InputStreamReader.java (read): If length is 0, return 0.\n\n\t* java/io/InputStreamReader.java (read): If length is 0, return\n\t0.  Reset `wpos' and `wcount' when buffer has been filled and\n\temptied.\n\t* java/util/Properties.java (save): Removed `FIXME' comment.\n\t(load): Invalid characters in \\u now treated as terminators.\n\tMake sure to append character resulting from `\\' handling.\n\tCast to `char' when appending to key or value.\n\t(skip_ws): Inverted test for whitespace.\n\nFrom-SVN: r26862", "tree": {"sha": "1f3955d0c2dba39eb67bebb27fc42978c9289425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f3955d0c2dba39eb67bebb27fc42978c9289425"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9733e4ee3172af5cf90267abf4a9ce8e082c058b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9733e4ee3172af5cf90267abf4a9ce8e082c058b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9733e4ee3172af5cf90267abf4a9ce8e082c058b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9733e4ee3172af5cf90267abf4a9ce8e082c058b/comments", "author": null, "committer": null, "parents": [{"sha": "05e0b2f47cf953ec7db7d9dede697420c9e48748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05e0b2f47cf953ec7db7d9dede697420c9e48748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05e0b2f47cf953ec7db7d9dede697420c9e48748"}], "stats": {"total": 41, "additions": 31, "deletions": 10}, "files": [{"sha": "7cd285ed976ebdaec9084869c3fa29e3a137a2b6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9733e4ee3172af5cf90267abf4a9ce8e082c058b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9733e4ee3172af5cf90267abf4a9ce8e082c058b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9733e4ee3172af5cf90267abf4a9ce8e082c058b", "patch": "@@ -1,5 +1,15 @@\n 1999-05-10  Tom Tromey  <tromey@cygnus.com>\n \n+\t* java/io/InputStreamReader.java (read): If length is 0, return\n+\t0.  Reset `wpos' and `wcount' when buffer has been filled and\n+\temptied.\n+\n+\t* java/util/Properties.java (save): Removed `FIXME' comment.\n+\t(load): Invalid characters in \\u now treated as terminators.\n+\tMake sure to append character resulting from `\\' handling.\n+\tCast to `char' when appending to key or value.\n+\t(skip_ws): Inverted test for whitespace.\n+\n \t* java/io/RandomAccessFile.java (RandomAccessFile): Removed\n \t`FIXME' comment.\n \t(readLine): Likewise."}, {"sha": "ae5e2c7b0eb016f13d6e2f7130ed1f6745997e67", "filename": "libjava/java/io/InputStreamReader.java", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9733e4ee3172af5cf90267abf4a9ce8e082c058b/libjava%2Fjava%2Fio%2FInputStreamReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9733e4ee3172af5cf90267abf4a9ce8e082c058b/libjava%2Fjava%2Fio%2FInputStreamReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStreamReader.java?ref=9733e4ee3172af5cf90267abf4a9ce8e082c058b", "patch": "@@ -111,6 +111,8 @@ public int read(char buf[], int offset, int length) throws IOException\n \t  }\n \telse\n \t  {\n+\t    if (length == 0)\n+\t      return 0;\n \t    for (;;)\n \t      {\n \t\tin.mark(1);\n@@ -141,6 +143,11 @@ public int read() throws IOException\n \t    wpos = 0;\n \t    wcount = 0;\n \t  }\n+\telse if (wavail == 0)\n+\t  {\n+\t    wpos = 0;\n+\t    wcount = 0;\n+\t  }\n \tint count = read(work, wpos, work.length-wpos);\n \tif (count <= 0)\n \t  return -1;"}, {"sha": "2988e7be5fe3cd0b07931b2dcfd9072068903e0b", "filename": "libjava/java/util/Properties.java", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9733e4ee3172af5cf90267abf4a9ce8e082c058b/libjava%2Fjava%2Futil%2FProperties.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9733e4ee3172af5cf90267abf4a9ce8e082c058b/libjava%2Fjava%2Futil%2FProperties.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FProperties.java?ref=9733e4ee3172af5cf90267abf4a9ce8e082c058b", "patch": "@@ -103,7 +103,7 @@ private final boolean skip_ws (PushbackReader reader) throws IOException\n \t  // FIXME: we use our own definition of whitespace.\n \t  // Character.isWhitespace includes newlines, which we don't\n \t  // want.  Character.isSpaceChar doesn't include \\t.\n-\t  if (c == ' ' || c == '\\t')\n+\t  if (c != ' ' && c != '\\t')\n \t    {\n \t      reader.unread(c);\n \t      return true;\n@@ -166,12 +166,12 @@ public synchronized void load (InputStream in) throws IOException\n \t\t  reader.unread(c);\n \t\t  break;\n \t\t}\n-\t      // FIXME: again, our own definitino of whitespace.\n+\t      // FIXME: again, our own definition of whitespace.\n \t      if (c == ' ' || c == '\\t' || c == ':' || c == '=')\n \t\tbreak;\n \n \t      first_char = false;\n-\t      key.append(c);\n+\t      key.append((char) c);\n \t    }\n \n \t  // Found end of key.  Skip whitespace.  If the terminator\n@@ -226,10 +226,14 @@ public synchronized void load (InputStream in) throws IOException\n \t\t\t  if (x == -1)\n \t\t\t    return;\n \t\t\t  int d = Character.digit((char) x, 16);\n-\t\t\t  // FIXME: what to do here?  We call it an\n-\t\t\t  // error.\n+\t\t\t  // We follow JDK here: invalid characters\n+\t\t\t  // are treated as terminators.\n \t\t\t  if (d == -1)\n-\t\t\t    throw new IOException ();\n+\t\t\t    {\n+\t\t\t      value.append((char) c);\n+\t\t\t      c = x;\n+\t\t\t      break;\n+\t\t\t    }\n \t\t\t  c <<= 4;\n \t\t\t  c |= d;\n \t\t\t}\n@@ -238,8 +242,7 @@ public synchronized void load (InputStream in) throws IOException\n \t\t      // Nothing.\n \t\t    }\n \t\t}\n-\t      else\n-\t\tvalue.append(c);\n+\t      value.append((char) c);\n \t    }\n \n \t  put (key.toString(), value.toString());\n@@ -290,7 +293,8 @@ public synchronized void save (OutputStream out, String comment)\n \t{\n \t  if (comment != null)\n \t    {\n-\t      // FIXME: what if COMMENT contains newlines?\n+\t      // We just lose if COMMENT contains a newline.  This is\n+\t      // what JDK 1.1 does.\n \t      output.write(\"#\");\n \t      output.write(comment);\n \t      output.write(newline);\n@@ -309,7 +313,7 @@ public synchronized void save (OutputStream out, String comment)\n \t      // characters.  But it also doesn't say we should encode\n \t      // it in any way.\n \t      // FIXME: if key contains ':', '=', or whitespace, must\n-\t      // quote it here.\n+\t      // quote it here.  Note that JDK 1.1 does not do this.\n \t      output.write(key);\n \t      output.write(\"=\");\n "}]}