{"sha": "87bd8b706752c8ecb0372595e9eace6c21c03419", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdiZDhiNzA2NzUyYzhlY2IwMzcyNTk1ZTllYWNlNmMyMWMwMzQxOQ==", "commit": {"author": {"name": "Aaron Luchko", "email": "aluchko@gcc.gnu.org", "date": "2005-07-12T18:30:25Z"}, "committer": {"name": "Aaron Luchko", "email": "aluchko@gcc.gnu.org", "date": "2005-07-12T18:30:25Z"}, "message": "ObjectReferenceCommandSet.java: New file.\n\n        * gnu/classpath/jdwp/processor/ObjectReferenceCommandSet.java:\n        New file.\n\nFrom-SVN: r101935", "tree": {"sha": "313372cdc6bb86ae13b68fc51da47ee7a507c1de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/313372cdc6bb86ae13b68fc51da47ee7a507c1de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87bd8b706752c8ecb0372595e9eace6c21c03419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87bd8b706752c8ecb0372595e9eace6c21c03419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87bd8b706752c8ecb0372595e9eace6c21c03419", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87bd8b706752c8ecb0372595e9eace6c21c03419/comments", "author": null, "committer": null, "parents": [{"sha": "817a82551ec74a6c6f1e1a94c2f42adefdce0240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/817a82551ec74a6c6f1e1a94c2f42adefdce0240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/817a82551ec74a6c6f1e1a94c2f42adefdce0240"}], "stats": {"total": 262, "additions": 258, "deletions": 4}, "files": [{"sha": "d05e0cd2b7e8ff4ea19315abcb3736570f555bbe", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87bd8b706752c8ecb0372595e9eace6c21c03419/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87bd8b706752c8ecb0372595e9eace6c21c03419/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=87bd8b706752c8ecb0372595e9eace6c21c03419", "patch": "@@ -1,4 +1,9 @@\n-2005-07-06  Colin Walters  <walters@verbum.org>\n+2005-07-12  Aaron Luchko  <aluchko@redhat.com>\n+\n+\t* gnu/classpath/jdwp/processor/ObjectReferenceCommandSet.java:\n+\tNew file.\n+\n+2005-07-08  Colin Walters  <walters@verbum.org>\n \n \t* verify.cc (class _Jv_BytecodeVerifier) <op_new>: Don't\n \tcheck for abstract classes or interfaces here; JVM spec\n@@ -8,9 +13,9 @@\n \n 2005-07-08  Andrew Haley  <aph@redhat.com>\n \n-        * posix-threads.cc (_Jv_ThreadSetPriority): Use SCHED_OTHER\n-        (regular, non-realtime scheduling), not SCHED_RR (realtime,\n-        round-robin).\n+\t* posix-threads.cc (_Jv_ThreadSetPriority): Use SCHED_OTHER\n+\t(regular, non-realtime scheduling), not SCHED_RR (realtime,\n+\tround-robin).\n \n 2005-07-07  Aaron Luchko  <aluchko@redhat.com>\n "}, {"sha": "38bb0cdbf962b8b8977f45a0d915faa2cdf09953", "filename": "libjava/gnu/classpath/jdwp/processor/ObjectReferenceCommandSet.java", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87bd8b706752c8ecb0372595e9eace6c21c03419/libjava%2Fgnu%2Fclasspath%2Fjdwp%2Fprocessor%2FObjectReferenceCommandSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87bd8b706752c8ecb0372595e9eace6c21c03419/libjava%2Fgnu%2Fclasspath%2Fjdwp%2Fprocessor%2FObjectReferenceCommandSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2Fjdwp%2Fprocessor%2FObjectReferenceCommandSet.java?ref=87bd8b706752c8ecb0372595e9eace6c21c03419", "patch": "@@ -0,0 +1,249 @@\n+/* ObjectReferenceCommandSet.java -- lass to implement the ObjectReference\n+   Command Set\n+   Copyright (C) 2005 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.classpath.jdwp.processor;\n+\n+import gnu.classpath.jdwp.IVirtualMachine;\n+import gnu.classpath.jdwp.Jdwp;\n+import gnu.classpath.jdwp.JdwpConstants;\n+import gnu.classpath.jdwp.exception.InvalidFieldException;\n+import gnu.classpath.jdwp.exception.JdwpException;\n+import gnu.classpath.jdwp.exception.JdwpInternalErrorException;\n+import gnu.classpath.jdwp.exception.NotImplementedException;\n+import gnu.classpath.jdwp.id.IdManager;\n+import gnu.classpath.jdwp.id.ObjectId;\n+import gnu.classpath.jdwp.id.ReferenceTypeId;\n+import gnu.classpath.jdwp.util.Value;\n+import gnu.classpath.jdwp.util.MethodInvoker;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A class representing the ObjectReference Command Set.\n+ * \n+ * @author Aaron Luchko <aluchko@redhat.com>\n+ */\n+public class ObjectReferenceCommandSet implements CommandSet\n+{\n+  // Our hook into the jvm\n+  private final IVirtualMachine vm = Jdwp.getIVirtualMachine();\n+\n+  // Manages all the different ids that are assigned by jdwp\n+  private final IdManager idMan = Jdwp.getIdManager();\n+\n+  public boolean runCommand(ByteBuffer bb, DataOutputStream os, byte command)\n+    throws JdwpException\n+  {\n+    try\n+      {\n+        switch (command)\n+          {\n+          case JdwpConstants.CommandSet.ObjectReference.REFERENCE_TYPE:\n+            executeReferenceType(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ObjectReference.GET_VALUES:\n+            executeGetValues(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ObjectReference.SET_VALUES:\n+            executeSetValues(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ObjectReference.MONITOR_INFO:\n+            executeMonitorInfo(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ObjectReference.INVOKE_METHOD:\n+            executeInvokeMethod(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ObjectReference.DISABLE_COLLECTION:\n+            executeDisableCollection(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ObjectReference.ENABLE_COLLECTION:\n+            executeEnableCollection(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ObjectReference.IS_COLLECTED:\n+            executeIsCollected(bb, os);\n+            break;\n+          default:\n+            throw new NotImplementedException(\"Command \" + command +\n+              \" not found in String Reference Command Set.\");\n+          }\n+      }\n+    catch (IOException ex)\n+      {\n+        // The DataOutputStream we're using isn't talking to a socket at all\n+        // So if we throw an IOException we're in serious trouble\n+        throw new JdwpInternalErrorException(ex);\n+      }\n+    return true;\n+  }\n+\n+  private void executeReferenceType(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ObjectId oid = idMan.readId(bb);\n+    Object obj = oid.getObject();\n+    Class clazz = obj.getClass();\n+    ReferenceTypeId refId = idMan.getReferenceTypeId(clazz);\n+    refId.writeTagged(os);\n+  }\n+\n+  private void executeGetValues(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ObjectId oid = idMan.readId(bb);\n+    Object obj = oid.getObject();\n+\n+    int numFields = bb.getInt();\n+\n+    os.writeInt(numFields); // Looks pointless but this is the protocol\n+\n+    for (int i = 0; i < numFields; i++)\n+      {\n+        Field field = (Field) idMan.readId(bb).getObject();\n+        Value.writeValueFromField(os, field, obj);\n+      }\n+  }\n+\n+  private void executeSetValues(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ObjectId oid = idMan.readId(bb);\n+    Object obj = oid.getObject();\n+\n+    int numFields = bb.getInt();\n+\n+    for (int i = 0; i < numFields; i++)\n+      {\n+        Field field = (Field) idMan.readId(bb).getObject();\n+        Object value = Value.getObj(bb, field);\n+        try\n+          {\n+            field.set(obj, value);\n+          }\n+        catch (IllegalArgumentException ex)\n+          {\n+            // I suppose this would best qualify as an invalid field then\n+            throw new InvalidFieldException(ex);\n+          }\n+        catch (IllegalAccessException ex)\n+          {\n+            // We should be able to access any field\n+            throw new JdwpInternalErrorException(ex);\n+          }\n+      }\n+  }\n+\n+  private void executeMonitorInfo(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException\n+  {\n+    // This command is optional, determined by VirtualMachines CapabilitiesNew\n+    // so we'll leave it till later to implement\n+    throw new NotImplementedException(\n+      \"Command ExecuteMonitorInfo not implemented.\");\n+\n+  }\n+\n+  private void executeInvokeMethod(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ObjectId oid = idMan.readId(bb);\n+    Object obj = oid.getObject();\n+\n+    ObjectId tid = idMan.readId(bb);\n+    Thread thread = (Thread) tid.getObject();\n+\n+    ReferenceTypeId rid = idMan.readReferenceTypeId(bb);\n+    Class clazz = rid.getType();\n+\n+    ObjectId mid = idMan.readId(bb);\n+    Method method = (Method) mid.getObject();\n+\n+    int args = bb.getInt();\n+    Object[] values = new Object[args];\n+\n+    for (int i = 0; i < args; i++)\n+      {\n+        values[i] = Value.getObj(bb);\n+      }\n+\n+    int invokeOptions = bb.getInt();\n+\n+    if ((invokeOptions & JdwpConstants.InvokeOptions.INVOKE_SINGLE_THREADED) != 0)\n+      { // We must suspend all other running threads first\n+        vm.suspendAllThreads();\n+      }\n+    boolean nonVirtual;\n+    if ((invokeOptions & JdwpConstants.InvokeOptions.INVOKE_NONVIRTUAL) != 0)\n+      nonVirtual = true;\n+    else\n+      nonVirtual = false;\n+    MethodInvoker vmi = new MethodInvoker(vm);\n+\n+    vmi.executeMethod(obj, thread, clazz, method, values, nonVirtual);\n+    Object value = vmi.getReturnedValue();\n+    ObjectId exceptionId = vmi.getExceptionId();\n+    \n+    Value.writeValue(os, value);\n+    exceptionId.writeTagged(os);\n+  }\n+\n+  private void executeDisableCollection(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ObjectId oid = idMan.readId(bb);\n+    oid.disableCollection();\n+  }\n+\n+  private void executeEnableCollection(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ObjectId oid = idMan.readId(bb);\n+    oid.enableCollection();\n+  }\n+\n+  private void executeIsCollected(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ObjectId oid = idMan.readId(bb);\n+    boolean collected = oid.isCollected();\n+    os.writeBoolean(collected);\n+  }\n+}"}]}