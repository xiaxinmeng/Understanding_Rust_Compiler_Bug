{"sha": "bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIxZWM0NzczYTAxZTViYmI3Y2I2ZTJmNTNlYTMzOGE3NGE2Nzk3Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-08T15:01:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-08T15:24:15Z"}, "message": "Couple of tweaks to help in LTO mode\n\nThe first tweak is to remove the TREE_OVERFLOW flag on INTEGER_CSTs\nbecause it prevents them from being uniquized in LTO mode.\n\nThe second, unrelated tweak is to canonicalize the packable types made\nby gigi so that at most one per type is present in the GENERIC IL.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Deal\n\twith artificial maximally-sized types designed by access types.\n\t* gcc-interface/utils.c (packable_type_hash): New structure.\n\t(packable_type_hasher): Likewise.\n\t(packable_type_hash_table): New hash table.\n\t(init_gnat_utils): Initialize it.\n\t(destroy_gnat_utils): Destroy it.\n\t(packable_type_hasher::equal): New method.\n\t(hash_packable_type): New static function.\n\t(canonicalize_packable_type): Likewise.\n\t(make_packable_type): Make sure not to use too small a type for the\n\tsize of the new fields.  Canonicalize the type if it is named.", "tree": {"sha": "64f188f766e3f5bf2ddc105a7bc2e6f241f3f838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64f188f766e3f5bf2ddc105a7bc2e6f241f3f838"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f/comments", "author": null, "committer": null, "parents": [{"sha": "c900c70049965fad7fa02aa08f0ac3a67ab99b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c900c70049965fad7fa02aa08f0ac3a67ab99b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c900c70049965fad7fa02aa08f0ac3a67ab99b37"}], "stats": {"total": 149, "additions": 141, "deletions": 8}, "files": [{"sha": "9644e018f3e825f3768a573233fec30ea6779996", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f", "patch": "@@ -1,3 +1,18 @@\n+2020-05-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Deal\n+\twith artificial maximally-sized types designed by access types.\n+\t* gcc-interface/utils.c (packable_type_hash): New structure.\n+\t(packable_type_hasher): Likewise.\n+\t(packable_type_hash_table): New hash table.\n+\t(init_gnat_utils): Initialize it.\n+\t(destroy_gnat_utils): Destroy it.\n+\t(packable_type_hasher::equal): New method.\n+\t(hash_packable_type): New static function.\n+\t(canonicalize_packable_type): Likewise.\n+\t(make_packable_type): Make sure not to use too small a type for the\n+\tsize of the new fields.  Canonicalize the type if it is named.\n+\n 2020-05-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Raise_Error_to_gnu): Always compute a lower"}, {"sha": "a4053eec8397cc5dd785505da5d3ee0e5ae1786a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f", "patch": "@@ -2685,6 +2685,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\tset_reverse_storage_order_on_array_type (gnu_type);\n \t      if (array_type_has_nonaliased_component (gnu_type, gnat_entity))\n \t\tset_nonaliased_component_on_array_type (gnu_type);\n+\n+\t      /* Kludge to remove the TREE_OVERFLOW flag for the sake of LTO\n+\t\t on maximally-sized array types designed by access types.  */\n+\t      if (integer_zerop (TYPE_SIZE (gnu_type))\n+\t\t  && TREE_OVERFLOW (TYPE_SIZE (gnu_type))\n+\t\t  && Is_Itype (gnat_entity)\n+\t\t  && (gnat_temp = Associated_Node_For_Itype (gnat_entity))\n+\t\t  && IN (Nkind (gnat_temp), N_Declaration)\n+\t\t  && Is_Access_Type (Defining_Entity (gnat_temp))\n+\t\t  && Is_Entity_Name (First_Index (gnat_entity))\n+\t\t  && UI_To_Int (RM_Size (Entity (First_Index (gnat_entity))))\n+\t\t     == BITS_PER_WORD)\n+\t\t{\n+\t\t  TYPE_SIZE (gnu_type) = bitsize_zero_node;\n+\t\t  TYPE_SIZE_UNIT (gnu_type) = size_zero_node;\n+\t\t}\n \t    }\n \n \t  /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */"}, {"sha": "9d0014820a5c7faa6493e9298b34405c3a0d57c2", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 110, "deletions": 8, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=bb1ec4773a01e5bbb7cb6e2f53ea338a74a6797f", "patch": "@@ -258,6 +258,29 @@ static GTY(()) vec<tree, va_gc> *builtin_decls;\n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n+/* A hash table of packable types.  It is modelled on the generic type\n+   hash table in tree.c, which must thus be used as a reference.  */\n+\n+struct GTY((for_user)) packable_type_hash\n+{\n+  hashval_t hash;\n+  tree type;\n+};\n+\n+struct packable_type_hasher : ggc_cache_ptr_hash<packable_type_hash>\n+{\n+  static inline hashval_t hash (packable_type_hash *t) { return t->hash; }\n+  static bool equal (packable_type_hash *a, packable_type_hash *b);\n+\n+  static int\n+  keep_cache_entry (packable_type_hash *&t)\n+  {\n+    return ggc_marked_p (t->type);\n+  }\n+};\n+\n+static GTY ((cache)) hash_table<packable_type_hasher> *packable_type_hash_table;\n+\n /* A hash table of padded types.  It is modelled on the generic type\n    hash table in tree.c, which must thus be used as a reference.  */\n \n@@ -333,6 +356,9 @@ init_gnat_utils (void)\n   /* Initialize the association of GNAT nodes to GCC trees as dummies.  */\n   dummy_node_table = ggc_cleared_vec_alloc<tree> (max_gnat_nodes);\n \n+  /* Initialize the hash table of packable types.  */\n+  packable_type_hash_table = hash_table<packable_type_hasher>::create_ggc (512);\n+\n   /* Initialize the hash table of padded types.  */\n   pad_type_hash_table = hash_table<pad_type_hasher>::create_ggc (512);\n }\n@@ -350,6 +376,10 @@ destroy_gnat_utils (void)\n   ggc_free (dummy_node_table);\n   dummy_node_table = NULL;\n \n+  /* Destroy the hash table of packable types.  */\n+  packable_type_hash_table->empty ();\n+  packable_type_hash_table = NULL;\n+\n   /* Destroy the hash table of padded types.  */\n   pad_type_hash_table->empty ();\n   pad_type_hash_table = NULL;\n@@ -983,6 +1013,68 @@ make_aligning_type (tree type, unsigned int align, tree size,\n   return record_type;\n }\n \n+/* Return true iff the packable types are equivalent.  */\n+\n+bool\n+packable_type_hasher::equal (packable_type_hash *t1, packable_type_hash *t2)\n+{\n+  tree type1, type2;\n+\n+  if (t1->hash != t2->hash)\n+    return 0;\n+\n+  type1 = t1->type;\n+  type2 = t2->type;\n+\n+  /* We consider that packable types are equivalent if they have the same\n+     name, size, alignment and RM size.  Taking the mode into account is\n+     redundant since it is determined by the others.  */\n+  return\n+    TYPE_NAME (type1) == TYPE_NAME (type2)\n+    && TYPE_SIZE (type1) == TYPE_SIZE (type2)\n+    && TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n+    && TYPE_ADA_SIZE (type1) == TYPE_ADA_SIZE (type2);\n+}\n+\n+/* Compute the hash value for the packable TYPE.  */\n+\n+static hashval_t\n+hash_packable_type (tree type)\n+{\n+  hashval_t hashcode;\n+\n+  hashcode = iterative_hash_expr (TYPE_NAME (type), 0);\n+  hashcode = iterative_hash_expr (TYPE_SIZE (type), hashcode);\n+  hashcode = iterative_hash_hashval_t (TYPE_ALIGN (type), hashcode);\n+  hashcode = iterative_hash_expr (TYPE_ADA_SIZE (type), hashcode);\n+\n+  return hashcode;\n+}\n+\n+/* Look up the packable TYPE in the hash table and return its canonical version\n+   if it exists; otherwise, insert it into the hash table.  */\n+\n+static tree\n+canonicalize_packable_type (tree type)\n+{\n+  const hashval_t hashcode = hash_packable_type (type);\n+  struct packable_type_hash in, *h, **slot;\n+\n+  in.hash = hashcode;\n+  in.type = type;\n+  slot = packable_type_hash_table->find_slot_with_hash (&in, hashcode, INSERT);\n+  h = *slot;\n+  if (!h)\n+    {\n+      h = ggc_alloc<packable_type_hash> ();\n+      h->hash = hashcode;\n+      h->type = type;\n+      *slot = h;\n+    }\n+\n+  return h->type;\n+}\n+\n /* TYPE is an ARRAY_TYPE that is being used as the type of a field in a packed\n    record.  See if we can rewrite it as a type that has non-BLKmode, which we\n    can pack tighter in the packed record.  If so, return the new type; if not,\n@@ -1062,16 +1154,16 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n     }\n   else\n     {\n-      tree type_size = TYPE_ADA_SIZE (type);\n+      tree ada_size = TYPE_ADA_SIZE (type);\n+\n       /* Do not try to shrink the size if the RM size is not constant.  */\n-      if (TYPE_CONTAINS_TEMPLATE_P (type)\n-\t  || !tree_fits_uhwi_p (type_size))\n+      if (TYPE_CONTAINS_TEMPLATE_P (type) || !tree_fits_uhwi_p (ada_size))\n \treturn type;\n \n       /* Round the RM size up to a unit boundary to get the minimal size\n \t for a BLKmode record.  Give up if it's already the size and we\n \t don't need to lower the alignment.  */\n-      new_size = tree_to_uhwi (type_size);\n+      new_size = tree_to_uhwi (ada_size);\n       new_size = (new_size + BITS_PER_UNIT - 1) & -BITS_PER_UNIT;\n       if (new_size == size && (max_align == 0 || align <= max_align))\n \treturn type;\n@@ -1117,7 +1209,13 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n \t  && TYPE_ADA_SIZE (new_field_type))\n \tnew_field_size = TYPE_ADA_SIZE (new_field_type);\n       else\n-\tnew_field_size = DECL_SIZE (field);\n+\t{\n+\t  new_field_size = DECL_SIZE (field);\n+\n+\t  /* Make sure not to use too small a type for the size.  */\n+\t  if (TYPE_MODE (new_field_type) == BLKmode)\n+\t    new_field_type = TREE_TYPE (field);\n+\t}\n \n       /* This is a layout with full representation, alignment and size clauses\n \t so we simply pass 0 as PACKED like gnat_to_gnu_field in this case.  */\n@@ -1160,8 +1258,8 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n     SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n \t\t\t    DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));\n \n-  /* Try harder to get a packable type if necessary, for example\n-     in case the record itself contains a BLKmode field.  */\n+  /* Try harder to get a packable type if necessary, for example in case\n+     the record itself contains a BLKmode field.  */\n   if (in_record && TYPE_MODE (new_type) == BLKmode)\n     SET_TYPE_MODE (new_type,\n \t\t   mode_for_size_tree (TYPE_SIZE (new_type),\n@@ -1171,7 +1269,11 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n   if (TYPE_MODE (new_type) == BLKmode && new_size >= size && max_align == 0)\n     return type;\n \n-  return new_type;\n+  /* If the packable type is named, we canonicalize it by means of the hash\n+     table.  This is consistent with the language semantics and ensures that\n+     gigi and the middle-end have a common view of these packable types.  */\n+  return\n+    TYPE_NAME (new_type) ? canonicalize_packable_type (new_type) : new_type;\n }\n \n /* Return true if TYPE has an unsigned representation.  This needs to be used"}]}