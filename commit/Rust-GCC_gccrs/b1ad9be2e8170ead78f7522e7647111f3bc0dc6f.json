{"sha": "b1ad9be2e8170ead78f7522e7647111f3bc0dc6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFhZDliZTJlODE3MGVhZDc4Zjc1MjJlNzY0NzExMWYzYmMwZGM2Zg==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2016-08-12T19:30:39Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2016-08-12T19:30:39Z"}, "message": "re PR tree-optimization/71083 (Unaligned bit-field address when predictive commoning)\n\n2016-08-12  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR tree-optimization/71083\n        * tree-predcom.c (ref_at_iteration): Use a COMPONENT_REF for the\n        bitfield access when possible.\n\nFrom-SVN: r239426", "tree": {"sha": "231b359fb9a1ead7ab8a33b1d8993158ba95ea22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/231b359fb9a1ead7ab8a33b1d8993158ba95ea22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7fd82d528e715fabf3688346250d47c20f149665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd82d528e715fabf3688346250d47c20f149665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd82d528e715fabf3688346250d47c20f149665"}], "stats": {"total": 71, "additions": 52, "deletions": 19}, "files": [{"sha": "aeb3f79e6a5f56a947cddad00e08659f0da64b7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1ad9be2e8170ead78f7522e7647111f3bc0dc6f", "patch": "@@ -1,3 +1,9 @@\n+2016-08-12  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR tree-optimization/71083\n+\t* tree-predcom.c (ref_at_iteration): Use a COMPONENT_REF for the\n+\tbitfield access when possible.\n+\n 2016-08-12  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR middle-end/71654"}, {"sha": "096365ad9a10db51b6a84b72332db493386be085", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ad9be2e8170ead78f7522e7647111f3bc0dc6f/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=b1ad9be2e8170ead78f7522e7647111f3bc0dc6f", "patch": "@@ -1365,11 +1365,16 @@ replace_ref_with (gimple *stmt, tree new_tree, bool set, bool in_lhs)\n /* Returns a memory reference to DR in the ITER-th iteration of\n    the loop it was analyzed in.  Append init stmts to STMTS.  */\n \n-static tree \n+static tree\n ref_at_iteration (data_reference_p dr, int iter, gimple_seq *stmts)\n {\n   tree off = DR_OFFSET (dr);\n   tree coff = DR_INIT (dr);\n+  tree ref = DR_REF (dr);\n+  enum tree_code ref_code = ERROR_MARK;\n+  tree ref_type = NULL_TREE;\n+  tree ref_op1 = NULL_TREE;\n+  tree ref_op2 = NULL_TREE;\n   if (iter == 0)\n     ;\n   else if (TREE_CODE (DR_STEP (dr)) == INTEGER_CST)\n@@ -1378,28 +1383,50 @@ ref_at_iteration (data_reference_p dr, int iter, gimple_seq *stmts)\n   else\n     off = size_binop (PLUS_EXPR, off,\n \t\t      size_binop (MULT_EXPR, DR_STEP (dr), ssize_int (iter)));\n-  tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);\n-  addr = force_gimple_operand_1 (unshare_expr (addr), stmts,\n-\t\t\t\t is_gimple_mem_ref_addr, NULL_TREE);\n-  tree alias_ptr = fold_convert (reference_alias_ptr_type (DR_REF (dr)), coff);\n-  tree type = build_aligned_type (TREE_TYPE (DR_REF (dr)),\n-\t\t\t\t  get_object_alignment (DR_REF (dr)));\n   /* While data-ref analysis punts on bit offsets it still handles\n      bitfield accesses at byte boundaries.  Cope with that.  Note that\n-     we cannot simply re-apply the outer COMPONENT_REF because the\n-     byte-granular portion of it is already applied via DR_INIT and\n-     DR_OFFSET, so simply build a BIT_FIELD_REF knowing that the bits\n+     if the bitfield object also starts at a byte-boundary we can simply\n+     replicate the COMPONENT_REF, but we have to subtract the component's\n+     byte-offset from the MEM_REF address first.\n+     Otherwise we simply build a BIT_FIELD_REF knowing that the bits\n      start at offset zero.  */\n-  if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n-      && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n-    {\n-      tree field = TREE_OPERAND (DR_REF (dr), 1);\n-      return build3 (BIT_FIELD_REF, TREE_TYPE (DR_REF (dr)),\n-\t\t     build2 (MEM_REF, type, addr, alias_ptr),\n-\t\t     DECL_SIZE (field), bitsize_zero_node);\n+  if (TREE_CODE (ref) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (ref, 1)))\n+    {\n+      unsigned HOST_WIDE_INT boff;\n+      tree field = TREE_OPERAND (ref, 1);\n+      tree offset = component_ref_field_offset (ref);\n+      ref_type = TREE_TYPE (ref);\n+      boff = tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field));\n+      /* This can occur in Ada.  See the comment in get_bit_range.  */\n+      if (boff % BITS_PER_UNIT != 0\n+\t  || !tree_fits_uhwi_p (offset))\n+\t{\n+\t  ref_code = BIT_FIELD_REF;\n+\t  ref_op1 = DECL_SIZE (field);\n+\t  ref_op2 = bitsize_zero_node;\n+\t}\n+      else\n+\t{\n+\t  boff >>= LOG2_BITS_PER_UNIT;\n+\t  boff += tree_to_uhwi (offset);\n+\t  coff = size_binop (MINUS_EXPR, coff, ssize_int (boff));\n+\t  ref_code = COMPONENT_REF;\n+\t  ref_op1 = field;\n+\t  ref_op2 = TREE_OPERAND (ref, 2);\n+\t  ref = TREE_OPERAND (ref, 0);\n+\t}\n     }\n-  else\n-    return fold_build2 (MEM_REF, type, addr, alias_ptr);\n+  tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);\n+  addr = force_gimple_operand_1 (unshare_expr (addr), stmts,\n+\t\t\t\t is_gimple_mem_ref_addr, NULL_TREE);\n+  tree alias_ptr = fold_convert (reference_alias_ptr_type (ref), coff);\n+  tree type = build_aligned_type (TREE_TYPE (ref),\n+\t\t\t\t  get_object_alignment (ref));\n+  ref = build2 (MEM_REF, type, addr, alias_ptr);\n+  if (ref_type)\n+    ref = build3 (ref_code, ref_type, ref, ref_op1, ref_op2);\n+  return ref;\n }\n \n /* Get the initialization expression for the INDEX-th temporary variable"}]}