{"sha": "9384a5afd6eac11ce7419869bbd2663fefdf918c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM4NGE1YWZkNmVhYzExY2U3NDE5ODY5YmJkMjY2M2ZlZmRmOTE4Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-11-13T09:30:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-11-13T09:30:49Z"}, "message": "tree-ssanames.h (set_range_info): Use value_range_base.\n\n2018-11-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssanames.h (set_range_info): Use value_range_base.\n\t(get_range_info): Likewise.\n\t* tree-ssanames.c (set_range_info): Likewise.\n\t(get_range_info): Likewise.\n\t* tree-vrp.c (value_range_base::union_helper): Split\n\tout common parts of value_range[_base]::union_.\n\t(value_range_base::union_): Update.\n\t(value_range::union_): Likewise.\n\t(determine_value_range_1): Use value_range_base.\n\t(determine_value_range): Likewise.\n\t* tree-vrp.h (value_range_base::union_helper): Move ...\n\t(value_range::union_helper): ... from here.\n\nFrom-SVN: r266061", "tree": {"sha": "9781a4382235b7759daaf43b34ad8252f9987bff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9781a4382235b7759daaf43b34ad8252f9987bff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9384a5afd6eac11ce7419869bbd2663fefdf918c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9384a5afd6eac11ce7419869bbd2663fefdf918c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9384a5afd6eac11ce7419869bbd2663fefdf918c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9384a5afd6eac11ce7419869bbd2663fefdf918c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b2a71af6e2818b867ad486efd9bbadb2b57570e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a71af6e2818b867ad486efd9bbadb2b57570e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2a71af6e2818b867ad486efd9bbadb2b57570e9"}], "stats": {"total": 195, "additions": 88, "deletions": 107}, "files": [{"sha": "29a216cd42dced880b6dec3473b763e2d9201370", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9384a5afd6eac11ce7419869bbd2663fefdf918c", "patch": "@@ -1,3 +1,18 @@\n+2018-11-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssanames.h (set_range_info): Use value_range_base.\n+\t(get_range_info): Likewise.\n+\t* tree-ssanames.c (set_range_info): Likewise.\n+\t(get_range_info): Likewise.\n+\t* tree-vrp.c (value_range_base::union_helper): Split\n+\tout common parts of value_range[_base]::union_.\n+\t(value_range_base::union_): Update.\n+\t(value_range::union_): Likewise.\n+\t(determine_value_range_1): Use value_range_base.\n+\t(determine_value_range): Likewise.\n+\t* tree-vrp.h (value_range_base::union_helper): Move ...\n+\t(value_range::union_helper): ... from here.\n+\n 2018-11-13  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_secondary_reload_inner): Negate"}, {"sha": "702b7db3ccca940a8f178b11d23586b2ee727256", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=9384a5afd6eac11ce7419869bbd2663fefdf918c", "patch": "@@ -401,7 +401,7 @@ set_range_info (tree name, enum value_range_kind range_type,\n /* Store range information for NAME from a value_range.  */\n \n void\n-set_range_info (tree name, const value_range &vr)\n+set_range_info (tree name, const value_range_base &vr)\n {\n   wide_int min = wi::to_wide (vr.min ());\n   wide_int max = wi::to_wide (vr.max ());\n@@ -434,7 +434,7 @@ get_range_info (const_tree name, wide_int *min, wide_int *max)\n    in a value_range VR.  Returns the value_range_kind.  */\n \n enum value_range_kind\n-get_range_info (const_tree name, value_range &vr)\n+get_range_info (const_tree name, value_range_base &vr)\n {\n   tree min, max;\n   wide_int wmin, wmax;"}, {"sha": "85372e11d9f3ff2df49ac4138c036446b53105a9", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=9384a5afd6eac11ce7419869bbd2663fefdf918c", "patch": "@@ -69,11 +69,11 @@ struct GTY ((variable_size)) range_info_def {\n /* Sets the value range to SSA.  */\n extern void set_range_info (tree, enum value_range_kind, const wide_int_ref &,\n \t\t\t    const wide_int_ref &);\n-extern void set_range_info (tree, const value_range &);\n+extern void set_range_info (tree, const value_range_base &);\n /* Gets the value range from SSA.  */\n extern enum value_range_kind get_range_info (const_tree, wide_int *,\n \t\t\t\t\t     wide_int *);\n-extern enum value_range_kind get_range_info (const_tree, value_range &);\n+extern enum value_range_kind get_range_info (const_tree, value_range_base &);\n extern void set_nonzero_bits (tree, const wide_int_ref &);\n extern wide_int get_nonzero_bits (const_tree);\n extern bool ssa_name_has_boolean_range (tree);"}, {"sha": "27bc1769f110f321ac75a67b41c6c605eb692d14", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 67, "deletions": 102, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9384a5afd6eac11ce7419869bbd2663fefdf918c", "patch": "@@ -6084,125 +6084,73 @@ value_range::intersect (const value_range *other)\n     }\n }\n \n-/* Meet operation for value ranges.  Given two value ranges VR0 and\n-   VR1, store in VR0 a range that contains both VR0 and VR1.  This\n-   may not be the smallest possible such range.  */\n+/* Helper for meet operation for value ranges.  Given two value ranges VR0 and\n+   VR1, return a range that contains both VR0 and VR1.  This may not be the\n+   smallest possible such range.  */\n \n-void\n-value_range_base::union_ (const value_range_base *other)\n+value_range_base\n+value_range_base::union_helper (const value_range_base *vr0,\n+\t\t\t\tconst value_range_base *vr1)\n {\n-  if (other->undefined_p ())\n-    {\n-      /* this already has the resulting range.  */\n-      return;\n-    }\n+  /* VR0 has the resulting range if VR1 is undefined or VR0 is varying.  */\n+  if (vr1->undefined_p ()\n+      || vr0->varying_p ())\n+    return *vr0;\n \n-  if (this->undefined_p ())\n-    {\n-      *this = *other;\n-      return;\n-    }\n+  /* VR1 has the resulting range if VR0 is undefined or VR1 is varying.  */\n+  if (vr0->undefined_p ()\n+      || vr1->varying_p ())\n+    return *vr1;\n \n-  if (this->varying_p ())\n-    {\n-      /* Nothing to do.  VR0 already has the resulting range.  */\n-      return;\n-    }\n+  value_range_kind vr0type = vr0->kind ();\n+  tree vr0min = vr0->min ();\n+  tree vr0max = vr0->max ();\n+  union_ranges (&vr0type, &vr0min, &vr0max,\n+\t\tvr1->kind (), vr1->min (), vr1->max ());\n+\n+  /* Work on a temporary so we can still use vr0 when union returns varying.  */\n+  value_range tem;\n+  tem.set_and_canonicalize (vr0type, vr0min, vr0max);\n \n-  if (other->varying_p ())\n+  /* Failed to find an efficient meet.  Before giving up and setting\n+     the result to VARYING, see if we can at least derive a useful\n+     anti-range.  */\n+  if (tem.varying_p ()\n+      && range_includes_zero_p (vr0) == 0\n+      && range_includes_zero_p (vr1) == 0)\n     {\n-      this->set_varying ();\n-      return;\n+      tem.set_nonnull (vr0->type ());\n+      return tem;\n     }\n \n-  value_range saved (*this);\n-  value_range_kind vr0type = this->kind ();\n-  tree vr0min = this->min ();\n-  tree vr0max = this->max ();\n-  union_ranges (&vr0type, &vr0min, &vr0max,\n-\t\tother->kind (), other->min (), other->max ());\n-  *this = value_range_base (vr0type, vr0min, vr0max);\n-  if (this->varying_p ())\n-    {\n-      /* Failed to find an efficient meet.  Before giving up and setting\n-\t the result to VARYING, see if we can at least derive a useful\n-\t anti-range.  */\n-      if (range_includes_zero_p (&saved) == 0\n-\t  && range_includes_zero_p (other) == 0)\n-\t{\n-\t  tree zero = build_int_cst (saved.type (), 0);\n-\t  *this = value_range_base (VR_ANTI_RANGE, zero, zero);\n-\t  return;\n-\t}\n-\n-      this->set_varying ();\n-      return;\n-    }\n-  this->set_and_canonicalize (this->kind (), this->min (), this->max ());\n+  return tem;\n }\n \n+\n /* Meet operation for value ranges.  Given two value ranges VR0 and\n    VR1, store in VR0 a range that contains both VR0 and VR1.  This\n    may not be the smallest possible such range.  */\n \n void\n-value_range::union_helper (value_range *vr0, const value_range *vr1)\n+value_range_base::union_ (const value_range_base *other)\n {\n-  if (vr1->undefined_p ())\n-    {\n-      /* VR0 already has the resulting range.  */\n-      return;\n-    }\n-\n-  if (vr0->undefined_p ())\n-    {\n-      vr0->deep_copy (vr1);\n-      return;\n-    }\n-\n-  if (vr0->varying_p ())\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      /* Nothing to do.  VR0 already has the resulting range.  */\n-      return;\n+      fprintf (dump_file, \"Meeting\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\nand\\n  \");\n+      dump_value_range (dump_file, other);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n-  if (vr1->varying_p ())\n-    {\n-      vr0->set_varying ();\n-      return;\n-    }\n+  *this = union_helper (this, other);\n \n-  value_range_kind vr0type = vr0->kind ();\n-  tree vr0min = vr0->min ();\n-  tree vr0max = vr0->max ();\n-  union_ranges (&vr0type, &vr0min, &vr0max,\n-\t\tvr1->kind (), vr1->min (), vr1->max ());\n-  /* Work on a temporary so we can still use vr0 when union returns varying.  */\n-  value_range tem;\n-  tem.set_and_canonicalize (vr0type, vr0min, vr0max);\n-  if (tem.varying_p ())\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      /* Failed to find an efficient meet.  Before giving up and setting\n-\t the result to VARYING, see if we can at least derive a useful\n-\t anti-range.  */\n-      if (range_includes_zero_p (vr0) == 0\n-\t  && range_includes_zero_p (vr1) == 0)\n-\t{\n-\t  vr0->set_nonnull (vr0->type ());\n-\t  return;\n-\t}\n-\n-      vr0->set_varying ();\n-      return;\n+      fprintf (dump_file, \"to\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\n\");\n     }\n-  vr0->update (tem.kind (), tem.min (), tem.max ());\n-\n-  /* The resulting set of equivalences is always the intersection of\n-     the two sets.  */\n-  if (vr0->m_equiv && vr1->m_equiv && vr0->m_equiv != vr1->m_equiv)\n-    bitmap_and_into (vr0->m_equiv, vr1->m_equiv);\n-  else if (vr0->m_equiv && !vr1->m_equiv)\n-    bitmap_clear (vr0->m_equiv);\n }\n \n void\n@@ -6216,7 +6164,24 @@ value_range::union_ (const value_range *other)\n       dump_value_range (dump_file, other);\n       fprintf (dump_file, \"\\n\");\n     }\n-  union_helper (this, other);\n+\n+  /* If THIS is undefined we want to pick up equivalences from OTHER.\n+     Just special-case this here rather than trying to fixup after the fact.  */\n+  if (this->undefined_p ())\n+    this->deep_copy (other);\n+  else\n+    {\n+      value_range_base tem = union_helper (this, other);\n+      this->update (tem.kind (), tem.min (), tem.max ());\n+\n+      /* The resulting set of equivalences is always the intersection of\n+\t the two sets.  */\n+      if (this->m_equiv && other->m_equiv && this->m_equiv != other->m_equiv)\n+\tbitmap_and_into (this->m_equiv, other->m_equiv);\n+      else if (this->m_equiv && !other->m_equiv)\n+\tbitmap_clear (this->m_equiv);\n+    }\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"to\\n  \");\n@@ -6867,19 +6832,19 @@ make_pass_vrp (gcc::context *ctxt)\n /* Worker for determine_value_range.  */\n \n static void\n-determine_value_range_1 (value_range *vr, tree expr)\n+determine_value_range_1 (value_range_base *vr, tree expr)\n {\n   if (BINARY_CLASS_P (expr))\n     {\n-      value_range vr0, vr1;\n+      value_range_base vr0, vr1;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       determine_value_range_1 (&vr1, TREE_OPERAND (expr, 1));\n       extract_range_from_binary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t\t      &vr0, &vr1);\n     }\n   else if (UNARY_CLASS_P (expr))\n     {\n-      value_range vr0;\n+      value_range_base vr0;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       extract_range_from_unary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t\t     &vr0, TREE_TYPE (TREE_OPERAND (expr, 0)));\n@@ -6908,7 +6873,7 @@ determine_value_range_1 (value_range *vr, tree expr)\n value_range_kind\n determine_value_range (tree expr, wide_int *min, wide_int *max)\n {\n-  value_range vr;\n+  value_range_base vr;\n   determine_value_range_1 (&vr, expr);\n   if (vr.constant_p ())\n     {"}, {"sha": "348fa4f0e7bc67ca252ac0163a70cb8a07d56391", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9384a5afd6eac11ce7419869bbd2663fefdf918c/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=9384a5afd6eac11ce7419869bbd2663fefdf918c", "patch": "@@ -77,6 +77,8 @@ class GTY((for_user)) value_range_base\n \n protected:\n   void check ();\n+  static value_range_base union_helper (const value_range_base *,\n+\t\t\t\t\tconst value_range_base *);\n \n   enum value_range_kind m_kind;\n \n@@ -145,7 +147,6 @@ class GTY((user)) value_range : public value_range_base\n   void check ();\n   bool equal_p (const value_range &, bool ignore_equivs) const;\n   void intersect_helper (value_range *, const value_range *);\n-  void union_helper (value_range *, const value_range *);\n \n   /* Set of SSA names whose value ranges are equivalent to this one.\n      This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */"}]}