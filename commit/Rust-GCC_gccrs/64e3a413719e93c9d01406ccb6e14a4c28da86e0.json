{"sha": "64e3a413719e93c9d01406ccb6e14a4c28da86e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRlM2E0MTM3MTllOTNjOWQwMTQwNmNjYjZlMTRhNGMyOGRhODZlMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-07-31T13:57:02Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-07-31T13:57:02Z"}, "message": "* local-alloc.c: Fix formatting.\n\nFrom-SVN: r35378", "tree": {"sha": "4e715a49585314edd539f3116af04e6f95f2873d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e715a49585314edd539f3116af04e6f95f2873d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64e3a413719e93c9d01406ccb6e14a4c28da86e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64e3a413719e93c9d01406ccb6e14a4c28da86e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64e3a413719e93c9d01406ccb6e14a4c28da86e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64e3a413719e93c9d01406ccb6e14a4c28da86e0/comments", "author": null, "committer": null, "parents": [{"sha": "bbe65572cd946b16ba8c429ade291c1feb13b9f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe65572cd946b16ba8c429ade291c1feb13b9f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe65572cd946b16ba8c429ade291c1feb13b9f2"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "cd97f09c81e3482e6738cad12e30b749c10bcadf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e3a413719e93c9d01406ccb6e14a4c28da86e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e3a413719e93c9d01406ccb6e14a4c28da86e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64e3a413719e93c9d01406ccb6e14a4c28da86e0", "patch": "@@ -9,6 +9,8 @@\n \n 2000-07-31  Kazu Hirata  <kazu@hxi.com>\n \n+\t* local-alloc.c: Fix formatting.\n+\n \t* h8300.c (get_shift_alg): Remove the variable alg.\n \t(emit_a_shift): Rearrange code to improve readability.\n "}, {"sha": "b93102bfe9842b5825f480deb261d6e50bbeada7", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e3a413719e93c9d01406ccb6e14a4c28da86e0/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e3a413719e93c9d01406ccb6e14a4c28da86e0/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=64e3a413719e93c9d01406ccb6e14a4c28da86e0", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* Allocation of hard register numbers to pseudo registers is done in\n    two passes.  In this pass we consider only regs that are born and\n    die once within one basic block.  We do this one basic block at a\n@@ -49,7 +48,7 @@ Boston, MA 02111-1307, USA.  */\n    Tying is represented with \"quantity numbers\".\n    A non-tied register is given a new quantity number.\n    Tied registers have the same quantity number.\n-   \n+\n    We have provision to exempt registers, even when they are contained\n    within the block, that can be tied to others that are not contained in it.\n    This is so that global_alloc could process them both and tie them then.\n@@ -177,7 +176,6 @@ static short *qty_phys_num_copy_sugg;\n \n static short *qty_phys_num_sugg;\n \n-\n /* If (REG N) has been assigned a quantity number, is a register number\n    of another register assigned the same quantity number, or -1 for the\n    end of the chain.  qty->first_reg point to the head of this chain.  */\n@@ -344,9 +342,9 @@ local_alloc ()\n \n   reg_qty = (int *) xmalloc (max_regno * sizeof (int));\n   reg_offset = (char *) xmalloc (max_regno * sizeof (char));\n-  reg_next_in_qty = (int *) xmalloc(max_regno * sizeof (int));\n+  reg_next_in_qty = (int *) xmalloc (max_regno * sizeof (int));\n \n-  /* Allocate the reg_renumber array */\n+  /* Allocate the reg_renumber array.  */\n   allocate_reg_info (max_regno, FALSE, TRUE);\n \n   /* Determine which pseudo-registers can be allocated by local-alloc.\n@@ -598,7 +596,7 @@ memref_referenced_p (memref, x)\n \treturn 1;\n \n       return memref_referenced_p (memref, SET_SRC (x));\n-      \n+\n     default:\n       break;\n     }\n@@ -837,7 +835,7 @@ update_equiv_regs ()\n \t a register used only in one basic block from a MEM.  If so, and the\n \t MEM remains unchanged for the life of the register, add a REG_EQUIV\n \t note.  */\n-\t \n+\n       note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \n       if (note == 0 && REG_BASIC_BLOCK (regno) >= 0\n@@ -861,8 +859,7 @@ update_equiv_regs ()\n \t\t  && (GET_CODE (XEXP (XEXP (XEXP (note, 0), 0), 0))\n \t\t      == LABEL_REF)))\n \t    recorded_label_ref = 1;\n-\t  \n-\t \n+\n \t  reg_equiv_replacement[regno] = XEXP (note, 0);\n \n \t  /* Don't mess with things live during setjmp.  */\n@@ -944,7 +941,7 @@ update_equiv_regs ()\n \t      /* reg_equiv_replace[REGNO] gets set only when\n \t\t REG_N_REFS[REGNO] is 2, i.e. the register is set\n \t\t once and used once.  (If it were only set, but not used,\n-\t\t flow would have deleted the setting insns.)  Hence \n+\t\t flow would have deleted the setting insns.)  Hence\n \t\t there can only be one insn in reg_equiv_init_insns.  */\n \t      equiv_insn = XEXP (reg_equiv_init_insns[regno], 0);\n \n@@ -1147,7 +1144,7 @@ block_alloc (b)\n \t\t    continue;\n \n \t\t  /* Likewise if each alternative has some operand that\n-\t\t     must match operand zero.  In that case, skip any \n+\t\t     must match operand zero.  In that case, skip any\n \t\t     operand that doesn't list operand 0 since we know that\n \t\t     the operand always conflicts with operand 0.  We\n \t\t     ignore commutatity in this case to keep things simple.  */\n@@ -1172,7 +1169,7 @@ block_alloc (b)\n \t\t\t priority to an equivalence found from that insn.  */\n \t\t      int may_save_copy\n \t\t\t= (r1 == recog_data.operand[i] && must_match_0 >= 0);\n-\t\t      \n+\n \t\t      if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n \t\t\twin = combine_regs (r1, r0, may_save_copy,\n \t\t\t\t\t    insn_number, insn, 0);\n@@ -1275,7 +1272,7 @@ block_alloc (b)\n \t\t&& GET_CODE (XEXP (link, 0)) == REG)\n \t      wipe_dead_reg (XEXP (link, 0), 1);\n \n-\t  /* If this is an insn that has a REG_RETVAL note pointing at a \n+\t  /* If this is an insn that has a REG_RETVAL note pointing at a\n \t     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT\n \t     block, so clear any register number that combined within it.  */\n \t  if ((note = find_reg_note (insn, REG_RETVAL, NULL_RTX)) != 0\n@@ -1299,7 +1296,7 @@ block_alloc (b)\n \n   /* Now every register that is local to this basic block\n      should have been given a quantity, or else -1 meaning ignore it.\n-     Every quantity should have a known birth and death.  \n+     Every quantity should have a known birth and death.\n \n      Order the qtys so we assign them registers in order of the\n      number of suggested registers they need so we allocate those with\n@@ -1351,8 +1348,8 @@ block_alloc (b)\n \tqty[q].phys_reg = -1;\n     }\n \n-  /* Order the qtys so we assign them registers in order of \n-     decreasing length of life.  Normally call qsort, but if we \n+  /* Order the qtys so we assign them registers in order of\n+     decreasing length of life.  Normally call qsort, but if we\n      have only a very small number of quantities, sort them ourselves.  */\n \n   for (i = 0; i < next_qty; i++)\n@@ -1405,7 +1402,7 @@ block_alloc (b)\n \t     The purpose behind extending the lifetime of this qty is to\n \t     discourage the register allocator from creating false\n \t     dependencies.\n- \n+\n \t     The adjustment value is choosen to indicate that this qty\n \t     conflicts with all the qtys in the instructions immediately\n \t     before and after the lifetime of this qty.\n@@ -1434,15 +1431,14 @@ block_alloc (b)\n \t\t  && !optimize_size\n \t\t  && !SMALL_REGISTER_CLASSES)\n \t\t{\n-\t\t\n-\t\t  qty[q].phys_reg = find_free_reg (qty[q].min_class, \n+\t\t  qty[q].phys_reg = find_free_reg (qty[q].min_class,\n \t\t\t\t\t\t   qty[q].mode, q, 0, 0,\n \t\t\t\t\t\t   fake_birth, fake_death);\n \t\t  if (qty[q].phys_reg >= 0)\n \t\t    continue;\n \t\t}\n #endif\n-\t      qty[q].phys_reg = find_free_reg (qty[q].min_class, \n+\t      qty[q].phys_reg = find_free_reg (qty[q].min_class,\n \t\t\t\t\t       qty[q].mode, q, 0, 0,\n \t\t\t\t\t       qty[q].birth, qty[q].death);\n \t      if (qty[q].phys_reg >= 0)\n@@ -1513,7 +1509,7 @@ qty_compare_1 (q1p, q2p)\n      const PTR q1p;\n      const PTR q2p;\n {\n-  register int q1 = *(const int *)q1p, q2 = *(const int *)q2p;\n+  register int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n   register int tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n \n   if (tem != 0)\n@@ -1544,7 +1540,7 @@ qty_sugg_compare (q1, q2)\n \n   if (tem != 0)\n     return tem;\n-  \n+\n   return QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n }\n \n@@ -1553,7 +1549,7 @@ qty_sugg_compare_1 (q1p, q2p)\n      const PTR q1p;\n      const PTR q2p;\n {\n-  register int q1 = *(const int *)q1p, q2 = *(const int *)q2p;\n+  register int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n   register int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n \n   if (tem != 0)\n@@ -1590,10 +1586,9 @@ qty_sugg_compare_1 (q1p, q2p)\n    MAY_SAVE_COPYCOPY is non-zero if this insn is simply copying USEDREG to\n    SETREG or if the input and output must share a register.\n    In that case, we record a hard reg suggestion in QTY_PHYS_COPY_SUGG.\n-   \n+\n    There are elaborate checks for the validity of combining.  */\n \n-   \n static int\n combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n      rtx usedreg, setreg;\n@@ -1837,7 +1832,7 @@ reg_is_born (reg, birth)\n      int birth;\n {\n   register int regno;\n-     \n+\n   if (GET_CODE (reg) == SUBREG)\n     regno = REGNO (SUBREG_REG (reg)) + SUBREG_WORD (reg);\n   else\n@@ -1878,7 +1873,7 @@ wipe_dead_reg (reg, output_p)\n   /* If this insn has multiple results,\n      and the dead reg is used in one of the results,\n      extend its life to after this insn,\n-     so it won't get allocated together with any other result of this insn. \n+     so it won't get allocated together with any other result of this insn.\n \n      It is unsafe to use !single_set here since it will ignore an unused\n      output.  Just because an output is unused does not mean the compiler\n@@ -1916,7 +1911,7 @@ wipe_dead_reg (reg, output_p)\n \t not to happen).  */\n       if (output_p)\n \tpost_mark_life (regno, GET_MODE (reg), 1,\n-\t\t\t2 * this_insn_number, 2 * this_insn_number+ 1);\n+\t\t\t2 * this_insn_number, 2 * this_insn_number + 1);\n     }\n \n   else if (reg_qty[regno] >= 0)\n@@ -1928,7 +1923,7 @@ wipe_dead_reg (reg, output_p)\n      (but actually we test only the first of the block for holding MODE)\n    and still free between insn BORN_INDEX and insn DEAD_INDEX,\n    and return the number of the first of them.\n-   Return -1 if such a block cannot be found. \n+   Return -1 if such a block cannot be found.\n    If QTYNO crosses calls, insist on a register preserved by calls,\n    unless ACCEPT_CALL_CLOBBERED is nonzero.\n \n@@ -1947,7 +1942,8 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n {\n   register int i, ins;\n #ifdef HARD_REG_SET\n-  register\t\t/* Declare it register if it's a scalar.  */\n+  /* Declare it register if it's a scalar.  */\n+  register\n #endif\n     HARD_REG_SET used, first_used;\n #ifdef ELIMINABLE_REGS\n@@ -1986,7 +1982,7 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n \n      This is true of any register that can be eliminated.  */\n #ifdef ELIMINABLE_REGS\n-  for (i = 0; i < (int)(sizeof eliminables / sizeof eliminables[0]); i++)\n+  for (i = 0; i < (int) (sizeof eliminables / sizeof eliminables[0]); i++)\n     SET_HARD_REG_BIT (used, eliminables[i].from);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n   /* If FRAME_POINTER_REGNUM is not a real register, then protect the one\n@@ -2048,17 +2044,17 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n \t      return regno;\n \t    }\n #ifndef REG_ALLOC_ORDER\n-\t  i += j;\t\t/* Skip starting points we know will lose */\n+\t  /* Skip starting points we know will lose.  */\n+\t  i += j;\n #endif\n \t}\n     }\n \n  fail:\n-\n   /* If we are just trying suggested register, we have just tried copy-\n      suggested registers, and there are arithmetic-suggested registers,\n      try them.  */\n-  \n+\n   /* If it would be profitable to allocate a call-clobbered register\n      and save and restore it around calls, do that.  */\n   if (just_try_suggested && qty_phys_num_copy_sugg[qtyno] != 0\n@@ -2078,7 +2074,8 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n       && flag_caller_saves\n       && ! just_try_suggested\n       && qty[qtyno].n_calls_crossed != 0\n-      && CALLER_SAVE_PROFITABLE (qty[qtyno].n_refs, qty[qtyno].n_calls_crossed))\n+      && CALLER_SAVE_PROFITABLE (qty[qtyno].n_refs,\n+\t\t\t\t qty[qtyno].n_calls_crossed))\n     {\n       i = find_free_reg (class, mode, qtyno, 1, 0, born_index, dead_index);\n       if (i >= 0)\n@@ -2119,7 +2116,8 @@ post_mark_life (regno, mode, life, birth, death)\n {\n   register int j = HARD_REGNO_NREGS (regno, mode);\n #ifdef HARD_REG_SET\n-  register\t\t/* Declare it register if it's a scalar.  */\n+  /* Declare it register if it's a scalar.  */\n+  register\n #endif\n     HARD_REG_SET this_reg;\n \n@@ -2183,7 +2181,7 @@ no_conflict_p (insn, r0, r1)\n \tif (! find_reg_note (p, REG_NO_CONFLICT, r1))\n \t  return 0;\n       }\n-      \n+\n   return ok;\n }\n \f\n@@ -2193,7 +2191,7 @@ no_conflict_p (insn, r0, r1)\n \n static int\n requires_inout (p)\n-  const char *p;\n+     const char *p;\n {\n   char c;\n   int found_zero = 0;"}]}