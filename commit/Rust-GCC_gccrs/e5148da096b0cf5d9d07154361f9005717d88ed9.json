{"sha": "e5148da096b0cf5d9d07154361f9005717d88ed9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUxNDhkYTA5NmIwY2Y1ZDlkMDcxNTQzNjFmOTAwNTcxN2Q4OGVkOQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-08T13:46:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-08T13:46:19Z"}, "message": "[multiple changes]\n\n2017-11-08  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch8.adb (Use_One_Type, Update_Use_Clause_Chain): Do not report\n\tabout unused use-type or use-package clauses inside inlined bodies.\n\n2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_elab.adb (Ensure_Prior_Elaboration): Add new parameter\n\tIn_Partial_Fin along with a comment on its usage. Do not guarantee the\n\tprior elaboration of a unit when the need came from a partial\n\tfinalization context.\n\t(In_Initialization_Context): Relocated to Process_Call.\n\t(Is_Partial_Finalization_Proc): New routine.\n\t(Process_Access): Add new parameter In_Partial_Fin along with a comment\n\ton its usage.\n\t(Process_Activation_Call): Add new parameter In_Partial_Fin along with\n\ta comment on its usage.\n\t(Process_Activation_Conditional_ABE_Impl): Add new parameter\n\tIn_Partial_Fin along with a comment on its usage. Do not emit any ABE\n\tdiagnostics when the activation occurs in a partial finalization\n\tcontext.\n\t(Process_Activation_Guaranteed_ABE_Impl): Add new parameter\n\tIn_Partial_Fin along with a comment on its usage.\n\t(Process_Call): Add new parameter In_Partial_Fin along with a comment\n\ton its usage. A call is within a partial finalization context when it\n\ttargets a finalizer or primitive [Deep_]Finalize, and the call appears\n\tin initialization actions. Pass this information down to the recursive\n\tsteps of the Processing phase.\n\t(Process_Call_Ada): Add new parameter In_Partial_Fin along with a\n\tcomment on its usage. Remove the guard which suppresses the generation\n\tof implicit Elaborate[_All] pragmas. This is now done in\n\tEnsure_Prior_Elaboration.\n\t(Process_Call_Conditional_ABE): Add new parameter In_Partial_Fin along\n\twith a comment on its usage. Do not emit any ABE diagnostics when the\n\tcall occurs in a partial finalization context.\n\t(Process_Call_SPARK): Add new parameter In_Partial_Fin along with a\n\tcomment on its usage.\n\t(Process_Instantiation): Add new parameter In_Partial_Fin along with a\n\tcomment on its usage.\n\t(Process_Instantiation_Ada): Add new parameter In_Partial_Fin along\n\twith a comment on its usage.\n\t(Process_Instantiation_Conditional_ABE): Add new parameter\n\tIn_Partial_Fin along with a comment on its usage. Do not emit any ABE\n\tdiagnostics when the instantiation occurs in a partial finalization\n\tcontext.\n\t(Process_Instantiation_SPARK): Add new parameter In_Partial_Fin along\n\twith a comment on its usage.\n\t(Process_Scenario): Add new parameter In_Partial_Fin along  with a\n\tcomment on its usage.\n\t(Process_Single_Activation): Add new parameter In_Partial_Fin along\n\twith a comment on its usage.\n\t(Traverse_Body): Add new parameter In_Partial_Fin along with a comment\n\ton its usage.\n\n2017-11-08  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_ch13.adb: Add optional parameter to Error_Msg.\n\n2017-11-08  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* fname.adb (Is_Internal_File_Name): Do not check the 8+3 naming schema\n\tfor the Interfaces.* hierarchy as longer unit names are now allowed.\n\n2017-11-08  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_util.adb (Subprogram_Name): Emit sloc for the enclosing\n\tsubprogram as well.  Support more cases of entities.\n\t(Append_Entity_Name): Add some defensive code.\n\nFrom-SVN: r254528", "tree": {"sha": "9324f92cbc3b2e930f38786eba3341e3976ad18f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9324f92cbc3b2e930f38786eba3341e3976ad18f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5148da096b0cf5d9d07154361f9005717d88ed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5148da096b0cf5d9d07154361f9005717d88ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5148da096b0cf5d9d07154361f9005717d88ed9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5148da096b0cf5d9d07154361f9005717d88ed9/comments", "author": null, "committer": null, "parents": [{"sha": "63ee540430c32a4f93924f4b2d970999b7cd201b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ee540430c32a4f93924f4b2d970999b7cd201b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63ee540430c32a4f93924f4b2d970999b7cd201b"}], "stats": {"total": 896, "additions": 569, "deletions": 327}, "files": [{"sha": "912de2376dc559b2d3182c0246d5886fa91b80fb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e5148da096b0cf5d9d07154361f9005717d88ed9", "patch": "@@ -1,3 +1,72 @@\n+2017-11-08  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch8.adb (Use_One_Type, Update_Use_Clause_Chain): Do not report\n+\tabout unused use-type or use-package clauses inside inlined bodies.\n+\n+2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_elab.adb (Ensure_Prior_Elaboration): Add new parameter\n+\tIn_Partial_Fin along with a comment on its usage. Do not guarantee the\n+\tprior elaboration of a unit when the need came from a partial\n+\tfinalization context.\n+\t(In_Initialization_Context): Relocated to Process_Call.\n+\t(Is_Partial_Finalization_Proc): New routine.\n+\t(Process_Access): Add new parameter In_Partial_Fin along with a comment\n+\ton its usage.\n+\t(Process_Activation_Call): Add new parameter In_Partial_Fin along with\n+\ta comment on its usage.\n+\t(Process_Activation_Conditional_ABE_Impl): Add new parameter\n+\tIn_Partial_Fin along with a comment on its usage. Do not emit any ABE\n+\tdiagnostics when the activation occurs in a partial finalization\n+\tcontext.\n+\t(Process_Activation_Guaranteed_ABE_Impl): Add new parameter\n+\tIn_Partial_Fin along with a comment on its usage.\n+\t(Process_Call): Add new parameter In_Partial_Fin along with a comment\n+\ton its usage. A call is within a partial finalization context when it\n+\ttargets a finalizer or primitive [Deep_]Finalize, and the call appears\n+\tin initialization actions. Pass this information down to the recursive\n+\tsteps of the Processing phase.\n+\t(Process_Call_Ada): Add new parameter In_Partial_Fin along with a\n+\tcomment on its usage. Remove the guard which suppresses the generation\n+\tof implicit Elaborate[_All] pragmas. This is now done in\n+\tEnsure_Prior_Elaboration.\n+\t(Process_Call_Conditional_ABE): Add new parameter In_Partial_Fin along\n+\twith a comment on its usage. Do not emit any ABE diagnostics when the\n+\tcall occurs in a partial finalization context.\n+\t(Process_Call_SPARK): Add new parameter In_Partial_Fin along with a\n+\tcomment on its usage.\n+\t(Process_Instantiation): Add new parameter In_Partial_Fin along with a\n+\tcomment on its usage.\n+\t(Process_Instantiation_Ada): Add new parameter In_Partial_Fin along\n+\twith a comment on its usage.\n+\t(Process_Instantiation_Conditional_ABE): Add new parameter\n+\tIn_Partial_Fin along with a comment on its usage. Do not emit any ABE\n+\tdiagnostics when the instantiation occurs in a partial finalization\n+\tcontext.\n+\t(Process_Instantiation_SPARK): Add new parameter In_Partial_Fin along\n+\twith a comment on its usage.\n+\t(Process_Scenario): Add new parameter In_Partial_Fin along  with a\n+\tcomment on its usage.\n+\t(Process_Single_Activation): Add new parameter In_Partial_Fin along\n+\twith a comment on its usage.\n+\t(Traverse_Body): Add new parameter In_Partial_Fin along with a comment\n+\ton its usage.\n+\n+2017-11-08  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_ch13.adb: Add optional parameter to Error_Msg.\n+\n+2017-11-08  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* fname.adb (Is_Internal_File_Name): Do not check the 8+3 naming schema\n+\tfor the Interfaces.* hierarchy as longer unit names are now allowed.\n+\n+2017-11-08  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_util.adb (Subprogram_Name): Emit sloc for the enclosing\n+\tsubprogram as well.  Support more cases of entities.\n+\t(Append_Entity_Name): Add some defensive code.\n+\n 2017-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c (gnat_post_options): Clear warn_return_type."}, {"sha": "96d813adbad515f02107bbd4a9ee9d4ab7ff9e86", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=e5148da096b0cf5d9d07154361f9005717d88ed9", "patch": "@@ -167,8 +167,11 @@ package body Fname is\n    is\n    begin\n       --  Definitely false if longer than 12 characters (8.3)\n+      --  except for the Interfaces packages\n \n-      if Fname'Length > 12 then\n+      if Fname'Length > 12\n+        and then Fname (Fname'First .. Fname'First + 1) /= \"i-\"\n+      then\n          return False;\n       end if;\n "}, {"sha": "ccca8b7ff53ba318584fdc5d24062cbfb594115a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e5148da096b0cf5d9d07154361f9005717d88ed9", "patch": "@@ -14317,7 +14317,7 @@ package body Sem_Ch13 is\n                if Source_Siz /= Target_Siz then\n                   Error_Msg\n                     (\"?z?types for unchecked conversion have different sizes!\",\n-                     Eloc);\n+                     Eloc, Act_Unit);\n \n                   if All_Errors_Mode then\n                      Error_Msg_Name_1 := Chars (Source);\n@@ -14353,35 +14353,35 @@ package body Sem_Ch13 is\n                            if Bytes_Big_Endian then\n                               Error_Msg\n                                 (\"\\?z?target value will include ^ undefined \"\n-                                 & \"low order bits!\", Eloc);\n+                                 & \"low order bits!\", Eloc, Act_Unit);\n                            else\n                               Error_Msg\n                                 (\"\\?z?target value will include ^ undefined \"\n-                                 & \"high order bits!\", Eloc);\n+                                 & \"high order bits!\", Eloc, Act_Unit);\n                            end if;\n \n                         else\n                            Error_Msg\n                              (\"\\?z?^ trailing bits of target value will be \"\n-                              & \"undefined!\", Eloc);\n+                              & \"undefined!\", Eloc, Act_Unit);\n                         end if;\n \n                      else pragma Assert (Source_Siz > Target_Siz);\n                         if Is_Discrete_Type (Source) then\n                            if Bytes_Big_Endian then\n                               Error_Msg\n                                 (\"\\?z?^ low order bits of source will be \"\n-                                 & \"ignored!\", Eloc);\n+                                 & \"ignored!\", Eloc, Act_Unit);\n                            else\n                               Error_Msg\n                                 (\"\\?z?^ high order bits of source will be \"\n-                                 & \"ignored!\", Eloc);\n+                                 & \"ignored!\", Eloc, Act_Unit);\n                            end if;\n \n                         else\n                            Error_Msg\n                              (\"\\?z?^ trailing bits of source will be \"\n-                              & \"ignored!\", Eloc);\n+                              & \"ignored!\", Eloc, Act_Unit);\n                         end if;\n                      end if;\n                   end if;\n@@ -14435,10 +14435,10 @@ package body Sem_Ch13 is\n                            Error_Msg_Node_2 := D_Source;\n                            Error_Msg\n                              (\"?z?alignment of & (^) is stricter than \"\n-                              & \"alignment of & (^)!\", Eloc);\n+                              & \"alignment of & (^)!\", Eloc, Act_Unit);\n                            Error_Msg\n                              (\"\\?z?resulting access value may have invalid \"\n-                              & \"alignment!\", Eloc);\n+                              & \"alignment!\", Eloc, Act_Unit);\n                         end if;\n                      end;\n                   end if;"}, {"sha": "df176a76c57e9439cd9e8eefa2b034f9b35ec79e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=e5148da096b0cf5d9d07154361f9005717d88ed9", "patch": "@@ -9057,6 +9057,7 @@ package body Sem_Ch8 is\n               and then Comes_From_Source (Curr)\n               and then not Is_Effective_Use_Clause (Curr)\n               and then not In_Instance\n+              and then not In_Inlined_Body\n             then\n                --  We are dealing with a potentially unused use_package_clause\n \n@@ -9865,6 +9866,7 @@ package body Sem_Ch8 is\n \n         and then not Spec_Reloaded_For_Body\n         and then not In_Instance\n+        and then not In_Inlined_Body\n       then\n          --  The type already has a use clause\n "}, {"sha": "735ecf70159018ebb26dd41a43905ca27666269d", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 437, "deletions": 304, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=e5148da096b0cf5d9d07154361f9005717d88ed9", "patch": "@@ -785,12 +785,15 @@ package body Sem_Elab is\n    --  string \" in SPARK\" is added to the end of the message.\n \n    procedure Ensure_Prior_Elaboration\n-     (N            : Node_Id;\n-      Unit_Id      : Entity_Id;\n-      In_Task_Body : Boolean);\n+     (N              : Node_Id;\n+      Unit_Id        : Entity_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Guarantee the elaboration of unit Unit_Id with respect to the main unit.\n-   --  N denotes the related scenario. Flag In_Task_Body should be set when the\n-   --  need for elaboration is initiated from a task body.\n+   --  N denotes the related scenario. Flag In_Partial_Fin should be set when\n+   --  the need for elaboration is initiated by a partial finalization routine.\n+   --  Flag In_Task_Body should be set when the need for prior elaboration is\n+   --  initiated from a task body.\n \n    procedure Ensure_Prior_Elaboration_Dynamic\n      (N        : Node_Id;\n@@ -1202,86 +1205,111 @@ package body Sem_Elab is\n    --  Pop the top of the scenario stack. A check is made to ensure that the\n    --  scenario being removed is the same as N.\n \n-   procedure Process_Access (Attr : Node_Id; In_Task_Body : Boolean);\n+   procedure Process_Access\n+     (Attr           : Node_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Perform ABE checks and diagnostics for 'Access to entry, operator, or\n-   --  subprogram denoted by Attr. Flag In_Task_Body should be set when the\n-   --  processing is initiated from a task body.\n+   --  subprogram denoted by Attr. Flag In_Partial_Fin shoud be set when the\n+   --  processing is initiated by a partial finalization routine. Flag\n+   --  In_Task_Body should be set when the processing is initiated from a task\n+   --  body.\n \n    generic\n       with procedure Process_Single_Activation\n-        (Call         : Node_Id;\n-         Call_Attrs   : Call_Attributes;\n-         Obj_Id       : Entity_Id;\n-         Task_Attrs   : Task_Attributes;\n-         In_Task_Body : Boolean);\n+        (Call           : Node_Id;\n+         Call_Attrs     : Call_Attributes;\n+         Obj_Id         : Entity_Id;\n+         Task_Attrs     : Task_Attributes;\n+         In_Partial_Fin : Boolean;\n+         In_Task_Body   : Boolean);\n       --  Perform ABE checks and diagnostics for task activation call Call\n       --  which activates task Obj_Id. Call_Attrs are the attributes of the\n       --  activation call. Task_Attrs are the attributes of the task type.\n-      --  Flag In_Task_Body should be set when the processing is initiated\n-      --  from a task body.\n+      --  Flag In_Partial_Fin shoud be set when the processing is initiated\n+      --  by a partial finalization routine. Flag In_Task_Body should be set\n+      --  when the processing is initiated from a task body.\n \n    procedure Process_Activation_Call\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      In_Task_Body : Boolean);\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Perform ABE checks and diagnostics for activation call Call by invoking\n    --  routine Process_Single_Activation on each task object being activated.\n-   --  Call_Attrs are the attributes of the activation call. Flag In_Task_Body\n-   --  should be set when the processing is initiated from a task body.\n+   --  Call_Attrs are the attributes of the activation call. In_Partial_Fin\n+   --  shoud be set when the processing is initiated by a partial finalization\n+   --  routine. Flag In_Task_Body should be set when the processing is started\n+   --  from a task body.\n \n    procedure Process_Activation_Conditional_ABE_Impl\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Obj_Id       : Entity_Id;\n-      Task_Attrs   : Task_Attributes;\n-      In_Task_Body : Boolean);\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Obj_Id         : Entity_Id;\n+      Task_Attrs     : Task_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Perform common conditional ABE checks and diagnostics for call Call\n    --  which activates task Obj_Id ignoring the Ada or SPARK rules. CAll_Attrs\n    --  are the attributes of the activation call. Task_Attrs are the attributes\n-   --  of the task type. Flag In_Task_Body should be set when the processing is\n-   --  initiated from a task body.\n+   --  of the task type. Flag In_Partial_Fin shoud be set when the processing\n+   --  is initiated by a partial finalization routine. Flag In_Task_Body should\n+   --  be set when the processing is initiated from a task body.\n \n    procedure Process_Activation_Guaranteed_ABE_Impl\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Obj_Id       : Entity_Id;\n-      Task_Attrs   : Task_Attributes;\n-      In_Task_Body : Boolean);\n-   --  Perform common guaranteed ABE checks and diagnostics for call Call\n-   --  which activates task Obj_Id ignoring the Ada or SPARK rules. CAll_Attrs\n-   --  are the attributes of the activation call. Task_Attrs are the attributes\n-   --  of the task type. Flag In_Task_Body should be set when the processing is\n-   --  initiated from a task body.\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Obj_Id         : Entity_Id;\n+      Task_Attrs     : Task_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n+   --  Perform common guaranteed ABE checks and diagnostics for call Call which\n+   --  activates task Obj_Id ignoring the Ada or SPARK rules. Task_Attrs are\n+   --  the attributes of the task type. The following parameters are provided\n+   --  for compatibility and are unused.\n+   --\n+   --    Call_Attrs\n+   --    In_Partial_Fin\n+   --    In_Task_Body\n \n    procedure Process_Call\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      In_Task_Body : Boolean);\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Top-level dispatcher for processing of calls. Perform ABE checks and\n    --  diagnostics for call Call which invokes target Target_Id. Call_Attrs\n-   --  are the attributes of the call. Flag In_Task_Body should be set when\n-   --  the processing is initiated from a task body.\n+   --  are the attributes of the call. Flag In_Partial_Fin shoud be set when\n+   --  the processing is initiated by a partial finalization routine. Flag\n+   --  In_Task_Body should be set when the processing is started from a task\n+   --  body.\n \n    procedure Process_Call_Ada\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      Target_Attrs : Target_Attributes;\n-      In_Task_Body : Boolean);\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      Target_Attrs   : Target_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Perform ABE checks and diagnostics for call Call which invokes target\n    --  Target_Id using the Ada rules. Call_Attrs are the attributes of the\n-   --  call. Target_Attrs are attributes of the target. Flag In_Task_Body\n-   --  should be set when the processing is initiated from a task body.\n+   --  call. Target_Attrs are attributes of the target. Flag In_Partial_Fin\n+   --  shoud be set when the processing is initiated by a partial finalization\n+   --  routine. Flag In_Task_Body should be set when the processing is started\n+   --  from a task body.\n \n    procedure Process_Call_Conditional_ABE\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      Target_Attrs : Target_Attributes);\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      Target_Attrs   : Target_Attributes;\n+      In_Partial_Fin : Boolean);\n    --  Perform common conditional ABE checks and diagnostics for call Call that\n    --  invokes target Target_Id ignoring the Ada or SPARK rules. Call_Attrs are\n    --  the attributes of the call. Target_Attrs are attributes of the target.\n+   --  Flag In_Partial_Fin shoud be set when the processing is initiated by a\n+   --  partial finalization routine.\n \n    procedure Process_Call_Guaranteed_ABE\n      (Call       : Node_Id;\n@@ -1292,70 +1320,87 @@ package body Sem_Elab is\n    --  the attributes of the call.\n \n    procedure Process_Call_SPARK\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      Target_Attrs : Target_Attributes);\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      Target_Attrs   : Target_Attributes;\n+      In_Partial_Fin : Boolean);\n    --  Perform ABE checks and diagnostics for call Call which invokes target\n    --  Target_Id using the SPARK rules. Call_Attrs are the attributes of the\n-   --  call. Target_Attrs are attributes of the target.\n+   --  call. Target_Attrs are attributes of the target. Flag In_Partial_Fin\n+   --  shoud be set when the processing is initiated by a partial finalization\n+   --  routine.\n \n    procedure Process_Guaranteed_ABE (N : Node_Id);\n    --  Top level dispatcher for processing of scenarios which result in a\n    --  guaranteed ABE.\n \n    procedure Process_Instantiation\n-     (Exp_Inst     : Node_Id;\n-      In_Task_Body : Boolean);\n+     (Exp_Inst       : Node_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Top level dispatcher for processing of instantiations. Perform ABE\n    --  checks and diagnostics for expanded instantiation Exp_Inst. Flag\n-   --  In_Task_Body should be set when the processing is initiated from a\n-   --  task body.\n+   --  In_Partial_Fin shoud be set when the processing is initiated by a\n+   --  partial finalization routine. Flag In_Task_Body should be set when\n+   --  the processing is initiated from a task body.\n \n    procedure Process_Instantiation_Ada\n-     (Exp_Inst     : Node_Id;\n-      Inst         : Node_Id;\n-      Inst_Attrs   : Instantiation_Attributes;\n-      Gen_Id       : Entity_Id;\n-      Gen_Attrs    : Target_Attributes;\n-      In_Task_Body : Boolean);\n+     (Exp_Inst       : Node_Id;\n+      Inst           : Node_Id;\n+      Inst_Attrs     : Instantiation_Attributes;\n+      Gen_Id         : Entity_Id;\n+      Gen_Attrs      : Target_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Perform ABE checks and diagnostics for expanded instantiation Exp_Inst\n    --  of generic Gen_Id using the Ada rules. Inst is the instantiation node.\n-   --  Inst_Attrs are the attributes of the instance. Gen_Attrs are the\n-   --  attributes of the generic. Flag In_Task_Body should be set when the\n-   --  processing is initiated from a task body.\n+   --  Inst_Attrs are the attributes of the instance. Gen_Attrs denotes the\n+   --  attributes of the generic. Flag In_Partial_Fin shoud be set when the\n+   --  processing is initiated by a partial finalization routine. In_Task_Body\n+   --  should be set when the processing is initiated from a task body.\n \n    procedure Process_Instantiation_Conditional_ABE\n-     (Exp_Inst   : Node_Id;\n-      Inst       : Node_Id;\n-      Inst_Attrs : Instantiation_Attributes;\n-      Gen_Id     : Entity_Id;\n-      Gen_Attrs  : Target_Attributes);\n+     (Exp_Inst       : Node_Id;\n+      Inst           : Node_Id;\n+      Inst_Attrs     : Instantiation_Attributes;\n+      Gen_Id         : Entity_Id;\n+      Gen_Attrs      : Target_Attributes;\n+      In_Partial_Fin : Boolean);\n    --  Perform common conditional ABE checks and diagnostics for expanded\n    --  instantiation Exp_Inst of generic Gen_Id ignoring the Ada or SPARK\n    --  rules. Inst is the instantiation node. Inst_Attrs are the attributes\n-   --  of the instance. Gen_Attrs are the attributes of the generic.\n+   --  of the instance. Gen_Attrs are the attributes of the generic. Flag\n+   --  In_Partial_Fin shoud be set when the processing is initiated by a\n+   --  partial finalization routine.\n \n    procedure Process_Instantiation_Guaranteed_ABE (Exp_Inst : Node_Id);\n    --  Perform common guaranteed ABE checks and diagnostics for expanded\n    --  instantiation Exp_Inst of generic Gen_Id ignoring the Ada or SPARK\n    --  rules.\n \n    procedure Process_Instantiation_SPARK\n-     (Exp_Inst   : Node_Id;\n-      Inst       : Node_Id;\n-      Inst_Attrs : Instantiation_Attributes;\n-      Gen_Id     : Entity_Id;\n-      Gen_Attrs  : Target_Attributes);\n+     (Exp_Inst       : Node_Id;\n+      Inst           : Node_Id;\n+      Inst_Attrs     : Instantiation_Attributes;\n+      Gen_Id         : Entity_Id;\n+      Gen_Attrs      : Target_Attributes;\n+      In_Partial_Fin : Boolean);\n    --  Perform ABE checks and diagnostics for expanded instantiation Exp_Inst\n    --  of generic Gen_Id using the SPARK rules. Inst is the instantiation node.\n-   --  Inst_Attrs are the attributes of the instance. Gen_Attrs are the\n-   --  attributes of the generic.\n-\n-   procedure Process_Scenario (N : Node_Id; In_Task_Body : Boolean := False);\n+   --  Inst_Attrs are the attributes of the instance. Gen_Attrs denotes the\n+   --  attributes of the generic. Flag In_Partial_Fin shoud be set when the\n+   --  processing is initiated by a partial finalization routine.\n+\n+   procedure Process_Scenario\n+     (N              : Node_Id;\n+      In_Partial_Fin : Boolean := False;\n+      In_Task_Body   : Boolean := False);\n    --  Top level dispatcher for processing of various elaboration scenarios.\n-   --  Perform ABE checks and diagnostics for scenario N. Flag In_Task_Body\n-   --  should be set when the processing is initiated from a task body.\n+   --  Perform ABE checks and diagnostics for scenario N. Flag In_Partial_Fin\n+   --  shoud be set when the processing is initiated by a partial finalization\n+   --  routine. Flag In_Task_Body should be set when the processing is started\n+   --  from a task body.\n \n    procedure Process_Variable_Assignment (Asmt : Node_Id);\n    --  Top level dispatcher for processing of variable assignments. Perform ABE\n@@ -1391,10 +1436,15 @@ package body Sem_Elab is\n    pragma Inline (Static_Elaboration_Checks);\n    --  Determine whether the static model is in effect\n \n-   procedure Traverse_Body (N : Node_Id; In_Task_Body : Boolean);\n+   procedure Traverse_Body\n+     (N              : Node_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean);\n    --  Inspect the declarations and statements of subprogram body N for\n-   --  suitable elaboration scenarios and process them. Flag In_Task_Body\n-   --  should be set when the traversal is initiated from a task body.\n+   --  suitable elaboration scenarios and process them. Flag In_Partial_Fin\n+   --  shoud be set when the processing is initiated by a partial finalization\n+   --  routine. Flag In_Task_Body should be set when the traversal is initiated\n+   --  from a task body.\n \n    procedure Update_Elaboration_Scenario (New_N : Node_Id; Old_N : Node_Id);\n    pragma Inline (Update_Elaboration_Scenario);\n@@ -1996,9 +2046,10 @@ package body Sem_Elab is\n    ------------------------------\n \n    procedure Ensure_Prior_Elaboration\n-     (N            : Node_Id;\n-      Unit_Id      : Entity_Id;\n-      In_Task_Body : Boolean)\n+     (N              : Node_Id;\n+      Unit_Id        : Entity_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n       Prag_Nam : Name_Id;\n \n@@ -2035,11 +2086,18 @@ package body Sem_Elab is\n          Prag_Nam := Name_Elaborate_All;\n       end if;\n \n+      --  Nothing to do when the need for prior elaboration came from a partial\n+      --  finalization routine which occurs in an initialization context. This\n+      --  behaviour parallels that of the old ABE mechanism.\n+\n+      if In_Partial_Fin then\n+         return;\n+\n       --  Nothing to do when the need for prior elaboration came from a task\n       --  body and switch -gnatd.y (disable implicit pragma Elaborate_All on\n       --  task bodies) is in effect.\n \n-      if Debug_Flag_Dot_Y and then In_Task_Body then\n+      elsif Debug_Flag_Dot_Y and then In_Task_Body then\n          return;\n \n       --  Nothing to do when the unit is elaborated prior to the main unit.\n@@ -6253,7 +6311,11 @@ package body Sem_Elab is\n    -- Process_Access --\n    --------------------\n \n-   procedure Process_Access (Attr : Node_Id; In_Task_Body : Boolean) is\n+   procedure Process_Access\n+     (Attr           : Node_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n+   is\n       function Build_Access_Marker (Target_Id : Entity_Id) return Node_Id;\n       pragma Inline (Build_Access_Marker);\n       --  Create a suitable call marker which invokes target Target_Id\n@@ -6340,17 +6402,19 @@ package body Sem_Elab is\n \n       if Debug_Flag_Dot_O then\n          Process_Scenario\n-           (N            => Build_Access_Marker (Target_Id),\n-            In_Task_Body => In_Task_Body);\n+           (N              => Build_Access_Marker (Target_Id),\n+            In_Partial_Fin => In_Partial_Fin,\n+            In_Task_Body   => In_Task_Body);\n \n       --  Otherwise ensure that the unit with the corresponding body is\n       --  elaborated prior to the main unit.\n \n       else\n          Ensure_Prior_Elaboration\n-           (N            => Attr,\n-            Unit_Id      => Target_Attrs.Unit_Id,\n-            In_Task_Body => In_Task_Body);\n+           (N              => Attr,\n+            Unit_Id        => Target_Attrs.Unit_Id,\n+            In_Partial_Fin => In_Partial_Fin,\n+            In_Task_Body   => In_Task_Body);\n       end if;\n    end Process_Access;\n \n@@ -6359,9 +6423,10 @@ package body Sem_Elab is\n    -----------------------------\n \n    procedure Process_Activation_Call\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      In_Task_Body : Boolean)\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n       procedure Process_Task_Object (Obj_Id : Entity_Id; Typ : Entity_Id);\n       --  Perform ABE checks and diagnostics for object Obj_Id with type Typ.\n@@ -6389,11 +6454,12 @@ package body Sem_Elab is\n                Attrs => Task_Attrs);\n \n             Process_Single_Activation\n-              (Call         => Call,\n-               Call_Attrs   => Call_Attrs,\n-               Obj_Id       => Obj_Id,\n-               Task_Attrs   => Task_Attrs,\n-               In_Task_Body => In_Task_Body);\n+              (Call           => Call,\n+               Call_Attrs     => Call_Attrs,\n+               Obj_Id         => Obj_Id,\n+               Task_Attrs     => Task_Attrs,\n+               In_Partial_Fin => In_Partial_Fin,\n+               In_Task_Body   => In_Task_Body);\n \n          --  Examine the component type when the object is an array\n \n@@ -6507,11 +6573,12 @@ package body Sem_Elab is\n    ---------------------------------------------\n \n    procedure Process_Activation_Conditional_ABE_Impl\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Obj_Id       : Entity_Id;\n-      Task_Attrs   : Task_Attributes;\n-      In_Task_Body : Boolean)\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Obj_Id         : Entity_Id;\n+      Task_Attrs     : Task_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n       Check_OK : constant Boolean :=\n                    not Is_Ignored_Ghost_Entity (Obj_Id)\n@@ -6650,12 +6717,19 @@ package body Sem_Elab is\n \n          if Earlier_In_Extended_Unit (Root, Task_Attrs.Body_Decl) then\n \n+            --  Do not emit any ABE diagnostics when the activation occurs in\n+            --  a partial finalization context because this leads to confusing\n+            --  noise.\n+\n+            if In_Partial_Fin then\n+               null;\n+\n             --  ABE diagnostics are emitted only in the static model because\n             --  there is a well-defined order to visiting scenarios. Without\n             --  this order diagnostics appear jumbled and result in unwanted\n             --  noise.\n \n-            if Static_Elaboration_Checks then\n+            elsif Static_Elaboration_Checks then\n                Error_Msg_Sloc := Sloc (Call);\n                Error_Msg_N\n                  (\"??task & will be activated # before elaboration of its \"\n@@ -6707,12 +6781,16 @@ package body Sem_Elab is\n \n       else\n          Ensure_Prior_Elaboration\n-           (N            => Call,\n-            Unit_Id      => Task_Attrs.Unit_Id,\n-            In_Task_Body => In_Task_Body);\n+           (N              => Call,\n+            Unit_Id        => Task_Attrs.Unit_Id,\n+            In_Partial_Fin => In_Partial_Fin,\n+            In_Task_Body   => In_Task_Body);\n       end if;\n \n-      Traverse_Body (Task_Attrs.Body_Decl, In_Task_Body => True);\n+      Traverse_Body\n+        (N              => Task_Attrs.Body_Decl,\n+         In_Partial_Fin => In_Partial_Fin,\n+         In_Task_Body   => True);\n    end Process_Activation_Conditional_ABE_Impl;\n \n    procedure Process_Activation_Conditional_ABE is\n@@ -6723,13 +6801,15 @@ package body Sem_Elab is\n    --------------------------------------------\n \n    procedure Process_Activation_Guaranteed_ABE_Impl\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Obj_Id       : Entity_Id;\n-      Task_Attrs   : Task_Attributes;\n-      In_Task_Body : Boolean)\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Obj_Id         : Entity_Id;\n+      Task_Attrs     : Task_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n       pragma Unreferenced (Call_Attrs);\n+      pragma Unreferenced (In_Partial_Fin);\n       pragma Unreferenced (In_Task_Body);\n \n       Check_OK : constant Boolean :=\n@@ -6868,19 +6948,108 @@ package body Sem_Elab is\n    ------------------\n \n    procedure Process_Call\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      In_Task_Body : Boolean)\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n+      function In_Initialization_Context (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N appears within a type init proc,\n+      --  primitive [Deep_]Initialize, or a block created for initialization\n+      --  purposes.\n+\n+      function Is_Partial_Finalization_Proc return Boolean;\n+      pragma Inline (Is_Partial_Finalization_Proc);\n+      --  Determine whether call Call with target Target_Id invokes a partial\n+      --  finalization procedure.\n+\n+      -------------------------------\n+      -- In_Initialization_Context --\n+      -------------------------------\n+\n+      function In_Initialization_Context (N : Node_Id) return Boolean is\n+         Par     : Node_Id;\n+         Spec_Id : Entity_Id;\n+\n+      begin\n+         --  Climb the parent chain looking for initialization actions\n+\n+         Par := Parent (N);\n+         while Present (Par) loop\n+\n+            --  A block may be part of the initialization actions of a default\n+            --  initialized object.\n+\n+            if Nkind (Par) = N_Block_Statement\n+              and then Is_Initialization_Block (Par)\n+            then\n+               return True;\n+\n+            --  A subprogram body may denote an initialization routine\n+\n+            elsif Nkind (Par) = N_Subprogram_Body then\n+               Spec_Id := Unique_Defining_Entity (Par);\n+\n+               --  The current subprogram body denotes a type init proc or\n+               --  primitive [Deep_]Initialize.\n+\n+               if Is_Init_Proc (Spec_Id)\n+                 or else Is_Controlled_Proc (Spec_Id, Name_Initialize)\n+                 or else Is_TSS (Spec_Id, TSS_Deep_Initialize)\n+               then\n+                  return True;\n+               end if;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return False;\n+      end In_Initialization_Context;\n+\n+      ----------------------------------\n+      -- Is_Partial_Finalization_Proc --\n+      ----------------------------------\n+\n+      function Is_Partial_Finalization_Proc return Boolean is\n+      begin\n+         --  To qualify, the target must denote primitive [Deep_]Finalize or a\n+         --  finalizer procedure, and the call must appear in an initialization\n+         --  context.\n+\n+         return\n+           (Is_Controlled_Proc (Target_Id, Name_Finalize)\n+              or else Is_Finalizer_Proc (Target_Id)\n+              or else Is_TSS (Target_Id, TSS_Deep_Finalize))\n+            and then In_Initialization_Context (Call);\n+      end Is_Partial_Finalization_Proc;\n+\n+      --  Local variables\n+\n+      Partial_Fin_On : Boolean;\n       SPARK_Rules_On : Boolean;\n       Target_Attrs   : Target_Attributes;\n \n+   --  Start of processing for Process_Call\n+\n    begin\n       Extract_Target_Attributes\n         (Target_Id => Target_Id,\n          Attrs     => Target_Attrs);\n \n+      --  The call occurs in a partial finalization context when a prior\n+      --  scenario is already in that mode, or when the target denotes a\n+      --  [Deep_]Finalize primitive or a finalizer within an initialization\n+      --  context.\n+\n+      Partial_Fin_On := In_Partial_Fin or else Is_Partial_Finalization_Proc;\n+\n       --  The SPARK rules are in effect when both the call and target are\n       --  subject to SPARK_Mode On.\n \n@@ -6954,96 +7123,44 @@ package body Sem_Elab is\n \n       elsif SPARK_Rules_On and Debug_Flag_Dot_V then\n          Process_Call_SPARK\n-           (Call         => Call,\n-            Call_Attrs   => Call_Attrs,\n-            Target_Id    => Target_Id,\n-            Target_Attrs => Target_Attrs);\n+           (Call           => Call,\n+            Call_Attrs     => Call_Attrs,\n+            Target_Id      => Target_Id,\n+            Target_Attrs   => Target_Attrs,\n+            In_Partial_Fin => In_Partial_Fin);\n \n       --  Otherwise the Ada rules are in effect, or SPARK code is allowed to\n       --  violate the SPARK rules.\n \n       else\n          Process_Call_Ada\n-           (Call         => Call,\n-            Call_Attrs   => Call_Attrs,\n-            Target_Id    => Target_Id,\n-            Target_Attrs => Target_Attrs,\n-            In_Task_Body => In_Task_Body);\n+           (Call           => Call,\n+            Call_Attrs     => Call_Attrs,\n+            Target_Id      => Target_Id,\n+            Target_Attrs   => Target_Attrs,\n+            In_Partial_Fin => Partial_Fin_On,\n+            In_Task_Body   => In_Task_Body);\n       end if;\n \n       --  Inspect the target body (and barried function) for other suitable\n       --  elaboration scenarios.\n \n-      Traverse_Body (Target_Attrs.Body_Barf, In_Task_Body);\n-      Traverse_Body (Target_Attrs.Body_Decl, In_Task_Body);\n+      Traverse_Body (Target_Attrs.Body_Barf, Partial_Fin_On, In_Task_Body);\n+      Traverse_Body (Target_Attrs.Body_Decl, Partial_Fin_On, In_Task_Body);\n    end Process_Call;\n \n    ----------------------\n    -- Process_Call_Ada --\n    ----------------------\n \n    procedure Process_Call_Ada\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      Target_Attrs : Target_Attributes;\n-      In_Task_Body : Boolean)\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      Target_Attrs   : Target_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n-      function In_Initialization_Context (N : Node_Id) return Boolean;\n-      --  Determine whether arbitrary node N appears within a type init proc or\n-      --  primitive [Deep_]Initialize.\n-\n-      -------------------------------\n-      -- In_Initialization_Context --\n-      -------------------------------\n-\n-      function In_Initialization_Context (N : Node_Id) return Boolean is\n-         Par     : Node_Id;\n-         Spec_Id : Entity_Id;\n-\n-      begin\n-         --  Climb the parent chain looking for initialization actions\n-\n-         Par := Parent (N);\n-         while Present (Par) loop\n-\n-            --  A block may be part of the initialization actions of a default\n-            --  initialized object.\n-\n-            if Nkind (Par) = N_Block_Statement\n-              and then Is_Initialization_Block (Par)\n-            then\n-               return True;\n-\n-            --  A subprogram body may denote an initialization routine\n-\n-            elsif Nkind (Par) = N_Subprogram_Body then\n-               Spec_Id := Unique_Defining_Entity (Par);\n-\n-               --  The current subprogram body denotes a type init proc or\n-               --  primitive [Deep_]Initialize.\n-\n-               if Is_Init_Proc (Spec_Id)\n-                 or else Is_Controlled_Proc (Spec_Id, Name_Initialize)\n-                 or else Is_TSS (Spec_Id, TSS_Deep_Initialize)\n-               then\n-                  return True;\n-               end if;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         return False;\n-      end In_Initialization_Context;\n-\n-      --  Local variables\n-\n       Check_OK : constant Boolean :=\n                    not Call_Attrs.Ghost_Mode_Ignore\n                      and then not Target_Attrs.Ghost_Mode_Ignore\n@@ -7053,8 +7170,6 @@ package body Sem_Elab is\n       --  target have active elaboration checks, and both are not ignored Ghost\n       --  constructs.\n \n-   --  Start of processing for Process_Call_Ada\n-\n    begin\n       --  Nothing to do for an Ada dispatching call because there are no ABE\n       --  diagnostics for either models. ABE checks for the dynamic model are\n@@ -7088,10 +7203,11 @@ package body Sem_Elab is\n         and then In_Extended_Main_Code_Unit (Target_Attrs.Body_Decl)\n       then\n          Process_Call_Conditional_ABE\n-           (Call         => Call,\n-            Call_Attrs   => Call_Attrs,\n-            Target_Id    => Target_Id,\n-            Target_Attrs => Target_Attrs);\n+           (Call           => Call,\n+            Call_Attrs     => Call_Attrs,\n+            Target_Id      => Target_Id,\n+            Target_Attrs   => Target_Attrs,\n+            In_Partial_Fin => In_Partial_Fin);\n \n       --  Otherwise the target body is not available in this compilation or it\n       --  resides in an external unit. Install a run-time ABE check to verify\n@@ -7105,35 +7221,17 @@ package body Sem_Elab is\n             Id      => Target_Attrs.Unit_Id);\n       end if;\n \n-      --  No implicit pragma Elaborate[_All] is generated when the call has\n-      --  elaboration checks suppressed. This behaviour parallels that of the\n-      --  old ABE mechanism.\n-\n-      if not Call_Attrs.Elab_Checks_OK then\n-         null;\n-\n-      --  No implicit pragma Elaborate[_All] is generated for finalization\n-      --  actions when primitive [Deep_]Finalize is not defined in the main\n-      --  unit and the call appears within some initialization actions. This\n-      --  behaviour parallels that of the old ABE mechanism.\n-\n-      --  Performance note: parent traversal\n-\n-      elsif (Is_Controlled_Proc (Target_Id, Name_Finalize)\n-              or else Is_TSS (Target_Id, TSS_Deep_Finalize))\n-        and then not In_Extended_Main_Code_Unit (Target_Attrs.Spec_Decl)\n-        and then In_Initialization_Context (Call)\n-      then\n-         null;\n-\n-      --  Otherwise ensure that the unit with the target body is elaborated\n-      --  prior to the main unit.\n+      --  Ensure that the unit with the target body is elaborated prior to the\n+      --  main unit. The implicit Elaborate[_All] is generated only when the\n+      --  call has elaboration checks enabled. This behaviour parallels that of\n+      --  the old ABE mechanism.\n \n-      else\n+      if Call_Attrs.Elab_Checks_OK then\n          Ensure_Prior_Elaboration\n-           (N            => Call,\n-            Unit_Id      => Target_Attrs.Unit_Id,\n-            In_Task_Body => In_Task_Body);\n+           (N              => Call,\n+            Unit_Id        => Target_Attrs.Unit_Id,\n+            In_Partial_Fin => In_Partial_Fin,\n+            In_Task_Body   => In_Task_Body);\n       end if;\n    end Process_Call_Ada;\n \n@@ -7142,10 +7240,11 @@ package body Sem_Elab is\n    ----------------------------------\n \n    procedure Process_Call_Conditional_ABE\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      Target_Attrs : Target_Attributes)\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      Target_Attrs   : Target_Attributes;\n+      In_Partial_Fin : Boolean)\n    is\n       Check_OK : constant Boolean :=\n                    not Call_Attrs.Ghost_Mode_Ignore\n@@ -7186,11 +7285,17 @@ package body Sem_Elab is\n \n       if Earlier_In_Extended_Unit (Root, Target_Attrs.Body_Decl) then\n \n+         --  Do not emit any ABE diagnostics when the call occurs in a partial\n+         --  finalization context because this leads to confusing noise.\n+\n+         if In_Partial_Fin then\n+            null;\n+\n          --  ABE diagnostics are emitted only in the static model because there\n          --  is a well-defined order to visiting scenarios. Without this order\n          --  diagnostics appear jumbled and result in unwanted noise.\n \n-         if Static_Elaboration_Checks then\n+         elsif Static_Elaboration_Checks then\n             Error_Msg_NE (\"??cannot call & before body seen\", Call, Target_Id);\n             Error_Msg_N (\"\\Program_Error may be raised at run time\", Call);\n \n@@ -7329,10 +7434,11 @@ package body Sem_Elab is\n    ------------------------\n \n    procedure Process_Call_SPARK\n-     (Call         : Node_Id;\n-      Call_Attrs   : Call_Attributes;\n-      Target_Id    : Entity_Id;\n-      Target_Attrs : Target_Attributes)\n+     (Call           : Node_Id;\n+      Call_Attrs     : Call_Attributes;\n+      Target_Id      : Entity_Id;\n+      Target_Attrs   : Target_Attributes;\n+      In_Partial_Fin : Boolean)\n    is\n    begin\n       --  A call to a source target or to a target which emulates Ada or SPARK\n@@ -7376,10 +7482,11 @@ package body Sem_Elab is\n         and then In_Extended_Main_Code_Unit (Target_Attrs.Body_Decl)\n       then\n          Process_Call_Conditional_ABE\n-           (Call         => Call,\n-            Call_Attrs   => Call_Attrs,\n-            Target_Id    => Target_Id,\n-            Target_Attrs => Target_Attrs);\n+           (Call           => Call,\n+            Call_Attrs     => Call_Attrs,\n+            Target_Id      => Target_Id,\n+            Target_Attrs   => Target_Attrs,\n+            In_Partial_Fin => In_Partial_Fin);\n \n       --  Otherwise the target body is not available in this compilation or it\n       --  resides in an external unit. There is no need to guarantee the prior\n@@ -7416,9 +7523,10 @@ package body Sem_Elab is\n \n          if Is_Activation_Proc (Target_Id) then\n             Process_Activation_Guaranteed_ABE\n-              (Call         => N,\n-               Call_Attrs   => Call_Attrs,\n-               In_Task_Body => False);\n+              (Call           => N,\n+               Call_Attrs     => Call_Attrs,\n+               In_Partial_Fin => False,\n+               In_Task_Body   => False);\n \n          else\n             Process_Call_Guaranteed_ABE\n@@ -7442,8 +7550,9 @@ package body Sem_Elab is\n    ---------------------------\n \n    procedure Process_Instantiation\n-     (Exp_Inst     : Node_Id;\n-      In_Task_Body : Boolean)\n+     (Exp_Inst       : Node_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n       Gen_Attrs  : Target_Attributes;\n       Gen_Id     : Entity_Id;\n@@ -7524,23 +7633,25 @@ package body Sem_Elab is\n \n       elsif SPARK_Rules_On and Debug_Flag_Dot_V then\n          Process_Instantiation_SPARK\n-           (Exp_Inst   => Exp_Inst,\n-            Inst       => Inst,\n-            Inst_Attrs => Inst_Attrs,\n-            Gen_Id     => Gen_Id,\n-            Gen_Attrs  => Gen_Attrs);\n+           (Exp_Inst       => Exp_Inst,\n+            Inst           => Inst,\n+            Inst_Attrs     => Inst_Attrs,\n+            Gen_Id         => Gen_Id,\n+            Gen_Attrs      => Gen_Attrs,\n+            In_Partial_Fin => In_Partial_Fin);\n \n       --  Otherwise the Ada rules are in effect, or SPARK code is allowed to\n       --  violate the SPARK rules.\n \n       else\n          Process_Instantiation_Ada\n-           (Exp_Inst     => Exp_Inst,\n-            Inst         => Inst,\n-            Inst_Attrs   => Inst_Attrs,\n-            Gen_Id       => Gen_Id,\n-            Gen_Attrs    => Gen_Attrs,\n-            In_Task_Body => In_Task_Body);\n+           (Exp_Inst       => Exp_Inst,\n+            Inst           => Inst,\n+            Inst_Attrs     => Inst_Attrs,\n+            Gen_Id         => Gen_Id,\n+            Gen_Attrs      => Gen_Attrs,\n+            In_Partial_Fin => In_Partial_Fin,\n+            In_Task_Body   => In_Task_Body);\n       end if;\n    end Process_Instantiation;\n \n@@ -7549,12 +7660,13 @@ package body Sem_Elab is\n    -------------------------------\n \n    procedure Process_Instantiation_Ada\n-     (Exp_Inst     : Node_Id;\n-      Inst         : Node_Id;\n-      Inst_Attrs   : Instantiation_Attributes;\n-      Gen_Id       : Entity_Id;\n-      Gen_Attrs    : Target_Attributes;\n-      In_Task_Body : Boolean)\n+     (Exp_Inst       : Node_Id;\n+      Inst           : Node_Id;\n+      Inst_Attrs     : Instantiation_Attributes;\n+      Gen_Id         : Entity_Id;\n+      Gen_Attrs      : Target_Attributes;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n    is\n       Check_OK : constant Boolean :=\n                    not Inst_Attrs.Ghost_Mode_Ignore\n@@ -7591,11 +7703,12 @@ package body Sem_Elab is\n         and then In_Extended_Main_Code_Unit (Gen_Attrs.Body_Decl)\n       then\n          Process_Instantiation_Conditional_ABE\n-           (Exp_Inst   => Exp_Inst,\n-            Inst       => Inst,\n-            Inst_Attrs => Inst_Attrs,\n-            Gen_Id     => Gen_Id,\n-            Gen_Attrs  => Gen_Attrs);\n+           (Exp_Inst       => Exp_Inst,\n+            Inst           => Inst,\n+            Inst_Attrs     => Inst_Attrs,\n+            Gen_Id         => Gen_Id,\n+            Gen_Attrs      => Gen_Attrs,\n+            In_Partial_Fin => In_Partial_Fin);\n \n       --  Otherwise the generic body is not available in this compilation or it\n       --  resides in an external unit. Install a run-time ABE check to verify\n@@ -7616,9 +7729,10 @@ package body Sem_Elab is\n \n       if Inst_Attrs.Elab_Checks_OK then\n          Ensure_Prior_Elaboration\n-           (N            => Inst,\n-            Unit_Id      => Gen_Attrs.Unit_Id,\n-            In_Task_Body => In_Task_Body);\n+           (N              => Inst,\n+            Unit_Id        => Gen_Attrs.Unit_Id,\n+            In_Partial_Fin => In_Partial_Fin,\n+            In_Task_Body   => In_Task_Body);\n       end if;\n    end Process_Instantiation_Ada;\n \n@@ -7627,11 +7741,12 @@ package body Sem_Elab is\n    -------------------------------------------\n \n    procedure Process_Instantiation_Conditional_ABE\n-     (Exp_Inst   : Node_Id;\n-      Inst       : Node_Id;\n-      Inst_Attrs : Instantiation_Attributes;\n-      Gen_Id     : Entity_Id;\n-      Gen_Attrs  : Target_Attributes)\n+     (Exp_Inst       : Node_Id;\n+      Inst           : Node_Id;\n+      Inst_Attrs     : Instantiation_Attributes;\n+      Gen_Id         : Entity_Id;\n+      Gen_Attrs      : Target_Attributes;\n+      In_Partial_Fin : Boolean)\n    is\n       Check_OK : constant Boolean :=\n                    not Inst_Attrs.Ghost_Mode_Ignore\n@@ -7676,11 +7791,17 @@ package body Sem_Elab is\n \n       if Earlier_In_Extended_Unit (Root, Gen_Attrs.Body_Decl) then\n \n+         --  Do not emit any ABE diagnostics when the instantiation occurs in a\n+         --  partial finalization context because this leads to unwanted noise.\n+\n+         if In_Partial_Fin then\n+            null;\n+\n          --  ABE diagnostics are emitted only in the static model because there\n          --  is a well-defined order to visiting scenarios. Without this order\n          --  diagnostics appear jumbled and result in unwanted noise.\n \n-         if Static_Elaboration_Checks then\n+         elsif Static_Elaboration_Checks then\n             Error_Msg_NE\n               (\"??cannot instantiate & before body seen\", Inst, Gen_Id);\n             Error_Msg_N (\"\\Program_Error may be raised at run time\", Inst);\n@@ -7832,11 +7953,12 @@ package body Sem_Elab is\n    ---------------------------------\n \n    procedure Process_Instantiation_SPARK\n-     (Exp_Inst   : Node_Id;\n-      Inst       : Node_Id;\n-      Inst_Attrs : Instantiation_Attributes;\n-      Gen_Id     : Entity_Id;\n-      Gen_Attrs  : Target_Attributes)\n+     (Exp_Inst       : Node_Id;\n+      Inst           : Node_Id;\n+      Inst_Attrs     : Instantiation_Attributes;\n+      Gen_Id         : Entity_Id;\n+      Gen_Attrs      : Target_Attributes;\n+      In_Partial_Fin : Boolean)\n    is\n       Req_Nam : Name_Id;\n \n@@ -7882,11 +8004,12 @@ package body Sem_Elab is\n         and then In_Extended_Main_Code_Unit (Gen_Attrs.Body_Decl)\n       then\n          Process_Instantiation_Conditional_ABE\n-           (Exp_Inst   => Exp_Inst,\n-            Inst       => Inst,\n-            Inst_Attrs => Inst_Attrs,\n-            Gen_Id     => Gen_Id,\n-            Gen_Attrs  => Gen_Attrs);\n+           (Exp_Inst       => Exp_Inst,\n+            Inst           => Inst,\n+            Inst_Attrs     => Inst_Attrs,\n+            Gen_Id         => Gen_Id,\n+            Gen_Attrs      => Gen_Attrs,\n+            In_Partial_Fin => In_Partial_Fin);\n \n       --  Otherwise the generic body is not available in this compilation or\n       --  it resides in an external unit. There is no need to guarantee the\n@@ -8086,7 +8209,11 @@ package body Sem_Elab is\n    -- Process_Scenario --\n    ----------------------\n \n-   procedure Process_Scenario (N : Node_Id; In_Task_Body : Boolean := False) is\n+   procedure Process_Scenario\n+     (N              : Node_Id;\n+      In_Partial_Fin : Boolean := False;\n+      In_Task_Body   : Boolean := False)\n+   is\n       Call_Attrs : Call_Attributes;\n       Target_Id  : Entity_Id;\n \n@@ -8098,7 +8225,7 @@ package body Sem_Elab is\n       --  'Access\n \n       if Is_Suitable_Access (N) then\n-         Process_Access (N, In_Task_Body);\n+         Process_Access (N, In_Partial_Fin, In_Task_Body);\n \n       --  Calls\n \n@@ -8119,23 +8246,25 @@ package body Sem_Elab is\n \n             if Is_Activation_Proc (Target_Id) then\n                Process_Activation_Conditional_ABE\n-                 (Call         => N,\n-                  Call_Attrs   => Call_Attrs,\n-                  In_Task_Body => In_Task_Body);\n+                 (Call           => N,\n+                  Call_Attrs     => Call_Attrs,\n+                  In_Partial_Fin => In_Partial_Fin,\n+                  In_Task_Body   => In_Task_Body);\n \n             else\n                Process_Call\n-                 (Call         => N,\n-                  Call_Attrs   => Call_Attrs,\n-                  Target_Id    => Target_Id,\n-                  In_Task_Body => In_Task_Body);\n+                 (Call           => N,\n+                  Call_Attrs     => Call_Attrs,\n+                  Target_Id      => Target_Id,\n+                  In_Partial_Fin => In_Partial_Fin,\n+                  In_Task_Body   => In_Task_Body);\n             end if;\n          end if;\n \n       --  Instantiations\n \n       elsif Is_Suitable_Instantiation (N) then\n-         Process_Instantiation (N, In_Task_Body);\n+         Process_Instantiation (N, In_Partial_Fin, In_Task_Body);\n \n       --  Variable assignments\n \n@@ -8328,7 +8457,11 @@ package body Sem_Elab is\n    -- Traverse_Body --\n    -------------------\n \n-   procedure Traverse_Body (N : Node_Id; In_Task_Body : Boolean) is\n+   procedure Traverse_Body\n+     (N              : Node_Id;\n+      In_Partial_Fin : Boolean;\n+      In_Task_Body   : Boolean)\n+   is\n       function Is_Potential_Scenario (Nod : Node_Id) return Traverse_Result;\n       --  Determine whether arbitrary node Nod denotes a suitable scenario and\n       --  if so, process it.\n@@ -8387,7 +8520,7 @@ package body Sem_Elab is\n          --  General case\n \n          elsif Is_Suitable_Scenario (Nod) then\n-            Process_Scenario (Nod, In_Task_Body);\n+            Process_Scenario (Nod, In_Partial_Fin, In_Task_Body);\n          end if;\n \n          return OK;"}, {"sha": "79c88648fc2fcd1b86c1e2f25f0d0f2bc2529221", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5148da096b0cf5d9d07154361f9005717d88ed9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e5148da096b0cf5d9d07154361f9005717d88ed9", "patch": "@@ -141,7 +141,9 @@ package body Sem_Util is\n \n    function Subprogram_Name (N : Node_Id) return String;\n    --  Return the fully qualified name of the enclosing subprogram for the\n-   --  given node N.\n+   --  given node N, with file:line:col information appended, e.g.\n+   --  \"subp:file:line:col\", corresponding to the source location of the\n+   --  body of the subprogram.\n \n    ------------------------------\n    --  Abstract_Interface_List --\n@@ -594,6 +596,7 @@ package body Sem_Util is\n       -----------\n \n       procedure Inner (E : Entity_Id) is\n+         Scop : Node_Id;\n       begin\n          --  If entity has an internal name, skip by it, and print its scope.\n          --  Note that we strip a final R from the name before the test; this\n@@ -615,21 +618,23 @@ package body Sem_Util is\n             end if;\n          end;\n \n+         Scop := Scope (E);\n+\n          --  Just print entity name if its scope is at the outer level\n \n-         if Scope (E) = Standard_Standard then\n+         if Scop = Standard_Standard then\n             null;\n \n          --  If scope comes from source, write scope and entity\n \n-         elsif Comes_From_Source (Scope (E)) then\n-            Append_Entity_Name (Temp, Scope (E));\n+         elsif Comes_From_Source (Scop) then\n+            Append_Entity_Name (Temp, Scop);\n             Append (Temp, '.');\n \n          --  If in wrapper package skip past it\n \n-         elsif Is_Wrapper_Package (Scope (E)) then\n-            Append_Entity_Name (Temp, Scope (Scope (E)));\n+         elsif Present (Scop) and then Is_Wrapper_Package (Scop) then\n+            Append_Entity_Name (Temp, Scope (Scop));\n             Append (Temp, '.');\n \n          --  Otherwise nothing to output (happens in unnamed block statements)\n@@ -23295,6 +23300,7 @@ package body Sem_Util is\n    function Subprogram_Name (N : Node_Id) return String is\n       Buf : Bounded_String;\n       Ent : Node_Id := N;\n+      Nod : Node_Id;\n \n    begin\n       while Present (Ent) loop\n@@ -23303,17 +23309,32 @@ package body Sem_Util is\n                Ent := Defining_Unit_Name (Specification (Ent));\n                exit;\n \n-            when N_Package_Body\n+            when N_Subprogram_Declaration =>\n+               Nod := Corresponding_Body (Ent);\n+\n+               if Present (Nod) then\n+                  Ent := Nod;\n+               else\n+                  Ent := Defining_Unit_Name (Specification (Ent));\n+               end if;\n+\n+               exit;\n+\n+            when N_Subprogram_Instantiation\n+               | N_Package_Body\n                | N_Package_Specification\n-               | N_Subprogram_Specification\n             =>\n                Ent := Defining_Unit_Name (Ent);\n                exit;\n \n+            when N_Protected_Type_Declaration =>\n+               Ent := Corresponding_Body (Ent);\n+               exit;\n+\n             when N_Protected_Body\n-               | N_Protected_Type_Declaration\n                | N_Task_Body\n             =>\n+               Ent := Defining_Identifier (Ent);\n                exit;\n \n             when others =>\n@@ -23324,18 +23345,32 @@ package body Sem_Util is\n       end loop;\n \n       if No (Ent) then\n-         return \"unknown subprogram\";\n+         return \"unknown subprogram:unknown file:0:0\";\n       end if;\n \n       --  If the subprogram is a child unit, use its simple name to start the\n       --  construction of the fully qualified name.\n \n       if Nkind (Ent) = N_Defining_Program_Unit_Name then\n-         Append_Entity_Name (Buf, Defining_Identifier (Ent));\n-      else\n-         Append_Entity_Name (Buf, Ent);\n+         Ent := Defining_Identifier (Ent);\n       end if;\n \n+      Append_Entity_Name (Buf, Ent);\n+\n+      --  Append source location of Ent to Buf so that the string will\n+      --  look like \"subp:file:line:col\".\n+\n+      declare\n+         Loc : constant Source_Ptr := Sloc (Ent);\n+      begin\n+         Append (Buf, ':');\n+         Append (Buf, Reference_Name (Get_Source_File_Index (Loc)));\n+         Append (Buf, ':');\n+         Append (Buf, Nat (Get_Logical_Line_Number (Loc)));\n+         Append (Buf, ':');\n+         Append (Buf, Nat (Get_Column_Number (Loc)));\n+      end;\n+\n       return +Buf;\n    end Subprogram_Name;\n "}]}