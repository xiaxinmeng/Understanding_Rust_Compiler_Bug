{"sha": "34e985136246df6832aed4dccdf7ed0cbcf4a9aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRlOTg1MTM2MjQ2ZGY2ODMyYWVkNGRjY2RmN2VkMGNiY2Y0YTlhYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-09-14T17:54:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-09-14T17:54:08Z"}, "message": "compiler: Ignore result context in constant expressions.\n\n    \n    When evaluating a constant expression, the gofrontend would incorrectly\n    force each operand to be represented as the resulting type before\n    checking if the operation was valid with the untyped constants.\n    According to the language specification on constant\n    expressions(http://golang.org/ref/spec#Constant_expressions): \"Untyped\n    boolean, numeric, and string constants may be used as operands wherever\n    it is legal to use an operand of boolean, numeric, or string type,\n    respectively.\"\n    \n    Fixes golang/go#11566.\n    \n    Reviewed-on: https://go-review.googlesource.com/12716\n\nFrom-SVN: r227758", "tree": {"sha": "2c86b3223c4eba8a77141ab30c23d32233a1007f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c86b3223c4eba8a77141ab30c23d32233a1007f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34e985136246df6832aed4dccdf7ed0cbcf4a9aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e985136246df6832aed4dccdf7ed0cbcf4a9aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34e985136246df6832aed4dccdf7ed0cbcf4a9aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e985136246df6832aed4dccdf7ed0cbcf4a9aa/comments", "author": null, "committer": null, "parents": [{"sha": "5c270a92a8ee5fe89dbadb743a3e4e2392b96dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c270a92a8ee5fe89dbadb743a3e4e2392b96dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c270a92a8ee5fe89dbadb743a3e4e2392b96dbc"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "cc7db66426593e406338a11ce0189ef8038ff097", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e985136246df6832aed4dccdf7ed0cbcf4a9aa/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e985136246df6832aed4dccdf7ed0cbcf4a9aa/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=34e985136246df6832aed4dccdf7ed0cbcf4a9aa", "patch": "@@ -1,4 +1,4 @@\n-aea4360ca9c37f8e929f177ae7e42593ee62aa79\n+1d9d92ab09996d2f7795481d2876a21194502b89\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "488c76ca6bc9696d713e6b0a7b8605758d7e9075", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e985136246df6832aed4dccdf7ed0cbcf4a9aa/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e985136246df6832aed4dccdf7ed0cbcf4a9aa/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=34e985136246df6832aed4dccdf7ed0cbcf4a9aa", "patch": "@@ -5307,6 +5307,14 @@ Binary_expression::do_determine_type(const Type_context* context)\n \t\t\t|| this->op_ == OPERATOR_GT\n \t\t\t|| this->op_ == OPERATOR_GE);\n \n+  // For constant expressions, the context of the result is not useful in\n+  // determining the types of the operands.  It is only legal to use abstract\n+  // boolean, numeric, and string constants as operands where it is legal to\n+  // use non-abstract boolean, numeric, and string constants, respectively.\n+  // Any issues with the operation will be resolved in the check_types pass.\n+  bool is_constant_expr = (this->left_->is_constant()\n+                           && this->right_->is_constant());\n+\n   Type_context subcontext(*context);\n \n   if (is_comparison)\n@@ -5351,7 +5359,8 @@ Binary_expression::do_determine_type(const Type_context* context)\n \tsubcontext.type = subcontext.type->make_non_abstract_type();\n     }\n \n-  this->left_->determine_type(&subcontext);\n+  if (!is_constant_expr)\n+    this->left_->determine_type(&subcontext);\n \n   if (is_shift_op)\n     {\n@@ -5371,7 +5380,8 @@ Binary_expression::do_determine_type(const Type_context* context)\n       subcontext.may_be_abstract = false;\n     }\n \n-  this->right_->determine_type(&subcontext);\n+  if (!is_constant_expr)\n+    this->right_->determine_type(&subcontext);\n \n   if (is_comparison)\n     {\n@@ -5396,7 +5406,8 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n     {\n     case OPERATOR_OROR:\n     case OPERATOR_ANDAND:\n-      if (!type->is_boolean_type())\n+      if (!type->is_boolean_type()\n+          || !otype->is_boolean_type())\n \t{\n \t  error_at(location, \"expected boolean type\");\n \t  return false;\n@@ -5431,10 +5442,8 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n \n     case OPERATOR_PLUS:\n     case OPERATOR_PLUSEQ:\n-      if (type->integer_type() == NULL\n-\t  && type->float_type() == NULL\n-\t  && type->complex_type() == NULL\n-\t  && !type->is_string_type())\n+      if ((!type->is_numeric_type() && !type->is_string_type())\n+          || (!otype->is_numeric_type() && !otype->is_string_type()))\n \t{\n \t  error_at(location,\n \t\t   \"expected integer, floating, complex, or string type\");\n@@ -5448,9 +5457,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n     case OPERATOR_MULTEQ:\n     case OPERATOR_DIV:\n     case OPERATOR_DIVEQ:\n-      if (type->integer_type() == NULL\n-\t  && type->float_type() == NULL\n-\t  && type->complex_type() == NULL)\n+      if (!type->is_numeric_type() || !otype->is_numeric_type())\n \t{\n \t  error_at(location, \"expected integer, floating, or complex type\");\n \t  return false;\n@@ -5467,7 +5474,7 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n     case OPERATOR_XOREQ:\n     case OPERATOR_BITCLEAR:\n     case OPERATOR_BITCLEAREQ:\n-      if (type->integer_type() == NULL)\n+      if (type->integer_type() == NULL || otype->integer_type() == NULL)\n \t{\n \t  error_at(location, \"expected integer type\");\n \t  return false;"}]}