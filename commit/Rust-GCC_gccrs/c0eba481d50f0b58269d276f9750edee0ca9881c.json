{"sha": "c0eba481d50f0b58269d276f9750edee0ca9881c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlYmE0ODFkNTBmMGI1ODI2OWQyNzZmOTc1MGVkZWUwY2E5ODgxYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-07-02T08:32:13Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-07-02T08:32:13Z"}, "message": "gfortran.texi (Fortran 2003): Add ISO Bind C.\n\n2007-07-02  Tobias Burnus  <burnus@net-b.de>\n\n\t* gfortran.texi (Fortran 2003): Add ISO Bind C.\n\t* intrinsic.texi (C_ASSOCIATED,C_F_POINTER,C_F_PROCPOINTER,\n\tC_FUNLOC,C_LOC): Document new ISO Bind C intrinsics.\n\nFrom-SVN: r126192", "tree": {"sha": "87a4c1f8c496d967139d8b361a83562050cbb72a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87a4c1f8c496d967139d8b361a83562050cbb72a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0eba481d50f0b58269d276f9750edee0ca9881c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0eba481d50f0b58269d276f9750edee0ca9881c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0eba481d50f0b58269d276f9750edee0ca9881c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0eba481d50f0b58269d276f9750edee0ca9881c/comments", "author": null, "committer": null, "parents": [{"sha": "901119aedeb8c8dae26e21d0853cadc882b2f9a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/901119aedeb8c8dae26e21d0853cadc882b2f9a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/901119aedeb8c8dae26e21d0853cadc882b2f9a0"}], "stats": {"total": 282, "additions": 281, "deletions": 1}, "files": [{"sha": "6f0747e723a3ed1adc98c55a3f073386b19288ee", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0eba481d50f0b58269d276f9750edee0ca9881c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0eba481d50f0b58269d276f9750edee0ca9881c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c0eba481d50f0b58269d276f9750edee0ca9881c", "patch": "@@ -1,3 +1,9 @@\n+2007-07-02  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.texi (Fortran 2003): Add ISO Bind C.\n+\t* intrinsic.texi (C_ASSOCIATED,C_F_POINTER,C_F_PROCPOINTER,\n+\tC_FUNLOC,C_LOC): Document new ISO Bind C intrinsics.\n+\n 2007-07-01  Christopher D. Rickett  <crickett@lanl.gov>\n \n \t* interface.c (gfc_compare_derived_types): Special case for comparing\n@@ -10,7 +16,7 @@\n \tNULL_FUNPTR.\n \t(gfc_conv_expr): Convert expressions for ISO C Binding derived types.\n \t* symbol.c (gfc_set_default_type): BIND(C) variables should not be\n-\timplicitly declared.\n+\tImplicitly declared.\n \t(check_conflict): Add BIND(C) and check for conflicts.\n \t(gfc_add_explicit_interface): Whitespace.\t\n \t(gfc_add_is_bind_c): New function.  "}, {"sha": "1125326235a3d72cee49100e243ea6a2d828fbac", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0eba481d50f0b58269d276f9750edee0ca9881c/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0eba481d50f0b58269d276f9750edee0ca9881c/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=c0eba481d50f0b58269d276f9750edee0ca9881c", "patch": "@@ -815,6 +815,10 @@ attribute; supported intrinsic modules: @code{ISO_FORTRAN_ENV},\n @item\n Renaming of operators in the @code{USE} statement.\n \n+@item\n+@cindex ISO C Bindings\n+Interoperability with C (ISO C Bindings)\n+\n @end itemize\n \n "}, {"sha": "7ac40ab0cff1363890afe68e2f546d2e2135680d", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0eba481d50f0b58269d276f9750edee0ca9881c/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0eba481d50f0b58269d276f9750edee0ca9881c/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=c0eba481d50f0b58269d276f9750edee0ca9881c", "patch": "@@ -70,6 +70,11 @@ Some basic guidelines for editing this document:\n * @code{BESYN}:         BESYN,     Bessel function of the second kind\n * @code{BIT_SIZE}:      BIT_SIZE,  Bit size inquiry function\n * @code{BTEST}:         BTEST,     Bit test function\n+* @code{C_ASSOCIATED}:  C_ASSOCIATED, Status of a C pointer\n+* @code{C_F_POINTER}:   C_F_POINTER, Convert C into Fortran pointer\n+* @code{C_F_PROCPOINTER}: C_F_PROCPOINTER, Convert C into Fortran procedure pointer\n+* @code{C_FUNLOC}:      C_FUNLOC,  Obtain the C address of a procedure\n+* @code{C_LOC}:         C_LOC,     Obtain the C address of an object\n * @code{CEILING}:       CEILING,   Integer ceiling function\n * @code{CHAR}:          CHAR,      Integer-to-character conversion function\n * @code{CHDIR}:         CHDIR,     Change working directory\n@@ -1837,6 +1842,271 @@ end program test_btest\n @end table\n \n \n+@node C_ASSOCIATED\n+@section @code{C_ASSOCIATED} --- Status of a C pointer\n+@fnindex C_ASSOCIATED\n+@cindex associatation status, C pointer\n+@cindex pointer, C associatation status\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{C_ASSOICATED(c_prt1[, c_ptr2])} determines the status of the C pointer @var{c_ptr1}\n+or if @var{c_ptr1} is associated with the target @var{c_ptr2}.\n+\n+@item @emph{Standard}:\n+F2003 and later\n+\n+@item @emph{Class}:\n+Inquiry function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = C_ASSOICATED(c_prt1[, c_ptr2])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{c_ptr1} @tab Scalar of the type @code{C_PTR} or @code{C_FUNPTR}.\n+@item @var{c_ptr2} @tab (Optional) Scalar of the same type as @var{c_ptr1}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{LOGICAL}; it is @code{.false.} if either\n+@var{c_ptr1} is a C NULL pointer or if @var{c_ptr1} and @var{c_ptr2}\n+point to different addresses.\n+\n+@item @emph{Example}:\n+@smallexample\n+subroutine association_test(a,b)\n+  use iso_c_binding, only: c_associated, c_loc, c_ptr\n+  implicit none\n+  real, pointer :: a\n+  type(c_ptr) :: b\n+  if(c_associated(b, c_loc(a))) &\n+     stop 'b and a do not point to same target'\n+end subroutine association_test\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{C_LOC}, @ref{C_FUNLOC}\n+@end table\n+\n+\n+@node C_FUNLOC\n+@section @code{C_FUNLOC} --- Obtain the C address of a procedure\n+@fnindex C_FUNLOC\n+@cindex pointer, C address of procedures\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{C_FUNLOC(x)} determines the C address of the argument.\n+\n+@item @emph{Standard}:\n+F2003 and later\n+\n+@item @emph{Class}:\n+Inquiry function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = C_FUNLOC(x)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{x} @tab Interoperable function or pointer to such function.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{C_FUNPTR} and contains the C address\n+of the argument.\n+\n+@item @emph{Example}:\n+@smallexample\n+module x\n+  use iso_c_binding\n+  implicit none\n+contains\n+  subroutine sub(a) bind(c)\n+    real(c_float) :: a\n+    a = sqrt(a)+5.0\n+  end subroutine sub\n+end module x\n+program main\n+  use iso_c_binding\n+  use x\n+  implicit none\n+  interface\n+    subroutine my_routine(p) bind(c,name='myC_func')\n+      import :: c_funptr\n+      type(c_funptr), intent(in) :: p\n+    end subroutine\n+  end interface\n+  call my_routine(c_funloc(sub))\n+end program main\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{C_ASSOCIATED}, @ref{C_LOC}, @ref{C_F_POINTER}, @ref{C_F_PROCPOINTER}\n+@end table\n+\n+\n+@node C_F_PROCPOINTER\n+@section @code{C_F_PROCPOINTER} --- Convert C into Fortran procedure pointer\n+@fnindex C_F_PROCPOINTER\n+@cindex pointer, C address of pointers\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{C_F_PROCPOINTER(cptr, fptr)} Assign the target of the C function pointer\n+@var{cptr} to the Fortran procedure pointer @var{fptr}.\n+\n+Note: Due to the currently lacking support of procedure pointers in GNU Fortran\n+this function is not fully operable.\n+\n+@item @emph{Standard}:\n+F2003 and later\n+\n+@item @emph{Class}:\n+Subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL C_F_PROCPOINTER(cptr, fptr)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{cptr}  @tab scalar of the type @code{C_FUNPTR}. It is\n+\t\t       @code{INTENT(IN)}.\n+@item @var{fptr}  @tab procedure pointer interoperable with @var{cptr}. It is\n+\t\t       @code{INTENT(OUT)}.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program main\n+  use iso_c_binding\n+  implicit none\n+  abstract interface\n+    function func(a)\n+      import :: c_float\n+      real(c_float), intent(in) :: a\n+      real(c_float) :: func\n+    end function\n+  end interface\n+  interface\n+     function getIterFunc() bind(c,name=\"getIterFunc\")\n+       import :: c_funptr\n+       type(c_funptr) :: getIterFunc\n+     end function\n+  end interface\n+  type(c_funptr) :: cfunptr\n+  procedure(func), pointer :: myFunc\n+  cfunptr = getIterFunc()\n+  call c_f_procpointer(cfunptr, myFunc)\n+end program main\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{C_LOC}, @ref{C_F_POINTER}\n+@end table\n+\n+\n+@node C_F_POINTER\n+@section @code{C_F_POINTER} --- Convert C into Fortran pointer\n+@fnindex C_F_POINTER\n+@cindex pointer, convert C to Fortran\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{C_F_POINTER(cptr, fptr[, shape])} Assign the target the C pointer\n+@var{cptr} to the Fortran pointer @var{fptr} and specify its\n+shape.\n+\n+@item @emph{Standard}:\n+F2003 and later\n+\n+@item @emph{Class}:\n+Subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL C_F_POINTER(cptr, fptr[, shape])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{cptr}  @tab scalar of the type @code{C_PTR}. It is\n+\t\t       @code{INTENT(IN)}.\n+@item @var{fptr}  @tab pointer interoperable with @var{cptr}. It is\n+\t\t       @code{INTENT(OUT)}.\n+@item @var{shape} @tab (Optional) Rank-one array of type @code{INTEGER}\n+                       with @code{INTENT(IN)}. It shall be present\n+\t\t       if and only if @var{fptr} is an array. The size\n+\t\t       must be equal to the rank of @var{fptr}.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program main\n+  use iso_c_binding\n+  implicit none\n+  interface\n+    subroutine my_routine(p) bind(c,name='myC_func')\n+      import :: c_ptr\n+      type(c_ptr), intent(out) :: p\n+    end subroutine\n+  end interface\n+  type(c_ptr) :: cptr\n+  real,pointer :: a(:)\n+  call my_routine(cptr)\n+  call c_f_pointer(cptr, a, [12])\n+end program main\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{C_LOC}, @ref{C_F_PROCPOINTER}\n+@end table\n+\n+\n+@node C_LOC\n+@section @code{C_LOC} --- Obtain the C address of an object\n+@fnindex C_LOC\n+@cindex procedure pointer, convert C to Fortran\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{C_LOC(x)} determines the C address of the argument.\n+\n+@item @emph{Standard}:\n+F2003 and later\n+\n+@item @emph{Class}:\n+Inquiry function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = C_LOC(x)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{x} @tab Associated scalar pointer or interoperatable scalar\n+\t\t   or allocated allocatable variable with @code{TARGET}\n+\t\t   attribute.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{C_PTR} and contains the C address\n+of the argument.\n+\n+@item @emph{Example}:\n+@smallexample\n+subroutine association_test(a,b)\n+  use iso_c_binding, only: c_associated, c_loc, c_ptr\n+  implicit none\n+  real, pointer :: a\n+  type(c_ptr) :: b\n+  if(c_associated(b, c_loc(a))) &\n+     stop 'b and a do not point to same target'\n+end subroutine association_test\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{C_ASSOCIATED}, @ref{C_FUNLOC}, @ref{C_F_POINTER}, @ref{C_F_PROCPOINTER}\n+@end table\n+\n \n @node CEILING\n @section @code{CEILING} --- Integer ceiling function"}]}