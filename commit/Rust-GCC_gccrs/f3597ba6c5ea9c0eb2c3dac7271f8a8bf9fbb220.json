{"sha": "f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220", "node_id": "C_kwDOANBUbNoAKGYzNTk3YmE2YzVlYTljMGViMmMzZGFjNzI3MWY4YThiZjlmYmIyMjA", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-10-06T05:23:48Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-14T13:46:51Z"}, "message": "ada: hardcfr docs: add optional checkpoints\n\nPreviously, control flow redundancy only checked the visited bitmap\nagainst the control flow graph at return points and before mandatory\ntail calls, missing various other possibilities of exiting a\nsubprogram, such as by raising or propagating exceptions, and calling\nnoreturn functions.  The checks inserted before returns also prevented\npotential tail-call optimizations.\n\nThis incremental change introduces options to control checking at each\nof these previously-missed checkpoints.  Unless disabled, a cleanup is\nintroduced to check when an exceptions escapes a subprogram.  To avoid\ndisrupting sibcall optimizations, when they are enabled, checks are\nintroduced before calls whose results are immediately returned,\nwhether or not they are ultimately optimized.  If enabled, checks are\nintroduced before noreturn calls and exception raises, or only before\nnothrow noreturn calls.\n\nAdd examples of code transformations to the GNAT RM.\n\ngcc/ada/\n\n\t* doc/gnat_rm/security_hardening_features.rst: Document optional\n\thardcfr checkpoints.\n\t* gnat_rm.texi: Regenerate.\n\t* gnat_ugn.texi: Regenerate.", "tree": {"sha": "e173356435df8c2c9e2846dd9d694d1c0f78a675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e173356435df8c2c9e2846dd9d694d1c0f78a675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90b9052e0b5df49d6c298c4706978135d2af2a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b9052e0b5df49d6c298c4706978135d2af2a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90b9052e0b5df49d6c298c4706978135d2af2a86"}], "stats": {"total": 254, "additions": 240, "deletions": 14}, "files": [{"sha": "ad165cd6849354fe3f771fab84228fef11fcddff", "filename": "gcc/ada/doc/gnat_rm/security_hardening_features.rst", "status": "modified", "additions": 121, "deletions": 5, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst?ref=f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220", "patch": "@@ -383,11 +383,127 @@ For each block that is marked as visited, the mechanism checks that at\n least one of its predecessors, and at least one of its successors, are\n also marked as visited.\n \n-Verification is performed just before returning.  Subprogram\n-executions that complete by raising or propagating an exception bypass\n-verification-and-return points.  A subprogram that can only complete\n-by raising or propagating an exception may have instrumentation\n-disabled altogether.\n+Verification is performed just before a subprogram returns.  The\n+following fragment:\n+\n+.. code-block:: ada\n+\n+   if X then\n+     Y := F (Z);\n+     return;\n+   end if;\n+\n+\n+gets turned into:\n+\n+.. code-block:: ada\n+\n+   type Visited_Bitmap is array (1..N) of Boolean with Pack;\n+   Visited : aliased Visited_Bitmap := (others => False);\n+   --  Bitmap of visited blocks.  N is the basic block count.\n+   [...]\n+   --  Basic block #I\n+   Visited(I) := True;\n+   if X then\n+     --  Basic block #J\n+     Visited(J) := True;\n+     Y := F (Z);\n+     CFR.Check (N, Visited'Access, CFG'Access);\n+     --  CFR is a hypothetical package whose Check procedure calls\n+     --  libgcc's __hardcfr_check, that traps if the Visited bitmap\n+     --  does not hold a valid path in CFG, the run-time\n+     --  representation of the control flow graph in the enclosing\n+     --  subprogram.\n+     return;\n+   end if;\n+   --  Basic block #K\n+   Visited(K) := True;\n+\n+\n+Verification would also be performed before tail calls, if any\n+front-ends marked them as mandatory or desirable, but none do.\n+Regular calls are optimized into tail calls too late for this\n+transformation to act on it.\n+\n+In order to avoid adding verification after potential tail calls,\n+which would prevent tail-call optimization, we recognize returning\n+calls, i.e., calls whose result, if any, is returned by the calling\n+subprogram to its caller immediately after the call returns.\n+Verification is performed before such calls, whether or not they are\n+ultimately optimized to tail calls.  This behavior is enabled by\n+default whenever sibcall optimization is enabled (see\n+:switch:`-foptimize-sibling-calls`); it may be disabled with\n+:switch:`-fno-hardcfr-check-returning-calls`, or enabled with\n+:switch:`-fhardcfr-check-returning-calls`, regardless of the\n+optimization, but the lack of other optimizations may prevent calls\n+from being recognized as returning calls:\n+\n+.. code-block:: ada\n+\n+     --  CFR.Check here, with -fhardcfr-check-returning-calls.\n+     P (X);\n+     --  CFR.Check here, with -fno-hardcfr-check-returning-calls.\n+     return;\n+\n+or:\n+\n+.. code-block:: ada\n+\n+     --  CFR.Check here, with -fhardcfr-check-returning-calls.\n+     R := F (X);\n+     --  CFR.Check here, with -fno-hardcfr-check-returning-calls.\n+     return R;\n+\n+\n+Any subprogram from which an exception may escape, i.e., that may\n+raise or propagate an exception that isn't handled internally, is\n+conceptually enclosed by a cleanup handler that performs verification,\n+unless this is disabled with :switch:`-fno-hardcfr-check-exceptions`.\n+With this feature enabled, a subprogram body containing:\n+\n+.. code-block:: ada\n+\n+     --  ...\n+       Y := F (X);  -- May raise exceptions.\n+     --  ...\n+       raise E;  -- Not handled internally.\n+     --  ...\n+\n+\n+gets modified as follows:\n+\n+.. code-block:: ada\n+\n+   begin\n+     --  ...\n+       Y := F (X);  -- May raise exceptions.\n+     --  ...\n+       raise E;  -- Not handled internally.\n+     --  ...\n+   exception\n+     when others =>\n+       CFR.Check (N, Visited'Access, CFG'Access);\n+       raise;\n+   end;\n+\n+\n+Verification may also be performed before No_Return calls, whether\n+only nothrow ones, with\n+:switch:`-fhardcfr-check-noreturn-calls=nothrow`, or all of them, with\n+:switch:`-fhardcfr-check-noreturn-calls=always`.  The default is\n+:switch:`-fhardcfr-check-noreturn-calls=never` for this feature, that\n+disables checking before No_Return calls.\n+\n+When a No_Return call returns control to its caller through an\n+exception, verification may have already been performed before the\n+call, if :switch:`-fhardcfr-check-noreturn-calls=always` is in effect.\n+The compiler arranges for already-checked No_Return calls without a\n+preexisting handler to bypass the implicitly-added cleanup handler and\n+thus the redundant check, but a local exception or cleanup handler, if\n+present, will modify the set of visited blocks, and checking will take\n+place again when the caller reaches the next verification point,\n+whether it is a return or reraise statement after the exception is\n+otherwise handled, or even another No_Return call.\n \n The instrumentation for hardening with control flow redundancy can be\n observed in dump files generated by the command-line option"}, {"sha": "83458cb60a6a9f10286b77db88ddb405a28be826", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 117, "deletions": 6, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220", "patch": "@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Oct 27, 2022\n+GNAT Reference Manual , Nov 14, 2022\n \n AdaCore\n \n@@ -29037,11 +29037,122 @@ For each block that is marked as visited, the mechanism checks that at\n least one of its predecessors, and at least one of its successors, are\n also marked as visited.\n \n-Verification is performed just before returning.  Subprogram\n-executions that complete by raising or propagating an exception bypass\n-verification-and-return points.  A subprogram that can only complete\n-by raising or propagating an exception may have instrumentation\n-disabled altogether.\n+Verification is performed just before a subprogram returns.  The\n+following fragment:\n+\n+@example\n+if X then\n+  Y := F (Z);\n+  return;\n+end if;\n+@end example\n+\n+gets turned into:\n+\n+@example\n+type Visited_Bitmap is array (1..N) of Boolean with Pack;\n+Visited : aliased Visited_Bitmap := (others => False);\n+--  Bitmap of visited blocks.  N is the basic block count.\n+[...]\n+--  Basic block #I\n+Visited(I) := True;\n+if X then\n+  --  Basic block #J\n+  Visited(J) := True;\n+  Y := F (Z);\n+  CFR.Check (N, Visited'Access, CFG'Access);\n+  --  CFR is a hypothetical package whose Check procedure calls\n+  --  libgcc's __hardcfr_check, that traps if the Visited bitmap\n+  --  does not hold a valid path in CFG, the run-time\n+  --  representation of the control flow graph in the enclosing\n+  --  subprogram.\n+  return;\n+end if;\n+--  Basic block #K\n+Visited(K) := True;\n+@end example\n+\n+Verification would also be performed before tail calls, if any\n+front-ends marked them as mandatory or desirable, but none do.\n+Regular calls are optimized into tail calls too late for this\n+transformation to act on it.\n+\n+In order to avoid adding verification after potential tail calls,\n+which would prevent tail-call optimization, we recognize returning\n+calls, i.e., calls whose result, if any, is returned by the calling\n+subprogram to its caller immediately after the call returns.\n+Verification is performed before such calls, whether or not they are\n+ultimately optimized to tail calls.  This behavior is enabled by\n+default whenever sibcall optimization is enabled (see\n+@code{-foptimize-sibling-calls}); it may be disabled with\n+@code{-fno-hardcfr-check-returning-calls}, or enabled with\n+@code{-fhardcfr-check-returning-calls}, regardless of the\n+optimization, but the lack of other optimizations may prevent calls\n+from being recognized as returning calls:\n+\n+@example\n+--  CFR.Check here, with -fhardcfr-check-returning-calls.\n+P (X);\n+--  CFR.Check here, with -fno-hardcfr-check-returning-calls.\n+return;\n+@end example\n+\n+or:\n+\n+@example\n+--  CFR.Check here, with -fhardcfr-check-returning-calls.\n+R := F (X);\n+--  CFR.Check here, with -fno-hardcfr-check-returning-calls.\n+return R;\n+@end example\n+\n+Any subprogram from which an exception may escape, i.e., that may\n+raise or propagate an exception that isn\u2019t handled internally, is\n+conceptually enclosed by a cleanup handler that performs verification,\n+unless this is disabled with @code{-fno-hardcfr-check-exceptions}.\n+With this feature enabled, a subprogram body containing:\n+\n+@example\n+--  ...\n+  Y := F (X);  -- May raise exceptions.\n+--  ...\n+  raise E;  -- Not handled internally.\n+--  ...\n+@end example\n+\n+gets modified as follows:\n+\n+@example\n+begin\n+  --  ...\n+    Y := F (X);  -- May raise exceptions.\n+  --  ...\n+    raise E;  -- Not handled internally.\n+  --  ...\n+exception\n+  when others =>\n+    CFR.Check (N, Visited'Access, CFG'Access);\n+    raise;\n+end;\n+@end example\n+\n+Verification may also be performed before No_Return calls, whether\n+only nothrow ones, with\n+@code{-fhardcfr-check-noreturn-calls=nothrow}, or all of them, with\n+@code{-fhardcfr-check-noreturn-calls=always}.  The default is\n+@code{-fhardcfr-check-noreturn-calls=never} for this feature, that\n+disables checking before No_Return calls.\n+\n+When a No_Return call returns control to its caller through an\n+exception, verification may have already been performed before the\n+call, if @code{-fhardcfr-check-noreturn-calls=always} is in effect.\n+The compiler arranges for already-checked No_Return calls without a\n+preexisting handler to bypass the implicitly-added cleanup handler and\n+thus the redundant check, but a local exception or cleanup handler, if\n+present, will modify the set of visited blocks, and checking will take\n+place again when the caller reaches the next verification point,\n+whether it is a return or reraise statement after the exception is\n+otherwise handled, or even another No_Return call.\n \n The instrumentation for hardening with control flow redundancy can be\n observed in dump files generated by the command-line option"}, {"sha": "2f43b4f71c8f6d17f876caae042610a4c3e42af2", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=f3597ba6c5ea9c0eb2c3dac7271f8a8bf9fbb220", "patch": "@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-GNAT User's Guide for Native Platforms , Oct 27, 2022\n+GNAT User's Guide for Native Platforms , Nov 14, 2022\n \n AdaCore\n \n@@ -17993,7 +17993,6 @@ instr.ads\n \n \n \n-\n @c -- Example: A |withing| unit has a |with| clause, it |withs| a |withed| unit\n \n @node GNAT and Program Execution,Platform-Specific Information,GNAT Utility Programs,Top\n@@ -29382,8 +29381,8 @@ to permit their use in free software.\n \n @printindex ge\n \n-@anchor{cf}@w{                              }\n @anchor{gnat_ugn/gnat_utility_programs switches-related-to-project-files}@w{                              }\n+@anchor{cf}@w{                              }\n \n @c %**end of body\n @bye"}]}