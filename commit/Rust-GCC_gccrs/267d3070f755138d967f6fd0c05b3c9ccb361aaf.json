{"sha": "267d3070f755138d967f6fd0c05b3c9ccb361aaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY3ZDMwNzBmNzU1MTM4ZDk2N2Y2ZmQwYzA1YjNjOWNjYjM2MWFhZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-04-20T09:25:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-04-20T09:25:42Z"}, "message": "Revert last patch.\n\nFrom-SVN: r172763", "tree": {"sha": "e069d62850ed1e1da9555cd452f0ceaefe28bbce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e069d62850ed1e1da9555cd452f0ceaefe28bbce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/267d3070f755138d967f6fd0c05b3c9ccb361aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267d3070f755138d967f6fd0c05b3c9ccb361aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/267d3070f755138d967f6fd0c05b3c9ccb361aaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267d3070f755138d967f6fd0c05b3c9ccb361aaf/comments", "author": null, "committer": null, "parents": [{"sha": "0b2ddd9ce3a1e6db7b9b16adf75fed550f05d0ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2ddd9ce3a1e6db7b9b16adf75fed550f05d0ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b2ddd9ce3a1e6db7b9b16adf75fed550f05d0ce"}], "stats": {"total": 892, "additions": 262, "deletions": 630}, "files": [{"sha": "5ff852bd001d090473eda02da695c48f5a1c629b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -1,3 +1,10 @@\n+2011-04-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/md.texi, optabs.h, genopinit.c, internal-fn.def\n+\tinternal-fn.c, tree.h, tree.c, tree-vectorizer.h,\n+\ttree-vect-data-refs.c, tree-vect-stmts.c, tree-vect-slp.c: Revert\n+\tlast patch.\n+\n 2011-04-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* doc/md.texi (vec_load_lanes, vec_store_lanes): Document."}, {"sha": "6dab0651eab528751989fc6982b0709be9ec5560", "filename": "gcc/config/arm/t-linux-eabi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Fconfig%2Farm%2Ft-linux-eabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Fconfig%2Farm%2Ft-linux-eabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-linux-eabi?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -21,8 +21,8 @@ TARGET_LIBGCC2_CFLAGS = -fPIC\n \n # We do not build a Thumb multilib for Linux because the definition of\n # CLEAR_INSN_CACHE in linux-gas.h does not work in Thumb mode.\n-MULTILIB_OPTIONS\t=\n-MULTILIB_DIRNAMES\t=\n+MULTILIB_OPTIONS\t= mthumb\n+MULTILIB_DIRNAMES\t= thumb\n \n #MULTILIB_OPTIONS     += mcpu=fa606te/mcpu=fa626te/mcpu=fmp626/mcpu=fa726te\n #MULTILIB_DIRNAMES    += fa606te fa626te fmp626 fa726te"}, {"sha": "df99ad4d6261d079a90b4da5879c369ab2acc898", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -3846,48 +3846,6 @@ into consecutive memory locations.  Operand 0 is the first of the\n consecutive memory locations, operand 1 is the first register, and\n operand 2 is a constant: the number of consecutive registers.\n \n-@cindex @code{vec_load_lanes@var{m}@var{n}} instruction pattern\n-@item @samp{vec_load_lanes@var{m}@var{n}}\n-Perform an interleaved load of several vectors from memory operand 1\n-into register operand 0.  Both operands have mode @var{m}.  The register\n-operand is viewed as holding consecutive vectors of mode @var{n},\n-while the memory operand is a flat array that contains the same number\n-of elements.  The operation is equivalent to:\n-\n-@smallexample\n-int c = GET_MODE_SIZE (@var{m}) / GET_MODE_SIZE (@var{n});\n-for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)\n-  for (i = 0; i < c; i++)\n-    operand0[i][j] = operand1[j * c + i];\n-@end smallexample\n-\n-For example, @samp{vec_load_lanestiv4hi} loads 8 16-bit values\n-from memory into a register of mode @samp{TI}@.  The register\n-contains two consecutive vectors of mode @samp{V4HI}@.\n-\n-This pattern can only be used if:\n-@smallexample\n-TARGET_ARRAY_MODE_SUPPORTED_P (@var{n}, @var{c})\n-@end smallexample\n-is true.  GCC assumes that, if a target supports this kind of\n-instruction for some mode @var{n}, it also supports unaligned\n-loads for vectors of mode @var{n}.\n-\n-@cindex @code{vec_store_lanes@var{m}@var{n}} instruction pattern\n-@item @samp{vec_store_lanes@var{m}@var{n}}\n-Equivalent to @samp{vec_load_lanes@var{m}@var{n}}, with the memory\n-and register operands reversed.  That is, the instruction is\n-equivalent to:\n-\n-@smallexample\n-int c = GET_MODE_SIZE (@var{m}) / GET_MODE_SIZE (@var{n});\n-for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)\n-  for (i = 0; i < c; i++)\n-    operand0[j * c + i] = operand1[i][j];\n-@end smallexample\n-\n-for a memory operand 0 and register operand 1.\n-\n @cindex @code{vec_set@var{m}} instruction pattern\n @item @samp{vec_set@var{m}}\n Set given field in the vector value.  Operand 0 is the vector to modify,"}, {"sha": "ab31968281c0a657031e683cf396a379be4ab705", "filename": "gcc/genopinit.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -74,8 +74,6 @@ static const char * const optabs[] =\n   \"set_convert_optab_handler (fractuns_optab, $B, $A, CODE_FOR_$(fractuns$Q$a$I$b2$))\",\n   \"set_convert_optab_handler (satfract_optab, $B, $A, CODE_FOR_$(satfract$a$Q$b2$))\",\n   \"set_convert_optab_handler (satfractuns_optab, $B, $A, CODE_FOR_$(satfractuns$I$a$Q$b2$))\",\n-  \"set_convert_optab_handler (vec_load_lanes_optab, $A, $B, CODE_FOR_$(vec_load_lanes$a$b$))\",\n-  \"set_convert_optab_handler (vec_store_lanes_optab, $A, $B, CODE_FOR_$(vec_store_lanes$a$b$))\",\n   \"set_optab_handler (add_optab, $A, CODE_FOR_$(add$P$a3$))\",\n   \"set_optab_handler (addv_optab, $A, CODE_FOR_$(add$F$a3$)),\\n\\\n     set_optab_handler (add_optab, $A, CODE_FOR_$(add$F$a3$))\","}, {"sha": "9f087b83105e2764ffeaddfd6394ad2ec9bcbf36", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -42,73 +42,6 @@ const int internal_fn_flags_array[] = {\n   0\n };\n \n-/* ARRAY_TYPE is an array of vector modes.  Return the associated insn\n-   for load-lanes-style optab OPTAB.  The insn must exist.  */\n-\n-static enum insn_code\n-get_multi_vector_move (tree array_type, convert_optab optab)\n-{\n-  enum insn_code icode;\n-  enum machine_mode imode;\n-  enum machine_mode vmode;\n-\n-  gcc_assert (TREE_CODE (array_type) == ARRAY_TYPE);\n-  imode = TYPE_MODE (array_type);\n-  vmode = TYPE_MODE (TREE_TYPE (array_type));\n-\n-  icode = convert_optab_handler (optab, imode, vmode);\n-  gcc_assert (icode != CODE_FOR_nothing);\n-  return icode;\n-}\n-\n-/* Expand LOAD_LANES call STMT.  */\n-\n-static void\n-expand_LOAD_LANES (gimple stmt)\n-{\n-  struct expand_operand ops[2];\n-  tree type, lhs, rhs;\n-  rtx target, mem;\n-\n-  lhs = gimple_call_lhs (stmt);\n-  rhs = gimple_call_arg (stmt, 0);\n-  type = TREE_TYPE (lhs);\n-\n-  target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n-  mem = expand_normal (rhs);\n-\n-  gcc_assert (MEM_P (mem));\n-  PUT_MODE (mem, TYPE_MODE (type));\n-\n-  create_output_operand (&ops[0], target, TYPE_MODE (type));\n-  create_fixed_operand (&ops[1], mem);\n-  expand_insn (get_multi_vector_move (type, vec_load_lanes_optab), 2, ops);\n-}\n-\n-/* Expand STORE_LANES call STMT.  */\n-\n-static void\n-expand_STORE_LANES (gimple stmt)\n-{\n-  struct expand_operand ops[2];\n-  tree type, lhs, rhs;\n-  rtx target, reg;\n-\n-  lhs = gimple_call_lhs (stmt);\n-  rhs = gimple_call_arg (stmt, 0);\n-  type = TREE_TYPE (rhs);\n-\n-  target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n-  reg = expand_normal (rhs);\n-\n-  gcc_assert (MEM_P (target));\n-  PUT_MODE (target, TYPE_MODE (type));\n-\n-  create_fixed_operand (&ops[0], target);\n-  create_input_operand (&ops[1], reg, TYPE_MODE (type));\n-  expand_insn (get_multi_vector_move (type, vec_store_lanes_optab), 2, ops);\n-}\n-\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "b9b622db71c6e7cce4f2044ce4e997a9c302ae9e", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -37,6 +37,3 @@ along with GCC; see the file COPYING3.  If not see\n      void expand_NAME (gimple stmt)\n \n    where STMT is the statement that performs the call.  */\n-\n-DEF_INTERNAL_FN (LOAD_LANES, ECF_CONST | ECF_LEAF)\n-DEF_INTERNAL_FN (STORE_LANES, ECF_CONST | ECF_LEAF)"}, {"sha": "be61f549fd4ae6461d0b2b6b0d34c29b93369066", "filename": "gcc/optabs.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -578,9 +578,6 @@ enum convert_optab_index\n   COI_satfract,\n   COI_satfractuns,\n \n-  COI_vec_load_lanes,\n-  COI_vec_store_lanes,\n-\n   COI_MAX\n };\n \n@@ -601,8 +598,6 @@ enum convert_optab_index\n #define fractuns_optab (&convert_optab_table[COI_fractuns])\n #define satfract_optab (&convert_optab_table[COI_satfract])\n #define satfractuns_optab (&convert_optab_table[COI_satfractuns])\n-#define vec_load_lanes_optab (&convert_optab_table[COI_vec_load_lanes])\n-#define vec_store_lanes_optab (&convert_optab_table[COI_vec_store_lanes])\n \n /* Contains the optab used for each rtx code.  */\n extern optab code_to_optab[NUM_RTX_CODE + 1];"}, {"sha": "d7d174fbba2fb84be1d3e2c03274e242931dfd86", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 8, "deletions": 76, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -43,45 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"optabs.h\"\n \n-/* Return true if load- or store-lanes optab OPTAB is implemented for\n-   COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */\n-\n-static bool\n-vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n-\t\t\t      tree vectype, unsigned HOST_WIDE_INT count)\n-{\n-  enum machine_mode mode, array_mode;\n-  bool limit_p;\n-\n-  mode = TYPE_MODE (vectype);\n-  limit_p = !targetm.array_mode_supported_p (mode, count);\n-  array_mode = mode_for_size (count * GET_MODE_BITSIZE (mode),\n-\t\t\t      MODE_INT, limit_p);\n-\n-  if (array_mode == BLKmode)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"no array mode for %s[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n-\t\t GET_MODE_NAME (mode), count);\n-      return false;\n-    }\n-\n-  if (convert_optab_handler (optab, array_mode, mode) == CODE_FOR_nothing)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"cannot use %s<%s><%s>\",\n-\t\t name, GET_MODE_NAME (array_mode), GET_MODE_NAME (mode));\n-      return false;\n-    }\n-\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"can use %s<%s><%s>\",\n-\t     name, GET_MODE_NAME (array_mode), GET_MODE_NAME (mode));\n-\n-  return true;\n-}\n-\n-\n /* Return the smallest scalar part of STMT.\n    This is used to determine the vectype of the stmt.  We generally set the\n    vectype according to the type of the result (lhs).  For stmts whose\n@@ -3415,18 +3376,6 @@ vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n }\n \n \n-/* Return TRUE if vec_store_lanes is available for COUNT vectors of\n-   type VECTYPE.  */\n-\n-bool\n-vect_store_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count)\n-{\n-  return vect_lanes_optab_supported_p (\"vec_store_lanes\",\n-\t\t\t\t       vec_store_lanes_optab,\n-\t\t\t\t       vectype, count);\n-}\n-\n-\n /* Function vect_permute_store_chain.\n \n    Given a chain of interleaved stores in DR_CHAIN of LENGTH that must be\n@@ -3881,16 +3830,6 @@ vect_strided_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   return true;\n }\n \n-/* Return TRUE if vec_load_lanes is available for COUNT vectors of\n-   type VECTYPE.  */\n-\n-bool\n-vect_load_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count)\n-{\n-  return vect_lanes_optab_supported_p (\"vec_load_lanes\",\n-\t\t\t\t       vec_load_lanes_optab,\n-\t\t\t\t       vectype, count);\n-}\n \n /* Function vect_permute_load_chain.\n \n@@ -4038,28 +3977,19 @@ void\n vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  gimple first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+  gimple next_stmt, new_stmt;\n   VEC(tree,heap) *result_chain = NULL;\n+  unsigned int i, gap_count;\n+  tree tmp_data_ref;\n \n   /* DR_CHAIN contains input data-refs that are a part of the interleaving.\n      RESULT_CHAIN is the output of vect_permute_load_chain, it contains permuted\n      vectors, that are ready for vector computation.  */\n   result_chain = VEC_alloc (tree, heap, size);\n+  /* Permute.  */\n   vect_permute_load_chain (dr_chain, size, stmt, gsi, &result_chain);\n-  vect_record_strided_load_vectors (stmt, result_chain);\n-  VEC_free (tree, heap, result_chain);\n-}\n-\n-/* RESULT_CHAIN contains the output of a group of strided loads that were\n-   generated as part of the vectorization of STMT.  Assign the statement\n-   for each vector to the associated scalar statement.  */\n-\n-void\n-vect_record_strided_load_vectors (gimple stmt, VEC(tree,heap) *result_chain)\n-{\n-  gimple first_stmt = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt));\n-  gimple next_stmt, new_stmt;\n-  unsigned int i, gap_count;\n-  tree tmp_data_ref;\n \n   /* Put a permuted data-ref in the VECTORIZED_STMT field.\n      Since we scan the chain starting from it's first node, their order\n@@ -4121,6 +4051,8 @@ vect_record_strided_load_vectors (gimple stmt, VEC(tree,heap) *result_chain)\n \t    break;\n         }\n     }\n+\n+  VEC_free (tree, heap, result_chain);\n }\n \n /* Function vect_force_dr_alignment_p."}, {"sha": "6eb67ae5a75e40fccdd9da6660efd92a0496e509", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -215,8 +215,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    vect_model_simple_cost (stmt_info, ncopies_for_cost, dt, slp_node);\n \t  else\n \t    /* Store.  */\n-\t    vect_model_store_cost (stmt_info, ncopies_for_cost, false,\n-\t\t\t\t   dt[0], slp_node);\n+\t    vect_model_store_cost (stmt_info, ncopies_for_cost, dt[0], slp_node);\n \t}\n \n       else\n@@ -580,7 +579,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n                   /* Analyze costs (for the first stmt in the group).  */\n                   vect_model_load_cost (vinfo_for_stmt (stmt),\n-                                        ncopies_for_cost, false, *node);\n+                                        ncopies_for_cost, *node);\n                 }\n \n               /* Store the place of this load in the interleaving chain.  In"}, {"sha": "879153d8031bbf3e73aed9cdbe9a96e64f38b7d4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 240, "deletions": 414, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -42,82 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n \n \n-/* Return a variable of type ELEM_TYPE[NELEMS].  */\n-\n-static tree\n-create_vector_array (tree elem_type, unsigned HOST_WIDE_INT nelems)\n-{\n-  return create_tmp_var (build_array_type_nelts (elem_type, nelems),\n-\t\t\t \"vect_array\");\n-}\n-\n-/* ARRAY is an array of vectors created by create_vector_array.\n-   Return an SSA_NAME for the vector in index N.  The reference\n-   is part of the vectorization of STMT and the vector is associated\n-   with scalar destination SCALAR_DEST.  */\n-\n-static tree\n-read_vector_array (gimple stmt, gimple_stmt_iterator *gsi, tree scalar_dest,\n-\t\t   tree array, unsigned HOST_WIDE_INT n)\n-{\n-  tree vect_type, vect, vect_name, array_ref;\n-  gimple new_stmt;\n-\n-  gcc_assert (TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE);\n-  vect_type = TREE_TYPE (TREE_TYPE (array));\n-  vect = vect_create_destination_var (scalar_dest, vect_type);\n-  array_ref = build4 (ARRAY_REF, vect_type, array,\n-\t\t      build_int_cst (size_type_node, n),\n-\t\t      NULL_TREE, NULL_TREE);\n-\n-  new_stmt = gimple_build_assign (vect, array_ref);\n-  vect_name = make_ssa_name (vect, new_stmt);\n-  gimple_assign_set_lhs (new_stmt, vect_name);\n-  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-  mark_symbols_for_renaming (new_stmt);\n-\n-  return vect_name;\n-}\n-\n-/* ARRAY is an array of vectors created by create_vector_array.\n-   Emit code to store SSA_NAME VECT in index N of the array.\n-   The store is part of the vectorization of STMT.  */\n-\n-static void\n-write_vector_array (gimple stmt, gimple_stmt_iterator *gsi, tree vect,\n-\t\t    tree array, unsigned HOST_WIDE_INT n)\n-{\n-  tree array_ref;\n-  gimple new_stmt;\n-\n-  array_ref = build4 (ARRAY_REF, TREE_TYPE (vect), array,\n-\t\t      build_int_cst (size_type_node, n),\n-\t\t      NULL_TREE, NULL_TREE);\n-\n-  new_stmt = gimple_build_assign (array_ref, vect);\n-  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-  mark_symbols_for_renaming (new_stmt);\n-}\n-\n-/* PTR is a pointer to an array of type TYPE.  Return a representation\n-   of *PTR.  The memory reference replaces those in FIRST_DR\n-   (and its group).  */\n-\n-static tree\n-create_array_ref (tree type, tree ptr, struct data_reference *first_dr)\n-{\n-  struct ptr_info_def *pi;\n-  tree mem_ref, alias_ptr_type;\n-\n-  alias_ptr_type = reference_alias_ptr_type (DR_REF (first_dr));\n-  mem_ref = build2 (MEM_REF, type, ptr, build_int_cst (alias_ptr_type, 0));\n-  /* Arrays have the same alignment as their type.  */\n-  pi = get_ptr_info (ptr);\n-  pi->align = TYPE_ALIGN_UNIT (type);\n-  pi->misalign = 0;\n-  return mem_ref;\n-}\n-\n /* Utility functions used by vect_mark_stmts_to_be_vectorized.  */\n \n /* Function vect_mark_relevant.\n@@ -724,8 +648,7 @@ vect_cost_strided_group_size (stmt_vec_info stmt_info)\n \n void\n vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n-\t\t       bool store_lanes_p, enum vect_def_type dt,\n-\t\t       slp_tree slp_node)\n+\t\t       enum vect_def_type dt, slp_tree slp_node)\n {\n   int group_size;\n   unsigned int inside_cost = 0, outside_cost = 0;\n@@ -762,11 +685,9 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n       first_dr = STMT_VINFO_DATA_REF (stmt_info);\n     }\n \n-  /* We assume that the cost of a single store-lanes instruction is\n-     equivalent to the cost of GROUP_SIZE separate stores.  If a strided\n-     access is instead being provided by a permute-and-store operation,\n-     include the cost of the permutes.  */\n-  if (!store_lanes_p && group_size > 1)\n+  /* Is this an access in a group of stores, which provide strided access?\n+     If so, add in the cost of the permutes.  */\n+  if (group_size > 1)\n     {\n       /* Uses a high and low interleave operation for each needed permute.  */\n       inside_cost = ncopies * exact_log2(group_size) * group_size\n@@ -842,8 +763,8 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n    access scheme chosen.  */\n \n void\n-vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n-\t\t      slp_tree slp_node)\n+vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n+\n {\n   int group_size;\n   gimple first_stmt;\n@@ -868,11 +789,9 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n       first_dr = dr;\n     }\n \n-  /* We assume that the cost of a single load-lanes instruction is\n-     equivalent to the cost of GROUP_SIZE separate loads.  If a strided\n-     access is instead being provided by a load-and-permute operation,\n-     include the cost of the permutes.  */\n-  if (!load_lanes_p && group_size > 1)\n+  /* Is this an access in a group of loads providing strided access?\n+     If so, add in the cost of the permutes.  */\n+  if (group_size > 1)\n     {\n       /* Uses an even and odd extract operations for each needed permute.  */\n       inside_cost = ncopies * exact_log2(group_size) * group_size\n@@ -3410,7 +3329,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  tree elem_type;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n   enum machine_mode vec_mode;\n@@ -3426,15 +3344,13 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   int j;\n   gimple next_stmt, first_stmt = NULL;\n   bool strided_store = false;\n-  bool store_lanes_p = false;\n   unsigned int group_size, i;\n   VEC(tree,heap) *dr_chain = NULL, *oprnds = NULL, *result_chain = NULL;\n   bool inv_p;\n   VEC(tree,heap) *vec_oprnds = NULL;\n   bool slp = (slp_node != NULL);\n   unsigned int vec_num;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n-  tree aggr_type;\n \n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -3488,8 +3404,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   /* The scalar rhs type needs to be trivially convertible to the vector\n      component type.  This should always be the case.  */\n-  elem_type = TREE_TYPE (vectype);\n-  if (!useless_type_conversion_p (elem_type, TREE_TYPE (op)))\n+  if (!useless_type_conversion_p (TREE_TYPE (vectype), TREE_TYPE (op)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"???  operands of different types\");\n@@ -3519,9 +3434,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (!slp && !PURE_SLP_STMT (stmt_info))\n \t{\n \t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-\t  if (vect_store_lanes_supported (vectype, group_size))\n-\t    store_lanes_p = true;\n-\t  else if (!vect_strided_store_supported (vectype, group_size))\n+\t  if (!vect_strided_store_supported (vectype, group_size))\n \t    return false;\n \t}\n \n@@ -3549,7 +3462,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      vect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt, NULL);\n+      vect_model_store_cost (stmt_info, ncopies, dt, NULL);\n       return true;\n     }\n \n@@ -3604,16 +3517,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n   gcc_assert (alignment_support_scheme);\n-  /* Targets with store-lane instructions must not require explicit\n-     realignment.  */\n-  gcc_assert (!store_lanes_p\n-\t      || alignment_support_scheme == dr_aligned\n-\t      || alignment_support_scheme == dr_unaligned_supported);\n-\n-  if (store_lanes_p)\n-    aggr_type = build_array_type_nelts (elem_type, vec_num * nunits);\n-  else\n-    aggr_type = vectype;\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -3702,7 +3605,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  /* We should have catched mismatched types earlier.  */\n \t  gcc_assert (useless_type_conversion_p (vectype,\n \t\t\t\t\t\t TREE_TYPE (vec_oprnd)));\n-\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, aggr_type, NULL,\n+\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, vectype, NULL,\n \t\t\t\t\t\t  NULL_TREE, &dummy, gsi,\n \t\t\t\t\t\t  &ptr_incr, false, &inv_p);\n \t  gcc_assert (bb_vinfo || !inv_p);\n@@ -3725,93 +3628,70 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      VEC_replace(tree, dr_chain, i, vec_oprnd);\n \t      VEC_replace(tree, oprnds, i, vec_oprnd);\n \t    }\n-\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n-\t\t\t\t\t TYPE_SIZE_UNIT (aggr_type));\n+\t  dataref_ptr =\n+\t\tbump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt, NULL_TREE);\n \t}\n \n-      if (store_lanes_p)\n+      new_stmt = NULL;\n+      if (strided_store)\n \t{\n-\t  tree vec_array;\n-\n-\t  /* Combine all the vectors into an array.  */\n-\t  vec_array = create_vector_array (vectype, vec_num);\n-\t  for (i = 0; i < vec_num; i++)\n-\t    {\n-\t      vec_oprnd = VEC_index (tree, dr_chain, i);\n-\t      write_vector_array (stmt, gsi, vec_oprnd, vec_array, i);\n-\t    }\n-\n-\t  /* Emit:\n-\t       MEM_REF[...all elements...] = STORE_LANES (VEC_ARRAY).  */\n-\t  data_ref = create_array_ref (aggr_type, dataref_ptr, first_dr);\n-\t  new_stmt = gimple_build_call_internal (IFN_STORE_LANES, 1, vec_array);\n-\t  gimple_call_set_lhs (new_stmt, data_ref);\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t  mark_symbols_for_renaming (new_stmt);\n+\t  result_chain = VEC_alloc (tree, heap, group_size);\n+\t  /* Permute.  */\n+\t  vect_permute_store_chain (dr_chain, group_size, stmt, gsi,\n+\t\t\t\t    &result_chain);\n \t}\n-      else\n+\n+      next_stmt = first_stmt;\n+      for (i = 0; i < vec_num; i++)\n \t{\n-\t  new_stmt = NULL;\n-\t  if (strided_store)\n+\t  struct ptr_info_def *pi;\n+\n+\t  if (i > 0)\n+\t    /* Bump the vector pointer.  */\n+\t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n+\t\t\t\t\t   NULL_TREE);\n+\n+\t  if (slp)\n+\t    vec_oprnd = VEC_index (tree, vec_oprnds, i);\n+\t  else if (strided_store)\n+\t    /* For strided stores vectorized defs are interleaved in\n+\t       vect_permute_store_chain().  */\n+\t    vec_oprnd = VEC_index (tree, result_chain, i);\n+\n+\t  data_ref = build2 (MEM_REF, TREE_TYPE (vec_oprnd), dataref_ptr,\n+\t\t\t     build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t    (DR_REF (first_dr)), 0));\n+\t  pi = get_ptr_info (dataref_ptr);\n+\t  pi->align = TYPE_ALIGN_UNIT (vectype);\n+          if (aligned_access_p (first_dr))\n+\t    pi->misalign = 0;\n+          else if (DR_MISALIGNMENT (first_dr) == -1)\n \t    {\n-\t      result_chain = VEC_alloc (tree, heap, group_size);\n-\t      /* Permute.  */\n-\t      vect_permute_store_chain (dr_chain, group_size, stmt, gsi,\n-\t\t\t\t\t&result_chain);\n+\t      TREE_TYPE (data_ref)\n+\t\t= build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t      TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t      pi->align = TYPE_ALIGN_UNIT (TREE_TYPE (vectype));\n+\t      pi->misalign = 0;\n \t    }\n-\n-\t  next_stmt = first_stmt;\n-\t  for (i = 0; i < vec_num; i++)\n+\t  else\n \t    {\n-\t      struct ptr_info_def *pi;\n-\n-\t      if (i > 0)\n-\t\t/* Bump the vector pointer.  */\n-\t\tdataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n-\t\t\t\t\t       stmt, NULL_TREE);\n-\n-\t      if (slp)\n-\t\tvec_oprnd = VEC_index (tree, vec_oprnds, i);\n-\t      else if (strided_store)\n-\t\t/* For strided stores vectorized defs are interleaved in\n-\t\t   vect_permute_store_chain().  */\n-\t\tvec_oprnd = VEC_index (tree, result_chain, i);\n-\n-\t      data_ref = build2 (MEM_REF, TREE_TYPE (vec_oprnd), dataref_ptr,\n-\t\t\t\t build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t(DR_REF (first_dr)), 0));\n-\t      pi = get_ptr_info (dataref_ptr);\n-\t      pi->align = TYPE_ALIGN_UNIT (vectype);\n-\t      if (aligned_access_p (first_dr))\n-\t\tpi->misalign = 0;\n-\t      else if (DR_MISALIGNMENT (first_dr) == -1)\n-\t\t{\n-\t\t  TREE_TYPE (data_ref)\n-\t\t    = build_aligned_type (TREE_TYPE (data_ref),\n-\t\t\t\t\t  TYPE_ALIGN (elem_type));\n-\t\t  pi->align = TYPE_ALIGN_UNIT (elem_type);\n-\t\t  pi->misalign = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  TREE_TYPE (data_ref)\n-\t\t    = build_aligned_type (TREE_TYPE (data_ref),\n-\t\t\t\t\t  TYPE_ALIGN (elem_type));\n-\t\t  pi->misalign = DR_MISALIGNMENT (first_dr);\n-\t\t}\n+\t      TREE_TYPE (data_ref)\n+\t\t= build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t      TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t      pi->misalign = DR_MISALIGNMENT (first_dr);\n+\t    }\n \n-\t      /* Arguments are ready.  Create the new vector stmt.  */\n-\t      new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t      mark_symbols_for_renaming (new_stmt);\n+\t  /* Arguments are ready.  Create the new vector stmt.  */\n+\t  new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n+\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  mark_symbols_for_renaming (new_stmt);\n \n-\t      if (slp)\n-\t\tcontinue;\n+          if (slp)\n+            continue;\n \n-\t      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n-\t      if (!next_stmt)\n-\t\tbreak;\n-\t    }\n+\t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t  if (!next_stmt)\n+\t    break;\n \t}\n       if (!slp)\n \t{\n@@ -3930,7 +3810,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bool nested_in_vect_loop = false;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  tree elem_type;\n   tree new_temp;\n   enum machine_mode mode;\n   gimple new_stmt = NULL;\n@@ -3947,7 +3826,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   gimple phi = NULL;\n   VEC(tree,heap) *dr_chain = NULL;\n   bool strided_load = false;\n-  bool load_lanes_p = false;\n   gimple first_stmt;\n   tree scalar_type;\n   bool inv_p;\n@@ -3960,7 +3838,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   enum tree_code code;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n-  tree aggr_type;\n \n   if (loop_vinfo)\n     {\n@@ -4037,8 +3914,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   /* The vector component type needs to be trivially convertible to the\n      scalar lhs.  This should always be the case.  */\n-  elem_type = TREE_TYPE (vectype);\n-  if (!useless_type_conversion_p (TREE_TYPE (scalar_dest), elem_type))\n+  if (!useless_type_conversion_p (TREE_TYPE (scalar_dest), TREE_TYPE (vectype)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"???  operands of different types\");\n@@ -4056,9 +3932,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (!slp && !PURE_SLP_STMT (stmt_info))\n \t{\n \t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-\t  if (vect_load_lanes_supported (vectype, group_size))\n-\t    load_lanes_p = true;\n-\t  else if (!vect_strided_load_supported (vectype, group_size))\n+\t  if (!vect_strided_load_supported (vectype, group_size))\n \t    return false;\n \t}\n     }\n@@ -4085,7 +3959,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n-      vect_model_load_cost (stmt_info, ncopies, load_lanes_p, NULL);\n+      vect_model_load_cost (stmt_info, ncopies, NULL);\n       return true;\n     }\n \n@@ -4126,11 +4000,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n   gcc_assert (alignment_support_scheme);\n-  /* Targets with load-lane instructions must not require explicit\n-     realignment.  */\n-  gcc_assert (!load_lanes_p\n-\t      || alignment_support_scheme == dr_aligned\n-\t      || alignment_support_scheme == dr_unaligned_supported);\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -4262,250 +4131,208 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (negative)\n     offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n \n-  if (load_lanes_p)\n-    aggr_type = build_array_type_nelts (elem_type, vec_num * nunits);\n-  else\n-    aggr_type = vectype;\n-\n   prev_stmt_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     {\n-      /* 1. Create the vector or array pointer update chain.  */\n+      /* 1. Create the vector pointer update chain.  */\n       if (j == 0)\n-        dataref_ptr = vect_create_data_ref_ptr (first_stmt, aggr_type, at_loop,\n+        dataref_ptr = vect_create_data_ref_ptr (first_stmt, vectype, at_loop,\n \t\t\t\t\t\toffset, &dummy, gsi,\n \t\t\t\t\t\t&ptr_incr, false, &inv_p);\n       else\n-        dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n-\t\t\t\t       TYPE_SIZE_UNIT (aggr_type));\n+        dataref_ptr =\n+\t\tbump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt, NULL_TREE);\n \n       if (strided_load || slp_perm)\n \tdr_chain = VEC_alloc (tree, heap, vec_num);\n \n-      if (load_lanes_p)\n+      for (i = 0; i < vec_num; i++)\n \t{\n-\t  tree vec_array;\n-\n-\t  vec_array = create_vector_array (vectype, vec_num);\n-\n-\t  /* Emit:\n-\t       VEC_ARRAY = LOAD_LANES (MEM_REF[...all elements...]).  */\n-\t  data_ref = create_array_ref (aggr_type, dataref_ptr, first_dr);\n-\t  new_stmt = gimple_build_call_internal (IFN_LOAD_LANES, 1, data_ref);\n-\t  gimple_call_set_lhs (new_stmt, vec_array);\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t  mark_symbols_for_renaming (new_stmt);\n+\t  if (i > 0)\n+\t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n+\t\t\t\t\t   NULL_TREE);\n \n-\t  /* Extract each vector into an SSA_NAME.  */\n-\t  for (i = 0; i < vec_num; i++)\n+\t  /* 2. Create the vector-load in the loop.  */\n+\t  switch (alignment_support_scheme)\n \t    {\n-\t      new_temp = read_vector_array (stmt, gsi, scalar_dest,\n-\t\t\t\t\t    vec_array, i);\n-\t      VEC_quick_push (tree, dr_chain, new_temp);\n-\t    }\n-\n-\t  /* Record the mapping between SSA_NAMEs and statements.  */\n-\t  vect_record_strided_load_vectors (stmt, dr_chain);\n-\t}\n-      else\n-\t{\n-\t  for (i = 0; i < vec_num; i++)\n-\t    {\n-\t      if (i > 0)\n-\t\tdataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n-\t\t\t\t\t       stmt, NULL_TREE);\n-\n-\t      /* 2. Create the vector-load in the loop.  */\n-\t      switch (alignment_support_scheme)\n-\t\t{\n-\t\tcase dr_aligned:\n-\t\tcase dr_unaligned_supported:\n+\t    case dr_aligned:\n+\t    case dr_unaligned_supported:\n+\t      {\n+\t\tstruct ptr_info_def *pi;\n+\t\tdata_ref\n+\t\t  = build2 (MEM_REF, vectype, dataref_ptr,\n+\t\t\t    build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t   (DR_REF (first_dr)), 0));\n+\t\tpi = get_ptr_info (dataref_ptr);\n+\t\tpi->align = TYPE_ALIGN_UNIT (vectype);\n+\t\tif (alignment_support_scheme == dr_aligned)\n \t\t  {\n-\t\t    struct ptr_info_def *pi;\n-\t\t    data_ref\n-\t\t      = build2 (MEM_REF, vectype, dataref_ptr,\n-\t\t\t\tbuild_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t       (DR_REF (first_dr)), 0));\n-\t\t    pi = get_ptr_info (dataref_ptr);\n-\t\t    pi->align = TYPE_ALIGN_UNIT (vectype);\n-\t\t    if (alignment_support_scheme == dr_aligned)\n-\t\t      {\n-\t\t\tgcc_assert (aligned_access_p (first_dr));\n-\t\t\tpi->misalign = 0;\n-\t\t      }\n-\t\t    else if (DR_MISALIGNMENT (first_dr) == -1)\n-\t\t      {\n-\t\t\tTREE_TYPE (data_ref)\n-\t\t\t  = build_aligned_type (TREE_TYPE (data_ref),\n-\t\t\t\t\t\tTYPE_ALIGN (elem_type));\n-\t\t\tpi->align = TYPE_ALIGN_UNIT (elem_type);\n-\t\t\tpi->misalign = 0;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tTREE_TYPE (data_ref)\n-\t\t\t  = build_aligned_type (TREE_TYPE (data_ref),\n-\t\t\t\t\t\tTYPE_ALIGN (elem_type));\n-\t\t\tpi->misalign = DR_MISALIGNMENT (first_dr);\n-\t\t      }\n-\t\t    break;\n+\t\t    gcc_assert (aligned_access_p (first_dr));\n+\t\t    pi->misalign = 0;\n \t\t  }\n-\t\tcase dr_explicit_realign:\n+\t\telse if (DR_MISALIGNMENT (first_dr) == -1)\n \t\t  {\n-\t\t    tree ptr, bump;\n-\t\t    tree vs_minus_1;\n-\n-\t\t    vs_minus_1 = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n-\n-\t\t    if (compute_in_loop)\n-\t\t      msq = vect_setup_realignment (first_stmt, gsi,\n-\t\t\t\t\t\t    &realignment_token,\n-\t\t\t\t\t\t    dr_explicit_realign,\n-\t\t\t\t\t\t    dataref_ptr, NULL);\n-\n-\t\t    new_stmt = gimple_build_assign_with_ops\n-\t\t\t\t (BIT_AND_EXPR, NULL_TREE, dataref_ptr,\n-\t\t\t\t  build_int_cst\n-\t\t\t\t  (TREE_TYPE (dataref_ptr),\n-\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n-\t\t    ptr = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n-\t\t    gimple_assign_set_lhs (new_stmt, ptr);\n-\t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t    data_ref\n-\t\t      = build2 (MEM_REF, vectype, ptr,\n-\t\t\t\tbuild_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t (DR_REF (first_dr)), 0));\n-\t\t    vec_dest = vect_create_destination_var (scalar_dest,\n-\t\t\t\t\t\t\t    vectype);\n-\t\t    new_stmt = gimple_build_assign (vec_dest, data_ref);\n-\t\t    new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t    gimple_assign_set_lhs (new_stmt, new_temp);\n-\t\t    gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n-\t\t    gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t    msq = new_temp;\n-\n-\t\t    bump = size_binop (MULT_EXPR, vs_minus_1,\n-\t\t\t\t       TYPE_SIZE_UNIT (scalar_type));\n-\t\t    ptr = bump_vector_ptr (dataref_ptr, NULL, gsi, stmt, bump);\n-\t\t    new_stmt = gimple_build_assign_with_ops\n-\t\t\t\t (BIT_AND_EXPR, NULL_TREE, ptr,\n-\t\t\t\t  build_int_cst\n-\t\t\t\t  (TREE_TYPE (ptr),\n-\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n-\t\t    ptr = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n-\t\t    gimple_assign_set_lhs (new_stmt, ptr);\n-\t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t    data_ref\n-\t\t      = build2 (MEM_REF, vectype, ptr,\n-\t\t\t\tbuild_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t (DR_REF (first_dr)), 0));\n-\t\t    break;\n+\t\t    TREE_TYPE (data_ref)\n+\t\t      = build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t\t    pi->align = TYPE_ALIGN_UNIT (TREE_TYPE (vectype));\n+\t\t    pi->misalign = 0;\n \t\t  }\n-\t\tcase dr_explicit_realign_optimized:\n-\t\t  new_stmt = gimple_build_assign_with_ops\n-\t\t\t       (BIT_AND_EXPR, NULL_TREE, dataref_ptr,\n-\t\t\t\tbuild_int_cst\n-\t\t\t\t  (TREE_TYPE (dataref_ptr),\n-\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n-\t\t  new_temp = make_ssa_name (SSA_NAME_VAR (dataref_ptr),\n-\t\t\t\t\t    new_stmt);\n-\t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t  data_ref\n-\t\t    = build2 (MEM_REF, vectype, new_temp,\n-\t\t\t      build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t       (DR_REF (first_dr)), 0));\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n+\t\telse\n+\t\t  {\n+\t\t    TREE_TYPE (data_ref)\n+\t\t      = build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t\t    pi->misalign = DR_MISALIGNMENT (first_dr);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    case dr_explicit_realign:\n+\t      {\n+\t\ttree ptr, bump;\n+\t\ttree vs_minus_1 = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n+\n+\t\tif (compute_in_loop)\n+\t\t  msq = vect_setup_realignment (first_stmt, gsi,\n+\t\t\t\t\t\t&realignment_token,\n+\t\t\t\t\t\tdr_explicit_realign,\n+\t\t\t\t\t\tdataref_ptr, NULL);\n+\n+\t\tnew_stmt = gimple_build_assign_with_ops\n+\t\t\t     (BIT_AND_EXPR, NULL_TREE, dataref_ptr,\n+\t\t\t      build_int_cst\n+\t\t\t        (TREE_TYPE (dataref_ptr),\n+\t\t\t\t -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t\tptr = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n+\t\tgimple_assign_set_lhs (new_stmt, ptr);\n+\t\tvect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\tdata_ref\n+\t\t  = build2 (MEM_REF, vectype, ptr,\n+\t\t\t    build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t     (DR_REF (first_dr)), 0));\n+\t\tvec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t\tnew_stmt = gimple_build_assign (vec_dest, data_ref);\n+\t\tnew_temp = make_ssa_name (vec_dest, new_stmt);\n+\t\tgimple_assign_set_lhs (new_stmt, new_temp);\n+\t\tgimple_set_vdef (new_stmt, gimple_vdef (stmt));\n+\t\tgimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t\tvect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\tmsq = new_temp;\n+\n+\t\tbump = size_binop (MULT_EXPR, vs_minus_1,\n+\t\t\t\t   TYPE_SIZE_UNIT (scalar_type));\n+\t\tptr = bump_vector_ptr (dataref_ptr, NULL, gsi, stmt, bump);\n+\t\tnew_stmt = gimple_build_assign_with_ops\n+\t\t\t     (BIT_AND_EXPR, NULL_TREE, ptr,\n+\t\t\t      build_int_cst\n+\t\t\t        (TREE_TYPE (ptr),\n+\t\t\t\t -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t\tptr = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n+\t\tgimple_assign_set_lhs (new_stmt, ptr);\n+\t\tvect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\tdata_ref\n+\t\t  = build2 (MEM_REF, vectype, ptr,\n+\t\t\t    build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t     (DR_REF (first_dr)), 0));\n+\t        break;\n+\t      }\n+\t    case dr_explicit_realign_optimized:\n+\t      new_stmt = gimple_build_assign_with_ops\n+\t\t\t   (BIT_AND_EXPR, NULL_TREE, dataref_ptr,\n+\t\t\t    build_int_cst\n+\t\t\t      (TREE_TYPE (dataref_ptr),\n+\t\t\t       -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t      new_temp = make_ssa_name (SSA_NAME_VAR (dataref_ptr), new_stmt);\n+\t      gimple_assign_set_lhs (new_stmt, new_temp);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      data_ref\n+\t\t= build2 (MEM_REF, vectype, new_temp,\n+\t\t\t  build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t   (DR_REF (first_dr)), 0));\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t  new_stmt = gimple_build_assign (vec_dest, data_ref);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  gimple_assign_set_lhs (new_stmt, new_temp);\n+\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  mark_symbols_for_renaming (new_stmt);\n+\n+\t  /* 3. Handle explicit realignment if necessary/supported.  Create in\n+\t\tloop: vec_dest = realign_load (msq, lsq, realignment_token)  */\n+\t  if (alignment_support_scheme == dr_explicit_realign_optimized\n+\t      || alignment_support_scheme == dr_explicit_realign)\n+\t    {\n+\t      lsq = gimple_assign_lhs (new_stmt);\n+\t      if (!realignment_token)\n+\t\trealignment_token = dataref_ptr;\n \t      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-\t      new_stmt = gimple_build_assign (vec_dest, data_ref);\n+\t      new_stmt\n+\t\t= gimple_build_assign_with_ops3 (REALIGN_LOAD_EXPR, vec_dest,\n+\t\t\t\t\t\t msq, lsq, realignment_token);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      gimple_assign_set_lhs (new_stmt, new_temp);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t      mark_symbols_for_renaming (new_stmt);\n \n-\t      /* 3. Handle explicit realignment if necessary/supported.\n-\t\t Create in loop:\n-\t\t   vec_dest = realign_load (msq, lsq, realignment_token)  */\n-\t      if (alignment_support_scheme == dr_explicit_realign_optimized\n-\t\t  || alignment_support_scheme == dr_explicit_realign)\n+\t      if (alignment_support_scheme == dr_explicit_realign_optimized)\n \t\t{\n-\t\t  lsq = gimple_assign_lhs (new_stmt);\n-\t\t  if (!realignment_token)\n-\t\t    realignment_token = dataref_ptr;\n-\t\t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-\t\t  new_stmt\n-\t\t    = gimple_build_assign_with_ops3 (REALIGN_LOAD_EXPR,\n-\t\t\t\t\t\t     vec_dest, msq, lsq,\n-\t\t\t\t\t\t     realignment_token);\n-\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-\t\t  if (alignment_support_scheme == dr_explicit_realign_optimized)\n-\t\t    {\n-\t\t      gcc_assert (phi);\n-\t\t      if (i == vec_num - 1 && j == ncopies - 1)\n-\t\t\tadd_phi_arg (phi, lsq,\n-\t\t\t\t     loop_latch_edge (containing_loop),\n-\t\t\t\t     UNKNOWN_LOCATION);\n-\t\t      msq = lsq;\n-\t\t    }\n+\t\t  gcc_assert (phi);\n+\t\t  if (i == vec_num - 1 && j == ncopies - 1)\n+\t\t    add_phi_arg (phi, lsq, loop_latch_edge (containing_loop),\n+\t\t\t\t UNKNOWN_LOCATION);\n+\t\t  msq = lsq;\n \t\t}\n+\t    }\n \n-\t      /* 4. Handle invariant-load.  */\n-\t      if (inv_p && !bb_vinfo)\n+\t  /* 4. Handle invariant-load.  */\n+\t  if (inv_p && !bb_vinfo)\n+\t    {\n+\t      gcc_assert (!strided_load);\n+\t      gcc_assert (nested_in_vect_loop_p (loop, stmt));\n+\t      if (j == 0)\n \t\t{\n-\t\t  gcc_assert (!strided_load);\n-\t\t  gcc_assert (nested_in_vect_loop_p (loop, stmt));\n-\t\t  if (j == 0)\n-\t\t    {\n-\t\t      int k;\n-\t\t      tree t = NULL_TREE;\n-\t\t      tree vec_inv, bitpos, bitsize = TYPE_SIZE (scalar_type);\n-\n-\t\t      /* CHECKME: bitpos depends on endianess?  */\n-\t\t      bitpos = bitsize_zero_node;\n-\t\t      vec_inv = build3 (BIT_FIELD_REF, scalar_type, new_temp,\n-\t\t\t\t\tbitsize, bitpos);\n-\t\t      vec_dest = vect_create_destination_var (scalar_dest,\n-\t\t\t\t\t\t\t      NULL_TREE);\n-\t\t      new_stmt = gimple_build_assign (vec_dest, vec_inv);\n-\t\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t      gimple_assign_set_lhs (new_stmt, new_temp);\n-\t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-\t\t      for (k = nunits - 1; k >= 0; --k)\n-\t\t\tt = tree_cons (NULL_TREE, new_temp, t);\n-\t\t      /* FIXME: use build_constructor directly.  */\n-\t\t      vec_inv = build_constructor_from_list (vectype, t);\n-\t\t      new_temp = vect_init_vector (stmt, vec_inv,\n-\t\t\t\t\t\t   vectype, gsi);\n-\t\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n-\t\t    }\n-\t\t  else\n-\t\t    gcc_unreachable (); /* FORNOW. */\n-\t\t}\n+\t\t  int k;\n+\t\t  tree t = NULL_TREE;\n+\t\t  tree vec_inv, bitpos, bitsize = TYPE_SIZE (scalar_type);\n+\n+\t\t  /* CHECKME: bitpos depends on endianess?  */\n+\t\t  bitpos = bitsize_zero_node;\n+\t\t  vec_inv = build3 (BIT_FIELD_REF, scalar_type, new_temp,\n+\t\t\t\t    bitsize, bitpos);\n+\t\t  vec_dest =\n+\t\t\tvect_create_destination_var (scalar_dest, NULL_TREE);\n+\t\t  new_stmt = gimple_build_assign (vec_dest, vec_inv);\n+                  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n-\t      if (negative)\n-\t\t{\n-\t\t  new_temp = reverse_vec_elements (new_temp, stmt, gsi);\n+\t\t  for (k = nunits - 1; k >= 0; --k)\n+\t\t    t = tree_cons (NULL_TREE, new_temp, t);\n+\t\t  /* FIXME: use build_constructor directly.  */\n+\t\t  vec_inv = build_constructor_from_list (vectype, t);\n+\t\t  new_temp = vect_init_vector (stmt, vec_inv, vectype, gsi);\n \t\t  new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t\t}\n+\t      else\n+\t\tgcc_unreachable (); /* FORNOW. */\n+\t    }\n \n-\t      /* Collect vector loads and later create their permutation in\n-\t\t vect_transform_strided_load ().  */\n-\t      if (strided_load || slp_perm)\n-\t\tVEC_quick_push (tree, dr_chain, new_temp);\n-\n-\t      /* Store vector loads in the corresponding SLP_NODE.  */\n-\t      if (slp && !slp_perm)\n-\t\tVEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node),\n-\t\t\t\tnew_stmt);\n+\t  if (negative)\n+\t    {\n+\t      new_temp = reverse_vec_elements (new_temp, stmt, gsi);\n+\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t    }\n+\n+\t  /* Collect vector loads and later create their permutation in\n+\t     vect_transform_strided_load ().  */\n+          if (strided_load || slp_perm)\n+            VEC_quick_push (tree, dr_chain, new_temp);\n+\n+         /* Store vector loads in the corresponding SLP_NODE.  */\n+\t  if (slp && !slp_perm)\n+\t    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n \t}\n \n       if (slp && !slp_perm)\n@@ -4524,8 +4351,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n         {\n           if (strided_load)\n   \t    {\n-\t      if (!load_lanes_p)\n-\t\tvect_transform_strided_load (stmt, dr_chain, group_size, gsi);\n+\t      vect_transform_strided_load (stmt, dr_chain, group_size, gsi);\n \t      *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \t    }\n           else"}, {"sha": "6e63afcc716790eb1bd0dd58c4610f1d49576c3f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -788,9 +788,9 @@ extern void free_stmt_vec_info (gimple stmt);\n extern tree vectorizable_function (gimple, tree, tree);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n                                     slp_tree);\n-extern void vect_model_store_cost (stmt_vec_info, int, bool,\n-\t\t\t\t   enum vect_def_type, slp_tree);\n-extern void vect_model_load_cost (stmt_vec_info, int, bool, slp_tree);\n+extern void vect_model_store_cost (stmt_vec_info, int, enum vect_def_type,\n+                                   slp_tree);\n+extern void vect_model_load_cost (stmt_vec_info, int, slp_tree);\n extern void vect_finish_stmt_generation (gimple, gimple,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n@@ -829,17 +829,14 @@ extern tree vect_create_data_ref_ptr (gimple, tree, struct loop *, tree,\n extern tree bump_vector_ptr (tree, gimple, gimple_stmt_iterator *, gimple, tree);\n extern tree vect_create_destination_var (tree, tree);\n extern bool vect_strided_store_supported (tree, unsigned HOST_WIDE_INT);\n-extern bool vect_store_lanes_supported (tree, unsigned HOST_WIDE_INT);\n extern bool vect_strided_load_supported (tree, unsigned HOST_WIDE_INT);\n-extern bool vect_load_lanes_supported (tree, unsigned HOST_WIDE_INT);\n extern void vect_permute_store_chain (VEC(tree,heap) *,unsigned int, gimple,\n                                     gimple_stmt_iterator *, VEC(tree,heap) **);\n extern tree vect_setup_realignment (gimple, gimple_stmt_iterator *, tree *,\n                                     enum dr_alignment_support, tree,\n                                     struct loop **);\n extern void vect_transform_strided_load (gimple, VEC(tree,heap) *, int,\n                                          gimple_stmt_iterator *);\n-extern void vect_record_strided_load_vectors (gimple, VEC(tree,heap) *);\n extern int vect_get_place_in_interleaving_chain (gimple, gimple);\n extern tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n extern tree vect_create_addr_base_for_vector_ref (gimple, gimple_seq *,"}, {"sha": "d0c18b17ae2ff9671158865a5ceda18697967f45", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -7340,15 +7340,6 @@ build_nonshared_array_type (tree elt_type, tree index_type)\n   return build_array_type_1 (elt_type, index_type, false);\n }\n \n-/* Return a representation of ELT_TYPE[NELTS], using indices of type\n-   sizetype.  */\n-\n-tree\n-build_array_type_nelts (tree elt_type, unsigned HOST_WIDE_INT nelts)\n-{\n-  return build_array_type (elt_type, build_index_type (size_int (nelts - 1)));\n-}\n-\n /* Recursively examines the array elements of TYPE, until a non-array\n    element type is found.  */\n "}, {"sha": "0bc98cd01b46691ae9fdab162326e3c65adb74e6", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267d3070f755138d967f6fd0c05b3c9ccb361aaf/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=267d3070f755138d967f6fd0c05b3c9ccb361aaf", "patch": "@@ -4247,7 +4247,6 @@ extern tree build_type_no_quals (tree);\n extern tree build_index_type (tree);\n extern tree build_array_type (tree, tree);\n extern tree build_nonshared_array_type (tree, tree);\n-extern tree build_array_type_nelts (tree, unsigned HOST_WIDE_INT);\n extern tree build_function_type (tree, tree);\n extern tree build_function_type_list (tree, ...);\n extern tree build_function_type_skip_args (tree, bitmap);"}]}