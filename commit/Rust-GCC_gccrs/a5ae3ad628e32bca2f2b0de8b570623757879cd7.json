{"sha": "a5ae3ad628e32bca2f2b0de8b570623757879cd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVhZTNhZDYyOGUzMmJjYTJmMmIwZGU4YjU3MDYyMzc1Nzg3OWNkNw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2005-02-12T10:24:40Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-02-12T10:24:40Z"}, "message": "tree-vectorizer.h (struct _stmt_vec_info): Rename a field: base to base_address.\n\n2005-02-13  Ira Rosen  <irar@il.ibm.com>\n\n        * tree-vectorizer.h (struct _stmt_vec_info): Rename a field: base\n        to base_address.\n        * tree-vectorizer.c (new_stmt_vec_info): Rename the above field of\n        stmt_vec_info.\n        (vect_get_base_and_offset): Always return an address.\n        (vect_create_addr_base_for_vector_ref): Remove treatment for\n        different data reference types.\n        (vect_compute_data_ref_alignment): Rename base to base_address in\n        stmt_vec_info. Get the object in order to force its alignment.\n        (vect_get_memtag_and_dr): Rename base to base_address in\n        stmt_vec_info. Extract the object for memtag analysis.\n\nFrom-SVN: r94930", "tree": {"sha": "5d72892c65985445fdedf3d27a2ff1dcd4cd21ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d72892c65985445fdedf3d27a2ff1dcd4cd21ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5ae3ad628e32bca2f2b0de8b570623757879cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5ae3ad628e32bca2f2b0de8b570623757879cd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5ae3ad628e32bca2f2b0de8b570623757879cd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5ae3ad628e32bca2f2b0de8b570623757879cd7/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6092c5db35325926974576aac7232cde33f14867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6092c5db35325926974576aac7232cde33f14867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6092c5db35325926974576aac7232cde33f14867"}], "stats": {"total": 74, "additions": 34, "deletions": 40}, "files": [{"sha": "e8e8a80c6391b16cc419928f1df250a6e0bca68c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ae3ad628e32bca2f2b0de8b570623757879cd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ae3ad628e32bca2f2b0de8b570623757879cd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5ae3ad628e32bca2f2b0de8b570623757879cd7", "patch": "@@ -1,3 +1,17 @@\n+2005-02-13  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Rename a field: base\n+\tto base_address.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Rename the above field of\n+\tstmt_vec_info.\n+\t(vect_get_base_and_offset): Always return an address.\n+\t(vect_create_addr_base_for_vector_ref): Remove treatment for\n+\tdifferent data reference types.\n+\t(vect_compute_data_ref_alignment): Rename base to base_address in\n+\tstmt_vec_info. Get the object in order to force its alignment.\n+\t(vect_get_memtag_and_dr): Rename base to base_address in\n+\tstmt_vec_info. Extract the object for memtag analysis.\n+\n 2005-02-12  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR regression/19898."}, {"sha": "f18d0bb091ded06aa4a20a96e62c6b340c3379bc", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ae3ad628e32bca2f2b0de8b570623757879cd7/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ae3ad628e32bca2f2b0de8b570623757879cd7/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=a5ae3ad628e32bca2f2b0de8b570623757879cd7", "patch": "@@ -1282,7 +1282,7 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_VEC_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n   STMT_VINFO_MEMTAG (res) = NULL;\n-  STMT_VINFO_VECT_DR_BASE (res) = NULL;\n+  STMT_VINFO_VECT_DR_BASE_ADDRESS (res) = NULL;\n   STMT_VINFO_VECT_INIT_OFFSET (res) = NULL_TREE;\n   STMT_VINFO_VECT_STEP (res) = NULL_TREE;\n   STMT_VINFO_VECT_BASE_ALIGNED_P (res) = false;\n@@ -1690,7 +1690,7 @@ vect_get_base_and_offset (struct data_reference *dr,\n       *misalign = ssize_int (0);\n       if (DECL_ALIGN (expr) >= TYPE_ALIGN (vectype))\n \t*base_aligned_p = true;\n-      return expr;\n+      return build_fold_addr_expr (expr);\n \n     case SSA_NAME:\n       if (TREE_CODE (TREE_TYPE (expr)) != POINTER_TYPE)\n@@ -1960,7 +1960,8 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree data_ref_base = unshare_expr (STMT_VINFO_VECT_DR_BASE (stmt_info));\n+  tree data_ref_base = \n+    unshare_expr (STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info));\n   tree base_name = unshare_expr (DR_BASE_NAME (dr));\n   tree ref = DR_REF (dr);\n   tree scalar_type = TREE_TYPE (ref);\n@@ -1971,33 +1972,6 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   tree dest, new_stmt;\n   tree base_offset = unshare_expr (STMT_VINFO_VECT_INIT_OFFSET (stmt_info));\n \n-  if (TREE_CODE (TREE_TYPE (data_ref_base)) != POINTER_TYPE)\n-    /* After the analysis stage, we expect to get here only with RECORD_TYPE\n-       and ARRAY_TYPE. */\n-    /* Add '&' to ref_base.  */\n-    data_ref_base = build_fold_addr_expr (data_ref_base);\n-  else\n-    {\n-      /* Create '(scalar_type*) base' for pointers.  */\n-      tree dest, new_stmt, new_temp, vec_stmt, tmp_base;\n-      tree scalar_array_type = build_array_type (scalar_type, 0);\n-      tree scalar_array_ptr_type = build_pointer_type (scalar_array_type);\n-      tree array_ptr = create_tmp_var (scalar_array_ptr_type, \"array_ptr\");\n-      add_referenced_tmp_var (array_ptr);\n-\n-      dest = create_tmp_var (TREE_TYPE (data_ref_base), \"dataref\");\n-      add_referenced_tmp_var (dest);\n-      tmp_base = force_gimple_operand (data_ref_base, &new_stmt, false, dest);  \n-      append_to_statement_list_force (new_stmt,  new_stmt_list);\n-      \n-      vec_stmt = fold_convert (scalar_array_ptr_type, tmp_base);\n-      vec_stmt = build2 (MODIFY_EXPR, void_type_node, array_ptr, vec_stmt);\n-      new_temp = make_ssa_name (array_ptr, vec_stmt);\n-      TREE_OPERAND (vec_stmt, 0) = new_temp;\n-      append_to_statement_list_force (vec_stmt,  new_stmt_list);\n-      data_ref_base = new_temp;\n-    }\n-\n   /* Create base_offset */\n   dest = create_tmp_var (TREE_TYPE (base_offset), \"base_off\");\n   add_referenced_tmp_var (dest);\n@@ -4253,7 +4227,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   misalign = STMT_VINFO_VECT_MISALIGNMENT (stmt_info);\n   base_aligned_p = STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info);\n-  base = STMT_VINFO_VECT_DR_BASE (stmt_info);\n+  base = build_fold_indirect_ref (STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info));\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n   if (!misalign)\n@@ -4877,7 +4851,8 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \t  /* Fall through.  */\n \t\n \tcase ADDR_EXPR:\n-\t  symbl = STMT_VINFO_VECT_DR_BASE (stmt_info);\n+\t  symbl = build_fold_indirect_ref (\n+\t\t       STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info));\n \t  break; /* For recursive call.  */\n \n \tcase PLUS_EXPR:\n@@ -4965,7 +4940,7 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \n       STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info) = base_aligned_p;\n       STMT_VINFO_VECT_MISALIGNMENT (stmt_info) = misalign;\n-      STMT_VINFO_VECT_DR_BASE (stmt_info) = dr_base;\t     \n+      STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info) = dr_base;\t     \n     }\n \n   if (!symbl)"}, {"sha": "7876cb6d7cbb038f0d7f93f7d297dba60870a121", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ae3ad628e32bca2f2b0de8b570623757879cd7/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ae3ad628e32bca2f2b0de8b570623757879cd7/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a5ae3ad628e32bca2f2b0de8b570623757879cd7", "patch": "@@ -174,20 +174,25 @@ typedef struct _stmt_vec_info {\n   tree memtag;\n \n   /** The following fields are used to store the information about \n-      data-reference. {base + initial_offset} is the first location accessed by\n-      data-ref in the loop, and step is the stride of data-ref in the loop;\n+      data-reference. {base_address + initial_offset} is the first location \n+      accessed by data-ref in the loop, and step is the stride of data-ref in \n+      the loop in bytes;\n       e.g.:\n     \n                        Example 1                      Example 2\n       data-ref         a[j].b[i][j]                   a + 4B (a is int*)\n-\n-      base             a                              a\n+      \n+      base_address     &a                             a\n       initial_offset   j_0*D_j + i_0*D_i + C          4\n       step             D_j                            4\n \n+      data-reference structure info:\n+      base_name        a                              NULL\n+      access_fn        <access_fns of indexes of b>   (0, +, 1)\n+\n   **/\n-  /* The above base, offset and step.  */\n-  tree base;\n+  /* The above base_address, offset and step.  */\n+  tree base_address;\n   tree initial_offset;\n   tree step;\n \n@@ -208,7 +213,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n #define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n #define STMT_VINFO_MEMTAG(S)              (S)->memtag\n-#define STMT_VINFO_VECT_DR_BASE(S)        (S)->base\n+#define STMT_VINFO_VECT_DR_BASE_ADDRESS(S)(S)->base_address\n #define STMT_VINFO_VECT_INIT_OFFSET(S)    (S)->initial_offset\n #define STMT_VINFO_VECT_STEP(S)           (S)->step\n #define STMT_VINFO_VECT_BASE_ALIGNED_P(S) (S)->base_aligned_p"}]}