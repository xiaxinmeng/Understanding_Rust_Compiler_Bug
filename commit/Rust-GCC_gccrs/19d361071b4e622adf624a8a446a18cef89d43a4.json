{"sha": "19d361071b4e622adf624a8a446a18cef89d43a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlkMzYxMDcxYjRlNjIyYWRmNjI0YThhNDQ2YTE4Y2VmODlkNDNhNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-01-26T10:12:47Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-01-26T10:12:47Z"}, "message": "re PR fortran/47339 (Fortran 2003/2008: Valid NAMELIST rejected; Fortran 95: Invalid namelist objects accepted)\n\n2011-01-26  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/47339\n        PR fortran/43062\n        * match.c (gfc_match_namelist): Allow assumed-length characters.\n        * resolve.c (resolve_fl_namelist): Adapt and add error messages.\n        * symbol.c (check_conflict): Allow allocatables in NML for\n        * F2003.\n        * trans-io.c (nml_get_addr_expr,transfer_namelist_element):\n        Changes due to that change.\n\n2011-01-26  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/47339\n        PR fortran/43062\n        * fortran.dg/namelist_69.f90: New test.\n        * fortran.dg/namelist_70.f90: New test.\n        * fortran.dg/namelist_assumed_char.f90: Modify dg-error, augment\n        * test.\n        * fortran.dg/namelist_3.f90: Adapt test.\n        * fortran.dg/namelist_34.f90: Ditto.\n        * fortran.dg/namelist_35.f90: Ditto.\n        * fortran.dg/namelist_5.f90: Ditto.\n        * fortran.dg/namelist_63.f90: Ditto.\n        * gfortran.dg/alloc_comp_constraint_1.f90: Ditto.\n\nFrom-SVN: r169282", "tree": {"sha": "722192447d3131faa8a3653d812ae2ca5689c8fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/722192447d3131faa8a3653d812ae2ca5689c8fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19d361071b4e622adf624a8a446a18cef89d43a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d361071b4e622adf624a8a446a18cef89d43a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d361071b4e622adf624a8a446a18cef89d43a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d361071b4e622adf624a8a446a18cef89d43a4/comments", "author": null, "committer": null, "parents": [{"sha": "52fe3d5beeb035fb4ae717f79f9825bf1898b67c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52fe3d5beeb035fb4ae717f79f9825bf1898b67c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52fe3d5beeb035fb4ae717f79f9825bf1898b67c"}], "stats": {"total": 853, "additions": 778, "deletions": 75}, "files": [{"sha": "0793b8cfc366e036472d40f1f2993cbfed899ba5", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -4030,13 +4030,6 @@ gfc_match_namelist (void)\n \t      gfc_error_check ();\n \t    }\n \n-\t  if (sym->ts.type == BT_CHARACTER && sym->ts.u.cl->length == NULL)\n-\t    {\n-\t      gfc_error (\"Assumed character length '%s' in namelist '%s' at \"\n-\t\t\t \"%C is not allowed\", sym->name, group_name->name);\n-\t      gfc_error_check ();\n-\t    }\n-\n \t  nl = gfc_get_namelist ();\n \t  nl->sym = sym;\n \t  sym->refs++;"}, {"sha": "a4a77accf9ca681b77533b1915cc74026bd84ca0", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -11726,40 +11726,64 @@ resolve_fl_namelist (gfc_symbol *sym)\n \n   for (nl = sym->namelist; nl; nl = nl->next)\n     {\n-      /* Reject namelist arrays of assumed shape.  */\n+      /* Check again, the check in match only works if NAMELIST comes\n+\t after the decl.  */\n+      if (nl->sym->as && nl->sym->as->type == AS_ASSUMED_SIZE)\n+     \t{\n+\t  gfc_error (\"Assumed size array '%s' in namelist '%s' at %L is not \"\n+\t\t     \"allowed\", nl->sym->name, sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+\n       if (nl->sym->as && nl->sym->as->type == AS_ASSUMED_SHAPE\n-\t  && gfc_notify_std (GFC_STD_F2003, \"NAMELIST array object '%s' \"\n-\t\t\t     \"must not have assumed shape in namelist \"\n+\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: NAMELIST array \"\n+\t\t\t     \"object '%s' with assumed shape in namelist \"\n \t\t\t     \"'%s' at %L\", nl->sym->name, sym->name,\n \t\t\t     &sym->declared_at) == FAILURE)\n-\t    return FAILURE;\n+\treturn FAILURE;\n \n-      /* Reject namelist arrays that are not constant shape.  */\n-      if (is_non_constant_shape_array (nl->sym))\n-\t{\n-\t  gfc_error (\"NAMELIST array object '%s' must have constant \"\n-\t\t     \"shape in namelist '%s' at %L\", nl->sym->name,\n-\t\t     sym->name, &sym->declared_at);\n-\t  return FAILURE;\n-\t}\n+      if (is_non_constant_shape_array (nl->sym)\n+\t  && gfc_notify_std (GFC_STD_F2003,  \"Fortran 2003: NAMELIST array \"\n+\t\t\t     \"object '%s' with nonconstant shape in namelist \"\n+\t\t\t     \"'%s' at %L\", nl->sym->name, sym->name,\n+\t\t\t     &sym->declared_at) == FAILURE)\n+\treturn FAILURE;\n \n-      /* Namelist objects cannot have allocatable or pointer components.  */\n-      if (nl->sym->ts.type != BT_DERIVED)\n-\tcontinue;\n+      if (nl->sym->ts.type == BT_CHARACTER\n+\t  && (nl->sym->ts.u.cl->length == NULL\n+\t      || !gfc_is_constant_expr (nl->sym->ts.u.cl->length))\n+\t  && gfc_notify_std (GFC_STD_F2003,  \"Fortran 2003: NAMELIST object \"\n+\t\t\t     \"'%s' with nonconstant character length in \"\n+\t\t\t     \"namelist '%s' at %L\", nl->sym->name, sym->name,\n+\t\t\t     &sym->declared_at) == FAILURE)\n+\treturn FAILURE;\n \n-      if (nl->sym->ts.u.derived->attr.alloc_comp)\n+      /* FIXME: Once UDDTIO is implemented, the following can be\n+\t removed.  */\n+      if (nl->sym->ts.type == BT_CLASS)\n \t{\n-\t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L cannot \"\n-\t\t     \"have ALLOCATABLE components\",\n-\t\t     nl->sym->name, sym->name, &sym->declared_at);\n+\t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L is \"\n+\t\t     \"polymorphic and requires a defined input/output \"\n+\t\t     \"procedure\", nl->sym->name, sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n \n-      if (nl->sym->ts.u.derived->attr.pointer_comp)\n+      if (nl->sym->ts.type == BT_DERIVED\n+\t  && (nl->sym->ts.u.derived->attr.alloc_comp\n+\t      || nl->sym->ts.u.derived->attr.pointer_comp))\n \t{\n-\t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L cannot \"\n-\t\t     \"have POINTER components\", \n-\t\t     nl->sym->name, sym->name, &sym->declared_at);\n+\t  if (gfc_notify_std (GFC_STD_F2003,  \"Fortran 2003: NAMELIST object \"\n+\t\t\t      \"'%s' in namelist '%s' at %L with ALLOCATABLE \"\n+\t\t\t      \"or POINTER components\", nl->sym->name,\n+\t\t\t      sym->name, &sym->declared_at) == FAILURE)\n+\t    return FAILURE;\n+\n+\t /* FIXME: Once UDDTIO is implemented, the following can be\n+\t    removed.  */\n+\t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L has \"\n+\t\t     \"ALLOCATABLE or POINTER components and thus requires \"\n+\t\t     \"a defined input/output procedure\", nl->sym->name,\n+\t\t     sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n     }"}, {"sha": "71aa518ee31b980bc036746bd600d54f3f2658c7", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -390,6 +390,14 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       goto conflict_std;\n     }\n \n+  if (attr->in_namelist && (attr->allocatable || attr->pointer))\n+    {\n+      a1 = in_namelist;\n+      a2 = attr->allocatable ? allocatable : pointer;\n+      standard = GFC_STD_F2003;\n+      goto conflict_std;\n+    }\n+\n   /* Check for attributes not allowed in a BLOCK DATA.  */\n   if (gfc_current_state () == COMP_BLOCK_DATA)\n     {\n@@ -495,9 +503,6 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (in_equivalence, allocatable);\n   conf (in_equivalence, threadprivate);\n \n-  conf (in_namelist, pointer);\n-  conf (in_namelist, allocatable);\n-\n   conf (entry, result);\n \n   conf (function, subroutine);"}, {"sha": "f6a783f38f06aa6f8670efaec7877cfd97550d81", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -1463,6 +1463,7 @@ nml_full_name (const char* var_name, const char* cmp_name)\n   return full_name;\n }\n \n+\n /* nml_get_addr_expr builds an address expression from the\n    gfc_symbol or gfc_component backend_decl's. An offset is\n    provided so that the address of an element of an array of\n@@ -1475,9 +1476,6 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n {\n   tree decl = NULL_TREE;\n   tree tmp;\n-  tree itmp;\n-  int array_flagged;\n-  int dummy_arg_flagged;\n \n   if (sym)\n     {\n@@ -1503,18 +1501,8 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n \n   /* Build indirect reference, if dummy argument.  */\n \n-  dummy_arg_flagged = POINTER_TYPE_P (TREE_TYPE(tmp));\n-\n-  itmp = (dummy_arg_flagged) ? build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t\ttmp) : tmp;\n-\n-  /* If an array, set flag and use indirect ref. if built.  */\n-\n-  array_flagged = (TREE_CODE (TREE_TYPE (itmp)) == ARRAY_TYPE\n-\t\t   && !TYPE_STRING_FLAG (TREE_TYPE (itmp)));\n-\n-  if (array_flagged)\n-    tmp = itmp;\n+  if (POINTER_TYPE_P (TREE_TYPE(tmp)))\n+    tmp = build_fold_indirect_ref_loc (input_location, tmp);\n \n   /* Treat the component of a derived type, using base_addr for\n      the derived type.  */\n@@ -1523,29 +1511,27 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n     tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n \t\t\t   base_addr, tmp, NULL_TREE);\n \n-  /* If we have a derived type component, a reference to the first\n-     element of the array is built.  This is done so that base_addr,\n-     used in the build of the component reference, always points to\n-     a RECORD_TYPE.  */\n-\n-  if (array_flagged)\n-    tmp = gfc_build_array_ref (tmp, gfc_index_zero_node, NULL);\n-\n-  /* Now build the address expression.  */\n-\n-  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+    tmp = gfc_conv_array_data (tmp);\n+  else\n+    {\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\ttmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \n-  /* If scalar dummy, resolve indirect reference now.  */\n+      if (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE)\n+         tmp = gfc_build_array_ref (tmp, gfc_index_zero_node, NULL);\n \n-  if (dummy_arg_flagged && !array_flagged)\n-    tmp = build_fold_indirect_ref_loc (input_location,\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\ttmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t   tmp);\n+    }\n \n   gcc_assert (tmp && POINTER_TYPE_P (TREE_TYPE (tmp)));\n \n   return tmp;\n }\n \n+\n /* For an object VAR_NAME whose base address is BASE_ADDR, generate a\n    call to iocall[IOCALL_SET_NML_VAL].  For derived type variable, recursively\n    generate calls to iocall[IOCALL_SET_NML_VAL] for each component.  */\n@@ -1565,6 +1551,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n   tree tmp;\n   tree dtype;\n   tree dt_parm_addr;\n+  tree decl = NULL_TREE;\n   int n_dim; \n   int itype;\n   int rank = 0;\n@@ -1588,7 +1575,10 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n \n   if (rank)\n     {\n-      dt =  TREE_TYPE ((sym) ? sym->backend_decl : c->backend_decl);\n+      decl = (sym) ? sym->backend_decl : c->backend_decl;\n+      if (sym && sym->attr.dummy)\n+        decl = build_fold_indirect_ref_loc (input_location, decl);\n+      dt =  TREE_TYPE (decl);\n       dtype = gfc_get_dtype (dt);\n     }\n   else\n@@ -1622,9 +1612,9 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n \t\t\t     iocall[IOCALL_SET_NML_VAL_DIM], 5,\n \t\t\t     dt_parm_addr,\n \t\t\t     IARG (n_dim),\n-\t\t\t     GFC_TYPE_ARRAY_STRIDE (dt, n_dim),\n-\t\t\t     GFC_TYPE_ARRAY_LBOUND (dt, n_dim),\n-\t\t\t     GFC_TYPE_ARRAY_UBOUND (dt, n_dim));\n+\t\t\t     gfc_conv_array_stride (decl, n_dim),\n+\t\t\t     gfc_conv_array_lbound (decl, n_dim),\n+\t\t\t     gfc_conv_array_ubound (decl, n_dim));\n       gfc_add_expr_to_block (block, tmp);\n     }\n "}, {"sha": "eb1b1058713e095804a27236b571e35bd7a9b4a4", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constraint_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_1.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -13,7 +13,7 @@ program main\n \n     type(foo) :: a\n     type(bar) :: b\n-    namelist /blah/ a ! { dg-error \"cannot have ALLOCATABLE components\" }\n+    namelist /blah/ a ! { dg-error \"has ALLOCATABLE or POINTER components and thus requires a defined input/output\" }\n \n     write (*, *) a  ! { dg-error \"cannot have ALLOCATABLE components\" }\n "}, {"sha": "722b94027ce1a2e5a9ab030772b28a400864b65b", "filename": "gcc/testsuite/gfortran.dg/namelist_3.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_3.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -1,7 +1,8 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n ! Check that a pointer cannot be a member of a namelist\n program namelist_3\n   integer,pointer :: x\n   allocate (x)\n-  namelist /n/ x ! { dg-error \"NAMELIST attribute conflicts with POINTER attribute\" \"\" }\n+  namelist /n/ x ! { dg-error \"NAMELIST attribute with POINTER attribute\" \"\" }\n end program namelist_3"}, {"sha": "f7c5e1cf6f150b99a936f4de15ac5e0ebd0ba4e6", "filename": "gcc/testsuite/gfortran.dg/namelist_34.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_34.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_34.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_34.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -23,8 +23,8 @@ MODULE nml\n    type(tp1) :: t1\n    type(tp3) :: t3\n \n-   namelist /a/ t1    ! { dg-error \"cannot have POINTER components\" }\n-   namelist /b/ t3    ! { dg-error \"cannot have POINTER components\" }\n+   namelist /a/ t1    ! { dg-error \"has ALLOCATABLE or POINTER components and thus requires a defined input/output\" }\n+   namelist /b/ t3    ! { dg-error \"has ALLOCATABLE or POINTER components and thus requires a defined input/output\" }\n END MODULE\n \n ! { dg-final { cleanup-modules \"types nml\" } }"}, {"sha": "9a2972de8c6280490a5af9aaa666de475c289c50", "filename": "gcc/testsuite/gfortran.dg/namelist_35.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_35.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_35.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_35.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -7,5 +7,5 @@\n subroutine test(cha)\n   implicit none\n   character(len=10) :: cha(:)\n-  namelist /z/  cha             ! { dg-error \"must not have assumed shape\" }\n+  namelist /z/  cha             ! { dg-error \"with assumed shape in namelist\" }\n end subroutine test"}, {"sha": "4fcf9ae66882af9ab42a5d6bda599cb799c132a1", "filename": "gcc/testsuite/gfortran.dg/namelist_5.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_5.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -1,13 +1,15 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n ! Tests the fix for PR25054 in which namelist objects with non-constant\n ! shape were allowed.\n !\n ! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n !\n SUBROUTINE S1(I)\n  integer :: a,b(I)\n- NAMELIST /NLIST/ a,b ! { dg-error \"must have constant shape\" }\n+ NAMELIST /NLIST/ a,b ! { dg-error \"with nonconstant shape\" }\n  a=1 ; b=2\n  write(6,NML=NLIST)\n END SUBROUTINE S1\n-END\n\\ No newline at end of file\n+END"}, {"sha": "0210174031fbe2dd19f1bb96df6c943ca9c69a1e", "filename": "gcc/testsuite/gfortran.dg/namelist_63.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_63.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_63.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_63.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -24,5 +24,5 @@ program test\n end type\n \n type (c_struct) curve(10)\n-namelist / params / curve ! { dg-error \"NAMELIST object .curve. in namelist .params. at .1. cannot have POINTER components\" }\n+namelist / params / curve ! { dg-error \"ALLOCATABLE or POINTER components and thus requires a defined input/output\" }\n end program"}, {"sha": "6261aabcf1d60a82f8c7b70483940c5d237674bc", "filename": "gcc/testsuite/gfortran.dg/namelist_69.f90", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_69.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_69.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_69.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -0,0 +1,233 @@\n+! { dg-do run }\n+!\n+! PR fortran/47339\n+! PR fortran/43062\n+!\n+! Run-time test for Fortran 2003 NAMELISTS\n+! Version for non-strings\n+!\n+program nml_test\n+  implicit none\n+\n+  character(len=1000) :: str\n+\n+  integer, allocatable :: a(:)\n+  integer, allocatable :: b\n+  integer, pointer :: ap(:)\n+  integer, pointer :: bp\n+  integer :: c\n+  integer :: d(3)\n+\n+  type t\n+    integer :: c1\n+    integer :: c2(3)\n+  end type t\n+  type(t) :: e,f(2)\n+  type(t),allocatable :: g,h(:)\n+  type(t),pointer :: i,j(:)\n+\n+  namelist /nml/ a, b, c, d, ap, bp,e,f,g,h,i,j\n+\n+  a = [1,2]\n+  allocate(b,ap(2),bp)\n+  ap = [98, 99]\n+  b = 7\n+  bp = 101\n+  c = 8\n+  d = [-1, -2, -3]\n+\n+  e%c1 = -701\n+  e%c2 = [-702,-703,-704]\n+  f(1)%c1 = 33001\n+  f(2)%c1 = 33002\n+  f(1)%c2 = [44001,44002,44003]\n+  f(2)%c2 = [44011,44012,44013]\n+\n+  allocate(g,h(2),i,j(2))\n+\n+  g%c1 = -601\n+  g%c2 = [-602,6703,-604]\n+  h(1)%c1 = 35001\n+  h(2)%c1 = 35002\n+  h(1)%c2 = [45001,45002,45003]\n+  h(2)%c2 = [45011,45012,45013]\n+\n+  i%c1 = -501\n+  i%c2 = [-502,-503,-504]\n+  j(1)%c1 = 36001\n+  j(2)%c1 = 36002\n+  j(1)%c2 = [46001,46002,46003]\n+  j(2)%c2 = [46011,46012,46013]\n+\n+  ! SAVE NAMELIST\n+  str = repeat('X', len(str))\n+  write(str,nml=nml)\n+\n+  ! RESET NAMELIST\n+  a = [-1,-1]\n+  ap = [-1, -1]\n+  b = -1\n+  bp = -1\n+  c = -1\n+  d = [-1, -1, -1]\n+\n+  e%c1 = -1\n+  e%c2 = [-1,-1,-1]\n+  f(1)%c1 = -1\n+  f(2)%c1 = -1\n+  f(1)%c2 = [-1,-1,-1]\n+  f(2)%c2 = [-1,-1,-1]\n+\n+  g%c1 = -1\n+  g%c2 = [-1,-1,-1]\n+  h(1)%c1 = -1\n+  h(2)%c1 = -1\n+  h(1)%c2 = [-1,-1,-1]\n+  h(2)%c2 = [-1,-1,-1]\n+\n+  i%c1 = -1\n+  i%c2 = [-1,-1,-1]\n+  j(1)%c1 = -1\n+  j(2)%c1 = -1\n+  j(1)%c2 = [-1,-1,-1]\n+  j(2)%c2 = [-1,-1,-1]\n+\n+  ! Read back\n+  read(str,nml=nml)\n+\n+  ! Check result\n+  if (any (a /= [1,2])) call abort()\n+  if (any (ap /= [98, 99])) call abort()\n+  if (b /= 7) call abort()\n+  if (bp /= 101) call abort()\n+  if (c /= 8) call abort()\n+  if (any (d /= [-1, -2, -3])) call abort()\n+\n+  if (e%c1 /= -701) call abort()\n+  if (any (e%c2 /= [-702,-703,-704])) call abort()\n+  if (f(1)%c1 /= 33001) call abort()\n+  if (f(2)%c1 /= 33002) call abort()\n+  if (any (f(1)%c2 /= [44001,44002,44003])) call abort()\n+  if (any (f(2)%c2 /= [44011,44012,44013])) call abort()\n+\n+  if (g%c1 /= -601) call abort()\n+  if (any(g%c2 /= [-602,6703,-604])) call abort()\n+  if (h(1)%c1 /= 35001) call abort()\n+  if (h(2)%c1 /= 35002) call abort()\n+  if (any (h(1)%c2 /= [45001,45002,45003])) call abort()\n+  if (any (h(2)%c2 /= [45011,45012,45013])) call abort()\n+\n+  if (i%c1 /= -501) call abort()\n+  if (any (i%c2 /= [-502,-503,-504])) call abort()\n+  if (j(1)%c1 /= 36001) call abort()\n+  if (j(2)%c1 /= 36002) call abort()\n+  if (any (j(1)%c2 /= [46001,46002,46003])) call abort()\n+  if (any (j(2)%c2 /= [46011,46012,46013])) call abort()\n+\n+  ! Check argument passing (dummy processing)\n+  call test2(a,b,c,d,ap,bp,e,f,g,h,i,j,2) \n+\n+contains\n+  subroutine test2(x1,x2,x3,x4,x1p,x2p,x6,x7,x8,x9,x10,x11,n)\n+    integer, allocatable :: x1(:)\n+    integer, allocatable :: x2\n+    integer, pointer :: x1p(:)\n+    integer, pointer :: x2p\n+    integer :: x3\n+    integer :: x4(3)\n+    integer :: n\n+    integer :: x5(n)\n+    type(t) :: x6,x7(2)\n+    type(t),allocatable :: x8,x9(:)\n+    type(t),pointer :: x10,x11(:)\n+    type(t) :: x12(n)\n+\n+    namelist /nml2/ x1, x2, x3, x4,x5,x1p,x2p,x6,x7,x8,x9,x10,x11,x12\n+\n+    x5 = [ 42, 53 ]\n+\n+    x12(1)%c1 = 37001\n+    x12(2)%c1 = 37002\n+    x12(1)%c2 = [47001,47002,47003]\n+    x12(2)%c2 = [47011,47012,47013]\n+\n+    ! SAVE NAMELIST\n+    str = repeat('X', len(str))\n+    write(str,nml=nml2)\n+\n+    ! RESET NAMELIST\n+    x1 = [-1,-1]\n+    x1p = [-1, -1]\n+    x2 = -1\n+    x2p = -1\n+    x3 = -1\n+    x4 = [-1, -1, -1]\n+\n+    x6%c1 = -1\n+    x6%c2 = [-1,-1,-1]\n+    x7(1)%c1 = -1\n+    x7(2)%c1 = -1\n+    x7(1)%c2 = [-1,-1,-1]\n+    x7(2)%c2 = [-1,-1,-1]\n+\n+    x8%c1 = -1\n+    x8%c2 = [-1,-1,-1]\n+    x9(1)%c1 = -1\n+    x9(2)%c1 = -1\n+    x9(1)%c2 = [-1,-1,-1]\n+    x9(2)%c2 = [-1,-1,-1]\n+\n+    x10%c1 = -1\n+    x10%c2 = [-1,-1,-1]\n+    x11(1)%c1 = -1\n+    x11(2)%c1 = -1\n+    x11(1)%c2 = [-1,-1,-1]\n+    x11(2)%c2 = [-1,-1,-1]\n+\n+    x5 = [ -1, -1 ]\n+\n+    x12(1)%c1 = -1\n+    x12(2)%c1 = -1\n+    x12(1)%c2 = [-1,-1,-1]\n+    x12(2)%c2 = [-1,-1,-1]\n+\n+    ! Read back\n+    read(str,nml=nml2)\n+\n+    ! Check result\n+    if (any (x1 /= [1,2])) call abort()\n+    if (any (x1p /= [98, 99])) call abort()\n+    if (x2 /= 7) call abort()\n+    if (x2p /= 101) call abort()\n+    if (x3 /= 8) call abort()\n+    if (any (x4 /= [-1, -2, -3])) call abort()\n+\n+    if (x6%c1 /= -701) call abort()\n+    if (any (x6%c2 /= [-702,-703,-704])) call abort()\n+    if (x7(1)%c1 /= 33001) call abort()\n+    if (x7(2)%c1 /= 33002) call abort()\n+    if (any (x7(1)%c2 /= [44001,44002,44003])) call abort()\n+    if (any (x7(2)%c2 /= [44011,44012,44013])) call abort()\n+\n+    if (x8%c1 /= -601) call abort()\n+    if (any(x8%c2 /= [-602,6703,-604])) call abort()\n+    if (x9(1)%c1 /= 35001) call abort()\n+    if (x9(2)%c1 /= 35002) call abort()\n+    if (any (x9(1)%c2 /= [45001,45002,45003])) call abort()\n+    if (any (x9(2)%c2 /= [45011,45012,45013])) call abort()\n+\n+    if (x10%c1 /= -501) call abort()\n+    if (any (x10%c2 /= [-502,-503,-504])) call abort()\n+    if (x11(1)%c1 /= 36001) call abort()\n+    if (x11(2)%c1 /= 36002) call abort()\n+    if (any (x11(1)%c2 /= [46001,46002,46003])) call abort()\n+    if (any (x11(2)%c2 /= [46011,46012,46013])) call abort()\n+\n+    if (any (x5 /= [ 42, 53 ])) call abort()\n+\n+    if (x12(1)%c1 /= 37001) call abort()\n+    if (x12(2)%c1 /= 37002) call abort()\n+    if (any (x12(1)%c2 /= [47001,47002,47003])) call abort()\n+    if (any (x12(2)%c2 /= [47011,47012,47013])) call abort()\n+  end subroutine test2\n+end program nml_test"}, {"sha": "f3edfc50cc138fb6bbc6171abcf0d8e0d643c23f", "filename": "gcc/testsuite/gfortran.dg/namelist_70.f90", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_70.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_70.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_70.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -0,0 +1,442 @@\n+! { dg-do run }\n+!\n+! PR fortran/47339\n+! PR fortran/43062\n+!\n+! Run-time test for Fortran 2003 NAMELISTS\n+! Version for non-strings\n+!\n+program nml_test\n+  implicit none\n+\n+  character(len=1000) :: str\n+\n+  character(len=5), allocatable :: a(:)\n+  character(len=5), allocatable :: b\n+  character(len=5), pointer :: ap(:)\n+  character(len=5), pointer :: bp\n+  character(len=5) :: c\n+  character(len=5) :: d(3)\n+\n+  type t\n+    character(len=5) :: c1\n+    character(len=5) :: c2(3)\n+  end type t\n+  type(t) :: e,f(2)\n+  type(t),allocatable :: g,h(:)\n+  type(t),pointer :: i,j(:)\n+\n+  namelist /nml/ a, b, c, d, ap, bp,e,f,g,h,i,j\n+\n+  a = [\"aa01\", \"aa02\"]\n+  allocate(b,ap(2),bp)\n+  ap = ['98', '99']\n+  b = '7'\n+  bp = '101'\n+  c = '8'\n+  d = ['-1', '-2', '-3']\n+\n+  e%c1 = '-701'\n+  e%c2 = ['-702','-703','-704']\n+  f(1)%c1 = '33001'\n+  f(2)%c1 = '33002'\n+  f(1)%c2 = ['44001','44002','44003']\n+  f(2)%c2 = ['44011','44012','44013']\n+\n+  allocate(g,h(2),i,j(2))\n+\n+  g%c1 = '-601'\n+  g%c2 = ['-602','6703','-604']\n+  h(1)%c1 = '35001'\n+  h(2)%c1 = '35002'\n+  h(1)%c2 = ['45001','45002','45003']\n+  h(2)%c2 = ['45011','45012','45013']\n+\n+  i%c1 = '-501'\n+  i%c2 = ['-502','-503','-504']\n+  j(1)%c1 = '36001'\n+  j(2)%c1 = '36002'\n+  j(1)%c2 = ['46001','46002','46003']\n+  j(2)%c2 = ['46011','46012','46013']\n+\n+  ! SAVE NAMELIST\n+  str = repeat('X', len(str))\n+  write(str,nml=nml)\n+\n+  ! RESET NAMELIST\n+  a = repeat('X', len(a))\n+  ap = repeat('X', len(ap))\n+  b = repeat('X', len(b))\n+  bp = repeat('X', len(bp))\n+  c = repeat('X', len(c))\n+  d = repeat('X', len(d))\n+\n+  e%c1 = repeat('X', len(e%c1))\n+  e%c2 = repeat('X', len(e%c2))\n+  f(1)%c1 = repeat('X', len(f(1)%c1))\n+  f(2)%c1 = repeat('X', len(f(2)%c1))\n+  f(1)%c2 = repeat('X', len(f(1)%c2))\n+  f(2)%c2 = repeat('X', len(f(2)%c2))\n+\n+  g%c1 = repeat('X', len(g%c1))\n+  g%c2 = repeat('X', len(g%c1))\n+  h(1)%c1 = repeat('X', len(h(1)%c1))\n+  h(2)%c1 = repeat('X', len(h(1)%c1))\n+  h(1)%c2 = repeat('X', len(h(1)%c1))\n+  h(2)%c2 = repeat('X', len(h(1)%c1))\n+\n+  i%c1 = repeat('X', len(i%c1))\n+  i%c2 = repeat('X', len(i%c1))\n+  j(1)%c1 = repeat('X', len(j(1)%c1))\n+  j(2)%c1 = repeat('X', len(j(2)%c1))\n+  j(1)%c2 = repeat('X', len(j(1)%c2))\n+  j(2)%c2 = repeat('X', len(j(2)%c2))\n+\n+  ! Read back\n+  read(str,nml=nml)\n+\n+  ! Check result\n+  if (any (a /= ['aa01','aa02'])) call abort()\n+  if (any (ap /= ['98', '99'])) call abort()\n+  if (b /= '7') call abort()\n+  if (bp /= '101') call abort()\n+  if (c /= '8') call abort()\n+  if (any (d /= ['-1', '-2', '-3'])) call abort()\n+\n+  if (e%c1 /= '-701') call abort()\n+  if (any (e%c2 /= ['-702','-703','-704'])) call abort()\n+  if (f(1)%c1 /= '33001') call abort()\n+  if (f(2)%c1 /= '33002') call abort()\n+  if (any (f(1)%c2 /= ['44001','44002','44003'])) call abort()\n+  if (any (f(2)%c2 /= ['44011','44012','44013'])) call abort()\n+\n+  if (g%c1 /= '-601') call abort()\n+  if (any(g%c2 /= ['-602','6703','-604'])) call abort()\n+  if (h(1)%c1 /= '35001') call abort()\n+  if (h(2)%c1 /= '35002') call abort()\n+  if (any (h(1)%c2 /= ['45001','45002','45003'])) call abort()\n+  if (any (h(2)%c2 /= ['45011','45012','45013'])) call abort()\n+\n+  if (i%c1 /= '-501') call abort()\n+  if (any (i%c2 /= ['-502','-503','-504'])) call abort()\n+  if (j(1)%c1 /= '36001') call abort()\n+  if (j(2)%c1 /= '36002') call abort()\n+  if (any (j(1)%c2 /= ['46001','46002','46003'])) call abort()\n+  if (any (j(2)%c2 /= ['46011','46012','46013'])) call abort()\n+\n+  ! Check argument passing (dummy processing)\n+  call test2(a,b,c,d,ap,bp,e,f,g,h,i,j,2) \n+  call test3(a,b,c,d,ap,bp,e,f,g,h,i,j,2,len(a)) \n+  call test4(a,b,c,d,ap,bp,e,f,g,h,i,j,2)\n+\n+contains\n+  subroutine test2(x1,x2,x3,x4,x1p,x2p,x6,x7,x8,x9,x10,x11,n)\n+    character(len=5), allocatable :: x1(:)\n+    character(len=5), allocatable :: x2\n+    character(len=5), pointer :: x1p(:)\n+    character(len=5), pointer :: x2p\n+    character(len=5) :: x3\n+    character(len=5) :: x4(3)\n+    integer :: n\n+    character(len=5) :: x5(n)\n+    type(t) :: x6,x7(2)\n+    type(t),allocatable :: x8,x9(:)\n+    type(t),pointer :: x10,x11(:)\n+    type(t) :: x12(n)\n+\n+    namelist /nml2/ x1, x2, x3, x4,x5,x1p,x2p,x6,x7,x8,x9,x10,x11,x12\n+\n+    x5 = [ 'x5-42', 'x5-53' ]\n+\n+    x12(1)%c1 = '37001'\n+    x12(2)%c1 = '37002'\n+    x12(1)%c2 = ['47001','47002','47003']\n+    x12(2)%c2 = ['47011','47012','47013']\n+ \n+    ! SAVE NAMELIST\n+    str = repeat('X', len(str))\n+    write(str,nml=nml2)\n+\n+    ! RESET NAMELIST\n+    x1 = repeat('X', len(x1))\n+    x1p = repeat('X', len(x1p))\n+    x2 = repeat('X', len(x2))\n+    x2p = repeat('X', len(x2p))\n+    x3 = repeat('X', len(x3))\n+    x4 = repeat('X', len(x4))\n+\n+    x6%c1 = repeat('X', len(x6%c1))\n+    x6%c2 = repeat('X', len(x6%c2))\n+    x7(1)%c1 = repeat('X', len(x7(1)%c1))\n+    x7(2)%c1 = repeat('X', len(x7(2)%c1))\n+    x7(1)%c2 = repeat('X', len(x7(1)%c2))\n+    x7(2)%c2 = repeat('X', len(x7(2)%c2))\n+\n+    x8%c1 = repeat('X', len(x8%c1))\n+    x8%c2 = repeat('X', len(x8%c1))\n+    x9(1)%c1 = repeat('X', len(x9(1)%c1))\n+    x9(2)%c1 = repeat('X', len(x9(1)%c1))\n+    x9(1)%c2 = repeat('X', len(x9(1)%c1))\n+    x9(2)%c2 = repeat('X', len(x9(1)%c1))\n+\n+    x10%c1 = repeat('X', len(x10%c1))\n+    x10%c2 = repeat('X', len(x10%c1))\n+    x11(1)%c1 = repeat('X', len(x11(1)%c1))\n+    x11(2)%c1 = repeat('X', len(x11(2)%c1))\n+    x11(1)%c2 = repeat('X', len(x11(1)%c2))\n+    x11(2)%c2 = repeat('X', len(x11(2)%c2))\n+\n+    x5 = repeat('X', len(x5))\n+\n+    x12(1)%c1 = repeat('X', len(x12(2)%c2))\n+    x12(2)%c1 = repeat('X', len(x12(2)%c2))\n+    x12(1)%c2 = repeat('X', len(x12(2)%c2))\n+    x12(2)%c2 = repeat('X', len(x12(2)%c2))\n+\n+    ! Read back\n+    read(str,nml=nml2)\n+\n+    ! Check result\n+    if (any (x1 /= ['aa01','aa02'])) call abort()\n+    if (any (x1p /= ['98', '99'])) call abort()\n+    if (x2 /= '7') call abort()\n+    if (x2p /= '101') call abort()\n+    if (x3 /= '8') call abort()\n+    if (any (x4 /= ['-1', '-2', '-3'])) call abort()\n+\n+    if (x6%c1 /= '-701') call abort()\n+    if (any (x6%c2 /= ['-702','-703','-704'])) call abort()\n+    if (x7(1)%c1 /= '33001') call abort()\n+    if (x7(2)%c1 /= '33002') call abort()\n+    if (any (x7(1)%c2 /= ['44001','44002','44003'])) call abort()\n+    if (any (x7(2)%c2 /= ['44011','44012','44013'])) call abort()\n+\n+    if (x8%c1 /= '-601') call abort()\n+    if (any(x8%c2 /= ['-602','6703','-604'])) call abort()\n+    if (x9(1)%c1 /= '35001') call abort()\n+    if (x9(2)%c1 /= '35002') call abort()\n+    if (any (x9(1)%c2 /= ['45001','45002','45003'])) call abort()\n+    if (any (x9(2)%c2 /= ['45011','45012','45013'])) call abort()\n+ \n+    if (x10%c1 /= '-501') call abort()\n+    if (any (x10%c2 /= ['-502','-503','-504'])) call abort()\n+    if (x11(1)%c1 /= '36001') call abort()\n+    if (x11(2)%c1 /= '36002') call abort()\n+    if (any (x11(1)%c2 /= ['46001','46002','46003'])) call abort()\n+    if (any (x11(2)%c2 /= ['46011','46012','46013'])) call abort()\n+\n+    if (any (x5 /= [ 'x5-42', 'x5-53' ])) call abort()\n+\n+    if (x12(1)%c1 /= '37001') call abort()\n+    if (x12(2)%c1 /= '37002') call abort()\n+    if (any (x12(1)%c2 /= ['47001','47002','47003'])) call abort()\n+    if (any (x12(2)%c2 /= ['47011','47012','47013'])) call abort()\n+  end subroutine test2\n+\n+  subroutine test3(x1,x2,x3,x4,x1p,x2p,x6,x7,x8,x9,x10,x11,n,ll)\n+    integer :: n, ll\n+    character(len=ll), allocatable :: x1(:)\n+    character(len=ll), allocatable :: x2\n+    character(len=ll), pointer :: x1p(:)\n+    character(len=ll), pointer :: x2p\n+    character(len=ll) :: x3\n+    character(len=ll) :: x4(3)\n+    character(len=ll) :: x5(n)\n+    type(t) :: x6,x7(2)\n+    type(t),allocatable :: x8,x9(:)\n+    type(t),pointer :: x10,x11(:)\n+    type(t) :: x12(n)\n+\n+   namelist /nml2/ x1, x2, x3, x4,x5,x1p,x2p,x6,x7,x8,x9,x10,x11,x12\n+\n+    x5 = [ 'x5-42', 'x5-53' ]\n+\n+    x12(1)%c1 = '37001'\n+    x12(2)%c1 = '37002'\n+    x12(1)%c2 = ['47001','47002','47003']\n+    x12(2)%c2 = ['47011','47012','47013']\n+ \n+    ! SAVE NAMELIST\n+    str = repeat('X', len(str))\n+    write(str,nml=nml2)\n+\n+    ! RESET NAMELIST\n+    x1 = repeat('X', len(x1))\n+    x1p = repeat('X', len(x1p))\n+\n+    x2 = repeat('X', len(x2))\n+    x2p = repeat('X', len(x2p))\n+    x3 = repeat('X', len(x3))\n+    x4 = repeat('X', len(x4))\n+\n+    x6%c1 = repeat('X', len(x6%c1))\n+    x6%c2 = repeat('X', len(x6%c2))\n+    x7(1)%c1 = repeat('X', len(x7(1)%c1))\n+    x7(2)%c1 = repeat('X', len(x7(2)%c1))\n+    x7(1)%c2 = repeat('X', len(x7(1)%c2))\n+    x7(2)%c2 = repeat('X', len(x7(2)%c2))\n+\n+    x8%c1 = repeat('X', len(x8%c1))\n+    x8%c2 = repeat('X', len(x8%c1))\n+    x9(1)%c1 = repeat('X', len(x9(1)%c1))\n+    x9(2)%c1 = repeat('X', len(x9(1)%c1))\n+    x9(1)%c2 = repeat('X', len(x9(1)%c1))\n+    x9(2)%c2 = repeat('X', len(x9(1)%c1))\n+\n+    x10%c1 = repeat('X', len(x10%c1))\n+    x10%c2 = repeat('X', len(x10%c1))\n+    x11(1)%c1 = repeat('X', len(x11(1)%c1))\n+    x11(2)%c1 = repeat('X', len(x11(2)%c1))\n+    x11(1)%c2 = repeat('X', len(x11(1)%c2))\n+    x11(2)%c2 = repeat('X', len(x11(2)%c2))\n+\n+    x5 = repeat('X', len(x5))\n+\n+    x12(1)%c1 = repeat('X', len(x12(2)%c2))\n+    x12(2)%c1 = repeat('X', len(x12(2)%c2))\n+    x12(1)%c2 = repeat('X', len(x12(2)%c2))\n+    x12(2)%c2 = repeat('X', len(x12(2)%c2))\n+\n+    ! Read back\n+    read(str,nml=nml2)\n+\n+    ! Check result\n+    if (any (x1 /= ['aa01','aa02'])) call abort()\n+    if (any (x1p /= ['98', '99'])) call abort()\n+    if (x2 /= '7') call abort()\n+    if (x2p /= '101') call abort()\n+    if (x3 /= '8') call abort()\n+    if (any (x4 /= ['-1', '-2', '-3'])) call abort()\n+\n+    if (x6%c1 /= '-701') call abort()\n+    if (any (x6%c2 /= ['-702','-703','-704'])) call abort()\n+    if (x7(1)%c1 /= '33001') call abort()\n+    if (x7(2)%c1 /= '33002') call abort()\n+    if (any (x7(1)%c2 /= ['44001','44002','44003'])) call abort()\n+    if (any (x7(2)%c2 /= ['44011','44012','44013'])) call abort()\n+\n+    if (x8%c1 /= '-601') call abort()\n+    if (any(x8%c2 /= ['-602','6703','-604'])) call abort()\n+    if (x9(1)%c1 /= '35001') call abort()\n+    if (x9(2)%c1 /= '35002') call abort()\n+    if (any (x9(1)%c2 /= ['45001','45002','45003'])) call abort()\n+    if (any (x9(2)%c2 /= ['45011','45012','45013'])) call abort()\n+ \n+    if (x10%c1 /= '-501') call abort()\n+    if (any (x10%c2 /= ['-502','-503','-504'])) call abort()\n+    if (x11(1)%c1 /= '36001') call abort()\n+    if (x11(2)%c1 /= '36002') call abort()\n+    if (any (x11(1)%c2 /= ['46001','46002','46003'])) call abort()\n+    if (any (x11(2)%c2 /= ['46011','46012','46013'])) call abort()\n+\n+    if (any (x5 /= [ 'x5-42', 'x5-53' ])) call abort()\n+\n+    if (x12(1)%c1 /= '37001') call abort()\n+    if (x12(2)%c1 /= '37002') call abort()\n+    if (any (x12(1)%c2 /= ['47001','47002','47003'])) call abort()\n+    if (any (x12(2)%c2 /= ['47011','47012','47013'])) call abort()\n+  end subroutine test3\n+\n+  subroutine test4(x1,x2,x3,x4,x1p,x2p,x6,x7,x8,x9,x10,x11,n)\n+    character(len=*), allocatable :: x1(:)\n+    character(len=*), allocatable :: x2\n+    character(len=*), pointer :: x1p(:)\n+    character(len=*), pointer :: x2p\n+    character(len=*) :: x3\n+    character(len=*) :: x4(3)\n+    integer :: n\n+    character(len=5) :: x5(n)\n+    type(t) :: x6,x7(2)\n+    type(t),allocatable :: x8,x9(:)\n+    type(t),pointer :: x10,x11(:)\n+    type(t) :: x12(n)\n+\n+    namelist /nml2/ x1, x2, x3, x4,x5,x1p,x2p,x6,x7,x8,x9,x10,x11,x12\n+\n+    x5 = [ 'x5-42', 'x5-53' ]\n+\n+    x12(1)%c1 = '37001'\n+    x12(2)%c1 = '37002'\n+    x12(1)%c2 = ['47001','47002','47003']\n+    x12(2)%c2 = ['47011','47012','47013']\n+ \n+    ! SAVE NAMELIST\n+    str = repeat('X', len(str))\n+    write(str,nml=nml2)\n+\n+    ! RESET NAMELIST\n+    x1 = repeat('X', len(x1))\n+    x1p = repeat('X', len(x1p))\n+    x2 = repeat('X', len(x2))\n+    x2p = repeat('X', len(x2p))\n+    x3 = repeat('X', len(x3))\n+    x4 = repeat('X', len(x4))\n+\n+    x6%c1 = repeat('X', len(x6%c1))\n+    x6%c2 = repeat('X', len(x6%c2))\n+    x7(1)%c1 = repeat('X', len(x7(1)%c1))\n+    x7(2)%c1 = repeat('X', len(x7(2)%c1))\n+    x7(1)%c2 = repeat('X', len(x7(1)%c2))\n+    x7(2)%c2 = repeat('X', len(x7(2)%c2))\n+\n+    x8%c1 = repeat('X', len(x8%c1))\n+    x8%c2 = repeat('X', len(x8%c1))\n+    x9(1)%c1 = repeat('X', len(x9(1)%c1))\n+    x9(2)%c1 = repeat('X', len(x9(1)%c1))\n+    x9(1)%c2 = repeat('X', len(x9(1)%c1))\n+    x9(2)%c2 = repeat('X', len(x9(1)%c1))\n+\n+    x10%c1 = repeat('X', len(x10%c1))\n+    x10%c2 = repeat('X', len(x10%c1))\n+    x11(1)%c1 = repeat('X', len(x11(1)%c1))\n+    x11(2)%c1 = repeat('X', len(x11(2)%c1))\n+    x11(1)%c2 = repeat('X', len(x11(1)%c2))\n+    x11(2)%c2 = repeat('X', len(x11(2)%c2))\n+\n+    x5 = repeat('X', len(x5))\n+\n+    x12(1)%c1 = repeat('X', len(x12(2)%c2))\n+    x12(2)%c1 = repeat('X', len(x12(2)%c2))\n+    x12(1)%c2 = repeat('X', len(x12(2)%c2))\n+    x12(2)%c2 = repeat('X', len(x12(2)%c2))\n+\n+    ! Read back\n+    read(str,nml=nml2)\n+\n+    ! Check result\n+    if (any (x1 /= ['aa01','aa02'])) call abort()\n+    if (any (x1p /= ['98', '99'])) call abort()\n+    if (x2 /= '7') call abort()\n+    if (x2p /= '101') call abort()\n+    if (x3 /= '8') call abort()\n+    if (any (x4 /= ['-1', '-2', '-3'])) call abort()\n+\n+    if (x6%c1 /= '-701') call abort()\n+    if (any (x6%c2 /= ['-702','-703','-704'])) call abort()\n+    if (x7(1)%c1 /= '33001') call abort()\n+    if (x7(2)%c1 /= '33002') call abort()\n+    if (any (x7(1)%c2 /= ['44001','44002','44003'])) call abort()\n+    if (any (x7(2)%c2 /= ['44011','44012','44013'])) call abort()\n+\n+    if (x8%c1 /= '-601') call abort()\n+    if (any(x8%c2 /= ['-602','6703','-604'])) call abort()\n+    if (x9(1)%c1 /= '35001') call abort()\n+    if (x9(2)%c1 /= '35002') call abort()\n+    if (any (x9(1)%c2 /= ['45001','45002','45003'])) call abort()\n+    if (any (x9(2)%c2 /= ['45011','45012','45013'])) call abort()\n+ \n+    if (x10%c1 /= '-501') call abort()\n+    if (any (x10%c2 /= ['-502','-503','-504'])) call abort()\n+    if (x11(1)%c1 /= '36001') call abort()\n+    if (x11(2)%c1 /= '36002') call abort()\n+    if (any (x11(1)%c2 /= ['46001','46002','46003'])) call abort()\n+    if (any (x11(2)%c2 /= ['46011','46012','46013'])) call abort()\n+\n+    if (any (x5 /= [ 'x5-42', 'x5-53' ])) call abort()\n+\n+    if (x12(1)%c1 /= '37001') call abort()\n+    if (x12(2)%c1 /= '37002') call abort()\n+    if (any (x12(1)%c2 /= ['47001','47002','47003'])) call abort()\n+    if (any (x12(2)%c2 /= ['47011','47012','47013'])) call abort()\n+  end subroutine test4\n+end program nml_test"}, {"sha": "b7d063c78b06bccd9f912faf35d53b85372240b4", "filename": "gcc/testsuite/gfortran.dg/namelist_assumed_char.f90", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_assumed_char.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d361071b4e622adf624a8a446a18cef89d43a4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_assumed_char.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_assumed_char.f90?ref=19d361071b4e622adf624a8a446a18cef89d43a4", "patch": "@@ -1,7 +1,20 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n ! PR30481 Assumed size character is not allowed in namelist.\n ! Test case from PR, submitted by Jerry DeLisle <jvdelisle@gcc.gnu.org>\n+!\n+! Modifications for PR fortran/47339 / PR fortran/43062:\n+! Add -std=f95, add bar()\n+!\n subroutine foo(c)\n   character*(*) c\n-  namelist /abc/ c  ! { dg-error \"Assumed character length\" }\n+  namelist /abc/ c  ! { dg-error \"nonconstant character length in namelist\" }\n end subroutine\n+\n+subroutine bar(d,n)\n+  integer :: n\n+  character(len=n) d\n+  namelist /abcd/ d  ! { dg-error \"nonconstant character length in namelist\" }\n+end subroutine bar\n+"}]}