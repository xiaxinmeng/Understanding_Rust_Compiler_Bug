{"sha": "86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhMDlhOWU5OWZkNzM0MjNiNmIwMGIxMDgzYWJmYjBkOGFjODYyZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-08-30T05:14:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-08-30T05:14:54Z"}, "message": "Implement C++0x 'auto' semantics.\n\n        * decl.c (start_decl_1): Don't complain about auto being incomplete.\n        (cp_finish_decl): Deduce auto.\n        * init.c (build_new): Handle 'new auto'.\n        * typeck2.c (cxx_incomplete_type_diagnostic): Give a different\n        message for auto than for normal template type parms.\n        * pt.c (type_dependent_expression_p): Handle { }.\n        (make_auto): New function.\n        (listify_autos): New function.\n        (do_auto_deduction): New function.\n        (is_auto): New function.\n        (type_uses_auto): New function.\n        * cp-tree.h: Declare them.\n        * parser.c (cp_parser_decl_specifier_seq): In C++0x mode, don't\n        treat auto as a declspec.\n        (cp_parser_simple_type_specifier): It's a type-specifier.\n\nFrom-SVN: r139798", "tree": {"sha": "e0bd80b1274106f983a05d33d9c48ec65a2d8085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0bd80b1274106f983a05d33d9c48ec65a2d8085"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3914aa38f56986ba8ff512ded75608e875436e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3914aa38f56986ba8ff512ded75608e875436e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3914aa38f56986ba8ff512ded75608e875436e2"}], "stats": {"total": 351, "additions": 332, "deletions": 19}, "files": [{"sha": "debbaba4661655714c68e18adaab68bdd80be8f8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -1,3 +1,22 @@\n+2008-08-29  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement C++0x 'auto' semantics.\n+\t* decl.c (start_decl_1): Don't complain about auto being incomplete.\n+\t(cp_finish_decl): Deduce auto.\n+\t* init.c (build_new): Handle 'new auto'.\n+\t* typeck2.c (cxx_incomplete_type_diagnostic): Give a different\n+\tmessage for auto than for normal template type parms.\n+\t* pt.c (type_dependent_expression_p): Handle { }.\n+\t(make_auto): New function.\n+\t(listify_autos): New function.\n+\t(do_auto_deduction): New function.\n+\t(is_auto): New function.\n+\t(type_uses_auto): New function.\n+\t* cp-tree.h: Declare them.\n+\t* parser.c (cp_parser_decl_specifier_seq): In C++0x mode, don't\n+\ttreat auto as a declspec.\n+\t(cp_parser_simple_type_specifier): It's a type-specifier.\n+\n 2008-08-29  Mark Mitchell  <mark@codesourcery.com>\n \n \t* mangle.c (write_type): Add target-specific manglings for"}, {"sha": "72963f02cbf7a8d1aba548a639ca50583c55c96e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -4521,6 +4521,10 @@ extern void end_specialization\t\t\t(void);\n extern void begin_explicit_instantiation\t(void);\n extern void end_explicit_instantiation\t\t(void);\n extern tree check_explicit_specialization\t(tree, tree, int, int);\n+extern tree make_auto\t\t\t\t(void);\n+extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n+extern tree type_uses_auto\t\t\t(tree);\n+extern bool is_auto\t\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, tree, bool, bool);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);"}, {"sha": "0d4dceddf8de78ba78c641a0d1fba47ecf9485d5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -4203,6 +4203,8 @@ start_decl_1 (tree decl, bool initialized)\n \t arrays which might be completed by the initialization.  */\n       if (complete_p)\n \t;\t\t\t/* A complete type is ok.  */\n+      else if (type_uses_auto (type))\n+\t; \t\t\t/* An auto type is ok.  */\n       else if (TREE_CODE (type) != ARRAY_TYPE)\n \t{\n \t  error (\"variable %q#D has initializer but incomplete type\", decl);\n@@ -4217,8 +4219,11 @@ start_decl_1 (tree decl, bool initialized)\n     }\n   else if (aggregate_definition_p && !complete_p)\n     {\n-      error (\"aggregate %q#D has incomplete type and cannot be defined\",\n-\t     decl);\n+      if (type_uses_auto (type))\n+\terror (\"declaration of %q#D has no initializer\", decl);\n+      else\n+\terror (\"aggregate %q#D has incomplete type and cannot be defined\",\n+\t       decl);\n       /* Change the type so that assemble_variable will give\n \t DECL an rtl we can live with: (mem (const_int 0)).  */\n       type = TREE_TYPE (decl) = error_mark_node;\n@@ -5406,6 +5411,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   int was_readonly = 0;\n   bool var_definition_p = false;\n   int saved_processing_template_decl;\n+  tree auto_node;\n \n   if (decl == error_mark_node)\n     return;\n@@ -5440,6 +5446,14 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       && (DECL_INITIAL (decl) || init))\n     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;\n \n+  auto_node = type_uses_auto (type);\n+  if (auto_node && !type_dependent_expression_p (init))\n+    {\n+      type = TREE_TYPE (decl) = do_auto_deduction (type, init, auto_node);\n+      if (type == error_mark_node)\n+\treturn;\n+    }\n+\n   if (processing_template_decl)\n     {\n       bool type_dependent_p;"}, {"sha": "1c722f52322d6ac0d2f7f2c216495f99afcbd87a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -2366,6 +2366,14 @@ build_new (tree placement, tree type, tree nelts, tree init,\n   orig_nelts = nelts;\n   orig_init = init;\n \n+  if (nelts == NULL_TREE && init != void_zero_node && list_length (init) == 1\n+      && !any_type_dependent_arguments_p (init))\n+    {\n+      tree auto_node = type_uses_auto (type);\n+      if (auto_node)\n+\ttype = do_auto_deduction (type, TREE_VALUE (init), auto_node);\n+    }\n+\n   if (processing_template_decl)\n     {\n       if (dependent_type_p (type)"}, {"sha": "08ec96711c17885c5175b0ce393244b0893cc1a7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -8324,11 +8324,11 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t     GNU Extension:\n \t       thread  */\n \tcase RID_AUTO:\n-          /* Consume the token.  */\n-          cp_lexer_consume_token (parser->lexer);\n-\n           if (cxx_dialect == cxx98) \n             {\n+\t      /* Consume the token.  */\n+\t      cp_lexer_consume_token (parser->lexer);\n+\n               /* Complain about `auto' as a storage specifier, if\n                  we're complaining about C++0x compatibility.  */\n               warning \n@@ -8340,10 +8340,9 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n               cp_parser_set_storage_class (parser, decl_specs, RID_AUTO,\n \t\t\t\t\t   token->location);\n             }\n-          else \n-            /* We do not yet support the use of `auto' as a\n-               type-specifier.  */\n-            error (\"%HC++0x %<auto%> specifier not supported\", &token->location);\n+          else\n+\t    /* C++0x auto type-specifier.  */\n+\t    found_decl_spec = false;\n           break;\n \n \tcase RID_REGISTER:\n@@ -11069,14 +11068,8 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       break;\n       \n     case RID_AUTO:\n-      if (cxx_dialect != cxx98)\n-        {\n-          /* Consume the token.  */\n-          cp_lexer_consume_token (parser->lexer);\n-          /* We do not yet support the use of `auto' as a\n-             type-specifier.  */\n-          error (\"%HC++0x %<auto%> specifier not supported\", &token->location);\n-        }\n+      maybe_warn_cpp0x (\"C++0x auto\");\n+      type = make_auto ();\n       break;\n \n     case RID_DECLTYPE:"}, {"sha": "3b345f1f4a36930c57bafba2b8292682e1321a0a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -16187,6 +16187,19 @@ type_dependent_expression_p (tree expression)\n   if (TREE_CODE (expression) == STMT_EXPR)\n     expression = stmt_expr_value_expr (expression);\n \n+  if (BRACE_ENCLOSED_INITIALIZER_P (expression))\n+    {\n+      tree elt;\n+      unsigned i;\n+\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expression), i, elt)\n+\t{\n+\t  if (type_dependent_expression_p (elt))\n+\t    return true;\n+\t}\n+      return false;\n+    }\n+\n   if (TREE_TYPE (expression) == unknown_type_node)\n     {\n       if (TREE_CODE (expression) == ADDR_EXPR)\n@@ -16673,4 +16686,124 @@ build_non_dependent_args (tree args)\n   return nreverse (new_args);\n }\n \n+/* Returns a type which represents 'auto'.  We use a TEMPLATE_TYPE_PARM\n+   with a level one deeper than the actual template parms.  */\n+\n+tree\n+make_auto (void)\n+{\n+  tree au;\n+\n+  /* ??? Is it worth caching this for multiple autos at the same level?  */\n+  au = cxx_make_type (TEMPLATE_TYPE_PARM);\n+  TYPE_NAME (au) = build_decl (TYPE_DECL, get_identifier (\"auto\"), au);\n+  TYPE_STUB_DECL (au) = TYPE_NAME (au);\n+  TEMPLATE_TYPE_PARM_INDEX (au) = build_template_parm_index\n+    (0, processing_template_decl + 1, processing_template_decl + 1,\n+     TYPE_NAME (au), NULL_TREE);\n+  TYPE_CANONICAL (au) = canonical_type_parameter (au);\n+  DECL_ARTIFICIAL (TYPE_NAME (au)) = 1;\n+  SET_DECL_TEMPLATE_PARM_P (TYPE_NAME (au));\n+\n+  return au;\n+}\n+\n+/* Replace auto in TYPE with std::initializer_list<auto>.  */\n+\n+static tree\n+listify_autos (tree type, tree auto_node)\n+{\n+  tree std_init_list = namespace_binding\n+    (get_identifier (\"initializer_list\"), std_node);\n+  tree argvec;\n+  tree init_auto;\n+  if (!std_init_list || !DECL_CLASS_TEMPLATE_P (std_init_list))\n+    {    \n+      error (\"deducing auto from brace-enclosed initializer list requires \"\n+\t     \"#include <initializer_list>\");\n+      return error_mark_node;\n+    }\n+  argvec = make_tree_vec (1);\n+  TREE_VEC_ELT (argvec, 0) = auto_node;\n+  init_auto = lookup_template_class (std_init_list, argvec, NULL_TREE,\n+\t\t\t\t     NULL_TREE, 0, tf_warning_or_error);\n+\n+  TREE_VEC_ELT (argvec, 0) = init_auto;\n+  if (processing_template_decl)\n+    argvec = add_to_template_args (current_template_args (), argvec);\n+  return tsubst (type, argvec, tf_warning_or_error, NULL_TREE);\n+}\n+\n+/* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n+   from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.  */\n+\n+tree\n+do_auto_deduction (tree type, tree init, tree auto_node)\n+{\n+  tree parms, args, tparms, targs;\n+  int val;\n+\n+  /* [dcl.spec.auto]: Obtain P from T by replacing the occurrences of auto\n+     with either a new invented type template parameter U or, if the\n+     initializer is a braced-init-list (8.5.4), with\n+     std::initializer_list<U>.  */\n+  if (BRACE_ENCLOSED_INITIALIZER_P (init))\n+    type = listify_autos (type, auto_node);\n+\n+  parms = build_tree_list (NULL_TREE, type);\n+  args = build_tree_list (NULL_TREE, init);\n+  tparms = make_tree_vec (1);\n+  targs = make_tree_vec (1);\n+  TREE_VEC_ELT (tparms, 0)\n+    = build_tree_list (NULL_TREE, TYPE_NAME (auto_node));\n+  val = type_unification_real (tparms, targs, parms, args, 0,\n+\t\t\t       DEDUCE_CALL, LOOKUP_NORMAL);\n+  if (val > 0)\n+    {\n+      error (\"unable to deduce %qT from %qE\", type, init);\n+      return error_mark_node;\n+    }\n+\n+  if (processing_template_decl)\n+    targs = add_to_template_args (current_template_args (), targs);\n+  return tsubst (type, targs, tf_warning_or_error, NULL_TREE);\n+}\n+\n+/* Returns true iff TYPE is a TEMPLATE_TYPE_PARM representing 'auto'.  */\n+\n+bool\n+is_auto (const_tree type)\n+{\n+  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n+      && TYPE_IDENTIFIER (type) == get_identifier (\"auto\"))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Returns true iff TYPE contains a use of 'auto'.  Since auto can only\n+   appear as a type-specifier for the declaration in question, we don't\n+   have to look through the whole type.  */\n+\n+tree\n+type_uses_auto (tree type)\n+{\n+  enum tree_code code;\n+  if (is_auto (type))\n+    return type;\n+\n+  code = TREE_CODE (type);\n+\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n+      || code == OFFSET_TYPE || code == FUNCTION_TYPE\n+      || code == METHOD_TYPE || code == ARRAY_TYPE)\n+    return type_uses_auto (TREE_TYPE (type));\n+\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    return type_uses_auto (TREE_TYPE (TREE_TYPE\n+\t\t\t\t   (TYPE_PTRMEMFUNC_FN_TYPE (type))));\n+\n+  return NULL_TREE;\n+}\n+\n #include \"gt-cp-pt.h\""}, {"sha": "24d003f9afa877f543f39ebfbebe95aa57515627", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -398,8 +398,12 @@ cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      emit_diagnostic (diag_kind, input_location, 0,\n-\t\t       \"invalid use of template type parameter %qT\", type);\n+      if (is_auto (type))\n+\temit_diagnostic (diag_kind, input_location, 0,\n+\t\t\t \"invalid use of %<auto%>\");\n+      else\n+\temit_diagnostic (diag_kind, input_location, 0,\n+\t\t\t \"invalid use of template type parameter %qT\", type);\n       break;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:"}, {"sha": "a3df9d1927ef591c7cbed0560257f79a02961c32", "filename": "gcc/testsuite/g++.dg/cpp0x/auto2.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto2.C?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -0,0 +1,72 @@\n+// Positive test for auto\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <typeinfo>\n+extern \"C\" void abort();\n+\n+int f() {}\n+\n+struct A\n+{\n+  int i;\n+  int f() {}\n+  A operator+(A a) { return a; }\n+};\n+\n+template <class T>\n+void g(T t)\n+{\n+  auto x = t+t;\n+  if (typeid(x) != typeid(t+t))\n+    abort();\n+\n+  auto p = new auto(&t);\n+  if (typeid(p) != typeid(T**))\n+    abort();\n+}\n+\n+int main()\n+{\n+  auto i = 42;\n+  if (typeid (i) != typeid (int))\n+    abort();\n+\n+  auto *p = &i;\n+  if (typeid (p) != typeid (int*))\n+    abort();\n+\n+  auto *p2 = &p;\n+  if (typeid (p2) != typeid (int**))\n+    abort();\n+\n+  auto (*fp)() = f;\n+  if (typeid (fp) != typeid (int (*)()))\n+    abort();\n+\n+  auto A::* pm = &A::i;\n+  if (typeid (pm) != typeid (int A::*))\n+    abort();\n+\n+  auto (A::*pmf)() = &A::f;\n+  if (typeid (pmf) != typeid (int (A::*)()))\n+    abort();\n+\n+  g(42);\n+  g(10.f);\n+  g(A());\n+\n+  auto *p3 = new auto (i);\n+  if (typeid (p3) != typeid (int*))\n+    abort();\n+\n+  for (auto idx = i; idx != 0; idx = 0);\n+  while (auto idx = 0);\n+  if (auto idx = 1);\n+\n+  switch (auto s = i)\n+    {\n+    case 42:\n+      break;\n+    }\n+}"}, {"sha": "c16ed7b65d18317a3a0c66b980eeee19041cd3ec", "filename": "gcc/testsuite/g++.dg/cpp0x/auto3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -0,0 +1,16 @@\n+// Negative test for auto\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+auto x;\t\t\t\t// { dg-error \"auto\" }\n+\n+// New CWG issue\n+auto a[2] = { 1, 2 };\t\t// { dg-error \"auto\" }\n+\n+template<class T>\n+struct A { };\n+\n+A<int> A1;\n+// CWG issue 625\n+A<auto> A2 = A1;\t\t// { dg-error \"auto\" }"}, {"sha": "d47bca4369dd43f4ea31c505779b22339d1e367f", "filename": "gcc/testsuite/g++.dg/cpp0x/auto4.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto4.C?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -0,0 +1,28 @@\n+// Testcase for deduction of std::initializer_list for auto.\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <typeinfo>\n+#include <initializer_list>\n+extern \"C\" void abort();\n+\n+template <class T>\n+void f (T t)\n+{\n+  auto ilt = { &t, &t };\n+  if (typeid(ilt) != typeid(std::initializer_list<T*>))\n+    abort();\n+\n+  auto il = { 1, 2, 3 };\n+  if (typeid(il) != typeid(std::initializer_list<int>))\n+    abort();\n+}\n+\n+int main()\n+{\n+  auto il = { 1, 2, 3 };\n+  if (typeid(il) != typeid(std::initializer_list<int>))\n+    abort();\n+\n+  f('c');\n+}"}, {"sha": "ebe2df22e6fa01bb29f47bda24412c386dcdf4c9", "filename": "gcc/testsuite/g++.dg/cpp0x/auto5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a09a9e99fd73423b6b00b1083abfb0d8ac862d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto5.C?ref=86a09a9e99fd73423b6b00b1083abfb0d8ac862d", "patch": "@@ -0,0 +1,22 @@\n+// Testcase for non-dependent auto in templates\n+// { dg-options \"-std=c++0x\" }\n+\n+struct A\n+{\n+  template<class> void f();\n+} a;\n+\n+template <class T>\n+void g()\n+{\n+  auto aa = a;\n+  aa.f<int>();\n+\n+  auto p = new auto (a);\n+  p->f<int>();\n+}\n+\n+int main()\n+{\n+  g<double>();\n+}"}]}