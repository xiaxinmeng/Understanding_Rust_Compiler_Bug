{"sha": "ac6d5c9112bb78e47398e040c553ad216edf3ebb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2ZDVjOTExMmJiNzhlNDczOThlMDQwYzU1M2FkMjE2ZWRmM2ViYg==", "commit": {"author": {"name": "Jeff Law", "email": "jlaw@localhost.localdomain", "date": "2021-08-27T19:27:38Z"}, "committer": {"name": "Jeff Law", "email": "jlaw@localhost.localdomain", "date": "2021-08-27T19:29:22Z"}, "message": "Reduce vector comparison of uniform vectors to a scalar comparison\n\ngcc/\n\t* tree-ssa-dom.c (reduce_vector_comparison_to_scalar_comparison): New\n\tfunction.\n\t(dom_opt_dom_walker::optimize_stmt): Use it.", "tree": {"sha": "ff06d132ee7c198fda35e741aa3a8c6ad443fb02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff06d132ee7c198fda35e741aa3a8c6ad443fb02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac6d5c9112bb78e47398e040c553ad216edf3ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6d5c9112bb78e47398e040c553ad216edf3ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6d5c9112bb78e47398e040c553ad216edf3ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6d5c9112bb78e47398e040c553ad216edf3ebb/comments", "author": null, "committer": null, "parents": [{"sha": "94a047359f84c7ea5ade378028852b19529a7495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a047359f84c7ea5ade378028852b19529a7495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94a047359f84c7ea5ade378028852b19529a7495"}], "stats": {"total": 65, "additions": 65, "deletions": 0}, "files": [{"sha": "a5245b33de696a7be12b04a75cdb6f064ef91db4", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6d5c9112bb78e47398e040c553ad216edf3ebb/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6d5c9112bb78e47398e040c553ad216edf3ebb/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=ac6d5c9112bb78e47398e040c553ad216edf3ebb", "patch": "@@ -1891,6 +1891,66 @@ dom_opt_dom_walker::test_for_singularity (gimple *stmt,\n     }\n }\n \n+/* If STMT is a comparison of two uniform vectors reduce it to a comparison\n+   of scalar objects, otherwise leave STMT unchanged.  */\n+\n+static void\n+reduce_vector_comparison_to_scalar_comparison (gimple *stmt)\n+{\n+  if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      tree lhs = gimple_cond_lhs (stmt);\n+      tree rhs = gimple_cond_rhs (stmt);\n+\n+      /* We may have a vector comparison where both arms are uniform\n+\t vectors.  If so, we can simplify the vector comparison down\n+\t to a scalar comparison.  */\n+      if (TREE_CODE (TREE_TYPE (lhs)) == VECTOR_TYPE\n+\t  && TREE_CODE (TREE_TYPE (rhs)) == VECTOR_TYPE)\n+\t{\n+\t  /* If either operand is an SSA_NAME, then look back to its\n+\t     defining statement to try and get at a suitable source.  */\n+\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t    {\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (rhs);\n+\t      if (gimple_assign_single_p (def_stmt))\n+\t\trhs = gimple_assign_rhs1 (def_stmt);\n+\t    }\n+\n+\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t    {\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (lhs);\n+\t      if (gimple_assign_single_p (def_stmt))\n+\t\tlhs = gimple_assign_rhs1 (def_stmt);\n+\t    }\n+\n+\t  /* Now see if they are both uniform vectors and if so replace\n+\t     the vector comparison with a scalar comparison.  */\n+\t  tree rhs_elem = rhs ? uniform_vector_p (rhs) : NULL_TREE;\n+\t  tree lhs_elem = lhs ? uniform_vector_p (lhs) : NULL_TREE;\n+\t  if (rhs_elem && lhs_elem)\n+\t    {\n+\t      if (dump_file && dump_flags & TDF_DETAILS)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Reducing vector comparison: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t\t}\n+\n+\t      gimple_cond_set_rhs (as_a <gcond *>(stmt), rhs_elem);\n+\t      gimple_cond_set_lhs (as_a <gcond *>(stmt), lhs_elem);\n+\t      gimple_set_modified (stmt, true);\n+\n+\t      if (dump_file && dump_flags & TDF_DETAILS)\n+\t\t{\n+\t\t  fprintf (dump_file, \"To scalar equivalent: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Optimize the statement in block BB pointed to by iterator SI.\n \n    We try to perform some simplistic global redundancy elimination and\n@@ -1933,6 +1993,11 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n   update_stmt_if_modified (stmt);\n   opt_stats.num_stmts++;\n \n+  /* STMT may be a comparison of uniform vectors that we can simplify\n+     down to a comparison of scalars.  Do that transformation first\n+     so that all the scalar optimizations from here onward apply.  */\n+  reduce_vector_comparison_to_scalar_comparison (stmt);\n+\n   /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */\n   cprop_into_stmt (stmt, m_evrp_range_analyzer);\n "}]}