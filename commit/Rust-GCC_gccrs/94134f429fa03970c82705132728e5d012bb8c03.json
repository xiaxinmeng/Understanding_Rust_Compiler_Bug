{"sha": "94134f429fa03970c82705132728e5d012bb8c03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxMzRmNDI5ZmEwMzk3MGM4MjcwNTEzMjcyOGU1ZDAxMmJiOGMwMw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-10-13T21:16:33Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-13T21:16:33Z"}, "message": "Makefile.in (BUILD_RTL): Replace $(BUILD_PREFIX)insn-modes.o with min-insn-modes.o.\n\n\t* Makefile.in (BUILD_RTL): Replace $(BUILD_PREFIX)insn-modes.o\n\twith min-insn-modes.o.\n\t(STAGESTUFF): Add min-insn-modes.c.\n\t(genobjs): Add genmodes.o.\n\t(print-rtl.o, print-rtl1.o): Depend on $(TM_P_H).\n\t(insn-modes.o): Depend on $(TM_H) not $(GTM_H); also real.h.\n\t(min-insn-modes.c, min-insn-modes.o): New rules.\n\t(s-modes): Also generate min-insn-modes.c.\n\t($(BUILD_PREFIX_1)insn-modes.o): Kill.\n\t* genmodes.c (struct mode_data): Add format field.\n\t(blank_mode, validate_mode, complete_mode): Update to match.\n\t(make_scalar_mode): Separate into make_int_mode and make_float_mode.\n\t(_SCALAR_MODE): Kill.\n\t(FLOAT_MODE, FRACTIONAL_FLOAT_MODE): Add format argument.\n\t(emit_insn_modes_c_header): Adjust.\n\t(emit_min_insn_modes_c_header, emit_real_format_for_mode)\n\t(emit_min_insn_modes_c): New functions.\n\t(emit_insn_modes_c): Call emit_real_format_for_mode.\n\t(main): Add -m option to generate min-insn-modes.c.\n\t* machmode.h: Update documentation.  Add format argument to\n\tall uses of FLOAT_MODE.\n\t* real.c: Don't define real_format_for_mode here.\n\n\t* dwarfout.c: Move default definition of PRINT_REG...\n\t* defaults.h: ...here.\n\t* print-rtl.c: Include tm_p.h.\n\t(DEBUG_PRINT_REG, DEBUG_REGISTER_NAMES, debug_reg_names, reg_names):\n\tKill.\n\t(print_rtx): Use PRINT_REG, not DEBUG_PRINT_REG.  But surround\n\tthis entire block with #ifndef GENERATOR_FILE.\n\t* regclass.c: Unconditionally define reg_names.\n\t* config/mips/mips.h, config/rs6000/rs6000.h, config/sh/sh.h\n\tDon't define DEBUG_REGISTER_NAMES.\n\t* config/rs6000/darwin.h: Don't use DEBUG_REGISTER_NAMES in\n\tredefinition of REGISTER_NAMES.\n\t* config/i386/i386.h: Don't define DEBUG_PRINT_REG.\n\n\t* combine.c: Change all preprocessor conditionals on\n\tEXTRA_CC_MODES to use SELECT_CC_MODE instead; rearrange a bit\n\tfor clarity.\n\t* genopinit.c: Remove mention of EXTRA_CC_MODES in comment.\n\t* configure.in: Don't define EXTRA_CC_MODES.\n\t* configure, config.in: Regenerate.\n\t* doc/tm.texi: Remove documentation of EXTRA_CC_MODES.\n\n\t* config/arc/arc.c, config/m32r/m32r.c, config/sparc/sparc.c:\n\tMay assume that GET_MODE_CLASS is accurate for extra CC modes\n\tat all times.\n\n\t* config/i860/i860.h (INIT_CUMULATIVE_ARGS): Pass correct\n\tnumber of arguments to aggregate_value_p.\n\n\t* genmodes.c (RESET_FLOAT_FORMAT, reset_float_format): New.\n\t* machmode.def: Explain ARCH-modes.def.  Document\n\tRESET_FLOAT_FORMAT.  Improve commentary on various mode\n\tclusters.  Do not define OI, PQI, PHI, PSI, PDI, QF, HF, TQF,\n\tXF, or TF modes here.  Remove backward-compatibility\n\tdefinition of CC.\n\n\t* config/alpha/alpha-modes.def: New file; define TF mode.\n\t* config/arc/arm-modes.def: Define XF mode.\n\t* config/c4x/c4x-modes.def: Define QF and HF modes.  Unset\n\tfloat format for SF and DF modes.\n\t* config/dsp16xx/dsp16xx-modes.def: New file; define HF mode.\n\t* config/i386/i386-modes.def: Define XF and TF modes.\n\t* config/i960/i960-modes.def: Define TF mode.\n\t* config/ia64/ia64-modes.def: Define TF and OI modes.\n\t* config/m68k/m68k-modes.def: New file; define XF mode.\n\t* config/mips/mips-modes.def: New file; define TF mode, reset\n\tformats for SF and DF modes.\n\t* config/pa/pa-modes.def: Define TF mode.\n\t* config/rs6000/rs6000.c: Define TF and PSI modes.\n\t* config/s390/s390-modes.def: Define OI mode.\n\t* config/sh/sh-modes.def: New file; define PSI mode.\n\t* config/sparc/sparc-modes.def: Define TF mode.\n\t* config/vax/vax-modes.def: New file; reset formats for SF and\n\tDF modes.\n\n\t* config/c4x/c4x.c (c4x_override_options): No need to mess\n\twith real_format_for_mode or set REAL_MODE_FORMATs.\n\t(c4x_immed_int_constant): Don't apply GET_MODE_CLASS to rtx\n\tvariable.\n\t* config/i386/i386.c (override_options): No need to set\n\tREAL_MODE_FORMATs here.\n\t* config/i960/i960.c (i960_initialize): Likewise.\n\t* config/m68k/m68k.c (m68k_override_options): Likewise.\n\t* config/ia64/ia64.c (ia64_override_options): Set REAL_MODE_FORMAT\n\tfor TFmode only if not the default.\n\t* config/mips/mips.c (override_options): Likewise.\n\t* config/vax/vax.c (override_optionms): Set REAL_MODE_FORMAT for\n\tDFmode only if not the default.\n\n\t* config/i370/i370.h (RET_REG): Don't consider TFmode.\n\t* config/m68hc11/m68hc11.c (print_operand): Don't consider XFmode.\n\t* config/dsp16xx/dsp16xx.c (hard_regno_mode_ok): #if 0 out use\n\tof modes that don't appear anywhere in the machine description.\n\n\t* config/arc/arc-modes.def, config/arm/arm-modes.def\n\t* config/c4x/c4x-modes.def, config/frv/frv-modes.def\n\t* config/i386/i386-modes.def, config/i960/i960-modes.def\n\t* config/ia64/ia64-modes.def, config/mmix/mmix-modes.def\n\t* config/pa/pa-modes.def, config/pdp11/pdp11-modes.def\n\t* config/rs6000/rs6000-modes.def, config/s390/s390-modes.def\n\t* config/sparc/sparc-modes.def: Convert to new style for\n\tdeclaring extra CC modes.\n\nFrom-SVN: r72440", "tree": {"sha": "0fd3f6b88fb03cdb98c4fbc4c1377f2f8c6b0ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fd3f6b88fb03cdb98c4fbc4c1377f2f8c6b0ff1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94134f429fa03970c82705132728e5d012bb8c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94134f429fa03970c82705132728e5d012bb8c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94134f429fa03970c82705132728e5d012bb8c03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94134f429fa03970c82705132728e5d012bb8c03/comments", "author": null, "committer": null, "parents": [{"sha": "d08dcf87c3cd30fc6d3029bed71ed06237c840ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08dcf87c3cd30fc6d3029bed71ed06237c840ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d08dcf87c3cd30fc6d3029bed71ed06237c840ba"}], "stats": {"total": 1061, "additions": 652, "deletions": 409}, "files": [{"sha": "06d9a766a5e0d31cf25b89449ea50e0b77a7e5e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -1,3 +1,111 @@\n+2003-10-13  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* Makefile.in (BUILD_RTL): Replace $(BUILD_PREFIX)insn-modes.o\n+\twith min-insn-modes.o.\n+\t(STAGESTUFF): Add min-insn-modes.c.\n+\t(genobjs): Add genmodes.o.\n+\t(print-rtl.o, print-rtl1.o): Depend on $(TM_P_H).\n+\t(insn-modes.o): Depend on $(TM_H) not $(GTM_H); also real.h.\n+\t(min-insn-modes.c, min-insn-modes.o): New rules.\n+\t(s-modes): Also generate min-insn-modes.c.\n+\t($(BUILD_PREFIX_1)insn-modes.o): Kill.\n+\t* genmodes.c (struct mode_data): Add format field.\n+\t(blank_mode, validate_mode, complete_mode): Update to match.\n+\t(make_scalar_mode): Separate into make_int_mode and make_float_mode.\n+\t(_SCALAR_MODE): Kill.\n+\t(FLOAT_MODE, FRACTIONAL_FLOAT_MODE): Add format argument.\n+\t(emit_insn_modes_c_header): Adjust.\n+\t(emit_min_insn_modes_c_header, emit_real_format_for_mode)\n+\t(emit_min_insn_modes_c): New functions.\n+\t(emit_insn_modes_c): Call emit_real_format_for_mode.\n+\t(main): Add -m option to generate min-insn-modes.c.\n+\t* machmode.h: Update documentation.  Add format argument to\n+\tall uses of FLOAT_MODE.\n+\t* real.c: Don't define real_format_for_mode here.\n+\n+\t* dwarfout.c: Move default definition of PRINT_REG...\n+\t* defaults.h: ...here.\n+\t* print-rtl.c: Include tm_p.h.\n+\t(DEBUG_PRINT_REG, DEBUG_REGISTER_NAMES, debug_reg_names, reg_names):\n+\tKill.\n+\t(print_rtx): Use PRINT_REG, not DEBUG_PRINT_REG.  But surround\n+\tthis entire block with #ifndef GENERATOR_FILE.\n+\t* regclass.c: Unconditionally define reg_names.\n+\t* config/mips/mips.h, config/rs6000/rs6000.h, config/sh/sh.h\n+\tDon't define DEBUG_REGISTER_NAMES.\n+\t* config/rs6000/darwin.h: Don't use DEBUG_REGISTER_NAMES in\n+\tredefinition of REGISTER_NAMES.\n+\t* config/i386/i386.h: Don't define DEBUG_PRINT_REG.\n+\n+\t* combine.c: Change all preprocessor conditionals on\n+\tEXTRA_CC_MODES to use SELECT_CC_MODE instead; rearrange a bit\n+\tfor clarity.\n+\t* genopinit.c: Remove mention of EXTRA_CC_MODES in comment.\n+\t* configure.in: Don't define EXTRA_CC_MODES.\n+\t* configure, config.in: Regenerate.\n+\t* doc/tm.texi: Remove documentation of EXTRA_CC_MODES.\n+\n+\t* config/arc/arc.c, config/m32r/m32r.c, config/sparc/sparc.c:\n+\tMay assume that GET_MODE_CLASS is accurate for extra CC modes\n+\tat all times.\n+\n+\t* config/i860/i860.h (INIT_CUMULATIVE_ARGS): Pass correct\n+\tnumber of arguments to aggregate_value_p.\n+\n+\t* genmodes.c (RESET_FLOAT_FORMAT, reset_float_format): New.\n+\t* machmode.def: Explain ARCH-modes.def.  Document\n+\tRESET_FLOAT_FORMAT.  Improve commentary on various mode\n+\tclusters.  Do not define OI, PQI, PHI, PSI, PDI, QF, HF, TQF,\n+\tXF, or TF modes here.  Remove backward-compatibility\n+\tdefinition of CC.\n+\n+\t* config/alpha/alpha-modes.def: New file; define TF mode.\n+\t* config/arc/arm-modes.def: Define XF mode.\n+\t* config/c4x/c4x-modes.def: Define QF and HF modes.  Unset\n+\tfloat format for SF and DF modes.\n+\t* config/dsp16xx/dsp16xx-modes.def: New file; define HF mode.\n+\t* config/i386/i386-modes.def: Define XF and TF modes.\n+\t* config/i960/i960-modes.def: Define TF mode.\n+\t* config/ia64/ia64-modes.def: Define TF and OI modes.\n+\t* config/m68k/m68k-modes.def: New file; define XF mode.\n+\t* config/mips/mips-modes.def: New file; define TF mode, reset\n+\tformats for SF and DF modes.\n+\t* config/pa/pa-modes.def: Define TF mode.\n+\t* config/rs6000/rs6000.c: Define TF and PSI modes.\n+\t* config/s390/s390-modes.def: Define OI mode.\n+\t* config/sh/sh-modes.def: New file; define PSI mode.\n+\t* config/sparc/sparc-modes.def: Define TF mode.\n+\t* config/vax/vax-modes.def: New file; reset formats for SF and\n+\tDF modes.\n+\n+\t* config/c4x/c4x.c (c4x_override_options): No need to mess\n+\twith real_format_for_mode or set REAL_MODE_FORMATs.\n+\t(c4x_immed_int_constant): Don't apply GET_MODE_CLASS to rtx\n+\tvariable.\n+\t* config/i386/i386.c (override_options): No need to set\n+\tREAL_MODE_FORMATs here.\n+\t* config/i960/i960.c (i960_initialize): Likewise.\n+\t* config/m68k/m68k.c (m68k_override_options): Likewise.\n+\t* config/ia64/ia64.c (ia64_override_options): Set REAL_MODE_FORMAT\n+\tfor TFmode only if not the default.\n+\t* config/mips/mips.c (override_options): Likewise.\n+\t* config/vax/vax.c (override_optionms): Set REAL_MODE_FORMAT for\n+\tDFmode only if not the default.\n+\n+\t* config/i370/i370.h (RET_REG): Don't consider TFmode.\n+\t* config/m68hc11/m68hc11.c (print_operand): Don't consider XFmode.\n+\t* config/dsp16xx/dsp16xx.c (hard_regno_mode_ok): #if 0 out use\n+\tof modes that don't appear anywhere in the machine description.\n+\n+\t* config/arc/arc-modes.def, config/arm/arm-modes.def\n+\t* config/c4x/c4x-modes.def, config/frv/frv-modes.def\n+\t* config/i386/i386-modes.def, config/i960/i960-modes.def\n+\t* config/ia64/ia64-modes.def, config/mmix/mmix-modes.def\n+\t* config/pa/pa-modes.def, config/pdp11/pdp11-modes.def\n+\t* config/rs6000/rs6000-modes.def, config/s390/s390-modes.def\n+\t* config/sparc/sparc-modes.def: Convert to new style for\n+\tdeclaring extra CC modes.\n+\n 2003-10-13  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cpplex.c (_cpp_clean_line): In the common case of a line"}, {"sha": "ede3da34101404eb55d55e968eb68e2242f8d8be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -715,7 +715,7 @@ LDEXP_LIB = @LDEXP_LIB@\n BUILD_LIBS = $(BUILD_LIBIBERTY)\n \n BUILD_RTL = $(BUILD_PREFIX)rtl.o read-rtl.o $(BUILD_PREFIX)bitmap.o \\\n-\t\t$(BUILD_PREFIX)ggc-none.o $(BUILD_PREFIX)insn-modes.o\n+\t\t$(BUILD_PREFIX)ggc-none.o min-insn-modes.o\n BUILD_SUPPORT = gensupport.o insn-conditions.o\n BUILD_EARLY_SUPPORT = gensupport.o dummy-conditions.o\n \n@@ -863,7 +863,7 @@ BACKEND = main.o libbackend.a\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attrtab.c insn-opinit.c insn-constants.h tm-preds.h \\\n- tree-check.h insn-conditions.c insn-modes.c insn-modes.h \\\n+ tree-check.h insn-conditions.c min-insn-modes.c insn-modes.c insn-modes.h \\\n  s-flags s-config s-codes s-mlib s-genrtl s-modes s-gtype gtyp-gen.h \\\n  s-output s-recog s-emit s-extract s-peep s-check s-conditions \\\n  s-attr s-attrtab s-opinit s-preds s-constants s-crt0 \\\n@@ -1519,7 +1519,7 @@ rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(RTL_H) real.h \\\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-    hard-reg-set.h $(BASIC_BLOCK_H) real.h\n+    hard-reg-set.h $(BASIC_BLOCK_H) real.h $(TM_P_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(RTL_H) \\\n    hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h flags.h\n \n@@ -2010,13 +2010,15 @@ s-genrtl: gengenrtl$(build_exeext) $(srcdir)/move-if-change\n \t$(SHELL) $(srcdir)/move-if-change tmp-genrtl.c genrtl.c\n \t$(STAMP) s-genrtl\n \n-insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \\\n-\t       $(MACHMODE_H)\n-insn-modes.c insn-modes.h : s-modes ; @true\n+insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+\t       $(MACHMODE_H) real.h\n+min-insn-modes.c insn-modes.c insn-modes.h : s-modes ; @true\n \n s-modes: genmodes$(build_exeext) $(srcdir)/move-if-change\n \t$(RUN_GEN) ./genmodes$(build_exeext) -h > tmp-modes.h\n \t$(SHELL) $(srcdir)/move-if-change tmp-modes.h insn-modes.h\n+\t$(RUN_GEN) ./genmodes$(build_exeext) -m > tmp-min-modes.c\n+\t$(SHELL) $(srcdir)/move-if-change tmp-min-modes.c min-insn-modes.c\n \t$(RUN_GEN) ./genmodes$(build_exeext) > tmp-modes.c\n \t$(SHELL) $(srcdir)/move-if-change tmp-modes.c insn-modes.c\n \t$(STAMP) s-modes\n@@ -2113,7 +2115,7 @@ genprogs=$(genprognames:%=%$(build_exeext))\n \n # Object files used in those programs.\n genobjs=$(genprognames:%=%.o) read-rtl.o gensupport.o genattrtab.o \\\n-        genautomata.o gengenrtl.o genpreds.o gengtype.o \\\n+        genautomata.o gengenrtl.o genmodes.o genpreds.o gengtype.o \\\n \tgenconstants.o gen-protos.o scan.o fix-header.o scan-decls.o \\\n \tgencheck.o dummy-conditions.o genconditions.o\n \n@@ -2261,7 +2263,7 @@ $(BUILD_PREFIX_1)rtl.o: $(srcdir)/rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYST\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)rtl.c $(OUTPUT_OPTION)\n \n print-rtl1.o: $(srcdir)/print-rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) \\\n-  $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H)\n+  $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H)\n \trm -f print-rtl1.c\n \tsed -e 's/config[.]h/bconfig.h/' $(srcdir)/print-rtl.c > print-rtl1.c\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) print-rtl1.c $(OUTPUT_OPTION)\n@@ -2290,11 +2292,9 @@ $(BUILD_PREFIX_1)ggc-none.o: ggc-none.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYST\n \tsed -e 's/config[.]h/bconfig.h/' $(srcdir)/ggc-none.c > $(BUILD_PREFIX)ggc-none.c\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)ggc-none.c $(OUTPUT_OPTION)\n \n-$(BUILD_PREFIX_1)insn-modes.o: insn-modes.c $(BCONFIG_H) $(SYSTEM_H) \\\n-\t\t\t       coretypes.h $(GTM_H) $(MACHMODE_H)\n-\trm -f $(BUILD_PREFIX)insn-modes.c\n-\tsed -e 's/config[.]h/bconfig.h/' $(srcdir)/insn-modes.c > $(BUILD_PREFIX)insn-modes.c\n-\t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)insn-modes.c $(OUTPUT_OPTION)\n+min-insn-modes.o: insn-modes.c $(BCONFIG_H) $(SYSTEM_H) $(MACHMODE_H)\n+\t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \\\n+\t    min-insn-modes.c $(OUTPUT_OPTION)\n \n #\f\n # Remake internationalization support."}, {"sha": "cac585a69c0261960711c474140a86914628fc86", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -1893,7 +1893,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       && XEXP (SET_SRC (PATTERN (i3)), 1) == const0_rtx\n       && rtx_equal_p (XEXP (SET_SRC (PATTERN (i3)), 0), i2dest))\n     {\n-#ifdef EXTRA_CC_MODES\n+#ifdef SELECT_CC_MODE\n       rtx *cc_use;\n       enum machine_mode compare_mode;\n #endif\n@@ -1903,7 +1903,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n       i2_is_used = 1;\n \n-#ifdef EXTRA_CC_MODES\n+#ifdef SELECT_CC_MODE\n       /* See if a COMPARE with the operand we substituted in should be done\n \t with the mode that is currently being used.  If not, do the same\n \t processing we do in `subst' for a SET; namely, if the destination\n@@ -5048,13 +5048,12 @@ simplify_set (rtx x)\n       /* Simplify our comparison, if possible.  */\n       new_code = simplify_comparison (old_code, &op0, &op1);\n \n-#ifdef EXTRA_CC_MODES\n+#ifdef SELECT_CC_MODE\n       /* If this machine has CC modes other than CCmode, check to see if we\n \t need to use a different CC mode here.  */\n       compare_mode = SELECT_CC_MODE (new_code, op0, op1);\n-#endif /* EXTRA_CC_MODES */\n \n-#if !defined (HAVE_cc0) && defined (EXTRA_CC_MODES)\n+#ifndef HAVE_cc0\n       /* If the mode changed, we have to change SET_DEST, the mode in the\n \t compare, and the mode in the place SET_DEST is used.  If SET_DEST is\n \t a hard register, just build new versions with the proper mode.  If it\n@@ -5078,7 +5077,8 @@ simplify_set (rtx x)\n \t      dest = new_dest;\n \t    }\n \t}\n-#endif\n+#endif  /* cc0 */\n+#endif  /* SELECT_CC_MODE */\n \n       /* If the code changed, we have to build a new comparison in\n \t undobuf.other_insn.  */"}, {"sha": "f39589da7483a54dbcab944e03b55a5a2532d315", "filename": "gcc/config.in", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -415,10 +415,6 @@\n    for this architecture. */\n #undef EXTRA_MODES_FILE\n \n-/* Define if the target architecture needs extra machine modes to represent\n-   the results of comparisons. */\n-#undef EXTRA_CC_MODES\n-\n /* Define to 1 if translation of program messages to the \n   user's native language is requested. */\n #undef ENABLE_NLS"}, {"sha": "b3747a1dae8e76729551ab536e422fc8b9a38965", "filename": "gcc/config/alpha/alpha-modes.def", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Falpha%2Falpha-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Falpha%2Falpha-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -0,0 +1,23 @@\n+/* Alpha extra machine modes. \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* 128-bit floating point.  This gets reset in alpha_override_options\n+   if VAX float format is in use. */\n+FLOAT_MODE (TF, 16, ieee_quad_format);"}, {"sha": "692a1e60fa54d71e33798d3af49fb179864fd6de", "filename": "gcc/config/arc/arc-modes.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Farc%2Farc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Farc%2Farc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -21,5 +21,5 @@ Boston, MA 02111-1307, USA.  */\n /* Some insns set all condition code flags, some only set the ZNC flags, and\n    some only set the ZN flags.  */\n \n-CC (CCZNC)\n-CC (CCZN)\n+CC_MODE (CCZNC);\n+CC_MODE (CCZN);"}, {"sha": "4e2022e5111a30c416f928676b48b0e96be9db4a", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -320,13 +320,10 @@ arc_init_reg_tables ()\n \t    arc_mode_class[i] = 0;\n \t  break;\n \tcase MODE_CC:\n+\t  arc_mode_class[i] = 1 << (int) C_MODE;\n+\t  break;\n \tdefault:\n-\t  /* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so\n-\t     we must explicitly check for them here.  */\n-\t  if (i == (int) CCmode || i == (int) CCZNmode || i == (int) CCZNCmode)\n-\t    arc_mode_class[i] = 1 << (int) C_MODE;\n-\t  else\n-\t    arc_mode_class[i] = 0;\n+\t  arc_mode_class[i] = 0;\n \t  break;\n \t}\n     }"}, {"sha": "154d3220689868119ba90e79218d8640ea95bb4f", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -22,25 +22,29 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n+/* Extended precision floating point.\n+   FIXME What format is this?  */\n+FLOAT_MODE (XF, 12, 0);\n+\n /* CCFPEmode should be used with floating inequalities,\n    CCFPmode should be used with floating equalities.\n    CC_NOOVmode should be used with SImode integer equalities.\n    CC_Zmode should be used if only the Z flag is set correctly\n    CCmode should be used otherwise. */\n \n-CC (CC_NOOV)\n-CC (CC_Z)\n-CC (CC_SWP)\n-CC (CCFP)\n-CC (CCFPE)\n-CC (CC_DNE)\n-CC (CC_DEQ)\n-CC (CC_DLE)\n-CC (CC_DLT)\n-CC (CC_DGE)\n-CC (CC_DGT)\n-CC (CC_DLEU)\n-CC (CC_DLTU)\n-CC (CC_DGEU)\n-CC (CC_DGTU)\n-CC (CC_C)\n+CC_MODE (CC_NOOV);\n+CC_MODE (CC_Z);\n+CC_MODE (CC_SWP);\n+CC_MODE (CCFP);\n+CC_MODE (CCFPE);\n+CC_MODE (CC_DNE);\n+CC_MODE (CC_DEQ);\n+CC_MODE (CC_DLE);\n+CC_MODE (CC_DLT);\n+CC_MODE (CC_DGE);\n+CC_MODE (CC_DGT);\n+CC_MODE (CC_DLEU);\n+CC_MODE (CC_DLTU);\n+CC_MODE (CC_DGEU);\n+CC_MODE (CC_DGTU);\n+CC_MODE (CC_C);"}, {"sha": "adf691a023a7a90ae55e0c9cf9c332685ba36e13", "filename": "gcc/config/c4x/c4x-modes.def", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -21,6 +21,14 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n+/* C4x wants 1- and 2-word float modes, in its own peculiar format.\n+   FIXME: Give this port a way to get rid of SFmode, DFmode, and all\n+   the other modes it doesn't use.  */\n+FLOAT_MODE (QF, 1, c4x_single_format);\n+FLOAT_MODE (HF, 2, c4x_extended_format);\n+RESET_FLOAT_FORMAT (SF, 0);  /* not used */\n+RESET_FLOAT_FORMAT (DF, 0);  /* not used */\n+\n /* Add any extra modes needed to represent the condition code.\n \n    On the C4x, we have a \"no-overflow\" mode which is used when an ADD,\n@@ -98,5 +106,4 @@\n    load instructions after an add, subtract, neg, abs or multiply.\n    We must emit a compare insn to check the result against 0.  */\n \n-CC (CC_NOOV)\n-\n+CC_MODE (CC_NOOV);"}, {"sha": "7fb5a337b419635376aa964ac91bbebb89937262", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -314,11 +314,6 @@ c4x_override_options (void)\n      This provides compatibility with the old -mno-aliases option.  */\n   if (! TARGET_ALIASES && ! flag_argument_noalias)\n     flag_argument_noalias = 1;\n-\n-  /* We're C4X floating point, not IEEE floating point.  */\n-  memset (real_format_for_mode, 0, sizeof real_format_for_mode);\n-  REAL_MODE_FORMAT (QFmode) = &c4x_single_format;\n-  REAL_MODE_FORMAT (HFmode) = &c4x_extended_format;\n }\n \n \n@@ -2464,8 +2459,8 @@ c4x_immed_int_constant (rtx op)\n     return 0;\n \n   return GET_MODE (op) == VOIDmode\n-    || GET_MODE_CLASS (op) == MODE_INT\n-    || GET_MODE_CLASS (op) == MODE_PARTIAL_INT;\n+    || GET_MODE_CLASS (GET_MODE (op)) == MODE_INT\n+    || GET_MODE_CLASS (GET_MODE (op)) == MODE_PARTIAL_INT;\n }\n \n "}, {"sha": "968e271ff44ad6bb0d11a31c7afd7a5405ce4cf6", "filename": "gcc/config/dsp16xx/dsp16xx-modes.def", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -0,0 +1,23 @@\n+/* DSP16xx extra modes.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* HFmode is the DSP16xx's equivalent of SFmode.\n+   FIXME: What format is this anyway? */ \n+FLOAT_MODE (HF, 2, 0);"}, {"sha": "dcfbc7e6853a9932d5c9d0a555fc6ed1feed735e", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -203,12 +203,15 @@ hard_regno_mode_ok (regno, mode)\n \t modes.  */\n       \n     case HFmode:\n+    case HImode:\n+#if 0 /* ??? These modes do not appear in the machine description nor\n+         are there library routines for them.  */\n     case SFmode:\n     case DFmode:\n     case XFmode:\n-    case HImode:\n     case SImode:\n     case DImode:\n+#endif\n       if (regno == REG_A0 || regno == REG_A1 || regno == REG_Y || regno == REG_PROD\n \t  || (IS_YBASE_REGISTER_WINDOW(regno) && ((regno & 1) == 0)))\n \treturn 1;"}, {"sha": "3985099a91c4b5dfbe6f047c9e87b221f61c6048", "filename": "gcc/config/frv/frv-modes.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Ffrv%2Ffrv-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Ffrv%2Ffrv-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -25,6 +25,6 @@ Boston, MA 02111-1307, USA.  */\n    CC_FPmode\tset FCC's from comparing floating point\n    CC_CCRmode\tset CCR's to do conditional execution */\n \n-CC (CC_UNS)\n-CC (CC_FP)\n-CC (CC_CCR)\n+CC_MODE (CC_UNS);\n+CC_MODE (CC_FP);\n+CC_MODE (CC_CCR);"}, {"sha": "8109ddedc2e99df044235852f39ee4ee6b1d6b0a", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -570,7 +570,8 @@ enum reg_class\n  */\n \n #define RET_REG(MODE)\t\\\n-    (((MODE) == DCmode || (MODE) == SCmode || (MODE) == TFmode || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n+    (((MODE) == DCmode || (MODE) == SCmode \\\n+      || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n   gen_rtx_REG (TYPE_MODE (VALTYPE), RET_REG (TYPE_MODE (VALTYPE)))"}, {"sha": "ddfc5cfcf521c22c434d44f4b196c1fc3405dc95", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -18,6 +18,12 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* By default our XFmode is the 80-bit extended format.  If we use\n+   TFmode instead, it's also the 80-bit format, but with padding. */\n+\n+FLOAT_MODE (XF, 12, ieee_extended_intel_96_format);\n+FLOAT_MODE (TF, 16, ieee_extended_intel_128_format);\n+\n /* Add any extra modes needed to represent the condition code.\n \n    For the i386, we need separate modes when floating-point\n@@ -38,9 +44,9 @@ Boston, MA 02111-1307, USA.  */\n \n    Add CCZ to indicate that only the Zero flag is valid.  */\n \n-CC (CCGC)\n-CC (CCGOC)\n-CC (CCNO)\n-CC (CCZ)\n-CC (CCFP)\n-CC (CCFPU)\n+CC_MODE (CCGC);\n+CC_MODE (CCGOC);\n+CC_MODE (CCNO);\n+CC_MODE (CCZ);\n+CC_MODE (CCFP);\n+CC_MODE (CCFPU);"}, {"sha": "dbdb194fc74820a77d18e94f366bd516f267269c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -1111,11 +1111,6 @@ override_options (void)\n \n   int const pta_size = ARRAY_SIZE (processor_alias_table);\n \n-  /* By default our XFmode is the 80-bit extended format.  If we have\n-     use TFmode instead, it's also the 80-bit format, but with padding.  */\n-  REAL_MODE_FORMAT (XFmode) = &ieee_extended_intel_96_format;\n-  REAL_MODE_FORMAT (TFmode) = &ieee_extended_intel_128_format;\n-\n   /* Set the default values for switches whose default depends on TARGET_64BIT\n      in case they weren't overwritten by command line options.  */\n   if (TARGET_64BIT)"}, {"sha": "b5575ec7f1c12217f35cf1a43af890a1c94bbf4a", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -465,7 +465,7 @@ struct cumulative_args { int ints, floats; };\n    invisible first argument.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n- ((CUM).ints = ((FNTYPE) != 0 && aggregate_value_p (TREE_TYPE ((FNTYPE))) \\\n+ ((CUM).ints = ((FNTYPE) != 0 && aggregate_value_p (TREE_TYPE ((FNTYPE)), 0) \\\n \t\t? 4 : 0),\t\t\t\\\n   (CUM).floats = 0)\n "}, {"sha": "e99939049c62734e62d3f7aba6e239841f2ecb37", "filename": "gcc/config/i960/i960-modes.def", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi960%2Fi960-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi960%2Fi960-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -21,10 +21,13 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* long double */\n+FLOAT_MODE (TF, 16, ieee_extended_intel_128_format);\n+\n /* Add any extra modes needed to represent the condition code.\n \n    Also, signed and unsigned comparisons are distinguished, as\n    are operations which are compatible with chkbit insns.  */\n \n-CC (CC_UNS)\n-CC (CC_CHK)\n+CC_MODE (CC_UNS);\n+CC_MODE (CC_CHK);"}, {"sha": "c1284f48da3eb67603441a0c2c3509cd30ee1637", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -167,9 +167,6 @@ i960_initialize ()\n       i960_maxbitalignment = 128;\n       i960_last_maxbitalignment = 8;\n     }\n-\n-  /* Tell the compiler which flavor of TFmode we're using.  */\n-  REAL_MODE_FORMAT (TFmode) = &ieee_extended_intel_128_format;\n }\n \f\n /* Return true if OP can be used as the source of an fp move insn.  */"}, {"sha": "f6d662fdd21432bb0273f49dd181837fdc161939", "filename": "gcc/config/ia64/ia64-modes.def", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -20,10 +20,16 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* hpux will override this in ia64_override_options.  */\n+FLOAT_MODE (TF, 16, ieee_extended_intel_128_format);\n+\n+/* 256-bit integer mode is needed for STACK_SAVEAREA_MODE.  */\n+INT_MODE (OI, 32);\n+\n /* Add any extra modes needed to represent the condition code.\n \n    CCImode is used to mark a single predicate register instead\n    of a register pair.  This is currently only used in reg_raw_mode\n    so that flow doesn't do something stupid.  */\n \n-CC (CCI)\n+CC_MODE (CCI);"}, {"sha": "b9a4537a30141159a49548be3d5ae9b1406e043f", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -4522,8 +4522,8 @@ ia64_override_options (void)\n   init_machine_status = ia64_init_machine_status;\n \n   /* Tell the compiler which flavor of TFmode we're using.  */\n-  if (INTEL_EXTENDED_IEEE_FORMAT)\n-    REAL_MODE_FORMAT (TFmode) = &ieee_extended_intel_128_format;\n+  if (!INTEL_EXTENDED_IEEE_FORMAT)\n+    REAL_MODE_FORMAT (TFmode) = &ieee_quad_format;\n }\n \f\n static enum attr_itanium_class ia64_safe_itanium_class (rtx);"}, {"sha": "dfea2fc74be927086a49d626acaa9222c86797f2", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -249,13 +249,10 @@ init_reg_tables ()\n \t    m32r_mode_class[i] = 0;\n \t  break;\n \tcase MODE_CC:\n+\t  m32r_mode_class[i] = 1 << (int) C_MODE;\n+\t  break;\n \tdefault:\n-\t  /* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so\n-\t     we must explicitly check for them here.  */\n-\t  if (i == (int) CCmode)\n-\t    m32r_mode_class[i] = 1 << (int) C_MODE;\n-\t  else\n-\t    m32r_mode_class[i] = 0;\n+\t  m32r_mode_class[i] = 0;\n \t  break;\n \t}\n     }"}, {"sha": "3f1cb4f9941d9fded8118f570d38c861b8409935", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -2337,8 +2337,7 @@ print_operand (file, op, letter)\n       REAL_VALUE_TO_TARGET_SINGLE (r, l);\n       asm_fprintf (file, \"%I0x%lx\", l);\n     }\n-  else if (GET_CODE (op) == CONST_DOUBLE\n-\t   && (GET_MODE (op) == DFmode || GET_MODE (op) == XFmode))\n+  else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == DFmode)\n     {\n       char dstr[30];\n "}, {"sha": "b0ee6208c3742b94e0c69f08e4830ae51d5b1205", "filename": "gcc/config/m68k/m68k-modes.def", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm68k%2Fm68k-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm68k%2Fm68k-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -0,0 +1,22 @@\n+/* M68k extra machine modes. \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* 80-bit floating point (IEEE extended, in a 96-bit field) */\n+FLOAT_MODE (XF, 12, ieee_extended_motorola_format);"}, {"sha": "00fd0ea08519288d00d35f31d3e072622b0e066d", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -290,9 +290,6 @@ override_options (void)\n     flag_no_function_cse = 1;\n \n   SUBTARGET_OVERRIDE_OPTIONS;\n-\n-  /* Tell the compiler which flavor of XFmode we're using.  */\n-  REAL_MODE_FORMAT (XFmode) = &ieee_extended_motorola_format;\n }\n \f\n /* Return nonzero if FUNC is an interrupt function as specified by the"}, {"sha": "b74297124df6e95253341f403363d4ccfbaaef8d", "filename": "gcc/config/mips/mips-modes.def", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -0,0 +1,27 @@\n+/* MIPS extra machine modes. \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* MIPS has a quirky almost-IEEE format for all its\n+   floating point.  */\n+RESET_FLOAT_FORMAT (SF, mips_single_format);\n+RESET_FLOAT_FORMAT (DF, mips_double_format);\n+\n+/* Irix6 will override this via MIPS_TFMODE_FORMAT.  */\n+FLOAT_MODE (TF, 16, mips_quad_format);"}, {"sha": "71fd880ec6d02fa5e5b726a1ec32135185059351", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -4856,12 +4856,8 @@ override_options (void)\n       flag_delayed_branch = 0;\n     }\n \n-  REAL_MODE_FORMAT (SFmode) = &mips_single_format;\n-  REAL_MODE_FORMAT (DFmode) = &mips_double_format;\n #ifdef MIPS_TFMODE_FORMAT\n   REAL_MODE_FORMAT (TFmode) = &MIPS_TFMODE_FORMAT;\n-#else\n-  REAL_MODE_FORMAT (TFmode) = &mips_quad_format;\n #endif\n \n   mips_print_operand_punct['?'] = 1;"}, {"sha": "2e5fb7a39b3a010a89c822c1d3cca3bc99c3ae2e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -3029,34 +3029,6 @@ typedef struct mips_args {\n   &mips_reg_names[175][0]\t\t\t\t\t\t\\\n }\n \n-/* print-rtl.c can't use REGISTER_NAMES, since it depends on mips.c.\n-   So define this for it.  */\n-#define DEBUG_REGISTER_NAMES\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  \"$0\",   \"at\",   \"v0\",   \"v1\",   \"a0\",   \"a1\",   \"a2\",   \"a3\",\t\t\\\n-  \"t0\",   \"t1\",   \"t2\",   \"t3\",   \"t4\",   \"t5\",   \"t6\",   \"t7\",\t\t\\\n-  \"s0\",   \"s1\",   \"s2\",   \"s3\",   \"s4\",   \"s5\",   \"s6\",   \"s7\",\t\t\\\n-  \"t8\",   \"t9\",   \"k0\",   \"k1\",   \"gp\",   \"sp\",   \"$fp\",  \"ra\",\t\t\\\n-  \"$f0\",  \"$f1\",  \"$f2\",  \"$f3\",  \"$f4\",  \"$f5\",  \"$f6\",  \"$f7\",\t\\\n-  \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\\\n-  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t\\\n-  \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t\\\n-  \"hi\",   \"lo\",   \"\",     \"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\t\\\n-  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\", \"\",     \"\",     \"\",     \"\",\t\t\\\n-  \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",\\\n-  \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\",\\\n-  \"$c0r16\",\"$c0r17\",\"$c0r18\",\"$c0r19\",\"$c0r20\",\"$c0r21\",\"$c0r22\",\"$c0r23\",\\\n-  \"$c0r24\",\"$c0r25\",\"$c0r26\",\"$c0r27\",\"$c0r28\",\"$c0r29\",\"$c0r30\",\"$c0r31\",\\\n-  \"$c2r0\", \"$c2r1\", \"$c2r2\", \"$c2r3\", \"$c2r4\", \"$c2r5\", \"$c2r6\", \"$c2r7\",\\\n-  \"$c2r8\", \"$c2r9\", \"$c2r10\",\"$c2r11\",\"$c2r12\",\"$c2r13\",\"$c2r14\",\"$c2r15\",\\\n-  \"$c2r16\",\"$c2r17\",\"$c2r18\",\"$c2r19\",\"$c2r20\",\"$c2r21\",\"$c2r22\",\"$c2r23\",\\\n-  \"$c2r24\",\"$c2r25\",\"$c2r26\",\"$c2r27\",\"$c2r28\",\"$c2r29\",\"$c2r30\",\"$c2r31\",\\\n-  \"$c3r0\", \"$c3r1\", \"$c3r2\", \"$c3r3\", \"$c3r4\", \"$c3r5\", \"$c3r6\", \"$c3r7\",\\\n-  \"$c3r8\", \"$c3r9\", \"$c3r10\",\"$c3r11\",\"$c3r12\",\"$c3r13\",\"$c3r14\",\"$c3r15\",\\\n-  \"$c3r16\",\"$c3r17\",\"$c3r18\",\"$c3r19\",\"$c3r20\",\"$c3r21\",\"$c3r22\",\"$c3r23\",\\\n-  \"$c3r24\",\"$c3r25\",\"$c3r26\",\"$c3r27\",\"$c3r28\",\"$c3r29\",\"$c3r30\",\"$c3r31\"\\\n-}\n-\n /* If defined, a C initializer for an array of structures\n    containing a name and a register number.  This macro defines\n    additional names for hard registers, thus allowing the `asm'"}, {"sha": "e4ebb30565ec82c9a63860f7e8a94c639c21a418", "filename": "gcc/config/mmix/mmix-modes.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmmix%2Fmmix-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fmmix%2Fmmix-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -32,19 +32,19 @@ Boston, MA 02111-1307, USA.  */\n \n /* The CC_UNS mode is for an unsigned operands integer comparison using\n    the CMPU insn.  Result values correspond to those in CCmode.  */\n-CC (CC_UNS)\n+CC_MODE (CC_UNS);\n \n /* The CC_FP mode is for a non-equality floating-point comparison, using\n    the FCMP or FCMPE insn.  The result is (integer) -1 or 1 for\n    espectively a < b and a > b, otherwise 0.  */\n-CC (CC_FP)\n+CC_MODE (CC_FP);\n \n /* The CC_FPEQ mode is for an equality floating-point comparison, using\n    the FEQL or FEQLE insn.  The result is (integer) 1 for a == b,\n    otherwise 0 (including NaN:s).  */\n-CC (CC_FPEQ)\n+CC_MODE (CC_FPEQ);\n \n /* The CC_FUN mode is for an ordering comparison, using the FUN or FUNE\n    insn.  The result is (integer) 1 if a is unordered to b, otherwise the\n    result is 0.  */\n-CC (CC_FUN)\n+CC_MODE (CC_FUN);"}, {"sha": "a68453df1f124118255fea29bd58df90ae12339d", "filename": "gcc/config/pa/pa-modes.def", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fpa%2Fpa-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fpa%2Fpa-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -21,10 +21,8 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Add any extra modes needed to represent the condition code.\n-\n-   HPPA floating comparisons produce condition codes.  */\n-\n-CC (CCFP)\n-\n+/* TFmode: IEEE quad floating point (software).  */\n+FLOAT_MODE (TF, 16, ieee_quad_format);\n \n+/* HPPA floating comparisons produce distinct condition codes.  */\n+CC_MODE (CCFP);"}, {"sha": "da083ad24a899317ba59e253838162d11bd7748e", "filename": "gcc/config/pdp11/pdp11-modes.def", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -22,5 +22,4 @@ Boston, MA 02111-1307, USA.  */\n /* Add any extra modes needed to represent the condition code.\n    CCFPmode is used for FPU, but should we use a separate reg? */\n \n-CC (CCFP)\n-\n+CC_MODE (CCFP);"}, {"sha": "15e3f24c33630b7c8438279bd657312aade429b3", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -141,11 +141,29 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef\tFP_SAVE_INLINE\n #define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 64)\n \n-/* Always use the \"debug\" register names, they're what the assembler\n-   wants to see.  */\n-\n+/* The assembler wants the alternate register names, but without\n+   leading percent sign.  */\n #undef REGISTER_NAMES\n-#define REGISTER_NAMES DEBUG_REGISTER_NAMES\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+     \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n+     \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n+    \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\t\\\n+    \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\t\t\\\n+     \"f0\",  \"f1\",  \"f2\",  \"f3\",  \"f4\",  \"f5\",  \"f6\",  \"f7\",\t\t\\\n+     \"f8\",  \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\t\t\\\n+    \"f16\", \"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\",\t\t\\\n+    \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\", \"f30\", \"f31\",\t\t\\\n+     \"mq\",  \"lr\", \"ctr\",  \"ap\",\t\t\t\t\t\t\\\n+    \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\",\t\t\\\n+    \"xer\",\t\t\t\t\t\t\t\t\\\n+     \"v0\",  \"v1\",  \"v2\",  \"v3\",  \"v4\",  \"v5\",  \"v6\",  \"v7\",             \\\n+     \"v8\",  \"v9\", \"v10\", \"v11\", \"v12\", \"v13\", \"v14\", \"v15\",             \\\n+    \"v16\", \"v17\", \"v18\", \"v19\", \"v20\", \"v21\", \"v22\", \"v23\",             \\\n+    \"v24\", \"v25\", \"v26\", \"v27\", \"v28\", \"v29\", \"v30\", \"v31\",             \\\n+    \"vrsave\", \"vscr\",\t\t\t\t\t\t\t\\\n+    \"spe_acc\", \"spefscr\"                                                \\\n+}\n \n /* This outputs NAME to FILE.  */\n "}, {"sha": "1b6aa481feef55000e5fffaa016d89c48d2595a9", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -19,13 +19,22 @@\n    Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n    MA 02111-1307, USA.  */\n \n+/* 128-bit floating point.  ABI_V4 uses IEEE quad, AIX/Darwin\n+   adjust this in rs6000_override_options. */\n+FLOAT_MODE (TF, 16, ieee_quad_format);\n+\n+/* PSImode is used for the XER register.  The XER register\n+   is not used for anything; perhaps it should be deleted,\n+   except that that would change register numbers.  */\n+PARTIAL_INT_MODE (SI);\n+\n /* Add any extra modes needed to represent the condition code.\n \n    For the RS/6000, we need separate modes when unsigned (logical) comparisons\n    are being done and we need a separate mode for floating-point.  We also\n    use a mode for the case when we are comparing the results of two\n    comparisons, as then only the EQ bit is valid in the register.  */\n \n-CC (CCUNS)\n-CC (CCFP)\n-CC (CCEQ)\n+CC_MODE (CCUNS);\n+CC_MODE (CCFP);\n+CC_MODE (CCEQ);"}, {"sha": "3aa2de340f5caacfc141b6fef1dd13c1fd19ac26", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -2550,31 +2550,6 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   &rs6000_reg_names[112][0],\t/* spefscr */\t\t\t\t\\\n }\n \n-/* print-rtl can't handle the above REGISTER_NAMES, so define the\n-   following for it.  Switch to use the alternate names since\n-   they are more mnemonic.  */\n-\n-#define DEBUG_REGISTER_NAMES\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-     \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n-     \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n-    \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\t\\\n-    \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\t\t\\\n-     \"f0\",  \"f1\",  \"f2\",  \"f3\",  \"f4\",  \"f5\",  \"f6\",  \"f7\",\t\t\\\n-     \"f8\",  \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\t\t\\\n-    \"f16\", \"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\",\t\t\\\n-    \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\", \"f30\", \"f31\",\t\t\\\n-     \"mq\",  \"lr\", \"ctr\",  \"ap\",\t\t\t\t\t\t\\\n-    \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\",\t\t\\\n-    \"xer\",\t\t\t\t\t\t\t\t\\\n-     \"v0\",  \"v1\",  \"v2\",  \"v3\",  \"v4\",  \"v5\",  \"v6\",  \"v7\",             \\\n-     \"v8\",  \"v9\", \"v10\", \"v11\", \"v12\", \"v13\", \"v14\", \"v15\",             \\\n-    \"v16\", \"v17\", \"v18\", \"v19\", \"v20\", \"v21\", \"v22\", \"v23\",             \\\n-    \"v24\", \"v25\", \"v26\", \"v27\", \"v28\", \"v29\", \"v30\", \"v31\",             \\\n-    \"vrsave\", \"vscr\",\t\t\t\t\t\t\t\\\n-    \"spe_acc\", \"spefscr\"                                                \\\n-}\n-\n /* Table of additional register names to use in user input.  */\n \n #define ADDITIONAL_REGISTER_NAMES \\"}, {"sha": "08759558871a568d8c4133eb1e0a179e7b284577", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -20,20 +20,23 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n+/* 256-bit integer mode is needed for STACK_SAVEAREA_MODE.  */\n+INT_MODE (OI, 32);\n+\n /* Add any extra modes needed to represent the condition code.  */\n \n-CC (CCZ)\n-CC (CCA)\n-CC (CCAP)\n-CC (CCAN)\n-CC (CCL)\n-CC (CCL1)\n-CC (CCL2)\n-CC (CCU)\n-CC (CCUR)\n-CC (CCS)\n-CC (CCSR)\n-CC (CCT)\n-CC (CCT1)\n-CC (CCT2)\n-CC (CCT3)\n+CC_MODE (CCZ);\n+CC_MODE (CCA);\n+CC_MODE (CCAP);\n+CC_MODE (CCAN);\n+CC_MODE (CCL);\n+CC_MODE (CCL1);\n+CC_MODE (CCL2);\n+CC_MODE (CCU);\n+CC_MODE (CCUR);\n+CC_MODE (CCS);\n+CC_MODE (CCSR);\n+CC_MODE (CCT);\n+CC_MODE (CCT1);\n+CC_MODE (CCT2);\n+CC_MODE (CCT3);"}, {"sha": "3906b4354c2ba2f1c4570806579702c335442185", "filename": "gcc/config/sh/sh-modes.def", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsh%2Fsh-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsh%2Fsh-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -0,0 +1,23 @@\n+/* Alpha extra machine modes. \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* The SH uses a partial integer mode to represent the FPSCR register.  */\n+PARTIAL_INT_MODE (SI);\n+"}, {"sha": "4ccff4b35310be3f0317d76bec1af01b6bbe3c75", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -743,8 +743,6 @@ extern char sh_register_names[][MAX_REGISTER_NAME_LENGTH + 1];\n   \"rap\"\t\t\t\t\t\t\t\t\t\\\n }\n \n-#define DEBUG_REGISTER_NAMES SH_REGISTER_NAMES_INITIALIZER\n-\n #define REGNAMES_ARR_INDEX_1(index) \\\n   (sh_register_names[index])\n #define REGNAMES_ARR_INDEX_2(index) \\"}, {"sha": "ea2a99d5ae1397f63251e33f92934cd0f3112855", "filename": "gcc/config/sparc/sparc-modes.def", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -21,6 +21,9 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* 128-bit floating point */\n+FLOAT_MODE (TF, 16, ieee_quad_format);\n+\n /* Add any extra modes needed to represent the condition code.\n \n    On the SPARC, we have a \"no-overflow\" mode which is used when an add or\n@@ -34,9 +37,8 @@ Boston, MA 02111-1307, USA.  */\n \n    CCXmode and CCX_NOOVmode are only used by v9.  */\n \n-CC (CCX)\n-CC (CC_NOOV)\n-CC (CCX_NOOV)\n-CC (CCFP)\n-CC (CCFPE)\n-\n+CC_MODE (CCX);\n+CC_MODE (CC_NOOV);\n+CC_MODE (CCX_NOOV);\n+CC_MODE (CCFP);\n+CC_MODE (CCFPE);"}, {"sha": "1332817e0fa92ae33b3e140dd139559991e819e3", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -3954,16 +3954,13 @@ sparc_init_modes (void)\n \t    sparc_mode_class[i] = 0;\n \t  break;\n \tcase MODE_CC:\n-\tdefault:\n-\t  /* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so\n-\t     we must explicitly check for them here.  */\n \t  if (i == (int) CCFPmode || i == (int) CCFPEmode)\n \t    sparc_mode_class[i] = 1 << (int) CCFP_MODE;\n-\t  else if (i == (int) CCmode || i == (int) CC_NOOVmode\n-\t\t   || i == (int) CCXmode || i == (int) CCX_NOOVmode)\n-\t    sparc_mode_class[i] = 1 << (int) CC_MODE;\n \t  else\n-\t    sparc_mode_class[i] = 0;\n+\t    sparc_mode_class[i] = 1 << (int) CC_MODE;\n+\t  break;\n+\tdefault:\n+\t  sparc_mode_class[i] = 0;\n \t  break;\n \t}\n     }"}, {"sha": "5f137f9aca9881c42c7c5c999fdf64f5ad63d591", "filename": "gcc/config/vax/vax-modes.def", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fvax%2Fvax-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fvax%2Fvax-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-modes.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -0,0 +1,23 @@\n+/* VAX extra machine modes. \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* We just need to reset the floating point formats.  */\n+RESET_FLOAT_FORMAT (SF, vax_f_format);\n+RESET_FLOAT_FORMAT (DF, vax_d_format);"}, {"sha": "dd22e33bbf775468196eb26afa5ad8e2adc6aef3", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -85,9 +85,8 @@ void\n override_options (void)\n {\n   /* We're VAX floating point, not IEEE floating point.  */\n-  memset (real_format_for_mode, 0, sizeof real_format_for_mode);\n-  REAL_MODE_FORMAT (SFmode) = &vax_f_format;\n-  REAL_MODE_FORMAT (DFmode) = (TARGET_G_FLOAT ? &vax_g_format : &vax_d_format);\n+  if (TARGET_G_FLOAT)\n+    REAL_MODE_FORMAT (DFmode) = &vax_g_format;\n }\n \n /* Generate the assembly code for function entry.  FILE is a stdio"}, {"sha": "3d01dd0894a29ffcf600ce3c8c43ac6e369d3a10", "filename": "gcc/configure", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -5273,10 +5273,6 @@ if test -n \"$extra_modes\" && test -f $srcdir/config/$extra_modes; then\n   \n   cat >> confdefs.h <<EOF\n #define EXTRA_MODES_FILE \"config/$extra_modes\"\n-EOF\n-\n-  cat >> confdefs.h <<\\EOF\n-#define EXTRA_CC_MODES 1\n EOF\n \n fi\n@@ -5386,7 +5382,7 @@ if test -f ../intl/config.intl; then\n   . ../intl/config.intl\n fi\n echo $ac_n \"checking whether NLS is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:5390: checking whether NLS is requested\" >&5\n+echo \"configure:5386: checking whether NLS is requested\" >&5\n if test x\"$USE_NLS\" != xyes; then\n   echo \"$ac_t\"\"no\" 1>&6\n else\n@@ -5397,7 +5393,7 @@ EOF\n \n \n   echo $ac_n \"checking for catalogs to be installed\"\"... $ac_c\" 1>&6\n-echo \"configure:5401: checking for catalogs to be installed\" >&5\n+echo \"configure:5397: checking for catalogs to be installed\" >&5\n   # Look for .po and .gmo files in the source directory.\n   CATALOGS=  \n   XLINGUAS=\n@@ -5447,7 +5443,7 @@ fi\n case $host_os in\n \twin32 | pe | cygwin* | mingw32* | uwin*)\n echo $ac_n \"checking whether windows registry support is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:5451: checking whether windows registry support is requested\" >&5\n+echo \"configure:5447: checking whether windows registry support is requested\" >&5\n if test \"x$enable_win32_registry\" != xno; then\n   cat >> confdefs.h <<\\EOF\n #define ENABLE_WIN32_REGISTRY 1\n@@ -5456,14 +5452,14 @@ EOF\n   echo \"$ac_t\"\"yes\" 1>&6\n   \n echo $ac_n \"checking for library containing RegOpenKeyExA\"\"... $ac_c\" 1>&6\n-echo \"configure:5460: checking for library containing RegOpenKeyExA\" >&5\n+echo \"configure:5456: checking for library containing RegOpenKeyExA\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_search_RegOpenKeyExA'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_func_search_save_LIBS=\"$LIBS\"\n ac_cv_search_RegOpenKeyExA=\"no\"\n cat > conftest.$ac_ext <<EOF\n-#line 5467 \"configure\"\n+#line 5463 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -5474,7 +5470,7 @@ int main() {\n RegOpenKeyExA()\n ; return 0; }\n EOF\n-if { (eval echo configure:5478: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:5474: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_search_RegOpenKeyExA=\"none required\"\n else\n@@ -5485,7 +5481,7 @@ rm -f conftest*\n test \"$ac_cv_search_RegOpenKeyExA\" = \"no\" && for i in advapi32; do\n LIBS=\"-l$i  $ac_func_search_save_LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 5489 \"configure\"\n+#line 5485 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -5496,7 +5492,7 @@ int main() {\n RegOpenKeyExA()\n ; return 0; }\n EOF\n-if { (eval echo configure:5500: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:5496: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_search_RegOpenKeyExA=\"-l$i\"\n break\n@@ -5538,7 +5534,7 @@ esac\n \n if test \"x$enable_win32_registry\" != xno; then\n   echo $ac_n \"checking registry key on windows hosts\"\"... $ac_c\" 1>&6\n-echo \"configure:5542: checking registry key on windows hosts\" >&5\n+echo \"configure:5538: checking registry key on windows hosts\" >&5\n   cat >> confdefs.h <<EOF\n #define WIN32_REGISTRY_KEY \"$gcc_cv_win32_registry_key\"\n EOF\n@@ -5802,7 +5798,7 @@ esac\n # build->target assembler and hope that it will have the same features\n # as the host->target assembler we'll be using.\n echo $ac_n \"checking what assembler to use\"\"... $ac_c\" 1>&6\n-echo \"configure:5806: checking what assembler to use\" >&5\n+echo \"configure:5802: checking what assembler to use\" >&5\n in_tree_gas=no\n gcc_cv_as=\n gcc_cv_gas_major_version=\n@@ -5926,7 +5922,7 @@ esac\n # build->target linker and hope that it will have the same features\n # as the host->target linker we'll be using.\n echo $ac_n \"checking what linker to use\"\"... $ac_c\" 1>&6\n-echo \"configure:5930: checking what linker to use\" >&5\n+echo \"configure:5926: checking what linker to use\" >&5\n in_tree_ld=no\n gcc_cv_ld=\n gcc_cv_gld_major_version=\n@@ -6034,7 +6030,7 @@ esac\n # Figure out what nm we will be using.\n gcc_cv_binutils_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/binutils\n echo $ac_n \"checking what nm to use\"\"... $ac_c\" 1>&6\n-echo \"configure:6038: checking what nm to use\" >&5\n+echo \"configure:6034: checking what nm to use\" >&5\n in_tree_nm=no\n if test -x nm$host_exeext; then\n \tgcc_cv_nm=./nm$host_exeext\n@@ -6057,7 +6053,7 @@ esac\n \n # Figure out what objdump we will be using.\n echo $ac_n \"checking what objdump to use\"\"... $ac_c\" 1>&6\n-echo \"configure:6061: checking what objdump to use\" >&5\n+echo \"configure:6057: checking what objdump to use\" >&5\n in_tree_objdump=no\n if test -x objdump$host_exeext; then\n \tgcc_cv_objdump=./objdump$host_exeext\n@@ -6082,7 +6078,7 @@ esac\n \n # Figure out what assembler alignment features are present.\n echo $ac_n \"checking assembler for .balign and .p2align\"\"... $ac_c\" 1>&6\n-echo \"configure:6086: checking assembler for .balign and .p2align\" >&5\n+echo \"configure:6082: checking assembler for .balign and .p2align\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_balign_and_p2align'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6094,7 +6090,7 @@ fi\n   elif test x$gcc_cv_as != x; then\n     echo '.balign 4\n .p2align 2' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6098: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6094: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_balign_and_p2align=yes\n     else\n@@ -6114,7 +6110,7 @@ EOF\n fi\n \n echo $ac_n \"checking assembler for .p2align with maximum skip\"\"... $ac_c\" 1>&6\n-echo \"configure:6118: checking assembler for .p2align with maximum skip\" >&5\n+echo \"configure:6114: checking assembler for .p2align with maximum skip\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_max_skip_p2align'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6125,7 +6121,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo '.p2align 4,,7' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6129: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6125: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_max_skip_p2align=yes\n     else\n@@ -6145,7 +6141,7 @@ EOF\n fi\n \n echo $ac_n \"checking assembler for working .subsection -1\"\"... $ac_c\" 1>&6\n-echo \"configure:6149: checking assembler for working .subsection -1\" >&5\n+echo \"configure:6145: checking assembler for working .subsection -1\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_subsection_m1'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6160,7 +6156,7 @@ fi\n .subsection -1\n conftest_label2: .word 0\n .previous' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6164: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6160: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tif test x$gcc_cv_nm != x; then\n     $gcc_cv_nm conftest.o | grep conftest_label1 > conftest.nm1\n@@ -6188,7 +6184,7 @@ EOF\n fi\n \n echo $ac_n \"checking assembler for .weak\"\"... $ac_c\" 1>&6\n-echo \"configure:6192: checking assembler for .weak\" >&5\n+echo \"configure:6188: checking assembler for .weak\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_weak'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6199,7 +6195,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo '\t.weak foobar' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6203: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6199: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_weak=yes\n     else\n@@ -6226,7 +6222,7 @@ fi\n # to be safe.\n # The gcc_GAS_CHECK_FEATURE call just sets a cache variable.\n echo $ac_n \"checking assembler for .hidden\"\"... $ac_c\" 1>&6\n-echo \"configure:6230: checking assembler for .hidden\" >&5\n+echo \"configure:6226: checking assembler for .hidden\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6239,7 +6235,7 @@ fi\n   elif test x$gcc_cv_as != x; then\n     echo '\t.hidden foobar\n foobar:' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6243: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6239: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_hidden=yes\n     else\n@@ -6254,7 +6250,7 @@ echo \"$ac_t\"\"$gcc_cv_as_hidden\" 1>&6\n \n \n echo $ac_n \"checking linker for .hidden support\"\"... $ac_c\" 1>&6\n-echo \"configure:6258: checking linker for .hidden support\" >&5\n+echo \"configure:6254: checking linker for .hidden support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_ld_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6317,7 +6313,7 @@ fi\n \n # Check if we have .[us]leb128, and support symbol arithmetic with it.\n echo $ac_n \"checking assembler for .sleb128 and .uleb128\"\"... $ac_c\" 1>&6\n-echo \"configure:6321: checking assembler for .sleb128 and .uleb128\" >&5\n+echo \"configure:6317: checking assembler for .sleb128 and .uleb128\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_leb128'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6334,7 +6330,7 @@ L1:\n \t.uleb128 1280\n \t.sleb128 -1010\n L2:' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6338: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6334: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \t# GAS versions before 2.11 do not support uleb128,\n   # despite appearing to.\n@@ -6370,7 +6366,7 @@ fi\n # GAS versions up to and including 2.11.0 may mis-optimize\n # .eh_frame data.\n echo $ac_n \"checking assembler for eh_frame optimization\"\"... $ac_c\" 1>&6\n-echo \"configure:6374: checking assembler for eh_frame optimization\" >&5\n+echo \"configure:6370: checking assembler for eh_frame optimization\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_eh_frame'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6413,7 +6409,7 @@ __FRAME_BEGIN__:\n \t.byte\t0x4\n \t.4byte\t.L1-.LFB1\n .LEFDE1:' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6417: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6413: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \t  cat > conftest.lit <<EOF\n  0000 10000000 00000000 017a0001 781a0004  .........z..x...\n@@ -6434,7 +6430,7 @@ EOF\n     || cmp conftest.big conftest.got > /dev/null 2>&1; }\n   then\n     gcc_cv_as_eh_frame=yes\n-  elif { ac_try='$gcc_cv_as -o conftest.o --traditional-format /dev/null'; { (eval echo configure:6438: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }; then\n+  elif { ac_try='$gcc_cv_as -o conftest.o --traditional-format /dev/null'; { (eval echo configure:6434: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }; then\n     gcc_cv_as_eh_frame=buggy\n   else\n     # Uh oh, what do we do now?\n@@ -6459,7 +6455,7 @@ EOF\n fi\n \n echo $ac_n \"checking assembler for section merging support\"\"... $ac_c\" 1>&6\n-echo \"configure:6463: checking assembler for section merging support\" >&5\n+echo \"configure:6459: checking assembler for section merging support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_shf_merge'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6471,7 +6467,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo '.section .rodata.str, \"aMS\", @progbits, 1' > conftest.s\n-    if { ac_try='$gcc_cv_as --fatal-warnings -o conftest.o conftest.s >&5'; { (eval echo configure:6475: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as --fatal-warnings -o conftest.o conftest.s >&5'; { (eval echo configure:6471: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_shf_merge=yes\n     else\n@@ -6709,7 +6705,7 @@ if test -z \"$tls_first_major\"; then\n   : # If we don't have a check, assume no support.\n else\n   echo $ac_n \"checking assembler for thread-local storage support\"\"... $ac_c\" 1>&6\n-echo \"configure:6713: checking assembler for thread-local storage support\" >&5\n+echo \"configure:6709: checking assembler for thread-local storage support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_tls'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6720,7 +6716,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo \"$conftest_s\" > conftest.s\n-    if { ac_try='$gcc_cv_as $tls_as_opt --fatal-warnings -o conftest.o conftest.s >&5'; { (eval echo configure:6724: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as $tls_as_opt --fatal-warnings -o conftest.o conftest.s >&5'; { (eval echo configure:6720: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_tls=yes\n     else\n@@ -6746,7 +6742,7 @@ case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)\n     echo $ac_n \"checking assembler for explicit relocation support\"\"... $ac_c\" 1>&6\n-echo \"configure:6750: checking assembler for explicit relocation support\" >&5\n+echo \"configure:6746: checking assembler for explicit relocation support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_alpha_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6769,7 +6765,7 @@ fi\n \tldah\t$1, d($29)\t!gprelhigh\n \tlda\t$1, d($1)\t!gprellow\n \tlda\t$29, 0($29)\t!gpdisp!3' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6773: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6769: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_alpha_explicit_relocs=yes\n     else\n@@ -6791,14 +6787,14 @@ fi\n \n   sparc*-*-*)\n     echo $ac_n \"checking assembler for .register\"\"... $ac_c\" 1>&6\n-echo \"configure:6795: checking assembler for .register\" >&5\n+echo \"configure:6791: checking assembler for .register\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_register_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   gcc_cv_as_sparc_register_op=no\n   if test x$gcc_cv_as != x; then\n     echo '.register %g2, #scratch' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6802: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6798: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_sparc_register_op=yes\n     else\n@@ -6818,14 +6814,14 @@ EOF\n fi\n \n     echo $ac_n \"checking assembler for -relax option\"\"... $ac_c\" 1>&6\n-echo \"configure:6822: checking assembler for -relax option\" >&5\n+echo \"configure:6818: checking assembler for -relax option\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_relax'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   gcc_cv_as_sparc_relax=no\n   if test x$gcc_cv_as != x; then\n     echo '.text' > conftest.s\n-    if { ac_try='$gcc_cv_as -relax -o conftest.o conftest.s >&5'; { (eval echo configure:6829: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as -relax -o conftest.o conftest.s >&5'; { (eval echo configure:6825: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_sparc_relax=yes\n     else\n@@ -6845,7 +6841,7 @@ EOF\n fi\n \n     echo $ac_n \"checking assembler for unaligned pcrel relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:6849: checking assembler for unaligned pcrel relocs\" >&5\n+echo \"configure:6845: checking assembler for unaligned pcrel relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6858,7 +6854,7 @@ foo:\n .align 4\n .byte 0\n .uaword %r_disp32(foo)' > conftest.s\n-    if { ac_try='$gcc_cv_as -K PIC -o conftest.o conftest.s >&5'; { (eval echo configure:6862: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as -K PIC -o conftest.o conftest.s >&5'; { (eval echo configure:6858: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tif test x$gcc_cv_ld != x \\\n        && $gcc_cv_ld -o conftest conftest.o -G > /dev/null 2>&1; then\n@@ -6881,7 +6877,7 @@ EOF\n \n \n       echo $ac_n \"checking assembler for unaligned pcrel relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:6885: checking assembler for unaligned pcrel relocs against hidden symbols\" >&5\n+echo \"configure:6881: checking assembler for unaligned pcrel relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6896,7 +6892,7 @@ else\n .hidden foo\n foo:\n .skip 4' > conftest.s\n-    if { ac_try='$gcc_cv_as -K PIC -o conftest.o conftest.s >&5'; { (eval echo configure:6900: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as -K PIC -o conftest.o conftest.s >&5'; { (eval echo configure:6896: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tif test x$gcc_cv_ld != x && test x$gcc_cv_objdump != x \\\n \t && $gcc_cv_ld -o conftest conftest.o -G > /dev/null 2>&1 \\\n@@ -6929,7 +6925,7 @@ fi\n fi # unaligned pcrel relocs\n \n     echo $ac_n \"checking assembler for offsetable %lo()\"\"... $ac_c\" 1>&6\n-echo \"configure:6933: checking assembler for offsetable %lo()\" >&5\n+echo \"configure:6929: checking assembler for offsetable %lo()\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6938,7 +6934,7 @@ else\n     echo '.text\n \tor %g1, %lo(ab) + 12, %g1\n \tor %g1, %lo(ab + 12), %g1' > conftest.s\n-    if { ac_try='$gcc_cv_as -xarch=v9 -o conftest.o conftest.s >&5'; { (eval echo configure:6942: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as -xarch=v9 -o conftest.o conftest.s >&5'; { (eval echo configure:6938: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tif test x$gcc_cv_objdump != x \\\n        && %gcc_cv_objdump -s -j .text conftest.o 2> /dev/null \\\n@@ -6964,7 +6960,7 @@ fi\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler for filds and fists mnemonics\"\"... $ac_c\" 1>&6\n-echo \"configure:6968: checking assembler for filds and fists mnemonics\" >&5\n+echo \"configure:6964: checking assembler for filds and fists mnemonics\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_ix86_filds_fists'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -6975,7 +6971,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo 'filds mem; fists mem' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6979: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:6975: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_ix86_filds_fists=yes\n     else\n@@ -6995,14 +6991,14 @@ EOF\n fi\n \n     echo $ac_n \"checking assembler for cmov syntax\"\"... $ac_c\" 1>&6\n-echo \"configure:6999: checking assembler for cmov syntax\" >&5\n+echo \"configure:6995: checking assembler for cmov syntax\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_ix86_cmov_sun_syntax'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   gcc_cv_as_ix86_cmov_sun_syntax=no\n   if test x$gcc_cv_as != x; then\n     echo 'cmovl.l %edx, %eax' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7006: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7002: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_ix86_cmov_sun_syntax=yes\n     else\n@@ -7024,7 +7020,7 @@ fi\n     # This one is used unconditionally by i386.[ch]; it is to be defined\n     # to 1 if the feature is present, 0 otherwise.\n     echo $ac_n \"checking assembler for GOTOFF in data\"\"... $ac_c\" 1>&6\n-echo \"configure:7028: checking assembler for GOTOFF in data\" >&5\n+echo \"configure:7024: checking assembler for GOTOFF in data\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_ix86_gotoff_in_data'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7039,7 +7035,7 @@ fi\n \tnop\n \t.data\n \t.long .L0@GOTOFF' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7043: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7039: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_ix86_gotoff_in_data=yes\n     else\n@@ -7060,7 +7056,7 @@ EOF\n \n   ia64*-*-*)\n     echo $ac_n \"checking assembler for ltoffx and ldxmov relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:7064: checking assembler for ltoffx and ldxmov relocs\" >&5\n+echo \"configure:7060: checking assembler for ltoffx and ldxmov relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_ia64_ltoffx_ldxmov_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7074,7 +7070,7 @@ fi\n \taddl r15 = @ltoffx(x#), gp\n \t;;\n \tld8.mov r16 = [r15], x#' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7078: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7074: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_ia64_ltoffx_ldxmov_relocs=yes\n     else\n@@ -7104,7 +7100,7 @@ fi\n \tmfcr 3,128\"\n \n     echo $ac_n \"checking assembler for mfcr field support\"\"... $ac_c\" 1>&6\n-echo \"configure:7108: checking assembler for mfcr field support\" >&5\n+echo \"configure:7104: checking assembler for mfcr field support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_powerpc_mfcrf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7115,7 +7111,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo \"$conftest_s\" > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7119: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7115: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_powerpc_mfcrf=yes\n     else\n@@ -7137,7 +7133,7 @@ fi\n \n   mips*-*-*)\n     echo $ac_n \"checking assembler for explicit relocation support\"\"... $ac_c\" 1>&6\n-echo \"configure:7141: checking assembler for explicit relocation support\" >&5\n+echo \"configure:7137: checking assembler for explicit relocation support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_mips_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7148,7 +7144,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo '\tlw $4,%gp_rel(foo)($4)' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7152: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7148: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_mips_explicit_relocs=yes\n     else\n@@ -7194,7 +7190,7 @@ if test x\"$insn\" != x; then\n \t.loc 1 3 0\n \t$insn\"\n  echo $ac_n \"checking assembler for dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:7198: checking assembler for dwarf2 debug_line support\" >&5\n+echo \"configure:7194: checking assembler for dwarf2 debug_line support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_dwarf2_debug_line'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7206,7 +7202,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo \"$conftest_s\" > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7210: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7206: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \t# ??? This fails with non-gnu grep.  Maybe use objdump?\n    if grep debug_line conftest.o > /dev/null 2>&1; then\n@@ -7228,15 +7224,15 @@ echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n # by DW_AT_decl_file.  Approximate this test by testing if\n # the assembler bitches if the same index is assigned twice.\n  echo $ac_n \"checking assembler for buggy dwarf2 .file directive\"\"... $ac_c\" 1>&6\n-echo \"configure:7232: checking assembler for buggy dwarf2 .file directive\" >&5\n+echo \"configure:7228: checking assembler for buggy dwarf2 .file directive\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_dwarf2_file_buggy'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   gcc_cv_as_dwarf2_file_buggy=no\n   if test x$gcc_cv_as != x; then\n     echo '\t.file 1 \"foo.s\"\n \t.file 1 \"bar.s\"' > conftest.s\n-    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7240: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'; { (eval echo configure:7236: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_dwarf2_file_buggy=yes\n     else\n@@ -7259,7 +7255,7 @@ EOF\n  fi\n \n  echo $ac_n \"checking assembler for --gdwarf2 option\"\"... $ac_c\" 1>&6\n-echo \"configure:7263: checking assembler for --gdwarf2 option\" >&5\n+echo \"configure:7259: checking assembler for --gdwarf2 option\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_gdwarf2_flag'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7271,7 +7267,7 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo \"$insn\" > conftest.s\n-    if { ac_try='$gcc_cv_as --gdwarf2 -o conftest.o conftest.s >&5'; { (eval echo configure:7275: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as --gdwarf2 -o conftest.o conftest.s >&5'; { (eval echo configure:7271: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \tgcc_cv_as_gdwarf2_flag=yes\n     else\n@@ -7291,7 +7287,7 @@ EOF\n fi\n \n  echo $ac_n \"checking assembler for --gstabs option\"\"... $ac_c\" 1>&6\n-echo \"configure:7295: checking assembler for --gstabs option\" >&5\n+echo \"configure:7291: checking assembler for --gstabs option\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_gstabs_flag'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7303,12 +7299,12 @@ else\n fi\n   elif test x$gcc_cv_as != x; then\n     echo \"$insn\" > conftest.s\n-    if { ac_try='$gcc_cv_as --gstabs -o conftest.o conftest.s >&5'; { (eval echo configure:7307: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+    if { ac_try='$gcc_cv_as --gstabs -o conftest.o conftest.s >&5'; { (eval echo configure:7303: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n     then\n \t# The native Solaris 9/Intel assembler doesn't understand --gstabs\n    # and warns about it, but still exits successfully.  So check for\n    # this.\n-   if { ac_try='$gcc_cv_as --gstabs -o conftest.o conftest.s 2>&1 | grep -i warning > /dev/null'; { (eval echo configure:7312: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n+   if { ac_try='$gcc_cv_as --gstabs -o conftest.o conftest.s 2>&1 | grep -i warning > /dev/null'; { (eval echo configure:7308: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; }\n    then :\n    else gcc_cv_as_gstabs_flag=yes\n    fi\n@@ -7330,7 +7326,7 @@ fi\n fi\n \n echo $ac_n \"checking linker read-only and read-write section mixing\"\"... $ac_c\" 1>&6\n-echo \"configure:7334: checking linker read-only and read-write section mixing\" >&5\n+echo \"configure:7330: checking linker read-only and read-write section mixing\" >&5\n gcc_cv_ld_ro_rw_mix=unknown\n if test $in_tree_ld = yes ; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 10 -o \"$gcc_cv_gld_major_version\" -gt 2 \\\n@@ -7369,7 +7365,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_ld_ro_rw_mix\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:7373: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:7369: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test $in_tree_ld = yes ; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 \\\n@@ -7391,7 +7387,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_ld_eh_frame_hdr\" 1>&6\n \n echo $ac_n \"checking linker position independent executable support\"\"... $ac_c\" 1>&6\n-echo \"configure:7395: checking linker position independent executable support\" >&5\n+echo \"configure:7391: checking linker position independent executable support\" >&5\n gcc_cv_ld_pie=no\n if test $in_tree_ld = yes ; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 15 -o \"$gcc_cv_gld_major_version\" -gt 2 \\\n@@ -7416,7 +7412,7 @@ echo \"$ac_t\"\"$gcc_cv_ld_pie\" 1>&6\n case \"$target\" in\n   mips*-*-*)\n     echo $ac_n \"checking whether libgloss uses STARTUP directives consistently\"\"... $ac_c\" 1>&6\n-echo \"configure:7420: checking whether libgloss uses STARTUP directives consistently\" >&5\n+echo \"configure:7416: checking whether libgloss uses STARTUP directives consistently\" >&5\n     gcc_cv_mips_libgloss_startup=no\n     gcc_cv_libgloss_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/libgloss\n     if test \"x$exec_prefix\" = xNONE; then\n@@ -7618,7 +7614,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:7622: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:7618: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "3da2200a194da0ee4fd07898dbdd712c2e10d340", "filename": "gcc/configure.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -1097,9 +1097,6 @@ if test -n \"$extra_modes\" && test -f $srcdir/config/$extra_modes; then\n   AC_DEFINE_UNQUOTED(EXTRA_MODES_FILE, \"config/$extra_modes\",\n   [Define to the name of a file containing a list of extra machine modes\n    for this architecture.])\n-  AC_DEFINE(EXTRA_CC_MODES, 1,\n-  [Define if the target architecture needs extra machine modes to represent\n-   the results of comparisons.])\n fi\n \n # auto-host.h is the file containing items generated by autoconf and is"}, {"sha": "0070c6d7586edee0e902e11a73b99107290f1cbe", "filename": "gcc/defaults.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -683,4 +683,10 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define STACK_POINTER_OFFSET    0\n #endif\n \n+/* How to print out a register name.  */\n+#ifndef PRINT_REG\n+#define PRINT_REG(RTX, CODE, FILE) \\\n+  fprintf ((FILE), \"%s\", reg_names[REGNO (RTX)])\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "2a98681987005bb057b9ae2b88b9e443883b90cc", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -5052,31 +5052,6 @@ that looks at an attribute (@pxref{Insn Attributes}) named, for example,\n two places, the @file{md} file and in @code{NOTICE_UPDATE_CC}.\n @end defmac\n \n-@defmac EXTRA_CC_MODES\n-Condition codes are represented in registers by machine modes of class\n-@code{MODE_CC}.  By default, there is just one mode, @code{CCmode}, with\n-this class.  If you need more such modes, create a file named\n-@file{@var{machine}-modes.def} in your @file{config/@var{machine}}\n-directory (@pxref{Back End, , Anatomy of a Target Back End}), containing\n-a list of these modes.  Each entry in the list should be a call to the\n-macro @code{CC}.  This macro takes one argument, which is the name of\n-the mode: it should begin with @samp{CC}.  Do not put quotation marks\n-around the name, or include the trailing @samp{mode}; these are\n-automatically added.  There should not be anything else in the file\n-except comments.\n-\n-A sample @file{@var{machine}-modes.def} file might look like this:\n-\n-@smallexample\n-CC (CC_NOOV)   /* @r{Comparison only valid if there was no overflow.} */\n-CC (CCFP)      /* @r{Floating point comparison that cannot trap.} */\n-CC (CCFPE)     /* @r{Floating point comparison that may trap.} */\n-@end smallexample\n-\n-When you create this file, the macro @code{EXTRA_CC_MODES} is\n-automatically defined by @command{configure}, with value @samp{1}.\n-@end defmac\n-\n @defmac SELECT_CC_MODE (@var{op}, @var{x}, @var{y})\n Returns a mode from class @code{MODE_CC} to be used when comparison\n operation code @var{op} is applied to rtx @var{x} and @var{y}.  For\n@@ -5093,7 +5068,8 @@ definition)\n       ? CC_NOOVmode : CCmode))\n @end smallexample\n \n-You need not define this macro if @code{EXTRA_CC_MODES} is not defined.\n+You should define this macro if and only if you define extra CC modes\n+in @file{@var{machine}-modes.def}.\n @end defmac\n \n @defmac CANONICALIZE_COMPARISON (@var{code}, @var{op0}, @var{op1})"}, {"sha": "5200af5aaf65ec0466b203b53dd8e552f931dbb4", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -597,12 +597,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define ASM_COMMENT_START \";#\"\n #endif\n \n-/* How to print out a register name.  */\n-#ifndef PRINT_REG\n-#define PRINT_REG(RTX, CODE, FILE) \\\n-  fprintf ((FILE), \"%s\", reg_names[REGNO (RTX)])\n-#endif\n-\n /* Define a macro which returns nonzero for any tagged type which is\n    used (directly or indirectly) in the specification of either some\n    function's return type or some formal parameter of some function."}, {"sha": "f9d4829001534adea63d26029c15a436026cb93d", "filename": "gcc/genmodes.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -59,6 +59,7 @@ struct mode_data\n   unsigned int bytesize;\t/* storage size in addressable units */\n   unsigned int ncomponents;\t/* number of subunits */\n   unsigned int alignment;\t/* mode alignment */\n+  const char *format;\t\t/* floating point format - MODE_FLOAT only */\n \n   struct mode_data *component;\t/* mode of components */\n   struct mode_data *wider;\t/* next wider mode */\n@@ -74,7 +75,7 @@ static struct mode_data *void_mode;\n static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1, -1, -1, -1,\n-  0, 0,\n+  0, 0, 0,\n   \"<unknown>\", 0\n };\n \n@@ -180,12 +181,14 @@ validate_mode (struct mode_data *m,\n \t       enum requirement r_bitsize,\n \t       enum requirement r_bytesize,\n \t       enum requirement r_component,\n-\t       enum requirement r_ncomponents)\n+\t       enum requirement r_ncomponents,\n+\t       enum requirement r_format)\n {\n   validate_field (m, bitsize);\n   validate_field (m, bytesize);\n   validate_field (m, component);\n   validate_field (m, ncomponents);\n+  validate_field (m, format);\n }\n #undef validate_field\n #undef validate_field_\n@@ -215,7 +218,7 @@ complete_mode (struct mode_data *m)\n       if (!strcmp (m->name, \"VOID\"))\n \tvoid_mode = m;\n \n-      validate_mode (m, UNSET, UNSET, UNSET, UNSET);\n+      validate_mode (m, UNSET, UNSET, UNSET, UNSET, UNSET);\n \n       m->bitsize = 0;\n       m->bytesize = 0;\n@@ -226,7 +229,7 @@ complete_mode (struct mode_data *m)\n     case MODE_CC:\n       /* Again, nothing more need be said.  For historical reasons,\n \t the size of a CC mode is four units.  */\n-      validate_mode (m, UNSET, UNSET, UNSET, UNSET);\n+      validate_mode (m, UNSET, UNSET, UNSET, UNSET, UNSET);\n \n       m->bytesize = 4;\n       m->ncomponents = 0;\n@@ -236,8 +239,10 @@ complete_mode (struct mode_data *m)\n     case MODE_INT:\n     case MODE_FLOAT:\n       /* A scalar mode must have a byte size, may have a bit size,\n-\t and must not have components.  */\n-      validate_mode (m, OPTIONAL, SET, UNSET, UNSET);\n+\t and must not have components.   A float mode must have a\n+         format.  */\n+      validate_mode (m, OPTIONAL, SET, UNSET, UNSET,\n+\t\t     m->class == MODE_FLOAT ? SET : UNSET);\n \n       m->ncomponents = 0;\n       m->component = 0;\n@@ -247,7 +252,7 @@ complete_mode (struct mode_data *m)\n       /* A partial integer mode uses ->component to say what the\n \t corresponding full-size integer mode is, and may also\n \t specify a bit size.  */\n-      validate_mode (m, OPTIONAL, UNSET, SET, UNSET);\n+      validate_mode (m, OPTIONAL, UNSET, SET, UNSET, UNSET);\n \n       m->bytesize = m->component->bytesize;\n \n@@ -258,7 +263,7 @@ complete_mode (struct mode_data *m)\n     case MODE_COMPLEX_INT:\n     case MODE_COMPLEX_FLOAT:\n       /* Complex modes should have a component indicated, but no more.  */\n-      validate_mode (m, UNSET, UNSET, SET, UNSET);\n+      validate_mode (m, UNSET, UNSET, SET, UNSET, UNSET);\n       m->ncomponents = 2;\n       if (m->component->bitsize != (unsigned int)-1)\n \tm->bitsize = 2 * m->component->bitsize;\n@@ -268,7 +273,7 @@ complete_mode (struct mode_data *m)\n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n       /* Vector modes should have a component and a number of components.  */\n-      validate_mode (m, UNSET, UNSET, SET, SET);\n+      validate_mode (m, UNSET, UNSET, SET, SET, UNSET);\n       if (m->component->bitsize != (unsigned int)-1)\n \tm->bitsize = m->ncomponents * m->component->bitsize;\n       m->bytesize = m->ncomponents * m->component->bytesize;\n@@ -412,22 +417,49 @@ make_special_mode (enum mode_class class, const char *name,\n   new_mode (class, name, file, line);\n }\n \n-#define _SCALAR_MODE(C, N, B, Y) \\\n-  make_scalar_mode (MODE_##C, #N, B, Y, __FILE__, __LINE__)\n+#define INT_MODE(N, Y) FRACTIONAL_INT_MODE (N, -1, Y)\n+#define FRACTIONAL_INT_MODE(N, B, Y) \\\n+  make_int_mode (#N, B, Y, __FILE__, __LINE__)\n \n-#define INT_MODE(N, Y)                 _SCALAR_MODE (INT, N, -1, Y)\n-#define FRACTIONAL_INT_MODE(N, B, Y)   _SCALAR_MODE (INT, N, B, Y)\n-#define FLOAT_MODE(N, Y)               _SCALAR_MODE (FLOAT, N, -1, Y)\n-#define FRACTIONAL_FLOAT_MODE(N, B, Y) _SCALAR_MODE (FLOAT, N, B, Y)\n+static void\n+make_int_mode (const char *name,\n+\t       unsigned int bitsize, unsigned int bytesize,\n+\t       const char *file, unsigned int line)\n+{\n+  struct mode_data *m = new_mode (MODE_INT, name, file, line);\n+  m->bytesize = bytesize;\n+  m->bitsize = bitsize;\n+}\n+\n+#define FLOAT_MODE(N, Y, F)             FRACTIONAL_FLOAT_MODE (N, -1, Y, F)\n+#define FRACTIONAL_FLOAT_MODE(N, B, Y, F) \\\n+  make_float_mode (#N, B, Y, #F, __FILE__, __LINE__)\n \n static void\n-make_scalar_mode (enum mode_class class, const char *name,\n-\t\t  unsigned int bitsize, unsigned int bytesize,\n-\t\t  const char *file, unsigned int line)\n+make_float_mode (const char *name,\n+\t\t unsigned int bitsize, unsigned int bytesize,\n+\t\t const char *format,\n+\t\t const char *file, unsigned int line)\n {\n-  struct mode_data *m = new_mode (class, name, file, line);\n+  struct mode_data *m = new_mode (MODE_FLOAT, name, file, line);\n   m->bytesize = bytesize;\n   m->bitsize = bitsize;\n+  m->format = format;\n+}\n+\n+#define RESET_FLOAT_FORMAT(N, F) \\\n+  reset_float_format (#N, #F, __FILE__, __LINE__)\n+static void ATTRIBUTE_UNUSED\n+reset_float_format (const char *name, const char *format,\n+\t\t    const char *file, const char *line)\n+{\n+  struct mode_data *m = find_mode (MODE_FLOAT, name);\n+  if (!m)\n+    {\n+      error (\"%s:%d: no mode \\\"%s\\\" in class FLOAT\", file, line, name);\n+      return;\n+    }\n+  m->format = format;\n }\n \n /* Partial integer modes are specified by relation to a full integer mode.\n@@ -680,12 +712,26 @@ emit_insn_modes_c_header (void)\n   puts (\"\\\n    by genmodes.  */\\n\\\n \\n\\\n-#define GENERATOR_FILE /* This inhibits insn-flags.h and\\n\\\n-                          insn-constants.h, which don't exist yet.  */\\n\\\n #include \\\"config.h\\\"\\n\\\n #include \\\"system.h\\\"\\n\\\n #include \\\"coretypes.h\\\"\\n\\\n #include \\\"tm.h\\\"\\n\\\n+#include \\\"machmode.h\\\"\\n\\\n+#include \\\"real.h\\\"\");\n+}\n+\n+static void\n+emit_min_insn_modes_c_header (void)\n+{\n+  printf (\"/* Generated automatically from machmode.def%s%s\\n\",\n+\t   HAVE_EXTRA_MODES ? \" and \" : \"\",\n+\t   EXTRA_MODES_FILE);\n+\n+  puts (\"\\\n+   by genmodes.  */\\n\\\n+\\n\\\n+#include \\\"bconfig.h\\\"\\n\\\n+#include \\\"system.h\\\"\\n\\\n #include \\\"machmode.h\\\"\");\n }\n \n@@ -856,6 +902,25 @@ emit_class_narrowest_mode (void)\n   print_closer ();\n }\n \n+static void\n+emit_real_format_for_mode (void)\n+{\n+  struct mode_data *m;\n+\n+  /* This will produce a table which is not constant, but points to\n+     entities that are constant, which is what we want.  */\n+  print_decl (\"struct real_format *\\n \", \"real_format_for_mode\",\n+\t      \"MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1\");\n+\n+  for (m = known_modes[MODE_FLOAT]; m; m = m->next)\n+    if (!strcmp (m->format, \"0\"))\n+      tagged_printf (\"%s\", m->format, m->name);\n+    else\n+      tagged_printf (\"&%s\", m->format, m->name);\n+\n+  print_closer ();\n+}\n+\n static void\n emit_insn_modes_c (void)\n {\n@@ -870,22 +935,35 @@ emit_insn_modes_c (void)\n   emit_mode_inner ();\n   emit_mode_base_align ();\n   emit_class_narrowest_mode ();\n+  emit_real_format_for_mode ();\n+}\n+\n+static void\n+emit_min_insn_modes_c (void)\n+{\n+  emit_min_insn_modes_c_header ();\n+  emit_mode_name ();\n+  emit_mode_class ();\n+  emit_mode_wider ();\n+  emit_class_narrowest_mode ();\n }\n \n /* Master control.  */\n int\n main(int argc, char **argv)\n {\n-  bool gen_header;\n+  bool gen_header = false, gen_min = false;\n   progname = argv[0];\n \n   if (argc == 1)\n-    gen_header = false;\n+    ;\n   else if (argc == 2 && !strcmp (argv[1], \"-h\"))\n     gen_header = true;\n+  else if (argc == 2 && !strcmp (argv[1], \"-m\"))\n+    gen_min = true;\n   else\n     {\n-      error (\"usage: %s [-h] > file\", progname);\n+      error (\"usage: %s [-h|-m] > file\", progname);\n       return FATAL_EXIT_CODE;\n     }\n \n@@ -899,6 +977,8 @@ main(int argc, char **argv)\n \n   if (gen_header)\n     emit_insn_modes_h ();\n+  else if (gen_min)\n+    emit_min_insn_modes_c ();\n   else\n     emit_insn_modes_c ();\n "}, {"sha": "2dc59f5baccfd3c7348f912e57d163b36f4e990b", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -230,7 +230,7 @@ gen_insn (rtx insn)\n \t      case 'b':\n \t\t/* This loop will stop at the first prefix match, so\n                    look through the modes in reverse order, in case\n-                   EXTRA_CC_MODES was used and CC is a prefix of the\n+                   there are extra CC modes and CC is a prefix of the\n                    CC modes (as it should be).  */\n \t\tfor (i = (MAX_MACHINE_MODE) - 1; i >= 0; i--)\n \t\t  {"}, {"sha": "72b1ec836447f1bc5cc65c4c7dff726fe06e2ac2", "filename": "gcc/machmode.def", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -50,6 +50,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    A BITSIZE, BYTESIZE, or COUNT argument must be a positive integer\n    constant.\n \n+   A FORMAT argument must be one of the real_mode_format structures\n+   declared in real.h, or else a literal 0.\n+\n+   This file defines only those modes which are of use on almost all\n+   machines.  Other modes can be defined in the target-specific\n+   mode definition file, config/ARCH/ARCH-modes.def.\n+\n    Order matters in this file in so far as statements which refer to\n    other modes must appear after the modes they refer to.  However,\n    statements which do not refer to other modes may appear in any\n@@ -69,13 +76,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n         declares MODE to be of class INT, BYTESIZE bytes wide in\n \tstorage, but with only BITSIZE significant bits.\n \n-     FLOAT_MODE (MODE, BYTESIZE);\n-        declares MODE to be of class FLOAT and BYTESIZE bytes wide.\n+     FLOAT_MODE (MODE, BYTESIZE, FORMAT);\n+        declares MODE to be of class FLOAT and BYTESIZE bytes wide,\n+\tusing floating point format FORMAT.\n \tAll of the bits of its representation are significant.\n \n-     FRACTIONAL_FLOAT_MODE (MODE, BITSIZE, BYTESIZE);\n+     FRACTIONAL_FLOAT_MODE (MODE, BITSIZE, BYTESIZE, FORMAT);\n         declares MODE to be of class FLOAT, BYTESIZE bytes wide in\n-\tstorage, but with only BITSIZE significant bits.\n+\tstorage, but with only BITSIZE significant bits, using\n+\tfloating point format FORMAT.\n+\n+     RESET_FLOAT_FORMAT (MODE, FORMAT);\n+\tchanges the format of MODE, which must be class FLOAT,\n+\tto FORMAT.  Use in an ARCH-modes.def to reset the format\n+\tof one of the float modes defined in this file.\n \n      PARTIAL_INT_MODE (MODE);\n         declares a mode of class PARTIAL_INT with the same size as\n@@ -106,10 +120,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \terror if there is no 'F'.  For INT modes, the names are\n \tderived by prefixing a C to the name.\n \n-     BITS_PER_UNIT (COUNT);\n-        Sets the number of bits in a machine byte (least addressable\n-\tunit).  If this statement does not appear, the default is 8.\n-\n    Note: If a mode is ever made which is more than 255 bytes wide,\n    machmode.h and genmodes.c will have to be changed to allocate\n    more space for the mode_size and mode_alignment arrays.  */\n@@ -125,39 +135,34 @@ RANDOM_MODE (BLK);\n /* Single bit mode used for booleans.  */\n FRACTIONAL_INT_MODE (BI, 1, 1);\n \n-/* Basic integer modes.  */\n+/* Basic integer modes.  We go up to TI in generic code (128 bits).\n+   The name OI is reserved for a 256-bit type (needed by some back ends).\n+   FIXME TI shouldn't be generically available either.  */\n INT_MODE (QI, 1);\n INT_MODE (HI, 2);\n INT_MODE (SI, 4);\n INT_MODE (DI, 8);\n INT_MODE (TI, 16);\n-INT_MODE (OI, 32);\n-\n-/* Pointers on some machines use these types to distinguish them from\n-   ints.  Useful if a pointer is 4 bytes but has some bits that are\n-   not significant, so it is really not quite as wide as an integer.  */\n-PARTIAL_INT_MODE (QI);\n-PARTIAL_INT_MODE (HI);\n-PARTIAL_INT_MODE (SI);\n-PARTIAL_INT_MODE (DI);\n-\n-/* Basic floating point modes.  */\n-FLOAT_MODE (QF, 1);\t/* C4x single precision */\n-FLOAT_MODE (HF, 2);\t/* C4x double precision */\n-FLOAT_MODE (TQF, 3);\t/* MIL-STD-1750a */\n-FLOAT_MODE (SF, 4);\n-FLOAT_MODE (DF, 8);\n-FLOAT_MODE (XF, 12);\t/* IEEE extended (80-bit) */\n-FLOAT_MODE (TF, 16);\n-\n-/* Basic CC modes.  */\n+\n+/* No partial integer modes are defined by default.  */\n+\n+/* Basic floating point modes.  SF and DF are the only modes provided\n+   by default.  The names QF, HF, XF, and TF are reserved for targets\n+   that need 1-word, 2-word, 80-bit, or 128-bit float types respectively.\n+\n+   These are the IEEE mappings.  They can be overridden with\n+   RESET_FLOAT_FORMAT or at runtime (in OVERRIDE_OPTIONS).  */\n+\n+FLOAT_MODE (SF, 4, ieee_single_format);\n+FLOAT_MODE (DF, 8, ieee_double_format);\n+\n+/* Basic CC modes.\n+   FIXME define this only for targets that need it.  */\n CC_MODE (CC);\n \n /* Allow the target to specify additional modes of various kinds.  */\n #if HAVE_EXTRA_MODES\n-# define CC(X) CC_MODE(X);  /* backward compatibility, temporary */\n # include EXTRA_MODES_FILE\n-# undef CC\n #endif\n \n /* Complex modes.  */\n@@ -176,7 +181,12 @@ VECTOR_MODE (INT, SI, 8)\n VECTOR_MODE (INT, DI, 4);\n VECTOR_MODE (INT, DI, 8);\n \n-VECTOR_MODE (INT, DI, 1);  /* PPC uses this.  Why not plain DI? */\n+/* PPC uses this to distinguish between DImode passed in\n+   float registers and DImode passed in vector registers.\n+   It would be in rs6000-modes.def but it's referenced in\n+   c-common.c.  FIXME.  */\n+\n+VECTOR_MODE (INT, DI, 1);\n \n VECTOR_MODES (FLOAT, 4);      /*                 V2HF */\n VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */"}, {"sha": "4d05136cf3f882aa5a6e4fd9536cebade0c6ada4", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -34,23 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"flags.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n-\n-/* How to print out a register name.\n-   We don't use PRINT_REG because some definitions of PRINT_REG\n-   don't work here.  */\n-#ifndef DEBUG_PRINT_REG\n-#define DEBUG_PRINT_REG(RTX, CODE, FILE) \\\n-  fprintf ((FILE), \"%d %s\", REGNO (RTX), reg_names[REGNO (RTX)])\n-#endif\n-\n-/* Array containing all of the register names */\n-\n-#ifdef DEBUG_REGISTER_NAMES\n-static const char * const debug_reg_names[] = DEBUG_REGISTER_NAMES;\n-#define reg_names debug_reg_names\n-#else\n-const char * reg_names[] = REGISTER_NAMES;\n-#endif\n+#include \"tm_p.h\"\n \n static FILE *outfile;\n \n@@ -398,10 +382,11 @@ print_rtx (rtx in_rtx)\n \t    int value = XINT (in_rtx, i);\n \t    const char *name;\n \n+#ifndef GENERATOR_FILE\n \t    if (GET_CODE (in_rtx) == REG && value < FIRST_PSEUDO_REGISTER)\n \t      {\n \t\tfputc (' ', outfile);\n-\t\tDEBUG_PRINT_REG (in_rtx, 0, outfile);\n+\t\tPRINT_REG (in_rtx, 0, outfile);\n \t      }\n \t    else if (GET_CODE (in_rtx) == REG\n \t\t     && value <= LAST_VIRTUAL_REGISTER)\n@@ -420,7 +405,9 @@ print_rtx (rtx in_rtx)\n \t\t  fprintf (outfile, \" %d virtual-reg-%d\", value,\n \t\t\t   value-FIRST_VIRTUAL_REGISTER);\n \t      }\n-\t    else if (flag_dump_unnumbered\n+\t    else\n+#endif\n+\t      if (flag_dump_unnumbered\n \t\t     && (is_insn || GET_CODE (in_rtx) == NOTE))\n \t      fputc ('#', outfile);\n \t    else"}, {"sha": "7609d996152e4afdd240804c98f12639b5013c44", "filename": "gcc/real.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -4415,24 +4415,6 @@ const struct real_format real_internal_format =\n     true,\n     true\n   };\n-\f\n-/* Set up default mode to format mapping for IEEE.  Everyone else has\n-   to set these values in OVERRIDE_OPTIONS.  */\n-\n-const struct real_format *real_format_for_mode[TFmode - QFmode + 1] =\n-{\n-  NULL,\t\t\t\t/* QFmode */\n-  NULL,\t\t\t\t/* HFmode */\n-  NULL,\t\t\t\t/* TQFmode */\n-  &ieee_single_format,\t\t/* SFmode */\n-  &ieee_double_format,\t\t/* DFmode */\n-\n-  /* We explicitly don't handle XFmode.  There are two formats,\n-     pretty much equally common.  Choose one in OVERRIDE_OPTIONS.  */\n-  NULL,\t\t\t\t/* XFmode */\n-  &ieee_quad_format\t\t/* TFmode */\n-};\n-\n \f\n /* Calculate the square root of X in mode MODE, and store the result\n    in R.  Return TRUE if the operation does not raise an exception."}, {"sha": "f16f03aa1b6e896d76e6189eec6ba78c02a57477", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94134f429fa03970c82705132728e5d012bb8c03/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=94134f429fa03970c82705132728e5d012bb8c03", "patch": "@@ -179,12 +179,9 @@ enum reg_class reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n \n enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n \n-/* Array containing all of the register names.  Unless\n-   DEBUG_REGISTER_NAMES is defined, use the copy in print-rtl.c.  */\n+/* Array containing all of the register names.  */\n \n-#ifdef DEBUG_REGISTER_NAMES\n const char * reg_names[] = REGISTER_NAMES;\n-#endif\n \n /* For each hard register, the widest mode object that it can contain.\n    This will be a MODE_INT mode if the register can hold integers.  Otherwise"}]}