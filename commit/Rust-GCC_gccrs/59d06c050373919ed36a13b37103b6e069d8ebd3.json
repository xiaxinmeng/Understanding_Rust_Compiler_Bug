{"sha": "59d06c050373919ed36a13b37103b6e069d8ebd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlkMDZjMDUwMzczOTE5ZWQzNmExM2IzNzEwM2I2ZTA2OWQ4ZWJkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T09:20:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T09:20:15Z"}, "message": "Add gen_(const_)vec_duplicate helpers\n\nThis patch adds helper functions for generating constant and\nnon-constant vector duplicates.  These routines help with SVE because\nit is then easier to use:\n\n   (const:M (vec_duplicate:M X))\n\nfor a broadcast of X, even if the number of elements in M isn't known\nat compile time.  It also makes it easier for general rtx code to treat\nconstant and non-constant duplicates in the same way.\n\nIn the target code, the patch uses gen_vec_duplicate instead of\ngen_rtx_VEC_DUPLICATE if handling constants correctly is potentially\nuseful.  It might be that some or all of the call sites only handle\nnon-constants in practice, in which case the change is a harmless\nno-op (and a saving of a few characters).\n\nOtherwise, the target changes use gen_const_vec_duplicate instead\nof gen_rtx_CONST_VECTOR if the constant is obviously a duplicate.\nThey also include some changes to use CONSTxx_RTX for easy global\nconstants.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* emit-rtl.h (gen_const_vec_duplicate): Declare.\n\t(gen_vec_duplicate): Likewise.\n\t* emit-rtl.c (gen_const_vec_duplicate_1): New function, split\n\tout from...\n\t(gen_const_vector): ...here.\n\t(gen_const_vec_duplicate, gen_vec_duplicate): New functions.\n\t(gen_rtx_CONST_VECTOR): Use gen_const_vec_duplicate for constants\n\twhose elements are all equal.\n\t* optabs.c (expand_vector_broadcast): Use gen_const_vec_duplicate.\n\t* simplify-rtx.c (simplify_const_unary_operation): Likewise.\n\t(simplify_relational_operation): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_simd_gen_const_vector_dup):\n\tLikewise.\n\t(aarch64_simd_dup_constant): Use gen_vec_duplicate.\n\t(aarch64_expand_vector_init): Likewise.\n\t* config/arm/arm.c (neon_vdup_constant): Likewise.\n\t(neon_expand_vector_init): Likewise.\n\t(arm_expand_vec_perm): Use gen_const_vec_duplicate.\n\t(arm_block_set_unaligned_vect): Likewise.\n\t(arm_block_set_aligned_vect): Likewise.\n\t* config/arm/neon.md (neon_copysignf<mode>): Likewise.\n\t* config/i386/i386.c (ix86_expand_vec_perm): Likewise.\n\t(expand_vec_perm_even_odd_pack): Likewise.\n\t(ix86_vector_duplicate_value): Use gen_vec_duplicate.\n\t* config/i386/sse.md (one_cmpl<mode>2): Use CONSTM1_RTX.\n\t* config/ia64/ia64.c (ia64_expand_vecint_compare): Use\n\tgen_const_vec_duplicate.\n\t* config/ia64/vect.md (addv2sf3, subv2sf3): Use CONST1_RTX.\n\t* config/mips/mips.c (mips_gen_const_int_vector): Use\n\tgen_const_vec_duplicate.\n\t(mips_expand_vector_init): Use CONST0_RTX.\n\t* config/powerpcspe/altivec.md (abs<mode>2, nabs<mode>2): Likewise.\n\t(define_split): Use gen_const_vec_duplicate.\n\t* config/rs6000/altivec.md (abs<mode>2, nabs<mode>2): Use CONST0_RTX.\n\t(define_split): Use gen_const_vec_duplicate.\n\t* config/s390/vx-builtins.md (vec_genmask<mode>): Likewise.\n\t(vec_ctd_s64, vec_ctd_u64, vec_ctsl, vec_ctul): Likewise.\n\t* config/spu/spu.c (spu_const): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254292", "tree": {"sha": "7dd263d0996c053d689121993600e51fa33249b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dd263d0996c053d689121993600e51fa33249b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59d06c050373919ed36a13b37103b6e069d8ebd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d06c050373919ed36a13b37103b6e069d8ebd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59d06c050373919ed36a13b37103b6e069d8ebd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d06c050373919ed36a13b37103b6e069d8ebd3/comments", "author": null, "committer": null, "parents": [{"sha": "a9b76c8962410173ba0351b5b05b5f1f91742fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b76c8962410173ba0351b5b05b5f1f91742fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9b76c8962410173ba0351b5b05b5f1f91742fc6"}], "stats": {"total": 372, "additions": 155, "deletions": 217}, "files": [{"sha": "d04af4e0cf79c9a5585699faa59b13deb21d2b9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -1,3 +1,46 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* emit-rtl.h (gen_const_vec_duplicate): Declare.\n+\t(gen_vec_duplicate): Likewise.\n+\t* emit-rtl.c (gen_const_vec_duplicate_1): New function, split\n+\tout from...\n+\t(gen_const_vector): ...here.\n+\t(gen_const_vec_duplicate, gen_vec_duplicate): New functions.\n+\t(gen_rtx_CONST_VECTOR): Use gen_const_vec_duplicate for constants\n+\twhose elements are all equal.\n+\t* optabs.c (expand_vector_broadcast): Use gen_const_vec_duplicate.\n+\t* simplify-rtx.c (simplify_const_unary_operation): Likewise.\n+\t(simplify_relational_operation): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_simd_gen_const_vector_dup):\n+\tLikewise.\n+\t(aarch64_simd_dup_constant): Use gen_vec_duplicate.\n+\t(aarch64_expand_vector_init): Likewise.\n+\t* config/arm/arm.c (neon_vdup_constant): Likewise.\n+\t(neon_expand_vector_init): Likewise.\n+\t(arm_expand_vec_perm): Use gen_const_vec_duplicate.\n+\t(arm_block_set_unaligned_vect): Likewise.\n+\t(arm_block_set_aligned_vect): Likewise.\n+\t* config/arm/neon.md (neon_copysignf<mode>): Likewise.\n+\t* config/i386/i386.c (ix86_expand_vec_perm): Likewise.\n+\t(expand_vec_perm_even_odd_pack): Likewise.\n+\t(ix86_vector_duplicate_value): Use gen_vec_duplicate.\n+\t* config/i386/sse.md (one_cmpl<mode>2): Use CONSTM1_RTX.\n+\t* config/ia64/ia64.c (ia64_expand_vecint_compare): Use\n+\tgen_const_vec_duplicate.\n+\t* config/ia64/vect.md (addv2sf3, subv2sf3): Use CONST1_RTX.\n+\t* config/mips/mips.c (mips_gen_const_int_vector): Use\n+\tgen_const_vec_duplicate.\n+\t(mips_expand_vector_init): Use CONST0_RTX.\n+\t* config/powerpcspe/altivec.md (abs<mode>2, nabs<mode>2): Likewise.\n+\t(define_split): Use gen_const_vec_duplicate.\n+\t* config/rs6000/altivec.md (abs<mode>2, nabs<mode>2): Use CONST0_RTX.\n+\t(define_split): Use gen_const_vec_duplicate.\n+\t* config/s390/vx-builtins.md (vec_genmask<mode>): Likewise.\n+\t(vec_ctd_s64, vec_ctd_u64, vec_ctsl, vec_ctul): Likewise.\n+\t* config/spu/spu.c (spu_const): Likewise.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "911868922175e5a0cdca3f040380b7dc428ccd4c", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -11721,16 +11721,8 @@ aarch64_mov_operand_p (rtx x, machine_mode mode)\n rtx\n aarch64_simd_gen_const_vector_dup (machine_mode mode, HOST_WIDE_INT val)\n {\n-  int nunits = GET_MODE_NUNITS (mode);\n-  rtvec v = rtvec_alloc (nunits);\n-  int i;\n-\n-  rtx cache = GEN_INT (val);\n-\n-  for (i=0; i < nunits; i++)\n-    RTVEC_ELT (v, i) = cache;\n-\n-  return gen_rtx_CONST_VECTOR (mode, v);\n+  rtx c = gen_int_mode (val, GET_MODE_INNER (mode));\n+  return gen_const_vec_duplicate (mode, c);\n }\n \n /* Check OP is a legal scalar immediate for the MOVI instruction.  */\n@@ -11942,7 +11934,7 @@ aarch64_simd_dup_constant (rtx vals)\n      single ARM register.  This will be cheaper than a vector\n      load.  */\n   x = copy_to_mode_reg (inner_mode, x);\n-  return gen_rtx_VEC_DUPLICATE (mode, x);\n+  return gen_vec_duplicate (mode, x);\n }\n \n \n@@ -12041,7 +12033,7 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n   if (all_same)\n     {\n       rtx x = copy_to_mode_reg (inner_mode, v0);\n-      aarch64_emit_move (target, gen_rtx_VEC_DUPLICATE (mode, x));\n+      aarch64_emit_move (target, gen_vec_duplicate (mode, x));\n       return;\n     }\n \n@@ -12082,7 +12074,7 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n \n       /* Create a duplicate of the most common element.  */\n       rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, maxelement));\n-      aarch64_emit_move (target, gen_rtx_VEC_DUPLICATE (mode, x));\n+      aarch64_emit_move (target, gen_vec_duplicate (mode, x));\n \n       /* Insert the rest.  */\n       for (int i = 0; i < n_elts; i++)"}, {"sha": "033ec255a577f782201527f57f45802bc0eb45e0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -12159,7 +12159,7 @@ neon_vdup_constant (rtx vals)\n      load.  */\n \n   x = copy_to_mode_reg (inner_mode, x);\n-  return gen_rtx_VEC_DUPLICATE (mode, x);\n+  return gen_vec_duplicate (mode, x);\n }\n \n /* Generate code to load VALS, which is a PARALLEL containing only\n@@ -12254,7 +12254,7 @@ neon_expand_vector_init (rtx target, rtx vals)\n   if (all_same && GET_MODE_SIZE (inner_mode) <= 4)\n     {\n       x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));\n-      emit_insn (gen_rtx_SET (target, gen_rtx_VEC_DUPLICATE (mode, x)));\n+      emit_insn (gen_rtx_SET (target, gen_vec_duplicate (mode, x)));\n       return;\n     }\n \n@@ -28756,9 +28756,9 @@ void\n arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n {\n   machine_mode vmode = GET_MODE (target);\n-  unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n+  unsigned int nelt = GET_MODE_NUNITS (vmode);\n   bool one_vector_p = rtx_equal_p (op0, op1);\n-  rtx rmask[MAX_VECT_LEN], mask;\n+  rtx mask;\n \n   /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n      numbering of elements for big-endian, we must reverse the order.  */\n@@ -28767,9 +28767,7 @@ arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n   /* The VTBL instruction does not use a modulo index, so we must take care\n      of that ourselves.  */\n   mask = GEN_INT (one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-  for (i = 0; i < nelt; ++i)\n-    rmask[i] = mask;\n-  mask = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rmask));\n+  mask = gen_const_vec_duplicate (vmode, mask);\n   sel = expand_simple_binop (vmode, AND, sel, mask, NULL, 0, OPTAB_LIB_WIDEN);\n \n   arm_expand_vec_perm_1 (target, op0, op1, sel);\n@@ -29823,10 +29821,9 @@ arm_block_set_unaligned_vect (rtx dstbase,\n \t\t\t      unsigned HOST_WIDE_INT value,\n \t\t\t      unsigned HOST_WIDE_INT align)\n {\n-  unsigned int i, j, nelt_v16, nelt_v8, nelt_mode;\n+  unsigned int i, nelt_v16, nelt_v8, nelt_mode;\n   rtx dst, mem;\n-  rtx val_elt, val_vec, reg;\n-  rtx rval[MAX_VECT_LEN];\n+  rtx val_vec, reg;\n   rtx (*gen_func) (rtx, rtx);\n   machine_mode mode;\n   unsigned HOST_WIDE_INT v = value;\n@@ -29854,12 +29851,9 @@ arm_block_set_unaligned_vect (rtx dstbase,\n   mem = adjust_automodify_address (dstbase, mode, dst, offset);\n \n   v = sext_hwi (v, BITS_PER_WORD);\n-  val_elt = GEN_INT (v);\n-  for (j = 0; j < nelt_mode; j++)\n-    rval[j] = val_elt;\n \n   reg = gen_reg_rtx (mode);\n-  val_vec = gen_rtx_CONST_VECTOR (mode, gen_rtvec_v (nelt_mode, rval));\n+  val_vec = gen_const_vec_duplicate (mode, GEN_INT (v));\n   /* Emit instruction loading the constant value.  */\n   emit_move_insn (reg, val_vec);\n \n@@ -29923,10 +29917,9 @@ arm_block_set_aligned_vect (rtx dstbase,\n \t\t\t    unsigned HOST_WIDE_INT value,\n \t\t\t    unsigned HOST_WIDE_INT align)\n {\n-  unsigned int i, j, nelt_v8, nelt_v16, nelt_mode;\n+  unsigned int i, nelt_v8, nelt_v16, nelt_mode;\n   rtx dst, addr, mem;\n-  rtx val_elt, val_vec, reg;\n-  rtx rval[MAX_VECT_LEN];\n+  rtx val_vec, reg;\n   machine_mode mode;\n   unsigned HOST_WIDE_INT v = value;\n   unsigned int offset = 0;\n@@ -29948,12 +29941,9 @@ arm_block_set_aligned_vect (rtx dstbase,\n   dst = copy_addr_to_reg (XEXP (dstbase, 0));\n \n   v = sext_hwi (v, BITS_PER_WORD);\n-  val_elt = GEN_INT (v);\n-  for (j = 0; j < nelt_mode; j++)\n-    rval[j] = val_elt;\n \n   reg = gen_reg_rtx (mode);\n-  val_vec = gen_rtx_CONST_VECTOR (mode, gen_rtvec_v (nelt_mode, rval));\n+  val_vec = gen_const_vec_duplicate (mode, GEN_INT (v));\n   /* Emit instruction loading the constant value.  */\n   emit_move_insn (reg, val_vec);\n "}, {"sha": "073c26580dd317a01cd0e275965fee2ef83ae3f9", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -3114,15 +3114,10 @@\n   \"{\n      rtx v_bitmask_cast;\n      rtx v_bitmask = gen_reg_rtx (<VCVTF:V_cmp_result>mode);\n-     int i, n_elt = GET_MODE_NUNITS (<MODE>mode);\n-     rtvec v = rtvec_alloc (n_elt);\n-\n-     /* Create bitmask for vector select.  */\n-     for (i = 0; i < n_elt; ++i)\n-       RTVEC_ELT (v, i) = GEN_INT (0x80000000);\n+     rtx c = GEN_INT (0x80000000);\n \n      emit_move_insn (v_bitmask,\n-\t\t     gen_rtx_CONST_VECTOR (<VCVTF:V_cmp_result>mode, v));\n+\t\t     gen_const_vec_duplicate (<VCVTF:V_cmp_result>mode, c));\n      emit_move_insn (operands[0], operands[2]);\n      v_bitmask_cast = simplify_gen_subreg (<MODE>mode, v_bitmask,\n \t\t\t\t\t   <VCVTF:V_cmp_result>mode, 0);"}, {"sha": "29678722226f05730e8fafcb03c5d709866ce42a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -24334,9 +24334,7 @@ ix86_expand_vec_perm (rtx operands[])\n \t  t2 = gen_reg_rtx (V32QImode);\n \t  t3 = gen_reg_rtx (V32QImode);\n \t  vt2 = GEN_INT (-128);\n-\t  for (i = 0; i < 32; i++)\n-\t    vec[i] = vt2;\n-\t  vt = gen_rtx_CONST_VECTOR (V32QImode, gen_rtvec_v (32, vec));\n+\t  vt = gen_const_vec_duplicate (V32QImode, vt2);\n \t  vt = force_reg (V32QImode, vt);\n \t  for (i = 0; i < 32; i++)\n \t    vec[i] = i < 16 ? vt2 : const0_rtx;\n@@ -24444,9 +24442,7 @@ ix86_expand_vec_perm (rtx operands[])\n       vt = GEN_INT (w - 1);\n     }\n \n-  for (i = 0; i < w; i++)\n-    vec[i] = vt;\n-  vt = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n+  vt = gen_const_vec_duplicate (maskmode, vt);\n   mask = expand_simple_binop (maskmode, AND, mask, vt,\n \t\t\t      NULL_RTX, 0, OPTAB_DIRECT);\n \n@@ -24536,9 +24532,7 @@ ix86_expand_vec_perm (rtx operands[])\n \t  e = w = 4;\n \t}\n \n-      for (i = 0; i < w; i++)\n-\tvec[i] = vt;\n-      vt = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n+      vt = gen_const_vec_duplicate (maskmode, vt);\n       vt = force_reg (maskmode, vt);\n       mask = expand_simple_binop (maskmode, AND, mask, vt,\n \t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n@@ -41224,7 +41218,7 @@ ix86_vector_duplicate_value (machine_mode mode, rtx target, rtx val)\n   rtx dup;\n \n   /* First attempt to recognize VAL as-is.  */\n-  dup = gen_rtx_VEC_DUPLICATE (mode, val);\n+  dup = gen_vec_duplicate (mode, val);\n   insn = emit_insn (gen_rtx_SET (target, dup));\n   if (recog_memoized (insn) < 0)\n     {\n@@ -46582,7 +46576,7 @@ expand_vec_perm_vpshufb2_vpermq_even_odd (struct expand_vec_perm_d *d)\n static bool\n expand_vec_perm_even_odd_pack (struct expand_vec_perm_d *d)\n {\n-  rtx op, dop0, dop1, t, rperm[16];\n+  rtx op, dop0, dop1, t;\n   unsigned i, odd, c, s, nelt = d->nelt;\n   bool end_perm = false;\n   machine_mode half_mode;\n@@ -46659,9 +46653,7 @@ expand_vec_perm_even_odd_pack (struct expand_vec_perm_d *d)\n   dop1 = gen_reg_rtx (half_mode);\n   if (odd == 0)\n     {\n-      for (i = 0; i < nelt / 2; i++)\n-\trperm[i] = GEN_INT (c);\n-      t = gen_rtx_CONST_VECTOR (half_mode, gen_rtvec_v (nelt / 2, rperm));\n+      t = gen_const_vec_duplicate (half_mode, GEN_INT (c));\n       t = force_reg (half_mode, t);\n       emit_insn (gen_and (dop0, t, gen_lowpart (half_mode, d->op0)));\n       emit_insn (gen_and (dop1, t, gen_lowpart (half_mode, d->op1)));"}, {"sha": "4dfb2f8d3b33b54804a2cf54c44c9c2bc0e019bc", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -11487,13 +11487,7 @@\n \t\t(match_dup 2)))]\n   \"TARGET_SSE\"\n {\n-  int i, n = GET_MODE_NUNITS (<MODE>mode);\n-  rtvec v = rtvec_alloc (n);\n-\n-  for (i = 0; i < n; ++i)\n-    RTVEC_ELT (v, i) = constm1_rtx;\n-\n-  operands[2] = force_reg (<MODE>mode, gen_rtx_CONST_VECTOR (<MODE>mode, v));\n+  operands[2] = force_reg (<MODE>mode, CONSTM1_RTX (<MODE>mode));\n })\n \n (define_expand \"<sse2_avx2>_andnot<mode>3\""}, {"sha": "3d38365b0871eabc16fba42607426a1c80971811", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -1938,7 +1938,7 @@ ia64_expand_vecint_compare (enum rtx_code code, machine_mode mode,\n \t    /* Subtract (-(INT MAX) - 1) from both operands to make\n \t       them signed.  */\n \t    mask = gen_int_mode (0x80000000, SImode);\n-\t    mask = gen_rtx_CONST_VECTOR (V2SImode, gen_rtvec (2, mask, mask));\n+\t    mask = gen_const_vec_duplicate (V2SImode, mask);\n \t    mask = force_reg (mode, mask);\n \t    t1 = gen_reg_rtx (mode);\n \t    emit_insn (gen_subv2si3 (t1, op0, mask));"}, {"sha": "20e260ccfbaa62711d7e5d09a51086603bd0e252", "filename": "gcc/config/ia64/vect.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -1138,8 +1138,7 @@\n \t\t  (match_operand:V2SF 2 \"fr_register_operand\" \"\")))]\n   \"\"\n {\n-  rtvec v = gen_rtvec (2, CONST1_RTX (SFmode), CONST1_RTX (SFmode));\n-  operands[3] = force_reg (V2SFmode, gen_rtx_CONST_VECTOR (V2SFmode, v));\n+  operands[3] = force_reg (V2SFmode, CONST1_RTX (V2SFmode));\n })\n \n (define_expand \"subv2sf3\"\n@@ -1150,8 +1149,7 @@\n \t  (neg:V2SF (match_operand:V2SF 2 \"fr_register_operand\" \"\"))))]\n   \"\"\n {\n-  rtvec v = gen_rtvec (2, CONST1_RTX (SFmode), CONST1_RTX (SFmode));\n-  operands[3] = force_reg (V2SFmode, gen_rtx_CONST_VECTOR (V2SFmode, v));\n+  operands[3] = force_reg (V2SFmode, CONST1_RTX (V2SFmode));\n })\n \n (define_insn \"mulv2sf3\""}, {"sha": "c836748f9c68f05d7337f592d1507adcd777e959", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -21681,14 +21681,8 @@ mips_expand_vi_broadcast (machine_mode vmode, rtx target, rtx elt)\n rtx\n mips_gen_const_int_vector (machine_mode mode, HOST_WIDE_INT val)\n {\n-  int nunits = GET_MODE_NUNITS (mode);\n-  rtvec v = rtvec_alloc (nunits);\n-  int i;\n-\n-  for (i = 0; i < nunits; i++)\n-    RTVEC_ELT (v, i) = gen_int_mode (val, GET_MODE_INNER (mode));\n-\n-  return gen_rtx_CONST_VECTOR (mode, v);\n+  rtx c = gen_int_mode (val, GET_MODE_INNER (mode));\n+  return gen_const_vec_duplicate (mode, c);\n }\n \n /* Return a vector of repeated 4-element sets generated from\n@@ -21843,12 +21837,7 @@ mips_expand_vector_init (rtx target, rtx vals)\n \t}\n       else\n \t{\n-\t  rtvec vec = shallow_copy_rtvec (XVEC (vals, 0));\n-\n-\t  for (i = 0; i < nelt; ++i)\n-\t    RTVEC_ELT (vec, i) = CONST0_RTX (imode);\n-\n-\t  emit_move_insn (target, gen_rtx_CONST_VECTOR (vmode, vec));\n+\t  emit_move_insn (target, CONST0_RTX (vmode));\n \n \t  for (i = 0; i < nelt; ++i)\n \t    {"}, {"sha": "f1cc6e2d07603c77b7995e6954da5f003d99ffc4", "filename": "gcc/config/powerpcspe/altivec.md", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -352,12 +352,10 @@\n   HOST_WIDE_INT val = const_vector_elt_as_int (op1, elt);\n   rtx rtx_val = GEN_INT (val);\n   int shift = vspltis_shifted (op1);\n-  int nunits = GET_MODE_NUNITS (<MODE>mode);\n-  int i;\n \n   gcc_assert (shift != 0);\n   operands[2] = gen_reg_rtx (<MODE>mode);\n-  operands[3] = gen_rtx_CONST_VECTOR (<MODE>mode, rtvec_alloc (nunits));\n+  operands[3] = gen_const_vec_duplicate (<MODE>mode, rtx_val);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n \n   if (shift < 0)\n@@ -370,10 +368,6 @@\n       operands[5] = CONST0_RTX (<MODE>mode);\n       operands[6] = GEN_INT (shift);\n     }\n-\n-  /* Populate the constant vectors.  */\n-  for (i = 0; i < nunits; i++)\n-    XVECEXP (operands[3], 0, i) = rtx_val;\n })\n \n (define_insn \"get_vrsave_internal\"\n@@ -2752,15 +2746,8 @@\n         (smax:VI2 (match_dup 1) (match_dup 4)))]\n   \"<VI_unit>\"\n {\n-  int i, n_elt = GET_MODE_NUNITS (<MODE>mode);\n-  rtvec v = rtvec_alloc (n_elt);\n-\n-  /* Create an all 0 constant.  */\n-  for (i = 0; i < n_elt; ++i)\n-    RTVEC_ELT (v, i) = const0_rtx;\n-\n   operands[2] = gen_reg_rtx (<MODE>mode);\n-  operands[3] = gen_rtx_CONST_VECTOR (<MODE>mode, v);\n+  operands[3] = CONST0_RTX (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n })\n \n@@ -2777,17 +2764,8 @@\n         (smin:VI2 (match_dup 1) (match_dup 4)))]\n   \"<VI_unit>\"\n {\n-  int i;\n-  int n_elt = GET_MODE_NUNITS (<MODE>mode);\n-\n-  rtvec v = rtvec_alloc (n_elt);\n-\n-  /* Create an all 0 constant.  */\n-  for (i = 0; i < n_elt; ++i)\n-    RTVEC_ELT (v, i) = const0_rtx;\n-\n   operands[2] = gen_reg_rtx (<MODE>mode);\n-  operands[3] = gen_rtx_CONST_VECTOR (<MODE>mode, v);\n+  operands[3] = CONST0_RTX (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n })\n "}, {"sha": "e64e804f35374537e4134bef326bb354b843d328", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -363,12 +363,10 @@\n   HOST_WIDE_INT val = const_vector_elt_as_int (op1, elt);\n   rtx rtx_val = GEN_INT (val);\n   int shift = vspltis_shifted (op1);\n-  int nunits = GET_MODE_NUNITS (<MODE>mode);\n-  int i;\n \n   gcc_assert (shift != 0);\n   operands[2] = gen_reg_rtx (<MODE>mode);\n-  operands[3] = gen_rtx_CONST_VECTOR (<MODE>mode, rtvec_alloc (nunits));\n+  operands[3] = gen_const_vec_duplicate (<MODE>mode, rtx_val);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n \n   if (shift < 0)\n@@ -381,10 +379,6 @@\n       operands[5] = CONST0_RTX (<MODE>mode);\n       operands[6] = GEN_INT (shift);\n     }\n-\n-  /* Populate the constant vectors.  */\n-  for (i = 0; i < nunits; i++)\n-    XVECEXP (operands[3], 0, i) = rtx_val;\n })\n \n (define_insn \"get_vrsave_internal\"\n@@ -3238,15 +3232,8 @@\n         (smax:VI2 (match_dup 1) (match_dup 4)))]\n   \"<VI_unit>\"\n {\n-  int i, n_elt = GET_MODE_NUNITS (<MODE>mode);\n-  rtvec v = rtvec_alloc (n_elt);\n-\n-  /* Create an all 0 constant.  */\n-  for (i = 0; i < n_elt; ++i)\n-    RTVEC_ELT (v, i) = const0_rtx;\n-\n   operands[2] = gen_reg_rtx (<MODE>mode);\n-  operands[3] = gen_rtx_CONST_VECTOR (<MODE>mode, v);\n+  operands[3] = CONST0_RTX (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n })\n \n@@ -3263,17 +3250,8 @@\n         (smin:VI2 (match_dup 1) (match_dup 4)))]\n   \"<VI_unit>\"\n {\n-  int i;\n-  int n_elt = GET_MODE_NUNITS (<MODE>mode);\n-\n-  rtvec v = rtvec_alloc (n_elt);\n-\n-  /* Create an all 0 constant.  */\n-  for (i = 0; i < n_elt; ++i)\n-    RTVEC_ELT (v, i) = const0_rtx;\n-\n   operands[2] = gen_reg_rtx (<MODE>mode);\n-  operands[3] = gen_rtx_CONST_VECTOR (<MODE>mode, v);\n+  operands[3] = CONST0_RTX (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n })\n "}, {"sha": "2184887549dcbcbb79be25c3efa8d352fdba96f0", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -91,12 +91,10 @@\n    (match_operand:QI    2 \"const_int_operand\" \"C\")]\n   \"TARGET_VX\"\n {\n-  int nunits = GET_MODE_NUNITS (<VI_HW:MODE>mode);\n   int bitlen = GET_MODE_UNIT_BITSIZE (<VI_HW:MODE>mode);\n   /* To bit little endian style.  */\n   int end = bitlen - 1 - INTVAL (operands[1]);\n   int start = bitlen - 1 - INTVAL (operands[2]);\n-  rtx const_vec[16];\n   int i;\n   unsigned HOST_WIDE_INT mask;\n   bool swapped_p = false;\n@@ -116,13 +114,11 @@\n   if (swapped_p)\n     mask = ~mask;\n \n-  for (i = 0; i < nunits; i++)\n-    const_vec[i] = GEN_INT (trunc_int_for_mode (mask,\n-\t\t\t      GET_MODE_INNER (<VI_HW:MODE>mode)));\n+  rtx mask_rtx = gen_int_mode (mask, GET_MODE_INNER (<VI_HW:MODE>mode));\n \n   emit_insn (gen_rtx_SET (operands[0],\n-\t\t\t  gen_rtx_CONST_VECTOR (<VI_HW:MODE>mode,\n-\t\t\t\t\t\tgen_rtvec_v (nunits, const_vec))));\n+\t\t\t  gen_const_vec_duplicate (<VI_HW:MODE>mode,\n+\t\t\t\t\t\t   mask_rtx)));\n   DONE;\n })\n \n@@ -1623,7 +1619,7 @@\n   real_2expN (&f, -INTVAL (operands[2]), DFmode);\n   c = const_double_from_real_value (f, DFmode);\n \n-  operands[3] = gen_rtx_CONST_VECTOR (V2DFmode, gen_rtvec (2, c, c));\n+  operands[3] = gen_const_vec_duplicate (V2DFmode, c);\n   operands[3] = force_reg (V2DFmode, operands[3]);\n })\n \n@@ -1654,7 +1650,7 @@\n   real_2expN (&f, -INTVAL (operands[2]), DFmode);\n   c = const_double_from_real_value (f, DFmode);\n \n-  operands[3] = gen_rtx_CONST_VECTOR (V2DFmode, gen_rtvec (2, c, c));\n+  operands[3] = gen_const_vec_duplicate (V2DFmode, c);\n   operands[3] = force_reg (V2DFmode, operands[3]);\n })\n \n@@ -1686,7 +1682,7 @@\n   real_2expN (&f, INTVAL (operands[2]), DFmode);\n   c = const_double_from_real_value (f, DFmode);\n \n-  operands[3] = gen_rtx_CONST_VECTOR (V2DFmode, gen_rtvec (2, c, c));\n+  operands[3] = gen_const_vec_duplicate (V2DFmode, c);\n   operands[3] = force_reg (V2DFmode, operands[3]);\n   operands[4] = gen_reg_rtx (V2DFmode);\n })\n@@ -1719,7 +1715,7 @@\n   real_2expN (&f, INTVAL (operands[2]), DFmode);\n   c = const_double_from_real_value (f, DFmode);\n \n-  operands[3] = gen_rtx_CONST_VECTOR (V2DFmode, gen_rtvec (2, c, c));\n+  operands[3] = gen_const_vec_duplicate (V2DFmode, c);\n   operands[3] = force_reg (V2DFmode, operands[3]);\n   operands[4] = gen_reg_rtx (V2DFmode);\n })"}, {"sha": "78252101ef57397976a674bc066285eb959a6452", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -1903,8 +1903,6 @@ rtx\n spu_const (machine_mode mode, HOST_WIDE_INT val)\n {\n   rtx inner;\n-  rtvec v;\n-  int units, i;\n \n   gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n \t      || GET_MODE_CLASS (mode) == MODE_FLOAT\n@@ -1923,14 +1921,7 @@ spu_const (machine_mode mode, HOST_WIDE_INT val)\n   else \n     inner = hwint_to_const_double (GET_MODE_INNER (mode), val);\n \n-  units = GET_MODE_NUNITS (mode);\n-\n-  v = rtvec_alloc (units);\n-\n-  for (i = 0; i < units; ++i)\n-    RTVEC_ELT (v, i) = inner;\n-\n-  return gen_rtx_CONST_VECTOR (mode, v);\n+  return gen_const_vec_duplicate (mode, inner);\n }\n \n /* Create a MODE vector constant from 4 ints. */"}, {"sha": "4df550fbe77ad83e9063230b0440d50be4792164", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -5757,61 +5757,73 @@ init_emit (void)\n #endif\n }\n \n-/* Generate a vector constant for mode MODE and constant value CONSTANT.  */\n+/* Like gen_const_vec_duplicate, but ignore const_tiny_rtx.  */\n \n static rtx\n-gen_const_vector (machine_mode mode, int constant)\n+gen_const_vec_duplicate_1 (machine_mode mode, rtx el)\n {\n-  rtx tem;\n-  rtvec v;\n-  int units, i;\n-  machine_mode inner;\n+  int nunits = GET_MODE_NUNITS (mode);\n+  rtvec v = rtvec_alloc (nunits);\n+  for (int i = 0; i < nunits; ++i)\n+    RTVEC_ELT (v, i) = el;\n+  return gen_rtx_raw_CONST_VECTOR (mode, v);\n+}\n \n-  units = GET_MODE_NUNITS (mode);\n-  inner = GET_MODE_INNER (mode);\n+/* Generate a vector constant of mode MODE in which every element has\n+   value ELT.  */\n \n-  gcc_assert (!DECIMAL_FLOAT_MODE_P (inner));\n+rtx\n+gen_const_vec_duplicate (machine_mode mode, rtx elt)\n+{\n+  scalar_mode inner_mode = GET_MODE_INNER (mode);\n+  if (elt == CONST0_RTX (inner_mode))\n+    return CONST0_RTX (mode);\n+  else if (elt == CONST1_RTX (inner_mode))\n+    return CONST1_RTX (mode);\n+  else if (elt == CONSTM1_RTX (inner_mode))\n+    return CONSTM1_RTX (mode);\n+\n+  return gen_const_vec_duplicate_1 (mode, elt);\n+}\n+\n+/* Return a vector rtx of mode MODE in which every element has value X.\n+   The result will be a constant if X is constant.  */\n+\n+rtx\n+gen_vec_duplicate (machine_mode mode, rtx x)\n+{\n+  if (CONSTANT_P (x))\n+    return gen_const_vec_duplicate (mode, x);\n+  return gen_rtx_VEC_DUPLICATE (mode, x);\n+}\n \n-  v = rtvec_alloc (units);\n+/* Generate a new vector constant for mode MODE and constant value\n+   CONSTANT.  */\n \n-  /* We need to call this function after we set the scalar const_tiny_rtx\n-     entries.  */\n-  gcc_assert (const_tiny_rtx[constant][(int) inner]);\n+static rtx\n+gen_const_vector (machine_mode mode, int constant)\n+{\n+  machine_mode inner = GET_MODE_INNER (mode);\n \n-  for (i = 0; i < units; ++i)\n-    RTVEC_ELT (v, i) = const_tiny_rtx[constant][(int) inner];\n+  gcc_assert (!DECIMAL_FLOAT_MODE_P (inner));\n+\n+  rtx el = const_tiny_rtx[constant][(int) inner];\n+  gcc_assert (el);\n \n-  tem = gen_rtx_raw_CONST_VECTOR (mode, v);\n-  return tem;\n+  return gen_const_vec_duplicate_1 (mode, el);\n }\n \n /* Generate a vector like gen_rtx_raw_CONST_VEC, but use the zero vector when\n    all elements are zero, and the one vector when all elements are one.  */\n rtx\n gen_rtx_CONST_VECTOR (machine_mode mode, rtvec v)\n {\n-  machine_mode inner = GET_MODE_INNER (mode);\n-  int nunits = GET_MODE_NUNITS (mode);\n-  rtx x;\n-  int i;\n-\n-  /* Check to see if all of the elements have the same value.  */\n-  x = RTVEC_ELT (v, nunits - 1);\n-  for (i = nunits - 2; i >= 0; i--)\n-    if (RTVEC_ELT (v, i) != x)\n-      break;\n+  gcc_assert (GET_MODE_NUNITS (mode) == GET_NUM_ELEM (v));\n \n   /* If the values are all the same, check to see if we can use one of the\n      standard constant vectors.  */\n-  if (i == -1)\n-    {\n-      if (x == CONST0_RTX (inner))\n-\treturn CONST0_RTX (mode);\n-      else if (x == CONST1_RTX (inner))\n-\treturn CONST1_RTX (mode);\n-      else if (x == CONSTM1_RTX (inner))\n-\treturn CONSTM1_RTX (mode);\n-    }\n+  if (rtvec_all_equal_p (v))\n+    return gen_const_vec_duplicate (mode, RTVEC_ELT (v, 0));\n \n   return gen_rtx_raw_CONST_VECTOR (mode, v);\n }"}, {"sha": "c79f740c5047bbcbc957ef4c1530156bb81a572f", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -438,6 +438,9 @@ get_max_uid (void)\n   return crtl->emit.x_cur_insn_uid;\n }\n \n+extern rtx gen_const_vec_duplicate (machine_mode, rtx);\n+extern rtx gen_vec_duplicate (machine_mode, rtx);\n+\n extern void set_decl_incoming_rtl (tree, rtx, bool);\n \n /* Return a memory reference like MEMREF, but with its mode changed"}, {"sha": "6f7848d6b0bed0c9c50b3a6a626e16eb8e36cfba", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -377,13 +377,8 @@ expand_vector_broadcast (machine_mode vmode, rtx op)\n \n   gcc_checking_assert (VECTOR_MODE_P (vmode));\n \n-  n = GET_MODE_NUNITS (vmode);\n-  vec = rtvec_alloc (n);\n-  for (i = 0; i < n; ++i)\n-    RTVEC_ELT (vec, i) = op;\n-\n   if (CONSTANT_P (op))\n-    return gen_rtx_CONST_VECTOR (vmode, vec);\n+    return gen_const_vec_duplicate (vmode, op);\n \n   /* ??? If the target doesn't have a vec_init, then we have no easy way\n      of performing this operation.  Most of this sort of generic support\n@@ -393,6 +388,10 @@ expand_vector_broadcast (machine_mode vmode, rtx op)\n   if (icode == CODE_FOR_nothing)\n     return NULL;\n \n+  n = GET_MODE_NUNITS (vmode);\n+  vec = rtvec_alloc (n);\n+  for (i = 0; i < n; ++i)\n+    RTVEC_ELT (vec, i) = op;\n   ret = gen_reg_rtx (vmode);\n   emit_insn (GEN_FCN (icode) (ret, gen_rtx_PARALLEL (vmode, vec)));\n "}, {"sha": "9736bccdaf0195e76554df76963447b2a5bb9878", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d06c050373919ed36a13b37103b6e069d8ebd3/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=59d06c050373919ed36a13b37103b6e069d8ebd3", "patch": "@@ -1707,28 +1707,23 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t  gcc_assert (GET_MODE_INNER (mode) == GET_MODE_INNER\n \t\t\t\t\t\t(GET_MODE (op)));\n       }\n-      if (CONST_SCALAR_INT_P (op) || CONST_DOUBLE_AS_FLOAT_P (op)\n-\t  || GET_CODE (op) == CONST_VECTOR)\n+      if (CONST_SCALAR_INT_P (op) || CONST_DOUBLE_AS_FLOAT_P (op))\n+\treturn gen_const_vec_duplicate (mode, op);\n+      if (GET_CODE (op) == CONST_VECTOR)\n \t{\n \t  int elt_size = GET_MODE_UNIT_SIZE (mode);\n           unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n \t  rtvec v = rtvec_alloc (n_elts);\n \t  unsigned int i;\n \n-\t  if (GET_CODE (op) != CONST_VECTOR)\n-\t    for (i = 0; i < n_elts; i++)\n-\t      RTVEC_ELT (v, i) = op;\n-\t  else\n-\t    {\n-\t      machine_mode inmode = GET_MODE (op);\n-\t      int in_elt_size = GET_MODE_UNIT_SIZE (inmode);\n-              unsigned in_n_elts = (GET_MODE_SIZE (inmode) / in_elt_size);\n+\t  machine_mode inmode = GET_MODE (op);\n+\t  int in_elt_size = GET_MODE_UNIT_SIZE (inmode);\n+\t  unsigned in_n_elts = (GET_MODE_SIZE (inmode) / in_elt_size);\n \n-\t      gcc_assert (in_n_elts < n_elts);\n-\t      gcc_assert ((n_elts % in_n_elts) == 0);\n-\t      for (i = 0; i < n_elts; i++)\n-\t        RTVEC_ELT (v, i) = CONST_VECTOR_ELT (op, i % in_n_elts);\n-\t    }\n+\t  gcc_assert (in_n_elts < n_elts);\n+\t  gcc_assert ((n_elts % in_n_elts) == 0);\n+\t  for (i = 0; i < n_elts; i++)\n+\t    RTVEC_ELT (v, i) = CONST_VECTOR_ELT (op, i % in_n_elts);\n \t  return gen_rtx_CONST_VECTOR (mode, v);\n \t}\n     }\n@@ -4636,20 +4631,13 @@ simplify_relational_operation (enum rtx_code code, machine_mode mode,\n \t    return CONST0_RTX (mode);\n #ifdef VECTOR_STORE_FLAG_VALUE\n \t  {\n-\t    int i, units;\n-\t    rtvec v;\n-\n \t    rtx val = VECTOR_STORE_FLAG_VALUE (mode);\n \t    if (val == NULL_RTX)\n \t      return NULL_RTX;\n \t    if (val == const1_rtx)\n \t      return CONST1_RTX (mode);\n \n-\t    units = GET_MODE_NUNITS (mode);\n-\t    v = rtvec_alloc (units);\n-\t    for (i = 0; i < units; i++)\n-\t      RTVEC_ELT (v, i) = val;\n-\t    return gen_rtx_raw_CONST_VECTOR (mode, v);\n+\t    return gen_const_vec_duplicate (mode, val);\n \t  }\n #else\n \t  return NULL_RTX;"}]}