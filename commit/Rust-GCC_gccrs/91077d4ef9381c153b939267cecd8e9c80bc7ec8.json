{"sha": "91077d4ef9381c153b939267cecd8e9c80bc7ec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwNzdkNGVmOTM4MWMxNTNiOTM5MjY3Y2VjZDhlOWM4MGJjN2VjOA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-05-11T13:56:06Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-05-11T13:56:06Z"}, "message": "re PR libfortran/52537 (slow trim function)\n\n2012-05-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/52537\n\t* frontend-passes.c (optimize_op):  Change\n\told-style comparison operators to new-style, simplify\n\tswitch as a result.\n\t(empty_string):  New function.\n\t(get_len_trim_call):  New function.\n\t(optimize_comparison):  If comparing to an empty string,\n\tuse comparison of len_trim to zero.\n\tUse new-style comparison operators only.\n\t(optimize_trim):  Use get_len_trim_call.\n\n2012-05-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/52537\n\t* gfortran.dg/string_compare_4.f90:  New test.\n\nFrom-SVN: r187406", "tree": {"sha": "db9f42f0ecca3a64aeac5cab33193f75cc50545c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db9f42f0ecca3a64aeac5cab33193f75cc50545c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91077d4ef9381c153b939267cecd8e9c80bc7ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91077d4ef9381c153b939267cecd8e9c80bc7ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91077d4ef9381c153b939267cecd8e9c80bc7ec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91077d4ef9381c153b939267cecd8e9c80bc7ec8/comments", "author": null, "committer": null, "parents": [{"sha": "3feb96d2f40609a8d9a77df21c516420004fbf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3feb96d2f40609a8d9a77df21c516420004fbf36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3feb96d2f40609a8d9a77df21c516420004fbf36"}], "stats": {"total": 192, "additions": 167, "deletions": 25}, "files": [{"sha": "e761ef5115401151fdbe71e9cc872c770b681a9f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=91077d4ef9381c153b939267cecd8e9c80bc7ec8", "patch": "@@ -1,3 +1,16 @@\n+2012-05-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/52537\n+\t* frontend-passes.c (optimize_op):  Change\n+\told-style comparison operators to new-style, simplify\n+\tswitch as a result.\n+\t(empty_string):  New function.\n+\t(get_len_trim_call):  New function.\n+\t(optimize_comparison):  If comparing to an empty string,\n+\tuse comparison of len_trim to zero.\n+\tUse new-style comparison operators only.\n+\t(optimize_trim):  Use get_len_trim_call.\n+\n 2012-05-11  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 53063\n@@ -7,7 +20,7 @@\n \t(gfc_handle_option): Set it here using handle_generated_option.\n \n 2012-05-08  Jan Hubicka  <jh@suse.cz>\n-\t\n+\n \t* trans-common.c (create_common): Do not fake TREE_ASM_WRITTEN.\n \t* trans-decl.c (gfc_finish_cray_pointee): Likewise.\n "}, {"sha": "5361d86c5435f3ddf0128dbc5ed90ac876191845", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 128, "deletions": 24, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=91077d4ef9381c153b939267cecd8e9c80bc7ec8", "patch": "@@ -806,20 +806,45 @@ optimize_op (gfc_expr *e)\n {\n   gfc_intrinsic_op op = e->value.op.op;\n \n+  /* Only use new-style comparisions.  */\n+  switch(op)\n+    {\n+    case INTRINSIC_EQ_OS:\n+      op = INTRINSIC_EQ;\n+      break;\n+\n+    case INTRINSIC_GE_OS:\n+      op = INTRINSIC_GE;\n+      break;\n+\n+    case INTRINSIC_LE_OS:\n+      op = INTRINSIC_LE;\n+      break;\n+\n+    case INTRINSIC_NE_OS:\n+      op = INTRINSIC_NE;\n+      break;\n+\n+    case INTRINSIC_GT_OS:\n+      op = INTRINSIC_GT;\n+      break;\n+\n+    case INTRINSIC_LT_OS:\n+      op = INTRINSIC_LT;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n   switch (op)\n     {\n     case INTRINSIC_EQ:\n-    case INTRINSIC_EQ_OS:\n     case INTRINSIC_GE:\n-    case INTRINSIC_GE_OS:\n     case INTRINSIC_LE:\n-    case INTRINSIC_LE_OS:\n     case INTRINSIC_NE:\n-    case INTRINSIC_NE_OS:\n     case INTRINSIC_GT:\n-    case INTRINSIC_GT_OS:\n     case INTRINSIC_LT:\n-    case INTRINSIC_LT_OS:\n       return optimize_comparison (e, op);\n \n     default:\n@@ -829,6 +854,63 @@ optimize_op (gfc_expr *e)\n   return false;\n }\n \n+\n+/* Return true if a constant string contains only blanks.  */\n+\n+static bool\n+empty_string (gfc_expr *e)\n+{\n+  int i;\n+\n+  if (e->ts.type != BT_CHARACTER || e->expr_type != EXPR_CONSTANT)\n+    return false;\n+\n+  for (i=0; i < e->value.character.length; i++)\n+    {\n+      if (e->value.character.string[i] != ' ')\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Insert a call to the intrinsic len_trim. Use a different name for\n+   the symbol tree so we don't run into trouble when the user has\n+   renamed len_trim for some reason.  */\n+\n+static gfc_expr*\n+get_len_trim_call (gfc_expr *str, int kind)\n+{\n+  gfc_expr *fcn;\n+  gfc_actual_arglist *actual_arglist, *next;\n+\n+  fcn = gfc_get_expr ();\n+  fcn->expr_type = EXPR_FUNCTION;\n+  fcn->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_LEN_TRIM);\n+  actual_arglist = gfc_get_actual_arglist ();\n+  actual_arglist->expr = str;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_get_int_expr (gfc_default_integer_kind, NULL, kind);\n+  actual_arglist->next = next;\n+\n+  fcn->value.function.actual = actual_arglist;\n+  fcn->where = str->where;\n+  fcn->ts.type = BT_INTEGER;\n+  fcn->ts.kind = gfc_charlen_int_kind;\n+\n+  gfc_get_sym_tree (\"__internal_len_trim\", current_ns, &fcn->symtree, false);\n+  fcn->symtree->n.sym->ts = fcn->ts;\n+  fcn->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  fcn->symtree->n.sym->attr.function = 1;\n+  fcn->symtree->n.sym->attr.elemental = 1;\n+  fcn->symtree->n.sym->attr.referenced = 1;\n+  fcn->symtree->n.sym->attr.access = ACCESS_PRIVATE;\n+  gfc_commit_symbol (fcn->symtree->n.sym);\n+\n+  return fcn;\n+}\n+\n /* Optimize expressions for equality.  */\n \n static bool\n@@ -872,6 +954,45 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n   if (e->rank > 0)\n     return change;\n \n+  /* Replace a == '' with len_trim(a) == 0 and a /= '' with\n+     len_trim(a) != 0 */\n+  if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER\n+      && (op == INTRINSIC_EQ || op == INTRINSIC_NE))\n+    {\n+      bool empty_op1, empty_op2;\n+      empty_op1 = empty_string (op1);\n+      empty_op2 = empty_string (op2);\n+\n+      if (empty_op1 || empty_op2)\n+\t{\n+\t  gfc_expr *fcn;\n+\t  gfc_expr *zero;\n+\t  gfc_expr *str;\n+\n+\t  /* This can only happen when an error for comparing\n+\t     characters of different kinds has already been issued.  */\n+\t  if (empty_op1 && empty_op2)\n+\t    return false;\n+\n+\t  zero = gfc_get_int_expr (gfc_charlen_int_kind, &e->where, 0);\n+\t  str = empty_op1 ? op2 : op1;\n+\n+\t  fcn = get_len_trim_call (str, gfc_charlen_int_kind);\n+\n+\n+\t  if (empty_op1)\n+\t    gfc_free_expr (op1);\n+\t  else\n+\t    gfc_free_expr (op2);\n+\n+\t  op1 = fcn;\n+\t  op2 = zero;\n+\t  e->value.op.op1 = fcn;\n+\t  e->value.op.op2 = zero;\n+\t}\n+    }\n+\n+\n   /* Don't compare REAL or COMPLEX expressions when honoring NaNs.  */\n \n   if (flag_finite_math_only\n@@ -945,32 +1066,26 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \t  switch (op)\n \t    {\n \t    case INTRINSIC_EQ:\n-\t    case INTRINSIC_EQ_OS:\n \t      result = eq == 0;\n \t      break;\n \t      \n \t    case INTRINSIC_GE:\n-\t    case INTRINSIC_GE_OS:\n \t      result = eq >= 0;\n \t      break;\n \n \t    case INTRINSIC_LE:\n-\t    case INTRINSIC_LE_OS:\n \t      result = eq <= 0;\n \t      break;\n \n \t    case INTRINSIC_NE:\n-\t    case INTRINSIC_NE_OS:\n \t      result = eq != 0;\n \t      break;\n \n \t    case INTRINSIC_GT:\n-\t    case INTRINSIC_GT_OS:\n \t      result = eq > 0;\n \t      break;\n \n \t    case INTRINSIC_LT:\n-\t    case INTRINSIC_LT_OS:\n \t      result = eq < 0;\n \t      break;\n \t      \n@@ -1002,7 +1117,6 @@ optimize_trim (gfc_expr *e)\n   gfc_expr *a;\n   gfc_ref *ref;\n   gfc_expr *fcn;\n-  gfc_actual_arglist *actual_arglist, *next;\n   gfc_ref **rr = NULL;\n \n   /* Don't do this optimization within an argument list, because\n@@ -1051,17 +1165,7 @@ optimize_trim (gfc_expr *e)\n \n   /* Build the function call to len_trim(x, gfc_defaul_integer_kind).  */\n \n-  fcn = gfc_get_expr ();\n-  fcn->expr_type = EXPR_FUNCTION;\n-  fcn->value.function.isym =\n-    gfc_intrinsic_function_by_id (GFC_ISYM_LEN_TRIM);\n-  actual_arglist = gfc_get_actual_arglist ();\n-  actual_arglist->expr = gfc_copy_expr (e);\n-  next = gfc_get_actual_arglist ();\n-  next->expr = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n-\t\t\t\t gfc_default_integer_kind);\n-  actual_arglist->next = next;\n-  fcn->value.function.actual = actual_arglist;\n+  fcn = get_len_trim_call (gfc_copy_expr (e), gfc_default_integer_kind);\n \n   /* Set the end of the reference to the call to len_trim.  */\n "}, {"sha": "526e3971fc949606de715e78cfd37a951a98a6a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91077d4ef9381c153b939267cecd8e9c80bc7ec8", "patch": "@@ -1,3 +1,8 @@\n+2012-05-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/52537\n+\t* gfortran.dg/string_compare_4.f90:  New test.\n+\n 2012-05-11  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/debug/dwarf2/nested-3.C: Allow for ! comments."}, {"sha": "80f1057cff6c9f64c881437fb56730b0aa08e017", "filename": "gcc/testsuite/gfortran.dg/string_compare_4.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_compare_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91077d4ef9381c153b939267cecd8e9c80bc7ec8/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_compare_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_compare_4.f90?ref=91077d4ef9381c153b939267cecd8e9c80bc7ec8", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-options \"-ffrontend-optimize -fdump-fortran-original\" }\n+! PR fortran/52537 - optimize comparisons with empty strings\n+program main\n+  implicit none\n+  character(len=10) :: a\n+  character(len=30) :: line\n+  line = 'x'\n+  read (unit=line,fmt='(A)') a\n+  if (trim(a) == '') print *,\"empty\"\n+  call foo(a)\n+  if (trim(a) == '    ') print *,\"empty\"\n+contains\n+  subroutine foo(b)\n+    character(*) :: b\n+    if (b /= '   ') print *,\"full\"\n+  end subroutine foo\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_string_len_trim\" 3 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}