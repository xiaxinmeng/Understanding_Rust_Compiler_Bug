{"sha": "e46858e4eeee45d35ca4a7df1996186fe884879b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ2ODU4ZTRlZWVlNDVkMzVjYTRhN2RmMTk5NjE4NmZlODg0ODc5Yg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-09-24T11:34:13Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-09-29T07:26:07Z"}, "message": "switch conversion: make a rapid speed up\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/96979\n\t* tree-switch-conversion.c (jump_table_cluster::can_be_handled):\n\tMake a fast bail out.\n\t(bit_test_cluster::can_be_handled): Likewise here.\n\t* tree-switch-conversion.h (get_range): Use wi::to_wide instead\n\tof a folding.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/96979\n\t* g++.dg/tree-ssa/pr96979.C: New test.", "tree": {"sha": "4a6167125770535ea2e0c7d1ff4bb527890ef671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a6167125770535ea2e0c7d1ff4bb527890ef671"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e46858e4eeee45d35ca4a7df1996186fe884879b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e46858e4eeee45d35ca4a7df1996186fe884879b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e46858e4eeee45d35ca4a7df1996186fe884879b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e46858e4eeee45d35ca4a7df1996186fe884879b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ffe56c01e4a9e80a3b3c4f5beb86d80a0663db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ffe56c01e4a9e80a3b3c4f5beb86d80a0663db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37ffe56c01e4a9e80a3b3c4f5beb86d80a0663db"}], "stats": {"total": 92, "additions": 79, "deletions": 13}, "files": [{"sha": "ec0f57a8548e08c6b2580cb79dae39fb5a3e3959", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr96979.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46858e4eeee45d35ca4a7df1996186fe884879b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr96979.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46858e4eeee45d35ca4a7df1996186fe884879b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr96979.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr96979.C?ref=e46858e4eeee45d35ca4a7df1996186fe884879b", "patch": "@@ -0,0 +1,48 @@\n+/* PR tree-optimization/96979 */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++17 -O2\" } */\n+\n+using u64 = unsigned long long;\n+\n+constexpr inline u64\n+foo (const char *str) noexcept\n+{\n+  u64 value = 0xcbf29ce484222325ULL;\n+  for (u64 i = 0; str[i]; i++)\n+    value = (value ^ u64(str[i])) * 0x100000001b3ULL;\n+  return value;\n+}\n+\n+struct V\n+{\n+  enum W\n+  {\n+#define A(n) n,\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3) B(n##4) B(n##5) B(n##6) B(n##7) B(n##8) B(n##9)\n+#define D(n) C(n##0) C(n##1) C(n##2) C(n##3) C(n##4) C(n##5) C(n##6) C(n##7) C(n##8) C(n##9)\n+#define E D(foo1) D(foo2) D(foo3)\n+    E\n+    last\n+  };\n+\n+  constexpr static W\n+  bar (const u64 h) noexcept\n+  {\n+    switch (h)\n+      {\n+#undef A\n+#define F(n) #n\n+#define A(n) case foo (F(n)): return n;\n+        E\n+      }\n+    return last;\n+  }\n+};\n+\n+int\n+baz (const char *s)\n+{\n+  const u64 h = foo (s);\n+  return V::bar (h);\n+}"}, {"sha": "03a1fe632d0a20720be5176662c64593aa5875f1", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46858e4eeee45d35ca4a7df1996186fe884879b/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46858e4eeee45d35ca4a7df1996186fe884879b/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=e46858e4eeee45d35ca4a7df1996186fe884879b", "patch": "@@ -1268,17 +1268,25 @@ jump_table_cluster::can_be_handled (const vec<cluster *> &clusters,\n   if (range == 0)\n     return false;\n \n+  if (range > HOST_WIDE_INT_M1U / 100)\n+    return false;\n+\n+  unsigned HOST_WIDE_INT lhs = 100 * range;\n+  if (lhs < range)\n+    return false;\n+\n+  /* First make quick guess as each cluster\n+     can add at maximum 2 to the comparison_count.  */\n+  if (lhs > 2 * max_ratio * (end - start + 1))\n+    return false;\n+\n   unsigned HOST_WIDE_INT comparison_count = 0;\n   for (unsigned i = start; i <= end; i++)\n     {\n       simple_cluster *sc = static_cast<simple_cluster *> (clusters[i]);\n       comparison_count += sc->m_range_p ? 2 : 1;\n     }\n \n-  unsigned HOST_WIDE_INT lhs = 100 * range;\n-  if (lhs < range)\n-    return false;\n-\n   return lhs <= max_ratio * comparison_count;\n }\n \n@@ -1364,12 +1372,12 @@ bit_test_cluster::can_be_handled (unsigned HOST_WIDE_INT range,\n {\n   /* Check overflow.  */\n   if (range == 0)\n-    return 0;\n+    return false;\n \n   if (range >= GET_MODE_BITSIZE (word_mode))\n     return false;\n \n-  return uniq <= 3;\n+  return uniq <= m_max_case_bit_tests;\n }\n \n /* Return true when cluster starting at START and ending at END (inclusive)\n@@ -1379,6 +1387,7 @@ bool\n bit_test_cluster::can_be_handled (const vec<cluster *> &clusters,\n \t\t\t\t  unsigned start, unsigned end)\n {\n+  auto_vec<int, m_max_case_bit_tests> dest_bbs;\n   /* For algorithm correctness, bit test for a single case must return\n      true.  We bail out in is_beneficial if it's called just for\n      a single case.  */\n@@ -1387,15 +1396,25 @@ bit_test_cluster::can_be_handled (const vec<cluster *> &clusters,\n \n   unsigned HOST_WIDE_INT range = get_range (clusters[start]->get_low (),\n \t\t\t\t\t    clusters[end]->get_high ());\n-  auto_bitmap dest_bbs;\n+\n+  /* Make a guess first.  */\n+  if (!can_be_handled (range, m_max_case_bit_tests))\n+    return false;\n \n   for (unsigned i = start; i <= end; i++)\n     {\n       simple_cluster *sc = static_cast<simple_cluster *> (clusters[i]);\n-      bitmap_set_bit (dest_bbs, sc->m_case_bb->index);\n+      /* m_max_case_bit_tests is very small integer, thus the operation\n+\t is constant. */\n+      if (!dest_bbs.contains (sc->m_case_bb->index))\n+\t{\n+\t  if (dest_bbs.length () >= m_max_case_bit_tests)\n+\t    return false;\n+\t  dest_bbs.quick_push (sc->m_case_bb->index);\n+\t}\n     }\n \n-  return can_be_handled (range, bitmap_count_bits (dest_bbs));\n+  return true;\n }\n \n /* Return true when COUNT of cases of UNIQ labels is beneficial for bit test"}, {"sha": "dbfd9eecba22c9091d0e3b6ebae8ec1912977283", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46858e4eeee45d35ca4a7df1996186fe884879b/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46858e4eeee45d35ca4a7df1996186fe884879b/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=e46858e4eeee45d35ca4a7df1996186fe884879b", "patch": "@@ -84,11 +84,10 @@ class cluster\n      then return 0.  */\n   static unsigned HOST_WIDE_INT get_range (tree low, tree high)\n   {\n-    tree r = fold_build2 (MINUS_EXPR, TREE_TYPE (low), high, low);\n-    if (!tree_fits_uhwi_p (r))\n+    wide_int w = wi::to_wide (high) - wi::to_wide (low);\n+    if (wi::neg_p (w, TYPE_SIGN (TREE_TYPE (low))) || !wi::fits_uhwi_p (w))\n       return 0;\n-\n-    return tree_to_uhwi (r) + 1;\n+    return w.to_uhwi () + 1;\n   }\n \n   /* Case label.  */"}]}