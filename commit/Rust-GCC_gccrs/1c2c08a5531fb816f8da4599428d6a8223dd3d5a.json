{"sha": "1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMyYzA4YTU1MzFmYjgxNmY4ZGE0NTk5NDI4ZDZhODIyM2RkM2Q1YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-06-16T02:51:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-16T02:51:01Z"}, "message": "method.c (hack_identifier): Don't let a class template out.\n\n\t* method.c (hack_identifier): Don't let a class template out.\n\t* call.c (check_dtor_name): Split out.\n\t(build_scoped_method_call): Use it.\n\t(build_method_call): Use it.\n\t* init.c (build_offset_ref): Use it.\n\t* typeck.c (build_static_cast): Fix handling of pointers to members.\n\t* decl.c (finish_function): Just return nothing from a constructor.\n\t* typeck.c (c_expand_return): Complain about returning a void\n\texpression from a destructor.\n\nFrom-SVN: r20521", "tree": {"sha": "fa90bdc903bf55966857420c39e6ce0bdf3f83fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa90bdc903bf55966857420c39e6ce0bdf3f83fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/comments", "author": null, "committer": null, "parents": [{"sha": "8b45da67d0eaa8d7fec5913d9439d88865edfc55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b45da67d0eaa8d7fec5913d9439d88865edfc55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b45da67d0eaa8d7fec5913d9439d88865edfc55"}], "stats": {"total": 171, "additions": 89, "deletions": 82}, "files": [{"sha": "ea7f27190458c09c1da401319757680af8d37ac3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "patch": "@@ -1,3 +1,18 @@\n+1998-06-16  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (hack_identifier): Don't let a class template out.\n+\n+\t* call.c (check_dtor_name): Split out.\n+\t(build_scoped_method_call): Use it.\n+\t(build_method_call): Use it.\n+\t* init.c (build_offset_ref): Use it.\n+\n+\t* typeck.c (build_static_cast): Fix handling of pointers to members.\n+\n+\t* decl.c (finish_function): Just return nothing from a constructor.\n+\t* typeck.c (c_expand_return): Complain about returning a void\n+\texpression from a destructor.\n+\n 1998-06-13  Mark Mitchell  <mark@markmitchell.com>\n \n \t* class.c (alter_access): Accept a BINFO explaining how to get"}, {"sha": "899989740ed419d9dbb17d2532f6b613b1ba4016", "filename": "gcc/cp/call.c", "status": "modified", "additions": 36, "deletions": 49, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "patch": "@@ -340,6 +340,35 @@ resolve_scope_to_name (outer_type, inner_stuff)\n   return tmp;\n }\n \n+/* Returns nonzero iff the destructor name specified in NAME\n+   (a BIT_NOT_EXPR) matches BASETYPE.  The operand of NAME can take many\n+   forms...  */\n+\n+int\n+check_dtor_name (basetype, name)\n+     tree basetype, name;\n+{\n+  name = TREE_OPERAND (name, 0);\n+\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    name = TREE_TYPE (name);\n+  else if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+    /* OK */;\n+  else if (TREE_CODE (name) == IDENTIFIER_NODE)\n+    {\n+      if (IS_AGGR_TYPE (basetype) && name == constructor_name (basetype))\n+\tname = basetype;\n+      else\n+\tname = get_type_value (name);\n+    }\n+  else\n+    my_friendly_abort (980605);\n+\n+  if (name && TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (name))\n+    return 1;\n+  return 0;\n+}\n+\n /* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.\n    This is how virtual function calls are avoided.  */\n \n@@ -386,31 +415,9 @@ build_scoped_method_call (exp, basetype, name, parms)\n     binfo = NULL_TREE;\n \n   /* Check the destructor call syntax.  */\n-  if (TREE_CODE (name) == BIT_NOT_EXPR)\n-    {\n-      tmp = TREE_OPERAND (name, 0);\n-\n-      if (TREE_CODE (tmp) == TYPE_DECL)\n-\ttmp = TREE_TYPE (tmp);\n-      else if (TREE_CODE_CLASS (TREE_CODE (tmp)) == 't')\n-\t/* OK */;\n-      else if (TREE_CODE (tmp) == IDENTIFIER_NODE)\n-\t{\n-\t  if (IS_AGGR_TYPE (basetype) && tmp == constructor_name (basetype))\n-\t    tmp = basetype;\n-\t  else\n-\t    tmp = get_type_value (tmp);\n-\t}\n-      else\n-\tmy_friendly_abort (980605);\n-      \n-      if (! (tmp && TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (tmp)))\n-\t{\n-\t  cp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n-\t\t    basetype, TREE_OPERAND (name, 0));\n-\t  return error_mark_node;\n-\t}\n-    }\n+  if (TREE_CODE (name) == BIT_NOT_EXPR && ! check_dtor_name (basetype, name))\n+    cp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n+\t      basetype, TREE_OPERAND (name, 0));\n \n   /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n      that explicit ~int is caught in the parser; this deals with typedefs\n@@ -645,36 +652,16 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n-      tree tmp;\n-\n-      tmp = name = TREE_OPERAND (name, 0);\n-\n       if (parms)\n \terror (\"destructors take no parameters\");\n       basetype = TREE_TYPE (instance);\n       if (TREE_CODE (basetype) == REFERENCE_TYPE)\n \tbasetype = TREE_TYPE (basetype);\n \n-      if (TREE_CODE (tmp) == TYPE_DECL)\n-\ttmp = TREE_TYPE (tmp);\n-      else if (TREE_CODE_CLASS (TREE_CODE (tmp)) == 't')\n-\t/* OK */;\n-      else if (TREE_CODE (tmp) == IDENTIFIER_NODE)\n-\t{\n-\t  if (IS_AGGR_TYPE (basetype) && tmp == constructor_name (basetype))\n-\t    tmp = basetype;\n-\t  else\n-\t    tmp = get_type_value (tmp);\n-\t}\n-      else\n-\tmy_friendly_abort (980605);\n-\n-      if (! (tmp && TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (tmp)))\n-\t{\n-\t  cp_error (\"destructor name `~%T' does not match type `%T' of expression\",\n-\t\t    name, basetype);\n-\t  return cp_convert (void_type_node, instance);\n-\t}\n+      if (! check_dtor_name (basetype, name))\n+\tcp_error\n+\t  (\"destructor name `~%T' does not match type `%T' of expression\",\n+\t   TREE_OPERAND (name, 0), basetype);\n \n       if (! TYPE_HAS_DESTRUCTOR (complete_type (basetype)))\n \treturn cp_convert (void_type_node, instance);"}, {"sha": "20dfdf7828634c0b7ba5b1c4c532e04d1e8e7b7f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "patch": "@@ -12599,7 +12599,8 @@ finish_function (lineno, call_poplevel, nested)\n \t\t  expand_end_bindings (decls, decls != NULL_TREE, 0);\n \t\t  poplevel (decls != NULL_TREE, 0, 0);\n \t\t}\n-\t      c_expand_return (current_class_ptr);\n+\t      /* c_expand_return knows to return 'this' from a constructor.  */\n+\t      c_expand_return (NULL_TREE);\n \t    }\n \t  else if (TREE_CODE (TREE_TYPE (DECL_RESULT (current_function_decl))) != VOID_TYPE\n \t\t   && return_label != NULL_RTX)\n@@ -12666,7 +12667,8 @@ finish_function (lineno, call_poplevel, nested)\n \t      poplevel (decls != NULL_TREE, 1, 0);\n \t    }\n \n-\t  c_expand_return (current_class_ptr);\n+\t  /* c_expand_return knows to return 'this' from a constructor.  */\n+\t  c_expand_return (NULL_TREE);\n \n \t  current_function_assigns_this = 0;\n \t  current_function_just_assigned_this = 0;"}, {"sha": "84015b07efddae1088a1b11f243ab3421bcfeba7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "patch": "@@ -1521,7 +1521,6 @@ build_offset_ref (type, name)\n {\n   tree decl, fnfields, fields, t = error_mark_node;\n   tree basebinfo = NULL_TREE;\n-  int dtor = 0;\n   tree orig_name = name;\n \n   /* class templates can come in as TEMPLATE_DECLs here.  */\n@@ -1553,12 +1552,17 @@ build_offset_ref (type, name)\n \n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n-      dtor = 1;\n-      name = TREE_OPERAND (name, 0);\n+      if (! check_dtor_name (type, name))\n+\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n+\t\t  type, TREE_OPERAND (name, 0));\n+      name = dtor_identifier;\n     }\n-\n-  if (name == constructor_name_full (type))\n-    name = constructor_name (type);\n+#if 0\n+  /* I think this is wrong, but the draft is unclear.  --jason 6/15/98 */\n+  else if (name == constructor_name_full (type)\n+\t   || name == constructor_name (type))\n+    name = ctor_identifier;\n+#endif\n \n   if (TYPE_SIZE (complete_type (type)) == 0)\n     {\n@@ -1598,18 +1602,6 @@ build_offset_ref (type, name)\n   else\n     decl = current_class_ref;\n \n-  if (constructor_name (BINFO_TYPE (basebinfo)) == name)\n-    {\n-      if (dtor)\n-\tname = dtor_identifier;\n-      else\n-\tname = ctor_identifier;\n-    }\n-  else\n-    if (dtor)\n-      my_friendly_abort (999);\n-\n-    \n   fnfields = lookup_fnfields (basebinfo, name, 1);\n   fields = lookup_field (basebinfo, name, 0, 0);\n "}, {"sha": "14148700ce0d9c49923228015e4ce8e10db2859b", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "patch": "@@ -1847,6 +1847,11 @@ hack_identifier (value, name)\n   else if (TREE_CODE (value) == NAMESPACE_DECL)\n     /* A namespace is not really expected here; this is likely illegal code. */\n     return value;\n+  else if (DECL_CLASS_TEMPLATE_P (value))\n+    {\n+      cp_error (\"use of class template `%T' as expression\", value);\n+      value = error_mark_node;\n+    }\n   else\n     mark_used (value);\n "}, {"sha": "b038a860dadf002d37e79b8a02f6798b4f747143", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c2c08a5531fb816f8da4599428d6a8223dd3d5a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1c2c08a5531fb816f8da4599428d6a8223dd3d5a", "patch": "@@ -4774,7 +4774,11 @@ unary_complex_lvalue (code, arg)\n \n       /* Check all this code for right semantics.  */\t\n       if (TREE_CODE (t) == FUNCTION_DECL)\n-\treturn build_unary_op (ADDR_EXPR, t, 0);\n+\t{\n+\t  if (DECL_DESTRUCTOR_P (t))\n+\t    cp_error (\"taking address of destructor\");\n+\t  return build_unary_op (ADDR_EXPR, t, 0);\n+\t}\n       if (TREE_CODE (t) == VAR_DECL)\n \treturn build_unary_op (ADDR_EXPR, t, 0);\n       else\n@@ -5422,8 +5426,8 @@ build_static_cast (type, expr)\n \t      >= TYPE_READONLY (TREE_TYPE (TREE_TYPE (intype))))\n \t  && (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (type)))\n \t      >= TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (intype))))\n-\t  && (binfo = get_binfo (TYPE_OFFSET_BASETYPE (intype),\n-\t\t\t\t TYPE_OFFSET_BASETYPE (type), 0))\n+\t  && (binfo = get_binfo (TYPE_OFFSET_BASETYPE (TREE_TYPE (type)),\n+\t\t\t\t TYPE_OFFSET_BASETYPE (TREE_TYPE (intype)), 0))\n \t  && ! TREE_VIA_VIRTUAL (binfo))\n \tok = 1;\n     }\n@@ -7206,16 +7210,19 @@ c_expand_return (retval)\n       return;\n     }\n \n-  if (retval == NULL_TREE)\n+  if (dtor_label)\n     {\n-      /* A non-named return value does not count.  */\n+      if (retval)\n+\terror (\"returning a value from a destructor\");\n \n       /* Can't just return from a destructor.  */\n-      if (dtor_label)\n-\t{\n-\t  expand_goto (dtor_label);\n-\t  return;\n-\t}\n+      expand_goto (dtor_label);\n+      return;\n+    }\n+\n+  if (retval == NULL_TREE)\n+    {\n+      /* A non-named return value does not count.  */\n \n       if (DECL_CONSTRUCTOR_P (current_function_decl))\n \tretval = current_class_ptr;\n@@ -7242,13 +7249,12 @@ c_expand_return (retval)\n \t  return;\n \t}\n     }\n-  else if (DECL_CONSTRUCTOR_P (current_function_decl)\n-\t   && retval != current_class_ptr)\n+  else if (DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n       if (flag_this_is_variable)\n \terror (\"return from a constructor: use `this = ...' instead\");\n       else\n-\terror (\"return from a constructor\");\n+\terror (\"returning a value from a constructor\");\n       retval = current_class_ptr;\n     }\n "}]}