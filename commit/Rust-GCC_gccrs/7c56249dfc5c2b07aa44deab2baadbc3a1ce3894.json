{"sha": "7c56249dfc5c2b07aa44deab2baadbc3a1ce3894", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M1NjI0OWRmYzVjMmIwN2FhNDRkZWFiMmJhYWRiYzNhMWNlMzg5NA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1992-07-22T20:02:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1992-07-22T20:02:29Z"}, "message": "(registers_ok_for_ldd_peep, addrs_ok_for_ldd_peep):\n\nFunctions renamed from registers_ok_for_ldd and\nmemory_ok_for_ldd repectively.  All callers changed.\n(register_ok_for_ldd): New function to determine if a register\nis a pseudo or the first register in a hard register pair.\n(mem_aligned_8): No longer static.  Return 0 instead of aborting\nwhen presented with an rtx which is not a MEM.\n(eligible_for_epilogue_delay): Use in_uncond_branch_delay since this\nis an unconditional branch.\n\nFrom-SVN: r1662", "tree": {"sha": "a5b4a961cea40d672a851c4adea1a8d7ca06e376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5b4a961cea40d672a851c4adea1a8d7ca06e376"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894/comments", "author": null, "committer": null, "parents": [{"sha": "198586008bed3f282b57bc5ef40030f0534e293a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198586008bed3f282b57bc5ef40030f0534e293a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/198586008bed3f282b57bc5ef40030f0534e293a"}], "stats": {"total": 30, "additions": 25, "deletions": 5}, "files": [{"sha": "2ebeb6dd5cf5c77c0ae5c2acb5f006ee197b3712", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7c56249dfc5c2b07aa44deab2baadbc3a1ce3894", "patch": "@@ -498,7 +498,7 @@ eligible_for_epilogue_delay (trial, slot)\n   if (leaf_function)\n     {\n       if (leaf_return_peephole_ok ())\n-\treturn (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_TRUE);\n+\treturn (get_attr_in_uncond_branch_delay (trial) == IN_BRANCH_DELAY_TRUE);\n       return 0;\n     }\n \n@@ -983,7 +983,7 @@ singlemove_string (operands)\n    aligned at least to a 8-byte boundary.  This should only be called\n    for memory accesses whose size is 8 bytes or larger.  */\n \n-static int\n+int\n mem_aligned_8 (mem)\n      register rtx mem;\n {\n@@ -992,7 +992,7 @@ mem_aligned_8 (mem)\n   register rtx offset;\n \n   if (GET_CODE (mem) != MEM)\n-    abort ();\t/* It's gotta be a MEM! */\n+    return 0;\t/* It's gotta be a MEM! */\n \n   addr = XEXP (mem, 0);\n \n@@ -2596,7 +2596,7 @@ output_arc_profiler (arcno, insert_after)\n    abort if we are passed pseudo registers.  */\n \n int\n-registers_ok_for_ldd (reg1, reg2)\n+registers_ok_for_ldd_peep (reg1, reg2)\n      rtx reg1, reg2;\n {\n \n@@ -2631,7 +2631,7 @@ registers_ok_for_ldd (reg1, reg2)\n    need only check that the offset for addr1 % 8 == 0.  */\n \n int\n-memory_ok_for_ldd (addr1, addr2)\n+addrs_ok_for_ldd_peep (addr1, addr2)\n       rtx addr1, addr2;\n {\n   int reg1, offset1;\n@@ -2689,6 +2689,26 @@ memory_ok_for_ldd (addr1, addr2)\n      instructions.  */\n   return 1;\n }\n+\n+/* Return 1 if reg is a pseudo, or is the first register in \n+   a hard register pair.  This makes it a candidate for use in\n+   ldd and std insns.  */\n+\n+int\n+register_ok_for_ldd (reg)\n+     rtx reg;\n+{\n+\n+  /* We might have been passed a SUBREG.  */\n+  if (GET_CODE (reg) != REG) \n+    return 0;\n+\n+  if (REGNO (reg) < FIRST_PSEUDO_REGISTER)\n+    return (REGNO (reg) % 2 == 0);\n+  else \n+    return 1;\n+\n+}\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified."}]}