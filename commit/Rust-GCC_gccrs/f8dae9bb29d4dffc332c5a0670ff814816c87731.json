{"sha": "f8dae9bb29d4dffc332c5a0670ff814816c87731", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkYWU5YmIyOWQ0ZGZmYzMzMmM1YTA2NzBmZjgxNDgxNmM4NzczMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T08:36:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T08:36:45Z"}, "message": "[multiple changes]\n\n2015-05-12  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting.\n\n2015-05-12  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: If we want to invoke gnatmake (gnatclean) with\n\t-P, then check if gprbuild (gprclean) is available; if it is,\n\tuse gprbuild (gprclean) instead of gnatmake (gnatclean).\n\n2015-05-12  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Add flag -gnatd.3 to output diagnostic info from\n\tExp_Unst.\n\t* einfo.ad, einfo.adb: Reorganize (and remove most of) flags used by\n\tExp_Unst.\n\t* exp_ch6.adb (Unest_Bodies): Table for delayed calls to\n\tUnnest_Subprogram (Expand_N_Subprogram_Body): Add entry to table\n\tfor later call instead of calling Unnest_Subprogram directly\n\t(Initialize): New procedure (Unnest_Subprograms): New procedure\n\t* exp_ch6.ads (Add_Extra_Actual_To_Call): Move into proper\n\talpha order.\n\t(Initialize): New procedure.\n\t(Unnest_Subprograms): New procedure.\n\t* exp_unst.adb (Unnest_Subprogram): Major rewrite, moving\n\tall processing to this routine which is now called late\n\tafter instantiating bodies. Fully handles the case of generic\n\tinstantiations now.\n\t* exp_unst.ads: Major rewrite, moving all processing to\n\tUnnest_Subprogram.\n\t* frontend.adb (Frontend): Add call to Exp_Ch6.Initialize.\n\t(Frontend): Add call to Unnest_Subprograms.\n\t* sem_ch8.adb (Find_Direct_Name): Back to old calling sequence\n\tfor Check_Nested_Access.\n\t* sem_util.adb (Build_Default_Subtype): Minor reformatting\n\t(Check_Nested_Access): Back to original VM-only form (we\n\tnow do all the processing for Unnest_Subprogram at the time\n\tit is called.\n\t(Denotes_Same_Object): Minor reformatting\n\t(Note_Possible_Modification): Old calling sequence for\n\tCheck_Nested_Access.\n\t* sem_util.ads (Check_Nested_Access): Back to original VM-only\n\tform (we now do all the processing for Unnest_Subprogram at the\n\ttime it is called.\n\nFrom-SVN: r223043", "tree": {"sha": "57218611df0267da5328f2edf73b0d2ae8c2c482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57218611df0267da5328f2edf73b0d2ae8c2c482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8dae9bb29d4dffc332c5a0670ff814816c87731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dae9bb29d4dffc332c5a0670ff814816c87731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8dae9bb29d4dffc332c5a0670ff814816c87731", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dae9bb29d4dffc332c5a0670ff814816c87731/comments", "author": null, "committer": null, "parents": [{"sha": "73cc8f6230c672fab16f0d43a661c62744b5f0cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73cc8f6230c672fab16f0d43a661c62744b5f0cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73cc8f6230c672fab16f0d43a661c62744b5f0cb"}], "stats": {"total": 2078, "additions": 1197, "deletions": 881}, "files": [{"sha": "10af3d88788162469ff456e404a59dfc10deb5e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -1,3 +1,48 @@\n+2015-05-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting.\n+\n+2015-05-12  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: If we want to invoke gnatmake (gnatclean) with\n+\t-P, then check if gprbuild (gprclean) is available; if it is,\n+\tuse gprbuild (gprclean) instead of gnatmake (gnatclean).\n+\n+2015-05-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Add flag -gnatd.3 to output diagnostic info from\n+\tExp_Unst.\n+\t* einfo.ad, einfo.adb: Reorganize (and remove most of) flags used by\n+\tExp_Unst.\n+\t* exp_ch6.adb (Unest_Bodies): Table for delayed calls to\n+\tUnnest_Subprogram (Expand_N_Subprogram_Body): Add entry to table\n+\tfor later call instead of calling Unnest_Subprogram directly\n+\t(Initialize): New procedure (Unnest_Subprograms): New procedure\n+\t* exp_ch6.ads (Add_Extra_Actual_To_Call): Move into proper\n+\talpha order.\n+\t(Initialize): New procedure.\n+\t(Unnest_Subprograms): New procedure.\n+\t* exp_unst.adb (Unnest_Subprogram): Major rewrite, moving\n+\tall processing to this routine which is now called late\n+\tafter instantiating bodies. Fully handles the case of generic\n+\tinstantiations now.\n+\t* exp_unst.ads: Major rewrite, moving all processing to\n+\tUnnest_Subprogram.\n+\t* frontend.adb (Frontend): Add call to Exp_Ch6.Initialize.\n+\t(Frontend): Add call to Unnest_Subprograms.\n+\t* sem_ch8.adb (Find_Direct_Name): Back to old calling sequence\n+\tfor Check_Nested_Access.\n+\t* sem_util.adb (Build_Default_Subtype): Minor reformatting\n+\t(Check_Nested_Access): Back to original VM-only form (we\n+\tnow do all the processing for Unnest_Subprogram at the time\n+\tit is called.\n+\t(Denotes_Same_Object): Minor reformatting\n+\t(Note_Possible_Modification): Old calling sequence for\n+\tCheck_Nested_Access.\n+\t* sem_util.ads (Check_Nested_Access): Back to original VM-only\n+\tform (we now do all the processing for Unnest_Subprogram at the\n+\ttime it is called.\n+\n 2015-05-12  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, freeze.adb, sem_ch6.adb: Minor reformatting."}, {"sha": "116fcfc6782546922b553ba97421cb810e98cbe6", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -157,7 +157,7 @@ package body Debug is\n \n    --  d.1  Enable unnesting of nested procedures\n    --  d.2  Allow statements in declarative part\n-   --  d.3\n+   --  d.3  Output debugging information from Exp_Unst\n    --  d.4\n    --  d.5\n    --  d.6\n@@ -755,6 +755,9 @@ package body Debug is\n    --       allowed, but in some debugging contexts (e.g. testing the circuit\n    --       for unnesting of procedures), it is useful to allow this.\n \n+   --  d.3  Output debugging information from Exp_Unst, including the name of\n+   --       any unreachable subprograms that get deleted.\n+\n    ------------------------------------------\n    -- Documentation for Binder Debug Flags --\n    ------------------------------------------"}, {"sha": "772195bd424c7a78ba4d1602799faacf926d097a", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -213,7 +213,6 @@ package body Einfo is\n    --    Stored_Constraint               Elist23\n \n    --    Related_Expression              Node24\n-   --    Uplevel_References              Elist24\n    --    Subps_Index                     Uint24\n \n    --    Interface_Alias                 Node25\n@@ -590,7 +589,7 @@ package body Einfo is\n \n    --    Is_Static_Type                  Flag281\n    --    Has_Nested_Subprogram           Flag282\n-   --    Uplevel_Reference_Noted         Flag283\n+   --    Is_Uplevel_Referenced_Entity    Flag283\n    --    Is_Unimplemented                Flag284\n \n    --    (unused)                        Flag285\n@@ -2418,7 +2417,6 @@ package body Einfo is\n \n    function Is_Static_Type (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id));\n       return Flag281 (Id);\n    end Is_Static_Type;\n \n@@ -2474,6 +2472,11 @@ package body Einfo is\n       return Flag144 (Id);\n    end Is_Unsigned_Type;\n \n+   function Is_Uplevel_Referenced_Entity (Id : E) return B is\n+   begin\n+      return Flag283 (Id);\n+   end Is_Uplevel_Referenced_Entity;\n+\n    function Is_Valued_Procedure (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -2684,8 +2687,10 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Ekind (Id) in Incomplete_Kind\n-           or else Ekind (Id) in Class_Wide_Kind\n-           or else Ekind (Id) = E_Abstract_State);\n+           or else\n+         Ekind (Id) in Class_Wide_Kind\n+           or else\n+         Ekind (Id) = E_Abstract_State);\n       return Node19 (Id);\n    end Non_Limited_View;\n \n@@ -3247,17 +3252,6 @@ package body Einfo is\n       return Node16 (Id);\n    end Unset_Reference;\n \n-   function Uplevel_Reference_Noted (Id : E) return B is\n-   begin\n-      return Flag283 (Id);\n-   end Uplevel_Reference_Noted;\n-\n-   function Uplevel_References (Id : E) return L is\n-   begin\n-      pragma Assert (Is_Subprogram (Id));\n-      return Elist24 (Id);\n-   end Uplevel_References;\n-\n    function Used_As_Generic_Actual (Id : E) return B is\n    begin\n       return Flag222 (Id);\n@@ -4458,11 +4452,6 @@ package body Einfo is\n       Set_Flag282 (Id, V);\n    end Set_Has_Nested_Subprogram;\n \n-   procedure Set_Has_Uplevel_Reference (Id : E; V : B := True) is\n-   begin\n-      Set_Flag215 (Id, V);\n-   end Set_Has_Uplevel_Reference;\n-\n    procedure Set_Has_Non_Standard_Rep (Id : E; V : B := True) is\n    begin\n       pragma Assert (Id = Base_Type (Id));\n@@ -4713,6 +4702,11 @@ package body Einfo is\n       Set_Flag72 (Id, V);\n    end Set_Has_Unknown_Discriminants;\n \n+   procedure Set_Has_Uplevel_Reference (Id : E; V : B := True) is\n+   begin\n+      Set_Flag215 (Id, V);\n+   end Set_Has_Uplevel_Reference;\n+\n    procedure Set_Has_Visible_Refinement (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n@@ -5423,6 +5417,15 @@ package body Einfo is\n       Set_Flag144 (Id, V);\n    end Set_Is_Unsigned_Type;\n \n+   procedure Set_Is_Uplevel_Referenced_Entity (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Constant, E_Variable)\n+          or else Is_Formal (Id)\n+          or else Is_Type (Id));\n+      Set_Flag283 (Id, V);\n+   end Set_Is_Uplevel_Referenced_Entity;\n+\n    procedure Set_Is_Valued_Procedure (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -5632,8 +5635,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Ekind (Id) in Incomplete_Kind\n-           or else Ekind (Id) = E_Abstract_State\n-           or else Ekind (Id) = E_Class_Wide_Type);\n+          or else Ekind_In (Id, E_Abstract_State, E_Class_Wide_Type));\n       Set_Node19 (Id, V);\n    end Set_Non_Limited_View;\n \n@@ -6224,17 +6226,6 @@ package body Einfo is\n       Set_Node16 (Id, V);\n    end Set_Unset_Reference;\n \n-   procedure Set_Uplevel_Reference_Noted (Id : E; V : B := True) is\n-   begin\n-      Set_Flag283 (Id, V);\n-   end Set_Uplevel_Reference_Noted;\n-\n-   procedure Set_Uplevel_References (Id : E; V : L) is\n-   begin\n-      pragma Assert (Is_Subprogram (Id));\n-      Set_Elist24 (Id, V);\n-   end Set_Uplevel_References;\n-\n    procedure Set_Used_As_Generic_Actual (Id : E; V : B := True) is\n    begin\n       Set_Flag222 (Id, V);\n@@ -7116,8 +7107,8 @@ package body Einfo is\n    function Has_Non_Limited_View (Id : E) return B is\n    begin\n       return (Ekind (Id) in Incomplete_Kind\n-          or else Ekind (Id) in Class_Wide_Kind\n-          or else Ekind (Id) = E_Abstract_State)\n+               or else Ekind (Id) in Class_Wide_Kind\n+               or else Ekind (Id) = E_Abstract_State)\n         and then Present (Non_Limited_View (Id));\n    end Has_Non_Limited_View;\n \n@@ -8802,6 +8793,7 @@ package body Einfo is\n       W (\"Is_Underlying_Record_View\",       Flag246 (Id));\n       W (\"Is_Unimplemented\",                Flag284 (Id));\n       W (\"Is_Unsigned_Type\",                Flag144 (Id));\n+      W (\"Is_Uplevel_Referenced_Entity\",    Flag283 (Id));\n       W (\"Is_Valued_Procedure\",             Flag127 (Id));\n       W (\"Is_Visible_Formal\",               Flag206 (Id));\n       W (\"Is_Visible_Lib_Unit\",             Flag116 (Id));\n@@ -8859,7 +8851,6 @@ package body Einfo is\n       W (\"Suppress_Value_Tracking_On_Call\", Flag217 (Id));\n       W (\"Treat_As_Volatile\",               Flag41  (Id));\n       W (\"Universal_Aliasing\",              Flag216 (Id));\n-      W (\"Uplevel_Reference_Noted\",         Flag283 (Id));\n       W (\"Used_As_Generic_Actual\",          Flag222 (Id));\n       W (\"Uses_Sec_Stack\",                  Flag95  (Id));\n       W (\"Warnings_Off\",                    Flag96  (Id));\n@@ -9774,11 +9765,7 @@ package body Einfo is\n          when E_Function                                   |\n               E_Operator                                   |\n               E_Procedure                                  =>\n-            if Field24 (Id) in Uint_Range then\n-               Write_Str (\"Subps_Index\");\n-            else\n-               Write_Str (\"Uplevel_References\");\n-            end if;\n+            Write_Str (\"Subps_Index\");\n \n          when others                                       =>\n             Write_Str (\"Field24???\");"}, {"sha": "c25be53052522b1ee1898a6cdf2d66f6fb78dc2d", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -2009,11 +2009,10 @@ package Einfo is\n --       Defined in all entities. Indicates that the entity is locally defined\n --       within a subprogram P, and there is a reference to the entity within\n --       a subprogram nested within P (at any depth). Set only for the VM case\n---       (where it is set for variables, constants and loop parameters), and in\n---       the case where we are unnesting nested subprograms (in which case it\n---       is also set for types and subtypes which are not static types, and\n---       that are referenced uplevel, as well as for subprograms that contain\n---       uplevel references or call other subprograms (Exp_Unst has details).\n+--       (where it is set for variables, constants and loop parameters). Note\n+--       that this is similar in usage to Is_Uplevel_Referenced_Entity (which\n+--       is used when we are unnesting subprograms), but the usages are a bit\n+--       different and it is cleaner to leave the old VM usage unchanged.\n \n --    Has_Visible_Refinement (Flag263)\n --       Defined in E_Abstract_State entities. Set when a state has at least\n@@ -2988,8 +2987,8 @@ package Einfo is\n --       Wide_Wide_String).\n \n --    Is_Static_Type (Flag281)\n---       Defined in all type and subtype entities. If set, indicates that the\n---       type is known to be a static type (defined as a discrete type with\n+--       Defined in entities. Only set for (sub)types. If set, indicates that\n+--       the type is known to be a static type (defined as a discrete type with\n --       static bounds, a record all of whose component types are static types,\n --       or an array, all of whose bounds are of a static type, and also have\n --       a component type that is a static type). See Set_Uplevel_Type for more\n@@ -3111,6 +3110,20 @@ package Einfo is\n --       subtype is still unsigned, but this cannot be determined by looking\n --       at its bounds or the bounds of the corresponding base type.\n \n+--    Is_Uplevel_Referenced_Entity (Flag283)\n+--       Defined in all entities. Used when unnesting subprograms to indicate\n+--       that an entity is locally defined within a subprogram P, and there is\n+--       a reference to the entity within a subprogram nested within P (at any\n+--       depth). Set for uplevel referenced objects (variables, constants and\n+--       loop parameters), and also for upreferenced dynamic types, including\n+--       the cases where the reference is implicit (e.g. the type of an array\n+--       used for computing the location of an element in an array. This is\n+--       used internally in Exp_Unst, see this package for further details.\n+--       Note that this is similar to the Has_Uplevel_Reference flag which\n+--       is used in the VM case but we prefer to keep the two cases entirely\n+--       separated, so that the VM usage is not disturbed by work on the\n+--       Unnesting_Subprograms mode.\n+\n --    Is_Valued_Procedure (Flag127)\n --       Defined in procedure entities. Set if an Import_Valued_Procedure\n --       or Export_Valued_Procedure pragma applies to the procedure entity.\n@@ -4142,8 +4155,6 @@ package Einfo is\n --    Subps_Index (Uint24)\n --       Used during Exp_Inst.Unnest_Subprogram to hold the index in the Subps\n --       table for a subprogram. See processing in this procedure for details.\n---       Note that this overlaps Uplevel_References, it is only set after the\n---       latter field has been acquired.\n \n --    Suppress_Elaboration_Warnings (Flag148)\n --       Defined in all entities, can be set only for subprogram entities and\n@@ -4278,19 +4289,6 @@ package Einfo is\n --       is identified. This field is used to generate a warning message if\n --       necessary (see Sem_Warn.Check_Unset_Reference).\n \n---    Uplevel_Reference_Noted (Flag283)\n---       Defined in all entities, used in Exp_Unst processing to note that an\n---       uplevel reference to the entity has been noted (to avoid processing a\n---       given entity more than once).\n-\n---    Uplevel_References (Elist24)\n---       Defined in subprogram entities. Set only if Has_Uplevel_Reference is\n---       set and if we are Unnest_Subprogram_Mode, otherwise undefined. Points\n---       to a list of explicit uplevel references to entities declared in\n---       the subprogram which need rewriting. Each entry uses two elements of\n---       the list, the first is the node that is the actual reference, the\n---       second is the entity of the enclosing subprogram for the reference.\n-\n --    Used_As_Generic_Actual (Flag222)\n --       Defined in all entities, set if the entity is used as an argument to\n --       a generic instantiation. Used to tune certain warning messages.\n@@ -5255,6 +5253,7 @@ package Einfo is\n    --    Has_Qualified_Name                  (Flag161)\n    --    Has_Stream_Size_Clause              (Flag184)\n    --    Has_Unknown_Discriminants           (Flag72)\n+   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Xref_Entry                      (Flag182)\n    --    In_Private_Part                     (Flag45)\n    --    Is_Ada_2005_Only                    (Flag185)\n@@ -5304,6 +5303,7 @@ package Einfo is\n    --    Is_Renaming_Of_Object               (Flag112)\n    --    Is_Shared_Passive                   (Flag60)\n    --    Is_Statically_Allocated             (Flag28)\n+   --    Is_Static_Type                      (Flag281)\n    --    Is_Tagged_Type                      (Flag55)\n    --    Is_Thunk                            (Flag225)\n    --    Is_Trivial_Subprogram               (Flag235)\n@@ -5324,7 +5324,6 @@ package Einfo is\n    --    Suppress_Elaboration_Warnings       (Flag148)\n    --    Suppress_Style_Checks               (Flag165)\n    --    Suppress_Value_Tracking_On_Call     (Flag217)\n-   --    Uplevel_Reference_Noted             (Flag283)\n    --    Used_As_Generic_Actual              (Flag222)\n    --    Warnings_Off                        (Flag96)\n    --    Warnings_Off_Used                   (Flag236)\n@@ -5395,7 +5394,6 @@ package Einfo is\n    --    Has_Static_Predicate_Aspect         (Flag259)\n    --    Has_Task                            (Flag30)   (base type only)\n    --    Has_Unchecked_Union                 (Flag123)  (base type only)\n-   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Volatile_Components             (Flag87)   (base type only)\n    --    In_Use                              (Flag8)\n    --    Is_Abstract_Type                    (Flag146)\n@@ -5412,7 +5410,6 @@ package Einfo is\n    --    Is_Non_Static_Subtype               (Flag109)\n    --    Is_Packed                           (Flag51)   (base type only)\n    --    Is_Private_Composite                (Flag107)\n-   --    Is_Static_Type                      (Flag281)\n    --    Is_Unsigned_Type                    (Flag144)\n    --    Is_Volatile                         (Flag16)\n    --    Itype_Printed                       (Flag202)  (itypes only)\n@@ -5617,14 +5614,14 @@ package Einfo is\n    --    Has_Independent_Components          (Flag34)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Thunks                          (Flag228)  (constants only)\n-   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Independent                      (Flag268)\n    --    Is_Processed_Transient              (Flag252)  (constants only)\n    --    Is_Return_Object                    (Flag209)\n    --    Is_True_Constant                    (Flag163)\n+   --    Is_Uplevel_Referenced_Entity        (Flag283)\n    --    Is_Volatile                         (Flag16)\n    --    Stores_Attribute_Old_Prefix         (Flag270)  (constants only)\n    --    Optimize_Alignment_Space            (Flag241)  (constants only)\n@@ -5785,7 +5782,6 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n-   --    Uplevel_References                  (Elist24)  (non-generic case only)\n    --    Subps_Index                         (Uint24)   (non-generic case only)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)\n@@ -5960,7 +5956,6 @@ package Einfo is\n    --    Extra_Accessibility_Of_Result       (Node19)\n    --    Last_Entity                         (Node20)\n    --    Has_Nested_Subprogram               (Flag282)\n-   --    Uplevel_References                  (Elist24)\n    --    Subps_Index                         (Uint24)\n    --    Overridden_Operation                (Node26)\n    --    Subprograms_For_Type                (Node29)\n@@ -6094,7 +6089,6 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n-   --    Uplevel_References                  (Elist24)  (non-generic case only)\n    --    Subps_Index                         (Uint24)   (non-generic case only)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)   (never for init proc)\n@@ -6351,7 +6345,6 @@ package Einfo is\n    --    Has_Independent_Components          (Flag34)\n    --    Has_Initial_Value                   (Flag219)\n    --    Has_Size_Clause                     (Flag29)\n-   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n@@ -6362,6 +6355,7 @@ package Einfo is\n    --    Is_True_Constant                    (Flag163)\n    --    Is_Volatile                         (Flag16)\n    --    Is_Return_Object                    (Flag209)\n+   --    Is_Uplevel_Referenced_Entity        (Flag283)\n    --    OK_To_Rename                        (Flag247)\n    --    Optimize_Alignment_Space            (Flag241)\n    --    Optimize_Alignment_Time             (Flag242)\n@@ -6913,6 +6907,7 @@ package Einfo is\n    function Is_Underlying_Record_View           (Id : E) return B;\n    function Is_Unimplemented                    (Id : E) return B;\n    function Is_Unsigned_Type                    (Id : E) return B;\n+   function Is_Uplevel_Referenced_Entity        (Id : E) return B;\n    function Is_Valued_Procedure                 (Id : E) return B;\n    function Is_Visible_Formal                   (Id : E) return B;\n    function Is_Visible_Lib_Unit                 (Id : E) return B;\n@@ -7041,8 +7036,6 @@ package Einfo is\n    function Underlying_Record_View              (Id : E) return E;\n    function Universal_Aliasing                  (Id : E) return B;\n    function Unset_Reference                     (Id : E) return N;\n-   function Uplevel_Reference_Noted             (Id : E) return B;\n-   function Uplevel_References                  (Id : E) return L;\n    function Used_As_Generic_Actual              (Id : E) return B;\n    function Uses_Lock_Free                      (Id : E) return B;\n    function Uses_Sec_Stack                      (Id : E) return B;\n@@ -7569,6 +7562,7 @@ package Einfo is\n    procedure Set_Is_Underlying_Record_View       (Id : E; V : B := True);\n    procedure Set_Is_Unimplemented                (Id : E; V : B := True);\n    procedure Set_Is_Unsigned_Type                (Id : E; V : B := True);\n+   procedure Set_Is_Uplevel_Referenced_Entity    (Id : E; V : B := True);\n    procedure Set_Is_Valued_Procedure             (Id : E; V : B := True);\n    procedure Set_Is_Visible_Formal               (Id : E; V : B := True);\n    procedure Set_Is_Visible_Lib_Unit             (Id : E; V : B := True);\n@@ -7697,8 +7691,6 @@ package Einfo is\n    procedure Set_Underlying_Record_View          (Id : E; V : E);\n    procedure Set_Universal_Aliasing              (Id : E; V : B := True);\n    procedure Set_Unset_Reference                 (Id : E; V : N);\n-   procedure Set_Uplevel_Reference_Noted         (Id : E; V : B := True);\n-   procedure Set_Uplevel_References              (Id : E; V : L);\n    procedure Set_Used_As_Generic_Actual          (Id : E; V : B := True);\n    procedure Set_Uses_Lock_Free                  (Id : E; V : B := True);\n    procedure Set_Uses_Sec_Stack                  (Id : E; V : B := True);\n@@ -8380,6 +8372,7 @@ package Einfo is\n    pragma Inline (Is_Underlying_Record_View);\n    pragma Inline (Is_Unimplemented);\n    pragma Inline (Is_Unsigned_Type);\n+   pragma Inline (Is_Uplevel_Referenced_Entity);\n    pragma Inline (Is_Valued_Procedure);\n    pragma Inline (Is_Visible_Formal);\n    pragma Inline (Is_Visible_Lib_Unit);\n@@ -8510,8 +8503,6 @@ package Einfo is\n    pragma Inline (Underlying_Record_View);\n    pragma Inline (Universal_Aliasing);\n    pragma Inline (Unset_Reference);\n-   pragma Inline (Uplevel_Reference_Noted);\n-   pragma Inline (Uplevel_References);\n    pragma Inline (Used_As_Generic_Actual);\n    pragma Inline (Uses_Lock_Free);\n    pragma Inline (Uses_Sec_Stack);\n@@ -8717,7 +8708,6 @@ package Einfo is\n    pragma Inline (Set_Has_Thunks);\n    pragma Inline (Set_Has_Unchecked_Union);\n    pragma Inline (Set_Has_Unknown_Discriminants);\n-   pragma Inline (Set_Has_Uplevel_Reference);\n    pragma Inline (Set_Has_Visible_Refinement);\n    pragma Inline (Set_Has_Volatile_Components);\n    pragma Inline (Set_Has_Xref_Entry);\n@@ -8836,6 +8826,7 @@ package Einfo is\n    pragma Inline (Set_Is_Underlying_Record_View);\n    pragma Inline (Set_Is_Unimplemented);\n    pragma Inline (Set_Is_Unsigned_Type);\n+   pragma Inline (Set_Is_Uplevel_Referenced_Entity);\n    pragma Inline (Set_Is_Valued_Procedure);\n    pragma Inline (Set_Is_Visible_Formal);\n    pragma Inline (Set_Is_Visible_Lib_Unit);\n@@ -8963,8 +8954,6 @@ package Einfo is\n    pragma Inline (Set_Underlying_Full_View);\n    pragma Inline (Set_Underlying_Record_View);\n    pragma Inline (Set_Universal_Aliasing);\n-   pragma Inline (Set_Uplevel_Reference_Noted);\n-   pragma Inline (Set_Uplevel_References);\n    pragma Inline (Set_Unset_Reference);\n    pragma Inline (Set_Used_As_Generic_Actual);\n    pragma Inline (Set_Uses_Lock_Free);"}, {"sha": "8677562f435802d19ddb4111e8f7ef576050560d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 79, "deletions": 27, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -71,13 +71,41 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Table;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n \n package body Exp_Ch6 is\n \n+   -------------------------------------\n+   -- Table for Unnesting Subprograms --\n+   -------------------------------------\n+\n+   --  When we expand a subprogram body, if it has nested subprograms and if\n+   --  we are in Unnest_Subprogram_Mode, then we record the subprogram entity\n+   --  and the body in this table, to later be passed to Unnest_Subprogram.\n+\n+   --  We need this delaying mechanism, because we have to wait untiil all\n+   --  instantiated bodies have been inserted before doing the unnesting.\n+\n+   type Unest_Entry is record\n+      Ent : Entity_Id;\n+      --  Entity for subprogram to be unnested\n+\n+      Bod : Node_Id;\n+      --  Subprogram body to be unnested\n+   end record;\n+\n+   package Unest_Bodies is new Table.Table (\n+     Table_Component_Type => Unest_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Unest_Bodies\");\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -5360,7 +5388,7 @@ package body Exp_Ch6 is\n \n         and then Has_Nested_Subprogram (Spec_Id)\n       then\n-         Unnest_Subprogram (Spec_Id, N);\n+         Unest_Bodies.Append ((Spec_Id, N));\n       end if;\n    end Expand_N_Subprogram_Body;\n \n@@ -5788,32 +5816,6 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Protected_Subprogram_Call;\n \n-   --------------------------------------------\n-   -- Has_Unconstrained_Access_Discriminants --\n-   --------------------------------------------\n-\n-   function Has_Unconstrained_Access_Discriminants\n-     (Subtyp : Entity_Id) return Boolean\n-   is\n-      Discr : Entity_Id;\n-\n-   begin\n-      if Has_Discriminants (Subtyp)\n-        and then not Is_Constrained (Subtyp)\n-      then\n-         Discr := First_Discriminant (Subtyp);\n-         while Present (Discr) loop\n-            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n-               return True;\n-            end if;\n-\n-            Next_Discriminant (Discr);\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Has_Unconstrained_Access_Discriminants;\n-\n    -----------------------------------\n    -- Expand_Simple_Function_Return --\n    -----------------------------------\n@@ -7999,6 +8001,41 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Subprogram_Contract;\n \n+   --------------------------------------------\n+   -- Has_Unconstrained_Access_Discriminants --\n+   --------------------------------------------\n+\n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean\n+   is\n+      Discr : Entity_Id;\n+\n+   begin\n+      if Has_Discriminants (Subtyp)\n+        and then not Is_Constrained (Subtyp)\n+      then\n+         Discr := First_Discriminant (Subtyp);\n+         while Present (Discr) loop\n+            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+               return True;\n+            end if;\n+\n+            Next_Discriminant (Discr);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Has_Unconstrained_Access_Discriminants;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Unest_Bodies.Init;\n+   end Initialize;\n+\n    --------------------------------\n    -- Is_Build_In_Place_Function --\n    --------------------------------\n@@ -9489,4 +9526,19 @@ package body Exp_Ch6 is\n       end if;\n    end Needs_Result_Accessibility_Level;\n \n+   ------------------------\n+   -- Unnest_Subprograms --\n+   ------------------------\n+\n+   procedure Unnest_Subprograms is\n+   begin\n+      for J in Unest_Bodies.First .. Unest_Bodies.Last loop\n+         declare\n+            UBJ : Unest_Entry renames Unest_Bodies.Table (J);\n+         begin\n+            Unnest_Subprogram (UBJ.Ent, UBJ.Bod);\n+         end;\n+      end loop;\n+   end Unnest_Subprograms;\n+\n end Exp_Ch6;"}, {"sha": "5cbcc965cf444afdb6f9d3f868c2f4eddcb097a8", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -97,6 +97,13 @@ package Exp_Ch6 is\n       --\n       --  ??? We might also need to be able to pass in a constrained flag.\n \n+   procedure Add_Extra_Actual_To_Call\n+     (Subprogram_Call : Node_Id;\n+      Extra_Formal    : Entity_Id;\n+      Extra_Actual    : Node_Id);\n+   --  Adds Extra_Actual as a named parameter association for the formal\n+   --  Extra_Formal in Subprogram_Call.\n+\n    function BIP_Formal_Suffix (Kind : BIP_Formal_Kind) return String;\n    --  Ada 2005 (AI-318-02): Returns a string to be used as the suffix of names\n    --  for build-in-place formal parameters of the given kind.\n@@ -109,6 +116,9 @@ package Exp_Ch6 is\n    --  function Func, and returns its Entity_Id. It is a bug if not found; the\n    --  caller should ensure this is called only when the extra formal exists.\n \n+   procedure Initialize;\n+   --  Initialize internal tables\n+\n    function Is_Build_In_Place_Function (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if E denotes a function, generic\n    --  function, or access-to-function type whose result must be built in\n@@ -201,11 +211,9 @@ package Exp_Ch6 is\n    --  parameter to identify the accessibility level of the function result\n    --  \"determined by the point of call\".\n \n-   procedure Add_Extra_Actual_To_Call\n-     (Subprogram_Call : Node_Id;\n-      Extra_Formal    : Entity_Id;\n-      Extra_Actual    : Node_Id);\n-   --  Adds Extra_Actual as a named parameter association for the formal\n-   --  Extra_Formal in Subprogram_Call.\n+   procedure Unnest_Subprograms;\n+   --  Called to unnest subprograms. If we are in unnest subprogram mode, and\n+   --  subprograms have been gathered in the Unest_Bodies table, this is the\n+   --  call that causes them to be processed for unnesting.\n \n end Exp_Ch6;"}, {"sha": "e80002d3361afafb2713345f90a142d6d99881c4", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 936, "deletions": 692, "changes": 1628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -24,29 +24,61 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Output;   use Output;\n with Rtsfind;  use Rtsfind;\n-with Sinput;   use Sinput;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Table;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n package body Exp_Unst is\n \n-   --  Tables used by Unnest_Subprogram\n+   ---------------------------\n+   -- Terminology for Calls --\n+   ---------------------------\n+\n+   --  The level of a subprogram in the nest being analyzed is defined to be\n+   --  the level of nesting, so the outer level subprogram (the one passed to\n+   --  Unnest_Subprogram) is 1, subprograms immediately nested within this\n+   --  outer level subprogram have a level of 2, etc.\n+\n+   --  Calls within the nest being analyzed are of three types:\n+\n+   --    Downward call: this is a call from a subprogram to a subprogram that\n+   --    is immediately nested with in the caller, and thus has a level that\n+   --    is one greater than the caller. It is a fundamental property of the\n+   --    nesting structure and visibility that it is not possible to make a\n+   --    call from level N to level M, where M is greater than N + 1.\n+\n+   --    Parallel call: this is a call from a nested subprogram to another\n+   --    nested subprogram that is at the same level.\n+\n+   --    Upward call: this is a call from a subprogram to a subprogram that\n+   --    encloses the caller. The level of the callee is less than the level\n+   --    of the caller, and there is no limit on the difference, e.g. for an\n+   --    uplevel call, a subprogram at level 5 can call one at level 2 or even\n+   --    the outer level subprogram at level 1.\n+\n+   -----------\n+   -- Subps --\n+   -----------\n+\n+   --  Table to record subprograms within the nest being currently analyzed\n \n    type Subp_Entry is record\n       Ent : Entity_Id;\n@@ -59,31 +91,69 @@ package body Exp_Unst is\n       --  Subprogram level (1 = outer subprogram (Subp argument), 2 = nested\n       --  immediately within this outer subprogram etc.)\n \n-      Urefs : Elist_Id;\n-      --  This is a copy of the Uplevel_References field from the entity for\n-      --  the subprogram. Copy this to reuse the field for Subps_Index.\n+      Reachable : Boolean;\n+      --  This flag is set True if there is a call path from the outer level\n+      --  subprogram to this subprogram. If Reachable is False, it means that\n+      --  the subprogram is declared but not actually referenced. We remove\n+      --  such suprograms from the tree, which simplifies our task, because\n+      --  we don't have to worry about e.g. uplevel references from such an\n+      --  unreferenced subpogram, which might require (useless) activation\n+      --  records to be created. This is computed by setting the outer level\n+      --  subprogram (Subp itself) as reachable, and then doing a transitive\n+      --  closure following all calls.\n+\n+      Uplevel_Ref : Nat;\n+      --  The outermost level which defines entities which this subprogram\n+      --  references either directly or indirectly via a call. This cannot\n+      --  be greater than Lev. If it is equal to Lev, then it means that the\n+      --  subprogram does not make any uplevel references and that thus it\n+      --  does not need an activation record pointer passed. If it is less than\n+      --  Lev, then an activation record pointer is needed, since there is at\n+      --  least one uplevel reference. This is computed by initially setting\n+      --  Uplevel_Ref to Lev for all subprograms. Then on the initial tree\n+      --  traversal, decreasing Uplevel_Ref for an explicit uplevel reference,\n+      --  and finally by doing a transitive closure that follows calls (if A\n+      --  calls B and B has an uplevel reference to level X, then A references\n+      --  level X indirectly).\n+\n+      Declares_AREC : Boolean;\n+      --  This is set True for a subprogram which include the declarations\n+      --  for a local activation record to bew passed on downward calls. It\n+      --  is set True for the target level of an uplevel reference, and for\n+      --  all intervening nested subprograms. For example, if a subprogram X\n+      --  at level 5 makes an uplevel reference to an entity declared in a\n+      --  level 2 subprogram, then the subprograms at levels 4,3,2 enclosing\n+      --  the level 5 subprogram will have this flag set True.\n+\n+      Uents : Elist_Id;\n+      --  This is a list of entities declared in this subprogram which are\n+      --  uplevel referenced. It contains both objects (which will be put in\n+      --  the corresponding AREC activation record), and types. The types are\n+      --  not put in the AREC activation record, but referenced bounds (i.e.\n+      --  generated _FIRST and _LAST entites, and formal parameters) will be\n+      --  in the list in their own right.\n \n       ARECnF : Entity_Id;\n-      --  This entity is defined for all subprograms with uplevel references\n-      --  except for the top-level subprogram (Subp itself). It is the entity\n-      --  for the formal which is added to the parameter list to pass the\n-      --  pointer to the activation record. Note that for this entity, n is\n-      --  one less than the current level.\n+      --  This entity is defined for all subprograms which need an extra formal\n+      --  that contains a pointer to the activation record needed for uplevel\n+      --  references. ARECnF must be defined for any subprogram which has a\n+      --  direct or indirect uplevel reference (i.e. Reference_Level < Lev).\n \n       ARECn   : Entity_Id;\n       ARECnT  : Entity_Id;\n       ARECnPT : Entity_Id;\n       ARECnP  : Entity_Id;\n       --  These AREC entities are defined only for subprograms for which we\n-      --  generate an activation record declaration, i.e. for subprograms\n-      --  with at least one nested subprogram that have uplevel referennces.\n-      --  They are set to Empty for all other cases.\n+      --  generate an activation record declaration, i.e. for subprograms for\n+      --  which the Declares_AREC flag is set True.\n \n       ARECnU : Entity_Id;\n       --  This AREC entity is the uplink component. It is other than Empty only\n-      --  for nested subprograms that themselves have nested subprograms and\n-      --  have uplevel references. Note that the n here is one less than the\n-      --  level of the subprogram defining the activation record.\n+      --  for nested subprograms that declare an activation record as indicated\n+      --  by Declares_AREC being Ture, and which have uplevel references (Lev\n+      --  greater than Uplevel_Ref). It is the additional component in the\n+      --  activation record that references the ARECnF pointer (which points\n+      --  the activation record one level higher, thus forming the chain).\n \n    end record;\n \n@@ -98,15 +168,24 @@ package body Exp_Unst is\n      Table_Name           => \"Unnest_Subps\");\n    --  Records the subprograms in the nest whose outer subprogram is Subp\n \n+   -----------\n+   -- Calls --\n+   -----------\n+\n+   --  Table to record calls within the nest being analyzed. These are the\n+   --  calls which may need to have an AREC actual added.\n+\n    type Call_Entry is record\n       N : Node_Id;\n       --  The actual call\n \n-      From : Entity_Id;\n-      --  Entity of the subprogram containing the call\n+      Caller : Entity_Id;\n+      --  Entity of the subprogram containing the call (can be at any level)\n \n-      To : Entity_Id;\n-      --  Entity of the subprogram called\n+      Callee : Entity_Id;\n+      --  Entity of the subprogram called (always at level 2 or higher). Note\n+      --  that in accordance with the basic rules of nesting, the level of To\n+      --  is either less than or equal to the level of From, or one greater.\n    end record;\n \n    package Calls is new Table.Table (\n@@ -120,227 +199,48 @@ package body Exp_Unst is\n    --  that are to other subprograms nested within the outer subprogram. These\n    --  are the calls that may need an additional parameter.\n \n-   -------------------------------------\n-   -- Check_Uplevel_Reference_To_Type --\n-   -------------------------------------\n-\n-   procedure Check_Uplevel_Reference_To_Type (Typ : Entity_Id) is\n-      function Check_Dynamic_Type (T : Entity_Id) return Boolean;\n-      --  This is an internal recursive routine that checks if T or any of\n-      --  its subsdidiary types are dynamic. If so, then the original Typ is\n-      --  marked as having an uplevel reference, as is the subsidiary type in\n-      --  question, and any referenced dynamic bounds are also marked as having\n-      --  an uplevel reference, and True is returned. If the type is a static\n-      --  type, then False is returned;\n-\n-      ------------------------\n-      -- Check_Dynamic_Type --\n-      ------------------------\n-\n-      function Check_Dynamic_Type (T : Entity_Id) return Boolean is\n-         DT : Boolean := False;\n-\n-      begin\n-         --  If it's a static type, nothing to do\n-\n-         if Is_Static_Type (T) then\n-            return False;\n-\n-         --  If the type is uplevel referenced, then it must be dynamic\n-\n-         elsif Has_Uplevel_Reference (T) then\n-            Set_Has_Uplevel_Reference (Typ);\n-            return True;\n-\n-         --  If the type is at library level, always consider it static, since\n-         --  uplevel references do not matter in this case.\n-\n-         elsif Is_Library_Level_Entity (T) then\n-            Set_Is_Static_Type (T);\n-            return False;\n-\n-         --  Otherwise we need to figure out what the story is with this type\n-\n-         else\n-            DT := False;\n-\n-            --  For a scalar type, check bounds\n-\n-            if Is_Scalar_Type (T) then\n-\n-               --  If both bounds static, then this is a static type\n-\n-               declare\n-                  LB : constant Node_Id := Type_Low_Bound (T);\n-                  UB : constant Node_Id := Type_High_Bound (T);\n-\n-               begin\n-                  if not Is_Static_Expression (LB) then\n-                     Set_Has_Uplevel_Reference (Entity (LB));\n-                     DT := True;\n-                  end if;\n-\n-                  if not Is_Static_Expression (UB) then\n-                     Set_Has_Uplevel_Reference (Entity (UB));\n-                     DT := True;\n-                  end if;\n-               end;\n-\n-            --  For record type, check all components\n-\n-            elsif Is_Record_Type (T) then\n-               declare\n-                  C : Entity_Id;\n-\n-               begin\n-                  C := First_Component_Or_Discriminant (T);\n-                  while Present (C) loop\n-                     if Check_Dynamic_Type (Etype (C)) then\n-                        DT := True;\n-                     end if;\n-\n-                     Next_Component_Or_Discriminant (C);\n-                  end loop;\n-               end;\n-\n-            --  For array type, check index types and component type\n-\n-            elsif Is_Array_Type (T) then\n-               declare\n-                  IX : Node_Id;\n-\n-               begin\n-                  if Check_Dynamic_Type (Component_Type (T)) then\n-                     DT := True;\n-                  end if;\n-\n-                  IX := First_Index (T);\n-                  while Present (IX) loop\n-                     if Check_Dynamic_Type (Etype (IX)) then\n-                        DT := True;\n-                     end if;\n-\n-                     Next_Index (IX);\n-                  end loop;\n-               end;\n-\n-            --  For now, ignore other types\n-\n-            else\n-               return False;\n-            end if;\n-\n-            --  See if we marked that type as dynamic\n-\n-            if DT then\n-               Set_Has_Uplevel_Reference (T);\n-               Set_Has_Uplevel_Reference (Typ);\n-               return True;\n-\n-            --  If not mark it as static\n-\n-            else\n-               Set_Is_Static_Type (T);\n-               return False;\n-            end if;\n-         end if;\n-      end Check_Dynamic_Type;\n-\n-   --  Start of processing for Check_Uplevel_Reference_To_Type\n-\n-   begin\n-      --  Nothing to do inside a generic (all processing is for instance)\n-\n-      if Inside_A_Generic then\n-         return;\n-\n-      --  Nothing to do if we know this is a static type\n-\n-      elsif Is_Static_Type (Typ) then\n-         return;\n-\n-      --  Nothing to do if already marked as uplevel referenced\n-\n-      elsif Has_Uplevel_Reference (Typ) then\n-         return;\n-\n-      --  Otherwise check if we have a dynamic type\n-\n-      else\n-         if Check_Dynamic_Type (Typ) then\n-            Set_Has_Uplevel_Reference (Typ);\n-         end if;\n-      end if;\n-\n-      null;\n-   end Check_Uplevel_Reference_To_Type;\n+   -----------\n+   -- Urefs --\n+   -----------\n \n-   ----------------------------\n-   -- Note_Uplevel_Reference --\n-   ----------------------------\n+   --  Table to record explicit uplevel references to objects (variables,\n+   --  constants, formal parameters). These are the references that will\n+   --  need rewriting to use the activation table (AREC) pointers. Also\n+   --  included are implicit and explicit uplevel references to types, but\n+   --  these do not get rewritten by the front end.\n \n-   procedure Note_Uplevel_Reference (N : Node_Id; Subp : Entity_Id) is\n-      Elmt : Elmt_Id;\n+   type Uref_Entry is record\n+      Ref : Node_Id;\n+      --  The reference itself. For objects this is always an entity reference\n+      --  and the referenced entity will have its Is_Uplevel_Referenced_Entity\n+      --  flag set and will appear in the Uplevel_Referenced_Entities list of\n+      --  the subprogram declaring this entity.\n \n-   begin\n-      --  Nothing to do inside a generic (all processing is for instance)\n-\n-      if Inside_A_Generic then\n-         return;\n-      end if;\n-\n-      --  Nothing to do if reference has no entity field\n-\n-      if Nkind (N) not in N_Has_Entity then\n-         return;\n-      end if;\n-\n-      --  Establish list if first call for Uplevel_References\n-\n-      if No (Uplevel_References (Subp)) then\n-         Set_Uplevel_References (Subp, New_Elmt_List);\n-      end if;\n-\n-      --  Ignore if node is already in the list. This is a bit inefficient,\n-      --  but we can definitely get duplicates that cause trouble!\n-\n-      Elmt := First_Elmt (Uplevel_References (Subp));\n-      while Present (Elmt) loop\n-         if N = Node (Elmt) then\n-            return;\n-         else\n-            Next_Elmt (Elmt);\n-         end if;\n-      end loop;\n-\n-      --  Add new entry to Uplevel_References. Each entry is two elements of\n-      --  the list. The first is the actual reference, the second is the\n-      --  enclosing subprogram at the point of reference\n+      Ent : Entity_Id;\n+      --  The Entity_Id of the uplevel referenced object or type\n \n-      Append_Elmt (N, Uplevel_References (Subp));\n+      Caller : Entity_Id;\n+      --  The entity for the subprogram immediately containing this entity\n \n-      if Is_Subprogram (Current_Scope) then\n-         Append_Elmt (Current_Scope, Uplevel_References (Subp));\n-      else\n-         Append_Elmt\n-           (Enclosing_Subprogram (Current_Scope), Uplevel_References (Subp));\n-      end if;\n+      Callee : Entity_Id;\n+      --  The entity for the subprogram containing the referenced entity. Note\n+      --  that the level of Callee must be less than the level of Caller, since\n+      --  this is uplevel reference.\n+   end record;\n \n-      Set_Has_Uplevel_Reference (Entity (N));\n-      Set_Has_Uplevel_Reference (Subp);\n-   end Note_Uplevel_Reference;\n+   package Urefs is new Table.Table (\n+     Table_Component_Type => Uref_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Unnest_Urefs\");\n \n    -----------------------\n    -- Unnest_Subprogram --\n    -----------------------\n \n    procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id) is\n-      function Actual_Ref (N : Node_Id) return Node_Id;\n-      --  This function is applied to an element in the Uplevel_References\n-      --  list, and it finds the actual reference. Often this is just N itself,\n-      --  but in some cases it gets rewritten, e.g. as a Type_Conversion, and\n-      --  this function digs out the actual reference\n-\n       function AREC_String (Lev : Pos) return String;\n       --  Given a level value, 1, 2, ... returns the string AREC, AREC2, ...\n \n@@ -357,43 +257,14 @@ package body Exp_Unst is\n       function Subp_Index (Sub : Entity_Id) return SI_Type;\n       --  Given the entity for a subprogram, return corresponding Subps index\n \n-      function Upref_Name (Ent : Entity_Id) return Name_Id;\n+      function Upref_Name (Ent : Entity_Id; Clist : List_Id) return Name_Id;\n       --  This function returns the name to be used in the activation record to\n-      --  reference the variable uplevel. Normally this is just a copy of the\n-      --  Chars field of the entity. The exception is when the scope of Ent\n-      --  is a declare block, in which case we append the entity number to\n-      --  make sure that no confusion occurs between use of the same name\n-      --  in different declare blocks.\n-\n-      ----------------\n-      -- Actual_Ref --\n-      ----------------\n-\n-      function Actual_Ref (N : Node_Id) return Node_Id is\n-      begin\n-         case Nkind (N) is\n-\n-            --  If we have an entity reference, then this is the actual ref\n-\n-            when N_Has_Entity =>\n-               return N;\n-\n-            --  For a type conversion, go get the expression\n-\n-            when N_Type_Conversion =>\n-               return Expression (N);\n-\n-            --  For an explicit dereference, get the prefix\n-\n-            when N_Explicit_Dereference =>\n-               return Prefix (N);\n-\n-            --  No other possibilities should exist\n-\n-            when others =>\n-               raise Program_Error;\n-         end case;\n-      end Actual_Ref;\n+      --  reference the variable uplevel. Clist is the list of components that\n+      --  have been created in the activation record so far. Normally this is\n+      --  just a copy of the Chars field of the entity. The exception is when\n+      --  the name has already been used, in which case we suffix the name with\n+      --  the entity number to avoid duplication. This happens with declare\n+      --  blocks and generic parameters at least.\n \n       -----------------\n       -- AREC_String --\n@@ -456,17 +327,25 @@ package body Exp_Unst is\n       -- Upref_Name --\n       ----------------\n \n-      function Upref_Name (Ent : Entity_Id) return Name_Id is\n+      function Upref_Name (Ent : Entity_Id; Clist : List_Id) return Name_Id is\n+         C : Node_Id;\n+\n       begin\n-         if Ekind (Scope (Ent)) /= E_Block then\n-            return Chars (Ent);\n+         C := First (Clist);\n+         loop\n+            if No (C) then\n+               return Chars (Ent);\n \n-         else\n-            Get_Name_String (Chars (Ent));\n-            Add_Str_To_Name_Buffer (\"__\");\n-            Add_Nat_To_Name_Buffer (Nat (Ent));\n-            return Name_Enter;\n-         end if;\n+            elsif Chars (Defining_Identifier (C)) = Chars (Ent) then\n+               Get_Name_String (Chars (Ent));\n+               Add_Str_To_Name_Buffer (\"__\");\n+               Add_Nat_To_Name_Buffer (Nat (Ent));\n+               return Name_Enter;\n+\n+            else\n+               Next (C);\n+            end if;\n+         end loop;\n       end Upref_Name;\n \n    --  Start of processing for Unnest_Subprogram\n@@ -477,15 +356,22 @@ package body Exp_Unst is\n       if Inside_A_Generic then\n          return;\n       end if;\n+\n       --  At least for now, do not unnest anything but main source unit\n \n       if not In_Extended_Main_Source_Unit (Subp_Body) then\n          return;\n       end if;\n \n+      --  This routine is called late, after the scope stack is gone. The\n+      --  following creates a suitable dummy scope stack to be used for the\n+      --  analyze/expand calls made from this routine.\n+\n+      Push_Scope (Subp);\n+\n       --  First step, we must mark all nested subprograms that require a static\n       --  link (activation record) because either they contain explicit uplevel\n-      --  references (as indicated by Has_Uplevel_Reference being set at this\n+      --  references (as indicated by ??? being set at this\n       --  point), or they make calls to other subprograms in the same nest that\n       --  require a static link (in which case we set this flag).\n \n@@ -499,43 +385,194 @@ package body Exp_Unst is\n \n       Subps.Init;\n       Calls.Init;\n+      Urefs.Init;\n \n       Build_Tables : declare\n+         Current_Subprogram : Entity_Id;\n+         --  When we scan a subprogram body, we set Current_Subprogram to the\n+         --  corresponding entity. This gets recursively saved and restored.\n+\n          function Visit_Node (N : Node_Id) return Traverse_Result;\n          --  Visit a single node in Subp\n \n+         -----------\n+         -- Visit --\n+         -----------\n+\n+         procedure Visit is new Traverse_Proc (Visit_Node);\n+         --  Used to traverse the body of Subp, populating the tables\n+\n          ----------------\n          -- Visit_Node --\n          ----------------\n \n          function Visit_Node (N : Node_Id) return Traverse_Result is\n-            Ent  : Entity_Id;\n-            Csub : Entity_Id;\n+            Ent    : Entity_Id;\n+            Caller : Entity_Id;\n+            Callee : Entity_Id;\n+\n+            procedure Check_Static_Type (T : Entity_Id; DT : in out Boolean);\n+               --  Given a type T, checks if it is a static type defined as a\n+               --  type with no dynamic bounds in sight. If so, the only action\n+               --  is to set Is_Static_Type True for T. If T is not a static\n+               --  type, then all types with dynamic bounds associated with\n+               --  T are detected, and their bounds are marked as uplevel\n+               --  referenced if not at the library level, and DT is set True.\n+\n+            procedure Note_Uplevel_Ref\n+              (E      : Entity_Id;\n+               Caller : Entity_Id;\n+               Callee : Entity_Id);\n+            --  Called when we detect an explicit or implicit uplevel reference\n+            --  from within Caller to entity E declared in Callee. E can be a\n+            --  an object or a type.\n+\n+            -----------------------\n+            -- Check_Static_Type --\n+            -----------------------\n+\n+            procedure Check_Static_Type (T : Entity_Id; DT : in out Boolean) is\n+               procedure Note_Uplevel_Bound (N : Node_Id);\n+               --  N is the bound of a dynamic type. This procedure notes that\n+               --  this bound is uplevel referenced, it can handle references\n+               --  to entities (typically _FIRST and _LAST entities), and also\n+               --  attribute references of the form T'name (name is typically\n+               --  FIRST or LAST) where T is the uplevel referenced bound.\n+\n+               ------------------------\n+               -- Note_Uplevel_Bound --\n+               ------------------------\n+\n+               procedure Note_Uplevel_Bound (N : Node_Id) is\n+               begin\n+                  --  Entity name case\n+\n+                  if Is_Entity_Name (N) then\n+                     if Present (Entity (N)) then\n+                        Note_Uplevel_Ref\n+                          (E      => Entity (N),\n+                           Caller => Current_Subprogram,\n+                           Callee => Enclosing_Subprogram (Entity (N)));\n+                     end if;\n \n-            function Find_Current_Subprogram return Entity_Id;\n-            --  Finds the current subprogram containing the call N\n+                  --  Attribute case\n \n-            -----------------------------\n-            -- Find_Current_Subprogram --\n-            -----------------------------\n+                  elsif Nkind (N) = N_Attribute_Reference then\n+                     Note_Uplevel_Bound (Prefix (N));\n+                  end if;\n+               end Note_Uplevel_Bound;\n \n-            function Find_Current_Subprogram return Entity_Id is\n-               Nod : Node_Id;\n+            --  Start of processing for Check_Static_Type\n \n             begin\n-               Nod := N;\n-               loop\n-                  Nod := Parent (Nod);\n+               --  If already marked static, immediate return\n \n-                  if Nkind (Nod) = N_Subprogram_Body then\n-                     if Acts_As_Spec (Nod) then\n-                        return Defining_Entity (Specification (Nod));\n-                     else\n-                        return Corresponding_Spec (Nod);\n+               if Is_Static_Type (T) then\n+                  return;\n+               end if;\n+\n+               --  If the type is at library level, always consider it static,\n+               --  since such uplevel references are irrelevant.\n+\n+               if Is_Library_Level_Entity (T) then\n+                  Set_Is_Static_Type (T);\n+                  return;\n+               end if;\n+\n+               --  Otherwise figure out what the story is with this type\n+\n+               --  For a scalar type, check bounds\n+\n+               if Is_Scalar_Type (T) then\n+\n+                  --  If both bounds static, then this is a static type\n+\n+                  declare\n+                     LB : constant Node_Id := Type_Low_Bound (T);\n+                     UB : constant Node_Id := Type_High_Bound (T);\n+\n+                  begin\n+                     if not Is_Static_Expression (LB) then\n+                        Note_Uplevel_Bound (LB);\n+                        DT := True;\n                      end if;\n-                  end if;\n-               end loop;\n-            end Find_Current_Subprogram;\n+\n+                     if not Is_Static_Expression (UB) then\n+                        Note_Uplevel_Bound (UB);\n+                        DT := True;\n+                     end if;\n+                  end;\n+\n+                  --  For record type, check all components\n+\n+               elsif Is_Record_Type (T) then\n+                  declare\n+                     C : Entity_Id;\n+                  begin\n+                     C := First_Component_Or_Discriminant (T);\n+                     while Present (C) loop\n+                        Check_Static_Type (Etype (C), DT);\n+                        Next_Component_Or_Discriminant (C);\n+                     end loop;\n+                  end;\n+\n+                  --  For array type, check index types and component type\n+\n+               elsif Is_Array_Type (T) then\n+                  declare\n+                     IX : Node_Id;\n+                  begin\n+                     Check_Static_Type (Component_Type (T), DT);\n+\n+                     IX := First_Index (T);\n+                     while Present (IX) loop\n+                        Check_Static_Type (Etype (IX), DT);\n+                        Next_Index (IX);\n+                     end loop;\n+                  end;\n+\n+               --  For now, ignore other types\n+\n+               else\n+                  return;\n+               end if;\n+\n+               if not DT then\n+                  Set_Is_Static_Type (T);\n+               end if;\n+            end Check_Static_Type;\n+\n+            ----------------------\n+            -- Note_Uplevel_Ref --\n+            ----------------------\n+\n+            procedure Note_Uplevel_Ref\n+              (E      : Entity_Id;\n+               Caller : Entity_Id;\n+               Callee : Entity_Id)\n+            is\n+            begin\n+               --  Nothing to do for static type\n+\n+               if Is_Static_Type (E) then\n+                  return;\n+               end if;\n+\n+               --  Nothing to do if Caller and Callee are the same\n+\n+               if Caller = Callee then\n+                  return;\n+               end if;\n+\n+               --  We have a new uplevel referenced entity\n+\n+               --  All we do at this stage is to add the uplevel reference to\n+               --  the table. It's too earch to do anything else, since this\n+               --  uplevel reference may come from an unreachable subprogram\n+               --  in which case the entry will be deleted.\n+\n+               Urefs.Append ((N, E, Caller, Callee));\n+            end Note_Uplevel_Ref;\n \n          --  Start of processing for Visit_Node\n \n@@ -557,29 +594,18 @@ package body Exp_Unst is\n \n                if Scope_Within (Ent, Subp) then\n \n-                  --  For now, ignore calls to generic instances. Seems to be\n-                  --  some problem there which we will investigate later ???\n-\n-                  if Original_Location (Sloc (Ent)) /= Sloc (Ent)\n-                    or else Is_Generic_Instance (Ent)\n-                  then\n-                     null;\n-\n                   --  Ignore calls to imported routines\n \n-                  elsif Is_Imported (Ent) then\n+                  if Is_Imported (Ent) then\n                      null;\n \n                   --  Here we have a call to keep and analyze\n \n                   else\n-                     Csub := Find_Current_Subprogram;\n+                     --  Both caller and callee must be subprograms\n \n-                     --  Both caller and callee must be subprograms (we ignore\n-                     --  generic subprograms).\n-\n-                     if Is_Subprogram (Csub) and then Is_Subprogram (Ent) then\n-                        Calls.Append ((N, Find_Current_Subprogram, Ent));\n+                     if Is_Subprogram (Ent) then\n+                        Calls.Append ((N, Current_Subprogram, Ent));\n                      end if;\n                   end if;\n                end if;\n@@ -589,103 +615,425 @@ package body Exp_Unst is\n             --  that it has a corresponding body we can get hold of. The case\n             --  of no corresponding body being available is ignored for now.\n \n-            elsif (Nkind (N) = N_Subprogram_Body and then Acts_As_Spec (N))\n-              or else (Nkind (N) = N_Subprogram_Declaration\n-                        and then Present (Corresponding_Body (N)))\n-            then\n-               Subps.Increment_Last;\n+            elsif Nkind (N) = N_Subprogram_Body then\n+               Ent := Corresponding_Spec_Of (N);\n+\n+               --  Ignore generic subprogram\n+\n+               if Is_Generic_Subprogram (Ent) then\n+                  return Skip;\n+               end if;\n+\n+               --  Make new entry in subprogram table if not already made\n+\n+               declare\n+                  L : constant Nat := Get_Level (Ent);\n+               begin\n+                  Subps.Append\n+                    ((Ent           => Ent,\n+                      Bod           => N,\n+                      Lev           => L,\n+                      Reachable     => False,\n+                      Uplevel_Ref   => L,\n+                      Declares_AREC => False,\n+                      Uents         => No_Elist,\n+                      ARECnF        => Empty,\n+                      ARECn         => Empty,\n+                      ARECnT        => Empty,\n+                      ARECnPT       => Empty,\n+                      ARECnP        => Empty,\n+                      ARECnU        => Empty));\n+                  Set_Subps_Index (Ent, UI_From_Int (Subps.Last));\n+               end;\n+\n+               --  We make a recursive call to scan the subprogram body, so\n+               --  that we can save and restore Current_Subprogram.\n \n                declare\n-                  STJ : Subp_Entry renames Subps.Table (Subps.Last);\n+                  Save_CS : constant Entity_Id := Current_Subprogram;\n+                  Decl    : Node_Id;\n \n                begin\n-                  --  Set fields of Subp_Entry for new subprogram\n+                  Current_Subprogram := Ent;\n \n-                  STJ.Ent := Defining_Entity (Specification (N));\n-                  STJ.Lev := Get_Level (STJ.Ent);\n+                  --  Scan declarations\n \n-                  if Nkind (N) = N_Subprogram_Body then\n-                     STJ.Bod := N;\n-                  else\n-                     STJ.Bod :=\n-                       Parent (Declaration_Node (Corresponding_Body (N)));\n-                     pragma Assert (Nkind (STJ.Bod) = N_Subprogram_Body);\n-                  end if;\n+                  Decl := First (Declarations (N));\n+                  while Present (Decl) loop\n+                     Visit (Decl);\n+                     Next (Decl);\n+                  end loop;\n+\n+                  --  Scan statements\n+\n+                  Visit (Handled_Statement_Sequence (N));\n \n-                  --  Capture Uplevel_References, and then set (uses the same\n-                  --  field), the Subps_Index value for this subprogram.\n+                  --  Restore current subprogram setting\n \n-                  STJ.Urefs := Uplevel_References (STJ.Ent);\n-                  Set_Subps_Index (STJ.Ent, UI_From_Int (Int (Subps.Last)));\n+                  Current_Subprogram := Save_CS;\n                end;\n+\n+               --  Now at this level, return skipping the subprogram body\n+               --  descendents, since we already took care of them!\n+\n+               return Skip;\n+\n+            --  Record an uplevel reference\n+\n+            elsif Nkind (N) in N_Has_Entity and then Present (Entity (N)) then\n+               Ent := Entity (N);\n+\n+               --  Only interested in entities declared within our nest\n+\n+               if not Is_Library_Level_Entity (Ent)\n+                 and then Scope_Within_Or_Same (Scope (Ent), Subp)\n+                 and then\n+\n+                   --  Constants and variables are interesting\n+\n+                   (Ekind_In (Ent, E_Constant, E_Variable)\n+\n+                     --  Formals are interesting, but not if being used as mere\n+                     --  names of parameters for name notation calls.\n+\n+                     or else\n+                       (Is_Formal (Ent)\n+                         and then not\n+                          (Nkind (Parent (N)) = N_Parameter_Association\n+                            and then Selector_Name (Parent (N)) = N))\n+\n+                     --  Types other than known Is_Static types are interesting\n+\n+                     or else (Is_Type (Ent)\n+                               and then not Is_Static_Type (Ent)))\n+               then\n+                  --  Here we have a possible interesting uplevel reference\n+\n+                  if Is_Type (Ent) then\n+                     declare\n+                        DT : Boolean := False;\n+\n+                     begin\n+                        Check_Static_Type (Ent, DT);\n+\n+                        if Is_Static_Type (Ent) then\n+                           return OK;\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  Caller := Current_Subprogram;\n+                  Callee := Enclosing_Subprogram (Ent);\n+\n+                  if Callee /= Caller and then not Is_Static_Type (Ent) then\n+                     Note_Uplevel_Ref (Ent, Caller, Callee);\n+                  end if;\n+               end if;\n+\n+            --  Skip generic declarations\n+\n+            elsif Nkind (N) in N_Generic_Declaration then\n+               return Skip;\n+\n+            --  Skip generic package body\n+\n+            elsif Nkind (N) = N_Package_Body\n+              and then Present (Corresponding_Spec (N))\n+              and then Ekind (Corresponding_Spec (N)) = E_Generic_Package\n+            then\n+               return Skip;\n             end if;\n \n+            --  Fall through to continue scanning children of this node\n+\n             return OK;\n          end Visit_Node;\n \n-         -----------\n-         -- Visit --\n-         -----------\n-\n-         procedure Visit is new Traverse_Proc (Visit_Node);\n-         --  Used to traverse the body of Subp, populating the tables\n-\n       --  Start of processing for Build_Tables\n \n       begin\n-         --  A special case, if the outer level subprogram has a separate spec\n-         --  then we won't catch it in the traversal of the body. But we do\n-         --  want to visit the declaration in this case!\n-\n-         if not Acts_As_Spec (Subp_Body) then\n-            declare\n-               Dummy : Traverse_Result;\n-               Decl  : constant Node_Id :=\n-                 Parent (Declaration_Node (Corresponding_Spec (Subp_Body)));\n-               pragma Assert (Nkind (Decl) = N_Subprogram_Declaration);\n-            begin\n-               Dummy := Visit_Node (Decl);\n-            end;\n-         end if;\n-\n-         --  Traverse the body to get the rest of the subprograms and calls\n+         --  Traverse the body to get subprograms, calls and uplevel references\n \n          Visit (Subp_Body);\n       end Build_Tables;\n \n-      --  Second step is to do the transitive closure, if any subprogram has\n-      --  a call to a subprogram for which Has_Uplevel_Reference is set, then\n-      --  we set Has_Uplevel_Reference for the calling routine.\n+      --  Now do the first transitive closure which determines which\n+      --  subprograms in the nest are actually reachable.\n \n-      Closure : declare\n+      Reachable_Closure : declare\n          Modified : Boolean;\n \n       begin\n+         Subps.Table (1).Reachable := True;\n+\n          --  We use a simple minded algorithm as follows (obviously this can\n          --  be done more efficiently, using one of the standard algorithms\n          --  for efficient transitive closure computation, but this is simple\n          --  and most likely fast enough that its speed does not matter).\n \n          --  Repeatedly scan the list of calls. Any time we find a call from\n-         --  A to B, where A does not have Has_Uplevel_Reference, and B does\n-         --  have this flag set, then set the flag for A, and note that we\n-         --  have made a change by setting Modified True. We repeat this until\n-         --  we make a pass with no modifications.\n+         --  A to B, where A is reachable, but B is not, then B is reachable,\n+         --  and note that we have made a change by setting Modified True. We\n+         --  repeat this until we make a pass with no modifications.\n \n          Outer : loop\n             Modified := False;\n             Inner : for J in Calls.First .. Calls.Last loop\n-               if not Has_Uplevel_Reference (Calls.Table (J).From)\n-                 and then Has_Uplevel_Reference (Calls.Table (J).To)\n-               then\n-                  Set_Has_Uplevel_Reference (Calls.Table (J).From);\n-                  Modified := True;\n-               end if;\n+               declare\n+                  CTJ : Call_Entry renames Calls.Table (J);\n+\n+                  SINF : constant SI_Type := Subp_Index (CTJ.Caller);\n+                  SINT : constant SI_Type := Subp_Index (CTJ.Callee);\n+\n+                  SUBF : Subp_Entry renames Subps.Table (SINF);\n+                  SUBT : Subp_Entry renames Subps.Table (SINT);\n+\n+               begin\n+                  if SUBF.Reachable and then not SUBT.Reachable then\n+                     SUBT.Reachable := True;\n+                     Modified := True;\n+                  end if;\n+               end;\n             end loop Inner;\n \n             exit Outer when not Modified;\n          end loop Outer;\n-      end Closure;\n+      end Reachable_Closure;\n+\n+      --  Remove calls from unreachable subprograms\n+\n+      declare\n+         New_Index : Nat;\n+\n+      begin\n+         New_Index := 0;\n+         for J in Calls.First .. Calls.Last loop\n+            declare\n+               CTJ : Call_Entry renames Calls.Table (J);\n+\n+               SINF : constant SI_Type := Subp_Index (CTJ.Caller);\n+               SINT : constant SI_Type := Subp_Index (CTJ.Callee);\n+\n+               SUBF : Subp_Entry renames Subps.Table (SINF);\n+               SUBT : Subp_Entry renames Subps.Table (SINT);\n+\n+            begin\n+               if SUBF.Reachable then\n+                  pragma Assert (SUBT.Reachable);\n+                  New_Index := New_Index + 1;\n+                  Calls.Table (New_Index) := Calls.Table (J);\n+               end if;\n+            end;\n+         end loop;\n+\n+         Calls.Set_Last (New_Index);\n+      end;\n+\n+      --  Remove uplevel references from unreachable subprograms\n+\n+      declare\n+         New_Index : Nat;\n+\n+      begin\n+         New_Index := 0;\n+         for J in Urefs.First .. Urefs.Last loop\n+            declare\n+               URJ : Uref_Entry renames Urefs.Table (J);\n+\n+               SINF : constant SI_Type := Subp_Index (URJ.Caller);\n+               SINT : constant SI_Type := Subp_Index (URJ.Callee);\n+\n+               SUBF : Subp_Entry renames Subps.Table (SINF);\n+               SUBT : Subp_Entry renames Subps.Table (SINT);\n+\n+               S : Entity_Id;\n+\n+            begin\n+               --  Keep reachable reference\n+\n+               if SUBF.Reachable then\n+                  New_Index := New_Index + 1;\n+                  Urefs.Table (New_Index) := Urefs.Table (J);\n+\n+                  --  And since we know we are keeping this one, this is a good\n+                  --  place to fill in information for a good reference.\n+\n+                  --  Mark all enclosing subprograms need to declare AREC\n+\n+                  S := URJ.Caller;\n+                  loop\n+                     S := Enclosing_Subprogram (S);\n+                     Subps.Table (Subp_Index (S)).Declares_AREC := True;\n+                     exit when S = URJ.Callee;\n+                  end loop;\n+\n+                  --  Add to list of uplevel referenced entities for Callee.\n+                  --  We do not add types to this list, only actual references\n+                  --  to objects that will be referenced uplevel, and we use\n+                  --  the flag Is_Uplevel_Referenced_Entity to avoid making\n+                  --  duplicate entries in the list.\n+\n+                  if not Is_Uplevel_Referenced_Entity (URJ.Ent) then\n+                     Set_Is_Uplevel_Referenced_Entity (URJ.Ent);\n+\n+                     if not Is_Type (URJ.Ent) then\n+                        Append_New_Elmt (URJ.Ent, SUBT.Uents);\n+                     end if;\n+                  end if;\n+\n+                  --  And set uplevel indication for caller\n+\n+                  if SUBT.Lev < SUBF.Uplevel_Ref then\n+                     SUBF.Uplevel_Ref := SUBT.Lev;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+         Urefs.Set_Last (New_Index);\n+      end;\n+\n+      --  Remove unreachable subprograms from Subps table. Note that we do\n+      --  this after eliminating entries from the other two tables, since\n+      --  thos elimination steps depend on referencing the Subps table.\n+\n+      declare\n+         New_SI : SI_Type;\n+\n+      begin\n+         New_SI := 0;\n+         for J in Subps.First .. Subps.Last loop\n+            declare\n+               STJ  : Subp_Entry renames Subps.Table (J);\n+               Spec : Node_Id;\n+               Decl : Node_Id;\n+\n+            begin\n+               --  Subprogram is reachable, copy and reset index\n+\n+               if STJ.Reachable then\n+                  New_SI := New_SI + 1;\n+                  Subps.Table (New_SI) := STJ;\n+                  Set_Subps_Index (STJ.Ent, UI_From_Int (New_SI));\n+\n+               --  Subprogram is not reachable\n+\n+               else\n+                  --  Clear index, since no longer active\n+\n+                  Set_Subps_Index (Subps.Table (J).Ent, Uint_0);\n+\n+                  --  Output debug information if -gnatd.3 set\n+\n+                  if Debug_Flag_Dot_3 then\n+                     Write_Str (\"Eliminate \");\n+                     Write_Name (Chars (Subps.Table (J).Ent));\n+                     Write_Str (\" at \");\n+                     Write_Location (Sloc (Subps.Table (J).Ent));\n+                     Write_Str (\" (not referenced)\");\n+                     Write_Eol;\n+                  end if;\n+\n+                  --  Rewrite declaration and body to null statements\n+\n+                  Spec := Corresponding_Spec (STJ.Bod);\n+\n+                  if Present (Spec) then\n+                     Decl := Parent (Declaration_Node (Spec));\n+                     Rewrite (Decl, Make_Null_Statement (Sloc (Decl)));\n+                  end if;\n+\n+                  Rewrite (STJ.Bod, Make_Null_Statement (Sloc (STJ.Bod)));\n+               end if;\n+            end;\n+         end loop;\n+\n+         Subps.Set_Last (New_SI);\n+      end;\n+\n+      --  Now it is time for the second transitive closure, which follows calls\n+      --  and makes sure that A calls B, and B has uplevel references, then A\n+      --  is also marked as having uplevel references.\n+\n+      Closure_Uplevel : declare\n+         Modified : Boolean;\n+\n+      begin\n+         --  We use a simple minded algorithm as follows (obviously this can\n+         --  be done more efficiently, using one of the standard algorithms\n+         --  for efficient transitive closure computation, but this is simple\n+         --  and most likely fast enough that its speed does not matter).\n+\n+         --  Repeatedly scan the list of calls. Any time we find a call from\n+         --  A to B, where B has uplevel references, make sure that A is marked\n+         --  as having at least the same level of uplevel referencing.\n+\n+         Outer2 : loop\n+            Modified := False;\n+            Inner2 : for J in Calls.First .. Calls.Last loop\n+               declare\n+                  CTJ  : Call_Entry renames Calls.Table (J);\n+                  SINF : constant SI_Type := Subp_Index (CTJ.Caller);\n+                  SINT : constant SI_Type := Subp_Index (CTJ.Callee);\n+                  SUBF : Subp_Entry renames Subps.Table (SINF);\n+                  SUBT : Subp_Entry renames Subps.Table (SINT);\n+               begin\n+                  if SUBT.Lev > SUBT.Uplevel_Ref\n+                    and then SUBF.Uplevel_Ref > SUBT.Uplevel_Ref\n+                  then\n+                     SUBF.Uplevel_Ref := SUBT.Uplevel_Ref;\n+                     Modified := True;\n+                  end if;\n+               end;\n+            end loop Inner2;\n+\n+            exit Outer2 when not Modified;\n+         end loop Outer2;\n+      end Closure_Uplevel;\n+\n+      --  We have one more step before the tables are complete. An uplevel\n+      --  call from subprogram A to subprogram B where subprogram B has uplevel\n+      --  references is in effect an uplevel reference, and must arrange for\n+      --  the proper activation link to be passed.\n+\n+      for J in Calls.First .. Calls.Last loop\n+         declare\n+            CTJ : Call_Entry renames Calls.Table (J);\n+\n+            SINF : constant SI_Type := Subp_Index (CTJ.Caller);\n+            SINT : constant SI_Type := Subp_Index (CTJ.Callee);\n+\n+            SUBF : Subp_Entry renames Subps.Table (SINF);\n+            SUBT : Subp_Entry renames Subps.Table (SINT);\n+\n+            A : Entity_Id;\n+\n+         begin\n+            --  If callee has uplevel references\n+\n+            if SUBT.Uplevel_Ref < SUBT.Lev\n+\n+              --  And this is an uplevel call\n+\n+              and then SUBT.Lev < SUBF.Lev\n+            then\n+               --  We need to arrange for finding the uplink\n+\n+               A := CTJ.Caller;\n+               loop\n+                  A := Enclosing_Subprogram (A);\n+                  Subps.Table (Subp_Index (A)).Declares_AREC := True;\n+                  exit when A = CTJ.Callee;\n+\n+                  --  In any case exit when we get to the outer level. This\n+                  --  happens in some odd cases with generics (in particular\n+                  --  sem_ch3.adb does not compile without this kludge ???).\n+\n+                  exit when A = Subp;\n+               end loop;\n+            end if;\n+         end;\n+      end loop;\n \n       --  Next step, create the entities for code we will insert. We do this\n       --  at the start so that all the entities are defined, regardless of the\n@@ -698,30 +1046,18 @@ package body Exp_Unst is\n             ARS : constant String     := AREC_String (STJ.Lev);\n \n          begin\n-            --  First we create the ARECnF entity for the additional formal\n-            --  for all subprograms requiring that an activation record pointer\n-            --  be passed. This is true of all subprograms that have uplevel\n-            --  references, and whose enclosing subprogram also has uplevel\n-            --  references.\n-\n-            if Has_Uplevel_Reference (STJ.Ent)\n-              and then STJ.Ent /= Subp\n-              and then Has_Uplevel_Reference (Enclosing_Subprogram (STJ.Ent))\n-            then\n+            --  First we create the ARECnF entity for the additional formal for\n+            --  all subprograms which need an activation record passed.\n+\n+            if STJ.Uplevel_Ref < STJ.Lev then\n                STJ.ARECnF :=\n                  Make_Defining_Identifier (Loc,\n                    Chars => Name_Find_Str (AREC_String (STJ.Lev - 1) & \"F\"));\n-            else\n-               STJ.ARECnF := Empty;\n             end if;\n \n-            --  Now define the AREC entities for the activation record. This\n-            --  is needed for any subprogram that has nested subprograms and\n-            --  has uplevel references.\n+            --  Define the AREC entities for the activation record if needed\n \n-            if Has_Nested_Subprogram (STJ.Ent)\n-              and then Has_Uplevel_Reference (STJ.Ent)\n-            then\n+            if STJ.Declares_AREC then\n                STJ.ARECn   :=\n                  Make_Defining_Identifier (Loc, Name_Find_Str (ARS));\n                STJ.ARECnT  :=\n@@ -731,27 +1067,17 @@ package body Exp_Unst is\n                STJ.ARECnP  :=\n                  Make_Defining_Identifier (Loc, Name_Find_Str (ARS & \"P\"));\n \n-            else\n-               STJ.ARECn   := Empty;\n-               STJ.ARECnT  := Empty;\n-               STJ.ARECnPT := Empty;\n-               STJ.ARECnP  := Empty;\n-               STJ.ARECnU  := Empty;\n-            end if;\n-\n-            --  Define uplink component entity if inner nesting case\n-\n-            if Has_Uplevel_Reference (STJ.Ent) and then STJ.Lev > 1 then\n-               declare\n-                  ARS1 : constant String := AREC_String (STJ.Lev - 1);\n-               begin\n-                  STJ.ARECnU :=\n-                    Make_Defining_Identifier (Loc,\n-                      Chars => Name_Find_Str (ARS1 & \"U\"));\n-               end;\n+               --  Define uplink component entity if inner nesting case\n \n-            else\n-               STJ.ARECnU := Empty;\n+               if Present (STJ.ARECnF) then\n+                  declare\n+                     ARS1 : constant String := AREC_String (STJ.Lev - 1);\n+                  begin\n+                     STJ.ARECnU :=\n+                       Make_Defining_Identifier (Loc,\n+                         Chars => Name_Find_Str (ARS1 & \"U\"));\n+                  end;\n+               end if;\n             end if;\n          end;\n       end loop Create_Entities;\n@@ -850,19 +1176,14 @@ package body Exp_Unst is\n                   end Add_Extra_Formal;\n                end if;\n \n-               --  Processing for subprograms that have at least one nested\n-               --  subprogram, and have uplevel references.\n+               --  Processing for subprograms that declare an activation record\n+\n+               if Present (STJ.ARECn) then\n \n-               if Has_Nested_Subprogram (STJ.Ent)\n-                 and then Has_Uplevel_Reference (STJ.Ent)\n-               then\n                   --  Local declarations for one such subprogram\n \n                   declare\n                      Loc   : constant Source_Ptr := Sloc (STJ.Bod);\n-                     Elmt  : Elmt_Id;\n-                     Nod   : Node_Id;\n-                     Ent   : Entity_Id;\n                      Clist : List_Id;\n                      Comp  : Entity_Id;\n \n@@ -872,44 +1193,13 @@ package body Exp_Unst is\n                      Decl_ARECnP  : Node_Id;\n                      --  Declaration nodes for the AREC entities we build\n \n-                     Uplevel_Entities :\n-                       array (1 .. List_Length (STJ.Urefs)) of Entity_Id;\n-                     Num_Uplevel_Entities : Nat;\n-                     --  Uplevel_Entities (1 .. Num_Uplevel_Entities) contains\n-                     --  a list (with no duplicates) of the entities for this\n-                     --  subprogram that are referenced uplevel. The maximum\n-                     --  number of entries cannot exceed the total number of\n-                     --  uplevel references.\n-\n                   begin\n-                     --  Populate the Uplevel_Entities array, using the flag\n-                     --  Uplevel_Reference_Noted to avoid duplicates.\n-\n-                     Num_Uplevel_Entities := 0;\n-\n-                     if Present (STJ.Urefs) then\n-                        Elmt := First_Elmt (STJ.Urefs);\n-                        while Present (Elmt) loop\n-                           Nod := Actual_Ref (Node (Elmt));\n-                           Ent := Entity (Nod);\n-\n-                           if not Uplevel_Reference_Noted (Ent) then\n-                              Set_Uplevel_Reference_Noted (Ent, True);\n-                              Num_Uplevel_Entities := Num_Uplevel_Entities + 1;\n-                              Uplevel_Entities (Num_Uplevel_Entities) := Ent;\n-                           end if;\n-\n-                           Next_Elmt (Elmt);\n-                           Next_Elmt (Elmt);\n-                        end loop;\n-                     end if;\n-\n                      --  Build list of component declarations for ARECnT\n \n                      Clist := Empty_List;\n \n                      --  If we are in a subprogram that has a static link that\n-                     --  ias passed in (as indicated by ARECnF being deinfed),\n+                     --  is passed in (as indicated by ARECnF being defined),\n                      --  then include ARECnU : ARECnPT := ARECnF where n is\n                      --  one less than the current level and the entity ARECnPT\n                      --  comes from the enclosing subprogram.\n@@ -934,22 +1224,35 @@ package body Exp_Unst is\n \n                      --  Add components for uplevel referenced entities\n \n-                     for J in 1 .. Num_Uplevel_Entities loop\n-                        Comp :=\n-                          Make_Defining_Identifier (Loc,\n-                            Chars => Upref_Name (Uplevel_Entities (J)));\n-\n-                        Set_Activation_Record_Component\n-                          (Uplevel_Entities (J), Comp);\n-\n-                        Append_To (Clist,\n-                          Make_Component_Declaration (Loc,\n-                            Defining_Identifier  => Comp,\n-                            Component_Definition =>\n-                              Make_Component_Definition (Loc,\n-                                Subtype_Indication =>\n-                                  New_Occurrence_Of (Addr, Loc))));\n-                     end loop;\n+                     if Present (STJ.Uents) then\n+                        declare\n+                           Elmt : Elmt_Id;\n+                           Uent : Entity_Id;\n+\n+                        begin\n+                           Elmt := First_Elmt (STJ.Uents);\n+                           while Present (Elmt) loop\n+                              Uent := Node (Elmt);\n+\n+                              Comp :=\n+                                Make_Defining_Identifier (Loc,\n+                                  Chars => Upref_Name (Uent, Clist));\n+\n+                              Set_Activation_Record_Component\n+                                (Uent, Comp);\n+\n+                              Append_To (Clist,\n+                                Make_Component_Declaration (Loc,\n+                                  Defining_Identifier  => Comp,\n+                                  Component_Definition =>\n+                                    Make_Component_Definition (Loc,\n+                                      Subtype_Indication =>\n+                                        New_Occurrence_Of (Addr, Loc))));\n+\n+                              Next_Elmt (Elmt);\n+                           end loop;\n+                        end;\n+                     end if;\n \n                      --  Now we can insert the AREC declarations into the body\n \n@@ -1010,89 +1313,93 @@ package body Exp_Unst is\n                      --  newly created entities go in the right entity chain.\n \n                      --  We analyze with all checks suppressed (since we do\n-                     --  not expect any exceptions, and also we temporarily\n-                     --  turn off Unested_Subprogram_Mode to avoid trying to\n-                     --  mark uplevel references (not needed at this stage,\n-                     --  and in fact causes a bit of recursive chaos).\n+                     --  not expect any exceptions).\n \n                      Push_Scope (STJ.Ent);\n-                     Opt.Unnest_Subprogram_Mode := False;\n                      Analyze (Decl_ARECnT,  Suppress => All_Checks);\n                      Analyze (Decl_ARECn,   Suppress => All_Checks);\n                      Analyze (Decl_ARECnPT, Suppress => All_Checks);\n                      Analyze (Decl_ARECnP,  Suppress => All_Checks);\n-                     Opt.Unnest_Subprogram_Mode := True;\n                      Pop_Scope;\n \n                      --  Next step, for each uplevel referenced entity, add\n-                     --  assignment operations to set the comoponent in the\n+                     --  assignment operations to set the component in the\n                      --  activation record.\n \n-                     for J in 1 .. Num_Uplevel_Entities loop\n+                     if Present (STJ.Uents) then\n                         declare\n-                           Ent : constant Entity_Id  := Uplevel_Entities (J);\n-                           Loc : constant Source_Ptr := Sloc (Ent);\n-                           Dec : constant Node_Id    := Declaration_Node (Ent);\n-                           Ins : Node_Id;\n-                           Asn : Node_Id;\n+                           Elmt : Elmt_Id;\n \n                         begin\n-                           --  For parameters, we insert the assignment right\n-                           --  after the declaration of ARECnP. For all other\n-                           --  entities, we insert the assignment immediately\n-                           --  after the declaration of the entity.\n-\n-                           --  Note: we don't need to mark the entity as being\n-                           --  aliased, because the address attribute will mark\n-                           --  it as Address_Taken, and that is good enough.\n-\n-                           if Is_Formal (Ent) then\n-                              Ins := Decl_ARECnP;\n-                           else\n-                              Ins := Dec;\n-                           end if;\n-\n-                           --  Build and insert the assignment:\n-                           --    ARECn.nam := nam'Address\n-\n-                           Asn :=\n-                             Make_Assignment_Statement (Loc,\n-                               Name       =>\n-                                 Make_Selected_Component (Loc,\n-                                   Prefix        =>\n-                                     New_Occurrence_Of (STJ.ARECn, Loc),\n-                                   Selector_Name =>\n-                                     New_Occurrence_Of\n-                                       (Activation_Record_Component (Ent),\n-                                        Loc)),\n-\n-                               Expression =>\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                     New_Occurrence_Of (Ent, Loc),\n-                                   Attribute_Name => Name_Address));\n-\n-                           Insert_After (Ins, Asn);\n-\n-                           --  Analyze the assignment statement. We do not need\n-                           --  to establish the relevant scope stack entries\n-                           --  here, because we have already set the correct\n-                           --  entity references, so no name resolution is\n-                           --  required, and no new entities are created, so\n-                           --  we don't even need to set the current scope.\n-\n-                           --  We analyze with all checks suppressed (since\n-                           --  we do not expect any exceptions, and also we\n-                           --  temporarily turn off Unested_Subprogram_Mode\n-                           --  to avoid trying to mark uplevel references (not\n-                           --  needed at this stage, and in fact causes a bit\n-                           --  of recursive chaos).\n-\n-                           Opt.Unnest_Subprogram_Mode := False;\n-                           Analyze (Asn, Suppress => All_Checks);\n-                           Opt.Unnest_Subprogram_Mode := True;\n+                           Elmt := First_Elmt (STJ.Uents);\n+                           while Present (Elmt) loop\n+                              declare\n+                                 Ent : constant Entity_Id  := Node (Elmt);\n+                                 Loc : constant Source_Ptr := Sloc (Ent);\n+                                 Dec : constant Node_Id    :=\n+                                         Declaration_Node (Ent);\n+                                 Ins : Node_Id;\n+                                 Asn : Node_Id;\n+\n+                              begin\n+                                 --  For parameters, we insert the assignment\n+                                 --  right after the declaration of ARECnP.\n+                                 --  For all other entities, we insert\n+                                 --  the assignment immediately after\n+                                 --  the declaration of the entity.\n+\n+                                 --  Note: we don't need to mark the entity\n+                                 --  as being aliased, because the address\n+                                 --  attribute will mark it as Address_Taken,\n+                                 --  and that is good enough.\n+\n+                                 if Is_Formal (Ent) then\n+                                    Ins := Decl_ARECnP;\n+                                 else\n+                                    Ins := Dec;\n+                                 end if;\n+\n+                                 --  Build and insert the assignment:\n+                                 --    ARECn.nam := nam'Address\n+\n+                                 Asn :=\n+                                   Make_Assignment_Statement (Loc,\n+                                     Name       =>\n+                                       Make_Selected_Component (Loc,\n+                                         Prefix        =>\n+                                           New_Occurrence_Of (STJ.ARECn, Loc),\n+                                         Selector_Name =>\n+                                           New_Occurrence_Of\n+                                             (Activation_Record_Component\n+                                                (Ent),\n+                                              Loc)),\n+\n+                                     Expression =>\n+                                       Make_Attribute_Reference (Loc,\n+                                         Prefix         =>\n+                                           New_Occurrence_Of (Ent, Loc),\n+                                         Attribute_Name => Name_Address));\n+\n+                                 Insert_After (Ins, Asn);\n+\n+                                 --  Analyze the assignment statement. We do\n+                                 --  not need to establish the relevant scope\n+                                 --  stack entries here, because we have\n+                                 --  already set the correct entity references,\n+                                 --  so no name resolution is required, and no\n+                                 --  new entities are created, so we don't even\n+                                 --  need to set the current scope.\n+\n+                                 --  We analyze with all checks suppressed\n+                                 --  (since we do not expect any exceptions).\n+\n+                                 Analyze (Asn, Suppress => All_Checks);\n+                              end;\n+\n+                              Next_Elmt (Elmt);\n+                           end loop;\n                         end;\n-                     end loop;\n+                     end if;\n                   end;\n                end if;\n             end;\n@@ -1104,204 +1411,141 @@ package body Exp_Unst is\n       --  need all the AREC declarations generated, inserted, and analyzed so\n       --  that the uplevel references can be successfully analyzed.\n \n-      Uplev_Refs : for J in Subps.First .. Subps.Last loop\n+      Uplev_Refs : for J in Urefs.First .. Urefs.Last loop\n          declare\n-            STJ : Subp_Entry renames Subps.Table (J);\n+            UPJ : Uref_Entry renames Urefs.Table (J);\n \n          begin\n-            --  We are only interested in entries which have uplevel references\n-            --  to deal with, as indicated by the Urefs list being present\n-\n-            if Present (STJ.Urefs) then\n-\n-               --  Process uplevel references for one subprogram\n-\n-               Uplev_Refs_For_One_Subp : declare\n-                  Elmt : Elmt_Id;\n-\n-                  function Get_Real_Subp (Ent : Entity_Id) return Entity_Id;\n-                  --  The entity recorded as the enclosing subprogram for the\n-                  --  reference sometimes turns out to be a subprogram body.\n-                  --  This function gets the proper subprogram spec if needed.\n-\n-                  -------------------\n-                  -- Get_Real_Subp --\n-                  -------------------\n-\n-                  function Get_Real_Subp (Ent : Entity_Id) return Entity_Id is\n-                     Nod : Node_Id;\n+            --  Ignore type references, these are implicit references that do\n+            --  not need rewriting (e.g. the appearence in a conversion).\n \n-                  begin\n-                     --  If we have a subprogram, return it\n-\n-                     if Is_Subprogram (Ent) then\n-                        return Ent;\n-\n-                     --  If we have a subprogram body, go to the body\n-\n-                     elsif Ekind (Ent) = E_Subprogram_Body then\n-                        Nod := Parent (Parent (Ent));\n-                        pragma Assert (Nkind (Nod) = N_Subprogram_Body);\n-\n-                        if Acts_As_Spec (Nod) then\n-                           return Ent;\n-                        else\n-                           return Corresponding_Spec (Nod);\n-                        end if;\n-\n-                     --  Should not be any other possibilities\n-\n-                     else\n-                        raise Program_Error;\n-                     end if;\n-                  end Get_Real_Subp;\n-\n-               --  Start of processing for Uplevel_References_For_One_Subp\n-\n-               begin\n-                  --  Loop through uplevel references\n-\n-                  Elmt := First_Elmt (STJ.Urefs);\n-                  while Present (Elmt) loop\n-\n-                     --  Rewrite one reference\n-\n-                     Rewrite_One_Ref : declare\n-                        Ref : constant Node_Id := Actual_Ref (Node (Elmt));\n-                        --  The reference to be rewritten\n+            if Is_Type (UPJ.Ent) then\n+               goto Continue;\n+            end if;\n \n-                        Loc : constant Source_Ptr := Sloc (Ref);\n-                        --  Source location for the reference\n+            --  Rewrite one reference\n \n-                        Ent : constant Entity_Id := Entity (Ref);\n-                        --  The referenced entity\n+            Rewrite_One_Ref : declare\n+               Loc : constant Source_Ptr := Sloc (UPJ.Ref);\n+               --  Source location for the reference\n \n-                        Typ : constant Entity_Id := Etype (Ent);\n-                        --  The type of the referenced entity\n+               Typ : constant Entity_Id := Etype (UPJ.Ent);\n+               --  The type of the referenced entity\n \n-                        Atyp : constant Entity_Id := Get_Actual_Subtype (Ref);\n-                        --  The actual subtype of the reference\n+               Atyp : constant Entity_Id := Get_Actual_Subtype (UPJ.Ref);\n+               --  The actual subtype of the reference\n \n-                        Rsub : constant Entity_Id :=\n-                                 Get_Real_Subp (Node (Next_Elmt (Elmt)));\n-                        --  The enclosing subprogram for the reference\n+               RS_Caller : constant SI_Type := Subp_Index (UPJ.Caller);\n+               --  Subp_Index for caller containing reference\n \n-                        RSX : constant SI_Type := Subp_Index (Rsub);\n-                        --  Subp_Index for enclosing subprogram for ref\n+               STJR : Subp_Entry renames Subps.Table (RS_Caller);\n+               --  Subp_Entry for subprogram containing reference\n \n-                        STJR : Subp_Entry renames Subps.Table (RSX);\n-                        --  Subp_Entry for enclosing subprogram for ref\n+               RS_Callee : constant SI_Type := Subp_Index (UPJ.Callee);\n+               --  Subp_Index for subprogram containing referenced entity\n \n-                        Pfx  : Node_Id;\n-                        Comp : Entity_Id;\n-                        SI   : SI_Type;\n+               STJE : Subp_Entry renames Subps.Table (RS_Callee);\n+               --  Subp_Entry for subprogram containing referenced entity\n \n-                     begin\n-                        --  Ignore if no ARECnF entity for enclosing subprogram\n-                        --  which probably happens as a result of not properly\n-                        --  treating instance bodies. To be examined ???\n+               Pfx  : Node_Id;\n+               Comp : Entity_Id;\n+               SI   : SI_Type;\n \n-                        --  If this test is omitted, then the compilation of\n-                        --  freeze.adb and inline.adb fail in unnesting mode.\n+            begin\n+               --  Ignore if no ARECnF entity for enclosing subprogram which\n+               --  probably happens as a result of not properly treating\n+               --  instance bodies. To be examined ???\n \n-                        if No (STJR.ARECnF) then\n-                           goto Continue;\n-                        end if;\n+               --  If this test is omitted, then the compilation of\n+               --  freeze.adb and inline.adb fail in unnesting mode.\n \n-                        --  Push the current scope, so that the pointer type\n-                        --  Tnn, and any subsidiary entities resulting from\n-                        --  the analysis of the rewritten reference, go in the\n-                        --  right entity chain.\n+               if No (STJR.ARECnF) then\n+                  goto Continue;\n+               end if;\n \n-                        Push_Scope (STJR.Ent);\n+               --  Push the current scope, so that the pointer type Tnn, and\n+               --  any subsidiary entities resulting from the analysis of the\n+               --  rewritten reference, go in the right entity chain.\n \n-                        --  Now we need to rewrite the reference. We have a\n-                        --  reference is from level STJE.Lev to level STJ.Lev.\n-                        --  The general form of the rewritten reference for\n-                        --  entity X is:\n+               Push_Scope (STJR.Ent);\n \n-                        --   Typ'Deref (ARECaF.ARECbU.ARECcU.ARECdU....ARECm.X)\n+               --  Now we need to rewrite the reference. We have a\n+               --  reference is from level STJR.Lev to level STJE.Lev.\n+               --  The general form of the rewritten reference for\n+               --  entity X is:\n \n-                        --  where a,b,c,d .. m =\n-                        --    STJR.Lev - 1,  STJ.Lev - 2, .. STJ.Lev\n+               --   Typ'Deref (ARECaF.ARECbU.ARECcU.ARECdU....ARECm.X)\n \n-                        pragma Assert (STJR.Lev > STJ.Lev);\n+               --  where a,b,c,d .. m =\n+               --    STJR.Lev - 1,  STJR.Lev - 2, .. STJE.Lev\n \n-                        --  Compute the prefix of X. Here are examples to make\n-                        --  things clear (with parens to show groupings, the\n-                        --  prefix is everything except the .X at the end).\n+               pragma Assert (STJR.Lev > STJE.Lev);\n \n-                        --   level 2 to level 1\n+               --  Compute the prefix of X. Here are examples to make things\n+               --  clear (with parens to show groupings, the prefix is\n+               --  everything except the .X at the end).\n \n-                        --     AREC1F.X\n+               --   level 2 to level 1\n \n-                        --   level 3 to level 1\n+               --     AREC1F.X\n \n-                        --     (AREC2F.AREC1U).X\n+               --   level 3 to level 1\n \n-                        --   level 4 to level 1\n+               --     (AREC2F.AREC1U).X\n \n-                        --     ((AREC3F.AREC2U).AREC1U).X\n+               --   level 4 to level 1\n \n-                        --   level 6 to level 2\n+               --     ((AREC3F.AREC2U).AREC1U).X\n \n-                        --     (((AREC5F.AREC4U).AREC3U).AREC2U).X\n+               --   level 6 to level 2\n \n-                        Pfx := New_Occurrence_Of (STJR.ARECnF, Loc);\n-                        SI := RSX;\n-                        for L in STJ.Lev .. STJR.Lev - 2 loop\n-                           SI := Enclosing_Subp (SI);\n-                           Pfx :=\n-                             Make_Selected_Component (Loc,\n-                               Prefix        => Pfx,\n-                               Selector_Name =>\n-                                 New_Occurrence_Of\n-                                   (Subps.Table (SI).ARECnU, Loc));\n-                        end loop;\n+               --     (((AREC5F.AREC4U).AREC3U).AREC2U).X\n \n-                        --  Get activation record component (must exist)\n+               Pfx := New_Occurrence_Of (STJR.ARECnF, Loc);\n+               SI := RS_Caller;\n+               for L in STJE.Lev .. STJR.Lev - 2 loop\n+                  SI := Enclosing_Subp (SI);\n+                  Pfx :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix        => Pfx,\n+                      Selector_Name =>\n+                        New_Occurrence_Of (Subps.Table (SI).ARECnU, Loc));\n+               end loop;\n \n-                        Comp := Activation_Record_Component (Ent);\n-                        pragma Assert (Present (Comp));\n+               --  Get activation record component (must exist)\n \n-                        --  Do the replacement\n+               Comp := Activation_Record_Component (UPJ.Ent);\n+               pragma Assert (Present (Comp));\n \n-                        Rewrite (Ref,\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         => New_Occurrence_Of (Atyp, Loc),\n-                            Attribute_Name => Name_Deref,\n-                            Expressions    => New_List (\n-                              Make_Selected_Component (Loc,\n-                                Prefix        => Pfx,\n-                                Selector_Name =>\n-                                  New_Occurrence_Of (Comp, Loc)))));\n+               --  Do the replacement\n \n-                        --  Analyze and resolve the new expression. We do not\n-                        --  need to establish the relevant scope stack entries\n-                        --  here, because we have already set all the correct\n-                        --  entity references, so no name resolution is needed.\n-                        --  We have already set the current scope, so that any\n-                        --  new entities created will be in the right scope.\n+               Rewrite (UPJ.Ref,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Occurrence_Of (Atyp, Loc),\n+                   Attribute_Name => Name_Deref,\n+                   Expressions    => New_List (\n+                     Make_Selected_Component (Loc,\n+                       Prefix        => Pfx,\n+                       Selector_Name =>\n+                         New_Occurrence_Of (Comp, Loc)))));\n \n-                        --  We analyze with all checks suppressed (since we do\n-                        --  not expect any exceptions, and also we temporarily\n-                        --  turn off Unested_Subprogram_Mode to avoid trying to\n-                        --  mark uplevel references (not needed at this stage,\n-                        --  and in fact causes a bit of recursive chaos).\n+               --  Analyze and resolve the new expression. We do not need to\n+               --  establish the relevant scope stack entries here, because we\n+               --  have already set all the correct entity references, so no\n+               --  name resolution is needed. We have already set the current\n+               --  scope, so that any new entities created will be in the right\n+               --  scope.\n \n-                        Opt.Unnest_Subprogram_Mode := False;\n-                        Analyze_And_Resolve (Ref, Typ, Suppress => All_Checks);\n-                        Opt.Unnest_Subprogram_Mode := True;\n-                        Pop_Scope;\n-                     end Rewrite_One_Ref;\n+               --  We analyze with all checks suppressed (since we do not\n+               --  expect any exceptions)\n \n-                  <<Continue>>\n-                     Next_Elmt (Elmt);\n-                     Next_Elmt (Elmt);\n-                  end loop;\n-               end Uplev_Refs_For_One_Subp;\n-            end if;\n+               Analyze_And_Resolve (UPJ.Ref, Typ, Suppress => All_Checks);\n+               Pop_Scope;\n+            end Rewrite_One_Ref;\n          end;\n+\n+      <<Continue>>\n+         null;\n       end loop Uplev_Refs;\n \n       --  Finally, loop through all calls adding extra actual for the\n@@ -1316,8 +1560,8 @@ package body Exp_Unst is\n \n          Adjust_One_Call : declare\n             CTJ : Call_Entry renames Calls.Table (J);\n-            STF : Subp_Entry renames Subps.Table (Subp_Index (CTJ.From));\n-            STT : Subp_Entry renames Subps.Table (Subp_Index (CTJ.To));\n+            STF : Subp_Entry renames Subps.Table (Subp_Index (CTJ.Caller));\n+            STT : Subp_Entry renames Subps.Table (Subp_Index (CTJ.Callee));\n \n             Loc : constant Source_Ptr := Sloc (CTJ.N);\n \n@@ -1344,7 +1588,7 @@ package body Exp_Unst is\n                   Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n \n                --  For a call that goes down a level, we pass a pointer\n-               --  to the activation record constructed wtihin the caller\n+               --  to the activation record constructed within the caller\n                --  (which may be the outer level subprogram, but also may\n                --  be a more deeply nested caller).\n \n@@ -1368,7 +1612,7 @@ package body Exp_Unst is\n                   pragma Assert (STT.Lev < STF.Lev);\n \n                   Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n-                  SubX := Subp_Index (CTJ.From);\n+                  SubX := Subp_Index (CTJ.Caller);\n                   for K in reverse STT.Lev .. STF.Lev - 1 loop\n                      SubX := Enclosing_Subp (SubX);\n                      Extra :="}, {"sha": "9a6393c6473ccccf8e0c213413e52bc5889b7f1d", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -529,23 +529,6 @@ package Exp_Unst is\n    -- Subprograms --\n    -----------------\n \n-   procedure Check_Uplevel_Reference_To_Type (Typ : Entity_Id);\n-   --  This procedure is called if Sem_Util.Check_Nested_Access detects an\n-   --  uplevel reference to a type or subtype entity Typ. On return there are\n-   --  two cases, if Typ is a static type (defined as a discrete type with\n-   --  static bounds, or a record all of whose components are of a static type,\n-   --  or an array whose index and component types are all static types), then\n-   --  the flag Is_Static_Type (Typ) will be set True, and in this case the\n-   --  flag Has_Uplevel_Reference is not set since we don't need to worry about\n-   --  uplevel references to static types. If on the other hand Typ is not a\n-   --  static type, then the flag Has_Uplevel_Reference will be set, and any\n-   --  non-static bounds referenced by the type will also be marked as having\n-   --  uplevel references (by setting Has_Uplevel_Reference for these bounds).\n-\n-   procedure Note_Uplevel_Reference (N : Node_Id; Subp : Entity_Id);\n-   --  Called in Unnest_Subprogram_Mode when we detect an explicit uplevel\n-   --  reference (node N) to an enclosing subprogram Subp.\n-\n    procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id);\n    --  Subp is a library level subprogram which has nested subprograms, and\n    --  Subp_Body is the corresponding N_Subprogram_Body node. This procedure"}, {"sha": "ba903793300e2b15f7addc1cea8b179dd0e4ce5e", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -30,6 +30,7 @@ with Checks;\n with CStand;\n with Debug;    use Debug;\n with Elists;\n+with Exp_Ch6;\n with Exp_Dbug;\n with Fmap;\n with Fname.UF;\n@@ -90,6 +91,7 @@ begin\n    Checks.Initialize;\n    Sem_Warn.Initialize;\n    Prep.Initialize;\n+   Exp_Ch6.Initialize;\n \n    if Generate_SCIL then\n       SCIL_LL.Initialize;\n@@ -408,13 +410,6 @@ begin\n \n          --  Cleanup processing after completing main analysis\n \n-         --  Turn off unnesting of subprograms mode. This is not right\n-         --  with respect to instantiations. What needs to happen is that\n-         --  we do the unnesting AFTER the call to Instantiate_Bodies. We\n-         --  will take care of that later ???\n-\n-         Opt.Unnest_Subprogram_Mode := False;\n-\n          --  Comment needed for ASIS mode test and GNATprove mode test???\n \n          if Operating_Mode = Generate_Code\n@@ -444,6 +439,10 @@ begin\n             Remove_Ignored_Ghost_Code;\n          end if;\n \n+         --  At this stage we can unnest subprogram bodies if required\n+\n+         Exp_Ch6.Unnest_Subprograms;\n+\n          --  List library units if requested\n \n          if List_Units then"}, {"sha": "dcc3a85f539ac9535716b9a89f8a2c33c17b77a0", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,6 +57,12 @@ with Ada.Text_IO;             use Ada.Text_IO;\n with GNAT.OS_Lib; use GNAT.OS_Lib;\n \n procedure GNATCmd is\n+   Gprbuild : constant String := \"gprbuild\";\n+   Gnatmake : constant String := \"gnatmake\";\n+\n+   Gprclean  : constant String := \"gprclean\";\n+   Gnatclean : constant String := \"gnatclean\";\n+\n    Normal_Exit : exception;\n    --  Raise this exception for normal program termination\n \n@@ -1166,14 +1172,47 @@ begin\n \n    begin\n       if The_Command = Stack then\n-\n          --  Never call gnatstack with a prefix\n \n          Program := new String'(Command_List (The_Command).Unixcmd.all);\n \n       else\n          Program :=\n            Program_Name (Command_List (The_Command).Unixcmd.all, \"gnat\");\n+\n+         --  If we want to invoke gnatmake/gnatclean with -P, then check if\n+         --  gprbuild/gprclean is available; if it is, use gprbuild/gprclean\n+         --  instead of gnatmake/gnatclean.\n+\n+         if Program.all = Gnatmake or else Program.all = Gnatclean then\n+            declare\n+               Project_File_Used : Boolean := False;\n+               Switch            : String_Access;\n+\n+            begin\n+               for J in 1 .. Last_Switches.Last loop\n+                  Switch := Last_Switches.Table (J);\n+                  if Switch'Length >= 2 and then\n+                    Switch (Switch'First .. Switch'First + 1) = \"-P\"\n+                  then\n+                     Project_File_Used := True;\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               if Project_File_Used then\n+                  if Program.all = Gnatmake\n+                    and then Locate_Exec_On_Path (Gprbuild) /= null\n+                  then\n+                     Program := new String'(Gprbuild);\n+                  elsif Program.all = Gnatclean\n+                    and then Locate_Exec_On_Path (Gprclean) /= null\n+                  then\n+                     Program := new String'(Gprclean);\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n       end if;\n \n       --  For the tools where the GNAT driver processes the project files,"}, {"sha": "7b87c2dbfc196620da6030cd9f058b8a3bd270be", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -1160,7 +1160,7 @@ package body Sem_Ch3 is\n                if Is_Access_Type (Typ)\n                  and then Null_Exclusion_In_Return_Present (T_Def)\n                then\n-                  Set_Etype  (Desig_Type,\n+                  Set_Etype (Desig_Type,\n                     Create_Null_Excluding_Itype\n                       (T           => Typ,\n                        Related_Nod => T_Def,"}, {"sha": "9c564dd98e44b919e1cb0907722e52b1bca0f100", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -5633,7 +5633,7 @@ package body Sem_Ch8 is\n                   end if;\n                end if;\n \n-               Check_Nested_Access (N, E);\n+               Check_Nested_Access (E);\n             end if;\n \n             Set_Entity_Or_Discriminal (N, E);"}, {"sha": "bebb7db04d32f24dabe219998d47cab961e8be51", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -32,7 +32,6 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Disp; use Exp_Disp;\n-with Exp_Unst; use Exp_Unst;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n@@ -1547,9 +1546,9 @@ package body Sem_Util is\n \n          Insert_Action (N, Decl);\n \n-         --  If the context is a component declaration the subtype\n-         --  declaration will be analyzed when the enclosing type is\n-         --  frozen, otherwise do it now.\n+         --  If the context is a component declaration the subtype declaration\n+         --  will be analyzed when the enclosing type is frozen, otherwise do\n+         --  it now.\n \n          if Ekind (Current_Scope) /= E_Record_Type then\n             Analyze (Decl);\n@@ -2872,44 +2871,23 @@ package body Sem_Util is\n    -- Check_Nested_Access --\n    -------------------------\n \n-   procedure Check_Nested_Access (N : Node_Id; Ent : Entity_Id) is\n+   procedure Check_Nested_Access (Ent : Entity_Id) is\n       Scop         : constant Entity_Id := Current_Scope;\n       Current_Subp : Entity_Id;\n       Enclosing    : Entity_Id;\n \n    begin\n-      --  Currently only enabled for VM back-ends for efficiency, should we\n-      --  enable it more systematically? Probably not unless someone actually\n-      --  needs it. It will be needed for C generation and is activated if the\n-      --  Opt.Unnest_Subprogram_Mode flag is set True.\n+      --  Currently only enabled for VM back-ends for efficiency\n \n-      if (VM_Target /= No_VM or else Unnest_Subprogram_Mode)\n+      if VM_Target /= No_VM\n+        and then Ekind_In (Ent, E_Variable, E_Constant, E_Loop_Parameter)\n         and then Scope (Ent) /= Empty\n         and then not Is_Library_Level_Entity (Ent)\n \n         --  Comment the exclusion of imported entities ???\n \n         and then not Is_Imported (Ent)\n       then\n-         --  In both the VM case and in Unnest_Subprogram_Mode, we mark\n-         --  variables, constants, and loop parameters.\n-\n-         if Ekind_In (Ent, E_Variable, E_Constant, E_Loop_Parameter) then\n-            null;\n-\n-         --  In Unnest_Subprogram_Mode, we also mark types and formals\n-\n-         elsif Unnest_Subprogram_Mode\n-           and then (Is_Type (Ent) or else Is_Formal (Ent))\n-         then\n-            null;\n-\n-            --  All other cases, do not mark\n-\n-         else\n-            return;\n-         end if;\n-\n          --  Get current subprogram that is relevant\n \n          if Is_Subprogram (Scop)\n@@ -2926,16 +2904,7 @@ package body Sem_Util is\n          --  Set flag if uplevel reference\n \n          if Enclosing /= Empty and then Enclosing /= Current_Subp then\n-            if Is_Type (Ent) then\n-               Check_Uplevel_Reference_To_Type (Ent);\n-            else\n-               Set_Has_Uplevel_Reference (Ent, True);\n-\n-               if Unnest_Subprogram_Mode then\n-                  Set_Has_Uplevel_Reference (Current_Subp, True);\n-                  Note_Uplevel_Reference (N, Enclosing);\n-               end if;\n-            end if;\n+            Set_Has_Uplevel_Reference (Ent, True);\n          end if;\n       end if;\n    end Check_Nested_Access;\n@@ -4949,7 +4918,7 @@ package body Sem_Util is\n \n       --  Both names are selected_components, their prefixes are known to\n       --  denote the same object, and their selector_names denote the same\n-      --  component (RM 6.4.1(6.6/3))\n+      --  component (RM 6.4.1(6.6/3)).\n \n       elsif Nkind (Obj1) = N_Selected_Component then\n          return Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2))\n@@ -15223,7 +15192,7 @@ package body Sem_Util is\n                   end if;\n                end if;\n \n-               Check_Nested_Access (N, Ent);\n+               Check_Nested_Access (Ent);\n             end if;\n \n             Kill_Checks (Ent);"}, {"sha": "06239d2b66e5367cc4891f49b002f5eb9b9e5b42", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dae9bb29d4dffc332c5a0670ff814816c87731/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f8dae9bb29d4dffc332c5a0670ff814816c87731", "patch": "@@ -308,12 +308,10 @@ package Sem_Util is\n    --  remains in the Examiner (JB01-005). Note that the Examiner does not\n    --  count package declarations in later declarative items.\n \n-   procedure Check_Nested_Access (N : Node_Id; Ent : Entity_Id);\n+   procedure Check_Nested_Access (Ent : Entity_Id);\n    --  Check whether Ent denotes an entity declared in an uplevel scope, which\n-   --  is accessed inside a nested procedure, and set the Has_Uplevel_Reference\n-   --  flag accordingly. This is currently only enabled for if on a VM target,\n-   --  or if Opt.Unnest_Subprogram_Mode is active. N is the node for the\n-   --  possible uplevel reference.\n+   --  is accessed inside a nested procedure, and set Has_Uplevel_Reference\n+   --  flag accordingly. This is currently only enabled for if on a VM target.\n \n    procedure Check_No_Hidden_State (Id : Entity_Id);\n    --  Determine whether object or state Id introduces a hidden state. If this"}]}