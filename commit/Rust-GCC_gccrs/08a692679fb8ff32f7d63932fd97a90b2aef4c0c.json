{"sha": "08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhhNjkyNjc5ZmI4ZmYzMmY3ZDYzOTMyZmQ5N2E5MGIyYWVmNGMwYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-10-25T17:23:15Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-10-25T17:23:15Z"}, "message": "cse.c: Change encoding of quantity numbers to avoid undefined pointer arithmetic on...\n\n\n\t* cse.c: Change encoding of quantity numbers to avoid undefined\n\tpointer arithmetic on qty_table.\n\t(REGNO_QTY_VALID_P): A quantity is now valid if it isn't negative.\n\t(get_cse_reg_info): Initialize reg_qty to a unique negative value.\n\t(new_basic_block): Assign \"real\" quantity numbers from zero.\n\t(delete_reg_equiv): Do nothing if quantity is invalid.  Reset the\n\tREG_QTY to its unique negative value.\n\t(merge_equiv_classes): Calculate need_rehash if quantity is valid.\n\t(cse_main): Don't include max_reg when determining max_qty.\n\t(cse_basic_block): Avoid subtracting a large offset from qty_table,\n\twhich causes undefined C99 behaviour.  Only allocate needed memory.\n\nCo-Authored-By: John David Anglin <dave.anglin@nrc-cnrc.gc.ca>\n\nFrom-SVN: r89543", "tree": {"sha": "497f93ba2711bdc721a726c414ea95d4abf630bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497f93ba2711bdc721a726c414ea95d4abf630bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a692679fb8ff32f7d63932fd97a90b2aef4c0c/comments", "author": null, "committer": null, "parents": [{"sha": "4cd26879f7580e057368bf872d2417764814f2ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd26879f7580e057368bf872d2417764814f2ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd26879f7580e057368bf872d2417764814f2ce"}], "stats": {"total": 53, "additions": 32, "deletions": 21}, "files": [{"sha": "474fec2c466be381107c551344e3ede71d158c78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a692679fb8ff32f7d63932fd97a90b2aef4c0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a692679fb8ff32f7d63932fd97a90b2aef4c0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "patch": "@@ -1,3 +1,18 @@\n+2004-10-25  Roger Sayle  <roger@eyesopen.com>\n+\t    John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* cse.c: Change encoding of quantity numbers to avoid undefined\n+\tpointer arithmetic on qty_table.\n+\t(REGNO_QTY_VALID_P): A quantity is now valid if it isn't negative.\n+\t(get_cse_reg_info): Initialize reg_qty to a unique negative value.\n+\t(new_basic_block): Assign \"real\" quantity numbers from zero.\n+\t(delete_reg_equiv): Do nothing if quantity is invalid.  Reset the\n+\tREG_QTY to its unique negative value.\n+\t(merge_equiv_classes): Calculate need_rehash if quantity is valid.\n+\t(cse_main): Don't include max_reg when determining max_qty.\n+\t(cse_basic_block): Avoid subtracting a large offset from qty_table,\n+\twhich causes undefined C99 behaviour.  Only allocate needed memory.\n+\n 2004-10-25  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* stmt.c (expand_case): Remove an obsolete comment."}, {"sha": "13133998ca65919398e32f92142e8d0c5309f9e0", "filename": "gcc/cse.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a692679fb8ff32f7d63932fd97a90b2aef4c0c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a692679fb8ff32f7d63932fd97a90b2aef4c0c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "patch": "@@ -84,11 +84,12 @@ Registers and \"quantity numbers\":\n    `reg_qty' records what quantity a register is currently thought\n    of as containing.\n \n-   All real quantity numbers are greater than or equal to `max_reg'.\n-   If register N has not been assigned a quantity, reg_qty[N] will equal N.\n+   All real quantity numbers are greater than or equal to zero.\n+   If register N has not been assigned a quantity, reg_qty[N] will\n+   equal -N - 1, which is always negative.\n \n-   Quantity numbers below `max_reg' do not exist and none of the `qty_table'\n-   entries should be referenced with an index below `max_reg'.\n+   Quantity numbers below zero do not exist and none of the `qty_table'\n+   entries should be referenced with a negative index.\n \n    We also maintain a bidirectional chain of registers for each\n    quantity number.  The `qty_table` members `first_reg' and `last_reg',\n@@ -546,7 +547,7 @@ struct table_elt\n /* Determine if the quantity number for register X represents a valid index\n    into the qty_table.  */\n \n-#define REGNO_QTY_VALID_P(N) (REG_QTY (N) != (int) (N))\n+#define REGNO_QTY_VALID_P(N) (REG_QTY (N) >= 0)\n \n static struct table_elt *table[HASH_SIZE];\n \n@@ -844,7 +845,7 @@ get_cse_reg_info (unsigned int regno)\n       p->reg_tick = 1;\n       p->reg_in_table = -1;\n       p->subreg_ticked = -1;\n-      p->reg_qty = regno;\n+      p->reg_qty = -regno - 1;\n       p->regno = regno;\n       p->next = cse_reg_info_used_list;\n       cse_reg_info_used_list = p;\n@@ -868,7 +869,7 @@ new_basic_block (void)\n {\n   int i;\n \n-  next_qty = max_reg;\n+  next_qty = 0;\n \n   /* Clear out hash table state for this pass.  */\n \n@@ -1012,7 +1013,7 @@ delete_reg_equiv (unsigned int reg)\n   int p, n;\n \n   /* If invalid, do nothing.  */\n-  if (q == (int) reg)\n+  if (! REGNO_QTY_VALID_P (reg))\n     return;\n \n   ent = &qty_table[q];\n@@ -1029,7 +1030,7 @@ delete_reg_equiv (unsigned int reg)\n   else\n     ent->first_reg = n;\n \n-  REG_QTY (reg) = reg;\n+  REG_QTY (reg) = -reg - 1;\n }\n \n /* Remove any invalid expressions from the hash table\n@@ -1627,7 +1628,7 @@ merge_equiv_classes (struct table_elt *class1, struct table_elt *class2)\n \n \t  if (REG_P (exp))\n \t    {\n-\t      need_rehash = (unsigned) REG_QTY (REGNO (exp)) != REGNO (exp);\n+\t      need_rehash = REGNO_QTY_VALID_P (REGNO (exp));\n \t      delete_reg_equiv (REGNO (exp));\n \t    }\n \n@@ -6739,8 +6740,6 @@ cse_main (rtx f, int nregs, FILE *file)\n       if (max_qty < 500)\n \tmax_qty = 500;\n \n-      max_qty += max_reg;\n-\n       /* If this basic block is being extended by following certain jumps,\n          (see `cse_end_of_basic_block'), we reprocess the code from the start.\n          Otherwise, we start after this basic block.  */\n@@ -6801,11 +6800,8 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n   int num_insns = 0;\n   int no_conflict = 0;\n \n-  /* This array is undefined before max_reg, so only allocate\n-     the space actually needed and adjust the start.  */\n-\n-  qty_table = xmalloc ((max_qty - max_reg) * sizeof (struct qty_table_elem));\n-  qty_table -= max_reg;\n+  /* Allocate the space needed by qty_table.  */\n+  qty_table = xmalloc (max_qty * sizeof (struct qty_table_elem));\n \n   new_basic_block ();\n \n@@ -6916,7 +6912,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \t{\n \t  if (to == 0)\n \t    {\n-\t      free (qty_table + max_reg);\n+\t      free (qty_table);\n \t      return 0;\n \t    }\n \n@@ -6951,7 +6947,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \t  /* If TO was the last insn in the function, we are done.  */\n \t  if (insn == 0)\n \t    {\n-\t      free (qty_table + max_reg);\n+\t      free (qty_table);\n \t      return 0;\n \t    }\n \n@@ -6960,7 +6956,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \t  prev = prev_nonnote_insn (to);\n \t  if (prev && BARRIER_P (prev))\n \t    {\n-\t      free (qty_table + max_reg);\n+\t      free (qty_table);\n \t      return insn;\n \t    }\n \n@@ -6995,7 +6991,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \n   gcc_assert (next_qty <= max_qty);\n \n-  free (qty_table + max_reg);\n+  free (qty_table);\n \n   return to ? NEXT_INSN (to) : 0;\n }"}]}