{"sha": "5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ2YTE2ZTI3ZTdlZTQ3YzZkMjE2OGQxMGMxZThkNWM1MzI4MTZhOQ==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-09-11T21:42:07Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-09-11T21:42:07Z"}, "message": "basic-block.h (LOOP_TREE, [...]): New.\n\n2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n\n\t* basic-block.h (LOOP_TREE, LOOP_PRE_HEADER, LOOP_EDGES): New.\n\t(LOOP_EXITS_DOMS, LOOP_ALL): Likewise.\n\t(flow_loops_update): New prototype.\n\t(flow_loops_find): Add flags to prototype.\n\t(struct loop): Add `pre_header_root' and `pre_header_trace' fields.\n\t* flow.c (flow_loop_pre_header_scan): New.\n\t(flow_loop_dump): Dump pre-header root and trace and exit dominators.\n\t(flow_loop_free): Free pre-header root and trace and exit dominators.\n\t(flow_loops_find): New argument flags.\n\t(flow_loops_update): New function.\n\t* toplev.c (rest_of_compilation): Add flag argument to flow_loops_find.\n\nFrom-SVN: r36333", "tree": {"sha": "ede055ecb879705a2129bef0497f0e7af7b14b3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ede055ecb879705a2129bef0497f0e7af7b14b3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/comments", "author": null, "committer": null, "parents": [{"sha": "c586192c7d0f9f5264179a7af8e48022b1a089de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c586192c7d0f9f5264179a7af8e48022b1a089de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c586192c7d0f9f5264179a7af8e48022b1a089de"}], "stats": {"total": 247, "additions": 191, "deletions": 56}, "files": [{"sha": "94a056238a741c96eb334102c2705e941d84c541", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "patch": "@@ -1,3 +1,17 @@\n+2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* basic-block.h (LOOP_TREE, LOOP_PRE_HEADER, LOOP_EDGES): New.\n+\t(LOOP_EXITS_DOMS, LOOP_ALL): Likewise.\n+\t(flow_loops_update): New prototype.\n+\t(flow_loops_find): Add flags to prototype.\n+\t(struct loop): Add `pre_header_root' and `pre_header_trace' fields.\n+\t* flow.c (flow_loop_pre_header_scan): New.\n+\t(flow_loop_dump): Dump pre-header root and trace and exit dominators.\n+\t(flow_loop_free): Free pre-header root and trace and exit dominators.\n+\t(flow_loops_find): New argument flags.\n+\t(flow_loops_update): New function.\n+\t* toplev.c (rest_of_compilation): Add flag argument to flow_loops_find.\n+\n 2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n \n \t* basic-block.h (split_block, update_bb_for_insn): New prototypes."}, {"sha": "b04352fc8eac16741bd8312dc35c30b76dff31e8", "filename": "gcc/basic-block.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "patch": "@@ -276,6 +276,12 @@ struct loop\n   /* Basic block of loop pre-header or NULL if it does not exist.  */\n   basic_block pre_header;\n \n+  /* Root node of pre_header extended basic block.  */\n+  basic_block pre_header_root;\n+\n+  /* Bitmap of blocks of trace from pre_header root to pre_header.  */\n+  sbitmap pre_header_trace;\n+\n   /* The first block in the loop.  This is not necessarily the same as\n      the loop header.  */\n   basic_block first;\n@@ -302,6 +308,9 @@ struct loop\n   /* Number of edges that exit the loop.  */\n   int num_exits;\n \n+  /* Bitmap of blocks that dominate all exits of the loop.  */\n+  sbitmap exits_doms;\n+\n   /* The loop nesting depth.  */\n   int depth;\n \n@@ -404,7 +413,8 @@ struct loops\n   sbitmap shared_headers;\n };\n \n-extern int flow_loops_find PARAMS ((struct loops *));\n+extern int flow_loops_find PARAMS ((struct loops *, int flags));\n+extern int flow_loops_update PARAMS ((struct loops *, int flags));\n extern void flow_loops_free PARAMS ((struct loops *));\n extern void flow_loops_dump PARAMS ((const struct loops *, FILE *,\n \t\t\t\t     void (*)(const struct loop *,\n@@ -468,6 +478,15 @@ enum update_life_extent\n #define PROP_AUTOINC\t\t32\t/* Create autoinc mem references.  */\n #define PROP_FINAL\t\t63\t/* All of the above.  */\n \n+\n+/* Flags for loop discovery.  */\n+\n+#define LOOP_TREE\t\t1 \t/* Build loop hierarchy tree.  */\n+#define LOOP_PRE_HEADER\t\t2\t/* Analyse loop pre-header.  */\n+#define LOOP_EDGES\t\t4 \t/* Find entry and exit edges.  */\n+#define LOOP_EXITS_DOMS\t\t8 \t/* Find nodes that dom. all exits.  */\n+#define LOOP_ALL\t       15 \t/* All of the above  */\n+\n extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n extern void update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n \t\t\t\t\t int));"}, {"sha": "c2ae9650c7c588302609e3dee002626dc80d28d8", "filename": "gcc/flow.c", "status": "modified", "additions": 156, "deletions": 54, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "patch": "@@ -432,7 +432,9 @@ static basic_block flow_dfs_compute_reverse_execute\n   PARAMS ((depth_first_search_ds));\n static void flow_dfs_compute_reverse_finish\n   PARAMS ((depth_first_search_ds));\n-static basic_block flow_loop_pre_header_find PARAMS ((basic_block, const sbitmap *));\n+static void flow_loop_pre_header_scan PARAMS ((struct loop *));\n+static basic_block flow_loop_pre_header_find PARAMS ((basic_block,\n+\t\t\t\t\t\t      const sbitmap *));\n static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n@@ -7374,13 +7376,20 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n \t   loop->depth, loop->level,\n \t   (long) (loop->outer ? loop->outer->num : -1));\n \n-  flow_edge_list_print (\";;   entry edges\", loop->entry_edges,\n+  if (loop->pre_header_root)\n+    fprintf (file, \";;  pre-header root %d\\n\", \n+\t     loop->pre_header_root->index);\n+  if (loop->pre_header_trace)\n+    flow_nodes_print (\";;  pre-header trace\", loop->pre_header_trace,\n+\t\t      file);\n+  flow_edge_list_print (\";;  entry edges\", loop->entry_edges,\n \t\t\tloop->num_entries, file);\n   fprintf (file, \";;  %d\", loop->num_nodes);\n   flow_nodes_print (\" nodes\", loop->nodes, file);\n-  flow_edge_list_print (\";;   exit edges\", loop->exit_edges,\n+  flow_edge_list_print (\";;  exit edges\", loop->exit_edges,\n \t\t\tloop->num_exits, file);\n-\n+  if (loop->exits_doms)\n+    flow_nodes_print (\";;  exit doms\", loop->exits_doms, file);\n   if (loop_dump_aux)\n     loop_dump_aux (loop, file, verbose);\n }\n@@ -7463,12 +7472,16 @@ flow_loops_free (loops)\n \t{\n \t  struct loop *loop = &loops->array[i];\n \n+\t  if (loop->pre_header_trace)\n+\t    sbitmap_free (loop->pre_header_trace);\n \t  if (loop->nodes)\n \t    sbitmap_free (loop->nodes);\n \t  if (loop->entry_edges)\n \t    free (loop->entry_edges);\n \t  if (loop->exit_edges)\n \t    free (loop->exit_edges);\n+\t  if (loop->exits_doms)\n+\t    sbitmap_free (loop->exits_doms);\n \t}\n       free (loops->array);\n       loops->array = NULL;\n@@ -7478,7 +7491,8 @@ flow_loops_free (loops)\n       if (loops->cfg.dfs_order)\n \tfree (loops->cfg.dfs_order);\n \n-      sbitmap_free (loops->shared_headers);\n+      if (loops->shared_headers)\n+\tsbitmap_free (loops->shared_headers);\n     }\n }\n \n@@ -7839,6 +7853,36 @@ flow_dfs_compute_reverse_finish (data)\n   return;\n }\n \n+\n+/* Find the root node of the loop pre-header extended basic block and\n+   the blocks along the trace from the root node to the loop header.  */\n+\n+static void\n+flow_loop_pre_header_scan (loop)\n+     struct loop *loop;\n+{\n+  basic_block ebb;\n+\n+  if (loop->num_entries != 1)\n+     return;\n+\n+  /* Find pre_header root note and trace from root node to pre_header.  */\n+  loop->pre_header_trace = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (loop->pre_header_trace);\n+  \n+  ebb = loop->entry_edges[0]->src;\n+  SET_BIT (loop->pre_header_trace, ebb->index);\n+  while (ebb->pred->src != ENTRY_BLOCK_PTR\n+\t && ! ebb->pred->pred_next)\n+    {\n+      ebb = ebb->pred->src;\n+      SET_BIT (loop->pre_header_trace, ebb->index);\n+    }\n+  \n+  loop->pre_header_root = ebb;\n+}\n+\n+\n /* Return the block for the pre-header of the loop with header\n    HEADER where DOM specifies the dominator information.  Return NULL if\n    there is no pre-header.  */\n@@ -7987,13 +8031,16 @@ flow_loops_level_compute (loops)\n   return levels;\n }\n \n+\n /* Find all the natural loops in the function and save in LOOPS structure\n    and recalculate loop_depth information in basic block structures.\n+   FLAGS controls which loop information is collected.\n    Return the number of natural loops found.  */\n \n int\n-flow_loops_find (loops)\n+flow_loops_find (loops, flags)\n      struct loops *loops;\n+     int flags;\n {\n   int i;\n   int b;\n@@ -8004,32 +8051,38 @@ flow_loops_find (loops)\n   int *dfs_order;\n   int *rc_order;\n \n-  loops->num = 0;\n-  loops->array = NULL;\n-  loops->tree = NULL;\n-  dfs_order = NULL;\n-  rc_order = NULL;\n+  /* This function cannot be repeatedly called with different\n+     flags to build up the loop information.  The loop tree\n+     must always be built if this function is called.  */\n+  if (! (flags & LOOP_TREE))\n+    abort ();\n+    \n+  memset (loops, 0, sizeof (*loops));\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n   if (n_basic_blocks == 0)\n     return 0;\n \n+  dfs_order = NULL;\n+  rc_order = NULL;\n+\n   /* Compute the dominators.  */\n   dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n   compute_flow_dominators (dom, NULL);\n \n   /* Count the number of loop edges (back edges).  This should be the\n-     same as the number of natural loops.  Also clear the loop_depth\n-     and as we work from inner->outer in a loop nest we call\n-     find_loop_nodes_find which will increment loop_depth for nodes\n-     within the current loop, which happens to enclose inner loops.  */\n+     same as the number of natural loops.  */\n \n   num_loops = 0;\n   for (b = 0; b < n_basic_blocks; b++)\n     {\n-      BASIC_BLOCK (b)->loop_depth = 0;\n-      for (e = BASIC_BLOCK (b)->pred; e; e = e->pred_next)\n+      basic_block header;\n+\n+      header = BASIC_BLOCK (b);\n+      header->loop_depth = 0;\n+\n+      for (e = header->pred; e; e = e->pred_next)\n \t{\n \t  basic_block latch = e->src;\n \n@@ -8039,6 +8092,9 @@ flow_loops_find (loops)\n \t     loop.  It also has single back edge to the header\n \t     from a latch node.  Note that multiple natural loops\n \t     may share the same header.  */\n+\t  if (b != header->index)\n+\t    abort ();\n+\n \t  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index], b))\n \t    num_loops++;\n \t}\n@@ -8069,8 +8125,8 @@ flow_loops_find (loops)\n \t{\n \t  basic_block header;\n \n-\t  /* Search the nodes of the CFG in DFS order that we can find\n-\t     outer loops first.  */\n+\t  /* Search the nodes of the CFG in reverse completion order\n+\t     so that we can find outer loops first.  */\n \t  header = BASIC_BLOCK (rc_order[b]);\n \n \t  /* Look for all the possible latch blocks for this header.  */\n@@ -8095,46 +8151,75 @@ flow_loops_find (loops)\n \t\t  loop->latch = latch;\n \t\t  loop->num = num_loops;\n \n-\t\t  /* Keep track of blocks that are loop headers so\n-\t\t     that we can tell which loops should be merged.  */\n-\t\t  if (TEST_BIT (headers, header->index))\n-\t\t    SET_BIT (loops->shared_headers, header->index);\n-\t\t  SET_BIT (headers, header->index);\n-\n-\t\t  /* Find nodes contained within the loop.  */\n-\t\t  loop->nodes = sbitmap_alloc (n_basic_blocks);\n-\t\t  loop->num_nodes\n-\t\t    = flow_loop_nodes_find (header, latch, loop->nodes);\n-\n-\t\t  /* Compute first and last blocks within the loop.\n-\t\t     These are often the same as the loop header and\n-\t\t     loop latch respectively, but this is not always\n-\t\t     the case.  */\n-\t\t  loop->first\n-\t\t    = BASIC_BLOCK (sbitmap_first_set_bit (loop->nodes));\n-\t\t  loop->last\n-\t\t    = BASIC_BLOCK (sbitmap_last_set_bit (loop->nodes));\n-\n-\t\t  /* Find edges which enter the loop header.\n-\t\t     Note that the entry edges should only\n-\t\t     enter the header of a natural loop.  */\n-\t\t  loop->num_entries\n-\t\t    = flow_loop_entry_edges_find (loop->header, loop->nodes,\n-\t\t\t\t\t\t  &loop->entry_edges);\n-\n-\t\t  /* Find edges which exit the loop.  */\n-\t\t  loop->num_exits\n-\t\t    = flow_loop_exit_edges_find (loop->nodes,\n-\t\t\t\t\t\t &loop->exit_edges);\n-\n-\t\t  /* Look to see if the loop has a pre-header node.  */\n-\t\t  loop->pre_header = flow_loop_pre_header_find (header, dom);\n-\n \t\t  num_loops++;\n \t\t}\n \t    }\n \t}\n \n+      for (i = 0; i < num_loops; i++)\n+\t{\n+\t  struct loop *loop = &loops->array[i];\n+\t  int j;\n+\n+\t  /* Keep track of blocks that are loop headers so\n+\t     that we can tell which loops should be merged.  */\n+\t  if (TEST_BIT (headers, loop->header->index))\n+\t    SET_BIT (loops->shared_headers, loop->header->index);\n+\t  SET_BIT (headers, loop->header->index);\n+\n+\t  /* Find nodes contained within the loop.  */\n+\t  loop->nodes = sbitmap_alloc (n_basic_blocks);\n+\t  loop->num_nodes\n+\t    = flow_loop_nodes_find (loop->header, loop->latch, loop->nodes);\n+\t  \n+\t  /* Compute first and last blocks within the loop.\n+\t     These are often the same as the loop header and\n+\t     loop latch respectively, but this is not always\n+\t     the case.  */\n+\t  loop->first\n+\t    = BASIC_BLOCK (sbitmap_first_set_bit (loop->nodes));\n+\t  loop->last\n+\t    = BASIC_BLOCK (sbitmap_last_set_bit (loop->nodes));\n+\t  \n+\t  if (flags & LOOP_EDGES)\n+\t    {\n+\t      /* Find edges which enter the loop header.\n+\t\t Note that the entry edges should only\n+\t\t enter the header of a natural loop.  */\n+\t      loop->num_entries\n+\t\t= flow_loop_entry_edges_find (loop->header,\n+\t\t\t\t\t      loop->nodes,\n+\t\t\t\t\t      &loop->entry_edges);\n+\t      \n+\t      /* Find edges which exit the loop.  */\n+\t      loop->num_exits\n+\t\t= flow_loop_exit_edges_find (loop->nodes,\n+\t\t\t\t\t     &loop->exit_edges);\n+\t      \n+\t      /* Determine which loop nodes dominate all the exits\n+\t\t of the loop.  */\n+\t      loop->exits_doms = sbitmap_alloc (n_basic_blocks);\n+\t      sbitmap_copy (loop->exits_doms, loop->nodes);\n+\t      for (j = 0; j < loop->num_exits; j++)\n+\t\tsbitmap_a_and_b (loop->exits_doms, loop->exits_doms,\n+\t\t\t\t dom[loop->exit_edges[j]->src->index]);\n+\t      \n+\t      /* The header of a natural loop must dominate\n+\t\t all exits.  */\n+\t      if (! TEST_BIT (loop->exits_doms, loop->header->index))\n+\t\tabort ();\n+\t    }\n+\t  \n+\t  if (flags & LOOP_PRE_HEADER)\n+\t    {\n+\t      /* Look to see if the loop has a pre-header node.  */\n+\t      loop->pre_header \n+\t\t= flow_loop_pre_header_find (loop->header, dom);\n+\n+\t      flow_loop_pre_header_scan (loop);\n+\t    }\n+\t}\n+\n       /* Natural loops with shared headers may either be disjoint or\n \t nested.  Disjoint loops with shared headers cannot be inner\n \t loops and should be merged.  For now just mark loops that share\n@@ -8163,6 +8248,23 @@ flow_loops_find (loops)\n   return num_loops;\n }\n \n+\n+/* Update the information regarding the loops in the CFG\n+   specified by LOOPS.  */\n+int\n+flow_loops_update (loops, flags)\n+     struct loops *loops;\n+     int flags;\n+{\n+  /* One day we may want to update the current loop data.  For now\n+     throw away the old stuff and rebuild what we need.  */\n+  if (loops->array)\n+    flow_loops_free (loops);\n+  \n+  return flow_loops_find (loops, flags);\n+}\n+\n+\n /* Return non-zero if edge E enters header of LOOP from outside of LOOP.  */\n \n int"}, {"sha": "5e819fbc1784b4c5472b3d01d288a3c1e094fd87", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "patch": "@@ -3211,7 +3211,7 @@ rest_of_compilation (decl)\n \n       /* Discover and record the loop depth at the head of each basic\n \t block.  The loop infrastructure does the real job for us.  */\n-      flow_loops_find (&loops);\n+      flow_loops_find (&loops, LOOP_TREE);\n \n       /* Estimate using heuristics if no profiling info is available.  */\n       estimate_probability (&loops);"}]}