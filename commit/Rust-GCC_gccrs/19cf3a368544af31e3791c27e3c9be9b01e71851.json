{"sha": "19cf3a368544af31e3791c27e3c9be9b01e71851", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTljZjNhMzY4NTQ0YWYzMWUzNzkxYzI3ZTNjOWJlOWIwMWU3MTg1MQ==", "commit": {"author": {"name": "Jackson Woodruff", "email": "jackson.woodruff@arm.com", "date": "2017-11-24T16:03:13Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-11-24T16:03:13Z"}, "message": "Factor out division by squares\n\nThis patch implements the some of the division optimizations discussed in\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=71026.\n\nThe division reciprocal optimization now handles divisions by squares:\n\n     x / (y * y) -> x  * (1 / y) * (1 / y)\n\nThis requires at least one more division by y before it triggers - the\n3 divisions of (1/ y) are then CSEd into a single division.  Overall\nthis changes 1 division into 1 multiply, which is generally much faster.\n\n\n2017-11-24  Jackson Woodruff  <jackson.woodruff@arm.com>\n\n    gcc/\n\tPR tree-optimization/71026\n\t* tree-ssa-math-opts (is_division_by_square, is_square_of): New.\n\t(insert_reciprocals): Change to insert reciprocals before a division\n\tby a square and to insert the square of a reciprocal.\n\t(execute_cse_reciprocals_1): Change to consider division by a square.\n\t(register_division_in): Add importance parameter.\n\n    testsuite/\n\tPR tree-optimization/71026\n\t* gfortran.dg/extract_recip_1.f: New test.\n\t* gcc.dg/extract_recip_3.c: New test.\n\t* gcc.dg/extract_recip_4.c: New test.\n\nFrom-SVN: r255141", "tree": {"sha": "4a8138b582ded97f36d36a37fd7c48fe089bb91d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a8138b582ded97f36d36a37fd7c48fe089bb91d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19cf3a368544af31e3791c27e3c9be9b01e71851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19cf3a368544af31e3791c27e3c9be9b01e71851", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19cf3a368544af31e3791c27e3c9be9b01e71851", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19cf3a368544af31e3791c27e3c9be9b01e71851/comments", "author": null, "committer": null, "parents": [{"sha": "15b6695ac534148a10dd5a5f266bf2e49316dc32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b6695ac534148a10dd5a5f266bf2e49316dc32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b6695ac534148a10dd5a5f266bf2e49316dc32"}], "stats": {"total": 319, "additions": 289, "deletions": 30}, "files": [{"sha": "dc52c16d6fbc452504622bc124d969ed5797cdcc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19cf3a368544af31e3791c27e3c9be9b01e71851", "patch": "@@ -1,3 +1,12 @@\n+2017-11-24  Jackson Woodruff  <jackson.woodruff@arm.com>\n+\n+\tPR tree-optimization/71026\n+\t* tree-ssa-math-opts (is_division_by_square, is_square_of): New.\n+\t(insert_reciprocals): Change to insert reciprocals before a division\n+\tby a square and to insert the square of a reciprocal.\n+\t(execute_cse_reciprocals_1): Change to consider division by a square.\n+\t(register_division_in): Add importance parameter.\n+\n 2017-11-24  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82402"}, {"sha": "0a8532ce7038818dac74235342426155c8686575", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=19cf3a368544af31e3791c27e3c9be9b01e71851", "patch": "@@ -1,3 +1,10 @@\n+2017-11-24  Jackson Woodruff  <jackson.woodruff@arm.com>\n+\n+\tPR tree-optimization/71026\n+\t* gfortran.dg/extract_recip_1.f: New test.\n+\t* gcc.dg/extract_recip_3.c: New test.\n+\t* gcc.dg/extract_recip_4.c: New test.\n+\n 2017-11-24  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82402"}, {"sha": "15bcc27f8bfae6cc960f7b60a2ddf95afc2692ee", "filename": "gcc/testsuite/gcc.dg/extract_recip_3.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2Fgcc.dg%2Fextract_recip_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2Fgcc.dg%2Fextract_recip_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fextract_recip_3.c?ref=19cf3a368544af31e3791c27e3c9be9b01e71851", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-optimized-raw\" } */\n+\n+float\n+extract_square (float *a, float *b, float x, float y)\n+{\n+  *a = 3 / (y * y);\n+  *b = 5 / (y * y);\n+\n+  return x / (y * y);\n+}\n+\n+/* Don't expect the 'powmult' (calculation of y * y)\n+   to be deleted until a later pass, so look for one\n+   more multiplication than strictly necessary.  */\n+float\n+extract_recip (float *a, float *b, float x, float y, float z)\n+{\n+  *a = 7 / y;\n+  *b = x / (y * y);\n+\n+  return z / y;\n+}\n+\n+/* 4 multiplications in 'extract_square', and 4 in 'extract_recip'.  */\n+/* { dg-final { scan-tree-dump-times \"mult_expr\" 8 \"optimized\" } } */\n+\n+/* 1 division in 'extract_square', 1 division in 'extract_recip'. */\n+/* { dg-final { scan-tree-dump-times \"rdiv_expr\" 2 \"optimized\" } } */"}, {"sha": "816e3615e5082dcb3d4e752059d708b99ec5b6cf", "filename": "gcc/testsuite/gcc.dg/extract_recip_4.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2Fgcc.dg%2Fextract_recip_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2Fgcc.dg%2Fextract_recip_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fextract_recip_4.c?ref=19cf3a368544af31e3791c27e3c9be9b01e71851", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-optimized-raw\" } */\n+\n+/* Don't expect any of these divisions to be extracted.  */\n+double f (double x, int p)\n+{\n+  if (p > 0)\n+    {\n+      return 1.0/(x * x);\n+    }\n+\n+  if (p > -1)\n+    {\n+      return x * x * x;\n+    }\n+  return  1.0 /(x);\n+}\n+\n+/* Expect a reciprocal to be extracted here.  */\n+double g (double *a, double x, double y)\n+{\n+  *a = 3 / y;\n+  double k = x / (y * y);\n+\n+  if (y * y == 2.0)\n+    return k + 1 / y;\n+  else\n+    return k - 1 / y;\n+}\n+\n+/* Expect 2 divisions in 'f' and 1 in 'g'.  */\n+/* { dg-final { scan-tree-dump-times \"rdiv_expr\" 3 \"optimized\" } } */\n+/* Expect 3 multiplications in 'f' and 4 in 'g'.  */\n+/* { dg-final { scan-tree-dump-times \"mult_expr\" 7 \"optimized\" } } */"}, {"sha": "f70157c6da25e6dbe309456eecada6a78317f97e", "filename": "gcc/testsuite/gfortran.dg/extract_recip_1.f", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2Fgfortran.dg%2Fextract_recip_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftestsuite%2Fgfortran.dg%2Fextract_recip_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextract_recip_1.f?ref=19cf3a368544af31e3791c27e3c9be9b01e71851", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! { dg-options \"-Ofast -fdump-tree-optimized-raw\" }\n+\n+      SUBROUTINE F(N,X,Y,Z,A,B)\n+          DIMENSION X(4,4), Y(4), Z(4)\n+          REAL, INTENT(INOUT) :: A, B\n+\n+          A = 1 / (Y(N)*Y(N))\n+\n+          DO I = 1, NV\n+          X(I, I) = 1 + X(I, I)\n+          ENDDO\n+\n+          Z(1) =  B / Y(N)\n+          Z(2) =  N / Y(N)\n+          RETURN\n+      END\n+\n+! { dg-final { scan-tree-dump-times \"rdiv_expr\" 1 \"optimized\" } }"}, {"sha": "7b5250b083ca7465343d0d99406d115c2038e748", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 191, "deletions": 30, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cf3a368544af31e3791c27e3c9be9b01e71851/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=19cf3a368544af31e3791c27e3c9be9b01e71851", "patch": "@@ -127,6 +127,10 @@ struct occurrence {\n      inserted in BB.  */\n   tree recip_def;\n \n+  /* If non-NULL, the SSA_NAME holding the definition for a squared\n+     reciprocal inserted in BB.  */\n+  tree square_recip_def;\n+\n   /* If non-NULL, the GIMPLE_ASSIGN for a reciprocal computation that\n      was inserted in BB.  */\n   gimple *recip_def_stmt;\n@@ -270,10 +274,14 @@ insert_bb (struct occurrence *new_occ, basic_block idom,\n   *p_head = new_occ;\n }\n \n-/* Register that we found a division in BB.  */\n+/* Register that we found a division in BB.\n+   IMPORTANCE is a measure of how much weighting to give\n+   that division.  Use IMPORTANCE = 2 to register a single\n+   division.  If the division is going to be found multiple\n+   times use 1 (as it is with squares).  */\n \n static inline void\n-register_division_in (basic_block bb)\n+register_division_in (basic_block bb, int importance)\n {\n   struct occurrence *occ;\n \n@@ -285,7 +293,7 @@ register_division_in (basic_block bb)\n     }\n \n   occ->bb_has_division = true;\n-  occ->num_divisions++;\n+  occ->num_divisions += importance;\n }\n \n \n@@ -328,66 +336,145 @@ is_division_by (gimple *use_stmt, tree def)\n \t && gimple_assign_rhs1 (use_stmt) != def;\n }\n \n+/* Return whether USE_STMT is DEF * DEF.  */\n+static inline bool\n+is_square_of (gimple *use_stmt, tree def)\n+{\n+  if (gimple_code (use_stmt) == GIMPLE_ASSIGN\n+      && gimple_assign_rhs_code (use_stmt) == MULT_EXPR)\n+    {\n+      tree op0 = gimple_assign_rhs1 (use_stmt);\n+      tree op1 = gimple_assign_rhs2 (use_stmt);\n+\n+      return op0 == op1 && op0 == def;\n+    }\n+  return 0;\n+}\n+\n+/* Return whether USE_STMT is a floating-point division by\n+   DEF * DEF.  */\n+static inline bool\n+is_division_by_square (gimple *use_stmt, tree def)\n+{\n+  if (gimple_code (use_stmt) == GIMPLE_ASSIGN\n+      && gimple_assign_rhs_code (use_stmt) == RDIV_EXPR\n+      && gimple_assign_rhs1 (use_stmt) != gimple_assign_rhs2 (use_stmt))\n+    {\n+      tree denominator = gimple_assign_rhs2 (use_stmt);\n+      if (TREE_CODE (denominator) == SSA_NAME)\n+\t{\n+\t  return is_square_of (SSA_NAME_DEF_STMT (denominator), def);\n+\t}\n+    }\n+  return 0;\n+}\n+\n /* Walk the subset of the dominator tree rooted at OCC, setting the\n    RECIP_DEF field to a definition of 1.0 / DEF that can be used in\n    the given basic block.  The field may be left NULL, of course,\n    if it is not possible or profitable to do the optimization.\n \n    DEF_BSI is an iterator pointing at the statement defining DEF.\n    If RECIP_DEF is set, a dominator already has a computation that can\n-   be used.  */\n+   be used.\n+\n+   If should_insert_square_recip is set, then this also inserts\n+   the square of the reciprocal immediately after the definition\n+   of the reciprocal.  */\n \n static void\n insert_reciprocals (gimple_stmt_iterator *def_gsi, struct occurrence *occ,\n-\t\t    tree def, tree recip_def, int threshold)\n+\t\t    tree def, tree recip_def, tree square_recip_def,\n+\t\t    int should_insert_square_recip, int threshold)\n {\n   tree type;\n-  gassign *new_stmt;\n+  gassign *new_stmt, *new_square_stmt;\n   gimple_stmt_iterator gsi;\n   struct occurrence *occ_child;\n \n   if (!recip_def\n       && (occ->bb_has_division || !flag_trapping_math)\n-      && occ->num_divisions >= threshold)\n+      /* Divide by two as all divisions are counted twice in\n+\t the costing loop.  */\n+      && occ->num_divisions / 2 >= threshold)\n     {\n       /* Make a variable with the replacement and substitute it.  */\n       type = TREE_TYPE (def);\n       recip_def = create_tmp_reg (type, \"reciptmp\");\n       new_stmt = gimple_build_assign (recip_def, RDIV_EXPR,\n \t\t\t\t      build_one_cst (type), def);\n \n+      if (should_insert_square_recip)\n+\t{\n+\t  square_recip_def = create_tmp_reg (type, \"powmult_reciptmp\");\n+\t  new_square_stmt = gimple_build_assign (square_recip_def, MULT_EXPR,\n+\t\t\t\t\t\t recip_def, recip_def);\n+\t}\n+\n       if (occ->bb_has_division)\n-        {\n-          /* Case 1: insert before an existing division.  */\n-          gsi = gsi_after_labels (occ->bb);\n-          while (!gsi_end_p (gsi) && !is_division_by (gsi_stmt (gsi), def))\n+\t{\n+\t  /* Case 1: insert before an existing division.  */\n+\t  gsi = gsi_after_labels (occ->bb);\n+\t  while (!gsi_end_p (gsi)\n+\t\t && (!is_division_by (gsi_stmt (gsi), def))\n+\t\t && (!is_division_by_square (gsi_stmt (gsi), def)))\n \t    gsi_next (&gsi);\n \n-          gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n-        }\n+\t  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+\t}\n       else if (def_gsi && occ->bb == def_gsi->bb)\n-        {\n-          /* Case 2: insert right after the definition.  Note that this will\n+\t{\n+\t  /* Case 2: insert right after the definition.  Note that this will\n \t     never happen if the definition statement can throw, because in\n \t     that case the sole successor of the statement's basic block will\n \t     dominate all the uses as well.  */\n-          gsi_insert_after (def_gsi, new_stmt, GSI_NEW_STMT);\n-        }\n+\t  gsi = *def_gsi;\n+\t  gsi_insert_after (def_gsi, new_stmt, GSI_NEW_STMT);\n+\t}\n       else\n-        {\n-          /* Case 3: insert in a basic block not containing defs/uses.  */\n-          gsi = gsi_after_labels (occ->bb);\n-          gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n-        }\n+\t{\n+\t  /* Case 3: insert in a basic block not containing defs/uses.  */\n+\t  gsi = gsi_after_labels (occ->bb);\n+\t  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+\t}\n+\n+      /* Regardless of which case the reciprocal as inserted in,\n+\t we insert the square immediately after the reciprocal.  */\n+      if (should_insert_square_recip)\n+\tgsi_insert_before (&gsi, new_square_stmt, GSI_SAME_STMT);\n \n       reciprocal_stats.rdivs_inserted++;\n \n       occ->recip_def_stmt = new_stmt;\n     }\n \n   occ->recip_def = recip_def;\n+  occ->square_recip_def = square_recip_def;\n   for (occ_child = occ->children; occ_child; occ_child = occ_child->next)\n-    insert_reciprocals (def_gsi, occ_child, def, recip_def, threshold);\n+    insert_reciprocals (def_gsi, occ_child, def, recip_def,\n+\t\t\tsquare_recip_def, should_insert_square_recip,\n+\t\t\tthreshold);\n+}\n+\n+/* Replace occurrences of expr / (x * x) with expr * ((1 / x) * (1 / x)).\n+   Take as argument the use for (x * x).  */\n+static inline void\n+replace_reciprocal_squares (use_operand_p use_p)\n+{\n+  gimple *use_stmt = USE_STMT (use_p);\n+  basic_block bb = gimple_bb (use_stmt);\n+  struct occurrence *occ = (struct occurrence *) bb->aux;\n+\n+  if (optimize_bb_for_speed_p (bb) && occ->square_recip_def\n+      && occ->recip_def)\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+      gimple_assign_set_rhs_code (use_stmt, MULT_EXPR);\n+      gimple_assign_set_rhs2 (use_stmt, occ->square_recip_def);\n+      SET_USE (use_p, occ->square_recip_def);\n+      fold_stmt_inplace (&gsi);\n+      update_stmt (use_stmt);\n+    }\n }\n \n \n@@ -448,32 +535,85 @@ free_bb (struct occurrence *occ)\n static void\n execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)\n {\n-  use_operand_p use_p;\n-  imm_use_iterator use_iter;\n+  use_operand_p use_p, square_use_p;\n+  imm_use_iterator use_iter, square_use_iter;\n+  tree square_def;\n   struct occurrence *occ;\n-  int count = 0, threshold;\n+  int count = 0;\n+  int threshold;\n+  int square_recip_count = 0;\n+  int sqrt_recip_count = 0;\n \n   gcc_assert (FLOAT_TYPE_P (TREE_TYPE (def)) && is_gimple_reg (def));\n+  threshold = targetm.min_divisions_for_recip_mul (TYPE_MODE (TREE_TYPE (def)));\n+\n+  /* If this is a square (x * x), we should check whether there are any\n+     enough divisions by x on it's own to warrant waiting for that pass.  */\n+  if (TREE_CODE (def) == SSA_NAME)\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (def);\n+\n+      if (is_gimple_assign (def_stmt)\n+\t  && gimple_assign_rhs_code (def_stmt) == MULT_EXPR\n+\t  && gimple_assign_rhs1 (def_stmt) == gimple_assign_rhs2 (def_stmt))\n+\t{\n+\t  /* This statement is a square of something.  We should take this\n+\t     in to account, as it may be more profitable to not extract\n+\t     the reciprocal here.  */\n+\t  tree op0 = gimple_assign_rhs1 (def_stmt);\n+\t  FOR_EACH_IMM_USE_FAST (use_p, use_iter, op0)\n+\t    {\n+\t      gimple *use_stmt = USE_STMT (use_p);\n+\t      if (is_division_by (use_stmt, op0))\n+\t\tsqrt_recip_count ++;\n+\t    }\n+\t}\n+    }\n \n   FOR_EACH_IMM_USE_FAST (use_p, use_iter, def)\n     {\n       gimple *use_stmt = USE_STMT (use_p);\n       if (is_division_by (use_stmt, def))\n \t{\n-\t  register_division_in (gimple_bb (use_stmt));\n+\t  register_division_in (gimple_bb (use_stmt), 2);\n \t  count++;\n \t}\n+\n+      if (is_square_of (use_stmt, def))\n+\t{\n+\t  square_def = gimple_assign_lhs (use_stmt);\n+\t  FOR_EACH_IMM_USE_FAST (square_use_p, square_use_iter, square_def)\n+\t    {\n+\t      gimple *square_use_stmt = USE_STMT (square_use_p);\n+\t      if (is_division_by (square_use_stmt, square_def))\n+\t\t{\n+\t\t  /* Halve the relative importance as this is called twice\n+\t\t     for each division by a square.  */\n+\t\t  register_division_in (gimple_bb (square_use_stmt), 1);\n+\t\t  square_recip_count ++;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n+  /* Square reciprocals will have been counted twice.  */\n+  square_recip_count /= 2;\n+\n+  if (sqrt_recip_count > square_recip_count)\n+    /* It will be more profitable to extract a 1 / x expression later,\n+       so it is not worth attempting to extract 1 / (x * x) now.  */\n+    return;\n+\n   /* Do the expensive part only if we can hope to optimize something.  */\n-  threshold = targetm.min_divisions_for_recip_mul (TYPE_MODE (TREE_TYPE (def)));\n-  if (count >= threshold)\n+  if (count + square_recip_count >= threshold\n+      && count >= 1)\n     {\n       gimple *use_stmt;\n       for (occ = occ_head; occ; occ = occ->next)\n \t{\n \t  compute_merit (occ);\n-\t  insert_reciprocals (def_gsi, occ, def, NULL, threshold);\n+\t  insert_reciprocals (def_gsi, occ, def, NULL, NULL,\n+\t\t\t      square_recip_count, threshold);\n \t}\n \n       FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, def)\n@@ -483,6 +623,27 @@ execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)\n \t      FOR_EACH_IMM_USE_ON_STMT (use_p, use_iter)\n \t\treplace_reciprocal (use_p);\n \t    }\n+\t  else if (square_recip_count > 0\n+\t\t   && is_square_of (use_stmt, def))\n+\t    {\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, use_iter)\n+\t\t{\n+\t\t  /* Find all uses of the square that are divisions and\n+\t\t   * replace them by multiplications with the inverse.  */\n+\t\t  imm_use_iterator square_iterator;\n+\t\t  gimple *powmult_use_stmt = USE_STMT (use_p);\n+\t\t  tree powmult_def_name = gimple_assign_lhs (powmult_use_stmt);\n+\n+\t\t  FOR_EACH_IMM_USE_STMT (powmult_use_stmt,\n+\t\t\t\t\t square_iterator, powmult_def_name)\n+\t\t    FOR_EACH_IMM_USE_ON_STMT (square_use_p, square_iterator)\n+\t\t      {\n+\t\t\tgimple *powmult_use_stmt = USE_STMT (square_use_p);\n+\t\t\tif (is_division_by (powmult_use_stmt, powmult_def_name))\n+\t\t\t  replace_reciprocal_squares (square_use_p);\n+\t\t      }\n+\t\t}\n+\t    }\n \t}\n     }\n "}]}