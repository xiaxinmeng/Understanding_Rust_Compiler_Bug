{"sha": "aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVhNTBiNDVmNWRiMzZkNzdkNGNmODQ4OGRkOThkOGEwNmMwNzNhOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-11-24T19:35:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-24T19:35:38Z"}, "message": "lto-streamer-in.c (lto_read_body_or_constructor): Set TYPE_CANONICAL only for types where LTO sets them.\n\n\t* lto-streamer-in.c (lto_read_body_or_constructor): Set TYPE_CANONICAL\n\tonly for types where LTO sets them.\n\t* tree.c (build_array_type_1): Do ont set TYPE_CANONICAL for LTO.\n\t(make_vector_type): Likewise.\n\t(gimple_canonical_types_compatible_p): Use canonical_type_used_p.\n\t* tree.h (canonical_type_used_p): New inline.\n\t* alias.c (get_alias_set): Handle structural equality for all\n\ttypes that pass canonical_type_used_p.\n\t(record_component_aliases): Look through all types with\n\trecord_component_aliases for possible pointers; sanity check that\n\tthe alias sets match.\n\n\t* lto.c (iterative_hash_canonical_type): Recruse for all types\n\twhich pass !canonical_type_used_p.\n\t(gimple_register_canonical_type_1): Sanity check we do not compute\n\tcanonical type of anything with !canonical_type_used_p.\n\t(gimple_register_canonical_type): Skip all types that are\n\t!canonical_type_used_p\n\nFrom-SVN: r230835", "tree": {"sha": "2720a21d3a42af746351fb5f5e419414f55e6da8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2720a21d3a42af746351fb5f5e419414f55e6da8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/comments", "author": null, "committer": null, "parents": [{"sha": "73c923307beaf7c49d753528fead01615ff85847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c923307beaf7c49d753528fead01615ff85847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c923307beaf7c49d753528fead01615ff85847"}], "stats": {"total": 99, "additions": 76, "deletions": 23}, "files": [{"sha": "a3e259bb15c5bed2ac370eb3fd06266191e1daae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "patch": "@@ -1,3 +1,17 @@\n+2015-11-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-streamer-in.c (lto_read_body_or_constructor): Set TYPE_CANONICAL\n+\tonly for types where LTO sets them.\n+\t* tree.c (build_array_type_1): Do ont set TYPE_CANONICAL for LTO.\n+\t(make_vector_type): Likewise.\n+\t(gimple_canonical_types_compatible_p): Use canonical_type_used_p.\n+\t* tree.h (canonical_type_used_p): New inline.\n+\t* alias.c (get_alias_set): Handle structural equality for all\n+\ttypes that pass canonical_type_used_p.\n+\t(record_component_aliases): Look through all types with\n+\trecord_component_aliases for possible pointers; sanity check that\n+\tthe alias sets match.\n+\n 2015-11-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.md (lround<mode>di2): Remove constraints."}, {"sha": "e8e3f6c34acd55a11278e9b1605cfad1bc5c9a39", "filename": "gcc/alias.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "patch": "@@ -869,11 +869,11 @@ get_alias_set (tree t)\n       set = lang_hooks.get_alias_set (t);\n       if (set != -1)\n \treturn set;\n-      /* Handle structure type equality for pointer types.  This is easy\n-\t to do, because the code bellow ignore canonical types on these anyway.\n-\t This is important for LTO, where TYPE_CANONICAL for pointers can not\n-\t be meaningfuly computed by the frotnend.  */\n-      if (!POINTER_TYPE_P (t))\n+      /* Handle structure type equality for pointer types, arrays and vectors.\n+\t This is easy to do, because the code bellow ignore canonical types on\n+\t these anyway.  This is important for LTO, where TYPE_CANONICAL for\n+\t pointers can not be meaningfuly computed by the frotnend.  */\n+      if (canonical_type_used_p (t))\n \t{\n \t  /* In LTO we set canonical types for all types where it makes\n \t     sense to do so.  Double check we did not miss some type.  */\n@@ -929,7 +929,9 @@ get_alias_set (tree t)\n      integer(kind=4)[4] the same alias set or not.\n      Just be pragmatic here and make sure the array and its element\n      type get the same alias set assigned.  */\n-  else if (TREE_CODE (t) == ARRAY_TYPE && !TYPE_NONALIASED_COMPONENT (t))\n+  else if (TREE_CODE (t) == ARRAY_TYPE\n+\t   && (!TYPE_NONALIASED_COMPONENT (t)\n+\t       || TYPE_STRUCTURAL_EQUALITY_P (t)))\n     set = get_alias_set (TREE_TYPE (t));\n \n   /* From the former common C and C++ langhook implementation:\n@@ -971,7 +973,10 @@ get_alias_set (tree t)\n \t We also want to make pointer to array/vector equivalent to pointer to\n \t its element (see the reasoning above). Skip all those types, too.  */\n       for (p = t; POINTER_TYPE_P (p)\n-\t   || (TREE_CODE (p) == ARRAY_TYPE && !TYPE_NONALIASED_COMPONENT (p))\n+\t   || (TREE_CODE (p) == ARRAY_TYPE\n+\t       && (!TYPE_NONALIASED_COMPONENT (p)\n+\t\t   || !COMPLETE_TYPE_P (p)\n+\t\t   || TYPE_STRUCTURAL_EQUALITY_P (p)))\n \t   || TREE_CODE (p) == VECTOR_TYPE;\n \t   p = TREE_TYPE (p))\n \t{\n@@ -1200,15 +1205,18 @@ record_component_aliases (tree type)\n \t\t/* VECTOR_TYPE and ARRAY_TYPE share the alias set with their\n \t\t   element type and that type has to be normalized to void *,\n \t\t   too, in the case it is a pointer. */\n-\t\twhile ((TREE_CODE (t) == ARRAY_TYPE\n-\t\t\t&& (!COMPLETE_TYPE_P (t)\n-\t\t\t    || TYPE_NONALIASED_COMPONENT (t)))\n-\t\t       || TREE_CODE (t) == VECTOR_TYPE)\n-\t\t  t = TREE_TYPE (t);\n+\t\twhile (!canonical_type_used_p (t) && !POINTER_TYPE_P (t))\n+\t\t  {\n+\t\t    gcc_checking_assert (TYPE_STRUCTURAL_EQUALITY_P (t));\n+\t\t    t = TREE_TYPE (t);\n+\t\t  }\n \t\tif (POINTER_TYPE_P (t))\n \t\t  t = ptr_type_node;\n+\t\telse if (flag_checking)\n+\t\t  gcc_checking_assert (get_alias_set (t)\n+\t\t\t\t       == get_alias_set (TREE_TYPE (field)));\n \t      }\n-\t   \n+\n \t    record_alias_subset (superset, get_alias_set (t));\n \t  }\n       break;"}, {"sha": "53298519b058b489c470b5fb35a8a6bc6e94fe52", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "patch": "@@ -1231,7 +1231,9 @@ lto_read_body_or_constructor (struct lto_file_decl_data *file_data, struct symta\n \t      if (TYPE_P (t))\n \t\t{\n \t\t  gcc_assert (TYPE_CANONICAL (t) == NULL_TREE);\n-\t\t  TYPE_CANONICAL (t) = TYPE_MAIN_VARIANT (t);\n+\t\t  if (type_with_alias_set_p (t)\n+\t\t      && canonical_type_used_p (t))\n+\t\t    TYPE_CANONICAL (t) = TYPE_MAIN_VARIANT (t);\n \t\t  if (TYPE_MAIN_VARIANT (t) != t)\n \t\t    {\n \t\t      gcc_assert (TYPE_NEXT_VARIANT (t) == NULL_TREE);"}, {"sha": "be0eb7f4e92db22777e0563a8e690d45a2480fda", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "patch": "@@ -1,3 +1,12 @@\n+2015-11-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (iterative_hash_canonical_type): Recruse for all types\n+\twhich pass !canonical_type_used_p.\n+\t(gimple_register_canonical_type_1): Sanity check we do not compute\n+\tcanonical type of anything with !canonical_type_used_p.\n+\t(gimple_register_canonical_type): Skip all types that are\n+\t!canonical_type_used_p\n+\n 2015-11-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (unify_scc): Use free_node."}, {"sha": "b1e2d6e8090cdd3b7819c1e4cd40de74f6ac58b5", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "patch": "@@ -389,9 +389,7 @@ iterative_hash_canonical_type (tree type, inchash::hash &hstate)\n   /* All type variants have same TYPE_CANONICAL.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  /* We do not compute TYPE_CANONICAl of POINTER_TYPE because the aliasing\n-     code never use it anyway.  */\n-  if (POINTER_TYPE_P (type))\n+  if (!canonical_type_used_p (type))\n     v = hash_canonical_type (type);\n   /* An already processed type.  */\n   else if (TYPE_CANONICAL (type))\n@@ -444,7 +442,7 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n \n   gcc_checking_assert (TYPE_P (t) && !TYPE_CANONICAL (t)\n \t\t       && type_with_alias_set_p (t)\n-\t\t       && !POINTER_TYPE_P (t));\n+\t\t       && canonical_type_used_p (t));\n \n   slot = htab_find_slot_with_hash (gimple_canonical_types, t, hash, INSERT);\n   if (*slot)\n@@ -477,7 +475,8 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n static void\n gimple_register_canonical_type (tree t)\n {\n-  if (TYPE_CANONICAL (t) || !type_with_alias_set_p (t) || POINTER_TYPE_P (t))\n+  if (TYPE_CANONICAL (t) || !type_with_alias_set_p (t)\n+      || !canonical_type_used_p (t))\n     return;\n \n   /* Canonical types are same among all complete variants.  */"}, {"sha": "4176d614a51d308eb7238e02820923db9ac79275", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "patch": "@@ -8252,7 +8252,8 @@ build_array_type_1 (tree elt_type, tree index_type, bool shared)\n   if (TYPE_CANONICAL (t) == t)\n     {\n       if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n-\t  || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type)))\n+\t  || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type))\n+\t  || in_lto_p)\n \tSET_TYPE_STRUCTURAL_EQUALITY (t);\n       else if (TYPE_CANONICAL (elt_type) != elt_type\n \t       || (index_type && TYPE_CANONICAL (index_type) != index_type))\n@@ -9865,7 +9866,7 @@ make_vector_type (tree innertype, int nunits, machine_mode mode)\n   SET_TYPE_VECTOR_SUBPARTS (t, nunits);\n   SET_TYPE_MODE (t, mode);\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P (innertype))\n+  if (TYPE_STRUCTURAL_EQUALITY_P (innertype) || in_lto_p)\n     SET_TYPE_STRUCTURAL_EQUALITY (t);\n   else if ((TYPE_CANONICAL (innertype) != innertype\n \t    || mode != VOIDmode)\n@@ -13295,7 +13296,8 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n \t TYPE_CANONICAL is more fine grained than the equivalnce we test (where\n \t all pointers are considered equal.  Be sure to not return false\n \t negatives.  */\n-      gcc_checking_assert (!POINTER_TYPE_P (t1) && !POINTER_TYPE_P (t2));\n+      gcc_checking_assert (canonical_type_used_p (t1)\n+\t\t\t   && canonical_type_used_p (t2));\n       return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n     }\n "}, {"sha": "121c88bb5e581989fbbd161087881c1df1b8b249", "filename": "gcc/tree.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea50b45f5db36d77d4cf8488dd98d8a06c073a8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "patch": "@@ -4811,7 +4811,9 @@ extern void DEBUG_FUNCTION verify_type (const_tree t);\n extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,\n \t\t\t\t\t\t bool trust_type_canonical = true);\n extern bool type_with_interoperable_signedness (const_tree);\n-/* Return simplified tree code of type that is used for canonical type merging.  */\n+\n+/* Return simplified tree code of type that is used for canonical type\n+   merging.  */\n inline enum tree_code\n tree_code_for_canonical_type_merging (enum tree_code code)\n {\n@@ -4833,6 +4835,23 @@ tree_code_for_canonical_type_merging (enum tree_code code)\n   return code;\n }\n \n+/* Return ture if get_alias_set care about TYPE_CANONICAL of given type.\n+   We don't define the types for pointers, arrays and vectors.  The reason is\n+   that pointers are handled specially: ptr_type_node accesses conflict with\n+   accesses to all other pointers.  This is done by alias.c.\n+   Because alias sets of arrays and vectors are the same as types of their\n+   elements, we can't compute canonical type either.  Otherwise we could go\n+   form void *[10] to int *[10] (because they are equivalent for canonical type\n+   machinery) and get wrong TBAA.  */\n+\n+inline bool\n+canonical_type_used_p (const_tree t)\n+{\n+  return !(POINTER_TYPE_P (t)\n+\t   || TREE_CODE (t) == ARRAY_TYPE\n+\t   || TREE_CODE (t) == VECTOR_TYPE);\n+}\n+\n #define tree_map_eq tree_map_base_eq\n extern unsigned int tree_map_hash (const void *);\n #define tree_map_marked_p tree_map_base_marked_p"}]}