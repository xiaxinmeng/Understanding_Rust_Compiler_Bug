{"sha": "9a856ec7dba14be85dab4690cc4c3da9c28a6e23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4NTZlYzdkYmExNGJlODVkYWI0NjkwY2M0YzNkYTljMjhhNmUyMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-23T21:36:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-23T21:36:55Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1245", "tree": {"sha": "cef6ac5a8d37ee90553f1efde16d1d736967bbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cef6ac5a8d37ee90553f1efde16d1d736967bbd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a856ec7dba14be85dab4690cc4c3da9c28a6e23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a856ec7dba14be85dab4690cc4c3da9c28a6e23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a856ec7dba14be85dab4690cc4c3da9c28a6e23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a856ec7dba14be85dab4690cc4c3da9c28a6e23/comments", "author": null, "committer": null, "parents": [{"sha": "a3229491d3c156b10eaf563eadb324de2e951d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3229491d3c156b10eaf563eadb324de2e951d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3229491d3c156b10eaf563eadb324de2e951d89"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "756d7dd9718825b009b0dc687934b5704edc9739", "filename": "gcc/optabs.c", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a856ec7dba14be85dab4690cc4c3da9c28a6e23/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a856ec7dba14be85dab4690cc4c3da9c28a6e23/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9a856ec7dba14be85dab4690cc4c3da9c28a6e23", "patch": "@@ -413,6 +413,66 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \tdelete_insns_since (last);\n     }\n \n+  /* Look for a wider mode of the same class for which we think we\n+     can open-code the operation.  */\n+\n+  if ((class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+      && mode != OPTAB_DIRECT && mode != OPTAB_LIB)\n+    for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+\t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      {\n+\tif (binoptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+\t  {\n+\t    rtx xop0 = op0, xop1 = op1;\n+\t    int no_extend = 0;\n+\n+\t    /* For certain integer operations, we need not actually extend\n+\t       the narrow operands, as long as we will truncate\n+\t       the results to the same narrowness.  */\n+\n+\t    if ((binoptab == ior_optab || binoptab == and_optab\n+\t\t || binoptab == xor_optab\n+\t\t || binoptab == add_optab || binoptab == sub_optab\n+\t\t || binoptab == smul_optab\n+\t\t || binoptab == ashl_optab || binoptab == lshl_optab)\n+\t\t&& class == MODE_INT)\n+\t      no_extend = 1;\n+\n+\t    /* If an operand is a constant integer, we might as well\n+\t       convert it since that is more efficient than using a SUBREG,\n+\t       unlike the case for other operands.  */\n+\n+\t    if (no_extend && GET_MODE (xop0) != VOIDmode)\n+\t      xop0 = gen_rtx (SUBREG, wider_mode,\n+\t\t\t      force_reg (GET_MODE (xop0), xop0), 0);\n+\t    else\n+\t      xop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n+\n+\t    if (no_extend && GET_MODE (xop1) != VOIDmode)\n+\t      xop1 = gen_rtx (SUBREG, wider_mode,\n+\t\t\t\tforce_reg (GET_MODE (xop1), xop1), 0);\n+\t    else\n+\t      xop1 = convert_to_mode (wider_mode, xop1, unsignedp);\n+\n+\t    temp = expand_binop (wider_mode, binoptab, xop0, xop1, 0,\n+\t\t\t\t unsignedp, OPTAB_DIRECT);\n+\t    if (temp)\n+\t      {\n+\t\tif (class != MODE_INT)\n+\t\t  {\n+\t\t    if (target == 0)\n+\t\t      target = gen_reg_rtx (mode);\n+\t\t    convert_move (target, temp, 0);\n+\t\t    return target;\n+\t\t  }\n+\t\telse\n+\t\t  return gen_lowpart (mode, temp);\n+\t      }\n+\t    else\n+\t      delete_insns_since (last);\n+\t  }\n+      }\n+\n   /* These can be done a word at a time.  */\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n       && class == MODE_INT\n@@ -1106,6 +1166,45 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \tdelete_insns_since (last);\n     }\n \n+  /* It can't be done in this mode.  Can we open-code it in a wider mode?  */\n+\n+  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+    for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+\t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      {\n+\tif (unoptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+\t  {\n+\t    rtx xop0 = op0;\n+\n+\t    /* For certain operations, we need not actually extend\n+\t       the narrow operand, as long as we will truncate the\n+\t       results to the same narrowness.  */\n+\n+\t    if ((unoptab == neg_optab || unoptab == one_cmpl_optab)\n+\t\t&& class == MODE_INT)\n+\t      xop0 = gen_rtx (SUBREG, wider_mode, force_reg (mode, xop0), 0);\n+\t    else\n+\t      xop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n+\t      \n+\t    temp = expand_unop (wider_mode, unoptab, xop0, 0, unsignedp);\n+\n+\t    if (temp)\n+\t      {\n+\t\tif (class != MODE_INT)\n+\t\t  {\n+\t\t    if (target == 0)\n+\t\t      target = gen_reg_rtx (mode);\n+\t\t    convert_move (target, temp, 0);\n+\t\t    return target;\n+\t\t  }\n+\t\telse\n+\t\t  return gen_lowpart (mode, temp);\n+\t      }\n+\t    else\n+\t      delete_insns_since (last);\n+\t  }\n+      }\n+\n   /* These can be done a word at a time.  */\n   if (unoptab == one_cmpl_optab\n       && class == MODE_INT"}]}