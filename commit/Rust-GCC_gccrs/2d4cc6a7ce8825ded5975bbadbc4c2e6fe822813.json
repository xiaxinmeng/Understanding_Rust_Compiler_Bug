{"sha": "2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ0Y2M2YTdjZTg4MjVkZWQ1OTc1YmJhZGJjNGMyZTZmZTgyMjgxMw==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2002-05-08T22:37:21Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2002-05-08T22:37:21Z"}, "message": "rtl.h (RTL_FLAG_CHECK*): Add an argument for the macro name, and use it in all invocations of these macros.\n\n\t* rtl.h (RTL_FLAG_CHECK*): Add an argument for the macro name,\n\tand use it in all invocations of these macros.  Clean up comments.\n\t* rtl.c (rtl_check_failed_flag): Add an argument for the name\n\tof the flag access macro whose check failed.\n\t* doc/rtl.texi (Flags): Document additional flag uses.\n\nFrom-SVN: r53306", "tree": {"sha": "e27f3b369f1a463345b6cf679d7ee21561c952e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e27f3b369f1a463345b6cf679d7ee21561c952e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/comments", "author": null, "committer": null, "parents": [{"sha": "ea45dbb8e7cc710e17a273b44b49483c130ecd5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea45dbb8e7cc710e17a273b44b49483c130ecd5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea45dbb8e7cc710e17a273b44b49483c130ecd5d"}], "stats": {"total": 312, "additions": 182, "deletions": 130}, "files": [{"sha": "e177fd3f363235b850acc29379f1a869f5a50afd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "patch": "@@ -1,3 +1,11 @@\n+2002-05-08  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* rtl.h (RTL_FLAG_CHECK*): Add an argument for the macro name,\n+\tand use it in all invocations of these macros.  Clean up comments.\n+\t* rtl.c (rtl_check_failed_flag): Add an argument for the name\n+\tof the flag access macro whose check failed.\n+\t* doc/rtl.texi (Flags): Document additional flag uses.\n+\n 2002-05-08  Robert Spier <rspier@pobox.com>\n \t    Neil Booth  <neil@daikokuya.demon.co.uk>\n "}, {"sha": "f537f394df1c745f39b2779c599f4b71efbad4db", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "patch": "@@ -396,9 +396,11 @@ Stored in the @code{unchanging} field and printed as @samp{/u}.\n \n @findex INSN_ANNULLED_BRANCH_P\n @cindex @code{insn} and @samp{/u}\n-@cindex @code{unchanging}, in @code{insn}\n+@cindex @code{jump_insn} and @samp{/u}\n+@cindex @code{unchanging}, in @code{insn} and @code{jump_insn}\n @item INSN_ANNULLED_BRANCH_P (@var{x})\n-In an @code{insn} in the delay slot of a branch insn, indicates that an\n+In an @code{insn} or @code{jump_insn} in the delay slot of a branch insn,\n+indicates that an\n annulling branch should be used.  See the discussion under\n @code{sequence} below.  Stored in the @code{unchanging} field and printed\n as @samp{/u}.\n@@ -427,9 +429,11 @@ nonzero if the insn has been deleted.  Stored in the\n \n @findex INSN_FROM_TARGET_P\n @cindex @code{insn} and @samp{/s}\n-@cindex @code{in_struct}, in @code{insn}\n+@cindex @code{jump_insn} and @samp{/s}\n+@cindex @code{in_struct}, in @code{insn} and @code{jump_insn}\n @item INSN_FROM_TARGET_P (@var{x})\n-In an @code{insn} in a delay slot of a branch, indicates that the insn\n+In an @code{insn} or @code{jump_insn} in a delay slot of a branch,\n+indicates that the insn\n is from the target of the branch.  If the branch insn has\n @code{INSN_ANNULLED_BRANCH_P} set, this insn will only be executed if\n the branch is taken.  For annulled branches with\n@@ -499,11 +503,12 @@ Stored in the @code{frame_related} field and printed as @samp{/f}.\n \n @findex MEM_VOLATILE_P\n @cindex @code{mem} and @samp{/v}\n+@cindex @code{asm_input} and @samp{/v}\n @cindex @code{asm_operands} and @samp{/v}\n-@cindex @code{volatil}, in @code{mem} and @code{asm_operands}\n+@cindex @code{volatil}, in @code{mem}, @code{asm_operands}, and @code{asm_input}\n @item MEM_VOLATILE_P (@var{x})\n-In @code{mem} and @code{asm_operands} expressions, nonzero for volatile\n-memory references.\n+In @code{mem}, @code{asm_operands}, and @code{asm_input} expressions,\n+nonzero for volatile memory references.\n Stored in the @code{volatil} field and printed as @samp{/v}.\n \n @findex REG_FUNCTION_VALUE_P\n@@ -758,7 +763,8 @@ label that would have been deleted is replaced with a @code{note} of type\n In an @code{insn} during dead-code elimination, 1 means that the insn is\n dead code.\n \n-In an @code{insn} during reorg for an insn in the delay slot of a branch,\n+In an @code{insn} or @code{jump_insn} during reorg for an insn in the\n+delay slot of a branch,\n 1 means that this insn is from the target of the branch.\n \n In an @code{insn} during instruction scheduling, 1 means that this insn\n@@ -803,8 +809,8 @@ that the value of the expression never changes.\n In @code{subreg} expressions, it is 1 if the @code{subreg} references an\n unsigned object whose mode has been promoted to a wider mode.\n \n-In an @code{insn} in the delay slot of a branch instruction, 1 means\n-an annulling branch should be used.\n+In an @code{insn} or @code{jump_insn} in the delay slot of a branch\n+instruction, 1 means an annulling branch should be used.\n \n In a @code{symbol_ref} expression, 1 means that this symbol addresses\n something in the per-function constant pool.\n@@ -832,7 +838,8 @@ the symbol has already been written.\n @cindex @samp{/v} in RTL dump\n @item volatil\n @cindex volatile memory references\n-In a @code{mem} or @code{asm_operands} expression, it is 1 if the memory\n+In a @code{mem}, @code{asm_operands}, or @code{asm_input}\n+expression, it is 1 if the memory\n reference is volatile.  Volatile memory references may not be deleted,\n reordered or combined.\n "}, {"sha": "f88547dd79e06ca5d5c2ba0bdecf18463d0ddd72", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "patch": "@@ -641,14 +641,15 @@ rtvec_check_failed_bounds (r, n, file, line, func)\n \n #if defined ENABLE_RTL_FLAG_CHECKING\n void\n-rtl_check_failed_flag (r, file, line, func)\n+rtl_check_failed_flag (name, r, file, line, func)\n+    const char *name;\n     rtx r;\n     const char *file;\n     int line;\n     const char *func;\n {\n   internal_error\n-    (\"RTL flag check: access macro used with unexpected rtx code `%s' in %s, at %s:%d\",\n-     GET_RTX_NAME (GET_CODE (r)), func, trim_filename (file), line);\n+    (\"RTL flag check: %s used with unexpected rtx code `%s' in %s, at %s:%d\",\n+     name, GET_RTX_NAME (GET_CODE (r)), func, trim_filename (file), line);\n }\n #endif /* ENABLE_RTL_FLAG_CHECKING */"}, {"sha": "be37b033e9e8938ee2f14ef02974489826868d36", "filename": "gcc/rtl.h", "status": "modified", "additions": 152, "deletions": 116, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2d4cc6a7ce8825ded5975bbadbc4c2e6fe822813", "patch": "@@ -338,81 +338,92 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n #define RTX_FLAG(RTX, FLAG)\t((RTX)->FLAG)\n \n #if defined ENABLE_RTL_FLAG_CHECKING\n-#define RTL_FLAG_CHECK1(RTX, C1) __extension__\t\t\t\\\n+#define RTL_FLAG_CHECK1(NAME, RTX, C1) __extension__\t\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1)\t\t\t\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n+      \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-#define RTL_FLAG_CHECK2(RTX, C1, C2) __extension__\t\t\\\n+#define RTL_FLAG_CHECK2(NAME, RTX, C1, C2) __extension__\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2)\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n+      \t\t\t      __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-#define RTL_FLAG_CHECK3(RTX, C1, C2, C3) __extension__\t\t\\\n+#define RTL_FLAG_CHECK3(NAME, RTX, C1, C2, C3) __extension__\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2 \t\t\t\\\n        && GET_CODE(_rtx) != C3)\t\t\t\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n+      \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-#define RTL_FLAG_CHECK4(RTX, C1, C2, C3, C4) __extension__\t\\\n+#define RTL_FLAG_CHECK4(NAME, RTX, C1, C2, C3, C4) __extension__\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4)\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n+      \t\t\t      __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-#define RTL_FLAG_CHECK5(RTX, C1, C2, C3, C4, C5) __extension__\t\\\n+#define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5) __extension__\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5)\t\t\t\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n+       \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-#define RTL_FLAG_CHECK6(RTX, C1, C2, C3, C4, C5, C6) __extension__\t\\\n+#define RTL_FLAG_CHECK6(NAME, RTX, C1, C2, C3, C4, C5, C6)\t\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6)\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n+      \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-#define RTL_FLAG_CHECK7(RTX, C1, C2, C3, C4, C5, C6, C7) __extension__\t\\\n+#define RTL_FLAG_CHECK7(NAME, RTX, C1, C2, C3, C4, C5, C6, C7)\t\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n        && GET_CODE(_rtx) != C7)\t\t\t\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n+       \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-#define RTL_FLAG_CHECK8(RTX, C1, C2, C3, C4, C5, C6, C7, C8) __extension__ \\\n+#define RTL_FLAG_CHECK8(NAME, RTX, C1, C2, C3, C4, C5, C6, C7, C8)\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n        && GET_CODE(_rtx) != C7 && GET_CODE(_rtx) != C8)\t\t\t\\\n-     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n+       \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-extern void rtl_check_failed_flag PARAMS ((rtx, const char *, int,\n-      \t\t\t\t\t const char *))\n+extern void rtl_check_failed_flag PARAMS ((const char *, rtx, const char *,\n+      \t\t\t\t\t   int, const char *))\n     ATTRIBUTE_NORETURN\n     ;\n \n #else\t/* not ENABLE_RTL_FLAG_CHECKING */\n \n-#define RTL_FLAG_CHECK1(RTX, C1)\t\t\t(RTX)\n-#define RTL_FLAG_CHECK2(RTX, C1, C2)\t\t\t(RTX)\n-#define RTL_FLAG_CHECK3(RTX, C1, C2, C3)\t\t(RTX)\n-#define RTL_FLAG_CHECK4(RTX, C1, C2, C3, C4)\t\t(RTX)\n-#define RTL_FLAG_CHECK5(RTX, C1, C2, C3, C4, C5)  \t(RTX)\n-#define RTL_FLAG_CHECK6(RTX, C1, C2, C3, C4, C5, C6)\t(RTX)\n-#define RTL_FLAG_CHECK7(RTX, C1, C2, C3, C4, C5, C6, C7) (RTX)\n-#define RTL_FLAG_CHECK8(RTX, C1, C2, C3, C4, C5, C6, C7, C8) (RTX)\n+#define RTL_FLAG_CHECK1(NAME, RTX, C1)\t\t\t\t\t(RTX)\n+#define RTL_FLAG_CHECK2(NAME, RTX, C1, C2)\t\t\t\t(RTX)\n+#define RTL_FLAG_CHECK3(NAME, RTX, C1, C2, C3)\t\t\t\t(RTX)\n+#define RTL_FLAG_CHECK4(NAME, RTX, C1, C2, C3, C4)\t\t\t(RTX)\n+#define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5)  \t\t(RTX)\n+#define RTL_FLAG_CHECK6(NAME, RTX, C1, C2, C3, C4, C5, C6)\t\t(RTX)\n+#define RTL_FLAG_CHECK7(NAME, RTX, C1, C2, C3, C4, C5, C6, C7)\t\t(RTX)\n+#define RTL_FLAG_CHECK8(NAME, RTX, C1, C2, C3, C4, C5, C6, C7, C8)\t(RTX)\n #endif\n \n #define CLEAR_RTX_FLAGS(RTX)\t\\\n@@ -504,39 +515,47 @@ do {\t\t\t\t\\\n    They are always in the same basic block as this insn.  */\n #define LOG_LINKS(INSN)\tXEXP(INSN, 5)\n \n-#define RTX_INTEGRATED_P(RTX)\t\\\n-  (RTL_FLAG_CHECK8((RTX), INSN, CALL_INSN, JUMP_INSN, INSN_LIST,\t\\\n-\t\t   BARRIER, CODE_LABEL, CONST, NOTE)->integrated)\n-#define RTX_UNCHANGING_P(RTX)\t\t\\\n-  (RTL_FLAG_CHECK3((RTX), REG, MEM, CONCAT)->unchanging)\n-#define RTX_FRAME_RELATED_P(RTX)\t\\\n-  (RTL_FLAG_CHECK5((RTX), INSN, CALL_INSN, JUMP_INSN, BARRIER,\t\\\n-\t\t   SET)->frame_related)\n-\n-/* 1 if insn has been deleted.  */\n-#define INSN_DELETED_P(RTX)\t\\\n-  (RTL_FLAG_CHECK6((RTX), INSN, CALL_INSN, JUMP_INSN, CODE_LABEL,\t\\\n-\t\t   BARRIER, NOTE)->volatil)\n-\n-/* 1 if insn is a call to a const or pure function.  */\n-#define CONST_OR_PURE_CALL_P(RTX)\t\\\n-  (RTL_FLAG_CHECK3((RTX), CALL_INSN, NOTE, EXPR_LIST)->unchanging)\n-\n-/* 1 if insn (assumed to be a CALL_INSN) is a sibling call.  */\n-#define SIBLING_CALL_P(INSN) (RTL_FLAG_CHECK1((INSN), CALL_INSN)->jump)\n-\n-/* 1 in an INSN in the delay slot of a branch insn if an annulling branch\n-   should be used.  */\n-#define INSN_ANNULLED_BRANCH_P(RTX) (RTL_FLAG_CHECK1((RTX), INSN)->unchanging)\n-\n-/* 1 if insn is a dead code.  Valid only for dead-code elimination phase.  */\n-#define INSN_DEAD_CODE_P(RTX) (RTL_FLAG_CHECK1((RTX), INSN)->in_struct)\n-\n-/* 1 if insn is in a delay slot and is from the target of the branch.  If\n-   the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n+#define RTX_INTEGRATED_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK8(\"RTX_INTEGRATED_P\", (RTX), INSN, CALL_INSN,\t\t\\\n+\t\t   JUMP_INSN, INSN_LIST, BARRIER, CODE_LABEL, CONST,\t\\\n+\t\t   NOTE)->integrated)\n+#define RTX_UNCHANGING_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK3(\"RTX_UNCHANGING_P\", (RTX), REG, MEM, CONCAT)->unchanging)\n+#define RTX_FRAME_RELATED_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK5(\"RTX_FRAME_RELATED_P\", (RTX), INSN, CALL_INSN,\t\\\n+\t\t   JUMP_INSN, BARRIER, SET)->frame_related)\n+\n+/* 1 if RTX is an insn that has been deleted.  */\n+#define INSN_DELETED_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK6(\"INSN_DELETED_P\", (RTX), INSN, CALL_INSN, JUMP_INSN,\t\\\n+\t\t   CODE_LABEL, BARRIER, NOTE)->volatil)\n+\n+/* 1 if RTX is a call to a const or pure function.  */\n+#define CONST_OR_PURE_CALL_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK3(\"CONST_OR_PURE_CALL_P\", (RTX), CALL_INSN, NOTE,\t\\\n+\t\t   EXPR_LIST)->unchanging)\n+\n+/* 1 if RTX is a call_insn for a sibling call.  */\n+#define SIBLING_CALL_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"SIBLING_CALL_P\", (RTX), CALL_INSN)->jump)\n+\n+/* 1 if RTX is an insn in the delay slot of a branch insn for which an\n+   annulling branch should be used.  */\n+#define INSN_ANNULLED_BRANCH_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK2(\"INSN_ANNULLED_BRANCH_P\", (RTX), INSN,\t\t\\\n+\t\t   JUMP_INSN)->unchanging)\n+\n+/* 1 if RTX is an insn that is dead code.  Valid only for dead-code\n+   elimination phase.  */\n+#define INSN_DEAD_CODE_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"INSN_DEAD_CODE_P\", (RTX), INSN)->in_struct)\n+\n+/* 1 if RTX is an insn in a delay slot and is from the target of the branch.\n+   If the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n    executed if the branch is taken.  For annulled branches with this bit\n    clear, the insn should be executed only if the branch is not taken.  */\n-#define INSN_FROM_TARGET_P(RTX) (RTL_FLAG_CHECK1((RTX), INSN)->in_struct)\n+#define INSN_FROM_TARGET_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK2(\"INSN_FROM_TARGET_P\", (RTX), INSN, JUMP_INSN)->in_struct)\n \n #define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n \n@@ -902,16 +921,17 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n #define REGNO(RTX) XCUINT (RTX, 0, REG)\n #define ORIGINAL_REGNO(RTX) X0UINT (RTX, 1)\n \n-/* For a REG rtx, REG_FUNCTION_VALUE_P is nonzero if the reg\n-   is the current function's return value.  */\n+/* 1 if RTX is a reg that is the current function's return value.  */\n+#define REG_FUNCTION_VALUE_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"REG_FUNCTION_VALUE_P\", (RTX), REG)->integrated)\n \n-#define REG_FUNCTION_VALUE_P(RTX) (RTL_FLAG_CHECK1((RTX), REG)->integrated)\n+/* 1 if RTX is a reg that corresponds to a variable declared by the user.  */\n+#define REG_USERVAR_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"REG_USERVAR_P\", (RTX), REG)->volatil)\n \n-/* 1 in a REG rtx if it corresponds to a variable declared by the user.  */\n-#define REG_USERVAR_P(RTX) (RTL_FLAG_CHECK1((RTX), REG)->volatil)\n-\n-/* 1 in a REG rtx if the register is a pointer.  */\n-#define REG_POINTER(RTX) (RTL_FLAG_CHECK1((RTX), REG)->frame_related)\n+/* 1 if RTX is a reg that holds a pointer value.  */\n+#define REG_POINTER(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"REG_POINTER\", (RTX), REG)->frame_related)\n \n /* 1 if the given register REG corresponds to a hard register.  */\n #define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n@@ -956,27 +976,30 @@ extern unsigned int subreg_regno_offset \tPARAMS ((unsigned int,\n \t\t\t\t\t\t\t enum machine_mode));\n extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n-/* 1 if the REG contained in SUBREG_REG is already known to be\n-   sign- or zero-extended from the mode of the SUBREG to the mode of\n+/* 1 if RTX is a subreg containing a reg that is already known to be\n+   sign- or zero-extended from the mode of the subreg to the mode of\n    the reg.  SUBREG_PROMOTED_UNSIGNED_P gives the signedness of the\n    extension.\n \n    When used as a LHS, is means that this extension must be done\n    when assigning to SUBREG_REG.  */\n \n-#define SUBREG_PROMOTED_VAR_P(RTX) (RTL_FLAG_CHECK1((RTX), SUBREG)->in_struct)\n-#define SUBREG_PROMOTED_UNSIGNED_SET(RTX, VAL)\t\\\n-do {\t\t\t\t\t\t\\\n-  RTL_FLAG_CHECK1((RTX), SUBREG);\t\t\\\n-  if ((VAL) < 0)\t\t\t\t\\\n-    (RTX)->volatil = 1;\t\t\t\t\\\n-  else {\t\t\t\t\t\\\n-    (RTX)->volatil = 0;\t\t\t\t\\\n-    (RTX)->unchanging = (VAL);\t\t\t\\\n-  }\t\t\t\t\t\t\\\n+#define SUBREG_PROMOTED_VAR_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"SUBREG_PROMOTED\", (RTX), SUBREG)->in_struct)\n+\n+#define SUBREG_PROMOTED_UNSIGNED_SET(RTX, VAL)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  RTL_FLAG_CHECK1(\"SUBREG_PROMOTED_UNSIGNED_SET\", (RTX), SUBREG);\t\\\n+  if ((VAL) < 0)\t\t\t\t\t\t\t\\\n+    (RTX)->volatil = 1;\t\t\t\t\t\t\t\\\n+  else {\t\t\t\t\t\t\t\t\\\n+    (RTX)->volatil = 0;\t\t\t\t\t\t\t\\\n+    (RTX)->unchanging = (VAL);\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n #define SUBREG_PROMOTED_UNSIGNED_P(RTX)\t\\\n-  ((RTL_FLAG_CHECK1((RTX), SUBREG)->volatil) ? -1 : (RTX)->unchanging)\n+  ((RTL_FLAG_CHECK1(\"SUBREG_PROMOTED_UNSIGNED_P\", (RTX), SUBREG)->volatil) \\\n+     ? -1 : (RTX)->unchanging)\n \n /* Access various components of an ASM_OPERANDS rtx.  */\n \n@@ -996,23 +1019,27 @@ do {\t\t\t\t\t\t\\\n #define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR (RTX, 5, ASM_OPERANDS)\n #define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT (RTX, 6, ASM_OPERANDS)\n \n-/* For a MEM RTX, 1 if we should keep the alias set for this mem\n+/* 1 if RTX is a mem and we should keep the alias set for this mem\n    unchanged when we access a component.  Set to 1, or example, when we\n    are already in a non-addressable component of an aggregate.  */\n-#define MEM_KEEP_ALIAS_SET_P(RTX) (RTL_FLAG_CHECK1((RTX), MEM)->jump)\n+#define MEM_KEEP_ALIAS_SET_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"MEM_KEEP_ALIAS_SET_P\", (RTX), MEM)->jump)\n \n-/* For a MEM rtx, 1 if it's a volatile reference.\n-   Also in an ASM_OPERANDS rtx.  */\n-#define MEM_VOLATILE_P(RTX) (RTL_FLAG_CHECK2((RTX), MEM, ASM_OPERANDS)->volatil)\n+/* 1 if RTX is a mem or asm_operand for a volatile reference.  */\n+#define MEM_VOLATILE_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK3(\"MEM_VOLATILE_P\", (RTX), MEM, ASM_OPERANDS,\t\t\\\n+\t\t   ASM_INPUT)->volatil)\n \n-/* For a MEM rtx, 1 if it refers to an aggregate, either to the\n+/* 1 if RTX is a mem that refers to an aggregate, either to the\n    aggregate itself of to a field of the aggregate.  If zero, RTX may\n    or may not be such a reference.  */\n-#define MEM_IN_STRUCT_P(RTX) (RTL_FLAG_CHECK1((RTX), MEM)->in_struct)\n+#define MEM_IN_STRUCT_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"MEM_IN_STRUCT_P\", (RTX), MEM)->in_struct)\n \n-/* For a MEM rtx, 1 if it refers to a scalar.  If zero, RTX may or may\n+/* 1 if RTX is a mem that refers to a scalar.  If zero, RTX may or may\n    not refer to a scalar.  */\n-#define MEM_SCALAR_P(RTX) (RTL_FLAG_CHECK1((RTX), MEM)->frame_related)\n+#define MEM_SCALAR_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"MEM_SCALAR_P\", (RTX), MEM)->frame_related)\n \n /* If VAL is non-zero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n    RTX.  Otherwise, vice versa.  Use this macro only when you are\n@@ -1078,33 +1105,37 @@ do {\t\t\t\t\t\t\\\n    MEM_KEEP_ALIAS_SET_P (LHS) = MEM_KEEP_ALIAS_SET_P (RHS),\t\\\n    MEM_ATTRS (LHS) = MEM_ATTRS (RHS))\n \n-/* For a LABEL_REF, 1 means that this reference is to a label outside the\n-   loop containing the reference.  */\n-#define LABEL_OUTSIDE_LOOP_P(RTX) (RTL_FLAG_CHECK1((RTX), LABEL_REF)->in_struct)\n+/* 1 if RTX is a label_ref to a label outside the loop containing the\n+   reference.  */\n+#define LABEL_OUTSIDE_LOOP_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"LABEL_OUTSIDE_LOOP_P\", (RTX), LABEL_REF)->in_struct)\n \n-/* For a LABEL_REF, 1 means it is for a nonlocal label.  */\n-/* Likewise in an EXPR_LIST for a REG_LABEL note.  */\n-#define LABEL_REF_NONLOCAL_P(RTX)\t\\\n-  (RTL_FLAG_CHECK2((RTX), LABEL_REF, REG_LABEL)->volatil)\n+/* 1 if RTX is a label_ref for a nonlocal label.  */\n+/* Likewise in an expr_list for a reg_label note.  */\n+#define LABEL_REF_NONLOCAL_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK2(\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF,\t\t\\\n+\t\t   REG_LABEL)->volatil)\n \n-/* For a CODE_LABEL, 1 means always consider this label to be needed.  */\n-#define LABEL_PRESERVE_P(RTX) \\\n-  (RTL_FLAG_CHECK2((RTX), CODE_LABEL, NOTE)->in_struct)\n+/* 1 if RTX is a code_label that should always be considered to be needed.  */\n+#define LABEL_PRESERVE_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK2(\"LABEL_PRESERVE_P\", (RTX), CODE_LABEL, NOTE)->in_struct)\n \n-/* For a REG, 1 means the register is used only in an exit test of a loop.  */\n-#define REG_LOOP_TEST_P(RTX) (RTL_FLAG_CHECK1((RTX), REG)->in_struct)\n+/* 1 if RTX is a reg that is used only in an exit test of a loop.  */\n+#define REG_LOOP_TEST_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"REG_LOOP_TEST_P\", (RTX), REG)->in_struct)\n \n-/* During sched, for an insn, 1 means that the insn must be scheduled together\n+/* During sched, 1 if RTX is an insn that must be scheduled together\n    with the preceding insn.  */\n-#define SCHED_GROUP_P(RTX)\t\\\n-  (RTL_FLAG_CHECK6((RTX), INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, \\\n-\t\t          BARRIER, NOTE)->in_struct)\n+#define SCHED_GROUP_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK6(\"SCHED_GROUP_P\", (RTX), INSN, JUMP_INSN, CALL_INSN,\t\\\n+\t\t          CODE_LABEL, BARRIER, NOTE)->in_struct)\n \n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n #define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)\n #define SET_SRC(RTX) XCEXP(RTX, 1, SET)\n-#define SET_IS_RETURN_P(RTX) (RTL_FLAG_CHECK1((RTX), SET)->jump)\n+#define SET_IS_RETURN_P(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"SET_IS_RETURN_P\", (RTX), SET)->jump)\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n #define TRAP_CONDITION(RTX) XCEXP (RTX, 0, TRAP_IF)\n@@ -1116,22 +1147,27 @@ do {\t\t\t\t\t\t\\\n #define COND_EXEC_TEST(RTX) XCEXP (RTX, 0, COND_EXEC)\n #define COND_EXEC_CODE(RTX) XCEXP (RTX, 1, COND_EXEC)\n \n-/* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n-#define CONSTANT_POOL_ADDRESS_P(RTX)\t\\\n-  (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->unchanging)\n+/* 1 if RTX is a symbol_ref that addresses this function's constants pool.  */\n+#define CONSTANT_POOL_ADDRESS_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"CONSTANT_POOL_ADDRESS_P\", (RTX), SYMBOL_REF)->unchanging)\n \n-/* 1 in a SYMBOL_REF if it addresses this function's string constant pool.  */\n-#define STRING_POOL_ADDRESS_P(RTX)\t\\\n-  (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->frame_related)\n+/* 1 if RTX is a symbol_ref that addresses this function's string constant\n+   pool  */\n+#define STRING_POOL_ADDRESS_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"STRING_POOL_ADDRESS_P\", (RTX), SYMBOL_REF)->frame_related)\n \n-/* Flag in a SYMBOL_REF for machine-specific purposes.  */\n-#define SYMBOL_REF_FLAG(RTX) (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->volatil)\n+/* Used if RTX is a symbol_ref, for machine-specific purposes.  */\n+#define SYMBOL_REF_FLAG(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"SYMBOL_REF_FLAG\", (RTX), SYMBOL_REF)->volatil)\n \n-/* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */\n-#define SYMBOL_REF_USED(RTX) (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->used)\n+/* 1 if RTX is a symbol_ref that has been the library function in\n+   emit_library_call.  */\n+#define SYMBOL_REF_USED(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"SYMBOL_REF_USED\", (RTX), SYMBOL_REF)->used)\n \n-/* 1 means a SYMBOL_REF is weak.  */\n-#define SYMBOL_REF_WEAK(RTX) (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->integrated)\n+/* 1 if RTX is a symbol_ref for a weak symbol.  */\n+#define SYMBOL_REF_WEAK(RTX)\t\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"SYMBOL_REF_WEAK\", (RTX), SYMBOL_REF)->integrated)\n \n /* Define a macro to look for REG_INC notes,\n    but save time on machines where they never exist.  */"}]}