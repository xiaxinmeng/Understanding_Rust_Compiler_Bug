{"sha": "30f641cdccd11267f13ae4959739d654c7fa5835", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBmNjQxY2RjY2QxMTI2N2YxM2FlNDk1OTczOWQ2NTRjN2ZhNTgzNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-09-30T20:38:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-09-30T20:38:59Z"}, "message": "vec.h (vec_prefix, vec): Prefix member names with \"m_\".\n\ngcc/\n\t* vec.h (vec_prefix, vec): Prefix member names with \"m_\".\n\t* vec.c (vec_prefix::calculate_allocation): Update accordingly.\n\nFrom-SVN: r203047", "tree": {"sha": "f69c70b4a61137d9fe39405cb9b07d6c156e2da2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f69c70b4a61137d9fe39405cb9b07d6c156e2da2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30f641cdccd11267f13ae4959739d654c7fa5835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f641cdccd11267f13ae4959739d654c7fa5835", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30f641cdccd11267f13ae4959739d654c7fa5835", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f641cdccd11267f13ae4959739d654c7fa5835/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65d3284bfe05bd65415f9caf9f535e8bb745bdd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d3284bfe05bd65415f9caf9f535e8bb745bdd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d3284bfe05bd65415f9caf9f535e8bb745bdd1"}], "stats": {"total": 185, "additions": 95, "deletions": 90}, "files": [{"sha": "7c9a6c513ae94d78923a8762af8e891853f90bf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f641cdccd11267f13ae4959739d654c7fa5835/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f641cdccd11267f13ae4959739d654c7fa5835/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30f641cdccd11267f13ae4959739d654c7fa5835", "patch": "@@ -1,3 +1,8 @@\n+2013-09-30  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* vec.h (vec_prefix, vec): Prefix member names with \"m_\".\n+\t* vec.c (vec_prefix::calculate_allocation): Update accordingly.\n+\n 2013-09-30  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* basic-block.h (edge_list): Prefix member names with \"m_\"."}, {"sha": "1303d531c0f3e05ab2196b07fb20d2488d28b5c0", "filename": "gcc/vec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f641cdccd11267f13ae4959739d654c7fa5835/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f641cdccd11267f13ae4959739d654c7fa5835/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=30f641cdccd11267f13ae4959739d654c7fa5835", "patch": "@@ -183,8 +183,8 @@ vec_prefix::calculate_allocation (vec_prefix *pfx, unsigned reserve,\n \n   if (pfx)\n     {\n-      alloc = pfx->alloc_;\n-      num = pfx->num_;\n+      alloc = pfx->m_alloc;\n+      num = pfx->m_num;\n     }\n   else if (!reserve)\n     /* If there's no vector, and we've not requested anything, then we"}, {"sha": "60b77ec0ffc94ed7ca60ea3a82b693b512330791", "filename": "gcc/vec.h", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f641cdccd11267f13ae4959739d654c7fa5835/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f641cdccd11267f13ae4959739d654c7fa5835/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=30f641cdccd11267f13ae4959739d654c7fa5835", "patch": "@@ -235,8 +235,8 @@ struct vec_prefix\n   friend struct va_heap;\n   friend struct va_stack;\n \n-  unsigned alloc_;\n-  unsigned num_;\n+  unsigned m_alloc;\n+  unsigned m_num;\n };\n \n template<typename, typename, typename> struct vec;\n@@ -285,23 +285,23 @@ va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact\n \t\t  MEM_STAT_DECL)\n {\n   unsigned alloc\n-    = vec_prefix::calculate_allocation (v ? &v->vecpfx_ : 0, reserve, exact);\n+    = vec_prefix::calculate_allocation (v ? &v->m_vecpfx : 0, reserve, exact);\n   if (!alloc)\n     {\n       release (v);\n       return;\n     }\n \n   if (GATHER_STATISTICS && v)\n-    v->vecpfx_.release_overhead ();\n+    v->m_vecpfx.release_overhead ();\n \n   size_t size = vec<T, va_heap, vl_embed>::embedded_size (alloc);\n   unsigned nelem = v ? v->length () : 0;\n   v = static_cast <vec<T, va_heap, vl_embed> *> (xrealloc (v, size));\n   v->embedded_init (alloc, nelem);\n \n   if (GATHER_STATISTICS)\n-    v->vecpfx_.register_overhead (size FINAL_PASS_MEM_STAT);\n+    v->m_vecpfx.register_overhead (size FINAL_PASS_MEM_STAT);\n }\n \n \n@@ -315,7 +315,7 @@ va_heap::release (vec<T, va_heap, vl_embed> *&v)\n     return;\n \n   if (GATHER_STATISTICS)\n-    v->vecpfx_.release_overhead ();\n+    v->m_vecpfx.release_overhead ();\n   ::free (v);\n   v = NULL;\n }\n@@ -364,7 +364,7 @@ va_gc::reserve (vec<T, A, vl_embed> *&v, unsigned reserve, bool exact\n \t\tMEM_STAT_DECL)\n {\n   unsigned alloc\n-    = vec_prefix::calculate_allocation (v ? &v->vecpfx_ : 0, reserve, exact);\n+    = vec_prefix::calculate_allocation (v ? &v->m_vecpfx : 0, reserve, exact);\n   if (!alloc)\n     {\n       ::ggc_free (v);\n@@ -433,9 +433,9 @@ void\n va_stack::alloc (vec<T, va_stack, vl_ptr> &v, unsigned nelems,\n \t\t vec<T, va_stack, vl_embed> *space)\n {\n-  v.vec_ = space;\n-  register_stack_vec (static_cast<void *> (v.vec_));\n-  v.vec_->embedded_init (nelems, 0);\n+  v.m_vec = space;\n+  register_stack_vec (static_cast<void *> (v.m_vec));\n+  v.m_vec->embedded_init (nelems, 0);\n }\n \n \n@@ -462,16 +462,16 @@ va_stack::reserve (vec<T, va_stack, vl_embed> *&v, unsigned nelems, bool exact\n     }\n \n   /* Move VEC_ to the heap.  */\n-  nelems += v->vecpfx_.num_;\n+  nelems += v->m_vecpfx.m_num;\n   vec<T, va_stack, vl_embed> *oldvec = v;\n   v = NULL;\n   va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&>(v), nelems,\n \t\t    exact PASS_MEM_STAT);\n   if (v && oldvec)\n     {\n-      v->vecpfx_.num_ = oldvec->length ();\n-      memcpy (v->vecdata_,\n-\t      oldvec->vecdata_,\n+      v->m_vecpfx.m_num = oldvec->length ();\n+      memcpy (v->m_vecdata,\n+\t      oldvec->m_vecdata,\n \t      oldvec->length () * sizeof (T));\n     }\n }\n@@ -562,11 +562,11 @@ template<typename T, typename A>\n struct GTY((user)) vec<T, A, vl_embed>\n {\n public:\n-  unsigned allocated (void) const { return vecpfx_.alloc_; }\n-  unsigned length (void) const { return vecpfx_.num_; }\n-  bool is_empty (void) const { return vecpfx_.num_ == 0; }\n-  T *address (void) { return vecdata_; }\n-  const T *address (void) const { return vecdata_; }\n+  unsigned allocated (void) const { return m_vecpfx.m_alloc; }\n+  unsigned length (void) const { return m_vecpfx.m_num; }\n+  bool is_empty (void) const { return m_vecpfx.m_num == 0; }\n+  T *address (void) { return m_vecdata; }\n+  const T *address (void) const { return m_vecdata; }\n   const T &operator[] (unsigned) const;\n   T &operator[] (unsigned);\n   T &last (void);\n@@ -601,8 +601,8 @@ struct GTY((user)) vec<T, A, vl_embed>\n \n   /* FIXME - These fields should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n-  vec_prefix vecpfx_;\n-  T vecdata_[1];\n+  vec_prefix m_vecpfx;\n+  T m_vecdata[1];\n };\n \n \n@@ -816,16 +816,16 @@ template<typename T, typename A>\n inline const T &\n vec<T, A, vl_embed>::operator[] (unsigned ix) const\n {\n-  gcc_checking_assert (ix < vecpfx_.num_);\n-  return vecdata_[ix];\n+  gcc_checking_assert (ix < m_vecpfx.m_num);\n+  return m_vecdata[ix];\n }\n \n template<typename T, typename A>\n inline T &\n vec<T, A, vl_embed>::operator[] (unsigned ix)\n {\n-  gcc_checking_assert (ix < vecpfx_.num_);\n-  return vecdata_[ix];\n+  gcc_checking_assert (ix < m_vecpfx.m_num);\n+  return m_vecdata[ix];\n }\n \n \n@@ -835,8 +835,8 @@ template<typename T, typename A>\n inline T &\n vec<T, A, vl_embed>::last (void)\n {\n-  gcc_checking_assert (vecpfx_.num_ > 0);\n-  return (*this)[vecpfx_.num_ - 1];\n+  gcc_checking_assert (m_vecpfx.m_num > 0);\n+  return (*this)[m_vecpfx.m_num - 1];\n }\n \n \n@@ -850,7 +850,7 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::space (unsigned nelems) const\n {\n-  return vecpfx_.alloc_ - vecpfx_.num_ >= nelems;\n+  return m_vecpfx.m_alloc - m_vecpfx.m_num >= nelems;\n }\n \n \n@@ -865,9 +865,9 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::iterate (unsigned ix, T *ptr) const\n {\n-  if (ix < vecpfx_.num_)\n+  if (ix < m_vecpfx.m_num)\n     {\n-      *ptr = vecdata_[ix];\n+      *ptr = m_vecdata[ix];\n       return true;\n     }\n   else\n@@ -891,9 +891,9 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::iterate (unsigned ix, T **ptr) const\n {\n-  if (ix < vecpfx_.num_)\n+  if (ix < m_vecpfx.m_num)\n     {\n-      *ptr = CONST_CAST (T *, &vecdata_[ix]);\n+      *ptr = CONST_CAST (T *, &m_vecdata[ix]);\n       return true;\n     }\n   else\n@@ -916,7 +916,7 @@ vec<T, A, vl_embed>::copy (ALONE_MEM_STAT_DECL) const\n     {\n       vec_alloc (new_vec, len PASS_MEM_STAT);\n       new_vec->embedded_init (len, len);\n-      memcpy (new_vec->address (), vecdata_, sizeof (T) * len);\n+      memcpy (new_vec->address (), m_vecdata, sizeof (T) * len);\n     }\n   return new_vec;\n }\n@@ -934,7 +934,7 @@ vec<T, A, vl_embed>::splice (vec<T, A, vl_embed> &src)\n     {\n       gcc_checking_assert (space (len));\n       memcpy (address () + length (), src.address (), len * sizeof (T));\n-      vecpfx_.num_ += len;\n+      m_vecpfx.m_num += len;\n     }\n }\n \n@@ -956,7 +956,7 @@ inline T *\n vec<T, A, vl_embed>::quick_push (const T &obj)\n {\n   gcc_checking_assert (space (1));\n-  T *slot = &vecdata_[vecpfx_.num_++];\n+  T *slot = &m_vecdata[m_vecpfx.m_num++];\n   *slot = obj;\n   return slot;\n }\n@@ -969,7 +969,7 @@ inline T &\n vec<T, A, vl_embed>::pop (void)\n {\n   gcc_checking_assert (length () > 0);\n-  return vecdata_[--vecpfx_.num_];\n+  return m_vecdata[--m_vecpfx.m_num];\n }\n \n \n@@ -981,7 +981,7 @@ inline void\n vec<T, A, vl_embed>::truncate (unsigned size)\n {\n   gcc_checking_assert (length () >= size);\n-  vecpfx_.num_ = size;\n+  m_vecpfx.m_num = size;\n }\n \n \n@@ -994,8 +994,8 @@ vec<T, A, vl_embed>::quick_insert (unsigned ix, const T &obj)\n {\n   gcc_checking_assert (length () < allocated ());\n   gcc_checking_assert (ix <= length ());\n-  T *slot = &vecdata_[ix];\n-  memmove (slot + 1, slot, (vecpfx_.num_++ - ix) * sizeof (T));\n+  T *slot = &m_vecdata[ix];\n+  memmove (slot + 1, slot, (m_vecpfx.m_num++ - ix) * sizeof (T));\n   *slot = obj;\n }\n \n@@ -1009,8 +1009,8 @@ inline void\n vec<T, A, vl_embed>::ordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length ());\n-  T *slot = &vecdata_[ix];\n-  memmove (slot, slot + 1, (--vecpfx_.num_ - ix) * sizeof (T));\n+  T *slot = &m_vecdata[ix];\n+  memmove (slot, slot + 1, (--m_vecpfx.m_num - ix) * sizeof (T));\n }\n \n \n@@ -1022,7 +1022,7 @@ inline void\n vec<T, A, vl_embed>::unordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length ());\n-  vecdata_[ix] = vecdata_[--vecpfx_.num_];\n+  m_vecdata[ix] = m_vecdata[--m_vecpfx.m_num];\n }\n \n \n@@ -1034,9 +1034,9 @@ inline void\n vec<T, A, vl_embed>::block_remove (unsigned ix, unsigned len)\n {\n   gcc_checking_assert (ix + len <= length ());\n-  T *slot = &vecdata_[ix];\n-  vecpfx_.num_ -= len;\n-  memmove (slot, slot + len, (vecpfx_.num_ - ix) * sizeof (T));\n+  T *slot = &m_vecdata[ix];\n+  m_vecpfx.m_num -= len;\n+  memmove (slot, slot + len, (m_vecpfx.m_num - ix) * sizeof (T));\n }\n \n \n@@ -1100,7 +1100,7 @@ inline size_t\n vec<T, A, vl_embed>::embedded_size (unsigned alloc)\n {\n   typedef vec<T, A, vl_embed> vec_embedded;\n-  return offsetof (vec_embedded, vecdata_) + alloc * sizeof (T);\n+  return offsetof (vec_embedded, m_vecdata) + alloc * sizeof (T);\n }\n \n \n@@ -1111,8 +1111,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::embedded_init (unsigned alloc, unsigned num)\n {\n-  vecpfx_.alloc_ = alloc;\n-  vecpfx_.num_ = num;\n+  m_vecpfx.m_alloc = alloc;\n+  m_vecpfx.m_num = num;\n }\n \n \n@@ -1123,8 +1123,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::quick_grow (unsigned len)\n {\n-  gcc_checking_assert (length () <= len && len <= vecpfx_.alloc_);\n-  vecpfx_.num_ = len;\n+  gcc_checking_assert (length () <= len && len <= m_vecpfx.m_alloc);\n+  m_vecpfx.m_num = len;\n }\n \n \n@@ -1229,22 +1229,22 @@ struct vec<T, A, vl_ptr>\n \n   /* Vector operations.  */\n   bool exists (void) const\n-  { return vec_ != NULL; }\n+  { return m_vec != NULL; }\n \n   bool is_empty (void) const\n-  { return vec_ ? vec_->is_empty () : true; }\n+  { return m_vec ? m_vec->is_empty () : true; }\n \n   unsigned length (void) const\n-  { return vec_ ? vec_->length () : 0; }\n+  { return m_vec ? m_vec->length () : 0; }\n \n   T *address (void)\n-  { return vec_ ? vec_->vecdata_ : NULL; }\n+  { return m_vec ? m_vec->m_vecdata : NULL; }\n \n   const T *address (void) const\n-  { return vec_ ? vec_->vecdata_ : NULL; }\n+  { return m_vec ? m_vec->m_vecdata : NULL; }\n \n   const T &operator[] (unsigned ix) const\n-  { return (*vec_)[ix]; }\n+  { return (*m_vec)[ix]; }\n \n   bool operator!=(const vec &other) const\n   { return !(*this == other); }\n@@ -1253,13 +1253,13 @@ struct vec<T, A, vl_ptr>\n   { return address () == other.address (); }\n \n   T &operator[] (unsigned ix)\n-  { return (*vec_)[ix]; }\n+  { return (*m_vec)[ix]; }\n \n   T &last (void)\n-  { return vec_->last (); }\n+  { return m_vec->last (); }\n \n   bool space (int nelems) const\n-  { return vec_ ? vec_->space (nelems) : nelems == 0; }\n+  { return m_vec ? m_vec->space (nelems) : nelems == 0; }\n \n   bool iterate (unsigned ix, T *p) const;\n   bool iterate (unsigned ix, T **p) const;\n@@ -1290,7 +1290,7 @@ struct vec<T, A, vl_ptr>\n \n   /* FIXME - This field should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n-  vec<T, A, vl_embed> *vec_;\n+  vec<T, A, vl_embed> *m_vec;\n };\n \n \n@@ -1393,8 +1393,8 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_ptr>::iterate (unsigned ix, T *ptr) const\n {\n-  if (vec_)\n-    return vec_->iterate (ix, ptr);\n+  if (m_vec)\n+    return m_vec->iterate (ix, ptr);\n   else\n     {\n       *ptr = 0;\n@@ -1416,8 +1416,8 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_ptr>::iterate (unsigned ix, T **ptr) const\n {\n-  if (vec_)\n-    return vec_->iterate (ix, ptr);\n+  if (m_vec)\n+    return m_vec->iterate (ix, ptr);\n   else\n     {\n       *ptr = 0;\n@@ -1457,7 +1457,7 @@ vec<T, A, vl_ptr>::copy (ALONE_MEM_STAT_DECL) const\n {\n   vec<T, A, vl_ptr> new_vec = vNULL;\n   if (length ())\n-    new_vec.vec_ = vec_->copy ();\n+    new_vec.m_vec = m_vec->copy ();\n   return new_vec;\n }\n \n@@ -1477,7 +1477,7 @@ vec<T, A, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n {\n   bool extend = nelems ? !space (nelems) : false;\n   if (extend)\n-    A::reserve (vec_, nelems, exact PASS_MEM_STAT);\n+    A::reserve (m_vec, nelems, exact PASS_MEM_STAT);\n   return extend;\n }\n \n@@ -1504,7 +1504,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::create (unsigned nelems MEM_STAT_DECL)\n {\n-  vec_ = NULL;\n+  m_vec = NULL;\n   if (nelems > 0)\n     reserve_exact (nelems PASS_MEM_STAT);\n }\n@@ -1516,8 +1516,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::release (void)\n {\n-  if (vec_)\n-    A::release (vec_);\n+  if (m_vec)\n+    A::release (m_vec);\n }\n \n \n@@ -1530,8 +1530,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::splice (vec<T, A, vl_ptr> &src)\n {\n-  if (src.vec_)\n-    vec_->splice (*(src.vec_));\n+  if (src.m_vec)\n+    m_vec->splice (*(src.m_vec));\n }\n \n \n@@ -1560,7 +1560,7 @@ template<typename T, typename A>\n inline T *\n vec<T, A, vl_ptr>::quick_push (const T &obj)\n {\n-  return vec_->quick_push (obj);\n+  return m_vec->quick_push (obj);\n }\n \n \n@@ -1583,7 +1583,7 @@ template<typename T, typename A>\n inline T &\n vec<T, A, vl_ptr>::pop (void)\n {\n-  return vec_->pop ();\n+  return m_vec->pop ();\n }\n \n \n@@ -1594,8 +1594,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::truncate (unsigned size)\n {\n-  if (vec_)\n-    vec_->truncate (size);\n+  if (m_vec)\n+    m_vec->truncate (size);\n   else\n     gcc_checking_assert (size == 0);\n }\n@@ -1612,7 +1612,7 @@ vec<T, A, vl_ptr>::safe_grow (unsigned len MEM_STAT_DECL)\n   unsigned oldlen = length ();\n   gcc_checking_assert (oldlen <= len);\n   reserve_exact (len - oldlen PASS_MEM_STAT);\n-  vec_->quick_grow (len);\n+  m_vec->quick_grow (len);\n }\n \n \n@@ -1637,8 +1637,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_grow (unsigned len)\n {\n-  gcc_checking_assert (vec_);\n-  vec_->quick_grow (len);\n+  gcc_checking_assert (m_vec);\n+  m_vec->quick_grow (len);\n }\n \n \n@@ -1650,8 +1650,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_grow_cleared (unsigned len)\n {\n-  gcc_checking_assert (vec_);\n-  vec_->quick_grow_cleared (len);\n+  gcc_checking_assert (m_vec);\n+  m_vec->quick_grow_cleared (len);\n }\n \n \n@@ -1662,7 +1662,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_insert (unsigned ix, const T &obj)\n {\n-  vec_->quick_insert (ix, obj);\n+  m_vec->quick_insert (ix, obj);\n }\n \n \n@@ -1686,7 +1686,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::ordered_remove (unsigned ix)\n {\n-  vec_->ordered_remove (ix);\n+  m_vec->ordered_remove (ix);\n }\n \n \n@@ -1697,7 +1697,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::unordered_remove (unsigned ix)\n {\n-  vec_->unordered_remove (ix);\n+  m_vec->unordered_remove (ix);\n }\n \n \n@@ -1708,7 +1708,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::block_remove (unsigned ix, unsigned len)\n {\n-  vec_->block_remove (ix, len);\n+  m_vec->block_remove (ix, len);\n }\n \n \n@@ -1719,8 +1719,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n {\n-  if (vec_)\n-    vec_->qsort (cmp);\n+  if (m_vec)\n+    m_vec->qsort (cmp);\n }\n \n \n@@ -1734,11 +1734,11 @@ inline unsigned\n vec<T, A, vl_ptr>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))\n     const\n {\n-  return vec_ ? vec_->lower_bound (obj, lessthan) : 0;\n+  return m_vec ? m_vec->lower_bound (obj, lessthan) : 0;\n }\n \n #if (GCC_VERSION >= 3000)\n-# pragma GCC poison vec_ vecpfx_ vecdata_\n+# pragma GCC poison m_vec m_vecpfx m_vecdata\n #endif\n \n #endif // GCC_VEC_H"}]}